diff --git a/Gopkg.lock b/Gopkg.lock
index d727a68a..cf89b732 100644
--- a/Gopkg.lock
+++ b/Gopkg.lock
@@ -78,22 +78,22 @@
 
 [[projects]]
   branch = "master"
-  digest = "1:1a3295dc941bb4b1eb160dc19766994d3b82c37deba34680000e93e44feb54e0"
+  digest = "1:48f9a43c330434d61098a65bdf4d8cbfbdc0eecf30ab35b1b88405868df6a42b"
   name = "github.com/go-openapi/analysis"
   packages = [
     ".",
     "internal",
   ]
   pruneopts = ""
-  revision = "c701774f4e604d952e4e8c56dee260be696e33c3"
+  revision = "e2f3fdbb7ed0e56e070ccbfb6fc75b288a33c014"
 
 [[projects]]
   branch = "master"
-  digest = "1:24fc3668d065e515396e7c89decee9aea6babfdfa104fcaad12c2ecabd428171"
+  digest = "1:90d75a4ad18e82be220162df5f551537c917ef2c0bfa4f04b3bde61130b6286a"
   name = "github.com/go-openapi/errors"
   packages = ["."]
   pruneopts = ""
-  revision = "d9664f9fab8994271e573ed69cf2adfc09b7a800"
+  revision = "7a7ff1b7b8020f22574411a32f28b4d168d69237"
 
 [[projects]]
   branch = "master"
@@ -109,7 +109,7 @@
   packages = ["."]
   pruneopts = ""
   revision = "ef5f0afec364d3b9396b7b77b43dbe26bf1f8004"
-  version = "v0.17.1"
+  version = "v0.17.2"
 
 [[projects]]
   digest = "1:1824e5330b35b2a2418d06aa55629cc59ad454b72e338aa125ba8ff98f16298b"
@@ -117,7 +117,7 @@
   packages = ["."]
   pruneopts = ""
   revision = "8483a886a90412cd6858df4ea3483dce9c8e35a3"
-  version = "v0.17.1"
+  version = "v0.17.2"
 
 [[projects]]
   branch = "master"
@@ -132,7 +132,7 @@
 
 [[projects]]
   branch = "master"
-  digest = "1:f797743ba6bd5da181d715e03030bdb9f3d46614d9cdaee2776fe27de8099a05"
+  digest = "1:e0cf671b9d1327867b8d6318b983b3e0865bab97679aa450ff09ebc2f89517fb"
   name = "github.com/go-openapi/runtime"
   packages = [
     ".",
@@ -146,7 +146,7 @@
     "security",
   ]
   pruneopts = ""
-  revision = "231d7876b7019dbcbfc97a7ba764379497b67c1d"
+  revision = "aadb2cc7b8862fdab251bf60a8b9d2a951c9746c"
 
 [[projects]]
   branch = "master"
@@ -158,19 +158,19 @@
 
 [[projects]]
   branch = "master"
-  digest = "1:147558ff4e7500d799d17b61c5b38888282bdd155dd5c5727a9ff32073df62b0"
+  digest = "1:20cb4fc645c5df5ab65253441e9d017c4ce9e372ed81862178da8f9c9e826d61"
   name = "github.com/go-openapi/strfmt"
   packages = ["."]
   pruneopts = ""
-  revision = "edab9990ffc9b4a428f3306ecf4d18a069ca3317"
+  revision = "b7bbaf9c758e8bee9311b1bb94262cd30f79dc16"
 
 [[projects]]
   branch = "master"
-  digest = "1:52e268f92bc7adac47ca908335bfd9f90e010c492c59797031cf99ec1caff4e2"
+  digest = "1:417789264f7cc44cbb3431ac997473e085018b01bdd98df57e6039981428aca4"
   name = "github.com/go-openapi/swag"
   packages = ["."]
   pruneopts = ""
-  revision = "a0a2ec671c17745100b0116b950a1cd55fd22552"
+  revision = "1d29f06aebd59ccdf11ae04aa0334ded96e2d909"
 
 [[projects]]
   branch = "master"
@@ -314,12 +314,12 @@
   version = "v1.1.2"
 
 [[projects]]
-  digest = "1:d0b38ba6da419a6d4380700218eeec8623841d44a856bb57369c172fbf692ab4"
+  digest = "1:ae3493c780092be9d576a1f746ab967293ec165e8473425631f06658b6212afc"
   name = "github.com/spf13/cast"
   packages = ["."]
   pruneopts = ""
-  revision = "8965335b8c7107321228e3e3702cab9832751bac"
-  version = "v1.2.0"
+  revision = "8c9545af88b134710ab1cd196795e7f2388358d7"
+  version = "v1.3.0"
 
 [[projects]]
   digest = "1:9ceffa4ab5f7195ecf18b3a7fff90c837a9ed5e22e66d18069e4bccfe1f52aa0"
@@ -339,11 +339,11 @@
 
 [[projects]]
   branch = "master"
-  digest = "1:c08585b9af4c0f3c516af8e06254a66b462aee46937d41b7d8434795051e33b6"
+  digest = "1:c25a789c738f7cc8ec7f34026badd4e117853f329334a5aa45cf5d0727d7d442"
   name = "github.com/spf13/viper"
   packages = ["."]
   pruneopts = ""
-  revision = "62edee319679b6ceaec16de03b966102d2dea709"
+  revision = "ae103d7e593e371c69e832d5eb3347e2b80cbbc9"
 
 [[projects]]
   digest = "1:c587772fb8ad29ad4db67575dad25ba17a51f072ff18a22b4f0257a4d9c24f75"
@@ -363,7 +363,7 @@
 
 [[projects]]
   branch = "master"
-  digest = "1:b4657db81437337ae70edb2175bd358d00cc14ec39330341a70d00f68cd6347a"
+  digest = "1:f7be435e0ca22e2cd62b2d2542081a231685837170a87a3662abb7cdf9f3f1cd"
   name = "golang.org/x/crypto"
   packages = [
     "ed25519",
@@ -371,11 +371,11 @@
     "pbkdf2",
   ]
   pruneopts = ""
-  revision = "74cb1d3d52f4c01cbfb44c1b50d204462f3124c7"
+  revision = "3d3f9f413869b949e48070b5bc593aa22cc2b8f2"
 
 [[projects]]
   branch = "master"
-  digest = "1:b001b57f383ecbebb54c3916ca6b8be129a6486d3dbf2dfc722cbb0a0b2a8679"
+  digest = "1:4ac199b027ed34460ec4e0a92c882156f561e78cd046fef095e50f867462435a"
   name = "golang.org/x/net"
   packages = [
     "context",
@@ -384,26 +384,26 @@
     "netutil",
   ]
   pruneopts = ""
-  revision = "9b4f9f5ad5197c79fd623a3638e70d8b26cef344"
+  revision = "adae6a3d119ae4890b46832a2e88a95adc62b8e7"
 
 [[projects]]
   branch = "master"
-  digest = "1:77478892c6d9d841c7997858d6287884c65b760000f29a25d7b1a6b6ada5f308"
+  digest = "1:51d339a1d79f5c617fba14414aefb7dfd184b8ba0ddbb9f95251430b67c8aab8"
   name = "golang.org/x/oauth2"
   packages = [
     ".",
     "internal",
   ]
   pruneopts = ""
-  revision = "9dcd33a902f40452422c2367fefcb95b54f9f8f8"
+  revision = "f42d05182288abf10faef86d16c0d07b8d40ea2d"
 
 [[projects]]
   branch = "master"
-  digest = "1:3bb377065822540748d69a5a9cb0de617cf997a9e4f757eceaac3075d1f07d50"
+  digest = "1:bae7ec6144727bacb0f06565215267a39134f63a4955114d03961ca9061a1e97"
   name = "golang.org/x/sys"
   packages = ["unix"]
   pruneopts = ""
-  revision = "5cd93ef61a7c8f0f858690154eb6de2e69415fa1"
+  revision = "93218def8b18e66adbdab3eca8ec334700329f1f"
 
 [[projects]]
   digest = "1:5acd3512b047305d49e8763eef7ba423901e85d5dd2fd1e71778a0ea8de10bd4"
@@ -431,7 +431,7 @@
 
 [[projects]]
   branch = "master"
-  digest = "1:d9f47d3af9482eea8b6f559fc709992cd8890ec615e855a61c2efdf5f1ca85ed"
+  digest = "1:882f3bb4a5ee4ce6f76c9c5833dd5ccb3282269949cd9f1c0d9212b45cb298c9"
   name = "golang.org/x/tools"
   packages = [
     "go/ast/astutil",
@@ -443,10 +443,10 @@
     "internal/gopathwalk",
   ]
   pruneopts = ""
-  revision = "a2dc47679d30b6c496245bafc6a166b46c5fe318"
+  revision = "2ddaf7f79a0937ffa9072ede7b696fd084abfe86"
 
 [[projects]]
-  digest = "1:8c432632a230496c35a15cfdf441436f04c90e724ad99c8463ef0c82bbe93edb"
+  digest = "1:77d3cff3a451d50be4b52db9c7766c0d8570ba47593f0c9dc72173adb208e788"
   name = "google.golang.org/appengine"
   packages = [
     "internal",
@@ -458,8 +458,8 @@
     "urlfetch",
   ]
   pruneopts = ""
-  revision = "ae0ab99deb4dc413a2b4bd6c8bdd0eb67f1e4d06"
-  version = "v1.2.0"
+  revision = "4a4468ece617fc8205e99368fa2200e9d1fad421"
+  version = "v1.3.0"
 
 [[projects]]
   digest = "1:ddc5fa8f9159bea7d1ce58143e6d8fd8054018f7bc3709940aa7f7bc92855ed9"
@@ -475,11 +475,11 @@
 
 [[projects]]
   branch = "v2"
-  digest = "1:f0620375dd1f6251d9973b5f2596228cc8042e887cd7f827e4220bc1ce8c30e2"
+  digest = "1:cedccf16b71e86db87a24f8d4c70b0a855872eb967cb906a66b95de56aefbd0d"
   name = "gopkg.in/yaml.v2"
   packages = ["."]
   pruneopts = ""
-  revision = "5420a8b6744d3b0345ab293f6fcba19c978f1183"
+  revision = "51d6538a90f86fe93ac480b35f37b2be17fef232"
 
 [solve-meta]
   analyzer-name = "dep"
diff --git a/fixtures/bugs/1767/Identifier.yaml b/fixtures/bugs/1767/Identifier.yaml
new file mode 100644
index 00000000..d27898b2
--- /dev/null
+++ b/fixtures/bugs/1767/Identifier.yaml
@@ -0,0 +1,24 @@
+type: object
+title: "Identifier"
+description: "v3.1.0-12545"
+properties:
+  use:
+    type: string
+    example: "usual"
+    enum:
+    - "usual"
+    - "official"
+    - "temp"
+    - "secondary"
+    - "old"
+  system:
+    type: string
+  value:
+    description: "Some unique value"
+    type: string
+  assigner:
+    description: "Organization"
+    allOf:
+      - $ref: 'Reference.yaml'
+required:
+  - use
diff --git a/fixtures/bugs/1767/Patient.yaml b/fixtures/bugs/1767/Patient.yaml
new file mode 100644
index 00000000..36f565be
--- /dev/null
+++ b/fixtures/bugs/1767/Patient.yaml
@@ -0,0 +1,19 @@
+type: object
+title: "Info about patient"
+description: ""
+properties:
+      id:
+        type: string
+      identifier:
+        type: array
+        description: "Identifier"
+        items:
+            allOf:
+            - $ref: 'Identifier.yaml'
+      active:
+        type: boolean
+      name:
+        description: "Name"
+        type: string
+required:
+- name
diff --git a/fixtures/bugs/1767/Reference.yaml b/fixtures/bugs/1767/Reference.yaml
new file mode 100644
index 00000000..3130b3d8
--- /dev/null
+++ b/fixtures/bugs/1767/Reference.yaml
@@ -0,0 +1,15 @@
+type: object
+title: "reference"
+description: "v3.1.0-12545"
+properties:
+      reference:
+        description: "Literal reference, Relative, internal or absolute URL"
+        type: string
+        example: "literal reference"
+      identifier:
+        description: "Logical reference, when literal reference is not known"
+        allOf:
+        - $ref: 'Identifier.yaml'
+      display:
+        type: string
+        description: "Text alternative for the resource"
diff --git a/fixtures/bugs/1767/fixture-1767.yaml b/fixtures/bugs/1767/fixture-1767.yaml
new file mode 100644
index 00000000..d58cd053
--- /dev/null
+++ b/fixtures/bugs/1767/fixture-1767.yaml
@@ -0,0 +1,51 @@
+---
+swagger: '2.0'
+info:
+  version: "1.0.0"
+  title: FHIR API
+  description: |
+    #### FHIR API
+schemes:
+- http
+host: "fhir.test.lan"
+basePath: /
+
+parameters:
+  patientID:
+    name: patientID
+    in: path
+    description: "patient ID"
+    type: string
+    required: true
+
+paths:
+  /Patient/{patientID}:
+    parameters:
+    - $ref: "#/parameters/patientID"
+    get:
+      tags:
+      - fhir
+      produces:
+      - application/fhir+json
+      consumes:
+      - application/fhir+json
+      responses:
+        200:
+          $ref: "#/responses/Patient"
+    put:
+      tags:
+      - fhir
+      produces:
+      - application/fhir+json
+      consumes:
+      - application/fhir+json
+      responses:
+        200:
+          $ref: "#/responses/Patient"
+
+responses:
+  Patient:
+    description: "Patient"
+    schema:
+      allOf:
+      - $ref: 'Patient.yaml'
diff --git a/fixtures/bugs/1767/flatten-full.yaml b/fixtures/bugs/1767/flatten-full.yaml
new file mode 100644
index 00000000..28cbc234
--- /dev/null
+++ b/fixtures/bugs/1767/flatten-full.yaml
@@ -0,0 +1,184 @@
+schemes:
+- http
+swagger: "2.0"
+info:
+  description: |
+    #### FHIR API
+  title: FHIR API
+  version: 1.0.0
+host: fhir.test.lan
+basePath: /
+paths:
+  /Patient/{patientID}:
+    get:
+      consumes:
+      - application/fhir+json
+      produces:
+      - application/fhir+json
+      tags:
+      - fhir
+      responses:
+        "200":
+          description: Patient
+          schema:
+            $ref: '#/definitions/getPatientPatientIdOKBody'
+    put:
+      consumes:
+      - application/fhir+json
+      produces:
+      - application/fhir+json
+      tags:
+      - fhir
+      responses:
+        "200":
+          description: Patient
+          schema:
+            $ref: '#/definitions/putPatientPatientIdOKBody'
+    parameters:
+    - type: string
+      description: patient ID
+      name: patientID
+      in: path
+      required: true
+definitions:
+  getPatientPatientIdOKBody:
+    allOf:
+    - $ref: '#/definitions/patient'
+    x-go-gen-location: operations
+  identifier:
+    description: v3.1.0-12545
+    type: object
+    title: Identifier
+    required:
+    - use
+    properties:
+      assigner:
+        $ref: '#/definitions/identifierAssigner'
+      system:
+        type: string
+      use:
+        type: string
+        enum:
+        - usual
+        - official
+        - temp
+        - secondary
+        - old
+        example: usual
+      value:
+        description: Some unique value
+        type: string
+  identifierAssigner:
+    description: Organization
+    allOf:
+    - $ref: '#/definitions/identifierAssignerAllOf0'
+    x-go-gen-location: models
+  identifierAssignerAllOf0:
+    description: v3.1.0-12545
+    type: object
+    title: reference
+    properties:
+      display:
+        description: Text alternative for the resource
+        type: string
+      identifier:
+        $ref: '#/definitions/identifierAssignerAllOf0Identifier'
+      reference:
+        description: Literal reference, Relative, internal or absolute URL
+        type: string
+        example: literal reference
+    x-go-gen-location: models
+  identifierAssignerAllOf0Identifier:
+    description: Logical reference, when literal reference is not known
+    allOf:
+    - $ref: '#/definitions/identifier'
+    x-go-gen-location: models
+  patient:
+    type: object
+    title: Info about patient
+    required:
+    - name
+    properties:
+      active:
+        type: boolean
+      id:
+        type: string
+      identifier:
+        description: Identifier
+        type: array
+        items:
+          $ref: '#/definitions/patientIdentifierItems'
+      name:
+        description: Name
+        type: string
+  patientIdentifierItems:
+    allOf:
+    - $ref: '#/definitions/patientIdentifierItemsAllOf0'
+    x-go-gen-location: models
+  patientIdentifierItemsAllOf0:
+    description: v3.1.0-12545
+    type: object
+    title: Identifier
+    required:
+    - use
+    properties:
+      assigner:
+        $ref: '#/definitions/patientIdentifierItemsAllOf0Assigner'
+      system:
+        type: string
+      use:
+        type: string
+        enum:
+        - usual
+        - official
+        - temp
+        - secondary
+        - old
+        example: usual
+      value:
+        description: Some unique value
+        type: string
+    x-go-gen-location: models
+  patientIdentifierItemsAllOf0Assigner:
+    description: Organization
+    allOf:
+    - $ref: '#/definitions/patientIdentifierItemsAllOf0AssignerAllOf0'
+    x-go-gen-location: models
+  patientIdentifierItemsAllOf0AssignerAllOf0:
+    description: v3.1.0-12545
+    type: object
+    title: reference
+    properties:
+      display:
+        description: Text alternative for the resource
+        type: string
+      identifier:
+        $ref: '#/definitions/patientIdentifierItemsAllOf0AssignerAllOf0Identifier'
+      reference:
+        description: Literal reference, Relative, internal or absolute URL
+        type: string
+        example: literal reference
+    x-go-gen-location: models
+  patientIdentifierItemsAllOf0AssignerAllOf0Identifier:
+    description: Logical reference, when literal reference is not known
+    allOf:
+    - $ref: '#/definitions/identifier'
+    x-go-gen-location: models
+  putPatientPatientIdOKBody:
+    allOf:
+    - $ref: '#/definitions/patient'
+    x-go-gen-location: operations
+parameters:
+  patientID:
+    type: string
+    description: patient ID
+    name: patientID
+    in: path
+    required: true
+responses:
+  Patient:
+    description: Patient
+    schema:
+      allOf:
+      - $ref: '#/definitions/patient'
+
diff --git a/fixtures/bugs/1767/flatten.yaml b/fixtures/bugs/1767/flatten.yaml
new file mode 100644
index 00000000..c5acc6e4
--- /dev/null
+++ b/fixtures/bugs/1767/flatten.yaml
@@ -0,0 +1,156 @@
+schemes:
+- http
+swagger: "2.0"
+info:
+  description: |
+    #### FHIR API
+  title: FHIR API
+  version: 1.0.0
+host: fhir.test.lan
+basePath: /
+paths:
+  /Patient/{patientID}:
+    get:
+      consumes:
+      - application/fhir+json
+      produces:
+      - application/fhir+json
+      tags:
+      - fhir
+      responses:
+        "200":
+          description: Patient
+          schema:
+            allOf:
+            - $ref: '#/definitions/patient'
+    put:
+      consumes:
+      - application/fhir+json
+      produces:
+      - application/fhir+json
+      tags:
+      - fhir
+      responses:
+        "200":
+          description: Patient
+          schema:
+            allOf:
+            - $ref: '#/definitions/patient'
+    parameters:
+    - type: string
+      description: patient ID
+      name: patientID
+      in: path
+      required: true
+definitions:
+  identifier:
+    description: v3.1.0-12545
+    type: object
+    title: Identifier
+    required:
+    - use
+    properties:
+      assigner:
+        description: Organization
+        allOf:
+        - description: v3.1.0-12545
+          type: object
+          title: reference
+          properties:
+            display:
+              description: Text alternative for the resource
+              type: string
+            identifier:
+              description: Logical reference, when literal reference is not known
+              allOf:
+              - $ref: '#/definitions/identifier'
+            reference:
+              description: Literal reference, Relative, internal or absolute URL
+              type: string
+              example: literal reference
+      system:
+        type: string
+      use:
+        type: string
+        enum:
+        - usual
+        - official
+        - temp
+        - secondary
+        - old
+        example: usual
+      value:
+        description: Some unique value
+        type: string
+  patient:
+    type: object
+    title: Info about patient
+    required:
+    - name
+    properties:
+      active:
+        type: boolean
+      id:
+        type: string
+      identifier:
+        description: Identifier
+        type: array
+        items:
+          allOf:
+          - description: v3.1.0-12545
+            type: object
+            title: Identifier
+            required:
+            - use
+            properties:
+              assigner:
+                description: Organization
+                allOf:
+                - description: v3.1.0-12545
+                  type: object
+                  title: reference
+                  properties:
+                    display:
+                      description: Text alternative for the resource
+                      type: string
+                    identifier:
+                      description: Logical reference, when literal reference is not
+                        known
+                      allOf:
+                      - $ref: '#/definitions/identifier'
+                    reference:
+                      description: Literal reference, Relative, internal or absolute
+                        URL
+                      type: string
+                      example: literal reference
+              system:
+                type: string
+              use:
+                type: string
+                enum:
+                - usual
+                - official
+                - temp
+                - secondary
+                - old
+                example: usual
+              value:
+                description: Some unique value
+                type: string
+      name:
+        description: Name
+        type: string
+parameters:
+  patientID:
+    type: string
+    description: patient ID
+    name: patientID
+    in: path
+    required: true
+responses:
+  Patient:
+    description: Patient
+    schema:
+      allOf:
+      - $ref: '#/definitions/patient'
+
diff --git a/fixtures/bugs/1774/AccessToken.yaml b/fixtures/bugs/1774/AccessToken.yaml
new file mode 100644
index 00000000..eaec652d
--- /dev/null
+++ b/fixtures/bugs/1774/AccessToken.yaml
@@ -0,0 +1,13 @@
+type: object
+properties:
+  value:
+    type: string
+  issuedAt:
+    type: string
+    format: datetime
+  signature:
+    type: string
+required:
+  - value
+  - issuedAt
+  - signature
diff --git a/fixtures/bugs/1774/Credentials.yaml b/fixtures/bugs/1774/Credentials.yaml
new file mode 100644
index 00000000..0d2613ac
--- /dev/null
+++ b/fixtures/bugs/1774/Credentials.yaml
@@ -0,0 +1,15 @@
+# User
+type: object
+properties:
+  username:
+    type: string
+    example: "Testuser"
+    description: "A username of the user"
+  password:
+    type: string
+    example: "123Test!"
+    description: "A password of the user"
+required:
+  - username
+  - password
+
diff --git a/fixtures/bugs/1774/Data.yaml b/fixtures/bugs/1774/Data.yaml
new file mode 100644
index 00000000..dbcbe805
--- /dev/null
+++ b/fixtures/bugs/1774/Data.yaml
@@ -0,0 +1,11 @@
+# Data
+type: object
+properties:
+  name:
+    type: string
+    example: "Test User"
+    description: "A name of the user"
+  credentials:
+    $ref: "./Credentials.yaml"
+required:
+- credentials
diff --git a/fixtures/bugs/1774/Error.yaml b/fixtures/bugs/1774/Error.yaml
new file mode 100644
index 00000000..0ca99350
--- /dev/null
+++ b/fixtures/bugs/1774/Error.yaml
@@ -0,0 +1,33 @@
+# Error
+type: object
+properties:
+  code:
+    type: string
+    description: "Error code"
+    example: RESOURCE_NOT_FOUND
+  message:
+    type: string
+    description: "Error message"
+    example: "Requested resource not found"
+  target:
+    type: string
+    description: "Related resource"
+    example: "/products/42"
+  details:
+    type: object
+    properties:
+      code:
+        type: string
+        description: "Detailed error code"
+        example: "MongoDB:2038"
+      message:
+        type: string
+        description: "Detailed error message"
+        example: "MongoDB: no document with ObjectID 42"
+    required:
+      - code
+      - message
+required:
+  - code
+  - message
+
diff --git a/fixtures/bugs/1774/Roles.yaml b/fixtures/bugs/1774/Roles.yaml
new file mode 100644
index 00000000..ecbb07b2
--- /dev/null
+++ b/fixtures/bugs/1774/Roles.yaml
@@ -0,0 +1,9 @@
+# Roles
+type: array
+items:
+  type: string
+  enum:
+  - ADMIN
+  - USER
+  example: "User"
+  description: "A role of the user"
diff --git a/fixtures/bugs/1774/User.yaml b/fixtures/bugs/1774/User.yaml
new file mode 100644
index 00000000..953b316d
--- /dev/null
+++ b/fixtures/bugs/1774/User.yaml
@@ -0,0 +1,15 @@
+# User
+type: object
+properties:
+  id:
+    type: string
+    format: uuid
+    readOnly: true
+    example: "87dcb276-d495-11e8-b06f-54ee75efd688"
+    description: "An ID of the user"
+  data:
+    $ref: "./Data.yaml"
+  roles:
+    $ref: "./Roles.yaml"
+required:
+  - data
diff --git a/fixtures/bugs/1774/Users.yaml b/fixtures/bugs/1774/Users.yaml
new file mode 100644
index 00000000..6432f0c5
--- /dev/null
+++ b/fixtures/bugs/1774/Users.yaml
@@ -0,0 +1,9 @@
+# Users
+type: object
+properties:
+  users:
+    type: array
+    items:
+      $ref: "./User.yaml"
+required:
+- users
diff --git a/fixtures/bugs/1774/def_api.yaml b/fixtures/bugs/1774/def_api.yaml
new file mode 100644
index 00000000..a9e4ae60
--- /dev/null
+++ b/fixtures/bugs/1774/def_api.yaml
@@ -0,0 +1,303 @@
+swagger: "2.0"
+info:
+  description: >-
+    REST API for the User Management Service
+  version: "1"
+  title: "User Management"
+  termsOfService: "Experimental, no SLA"
+  contact:
+    email: "development@bbgo.org"
+  license:
+    name: "Apache 2.0"
+    url: "http://www.apache.org/licenses/LICENSE-2.0.html"
+# host: "localhost"
+basePath: "/user-service/v1"
+tags:
+- name: User
+  description: "User"
+
+- name: Token
+  description: "Token"
+
+schemes:
+- "https"
+- "http"
+paths:
+  /users:
+    post:
+      tags:
+      - User
+      summary: "an operation to register a new user"
+      description: >-
+        Registers a new user
+      operationId: "registerUser"
+      consumes:
+      - "application/json"
+      produces:
+      - "application/json"
+      parameters:
+      - name: payload
+        in: body
+        description: >-
+          Data for the user to be registered
+        schema:
+          $ref: "./Data.yaml"
+        required: true
+      responses:
+        201:
+          description: Created
+          headers:
+            Location:
+              description: URI of the registered resource
+              type: string
+              #format: uri
+            ETag:
+              description: >-
+                Fingerprint of the created resource
+              type: string
+          schema:
+            $ref: "./User.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        500:
+          $ref: "./responses.yaml#/500"
+
+    get:
+      tags:
+      - User
+      summary: Get all users
+      description: >-
+        Get all users
+      operationId: "getUsers"
+      produces:
+      - "application/json"
+      parameters:
+      - $ref: "./parameters.yaml#/filter"
+      - $ref: "./parameters.yaml#/top"
+      - $ref: "./parameters.yaml#/skip"
+      - $ref: "./parameters.yaml#/search"
+      responses:
+        200:
+          description: OK
+          schema:
+            $ref: "./Users.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+  /users/{id}:
+    get:
+      tags:
+      - User
+      summary: "Retrieve a user by ID"
+      description: >-
+        Returns user
+      operationId: "getUser"
+      produces:
+      - "application/json"
+      parameters:
+      - in: path
+        name: "id"
+        description: "User ID"
+        type: string
+        required: true
+      responses:
+        200:
+          description: OK
+          headers:
+            ETag:
+              description: >-
+                Fingerprint of the user object retrieved
+              type: string
+          schema:
+            $ref: "./User.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+    delete:
+      tags:
+      - User
+      summary: Deletes a user
+      description: >-
+        Deletes a user
+      operationId: deleteUser
+      parameters:
+      - name: id
+        in: path
+        description: ID of a user to delete
+        required: true
+        type: "string"
+      responses:
+        204:
+          $ref: "./responses.yaml#/204"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+  /users/{id}/data:
+    put:
+      tags:
+      - User
+      summary: Update an existing user data
+      description: >-
+        Updates data for an existing user
+      operationId: updateData
+      consumes:
+      - application/json
+      produces:
+      - application/json
+      parameters:
+      - in: path
+        name: id
+        description: ID of the user to update
+        type: string
+        required: true
+      - in: body
+        name: payload
+        description: User data to be updated
+        required: true
+        schema:
+          $ref: "./Data.yaml"
+      - $ref: "./parameters.yaml#/ifmatch"
+      responses:
+        200:
+          description: OK
+          headers:
+            ETag:
+              description: "Fingerprint of the user object updated"
+              type: string
+          schema:
+            $ref: "./User.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        412:
+          $ref: "./responses.yaml#/412"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+  /users/{id}/roles:
+    put:
+      tags:
+      - User
+      summary: Update roles for an existing user
+      description: >-
+        Updates roles for an existing user
+      operationId: updateRoles
+      consumes:
+      - application/json
+      produces:
+      - application/json
+      parameters:
+      - in: path
+        name: id
+        description: ID of the user to update
+        type: string
+        required: true
+      - in: body
+        name: payload
+        description: User roles to be updated
+        required: true
+        schema:
+          $ref: "./Roles.yaml"
+      - $ref: "./parameters.yaml#/ifmatch"
+      responses:
+        200:
+          description: OK
+          headers:
+            ETag:
+              description: "Fingerprint of the user object updated"
+              type: string
+          schema:
+            $ref: "./User.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        412:
+          $ref: "./responses.yaml#/412"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+  /token:
+    post:
+      tags:
+      - Token
+      summary: Issues a token for an authenticated user
+      description: >-
+        Issues a token for an authenticated user
+      operationId: issueToken
+      produces:
+      - application/json
+      responses:
+        200:
+          description: OK
+          schema:
+            $ref: "./AccessToken.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        412:
+          $ref: "./responses.yaml#/412"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - basicAuth: []
+
+securityDefinitions:
+  basicAuth:
+    type: basic
+  tokenAuth:
+    type: apiKey
+    in: header
+    name: Authorization
\ No newline at end of file
diff --git a/fixtures/bugs/1774/parameters.yaml b/fixtures/bugs/1774/parameters.yaml
new file mode 100644
index 00000000..e9e4390b
--- /dev/null
+++ b/fixtures/bugs/1774/parameters.yaml
@@ -0,0 +1,46 @@
+top:
+  name: $top
+  in: query
+  description: >-
+    Show only the first N elements, where N is a positive integer. If a value
+    less than 0 is specified, the URI should be considered malformed.
+  type: integer
+  minimum: 0
+  required: false
+skip:
+  name: $skip
+  in: query
+  description: >-
+    Skip the first N elements, where N is a positive integer as specified by
+    this query option. If a value less than 0 is specified, the URI should be
+    considered malformed.
+  type: integer
+  minimum: 0
+  required: false
+search:
+  name: $search
+  in: query
+  description: Free text search on selected entity.
+  type: string
+  required: false
+filter:
+  name: $filter
+  in: query
+  description: >-
+    Causes returning only entities, for those the filter condition evaluates true.
+  type: string
+  required: false
+etag:
+  name: ETag
+  in: header
+  description: Known fingerprint of the entity
+  type: string
+  required: false
+ifmatch:
+  name: If-Match
+  in: header
+  description: >-
+    The request will succeed if the value equals to the current fingerprint
+    of the entity on the server side.
+  type: string
+  required: false
diff --git a/fixtures/bugs/1774/responses.yaml b/fixtures/bugs/1774/responses.yaml
new file mode 100644
index 00000000..61e54bd3
--- /dev/null
+++ b/fixtures/bugs/1774/responses.yaml
@@ -0,0 +1,68 @@
+204:
+  description: No Content
+400:
+  description: Bad Request
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: MISSING_PARAMETERS
+      message: >-
+        Required parameters missing or incorrect.
+401:
+  description: Unauthorized
+  headers:
+    WWW_Authenticate:
+      type: string
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: UNAUTHORIZED
+      message: >-
+        To access API you have to login
+403:
+  description: Forbidden
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: FORBIDDEN
+      message: >-
+        Insufficient privileges to access API
+404:
+  description: Not Found
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: RESOURCE_NOT_FOUND
+      message: >-
+        Requested resource not found
+412:
+  description: Precondition Failed
+  schema:
+    $ref: "./Error.yaml"
+  examples:
+    application/json:
+      code: CONCURRENT_MODIFICATION
+      message: >-
+        The resource was modified in the meanwhile
+500:
+  description: Internal server error
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: INTERNAL_SERVER_ERROR
+      message: >-
+        Internal server error occurred, retry after some time. In case the issue
+        persists contact your system administrator
+501:
+  description: Not Implemented
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: FEATURE_NOT_IMPLEMENTED
+      message: Requested feature is not implemented.
diff --git a/fixtures/bugs/1796/models/pair.json b/fixtures/bugs/1796/models/pair.json
new file mode 100644
index 00000000..14ae82d3
--- /dev/null
+++ b/fixtures/bugs/1796/models/pair.json
@@ -0,0 +1,16 @@
+{
+    "Pair": {
+        "description":
+          "Simple key value pair model that is used by some of the other models.",
+        "type": "object",
+        "required": ["key", "value"],
+        "properties": {
+          "key": {
+            "type": "string"
+          },
+          "value": {
+            "type": "string"
+          }
+        }
+     }
+  }
diff --git a/fixtures/bugs/1796/models/query.json b/fixtures/bugs/1796/models/query.json
new file mode 100644
index 00000000..9893fe9e
--- /dev/null
+++ b/fixtures/bugs/1796/models/query.json
@@ -0,0 +1,61 @@
+{
+    "Query": {
+       "description":
+         "Represents a search query using a boolean expression tree",
+       "type": "object",
+       "properties": {
+         "queryRoot": {
+           "$ref": "#/QueryNode"
+         },
+         "limit": {
+           "type": "integer",
+           "format": "int64"
+         },
+         "offset": {
+           "type": "integer",
+           "format": "int64"
+         }
+       }
+     },
+     "QueryNode": {
+      "description":
+        "Node in a boolean expression tree that represents a query",
+      "type": "object",
+      "properties": {
+        "and": {
+          "type": "array",
+          "items": {
+            "$ref": "#/QueryNode"
+          }
+        },
+        "or": {
+          "type": "array",
+          "items": {
+            "$ref": "#/QueryNode"
+          }
+        },
+        "not": {
+          "type": "array",
+          "items": {
+            "$ref": "#/QueryNode"
+          }
+        },
+        "wildcards": {
+          "description":
+            "Array of key/value pairs representing wildcard term matches",
+          "type": "array",
+          "items": {
+            "$ref": "./pair.json#/Pair"
+          }
+        },
+        "exact": {
+          "description":
+            "Array of key/value pairs representing exact term matches",
+          "type": "array",
+          "items": {
+            "$ref": "./pair.json#/Pair"
+          }
+        }
+      }
+    }
+ }
diff --git a/fixtures/bugs/1796/queryIssue.json b/fixtures/bugs/1796/queryIssue.json
new file mode 100644
index 00000000..46cd7dd5
--- /dev/null
+++ b/fixtures/bugs/1796/queryIssue.json
@@ -0,0 +1,68 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Query Model Issue",
+    "description": "Test for Query Model Issue",
+    "version": "0.0.1"
+  },
+  "schemes": ["http"],
+  "produces": ["application/json"],
+  "paths": {
+ 
+    "/search": {
+      "post": {
+        "operationId": "searchObject",
+        "tags": ["Query"],
+        "produces": ["application/json"],
+        "consumes": ["application/json"],
+        "security": [
+          {
+            "Bearer": []
+          }
+        ],
+        "summary":
+          "Get a list of the algorithms available in the AlgorithmBank instance. By default returns the first 10 results.",
+        "parameters": [
+          {
+            "name": "query",
+            "in": "body",
+            "required": true,
+            "schema": {
+              "$ref": "./models/query.json#/Query"
+            }
+          }
+        ], 
+        "responses": {
+          "200": {
+            "description": "OK",
+            "schema": {
+              "type": "string"
+            }
+          },
+          "400": {
+            "description": "Invalid parameters."
+          },
+          "401": {
+            "description": "Unauthenticated."
+          },
+          "403": {
+            "description": "User is not authorized to perform the action",
+            "schema": {
+              "type": "string"
+            }
+          },
+          "500": {
+            "description": "Internal Server Error",
+            "schema": {
+              "type": "string"
+            }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+
+  }
+}
+
diff --git a/hack/codegen-nonreg.sh b/hack/codegen-nonreg.sh
index 565b9012..0d472f99 100755
--- a/hack/codegen-nonreg.sh
+++ b/hack/codegen-nonreg.sh
@@ -117,14 +117,20 @@ fixture-1392-3.yaml|\
 )"
 
 # A list of known fixtures not supporting expand mode (not including the discriminator case).
-# Normally, this is because of duplicate names constructed during codegen of anonmyous structures.
+# Normally, this is because of duplicate names constructed during codegen of anonymous structures.
 # This should be solved with proper analysis of names before codegen.
 known_expand_failure="@(\
 todolist.enums.flattened.json|\
-fixture-1479.yaml\
+fixture-1479.yaml|\
 bitbucket.json|\
 )"
 
+# A list of known failures with minimal spec flattening. For those special cases, a full
+# flattening is required
+known_failed_minimal="@(\
+fixture-1767.yaml|\
+)"
+
 if [[ "$1" == "--circleci" ]] ; then
     # Coloured output not supported by default on CircleCI.
     # Forcing term to xterm is not enough: tput not available with minimalist env.
@@ -155,12 +161,15 @@ specdir=${specdir}" fixtures/bugs/957"
 specdir=${specdir}" fixtures/bugs/1614"
 specdir=${specdir}" fixtures/bugs/931"
 specdir=${specdir}" fixtures/bugs/1683"
+specdir=${specdir}" fixtures/bugs/1796"
 gendir=./tmp-gen
 rm -rf ${gendir}
 
 check_list=`for d in ${specdir}; do ls $d/*.yml;ls $d/*.json;ls $d/*.yaml;done 2>/dev/null`
 # there are several subspecs there: we just want the master
 check_list=${check_list}" fixtures/bugs/1621/fixture-1621.yaml"
+check_list=${check_list}" fixtures/bugs/1774/def_api.yaml"
+check_list=${check_list}" fixtures/bugs/1767/fixture-1767.yaml"
 
 list=( $check_list )
 fixtures_count=${#list[@]}
@@ -194,9 +203,16 @@ for spec in ${check_list}; do
         warncr "[`date +%T`]${spec}: will not attempt to build with expand mode because of known issues..."
         run="true"
         opts=""
-        buildClient="false"
+        buildClient="true"
         noexpand="true"
         ;;
+    ${known_failed_minimal})
+        warncr "[`date +%T`]${spec}: will not attempt to build with flatten minimal mode because of known issues..."
+        run="true"
+        opts=""
+        buildClient="true"
+        noflatten="true"
+        ;;
     *)
         infocr "[`date +%T`]${spec}: assumed valid and tested against build."
         run="true"
@@ -219,9 +235,16 @@ for spec in ${check_list}; do
 	            warncr "Skipped ${testcase} with ${preprocessingOpts}: discriminator not supported in this mode"
 	            continue
 	        fi
-            if [[ ${noexpand} != "true" && ${preprocessingOpts} == "--with-flatten=expand" ]] ; then
-                continue
+          if [[ ${noexpand} != "true" && ${preprocessingOpts} == "--with-flatten=expand" ]] ; then
+              continue
+          fi
+          if [[ ${noflatten} == "true" && ( ${preprocessingOpts} == "--with-flatten=minimal" || ${preprocessingOpts} == "" ) ]] ; then
+            if [[ ${OPTS} == "--with-flatten=minimal" ]] ; then
+              preprocessingOpts="--with-flatten=full"
+            else
+              continue
             fi
+          fi
 
 	        target=${gendir}/gen-${testcase%.*}${index}
 	        target_client=${gendir}/gen-${testcase%.*}${index}"-client"
diff --git a/vendor/github.com/go-openapi/analysis/.golangci.yml b/vendor/github.com/go-openapi/analysis/.golangci.yml
index 922278cc..212c13bf 100644
--- a/vendor/github.com/go-openapi/analysis/.golangci.yml
+++ b/vendor/github.com/go-openapi/analysis/.golangci.yml
@@ -17,3 +17,5 @@ linters:
   enable-all: true
   disable:
     - maligned
+    - gochecknoglobals
+    - gochecknoinits
diff --git a/vendor/github.com/go-openapi/analysis/analyzer.go b/vendor/github.com/go-openapi/analysis/analyzer.go
index 81dc18f3..85711d57 100644
--- a/vendor/github.com/go-openapi/analysis/analyzer.go
+++ b/vendor/github.com/go-openapi/analysis/analyzer.go
@@ -104,6 +104,38 @@ func (p *patternAnalysis) addSchemaPattern(key, pattern string) {
 	p.addPattern(key, pattern)
 }
 
+type enumAnalysis struct {
+	parameters map[string][]interface{}
+	headers    map[string][]interface{}
+	items      map[string][]interface{}
+	schemas    map[string][]interface{}
+	allEnums   map[string][]interface{}
+}
+
+func (p *enumAnalysis) addEnum(key string, enum []interface{}) {
+	p.allEnums["#"+key] = enum
+}
+
+func (p *enumAnalysis) addParameterEnum(key string, enum []interface{}) {
+	p.parameters["#"+key] = enum
+	p.addEnum(key, enum)
+}
+
+func (p *enumAnalysis) addHeaderEnum(key string, enum []interface{}) {
+	p.headers["#"+key] = enum
+	p.addEnum(key, enum)
+}
+
+func (p *enumAnalysis) addItemsEnum(key string, enum []interface{}) {
+	p.items["#"+key] = enum
+	p.addEnum(key, enum)
+}
+
+func (p *enumAnalysis) addSchemaEnum(key string, enum []interface{}) {
+	p.schemas["#"+key] = enum
+	p.addEnum(key, enum)
+}
+
 // New takes a swagger spec object and returns an analyzed spec document.
 // The analyzed document contains a number of indices that make it easier to
 // reason about semantics of a swagger specification for use in code generation
@@ -134,6 +166,13 @@ func New(doc *spec.Swagger) *Spec {
 			schemas:     make(map[string]string, 150),
 			allPatterns: make(map[string]string, 150),
 		},
+		enums: enumAnalysis{
+			parameters: make(map[string][]interface{}, 150),
+			headers:    make(map[string][]interface{}, 150),
+			items:      make(map[string][]interface{}, 150),
+			schemas:    make(map[string][]interface{}, 150),
+			allEnums:   make(map[string][]interface{}, 150),
+		},
 	}
 	a.initialize()
 	return a
@@ -149,6 +188,7 @@ type Spec struct {
 	operations  map[string]map[string]*spec.Operation
 	references  referenceAnalysis
 	patterns    patternAnalysis
+	enums       enumAnalysis
 	allSchemas  map[string]SchemaRef
 	allOfs      map[string]SchemaRef
 }
@@ -173,6 +213,11 @@ func (s *Spec) reset() {
 	s.patterns.items = make(map[string]string, 150)
 	s.patterns.schemas = make(map[string]string, 150)
 	s.patterns.allPatterns = make(map[string]string, 150)
+	s.enums.parameters = make(map[string][]interface{}, 150)
+	s.enums.headers = make(map[string][]interface{}, 150)
+	s.enums.items = make(map[string][]interface{}, 150)
+	s.enums.schemas = make(map[string][]interface{}, 150)
+	s.enums.allEnums = make(map[string][]interface{}, 150)
 }
 
 func (s *Spec) reload() {
@@ -207,6 +252,9 @@ func (s *Spec) initialize() {
 		if parameter.Pattern != "" {
 			s.patterns.addParameterPattern(refPref, parameter.Pattern)
 		}
+		if len(parameter.Enum) > 0 {
+			s.enums.addParameterEnum(refPref, parameter.Enum)
+		}
 	}
 
 	for name, response := range s.spec.Responses {
@@ -219,6 +267,9 @@ func (s *Spec) initialize() {
 			if v.Pattern != "" {
 				s.patterns.addHeaderPattern(hRefPref, v.Pattern)
 			}
+			if len(v.Enum) > 0 {
+				s.enums.addHeaderEnum(hRefPref, v.Enum)
+			}
 		}
 		if response.Schema != nil {
 			s.analyzeSchema("schema", *response.Schema, refPref)
@@ -256,6 +307,9 @@ func (s *Spec) analyzeOperations(path string, pi *spec.PathItem) {
 		if param.Pattern != "" {
 			s.patterns.addParameterPattern(refPref, param.Pattern)
 		}
+		if len(param.Enum) > 0 {
+			s.enums.addParameterEnum(refPref, param.Enum)
+		}
 		if param.Items != nil {
 			s.analyzeItems("items", param.Items, refPref, "parameter")
 		}
@@ -277,6 +331,9 @@ func (s *Spec) analyzeItems(name string, items *spec.Items, prefix, location str
 	if items.Pattern != "" {
 		s.patterns.addItemsPattern(refPref, items.Pattern)
 	}
+	if len(items.Enum) > 0 {
+		s.enums.addItemsEnum(refPref, items.Enum)
+	}
 }
 
 func (s *Spec) analyzeOperation(method, path string, op *spec.Operation) {
@@ -308,6 +365,9 @@ func (s *Spec) analyzeOperation(method, path string, op *spec.Operation) {
 		if param.Pattern != "" {
 			s.patterns.addParameterPattern(refPref, param.Pattern)
 		}
+		if len(param.Enum) > 0 {
+			s.enums.addParameterEnum(refPref, param.Enum)
+		}
 		s.analyzeItems("items", param.Items, refPref, "parameter")
 		if param.In == "body" && param.Schema != nil {
 			s.analyzeSchema("schema", *param.Schema, refPref)
@@ -341,6 +401,9 @@ func (s *Spec) analyzeOperation(method, path string, op *spec.Operation) {
 				if v.Pattern != "" {
 					s.patterns.addHeaderPattern(hRefPref, v.Pattern)
 				}
+				if len(v.Enum) > 0 {
+					s.enums.addHeaderEnum(hRefPref, v.Enum)
+				}
 			}
 			if res.Schema != nil {
 				s.analyzeSchema("schema", *res.Schema, refPref)
@@ -366,6 +429,9 @@ func (s *Spec) analyzeSchema(name string, schema spec.Schema, prefix string) {
 	if schema.Pattern != "" {
 		s.patterns.addSchemaPattern(refURI, schema.Pattern)
 	}
+	if len(schema.Enum) > 0 {
+		s.enums.addSchemaEnum(refURI, schema.Enum)
+	}
 
 	for k, v := range schema.Definitions {
 		s.analyzeSchema(k, v, slashpath.Join(refURI, "definitions"))
@@ -861,6 +927,14 @@ func cloneStringMap(source map[string]string) map[string]string {
 	return res
 }
 
+func cloneEnumMap(source map[string][]interface{}) map[string][]interface{} {
+	res := make(map[string][]interface{}, len(source))
+	for k, v := range source {
+		res[k] = v
+	}
+	return res
+}
+
 // ParameterPatterns returns all the patterns found in parameters
 // the map is cloned to avoid accidental changes
 func (s *Spec) ParameterPatterns() map[string]string {
@@ -890,3 +964,33 @@ func (s *Spec) SchemaPatterns() map[string]string {
 func (s *Spec) AllPatterns() map[string]string {
 	return cloneStringMap(s.patterns.allPatterns)
 }
+
+// ParameterEnums returns all the enums found in parameters
+// the map is cloned to avoid accidental changes
+func (s *Spec) ParameterEnums() map[string][]interface{} {
+	return cloneEnumMap(s.enums.parameters)
+}
+
+// HeaderEnums returns all the enums found in response headers
+// the map is cloned to avoid accidental changes
+func (s *Spec) HeaderEnums() map[string][]interface{} {
+	return cloneEnumMap(s.enums.headers)
+}
+
+// ItemsEnums returns all the enums found in simple array items
+// the map is cloned to avoid accidental changes
+func (s *Spec) ItemsEnums() map[string][]interface{} {
+	return cloneEnumMap(s.enums.items)
+}
+
+// SchemaEnums returns all the enums found in schemas
+// the map is cloned to avoid accidental changes
+func (s *Spec) SchemaEnums() map[string][]interface{} {
+	return cloneEnumMap(s.enums.schemas)
+}
+
+// AllEnums returns all the enums found in the spec
+// the map is cloned to avoid accidental changes
+func (s *Spec) AllEnums() map[string][]interface{} {
+	return cloneEnumMap(s.enums.allEnums)
+}
diff --git a/vendor/github.com/go-openapi/analysis/analyzer_test.go b/vendor/github.com/go-openapi/analysis/analyzer_test.go
index 1de549b6..0b888f18 100644
--- a/vendor/github.com/go-openapi/analysis/analyzer_test.go
+++ b/vendor/github.com/go-openapi/analysis/analyzer_test.go
@@ -884,3 +884,62 @@ func Test_EdgeCases(t *testing.T) {
 	assert.NotNil(t, res7)
 	assert.Len(t, res7, 1)
 }
+
+func TestEnumAnalysis(t *testing.T) {
+	doc, err := loadSpec(filepath.Join("fixtures", "enums.yml"))
+	if assert.NoError(t, err) {
+		an := New(doc)
+		en := an.enums
+
+		// parameters
+		assertEnum(t, en.parameters, "#/parameters/idParam", []interface{}{"aA", "b9", "c3"})
+		assertEnum(t, en.parameters, "#/paths/~1some~1where~1{id}/parameters/1", []interface{}{"bA", "ba", "b9"})
+		assertEnum(t, en.parameters, "#/paths/~1some~1where~1{id}/get/parameters/0", []interface{}{"a0", "b1", "c2"})
+
+		// responses
+		assertEnum(t, en.headers, "#/responses/notFound/headers/ContentLength", []interface{}{"1234", "123"})
+		assertEnum(t, en.headers,
+			"#/paths/~1some~1where~1{id}/get/responses/200/headers/X-Request-Id", []interface{}{"dA", "d9"})
+
+		// definitions
+		assertEnum(t, en.schemas,
+			"#/paths/~1other~1place/post/parameters/0/schema/properties/value", []interface{}{"eA", "e9"})
+		assertEnum(t, en.schemas, "#/paths/~1other~1place/post/responses/200/schema/properties/data",
+			[]interface{}{"123a", "123b", "123d"})
+		assertEnum(t, en.schemas, "#/definitions/named", []interface{}{"fA", "f9"})
+		assertEnum(t, en.schemas, "#/definitions/tag/properties/value", []interface{}{"gA", "ga", "g9"})
+		assertEnum(t, en.schemas, "#/definitions/record",
+			[]interface{}{`{"createdAt": "2018-08-31"}`, `{"createdAt": "2018-09-30"}`})
+
+		// array enum
+		assertEnum(t, en.parameters, "#/paths/~1some~1where~1{id}/get/parameters/1",
+			[]interface{}{[]interface{}{"cA", "cz", "c9"}, []interface{}{"cA", "cz"}, []interface{}{"cz", "c9"}})
+
+		// items
+		assertEnum(t, en.items, "#/paths/~1some~1where~1{id}/get/parameters/1/items", []interface{}{"cA", "cz", "c9"})
+		assertEnum(t, en.items, "#/paths/~1other~1place/post/responses/default/headers/Via/items",
+			[]interface{}{"AA", "Ab"})
+
+		res := an.AllEnums()
+		assert.Lenf(t, res, 14, "Expected 14 enums in this spec, but got %d", len(res))
+
+		res = an.ParameterEnums()
+		assert.Lenf(t, res, 4, "Expected 4 enums in this spec, but got %d", len(res))
+
+		res = an.SchemaEnums()
+		assert.Lenf(t, res, 6, "Expected 6 schema enums in this spec, but got %d", len(res))
+
+		res = an.HeaderEnums()
+		assert.Lenf(t, res, 2, "Expected 2 header enums in this spec, but got %d", len(res))
+
+		res = an.ItemsEnums()
+		assert.Lenf(t, res, 2, "Expected 2 items enums in this spec, but got %d", len(res))
+	}
+}
+
+func assertEnum(t testing.TB, data map[string][]interface{}, key string, enum []interface{}) bool {
+	if assert.Contains(t, data, key) {
+		return assert.Equal(t, enum, data[key])
+	}
+	return false
+}
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/remote/remote.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/remote/remote.yaml
new file mode 100644
index 00000000..8de1136d
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/remote/remote.yaml
@@ -0,0 +1,8 @@
+aRemotePlace:
+  type: object
+  properties:
+    remoteProp:
+      type: integer
+
+moreRemoteThanYouCanThink:
+  $ref: './remote/remote.yaml#/farFarAway'
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/remote/remote/remote.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/remote/remote/remote.yaml
new file mode 100644
index 00000000..857268e4
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/remote/remote/remote.yaml
@@ -0,0 +1,5 @@
+farFarAway:
+  type: object
+  properties:
+    farFarAwayProp:
+      type: integer
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/responses.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/responses.yaml
new file mode 100644
index 00000000..6db8e726
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/responses.yaml
@@ -0,0 +1,104 @@
+swagger: '2.0'
+info:
+  title: Responses
+  version: 0.1.0
+
+definitions:
+  Error:
+    type: object
+    description: |
+      Contains all the properties any error response from the API will contain.
+      Some properties are optional so might be empty most of the time
+    required:
+      - code
+      - message
+    properties:
+      code:
+        description: the error code, this is not necessarily the http status code
+        type: integer
+        format: int32
+      message:
+        description: a human readable version of the error
+        type: string
+      helpUrl:
+        description: an optional url for getting more help about this error
+        type: string
+        format: uri
+
+  myArray:
+    type: array
+    items:
+      $ref: '#/definitions/myItems'
+
+  myItems:
+    type: object
+    properties:
+      propItems1:
+        type: integer
+      propItems2:
+        $ref: 'remote/remote.yaml#/aRemotePlace'
+
+otherPlace:
+  Error:
+    type: object
+    properties:
+      message:
+        type: string
+
+parameters:
+  BadRequest:
+    name: badRequest
+    in: body
+    schema:
+      $ref: '#/definitions/Error'
+  GoodRequest:
+    name: goodRequest
+    in: body
+    schema:
+      $ref: '#/otherPlace/Error'
+  PlainRequest:
+    name: plainRequest
+    in: body
+    schema:
+      type: integer
+  StrangeRequest:
+    name: stangeRequest
+    in: body
+    schema:
+      $ref: 'responses.yaml#/otherPlace/Error'
+  RemoteRequest:
+    name: remoteRequest
+    in: body
+    schema:
+      $ref: './remote/remote.yaml#/moreRemoteThanYouCanThink'
+
+responses:
+  BadRequest:
+    description: Bad request
+    schema:
+      $ref: '#/definitions/Error'
+  GoodRequest:
+    description: good request
+    schema:
+      $ref: '#/otherPlace/Error'
+  PlainRequest:
+    description: plain request
+    schema:
+      type: integer
+  StrangeRequest:
+    description: strange request
+    schema:
+      $ref: 'responses.yaml#/otherPlace/Error'
+  RemoteRequest:
+    description: remote request
+    schema:
+      $ref: './remote/remote.yaml#/moreRemoteThanYouCanThink'
+
+paths:
+  /:
+    get:
+      summary: GET
+      operationId: getAll
+      responses:
+        200:
+          description: Ok
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/swagger.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/swagger.yaml
new file mode 100644
index 00000000..6ae0aba8
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1429/swagger.yaml
@@ -0,0 +1,39 @@
+swagger: '2.0'
+info:
+  title: Object
+  version: 0.1.0
+
+paths:
+  /:
+    get:
+      summary: GET
+      operationId: getAll
+      parameters:
+        - $ref: 'responses.yaml#/parameters/BadRequest'
+        - $ref: 'responses.yaml#/parameters/GoodRequest'
+        - $ref: 'responses.yaml#/parameters/PlainRequest'
+        - $ref: 'responses.yaml#/parameters/StrangeRequest'
+        - $ref: 'responses.yaml#/parameters/RemoteRequest'
+        - name: nestedBody
+          in: body
+          schema:
+            $ref: '#/definitions/nestedRefDefinition'
+      responses:
+        200:
+          description: Ok
+        400:
+          $ref: 'responses.yaml#/responses/BadRequest'
+        403:
+          $ref: 'responses.yaml#/responses/GoodRequest'
+        404:
+          $ref: 'responses.yaml#/responses/PlainRequest'
+        304:
+          $ref: 'responses.yaml#/responses/StrangeRequest'
+        204:
+          $ref: 'responses.yaml#/responses/RemoteRequest'
+
+definitions:
+  badDefinition:
+    $ref: 'responses.yaml#/definitions/Error'
+  nestedRefDefinition:
+    $ref: 'responses.yaml#/definitions/myArray'
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/Identifier.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/Identifier.yaml
new file mode 100644
index 00000000..d27898b2
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/Identifier.yaml
@@ -0,0 +1,24 @@
+type: object
+title: "Identifier"
+description: "v3.1.0-12545"
+properties:
+  use:
+    type: string
+    example: "usual"
+    enum:
+    - "usual"
+    - "official"
+    - "temp"
+    - "secondary"
+    - "old"
+  system:
+    type: string
+  value:
+    description: "Some unique value"
+    type: string
+  assigner:
+    description: "Organization"
+    allOf:
+      - $ref: 'Reference.yaml'
+required:
+  - use
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/Patient.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/Patient.yaml
new file mode 100644
index 00000000..36f565be
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/Patient.yaml
@@ -0,0 +1,19 @@
+type: object
+title: "Info about patient"
+description: ""
+properties:
+      id:
+        type: string
+      identifier:
+        type: array
+        description: "Identifier"
+        items:
+            allOf:
+            - $ref: 'Identifier.yaml'
+      active:
+        type: boolean
+      name:
+        description: "Name"
+        type: string
+required:
+- name
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/Reference.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/Reference.yaml
new file mode 100644
index 00000000..3130b3d8
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/Reference.yaml
@@ -0,0 +1,15 @@
+type: object
+title: "reference"
+description: "v3.1.0-12545"
+properties:
+      reference:
+        description: "Literal reference, Relative, internal or absolute URL"
+        type: string
+        example: "literal reference"
+      identifier:
+        description: "Logical reference, when literal reference is not known"
+        allOf:
+        - $ref: 'Identifier.yaml'
+      display:
+        type: string
+        description: "Text alternative for the resource"
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/fixture-1767.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/fixture-1767.yaml
new file mode 100644
index 00000000..d58cd053
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1767/fixture-1767.yaml
@@ -0,0 +1,51 @@
+---
+swagger: '2.0'
+info:
+  version: "1.0.0"
+  title: FHIR API
+  description: |
+    #### FHIR API
+schemes:
+- http
+host: "fhir.test.lan"
+basePath: /
+
+parameters:
+  patientID:
+    name: patientID
+    in: path
+    description: "patient ID"
+    type: string
+    required: true
+
+paths:
+  /Patient/{patientID}:
+    parameters:
+    - $ref: "#/parameters/patientID"
+    get:
+      tags:
+      - fhir
+      produces:
+      - application/fhir+json
+      consumes:
+      - application/fhir+json
+      responses:
+        200:
+          $ref: "#/responses/Patient"
+    put:
+      tags:
+      - fhir
+      produces:
+      - application/fhir+json
+      consumes:
+      - application/fhir+json
+      responses:
+        200:
+          $ref: "#/responses/Patient"
+
+responses:
+  Patient:
+    description: "Patient"
+    schema:
+      allOf:
+      - $ref: 'Patient.yaml'
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/AccessToken.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/AccessToken.yaml
new file mode 100644
index 00000000..eaec652d
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/AccessToken.yaml
@@ -0,0 +1,13 @@
+type: object
+properties:
+  value:
+    type: string
+  issuedAt:
+    type: string
+    format: datetime
+  signature:
+    type: string
+required:
+  - value
+  - issuedAt
+  - signature
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Credentials.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Credentials.yaml
new file mode 100644
index 00000000..0d2613ac
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Credentials.yaml
@@ -0,0 +1,15 @@
+# User
+type: object
+properties:
+  username:
+    type: string
+    example: "Testuser"
+    description: "A username of the user"
+  password:
+    type: string
+    example: "123Test!"
+    description: "A password of the user"
+required:
+  - username
+  - password
+
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Data.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Data.yaml
new file mode 100644
index 00000000..dbcbe805
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Data.yaml
@@ -0,0 +1,11 @@
+# Data
+type: object
+properties:
+  name:
+    type: string
+    example: "Test User"
+    description: "A name of the user"
+  credentials:
+    $ref: "./Credentials.yaml"
+required:
+- credentials
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Error.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Error.yaml
new file mode 100644
index 00000000..0ca99350
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Error.yaml
@@ -0,0 +1,33 @@
+# Error
+type: object
+properties:
+  code:
+    type: string
+    description: "Error code"
+    example: RESOURCE_NOT_FOUND
+  message:
+    type: string
+    description: "Error message"
+    example: "Requested resource not found"
+  target:
+    type: string
+    description: "Related resource"
+    example: "/products/42"
+  details:
+    type: object
+    properties:
+      code:
+        type: string
+        description: "Detailed error code"
+        example: "MongoDB:2038"
+      message:
+        type: string
+        description: "Detailed error message"
+        example: "MongoDB: no document with ObjectID 42"
+    required:
+      - code
+      - message
+required:
+  - code
+  - message
+
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Roles.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Roles.yaml
new file mode 100644
index 00000000..ecbb07b2
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Roles.yaml
@@ -0,0 +1,9 @@
+# Roles
+type: array
+items:
+  type: string
+  enum:
+  - ADMIN
+  - USER
+  example: "User"
+  description: "A role of the user"
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/User.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/User.yaml
new file mode 100644
index 00000000..953b316d
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/User.yaml
@@ -0,0 +1,15 @@
+# User
+type: object
+properties:
+  id:
+    type: string
+    format: uuid
+    readOnly: true
+    example: "87dcb276-d495-11e8-b06f-54ee75efd688"
+    description: "An ID of the user"
+  data:
+    $ref: "./Data.yaml"
+  roles:
+    $ref: "./Roles.yaml"
+required:
+  - data
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Users.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Users.yaml
new file mode 100644
index 00000000..6432f0c5
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/Users.yaml
@@ -0,0 +1,9 @@
+# Users
+type: object
+properties:
+  users:
+    type: array
+    items:
+      $ref: "./User.yaml"
+required:
+- users
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/def_api.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/def_api.yaml
new file mode 100644
index 00000000..a9e4ae60
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/def_api.yaml
@@ -0,0 +1,303 @@
+swagger: "2.0"
+info:
+  description: >-
+    REST API for the User Management Service
+  version: "1"
+  title: "User Management"
+  termsOfService: "Experimental, no SLA"
+  contact:
+    email: "development@bbgo.org"
+  license:
+    name: "Apache 2.0"
+    url: "http://www.apache.org/licenses/LICENSE-2.0.html"
+# host: "localhost"
+basePath: "/user-service/v1"
+tags:
+- name: User
+  description: "User"
+
+- name: Token
+  description: "Token"
+
+schemes:
+- "https"
+- "http"
+paths:
+  /users:
+    post:
+      tags:
+      - User
+      summary: "an operation to register a new user"
+      description: >-
+        Registers a new user
+      operationId: "registerUser"
+      consumes:
+      - "application/json"
+      produces:
+      - "application/json"
+      parameters:
+      - name: payload
+        in: body
+        description: >-
+          Data for the user to be registered
+        schema:
+          $ref: "./Data.yaml"
+        required: true
+      responses:
+        201:
+          description: Created
+          headers:
+            Location:
+              description: URI of the registered resource
+              type: string
+              #format: uri
+            ETag:
+              description: >-
+                Fingerprint of the created resource
+              type: string
+          schema:
+            $ref: "./User.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        500:
+          $ref: "./responses.yaml#/500"
+
+    get:
+      tags:
+      - User
+      summary: Get all users
+      description: >-
+        Get all users
+      operationId: "getUsers"
+      produces:
+      - "application/json"
+      parameters:
+      - $ref: "./parameters.yaml#/filter"
+      - $ref: "./parameters.yaml#/top"
+      - $ref: "./parameters.yaml#/skip"
+      - $ref: "./parameters.yaml#/search"
+      responses:
+        200:
+          description: OK
+          schema:
+            $ref: "./Users.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+  /users/{id}:
+    get:
+      tags:
+      - User
+      summary: "Retrieve a user by ID"
+      description: >-
+        Returns user
+      operationId: "getUser"
+      produces:
+      - "application/json"
+      parameters:
+      - in: path
+        name: "id"
+        description: "User ID"
+        type: string
+        required: true
+      responses:
+        200:
+          description: OK
+          headers:
+            ETag:
+              description: >-
+                Fingerprint of the user object retrieved
+              type: string
+          schema:
+            $ref: "./User.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+    delete:
+      tags:
+      - User
+      summary: Deletes a user
+      description: >-
+        Deletes a user
+      operationId: deleteUser
+      parameters:
+      - name: id
+        in: path
+        description: ID of a user to delete
+        required: true
+        type: "string"
+      responses:
+        204:
+          $ref: "./responses.yaml#/204"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+  /users/{id}/data:
+    put:
+      tags:
+      - User
+      summary: Update an existing user data
+      description: >-
+        Updates data for an existing user
+      operationId: updateData
+      consumes:
+      - application/json
+      produces:
+      - application/json
+      parameters:
+      - in: path
+        name: id
+        description: ID of the user to update
+        type: string
+        required: true
+      - in: body
+        name: payload
+        description: User data to be updated
+        required: true
+        schema:
+          $ref: "./Data.yaml"
+      - $ref: "./parameters.yaml#/ifmatch"
+      responses:
+        200:
+          description: OK
+          headers:
+            ETag:
+              description: "Fingerprint of the user object updated"
+              type: string
+          schema:
+            $ref: "./User.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        412:
+          $ref: "./responses.yaml#/412"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+  /users/{id}/roles:
+    put:
+      tags:
+      - User
+      summary: Update roles for an existing user
+      description: >-
+        Updates roles for an existing user
+      operationId: updateRoles
+      consumes:
+      - application/json
+      produces:
+      - application/json
+      parameters:
+      - in: path
+        name: id
+        description: ID of the user to update
+        type: string
+        required: true
+      - in: body
+        name: payload
+        description: User roles to be updated
+        required: true
+        schema:
+          $ref: "./Roles.yaml"
+      - $ref: "./parameters.yaml#/ifmatch"
+      responses:
+        200:
+          description: OK
+          headers:
+            ETag:
+              description: "Fingerprint of the user object updated"
+              type: string
+          schema:
+            $ref: "./User.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        412:
+          $ref: "./responses.yaml#/412"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - tokenAuth: [ADMIN, USER]
+
+  /token:
+    post:
+      tags:
+      - Token
+      summary: Issues a token for an authenticated user
+      description: >-
+        Issues a token for an authenticated user
+      operationId: issueToken
+      produces:
+      - application/json
+      responses:
+        200:
+          description: OK
+          schema:
+            $ref: "./AccessToken.yaml"
+        400:
+          $ref: "./responses.yaml#/400"
+        401:
+          $ref: "./responses.yaml#/401"
+        403:
+          $ref: "./responses.yaml#/403"
+        404:
+          $ref: "./responses.yaml#/404"
+        412:
+          $ref: "./responses.yaml#/412"
+        500:
+          $ref: "./responses.yaml#/500"
+      security:
+      - basicAuth: []
+
+securityDefinitions:
+  basicAuth:
+    type: basic
+  tokenAuth:
+    type: apiKey
+    in: header
+    name: Authorization
\ No newline at end of file
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/parameters.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/parameters.yaml
new file mode 100644
index 00000000..e9e4390b
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/parameters.yaml
@@ -0,0 +1,46 @@
+top:
+  name: $top
+  in: query
+  description: >-
+    Show only the first N elements, where N is a positive integer. If a value
+    less than 0 is specified, the URI should be considered malformed.
+  type: integer
+  minimum: 0
+  required: false
+skip:
+  name: $skip
+  in: query
+  description: >-
+    Skip the first N elements, where N is a positive integer as specified by
+    this query option. If a value less than 0 is specified, the URI should be
+    considered malformed.
+  type: integer
+  minimum: 0
+  required: false
+search:
+  name: $search
+  in: query
+  description: Free text search on selected entity.
+  type: string
+  required: false
+filter:
+  name: $filter
+  in: query
+  description: >-
+    Causes returning only entities, for those the filter condition evaluates true.
+  type: string
+  required: false
+etag:
+  name: ETag
+  in: header
+  description: Known fingerprint of the entity
+  type: string
+  required: false
+ifmatch:
+  name: If-Match
+  in: header
+  description: >-
+    The request will succeed if the value equals to the current fingerprint
+    of the entity on the server side.
+  type: string
+  required: false
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/responses.yaml b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/responses.yaml
new file mode 100644
index 00000000..61e54bd3
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1774/responses.yaml
@@ -0,0 +1,68 @@
+204:
+  description: No Content
+400:
+  description: Bad Request
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: MISSING_PARAMETERS
+      message: >-
+        Required parameters missing or incorrect.
+401:
+  description: Unauthorized
+  headers:
+    WWW_Authenticate:
+      type: string
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: UNAUTHORIZED
+      message: >-
+        To access API you have to login
+403:
+  description: Forbidden
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: FORBIDDEN
+      message: >-
+        Insufficient privileges to access API
+404:
+  description: Not Found
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: RESOURCE_NOT_FOUND
+      message: >-
+        Requested resource not found
+412:
+  description: Precondition Failed
+  schema:
+    $ref: "./Error.yaml"
+  examples:
+    application/json:
+      code: CONCURRENT_MODIFICATION
+      message: >-
+        The resource was modified in the meanwhile
+500:
+  description: Internal server error
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: INTERNAL_SERVER_ERROR
+      message: >-
+        Internal server error occurred, retry after some time. In case the issue
+        persists contact your system administrator
+501:
+  description: Not Implemented
+  schema:
+    $ref: './Error.yaml'
+  examples:
+    application/json:
+      code: FEATURE_NOT_IMPLEMENTED
+      message: Requested feature is not implemented.
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1796/models/pair.json b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1796/models/pair.json
new file mode 100644
index 00000000..b124fdd5
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1796/models/pair.json
@@ -0,0 +1,23 @@
+{
+    "Pair": {
+        "description":
+          "Simple key value pair model that is used by some of the other models.",
+        "type": "object",
+        "required": ["key", "value"],
+        "properties": {
+          "key": {
+            "type": "string"
+          },
+          "value": {
+            "type": "string"
+          }
+        },
+        "x-go-type": {
+            "import": {
+              "package": "bitbucket.di2e.net/scm/pir/ab-models.git",
+              "alias": "abmodels"
+            },
+            "type": "Pair"
+        }
+     }
+  }
\ No newline at end of file
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1796/models/query.json b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1796/models/query.json
new file mode 100644
index 00000000..24433f07
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1796/models/query.json
@@ -0,0 +1,75 @@
+{
+    "Query": {
+       "description":
+         "Represents a search query using a boolean expression tree",
+       "type": "object",
+       "properties": {
+         "queryRoot": {
+           "$ref": "#/QueryNode"
+         },
+         "limit": {
+           "type": "integer",
+           "format": "int64"
+         },
+         "offset": {
+           "type": "integer",
+           "format": "int64"
+         }
+       },
+       "x-go-type": {
+           "import": {
+              "package": "bitbucket.di2e.net/scm/pir/ab-models.git",
+              "alias": "models"
+           },
+           "type": "Query"
+       }
+     },
+     "QueryNode": {
+      "description":
+        "Node in a boolean expression tree that represents a query",
+      "type": "object",
+      "properties": {
+        "and": {
+          "type": "array",
+          "items": {
+            "$ref": "#/QueryNode"
+          }
+        },
+        "or": {
+          "type": "array",
+          "items": {
+            "$ref": "#/QueryNode"
+          }
+        },
+        "not": {
+          "type": "array",
+          "items": {
+            "$ref": "#/QueryNode"
+          }
+        },
+        "wildcards": {
+          "description":
+            "Array of key/value pairs representing wildcard term matches",
+          "type": "array",
+          "items": {
+            "$ref": "./pair.json#/Pair"
+          }
+        },
+        "exact": {
+          "description":
+            "Array of key/value pairs representing exact term matches",
+          "type": "array",
+          "items": {
+            "$ref": "./pair.json#/Pair"
+          }
+        }
+      },
+      "x-go-type": {
+          "import": {
+            "package": "bitbucket.di2e.net/scm/pir/ab-models.git",
+            "alias": "models"
+          },
+          "type": "QueryNode"
+      }
+    }
+ }
\ No newline at end of file
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/bugs/1796/queryIssue.json b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1796/queryIssue.json
new file mode 100644
index 00000000..46cd7dd5
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/bugs/1796/queryIssue.json
@@ -0,0 +1,68 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Query Model Issue",
+    "description": "Test for Query Model Issue",
+    "version": "0.0.1"
+  },
+  "schemes": ["http"],
+  "produces": ["application/json"],
+  "paths": {
+ 
+    "/search": {
+      "post": {
+        "operationId": "searchObject",
+        "tags": ["Query"],
+        "produces": ["application/json"],
+        "consumes": ["application/json"],
+        "security": [
+          {
+            "Bearer": []
+          }
+        ],
+        "summary":
+          "Get a list of the algorithms available in the AlgorithmBank instance. By default returns the first 10 results.",
+        "parameters": [
+          {
+            "name": "query",
+            "in": "body",
+            "required": true,
+            "schema": {
+              "$ref": "./models/query.json#/Query"
+            }
+          }
+        ], 
+        "responses": {
+          "200": {
+            "description": "OK",
+            "schema": {
+              "type": "string"
+            }
+          },
+          "400": {
+            "description": "Invalid parameters."
+          },
+          "401": {
+            "description": "Unauthenticated."
+          },
+          "403": {
+            "description": "User is not authorized to perform the action",
+            "schema": {
+              "type": "string"
+            }
+          },
+          "500": {
+            "description": "Internal Server Error",
+            "schema": {
+              "type": "string"
+            }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+
+  }
+}
+
diff --git a/vendor/github.com/go-openapi/analysis/fixtures/enums.yml b/vendor/github.com/go-openapi/analysis/fixtures/enums.yml
new file mode 100644
index 00000000..ab1f91eb
--- /dev/null
+++ b/vendor/github.com/go-openapi/analysis/fixtures/enums.yml
@@ -0,0 +1,185 @@
+---
+swagger: "2.0"
+info:
+  version: "0.1.0"
+  title: reference analysis
+
+parameters:
+  idParam:
+    name: id
+    in: path
+    type: string
+    pattern: 'a[A-Za-Z0-9]+'
+    enum:
+      - aA
+      - b9
+      - c3
+
+responses:
+  notFound:
+    headers:
+      ContentLength:
+        type: string
+        pattern: '[0-9]+'
+        enum:
+          - '1234'
+          - '123'
+    schema:
+      $ref: "#/definitions/error"
+
+paths:
+  "/some/where/{id}":
+    parameters:
+      - $ref: "#/parameters/idParam"
+      - name: name
+        in: query
+        pattern: 'b[A-Za-z0-9]+'
+        enum:
+          - bA
+          - ba
+          - b9
+      - name: bodyId
+        in: body
+        schema:
+          type: object
+    get:
+      parameters:
+      - name: filter
+        in: query
+        type: string
+        pattern: "[abc][0-9]+"
+        enum:
+          - a0
+          - b1
+          - c2
+      - name: other
+        in: query
+        type: array
+        items:
+          type: string
+          pattern: 'c[A-Za-z0-9]+'
+          enum:
+            - cA
+            - cz
+            - c9
+        enum:
+          -
+            - cA
+            - cz
+            - c9
+          -
+            - cA
+            - cz
+          -
+            - cz
+            - c9
+      - name: body
+        in: body
+        schema:
+          type: object
+          enum:
+            - '{"a": 10, "b": 20}'
+            - '{"a": 11, "d": "zzz"}'
+            
+      responses:
+        default:
+          schema:
+            type: object
+        404:
+          $ref: "#/responses/notFound"
+        200:
+          headers:
+            X-Request-Id:
+              type: string
+              pattern: 'd[A-Za-z0-9]+'
+              enum:
+                - dA
+                - d9
+          schema:
+            $ref: "#/definitions/tag"
+  "/other/place":
+    post:
+      parameters:
+        - name: body
+          in: body
+          schema:
+            type: object
+            properties:
+              value:
+                type: string
+                pattern: 'e[A-Za-z0-9]+'
+                enum:
+                  - eA
+                  - e9
+      responses:
+        default:
+          headers:
+            Via:
+              type: array
+              items:
+                type: string
+                pattern: '[A-Za-z]+'
+                enum:
+                  - AA
+                  - Ab
+        200:
+          schema:
+            type: object
+            properties:
+              data:
+                type: string
+                pattern: "[0-9]+[abd]"
+                enum:
+                  - 123a
+                  - 123b
+                  - 123d
+definitions:
+  named:
+    type: string
+    pattern: 'f[A-Za-z0-9]+'
+    enum:
+      - fA
+      - f9
+  tag:
+    type: object
+    properties:
+      id:
+        type: integer
+        format: int64
+      value:
+        type: string
+        pattern: 'g[A-Za-z0-9]+'
+        enum:
+          - gA
+          - ga
+          - g9
+      audit:
+        $ref: "#/definitions/record"
+  record:
+    type: object
+    properties:
+      createdAt:
+        type: string
+        format: date
+    enum:
+      - '{"createdAt": "2018-08-31"}'
+      - '{"createdAt": "2018-09-30"}'
+  error:
+    type: object
+    required:
+      - id
+      - message
+    properties:
+      id:
+        type: integer
+        format: int64
+        readOnly: true
+      message:
+        type: string
+        readOnly: true
+  withPatternProperties:
+    type: object
+    additionalProperties: true
+    patternProperties:
+      '^prop[0-9]+$':
+        type: string
diff --git a/vendor/github.com/go-openapi/analysis/flatten.go b/vendor/github.com/go-openapi/analysis/flatten.go
index 5d98f218..0095e825 100644
--- a/vendor/github.com/go-openapi/analysis/flatten.go
+++ b/vendor/github.com/go-openapi/analysis/flatten.go
@@ -75,12 +75,14 @@ type newRef struct {
 type context struct {
 	newRefs  map[string]*newRef
 	warnings []string
+	resolved map[string]string
 }
 
 func newContext() *context {
 	return &context{
 		newRefs:  make(map[string]*newRef, 150),
 		warnings: make([]string, 0),
+		resolved: make(map[string]string, 50),
 	}
 }
 
@@ -141,8 +143,9 @@ func Flatten(opts FlattenOpts) error {
 
 	opts.flattenContext = newContext()
 
-	// recursively expand responses, parameters, path items and items in simple schemas
-	// TODO: we should not expand discriminated types
+	// recursively expand responses, parameters, path items and items in simple schemas.
+	// This simplifies the spec and leaves $ref only into schema objects.
+	//
 	if err := swspec.ExpandSpec(opts.Swagger(), opts.ExpandOpts(!opts.Expand)); err != nil {
 		return err
 	}
@@ -163,10 +166,13 @@ func Flatten(opts FlattenOpts) error {
 	opts.Spec.reload() // re-analyze
 
 	// at this point there are no other references left but schemas
-	if err := importExternalReferences(&opts); err != nil {
-		return err
+	for imported := false; !imported; {
+		var err error
+		if imported, err = importExternalReferences(&opts); err != nil {
+			return err
+		}
+		opts.Spec.reload() // re-analyze
 	}
-	opts.Spec.reload() // re-analyze
 
 	if !opts.Minimal && !opts.Expand {
 		// full flattening: rewrite inline schemas (schemas that aren't simple types or arrays or maps)
@@ -176,7 +182,6 @@ func Flatten(opts FlattenOpts) error {
 
 		opts.Spec.reload() // re-analyze
 	}
-
 	// rewrite JSON pointers other than $ref to named definitions
 	// and attempts to resolve conflicting names
 	if err := stripPointersAndOAIGen(&opts); err != nil {
@@ -512,7 +517,10 @@ const (
 	definitionsPath = "#/definitions"
 )
 
-var ignoredKeys map[string]struct{}
+var (
+	ignoredKeys  map[string]struct{}
+	validMethods map[string]struct{}
+)
 
 func init() {
 	ignoredKeys = map[string]struct{}{
@@ -522,6 +530,16 @@ func init() {
 		"anyOf":      {},
 		"oneOf":      {},
 	}
+
+	validMethods = map[string]struct{}{
+		"GET":     {},
+		"HEAD":    {},
+		"OPTIONS": {},
+		"PATCH":   {},
+		"POST":    {},
+		"PUT":     {},
+		"DELETE":  {},
+	}
 }
 
 type splitKey []string
@@ -619,26 +637,12 @@ func (s splitKey) ResponseName() string {
 	return ""
 }
 
-var validMethods map[string]struct{}
-
-func init() {
-	validMethods = map[string]struct{}{
-		"GET":     {},
-		"HEAD":    {},
-		"OPTIONS": {},
-		"PATCH":   {},
-		"POST":    {},
-		"PUT":     {},
-		"DELETE":  {},
-	}
-}
-
 func (s splitKey) PathItemRef() swspec.Ref {
 	if len(s) < 3 {
 		return swspec.Ref{}
 	}
 	pth, method := s[1], s[2]
-	if _, validMethod := validMethods[strings.ToUpper(method)]; !validMethod && !strings.HasPrefix(method, "x-") {
+	if _, isValidMethod := validMethods[strings.ToUpper(method)]; !isValidMethod && !strings.HasPrefix(method, "x-") {
 		return swspec.Ref{}
 	}
 	return swspec.MustCreateRef("#" + slashpath.Join("/", paths, jsonpointer.Escape(pth), strings.ToUpper(method)))
@@ -777,9 +781,12 @@ func cloneSchema(schema *swspec.Schema) (*swspec.Schema, error) {
 	return &sch, nil
 }
 
-func importExternalReferences(opts *FlattenOpts) error {
+func importExternalReferences(opts *FlattenOpts) (bool, error) {
 	groupedRefs := reverseIndexForSchemaRefs(opts)
 	sortedRefStr := make([]string, 0, len(groupedRefs))
+	if opts.flattenContext == nil {
+		opts.flattenContext = newContext()
+	}
 
 	// sort $ref resolution to ensure deterministic name conflict resolution
 	for refStr := range groupedRefs {
@@ -787,35 +794,53 @@ func importExternalReferences(opts *FlattenOpts) error {
 	}
 	sort.Strings(sortedRefStr)
 
+	complete := true
 	for _, refStr := range sortedRefStr {
 		entry := groupedRefs[refStr]
 		if !entry.Ref.HasFragmentOnly {
-			debugLog("importing external schema for [%s] from %s", strings.Join(entry.Keys, ", "), refStr)
-			// resolve to actual schema
-			sch := new(swspec.Schema)
-			sch.Ref = entry.Ref
-			if err := swspec.ExpandSchemaWithBasePath(sch, nil, opts.ExpandOpts(false)); err != nil {
-				return err
-			}
-			if sch == nil {
-				return fmt.Errorf("no schema found at %s for [%s]", refStr, strings.Join(entry.Keys, ", "))
-			}
-			debugLog("importing external schema for [%s] from %s", strings.Join(entry.Keys, ", "), refStr)
-
-			// generate a unique name - isOAIGen means that a naming conflict was resolved by changing the name
-			newName, isOAIGen := uniqifyName(opts.Swagger().Definitions, nameFromRef(entry.Ref))
-			debugLog("new name for [%s]: %s - with name conflict:%t",
-				strings.Join(entry.Keys, ", "), newName, isOAIGen)
+			complete = false
+			var isOAIGen bool
+
+			newName := opts.flattenContext.resolved[refStr]
+			if newName != "" {
+				// rewrite ref with already resolved external ref (useful for cyclicali refs)
+				debugLog("resolving known ref [%s] to %s", refStr, newName)
+				// rewrite the external refs to local ones
+				for _, key := range entry.Keys {
+					if err := updateRef(opts.Swagger(), key,
+						swspec.MustCreateRef(slashpath.Join(definitionsPath, newName))); err != nil {
+						return false, err
+					}
+				}
+			} else {
+				debugLog("importing external schema for [%s] from %s", strings.Join(entry.Keys, ", "), refStr)
 
-			// rewrite the external refs to local ones
-			for _, key := range entry.Keys {
-				if err := updateRef(opts.Swagger(), key,
-					swspec.MustCreateRef(slashpath.Join(definitionsPath, newName))); err != nil {
-					return err
+				// resolve to actual schema
+				sch := new(swspec.Schema)
+				sch.Ref = entry.Ref
+				if err := swspec.ExpandSchemaWithBasePath(sch, nil, opts.ExpandOpts(false)); err != nil {
+					return false, err
+				}
+				if sch == nil {
+					return false, fmt.Errorf("no schema found at %s for [%s]", refStr, strings.Join(entry.Keys, ", "))
 				}
+				debugLog("importing external schema for [%s] from %s", strings.Join(entry.Keys, ", "), refStr)
 
-				// keep track of created refs
-				if opts.flattenContext != nil {
+				// generate a unique name - isOAIGen means that a naming conflict was resolved by changing the name
+				newName, isOAIGen = uniqifyName(opts.Swagger().Definitions, nameFromRef(entry.Ref))
+				debugLog("new name for [%s]: %s - with name conflict:%t",
+					strings.Join(entry.Keys, ", "), newName, isOAIGen)
+
+				opts.flattenContext.resolved[refStr] = newName
+
+				// rewrite the external refs to local ones
+				for _, key := range entry.Keys {
+					if err := updateRef(opts.Swagger(), key,
+						swspec.MustCreateRef(slashpath.Join(definitionsPath, newName))); err != nil {
+						return false, err
+					}
+
+					// keep track of created refs
 					resolved := false
 					if _, ok := opts.flattenContext.newRefs[key]; ok {
 						resolved = opts.flattenContext.newRefs[key].resolved
@@ -829,13 +854,13 @@ func importExternalReferences(opts *FlattenOpts) error {
 						schema:   sch,
 					}
 				}
-			}
 
-			// add the resolved schema to the definitions
-			saveSchema(opts.Swagger(), newName, sch)
+				// add the resolved schema to the definitions
+				saveSchema(opts.Swagger(), newName, sch)
+			}
 		}
 	}
-	return nil
+	return complete, nil
 }
 
 type refRevIdx struct {
@@ -1259,7 +1284,6 @@ func croak(opts *FlattenOpts) {
 func namePointers(opts *FlattenOpts) error {
 	debugLog("name pointers")
 	refsToReplace := make(map[string]SchemaRef, len(opts.Spec.references.schemas))
-	//for k, ref := range opts.Spec.references.schemas {
 	for k, ref := range opts.Spec.references.allRefs {
 		if slashpath.Dir(ref.String()) == definitionsPath {
 			// this a ref to a top-level definition: ok
@@ -1377,6 +1401,7 @@ func namePointers(opts *FlattenOpts) error {
 // NOTE: all external $ref's are assumed to be already expanded at this stage.
 func deepestRef(opts *FlattenOpts, ref swspec.Ref) (swspec.Ref, *swspec.Schema, error) {
 	if !ref.HasFragmentOnly {
+		// we found an external $ref, which is odd
 		// does nothing on external $refs
 		return ref, nil, nil
 	}
diff --git a/vendor/github.com/go-openapi/analysis/flatten_test.go b/vendor/github.com/go-openapi/analysis/flatten_test.go
index 1d08a31d..bf5d1b88 100644
--- a/vendor/github.com/go-openapi/analysis/flatten_test.go
+++ b/vendor/github.com/go-openapi/analysis/flatten_test.go
@@ -137,7 +137,7 @@ func TestImportExternalReferences(t *testing.T) {
 			// technically not necessary to run for each value, but if things go right
 			// this is idempotent, so having it repeat shouldn't matter
 			// this validates that behavior
-			err := importExternalReferences(&FlattenOpts{
+			_, err := importExternalReferences(&FlattenOpts{
 				Spec:     New(sp),
 				BasePath: bp,
 			})
@@ -1845,3 +1845,63 @@ func Test_NormalizePath(t *testing.T) {
 			&FlattenOpts{BasePath: "/abs/to/spec/spec.json"}))
 	}
 }
+
+func TestFlatten_Issue_1796(t *testing.T) {
+	// remote cyclic ref
+	bp := filepath.Join("fixtures", "bugs", "1796", "queryIssue.json")
+	sp := loadOrFail(t, bp)
+	an := New(sp)
+	err := Flatten(FlattenOpts{Spec: an, BasePath: bp, Verbose: true, Minimal: true, Expand: false,
+		RemoveUnused: false})
+	assert.NoError(t, err)
+	//bbb, _ := json.MarshalIndent(an.spec, "", " ")
+	//t.Logf("%s", string(bbb))
+	//t.Logf("%s", an.AllDefinitionReferences())
+
+	// assert all $ref match  "$ref": "#/definitions/something"
+	for _, ref := range an.AllReferences() {
+		assert.True(t, strings.HasPrefix(ref, "#/definitions"))
+	}
+}
+
+func TestFlatten_Issue_1767(t *testing.T) {
+	// remote cyclic ref again
+	bp := filepath.Join("fixtures", "bugs", "1767", "fixture-1767.yaml")
+	sp := loadOrFail(t, bp)
+	an := New(sp)
+	err := Flatten(FlattenOpts{Spec: an, BasePath: bp, Verbose: true, Minimal: true, Expand: false,
+		RemoveUnused: false})
+	assert.NoError(t, err)
+	// assert all $ref match  "$ref": "#/definitions/something"
+	for _, ref := range an.AllReferences() {
+		assert.True(t, strings.HasPrefix(ref, "#/definitions"))
+	}
+}
+
+func TestFlatten_Issue_1774(t *testing.T) {
+	// remote cyclic ref again
+	bp := filepath.Join("fixtures", "bugs", "1774", "def_api.yaml")
+	sp := loadOrFail(t, bp)
+	an := New(sp)
+	err := Flatten(FlattenOpts{Spec: an, BasePath: bp, Verbose: true, Minimal: false, Expand: false,
+		RemoveUnused: false})
+	assert.NoError(t, err)
+	//bbb, _ := json.MarshalIndent(an.spec, "", " ")
+	//t.Logf("%s", string(bbb))
+	//t.Logf("%s", an.AllDefinitionReferences())
+	// assert all $ref match  "$ref": "#/definitions/something"
+	for _, ref := range an.AllReferences() {
+		assert.True(t, strings.HasPrefix(ref, "#/definitions"))
+	}
+}
+
+func TestFlatten_1429(t *testing.T) {
+	// nested / remote $ref in response / param schemas
+	// issue go-swagger/go-swagger#1429
+	bp := filepath.Join("fixtures", "bugs", "1429", "swagger.yaml")
+	sp := loadOrFail(t, bp)
+
+	an := New(sp)
+	err := Flatten(FlattenOpts{Spec: an, BasePath: bp, Verbose: true, Minimal: true, RemoveUnused: false})
+	assert.NoError(t, err)
+}
diff --git a/vendor/github.com/go-openapi/analysis/schema.go b/vendor/github.com/go-openapi/analysis/schema.go
index c0b77c56..afbf932f 100644
--- a/vendor/github.com/go-openapi/analysis/schema.go
+++ b/vendor/github.com/go-openapi/analysis/schema.go
@@ -1,6 +1,8 @@
 package analysis
 
 import (
+	"fmt"
+
 	"github.com/go-openapi/spec"
 	"github.com/go-openapi/strfmt"
 )
@@ -16,6 +18,10 @@ type SchemaOpts struct {
 // Schema analysis, will classify the schema according to known
 // patterns.
 func Schema(opts SchemaOpts) (*AnalyzedSchema, error) {
+	if opts.Schema == nil {
+		return nil, fmt.Errorf("no schema to analyze")
+	}
+
 	a := &AnalyzedSchema{
 		schema:   opts.Schema,
 		root:     opts.Root,
diff --git a/vendor/github.com/go-openapi/analysis/schema_test.go b/vendor/github.com/go-openapi/analysis/schema_test.go
index 59d04d16..0d142d7e 100644
--- a/vendor/github.com/go-openapi/analysis/schema_test.go
+++ b/vendor/github.com/go-openapi/analysis/schema_test.go
@@ -332,3 +332,8 @@ func TestSchemaAnalys_InvalidSchema(t *testing.T) {
 	//bbb, _ := json.MarshalIndent(def, "", " ")
 	//log.Printf(string(bbb))
 }
+
+func TestSchemaAnalysis_EdgeCases(t *testing.T) {
+	_, err := Schema(SchemaOpts{Schema: nil})
+	assert.Error(t, err)
+}
diff --git a/vendor/github.com/go-openapi/errors/.golangci.yml b/vendor/github.com/go-openapi/errors/.golangci.yml
new file mode 100644
index 00000000..0305d9f4
--- /dev/null
+++ b/vendor/github.com/go-openapi/errors/.golangci.yml
@@ -0,0 +1,19 @@
+linters-settings:
+  govet:
+    check-shadowing: true
+  golint:
+    min-confidence: 0
+  gocyclo:
+    min-complexity: 30
+  maligned:
+    suggest-new: true
+  dupl:
+    threshold: 100
+  goconst:
+    min-len: 2
+    min-occurrences: 4
+linters:
+  enable-all: true
+  disable:
+    - maligned
+    - lll
diff --git a/vendor/github.com/go-openapi/errors/api.go b/vendor/github.com/go-openapi/errors/api.go
index d1a752c4..3372e14d 100644
--- a/vendor/github.com/go-openapi/errors/api.go
+++ b/vendor/github.com/go-openapi/errors/api.go
@@ -134,26 +134,26 @@ func ServeError(rw http.ResponseWriter, r *http.Request, err error) {
 		rw.Header().Add("Allow", strings.Join(err.(*MethodNotAllowedError).Allowed, ","))
 		rw.WriteHeader(asHTTPCode(int(e.Code())))
 		if r == nil || r.Method != head {
-			rw.Write(errorAsJSON(e))
+			_, _ = rw.Write(errorAsJSON(e))
 		}
 	case Error:
 		value := reflect.ValueOf(e)
 		if value.Kind() == reflect.Ptr && value.IsNil() {
 			rw.WriteHeader(http.StatusInternalServerError)
-			rw.Write(errorAsJSON(New(http.StatusInternalServerError, "Unknown error")))
+			_, _ = rw.Write(errorAsJSON(New(http.StatusInternalServerError, "Unknown error")))
 			return
 		}
 		rw.WriteHeader(asHTTPCode(int(e.Code())))
 		if r == nil || r.Method != head {
-			rw.Write(errorAsJSON(e))
+			_, _ = rw.Write(errorAsJSON(e))
 		}
 	case nil:
 		rw.WriteHeader(http.StatusInternalServerError)
-		rw.Write(errorAsJSON(New(http.StatusInternalServerError, "Unknown error")))
+		_, _ = rw.Write(errorAsJSON(New(http.StatusInternalServerError, "Unknown error")))
 	default:
 		rw.WriteHeader(http.StatusInternalServerError)
 		if r == nil || r.Method != head {
-			rw.Write(errorAsJSON(New(http.StatusInternalServerError, err.Error())))
+			_, _ = rw.Write(errorAsJSON(New(http.StatusInternalServerError, err.Error())))
 		}
 	}
 }
diff --git a/vendor/github.com/go-openapi/errors/headers.go b/vendor/github.com/go-openapi/errors/headers.go
index a80ddc97..0360c094 100644
--- a/vendor/github.com/go-openapi/errors/headers.go
+++ b/vendor/github.com/go-openapi/errors/headers.go
@@ -54,7 +54,7 @@ const (
 
 // InvalidContentType error for an invalid content type
 func InvalidContentType(value string, allowed []string) *Validation {
-	var values []interface{}
+	values := make([]interface{}, 0, len(allowed))
 	for _, v := range allowed {
 		values = append(values, v)
 	}
@@ -70,7 +70,7 @@ func InvalidContentType(value string, allowed []string) *Validation {
 
 // InvalidResponseFormat error for an unacceptable response format request
 func InvalidResponseFormat(value string, allowed []string) *Validation {
-	var values []interface{}
+	values := make([]interface{}, 0, len(allowed))
 	for _, v := range allowed {
 		values = append(values, v)
 	}
diff --git a/vendor/github.com/go-openapi/errors/schema_test.go b/vendor/github.com/go-openapi/errors/schema_test.go
index 53093f0c..e327aefe 100644
--- a/vendor/github.com/go-openapi/errors/schema_test.go
+++ b/vendor/github.com/go-openapi/errors/schema_test.go
@@ -293,10 +293,10 @@ func TestSchemaErrors(t *testing.T) {
 	assert.EqualValues(t, CompositeErrorCode, err2.Code())
 	assert.Equal(t, "validation failure list", err2.Error())
 
-	err2 = CompositeValidationError(fmt.Errorf("First error"), fmt.Errorf("Second error"))
+	err2 = CompositeValidationError(fmt.Errorf("first error"), fmt.Errorf("second error"))
 	assert.Error(t, err2)
 	assert.EqualValues(t, CompositeErrorCode, err2.Code())
-	assert.Equal(t, "validation failure list:\nFirst error\nSecond error", err2.Error())
+	assert.Equal(t, "validation failure list:\nfirst error\nsecond error", err2.Error())
 
 	//func MultipleOfMustBePositive(name, in string, factor interface{}) *Validation {
 	err = MultipleOfMustBePositive("path", "body", float64(-10))
diff --git a/vendor/github.com/go-openapi/runtime/README.md b/vendor/github.com/go-openapi/runtime/README.md
index 92c40705..5b1ec649 100644
--- a/vendor/github.com/go-openapi/runtime/README.md
+++ b/vendor/github.com/go-openapi/runtime/README.md
@@ -2,4 +2,6 @@
 
 [![license](http://img.shields.io/badge/license-Apache%20v2-orange.svg)](https://raw.githubusercontent.com/go-openapi/runtime/master/LICENSE) [![GoDoc](https://godoc.org/github.com/go-openapi/runtime?status.svg)](http://godoc.org/github.com/go-openapi/runtime)
 
+# golang Open-API toolkit - runtime
+
 The runtime component for use in codegeneration or as untyped usage.
diff --git a/vendor/github.com/go-openapi/strfmt/.golangci.yml b/vendor/github.com/go-openapi/strfmt/.golangci.yml
index 4029779e..a90f7e38 100644
--- a/vendor/github.com/go-openapi/strfmt/.golangci.yml
+++ b/vendor/github.com/go-openapi/strfmt/.golangci.yml
@@ -4,16 +4,17 @@ linters-settings:
   golint:
     min-confidence: 0
   gocyclo:
-    min-complexity: 25
+    min-complexity: 30
   maligned:
     suggest-new: true
   dupl:
     threshold: 100
   goconst:
     min-len: 2
-    min-occurrences: 2
+    min-occurrences: 4
 
 linters:
   enable-all: true
   disable:
     - maligned
+    - lll
diff --git a/vendor/github.com/go-openapi/strfmt/date_test.go b/vendor/github.com/go-openapi/strfmt/date_test.go
index 4a7f215b..40f51742 100644
--- a/vendor/github.com/go-openapi/strfmt/date_test.go
+++ b/vendor/github.com/go-openapi/strfmt/date_test.go
@@ -77,7 +77,7 @@ func TestDate_Scan(t *testing.T) {
 	values := []interface{}{str, []byte(str), ref}
 	for _, value := range values {
 		result := Date{}
-		(&result).Scan(value)
+		_ = (&result).Scan(value)
 		assert.Equal(t, date, result, "value: %#v", value)
 	}
 
diff --git a/vendor/github.com/go-openapi/strfmt/default.go b/vendor/github.com/go-openapi/strfmt/default.go
index 13235ec2..a8cb9bd2 100644
--- a/vendor/github.com/go-openapi/strfmt/default.go
+++ b/vendor/github.com/go-openapi/strfmt/default.go
@@ -49,7 +49,7 @@ const (
 	//  <subdomain> ::= <label> | <subdomain> "." <label>
 	//  var subdomain = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/;
 	//  <domain> ::= <subdomain> | " "
-	HostnamePattern = `^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$`
+	HostnamePattern = `^[a-zA-Z0-9](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$`
 	// UUIDPattern Regex for UUID that allows uppercase
 	UUIDPattern = `(?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$`
 	// UUID3Pattern Regex for UUID3 that allows uppercase
@@ -112,7 +112,7 @@ func IsUUID5(str string) bool {
 	return rxUUID5.MatchString(str)
 }
 
-// Validates an email address.
+// IsEmail validates an email address.
 func IsEmail(str string) bool {
 	addr, e := mail.ParseAddress(str)
 	return e == nil && addr.Address != ""
@@ -197,13 +197,7 @@ func init() {
 	Default.Add("password", &pw, func(_ string) bool { return true })
 }
 
-/* unused:
-var formatCheckers = map[string]Validator{
-	"byte": govalidator.IsBase64,
-}
-*/
-
-// Base64 represents a base64 encoded string
+// Base64 represents a base64 encoded string, using URLEncoding alphabet
 //
 // swagger:strfmt byte
 type Base64 []byte
diff --git a/vendor/github.com/go-openapi/strfmt/default_test.go b/vendor/github.com/go-openapi/strfmt/default_test.go
index 0dc940ac..09d074ab 100644
--- a/vendor/github.com/go-openapi/strfmt/default_test.go
+++ b/vendor/github.com/go-openapi/strfmt/default_test.go
@@ -15,6 +15,13 @@
 package strfmt
 
 import (
+	"database/sql"
+	"database/sql/driver"
+	"encoding"
+	"encoding/json"
+	"fmt"
+	"reflect"
+	"strings"
 	"testing"
 
 	"github.com/globalsign/mgo/bson"
@@ -22,87 +29,15 @@ import (
 	"github.com/stretchr/testify/assert"
 )
 
-func testValid(t *testing.T, name, value string) {
-	ok := Default.Validates(name, value)
-	if !ok {
-		t.Errorf("expected %s of type %s to be valid", value, name)
-	}
-}
-
-func testInvalid(t *testing.T, name, value string) {
-	ok := Default.Validates(name, value)
-	if ok {
-		t.Errorf("expected %s of type %s to be invalid", value, name)
-	}
-}
-
 func TestFormatURI(t *testing.T) {
 	uri := URI("http://somewhere.com")
-	str := string("http://somewhereelse.com")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := uri.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, URI("http://somewhereelse.com"), string(b))
-
-	b, err = uri.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("http://somewhereelse.com"), b)
-
-	err = uri.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, URI("http://somewhereelse.com"), string(b))
-
-	b, err = uri.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&uri)
-	assert.NoError(t, err)
-
-	var uriCopy URI
-	err = bson.Unmarshal(bsonData, &uriCopy)
-	assert.NoError(t, err)
-	assert.Equal(t, uri, uriCopy)
-
-	testValid(t, "uri", str)
-	testInvalid(t, "uri", "somewhere.com")
+	str := "http://somewhereelse.com"
+	testStringFormat(t, &uri, "uri", str, []string{}, []string{"somewhere.com"})
 }
 
 func TestFormatEmail(t *testing.T) {
 	email := Email("somebody@somewhere.com")
 	str := string("somebodyelse@somewhere.com")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := email.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, Email("somebodyelse@somewhere.com"), string(b))
-
-	b, err = email.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("somebodyelse@somewhere.com"), b)
-
-	err = email.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, Email(str), string(b))
-
-	b, err = email.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&email)
-	assert.NoError(t, err)
-
-	var emailCopy Email
-	err = bson.Unmarshal(bsonData, &emailCopy)
-	assert.NoError(t, err)
-	assert.Equal(t, email, emailCopy)
-
-	testValid(t, "email", str)
-	testInvalid(t, "email", "somebody@somewhere@com")
-
 	validEmails := []string{
 		"blah@gmail.com",
 		"test@d.verylongtoplevel",
@@ -124,184 +59,57 @@ func TestFormatEmail(t *testing.T) {
 		"api@piston.ninja",
 	}
 
-	for _, eml := range validEmails {
-		testValid(t, "email", eml)
-	}
+	testStringFormat(t, &email, "email", str, validEmails, []string{"somebody@somewhere@com"})
 }
 
 func TestFormatHostname(t *testing.T) {
 	hostname := Hostname("somewhere.com")
 	str := string("somewhere.com")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := hostname.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, Hostname("somewhere.com"), string(b))
-
-	b, err = hostname.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("somewhere.com"), b)
-
-	err = hostname.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, Hostname(str), string(b))
-
-	b, err = hostname.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&hostname)
-	assert.NoError(t, err)
-
-	var hostnameCopy Hostname
-	err = bson.Unmarshal(bsonData, &hostnameCopy)
-	assert.NoError(t, err)
-	assert.Equal(t, hostname, hostnameCopy)
-
-	testValid(t, "hostname", str)
-	testInvalid(t, "hostname", "somewhere.com!")
+	veryLongStr := strings.Repeat("a", 256)
+	longStr := strings.Repeat("a", 64)
+	longAddrSegment := strings.Join([]string{"x", "y", longStr}, ".")
+	invalidHostnames := []string{
+		"somewhere.com!",
+		veryLongStr,
+		longAddrSegment,
+	}
+	validHostnames := []string{
+		"somewhere.com",
+		"888.com",
+	}
+	testStringFormat(t, &hostname, "hostname", str, []string{}, invalidHostnames)
+	testStringFormat(t, &hostname, "hostname", str, validHostnames, []string{})
 }
 
 func TestFormatIPv4(t *testing.T) {
 	ipv4 := IPv4("192.168.254.1")
 	str := string("192.168.254.2")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := ipv4.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, IPv4("192.168.254.2"), string(b))
-
-	b, err = ipv4.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("192.168.254.2"), b)
-
-	err = ipv4.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, IPv4(str), string(b))
-
-	b, err = ipv4.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&ipv4)
-	assert.NoError(t, err)
-
-	var ipv4Copy IPv4
-	err = bson.Unmarshal(bsonData, &ipv4Copy)
-	assert.NoError(t, err)
-	assert.Equal(t, ipv4, ipv4Copy)
-
-	testValid(t, "ipv4", str)
-	testInvalid(t, "ipv4", "192.168.254.2.2")
+	testStringFormat(t, &ipv4, "ipv4", str, []string{}, []string{"198.168.254.2.2"})
 }
 
 func TestFormatIPv6(t *testing.T) {
 	ipv6 := IPv6("::1")
 	str := string("::2")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := ipv6.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, IPv6("::2"), string(b))
-
-	b, err = ipv6.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("::2"), b)
-
-	err = ipv6.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, IPv6(str), string(b))
-
-	b, err = ipv6.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&ipv6)
-	assert.NoError(t, err)
-
-	var ipv6Copy IPv6
-	err = bson.Unmarshal(bsonData, &ipv6Copy)
-	assert.NoError(t, err)
-	assert.Equal(t, ipv6, ipv6Copy)
-
-	testValid(t, "ipv6", str)
-	testInvalid(t, "ipv6", "127.0.0.1")
+	// TODO: test ipv6 zones
+	testStringFormat(t, &ipv6, "ipv6", str, []string{}, []string{"127.0.0.1"})
 }
 
 func TestFormatMAC(t *testing.T) {
 	mac := MAC("01:02:03:04:05:06")
 	str := string("06:05:04:03:02:01")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := mac.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, MAC("06:05:04:03:02:01"), string(b))
-
-	b, err = mac.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("06:05:04:03:02:01"), b)
-
-	err = mac.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, MAC(str), string(b))
-
-	b, err = mac.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&mac)
-	assert.NoError(t, err)
-
-	var macCopy MAC
-	err = bson.Unmarshal(bsonData, &macCopy)
-	assert.NoError(t, err)
-	assert.Equal(t, mac, macCopy)
-
-	testValid(t, "mac", str)
-	testInvalid(t, "mac", "01:02:03:04:05")
+	testStringFormat(t, &mac, "mac", str, []string{}, []string{"01:02:03:04:05"})
 }
 
 func TestFormatUUID3(t *testing.T) {
 	first3 := uuid.NewMD5(uuid.NameSpace_URL, []byte("somewhere.com"))
 	other3 := uuid.NewMD5(uuid.NameSpace_URL, []byte("somewhereelse.com"))
 	uuid3 := UUID3(first3.String())
-	str := string(other3.String())
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := uuid3.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, UUID3(other3.String()), string(b))
-
-	b, err = uuid3.MarshalText()
-	assert.NoError(t, err)
-	assert.EqualValues(t, []byte(other3.String()), b)
-
-	err = uuid3.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, UUID3(str), string(b))
-
-	b, err = uuid3.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&uuid3)
-	assert.NoError(t, err)
-
-	var uuid3Copy UUID3
-	err = bson.Unmarshal(bsonData, &uuid3Copy)
-	assert.NoError(t, err)
-	assert.Equal(t, uuid3, uuid3Copy)
-
-	testValid(t, "uuid3", str)
-	testInvalid(t, "uuid3", "not-a-uuid")
+	str := other3.String()
+	testStringFormat(t, &uuid3, "uuid3", str, []string{}, []string{"not-a-uuid"})
 
+	// special case for zero UUID
 	var uuidZero UUID3
-	err = uuidZero.UnmarshalJSON([]byte(jsonNull))
+	err := uuidZero.UnmarshalJSON([]byte(jsonNull))
 	assert.NoError(t, err)
 	assert.EqualValues(t, UUID3(""), uuidZero)
 }
@@ -310,39 +118,12 @@ func TestFormatUUID4(t *testing.T) {
 	first4 := uuid.NewRandom()
 	other4 := uuid.NewRandom()
 	uuid4 := UUID4(first4.String())
-	str := string(other4.String())
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := uuid4.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, UUID4(other4.String()), string(b))
-
-	b, err = uuid4.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte(other4.String()), b)
-
-	err = uuid4.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, UUID4(str), string(b))
-
-	b, err = uuid4.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&uuid4)
-	assert.NoError(t, err)
-
-	var uuid4Copy UUID4
-	err = bson.Unmarshal(bsonData, &uuid4Copy)
-	assert.NoError(t, err)
-	assert.Equal(t, uuid4, uuid4Copy)
-
-	testValid(t, "uuid4", str)
-	testInvalid(t, "uuid4", "not-a-uuid")
+	str := other4.String()
+	testStringFormat(t, &uuid4, "uuid4", str, []string{}, []string{"not-a-uuid"})
 
+	// special case for zero UUID
 	var uuidZero UUID4
-	err = uuidZero.UnmarshalJSON([]byte(jsonNull))
+	err := uuidZero.UnmarshalJSON([]byte(jsonNull))
 	assert.NoError(t, err)
 	assert.EqualValues(t, UUID4(""), uuidZero)
 }
@@ -351,39 +132,12 @@ func TestFormatUUID5(t *testing.T) {
 	first5 := uuid.NewSHA1(uuid.NameSpace_URL, []byte("somewhere.com"))
 	other5 := uuid.NewSHA1(uuid.NameSpace_URL, []byte("somewhereelse.com"))
 	uuid5 := UUID5(first5.String())
-	str := string(other5.String())
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := uuid5.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, UUID5(other5.String()), string(b))
-
-	b, err = uuid5.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte(other5.String()), b)
-
-	err = uuid5.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, UUID5(str), string(b))
-
-	b, err = uuid5.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&uuid5)
-	assert.NoError(t, err)
-
-	var uuid5Copy UUID5
-	err = bson.Unmarshal(bsonData, &uuid5Copy)
-	assert.NoError(t, err)
-	assert.Equal(t, uuid5, uuid5Copy)
-
-	testValid(t, "uuid5", str)
-	testInvalid(t, "uuid5", "not-a-uuid")
+	str := other5.String()
+	testStringFormat(t, &uuid5, "uuid5", str, []string{}, []string{"not-a-uuid"})
 
+	// special case for zero UUID
 	var uuidZero UUID5
-	err = uuidZero.UnmarshalJSON([]byte(jsonNull))
+	err := uuidZero.UnmarshalJSON([]byte(jsonNull))
 	assert.NoError(t, err)
 	assert.EqualValues(t, UUID5(""), uuidZero)
 }
@@ -392,39 +146,12 @@ func TestFormatUUID(t *testing.T) {
 	first5 := uuid.NewSHA1(uuid.NameSpace_URL, []byte("somewhere.com"))
 	other5 := uuid.NewSHA1(uuid.NameSpace_URL, []byte("somewhereelse.com"))
 	uuid := UUID(first5.String())
-	str := string(other5.String())
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := uuid.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, UUID(other5.String()), string(b))
-
-	b, err = uuid.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte(other5.String()), b)
-
-	err = uuid.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, UUID(str), string(b))
-
-	b, err = uuid.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&uuid)
-	assert.NoError(t, err)
-
-	var uuidCopy UUID
-	err = bson.Unmarshal(bsonData, &uuidCopy)
-	assert.NoError(t, err)
-	assert.Equal(t, uuid, uuidCopy)
-
-	testValid(t, "uuid", str)
-	testInvalid(t, "uuid", "not-a-uuid")
+	str := other5.String()
+	testStringFormat(t, &uuid, "uuid", str, []string{}, []string{"not-a-uuid"})
 
+	// special case for zero UUID
 	var uuidZero UUID
-	err = uuidZero.UnmarshalJSON([]byte(jsonNull))
+	err := uuidZero.UnmarshalJSON([]byte(jsonNull))
 	assert.NoError(t, err)
 	assert.EqualValues(t, UUID(""), uuidZero)
 }
@@ -432,305 +159,214 @@ func TestFormatUUID(t *testing.T) {
 func TestFormatISBN(t *testing.T) {
 	isbn := ISBN("0321751043")
 	str := string("0321751043")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := isbn.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, ISBN("0321751043"), string(b))
-
-	b, err = isbn.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("0321751043"), b)
-
-	err = isbn.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, ISBN(str), string(b))
-
-	b, err = isbn.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&isbn)
-	assert.NoError(t, err)
-
-	var isbnCopy ISBN
-	err = bson.Unmarshal(bsonData, &isbnCopy)
-	assert.NoError(t, err)
-	assert.Equal(t, isbn, isbnCopy)
-
-	testValid(t, "isbn", str)
-	testInvalid(t, "isbn", "836217463") // bad checksum
+	testStringFormat(t, &isbn, "isbn", str, []string{}, []string{"836217463"}) // bad checksum
 }
 
 func TestFormatISBN10(t *testing.T) {
 	isbn10 := ISBN10("0321751043")
 	str := string("0321751043")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := isbn10.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, ISBN10("0321751043"), string(b))
-
-	b, err = isbn10.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("0321751043"), b)
-
-	err = isbn10.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, ISBN10(str), string(b))
-
-	b, err = isbn10.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&isbn10)
-	assert.NoError(t, err)
-
-	var isbn10Copy ISBN10
-	err = bson.Unmarshal(bsonData, &isbn10Copy)
-	assert.NoError(t, err)
-	assert.Equal(t, isbn10, isbn10Copy)
-
-	testValid(t, "isbn10", str)
-	testInvalid(t, "isbn10", "836217463") // bad checksum
+	testStringFormat(t, &isbn10, "isbn10", str, []string{}, []string{"836217463"}) // bad checksum
 }
 
 func TestFormatISBN13(t *testing.T) {
 	isbn13 := ISBN13("978-0321751041")
 	str := string("978-0321751041")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := isbn13.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, ISBN13("978-0321751041"), string(b))
-
-	b, err = isbn13.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("978-0321751041"), b)
-
-	err = isbn13.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, ISBN13(str), string(b))
-
-	b, err = isbn13.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&isbn13)
-	assert.NoError(t, err)
-
-	var isbn13Copy ISBN13
-	err = bson.Unmarshal(bsonData, &isbn13Copy)
-	assert.NoError(t, err)
-	assert.Equal(t, isbn13, isbn13Copy)
-
-	testValid(t, "isbn13", str)
-	testInvalid(t, "isbn13", "978-0321751042") // bad checksum
+	testStringFormat(t, &isbn13, "isbn13", str, []string{}, []string{"978-0321751042"}) // bad checksum
 }
 
 func TestFormatHexColor(t *testing.T) {
 	hexColor := HexColor("#FFFFFF")
 	str := string("#000000")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := hexColor.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, HexColor("#000000"), string(b))
-
-	b, err = hexColor.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("#000000"), b)
-
-	err = hexColor.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, HexColor(str), string(b))
-
-	b, err = hexColor.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&hexColor)
-	assert.NoError(t, err)
-
-	var hexColorCopy HexColor
-	err = bson.Unmarshal(bsonData, &hexColorCopy)
-	assert.NoError(t, err)
-	assert.Equal(t, hexColor, hexColorCopy)
-
-	testValid(t, "hexcolor", str)
-	testInvalid(t, "hexcolor", "#fffffffz")
+	testStringFormat(t, &hexColor, "hexcolor", str, []string{}, []string{"#fffffffz"})
 }
 
 func TestFormatRGBColor(t *testing.T) {
 	rgbColor := RGBColor("rgb(255,255,255)")
 	str := string("rgb(0,0,0)")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := rgbColor.UnmarshalText(b)
-	assert.NoError(t, err)
-	assert.EqualValues(t, RGBColor("rgb(0,0,0)"), string(b))
-
-	b, err = rgbColor.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("rgb(0,0,0)"), b)
-
-	err = rgbColor.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, RGBColor(str), string(b))
-
-	b, err = rgbColor.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&rgbColor)
-	assert.NoError(t, err)
-
-	var rgbColorCopy RGBColor
-	err = bson.Unmarshal(bsonData, &rgbColorCopy)
-	assert.NoError(t, err)
-	assert.Equal(t, rgbColor, rgbColorCopy)
-
-	testValid(t, "rgbcolor", str)
-	testInvalid(t, "rgbcolor", "rgb(300,0,0)")
+	testStringFormat(t, &rgbColor, "rgbcolor", str, []string{}, []string{"rgb(300,0,0)"})
 }
 
 func TestFormatSSN(t *testing.T) {
 	ssn := SSN("111-11-1111")
 	str := string("999 99 9999")
+	testStringFormat(t, &ssn, "ssn", str, []string{}, []string{"999 99 999"})
+}
+
+func TestFormatCreditCard(t *testing.T) {
+	creditCard := CreditCard("4111-1111-1111-1111")
+	str := string("4012-8888-8888-1881")
+	testStringFormat(t, &creditCard, "creditcard", str, []string{}, []string{"9999-9999-9999-999"})
+}
+
+func TestFormatPassword(t *testing.T) {
+	password := Password("super secret stuff here")
+	testStringFormat(t, &password, "password", "super secret!!!", []string{"even more secret"}, []string{})
+}
+
+func TestFormatBase64(t *testing.T) {
+	b64 := Base64("ZWxpemFiZXRocG9zZXk=")
+	str := string("ZWxpemFiZXRocG9zZXk=")
 	b := []byte(str)
 	bj := []byte("\"" + str + "\"")
 
-	err := ssn.UnmarshalText(b)
+	err := b64.UnmarshalText(b)
 	assert.NoError(t, err)
-	assert.EqualValues(t, SSN("999 99 9999"), string(b))
+	assert.EqualValues(t, Base64("ZWxpemFiZXRocG9zZXk="), string(b))
 
-	b, err = ssn.MarshalText()
+	b, err = b64.MarshalText()
 	assert.NoError(t, err)
-	assert.Equal(t, []byte("999 99 9999"), b)
+	assert.Equal(t, []byte("ZWxpemFiZXRocG9zZXk="), b)
 
-	err = ssn.UnmarshalJSON(bj)
+	err = b64.UnmarshalJSON(bj)
 	assert.NoError(t, err)
-	assert.EqualValues(t, SSN(str), string(b))
+	assert.EqualValues(t, Base64(str), string(b))
 
-	b, err = ssn.MarshalJSON()
+	b, err = b64.MarshalJSON()
 	assert.NoError(t, err)
 	assert.Equal(t, bj, b)
 
-	bsonData, err := bson.Marshal(&ssn)
-	assert.NoError(t, err)
-
-	var ssnCopy SSN
-	err = bson.Unmarshal(bsonData, &ssnCopy)
-	assert.NoError(t, err)
-	assert.Equal(t, ssn, ssnCopy)
-
-	testValid(t, "ssn", str)
-	testInvalid(t, "ssn", "999 99 999")
-}
-
-func TestFormatCreditCard(t *testing.T) {
-	creditCard := CreditCard("4111-1111-1111-1111")
-	str := string("4012-8888-8888-1881")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
-
-	err := creditCard.UnmarshalText(b)
+	bsonData, err := bson.Marshal(&b64)
 	assert.NoError(t, err)
-	assert.EqualValues(t, CreditCard("4012-8888-8888-1881"), string(b))
 
-	b, err = creditCard.MarshalText()
+	var b64Copy Base64
+	err = bson.Unmarshal(bsonData, &b64Copy)
 	assert.NoError(t, err)
-	assert.Equal(t, []byte("4012-8888-8888-1881"), b)
+	assert.Equal(t, b64, b64Copy)
 
-	err = creditCard.UnmarshalJSON(bj)
-	assert.NoError(t, err)
-	assert.EqualValues(t, CreditCard(str), string(b))
+	testValid(t, "byte", str)
+	testInvalid(t, "byte", "ZWxpemFiZXRocG9zZXk") // missing pad char
 
-	b, err = creditCard.MarshalJSON()
+	// Valuer interface
+	b64 = Base64("ZWxpemFiZXRocG9zZXk=")
+	sqlvalue, err := b64.Value()
 	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
-
-	bsonData, err := bson.Marshal(&creditCard)
+	sqlvalueAsString, ok := sqlvalue.(string)
+	if assert.Truef(t, ok, "[%s]Value: expected driver value to be a string", "byte") {
+		assert.EqualValuesf(t, str, sqlvalueAsString, "[%s]Value: expected %v and %v to be equal", "byte", sqlvalue, str)
+	}
+	// Scanner interface
+	b64 = Base64("")
+	err = b64.Scan(str)
 	assert.NoError(t, err)
+	b64AsStr := b64.String()
+	assert.EqualValues(t, str, b64AsStr)
 
-	var creditCardCopy CreditCard
-	err = bson.Unmarshal(bsonData, &creditCardCopy)
+	err = b64.Scan([]byte(str))
 	assert.NoError(t, err)
-	assert.Equal(t, creditCard, creditCardCopy)
+	b64AsStr = b64.String()
+	assert.EqualValues(t, str, b64AsStr)
 
-	testValid(t, "creditcard", str)
-	testInvalid(t, "creditcard", "9999-9999-9999-999") // bad checksum
+	err = b64.Scan(123)
+	assert.Error(t, err)
 }
 
-func TestFormatPassword(t *testing.T) {
-	password := Password("super secret stuff here")
-	str := string("even more secret")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
+type testableFormat interface {
+	encoding.TextMarshaler
+	encoding.TextUnmarshaler
+	json.Marshaler
+	json.Unmarshaler
+	bson.Getter
+	bson.Setter
+	fmt.Stringer
+	sql.Scanner
+	driver.Valuer
+}
 
-	err := password.UnmarshalText(b)
+func testStringFormat(t *testing.T, what testableFormat, format, with string, validSamples, invalidSamples []string) {
+	// text encoding interface
+	b := []byte(with)
+	err := what.UnmarshalText(b)
 	assert.NoError(t, err)
-	assert.EqualValues(t, Password("even more secret"), string(b))
 
-	b, err = password.MarshalText()
-	assert.NoError(t, err)
-	assert.Equal(t, []byte("even more secret"), b)
+	val := reflect.Indirect(reflect.ValueOf(what))
+	strVal := val.String()
+	assert.Equalf(t, with, strVal, "[%s]UnmarshalText: expected %v and %v to be value equal", format, strVal, with)
 
-	err = password.UnmarshalJSON(bj)
+	b, err = what.MarshalText()
 	assert.NoError(t, err)
-	assert.EqualValues(t, Password(str), string(b))
+	assert.Equalf(t, []byte(with), b, "[%s]MarshalText: expected %v and %v to be value equal as []byte", format, string(b), with)
 
-	b, err = password.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
+	// Stringer
+	strVal = what.String()
+	assert.Equalf(t, []byte(with), b, "[%s]String: expected %v and %v to be equal", strVal, with)
 
-	bsonData, err := bson.Marshal(&password)
+	// JSON encoding interface
+	bj := []byte("\"" + with + "\"")
+	err = what.UnmarshalJSON(bj)
 	assert.NoError(t, err)
+	val = reflect.Indirect(reflect.ValueOf(what))
+	strVal = val.String()
+	assert.EqualValuesf(t, with, strVal, "[%s]UnmarshalJSON: expected %v and %v to be value equal", format, strVal, with)
 
-	var passwordCopy Password
-	err = bson.Unmarshal(bsonData, &passwordCopy)
+	b, err = what.MarshalJSON()
 	assert.NoError(t, err)
-	assert.Equal(t, password, passwordCopy)
+	assert.Equalf(t, bj, b, "[%s]MarshalJSON: expected %v and %v to be value equal as []byte", format, string(b), with)
 
-	// everything is valid
-	testValid(t, "password", str)
-}
+	// bson encoding interface
+	bsonData, err := bson.Marshal(&what)
+	assert.NoError(t, err)
 
-func TestFormatBase64(t *testing.T) {
-	b64 := Base64("ZWxpemFiZXRocG9zZXk=")
-	str := string("ZWxpemFiZXRocG9zZXk=")
-	b := []byte(str)
-	bj := []byte("\"" + str + "\"")
+	resetValue(t, format, what)
 
-	err := b64.UnmarshalText(b)
+	err = bson.Unmarshal(bsonData, what)
 	assert.NoError(t, err)
-	assert.EqualValues(t, Base64("ZWxpemFiZXRocG9zZXk="), string(b))
+	val = reflect.Indirect(reflect.ValueOf(what))
+	strVal = val.String()
+	assert.EqualValuesf(t, with, strVal, "[%s]bson.Unmarshal: expected %v and %v to be equal (reset value) ", format, what, with)
 
-	b, err = b64.MarshalText()
+	// Scanner interface
+	resetValue(t, format, what)
+	err = what.Scan(with)
 	assert.NoError(t, err)
-	assert.Equal(t, []byte("ZWxpemFiZXRocG9zZXk="), b)
+	val = reflect.Indirect(reflect.ValueOf(what))
+	strVal = val.String()
+	assert.EqualValuesf(t, with, strVal, "[%s]Scan: expected %v and %v to be value equal", format, strVal, with)
 
-	err = b64.UnmarshalJSON(bj)
+	err = what.Scan([]byte(with))
 	assert.NoError(t, err)
-	assert.EqualValues(t, Base64(str), string(b))
+	val = reflect.Indirect(reflect.ValueOf(what))
+	strVal = val.String()
+	assert.EqualValuesf(t, with, strVal, "[%s]Scan: expected %v and %v to be value equal", format, strVal, with)
 
-	b, err = b64.MarshalJSON()
-	assert.NoError(t, err)
-	assert.Equal(t, bj, b)
+	err = what.Scan(123)
+	assert.Error(t, err)
 
-	bsonData, err := bson.Marshal(&b64)
+	// Valuer interface
+	sqlvalue, err := what.Value()
 	assert.NoError(t, err)
+	sqlvalueAsString, ok := sqlvalue.(string)
+	if assert.Truef(t, ok, "[%s]Value: expected driver value to be a string", format) {
+		assert.EqualValuesf(t, with, sqlvalueAsString, "[%s]Value: expected %v and %v to be equal", format, sqlvalue, with)
+	}
 
-	var b64Copy Base64
-	err = bson.Unmarshal(bsonData, &b64Copy)
+	// validation with Registry
+	for _, valid := range append(validSamples, with) {
+		testValid(t, format, valid)
+	}
+
+	for _, invalid := range invalidSamples {
+		testInvalid(t, format, invalid)
+	}
+}
+
+func resetValue(t *testing.T, format string, what encoding.TextUnmarshaler) {
+	err := what.UnmarshalText([]byte("reset value"))
 	assert.NoError(t, err)
-	assert.Equal(t, b64, b64Copy)
+	val := reflect.Indirect(reflect.ValueOf(what))
+	strVal := val.String()
+	assert.Equalf(t, "reset value", strVal, "[%s]UnmarshalText: expected %v and %v to be equal (reset value) ", format, strVal, "reset value")
+}
 
-	testValid(t, "byte", str)
-	testInvalid(t, "byte", "ZWxpemFiZXRocG9zZXk") // missing pad char
+func testValid(t *testing.T, name, value string) {
+	ok := Default.Validates(name, value)
+	if !ok {
+		t.Errorf("expected %q of type %s to be valid", value, name)
+	}
+}
+
+func testInvalid(t *testing.T, name, value string) {
+	ok := Default.Validates(name, value)
+	if ok {
+		t.Errorf("expected %q of type %s to be invalid", value, name)
+	}
 }
diff --git a/vendor/github.com/go-openapi/strfmt/duration.go b/vendor/github.com/go-openapi/strfmt/duration.go
index 28df8e48..61fd6d37 100644
--- a/vendor/github.com/go-openapi/strfmt/duration.go
+++ b/vendor/github.com/go-openapi/strfmt/duration.go
@@ -121,7 +121,7 @@ func ParseDuration(cand string) (time.Duration, error) {
 	if ok {
 		return dur, nil
 	}
-	return 0, fmt.Errorf("Unable to parse %s as duration", cand)
+	return 0, fmt.Errorf("unable to parse %s as duration", cand)
 }
 
 // Scan reads a Duration value from database driver type.
diff --git a/vendor/github.com/go-openapi/strfmt/format_test.go b/vendor/github.com/go-openapi/strfmt/format_test.go
index 9c9fa3fc..096eaf8a 100644
--- a/vendor/github.com/go-openapi/strfmt/format_test.go
+++ b/vendor/github.com/go-openapi/strfmt/format_test.go
@@ -131,12 +131,12 @@ type testStruct struct {
 	D          Date       `json:"d,omitempty"`
 	DT         DateTime   `json:"dt,omitempty"`
 	Dur        Duration   `json:"dur,omitempty"`
-	Uri        URI        `json:"uri,omitempty"`
+	URI        URI        `json:"uri,omitempty"`
 	Eml        Email      `json:"eml,omitempty"`
-	Uuid       UUID       `json:"uuid,omitempty"`
-	Uuid3      UUID3      `json:"uuid3,omitempty"`
-	Uuid4      UUID4      `json:"uuid4,omitempty"`
-	Uuid5      UUID5      `json:"uuid5,omitempty"`
+	UUID       UUID       `json:"uuid,omitempty"`
+	UUID3      UUID3      `json:"uuid3,omitempty"`
+	UUID4      UUID4      `json:"uuid4,omitempty"`
+	UUID5      UUID5      `json:"uuid5,omitempty"`
 	Hn         Hostname   `json:"hn,omitempty"`
 	Ipv4       IPv4       `json:"ipv4,omitempty"`
 	Ipv6       IPv6       `json:"ipv6,omitempty"`
@@ -187,12 +187,12 @@ func TestDecodeHook(t *testing.T) {
 		D:          Date(date),
 		DT:         dt,
 		Dur:        Duration(dur),
-		Uri:        URI("http://www.dummy.com"),
+		URI:        URI("http://www.dummy.com"),
 		Eml:        Email("dummy@dummy.com"),
-		Uuid:       UUID("a8098c1a-f86e-11da-bd1a-00112444be1e"),
-		Uuid3:      UUID3("bcd02e22-68f0-3046-a512-327cca9def8f"),
-		Uuid4:      UUID4("025b0d74-00a2-4048-bf57-227c5111bb34"),
-		Uuid5:      UUID5("886313e1-3b8a-5372-9b90-0c9aee199e5d"),
+		UUID:       UUID("a8098c1a-f86e-11da-bd1a-00112444be1e"),
+		UUID3:      UUID3("bcd02e22-68f0-3046-a512-327cca9def8f"),
+		UUID4:      UUID4("025b0d74-00a2-4048-bf57-227c5111bb34"),
+		UUID5:      UUID5("886313e1-3b8a-5372-9b90-0c9aee199e5d"),
 		Hn:         Hostname("somewhere.com"),
 		Ipv4:       IPv4("192.168.254.1"),
 		Ipv6:       IPv6("::1"),
diff --git a/vendor/github.com/go-openapi/swag/convert_types_test.go b/vendor/github.com/go-openapi/swag/convert_types_test.go
index 681b2cf2..13859575 100644
--- a/vendor/github.com/go-openapi/swag/convert_types_test.go
+++ b/vendor/github.com/go-openapi/swag/convert_types_test.go
@@ -1,3 +1,17 @@
+// Copyright 2015 go-swagger maintainers
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 package swag
 
 import (
diff --git a/vendor/github.com/go-openapi/swag/net.go b/vendor/github.com/go-openapi/swag/net.go
index 8323fa37..821235f8 100644
--- a/vendor/github.com/go-openapi/swag/net.go
+++ b/vendor/github.com/go-openapi/swag/net.go
@@ -1,3 +1,17 @@
+// Copyright 2015 go-swagger maintainers
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 package swag
 
 import (
diff --git a/vendor/github.com/go-openapi/swag/net_test.go b/vendor/github.com/go-openapi/swag/net_test.go
index 041db60a..79e58600 100644
--- a/vendor/github.com/go-openapi/swag/net_test.go
+++ b/vendor/github.com/go-openapi/swag/net_test.go
@@ -1,3 +1,17 @@
+// Copyright 2015 go-swagger maintainers
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 package swag
 
 import (
diff --git a/vendor/github.com/go-openapi/swag/post_go18.go b/vendor/github.com/go-openapi/swag/post_go18.go
index ef48086d..c2e686d3 100644
--- a/vendor/github.com/go-openapi/swag/post_go18.go
+++ b/vendor/github.com/go-openapi/swag/post_go18.go
@@ -1,3 +1,17 @@
+// Copyright 2015 go-swagger maintainers
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 // +build go1.8
 
 package swag
diff --git a/vendor/github.com/go-openapi/swag/post_go19.go b/vendor/github.com/go-openapi/swag/post_go19.go
index 567680c7..9db23c09 100644
--- a/vendor/github.com/go-openapi/swag/post_go19.go
+++ b/vendor/github.com/go-openapi/swag/post_go19.go
@@ -1,3 +1,17 @@
+// Copyright 2015 go-swagger maintainers
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 // +build go1.9
 
 package swag
diff --git a/vendor/github.com/go-openapi/swag/pre_go18.go b/vendor/github.com/go-openapi/swag/pre_go18.go
index 860bb2bb..6607f339 100644
--- a/vendor/github.com/go-openapi/swag/pre_go18.go
+++ b/vendor/github.com/go-openapi/swag/pre_go18.go
@@ -1,3 +1,17 @@
+// Copyright 2015 go-swagger maintainers
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 // +build !go1.8
 
 package swag
diff --git a/vendor/github.com/go-openapi/swag/pre_go19.go b/vendor/github.com/go-openapi/swag/pre_go19.go
index 72c48ae7..9c96ab90 100644
--- a/vendor/github.com/go-openapi/swag/pre_go19.go
+++ b/vendor/github.com/go-openapi/swag/pre_go19.go
@@ -1,3 +1,17 @@
+// Copyright 2015 go-swagger maintainers
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 // +build !go1.9
 
 package swag
diff --git a/vendor/github.com/spf13/cast/.travis.yml b/vendor/github.com/spf13/cast/.travis.yml
index 4da97668..6420d1c2 100644
--- a/vendor/github.com/spf13/cast/.travis.yml
+++ b/vendor/github.com/spf13/cast/.travis.yml
@@ -1,8 +1,9 @@
 language: go
+env:
+  -  GO111MODULE=on
 sudo: required
 go:
-  - 1.7.5
-  - 1.8
+  - "1.11.x"
   - tip
 os:
   - linux
diff --git a/vendor/github.com/spf13/cast/cast.go b/vendor/github.com/spf13/cast/cast.go
index 8b8c208b..9fba638d 100644
--- a/vendor/github.com/spf13/cast/cast.go
+++ b/vendor/github.com/spf13/cast/cast.go
@@ -122,6 +122,18 @@ func ToStringMapBool(i interface{}) map[string]bool {
 	return v
 }
 
+// ToStringMapInt casts an interface to a map[string]int type.
+func ToStringMapInt(i interface{}) map[string]int {
+	v, _ := ToStringMapIntE(i)
+	return v
+}
+
+// ToStringMapInt64 casts an interface to a map[string]int64 type.
+func ToStringMapInt64(i interface{}) map[string]int64 {
+	v, _ := ToStringMapInt64E(i)
+	return v
+}
+
 // ToStringMap casts an interface to a map[string]interface{} type.
 func ToStringMap(i interface{}) map[string]interface{} {
 	v, _ := ToStringMapE(i)
diff --git a/vendor/github.com/spf13/cast/cast_test.go b/vendor/github.com/spf13/cast/cast_test.go
index d9b0b013..d9a1479d 100644
--- a/vendor/github.com/spf13/cast/cast_test.go
+++ b/vendor/github.com/spf13/cast/cast_test.go
@@ -821,6 +821,83 @@ func TestToStringMapBoolE(t *testing.T) {
 	}
 }
 
+func TestToStringMapIntE(t *testing.T) {
+	tests := []struct {
+		input  interface{}
+		expect map[string]int
+		iserr  bool
+	}{
+		{map[interface{}]interface{}{"v1": 1, "v2": 222}, map[string]int{"v1": 1, "v2": 222}, false},
+		{map[string]interface{}{"v1": 342, "v2": 5141}, map[string]int{"v1": 342, "v2": 5141}, false},
+		{map[string]int{"v1": 33, "v2": 88}, map[string]int{"v1": 33, "v2": 88}, false},
+		{map[string]int32{"v1": int32(33), "v2": int32(88)}, map[string]int{"v1": 33, "v2": 88}, false},
+		{map[string]uint16{"v1": uint16(33), "v2": uint16(88)}, map[string]int{"v1": 33, "v2": 88}, false},
+		{map[string]float64{"v1": float64(8.22), "v2": float64(43.32)}, map[string]int{"v1": 8, "v2": 43}, false},
+		{`{"v1": 67, "v2": 56}`, map[string]int{"v1": 67, "v2": 56}, false},
+
+		// errors
+		{nil, nil, true},
+		{testing.T{}, nil, true},
+		{"", nil, true},
+	}
+
+	for i, test := range tests {
+		errmsg := fmt.Sprintf("i = %d", i) // assert helper message
+
+		v, err := ToStringMapIntE(test.input)
+		if test.iserr {
+			assert.Error(t, err, errmsg)
+			continue
+		}
+
+		assert.NoError(t, err, errmsg)
+		assert.Equal(t, test.expect, v, errmsg)
+
+		// Non-E test
+		v = ToStringMapInt(test.input)
+		assert.Equal(t, test.expect, v, errmsg)
+	}
+}
+
+func TestToStringMapInt64E(t *testing.T) {
+	tests := []struct {
+		input  interface{}
+		expect map[string]int64
+		iserr  bool
+	}{
+		{map[interface{}]interface{}{"v1": int32(8), "v2": int32(888)}, map[string]int64{"v1": int64(8), "v2": int64(888)}, false},
+		{map[string]interface{}{"v1": int64(45), "v2": int64(67)}, map[string]int64{"v1": 45, "v2": 67}, false},
+		{map[string]int64{"v1": 33, "v2": 88}, map[string]int64{"v1": 33, "v2": 88}, false},
+		{map[string]int{"v1": 33, "v2": 88}, map[string]int64{"v1": 33, "v2": 88}, false},
+		{map[string]int32{"v1": int32(33), "v2": int32(88)}, map[string]int64{"v1": 33, "v2": 88}, false},
+		{map[string]uint16{"v1": uint16(33), "v2": uint16(88)}, map[string]int64{"v1": 33, "v2": 88}, false},
+		{map[string]float64{"v1": float64(8.22), "v2": float64(43.32)}, map[string]int64{"v1": 8, "v2": 43}, false},
+		{`{"v1": 67, "v2": 56}`, map[string]int64{"v1": 67, "v2": 56}, false},
+
+		// errors
+		{nil, nil, true},
+		{testing.T{}, nil, true},
+		{"", nil, true},
+	}
+
+	for i, test := range tests {
+		errmsg := fmt.Sprintf("i = %d", i) // assert helper message
+
+		v, err := ToStringMapInt64E(test.input)
+		if test.iserr {
+			assert.Error(t, err, errmsg)
+			continue
+		}
+
+		assert.NoError(t, err, errmsg)
+		assert.Equal(t, test.expect, v, errmsg)
+
+		// Non-E test
+		v = ToStringMapInt64(test.input)
+		assert.Equal(t, test.expect, v, errmsg)
+	}
+}
+
 func TestToStringMapStringE(t *testing.T) {
 	var stringMapString = map[string]string{"key 1": "value 1", "key 2": "value 2", "key 3": "value 3"}
 	var stringMapInterface = map[string]interface{}{"key 1": "value 1", "key 2": "value 2", "key 3": "value 3"}
@@ -1112,6 +1189,7 @@ func TestToTimeEE(t *testing.T) {
 		{"Tue, 10 Nov 2009 23:00:00 UTC", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},   // RFC1123
 		{"Tue, 10 Nov 2009 23:00:00 +0000", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false}, // RFC1123Z
 		{"2009-11-10T23:00:00Z", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},            // RFC3339
+		{"2018-10-21T23:21:29+0200", time.Date(2018, 10, 21, 21, 21, 29, 0, time.UTC), false},      // RFC3339 without timezone hh:mm colon
 		{"2009-11-10T23:00:00Z", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},            // RFC3339Nano
 		{"11:00PM", time.Date(0, 1, 1, 23, 0, 0, 0, time.UTC), false},                              // Kitchen
 		{"Nov 10 23:00:00", time.Date(0, 11, 10, 23, 0, 0, 0, time.UTC), false},                    // Stamp
@@ -1119,6 +1197,7 @@ func TestToTimeEE(t *testing.T) {
 		{"Nov 10 23:00:00.000000", time.Date(0, 11, 10, 23, 0, 0, 0, time.UTC), false},             // StampMicro
 		{"Nov 10 23:00:00.000000000", time.Date(0, 11, 10, 23, 0, 0, 0, time.UTC), false},          // StampNano
 		{"2016-03-06 15:28:01-00:00", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},        // RFC3339 without T
+		{"2016-03-06 15:28:01-0000", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},         // RFC3339 without T or timezone hh:mm colon
 		{"2016-03-06 15:28:01", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},
 		{"2016-03-06 15:28:01 -0000", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},
 		{"2016-03-06 15:28:01 -00:00", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},
diff --git a/vendor/github.com/spf13/cast/caste.go b/vendor/github.com/spf13/cast/caste.go
index 4fe19289..a4859fb0 100644
--- a/vendor/github.com/spf13/cast/caste.go
+++ b/vendor/github.com/spf13/cast/caste.go
@@ -990,6 +990,87 @@ func ToStringMapE(i interface{}) (map[string]interface{}, error) {
 	}
 }
 
+// ToStringMapIntE casts an interface to a map[string]int{} type.
+func ToStringMapIntE(i interface{}) (map[string]int, error) {
+	var m = map[string]int{}
+	if i == nil {
+		return m, fmt.Errorf("unable to cast %#v of type %T to map[string]int", i, i)
+	}
+
+	switch v := i.(type) {
+	case map[interface{}]interface{}:
+		for k, val := range v {
+			m[ToString(k)] = ToInt(val)
+		}
+		return m, nil
+	case map[string]interface{}:
+		for k, val := range v {
+			m[k] = ToInt(val)
+		}
+		return m, nil
+	case map[string]int:
+		return v, nil
+	case string:
+		err := jsonStringToObject(v, &m)
+		return m, err
+	}
+
+	if reflect.TypeOf(i).Kind() != reflect.Map {
+		return m, fmt.Errorf("unable to cast %#v of type %T to map[string]int", i, i)
+	}
+
+	mVal := reflect.ValueOf(m)
+	v := reflect.ValueOf(i)
+	for _, keyVal := range v.MapKeys() {
+		val, err := ToIntE(v.MapIndex(keyVal).Interface())
+		if err != nil {
+			return m, fmt.Errorf("unable to cast %#v of type %T to map[string]int", i, i)
+		}
+		mVal.SetMapIndex(keyVal, reflect.ValueOf(val))
+	}
+	return m, nil
+}
+
+// ToStringMapInt64E casts an interface to a map[string]int64{} type.
+func ToStringMapInt64E(i interface{}) (map[string]int64, error) {
+	var m = map[string]int64{}
+	if i == nil {
+		return m, fmt.Errorf("unable to cast %#v of type %T to map[string]int64", i, i)
+	}
+
+	switch v := i.(type) {
+	case map[interface{}]interface{}:
+		for k, val := range v {
+			m[ToString(k)] = ToInt64(val)
+		}
+		return m, nil
+	case map[string]interface{}:
+		for k, val := range v {
+			m[k] = ToInt64(val)
+		}
+		return m, nil
+	case map[string]int64:
+		return v, nil
+	case string:
+		err := jsonStringToObject(v, &m)
+		return m, err
+	}
+
+	if reflect.TypeOf(i).Kind() != reflect.Map {
+		return m, fmt.Errorf("unable to cast %#v of type %T to map[string]int64", i, i)
+	}
+	mVal := reflect.ValueOf(m)
+	v := reflect.ValueOf(i)
+	for _, keyVal := range v.MapKeys() {
+		val, err := ToInt64E(v.MapIndex(keyVal).Interface())
+		if err != nil {
+			return m, fmt.Errorf("unable to cast %#v of type %T to map[string]int64", i, i)
+		}
+		mVal.SetMapIndex(keyVal, reflect.ValueOf(val))
+	}
+	return m, nil
+}
+
 // ToSliceE casts an interface to a []interface{} type.
 func ToSliceE(i interface{}) ([]interface{}, error) {
 	var s []interface{}
@@ -1137,9 +1218,11 @@ func StringToDate(s string) (time.Time, error) {
 		"2006-01-02 15:04:05.999999999 -0700 MST", // Time.String()
 		"2006-01-02",
 		"02 Jan 2006",
+		"2006-01-02T15:04:05-0700", // RFC3339 without timezone hh:mm colon
 		"2006-01-02 15:04:05 -07:00",
 		"2006-01-02 15:04:05 -0700",
 		"2006-01-02 15:04:05Z07:00", // RFC3339 without T
+		"2006-01-02 15:04:05Z0700",  // RFC3339 without T or timezone hh:mm colon
 		"2006-01-02 15:04:05",
 		time.Kitchen,
 		time.Stamp,
diff --git a/vendor/github.com/spf13/cast/go.mod b/vendor/github.com/spf13/cast/go.mod
new file mode 100644
index 00000000..c1c0232d
--- /dev/null
+++ b/vendor/github.com/spf13/cast/go.mod
@@ -0,0 +1,7 @@
+module github.com/spf13/cast
+
+require (
+	github.com/davecgh/go-spew v1.1.1 // indirect
+	github.com/pmezard/go-difflib v1.0.0 // indirect
+	github.com/stretchr/testify v1.2.2
+)
diff --git a/vendor/github.com/spf13/cast/go.sum b/vendor/github.com/spf13/cast/go.sum
new file mode 100644
index 00000000..e03ee77d
--- /dev/null
+++ b/vendor/github.com/spf13/cast/go.sum
@@ -0,0 +1,6 @@
+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
+github.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=
+github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
diff --git a/vendor/github.com/spf13/viper/README.md b/vendor/github.com/spf13/viper/README.md
index 87bbc8b4..0208eac8 100644
--- a/vendor/github.com/spf13/viper/README.md
+++ b/vendor/github.com/spf13/viper/README.md
@@ -179,13 +179,14 @@ viper.GetBool("verbose") // true
 ### Working with Environment Variables
 
 Viper has full support for environment variables. This enables 12 factor
-applications out of the box. There are four methods that exist to aid working
+applications out of the box. There are five methods that exist to aid working
 with ENV:
 
  * `AutomaticEnv()`
  * `BindEnv(string...) : error`
  * `SetEnvPrefix(string)`
  * `SetEnvKeyReplacer(string...) *strings.Replacer`
+  * `AllowEmptyEnvVar(bool)`
 
 _When working with ENV variables, its important to recognize that Viper
 treats ENV variables as case sensitive._
@@ -217,6 +218,10 @@ keys to an extent. This is useful if you want to use `-` or something in your
 `Get()` calls, but want your environmental variables to use `_` delimiters. An
 example of using it can be found in `viper_test.go`.
 
+By default empty environment variables are considered unset and will fall back to
+the next configuration source. To treat empty environment variables as set, use
+the `AllowEmptyEnv` method.
+
 #### Env example
 
 ```go
diff --git a/vendor/github.com/spf13/viper/viper.go b/vendor/github.com/spf13/viper/viper.go
index a32ab738..18756270 100644
--- a/vendor/github.com/spf13/viper/viper.go
+++ b/vendor/github.com/spf13/viper/viper.go
@@ -187,6 +187,7 @@ type Viper struct {
 
 	automaticEnvApplied bool
 	envKeyReplacer      *strings.Replacer
+	allowEmptyEnv       bool
 
 	config         map[string]interface{}
 	override       map[string]interface{}
@@ -373,6 +374,14 @@ func (v *Viper) mergeWithEnvPrefix(in string) string {
 	return strings.ToUpper(in)
 }
 
+// AllowEmptyEnv tells Viper to consider set,
+// but empty environment variables as valid values instead of falling back.
+// For backward compatibility reasons this is false by default.
+func AllowEmptyEnv(allowEmptyEnv bool) { v.AllowEmptyEnv(allowEmptyEnv) }
+func (v *Viper) AllowEmptyEnv(allowEmptyEnv bool) {
+	v.allowEmptyEnv = allowEmptyEnv
+}
+
 // TODO: should getEnv logic be moved into find(). Can generalize the use of
 // rewriting keys many things, Ex: Get('someKey') -> some_key
 // (camel case to snake case for JSON keys perhaps)
@@ -380,11 +389,14 @@ func (v *Viper) mergeWithEnvPrefix(in string) string {
 // getEnv is a wrapper around os.Getenv which replaces characters in the original
 // key. This allows env vars which have different keys than the config object
 // keys.
-func (v *Viper) getEnv(key string) string {
+func (v *Viper) getEnv(key string) (string, bool) {
 	if v.envKeyReplacer != nil {
 		key = v.envKeyReplacer.Replace(key)
 	}
-	return os.Getenv(key)
+
+	val, ok := os.LookupEnv(key)
+
+	return val, ok && (v.allowEmptyEnv || val != "")
 }
 
 // ConfigFileUsed returns the file used to populate the config registry.
@@ -611,10 +623,9 @@ func (v *Viper) isPathShadowedInFlatMap(path []string, mi interface{}) string {
 //       "foo.bar.baz" in a lower-priority map
 func (v *Viper) isPathShadowedInAutoEnv(path []string) string {
 	var parentKey string
-	var val string
 	for i := 1; i < len(path); i++ {
 		parentKey = strings.Join(path[0:i], v.keyDelim)
-		if val = v.getEnv(v.mergeWithEnvPrefix(parentKey)); val != "" {
+		if _, ok := v.getEnv(v.mergeWithEnvPrefix(parentKey)); ok {
 			return parentKey
 		}
 	}
@@ -993,7 +1004,7 @@ func (v *Viper) find(lcaseKey string) interface{} {
 	if v.automaticEnvApplied {
 		// even if it hasn't been registered, if automaticEnv is used,
 		// check any Get request
-		if val = v.getEnv(v.mergeWithEnvPrefix(lcaseKey)); val != "" {
+		if val, ok := v.getEnv(v.mergeWithEnvPrefix(lcaseKey)); ok {
 			return val
 		}
 		if nested && v.isPathShadowedInAutoEnv(path) != "" {
@@ -1002,7 +1013,7 @@ func (v *Viper) find(lcaseKey string) interface{} {
 	}
 	envkey, exists := v.env[lcaseKey]
 	if exists {
-		if val = v.getEnv(envkey); val != "" {
+		if val, ok := v.getEnv(envkey); ok {
 			return val
 		}
 	}
diff --git a/vendor/github.com/spf13/viper/viper_test.go b/vendor/github.com/spf13/viper/viper_test.go
index c8fa1f4c..fa3903ec 100644
--- a/vendor/github.com/spf13/viper/viper_test.go
+++ b/vendor/github.com/spf13/viper/viper_test.go
@@ -388,6 +388,36 @@ func TestEnv(t *testing.T) {
 
 }
 
+func TestEmptyEnv(t *testing.T) {
+	initJSON()
+
+	BindEnv("type") // Empty environment variable
+	BindEnv("name") // Bound, but not set environment variable
+
+	os.Clearenv()
+
+	os.Setenv("TYPE", "")
+
+	assert.Equal(t, "donut", Get("type"))
+	assert.Equal(t, "Cake", Get("name"))
+}
+
+func TestEmptyEnv_Allowed(t *testing.T) {
+	initJSON()
+
+	AllowEmptyEnv(true)
+
+	BindEnv("type") // Empty environment variable
+	BindEnv("name") // Bound, but not set environment variable
+
+	os.Clearenv()
+
+	os.Setenv("TYPE", "")
+
+	assert.Equal(t, "", Get("type"))
+	assert.Equal(t, "Cake", Get("name"))
+}
+
 func TestEnvPrefix(t *testing.T) {
 	initJSON()
 
@@ -583,24 +613,28 @@ func TestBindPFlags(t *testing.T) {
 }
 
 func TestBindPFlagsStringSlice(t *testing.T) {
-	for _, testValue := range []struct {
+	tests := []struct {
 		Expected []string
 		Value    string
 	}{
 		{[]string{}, ""},
 		{[]string{"jeden"}, "jeden"},
 		{[]string{"dwa", "trzy"}, "dwa,trzy"},
-		{[]string{"cztery", "piec , szesc"}, "cztery,\"piec , szesc\""}} {
+		{[]string{"cztery", "piec , szesc"}, "cztery,\"piec , szesc\""},
+	}
+
+	v := New() // create independent Viper object
+	defaultVal := []string{"default"}
+	v.SetDefault("stringslice", defaultVal)
+
+	for _, testValue := range tests {
+		flagSet := pflag.NewFlagSet("test", pflag.ContinueOnError)
+		flagSet.StringSlice("stringslice", testValue.Expected, "test")
 
 		for _, changed := range []bool{true, false} {
-			v := New() // create independent Viper object
-			flagSet := pflag.NewFlagSet("test", pflag.ContinueOnError)
-			flagSet.StringSlice("stringslice", testValue.Expected, "test")
-			flagSet.Visit(func(f *pflag.Flag) {
-				if len(testValue.Value) > 0 {
-					f.Value.Set(testValue.Value)
-					f.Changed = changed
-				}
+			flagSet.VisitAll(func(f *pflag.Flag) {
+				f.Value.Set(testValue.Value)
+				f.Changed = changed
 			})
 
 			err := v.BindPFlags(flagSet)
@@ -615,7 +649,11 @@ func TestBindPFlagsStringSlice(t *testing.T) {
 			if err := v.Unmarshal(val); err != nil {
 				t.Fatalf("%+#v cannot unmarshal: %s", testValue.Value, err)
 			}
-			assert.Equal(t, testValue.Expected, val.StringSlice)
+			if changed {
+				assert.Equal(t, testValue.Expected, val.StringSlice)
+			} else {
+				assert.Equal(t, defaultVal, val.StringSlice)
+			}
 		}
 	}
 }
diff --git a/vendor/golang.org/x/crypto/acme/acme.go b/vendor/golang.org/x/crypto/acme/acme.go
index 7df64764..c6fd9989 100644
--- a/vendor/golang.org/x/crypto/acme/acme.go
+++ b/vendor/golang.org/x/crypto/acme/acme.go
@@ -77,6 +77,10 @@ const (
 type Client struct {
 	// Key is the account key used to register with a CA and sign requests.
 	// Key.Public() must return a *rsa.PublicKey or *ecdsa.PublicKey.
+	//
+	// The following algorithms are supported:
+	// RS256, ES256, ES384 and ES512.
+	// See RFC7518 for more details about the algorithms.
 	Key crypto.Signer
 
 	// HTTPClient optionally specifies an HTTP client to use
diff --git a/vendor/golang.org/x/crypto/acme/jws.go b/vendor/golang.org/x/crypto/acme/jws.go
index 6cbca25d..1093b503 100644
--- a/vendor/golang.org/x/crypto/acme/jws.go
+++ b/vendor/golang.org/x/crypto/acme/jws.go
@@ -25,7 +25,7 @@ func jwsEncodeJSON(claimset interface{}, key crypto.Signer, nonce string) ([]byt
 	if err != nil {
 		return nil, err
 	}
-	alg, sha := jwsHasher(key)
+	alg, sha := jwsHasher(key.Public())
 	if alg == "" || !sha.Available() {
 		return nil, ErrUnsupportedKey
 	}
@@ -97,13 +97,16 @@ func jwkEncode(pub crypto.PublicKey) (string, error) {
 }
 
 // jwsSign signs the digest using the given key.
-// It returns ErrUnsupportedKey if the key type is unknown.
-// The hash is used only for RSA keys.
+// The hash is unused for ECDSA keys.
+//
+// Note: non-stdlib crypto.Signer implementations are expected to return
+// the signature in the format as specified in RFC7518.
+// See https://tools.ietf.org/html/rfc7518 for more details.
 func jwsSign(key crypto.Signer, hash crypto.Hash, digest []byte) ([]byte, error) {
-	switch key := key.(type) {
-	case *rsa.PrivateKey:
-		return key.Sign(rand.Reader, digest, hash)
-	case *ecdsa.PrivateKey:
+	if key, ok := key.(*ecdsa.PrivateKey); ok {
+		// The key.Sign method of ecdsa returns ASN1-encoded signature.
+		// So, we use the package Sign function instead
+		// to get R and S values directly and format the result accordingly.
 		r, s, err := ecdsa.Sign(rand.Reader, key, digest)
 		if err != nil {
 			return nil, err
@@ -118,18 +121,18 @@ func jwsSign(key crypto.Signer, hash crypto.Hash, digest []byte) ([]byte, error)
 		copy(sig[size*2-len(sb):], sb)
 		return sig, nil
 	}
-	return nil, ErrUnsupportedKey
+	return key.Sign(rand.Reader, digest, hash)
 }
 
 // jwsHasher indicates suitable JWS algorithm name and a hash function
 // to use for signing a digest with the provided key.
 // It returns ("", 0) if the key is not supported.
-func jwsHasher(key crypto.Signer) (string, crypto.Hash) {
-	switch key := key.(type) {
-	case *rsa.PrivateKey:
+func jwsHasher(pub crypto.PublicKey) (string, crypto.Hash) {
+	switch pub := pub.(type) {
+	case *rsa.PublicKey:
 		return "RS256", crypto.SHA256
-	case *ecdsa.PrivateKey:
-		switch key.Params().Name {
+	case *ecdsa.PublicKey:
+		switch pub.Params().Name {
 		case "P-256":
 			return "ES256", crypto.SHA256
 		case "P-384":
diff --git a/vendor/golang.org/x/crypto/acme/jws_test.go b/vendor/golang.org/x/crypto/acme/jws_test.go
index 0ff0fb5a..ee30b1e1 100644
--- a/vendor/golang.org/x/crypto/acme/jws_test.go
+++ b/vendor/golang.org/x/crypto/acme/jws_test.go
@@ -5,6 +5,7 @@
 package acme
 
 import (
+	"crypto"
 	"crypto/ecdsa"
 	"crypto/elliptic"
 	"crypto/rsa"
@@ -13,6 +14,7 @@ import (
 	"encoding/json"
 	"encoding/pem"
 	"fmt"
+	"io"
 	"math/big"
 	"testing"
 )
@@ -241,6 +243,79 @@ func TestJWSEncodeJSONEC(t *testing.T) {
 	}
 }
 
+type customTestSigner struct {
+	sig []byte
+	pub crypto.PublicKey
+}
+
+func (s *customTestSigner) Public() crypto.PublicKey { return s.pub }
+func (s *customTestSigner) Sign(io.Reader, []byte, crypto.SignerOpts) ([]byte, error) {
+	return s.sig, nil
+}
+
+func TestJWSEncodeJSONCustom(t *testing.T) {
+	claims := struct{ Msg string }{"hello"}
+	const (
+		// printf '{"Msg":"hello"}' | base64 | tr -d '=' | tr '/+' '_-'
+		payload = "eyJNc2ciOiJoZWxsbyJ9"
+		// printf 'testsig' | base64 | tr -d '='
+		testsig = "dGVzdHNpZw"
+
+		// printf '{"alg":"ES256","jwk":{"crv":"P-256","kty":"EC","x":<testKeyECPubY>,"y":<testKeyECPubY>,"nonce":"nonce"}' | \
+		// base64 | tr -d '=' | tr '/+' '_-'
+		es256phead = "eyJhbGciOiJFUzI1NiIsImp3ayI6eyJjcnYiOiJQLTI1NiIsImt0eSI6IkVDIiwieCI6IjVsaEV1" +
+			"ZzV4SzR4QkRaMm5BYmF4THRhTGl2ODVieEo3ZVBkMWRrTzIzSFEiLCJ5IjoiNGFpSzcyc0JlVUFH" +
+			"a3YwVGFMc213b2tZVVl5TnhHc1M1RU1JS3dzTklLayJ9LCJub25jZSI6Im5vbmNlIn0"
+
+		// {"alg":"RS256","jwk":{"e":"AQAB","kty":"RSA","n":"..."},"nonce":"nonce"}
+		rs256phead = "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJlIjoiQVFBQiIsImt0eSI6" +
+			"IlJTQSIsIm4iOiI0eGdaM2VSUGt3b1J2eTdxZVJVYm1NRGUwVi14" +
+			"SDllV0xkdTBpaGVlTGxybUQybXFXWGZQOUllU0tBcGJuMzRnOFR1" +
+			"QVM5ZzV6aHE4RUxRM2ttanItS1Y4NkdBTWdJNlZBY0dscTNRcnpw" +
+			"VENmXzMwQWI3LXphd3JmUmFGT05hMUh3RXpQWTFLSG5HVmt4SmM4" +
+			"NWdOa3dZSTlTWTJSSFh0dmxuM3pzNXdJVE5yZG9zcUVYZWFJa1ZZ" +
+			"QkVoYmhOdTU0cHAza3hvNlR1V0xpOWU2cFhlV2V0RXdtbEJ3dFda" +
+			"bFBvaWIyajNUeExCa3NLWmZveUZ5ZWszODBtSGdKQXVtUV9JMmZq" +
+			"ajk4Xzk3bWszaWhPWTRBZ1ZkQ0RqMXpfR0NvWmtHNVJxN25iQ0d5" +
+			"b3N5S1d5RFgwMFpzLW5OcVZob0xlSXZYQzRubldkSk1aNnJvZ3h5" +
+			"UVEifSwibm9uY2UiOiJub25jZSJ9"
+	)
+
+	tt := []struct {
+		alg, phead string
+		pub        crypto.PublicKey
+	}{
+		{"RS256", rs256phead, testKey.Public()},
+		{"ES256", es256phead, testKeyEC.Public()},
+	}
+	for _, tc := range tt {
+		tc := tc
+		t.Run(tc.alg, func(t *testing.T) {
+			signer := &customTestSigner{
+				sig: []byte("testsig"),
+				pub: tc.pub,
+			}
+			b, err := jwsEncodeJSON(claims, signer, "nonce")
+			if err != nil {
+				t.Fatal(err)
+			}
+			var j struct{ Protected, Payload, Signature string }
+			if err := json.Unmarshal(b, &j); err != nil {
+				t.Fatal(err)
+			}
+			if j.Protected != tc.phead {
+				t.Errorf("j.Protected = %q\nwant %q", j.Protected, tc.phead)
+			}
+			if j.Payload != payload {
+				t.Errorf("j.Payload = %q\nwant %q", j.Payload, payload)
+			}
+			if j.Signature != testsig {
+				t.Errorf("j.Signature = %q\nwant %q", j.Signature, testsig)
+			}
+		})
+	}
+}
+
 func TestJWKThumbprintRSA(t *testing.T) {
 	// Key example from RFC 7638
 	const base64N = "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx4cbbfAAt" +
diff --git a/vendor/golang.org/x/crypto/bcrypt/bcrypt_test.go b/vendor/golang.org/x/crypto/bcrypt/bcrypt_test.go
index aecf759e..b7162d82 100644
--- a/vendor/golang.org/x/crypto/bcrypt/bcrypt_test.go
+++ b/vendor/golang.org/x/crypto/bcrypt/bcrypt_test.go
@@ -209,19 +209,19 @@ func TestMinorNotRequired(t *testing.T) {
 func BenchmarkEqual(b *testing.B) {
 	b.StopTimer()
 	passwd := []byte("somepasswordyoulike")
-	hash, _ := GenerateFromPassword(passwd, 10)
+	hash, _ := GenerateFromPassword(passwd, DefaultCost)
 	b.StartTimer()
 	for i := 0; i < b.N; i++ {
 		CompareHashAndPassword(hash, passwd)
 	}
 }
 
-func BenchmarkGeneration(b *testing.B) {
+func BenchmarkDefaultCost(b *testing.B) {
 	b.StopTimer()
 	passwd := []byte("mylongpassword1234")
 	b.StartTimer()
 	for i := 0; i < b.N; i++ {
-		GenerateFromPassword(passwd, 10)
+		GenerateFromPassword(passwd, DefaultCost)
 	}
 }
 
diff --git a/vendor/golang.org/x/crypto/blake2b/blake2x.go b/vendor/golang.org/x/crypto/blake2b/blake2x.go
index c814496a..52c414db 100644
--- a/vendor/golang.org/x/crypto/blake2b/blake2x.go
+++ b/vendor/golang.org/x/crypto/blake2b/blake2x.go
@@ -29,7 +29,7 @@ type XOF interface {
 }
 
 // OutputLengthUnknown can be used as the size argument to NewXOF to indicate
-// the the length of the output is not known in advance.
+// the length of the output is not known in advance.
 const OutputLengthUnknown = 0
 
 // magicUnknownOutputLength is a magic value for the output size that indicates
diff --git a/vendor/golang.org/x/crypto/blake2s/blake2x.go b/vendor/golang.org/x/crypto/blake2s/blake2x.go
index eaff2a7f..828749ff 100644
--- a/vendor/golang.org/x/crypto/blake2s/blake2x.go
+++ b/vendor/golang.org/x/crypto/blake2s/blake2x.go
@@ -29,7 +29,7 @@ type XOF interface {
 }
 
 // OutputLengthUnknown can be used as the size argument to NewXOF to indicate
-// the the length of the output is not known in advance.
+// the length of the output is not known in advance.
 const OutputLengthUnknown = 0
 
 // magicUnknownOutputLength is a magic value for the output size that indicates
diff --git a/vendor/golang.org/x/crypto/cryptobyte/builder.go b/vendor/golang.org/x/crypto/cryptobyte/builder.go
index 29b4c764..ca7b1db5 100644
--- a/vendor/golang.org/x/crypto/cryptobyte/builder.go
+++ b/vendor/golang.org/x/crypto/cryptobyte/builder.go
@@ -50,8 +50,14 @@ func NewFixedBuilder(buffer []byte) *Builder {
 	}
 }
 
+// SetError sets the value to be returned as the error from Bytes. Writes
+// performed after calling SetError are ignored.
+func (b *Builder) SetError(err error) {
+	b.err = err
+}
+
 // Bytes returns the bytes written by the builder or an error if one has
-// occurred during during building.
+// occurred during building.
 func (b *Builder) Bytes() ([]byte, error) {
 	if b.err != nil {
 		return nil, b.err
@@ -94,7 +100,7 @@ func (b *Builder) AddBytes(v []byte) {
 	b.add(v...)
 }
 
-// BuilderContinuation is continuation-passing interface for building
+// BuilderContinuation is a continuation-passing interface for building
 // length-prefixed byte sequences. Builder methods for length-prefixed
 // sequences (AddUint8LengthPrefixed etc) will invoke the BuilderContinuation
 // supplied to them. The child builder passed to the continuation can be used
@@ -268,9 +274,11 @@ func (b *Builder) flushChild() {
 		return
 	}
 
-	if !b.fixedSize {
-		b.result = child.result // In case child reallocated result.
+	if b.fixedSize && &b.result[0] != &child.result[0] {
+		panic("cryptobyte: BuilderContinuation reallocated a fixed-size buffer")
 	}
+
+	b.result = child.result
 }
 
 func (b *Builder) add(bytes ...byte) {
@@ -278,7 +286,7 @@ func (b *Builder) add(bytes ...byte) {
 		return
 	}
 	if b.child != nil {
-		panic("attempted write while child is pending")
+		panic("cryptobyte: attempted write while child is pending")
 	}
 	if len(b.result)+len(bytes) < len(bytes) {
 		b.err = errors.New("cryptobyte: length overflow")
@@ -290,6 +298,26 @@ func (b *Builder) add(bytes ...byte) {
 	b.result = append(b.result, bytes...)
 }
 
+// Unwrite rolls back n bytes written directly to the Builder. An attempt by a
+// child builder passed to a continuation to unwrite bytes from its parent will
+// panic.
+func (b *Builder) Unwrite(n int) {
+	if b.err != nil {
+		return
+	}
+	if b.child != nil {
+		panic("cryptobyte: attempted unwrite while child is pending")
+	}
+	length := len(b.result) - b.pendingLenLen - b.offset
+	if length < 0 {
+		panic("cryptobyte: internal error")
+	}
+	if n > length {
+		panic("cryptobyte: attempted to unwrite more than was written")
+	}
+	b.result = b.result[:len(b.result)-n]
+}
+
 // A MarshalingValue marshals itself into a Builder.
 type MarshalingValue interface {
 	// Marshal is called by Builder.AddValue. It receives a pointer to a builder
diff --git a/vendor/golang.org/x/crypto/cryptobyte/cryptobyte_test.go b/vendor/golang.org/x/crypto/cryptobyte/cryptobyte_test.go
index f294dd55..fe658ef3 100644
--- a/vendor/golang.org/x/crypto/cryptobyte/cryptobyte_test.go
+++ b/vendor/golang.org/x/crypto/cryptobyte/cryptobyte_test.go
@@ -327,12 +327,14 @@ func TestWriteWithPendingChild(t *testing.T) {
 	var b Builder
 	b.AddUint8LengthPrefixed(func(c *Builder) {
 		c.AddUint8LengthPrefixed(func(d *Builder) {
-			defer func() {
-				if recover() == nil {
-					t.Errorf("recover() = nil, want error; c.AddUint8() did not panic")
-				}
+			func() {
+				defer func() {
+					if recover() == nil {
+						t.Errorf("recover() = nil, want error; c.AddUint8() did not panic")
+					}
+				}()
+				c.AddUint8(2) // panics
 			}()
-			c.AddUint8(2) // panics
 
 			defer func() {
 				if recover() == nil {
@@ -351,6 +353,92 @@ func TestWriteWithPendingChild(t *testing.T) {
 	})
 }
 
+func TestSetError(t *testing.T) {
+	const errorStr = "TestSetError"
+	var b Builder
+	b.SetError(errors.New(errorStr))
+
+	ret, err := b.Bytes()
+	if ret != nil {
+		t.Error("expected nil result")
+	}
+	if err == nil {
+		t.Fatal("unexpected nil error")
+	}
+	if s := err.Error(); s != errorStr {
+		t.Errorf("expected error %q, got %v", errorStr, s)
+	}
+}
+
+func TestUnwrite(t *testing.T) {
+	var b Builder
+	b.AddBytes([]byte{1, 2, 3, 4, 5})
+	b.Unwrite(2)
+	if err := builderBytesEq(&b, 1, 2, 3); err != nil {
+		t.Error(err)
+	}
+
+	func() {
+		defer func() {
+			if recover() == nil {
+				t.Errorf("recover() = nil, want error; b.Unwrite() did not panic")
+			}
+		}()
+		b.Unwrite(4) // panics
+	}()
+
+	b = Builder{}
+	b.AddBytes([]byte{1, 2, 3, 4, 5})
+	b.AddUint8LengthPrefixed(func(b *Builder) {
+		b.AddBytes([]byte{1, 2, 3, 4, 5})
+
+		defer func() {
+			if recover() == nil {
+				t.Errorf("recover() = nil, want error; b.Unwrite() did not panic")
+			}
+		}()
+		b.Unwrite(6) // panics
+	})
+
+	b = Builder{}
+	b.AddBytes([]byte{1, 2, 3, 4, 5})
+	b.AddUint8LengthPrefixed(func(c *Builder) {
+		defer func() {
+			if recover() == nil {
+				t.Errorf("recover() = nil, want error; b.Unwrite() did not panic")
+			}
+		}()
+		b.Unwrite(2) // panics (attempted unwrite while child is pending)
+	})
+}
+
+func TestFixedBuilderLengthPrefixed(t *testing.T) {
+	bufCap := 10
+	inner := bytes.Repeat([]byte{0xff}, bufCap-2)
+	buf := make([]byte, 0, bufCap)
+	b := NewFixedBuilder(buf)
+	b.AddUint16LengthPrefixed(func(b *Builder) {
+		b.AddBytes(inner)
+	})
+	if got := b.BytesOrPanic(); len(got) != bufCap {
+		t.Errorf("Expected output lenght to be %d, got %d", bufCap, len(got))
+	}
+}
+
+func TestFixedBuilderPanicReallocate(t *testing.T) {
+	defer func() {
+		recover()
+	}()
+
+	b := NewFixedBuilder(make([]byte, 0, 10))
+	b1 := NewFixedBuilder(make([]byte, 0, 10))
+	b.AddUint16LengthPrefixed(func(b *Builder) {
+		*b = *b1
+	})
+
+	t.Error("Builder did not panic")
+}
+
 // ASN.1
 
 func TestASN1Int64(t *testing.T) {
diff --git a/vendor/golang.org/x/crypto/hkdf/example_test.go b/vendor/golang.org/x/crypto/hkdf/example_test.go
index df843951..e89c260e 100644
--- a/vendor/golang.org/x/crypto/hkdf/example_test.go
+++ b/vendor/golang.org/x/crypto/hkdf/example_test.go
@@ -9,49 +9,44 @@ import (
 	"crypto/rand"
 	"crypto/sha256"
 	"fmt"
-	"golang.org/x/crypto/hkdf"
 	"io"
+
+	"golang.org/x/crypto/hkdf"
 )
 
-// Usage example that expands one master key into three other cryptographically
-// secure keys.
+// Usage example that expands one master secret into three other
+// cryptographically secure keys.
 func Example_usage() {
-	// Underlying hash function to use
+	// Underlying hash function for HMAC.
 	hash := sha256.New
 
-	// Cryptographically secure master key.
-	master := []byte{0x00, 0x01, 0x02, 0x03} // i.e. NOT this.
+	// Cryptographically secure master secret.
+	secret := []byte{0x00, 0x01, 0x02, 0x03} // i.e. NOT this.
 
-	// Non secret salt, optional (can be nil)
-	// Recommended: hash-length sized random
+	// Non-secret salt, optional (can be nil).
+	// Recommended: hash-length random value.
 	salt := make([]byte, hash().Size())
-	n, err := io.ReadFull(rand.Reader, salt)
-	if n != len(salt) || err != nil {
-		fmt.Println("error:", err)
-		return
+	if _, err := rand.Read(salt); err != nil {
+		panic(err)
 	}
 
-	// Non secret context specific info, optional (can be nil).
-	// Note, independent from the master key.
-	info := []byte{0x03, 0x14, 0x15, 0x92, 0x65}
-
-	// Create the key derivation function
-	hkdf := hkdf.New(hash, master, salt, info)
-
-	// Generate the required keys
-	keys := make([][]byte, 3)
-	for i := 0; i < len(keys); i++ {
-		keys[i] = make([]byte, 24)
-		n, err := io.ReadFull(hkdf, keys[i])
-		if n != len(keys[i]) || err != nil {
-			fmt.Println("error:", err)
-			return
+	// Non-secret context info, optional (can be nil).
+	info := []byte("hkdf example")
+
+	// Generate three 128-bit derived keys.
+	hkdf := hkdf.New(hash, secret, salt, info)
+
+	var keys [][]byte
+	for i := 0; i < 3; i++ {
+		key := make([]byte, 16)
+		if _, err := io.ReadFull(hkdf, key); err != nil {
+			panic(err)
 		}
+		keys = append(keys, key)
 	}
 
-	// Keys should contain 192 bit random keys
-	for i := 1; i <= len(keys); i++ {
-		fmt.Printf("Key #%d: %v\n", i, !bytes.Equal(keys[i-1], make([]byte, 24)))
+	for i := range keys {
+		fmt.Printf("Key #%d: %v\n", i+1, !bytes.Equal(keys[i], make([]byte, 16)))
 	}
 
 	// Output:
diff --git a/vendor/golang.org/x/crypto/hkdf/hkdf.go b/vendor/golang.org/x/crypto/hkdf/hkdf.go
index 5bc24635..dda3f143 100644
--- a/vendor/golang.org/x/crypto/hkdf/hkdf.go
+++ b/vendor/golang.org/x/crypto/hkdf/hkdf.go
@@ -8,8 +8,6 @@
 // HKDF is a cryptographic key derivation function (KDF) with the goal of
 // expanding limited input keying material into one or more cryptographically
 // strong secret keys.
-//
-// RFC 5869: https://tools.ietf.org/html/rfc5869
 package hkdf // import "golang.org/x/crypto/hkdf"
 
 import (
@@ -19,6 +17,21 @@ import (
 	"io"
 )
 
+// Extract generates a pseudorandom key for use with Expand from an input secret
+// and an optional independent salt.
+//
+// Only use this function if you need to reuse the extracted key with multiple
+// Expand invocations and different context values. Most common scenarios,
+// including the generation of multiple keys, should use New instead.
+func Extract(hash func() hash.Hash, secret, salt []byte) []byte {
+	if salt == nil {
+		salt = make([]byte, hash().Size())
+	}
+	extractor := hmac.New(hash, salt)
+	extractor.Write(secret)
+	return extractor.Sum(nil)
+}
+
 type hkdf struct {
 	expander hash.Hash
 	size     int
@@ -26,22 +39,22 @@ type hkdf struct {
 	info    []byte
 	counter byte
 
-	prev  []byte
-	cache []byte
+	prev []byte
+	buf  []byte
 }
 
 func (f *hkdf) Read(p []byte) (int, error) {
 	// Check whether enough data can be generated
 	need := len(p)
-	remains := len(f.cache) + int(255-f.counter+1)*f.size
+	remains := len(f.buf) + int(255-f.counter+1)*f.size
 	if remains < need {
 		return 0, errors.New("hkdf: entropy limit reached")
 	}
-	// Read from the cache, if enough data is present
-	n := copy(p, f.cache)
+	// Read any leftover from the buffer
+	n := copy(p, f.buf)
 	p = p[n:]
 
-	// Fill the buffer
+	// Fill the rest of the buffer
 	for len(p) > 0 {
 		f.expander.Reset()
 		f.expander.Write(f.prev)
@@ -51,25 +64,30 @@ func (f *hkdf) Read(p []byte) (int, error) {
 		f.counter++
 
 		// Copy the new batch into p
-		f.cache = f.prev
-		n = copy(p, f.cache)
+		f.buf = f.prev
+		n = copy(p, f.buf)
 		p = p[n:]
 	}
 	// Save leftovers for next run
-	f.cache = f.cache[n:]
+	f.buf = f.buf[n:]
 
 	return need, nil
 }
 
-// New returns a new HKDF using the given hash, the secret keying material to expand
-// and optional salt and info fields.
-func New(hash func() hash.Hash, secret, salt, info []byte) io.Reader {
-	if salt == nil {
-		salt = make([]byte, hash().Size())
-	}
-	extractor := hmac.New(hash, salt)
-	extractor.Write(secret)
-	prk := extractor.Sum(nil)
+// Expand returns a Reader, from which keys can be read, using the given
+// pseudorandom key and optional context info, skipping the extraction step.
+//
+// The pseudorandomKey should have been generated by Extract, or be a uniformly
+// random or pseudorandom cryptographically strong key. See RFC 5869, Section
+// 3.3. Most common scenarios will want to use New instead.
+func Expand(hash func() hash.Hash, pseudorandomKey, info []byte) io.Reader {
+	expander := hmac.New(hash, pseudorandomKey)
+	return &hkdf{expander, expander.Size(), info, 1, nil, nil}
+}
 
-	return &hkdf{hmac.New(hash, prk), extractor.Size(), info, 1, nil, nil}
+// New returns a Reader, from which keys can be read, using the given hash,
+// secret, salt and context info. Salt and info can be nil.
+func New(hash func() hash.Hash, secret, salt, info []byte) io.Reader {
+	prk := Extract(hash, secret, salt)
+	return Expand(hash, prk, info)
 }
diff --git a/vendor/golang.org/x/crypto/hkdf/hkdf_test.go b/vendor/golang.org/x/crypto/hkdf/hkdf_test.go
index cee659bc..ea575772 100644
--- a/vendor/golang.org/x/crypto/hkdf/hkdf_test.go
+++ b/vendor/golang.org/x/crypto/hkdf/hkdf_test.go
@@ -18,6 +18,7 @@ type hkdfTest struct {
 	hash   func() hash.Hash
 	master []byte
 	salt   []byte
+	prk    []byte
 	info   []byte
 	out    []byte
 }
@@ -35,6 +36,12 @@ var hkdfTests = []hkdfTest{
 			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
 			0x08, 0x09, 0x0a, 0x0b, 0x0c,
 		},
+		[]byte{
+			0x07, 0x77, 0x09, 0x36, 0x2c, 0x2e, 0x32, 0xdf,
+			0x0d, 0xdc, 0x3f, 0x0d, 0xc4, 0x7b, 0xba, 0x63,
+			0x90, 0xb6, 0xc7, 0x3b, 0xb5, 0x0f, 0x9c, 0x31,
+			0x22, 0xec, 0x84, 0x4a, 0xd7, 0xc2, 0xb3, 0xe5,
+		},
 		[]byte{
 			0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
 			0xf8, 0xf9,
@@ -74,6 +81,12 @@ var hkdfTests = []hkdfTest{
 			0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
 			0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 		},
+		[]byte{
+			0x06, 0xa6, 0xb8, 0x8c, 0x58, 0x53, 0x36, 0x1a,
+			0x06, 0x10, 0x4c, 0x9c, 0xeb, 0x35, 0xb4, 0x5c,
+			0xef, 0x76, 0x00, 0x14, 0x90, 0x46, 0x71, 0x01,
+			0x4a, 0x19, 0x3f, 0x40, 0xc1, 0x5f, 0xc2, 0x44,
+		},
 		[]byte{
 			0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
 			0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
@@ -108,6 +121,12 @@ var hkdfTests = []hkdfTest{
 			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
 		},
 		[]byte{},
+		[]byte{
+			0x19, 0xef, 0x24, 0xa3, 0x2c, 0x71, 0x7b, 0x16,
+			0x7f, 0x33, 0xa9, 0x1d, 0x6f, 0x64, 0x8b, 0xdf,
+			0x96, 0x59, 0x67, 0x76, 0xaf, 0xdb, 0x63, 0x77,
+			0xac, 0x43, 0x4c, 0x1c, 0x29, 0x3c, 0xcb, 0x04,
+		},
 		[]byte{},
 		[]byte{
 			0x8d, 0xa4, 0xe7, 0x75, 0xa5, 0x63, 0xc1, 0x8f,
@@ -118,6 +137,30 @@ var hkdfTests = []hkdfTest{
 			0x96, 0xc8,
 		},
 	},
+	{
+		sha256.New,
+		[]byte{
+			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+		},
+		nil,
+		[]byte{
+			0x19, 0xef, 0x24, 0xa3, 0x2c, 0x71, 0x7b, 0x16,
+			0x7f, 0x33, 0xa9, 0x1d, 0x6f, 0x64, 0x8b, 0xdf,
+			0x96, 0x59, 0x67, 0x76, 0xaf, 0xdb, 0x63, 0x77,
+			0xac, 0x43, 0x4c, 0x1c, 0x29, 0x3c, 0xcb, 0x04,
+		},
+		nil,
+		[]byte{
+			0x8d, 0xa4, 0xe7, 0x75, 0xa5, 0x63, 0xc1, 0x8f,
+			0x71, 0x5f, 0x80, 0x2a, 0x06, 0x3c, 0x5a, 0x31,
+			0xb8, 0xa1, 0x1f, 0x5c, 0x5e, 0xe1, 0x87, 0x9e,
+			0xc3, 0x45, 0x4e, 0x5f, 0x3c, 0x73, 0x8d, 0x2d,
+			0x9d, 0x20, 0x13, 0x95, 0xfa, 0xa4, 0xb6, 0x1a,
+			0x96, 0xc8,
+		},
+	},
 	{
 		sha1.New,
 		[]byte{
@@ -128,6 +171,11 @@ var hkdfTests = []hkdfTest{
 			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
 			0x08, 0x09, 0x0a, 0x0b, 0x0c,
 		},
+		[]byte{
+			0x9b, 0x6c, 0x18, 0xc4, 0x32, 0xa7, 0xbf, 0x8f,
+			0x0e, 0x71, 0xc8, 0xeb, 0x88, 0xf4, 0xb3, 0x0b,
+			0xaa, 0x2b, 0xa2, 0x43,
+		},
 		[]byte{
 			0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
 			0xf8, 0xf9,
@@ -167,6 +215,11 @@ var hkdfTests = []hkdfTest{
 			0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
 			0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 		},
+		[]byte{
+			0x8a, 0xda, 0xe0, 0x9a, 0x2a, 0x30, 0x70, 0x59,
+			0x47, 0x8d, 0x30, 0x9b, 0x26, 0xc4, 0x11, 0x5a,
+			0x22, 0x4c, 0xfa, 0xf6,
+		},
 		[]byte{
 			0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
 			0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
@@ -201,6 +254,11 @@ var hkdfTests = []hkdfTest{
 			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
 		},
 		[]byte{},
+		[]byte{
+			0xda, 0x8c, 0x8a, 0x73, 0xc7, 0xfa, 0x77, 0x28,
+			0x8e, 0xc6, 0xf5, 0xe7, 0xc2, 0x97, 0x78, 0x6a,
+			0xa0, 0xd3, 0x2d, 0x01,
+		},
 		[]byte{},
 		[]byte{
 			0x0a, 0xc1, 0xaf, 0x70, 0x02, 0xb3, 0xd7, 0x61,
@@ -219,7 +277,12 @@ var hkdfTests = []hkdfTest{
 			0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
 		},
 		nil,
-		[]byte{},
+		[]byte{
+			0x2a, 0xdc, 0xca, 0xda, 0x18, 0x77, 0x9e, 0x7c,
+			0x20, 0x77, 0xad, 0x2e, 0xb1, 0x9d, 0x3f, 0x3e,
+			0x73, 0x13, 0x85, 0xdd,
+		},
+		nil,
 		[]byte{
 			0x2c, 0x91, 0x11, 0x72, 0x04, 0xd7, 0x45, 0xf3,
 			0x50, 0x0d, 0x63, 0x6a, 0x62, 0xf6, 0x4f, 0x0a,
@@ -233,6 +296,11 @@ var hkdfTests = []hkdfTest{
 
 func TestHKDF(t *testing.T) {
 	for i, tt := range hkdfTests {
+		prk := Extract(tt.hash, tt.master, tt.salt)
+		if !bytes.Equal(prk, tt.prk) {
+			t.Errorf("test %d: incorrect PRK: have %v, need %v.", i, prk, tt.prk)
+		}
+
 		hkdf := New(tt.hash, tt.master, tt.salt, tt.info)
 		out := make([]byte, len(tt.out))
 
@@ -244,6 +312,17 @@ func TestHKDF(t *testing.T) {
 		if !bytes.Equal(out, tt.out) {
 			t.Errorf("test %d: incorrect output: have %v, need %v.", i, out, tt.out)
 		}
+
+		hkdf = Expand(tt.hash, prk, tt.info)
+
+		n, err = io.ReadFull(hkdf, out)
+		if n != len(tt.out) || err != nil {
+			t.Errorf("test %d: not enough output bytes from Expand: %d.", i, n)
+		}
+
+		if !bytes.Equal(out, tt.out) {
+			t.Errorf("test %d: incorrect output from Expand: have %v, need %v.", i, out, tt.out)
+		}
 	}
 }
 
diff --git a/vendor/golang.org/x/crypto/ocsp/ocsp.go b/vendor/golang.org/x/crypto/ocsp/ocsp.go
index 5edc9c97..f079d9ea 100644
--- a/vendor/golang.org/x/crypto/ocsp/ocsp.go
+++ b/vendor/golang.org/x/crypto/ocsp/ocsp.go
@@ -63,7 +63,7 @@ func (r ResponseStatus) String() string {
 }
 
 // ResponseError is an error that may be returned by ParseResponse to indicate
-// that the response itself is an error, not just that its indicating that a
+// that the response itself is an error, not just that it's indicating that a
 // certificate is revoked, unknown, etc.
 type ResponseError struct {
 	Status ResponseStatus
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/packet.go b/vendor/golang.org/x/crypto/openpgp/packet/packet.go
index 625bb5ac..5af64c54 100644
--- a/vendor/golang.org/x/crypto/openpgp/packet/packet.go
+++ b/vendor/golang.org/x/crypto/openpgp/packet/packet.go
@@ -404,14 +404,16 @@ const (
 type PublicKeyAlgorithm uint8
 
 const (
-	PubKeyAlgoRSA            PublicKeyAlgorithm = 1
-	PubKeyAlgoRSAEncryptOnly PublicKeyAlgorithm = 2
-	PubKeyAlgoRSASignOnly    PublicKeyAlgorithm = 3
-	PubKeyAlgoElGamal        PublicKeyAlgorithm = 16
-	PubKeyAlgoDSA            PublicKeyAlgorithm = 17
+	PubKeyAlgoRSA     PublicKeyAlgorithm = 1
+	PubKeyAlgoElGamal PublicKeyAlgorithm = 16
+	PubKeyAlgoDSA     PublicKeyAlgorithm = 17
 	// RFC 6637, Section 5.
 	PubKeyAlgoECDH  PublicKeyAlgorithm = 18
 	PubKeyAlgoECDSA PublicKeyAlgorithm = 19
+
+	// Deprecated in RFC 4880, Section 13.5. Use key flags instead.
+	PubKeyAlgoRSAEncryptOnly PublicKeyAlgorithm = 2
+	PubKeyAlgoRSASignOnly    PublicKeyAlgorithm = 3
 )
 
 // CanEncrypt returns true if it's possible to encrypt a message to a public
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/private_key.go b/vendor/golang.org/x/crypto/openpgp/packet/private_key.go
index 87fc461a..bd31ccea 100644
--- a/vendor/golang.org/x/crypto/openpgp/packet/private_key.go
+++ b/vendor/golang.org/x/crypto/openpgp/packet/private_key.go
@@ -64,7 +64,7 @@ func NewECDSAPrivateKey(currentTime time.Time, priv *ecdsa.PrivateKey) *PrivateK
 	return pk
 }
 
-// NewSignerPrivateKey creates a sign-only PrivateKey from a crypto.Signer that
+// NewSignerPrivateKey creates a PrivateKey from a crypto.Signer that
 // implements RSA or ECDSA.
 func NewSignerPrivateKey(currentTime time.Time, signer crypto.Signer) *PrivateKey {
 	pk := new(PrivateKey)
@@ -73,10 +73,8 @@ func NewSignerPrivateKey(currentTime time.Time, signer crypto.Signer) *PrivateKe
 	switch pubkey := signer.Public().(type) {
 	case *rsa.PublicKey:
 		pk.PublicKey = *NewRSAPublicKey(currentTime, pubkey)
-		pk.PubKeyAlgo = PubKeyAlgoRSASignOnly
 	case rsa.PublicKey:
 		pk.PublicKey = *NewRSAPublicKey(currentTime, &pubkey)
-		pk.PubKeyAlgo = PubKeyAlgoRSASignOnly
 	case *ecdsa.PublicKey:
 		pk.PublicKey = *NewECDSAPublicKey(currentTime, pubkey)
 	case ecdsa.PublicKey:
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/private_key_test.go b/vendor/golang.org/x/crypto/openpgp/packet/private_key_test.go
index 794d746a..cc08b483 100644
--- a/vendor/golang.org/x/crypto/openpgp/packet/private_key_test.go
+++ b/vendor/golang.org/x/crypto/openpgp/packet/private_key_test.go
@@ -172,12 +172,8 @@ func TestRSASignerPrivateKey(t *testing.T) {
 
 	priv := NewSignerPrivateKey(time.Now(), &rsaSigner{rsaPriv})
 
-	if priv.PubKeyAlgo != PubKeyAlgoRSASignOnly {
-		t.Fatal("NewSignerPrivateKey should have made a sign-only RSA private key")
-	}
-
 	sig := &Signature{
-		PubKeyAlgo: PubKeyAlgoRSASignOnly,
+		PubKeyAlgo: PubKeyAlgoRSA,
 		Hash:       crypto.SHA256,
 	}
 	msg := []byte("Hello World!")
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/signature.go b/vendor/golang.org/x/crypto/openpgp/packet/signature.go
index 6ce0cbed..b2a24a53 100644
--- a/vendor/golang.org/x/crypto/openpgp/packet/signature.go
+++ b/vendor/golang.org/x/crypto/openpgp/packet/signature.go
@@ -542,7 +542,7 @@ func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey, config *Config) (err e
 			r, s, err = ecdsa.Sign(config.Random(), pk, digest)
 		} else {
 			var b []byte
-			b, err = priv.PrivateKey.(crypto.Signer).Sign(config.Random(), digest, nil)
+			b, err = priv.PrivateKey.(crypto.Signer).Sign(config.Random(), digest, sig.Hash)
 			if err == nil {
 				r, s, err = unwrapECDSASig(b)
 			}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/userattribute.go b/vendor/golang.org/x/crypto/openpgp/packet/userattribute.go
index 96a2b382..d19ffbc7 100644
--- a/vendor/golang.org/x/crypto/openpgp/packet/userattribute.go
+++ b/vendor/golang.org/x/crypto/openpgp/packet/userattribute.go
@@ -80,7 +80,7 @@ func (uat *UserAttribute) Serialize(w io.Writer) (err error) {
 
 // ImageData returns zero or more byte slices, each containing
 // JPEG File Interchange Format (JFIF), for each photo in the
-// the user attribute packet.
+// user attribute packet.
 func (uat *UserAttribute) ImageData() (imageData [][]byte) {
 	for _, sp := range uat.Contents {
 		if sp.SubType == UserAttrImageSubpacket && len(sp.Contents) > 16 {
diff --git a/vendor/golang.org/x/crypto/ripemd160/ripemd160.go b/vendor/golang.org/x/crypto/ripemd160/ripemd160.go
index 6c6e8423..fd97ba1b 100644
--- a/vendor/golang.org/x/crypto/ripemd160/ripemd160.go
+++ b/vendor/golang.org/x/crypto/ripemd160/ripemd160.go
@@ -5,7 +5,7 @@
 // Package ripemd160 implements the RIPEMD-160 hash algorithm.
 package ripemd160 // import "golang.org/x/crypto/ripemd160"
 
-// RIPEMD-160 is designed by by Hans Dobbertin, Antoon Bosselaers, and Bart
+// RIPEMD-160 is designed by Hans Dobbertin, Antoon Bosselaers, and Bart
 // Preneel with specifications available at:
 // http://homes.esat.kuleuven.be/~cosicart/pdf/AB-9601/AB-9601.pdf.
 
diff --git a/vendor/golang.org/x/crypto/scrypt/scrypt.go b/vendor/golang.org/x/crypto/scrypt/scrypt.go
index 9b25b5ac..3362afd1 100644
--- a/vendor/golang.org/x/crypto/scrypt/scrypt.go
+++ b/vendor/golang.org/x/crypto/scrypt/scrypt.go
@@ -29,7 +29,7 @@ func blockXOR(dst, src []uint32, n int) {
 }
 
 // salsaXOR applies Salsa20/8 to the XOR of 16 numbers from tmp and in,
-// and puts the result into both both tmp and out.
+// and puts the result into both tmp and out.
 func salsaXOR(tmp *[16]uint32, in, out []uint32) {
 	w0 := tmp[0] ^ in[0]
 	w1 := tmp[1] ^ in[1]
diff --git a/vendor/golang.org/x/crypto/sha3/doc.go b/vendor/golang.org/x/crypto/sha3/doc.go
index a0ee3ae7..c2fef30a 100644
--- a/vendor/golang.org/x/crypto/sha3/doc.go
+++ b/vendor/golang.org/x/crypto/sha3/doc.go
@@ -43,7 +43,7 @@
 // is then "full" and the permutation is applied to "empty" it. This process is
 // repeated until all the input has been "absorbed". The input is then padded.
 // The digest is "squeezed" from the sponge in the same way, except that output
-// output is copied out instead of input being XORed in.
+// is copied out instead of input being XORed in.
 //
 // A sponge is parameterized by its generic security strength, which is equal
 // to half its capacity; capacity + rate is equal to the permutation's width.
diff --git a/vendor/golang.org/x/crypto/ssh/agent/client.go b/vendor/golang.org/x/crypto/ssh/agent/client.go
index b1808dd2..51f74050 100644
--- a/vendor/golang.org/x/crypto/ssh/agent/client.go
+++ b/vendor/golang.org/x/crypto/ssh/agent/client.go
@@ -25,10 +25,22 @@ import (
 	"math/big"
 	"sync"
 
+	"crypto"
 	"golang.org/x/crypto/ed25519"
 	"golang.org/x/crypto/ssh"
 )
 
+// SignatureFlags represent additional flags that can be passed to the signature
+// requests an defined in [PROTOCOL.agent] section 4.5.1.
+type SignatureFlags uint32
+
+// SignatureFlag values as defined in [PROTOCOL.agent] section 5.3.
+const (
+	SignatureFlagReserved SignatureFlags = 1 << iota
+	SignatureFlagRsaSha256
+	SignatureFlagRsaSha512
+)
+
 // Agent represents the capabilities of an ssh-agent.
 type Agent interface {
 	// List returns the identities known to the agent.
@@ -57,6 +69,26 @@ type Agent interface {
 	Signers() ([]ssh.Signer, error)
 }
 
+type ExtendedAgent interface {
+	Agent
+
+	// SignWithFlags signs like Sign, but allows for additional flags to be sent/received
+	SignWithFlags(key ssh.PublicKey, data []byte, flags SignatureFlags) (*ssh.Signature, error)
+
+	// Extension processes a custom extension request. Standard-compliant agents are not
+	// required to support any extensions, but this method allows agents to implement
+	// vendor-specific methods or add experimental features. See [PROTOCOL.agent] section 4.7.
+	// If agent extensions are unsupported entirely this method MUST return an
+	// ErrExtensionUnsupported error. Similarly, if just the specific extensionType in
+	// the request is unsupported by the agent then ErrExtensionUnsupported MUST be
+	// returned.
+	//
+	// In the case of success, since [PROTOCOL.agent] section 4.7 specifies that the contents
+	// of the response are unspecified (including the type of the message), the complete
+	// response will be returned as a []byte slice, including the "type" byte of the message.
+	Extension(extensionType string, contents []byte) ([]byte, error)
+}
+
 // ConstraintExtension describes an optional constraint defined by users.
 type ConstraintExtension struct {
 	// ExtensionName consist of a UTF-8 string suffixed by the
@@ -179,6 +211,23 @@ type constrainExtensionAgentMsg struct {
 	Rest []byte `ssh:"rest"`
 }
 
+// See [PROTOCOL.agent], section 4.7
+const agentExtension = 27
+const agentExtensionFailure = 28
+
+// ErrExtensionUnsupported indicates that an extension defined in
+// [PROTOCOL.agent] section 4.7 is unsupported by the agent. Specifically this
+// error indicates that the agent returned a standard SSH_AGENT_FAILURE message
+// as the result of a SSH_AGENTC_EXTENSION request. Note that the protocol
+// specification (and therefore this error) does not distinguish between a
+// specific extension being unsupported and extensions being unsupported entirely.
+var ErrExtensionUnsupported = errors.New("agent: extension unsupported")
+
+type extensionAgentMsg struct {
+	ExtensionType string `sshtype:"27"`
+	Contents      []byte
+}
+
 // Key represents a protocol 2 public key as defined in
 // [PROTOCOL.agent], section 2.5.2.
 type Key struct {
@@ -260,7 +309,7 @@ type client struct {
 
 // NewClient returns an Agent that talks to an ssh-agent process over
 // the given connection.
-func NewClient(rw io.ReadWriter) Agent {
+func NewClient(rw io.ReadWriter) ExtendedAgent {
 	return &client{conn: rw}
 }
 
@@ -268,6 +317,21 @@ func NewClient(rw io.ReadWriter) Agent {
 // unmarshaled into reply and replyType is set to the first byte of
 // the reply, which contains the type of the message.
 func (c *client) call(req []byte) (reply interface{}, err error) {
+	buf, err := c.callRaw(req)
+	if err != nil {
+		return nil, err
+	}
+	reply, err = unmarshal(buf)
+	if err != nil {
+		return nil, clientErr(err)
+	}
+	return reply, nil
+}
+
+// callRaw sends an RPC to the agent. On success, the raw
+// bytes of the response are returned; no unmarshalling is
+// performed on the response.
+func (c *client) callRaw(req []byte) (reply []byte, err error) {
 	c.mu.Lock()
 	defer c.mu.Unlock()
 
@@ -284,18 +348,14 @@ func (c *client) call(req []byte) (reply interface{}, err error) {
 	}
 	respSize := binary.BigEndian.Uint32(respSizeBuf[:])
 	if respSize > maxAgentResponseBytes {
-		return nil, clientErr(err)
+		return nil, clientErr(errors.New("response too large"))
 	}
 
 	buf := make([]byte, respSize)
 	if _, err = io.ReadFull(c.conn, buf); err != nil {
 		return nil, clientErr(err)
 	}
-	reply, err = unmarshal(buf)
-	if err != nil {
-		return nil, clientErr(err)
-	}
-	return reply, err
+	return buf, nil
 }
 
 func (c *client) simpleCall(req []byte) error {
@@ -369,9 +429,14 @@ func (c *client) List() ([]*Key, error) {
 // Sign has the agent sign the data using a protocol 2 key as defined
 // in [PROTOCOL.agent] section 2.6.2.
 func (c *client) Sign(key ssh.PublicKey, data []byte) (*ssh.Signature, error) {
+	return c.SignWithFlags(key, data, 0)
+}
+
+func (c *client) SignWithFlags(key ssh.PublicKey, data []byte, flags SignatureFlags) (*ssh.Signature, error) {
 	req := ssh.Marshal(signRequestAgentMsg{
 		KeyBlob: key.Marshal(),
 		Data:    data,
+		Flags:   uint32(flags),
 	})
 
 	msg, err := c.call(req)
@@ -681,3 +746,44 @@ func (s *agentKeyringSigner) Sign(rand io.Reader, data []byte) (*ssh.Signature,
 	// The agent has its own entropy source, so the rand argument is ignored.
 	return s.agent.Sign(s.pub, data)
 }
+
+func (s *agentKeyringSigner) SignWithOpts(rand io.Reader, data []byte, opts crypto.SignerOpts) (*ssh.Signature, error) {
+	var flags SignatureFlags
+	if opts != nil {
+		switch opts.HashFunc() {
+		case crypto.SHA256:
+			flags = SignatureFlagRsaSha256
+		case crypto.SHA512:
+			flags = SignatureFlagRsaSha512
+		}
+	}
+	return s.agent.SignWithFlags(s.pub, data, flags)
+}
+
+// Calls an extension method. It is up to the agent implementation as to whether or not
+// any particular extension is supported and may always return an error. Because the
+// type of the response is up to the implementation, this returns the bytes of the
+// response and does not attempt any type of unmarshalling.
+func (c *client) Extension(extensionType string, contents []byte) ([]byte, error) {
+	req := ssh.Marshal(extensionAgentMsg{
+		ExtensionType: extensionType,
+		Contents:      contents,
+	})
+	buf, err := c.callRaw(req)
+	if err != nil {
+		return nil, err
+	}
+	if len(buf) == 0 {
+		return nil, errors.New("agent: failure; empty response")
+	}
+	// [PROTOCOL.agent] section 4.7 indicates that an SSH_AGENT_FAILURE message
+	// represents an agent that does not support the extension
+	if buf[0] == agentFailure {
+		return nil, ErrExtensionUnsupported
+	}
+	if buf[0] == agentExtensionFailure {
+		return nil, errors.New("agent: generic extension failure")
+	}
+
+	return buf, nil
+}
diff --git a/vendor/golang.org/x/crypto/ssh/agent/client_test.go b/vendor/golang.org/x/crypto/ssh/agent/client_test.go
index 266fd6d4..2f798f94 100644
--- a/vendor/golang.org/x/crypto/ssh/agent/client_test.go
+++ b/vendor/golang.org/x/crypto/ssh/agent/client_test.go
@@ -20,7 +20,7 @@ import (
 )
 
 // startOpenSSHAgent executes ssh-agent, and returns an Agent interface to it.
-func startOpenSSHAgent(t *testing.T) (client Agent, socket string, cleanup func()) {
+func startOpenSSHAgent(t *testing.T) (client ExtendedAgent, socket string, cleanup func()) {
 	if testing.Short() {
 		// ssh-agent is not always available, and the key
 		// types supported vary by platform.
@@ -79,13 +79,12 @@ func startOpenSSHAgent(t *testing.T) (client Agent, socket string, cleanup func(
 	}
 }
 
-// startKeyringAgent uses Keyring to simulate a ssh-agent Server and returns a client.
-func startKeyringAgent(t *testing.T) (client Agent, cleanup func()) {
+func startAgent(t *testing.T, agent Agent) (client ExtendedAgent, cleanup func()) {
 	c1, c2, err := netPipe()
 	if err != nil {
 		t.Fatalf("netPipe: %v", err)
 	}
-	go ServeAgent(NewKeyring(), c2)
+	go ServeAgent(agent, c2)
 
 	return NewClient(c1), func() {
 		c1.Close()
@@ -93,6 +92,11 @@ func startKeyringAgent(t *testing.T) (client Agent, cleanup func()) {
 	}
 }
 
+// startKeyringAgent uses Keyring to simulate a ssh-agent Server and returns a client.
+func startKeyringAgent(t *testing.T) (client ExtendedAgent, cleanup func()) {
+	return startAgent(t, NewKeyring())
+}
+
 func testOpenSSHAgent(t *testing.T, key interface{}, cert *ssh.Certificate, lifetimeSecs uint32) {
 	agent, _, cleanup := startOpenSSHAgent(t)
 	defer cleanup()
@@ -107,7 +111,7 @@ func testKeyringAgent(t *testing.T, key interface{}, cert *ssh.Certificate, life
 	testAgentInterface(t, agent, key, cert, lifetimeSecs)
 }
 
-func testAgentInterface(t *testing.T, agent Agent, key interface{}, cert *ssh.Certificate, lifetimeSecs uint32) {
+func testAgentInterface(t *testing.T, agent ExtendedAgent, key interface{}, cert *ssh.Certificate, lifetimeSecs uint32) {
 	signer, err := ssh.NewSignerFromKey(key)
 	if err != nil {
 		t.Fatalf("NewSignerFromKey(%T): %v", key, err)
@@ -159,6 +163,25 @@ func testAgentInterface(t *testing.T, agent Agent, key interface{}, cert *ssh.Ce
 		t.Fatalf("Verify(%s): %v", pubKey.Type(), err)
 	}
 
+	// For tests on RSA keys, try signing with SHA-256 and SHA-512 flags
+	if pubKey.Type() == "ssh-rsa" {
+		sshFlagTest := func(flag SignatureFlags, expectedSigFormat string) {
+			sig, err = agent.SignWithFlags(pubKey, data, flag)
+			if err != nil {
+				t.Fatalf("SignWithFlags(%s): %v", pubKey.Type(), err)
+			}
+			if sig.Format != expectedSigFormat {
+				t.Fatalf("Signature format didn't match expected value: %s != %s", sig.Format, expectedSigFormat)
+			}
+			if err := pubKey.Verify(data, sig); err != nil {
+				t.Fatalf("Verify(%s): %v", pubKey.Type(), err)
+			}
+		}
+		sshFlagTest(0, ssh.SigAlgoRSA)
+		sshFlagTest(SignatureFlagRsaSha256, ssh.SigAlgoRSASHA2256)
+		sshFlagTest(SignatureFlagRsaSha512, ssh.SigAlgoRSASHA2512)
+	}
+
 	// If the key has a lifetime, is it removed when it should be?
 	if lifetimeSecs > 0 {
 		time.Sleep(time.Second*time.Duration(lifetimeSecs) + 100*time.Millisecond)
@@ -218,6 +241,35 @@ func netPipe() (net.Conn, net.Conn, error) {
 	return c1, c2, nil
 }
 
+func TestServerResponseTooLarge(t *testing.T) {
+	a, b, err := netPipe()
+	if err != nil {
+		t.Fatalf("netPipe: %v", err)
+	}
+
+	defer a.Close()
+	defer b.Close()
+
+	var response identitiesAnswerAgentMsg
+	response.NumKeys = 1
+	response.Keys = make([]byte, maxAgentResponseBytes+1)
+
+	agent := NewClient(a)
+	go func() {
+		n, _ := b.Write(ssh.Marshal(response))
+		if n < 4 {
+			t.Fatalf("At least 4 bytes (the response size) should have been successfully written: %d < 4", n)
+		}
+	}()
+	_, err = agent.List()
+	if err == nil {
+		t.Fatal("Did not get error result")
+	}
+	if err.Error() != "agent: client error: response too large" {
+		t.Fatal("Did not get expected error result")
+	}
+}
+
 func TestAuth(t *testing.T) {
 	agent, _, cleanup := startOpenSSHAgent(t)
 	defer cleanup()
@@ -377,3 +429,38 @@ func testAgentLifetime(t *testing.T, agent Agent) {
 		t.Errorf("Want 0 keys, got %v", len(keys))
 	}
 }
+
+type keyringExtended struct {
+	*keyring
+}
+
+func (r *keyringExtended) Extension(extensionType string, contents []byte) ([]byte, error) {
+	if extensionType != "my-extension@example.com" {
+		return []byte{agentExtensionFailure}, nil
+	}
+	return append([]byte{agentSuccess}, contents...), nil
+}
+
+func TestAgentExtensions(t *testing.T) {
+	agent, _, cleanup := startOpenSSHAgent(t)
+	defer cleanup()
+	result, err := agent.Extension("my-extension@example.com", []byte{0x00, 0x01, 0x02})
+	if err == nil {
+		t.Fatal("should have gotten agent extension failure")
+	}
+
+	agent, cleanup = startAgent(t, &keyringExtended{})
+	defer cleanup()
+	result, err = agent.Extension("my-extension@example.com", []byte{0x00, 0x01, 0x02})
+	if err != nil {
+		t.Fatalf("agent extension failure: %v", err)
+	}
+	if len(result) != 4 || !bytes.Equal(result, []byte{agentSuccess, 0x00, 0x01, 0x02}) {
+		t.Fatalf("agent extension result invalid: %v", result)
+	}
+
+	result, err = agent.Extension("bad-extension@example.com", []byte{0x00, 0x01, 0x02})
+	if err == nil {
+		t.Fatal("should have gotten agent extension failure")
+	}
+}
diff --git a/vendor/golang.org/x/crypto/ssh/agent/keyring.go b/vendor/golang.org/x/crypto/ssh/agent/keyring.go
index 1a516327..c9d97943 100644
--- a/vendor/golang.org/x/crypto/ssh/agent/keyring.go
+++ b/vendor/golang.org/x/crypto/ssh/agent/keyring.go
@@ -182,6 +182,10 @@ func (r *keyring) Add(key AddedKey) error {
 
 // Sign returns a signature for the data.
 func (r *keyring) Sign(key ssh.PublicKey, data []byte) (*ssh.Signature, error) {
+	return r.SignWithFlags(key, data, 0)
+}
+
+func (r *keyring) SignWithFlags(key ssh.PublicKey, data []byte, flags SignatureFlags) (*ssh.Signature, error) {
 	r.mu.Lock()
 	defer r.mu.Unlock()
 	if r.locked {
@@ -192,7 +196,24 @@ func (r *keyring) Sign(key ssh.PublicKey, data []byte) (*ssh.Signature, error) {
 	wanted := key.Marshal()
 	for _, k := range r.keys {
 		if bytes.Equal(k.signer.PublicKey().Marshal(), wanted) {
-			return k.signer.Sign(rand.Reader, data)
+			if flags == 0 {
+				return k.signer.Sign(rand.Reader, data)
+			} else {
+				if algorithmSigner, ok := k.signer.(ssh.AlgorithmSigner); !ok {
+					return nil, fmt.Errorf("agent: signature does not support non-default signature algorithm: %T", k.signer)
+				} else {
+					var algorithm string
+					switch flags {
+					case SignatureFlagRsaSha256:
+						algorithm = ssh.SigAlgoRSASHA2256
+					case SignatureFlagRsaSha512:
+						algorithm = ssh.SigAlgoRSASHA2512
+					default:
+						return nil, fmt.Errorf("agent: unsupported signature flags: %d", flags)
+					}
+					return algorithmSigner.SignWithAlgorithm(rand.Reader, data, algorithm)
+				}
+			}
 		}
 	}
 	return nil, errors.New("not found")
@@ -213,3 +234,8 @@ func (r *keyring) Signers() ([]ssh.Signer, error) {
 	}
 	return s, nil
 }
+
+// The keyring does not support any extensions
+func (r *keyring) Extension(extensionType string, contents []byte) ([]byte, error) {
+	return nil, ErrExtensionUnsupported
+}
diff --git a/vendor/golang.org/x/crypto/ssh/agent/server.go b/vendor/golang.org/x/crypto/ssh/agent/server.go
index 2e4692cb..a1949762 100644
--- a/vendor/golang.org/x/crypto/ssh/agent/server.go
+++ b/vendor/golang.org/x/crypto/ssh/agent/server.go
@@ -128,7 +128,14 @@ func (s *server) processRequest(data []byte) (interface{}, error) {
 			Blob:   req.KeyBlob,
 		}
 
-		sig, err := s.agent.Sign(k, req.Data) //  TODO(hanwen): flags.
+		var sig *ssh.Signature
+		var err error
+		if extendedAgent, ok := s.agent.(ExtendedAgent); ok {
+			sig, err = extendedAgent.SignWithFlags(k, req.Data, SignatureFlags(req.Flags))
+		} else {
+			sig, err = s.agent.Sign(k, req.Data)
+		}
+
 		if err != nil {
 			return nil, err
 		}
@@ -150,6 +157,43 @@ func (s *server) processRequest(data []byte) (interface{}, error) {
 
 	case agentAddIDConstrained, agentAddIdentity:
 		return nil, s.insertIdentity(data)
+
+	case agentExtension:
+		// Return a stub object where the whole contents of the response gets marshaled.
+		var responseStub struct {
+			Rest []byte `ssh:"rest"`
+		}
+
+		if extendedAgent, ok := s.agent.(ExtendedAgent); !ok {
+			// If this agent doesn't implement extensions, [PROTOCOL.agent] section 4.7
+			// requires that we return a standard SSH_AGENT_FAILURE message.
+			responseStub.Rest = []byte{agentFailure}
+		} else {
+			var req extensionAgentMsg
+			if err := ssh.Unmarshal(data, &req); err != nil {
+				return nil, err
+			}
+			res, err := extendedAgent.Extension(req.ExtensionType, req.Contents)
+			if err != nil {
+				// If agent extensions are unsupported, return a standard SSH_AGENT_FAILURE
+				// message as required by [PROTOCOL.agent] section 4.7.
+				if err == ErrExtensionUnsupported {
+					responseStub.Rest = []byte{agentFailure}
+				} else {
+					// As the result of any other error processing an extension request,
+					// [PROTOCOL.agent] section 4.7 requires that we return a
+					// SSH_AGENT_EXTENSION_FAILURE code.
+					responseStub.Rest = []byte{agentExtensionFailure}
+				}
+			} else {
+				if len(res) == 0 {
+					return nil, nil
+				}
+				responseStub.Rest = res
+			}
+		}
+
+		return responseStub, nil
 	}
 
 	return nil, fmt.Errorf("unknown opcode %d", data[0])
diff --git a/vendor/golang.org/x/crypto/ssh/certs.go b/vendor/golang.org/x/crypto/ssh/certs.go
index 42106f3f..00ed9923 100644
--- a/vendor/golang.org/x/crypto/ssh/certs.go
+++ b/vendor/golang.org/x/crypto/ssh/certs.go
@@ -222,6 +222,11 @@ type openSSHCertSigner struct {
 	signer Signer
 }
 
+type algorithmOpenSSHCertSigner struct {
+	*openSSHCertSigner
+	algorithmSigner AlgorithmSigner
+}
+
 // NewCertSigner returns a Signer that signs with the given Certificate, whose
 // private key is held by signer. It returns an error if the public key in cert
 // doesn't match the key used by signer.
@@ -230,7 +235,12 @@ func NewCertSigner(cert *Certificate, signer Signer) (Signer, error) {
 		return nil, errors.New("ssh: signer and cert have different public key")
 	}
 
-	return &openSSHCertSigner{cert, signer}, nil
+	if algorithmSigner, ok := signer.(AlgorithmSigner); ok {
+		return &algorithmOpenSSHCertSigner{
+			&openSSHCertSigner{cert, signer}, algorithmSigner}, nil
+	} else {
+		return &openSSHCertSigner{cert, signer}, nil
+	}
 }
 
 func (s *openSSHCertSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
@@ -241,6 +251,10 @@ func (s *openSSHCertSigner) PublicKey() PublicKey {
 	return s.pub
 }
 
+func (s *algorithmOpenSSHCertSigner) SignWithAlgorithm(rand io.Reader, data []byte, algorithm string) (*Signature, error) {
+	return s.algorithmSigner.SignWithAlgorithm(rand, data, algorithm)
+}
+
 const sourceAddressCriticalOption = "source-address"
 
 // CertChecker does the work of verifying a certificate. Its methods
diff --git a/vendor/golang.org/x/crypto/ssh/client.go b/vendor/golang.org/x/crypto/ssh/client.go
index ae6ca775..7b00bff1 100644
--- a/vendor/golang.org/x/crypto/ssh/client.go
+++ b/vendor/golang.org/x/crypto/ssh/client.go
@@ -185,7 +185,7 @@ func Dial(network, addr string, config *ClientConfig) (*Client, error) {
 // keys.  A HostKeyCallback must return nil if the host key is OK, or
 // an error to reject it. It receives the hostname as passed to Dial
 // or NewClientConn. The remote address is the RemoteAddr of the
-// net.Conn underlying the the SSH connection.
+// net.Conn underlying the SSH connection.
 type HostKeyCallback func(hostname string, remote net.Addr, key PublicKey) error
 
 // BannerCallback is the function type used for treat the banner sent by
diff --git a/vendor/golang.org/x/crypto/ssh/client_auth_test.go b/vendor/golang.org/x/crypto/ssh/client_auth_test.go
index 5fbb20d8..026d137e 100644
--- a/vendor/golang.org/x/crypto/ssh/client_auth_test.go
+++ b/vendor/golang.org/x/crypto/ssh/client_auth_test.go
@@ -9,6 +9,7 @@ import (
 	"crypto/rand"
 	"errors"
 	"fmt"
+	"io"
 	"os"
 	"strings"
 	"testing"
@@ -28,8 +29,14 @@ func (cr keyboardInteractive) Challenge(user string, instruction string, questio
 var clientPassword = "tiger"
 
 // tryAuth runs a handshake with a given config against an SSH server
-// with config serverConfig
+// with config serverConfig. Returns both client and server side errors.
 func tryAuth(t *testing.T, config *ClientConfig) error {
+	err, _ := tryAuthBothSides(t, config)
+	return err
+}
+
+// tryAuthBothSides runs the handshake and returns the resulting errors from both sides of the connection.
+func tryAuthBothSides(t *testing.T, config *ClientConfig) (clientError error, serverAuthErrors []error) {
 	c1, c2, err := netPipe()
 	if err != nil {
 		t.Fatalf("netPipe: %v", err)
@@ -79,9 +86,13 @@ func tryAuth(t *testing.T, config *ClientConfig) error {
 	}
 	serverConfig.AddHostKey(testSigners["rsa"])
 
+	serverConfig.AuthLogCallback = func(conn ConnMetadata, method string, err error) {
+		serverAuthErrors = append(serverAuthErrors, err)
+	}
+
 	go newServer(c1, serverConfig)
 	_, _, _, err = NewClientConn(c2, "", config)
-	return err
+	return err, serverAuthErrors
 }
 
 func TestClientAuthPublicKey(t *testing.T) {
@@ -213,6 +224,45 @@ func TestAuthMethodRSAandDSA(t *testing.T) {
 	}
 }
 
+type invalidAlgSigner struct {
+	Signer
+}
+
+func (s *invalidAlgSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
+	sig, err := s.Signer.Sign(rand, data)
+	if sig != nil {
+		sig.Format = "invalid"
+	}
+	return sig, err
+}
+
+func TestMethodInvalidAlgorithm(t *testing.T) {
+	config := &ClientConfig{
+		User: "testuser",
+		Auth: []AuthMethod{
+			PublicKeys(&invalidAlgSigner{testSigners["rsa"]}),
+		},
+		HostKeyCallback: InsecureIgnoreHostKey(),
+	}
+
+	err, serverErrors := tryAuthBothSides(t, config)
+	if err == nil {
+		t.Fatalf("login succeeded")
+	}
+
+	found := false
+	want := "algorithm \"invalid\""
+
+	var errStrings []string
+	for _, err := range serverErrors {
+		found = found || (err != nil && strings.Contains(err.Error(), want))
+		errStrings = append(errStrings, err.Error())
+	}
+	if !found {
+		t.Errorf("server got error %q, want substring %q", errStrings, want)
+	}
+}
+
 func TestClientHMAC(t *testing.T) {
 	for _, mac := range supportedMACs {
 		config := &ClientConfig{
diff --git a/vendor/golang.org/x/crypto/ssh/keys.go b/vendor/golang.org/x/crypto/ssh/keys.go
index 2261dc38..96980479 100644
--- a/vendor/golang.org/x/crypto/ssh/keys.go
+++ b/vendor/golang.org/x/crypto/ssh/keys.go
@@ -38,6 +38,16 @@ const (
 	KeyAlgoED25519  = "ssh-ed25519"
 )
 
+// These constants represent non-default signature algorithms that are supported
+// as algorithm parameters to AlgorithmSigner.SignWithAlgorithm methods. See
+// [PROTOCOL.agent] section 4.5.1 and
+// https://tools.ietf.org/html/draft-ietf-curdle-rsa-sha2-10
+const (
+	SigAlgoRSA        = "ssh-rsa"
+	SigAlgoRSASHA2256 = "rsa-sha2-256"
+	SigAlgoRSASHA2512 = "rsa-sha2-512"
+)
+
 // parsePubKey parses a public key of the given algorithm.
 // Use ParsePublicKey for keys with prepended algorithm.
 func parsePubKey(in []byte, algo string) (pubKey PublicKey, rest []byte, err error) {
@@ -301,6 +311,19 @@ type Signer interface {
 	Sign(rand io.Reader, data []byte) (*Signature, error)
 }
 
+// A AlgorithmSigner is a Signer that also supports specifying a specific
+// algorithm to use for signing.
+type AlgorithmSigner interface {
+	Signer
+
+	// SignWithAlgorithm is like Signer.Sign, but allows specification of a
+	// non-default signing algorithm. See the SigAlgo* constants in this
+	// package for signature algorithms supported by this package. Callers may
+	// pass an empty string for the algorithm in which case the AlgorithmSigner
+	// will use its default algorithm.
+	SignWithAlgorithm(rand io.Reader, data []byte, algorithm string) (*Signature, error)
+}
+
 type rsaPublicKey rsa.PublicKey
 
 func (r *rsaPublicKey) Type() string {
@@ -349,13 +372,21 @@ func (r *rsaPublicKey) Marshal() []byte {
 }
 
 func (r *rsaPublicKey) Verify(data []byte, sig *Signature) error {
-	if sig.Format != r.Type() {
+	var hash crypto.Hash
+	switch sig.Format {
+	case SigAlgoRSA:
+		hash = crypto.SHA1
+	case SigAlgoRSASHA2256:
+		hash = crypto.SHA256
+	case SigAlgoRSASHA2512:
+		hash = crypto.SHA512
+	default:
 		return fmt.Errorf("ssh: signature type %s for key type %s", sig.Format, r.Type())
 	}
-	h := crypto.SHA1.New()
+	h := hash.New()
 	h.Write(data)
 	digest := h.Sum(nil)
-	return rsa.VerifyPKCS1v15((*rsa.PublicKey)(r), crypto.SHA1, digest, sig.Blob)
+	return rsa.VerifyPKCS1v15((*rsa.PublicKey)(r), hash, digest, sig.Blob)
 }
 
 func (r *rsaPublicKey) CryptoPublicKey() crypto.PublicKey {
@@ -459,6 +490,14 @@ func (k *dsaPrivateKey) PublicKey() PublicKey {
 }
 
 func (k *dsaPrivateKey) Sign(rand io.Reader, data []byte) (*Signature, error) {
+	return k.SignWithAlgorithm(rand, data, "")
+}
+
+func (k *dsaPrivateKey) SignWithAlgorithm(rand io.Reader, data []byte, algorithm string) (*Signature, error) {
+	if algorithm != "" && algorithm != k.PublicKey().Type() {
+		return nil, fmt.Errorf("ssh: unsupported signature algorithm %s", algorithm)
+	}
+
 	h := crypto.SHA1.New()
 	h.Write(data)
 	digest := h.Sum(nil)
@@ -691,16 +730,42 @@ func (s *wrappedSigner) PublicKey() PublicKey {
 }
 
 func (s *wrappedSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
+	return s.SignWithAlgorithm(rand, data, "")
+}
+
+func (s *wrappedSigner) SignWithAlgorithm(rand io.Reader, data []byte, algorithm string) (*Signature, error) {
 	var hashFunc crypto.Hash
 
-	switch key := s.pubKey.(type) {
-	case *rsaPublicKey, *dsaPublicKey:
-		hashFunc = crypto.SHA1
-	case *ecdsaPublicKey:
-		hashFunc = ecHash(key.Curve)
-	case ed25519PublicKey:
-	default:
-		return nil, fmt.Errorf("ssh: unsupported key type %T", key)
+	if _, ok := s.pubKey.(*rsaPublicKey); ok {
+		// RSA keys support a few hash functions determined by the requested signature algorithm
+		switch algorithm {
+		case "", SigAlgoRSA:
+			algorithm = SigAlgoRSA
+			hashFunc = crypto.SHA1
+		case SigAlgoRSASHA2256:
+			hashFunc = crypto.SHA256
+		case SigAlgoRSASHA2512:
+			hashFunc = crypto.SHA512
+		default:
+			return nil, fmt.Errorf("ssh: unsupported signature algorithm %s", algorithm)
+		}
+	} else {
+		// The only supported algorithm for all other key types is the same as the type of the key
+		if algorithm == "" {
+			algorithm = s.pubKey.Type()
+		} else if algorithm != s.pubKey.Type() {
+			return nil, fmt.Errorf("ssh: unsupported signature algorithm %s", algorithm)
+		}
+
+		switch key := s.pubKey.(type) {
+		case *dsaPublicKey:
+			hashFunc = crypto.SHA1
+		case *ecdsaPublicKey:
+			hashFunc = ecHash(key.Curve)
+		case ed25519PublicKey:
+		default:
+			return nil, fmt.Errorf("ssh: unsupported key type %T", key)
+		}
 	}
 
 	var digest []byte
@@ -745,7 +810,7 @@ func (s *wrappedSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
 	}
 
 	return &Signature{
-		Format: s.pubKey.Type(),
+		Format: algorithm,
 		Blob:   signature,
 	}, nil
 }
diff --git a/vendor/golang.org/x/crypto/ssh/keys_test.go b/vendor/golang.org/x/crypto/ssh/keys_test.go
index f28725f1..3847b3bf 100644
--- a/vendor/golang.org/x/crypto/ssh/keys_test.go
+++ b/vendor/golang.org/x/crypto/ssh/keys_test.go
@@ -109,6 +109,49 @@ func TestKeySignVerify(t *testing.T) {
 	}
 }
 
+func TestKeySignWithAlgorithmVerify(t *testing.T) {
+	for _, priv := range testSigners {
+		if algorithmSigner, ok := priv.(AlgorithmSigner); !ok {
+			t.Errorf("Signers constructed by ssh package should always implement the AlgorithmSigner interface: %T", priv)
+		} else {
+			pub := priv.PublicKey()
+			data := []byte("sign me")
+
+			signWithAlgTestCase := func(algorithm string, expectedAlg string) {
+				sig, err := algorithmSigner.SignWithAlgorithm(rand.Reader, data, algorithm)
+				if err != nil {
+					t.Fatalf("Sign(%T): %v", priv, err)
+				}
+				if sig.Format != expectedAlg {
+					t.Errorf("signature format did not match requested signature algorithm: %s != %s", sig.Format, expectedAlg)
+				}
+
+				if err := pub.Verify(data, sig); err != nil {
+					t.Errorf("publicKey.Verify(%T): %v", priv, err)
+				}
+				sig.Blob[5]++
+				if err := pub.Verify(data, sig); err == nil {
+					t.Errorf("publicKey.Verify on broken sig did not fail")
+				}
+			}
+
+			// Using the empty string as the algorithm name should result in the same signature format as the algorithm-free Sign method.
+			defaultSig, err := priv.Sign(rand.Reader, data)
+			if err != nil {
+				t.Fatalf("Sign(%T): %v", priv, err)
+			}
+			signWithAlgTestCase("", defaultSig.Format)
+
+			// RSA keys are the only ones which currently support more than one signing algorithm
+			if pub.Type() == KeyAlgoRSA {
+				for _, algorithm := range []string{SigAlgoRSA, SigAlgoRSASHA2256, SigAlgoRSASHA2512} {
+					signWithAlgTestCase(algorithm, algorithm)
+				}
+			}
+		}
+	}
+}
+
 func TestParseRSAPrivateKey(t *testing.T) {
 	key := testPrivateKeys["rsa"]
 
diff --git a/vendor/golang.org/x/crypto/ssh/mux_test.go b/vendor/golang.org/x/crypto/ssh/mux_test.go
index d88b64e4..94596ec2 100644
--- a/vendor/golang.org/x/crypto/ssh/mux_test.go
+++ b/vendor/golang.org/x/crypto/ssh/mux_test.go
@@ -20,7 +20,7 @@ func muxPair() (*mux, *mux) {
 	return s, c
 }
 
-// Returns both ends of a channel, and the mux for the the 2nd
+// Returns both ends of a channel, and the mux for the 2nd
 // channel.
 func channelPair(t *testing.T) (*channel, *channel, *mux) {
 	c, s := muxPair()
diff --git a/vendor/golang.org/x/crypto/ssh/server.go b/vendor/golang.org/x/crypto/ssh/server.go
index 122c03e7..e86e8966 100644
--- a/vendor/golang.org/x/crypto/ssh/server.go
+++ b/vendor/golang.org/x/crypto/ssh/server.go
@@ -484,6 +484,7 @@ userAuthLoop:
 				// sig.Format.  This is usually the same, but
 				// for certs, the names differ.
 				if !isAcceptableAlgo(sig.Format) {
+					authErr = fmt.Errorf("ssh: algorithm %q not accepted", sig.Format)
 					break
 				}
 				signedData := buildDataSignedForAuth(sessionID, userAuthReq, algoBytes, pubKeyData)
diff --git a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp.go b/vendor/golang.org/x/net/context/ctxhttp/ctxhttp.go
index 606cf1f9..37dc0cfd 100644
--- a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp.go
+++ b/vendor/golang.org/x/net/context/ctxhttp/ctxhttp.go
@@ -2,18 +2,15 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build go1.7
-
 // Package ctxhttp provides helper functions for performing context-aware HTTP requests.
 package ctxhttp // import "golang.org/x/net/context/ctxhttp"
 
 import (
+	"context"
 	"io"
 	"net/http"
 	"net/url"
 	"strings"
-
-	"golang.org/x/net/context"
 )
 
 // Do sends an HTTP request with the provided http.Client and returns
diff --git a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_17_test.go b/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_17_test.go
deleted file mode 100644
index 72411b1b..00000000
--- a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_17_test.go
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !plan9,go1.7
-
-package ctxhttp
-
-import (
-	"io"
-	"net/http"
-	"net/http/httptest"
-	"testing"
-
-	"context"
-)
-
-func TestGo17Context(t *testing.T) {
-	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		io.WriteString(w, "ok")
-	}))
-	defer ts.Close()
-	ctx := context.Background()
-	resp, err := Get(ctx, http.DefaultClient, ts.URL)
-	if resp == nil || err != nil {
-		t.Fatalf("error received from client: %v %v", err, resp)
-	}
-	resp.Body.Close()
-}
diff --git a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17.go b/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17.go
deleted file mode 100644
index 926870cc..00000000
--- a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17.go
+++ /dev/null
@@ -1,147 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !go1.7
-
-package ctxhttp // import "golang.org/x/net/context/ctxhttp"
-
-import (
-	"io"
-	"net/http"
-	"net/url"
-	"strings"
-
-	"golang.org/x/net/context"
-)
-
-func nop() {}
-
-var (
-	testHookContextDoneBeforeHeaders = nop
-	testHookDoReturned               = nop
-	testHookDidBodyClose             = nop
-)
-
-// Do sends an HTTP request with the provided http.Client and returns an HTTP response.
-// If the client is nil, http.DefaultClient is used.
-// If the context is canceled or times out, ctx.Err() will be returned.
-func Do(ctx context.Context, client *http.Client, req *http.Request) (*http.Response, error) {
-	if client == nil {
-		client = http.DefaultClient
-	}
-
-	// TODO(djd): Respect any existing value of req.Cancel.
-	cancel := make(chan struct{})
-	req.Cancel = cancel
-
-	type responseAndError struct {
-		resp *http.Response
-		err  error
-	}
-	result := make(chan responseAndError, 1)
-
-	// Make local copies of test hooks closed over by goroutines below.
-	// Prevents data races in tests.
-	testHookDoReturned := testHookDoReturned
-	testHookDidBodyClose := testHookDidBodyClose
-
-	go func() {
-		resp, err := client.Do(req)
-		testHookDoReturned()
-		result <- responseAndError{resp, err}
-	}()
-
-	var resp *http.Response
-
-	select {
-	case <-ctx.Done():
-		testHookContextDoneBeforeHeaders()
-		close(cancel)
-		// Clean up after the goroutine calling client.Do:
-		go func() {
-			if r := <-result; r.resp != nil {
-				testHookDidBodyClose()
-				r.resp.Body.Close()
-			}
-		}()
-		return nil, ctx.Err()
-	case r := <-result:
-		var err error
-		resp, err = r.resp, r.err
-		if err != nil {
-			return resp, err
-		}
-	}
-
-	c := make(chan struct{})
-	go func() {
-		select {
-		case <-ctx.Done():
-			close(cancel)
-		case <-c:
-			// The response's Body is closed.
-		}
-	}()
-	resp.Body = &notifyingReader{resp.Body, c}
-
-	return resp, nil
-}
-
-// Get issues a GET request via the Do function.
-func Get(ctx context.Context, client *http.Client, url string) (*http.Response, error) {
-	req, err := http.NewRequest("GET", url, nil)
-	if err != nil {
-		return nil, err
-	}
-	return Do(ctx, client, req)
-}
-
-// Head issues a HEAD request via the Do function.
-func Head(ctx context.Context, client *http.Client, url string) (*http.Response, error) {
-	req, err := http.NewRequest("HEAD", url, nil)
-	if err != nil {
-		return nil, err
-	}
-	return Do(ctx, client, req)
-}
-
-// Post issues a POST request via the Do function.
-func Post(ctx context.Context, client *http.Client, url string, bodyType string, body io.Reader) (*http.Response, error) {
-	req, err := http.NewRequest("POST", url, body)
-	if err != nil {
-		return nil, err
-	}
-	req.Header.Set("Content-Type", bodyType)
-	return Do(ctx, client, req)
-}
-
-// PostForm issues a POST request via the Do function.
-func PostForm(ctx context.Context, client *http.Client, url string, data url.Values) (*http.Response, error) {
-	return Post(ctx, client, url, "application/x-www-form-urlencoded", strings.NewReader(data.Encode()))
-}
-
-// notifyingReader is an io.ReadCloser that closes the notify channel after
-// Close is called or a Read fails on the underlying ReadCloser.
-type notifyingReader struct {
-	io.ReadCloser
-	notify chan<- struct{}
-}
-
-func (r *notifyingReader) Read(p []byte) (int, error) {
-	n, err := r.ReadCloser.Read(p)
-	if err != nil && r.notify != nil {
-		close(r.notify)
-		r.notify = nil
-	}
-	return n, err
-}
-
-func (r *notifyingReader) Close() error {
-	err := r.ReadCloser.Close()
-	if r.notify != nil {
-		close(r.notify)
-		r.notify = nil
-	}
-	return err
-}
diff --git a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17_test.go b/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17_test.go
deleted file mode 100644
index 9159cf02..00000000
--- a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17_test.go
+++ /dev/null
@@ -1,79 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !plan9,!go1.7
-
-package ctxhttp
-
-import (
-	"net"
-	"net/http"
-	"net/http/httptest"
-	"sync"
-	"testing"
-	"time"
-
-	"golang.org/x/net/context"
-)
-
-// golang.org/issue/14065
-func TestClosesResponseBodyOnCancel(t *testing.T) {
-	defer func() { testHookContextDoneBeforeHeaders = nop }()
-	defer func() { testHookDoReturned = nop }()
-	defer func() { testHookDidBodyClose = nop }()
-
-	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))
-	defer ts.Close()
-
-	ctx, cancel := context.WithCancel(context.Background())
-
-	// closed when Do enters select case <-ctx.Done()
-	enteredDonePath := make(chan struct{})
-
-	testHookContextDoneBeforeHeaders = func() {
-		close(enteredDonePath)
-	}
-
-	testHookDoReturned = func() {
-		// We now have the result (the Flush'd headers) at least,
-		// so we can cancel the request.
-		cancel()
-
-		// But block the client.Do goroutine from sending
-		// until Do enters into the <-ctx.Done() path, since
-		// otherwise if both channels are readable, select
-		// picks a random one.
-		<-enteredDonePath
-	}
-
-	sawBodyClose := make(chan struct{})
-	testHookDidBodyClose = func() { close(sawBodyClose) }
-
-	tr := &http.Transport{}
-	defer tr.CloseIdleConnections()
-	c := &http.Client{Transport: tr}
-	req, _ := http.NewRequest("GET", ts.URL, nil)
-	_, doErr := Do(ctx, c, req)
-
-	select {
-	case <-sawBodyClose:
-	case <-time.After(5 * time.Second):
-		t.Fatal("timeout waiting for body to close")
-	}
-
-	if doErr != ctx.Err() {
-		t.Errorf("Do error = %v; want %v", doErr, ctx.Err())
-	}
-}
-
-type noteCloseConn struct {
-	net.Conn
-	onceClose sync.Once
-	closefn   func()
-}
-
-func (c *noteCloseConn) Close() error {
-	c.onceClose.Do(c.closefn)
-	return c.Conn.Close()
-}
diff --git a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_test.go b/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_test.go
index 1e415518..c4339c4e 100644
--- a/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_test.go
+++ b/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_test.go
@@ -7,16 +7,28 @@
 package ctxhttp
 
 import (
+	"context"
 	"io"
 	"io/ioutil"
 	"net/http"
 	"net/http/httptest"
 	"testing"
 	"time"
-
-	"golang.org/x/net/context"
 )
 
+func TestGo17Context(t *testing.T) {
+	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		io.WriteString(w, "ok")
+	}))
+	defer ts.Close()
+	ctx := context.Background()
+	resp, err := Get(ctx, http.DefaultClient, ts.URL)
+	if resp == nil || err != nil {
+		t.Fatalf("error received from client: %v %v", err, resp)
+	}
+	resp.Body.Close()
+}
+
 const (
 	requestDuration = 100 * time.Millisecond
 	requestBody     = "ok"
diff --git a/vendor/golang.org/x/net/http2/configure_transport.go b/vendor/golang.org/x/net/http2/configure_transport.go
deleted file mode 100644
index 6356b328..00000000
--- a/vendor/golang.org/x/net/http2/configure_transport.go
+++ /dev/null
@@ -1,82 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.6
-
-package http2
-
-import (
-	"crypto/tls"
-	"fmt"
-	"net/http"
-)
-
-func configureTransport(t1 *http.Transport) (*Transport, error) {
-	connPool := new(clientConnPool)
-	t2 := &Transport{
-		ConnPool: noDialClientConnPool{connPool},
-		t1:       t1,
-	}
-	connPool.t = t2
-	if err := registerHTTPSProtocol(t1, noDialH2RoundTripper{t2}); err != nil {
-		return nil, err
-	}
-	if t1.TLSClientConfig == nil {
-		t1.TLSClientConfig = new(tls.Config)
-	}
-	if !strSliceContains(t1.TLSClientConfig.NextProtos, "h2") {
-		t1.TLSClientConfig.NextProtos = append([]string{"h2"}, t1.TLSClientConfig.NextProtos...)
-	}
-	if !strSliceContains(t1.TLSClientConfig.NextProtos, "http/1.1") {
-		t1.TLSClientConfig.NextProtos = append(t1.TLSClientConfig.NextProtos, "http/1.1")
-	}
-	upgradeFn := func(authority string, c *tls.Conn) http.RoundTripper {
-		addr := authorityAddr("https", authority)
-		if used, err := connPool.addConnIfNeeded(addr, t2, c); err != nil {
-			go c.Close()
-			return erringRoundTripper{err}
-		} else if !used {
-			// Turns out we don't need this c.
-			// For example, two goroutines made requests to the same host
-			// at the same time, both kicking off TCP dials. (since protocol
-			// was unknown)
-			go c.Close()
-		}
-		return t2
-	}
-	if m := t1.TLSNextProto; len(m) == 0 {
-		t1.TLSNextProto = map[string]func(string, *tls.Conn) http.RoundTripper{
-			"h2": upgradeFn,
-		}
-	} else {
-		m["h2"] = upgradeFn
-	}
-	return t2, nil
-}
-
-// registerHTTPSProtocol calls Transport.RegisterProtocol but
-// converting panics into errors.
-func registerHTTPSProtocol(t *http.Transport, rt noDialH2RoundTripper) (err error) {
-	defer func() {
-		if e := recover(); e != nil {
-			err = fmt.Errorf("%v", e)
-		}
-	}()
-	t.RegisterProtocol("https", rt)
-	return nil
-}
-
-// noDialH2RoundTripper is a RoundTripper which only tries to complete the request
-// if there's already has a cached connection to the host.
-// (The field is exported so it can be accessed via reflect from net/http; tested
-// by TestNoDialH2RoundTripperType)
-type noDialH2RoundTripper struct{ *Transport }
-
-func (rt noDialH2RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
-	res, err := rt.Transport.RoundTrip(req)
-	if isNoCachedConnError(err) {
-		return nil, http.ErrSkipAltProtocol
-	}
-	return res, err
-}
diff --git a/vendor/golang.org/x/net/http2/databuffer_test.go b/vendor/golang.org/x/net/http2/databuffer_test.go
index 028e12e5..32cd5f38 100644
--- a/vendor/golang.org/x/net/http2/databuffer_test.go
+++ b/vendor/golang.org/x/net/http2/databuffer_test.go
@@ -2,8 +2,6 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build go1.7
-
 package http2
 
 import (
diff --git a/vendor/golang.org/x/net/http2/frame.go b/vendor/golang.org/x/net/http2/frame.go
index c85e31f2..b46791d1 100644
--- a/vendor/golang.org/x/net/http2/frame.go
+++ b/vendor/golang.org/x/net/http2/frame.go
@@ -1477,7 +1477,7 @@ func (fr *Framer) maxHeaderStringLen() int {
 }
 
 // readMetaFrame returns 0 or more CONTINUATION frames from fr and
-// merge them into into the provided hf and returns a MetaHeadersFrame
+// merge them into the provided hf and returns a MetaHeadersFrame
 // with the decoded hpack values.
 func (fr *Framer) readMetaFrame(hf *HeadersFrame) (*MetaHeadersFrame, error) {
 	if fr.AllowIllegalReads {
diff --git a/vendor/golang.org/x/net/http2/go111.go b/vendor/golang.org/x/net/http2/go111.go
index 9749dc0b..3a131016 100644
--- a/vendor/golang.org/x/net/http2/go111.go
+++ b/vendor/golang.org/x/net/http2/go111.go
@@ -6,19 +6,22 @@
 
 package http2
 
-import "net/textproto"
+import (
+	"net/http/httptrace"
+	"net/textproto"
+)
 
-func traceHasWroteHeaderField(trace *clientTrace) bool {
+func traceHasWroteHeaderField(trace *httptrace.ClientTrace) bool {
 	return trace != nil && trace.WroteHeaderField != nil
 }
 
-func traceWroteHeaderField(trace *clientTrace, k, v string) {
+func traceWroteHeaderField(trace *httptrace.ClientTrace, k, v string) {
 	if trace != nil && trace.WroteHeaderField != nil {
 		trace.WroteHeaderField(k, []string{v})
 	}
 }
 
-func traceGot1xxResponseFunc(trace *clientTrace) func(int, textproto.MIMEHeader) error {
+func traceGot1xxResponseFunc(trace *httptrace.ClientTrace) func(int, textproto.MIMEHeader) error {
 	if trace != nil {
 		return trace.Got1xxResponse
 	}
diff --git a/vendor/golang.org/x/net/http2/go16.go b/vendor/golang.org/x/net/http2/go16.go
deleted file mode 100644
index 00b2e9e3..00000000
--- a/vendor/golang.org/x/net/http2/go16.go
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.6
-
-package http2
-
-import (
-	"net/http"
-	"time"
-)
-
-func transportExpectContinueTimeout(t1 *http.Transport) time.Duration {
-	return t1.ExpectContinueTimeout
-}
diff --git a/vendor/golang.org/x/net/http2/go17.go b/vendor/golang.org/x/net/http2/go17.go
deleted file mode 100644
index d957b7bc..00000000
--- a/vendor/golang.org/x/net/http2/go17.go
+++ /dev/null
@@ -1,121 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.7
-
-package http2
-
-import (
-	"context"
-	"net"
-	"net/http"
-	"net/http/httptrace"
-	"time"
-)
-
-type contextContext interface {
-	context.Context
-}
-
-var errCanceled = context.Canceled
-
-func serverConnBaseContext(c net.Conn, opts *ServeConnOpts) (ctx contextContext, cancel func()) {
-	ctx, cancel = context.WithCancel(context.Background())
-	ctx = context.WithValue(ctx, http.LocalAddrContextKey, c.LocalAddr())
-	if hs := opts.baseConfig(); hs != nil {
-		ctx = context.WithValue(ctx, http.ServerContextKey, hs)
-	}
-	return
-}
-
-func contextWithCancel(ctx contextContext) (_ contextContext, cancel func()) {
-	return context.WithCancel(ctx)
-}
-
-func requestWithContext(req *http.Request, ctx contextContext) *http.Request {
-	return req.WithContext(ctx)
-}
-
-type clientTrace httptrace.ClientTrace
-
-func reqContext(r *http.Request) context.Context { return r.Context() }
-
-func (t *Transport) idleConnTimeout() time.Duration {
-	if t.t1 != nil {
-		return t.t1.IdleConnTimeout
-	}
-	return 0
-}
-
-func setResponseUncompressed(res *http.Response) { res.Uncompressed = true }
-
-func traceGetConn(req *http.Request, hostPort string) {
-	trace := httptrace.ContextClientTrace(req.Context())
-	if trace == nil || trace.GetConn == nil {
-		return
-	}
-	trace.GetConn(hostPort)
-}
-
-func traceGotConn(req *http.Request, cc *ClientConn) {
-	trace := httptrace.ContextClientTrace(req.Context())
-	if trace == nil || trace.GotConn == nil {
-		return
-	}
-	ci := httptrace.GotConnInfo{Conn: cc.tconn}
-	cc.mu.Lock()
-	ci.Reused = cc.nextStreamID > 1
-	ci.WasIdle = len(cc.streams) == 0 && ci.Reused
-	if ci.WasIdle && !cc.lastActive.IsZero() {
-		ci.IdleTime = time.Now().Sub(cc.lastActive)
-	}
-	cc.mu.Unlock()
-
-	trace.GotConn(ci)
-}
-
-func traceWroteHeaders(trace *clientTrace) {
-	if trace != nil && trace.WroteHeaders != nil {
-		trace.WroteHeaders()
-	}
-}
-
-func traceGot100Continue(trace *clientTrace) {
-	if trace != nil && trace.Got100Continue != nil {
-		trace.Got100Continue()
-	}
-}
-
-func traceWait100Continue(trace *clientTrace) {
-	if trace != nil && trace.Wait100Continue != nil {
-		trace.Wait100Continue()
-	}
-}
-
-func traceWroteRequest(trace *clientTrace, err error) {
-	if trace != nil && trace.WroteRequest != nil {
-		trace.WroteRequest(httptrace.WroteRequestInfo{Err: err})
-	}
-}
-
-func traceFirstResponseByte(trace *clientTrace) {
-	if trace != nil && trace.GotFirstResponseByte != nil {
-		trace.GotFirstResponseByte()
-	}
-}
-
-func requestTrace(req *http.Request) *clientTrace {
-	trace := httptrace.ContextClientTrace(req.Context())
-	return (*clientTrace)(trace)
-}
-
-// Ping sends a PING frame to the server and waits for the ack.
-func (cc *ClientConn) Ping(ctx context.Context) error {
-	return cc.ping(ctx)
-}
-
-// Shutdown gracefully closes the client connection, waiting for running streams to complete.
-func (cc *ClientConn) Shutdown(ctx context.Context) error {
-	return cc.shutdown(ctx)
-}
diff --git a/vendor/golang.org/x/net/http2/go17_not18.go b/vendor/golang.org/x/net/http2/go17_not18.go
deleted file mode 100644
index b4c52ece..00000000
--- a/vendor/golang.org/x/net/http2/go17_not18.go
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.7,!go1.8
-
-package http2
-
-import "crypto/tls"
-
-// temporary copy of Go 1.7's private tls.Config.clone:
-func cloneTLSConfig(c *tls.Config) *tls.Config {
-	return &tls.Config{
-		Rand:                        c.Rand,
-		Time:                        c.Time,
-		Certificates:                c.Certificates,
-		NameToCertificate:           c.NameToCertificate,
-		GetCertificate:              c.GetCertificate,
-		RootCAs:                     c.RootCAs,
-		NextProtos:                  c.NextProtos,
-		ServerName:                  c.ServerName,
-		ClientAuth:                  c.ClientAuth,
-		ClientCAs:                   c.ClientCAs,
-		InsecureSkipVerify:          c.InsecureSkipVerify,
-		CipherSuites:                c.CipherSuites,
-		PreferServerCipherSuites:    c.PreferServerCipherSuites,
-		SessionTicketsDisabled:      c.SessionTicketsDisabled,
-		SessionTicketKey:            c.SessionTicketKey,
-		ClientSessionCache:          c.ClientSessionCache,
-		MinVersion:                  c.MinVersion,
-		MaxVersion:                  c.MaxVersion,
-		CurvePreferences:            c.CurvePreferences,
-		DynamicRecordSizingDisabled: c.DynamicRecordSizingDisabled,
-		Renegotiation:               c.Renegotiation,
-	}
-}
diff --git a/vendor/golang.org/x/net/http2/go18.go b/vendor/golang.org/x/net/http2/go18.go
deleted file mode 100644
index 4f30d228..00000000
--- a/vendor/golang.org/x/net/http2/go18.go
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.8
-
-package http2
-
-import (
-	"crypto/tls"
-	"io"
-	"net/http"
-)
-
-func cloneTLSConfig(c *tls.Config) *tls.Config {
-	c2 := c.Clone()
-	c2.GetClientCertificate = c.GetClientCertificate // golang.org/issue/19264
-	return c2
-}
-
-var _ http.Pusher = (*responseWriter)(nil)
-
-// Push implements http.Pusher.
-func (w *responseWriter) Push(target string, opts *http.PushOptions) error {
-	internalOpts := pushOptions{}
-	if opts != nil {
-		internalOpts.Method = opts.Method
-		internalOpts.Header = opts.Header
-	}
-	return w.push(target, internalOpts)
-}
-
-func configureServer18(h1 *http.Server, h2 *Server) error {
-	if h2.IdleTimeout == 0 {
-		if h1.IdleTimeout != 0 {
-			h2.IdleTimeout = h1.IdleTimeout
-		} else {
-			h2.IdleTimeout = h1.ReadTimeout
-		}
-	}
-	return nil
-}
-
-func shouldLogPanic(panicValue interface{}) bool {
-	return panicValue != nil && panicValue != http.ErrAbortHandler
-}
-
-func reqGetBody(req *http.Request) func() (io.ReadCloser, error) {
-	return req.GetBody
-}
-
-func reqBodyIsNoBody(body io.ReadCloser) bool {
-	return body == http.NoBody
-}
-
-func go18httpNoBody() io.ReadCloser { return http.NoBody } // for tests only
diff --git a/vendor/golang.org/x/net/http2/go18_test.go b/vendor/golang.org/x/net/http2/go18_test.go
deleted file mode 100644
index 30e3b038..00000000
--- a/vendor/golang.org/x/net/http2/go18_test.go
+++ /dev/null
@@ -1,79 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.8
-
-package http2
-
-import (
-	"crypto/tls"
-	"net/http"
-	"testing"
-	"time"
-)
-
-// Tests that http2.Server.IdleTimeout is initialized from
-// http.Server.{Idle,Read}Timeout. http.Server.IdleTimeout was
-// added in Go 1.8.
-func TestConfigureServerIdleTimeout_Go18(t *testing.T) {
-	const timeout = 5 * time.Second
-	const notThisOne = 1 * time.Second
-
-	// With a zero http2.Server, verify that it copies IdleTimeout:
-	{
-		s1 := &http.Server{
-			IdleTimeout: timeout,
-			ReadTimeout: notThisOne,
-		}
-		s2 := &Server{}
-		if err := ConfigureServer(s1, s2); err != nil {
-			t.Fatal(err)
-		}
-		if s2.IdleTimeout != timeout {
-			t.Errorf("s2.IdleTimeout = %v; want %v", s2.IdleTimeout, timeout)
-		}
-	}
-
-	// And that it falls back to ReadTimeout:
-	{
-		s1 := &http.Server{
-			ReadTimeout: timeout,
-		}
-		s2 := &Server{}
-		if err := ConfigureServer(s1, s2); err != nil {
-			t.Fatal(err)
-		}
-		if s2.IdleTimeout != timeout {
-			t.Errorf("s2.IdleTimeout = %v; want %v", s2.IdleTimeout, timeout)
-		}
-	}
-
-	// Verify that s1's IdleTimeout doesn't overwrite an existing setting:
-	{
-		s1 := &http.Server{
-			IdleTimeout: notThisOne,
-		}
-		s2 := &Server{
-			IdleTimeout: timeout,
-		}
-		if err := ConfigureServer(s1, s2); err != nil {
-			t.Fatal(err)
-		}
-		if s2.IdleTimeout != timeout {
-			t.Errorf("s2.IdleTimeout = %v; want %v", s2.IdleTimeout, timeout)
-		}
-	}
-}
-
-func TestCertClone(t *testing.T) {
-	c := &tls.Config{
-		GetClientCertificate: func(*tls.CertificateRequestInfo) (*tls.Certificate, error) {
-			panic("shouldn't be called")
-		},
-	}
-	c2 := cloneTLSConfig(c)
-	if c2.GetClientCertificate == nil {
-		t.Error("GetClientCertificate is nil")
-	}
-}
diff --git a/vendor/golang.org/x/net/http2/go19.go b/vendor/golang.org/x/net/http2/go19.go
deleted file mode 100644
index 38124ba5..00000000
--- a/vendor/golang.org/x/net/http2/go19.go
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.9
-
-package http2
-
-import (
-	"net/http"
-)
-
-func configureServer19(s *http.Server, conf *Server) error {
-	s.RegisterOnShutdown(conf.state.startGracefulShutdown)
-	return nil
-}
diff --git a/vendor/golang.org/x/net/http2/go19_test.go b/vendor/golang.org/x/net/http2/go19_test.go
deleted file mode 100644
index 22b00066..00000000
--- a/vendor/golang.org/x/net/http2/go19_test.go
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.9
-
-package http2
-
-import (
-	"context"
-	"net/http"
-	"reflect"
-	"testing"
-	"time"
-)
-
-func TestServerGracefulShutdown(t *testing.T) {
-	var st *serverTester
-	handlerDone := make(chan struct{})
-	st = newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
-		defer close(handlerDone)
-		go st.ts.Config.Shutdown(context.Background())
-
-		ga := st.wantGoAway()
-		if ga.ErrCode != ErrCodeNo {
-			t.Errorf("GOAWAY error = %v; want ErrCodeNo", ga.ErrCode)
-		}
-		if ga.LastStreamID != 1 {
-			t.Errorf("GOAWAY LastStreamID = %v; want 1", ga.LastStreamID)
-		}
-
-		w.Header().Set("x-foo", "bar")
-	})
-	defer st.Close()
-
-	st.greet()
-	st.bodylessReq1()
-
-	select {
-	case <-handlerDone:
-	case <-time.After(5 * time.Second):
-		t.Fatalf("server did not shutdown?")
-	}
-	hf := st.wantHeaders()
-	goth := st.decodeHeader(hf.HeaderBlockFragment())
-	wanth := [][2]string{
-		{":status", "200"},
-		{"x-foo", "bar"},
-		{"content-length", "0"},
-	}
-	if !reflect.DeepEqual(goth, wanth) {
-		t.Errorf("Got headers %v; want %v", goth, wanth)
-	}
-
-	n, err := st.cc.Read([]byte{0})
-	if n != 0 || err == nil {
-		t.Errorf("Read = %v, %v; want 0, non-nil", n, err)
-	}
-}
diff --git a/vendor/golang.org/x/net/http2/h2c/h2c.go b/vendor/golang.org/x/net/http2/h2c/h2c.go
index f2d60f84..03a31c80 100644
--- a/vendor/golang.org/x/net/http2/h2c/h2c.go
+++ b/vendor/golang.org/x/net/http2/h2c/h2c.go
@@ -293,7 +293,7 @@ func (c *rwConn) Write(p []byte) (int, error) {
 	return n, err
 }
 
-// settingsAckSwallowWriter is a writer that normally forwards bytes to it's
+// settingsAckSwallowWriter is a writer that normally forwards bytes to its
 // underlying Writer, but swallows the first SettingsAck frame that it sees.
 type settingsAckSwallowWriter struct {
 	Writer     *bufio.Writer
diff --git a/vendor/golang.org/x/net/http2/h2i/h2i.go b/vendor/golang.org/x/net/http2/h2i/h2i.go
index 12d325eb..0f0e5528 100644
--- a/vendor/golang.org/x/net/http2/h2i/h2i.go
+++ b/vendor/golang.org/x/net/http2/h2i/h2i.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build !js,!nacl,!plan9,!solaris
+// +build darwin dragonfly freebsd linux netbsd openbsd solaris windows
 
 /*
 The h2i command is an interactive HTTP/2 console.
diff --git a/vendor/golang.org/x/net/http2/http2_test.go b/vendor/golang.org/x/net/http2/http2_test.go
index 667db488..dda67439 100644
--- a/vendor/golang.org/x/net/http2/http2_test.go
+++ b/vendor/golang.org/x/net/http2/http2_test.go
@@ -225,3 +225,56 @@ func waitErrCondition(waitFor, checkEvery time.Duration, fn func() error) error
 	}
 	return err
 }
+
+// Tests that http2.Server.IdleTimeout is initialized from
+// http.Server.{Idle,Read}Timeout. http.Server.IdleTimeout was
+// added in Go 1.8.
+func TestConfigureServerIdleTimeout_Go18(t *testing.T) {
+	const timeout = 5 * time.Second
+	const notThisOne = 1 * time.Second
+
+	// With a zero http2.Server, verify that it copies IdleTimeout:
+	{
+		s1 := &http.Server{
+			IdleTimeout: timeout,
+			ReadTimeout: notThisOne,
+		}
+		s2 := &Server{}
+		if err := ConfigureServer(s1, s2); err != nil {
+			t.Fatal(err)
+		}
+		if s2.IdleTimeout != timeout {
+			t.Errorf("s2.IdleTimeout = %v; want %v", s2.IdleTimeout, timeout)
+		}
+	}
+
+	// And that it falls back to ReadTimeout:
+	{
+		s1 := &http.Server{
+			ReadTimeout: timeout,
+		}
+		s2 := &Server{}
+		if err := ConfigureServer(s1, s2); err != nil {
+			t.Fatal(err)
+		}
+		if s2.IdleTimeout != timeout {
+			t.Errorf("s2.IdleTimeout = %v; want %v", s2.IdleTimeout, timeout)
+		}
+	}
+
+	// Verify that s1's IdleTimeout doesn't overwrite an existing setting:
+	{
+		s1 := &http.Server{
+			IdleTimeout: notThisOne,
+		}
+		s2 := &Server{
+			IdleTimeout: timeout,
+		}
+		if err := ConfigureServer(s1, s2); err != nil {
+			t.Fatal(err)
+		}
+		if s2.IdleTimeout != timeout {
+			t.Errorf("s2.IdleTimeout = %v; want %v", s2.IdleTimeout, timeout)
+		}
+	}
+}
diff --git a/vendor/golang.org/x/net/http2/not_go111.go b/vendor/golang.org/x/net/http2/not_go111.go
index 0df34e6d..161bca7c 100644
--- a/vendor/golang.org/x/net/http2/not_go111.go
+++ b/vendor/golang.org/x/net/http2/not_go111.go
@@ -6,12 +6,15 @@
 
 package http2
 
-import "net/textproto"
+import (
+	"net/http/httptrace"
+	"net/textproto"
+)
 
-func traceHasWroteHeaderField(trace *clientTrace) bool { return false }
+func traceHasWroteHeaderField(trace *httptrace.ClientTrace) bool { return false }
 
-func traceWroteHeaderField(trace *clientTrace, k, v string) {}
+func traceWroteHeaderField(trace *httptrace.ClientTrace, k, v string) {}
 
-func traceGot1xxResponseFunc(trace *clientTrace) func(int, textproto.MIMEHeader) error {
+func traceGot1xxResponseFunc(trace *httptrace.ClientTrace) func(int, textproto.MIMEHeader) error {
 	return nil
 }
diff --git a/vendor/golang.org/x/net/http2/not_go16.go b/vendor/golang.org/x/net/http2/not_go16.go
deleted file mode 100644
index 508cebcc..00000000
--- a/vendor/golang.org/x/net/http2/not_go16.go
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !go1.6
-
-package http2
-
-import (
-	"net/http"
-	"time"
-)
-
-func configureTransport(t1 *http.Transport) (*Transport, error) {
-	return nil, errTransportVersion
-}
-
-func transportExpectContinueTimeout(t1 *http.Transport) time.Duration {
-	return 0
-
-}
diff --git a/vendor/golang.org/x/net/http2/not_go17.go b/vendor/golang.org/x/net/http2/not_go17.go
deleted file mode 100644
index 7ffb2504..00000000
--- a/vendor/golang.org/x/net/http2/not_go17.go
+++ /dev/null
@@ -1,95 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !go1.7
-
-package http2
-
-import (
-	"crypto/tls"
-	"errors"
-	"net"
-	"net/http"
-	"time"
-)
-
-type contextContext interface {
-	Done() <-chan struct{}
-	Err() error
-}
-
-var errCanceled = errors.New("canceled")
-
-type fakeContext struct{}
-
-func (fakeContext) Done() <-chan struct{} { return nil }
-func (fakeContext) Err() error            { panic("should not be called") }
-
-func reqContext(r *http.Request) fakeContext {
-	return fakeContext{}
-}
-
-func setResponseUncompressed(res *http.Response) {
-	// Nothing.
-}
-
-type clientTrace struct{}
-
-func requestTrace(*http.Request) *clientTrace { return nil }
-func traceGetConn(*http.Request, string)      {}
-func traceGotConn(*http.Request, *ClientConn) {}
-func traceFirstResponseByte(*clientTrace)     {}
-func traceWroteHeaders(*clientTrace)          {}
-func traceWroteRequest(*clientTrace, error)   {}
-func traceGot100Continue(trace *clientTrace)  {}
-func traceWait100Continue(trace *clientTrace) {}
-
-func nop() {}
-
-func serverConnBaseContext(c net.Conn, opts *ServeConnOpts) (ctx contextContext, cancel func()) {
-	return nil, nop
-}
-
-func contextWithCancel(ctx contextContext) (_ contextContext, cancel func()) {
-	return ctx, nop
-}
-
-func requestWithContext(req *http.Request, ctx contextContext) *http.Request {
-	return req
-}
-
-// temporary copy of Go 1.6's private tls.Config.clone:
-func cloneTLSConfig(c *tls.Config) *tls.Config {
-	return &tls.Config{
-		Rand:                     c.Rand,
-		Time:                     c.Time,
-		Certificates:             c.Certificates,
-		NameToCertificate:        c.NameToCertificate,
-		GetCertificate:           c.GetCertificate,
-		RootCAs:                  c.RootCAs,
-		NextProtos:               c.NextProtos,
-		ServerName:               c.ServerName,
-		ClientAuth:               c.ClientAuth,
-		ClientCAs:                c.ClientCAs,
-		InsecureSkipVerify:       c.InsecureSkipVerify,
-		CipherSuites:             c.CipherSuites,
-		PreferServerCipherSuites: c.PreferServerCipherSuites,
-		SessionTicketsDisabled:   c.SessionTicketsDisabled,
-		SessionTicketKey:         c.SessionTicketKey,
-		ClientSessionCache:       c.ClientSessionCache,
-		MinVersion:               c.MinVersion,
-		MaxVersion:               c.MaxVersion,
-		CurvePreferences:         c.CurvePreferences,
-	}
-}
-
-func (cc *ClientConn) Ping(ctx contextContext) error {
-	return cc.ping(ctx)
-}
-
-func (cc *ClientConn) Shutdown(ctx contextContext) error {
-	return cc.shutdown(ctx)
-}
-
-func (t *Transport) idleConnTimeout() time.Duration { return 0 }
diff --git a/vendor/golang.org/x/net/http2/not_go18.go b/vendor/golang.org/x/net/http2/not_go18.go
deleted file mode 100644
index 6f8d3f86..00000000
--- a/vendor/golang.org/x/net/http2/not_go18.go
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !go1.8
-
-package http2
-
-import (
-	"io"
-	"net/http"
-)
-
-func configureServer18(h1 *http.Server, h2 *Server) error {
-	// No IdleTimeout to sync prior to Go 1.8.
-	return nil
-}
-
-func shouldLogPanic(panicValue interface{}) bool {
-	return panicValue != nil
-}
-
-func reqGetBody(req *http.Request) func() (io.ReadCloser, error) {
-	return nil
-}
-
-func reqBodyIsNoBody(io.ReadCloser) bool { return false }
-
-func go18httpNoBody() io.ReadCloser { return nil } // for tests only
diff --git a/vendor/golang.org/x/net/http2/not_go19.go b/vendor/golang.org/x/net/http2/not_go19.go
deleted file mode 100644
index 5ae07726..00000000
--- a/vendor/golang.org/x/net/http2/not_go19.go
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !go1.9
-
-package http2
-
-import (
-	"net/http"
-)
-
-func configureServer19(s *http.Server, conf *Server) error {
-	// not supported prior to go1.9
-	return nil
-}
diff --git a/vendor/golang.org/x/net/http2/server.go b/vendor/golang.org/x/net/http2/server.go
index 56859d1f..b57b6e2d 100644
--- a/vendor/golang.org/x/net/http2/server.go
+++ b/vendor/golang.org/x/net/http2/server.go
@@ -28,6 +28,7 @@ package http2
 import (
 	"bufio"
 	"bytes"
+	"context"
 	"crypto/tls"
 	"errors"
 	"fmt"
@@ -209,12 +210,14 @@ func ConfigureServer(s *http.Server, conf *Server) error {
 		conf = new(Server)
 	}
 	conf.state = &serverInternalState{activeConns: make(map[*serverConn]struct{})}
-	if err := configureServer18(s, conf); err != nil {
-		return err
-	}
-	if err := configureServer19(s, conf); err != nil {
-		return err
+	if h1, h2 := s, conf; h2.IdleTimeout == 0 {
+		if h1.IdleTimeout != 0 {
+			h2.IdleTimeout = h1.IdleTimeout
+		} else {
+			h2.IdleTimeout = h1.ReadTimeout
+		}
 	}
+	s.RegisterOnShutdown(conf.state.startGracefulShutdown)
 
 	if s.TLSConfig == nil {
 		s.TLSConfig = new(tls.Config)
@@ -435,6 +438,15 @@ func (s *Server) ServeConn(c net.Conn, opts *ServeConnOpts) {
 	sc.serve()
 }
 
+func serverConnBaseContext(c net.Conn, opts *ServeConnOpts) (ctx context.Context, cancel func()) {
+	ctx, cancel = context.WithCancel(context.Background())
+	ctx = context.WithValue(ctx, http.LocalAddrContextKey, c.LocalAddr())
+	if hs := opts.baseConfig(); hs != nil {
+		ctx = context.WithValue(ctx, http.ServerContextKey, hs)
+	}
+	return
+}
+
 func (sc *serverConn) rejectConn(err ErrCode, debug string) {
 	sc.vlogf("http2: server rejecting conn: %v, %s", err, debug)
 	// ignoring errors. hanging up anyway.
@@ -450,7 +462,7 @@ type serverConn struct {
 	conn             net.Conn
 	bw               *bufferedWriter // writing to conn
 	handler          http.Handler
-	baseCtx          contextContext
+	baseCtx          context.Context
 	framer           *Framer
 	doneServing      chan struct{}          // closed when serverConn.serve ends
 	readFrameCh      chan readFrameResult   // written by serverConn.readFrames
@@ -530,7 +542,7 @@ type stream struct {
 	id        uint32
 	body      *pipe       // non-nil if expecting DATA frames
 	cw        closeWaiter // closed wait stream transitions to closed state
-	ctx       contextContext
+	ctx       context.Context
 	cancelCtx func()
 
 	// owned by serverConn's serve loop:
@@ -1110,7 +1122,7 @@ func (sc *serverConn) startFrameWrite(wr FrameWriteRequest) {
 
 // errHandlerPanicked is the error given to any callers blocked in a read from
 // Request.Body when the main goroutine panics. Since most handlers read in the
-// the main ServeHTTP goroutine, this will show up rarely.
+// main ServeHTTP goroutine, this will show up rarely.
 var errHandlerPanicked = errors.New("http2: handler panicked")
 
 // wroteFrame is called on the serve goroutine with the result of
@@ -1882,7 +1894,7 @@ func (sc *serverConn) newStream(id, pusherID uint32, state streamState) *stream
 		panic("internal error: cannot create stream with id 0")
 	}
 
-	ctx, cancelCtx := contextWithCancel(sc.baseCtx)
+	ctx, cancelCtx := context.WithCancel(sc.baseCtx)
 	st := &stream{
 		sc:        sc,
 		id:        id,
@@ -2048,7 +2060,7 @@ func (sc *serverConn) newWriterAndRequestNoBody(st *stream, rp requestParam) (*r
 		Body:       body,
 		Trailer:    trailer,
 	}
-	req = requestWithContext(req, st.ctx)
+	req = req.WithContext(st.ctx)
 
 	rws := responseWriterStatePool.Get().(*responseWriterState)
 	bwSave := rws.bw
@@ -2076,7 +2088,7 @@ func (sc *serverConn) runHandler(rw *responseWriter, req *http.Request, handler
 				stream: rw.rws.stream,
 			})
 			// Same as net/http:
-			if shouldLogPanic(e) {
+			if e != nil && e != http.ErrAbortHandler {
 				const size = 64 << 10
 				buf := make([]byte, size)
 				buf = buf[:runtime.Stack(buf, false)]
@@ -2638,14 +2650,9 @@ var (
 	ErrPushLimitReached = errors.New("http2: push would exceed peer's SETTINGS_MAX_CONCURRENT_STREAMS")
 )
 
-// pushOptions is the internal version of http.PushOptions, which we
-// cannot include here because it's only defined in Go 1.8 and later.
-type pushOptions struct {
-	Method string
-	Header http.Header
-}
+var _ http.Pusher = (*responseWriter)(nil)
 
-func (w *responseWriter) push(target string, opts pushOptions) error {
+func (w *responseWriter) Push(target string, opts *http.PushOptions) error {
 	st := w.rws.stream
 	sc := st.sc
 	sc.serveG.checkNotOn()
@@ -2656,6 +2663,10 @@ func (w *responseWriter) push(target string, opts pushOptions) error {
 		return ErrRecursivePush
 	}
 
+	if opts == nil {
+		opts = new(http.PushOptions)
+	}
+
 	// Default options.
 	if opts.Method == "" {
 		opts.Method = "GET"
diff --git a/vendor/golang.org/x/net/http2/server_push_test.go b/vendor/golang.org/x/net/http2/server_push_test.go
index 918fd30d..6e57de0b 100644
--- a/vendor/golang.org/x/net/http2/server_push_test.go
+++ b/vendor/golang.org/x/net/http2/server_push_test.go
@@ -2,8 +2,6 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build go1.8
-
 package http2
 
 import (
diff --git a/vendor/golang.org/x/net/http2/server_test.go b/vendor/golang.org/x/net/http2/server_test.go
index bb19c966..b0a117f7 100644
--- a/vendor/golang.org/x/net/http2/server_test.go
+++ b/vendor/golang.org/x/net/http2/server_test.go
@@ -6,6 +6,7 @@ package http2
 
 import (
 	"bytes"
+	"context"
 	"crypto/tls"
 	"errors"
 	"flag"
@@ -2415,6 +2416,7 @@ func testRejectTLS(t *testing.T, max uint16) {
 
 func TestServer_Rejects_TLSBadCipher(t *testing.T) {
 	st := newServerTester(t, nil, func(c *tls.Config) {
+		c.MaxVersion = tls.VersionTLS12 // workaround for golang.org/issue/28762
 		// Only list bad ones:
 		c.CipherSuites = []uint16{
 			tls.TLS_RSA_WITH_RC4_128_SHA,
@@ -3850,3 +3852,47 @@ func TestServer_Headers_HalfCloseRemote(t *testing.T) {
 
 	st.wantRSTStream(1, ErrCodeStreamClosed)
 }
+
+func TestServerGracefulShutdown(t *testing.T) {
+	var st *serverTester
+	handlerDone := make(chan struct{})
+	st = newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
+		defer close(handlerDone)
+		go st.ts.Config.Shutdown(context.Background())
+
+		ga := st.wantGoAway()
+		if ga.ErrCode != ErrCodeNo {
+			t.Errorf("GOAWAY error = %v; want ErrCodeNo", ga.ErrCode)
+		}
+		if ga.LastStreamID != 1 {
+			t.Errorf("GOAWAY LastStreamID = %v; want 1", ga.LastStreamID)
+		}
+
+		w.Header().Set("x-foo", "bar")
+	})
+	defer st.Close()
+
+	st.greet()
+	st.bodylessReq1()
+
+	select {
+	case <-handlerDone:
+	case <-time.After(5 * time.Second):
+		t.Fatalf("server did not shutdown?")
+	}
+	hf := st.wantHeaders()
+	goth := st.decodeHeader(hf.HeaderBlockFragment())
+	wanth := [][2]string{
+		{":status", "200"},
+		{"x-foo", "bar"},
+		{"content-length", "0"},
+	}
+	if !reflect.DeepEqual(goth, wanth) {
+		t.Errorf("Got headers %v; want %v", goth, wanth)
+	}
+
+	n, err := st.cc.Read([]byte{0})
+	if n != 0 || err == nil {
+		t.Errorf("Read = %v, %v; want 0, non-nil", n, err)
+	}
+}
diff --git a/vendor/golang.org/x/net/http2/transport.go b/vendor/golang.org/x/net/http2/transport.go
index 9d1f2fad..3fe29188 100644
--- a/vendor/golang.org/x/net/http2/transport.go
+++ b/vendor/golang.org/x/net/http2/transport.go
@@ -10,6 +10,7 @@ import (
 	"bufio"
 	"bytes"
 	"compress/gzip"
+	"context"
 	"crypto/rand"
 	"crypto/tls"
 	"errors"
@@ -21,6 +22,7 @@ import (
 	mathrand "math/rand"
 	"net"
 	"net/http"
+	"net/http/httptrace"
 	"net/textproto"
 	"sort"
 	"strconv"
@@ -118,16 +120,56 @@ func (t *Transport) disableCompression() bool {
 	return t.DisableCompression || (t.t1 != nil && t.t1.DisableCompression)
 }
 
-var errTransportVersion = errors.New("http2: ConfigureTransport is only supported starting at Go 1.6")
-
 // ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2.
-// It requires Go 1.6 or later and returns an error if the net/http package is too old
-// or if t1 has already been HTTP/2-enabled.
+// It returns an error if t1 has already been HTTP/2-enabled.
 func ConfigureTransport(t1 *http.Transport) error {
-	_, err := configureTransport(t1) // in configure_transport.go (go1.6) or not_go16.go
+	_, err := configureTransport(t1)
 	return err
 }
 
+func configureTransport(t1 *http.Transport) (*Transport, error) {
+	connPool := new(clientConnPool)
+	t2 := &Transport{
+		ConnPool: noDialClientConnPool{connPool},
+		t1:       t1,
+	}
+	connPool.t = t2
+	if err := registerHTTPSProtocol(t1, noDialH2RoundTripper{t2}); err != nil {
+		return nil, err
+	}
+	if t1.TLSClientConfig == nil {
+		t1.TLSClientConfig = new(tls.Config)
+	}
+	if !strSliceContains(t1.TLSClientConfig.NextProtos, "h2") {
+		t1.TLSClientConfig.NextProtos = append([]string{"h2"}, t1.TLSClientConfig.NextProtos...)
+	}
+	if !strSliceContains(t1.TLSClientConfig.NextProtos, "http/1.1") {
+		t1.TLSClientConfig.NextProtos = append(t1.TLSClientConfig.NextProtos, "http/1.1")
+	}
+	upgradeFn := func(authority string, c *tls.Conn) http.RoundTripper {
+		addr := authorityAddr("https", authority)
+		if used, err := connPool.addConnIfNeeded(addr, t2, c); err != nil {
+			go c.Close()
+			return erringRoundTripper{err}
+		} else if !used {
+			// Turns out we don't need this c.
+			// For example, two goroutines made requests to the same host
+			// at the same time, both kicking off TCP dials. (since protocol
+			// was unknown)
+			go c.Close()
+		}
+		return t2
+	}
+	if m := t1.TLSNextProto; len(m) == 0 {
+		t1.TLSNextProto = map[string]func(string, *tls.Conn) http.RoundTripper{
+			"h2": upgradeFn,
+		}
+	} else {
+		m["h2"] = upgradeFn
+	}
+	return t2, nil
+}
+
 func (t *Transport) connPool() ClientConnPool {
 	t.connPoolOnce.Do(t.initConnPool)
 	return t.connPoolOrDef
@@ -192,7 +234,7 @@ type ClientConn struct {
 type clientStream struct {
 	cc            *ClientConn
 	req           *http.Request
-	trace         *clientTrace // or nil
+	trace         *httptrace.ClientTrace // or nil
 	ID            uint32
 	resc          chan resAndError
 	bufPipe       pipe // buffered pipe with the flow-controlled response payload
@@ -226,7 +268,7 @@ type clientStream struct {
 // channel to be signaled. A non-nil error is returned only if the request was
 // canceled.
 func awaitRequestCancel(req *http.Request, done <-chan struct{}) error {
-	ctx := reqContext(req)
+	ctx := req.Context()
 	if req.Cancel == nil && ctx.Done() == nil {
 		return nil
 	}
@@ -401,8 +443,8 @@ func (t *Transport) RoundTripOpt(req *http.Request, opt RoundTripOpt) (*http.Res
 				select {
 				case <-time.After(time.Second * time.Duration(backoff)):
 					continue
-				case <-reqContext(req).Done():
-					return nil, reqContext(req).Err()
+				case <-req.Context().Done():
+					return nil, req.Context().Err()
 				}
 			}
 		}
@@ -439,16 +481,15 @@ func shouldRetryRequest(req *http.Request, err error, afterBodyWrite bool) (*htt
 	}
 	// If the Body is nil (or http.NoBody), it's safe to reuse
 	// this request and its Body.
-	if req.Body == nil || reqBodyIsNoBody(req.Body) {
+	if req.Body == nil || req.Body == http.NoBody {
 		return req, nil
 	}
 
 	// If the request body can be reset back to its original
 	// state via the optional req.GetBody, do that.
-	getBody := reqGetBody(req) // Go 1.8: getBody = req.GetBody
-	if getBody != nil {
+	if req.GetBody != nil {
 		// TODO: consider a req.Body.Close here? or audit that all caller paths do?
-		body, err := getBody()
+		body, err := req.GetBody()
 		if err != nil {
 			return nil, err
 		}
@@ -494,7 +535,7 @@ func (t *Transport) dialClientConn(addr string, singleUse bool) (*ClientConn, er
 func (t *Transport) newTLSConfig(host string) *tls.Config {
 	cfg := new(tls.Config)
 	if t.TLSClientConfig != nil {
-		*cfg = *cloneTLSConfig(t.TLSClientConfig)
+		*cfg = *t.TLSClientConfig.Clone()
 	}
 	if !strSliceContains(cfg.NextProtos, NextProtoTLS) {
 		cfg.NextProtos = append([]string{NextProtoTLS}, cfg.NextProtos...)
@@ -545,7 +586,7 @@ func (t *Transport) expectContinueTimeout() time.Duration {
 	if t.t1 == nil {
 		return 0
 	}
-	return transportExpectContinueTimeout(t.t1)
+	return t.t1.ExpectContinueTimeout
 }
 
 func (t *Transport) NewClientConn(c net.Conn) (*ClientConn, error) {
@@ -711,8 +752,7 @@ func (cc *ClientConn) closeIfIdle() {
 var shutdownEnterWaitStateHook = func() {}
 
 // Shutdown gracefully close the client connection, waiting for running streams to complete.
-// Public implementation is in go17.go and not_go17.go
-func (cc *ClientConn) shutdown(ctx contextContext) error {
+func (cc *ClientConn) Shutdown(ctx context.Context) error {
 	if err := cc.sendGoAway(); err != nil {
 		return err
 	}
@@ -882,7 +922,7 @@ func checkConnHeaders(req *http.Request) error {
 // req.ContentLength, where 0 actually means zero (not unknown) and -1
 // means unknown.
 func actualContentLength(req *http.Request) int64 {
-	if req.Body == nil || reqBodyIsNoBody(req.Body) {
+	if req.Body == nil || req.Body == http.NoBody {
 		return 0
 	}
 	if req.ContentLength != 0 {
@@ -952,7 +992,7 @@ func (cc *ClientConn) roundTrip(req *http.Request) (res *http.Response, gotErrAf
 
 	cs := cc.newStream()
 	cs.req = req
-	cs.trace = requestTrace(req)
+	cs.trace = httptrace.ContextClientTrace(req.Context())
 	cs.requestedGzip = requestedGzip
 	bodyWriter := cc.t.getBodyWriterState(cs, body)
 	cs.on100 = bodyWriter.on100
@@ -990,7 +1030,7 @@ func (cc *ClientConn) roundTrip(req *http.Request) (res *http.Response, gotErrAf
 
 	readLoopResCh := cs.resc
 	bodyWritten := false
-	ctx := reqContext(req)
+	ctx := req.Context()
 
 	handleReadLoopResponse := func(re resAndError) (*http.Response, bool, error) {
 		res := re.res
@@ -1060,6 +1100,7 @@ func (cc *ClientConn) roundTrip(req *http.Request) (res *http.Response, gotErrAf
 			default:
 			}
 			if err != nil {
+				cc.forgetStreamID(cs.ID)
 				return nil, cs.getStartedWrite(), err
 			}
 			bodyWritten = true
@@ -1181,6 +1222,7 @@ func (cs *clientStream) writeRequestBody(body io.Reader, bodyCloser io.Closer) (
 			sawEOF = true
 			err = nil
 		} else if err != nil {
+			cc.writeStreamReset(cs.ID, ErrCodeCancel, err)
 			return err
 		}
 
@@ -1416,7 +1458,7 @@ func (cc *ClientConn) encodeHeaders(req *http.Request, addGzipHeader bool, trail
 		return nil, errRequestHeaderListSize
 	}
 
-	trace := requestTrace(req)
+	trace := httptrace.ContextClientTrace(req.Context())
 	traceHeaders := traceHasWroteHeaderField(trace)
 
 	// Header list size is ok. Write the headers.
@@ -1839,7 +1881,7 @@ func (rl *clientConnReadLoop) handleResponse(cs *clientStream, f *MetaHeadersFra
 		res.Header.Del("Content-Length")
 		res.ContentLength = -1
 		res.Body = &gzipReader{body: res.Body}
-		setResponseUncompressed(res)
+		res.Uncompressed = true
 	}
 	return res, nil
 }
@@ -2216,8 +2258,7 @@ func (rl *clientConnReadLoop) processResetStream(f *RSTStreamFrame) error {
 }
 
 // Ping sends a PING frame to the server and waits for the ack.
-// Public implementation is in go17.go and not_go17.go
-func (cc *ClientConn) ping(ctx contextContext) error {
+func (cc *ClientConn) Ping(ctx context.Context) error {
 	c := make(chan struct{})
 	// Generate a random payload
 	var p [8]byte
@@ -2451,3 +2492,91 @@ func (s bodyWriterState) scheduleBodyWrite() {
 func isConnectionCloseRequest(req *http.Request) bool {
 	return req.Close || httpguts.HeaderValuesContainsToken(req.Header["Connection"], "close")
 }
+
+// registerHTTPSProtocol calls Transport.RegisterProtocol but
+// converting panics into errors.
+func registerHTTPSProtocol(t *http.Transport, rt noDialH2RoundTripper) (err error) {
+	defer func() {
+		if e := recover(); e != nil {
+			err = fmt.Errorf("%v", e)
+		}
+	}()
+	t.RegisterProtocol("https", rt)
+	return nil
+}
+
+// noDialH2RoundTripper is a RoundTripper which only tries to complete the request
+// if there's already has a cached connection to the host.
+// (The field is exported so it can be accessed via reflect from net/http; tested
+// by TestNoDialH2RoundTripperType)
+type noDialH2RoundTripper struct{ *Transport }
+
+func (rt noDialH2RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
+	res, err := rt.Transport.RoundTrip(req)
+	if isNoCachedConnError(err) {
+		return nil, http.ErrSkipAltProtocol
+	}
+	return res, err
+}
+
+func (t *Transport) idleConnTimeout() time.Duration {
+	if t.t1 != nil {
+		return t.t1.IdleConnTimeout
+	}
+	return 0
+}
+
+func traceGetConn(req *http.Request, hostPort string) {
+	trace := httptrace.ContextClientTrace(req.Context())
+	if trace == nil || trace.GetConn == nil {
+		return
+	}
+	trace.GetConn(hostPort)
+}
+
+func traceGotConn(req *http.Request, cc *ClientConn) {
+	trace := httptrace.ContextClientTrace(req.Context())
+	if trace == nil || trace.GotConn == nil {
+		return
+	}
+	ci := httptrace.GotConnInfo{Conn: cc.tconn}
+	cc.mu.Lock()
+	ci.Reused = cc.nextStreamID > 1
+	ci.WasIdle = len(cc.streams) == 0 && ci.Reused
+	if ci.WasIdle && !cc.lastActive.IsZero() {
+		ci.IdleTime = time.Now().Sub(cc.lastActive)
+	}
+	cc.mu.Unlock()
+
+	trace.GotConn(ci)
+}
+
+func traceWroteHeaders(trace *httptrace.ClientTrace) {
+	if trace != nil && trace.WroteHeaders != nil {
+		trace.WroteHeaders()
+	}
+}
+
+func traceGot100Continue(trace *httptrace.ClientTrace) {
+	if trace != nil && trace.Got100Continue != nil {
+		trace.Got100Continue()
+	}
+}
+
+func traceWait100Continue(trace *httptrace.ClientTrace) {
+	if trace != nil && trace.Wait100Continue != nil {
+		trace.Wait100Continue()
+	}
+}
+
+func traceWroteRequest(trace *httptrace.ClientTrace, err error) {
+	if trace != nil && trace.WroteRequest != nil {
+		trace.WroteRequest(httptrace.WroteRequestInfo{Err: err})
+	}
+}
+
+func traceFirstResponseByte(trace *httptrace.ClientTrace) {
+	if trace != nil && trace.GotFirstResponseByte != nil {
+		trace.GotFirstResponseByte()
+	}
+}
diff --git a/vendor/golang.org/x/net/http2/transport_test.go b/vendor/golang.org/x/net/http2/transport_test.go
index 5b5c0768..f6efa61d 100644
--- a/vendor/golang.org/x/net/http2/transport_test.go
+++ b/vendor/golang.org/x/net/http2/transport_test.go
@@ -7,6 +7,7 @@ package http2
 import (
 	"bufio"
 	"bytes"
+	"context"
 	"crypto/tls"
 	"errors"
 	"flag"
@@ -31,7 +32,6 @@ import (
 	"testing"
 	"time"
 
-	"golang.org/x/net/context"
 	"golang.org/x/net/http2/hpack"
 )
 
@@ -424,7 +424,7 @@ func TestActualContentLength(t *testing.T) {
 		},
 		// http.NoBody means 0, not -1.
 		3: {
-			req:  &http.Request{Body: go18httpNoBody()},
+			req:  &http.Request{Body: http.NoBody},
 			want: 0,
 		},
 	}
@@ -564,9 +564,6 @@ func TestTransportDialTLS(t *testing.T) {
 func TestConfigureTransport(t *testing.T) {
 	t1 := &http.Transport{}
 	err := ConfigureTransport(t1)
-	if err == errTransportVersion {
-		t.Skip(err)
-	}
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -3784,7 +3781,7 @@ func TestTransportNoBodyMeansNoDATA(t *testing.T) {
 	unblockClient := make(chan bool)
 
 	ct.client = func() error {
-		req, _ := http.NewRequest("GET", "https://dummy.tld/", go18httpNoBody())
+		req, _ := http.NewRequest("GET", "https://dummy.tld/", http.NoBody)
 		ct.tr.RoundTrip(req)
 		<-unblockClient
 		return nil
@@ -4024,8 +4021,8 @@ func testClientConnClose(t *testing.T, closeMode closeMode) {
 	}
 	switch closeMode {
 	case shutdownCancel:
-		if err = cc.Shutdown(canceledCtx); err != errCanceled {
-			t.Errorf("got %v, want %v", err, errCanceled)
+		if err = cc.Shutdown(canceledCtx); err != context.Canceled {
+			t.Errorf("got %v, want %v", err, context.Canceled)
 		}
 		if cc.closing == false {
 			t.Error("expected closing to be true")
@@ -4183,3 +4180,99 @@ func TestNoDialH2RoundTripperType(t *testing.T) {
 		t.Fatalf("wrong kind %T; want *Transport", v.Interface())
 	}
 }
+
+type errReader struct {
+	body []byte
+	err  error
+}
+
+func (r *errReader) Read(p []byte) (int, error) {
+	if len(r.body) > 0 {
+		n := copy(p, r.body)
+		r.body = r.body[n:]
+		return n, nil
+	}
+	return 0, r.err
+}
+
+func testTransportBodyReadError(t *testing.T, body []byte) {
+	clientDone := make(chan struct{})
+	ct := newClientTester(t)
+	ct.client = func() error {
+		defer ct.cc.(*net.TCPConn).CloseWrite()
+		defer close(clientDone)
+
+		checkNoStreams := func() error {
+			cp, ok := ct.tr.connPool().(*clientConnPool)
+			if !ok {
+				return fmt.Errorf("conn pool is %T; want *clientConnPool", ct.tr.connPool())
+			}
+			cp.mu.Lock()
+			defer cp.mu.Unlock()
+			conns, ok := cp.conns["dummy.tld:443"]
+			if !ok {
+				return fmt.Errorf("missing connection")
+			}
+			if len(conns) != 1 {
+				return fmt.Errorf("conn pool size: %v; expect 1", len(conns))
+			}
+			if activeStreams(conns[0]) != 0 {
+				return fmt.Errorf("active streams count: %v; want 0", activeStreams(conns[0]))
+			}
+			return nil
+		}
+		bodyReadError := errors.New("body read error")
+		body := &errReader{body, bodyReadError}
+		req, err := http.NewRequest("PUT", "https://dummy.tld/", body)
+		if err != nil {
+			return err
+		}
+		_, err = ct.tr.RoundTrip(req)
+		if err != bodyReadError {
+			return fmt.Errorf("err = %v; want %v", err, bodyReadError)
+		}
+		if err = checkNoStreams(); err != nil {
+			return err
+		}
+		return nil
+	}
+	ct.server = func() error {
+		ct.greet()
+		var receivedBody []byte
+		var resetCount int
+		for {
+			f, err := ct.fr.ReadFrame()
+			if err != nil {
+				select {
+				case <-clientDone:
+					// If the client's done, it
+					// will have reported any
+					// errors on its side.
+					if bytes.Compare(receivedBody, body) != 0 {
+						return fmt.Errorf("body: %v; expected %v", receivedBody, body)
+					}
+					if resetCount != 1 {
+						return fmt.Errorf("stream reset count: %v; expected: 1", resetCount)
+					}
+					return nil
+				default:
+					return err
+				}
+			}
+			switch f := f.(type) {
+			case *WindowUpdateFrame, *SettingsFrame:
+			case *HeadersFrame:
+			case *DataFrame:
+				receivedBody = append(receivedBody, f.Data()...)
+			case *RSTStreamFrame:
+				resetCount++
+			default:
+				return fmt.Errorf("Unexpected client frame %v", f)
+			}
+		}
+	}
+	ct.run()
+}
+
+func TestTransportBodyReadError_Immediately(t *testing.T) { testTransportBodyReadError(t, nil) }
+func TestTransportBodyReadError_Some(t *testing.T)        { testTransportBodyReadError(t, []byte("123")) }
diff --git a/vendor/golang.org/x/net/http2/write.go b/vendor/golang.org/x/net/http2/write.go
index fae5c8ad..3849bc26 100644
--- a/vendor/golang.org/x/net/http2/write.go
+++ b/vendor/golang.org/x/net/http2/write.go
@@ -329,7 +329,7 @@ func (wu writeWindowUpdate) writeFrame(ctx writeContext) error {
 }
 
 // encodeHeaders encodes an http.Header. If keys is not nil, then (k, h[k])
-// is encoded only only if k is in keys.
+// is encoded only if k is in keys.
 func encodeHeaders(enc *hpack.Encoder, h http.Header, keys []string) {
 	if keys == nil {
 		sorter := sorterPool.Get().(*sorter)
diff --git a/vendor/golang.org/x/net/icmp/extension_test.go b/vendor/golang.org/x/net/icmp/extension_test.go
index a7669dae..ff513091 100644
--- a/vendor/golang.org/x/net/icmp/extension_test.go
+++ b/vendor/golang.org/x/net/icmp/extension_test.go
@@ -277,8 +277,7 @@ func TestMarshalAndParseExtension(t *testing.T) {
 					0x20, 0x00, 0x00, 0x00,
 				},
 				obj: []byte{
-					0x00, 0x0c, 0x03, 0x02,
-					0x00, 0x00, 0x00, 0x00,
+					0x00, 0x08, 0x03, 0x02,
 					0x00, 0x00, 0x03, 0x8f,
 				},
 				ext: &InterfaceIdent{
diff --git a/vendor/golang.org/x/net/icmp/interface.go b/vendor/golang.org/x/net/icmp/interface.go
index 617f757b..ae14818d 100644
--- a/vendor/golang.org/x/net/icmp/interface.go
+++ b/vendor/golang.org/x/net/icmp/interface.go
@@ -259,7 +259,7 @@ func (ifi *InterfaceIdent) Len(_ int) int {
 		}
 		return 4 + (l+3)&^3
 	case typeInterfaceByIndex:
-		return 4 + 8
+		return 4 + 4
 	case typeInterfaceByAddress:
 		return 4 + 4 + (len(ifi.Addr)+3)&^3
 	default:
@@ -284,7 +284,7 @@ func (ifi *InterfaceIdent) marshal(proto int, b []byte) error {
 	case typeInterfaceByName:
 		copy(b[4:], ifi.Name)
 	case typeInterfaceByIndex:
-		binary.BigEndian.PutUint64(b[4:4+8], uint64(ifi.Index))
+		binary.BigEndian.PutUint32(b[4:4+4], uint32(ifi.Index))
 	case typeInterfaceByAddress:
 		binary.BigEndian.PutUint16(b[4:4+2], uint16(ifi.AFI))
 		b[4+2] = byte(len(ifi.Addr))
@@ -302,10 +302,10 @@ func parseInterfaceIdent(b []byte) (Extension, error) {
 	case typeInterfaceByName:
 		ifi.Name = strings.Trim(string(b[4:]), string(0))
 	case typeInterfaceByIndex:
-		if len(b[4:]) < 8 {
+		if len(b[4:]) < 4 {
 			return nil, errInvalidExtension
 		}
-		ifi.Index = int(binary.BigEndian.Uint64(b[4 : 4+8]))
+		ifi.Index = int(binary.BigEndian.Uint32(b[4 : 4+4]))
 	case typeInterfaceByAddress:
 		if len(b[4:]) < 4 {
 			return nil, errInvalidExtension
diff --git a/vendor/golang.org/x/net/icmp/message.go b/vendor/golang.org/x/net/icmp/message.go
index 75aac6c5..b7883cc9 100644
--- a/vendor/golang.org/x/net/icmp/message.go
+++ b/vendor/golang.org/x/net/icmp/message.go
@@ -24,7 +24,8 @@ import (
 	"golang.org/x/net/ipv6"
 )
 
-// BUG(mikio): This package is not implemented on JS, NaCl and Plan 9.
+// BUG(mikio): This package is not implemented on AIX, JS, NaCl and
+// Plan 9.
 
 var (
 	errInvalidConn      = errors.New("invalid connection")
diff --git a/vendor/golang.org/x/net/internal/socket/empty.s b/vendor/golang.org/x/net/internal/socket/empty.s
new file mode 100644
index 00000000..bff0231c
--- /dev/null
+++ b/vendor/golang.org/x/net/internal/socket/empty.s
@@ -0,0 +1,7 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build darwin,go1.12
+
+// This exists solely so we can linkname in symbols from syscall.
diff --git a/vendor/golang.org/x/net/internal/socket/sys_go1_11_darwin.go b/vendor/golang.org/x/net/internal/socket/sys_go1_11_darwin.go
new file mode 100644
index 00000000..02d2b3cc
--- /dev/null
+++ b/vendor/golang.org/x/net/internal/socket/sys_go1_11_darwin.go
@@ -0,0 +1,33 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build !go1.12
+
+package socket
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+func getsockopt(s uintptr, level, name int, b []byte) (int, error) {
+	l := uint32(len(b))
+	_, _, errno := syscall.Syscall6(syscall.SYS_GETSOCKOPT, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(unsafe.Pointer(&l)), 0)
+	return int(l), errnoErr(errno)
+}
+
+func setsockopt(s uintptr, level, name int, b []byte) error {
+	_, _, errno := syscall.Syscall6(syscall.SYS_SETSOCKOPT, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(len(b)), 0)
+	return errnoErr(errno)
+}
+
+func recvmsg(s uintptr, h *msghdr, flags int) (int, error) {
+	n, _, errno := syscall.Syscall(syscall.SYS_RECVMSG, s, uintptr(unsafe.Pointer(h)), uintptr(flags))
+	return int(n), errnoErr(errno)
+}
+
+func sendmsg(s uintptr, h *msghdr, flags int) (int, error) {
+	n, _, errno := syscall.Syscall(syscall.SYS_SENDMSG, s, uintptr(unsafe.Pointer(h)), uintptr(flags))
+	return int(n), errnoErr(errno)
+}
diff --git a/vendor/golang.org/x/net/internal/socket/sys_go1_12_darwin.go b/vendor/golang.org/x/net/internal/socket/sys_go1_12_darwin.go
new file mode 100644
index 00000000..0999a19f
--- /dev/null
+++ b/vendor/golang.org/x/net/internal/socket/sys_go1_12_darwin.go
@@ -0,0 +1,42 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build go1.12
+
+package socket
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+//go:linkname syscall_getsockopt syscall.getsockopt
+func syscall_getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *uint32) error
+
+func getsockopt(s uintptr, level, name int, b []byte) (int, error) {
+	l := uint32(len(b))
+	err := syscall_getsockopt(int(s), level, name, unsafe.Pointer(&b[0]), &l)
+	return int(l), err
+}
+
+//go:linkname syscall_setsockopt syscall.setsockopt
+func syscall_setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) error
+
+func setsockopt(s uintptr, level, name int, b []byte) error {
+	return syscall_setsockopt(int(s), level, name, unsafe.Pointer(&b[0]), uintptr(len(b)))
+}
+
+//go:linkname syscall_recvmsg syscall.recvmsg
+func syscall_recvmsg(s int, msg *syscall.Msghdr, flags int) (n int, err error)
+
+func recvmsg(s uintptr, h *msghdr, flags int) (int, error) {
+	return syscall_recvmsg(int(s), (*syscall.Msghdr)(unsafe.Pointer(h)), flags)
+}
+
+//go:linkname syscall_sendmsg syscall.sendmsg
+func syscall_sendmsg(s int, msg *syscall.Msghdr, flags int) (n int, err error)
+
+func sendmsg(s uintptr, h *msghdr, flags int) (int, error) {
+	return syscall_sendmsg(int(s), (*syscall.Msghdr)(unsafe.Pointer(h)), flags)
+}
diff --git a/vendor/golang.org/x/net/internal/socket/sys_posix.go b/vendor/golang.org/x/net/internal/socket/sys_posix.go
index dc130c27..9a9bc476 100644
--- a/vendor/golang.org/x/net/internal/socket/sys_posix.go
+++ b/vendor/golang.org/x/net/internal/socket/sys_posix.go
@@ -121,18 +121,21 @@ var zoneCache = ipv6ZoneCache{
 	toName:  make(map[int]string),
 }
 
-func (zc *ipv6ZoneCache) update(ift []net.Interface) {
+// update refreshes the network interface information if the cache was last
+// updated more than 1 minute ago, or if force is set. It returns whether the
+// cache was updated.
+func (zc *ipv6ZoneCache) update(ift []net.Interface, force bool) (updated bool) {
 	zc.Lock()
 	defer zc.Unlock()
 	now := time.Now()
-	if zc.lastFetched.After(now.Add(-60 * time.Second)) {
-		return
+	if !force && zc.lastFetched.After(now.Add(-60*time.Second)) {
+		return false
 	}
 	zc.lastFetched = now
 	if len(ift) == 0 {
 		var err error
 		if ift, err = net.Interfaces(); err != nil {
-			return
+			return false
 		}
 	}
 	zc.toIndex = make(map[string]int, len(ift))
@@ -143,25 +146,38 @@ func (zc *ipv6ZoneCache) update(ift []net.Interface) {
 			zc.toName[ifi.Index] = ifi.Name
 		}
 	}
+	return true
 }
 
 func (zc *ipv6ZoneCache) name(zone int) string {
-	zoneCache.update(nil)
+	updated := zoneCache.update(nil, false)
 	zoneCache.RLock()
-	defer zoneCache.RUnlock()
 	name, ok := zoneCache.toName[zone]
-	if !ok {
+	zoneCache.RUnlock()
+	if !ok && !updated {
+		zoneCache.update(nil, true)
+		zoneCache.RLock()
+		name, ok = zoneCache.toName[zone]
+		zoneCache.RUnlock()
+	}
+	if !ok { // last resort
 		name = strconv.Itoa(zone)
 	}
 	return name
 }
 
 func (zc *ipv6ZoneCache) index(zone string) int {
-	zoneCache.update(nil)
+	updated := zoneCache.update(nil, false)
 	zoneCache.RLock()
-	defer zoneCache.RUnlock()
 	index, ok := zoneCache.toIndex[zone]
-	if !ok {
+	zoneCache.RUnlock()
+	if !ok && !updated {
+		zoneCache.update(nil, true)
+		zoneCache.RLock()
+		index, ok = zoneCache.toIndex[zone]
+		zoneCache.RUnlock()
+	}
+	if !ok { // last resort
 		index, _ = strconv.Atoi(zone)
 	}
 	return index
diff --git a/vendor/golang.org/x/net/internal/socket/sys_unix.go b/vendor/golang.org/x/net/internal/socket/sys_unix.go
index 18eba308..0eb71283 100644
--- a/vendor/golang.org/x/net/internal/socket/sys_unix.go
+++ b/vendor/golang.org/x/net/internal/socket/sys_unix.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build darwin dragonfly freebsd linux,!s390x,!386 netbsd openbsd
+// +build dragonfly freebsd linux,!s390x,!386 netbsd openbsd
 
 package socket
 
diff --git a/vendor/golang.org/x/net/ipv4/doc.go b/vendor/golang.org/x/net/ipv4/doc.go
index 3efa2903..863d55b8 100644
--- a/vendor/golang.org/x/net/ipv4/doc.go
+++ b/vendor/golang.org/x/net/ipv4/doc.go
@@ -241,4 +241,5 @@
 // IncludeSourceSpecificGroup may return an error.
 package ipv4 // import "golang.org/x/net/ipv4"
 
-// BUG(mikio): This package is not implemented on JS, NaCl and Plan 9.
+// BUG(mikio): This package is not implemented on AIX, JS, NaCl and
+// Plan 9.
diff --git a/vendor/golang.org/x/net/ipv4/payload_cmsg.go b/vendor/golang.org/x/net/ipv4/payload_cmsg.go
index 204a49fe..a7c892dc 100644
--- a/vendor/golang.org/x/net/ipv4/payload_cmsg.go
+++ b/vendor/golang.org/x/net/ipv4/payload_cmsg.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build !js,!nacl,!plan9,!windows
+// +build darwin dragonfly freebsd linux netbsd openbsd solaris
 
 package ipv4
 
diff --git a/vendor/golang.org/x/net/ipv4/payload_cmsg_go1_8.go b/vendor/golang.org/x/net/ipv4/payload_cmsg_go1_8.go
index 8d45599f..15a27b7a 100644
--- a/vendor/golang.org/x/net/ipv4/payload_cmsg_go1_8.go
+++ b/vendor/golang.org/x/net/ipv4/payload_cmsg_go1_8.go
@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 // +build !go1.9
-// +build !js,!nacl,!plan9,!windows
+// +build darwin dragonfly freebsd linux netbsd openbsd solaris
 
 package ipv4
 
diff --git a/vendor/golang.org/x/net/ipv4/payload_cmsg_go1_9.go b/vendor/golang.org/x/net/ipv4/payload_cmsg_go1_9.go
index 4081aad8..aab3b224 100644
--- a/vendor/golang.org/x/net/ipv4/payload_cmsg_go1_9.go
+++ b/vendor/golang.org/x/net/ipv4/payload_cmsg_go1_9.go
@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 // +build go1.9
-// +build !js,!nacl,!plan9,!windows
+// +build darwin dragonfly freebsd linux netbsd openbsd solaris
 
 package ipv4
 
diff --git a/vendor/golang.org/x/net/ipv4/payload_nocmsg.go b/vendor/golang.org/x/net/ipv4/payload_nocmsg.go
index 1d434c61..d57f05c1 100644
--- a/vendor/golang.org/x/net/ipv4/payload_nocmsg.go
+++ b/vendor/golang.org/x/net/ipv4/payload_nocmsg.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build js nacl plan9 windows
+// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris
 
 package ipv4
 
diff --git a/vendor/golang.org/x/net/ipv6/doc.go b/vendor/golang.org/x/net/ipv6/doc.go
index e0be9d50..d38ea0da 100644
--- a/vendor/golang.org/x/net/ipv6/doc.go
+++ b/vendor/golang.org/x/net/ipv6/doc.go
@@ -240,4 +240,5 @@
 // IncludeSourceSpecificGroup may return an error.
 package ipv6 // import "golang.org/x/net/ipv6"
 
-// BUG(mikio): This package is not implemented on JS, NaCl and Plan 9.
+// BUG(mikio): This package is not implemented on AIX, JS, NaCl and
+// Plan 9.
diff --git a/vendor/golang.org/x/net/ipv6/payload_cmsg.go b/vendor/golang.org/x/net/ipv6/payload_cmsg.go
index 3f23b5d2..e17847d0 100644
--- a/vendor/golang.org/x/net/ipv6/payload_cmsg.go
+++ b/vendor/golang.org/x/net/ipv6/payload_cmsg.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build !js,!nacl,!plan9,!windows
+// +build darwin dragonfly freebsd linux netbsd openbsd solaris
 
 package ipv6
 
diff --git a/vendor/golang.org/x/net/ipv6/payload_cmsg_go1_8.go b/vendor/golang.org/x/net/ipv6/payload_cmsg_go1_8.go
index bc4209db..a48a6ed6 100644
--- a/vendor/golang.org/x/net/ipv6/payload_cmsg_go1_8.go
+++ b/vendor/golang.org/x/net/ipv6/payload_cmsg_go1_8.go
@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 // +build !go1.9
-// +build !js,!nacl,!plan9,!windows
+// +build darwin dragonfly freebsd linux netbsd openbsd solaris
 
 package ipv6
 
diff --git a/vendor/golang.org/x/net/ipv6/payload_cmsg_go1_9.go b/vendor/golang.org/x/net/ipv6/payload_cmsg_go1_9.go
index 7dd65048..fb196ed8 100644
--- a/vendor/golang.org/x/net/ipv6/payload_cmsg_go1_9.go
+++ b/vendor/golang.org/x/net/ipv6/payload_cmsg_go1_9.go
@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 // +build go1.9
-// +build !js,!nacl,!plan9,!windows
+// +build darwin dragonfly freebsd linux netbsd openbsd solaris
 
 package ipv6
 
diff --git a/vendor/golang.org/x/net/ipv6/payload_nocmsg.go b/vendor/golang.org/x/net/ipv6/payload_nocmsg.go
index 459142d2..bfb54478 100644
--- a/vendor/golang.org/x/net/ipv6/payload_nocmsg.go
+++ b/vendor/golang.org/x/net/ipv6/payload_nocmsg.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build js nacl plan9 windows
+// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris
 
 package ipv6
 
diff --git a/vendor/golang.org/x/net/route/empty.s b/vendor/golang.org/x/net/route/empty.s
new file mode 100644
index 00000000..bff0231c
--- /dev/null
+++ b/vendor/golang.org/x/net/route/empty.s
@@ -0,0 +1,7 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build darwin,go1.12
+
+// This exists solely so we can linkname in symbols from syscall.
diff --git a/vendor/golang.org/x/net/route/syscall.go b/vendor/golang.org/x/net/route/syscall.go
index 5f69ea63..72431b03 100644
--- a/vendor/golang.org/x/net/route/syscall.go
+++ b/vendor/golang.org/x/net/route/syscall.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build darwin dragonfly freebsd netbsd openbsd
+// +build dragonfly freebsd netbsd openbsd
 
 package route
 
diff --git a/vendor/golang.org/x/net/route/syscall_go1_11_darwin.go b/vendor/golang.org/x/net/route/syscall_go1_11_darwin.go
new file mode 100644
index 00000000..7228e443
--- /dev/null
+++ b/vendor/golang.org/x/net/route/syscall_go1_11_darwin.go
@@ -0,0 +1,28 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build !go1.12
+
+package route
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+var zero uintptr
+
+func sysctl(mib []int32, old *byte, oldlen *uintptr, new *byte, newlen uintptr) error {
+	var p unsafe.Pointer
+	if len(mib) > 0 {
+		p = unsafe.Pointer(&mib[0])
+	} else {
+		p = unsafe.Pointer(&zero)
+	}
+	_, _, errno := syscall.Syscall6(syscall.SYS___SYSCTL, uintptr(p), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), newlen)
+	if errno != 0 {
+		return error(errno)
+	}
+	return nil
+}
diff --git a/vendor/golang.org/x/net/route/syscall_go1_12_darwin.go b/vendor/golang.org/x/net/route/syscall_go1_12_darwin.go
new file mode 100644
index 00000000..7922a683
--- /dev/null
+++ b/vendor/golang.org/x/net/route/syscall_go1_12_darwin.go
@@ -0,0 +1,12 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build go1.12
+
+package route
+
+import _ "unsafe" // for linkname
+
+//go:linkname sysctl syscall.sysctl
+func sysctl(mib []int32, old *byte, oldlen *uintptr, new *byte, newlen uintptr) error
diff --git a/vendor/golang.org/x/net/trace/trace.go b/vendor/golang.org/x/net/trace/trace.go
index f00d869f..43711c67 100644
--- a/vendor/golang.org/x/net/trace/trace.go
+++ b/vendor/golang.org/x/net/trace/trace.go
@@ -64,6 +64,7 @@ package trace // import "golang.org/x/net/trace"
 
 import (
 	"bytes"
+	"context"
 	"fmt"
 	"html/template"
 	"io"
@@ -124,6 +125,18 @@ func init() {
 	http.HandleFunc("/debug/events", Events)
 }
 
+// NewContext returns a copy of the parent context
+// and associates it with a Trace.
+func NewContext(ctx context.Context, tr Trace) context.Context {
+	return context.WithValue(ctx, contextKey, tr)
+}
+
+// FromContext returns the Trace bound to the context, if any.
+func FromContext(ctx context.Context) (tr Trace, ok bool) {
+	tr, ok = ctx.Value(contextKey).(Trace)
+	return
+}
+
 // Traces responds with traces from the program.
 // The package initialization registers it in http.DefaultServeMux
 // at /debug/requests.
diff --git a/vendor/golang.org/x/net/trace/trace_go16.go b/vendor/golang.org/x/net/trace/trace_go16.go
deleted file mode 100644
index d6081911..00000000
--- a/vendor/golang.org/x/net/trace/trace_go16.go
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !go1.7
-
-package trace
-
-import "golang.org/x/net/context"
-
-// NewContext returns a copy of the parent context
-// and associates it with a Trace.
-func NewContext(ctx context.Context, tr Trace) context.Context {
-	return context.WithValue(ctx, contextKey, tr)
-}
-
-// FromContext returns the Trace bound to the context, if any.
-func FromContext(ctx context.Context) (tr Trace, ok bool) {
-	tr, ok = ctx.Value(contextKey).(Trace)
-	return
-}
diff --git a/vendor/golang.org/x/net/trace/trace_go17.go b/vendor/golang.org/x/net/trace/trace_go17.go
deleted file mode 100644
index df6e1fba..00000000
--- a/vendor/golang.org/x/net/trace/trace_go17.go
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.7
-
-package trace
-
-import "context"
-
-// NewContext returns a copy of the parent context
-// and associates it with a Trace.
-func NewContext(ctx context.Context, tr Trace) context.Context {
-	return context.WithValue(ctx, contextKey, tr)
-}
-
-// FromContext returns the Trace bound to the context, if any.
-func FromContext(ctx context.Context) (tr Trace, ok bool) {
-	tr, ok = ctx.Value(contextKey).(Trace)
-	return
-}
diff --git a/vendor/golang.org/x/net/webdav/file.go b/vendor/golang.org/x/net/webdav/file.go
index 748118dd..9f537787 100644
--- a/vendor/golang.org/x/net/webdav/file.go
+++ b/vendor/golang.org/x/net/webdav/file.go
@@ -5,6 +5,7 @@
 package webdav
 
 import (
+	"context"
 	"encoding/xml"
 	"io"
 	"net/http"
@@ -14,8 +15,6 @@ import (
 	"strings"
 	"sync"
 	"time"
-
-	"golang.org/x/net/context"
 )
 
 // slashClean is equivalent to but slightly more efficient than
diff --git a/vendor/golang.org/x/net/webdav/file_go1.6.go b/vendor/golang.org/x/net/webdav/file_go1.6.go
deleted file mode 100644
index fa387700..00000000
--- a/vendor/golang.org/x/net/webdav/file_go1.6.go
+++ /dev/null
@@ -1,17 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !go1.7
-
-package webdav
-
-import (
-	"net/http"
-
-	"golang.org/x/net/context"
-)
-
-func getContext(r *http.Request) context.Context {
-	return context.Background()
-}
diff --git a/vendor/golang.org/x/net/webdav/file_go1.7.go b/vendor/golang.org/x/net/webdav/file_go1.7.go
deleted file mode 100644
index d1c3de83..00000000
--- a/vendor/golang.org/x/net/webdav/file_go1.7.go
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.7
-
-package webdav
-
-import (
-	"context"
-	"net/http"
-)
-
-func getContext(r *http.Request) context.Context {
-	return r.Context()
-}
diff --git a/vendor/golang.org/x/net/webdav/file_test.go b/vendor/golang.org/x/net/webdav/file_test.go
index bfd96e19..04b8a455 100644
--- a/vendor/golang.org/x/net/webdav/file_test.go
+++ b/vendor/golang.org/x/net/webdav/file_test.go
@@ -5,6 +5,7 @@
 package webdav
 
 import (
+	"context"
 	"encoding/xml"
 	"fmt"
 	"io"
@@ -18,8 +19,6 @@ import (
 	"strconv"
 	"strings"
 	"testing"
-
-	"golang.org/x/net/context"
 )
 
 func TestSlashClean(t *testing.T) {
diff --git a/vendor/golang.org/x/net/webdav/prop.go b/vendor/golang.org/x/net/webdav/prop.go
index 4d7be349..2c48bc4e 100644
--- a/vendor/golang.org/x/net/webdav/prop.go
+++ b/vendor/golang.org/x/net/webdav/prop.go
@@ -6,6 +6,7 @@ package webdav
 
 import (
 	"bytes"
+	"context"
 	"encoding/xml"
 	"errors"
 	"fmt"
@@ -15,8 +16,6 @@ import (
 	"os"
 	"path/filepath"
 	"strconv"
-
-	"golang.org/x/net/context"
 )
 
 // Proppatch describes a property update instruction as defined in RFC 4918.
diff --git a/vendor/golang.org/x/net/webdav/prop_test.go b/vendor/golang.org/x/net/webdav/prop_test.go
index bc42b913..855446b8 100644
--- a/vendor/golang.org/x/net/webdav/prop_test.go
+++ b/vendor/golang.org/x/net/webdav/prop_test.go
@@ -5,6 +5,7 @@
 package webdav
 
 import (
+	"context"
 	"encoding/xml"
 	"fmt"
 	"net/http"
@@ -13,8 +14,6 @@ import (
 	"regexp"
 	"sort"
 	"testing"
-
-	"golang.org/x/net/context"
 )
 
 func TestMemPS(t *testing.T) {
diff --git a/vendor/golang.org/x/net/webdav/webdav.go b/vendor/golang.org/x/net/webdav/webdav.go
index 7b56687f..744d2d52 100644
--- a/vendor/golang.org/x/net/webdav/webdav.go
+++ b/vendor/golang.org/x/net/webdav/webdav.go
@@ -174,7 +174,7 @@ func (h *Handler) handleOptions(w http.ResponseWriter, r *http.Request) (status
 	if err != nil {
 		return status, err
 	}
-	ctx := getContext(r)
+	ctx := r.Context()
 	allow := "OPTIONS, LOCK, PUT, MKCOL"
 	if fi, err := h.FileSystem.Stat(ctx, reqPath); err == nil {
 		if fi.IsDir() {
@@ -197,7 +197,7 @@ func (h *Handler) handleGetHeadPost(w http.ResponseWriter, r *http.Request) (sta
 		return status, err
 	}
 	// TODO: check locks for read-only access??
-	ctx := getContext(r)
+	ctx := r.Context()
 	f, err := h.FileSystem.OpenFile(ctx, reqPath, os.O_RDONLY, 0)
 	if err != nil {
 		return http.StatusNotFound, err
@@ -231,7 +231,7 @@ func (h *Handler) handleDelete(w http.ResponseWriter, r *http.Request) (status i
 	}
 	defer release()
 
-	ctx := getContext(r)
+	ctx := r.Context()
 
 	// TODO: return MultiStatus where appropriate.
 
@@ -262,7 +262,7 @@ func (h *Handler) handlePut(w http.ResponseWriter, r *http.Request) (status int,
 	defer release()
 	// TODO(rost): Support the If-Match, If-None-Match headers? See bradfitz'
 	// comments in http.checkEtag.
-	ctx := getContext(r)
+	ctx := r.Context()
 
 	f, err := h.FileSystem.OpenFile(ctx, reqPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
 	if err != nil {
@@ -300,7 +300,7 @@ func (h *Handler) handleMkcol(w http.ResponseWriter, r *http.Request) (status in
 	}
 	defer release()
 
-	ctx := getContext(r)
+	ctx := r.Context()
 
 	if r.ContentLength > 0 {
 		return http.StatusUnsupportedMediaType, nil
@@ -344,7 +344,7 @@ func (h *Handler) handleCopyMove(w http.ResponseWriter, r *http.Request) (status
 		return http.StatusForbidden, errDestinationEqualsSource
 	}
 
-	ctx := getContext(r)
+	ctx := r.Context()
 
 	if r.Method == "COPY" {
 		// Section 7.5.1 says that a COPY only needs to lock the destination,
@@ -399,7 +399,7 @@ func (h *Handler) handleLock(w http.ResponseWriter, r *http.Request) (retStatus
 		return status, err
 	}
 
-	ctx := getContext(r)
+	ctx := r.Context()
 	token, ld, now, created := "", LockDetails{}, time.Now(), false
 	if li == (lockInfo{}) {
 		// An empty lockInfo means to refresh the lock.
@@ -511,7 +511,7 @@ func (h *Handler) handlePropfind(w http.ResponseWriter, r *http.Request) (status
 	if err != nil {
 		return status, err
 	}
-	ctx := getContext(r)
+	ctx := r.Context()
 	fi, err := h.FileSystem.Stat(ctx, reqPath)
 	if err != nil {
 		if os.IsNotExist(err) {
@@ -581,7 +581,7 @@ func (h *Handler) handleProppatch(w http.ResponseWriter, r *http.Request) (statu
 	}
 	defer release()
 
-	ctx := getContext(r)
+	ctx := r.Context()
 
 	if _, err := h.FileSystem.Stat(ctx, reqPath); err != nil {
 		if os.IsNotExist(err) {
diff --git a/vendor/golang.org/x/net/webdav/webdav_test.go b/vendor/golang.org/x/net/webdav/webdav_test.go
index 25e0d542..46d1bb62 100644
--- a/vendor/golang.org/x/net/webdav/webdav_test.go
+++ b/vendor/golang.org/x/net/webdav/webdav_test.go
@@ -5,6 +5,7 @@
 package webdav
 
 import (
+	"context"
 	"errors"
 	"fmt"
 	"io"
@@ -18,8 +19,6 @@ import (
 	"sort"
 	"strings"
 	"testing"
-
-	"golang.org/x/net/context"
 )
 
 // TODO: add tests to check XML responses with the expected prefix path
diff --git a/vendor/golang.org/x/oauth2/README.md b/vendor/golang.org/x/oauth2/README.md
index eb8dcee1..68f436ed 100644
--- a/vendor/golang.org/x/oauth2/README.md
+++ b/vendor/golang.org/x/oauth2/README.md
@@ -24,7 +24,9 @@ See godoc for further documentation and examples.
 
 In change 96e89be (March 2015), we removed the `oauth2.Context2` type in favor
 of the [`context.Context`](https://golang.org/x/net/context#Context) type from
-the `golang.org/x/net/context` package
+the `golang.org/x/net/context` package. Later replaced by the standard `context` package
+of the [`context.Context`](https://golang.org/pkg/context#Context) type.
+
 
 This means it's no longer possible to use the "Classic App Engine"
 `appengine.Context` type with the `oauth2` package. (You're using
@@ -44,7 +46,7 @@ with the `oauth2` package.
 
 ```go
 import (
-	"golang.org/x/net/context"
+	"context"
 	"golang.org/x/oauth2"
 	"golang.org/x/oauth2/google"
 	newappengine "google.golang.org/appengine"
@@ -68,6 +70,13 @@ func handler(w http.ResponseWriter, r *http.Request) {
 }
 ```
 
+## Policy for new packages
+
+We no longer accept new provider-specific packages in this repo. For
+defining provider endpoints and provider-specific OAuth2 behavior, we
+encourage you to create packages elsewhere. We'll keep the existing
+packages for compatibility.
+
 ## Report Issues / Send Patches
 
 This repository uses Gerrit for code changes. To learn how to submit changes to
diff --git a/vendor/golang.org/x/oauth2/clientcredentials/clientcredentials.go b/vendor/golang.org/x/oauth2/clientcredentials/clientcredentials.go
index c4e840d2..3c816bb8 100644
--- a/vendor/golang.org/x/oauth2/clientcredentials/clientcredentials.go
+++ b/vendor/golang.org/x/oauth2/clientcredentials/clientcredentials.go
@@ -14,12 +14,12 @@
 package clientcredentials // import "golang.org/x/oauth2/clientcredentials"
 
 import (
+	"context"
 	"fmt"
 	"net/http"
 	"net/url"
 	"strings"
 
-	"golang.org/x/net/context"
 	"golang.org/x/oauth2"
 	"golang.org/x/oauth2/internal"
 )
@@ -45,16 +45,19 @@ type Config struct {
 }
 
 // Token uses client credentials to retrieve a token.
-// The HTTP client to use is derived from the context.
-// If nil, http.DefaultClient is used.
+//
+// The provided context optionally controls which HTTP client is used. See the oauth2.HTTPClient variable.
 func (c *Config) Token(ctx context.Context) (*oauth2.Token, error) {
 	return c.TokenSource(ctx).Token()
 }
 
 // Client returns an HTTP client using the provided token.
-// The token will auto-refresh as necessary. The underlying
-// HTTP transport will be obtained using the provided context.
-// The returned client and its Transport should not be modified.
+// The token will auto-refresh as necessary.
+//
+// The provided context optionally controls which HTTP client
+// is returned. See the oauth2.HTTPClient variable.
+//
+// The returned Client and its Transport should not be modified.
 func (c *Config) Client(ctx context.Context) *http.Client {
 	return oauth2.NewClient(ctx, c.TokenSource(ctx))
 }
diff --git a/vendor/golang.org/x/oauth2/facebook/facebook.go b/vendor/golang.org/x/oauth2/facebook/facebook.go
index 14c801a2..21c49e7f 100644
--- a/vendor/golang.org/x/oauth2/facebook/facebook.go
+++ b/vendor/golang.org/x/oauth2/facebook/facebook.go
@@ -11,6 +11,6 @@ import (
 
 // Endpoint is Facebook's OAuth 2.0 endpoint.
 var Endpoint = oauth2.Endpoint{
-	AuthURL:  "https://www.facebook.com/dialog/oauth",
-	TokenURL: "https://graph.facebook.com/oauth/access_token",
+	AuthURL:  "https://www.facebook.com/v3.1/dialog/oauth",
+	TokenURL: "https://graph.facebook.com/v3.1/oauth/access_token",
 }
diff --git a/vendor/golang.org/x/oauth2/google/appengine.go b/vendor/golang.org/x/oauth2/google/appengine.go
index 50d918b8..feb1157b 100644
--- a/vendor/golang.org/x/oauth2/google/appengine.go
+++ b/vendor/golang.org/x/oauth2/google/appengine.go
@@ -5,85 +5,34 @@
 package google
 
 import (
-	"sort"
-	"strings"
-	"sync"
+	"context"
 	"time"
 
-	"golang.org/x/net/context"
 	"golang.org/x/oauth2"
 )
 
-// appengineFlex is set at init time by appengineflex_hook.go. If true, we are on App Engine Flex.
-var appengineFlex bool
-
-// Set at init time by appengine_hook.go. If nil, we're not on App Engine.
+// Set at init time by appengine_gen1.go. If nil, we're not on App Engine standard first generation (<= Go 1.9) or App Engine flexible.
 var appengineTokenFunc func(c context.Context, scopes ...string) (token string, expiry time.Time, err error)
 
-// Set at init time by appengine_hook.go. If nil, we're not on App Engine.
+// Set at init time by appengine_gen1.go. If nil, we're not on App Engine standard first generation (<= Go 1.9) or App Engine flexible.
 var appengineAppIDFunc func(c context.Context) string
 
-// AppEngineTokenSource returns a token source that fetches tokens
-// issued to the current App Engine application's service account.
-// If you are implementing a 3-legged OAuth 2.0 flow on App Engine
-// that involves user accounts, see oauth2.Config instead.
+// AppEngineTokenSource returns a token source that fetches tokens from either
+// the current application's service account or from the metadata server,
+// depending on the App Engine environment. See below for environment-specific
+// details. If you are implementing a 3-legged OAuth 2.0 flow on App Engine that
+// involves user accounts, see oauth2.Config instead.
+//
+// First generation App Engine runtimes (<= Go 1.9):
+// AppEngineTokenSource returns a token source that fetches tokens issued to the
+// current App Engine application's service account. The provided context must have
+// come from appengine.NewContext.
 //
-// The provided context must have come from appengine.NewContext.
+// Second generation App Engine runtimes (>= Go 1.11) and App Engine flexible:
+// AppEngineTokenSource is DEPRECATED on second generation runtimes and on the
+// flexible environment. It delegates to ComputeTokenSource, and the provided
+// context and scopes are not used. Please use DefaultTokenSource (or ComputeTokenSource,
+// which DefaultTokenSource will use in this case) instead.
 func AppEngineTokenSource(ctx context.Context, scope ...string) oauth2.TokenSource {
-	if appengineTokenFunc == nil {
-		panic("google: AppEngineTokenSource can only be used on App Engine.")
-	}
-	scopes := append([]string{}, scope...)
-	sort.Strings(scopes)
-	return &appEngineTokenSource{
-		ctx:    ctx,
-		scopes: scopes,
-		key:    strings.Join(scopes, " "),
-	}
-}
-
-// aeTokens helps the fetched tokens to be reused until their expiration.
-var (
-	aeTokensMu sync.Mutex
-	aeTokens   = make(map[string]*tokenLock) // key is space-separated scopes
-)
-
-type tokenLock struct {
-	mu sync.Mutex // guards t; held while fetching or updating t
-	t  *oauth2.Token
-}
-
-type appEngineTokenSource struct {
-	ctx    context.Context
-	scopes []string
-	key    string // to aeTokens map; space-separated scopes
-}
-
-func (ts *appEngineTokenSource) Token() (*oauth2.Token, error) {
-	if appengineTokenFunc == nil {
-		panic("google: AppEngineTokenSource can only be used on App Engine.")
-	}
-
-	aeTokensMu.Lock()
-	tok, ok := aeTokens[ts.key]
-	if !ok {
-		tok = &tokenLock{}
-		aeTokens[ts.key] = tok
-	}
-	aeTokensMu.Unlock()
-
-	tok.mu.Lock()
-	defer tok.mu.Unlock()
-	if tok.t.Valid() {
-		return tok.t, nil
-	}
-	access, exp, err := appengineTokenFunc(ts.ctx, ts.scopes...)
-	if err != nil {
-		return nil, err
-	}
-	tok.t = &oauth2.Token{
-		AccessToken: access,
-		Expiry:      exp,
-	}
-	return tok.t, nil
+	return appEngineTokenSource(ctx, scope...)
 }
diff --git a/vendor/golang.org/x/oauth2/google/appengine_gen1.go b/vendor/golang.org/x/oauth2/google/appengine_gen1.go
new file mode 100644
index 00000000..83dacac3
--- /dev/null
+++ b/vendor/golang.org/x/oauth2/google/appengine_gen1.go
@@ -0,0 +1,77 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build appengine
+
+// This file applies to App Engine first generation runtimes (<= Go 1.9).
+
+package google
+
+import (
+	"context"
+	"sort"
+	"strings"
+	"sync"
+
+	"golang.org/x/oauth2"
+	"google.golang.org/appengine"
+)
+
+func init() {
+	appengineTokenFunc = appengine.AccessToken
+	appengineAppIDFunc = appengine.AppID
+}
+
+// See comment on AppEngineTokenSource in appengine.go.
+func appEngineTokenSource(ctx context.Context, scope ...string) oauth2.TokenSource {
+	scopes := append([]string{}, scope...)
+	sort.Strings(scopes)
+	return &gaeTokenSource{
+		ctx:    ctx,
+		scopes: scopes,
+		key:    strings.Join(scopes, " "),
+	}
+}
+
+// aeTokens helps the fetched tokens to be reused until their expiration.
+var (
+	aeTokensMu sync.Mutex
+	aeTokens   = make(map[string]*tokenLock) // key is space-separated scopes
+)
+
+type tokenLock struct {
+	mu sync.Mutex // guards t; held while fetching or updating t
+	t  *oauth2.Token
+}
+
+type gaeTokenSource struct {
+	ctx    context.Context
+	scopes []string
+	key    string // to aeTokens map; space-separated scopes
+}
+
+func (ts *gaeTokenSource) Token() (*oauth2.Token, error) {
+	aeTokensMu.Lock()
+	tok, ok := aeTokens[ts.key]
+	if !ok {
+		tok = &tokenLock{}
+		aeTokens[ts.key] = tok
+	}
+	aeTokensMu.Unlock()
+
+	tok.mu.Lock()
+	defer tok.mu.Unlock()
+	if tok.t.Valid() {
+		return tok.t, nil
+	}
+	access, exp, err := appengineTokenFunc(ts.ctx, ts.scopes...)
+	if err != nil {
+		return nil, err
+	}
+	tok.t = &oauth2.Token{
+		AccessToken: access,
+		Expiry:      exp,
+	}
+	return tok.t, nil
+}
diff --git a/vendor/golang.org/x/oauth2/google/appengine_gen2_flex.go b/vendor/golang.org/x/oauth2/google/appengine_gen2_flex.go
new file mode 100644
index 00000000..04c2c221
--- /dev/null
+++ b/vendor/golang.org/x/oauth2/google/appengine_gen2_flex.go
@@ -0,0 +1,27 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build !appengine
+
+// This file applies to App Engine second generation runtimes (>= Go 1.11) and App Engine flexible.
+
+package google
+
+import (
+	"context"
+	"log"
+	"sync"
+
+	"golang.org/x/oauth2"
+)
+
+var logOnce sync.Once // only spam about deprecation once
+
+// See comment on AppEngineTokenSource in appengine.go.
+func appEngineTokenSource(ctx context.Context, scope ...string) oauth2.TokenSource {
+	logOnce.Do(func() {
+		log.Print("google: AppEngineTokenSource is deprecated on App Engine standard second generation runtimes (>= Go 1.11) and App Engine flexible. Please use DefaultTokenSource or ComputeTokenSource.")
+	})
+	return ComputeTokenSource("")
+}
diff --git a/vendor/golang.org/x/oauth2/google/appengine_hook.go b/vendor/golang.org/x/oauth2/google/appengine_hook.go
deleted file mode 100644
index 56669eaa..00000000
--- a/vendor/golang.org/x/oauth2/google/appengine_hook.go
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build appengine appenginevm
-
-package google
-
-import "google.golang.org/appengine"
-
-func init() {
-	appengineTokenFunc = appengine.AccessToken
-	appengineAppIDFunc = appengine.AppID
-}
diff --git a/vendor/golang.org/x/oauth2/google/appengineflex_hook.go b/vendor/golang.org/x/oauth2/google/appengineflex_hook.go
deleted file mode 100644
index 5d0231af..00000000
--- a/vendor/golang.org/x/oauth2/google/appengineflex_hook.go
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build appenginevm
-
-package google
-
-func init() {
-	appengineFlex = true // Flex doesn't support appengine.AccessToken; depend on metadata server.
-}
diff --git a/vendor/golang.org/x/oauth2/google/default.go b/vendor/golang.org/x/oauth2/google/default.go
index a3160743..5087d845 100644
--- a/vendor/golang.org/x/oauth2/google/default.go
+++ b/vendor/golang.org/x/oauth2/google/default.go
@@ -5,6 +5,7 @@
 package google
 
 import (
+	"context"
 	"encoding/json"
 	"fmt"
 	"io/ioutil"
@@ -14,10 +15,28 @@ import (
 	"runtime"
 
 	"cloud.google.com/go/compute/metadata"
-	"golang.org/x/net/context"
 	"golang.org/x/oauth2"
 )
 
+// Credentials holds Google credentials, including "Application Default Credentials".
+// For more details, see:
+// https://developers.google.com/accounts/docs/application-default-credentials
+type Credentials struct {
+	ProjectID   string // may be empty
+	TokenSource oauth2.TokenSource
+
+	// JSON contains the raw bytes from a JSON credentials file.
+	// This field may be nil if authentication is provided by the
+	// environment and not with a credentials file, e.g. when code is
+	// running on Google Cloud Platform.
+	JSON []byte
+}
+
+// DefaultCredentials is the old name of Credentials.
+//
+// Deprecated: use Credentials instead.
+type DefaultCredentials = Credentials
+
 // DefaultClient returns an HTTP Client that uses the
 // DefaultTokenSource to obtain authentication credentials.
 func DefaultClient(ctx context.Context, scope ...string) (*http.Client, error) {
@@ -39,8 +58,23 @@ func DefaultTokenSource(ctx context.Context, scope ...string) (oauth2.TokenSourc
 	return creds.TokenSource, nil
 }
 
-// Common implementation for FindDefaultCredentials.
-func findDefaultCredentials(ctx context.Context, scopes []string) (*DefaultCredentials, error) {
+// FindDefaultCredentials searches for "Application Default Credentials".
+//
+// It looks for credentials in the following places,
+// preferring the first location found:
+//
+//   1. A JSON file whose path is specified by the
+//      GOOGLE_APPLICATION_CREDENTIALS environment variable.
+//   2. A JSON file in a location known to the gcloud command-line tool.
+//      On Windows, this is %APPDATA%/gcloud/application_default_credentials.json.
+//      On other systems, $HOME/.config/gcloud/application_default_credentials.json.
+//   3. On Google App Engine standard first generation runtimes (<= Go 1.9) it uses
+//      the appengine.AccessToken function.
+//   4. On Google Compute Engine, Google App Engine standard second generation runtimes
+//      (>= Go 1.11), and Google App Engine flexible environment, it fetches
+//      credentials from the metadata server.
+//      (In this final case any provided scopes are ignored.)
+func FindDefaultCredentials(ctx context.Context, scopes ...string) (*Credentials, error) {
 	// First, try the environment variable.
 	const envVar = "GOOGLE_APPLICATION_CREDENTIALS"
 	if filename := os.Getenv(envVar); filename != "" {
@@ -59,15 +93,18 @@ func findDefaultCredentials(ctx context.Context, scopes []string) (*DefaultCrede
 		return nil, fmt.Errorf("google: error getting credentials using well-known file (%v): %v", filename, err)
 	}
 
-	// Third, if we're on Google App Engine use those credentials.
-	if appengineTokenFunc != nil && !appengineFlex {
+	// Third, if we're on a Google App Engine standard first generation runtime (<= Go 1.9)
+	// use those credentials. App Engine standard second generation runtimes (>= Go 1.11)
+	// and App Engine flexible use ComputeTokenSource and the metadata server.
+	if appengineTokenFunc != nil {
 		return &DefaultCredentials{
 			ProjectID:   appengineAppIDFunc(ctx),
 			TokenSource: AppEngineTokenSource(ctx, scopes...),
 		}, nil
 	}
 
-	// Fourth, if we're on Google Compute Engine use the metadata server.
+	// Fourth, if we're on Google Compute Engine, an App Engine standard second generation runtime,
+	// or App Engine flexible, use the metadata server.
 	if metadata.OnGCE() {
 		id, _ := metadata.ProjectID()
 		return &DefaultCredentials{
@@ -81,8 +118,11 @@ func findDefaultCredentials(ctx context.Context, scopes []string) (*DefaultCrede
 	return nil, fmt.Errorf("google: could not find default credentials. See %v for more information.", url)
 }
 
-// Common implementation for CredentialsFromJSON.
-func credentialsFromJSON(ctx context.Context, jsonData []byte, scopes []string) (*DefaultCredentials, error) {
+// CredentialsFromJSON obtains Google credentials from a JSON value. The JSON can
+// represent either a Google Developers Console client_credentials.json file (as in
+// ConfigFromJSON) or a Google Developers service account key file (as in
+// JWTConfigFromJSON).
+func CredentialsFromJSON(ctx context.Context, jsonData []byte, scopes ...string) (*Credentials, error) {
 	var f credentialsFile
 	if err := json.Unmarshal(jsonData, &f); err != nil {
 		return nil, err
diff --git a/vendor/golang.org/x/oauth2/google/doc_go19.go b/vendor/golang.org/x/oauth2/google/doc.go
similarity index 99%
rename from vendor/golang.org/x/oauth2/google/doc_go19.go
rename to vendor/golang.org/x/oauth2/google/doc.go
index 2a86325f..73be6290 100644
--- a/vendor/golang.org/x/oauth2/google/doc_go19.go
+++ b/vendor/golang.org/x/oauth2/google/doc.go
@@ -2,8 +2,6 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build go1.9
-
 // Package google provides support for making OAuth2 authorized and authenticated
 // HTTP requests to Google APIs. It supports the Web server flow, client-side
 // credentials, service accounts, Google Compute Engine service accounts, and Google
diff --git a/vendor/golang.org/x/oauth2/google/doc_not_go19.go b/vendor/golang.org/x/oauth2/google/doc_not_go19.go
deleted file mode 100644
index 5c3c6e14..00000000
--- a/vendor/golang.org/x/oauth2/google/doc_not_go19.go
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !go1.9
-
-// Package google provides support for making OAuth2 authorized and authenticated
-// HTTP requests to Google APIs. It supports the Web server flow, client-side
-// credentials, service accounts, Google Compute Engine service accounts, and Google
-// App Engine service accounts.
-//
-// A brief overview of the package follows. For more information, please read
-// https://developers.google.com/accounts/docs/OAuth2
-// and
-// https://developers.google.com/accounts/docs/application-default-credentials.
-//
-// OAuth2 Configs
-//
-// Two functions in this package return golang.org/x/oauth2.Config values from Google credential
-// data. Google supports two JSON formats for OAuth2 credentials: one is handled by ConfigFromJSON,
-// the other by JWTConfigFromJSON. The returned Config can be used to obtain a TokenSource or
-// create an http.Client.
-//
-//
-// Credentials
-//
-// The DefaultCredentials type represents Google Application Default Credentials, as
-// well as other forms of credential.
-//
-// Use FindDefaultCredentials to obtain Application Default Credentials.
-// FindDefaultCredentials looks in some well-known places for a credentials file, and
-// will call AppEngineTokenSource or ComputeTokenSource as needed.
-//
-// DefaultClient and DefaultTokenSource are convenience methods. They first call FindDefaultCredentials,
-// then use the credentials to construct an http.Client or an oauth2.TokenSource.
-//
-// Use CredentialsFromJSON to obtain credentials from either of the two JSON
-// formats described in OAuth2 Configs, above. (The DefaultCredentials returned may
-// not be "Application Default Credentials".) The TokenSource in the returned value
-// is the same as the one obtained from the oauth2.Config returned from
-// ConfigFromJSON or JWTConfigFromJSON, but the DefaultCredentials may contain
-// additional information that is useful is some circumstances.
-package google // import "golang.org/x/oauth2/google"
diff --git a/vendor/golang.org/x/oauth2/google/example_test.go b/vendor/golang.org/x/oauth2/google/example_test.go
index 643f5071..d9c5a104 100644
--- a/vendor/golang.org/x/oauth2/google/example_test.go
+++ b/vendor/golang.org/x/oauth2/google/example_test.go
@@ -5,12 +5,12 @@
 package google_test
 
 import (
+	"context"
 	"fmt"
 	"io/ioutil"
 	"log"
 	"net/http"
 
-	"golang.org/x/net/context"
 	"golang.org/x/oauth2"
 	"golang.org/x/oauth2/google"
 	"golang.org/x/oauth2/jwt"
diff --git a/vendor/golang.org/x/oauth2/google/go19.go b/vendor/golang.org/x/oauth2/google/go19.go
deleted file mode 100644
index 4d0318b1..00000000
--- a/vendor/golang.org/x/oauth2/google/go19.go
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build go1.9
-
-package google
-
-import (
-	"golang.org/x/net/context"
-	"golang.org/x/oauth2"
-)
-
-// Credentials holds Google credentials, including "Application Default Credentials".
-// For more details, see:
-// https://developers.google.com/accounts/docs/application-default-credentials
-type Credentials struct {
-	ProjectID   string // may be empty
-	TokenSource oauth2.TokenSource
-
-	// JSON contains the raw bytes from a JSON credentials file.
-	// This field may be nil if authentication is provided by the
-	// environment and not with a credentials file, e.g. when code is
-	// running on Google Cloud Platform.
-	JSON []byte
-}
-
-// DefaultCredentials is the old name of Credentials.
-//
-// Deprecated: use Credentials instead.
-type DefaultCredentials = Credentials
-
-// FindDefaultCredentials searches for "Application Default Credentials".
-//
-// It looks for credentials in the following places,
-// preferring the first location found:
-//
-//   1. A JSON file whose path is specified by the
-//      GOOGLE_APPLICATION_CREDENTIALS environment variable.
-//   2. A JSON file in a location known to the gcloud command-line tool.
-//      On Windows, this is %APPDATA%/gcloud/application_default_credentials.json.
-//      On other systems, $HOME/.config/gcloud/application_default_credentials.json.
-//   3. On Google App Engine it uses the appengine.AccessToken function.
-//   4. On Google Compute Engine and Google App Engine Managed VMs, it fetches
-//      credentials from the metadata server.
-//      (In this final case any provided scopes are ignored.)
-func FindDefaultCredentials(ctx context.Context, scopes ...string) (*Credentials, error) {
-	return findDefaultCredentials(ctx, scopes)
-}
-
-// CredentialsFromJSON obtains Google credentials from a JSON value. The JSON can
-// represent either a Google Developers Console client_credentials.json file (as in
-// ConfigFromJSON) or a Google Developers service account key file (as in
-// JWTConfigFromJSON).
-func CredentialsFromJSON(ctx context.Context, jsonData []byte, scopes ...string) (*Credentials, error) {
-	return credentialsFromJSON(ctx, jsonData, scopes)
-}
diff --git a/vendor/golang.org/x/oauth2/google/google.go b/vendor/golang.org/x/oauth2/google/google.go
index f7481fbc..ca7d208d 100644
--- a/vendor/golang.org/x/oauth2/google/google.go
+++ b/vendor/golang.org/x/oauth2/google/google.go
@@ -5,6 +5,7 @@
 package google
 
 import (
+	"context"
 	"encoding/json"
 	"errors"
 	"fmt"
@@ -12,7 +13,6 @@ import (
 	"time"
 
 	"cloud.google.com/go/compute/metadata"
-	"golang.org/x/net/context"
 	"golang.org/x/oauth2"
 	"golang.org/x/oauth2/jwt"
 )
diff --git a/vendor/golang.org/x/oauth2/google/not_go19.go b/vendor/golang.org/x/oauth2/google/not_go19.go
deleted file mode 100644
index 544e4062..00000000
--- a/vendor/golang.org/x/oauth2/google/not_go19.go
+++ /dev/null
@@ -1,54 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !go1.9
-
-package google
-
-import (
-	"golang.org/x/net/context"
-	"golang.org/x/oauth2"
-)
-
-// DefaultCredentials holds Google credentials, including "Application Default Credentials".
-// For more details, see:
-// https://developers.google.com/accounts/docs/application-default-credentials
-type DefaultCredentials struct {
-	ProjectID   string // may be empty
-	TokenSource oauth2.TokenSource
-
-	// JSON contains the raw bytes from a JSON credentials file.
-	// This field may be nil if authentication is provided by the
-	// environment and not with a credentials file, e.g. when code is
-	// running on Google Cloud Platform.
-	JSON []byte
-}
-
-// FindDefaultCredentials searches for "Application Default Credentials".
-//
-// It looks for credentials in the following places,
-// preferring the first location found:
-//
-//   1. A JSON file whose path is specified by the
-//      GOOGLE_APPLICATION_CREDENTIALS environment variable.
-//   2. A JSON file in a location known to the gcloud command-line tool.
-//      On Windows, this is %APPDATA%/gcloud/application_default_credentials.json.
-//      On other systems, $HOME/.config/gcloud/application_default_credentials.json.
-//   3. On Google App Engine it uses the appengine.AccessToken function.
-//   4. On Google Compute Engine and Google App Engine Managed VMs, it fetches
-//      credentials from the metadata server.
-//      (In this final case any provided scopes are ignored.)
-func FindDefaultCredentials(ctx context.Context, scopes ...string) (*DefaultCredentials, error) {
-	return findDefaultCredentials(ctx, scopes)
-}
-
-// CredentialsFromJSON obtains Google credentials from a JSON value. The JSON can
-// represent either a Google Developers Console client_credentials.json file (as in
-// ConfigFromJSON) or a Google Developers service account key file (as in
-// JWTConfigFromJSON).
-//
-// Note: despite the name, the returned credentials may not be Application Default Credentials.
-func CredentialsFromJSON(ctx context.Context, jsonData []byte, scopes ...string) (*DefaultCredentials, error) {
-	return credentialsFromJSON(ctx, jsonData, scopes)
-}
diff --git a/vendor/golang.org/x/oauth2/google/sdk.go b/vendor/golang.org/x/oauth2/google/sdk.go
index b9660cad..456224bc 100644
--- a/vendor/golang.org/x/oauth2/google/sdk.go
+++ b/vendor/golang.org/x/oauth2/google/sdk.go
@@ -6,6 +6,7 @@ package google
 
 import (
 	"bufio"
+	"context"
 	"encoding/json"
 	"errors"
 	"fmt"
@@ -18,7 +19,6 @@ import (
 	"strings"
 	"time"
 
-	"golang.org/x/net/context"
 	"golang.org/x/oauth2"
 )
 
diff --git a/vendor/golang.org/x/oauth2/internal/oauth2.go b/vendor/golang.org/x/oauth2/internal/oauth2.go
index fc63fcab..c0ab196c 100644
--- a/vendor/golang.org/x/oauth2/internal/oauth2.go
+++ b/vendor/golang.org/x/oauth2/internal/oauth2.go
@@ -26,7 +26,7 @@ func ParseKey(key []byte) (*rsa.PrivateKey, error) {
 	if err != nil {
 		parsedKey, err = x509.ParsePKCS1PrivateKey(key)
 		if err != nil {
-			return nil, fmt.Errorf("private key should be a PEM or plain PKSC1 or PKCS8; parse error: %v", err)
+			return nil, fmt.Errorf("private key should be a PEM or plain PKCS1 or PKCS8; parse error: %v", err)
 		}
 	}
 	parsed, ok := parsedKey.(*rsa.PrivateKey)
diff --git a/vendor/golang.org/x/oauth2/internal/token.go b/vendor/golang.org/x/oauth2/internal/token.go
index 53259a41..5ab17b9a 100644
--- a/vendor/golang.org/x/oauth2/internal/token.go
+++ b/vendor/golang.org/x/oauth2/internal/token.go
@@ -5,6 +5,7 @@
 package internal
 
 import (
+	"context"
 	"encoding/json"
 	"errors"
 	"fmt"
@@ -17,7 +18,6 @@ import (
 	"strings"
 	"time"
 
-	"golang.org/x/net/context"
 	"golang.org/x/net/context/ctxhttp"
 )
 
diff --git a/vendor/golang.org/x/oauth2/internal/token_test.go b/vendor/golang.org/x/oauth2/internal/token_test.go
index 7b52e511..d1da8bb0 100644
--- a/vendor/golang.org/x/oauth2/internal/token_test.go
+++ b/vendor/golang.org/x/oauth2/internal/token_test.go
@@ -5,14 +5,13 @@
 package internal
 
 import (
+	"context"
 	"fmt"
 	"io"
 	"net/http"
 	"net/http/httptest"
 	"net/url"
 	"testing"
-
-	"golang.org/x/net/context"
 )
 
 func TestRegisterBrokenAuthHeaderProvider(t *testing.T) {
diff --git a/vendor/golang.org/x/oauth2/internal/transport.go b/vendor/golang.org/x/oauth2/internal/transport.go
index d16f9ae1..572074a6 100644
--- a/vendor/golang.org/x/oauth2/internal/transport.go
+++ b/vendor/golang.org/x/oauth2/internal/transport.go
@@ -5,9 +5,8 @@
 package internal
 
 import (
+	"context"
 	"net/http"
-
-	"golang.org/x/net/context"
 )
 
 // HTTPClient is the context key to use with golang.org/x/net/context's
diff --git a/vendor/golang.org/x/oauth2/jwt/jwt.go b/vendor/golang.org/x/oauth2/jwt/jwt.go
index e08f3159..0783a94c 100644
--- a/vendor/golang.org/x/oauth2/jwt/jwt.go
+++ b/vendor/golang.org/x/oauth2/jwt/jwt.go
@@ -9,6 +9,7 @@
 package jwt
 
 import (
+	"context"
 	"encoding/json"
 	"fmt"
 	"io"
@@ -18,7 +19,6 @@ import (
 	"strings"
 	"time"
 
-	"golang.org/x/net/context"
 	"golang.org/x/oauth2"
 	"golang.org/x/oauth2/internal"
 	"golang.org/x/oauth2/jws"
diff --git a/vendor/golang.org/x/oauth2/oauth2.go b/vendor/golang.org/x/oauth2/oauth2.go
index 16775d08..1e8e1b74 100644
--- a/vendor/golang.org/x/oauth2/oauth2.go
+++ b/vendor/golang.org/x/oauth2/oauth2.go
@@ -10,13 +10,13 @@ package oauth2 // import "golang.org/x/oauth2"
 
 import (
 	"bytes"
+	"context"
 	"errors"
 	"net/http"
 	"net/url"
 	"strings"
 	"sync"
 
-	"golang.org/x/net/context"
 	"golang.org/x/oauth2/internal"
 )
 
@@ -164,8 +164,7 @@ func (c *Config) AuthCodeURL(state string, opts ...AuthCodeOption) string {
 // and when other authorization grant types are not available."
 // See https://tools.ietf.org/html/rfc6749#section-4.3 for more info.
 //
-// The HTTP client to use is derived from the context.
-// If nil, http.DefaultClient is used.
+// The provided context optionally controls which HTTP client is used. See the HTTPClient variable.
 func (c *Config) PasswordCredentialsToken(ctx context.Context, username, password string) (*Token, error) {
 	v := url.Values{
 		"grant_type": {"password"},
@@ -183,8 +182,7 @@ func (c *Config) PasswordCredentialsToken(ctx context.Context, username, passwor
 // It is used after a resource provider redirects the user back
 // to the Redirect URI (the URL obtained from AuthCodeURL).
 //
-// The HTTP client to use is derived from the context.
-// If a client is not provided via the context, http.DefaultClient is used.
+// The provided context optionally controls which HTTP client is used. See the HTTPClient variable.
 //
 // The code will be in the *http.Request.FormValue("code"). Before
 // calling Exchange, be sure to validate FormValue("state").
diff --git a/vendor/golang.org/x/oauth2/oauth2_test.go b/vendor/golang.org/x/oauth2/oauth2_test.go
index ef12ebc5..19aaf6b2 100644
--- a/vendor/golang.org/x/oauth2/oauth2_test.go
+++ b/vendor/golang.org/x/oauth2/oauth2_test.go
@@ -5,6 +5,7 @@
 package oauth2
 
 import (
+	"context"
 	"errors"
 	"fmt"
 	"io/ioutil"
@@ -13,8 +14,6 @@ import (
 	"net/url"
 	"testing"
 	"time"
-
-	"golang.org/x/net/context"
 )
 
 type mockTransport struct {
diff --git a/vendor/golang.org/x/oauth2/token.go b/vendor/golang.org/x/oauth2/token.go
index 34db8cdc..9be1ae53 100644
--- a/vendor/golang.org/x/oauth2/token.go
+++ b/vendor/golang.org/x/oauth2/token.go
@@ -5,6 +5,7 @@
 package oauth2
 
 import (
+	"context"
 	"fmt"
 	"net/http"
 	"net/url"
@@ -12,7 +13,6 @@ import (
 	"strings"
 	"time"
 
-	"golang.org/x/net/context"
 	"golang.org/x/oauth2/internal"
 )
 
diff --git a/vendor/golang.org/x/sys/unix/asm_linux_ppc64x.s b/vendor/golang.org/x/sys/unix/asm_linux_ppc64x.s
index 649e5871..88f71255 100644
--- a/vendor/golang.org/x/sys/unix/asm_linux_ppc64x.s
+++ b/vendor/golang.org/x/sys/unix/asm_linux_ppc64x.s
@@ -15,12 +15,6 @@
 // Just jump to package syscall's implementation for all these functions.
 // The runtime may know about them.
 
-TEXT Syscall(SB),NOSPLIT,$0-56
-	BR	syscallSyscall(SB)
-
-TEXT Syscall6(SB),NOSPLIT,$0-80
-	BR	syscallSyscall6(SB)
-
 TEXT SyscallNoError(SB),NOSPLIT,$0-48
 	BL	runtimeentersyscall(SB)
 	MOVD	a1+8(FP), R3
@@ -36,12 +30,6 @@ TEXT SyscallNoError(SB),NOSPLIT,$0-48
 	BL	runtimeexitsyscall(SB)
 	RET
 
-TEXT RawSyscall(SB),NOSPLIT,$0-56
-	BR	syscallRawSyscall(SB)
-
-TEXT RawSyscall6(SB),NOSPLIT,$0-80
-	BR	syscallRawSyscall6(SB)
-
 TEXT RawSyscallNoError(SB),NOSPLIT,$0-48
 	MOVD	a1+8(FP), R3
 	MOVD	a2+16(FP), R4
diff --git a/vendor/golang.org/x/sys/unix/linux/types.go b/vendor/golang.org/x/sys/unix/linux/types.go
index dca55a5a..273bd469 100644
--- a/vendor/golang.org/x/sys/unix/linux/types.go
+++ b/vendor/golang.org/x/sys/unix/linux/types.go
@@ -48,6 +48,7 @@ package unix
 #include <sys/wait.h>
 #include <linux/filter.h>
 #include <linux/icmpv6.h>
+#include <linux/if_pppox.h>
 #include <linux/keyctl.h>
 #include <linux/netfilter/nf_tables.h>
 #include <linux/netfilter/nfnetlink.h>
@@ -168,6 +169,7 @@ union sockaddr_all {
 	struct sockaddr_un s4;
 	struct sockaddr_ll s5;
 	struct sockaddr_nl s6;
+	struct sockaddr_pppox s7;
 };
 
 struct sockaddr_any {
@@ -432,6 +434,8 @@ type RawSockaddrVM C.struct_sockaddr_vm
 
 type RawSockaddrXDP C.struct_sockaddr_xdp
 
+type RawSockaddrPPPoX [C.sizeof_struct_sockaddr_pppox]byte
+
 type RawSockaddr C.struct_sockaddr
 
 type RawSockaddrAny C.struct_sockaddr_any
@@ -480,6 +484,7 @@ const (
 	SizeofSockaddrALG       = C.sizeof_struct_sockaddr_alg
 	SizeofSockaddrVM        = C.sizeof_struct_sockaddr_vm
 	SizeofSockaddrXDP       = C.sizeof_struct_sockaddr_xdp
+	SizeofSockaddrPPPoX     = C.sizeof_struct_sockaddr_pppox
 	SizeofLinger            = C.sizeof_struct_linger
 	SizeofIovec             = C.sizeof_struct_iovec
 	SizeofIPMreq            = C.sizeof_struct_ip_mreq
diff --git a/vendor/golang.org/x/sys/unix/mkerrors.sh b/vendor/golang.org/x/sys/unix/mkerrors.sh
index 7943853f..aa860fa2 100755
--- a/vendor/golang.org/x/sys/unix/mkerrors.sh
+++ b/vendor/golang.org/x/sys/unix/mkerrors.sh
@@ -101,7 +101,7 @@ includes_DragonFly='
 '
 
 includes_FreeBSD='
-#include <sys/capability.h>
+#include <sys/capsicum.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/event.h>
@@ -197,6 +197,7 @@ struct ltchars {
 #include <linux/keyctl.h>
 #include <linux/magic.h>
 #include <linux/memfd.h>
+#include <linux/module.h>
 #include <linux/netfilter/nfnetlink.h>
 #include <linux/netlink.h>
 #include <linux/net_namespace.h>
@@ -449,6 +450,7 @@ ccflags="$@"
 		$2 ~ /^KEXEC_/ ||
 		$2 ~ /^LINUX_REBOOT_CMD_/ ||
 		$2 ~ /^LINUX_REBOOT_MAGIC[12]$/ ||
+		$2 ~ /^MODULE_INIT_/ ||
 		$2 !~ "NLA_TYPE_MASK" &&
 		$2 ~ /^(NETLINK|NLM|NLMSG|NLA|IFA|IFAN|RT|RTC|RTCF|RTN|RTPROT|RTNH|ARPHRD|ETH_P|NETNSA)_/ ||
 		$2 ~ /^SIOC/ ||
diff --git a/vendor/golang.org/x/sys/unix/mkpost.go b/vendor/golang.org/x/sys/unix/mkpost.go
index 7e5c22c4..6d263cf1 100644
--- a/vendor/golang.org/x/sys/unix/mkpost.go
+++ b/vendor/golang.org/x/sys/unix/mkpost.go
@@ -46,6 +46,10 @@ func main() {
 	valRegex := regexp.MustCompile(`type (Fsid|Sigset_t) struct {(\s+)X__val(\s+\S+\s+)}`)
 	b = valRegex.ReplaceAll(b, []byte("type $1 struct {${2}Val$3}"))
 
+	// Intentionally export __fds_bits field in FdSet
+	fdSetRegex := regexp.MustCompile(`type (FdSet) struct {(\s+)X__fds_bits(\s+\S+\s+)}`)
+	b = fdSetRegex.ReplaceAll(b, []byte("type $1 struct {${2}Bits$3}"))
+
 	// If we have empty Ptrace structs, we should delete them. Only s390x emits
 	// nonempty Ptrace structs.
 	ptraceRexexp := regexp.MustCompile(`type Ptrace((Psw|Fpregs|Per) struct {\s*})`)
@@ -65,6 +69,10 @@ func main() {
 	convertUtsnameRegex := regexp.MustCompile(`((Sys|Node|Domain)name|Release|Version|Machine)(\s+)\[(\d+)\]u?int8`)
 	b = convertUtsnameRegex.ReplaceAll(b, []byte("$1$3[$4]byte"))
 
+	// Convert [1024]int8 to [1024]byte in Ptmget members
+	convertPtmget := regexp.MustCompile(`([SC]n)(\s+)\[(\d+)\]u?int8`)
+	b = convertPtmget.ReplaceAll(b, []byte("$1[$3]byte"))
+
 	// Remove spare fields (e.g. in Statx_t)
 	spareFieldsRegex := regexp.MustCompile(`X__spare\S*`)
 	b = spareFieldsRegex.ReplaceAll(b, []byte("_"))
diff --git a/vendor/golang.org/x/sys/unix/openbsd_pledge.go b/vendor/golang.org/x/sys/unix/openbsd_pledge.go
index 8a9c8799..230a36d2 100644
--- a/vendor/golang.org/x/sys/unix/openbsd_pledge.go
+++ b/vendor/golang.org/x/sys/unix/openbsd_pledge.go
@@ -30,15 +30,9 @@ func Pledge(promises, execpromises string) error {
 		return err
 	}
 
-	// If OpenBSD <= 5.9, pledge is not available.
-	if (maj == 5 && min != 9) || maj < 5 {
-		return fmt.Errorf("pledge syscall is not available on OpenBSD %d.%d", maj, min)
-	}
-
-	// If OpenBSD <= 6.2 and execpromises is not empty
-	// return an error - execpromises is not available before 6.3
-	if (maj < 6 || (maj == 6 && min <= 2)) && execpromises != "" {
-		return fmt.Errorf("cannot use execpromises on OpenBSD %d.%d", maj, min)
+	err = pledgeAvailable(maj, min, execpromises)
+	if err != nil {
+		return err
 	}
 
 	pptr, err := syscall.BytePtrFromString(promises)
@@ -67,6 +61,70 @@ func Pledge(promises, execpromises string) error {
 	return nil
 }
 
+// PledgePromises implements the pledge syscall.
+//
+// This changes the promises and leaves the execpromises untouched.
+//
+// For more information see pledge(2).
+func PledgePromises(promises string) error {
+	maj, min, err := majmin()
+	if err != nil {
+		return err
+	}
+
+	err = pledgeAvailable(maj, min, "")
+	if err != nil {
+		return err
+	}
+
+	// This variable holds the execpromises and is always nil.
+	var expr unsafe.Pointer
+
+	pptr, err := syscall.BytePtrFromString(promises)
+	if err != nil {
+		return err
+	}
+
+	_, _, e := syscall.Syscall(SYS_PLEDGE, uintptr(unsafe.Pointer(pptr)), uintptr(expr), 0)
+	if e != 0 {
+		return e
+	}
+
+	return nil
+}
+
+// PledgeExecpromises implements the pledge syscall.
+//
+// This changes the execpromises and leaves the promises untouched.
+//
+// For more information see pledge(2).
+func PledgeExecpromises(execpromises string) error {
+	maj, min, err := majmin()
+	if err != nil {
+		return err
+	}
+
+	err = pledgeAvailable(maj, min, execpromises)
+	if err != nil {
+		return err
+	}
+
+	// This variable holds the promises and is always nil.
+	var pptr unsafe.Pointer
+
+	exptr, err := syscall.BytePtrFromString(execpromises)
+	if err != nil {
+		return err
+	}
+
+	_, _, e := syscall.Syscall(SYS_PLEDGE, uintptr(pptr), uintptr(unsafe.Pointer(exptr)), 0)
+	if e != 0 {
+		return e
+	}
+
+	return nil
+}
+
 // majmin returns major and minor version number for an OpenBSD system.
 func majmin() (major int, minor int, err error) {
 	var v Utsname
@@ -89,3 +147,20 @@ func majmin() (major int, minor int, err error) {
 
 	return
 }
+
+// pledgeAvailable checks for availability of the pledge(2) syscall
+// based on the running OpenBSD version.
+func pledgeAvailable(maj, min int, execpromises string) error {
+	// If OpenBSD <= 5.9, pledge is not available.
+	if (maj == 5 && min != 9) || maj < 5 {
+		return fmt.Errorf("pledge syscall is not available on OpenBSD %d.%d", maj, min)
+	}
+
+	// If OpenBSD <= 6.2 and execpromises is not empty,
+	// return an error - execpromises is not available before 6.3
+	if (maj < 6 || (maj == 6 && min <= 2)) && execpromises != "" {
+		return fmt.Errorf("cannot use execpromises on OpenBSD %d.%d", maj, min)
+	}
+
+	return nil
+}
diff --git a/vendor/golang.org/x/sys/unix/openbsd_unveil.go b/vendor/golang.org/x/sys/unix/openbsd_unveil.go
new file mode 100644
index 00000000..aebc2dc5
--- /dev/null
+++ b/vendor/golang.org/x/sys/unix/openbsd_unveil.go
@@ -0,0 +1,44 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build openbsd
+
+package unix
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+// Unveil implements the unveil syscall.
+// For more information see unveil(2).
+// Note that the special case of blocking further
+// unveil calls is handled by UnveilBlock.
+func Unveil(path string, flags string) error {
+	pathPtr, err := syscall.BytePtrFromString(path)
+	if err != nil {
+		return err
+	}
+	flagsPtr, err := syscall.BytePtrFromString(flags)
+	if err != nil {
+		return err
+	}
+	_, _, e := syscall.Syscall(SYS_UNVEIL, uintptr(unsafe.Pointer(pathPtr)), uintptr(unsafe.Pointer(flagsPtr)), 0)
+	if e != 0 {
+		return e
+	}
+	return nil
+}
+
+// UnveilBlock blocks future unveil calls.
+// For more information see unveil(2).
+func UnveilBlock() error {
+	// Both pointers must be nil.
+	var pathUnsafe, flagsUnsafe unsafe.Pointer
+	_, _, e := syscall.Syscall(SYS_UNVEIL, uintptr(pathUnsafe), uintptr(flagsUnsafe), 0)
+	if e != 0 {
+		return e
+	}
+	return nil
+}
diff --git a/vendor/golang.org/x/sys/unix/syscall_darwin_test.go b/vendor/golang.org/x/sys/unix/syscall_darwin_test.go
index 65691d5c..7faa295f 100644
--- a/vendor/golang.org/x/sys/unix/syscall_darwin_test.go
+++ b/vendor/golang.org/x/sys/unix/syscall_darwin_test.go
@@ -4,6 +4,13 @@
 
 package unix_test
 
+import (
+	"os"
+	"testing"
+
+	"golang.org/x/sys/unix"
+)
+
 // stringsFromByteSlice converts a sequence of attributes to a []string.
 // On Darwin, each entry is a NULL-terminated string.
 func stringsFromByteSlice(buf []byte) []string {
@@ -17,3 +24,40 @@ func stringsFromByteSlice(buf []byte) []string {
 	}
 	return result
 }
+
+func TestUtimesNanoAt(t *testing.T) {
+	defer chtmpdir(t)()
+
+	symlink := "symlink1"
+	os.Remove(symlink)
+	err := os.Symlink("nonexisting", symlink)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	ts := []unix.Timespec{
+		{Sec: 1111, Nsec: 2222},
+		{Sec: 3333, Nsec: 4444},
+	}
+	err = unix.UtimesNanoAt(unix.AT_FDCWD, symlink, ts, unix.AT_SYMLINK_NOFOLLOW)
+	if err != nil {
+		t.Fatalf("UtimesNanoAt: %v", err)
+	}
+
+	var st unix.Stat_t
+	err = unix.Lstat(symlink, &st)
+	if err != nil {
+		t.Fatalf("Lstat: %v", err)
+	}
+
+	// Only check Mtimespec, Atimespec might not be supported by the underlying filesystem
+	expected := ts[1]
+	if st.Mtimespec.Nsec == 0 {
+		// Some filesystems only support 1-second time stamp resolution
+		// and will always set Nsec to 0.
+		expected.Nsec = 0
+	}
+	if st.Mtimespec != expected {
+		t.Errorf("UtimesNanoAt: wrong mtime: got %v, expected %v", st.Mtimespec, expected)
+	}
+}
diff --git a/vendor/golang.org/x/sys/unix/syscall_dragonfly.go b/vendor/golang.org/x/sys/unix/syscall_dragonfly.go
index 79d125b3..75651057 100644
--- a/vendor/golang.org/x/sys/unix/syscall_dragonfly.go
+++ b/vendor/golang.org/x/sys/unix/syscall_dragonfly.go
@@ -248,11 +248,13 @@ func Uname(uname *Utsname) error {
 //sys	Dup(fd int) (nfd int, err error)
 //sys	Dup2(from int, to int) (err error)
 //sys	Exit(code int)
+//sys	Faccessat(dirfd int, path string, mode uint32, flags int) (err error)
 //sys	Fchdir(fd int) (err error)
 //sys	Fchflags(fd int, flags int) (err error)
 //sys	Fchmod(fd int, mode uint32) (err error)
 //sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
 //sys	Fchown(fd int, uid int, gid int) (err error)
+//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
 //sys	Flock(fd int, how int) (err error)
 //sys	Fpathconf(fd int, name int) (val int, err error)
 //sys	Fstat(fd int, stat *Stat_t) (err error)
@@ -280,13 +282,17 @@ func Uname(uname *Utsname) error {
 //sys	Kqueue() (fd int, err error)
 //sys	Lchown(path string, uid int, gid int) (err error)
 //sys	Link(path string, link string) (err error)
+//sys	Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)
 //sys	Listen(s int, backlog int) (err error)
 //sys	Lstat(path string, stat *Stat_t) (err error)
 //sys	Mkdir(path string, mode uint32) (err error)
+//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
 //sys	Mkfifo(path string, mode uint32) (err error)
 //sys	Mknod(path string, mode uint32, dev int) (err error)
+//sys	Mknodat(fd int, path string, mode uint32, dev int) (err error)
 //sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
 //sys	Open(path string, mode int, perm uint32) (fd int, err error)
+//sys	Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)
 //sys	Pathconf(path string, name int) (val int, err error)
 //sys	read(fd int, p []byte) (n int, err error)
 //sys	Readlink(path string, buf []byte) (n int, err error)
@@ -312,11 +318,13 @@ func Uname(uname *Utsname) error {
 //sys	Stat(path string, stat *Stat_t) (err error)
 //sys	Statfs(path string, stat *Statfs_t) (err error)
 //sys	Symlink(path string, link string) (err error)
+//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
 //sys	Sync() (err error)
 //sys	Truncate(path string, length int64) (err error)
 //sys	Umask(newmask int) (oldmask int)
 //sys	Undelete(path string) (err error)
 //sys	Unlink(path string) (err error)
+//sys	Unlinkat(dirfd int, path string, flags int) (err error)
 //sys	Unmount(path string, flags int) (err error)
 //sys	write(fd int, p []byte) (n int, err error)
 //sys   mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
diff --git a/vendor/golang.org/x/sys/unix/syscall_linux.go b/vendor/golang.org/x/sys/unix/syscall_linux.go
index bfa20a97..96ff70dc 100644
--- a/vendor/golang.org/x/sys/unix/syscall_linux.go
+++ b/vendor/golang.org/x/sys/unix/syscall_linux.go
@@ -12,6 +12,8 @@
 package unix
 
 import (
+	"encoding/binary"
+	"net"
 	"syscall"
 	"unsafe"
 )
@@ -710,6 +712,51 @@ func (sa *SockaddrXDP) sockaddr() (unsafe.Pointer, _Socklen, error) {
 	return unsafe.Pointer(&sa.raw), SizeofSockaddrXDP, nil
 }
 
+// This constant mirrors the #define of PX_PROTO_OE in
+// linux/if_pppox.h. We're defining this by hand here instead of
+// autogenerating through mkerrors.sh because including
+// linux/if_pppox.h causes some declaration conflicts with other
+// includes (linux/if_pppox.h includes linux/in.h, which conflicts
+// with netinet/in.h). Given that we only need a single zero constant
+// out of that file, it's cleaner to just define it by hand here.
+const px_proto_oe = 0
+
+type SockaddrPPPoE struct {
+	SID    uint16
+	Remote net.HardwareAddr
+	Dev    string
+	raw    RawSockaddrPPPoX
+}
+
+func (sa *SockaddrPPPoE) sockaddr() (unsafe.Pointer, _Socklen, error) {
+	if len(sa.Remote) != 6 {
+		return nil, 0, EINVAL
+	}
+	if len(sa.Dev) > IFNAMSIZ-1 {
+		return nil, 0, EINVAL
+	}
+
+	*(*uint16)(unsafe.Pointer(&sa.raw[0])) = AF_PPPOX
+	// This next field is in host-endian byte order. We can't use the
+	// same unsafe pointer cast as above, because this value is not
+	// 32-bit aligned and some architectures don't allow unaligned
+	// access.
+	//
+	// However, the value of px_proto_oe is 0, so we can use
+	// encoding/binary helpers to write the bytes without worrying
+	// about the ordering.
+	binary.BigEndian.PutUint32(sa.raw[2:6], px_proto_oe)
+	// This field is deliberately big-endian, unlike the previous
+	// one. The kernel expects SID to be in network byte order.
+	binary.BigEndian.PutUint16(sa.raw[6:8], sa.SID)
+	copy(sa.raw[8:14], sa.Remote)
+	for i := 14; i < 14+IFNAMSIZ; i++ {
+		sa.raw[i] = 0
+	}
+	copy(sa.raw[14:], sa.Dev)
+	return unsafe.Pointer(&sa.raw), SizeofSockaddrPPPoX, nil
+}
+
 func anyToSockaddr(fd int, rsa *RawSockaddrAny) (Sockaddr, error) {
 	switch rsa.Addr.Family {
 	case AF_NETLINK:
@@ -820,6 +867,22 @@ func anyToSockaddr(fd int, rsa *RawSockaddrAny) (Sockaddr, error) {
 			SharedUmemFD: pp.Shared_umem_fd,
 		}
 		return sa, nil
+	case AF_PPPOX:
+		pp := (*RawSockaddrPPPoX)(unsafe.Pointer(rsa))
+		if binary.BigEndian.Uint32(pp[2:6]) != px_proto_oe {
+			return nil, EINVAL
+		}
+		sa := &SockaddrPPPoE{
+			SID:    binary.BigEndian.Uint16(pp[6:8]),
+			Remote: net.HardwareAddr(pp[8:14]),
+		}
+		for i := 14; i < 14+IFNAMSIZ; i++ {
+			if pp[i] == 0 {
+				sa.Dev = string(pp[14:i])
+				break
+			}
+		}
+		return sa, nil
 	}
 	return nil, EAFNOSUPPORT
 }
@@ -1304,6 +1367,7 @@ func Mount(source string, target string, fstype string, flags uintptr, data stri
 //sys	ClockGettime(clockid int32, time *Timespec) (err error)
 //sys	Close(fd int) (err error)
 //sys	CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)
+//sys	DeleteModule(name string, flags int) (err error)
 //sys	Dup(oldfd int) (fd int, err error)
 //sys	Dup3(oldfd int, newfd int, flags int) (err error)
 //sysnb	EpollCreate1(flag int) (fd int, err error)
@@ -1317,6 +1381,7 @@ func Mount(source string, target string, fstype string, flags uintptr, data stri
 //sys	fcntl(fd int, cmd int, arg int) (val int, err error)
 //sys	Fdatasync(fd int) (err error)
 //sys	Fgetxattr(fd int, attr string, dest []byte) (sz int, err error)
+//sys	FinitModule(fd int, params string, flags int) (err error)
 //sys	Flistxattr(fd int, dest []byte) (sz int, err error)
 //sys	Flock(fd int, how int) (err error)
 //sys	Fremovexattr(fd int, attr string) (err error)
@@ -1338,6 +1403,7 @@ func Getpgrp() (pid int) {
 //sysnb	Getsid(pid int) (sid int, err error)
 //sysnb	Gettid() (tid int)
 //sys	Getxattr(path string, attr string, dest []byte) (sz int, err error)
+//sys	InitModule(moduleImage []byte, params string) (err error)
 //sys	InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)
 //sysnb	InotifyInit1(flags int) (fd int, err error)
 //sysnb	InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)
@@ -1527,8 +1593,6 @@ func Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {
 // ClockNanosleep
 // ClockSettime
 // Clone
-// CreateModule
-// DeleteModule
 // EpollCtlOld
 // EpollPwait
 // EpollWaitOld
@@ -1572,7 +1636,6 @@ func Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {
 // Pselect6
 // Ptrace
 // Putpmsg
-// QueryModule
 // Quotactl
 // Readahead
 // Readv
diff --git a/vendor/golang.org/x/sys/unix/syscall_netbsd.go b/vendor/golang.org/x/sys/unix/syscall_netbsd.go
index 206ce2af..059327a3 100644
--- a/vendor/golang.org/x/sys/unix/syscall_netbsd.go
+++ b/vendor/golang.org/x/sys/unix/syscall_netbsd.go
@@ -13,6 +13,7 @@
 package unix
 
 import (
+	"runtime"
 	"syscall"
 	"unsafe"
 )
@@ -190,6 +191,13 @@ func IoctlGetTermios(fd int, req uint) (*Termios, error) {
 	return &value, err
 }
 
+func IoctlGetPtmget(fd int, req uint) (*Ptmget, error) {
+	var value Ptmget
+	err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))
+	runtime.KeepAlive(value)
+	return &value, err
+}
+
 func Uname(uname *Utsname) error {
 	mib := []_C_int{CTL_KERN, KERN_OSTYPE}
 	n := unsafe.Sizeof(uname.Sysname)
@@ -269,6 +277,7 @@ func Uname(uname *Utsname) error {
 //sys	Fchmod(fd int, mode uint32) (err error)
 //sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
 //sys	Fchown(fd int, uid int, gid int) (err error)
+//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
 //sys	Flock(fd int, how int) (err error)
 //sys	Fpathconf(fd int, name int) (val int, err error)
 //sys	Fstat(fd int, stat *Stat_t) (err error)
@@ -293,19 +302,26 @@ func Uname(uname *Utsname) error {
 //sys	Kqueue() (fd int, err error)
 //sys	Lchown(path string, uid int, gid int) (err error)
 //sys	Link(path string, link string) (err error)
+//sys	Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)
 //sys	Listen(s int, backlog int) (err error)
 //sys	Lstat(path string, stat *Stat_t) (err error)
 //sys	Mkdir(path string, mode uint32) (err error)
+//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
 //sys	Mkfifo(path string, mode uint32) (err error)
+//sys	Mkfifoat(dirfd int, path string, mode uint32) (err error)
 //sys	Mknod(path string, mode uint32, dev int) (err error)
+//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
 //sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
 //sys	Open(path string, mode int, perm uint32) (fd int, err error)
+//sys	Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)
 //sys	Pathconf(path string, name int) (val int, err error)
 //sys	Pread(fd int, p []byte, offset int64) (n int, err error)
 //sys	Pwrite(fd int, p []byte, offset int64) (n int, err error)
 //sys	read(fd int, p []byte) (n int, err error)
 //sys	Readlink(path string, buf []byte) (n int, err error)
+//sys	Readlinkat(dirfd int, path string, buf []byte) (n int, err error)
 //sys	Rename(from string, to string) (err error)
+//sys	Renameat(fromfd int, from string, tofd int, to string) (err error)
 //sys	Revoke(path string) (err error)
 //sys	Rmdir(path string) (err error)
 //sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK
@@ -323,10 +339,12 @@ func Uname(uname *Utsname) error {
 //sysnb	Setuid(uid int) (err error)
 //sys	Stat(path string, stat *Stat_t) (err error)
 //sys	Symlink(path string, link string) (err error)
+//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
 //sys	Sync() (err error)
 //sys	Truncate(path string, length int64) (err error)
 //sys	Umask(newmask int) (oldmask int)
 //sys	Unlink(path string) (err error)
+//sys	Unlinkat(dirfd int, path string, flags int) (err error)
 //sys	Unmount(path string, flags int) (err error)
 //sys	write(fd int, p []byte) (n int, err error)
 //sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
diff --git a/vendor/golang.org/x/sys/unix/syscall_netbsd_test.go b/vendor/golang.org/x/sys/unix/syscall_netbsd_test.go
index 3573a133..41141f96 100644
--- a/vendor/golang.org/x/sys/unix/syscall_netbsd_test.go
+++ b/vendor/golang.org/x/sys/unix/syscall_netbsd_test.go
@@ -5,6 +5,7 @@
 package unix_test
 
 import (
+	"bytes"
 	"testing"
 
 	"golang.org/x/sys/unix"
@@ -33,3 +34,18 @@ func TestSysctlClockinfo(t *testing.T) {
 	t.Logf("tick = %v, tickadj = %v, hz = %v, profhz = %v, stathz = %v",
 		ci.Tick, ci.Tickadj, ci.Hz, ci.Profhz, ci.Stathz)
 }
+
+func TestIoctlPtmget(t *testing.T) {
+	fd, err := unix.Open("/dev/ptmx", unix.O_NOCTTY|unix.O_RDWR, 0666)
+	if err != nil {
+		t.Skip("failed to open /dev/ptmx, skipping test")
+	}
+	defer unix.Close(fd)
+
+	ptm, err := unix.IoctlGetPtmget(fd, unix.TIOCPTSNAME)
+	if err != nil {
+		t.Fatalf("IoctlGetPtmget: %v\n", err)
+	}
+
+	t.Logf("sfd = %v, ptsname = %v", ptm.Sfd, string(ptm.Sn[:bytes.IndexByte(ptm.Sn[:], 0)]))
+}
diff --git a/vendor/golang.org/x/sys/unix/syscall_openbsd.go b/vendor/golang.org/x/sys/unix/syscall_openbsd.go
index 2b9f26a6..5a398f81 100644
--- a/vendor/golang.org/x/sys/unix/syscall_openbsd.go
+++ b/vendor/golang.org/x/sys/unix/syscall_openbsd.go
@@ -233,6 +233,7 @@ func Uname(uname *Utsname) error {
 //sys	Fchmod(fd int, mode uint32) (err error)
 //sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
 //sys	Fchown(fd int, uid int, gid int) (err error)
+//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
 //sys	Flock(fd int, how int) (err error)
 //sys	Fpathconf(fd int, name int) (val int, err error)
 //sys	Fstat(fd int, stat *Stat_t) (err error)
@@ -259,11 +260,15 @@ func Uname(uname *Utsname) error {
 //sys	Kqueue() (fd int, err error)
 //sys	Lchown(path string, uid int, gid int) (err error)
 //sys	Link(path string, link string) (err error)
+//sys	Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)
 //sys	Listen(s int, backlog int) (err error)
 //sys	Lstat(path string, stat *Stat_t) (err error)
 //sys	Mkdir(path string, mode uint32) (err error)
+//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
 //sys	Mkfifo(path string, mode uint32) (err error)
+//sys	Mkfifoat(dirfd int, path string, mode uint32) (err error)
 //sys	Mknod(path string, mode uint32, dev int) (err error)
+//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
 //sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
 //sys	Open(path string, mode int, perm uint32) (fd int, err error)
 //sys	Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)
@@ -272,7 +277,9 @@ func Uname(uname *Utsname) error {
 //sys	Pwrite(fd int, p []byte, offset int64) (n int, err error)
 //sys	read(fd int, p []byte) (n int, err error)
 //sys	Readlink(path string, buf []byte) (n int, err error)
+//sys	Readlinkat(dirfd int, path string, buf []byte) (n int, err error)
 //sys	Rename(from string, to string) (err error)
+//sys	Renameat(fromfd int, from string, tofd int, to string) (err error)
 //sys	Revoke(path string) (err error)
 //sys	Rmdir(path string) (err error)
 //sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK
@@ -295,10 +302,12 @@ func Uname(uname *Utsname) error {
 //sys	Stat(path string, stat *Stat_t) (err error)
 //sys	Statfs(path string, stat *Statfs_t) (err error)
 //sys	Symlink(path string, link string) (err error)
+//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
 //sys	Sync() (err error)
 //sys	Truncate(path string, length int64) (err error)
 //sys	Umask(newmask int) (oldmask int)
 //sys	Unlink(path string) (err error)
+//sys	Unlinkat(dirfd int, path string, flags int) (err error)
 //sys	Unmount(path string, flags int) (err error)
 //sys	write(fd int, p []byte) (n int, err error)
 //sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
@@ -321,15 +330,11 @@ func Uname(uname *Utsname) error {
 // clock_settime
 // closefrom
 // execve
-// faccessat
-// fchmodat
-// fchownat
 // fcntl
 // fhopen
 // fhstat
 // fhstatfs
 // fork
-// fstatat
 // futimens
 // getfh
 // getgid
@@ -343,12 +348,8 @@ func Uname(uname *Utsname) error {
 // lfs_markv
 // lfs_segclean
 // lfs_segwait
-// linkat
 // mincore
 // minherit
-// mkdirat
-// mkfifoat
-// mknodat
 // mount
 // mquery
 // msgctl
@@ -361,7 +362,6 @@ func Uname(uname *Utsname) error {
 // profil
 // pwritev
 // quotactl
-// readlinkat
 // readv
 // reboot
 // renameat
@@ -382,13 +382,11 @@ func Uname(uname *Utsname) error {
 // sigprocmask
 // sigreturn
 // sigsuspend
-// symlinkat
 // sysarch
 // syscall
 // threxit
 // thrsigdivert
 // thrsleep
 // thrwakeup
-// unlinkat
 // vfork
 // writev
diff --git a/vendor/golang.org/x/sys/unix/syscall_unix_gc.go b/vendor/golang.org/x/sys/unix/syscall_unix_gc.go
index 4cb8e8ed..1c70d1b6 100644
--- a/vendor/golang.org/x/sys/unix/syscall_unix_gc.go
+++ b/vendor/golang.org/x/sys/unix/syscall_unix_gc.go
@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 // +build darwin dragonfly freebsd linux netbsd openbsd solaris
-// +build !gccgo
+// +build !gccgo,!ppc64le,!ppc64
 
 package unix
 
diff --git a/vendor/golang.org/x/sys/unix/syscall_unix_gc_ppc64x.go b/vendor/golang.org/x/sys/unix/syscall_unix_gc_ppc64x.go
new file mode 100644
index 00000000..86dc765a
--- /dev/null
+++ b/vendor/golang.org/x/sys/unix/syscall_unix_gc_ppc64x.go
@@ -0,0 +1,24 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build linux
+// +build ppc64le ppc64
+// +build !gccgo
+
+package unix
+
+import "syscall"
+
+func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno) {
+	return syscall.Syscall(trap, a1, a2, a3)
+}
+func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno) {
+	return syscall.Syscall6(trap, a1, a2, a3, a4, a5, a6)
+}
+func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno) {
+	return syscall.RawSyscall(trap, a1, a2, a3)
+}
+func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno) {
+	return syscall.RawSyscall6(trap, a1, a2, a3, a4, a5, a6)
+}
diff --git a/vendor/golang.org/x/sys/unix/types_freebsd.go b/vendor/golang.org/x/sys/unix/types_freebsd.go
index 8421ccf1..74707989 100644
--- a/vendor/golang.org/x/sys/unix/types_freebsd.go
+++ b/vendor/golang.org/x/sys/unix/types_freebsd.go
@@ -26,7 +26,7 @@ package unix
 #include <termios.h>
 #include <stdio.h>
 #include <unistd.h>
-#include <sys/capability.h>
+#include <sys/capsicum.h>
 #include <sys/event.h>
 #include <sys/mman.h>
 #include <sys/mount.h>
diff --git a/vendor/golang.org/x/sys/unix/types_netbsd.go b/vendor/golang.org/x/sys/unix/types_netbsd.go
index 1edbf1ba..2dd4f954 100644
--- a/vendor/golang.org/x/sys/unix/types_netbsd.go
+++ b/vendor/golang.org/x/sys/unix/types_netbsd.go
@@ -248,6 +248,8 @@ type Termios C.struct_termios
 
 type Winsize C.struct_winsize
 
+type Ptmget C.struct_ptmget
+
 // fchmodat-like syscalls.
 
 const (
diff --git a/vendor/golang.org/x/sys/unix/xattr_bsd.go b/vendor/golang.org/x/sys/unix/xattr_bsd.go
index 93049932..30c1d71f 100644
--- a/vendor/golang.org/x/sys/unix/xattr_bsd.go
+++ b/vendor/golang.org/x/sys/unix/xattr_bsd.go
@@ -81,7 +81,10 @@ func Lgetxattr(link string, attr string, dest []byte) (sz int, err error) {
 // flags are unused on FreeBSD
 
 func Fsetxattr(fd int, attr string, data []byte, flags int) (err error) {
-	d := unsafe.Pointer(&data[0])
+	var d unsafe.Pointer
+	if len(data) > 0 {
+		d = unsafe.Pointer(&data[0])
+	}
 	datasiz := len(data)
 
 	nsid, a, err := xattrnamespace(attr)
@@ -94,7 +97,10 @@ func Fsetxattr(fd int, attr string, data []byte, flags int) (err error) {
 }
 
 func Setxattr(file string, attr string, data []byte, flags int) (err error) {
-	d := unsafe.Pointer(&data[0])
+	var d unsafe.Pointer
+	if len(data) > 0 {
+		d = unsafe.Pointer(&data[0])
+	}
 	datasiz := len(data)
 
 	nsid, a, err := xattrnamespace(attr)
@@ -107,7 +113,10 @@ func Setxattr(file string, attr string, data []byte, flags int) (err error) {
 }
 
 func Lsetxattr(link string, attr string, data []byte, flags int) (err error) {
-	d := unsafe.Pointer(&data[0])
+	var d unsafe.Pointer
+	if len(data) > 0 {
+		d = unsafe.Pointer(&data[0])
+	}
 	datasiz := len(data)
 
 	nsid, a, err := xattrnamespace(attr)
diff --git a/vendor/golang.org/x/sys/unix/xattr_test.go b/vendor/golang.org/x/sys/unix/xattr_test.go
index 11a76ce2..57fc84fb 100644
--- a/vendor/golang.org/x/sys/unix/xattr_test.go
+++ b/vendor/golang.org/x/sys/unix/xattr_test.go
@@ -24,13 +24,19 @@ func TestXattr(t *testing.T) {
 
 	xattrName := "user.test"
 	xattrDataSet := "gopher"
-	err := unix.Setxattr(f, xattrName, []byte(xattrDataSet), 0)
+
+	err := unix.Setxattr(f, xattrName, []byte{}, 0)
 	if err == unix.ENOTSUP || err == unix.EOPNOTSUPP {
 		t.Skip("filesystem does not support extended attributes, skipping test")
 	} else if err != nil {
 		t.Fatalf("Setxattr: %v", err)
 	}
 
+	err = unix.Setxattr(f, xattrName, []byte(xattrDataSet), 0)
+	if err != nil {
+		t.Fatalf("Setxattr: %v", err)
+	}
+
 	// find size
 	size, err := unix.Listxattr(f, nil)
 	if err != nil {
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_386.go b/vendor/golang.org/x/sys/unix/zerrors_linux_386.go
index 7d93bdf0..673152b9 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_386.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_386.go
@@ -1023,6 +1023,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go b/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
index bd57833b..5735bcf3 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
@@ -1023,6 +1023,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go b/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
index b059c287..d8e8442e 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
@@ -1021,6 +1021,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go b/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
index 97d5e224..5d79b789 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
@@ -1024,6 +1024,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go b/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
index 059d1fc1..3c91615c 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
@@ -1021,6 +1021,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go b/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
index 355f749b..e1f86c1c 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
@@ -1021,6 +1021,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go b/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
index 5218cf5a..d09e3b68 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
@@ -1021,6 +1021,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go b/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
index 73e35b9e..f78108df 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
@@ -1021,6 +1021,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go b/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
index 82f44ce3..8da57a99 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
@@ -1020,6 +1020,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go b/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
index 8734df99..1832c0a7 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
@@ -1020,6 +1020,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go b/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go
index 0954f472..c6bd4eff 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go
@@ -1021,6 +1021,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go b/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
index 61a96aba..8cdf353d 100644
--- a/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
+++ b/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
@@ -1021,6 +1021,8 @@ const (
 	MNT_DETACH                           = 0x2
 	MNT_EXPIRE                           = 0x4
 	MNT_FORCE                            = 0x1
+	MODULE_INIT_IGNORE_MODVERSIONS       = 0x1
+	MODULE_INIT_IGNORE_VERMAGIC          = 0x2
 	MSDOS_SUPER_MAGIC                    = 0x4d44
 	MSG_BATCH                            = 0x40000
 	MSG_CMSG_CLOEXEC                     = 0x40000000
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go b/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go
index 91f36e9e..96a67134 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go
@@ -588,6 +588,21 @@ func Exit(code int) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Fchdir(fd int) (err error) {
 	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
 	if e1 != 0 {
@@ -643,6 +658,21 @@ func Fchown(fd int, uid int, gid int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flock(fd int, how int) (err error) {
 	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
 	if e1 != 0 {
@@ -927,6 +957,26 @@ func Link(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(link)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Listen(s int, backlog int) (err error) {
 	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
 	if e1 != 0 {
@@ -967,6 +1017,21 @@ func Mkdir(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkdirat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mkfifo(path string, mode uint32) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -997,6 +1062,21 @@ func Mknod(path string, mode uint32, dev int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mknodat(fd int, path string, mode uint32, dev int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
 	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
 	if e1 != 0 {
@@ -1023,6 +1103,22 @@ func Open(path string, mode int, perm uint32) (fd int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Pathconf(path string, name int) (val int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1345,6 +1441,26 @@ func Symlink(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Sync() (err error) {
 	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
 	if e1 != 0 {
@@ -1408,6 +1524,21 @@ func Unlink(path string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Unlinkat(dirfd int, path string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Unmount(path string, flags int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
index 35b155a0..cd94680d 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
index 46e9ddfb..96e9df7d 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
index 914f25f0..e8d82d14 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
index 1d6c5562..41f2d0cf 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
index 260631d1..7e65fe0b 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
index ff2d84fb..fd06fb89 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
index 48d14e60..9e8ec28c 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
index 12c17a92..b4d2ccbb 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
index c8ca4279..bca3d253 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
index 870c8f6d..e34089c6 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go
index 542f3a3a..312b2afa 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go b/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
index 55e79d64..04ec8bef 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
@@ -458,6 +458,21 @@ func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags in
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Dup(oldfd int) (fd int, err error) {
 	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
 	fd = int(r0)
@@ -606,6 +621,21 @@ func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flistxattr(fd int, dest []byte) (sz int, err error) {
 	var _p0 unsafe.Pointer
 	if len(dest) > 0 {
@@ -807,6 +837,27 @@ func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(pathname)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go b/vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
index f1874d5a..9ed7c71f 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
@@ -865,6 +865,21 @@ func Fchown(fd int, uid int, gid int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flock(fd int, how int) (err error) {
 	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
 	if e1 != 0 {
@@ -1114,6 +1129,26 @@ func Link(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(link)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Listen(s int, backlog int) (err error) {
 	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
 	if e1 != 0 {
@@ -1154,6 +1189,21 @@ func Mkdir(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkdirat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mkfifo(path string, mode uint32) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1169,6 +1219,21 @@ func Mkfifo(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkfifoat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKFIFOAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mknod(path string, mode uint32, dev int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1184,6 +1249,21 @@ func Mknod(path string, mode uint32, dev int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
 	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
 	if e1 != 0 {
@@ -1210,6 +1290,22 @@ func Open(path string, mode int, perm uint32) (fd int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Pathconf(path string, name int) (val int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1299,6 +1395,28 @@ func Readlink(path string, buf []byte) (n int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Readlinkat(dirfd int, path string, buf []byte) (n int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(buf) > 0 {
+		_p1 = unsafe.Pointer(&buf[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Rename(from string, to string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(from)
@@ -1319,6 +1437,26 @@ func Rename(from string, to string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Renameat(fromfd int, from string, tofd int, to string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(from)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(to)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Revoke(path string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1516,6 +1654,26 @@ func Symlink(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Sync() (err error) {
 	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
 	if e1 != 0 {
@@ -1564,6 +1722,21 @@ func Unlink(path string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Unlinkat(dirfd int, path string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Unmount(path string, flags int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go b/vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
index eb802839..613b7fd9 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
@@ -865,6 +865,21 @@ func Fchown(fd int, uid int, gid int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flock(fd int, how int) (err error) {
 	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
 	if e1 != 0 {
@@ -1114,6 +1129,26 @@ func Link(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(link)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Listen(s int, backlog int) (err error) {
 	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
 	if e1 != 0 {
@@ -1154,6 +1189,21 @@ func Mkdir(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkdirat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mkfifo(path string, mode uint32) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1169,6 +1219,21 @@ func Mkfifo(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkfifoat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKFIFOAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mknod(path string, mode uint32, dev int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1184,6 +1249,21 @@ func Mknod(path string, mode uint32, dev int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
 	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
 	if e1 != 0 {
@@ -1210,6 +1290,22 @@ func Open(path string, mode int, perm uint32) (fd int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Pathconf(path string, name int) (val int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1299,6 +1395,28 @@ func Readlink(path string, buf []byte) (n int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Readlinkat(dirfd int, path string, buf []byte) (n int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(buf) > 0 {
+		_p1 = unsafe.Pointer(&buf[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Rename(from string, to string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(from)
@@ -1319,6 +1437,26 @@ func Rename(from string, to string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Renameat(fromfd int, from string, tofd int, to string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(from)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(to)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Revoke(path string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1516,6 +1654,26 @@ func Symlink(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Sync() (err error) {
 	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
 	if e1 != 0 {
@@ -1564,6 +1722,21 @@ func Unlink(path string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Unlinkat(dirfd int, path string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Unmount(path string, flags int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go b/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
index 7b36499d..08475087 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
@@ -865,6 +865,21 @@ func Fchown(fd int, uid int, gid int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flock(fd int, how int) (err error) {
 	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
 	if e1 != 0 {
@@ -1114,6 +1129,26 @@ func Link(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(link)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Listen(s int, backlog int) (err error) {
 	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
 	if e1 != 0 {
@@ -1154,6 +1189,21 @@ func Mkdir(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkdirat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mkfifo(path string, mode uint32) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1169,6 +1219,21 @@ func Mkfifo(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkfifoat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKFIFOAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mknod(path string, mode uint32, dev int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1184,6 +1249,21 @@ func Mknod(path string, mode uint32, dev int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
 	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
 	if e1 != 0 {
@@ -1210,6 +1290,22 @@ func Open(path string, mode int, perm uint32) (fd int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Pathconf(path string, name int) (val int, err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1299,6 +1395,28 @@ func Readlink(path string, buf []byte) (n int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Readlinkat(dirfd int, path string, buf []byte) (n int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(buf) > 0 {
+		_p1 = unsafe.Pointer(&buf[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Rename(from string, to string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(from)
@@ -1319,6 +1437,26 @@ func Rename(from string, to string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Renameat(fromfd int, from string, tofd int, to string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(from)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(to)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Revoke(path string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1516,6 +1654,26 @@ func Symlink(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Sync() (err error) {
 	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
 	if e1 != 0 {
@@ -1564,6 +1722,21 @@ func Unlink(path string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Unlinkat(dirfd int, path string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Unmount(path string, flags int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go b/vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
index 08223568..414cd13c 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
@@ -650,6 +650,21 @@ func Fchown(fd int, uid int, gid int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flock(fd int, how int) (err error) {
 	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
 	if e1 != 0 {
@@ -920,6 +935,26 @@ func Link(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(link)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Listen(s int, backlog int) (err error) {
 	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
 	if e1 != 0 {
@@ -960,6 +995,21 @@ func Mkdir(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkdirat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mkfifo(path string, mode uint32) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -975,6 +1025,21 @@ func Mkfifo(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkfifoat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKFIFOAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mknod(path string, mode uint32, dev int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -990,6 +1055,21 @@ func Mknod(path string, mode uint32, dev int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
 	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
 	if e1 != 0 {
@@ -1121,6 +1201,28 @@ func Readlink(path string, buf []byte) (n int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Readlinkat(dirfd int, path string, buf []byte) (n int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(buf) > 0 {
+		_p1 = unsafe.Pointer(&buf[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Rename(from string, to string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(from)
@@ -1141,6 +1243,26 @@ func Rename(from string, to string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Renameat(fromfd int, from string, tofd int, to string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(from)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(to)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Revoke(path string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1398,6 +1520,26 @@ func Symlink(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Sync() (err error) {
 	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
 	if e1 != 0 {
@@ -1446,6 +1588,21 @@ func Unlink(path string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Unlinkat(dirfd int, path string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Unmount(path string, flags int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go b/vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
index 3d0bae42..846f5fa6 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
@@ -650,6 +650,21 @@ func Fchown(fd int, uid int, gid int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flock(fd int, how int) (err error) {
 	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
 	if e1 != 0 {
@@ -920,6 +935,26 @@ func Link(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(link)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Listen(s int, backlog int) (err error) {
 	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
 	if e1 != 0 {
@@ -960,6 +995,21 @@ func Mkdir(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkdirat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mkfifo(path string, mode uint32) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -975,6 +1025,21 @@ func Mkfifo(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkfifoat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKFIFOAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mknod(path string, mode uint32, dev int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -990,6 +1055,21 @@ func Mknod(path string, mode uint32, dev int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
 	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
 	if e1 != 0 {
@@ -1121,6 +1201,28 @@ func Readlink(path string, buf []byte) (n int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Readlinkat(dirfd int, path string, buf []byte) (n int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(buf) > 0 {
+		_p1 = unsafe.Pointer(&buf[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Rename(from string, to string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(from)
@@ -1141,6 +1243,26 @@ func Rename(from string, to string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Renameat(fromfd int, from string, tofd int, to string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(from)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(to)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Revoke(path string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1398,6 +1520,26 @@ func Symlink(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Sync() (err error) {
 	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
 	if e1 != 0 {
@@ -1446,6 +1588,21 @@ func Unlink(path string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Unlinkat(dirfd int, path string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Unmount(path string, flags int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
diff --git a/vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go b/vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
index 6422c460..59911659 100644
--- a/vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
+++ b/vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
@@ -650,6 +650,21 @@ func Fchown(fd int, uid int, gid int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Flock(fd int, how int) (err error) {
 	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
 	if e1 != 0 {
@@ -920,6 +935,26 @@ func Link(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(link)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Listen(s int, backlog int) (err error) {
 	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)
 	if e1 != 0 {
@@ -960,6 +995,21 @@ func Mkdir(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkdirat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mkfifo(path string, mode uint32) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -975,6 +1025,21 @@ func Mkfifo(path string, mode uint32) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mkfifoat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKFIFOAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Mknod(path string, mode uint32, dev int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -990,6 +1055,21 @@ func Mknod(path string, mode uint32, dev int) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
 	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
 	if e1 != 0 {
@@ -1121,6 +1201,28 @@ func Readlink(path string, buf []byte) (n int, err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Readlinkat(dirfd int, path string, buf []byte) (n int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(buf) > 0 {
+		_p1 = unsafe.Pointer(&buf[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Rename(from string, to string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(from)
@@ -1141,6 +1243,26 @@ func Rename(from string, to string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Renameat(fromfd int, from string, tofd int, to string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(from)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(to)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Revoke(path string) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
@@ -1398,6 +1520,26 @@ func Symlink(path string, link string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Sync() (err error) {
 	_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)
 	if e1 != 0 {
@@ -1446,6 +1588,21 @@ func Unlink(path string) (err error) {
 
 // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
 
+func Unlinkat(dirfd int, path string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
 func Unmount(path string, flags int) (err error) {
 	var _p0 *byte
 	_p0, err = BytePtrFromString(path)
diff --git a/vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go b/vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
index 28ef5242..c146c1ad 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
@@ -339,7 +339,7 @@ type Kevent_t struct {
 }
 
 type FdSet struct {
-	_ [32]uint32
+	Bits [32]uint32
 }
 
 const (
diff --git a/vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go b/vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
index e2d984a4..ac33a8dd 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
@@ -337,7 +337,7 @@ type Kevent_t struct {
 }
 
 type FdSet struct {
-	_ [16]uint64
+	Bits [16]uint64
 }
 
 const (
diff --git a/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go b/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
index 9b415aba..e27511a6 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
@@ -337,7 +337,7 @@ type Kevent_t struct {
 }
 
 type FdSet struct {
-	_ [32]uint32
+	Bits [32]uint32
 }
 
 const (
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_386.go b/vendor/golang.org/x/sys/unix/ztypes_linux_386.go
index 5f8f0349..f56e164b 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_386.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_386.go
@@ -286,6 +286,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]int8
@@ -421,6 +423,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x8
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go b/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go
index aa52a439..ac5f636a 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go
@@ -288,6 +288,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]int8
@@ -425,6 +427,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x10
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go b/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go
index 23c8438b..eb7562da 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go
@@ -289,6 +289,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]uint8
@@ -424,6 +426,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x8
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go b/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go
index d7a993e2..3c4fb88d 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go
@@ -289,6 +289,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]int8
@@ -426,6 +428,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x10
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go b/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go
index b8c3d0a4..647e40a7 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go
@@ -287,6 +287,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]int8
@@ -422,6 +424,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x8
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go b/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go
index a6f76149..e0159b01 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go
@@ -289,6 +289,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]int8
@@ -426,6 +428,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x10
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go b/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go
index 3dd19417..c1a024df 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go
@@ -289,6 +289,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]int8
@@ -426,6 +428,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x10
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go b/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go
index 210de76c..7e525eb7 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go
@@ -287,6 +287,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]int8
@@ -422,6 +424,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x8
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go b/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go
index b46d54e3..85ae2954 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go
@@ -290,6 +290,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]uint8
@@ -427,6 +429,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x10
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go b/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go
index 6ee799ce..d0c930a1 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go
@@ -290,6 +290,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]uint8
@@ -427,6 +429,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x10
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go b/vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go
index 60ae71e6..c1a20bcd 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go
@@ -289,6 +289,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]uint8
@@ -426,6 +428,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x10
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go b/vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go
index dea88f7b..3c26ea82 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go
@@ -288,6 +288,8 @@ type RawSockaddrXDP struct {
 	Shared_umem_fd uint32
 }
 
+type RawSockaddrPPPoX [0x1e]byte
+
 type RawSockaddr struct {
 	Family uint16
 	Data   [14]int8
@@ -425,6 +427,7 @@ const (
 	SizeofSockaddrALG       = 0x58
 	SizeofSockaddrVM        = 0x10
 	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
 	SizeofLinger            = 0x8
 	SizeofIovec             = 0x10
 	SizeofIPMreq            = 0x8
diff --git a/vendor/golang.org/x/sys/unix/ztypes_netbsd_386.go b/vendor/golang.org/x/sys/unix/ztypes_netbsd_386.go
index 1fdc5fd2..2dae0c17 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_netbsd_386.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_netbsd_386.go
@@ -402,6 +402,13 @@ type Winsize struct {
 	Ypixel uint16
 }
 
+type Ptmget struct {
+	Cfd int32
+	Sfd int32
+	Cn  [1024]byte
+	Sn  [1024]byte
+}
+
 const (
 	AT_FDCWD            = -0x64
 	AT_SYMLINK_NOFOLLOW = 0x200
diff --git a/vendor/golang.org/x/sys/unix/ztypes_netbsd_amd64.go b/vendor/golang.org/x/sys/unix/ztypes_netbsd_amd64.go
index 711f7806..1f0e76c0 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_netbsd_amd64.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_netbsd_amd64.go
@@ -409,6 +409,13 @@ type Winsize struct {
 	Ypixel uint16
 }
 
+type Ptmget struct {
+	Cfd int32
+	Sfd int32
+	Cn  [1024]byte
+	Sn  [1024]byte
+}
+
 const (
 	AT_FDCWD            = -0x64
 	AT_SYMLINK_NOFOLLOW = 0x200
diff --git a/vendor/golang.org/x/sys/unix/ztypes_netbsd_arm.go b/vendor/golang.org/x/sys/unix/ztypes_netbsd_arm.go
index fa1a16ba..53f2159c 100644
--- a/vendor/golang.org/x/sys/unix/ztypes_netbsd_arm.go
+++ b/vendor/golang.org/x/sys/unix/ztypes_netbsd_arm.go
@@ -407,6 +407,13 @@ type Winsize struct {
 	Ypixel uint16
 }
 
+type Ptmget struct {
+	Cfd int32
+	Sfd int32
+	Cn  [1024]byte
+	Sn  [1024]byte
+}
+
 const (
 	AT_FDCWD            = -0x64
 	AT_SYMLINK_NOFOLLOW = 0x200
diff --git a/vendor/golang.org/x/tools/cmd/bundle/main.go b/vendor/golang.org/x/tools/cmd/bundle/main.go
index 601da7f8..7c552683 100644
--- a/vendor/golang.org/x/tools/cmd/bundle/main.go
+++ b/vendor/golang.org/x/tools/cmd/bundle/main.go
@@ -105,7 +105,7 @@ var (
 	outputFile = flag.String("o", "", "write output to `file` (default standard output)")
 	dstPath    = flag.String("dst", "", "set destination import `path` (default taken from current directory)")
 	pkgName    = flag.String("pkg", "", "set destination package `name` (default taken from current directory)")
-	prefix     = flag.String("prefix", "", "set bundled identifier prefix to `p` (default source package name + \"_\")")
+	prefix     = flag.String("prefix", "&_", "set bundled identifier prefix to `p` (default is \"&_\", where & stands for the original name)")
 	underscore = flag.Bool("underscore", false, "rewrite golang.org to golang_org in imports; temporary workaround for golang.org/issue/16333")
 
 	importMap = map[string]string{}
@@ -203,9 +203,8 @@ func bundle(src, dst, dstpkg, prefix string) ([]byte, error) {
 	// Because there was a single Import call and Load succeeded,
 	// InitialPackages is guaranteed to hold the sole requested package.
 	info := lprog.InitialPackages()[0]
-	if prefix == "" {
-		pkgName := info.Files[0].Name.Name
-		prefix = pkgName + "_"
+	if strings.Contains(prefix, "&") {
+		prefix = strings.Replace(prefix, "&", info.Files[0].Name.Name, -1)
 	}
 
 	objsToUpdate := make(map[types.Object]bool)
diff --git a/vendor/golang.org/x/tools/cmd/godoc/appinit.go b/vendor/golang.org/x/tools/cmd/godoc/appinit.go
index 6318bb75..1f276d86 100644
--- a/vendor/golang.org/x/tools/cmd/godoc/appinit.go
+++ b/vendor/golang.org/x/tools/cmd/godoc/appinit.go
@@ -84,7 +84,11 @@ func main() {
 	}
 	corpus.IndexDirectory = indexDirectoryDefault
 	corpus.InitVersionInfo()
-	go corpus.RunIndexer()
+	if indexFilenames != "" {
+		corpus.RunIndexer()
+	} else {
+		go corpus.RunIndexer()
+	}
 
 	pres = godoc.NewPresentation(corpus)
 	pres.TabWidth = 8
diff --git a/vendor/golang.org/x/tools/cmd/golsp/main.go b/vendor/golang.org/x/tools/cmd/golsp/main.go
index 161e5f9e..ce619ae1 100644
--- a/vendor/golang.org/x/tools/cmd/golsp/main.go
+++ b/vendor/golang.org/x/tools/cmd/golsp/main.go
@@ -10,6 +10,7 @@ package main // import "golang.org/x/tools/cmd/golsp"
 
 import (
 	"context"
+	"encoding/json"
 	"flag"
 	"fmt"
 	"io"
@@ -18,6 +19,7 @@ import (
 	"runtime"
 	"runtime/pprof"
 	"runtime/trace"
+	"time"
 
 	"golang.org/x/tools/internal/jsonrpc2"
 	"golang.org/x/tools/internal/lsp"
@@ -86,6 +88,7 @@ func main() {
 		}()
 	}
 
+	out := os.Stderr
 	if *logfile != "" {
 		f, err := os.Create(*logfile)
 		if err != nil {
@@ -93,12 +96,52 @@ func main() {
 		}
 		defer f.Close()
 		log.SetOutput(io.MultiWriter(os.Stderr, f))
+		out = f
 	}
-	if err := run(context.Background()); err != nil {
+	if err := lsp.RunServer(
+		context.Background(),
+		jsonrpc2.NewHeaderStream(os.Stdin, os.Stdout),
+		func(direction jsonrpc2.Direction, id *jsonrpc2.ID, elapsed time.Duration, method string, payload *json.RawMessage, err *jsonrpc2.Error) {
+
+			if err != nil {
+				fmt.Fprintf(out, "[Error - %v] %s %s%s %v", time.Now().Format("3:04:05 PM"), direction, method, id, err)
+				return
+			}
+			fmt.Fprintf(out, "[Trace - %v] ", time.Now().Format("3:04:05 PM"))
+			switch direction {
+			case jsonrpc2.Send:
+				fmt.Fprint(out, "Received ")
+			case jsonrpc2.Receive:
+				fmt.Fprint(out, "Sending ")
+			}
+			switch {
+			case id == nil:
+				fmt.Fprint(out, "notification ")
+			case elapsed >= 0:
+				fmt.Fprint(out, "response ")
+			default:
+				fmt.Fprint(out, "request ")
+			}
+			fmt.Fprintf(out, "'%s", method)
+			switch {
+			case id == nil:
+				// do nothing
+			case id.Name != "":
+				fmt.Fprintf(out, " - (%s)", id.Name)
+			default:
+				fmt.Fprintf(out, " - (%d)", id.Number)
+			}
+			fmt.Fprint(out, "'")
+			if elapsed >= 0 {
+				fmt.Fprintf(out, " in %vms", elapsed.Nanoseconds()/1000)
+			}
+			params := string(*payload)
+			if params == "null" {
+				params = "{}"
+			}
+			fmt.Fprintf(out, ".\r\nParams: %s\r\n\r\n\r\n", params)
+		},
+	); err != nil {
 		log.Fatal(err)
 	}
 }
-
-func run(ctx context.Context) error {
-	return lsp.RunServer(ctx, jsonrpc2.NewHeaderStream(os.Stdin, os.Stdout), jsonrpc2.Log)
-}
diff --git a/vendor/golang.org/x/tools/cmd/stringer/stringer.go b/vendor/golang.org/x/tools/cmd/stringer/stringer.go
index 5c3ad354..57d3a723 100644
--- a/vendor/golang.org/x/tools/cmd/stringer/stringer.go
+++ b/vendor/golang.org/x/tools/cmd/stringer/stringer.go
@@ -87,7 +87,7 @@ var (
 
 // Usage is a replacement usage function for the flags package.
 func Usage() {
-	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
+	fmt.Fprintf(os.Stderr, "Usage of stringer:\n")
 	fmt.Fprintf(os.Stderr, "\tstringer [flags] -type T [directory]\n")
 	fmt.Fprintf(os.Stderr, "\tstringer [flags] -type T files... # Must be a single package\n")
 	fmt.Fprintf(os.Stderr, "For more information, see:\n")
@@ -428,10 +428,24 @@ func (f *File) genDecl(node ast.Node) bool {
 	for _, spec := range decl.Specs {
 		vspec := spec.(*ast.ValueSpec) // Guaranteed to succeed as this is CONST.
 		if vspec.Type == nil && len(vspec.Values) > 0 {
-			// "X = 1". With no type but a value, the constant is untyped.
-			// Skip this vspec and reset the remembered type.
+			// "X = 1". With no type but a value. If the constant is untyped,
+			// skip this vspec and reset the remembered type.
 			typ = ""
-			continue
+
+			// If this is a simple type conversion, remember the type.
+			// We don't mind if this is actually a call; a qualified call won't
+			// be matched (that will be SelectorExpr, not Ident), and only unusual
+			// situations will result in a function call that appears to be
+			// a type conversion.
+			ce, ok := vspec.Values[0].(*ast.CallExpr)
+			if !ok {
+				continue
+			}
+			id, ok := ce.Fun.(*ast.Ident)
+			if !ok {
+				continue
+			}
+			typ = id.Name
 		}
 		if vspec.Type != nil {
 			// "X T". We have a type. Remember it.
diff --git a/vendor/golang.org/x/tools/cmd/stringer/testdata/conv.go b/vendor/golang.org/x/tools/cmd/stringer/testdata/conv.go
new file mode 100644
index 00000000..9a9dc644
--- /dev/null
+++ b/vendor/golang.org/x/tools/cmd/stringer/testdata/conv.go
@@ -0,0 +1,41 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Check that constants defined as a conversion are accepted.
+
+package main
+
+import "fmt"
+
+type Other int // Imagine this is in another package.
+
+const (
+	alpha Other = iota
+	beta
+	gamma
+	delta
+)
+
+type Conv int
+
+const (
+	Alpha = Conv(alpha)
+	Beta  = Conv(beta)
+	Gamma = Conv(gamma)
+	Delta = Conv(delta)
+)
+
+func main() {
+	ck(Alpha, "Alpha")
+	ck(Beta, "Beta")
+	ck(Gamma, "Gamma")
+	ck(Delta, "Delta")
+	ck(42, "Conv(42)")
+}
+
+func ck(c Conv, str string) {
+	if fmt.Sprint(c) != str {
+		panic("conv.go: " + str)
+	}
+}
diff --git a/vendor/golang.org/x/tools/cmd/tip/godoc.go b/vendor/golang.org/x/tools/cmd/tip/godoc.go
index a01b8ca2..4332c355 100644
--- a/vendor/golang.org/x/tools/cmd/tip/godoc.go
+++ b/vendor/golang.org/x/tools/cmd/tip/godoc.go
@@ -48,7 +48,7 @@ func (b godocBuilder) Init(dir, hostport string, heads map[string]string) (*exec
 	}
 
 	godocBin := filepath.Join(goPath, "bin/godoc")
-	godoc := exec.Command(godocBin, "-http="+hostport, "-index", "-index_interval=-1s")
+	godoc := exec.Command(godocBin, "-http="+hostport, "-index", "-index_interval=-1s", "-play")
 	godoc.Env = []string{"GOROOT=" + goDir}
 	// TODO(adg): log this somewhere useful
 	godoc.Stdout = os.Stdout
diff --git a/vendor/golang.org/x/tools/go/analysis/cmd/vet-lite/main.go b/vendor/golang.org/x/tools/go/analysis/cmd/vet-lite/main.go
new file mode 100644
index 00000000..259d3976
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/cmd/vet-lite/main.go
@@ -0,0 +1,74 @@
+// The vet-lite command is a driver for static checkers conforming to
+// the golang.org/x/tools/go/analysis API. It must be run by go vet:
+//
+//   $ go vet -vettool=$(which vet-lite)
+//
+// For a checker also capable of running standalone, use multichecker.
+package main
+
+import (
+	"golang.org/x/tools/go/analysis/unitchecker"
+
+	"golang.org/x/tools/go/analysis/passes/asmdecl"
+	"golang.org/x/tools/go/analysis/passes/assign"
+	"golang.org/x/tools/go/analysis/passes/atomic"
+	"golang.org/x/tools/go/analysis/passes/bools"
+	"golang.org/x/tools/go/analysis/passes/buildtag"
+	"golang.org/x/tools/go/analysis/passes/cgocall"
+	"golang.org/x/tools/go/analysis/passes/composite"
+	"golang.org/x/tools/go/analysis/passes/copylock"
+	"golang.org/x/tools/go/analysis/passes/httpresponse"
+	"golang.org/x/tools/go/analysis/passes/loopclosure"
+	"golang.org/x/tools/go/analysis/passes/lostcancel"
+	"golang.org/x/tools/go/analysis/passes/nilfunc"
+	"golang.org/x/tools/go/analysis/passes/printf"
+	"golang.org/x/tools/go/analysis/passes/shift"
+	"golang.org/x/tools/go/analysis/passes/stdmethods"
+	"golang.org/x/tools/go/analysis/passes/structtag"
+	"golang.org/x/tools/go/analysis/passes/tests"
+	"golang.org/x/tools/go/analysis/passes/unmarshal"
+	"golang.org/x/tools/go/analysis/passes/unreachable"
+	"golang.org/x/tools/go/analysis/passes/unsafeptr"
+	"golang.org/x/tools/go/analysis/passes/unusedresult"
+)
+
+// Legacy vet had the concept of "experimental" checkers. There
+// was exactly one, shadow, and it had to be explicitly enabled
+// by the -shadow flag, which would of course disable all the
+// other tristate flags, requiring the -all flag to reenable them.
+// (By itself, -all did not enable all checkers.)
+// The -all flag is no longer needed, so it is a no-op.
+//
+// The shadow analyzer has been removed from the suite,
+// but can be run using these additional commands:
+//   $ go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow
+//   $ go vet -vettool=$(which shadow)
+// Alternatively, one could build a multichecker containing all
+// the desired checks (vet's suite + shadow) and run it in a
+// single "go vet" command.
+
+func main() {
+	unitchecker.Main(
+		asmdecl.Analyzer,
+		assign.Analyzer,
+		atomic.Analyzer,
+		bools.Analyzer,
+		buildtag.Analyzer,
+		cgocall.Analyzer,
+		composite.Analyzer,
+		copylock.Analyzer,
+		httpresponse.Analyzer,
+		loopclosure.Analyzer,
+		lostcancel.Analyzer,
+		nilfunc.Analyzer,
+		printf.Analyzer,
+		shift.Analyzer,
+		stdmethods.Analyzer,
+		structtag.Analyzer,
+		tests.Analyzer,
+		unmarshal.Analyzer,
+		unreachable.Analyzer,
+		unsafeptr.Analyzer,
+		unusedresult.Analyzer,
+	)
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/cmd/vet/vet.go b/vendor/golang.org/x/tools/go/analysis/cmd/vet/vet.go
index ed075c43..d00fb646 100644
--- a/vendor/golang.org/x/tools/go/analysis/cmd/vet/vet.go
+++ b/vendor/golang.org/x/tools/go/analysis/cmd/vet/vet.go
@@ -7,10 +7,10 @@
 // using the golang.org/x/tools/go/packages API to load packages in any
 // build system.
 //
-// Each analysis flag name is preceded by the analysis name: --analysis.flag.
-// In addition, the --analysis.enabled flag controls whether the
-// diagnostics of that analysis are displayed. (A disabled analysis may yet
-// be run if it is required by some other analysis that is enabled.)
+// Each analyzer flag name is preceded by the analyzer name: -NAME.flag.
+// In addition, the -NAME flag itself controls whether the
+// diagnostics of that analyzer are displayed. (A disabled analyzer may yet
+// be run if it is required by some other analyzer that is enabled.)
 package main
 
 import (
@@ -25,24 +25,27 @@ import (
 	"golang.org/x/tools/go/analysis/passes/cgocall"
 	"golang.org/x/tools/go/analysis/passes/composite"
 	"golang.org/x/tools/go/analysis/passes/copylock"
-	"golang.org/x/tools/go/analysis/passes/findcall"
 	"golang.org/x/tools/go/analysis/passes/httpresponse"
 	"golang.org/x/tools/go/analysis/passes/loopclosure"
 	"golang.org/x/tools/go/analysis/passes/lostcancel"
 	"golang.org/x/tools/go/analysis/passes/nilfunc"
 	"golang.org/x/tools/go/analysis/passes/nilness"
-	"golang.org/x/tools/go/analysis/passes/pkgfact"
 	"golang.org/x/tools/go/analysis/passes/printf"
 	"golang.org/x/tools/go/analysis/passes/shift"
 	"golang.org/x/tools/go/analysis/passes/stdmethods"
 	"golang.org/x/tools/go/analysis/passes/structtag"
 	"golang.org/x/tools/go/analysis/passes/tests"
+	"golang.org/x/tools/go/analysis/passes/unmarshal"
 	"golang.org/x/tools/go/analysis/passes/unreachable"
 	"golang.org/x/tools/go/analysis/passes/unsafeptr"
 	"golang.org/x/tools/go/analysis/passes/unusedresult"
 )
 
 func main() {
+	// This suite of analyzers is applied to all code
+	// in GOROOT by GOROOT/src/cmd/vet/all. When adding
+	// a new analyzer, update the whitelist used by vet/all,
+	// or change its vet command to disable the new analyzer.
 	multichecker.Main(
 		// the traditional vet suite:
 		asmdecl.Analyzer,
@@ -57,25 +60,21 @@ func main() {
 		loopclosure.Analyzer,
 		lostcancel.Analyzer,
 		nilfunc.Analyzer,
-		pkgfact.Analyzer,
 		printf.Analyzer,
-		// shadow.Analyzer, // experimental; not enabled by default
 		shift.Analyzer,
 		stdmethods.Analyzer,
 		structtag.Analyzer,
 		tests.Analyzer,
+		unmarshal.Analyzer,
 		unreachable.Analyzer,
 		unsafeptr.Analyzer,
 		unusedresult.Analyzer,
 
 		// for debugging:
-		findcall.Analyzer,
+		// findcall.Analyzer,
+		// pkgfact.Analyzer,
 
-		// use SSA:
+		// uses SSA:
 		nilness.Analyzer,
-
-		// Work in progress:
-		// httpheader.Analyzer,
-		// deadcode.Analyzer,
 	)
 }
diff --git a/vendor/golang.org/x/tools/go/analysis/doc.go b/vendor/golang.org/x/tools/go/analysis/doc.go
index 4223ab80..5dee6151 100644
--- a/vendor/golang.org/x/tools/go/analysis/doc.go
+++ b/vendor/golang.org/x/tools/go/analysis/doc.go
@@ -72,11 +72,13 @@ To add a new Analyzer to an existing driver, add another item to the list:
 
 A driver may use the name, flags, and documentation to provide on-line
 help that describes the analyses its performs.
+The doc comment contains a brief one-line summary,
+optionally followed by paragraphs of explanation.
 The vet command, shown below, is an example of a driver that runs
 multiple analyzers. It is based on the multichecker package
 (see the "Standalone commands" section for details).
 
-	$ go build golang.org/x/tools/cmd/vet
+	$ go build golang.org/x/tools/go/analysis/cmd/vet
 	$ ./vet help
 	vet is a tool for static analysis of Go programs.
 
@@ -285,6 +287,16 @@ pointed to by fact. This scheme assumes that the concrete type of fact
 is a pointer; this assumption is checked by the Validate function.
 See the "printf" analyzer for an example of object facts in action.
 
+Some driver implementations (such as those based on Bazel and Blaze) do
+not currently apply analyzers to packages of the standard library.
+Therefore, for best results, analyzer authors should not rely on
+analysis facts being available for standard packages.
+For example, although the printf checker is capable of deducing during
+analysis of the log package that log.Printf is a printf-wrapper,
+this fact is built in to the analyzer so that it correctly checks
+calls to log.Printf even when run in a driver that does not apply
+it to standard packages. We plan to remove this limitation in future.
+
 
 Testing an Analyzer
 
@@ -298,14 +310,14 @@ diagnostics and facts (and no more). Expectations are expressed using
 Standalone commands
 
 Analyzers are provided in the form of packages that a driver program is
-expected to import. The vet command imports a set of several analyses,
+expected to import. The vet command imports a set of several analyzers,
 but users may wish to define their own analysis commands that perform
 additional checks. To simplify the task of creating an analysis command,
 either for a single analyzer or for a whole suite, we provide the
 singlechecker and multichecker subpackages.
 
 The singlechecker package provides the main function for a command that
-runs one analysis. By convention, each analyzer such as
+runs one analyzer. By convention, each analyzer such as
 go/passes/findcall should be accompanied by a singlechecker-based
 command such as go/analysis/passes/findcall/cmd/findcall, defined in its
 entirety as:
diff --git a/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/flags.go b/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/flags.go
index d6c13f26..729ac3b4 100644
--- a/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/flags.go
+++ b/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/flags.go
@@ -11,41 +11,41 @@ import (
 	"encoding/json"
 	"flag"
 	"fmt"
+	"go/token"
 	"io"
+	"io/ioutil"
 	"log"
 	"os"
 	"strconv"
+	"strings"
 
 	"golang.org/x/tools/go/analysis"
 )
 
+// flags common to all {single,multi,unit}checkers.
+var (
+	JSON    = false // -json
+	Context = -1    // -c=N: if N>0, display offending line plus N lines of context
+)
+
 // Parse creates a flag for each of the analyzer's flags,
-// including (in multi mode) an --analysis.enable flag,
+// including (in multi mode) a flag named after the analyzer,
 // parses the flags, then filters and returns the list of
 // analyzers enabled by flags.
 func Parse(analyzers []*analysis.Analyzer, multi bool) []*analysis.Analyzer {
 	// Connect each analysis flag to the command line as -analysis.flag.
-	type analysisFlag struct {
-		Name  string
-		Bool  bool
-		Usage string
-	}
-	var analysisFlags []analysisFlag
-
 	enabled := make(map[*analysis.Analyzer]*triState)
 	for _, a := range analyzers {
 		var prefix string
 
-		// Add -analysis.enable flag.
+		// Add -NAME flag to enable it.
 		if multi {
 			prefix = a.Name + "."
 
 			enable := new(triState)
-			enableName := prefix + "enable"
 			enableUsage := "enable " + a.Name + " analysis"
-			flag.Var(enable, enableName, enableUsage)
+			flag.Var(enable, a.Name, enableUsage)
 			enabled[a] = enable
-			analysisFlags = append(analysisFlags, analysisFlag{enableName, true, enableUsage})
 		}
 
 		a.Flags.VisitAll(func(f *flag.Flag) {
@@ -56,12 +56,6 @@ func Parse(analyzers []*analysis.Analyzer, multi bool) []*analysis.Analyzer {
 
 			name := prefix + f.Name
 			flag.Var(f.Value, name, f.Usage)
-
-			var isBool bool
-			if b, ok := f.Value.(interface{ IsBoolFlag() bool }); ok {
-				isBool = b.IsBoolFlag()
-			}
-			analysisFlags = append(analysisFlags, analysisFlag{name, isBool, f.Usage})
 		})
 	}
 
@@ -69,20 +63,33 @@ func Parse(analyzers []*analysis.Analyzer, multi bool) []*analysis.Analyzer {
 	printflags := flag.Bool("flags", false, "print analyzer flags in JSON")
 	addVersionFlag()
 
+	// flags common to all checkers
+	flag.BoolVar(&JSON, "json", JSON, "emit JSON output")
+	flag.IntVar(&Context, "c", Context, `display offending line with this many lines of context`)
+
+	// Add shims for legacy vet flags to enable existing
+	// scripts that run vet to continue to work.
+	_ = flag.Bool("source", false, "no effect (deprecated)")
+	_ = flag.Bool("v", false, "no effect (deprecated)")
+	_ = flag.Bool("all", false, "no effect (deprecated)")
+	_ = flag.String("tags", "", "no effect (deprecated)")
+	for old, new := range vetLegacyFlags {
+		newFlag := flag.Lookup(new)
+		if newFlag != nil && flag.Lookup(old) == nil {
+			flag.Var(newFlag.Value, old, "deprecated alias for -"+new)
+		}
+	}
+
 	flag.Parse() // (ExitOnError)
 
 	// -flags: print flags so that go vet knows which ones are legitimate.
 	if *printflags {
-		data, err := json.MarshalIndent(analysisFlags, "", "\t")
-		if err != nil {
-			log.Fatal(err)
-		}
-		os.Stdout.Write(data)
+		printFlags()
 		os.Exit(0)
 	}
 
-	// If any --foo.enable flag is true,  run only those analyzers. Otherwise,
-	// if any --foo.enable flag is false, run all but those analyzers.
+	// If any -NAME flag is true,  run only those analyzers. Otherwise,
+	// if any -NAME flag is false, run all but those analyzers.
 	if multi {
 		var hasTrue, hasFalse bool
 		for _, ts := range enabled {
@@ -115,6 +122,33 @@ func Parse(analyzers []*analysis.Analyzer, multi bool) []*analysis.Analyzer {
 	return analyzers
 }
 
+func printFlags() {
+	type jsonFlag struct {
+		Name  string
+		Bool  bool
+		Usage string
+	}
+	var flags []jsonFlag = nil
+	flag.VisitAll(func(f *flag.Flag) {
+		// Don't report {single,multi}checker debugging
+		// flags as these have no effect on unitchecker
+		// (as invoked by 'go vet').
+		switch f.Name {
+		case "debug", "cpuprofile", "memprofile", "trace":
+			return
+		}
+
+		b, ok := f.Value.(interface{ IsBoolFlag() bool })
+		isBool := ok && b.IsBoolFlag()
+		flags = append(flags, jsonFlag{f.Name, isBool, f.Usage})
+	})
+	data, err := json.MarshalIndent(flags, "", "\t")
+	if err != nil {
+		log.Fatal(err)
+	}
+	os.Stdout.Write(data)
+}
+
 // addVersionFlag registers a -V flag that, if set,
 // prints the executable version and exits 0.
 //
@@ -195,7 +229,7 @@ func (ts *triState) Set(value string) error {
 	b, err := strconv.ParseBool(value)
 	if err != nil {
 		// This error message looks poor but package "flag" adds
-		// "invalid boolean value %q for -foo.enable: %s"
+		// "invalid boolean value %q for -NAME: %s"
 		return fmt.Errorf("want true or false")
 	}
 	if b {
@@ -221,3 +255,89 @@ func (ts *triState) String() string {
 func (ts triState) IsBoolFlag() bool {
 	return true
 }
+
+// Legacy flag support
+
+// vetLegacyFlags maps flags used by legacy vet to their corresponding
+// new names. The old names will continue to work.
+var vetLegacyFlags = map[string]string{
+	// Analyzer name changes
+	"bool":       "bools",
+	"buildtags":  "buildtag",
+	"methods":    "stdmethods",
+	"rangeloops": "loopclosure",
+
+	// Analyzer flags
+	"compositewhitelist":  "composites.whitelist",
+	"printfuncs":          "printf.funcs",
+	"shadowstrict":        "shadow.strict",
+	"unusedfuncs":         "unusedresult.funcs",
+	"unusedstringmethods": "unusedresult.stringmethods",
+}
+
+// ---- output helpers common to all drivers ----
+
+// PrintPlain prints a diagnostic in plain text form,
+// with context specified by the -c flag.
+func PrintPlain(fset *token.FileSet, diag analysis.Diagnostic) {
+	posn := fset.Position(diag.Pos)
+	fmt.Fprintf(os.Stderr, "%s: %s\n", posn, diag.Message)
+
+	// -c=N: show offending line plus N lines of context.
+	if Context >= 0 {
+		data, _ := ioutil.ReadFile(posn.Filename)
+		lines := strings.Split(string(data), "\n")
+		for i := posn.Line - Context; i <= posn.Line+Context; i++ {
+			if 1 <= i && i <= len(lines) {
+				fmt.Fprintf(os.Stderr, "%d\t%s\n", i, lines[i-1])
+			}
+		}
+	}
+}
+
+// A JSONTree is a mapping from package ID to analysis name to result.
+// Each result is either a jsonError or a list of jsonDiagnostic.
+type JSONTree map[string]map[string]interface{}
+
+// Add adds the result of analysis 'name' on package 'id'.
+// The result is either a list of diagnostics or an error.
+func (tree JSONTree) Add(fset *token.FileSet, id, name string, diags []analysis.Diagnostic, err error) {
+	var v interface{}
+	if err != nil {
+		type jsonError struct {
+			Err string `json:"error"`
+		}
+		v = jsonError{err.Error()}
+	} else if len(diags) > 0 {
+		type jsonDiagnostic struct {
+			Category string `json:"category,omitempty"`
+			Posn     string `json:"posn"`
+			Message  string `json:"message"`
+		}
+		var diagnostics []jsonDiagnostic
+		for _, f := range diags {
+			diagnostics = append(diagnostics, jsonDiagnostic{
+				Category: f.Category,
+				Posn:     fset.Position(f.Pos).String(),
+				Message:  f.Message,
+			})
+		}
+		v = diagnostics
+	}
+	if v != nil {
+		m, ok := tree[id]
+		if !ok {
+			m = make(map[string]interface{})
+			tree[id] = m
+		}
+		m[name] = v
+	}
+}
+
+func (tree JSONTree) Print() {
+	data, err := json.MarshalIndent(tree, "", "\t")
+	if err != nil {
+		log.Panicf("internal error: JSON marshalling failed: %v", err)
+	}
+	fmt.Printf("%s\n", data)
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/flags_test.go b/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/flags_test.go
index d2310acf..1f055dde 100644
--- a/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/flags_test.go
+++ b/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/flags_test.go
@@ -45,11 +45,11 @@ func TestExec(t *testing.T) {
 		want  string
 	}{
 		{"", "[a1 a2 a3]"},
-		{"-a1.enable=0", "[a2 a3]"},
-		{"-a1.enable=1", "[a1]"},
-		{"-a1.enable", "[a1]"},
-		{"-a1.enable=1 -a3.enable=1", "[a1 a3]"},
-		{"-a1.enable=1 -a3.enable=0", "[a1]"},
+		{"-a1=0", "[a2 a3]"},
+		{"-a1=1", "[a1]"},
+		{"-a1", "[a1]"},
+		{"-a1=1 -a3=1", "[a1 a3]"},
+		{"-a1=1 -a3=0", "[a1]"},
 	} {
 		cmd := exec.Command(progname, "-test.run=TestExec")
 		cmd.Env = append(os.Environ(), "ANALYSISFLAGS_CHILD=1", "FLAGS="+test.flags)
diff --git a/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/help.go b/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/help.go
new file mode 100644
index 00000000..66aa6245
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/internal/analysisflags/help.go
@@ -0,0 +1,89 @@
+package analysisflags
+
+import (
+	"flag"
+	"fmt"
+	"log"
+	"sort"
+	"strings"
+
+	"golang.org/x/tools/go/analysis"
+)
+
+const help = `PROGNAME is a tool for static analysis of Go programs.
+
+PROGNAME examines Go source code and reports suspicious constructs,
+such as Printf calls whose arguments do not align with the format
+string. It uses heuristics that do not guarantee all reports are
+genuine problems, but it can find errors not caught by the compilers.
+`
+
+// Help implements the help subcommand for a multichecker or vet-lite
+// style command. The optional args specify the analyzers to describe.
+// Help calls log.Fatal if no such analyzer exists.
+func Help(progname string, analyzers []*analysis.Analyzer, args []string) {
+	// No args: show summary of all analyzers.
+	if len(args) == 0 {
+		fmt.Println(strings.Replace(help, "PROGNAME", progname, -1))
+		fmt.Println("Registered analyzers:")
+		fmt.Println()
+		sort.Slice(analyzers, func(i, j int) bool {
+			return analyzers[i].Name < analyzers[j].Name
+		})
+		for _, a := range analyzers {
+			title := strings.Split(a.Doc, "\n\n")[0]
+			fmt.Printf("    %-12s %s\n", a.Name, title)
+		}
+		fmt.Println("\nBy default all analyzers are run.")
+		fmt.Println("To select specific analyzers, use the -NAME flag for each one,")
+		fmt.Println(" or -NAME=false to run all analyzers not explicitly disabled.")
+
+		// Show only the core command-line flags.
+		fmt.Println("\nCore flags:")
+		fmt.Println()
+		fs := flag.NewFlagSet("", flag.ExitOnError)
+		flag.VisitAll(func(f *flag.Flag) {
+			if !strings.Contains(f.Name, ".") {
+				fs.Var(f.Value, f.Name, f.Usage)
+			}
+		})
+		fs.PrintDefaults()
+
+		fmt.Printf("\nTo see details and flags of a specific analyzer, run '%s help name'.\n", progname)
+
+		return
+	}
+
+	// Show help on specific analyzer(s).
+outer:
+	for _, arg := range args {
+		for _, a := range analyzers {
+			if a.Name == arg {
+				paras := strings.Split(a.Doc, "\n\n")
+				title := paras[0]
+				fmt.Printf("%s: %s\n", a.Name, title)
+
+				// Show only the flags relating to this analysis,
+				// properly prefixed.
+				first := true
+				fs := flag.NewFlagSet(a.Name, flag.ExitOnError)
+				a.Flags.VisitAll(func(f *flag.Flag) {
+					if first {
+						first = false
+						fmt.Println("\nAnalyzer flags:")
+						fmt.Println()
+					}
+					fs.Var(f.Value, a.Name+"."+f.Name, f.Usage)
+				})
+				fs.PrintDefaults()
+
+				if len(paras) > 1 {
+					fmt.Printf("\n%s\n", strings.Join(paras[1:], "\n\n"))
+				}
+
+				continue outer
+			}
+		}
+		log.Fatalf("Analyzer %q not registered", arg)
+	}
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/internal/checker/checker.go b/vendor/golang.org/x/tools/go/analysis/internal/checker/checker.go
index a7c78269..6c651796 100644
--- a/vendor/golang.org/x/tools/go/analysis/internal/checker/checker.go
+++ b/vendor/golang.org/x/tools/go/analysis/internal/checker/checker.go
@@ -7,12 +7,10 @@ package checker
 import (
 	"bytes"
 	"encoding/gob"
-	"encoding/json"
 	"flag"
 	"fmt"
 	"go/token"
 	"go/types"
-	"io/ioutil"
 	"log"
 	"os"
 	"reflect"
@@ -25,12 +23,11 @@ import (
 	"time"
 
 	"golang.org/x/tools/go/analysis"
+	"golang.org/x/tools/go/analysis/internal/analysisflags"
 	"golang.org/x/tools/go/packages"
 )
 
 var (
-	JSON = false
-
 	// Debug is a set of single-letter flags:
 	//
 	//	f	show [f]acts as they are created
@@ -41,17 +38,16 @@ var (
 	//
 	Debug = ""
 
-	Context = -1 // if >=0, display offending line plus this many lines of context
-
 	// Log files for optional performance tracing.
 	CPUProfile, MemProfile, Trace string
 )
 
 // RegisterFlags registers command-line flags used the analysis driver.
 func RegisterFlags() {
-	flag.BoolVar(&JSON, "json", JSON, "emit JSON output")
+	// When adding flags here, remember to update
+	// the list of suppressed flags in analysisflags.
+
 	flag.StringVar(&Debug, "debug", Debug, `debug flags, any subset of "lpsv"`)
-	flag.IntVar(&Context, "c", Context, `display offending line with this many lines of context`)
 
 	flag.StringVar(&CPUProfile, "cpuprofile", "", "write CPU profile to this file")
 	flag.StringVar(&MemProfile, "memprofile", "", "write memory profile to this file")
@@ -63,7 +59,8 @@ func RegisterFlags() {
 // Analysis flags must already have been set.
 // It provides most of the logic for the main functions of both the
 // singlechecker and the multi-analysis commands.
-func Run(args []string, analyzers []*analysis.Analyzer) error {
+// It returns the appropriate exit code.
+func Run(args []string, analyzers []*analysis.Analyzer) (exitcode int) {
 	if CPUProfile != "" {
 		f, err := os.Create(CPUProfile)
 		if err != nil {
@@ -118,15 +115,14 @@ func Run(args []string, analyzers []*analysis.Analyzer) error {
 	allSyntax := needFacts(analyzers)
 	initial, err := load(args, allSyntax)
 	if err != nil {
-		return err
+		log.Print(err)
+		return 1 // load errors
 	}
 
-	roots := analyze(initial, analyzers)
-
 	// Print the results.
-	printDiagnostics(roots)
+	roots := analyze(initial, analyzers)
 
-	return nil
+	return printDiagnostics(roots)
 }
 
 // load loads the initial packages.
@@ -147,6 +143,9 @@ func load(patterns []string, allSyntax bool) ([]*packages.Package, error) {
 			err = fmt.Errorf("error during loading")
 		}
 	}
+	if len(initial) == 0 {
+		err = fmt.Errorf("%s matched no packages", strings.Join(patterns, " "))
+	}
 	return initial, err
 }
 
@@ -250,7 +249,12 @@ func analyze(pkgs []*packages.Package, analyzers []*analysis.Analyzer) []*action
 // printDiagnostics prints the diagnostics for the root packages in either
 // plain text or JSON format. JSON format also includes errors for any
 // dependencies.
-func printDiagnostics(roots []*action) {
+//
+// It returns the exitcode: in plain mode, 0 for success, 1 for analysis
+// errors, and 3 for diagnostics. We avoid 2 since the flag package uses
+// it. JSON mode always succeeds at printing errors and diagnostics in a
+// structured form to stdout.
+func printDiagnostics(roots []*action) (exitcode int) {
 	// Print the output.
 	//
 	// Print diagnostics only for root packages,
@@ -268,50 +272,18 @@ func printDiagnostics(roots []*action) {
 		}
 	}
 
-	if JSON {
-		tree := make(map[string]map[string]interface{}) // ID -> analysis -> result
-
+	if analysisflags.JSON {
+		// JSON output
+		tree := make(analysisflags.JSONTree)
 		print = func(act *action) {
-			m, existing := tree[act.pkg.ID]
-			if !existing {
-				m = make(map[string]interface{})
-				// Insert m into tree later iff non-empty.
-			}
-			if act.err != nil {
-				type jsonError struct {
-					Err string `json:"error"`
-				}
-				m[act.a.Name] = jsonError{act.err.Error()}
-			} else if act.isroot {
-				type jsonDiagnostic struct {
-					Category string `json:"category,omitempty"`
-					Posn     string `json:"posn"`
-					Message  string `json:"message"`
-				}
-				var diagnostics []jsonDiagnostic
-				for _, f := range act.diagnostics {
-					diagnostics = append(diagnostics, jsonDiagnostic{
-						Category: f.Category,
-						Posn:     act.pkg.Fset.Position(f.Pos).String(),
-						Message:  f.Message,
-					})
-				}
-				if diagnostics != nil {
-					m[act.a.Name] = diagnostics
-				}
-			}
-			if !existing && len(m) > 0 {
-				tree[act.pkg.ID] = m
+			var diags []analysis.Diagnostic
+			if act.isroot {
+				diags = act.diagnostics
 			}
+			tree.Add(act.pkg.Fset, act.pkg.ID, act.a.Name, diags, act.err)
 		}
 		visitAll(roots)
-
-		data, err := json.MarshalIndent(tree, "", "\t")
-		if err != nil {
-			log.Panicf("internal error: JSON marshalling failed: %v", err)
-		}
-		os.Stdout.Write(data)
-		fmt.Println()
+		tree.Print()
 	} else {
 		// plain text output
 
@@ -328,37 +300,30 @@ func printDiagnostics(roots []*action) {
 		print = func(act *action) {
 			if act.err != nil {
 				fmt.Fprintf(os.Stderr, "%s: %v\n", act.a.Name, act.err)
+				exitcode = 1 // analysis failed, at least partially
 				return
 			}
 			if act.isroot {
-				for _, f := range act.diagnostics {
+				for _, diag := range act.diagnostics {
 					// We don't display a.Name/f.Category
 					// as most users don't care.
 
-					posn := act.pkg.Fset.Position(f.Pos)
-
-					k := key{posn, act.a, f.Message}
+					posn := act.pkg.Fset.Position(diag.Pos)
+					k := key{posn, act.a, diag.Message}
 					if seen[k] {
 						continue // duplicate
 					}
 					seen[k] = true
 
-					fmt.Fprintf(os.Stderr, "%s: %s\n", posn, f.Message)
-
-					// -c=0: show offending line of code in context.
-					if Context >= 0 {
-						data, _ := ioutil.ReadFile(posn.Filename)
-						lines := strings.Split(string(data), "\n")
-						for i := posn.Line - Context; i <= posn.Line+Context; i++ {
-							if 1 <= i && i <= len(lines) {
-								fmt.Fprintf(os.Stderr, "%d\t%s\n", i, lines[i-1])
-							}
-						}
-					}
+					analysisflags.PrintPlain(act.pkg.Fset, diag)
 				}
 			}
 		}
 		visitAll(roots)
+
+		if exitcode == 0 && len(seen) > 0 {
+			exitcode = 3 // successfuly produced diagnostics
+		}
 	}
 
 	// Print timing info.
@@ -386,6 +351,8 @@ func printDiagnostics(roots []*action) {
 			}
 		}
 	}
+
+	return exitcode
 }
 
 // needFacts reports whether any analysis required by the specified set
diff --git a/vendor/golang.org/x/tools/go/analysis/internal/facts/facts.go b/vendor/golang.org/x/tools/go/analysis/internal/facts/facts.go
new file mode 100644
index 00000000..468f1489
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/internal/facts/facts.go
@@ -0,0 +1,299 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package facts defines a serializable set of analysis.Fact.
+//
+// It provides a partial implementation of the Fact-related parts of the
+// analysis.Pass interface for use in analysis drivers such as "go vet"
+// and other build systems.
+//
+// The serial format is unspecified and may change, so the same version
+// of this package must be used for reading and writing serialized facts.
+//
+// The handling of facts in the analysis system parallels the handling
+// of type information in the compiler: during compilation of package P,
+// the compiler emits an export data file that describes the type of
+// every object (named thing) defined in package P, plus every object
+// indirectly reachable from one of those objects. Thus the downstream
+// compiler of package Q need only load one export data file per direct
+// import of Q, and it will learn everything about the API of package P
+// and everything it needs to know about the API of P's dependencies.
+//
+// Similarly, analysis of package P emits a fact set containing facts
+// about all objects exported from P, plus additional facts about only
+// those objects of P's dependencies that are reachable from the API of
+// package P; the downstream analysis of Q need only load one fact set
+// per direct import of Q.
+//
+// The notion of "exportedness" that matters here is that of the
+// compiler. According to the language spec, a method pkg.T.f is
+// unexported simply because its name starts with lowercase. But the
+// compiler must nonethless export f so that downstream compilations can
+// accurately ascertain whether pkg.T implements an interface pkg.I
+// defined as interface{f()}. Exported thus means "described in export
+// data".
+//
+package facts
+
+import (
+	"bytes"
+	"encoding/gob"
+	"fmt"
+	"go/types"
+	"io/ioutil"
+	"log"
+	"reflect"
+	"sort"
+	"sync"
+
+	"golang.org/x/tools/go/analysis"
+	"golang.org/x/tools/go/types/objectpath"
+)
+
+const debug = false
+
+// A Set is a set of analysis.Facts.
+//
+// Decode creates a Set of facts by reading from the imports of a given
+// package, and Encode writes out the set. Between these operation,
+// the Import and Export methods will query and update the set.
+//
+// All of Set's methods except String are safe to call concurrently.
+type Set struct {
+	pkg *types.Package
+	mu  sync.Mutex
+	m   map[key]analysis.Fact
+}
+
+type key struct {
+	pkg *types.Package
+	obj types.Object // (object facts only)
+	t   reflect.Type
+}
+
+// ImportObjectFact implements analysis.Pass.ImportObjectFact.
+func (s *Set) ImportObjectFact(obj types.Object, ptr analysis.Fact) bool {
+	if obj == nil {
+		panic("nil object")
+	}
+	key := key{pkg: obj.Pkg(), obj: obj, t: reflect.TypeOf(ptr)}
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	if v, ok := s.m[key]; ok {
+		reflect.ValueOf(ptr).Elem().Set(reflect.ValueOf(v).Elem())
+		return true
+	}
+	return false
+}
+
+// ExportObjectFact implements analysis.Pass.ExportObjectFact.
+func (s *Set) ExportObjectFact(obj types.Object, fact analysis.Fact) {
+	if obj.Pkg() != s.pkg {
+		log.Panicf("in package %s: ExportObjectFact(%s, %T): can't set fact on object belonging another package",
+			s.pkg, obj, fact)
+	}
+	key := key{pkg: obj.Pkg(), obj: obj, t: reflect.TypeOf(fact)}
+	s.mu.Lock()
+	s.m[key] = fact // clobber any existing entry
+	s.mu.Unlock()
+}
+
+// ImportPackageFact implements analysis.Pass.ImportPackageFact.
+func (s *Set) ImportPackageFact(pkg *types.Package, ptr analysis.Fact) bool {
+	if pkg == nil {
+		panic("nil package")
+	}
+	key := key{pkg: pkg, t: reflect.TypeOf(ptr)}
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	if v, ok := s.m[key]; ok {
+		reflect.ValueOf(ptr).Elem().Set(reflect.ValueOf(v).Elem())
+		return true
+	}
+	return false
+}
+
+// ExportPackageFact implements analysis.Pass.ExportPackageFact.
+func (s *Set) ExportPackageFact(fact analysis.Fact) {
+	key := key{pkg: s.pkg, t: reflect.TypeOf(fact)}
+	s.mu.Lock()
+	s.m[key] = fact // clobber any existing entry
+	s.mu.Unlock()
+}
+
+// gobFact is the Gob declaration of a serialized fact.
+type gobFact struct {
+	PkgPath string          // path of package
+	Object  objectpath.Path // optional path of object relative to package itself
+	Fact    analysis.Fact   // type and value of user-defined Fact
+}
+
+// Decode decodes all the facts relevant to the analysis of package pkg.
+// The read function reads serialized fact data from an external source
+// for one of of pkg's direct imports. The empty file is a valid
+// encoding of an empty fact set.
+//
+// It is the caller's responsibility to call gob.Register on all
+// necessary fact types.
+func Decode(pkg *types.Package, read func(packagePath string) ([]byte, error)) (*Set, error) {
+	// Compute the import map for this package.
+	// See the package doc comment.
+	packages := importMap(pkg.Imports())
+
+	// Read facts from imported packages.
+	// Facts may describe indirectly imported packages, or their objects.
+	m := make(map[key]analysis.Fact) // one big bucket
+	for _, imp := range pkg.Imports() {
+		logf := func(format string, args ...interface{}) {
+			if debug {
+				prefix := fmt.Sprintf("in %s, importing %s: ",
+					pkg.Path(), imp.Path())
+				log.Print(prefix, fmt.Sprintf(format, args...))
+			}
+		}
+
+		// Read the gob-encoded facts.
+		data, err := read(imp.Path())
+		if err != nil {
+			return nil, fmt.Errorf("in %s, can't import facts for package %q: %v",
+				pkg.Path(), imp.Path(), err)
+		}
+		if len(data) == 0 {
+			continue // no facts
+		}
+		var gobFacts []gobFact
+		if err := gob.NewDecoder(bytes.NewReader(data)).Decode(&gobFacts); err != nil {
+			return nil, fmt.Errorf("decoding facts for %q: %v", imp.Path(), err)
+		}
+		if debug {
+			logf("decoded %d facts: %v", len(gobFacts), gobFacts)
+		}
+
+		// Parse each one into a key and a Fact.
+		for _, f := range gobFacts {
+			factPkg := packages[f.PkgPath]
+			if factPkg == nil {
+				// Fact relates to a dependency that was
+				// unused in this translation unit. Skip.
+				logf("no package %q; discarding %v", f.PkgPath, f.Fact)
+				continue
+			}
+			key := key{pkg: factPkg, t: reflect.TypeOf(f.Fact)}
+			if f.Object != "" {
+				// object fact
+				obj, err := objectpath.Object(factPkg, f.Object)
+				if err != nil {
+					// (most likely due to unexported object)
+					// TODO(adonovan): audit for other possibilities.
+					logf("no object for path: %v; discarding %s", err, f.Fact)
+					continue
+				}
+				key.obj = obj
+				logf("read %T fact %s for %v", f.Fact, f.Fact, key.obj)
+			} else {
+				// package fact
+				logf("read %T fact %s for %v", f.Fact, f.Fact, factPkg)
+			}
+			m[key] = f.Fact
+		}
+	}
+
+	return &Set{pkg: pkg, m: m}, nil
+}
+
+// Encode encodes a set of facts to a memory buffer.
+//
+// It may fail if one of the Facts could not be gob-encoded, but this is
+// a sign of a bug in an Analyzer.
+func (s *Set) Encode() []byte {
+
+	// TODO(adonovan): opt: use a more efficient encoding
+	// that avoids repeating PkgPath for each fact.
+
+	// Gather all facts, including those from imported packages.
+	var gobFacts []gobFact
+
+	s.mu.Lock()
+	for k, fact := range s.m {
+		if debug {
+			log.Printf("%v => %s\n", k, fact)
+		}
+		var object objectpath.Path
+		if k.obj != nil {
+			path, err := objectpath.For(k.obj)
+			if err != nil {
+				if debug {
+					log.Printf("discarding fact %s about %s\n", fact, k.obj)
+				}
+				continue // object not accessible from package API; discard fact
+			}
+			object = path
+		}
+		gobFacts = append(gobFacts, gobFact{
+			PkgPath: k.pkg.Path(),
+			Object:  object,
+			Fact:    fact,
+		})
+	}
+	s.mu.Unlock()
+
+	// Sort facts by (package, object, type) for determinism.
+	sort.Slice(gobFacts, func(i, j int) bool {
+		x, y := gobFacts[i], gobFacts[j]
+		if x.PkgPath != y.PkgPath {
+			return x.PkgPath < y.PkgPath
+		}
+		if x.Object != y.Object {
+			return x.Object < y.Object
+		}
+		tx := reflect.TypeOf(x.Fact)
+		ty := reflect.TypeOf(y.Fact)
+		if tx != ty {
+			return tx.String() < ty.String()
+		}
+		return false // equal
+	})
+
+	var buf bytes.Buffer
+	if len(gobFacts) > 0 {
+		if err := gob.NewEncoder(&buf).Encode(gobFacts); err != nil {
+			// Fact encoding should never fail. Identify the culprit.
+			for _, gf := range gobFacts {
+				if err := gob.NewEncoder(ioutil.Discard).Encode(gf); err != nil {
+					fact := gf.Fact
+					pkgpath := reflect.TypeOf(fact).Elem().PkgPath()
+					log.Panicf("internal error: gob encoding of analysis fact %s failed: %v; please report a bug against fact %T in package %q",
+						fact, err, fact, pkgpath)
+				}
+			}
+		}
+	}
+
+	if debug {
+		log.Printf("package %q: encode %d facts, %d bytes\n",
+			s.pkg.Path(), len(gobFacts), buf.Len())
+	}
+
+	return buf.Bytes()
+}
+
+// String is provided only for debugging, and must not be called
+// concurrent with any Import/Export method.
+func (s *Set) String() string {
+	var buf bytes.Buffer
+	buf.WriteString("{")
+	for k, f := range s.m {
+		if buf.Len() > 1 {
+			buf.WriteString(", ")
+		}
+		if k.obj != nil {
+			buf.WriteString(k.obj.String())
+		} else {
+			buf.WriteString(k.pkg.Path())
+		}
+		fmt.Fprintf(&buf, ": %v", f)
+	}
+	buf.WriteString("}")
+	return buf.String()
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/internal/facts/facts_test.go b/vendor/golang.org/x/tools/go/analysis/internal/facts/facts_test.go
new file mode 100644
index 00000000..e21a4982
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/internal/facts/facts_test.go
@@ -0,0 +1,174 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package facts_test
+
+import (
+	"encoding/gob"
+	"fmt"
+	"go/token"
+	"go/types"
+	"os"
+	"testing"
+
+	"golang.org/x/tools/go/analysis/analysistest"
+	"golang.org/x/tools/go/analysis/internal/facts"
+	"golang.org/x/tools/go/packages"
+)
+
+type myFact struct {
+	S string
+}
+
+func (f *myFact) String() string { return fmt.Sprintf("myFact(%s)", f.S) }
+func (f *myFact) AFact()         {}
+
+func TestEncodeDecode(t *testing.T) {
+	gob.Register(new(myFact))
+
+	// c -> b -> a, a2
+	// c does not directly depend on a, but it indirectly uses a.T.
+	//
+	// Package a2 is never loaded directly so it is incomplete.
+	//
+	// We use only types in this example because we rely on
+	// types.Eval to resolve the lookup expressions, and it only
+	// works for types. This is a definite gap in the typechecker API.
+	files := map[string]string{
+		"a/a.go":  `package a; type A int; type T int`,
+		"a2/a.go": `package a2; type A2 int; type Unneeded int`,
+		"b/b.go":  `package b; import ("a"; "a2"); type B chan a2.A2; type F func() a.T`,
+		"c/c.go":  `package c; import "b"; type C []b.B`,
+	}
+	dir, cleanup, err := analysistest.WriteFiles(files)
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer cleanup()
+
+	// factmap represents the passing of encoded facts from one
+	// package to another. In practice one would use the file system.
+	factmap := make(map[string][]byte)
+	read := func(path string) ([]byte, error) { return factmap[path], nil }
+
+	// In the following table, we analyze packages (a, b, c) in order,
+	// look up various objects accessible within each package,
+	// and see if they have a fact.  The "analysis" exports a fact
+	// for every object at package level.
+	//
+	// Note: Loop iterations are not independent test cases;
+	// order matters, as we populate factmap.
+	type lookups []struct {
+		objexpr string
+		want    string
+	}
+	for _, test := range []struct {
+		path    string
+		lookups lookups
+	}{
+		{"a", lookups{
+			{"A", "myFact(a.A)"},
+		}},
+		{"b", lookups{
+			{"a.A", "myFact(a.A)"},
+			{"a.T", "myFact(a.T)"},
+			{"B", "myFact(b.B)"},
+			{"F", "myFact(b.F)"},
+			{"F(nil)()", "myFact(a.T)"}, // (result type of b.F)
+		}},
+		{"c", lookups{
+			{"b.B", "myFact(b.B)"},
+			{"b.F", "myFact(b.F)"},
+			//{"b.F(nil)()", "myFact(a.T)"}, // no fact; TODO(adonovan): investigate
+			{"C", "myFact(c.C)"},
+			{"C{}[0]", "myFact(b.B)"},
+			{"<-(C{}[0])", "no fact"}, // object but no fact (we never "analyze" a2)
+		}},
+	} {
+		// load package
+		pkg, err := load(dir, test.path)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// decode
+		facts, err := facts.Decode(pkg, read)
+		if err != nil {
+			t.Fatalf("Decode failed: %v", err)
+		}
+		if true {
+			t.Logf("decode %s facts = %v", pkg.Path(), facts) // show all facts
+		}
+
+		// export
+		// (one fact for each package-level object)
+		scope := pkg.Scope()
+		for _, name := range scope.Names() {
+			obj := scope.Lookup(name)
+			fact := &myFact{obj.Pkg().Name() + "." + obj.Name()}
+			facts.ExportObjectFact(obj, fact)
+		}
+
+		// import
+		// (after export, because an analyzer may import its own facts)
+		for _, lookup := range test.lookups {
+			fact := new(myFact)
+			var got string
+			if obj := find(pkg, lookup.objexpr); obj == nil {
+				got = "no object"
+			} else if facts.ImportObjectFact(obj, fact) {
+				got = fact.String()
+			} else {
+				got = "no fact"
+			}
+			if got != lookup.want {
+				t.Errorf("in %s, ImportObjectFact(%s, %T) = %s, want %s",
+					pkg.Path(), lookup.objexpr, fact, got, lookup.want)
+			}
+		}
+
+		// encode
+		factmap[pkg.Path()] = facts.Encode()
+	}
+}
+
+func find(p *types.Package, expr string) types.Object {
+	// types.Eval only allows us to compute a TypeName object for an expression.
+	// TODO(adonovan): support other expressions that denote an object:
+	// - an identifier (or qualified ident) for a func, const, or var
+	// - new(T).f for a field or method
+	// I've added CheckExpr in https://go-review.googlesource.com/c/go/+/144677.
+	// If that becomes available, use it.
+
+	// Choose an arbitrary position within the (single-file) package
+	// so that we are within the scope of its import declarations.
+	somepos := p.Scope().Lookup(p.Scope().Names()[0]).Pos()
+	tv, err := types.Eval(token.NewFileSet(), p, somepos, expr)
+	if err != nil {
+		return nil
+	}
+	if n, ok := tv.Type.(*types.Named); ok {
+		return n.Obj()
+	}
+	return nil
+}
+
+func load(dir string, path string) (*types.Package, error) {
+	cfg := &packages.Config{
+		Mode: packages.LoadSyntax,
+		Dir:  dir,
+		Env:  append(os.Environ(), "GOPATH="+dir, "GO111MODULE=off", "GOPROXY=off"),
+	}
+	pkgs, err := packages.Load(cfg, path)
+	if err != nil {
+		return nil, err
+	}
+	if packages.PrintErrors(pkgs) > 0 {
+		return nil, fmt.Errorf("packages had errors")
+	}
+	if len(pkgs) == 0 {
+		return nil, fmt.Errorf("no package matched %s", path)
+	}
+	return pkgs[0].Types, nil
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/internal/facts/imports.go b/vendor/golang.org/x/tools/go/analysis/internal/facts/imports.go
new file mode 100644
index 00000000..34740f48
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/internal/facts/imports.go
@@ -0,0 +1,88 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package facts
+
+import "go/types"
+
+// importMap computes the import map for a package by traversing the
+// entire exported API each of its imports.
+//
+// This is a workaround for the fact that we cannot access the map used
+// internally by the types.Importer returned by go/importer. The entries
+// in this map are the packages and objects that may be relevant to the
+// current analysis unit.
+//
+// Packages in the map that are only indirectly imported may be
+// incomplete (!pkg.Complete()).
+//
+func importMap(imports []*types.Package) map[string]*types.Package {
+	objects := make(map[types.Object]bool)
+	packages := make(map[string]*types.Package)
+
+	var addObj func(obj types.Object) bool
+	var addType func(T types.Type)
+
+	addObj = func(obj types.Object) bool {
+		if !objects[obj] {
+			objects[obj] = true
+			addType(obj.Type())
+			if pkg := obj.Pkg(); pkg != nil {
+				packages[pkg.Path()] = pkg
+			}
+			return true
+		}
+		return false
+	}
+
+	addType = func(T types.Type) {
+		switch T := T.(type) {
+		case *types.Basic:
+			// nop
+		case *types.Named:
+			if addObj(T.Obj()) {
+				for i := 0; i < T.NumMethods(); i++ {
+					addObj(T.Method(i))
+				}
+			}
+		case *types.Pointer:
+			addType(T.Elem())
+		case *types.Slice:
+			addType(T.Elem())
+		case *types.Array:
+			addType(T.Elem())
+		case *types.Chan:
+			addType(T.Elem())
+		case *types.Map:
+			addType(T.Key())
+			addType(T.Elem())
+		case *types.Signature:
+			addType(T.Params())
+			addType(T.Results())
+		case *types.Struct:
+			for i := 0; i < T.NumFields(); i++ {
+				addObj(T.Field(i))
+			}
+		case *types.Tuple:
+			for i := 0; i < T.Len(); i++ {
+				addObj(T.At(i))
+			}
+		case *types.Interface:
+			for i := 0; i < T.NumMethods(); i++ {
+				addObj(T.Method(i))
+			}
+		}
+	}
+
+	for _, imp := range imports {
+		packages[imp.Path()] = imp
+
+		scope := imp.Scope()
+		for _, name := range scope.Names() {
+			addObj(scope.Lookup(name))
+		}
+	}
+
+	return packages
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/multichecker/multichecker.go b/vendor/golang.org/x/tools/go/analysis/multichecker/multichecker.go
index 27406fa0..3c62be58 100644
--- a/vendor/golang.org/x/tools/go/analysis/multichecker/multichecker.go
+++ b/vendor/golang.org/x/tools/go/analysis/multichecker/multichecker.go
@@ -13,35 +13,18 @@ import (
 	"log"
 	"os"
 	"path/filepath"
-	"sort"
 	"strings"
 
 	"golang.org/x/tools/go/analysis"
 	"golang.org/x/tools/go/analysis/internal/analysisflags"
 	"golang.org/x/tools/go/analysis/internal/checker"
+	"golang.org/x/tools/go/analysis/unitchecker"
 )
 
-// TODO(adonovan): document (and verify) the exit codes:
-// "Vet's exit code is 2 for erroneous invocation of the tool, 1 if a
-// problem was reported, and 0 otherwise. Note that the tool does not
-// check every possible problem and depends on unreliable heuristics
-// so it should be used as guidance only, not as a firm indicator of
-// program correctness."
-
-const usage = `PROGNAME is a tool for static analysis of Go programs.
-
-PROGNAME examines Go source code and reports suspicious constructs, such as Printf
-calls whose arguments do not align with the format string. It uses heuristics
-that do not guarantee all reports are genuine problems, but it can find errors
-not caught by the compilers.
-
-Usage: PROGNAME [-flag] [package]
-`
-
 func Main(analyzers ...*analysis.Analyzer) {
 	progname := filepath.Base(os.Args[0])
 	log.SetFlags(0)
-	log.SetPrefix(progname + ": ")
+	log.SetPrefix(progname + ": ") // e.g. "vet: "
 
 	if err := analysis.Validate(analyzers); err != nil {
 		log.Fatal(err)
@@ -53,85 +36,25 @@ func Main(analyzers ...*analysis.Analyzer) {
 
 	args := flag.Args()
 	if len(args) == 0 {
-		fmt.Fprintln(os.Stderr, strings.Replace(usage, "PROGNAME", progname, -1))
-		fmt.Fprintf(os.Stderr, "Run '%[1]s help' for more detail,\n"+
-			" or '%[1]s help name' for details and flags of a specific analyzer.\n",
-			progname)
+		fmt.Fprintf(os.Stderr, `%[1]s is a tool for static analysis of Go programs.
+
+Usage: %[1]s [-flag] [package]
+
+Run '%[1]s help' for more detail,
+ or '%[1]s help name' for details and flags of a specific analyzer.
+`, progname)
 		os.Exit(1)
 	}
 
 	if args[0] == "help" {
-		help(progname, analyzers, args[1:])
+		analysisflags.Help(progname, analyzers, args[1:])
 		os.Exit(0)
 	}
 
-	if err := checker.Run(args, analyzers); err != nil {
-		log.Fatal(err)
-	}
-}
-
-func help(progname string, analyzers []*analysis.Analyzer, args []string) {
-	// No args: show summary of all analyzers.
-	if len(args) == 0 {
-		fmt.Println(strings.Replace(usage, "PROGNAME", progname, -1))
-		fmt.Println("Registered analyzers:")
-		fmt.Println()
-		sort.Slice(analyzers, func(i, j int) bool {
-			return analyzers[i].Name < analyzers[j].Name
-		})
-		for _, a := range analyzers {
-			title := strings.Split(a.Doc, "\n\n")[0]
-			fmt.Printf("    %-12s %s\n", a.Name, title)
-		}
-		fmt.Println("\nBy default all analyzers are run.")
-		fmt.Println("To select specific analyzers, use the -NAME.enable flag for each one.")
-
-		// Show only the core command-line flags.
-		fmt.Println("\nCore flags:")
-		fmt.Println()
-		fs := flag.NewFlagSet("", flag.ExitOnError)
-		flag.VisitAll(func(f *flag.Flag) {
-			if !strings.Contains(f.Name, ".") {
-				fs.Var(f.Value, f.Name, f.Usage)
-			}
-		})
-		fs.PrintDefaults()
-
-		fmt.Printf("\nTo see details and flags of a specific analyzer, run '%s help name'.\n", progname)
-
-		return
+	if len(args) == 1 && strings.HasSuffix(args[0], ".cfg") {
+		unitchecker.Run(args[0], analyzers)
+		panic("unreachable")
 	}
 
-	// Show help on specific analyzer(s).
-outer:
-	for _, arg := range args {
-		for _, a := range analyzers {
-			if a.Name == arg {
-				paras := strings.Split(a.Doc, "\n\n")
-				title := paras[0]
-				fmt.Printf("%s: %s\n", a.Name, title)
-
-				// Show only the flags relating to this analysis,
-				// properly prefixed.
-				first := true
-				fs := flag.NewFlagSet(a.Name, flag.ExitOnError)
-				a.Flags.VisitAll(func(f *flag.Flag) {
-					if first {
-						first = false
-						fmt.Println("\nAnalyzer flags:")
-						fmt.Println()
-					}
-					fs.Var(f.Value, a.Name+"."+f.Name, f.Usage)
-				})
-				fs.PrintDefaults()
-
-				if len(paras) > 1 {
-					fmt.Printf("\n%s\n", strings.Join(paras[1:], "\n\n"))
-				}
-
-				continue outer
-			}
-		}
-		log.Fatalf("Analyzer %q not registered", arg)
-	}
+	os.Exit(checker.Run(args, analyzers))
 }
diff --git a/vendor/golang.org/x/tools/go/analysis/multichecker/multichecker_test.go b/vendor/golang.org/x/tools/go/analysis/multichecker/multichecker_test.go
new file mode 100644
index 00000000..72500722
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/multichecker/multichecker_test.go
@@ -0,0 +1,82 @@
+// +build go1.12
+
+package multichecker_test
+
+import (
+	"fmt"
+	"os"
+	"os/exec"
+	"runtime"
+	"testing"
+
+	"golang.org/x/tools/go/analysis"
+	"golang.org/x/tools/go/analysis/multichecker"
+	"golang.org/x/tools/go/analysis/passes/findcall"
+)
+
+func main() {
+	fail := &analysis.Analyzer{
+		Name: "fail",
+		Doc:  "always fail on a package 'sort'",
+		Run: func(pass *analysis.Pass) (interface{}, error) {
+			if pass.Pkg.Path() == "sort" {
+				return nil, fmt.Errorf("failed")
+			}
+			return nil, nil
+		},
+	}
+	multichecker.Main(findcall.Analyzer, fail)
+}
+
+// TestExitCode ensures that analysis failures are reported correctly.
+// This test fork/execs the main function above.
+func TestExitCode(t *testing.T) {
+	if runtime.GOOS != "linux" {
+		t.Skipf("skipping fork/exec test on this platform")
+	}
+
+	if os.Getenv("MULTICHECKER_CHILD") == "1" {
+		// child process
+
+		// replace [progname -test.run=TestExitCode -- ...]
+		//      by [progname ...]
+		os.Args = os.Args[2:]
+		os.Args[0] = "vet"
+		main()
+		panic("unreachable")
+	}
+
+	for _, test := range []struct {
+		args []string
+		want int
+	}{
+		{[]string{"nosuchdir/..."}, 1},                      // matched no packages
+		{[]string{"nosuchpkg"}, 1},                          // matched no packages
+		{[]string{"-unknownflag"}, 2},                       // flag error
+		{[]string{"-findcall.name=panic", "io"}, 3},         // finds diagnostics
+		{[]string{"-findcall=0", "io"}, 0},                  // no checkers
+		{[]string{"-findcall.name=nosuchfunc", "io"}, 0},    // no diagnostics
+		{[]string{"-findcall.name=panic", "sort", "io"}, 1}, // 'fail' failed on 'sort'
+
+		// -json: exits zero even in face of diagnostics or package errors.
+		{[]string{"-findcall.name=panic", "-json", "io"}, 0},
+		{[]string{"-findcall.name=panic", "-json", "io"}, 0},
+		{[]string{"-findcall.name=panic", "-json", "sort", "io"}, 0},
+	} {
+		args := []string{"-test.run=TestExitCode", "--"}
+		args = append(args, test.args...)
+		cmd := exec.Command(os.Args[0], args...)
+		cmd.Env = append(os.Environ(), "MULTICHECKER_CHILD=1")
+		out, err := cmd.CombinedOutput()
+		if len(out) > 0 {
+			t.Logf("%s: out=<<%s>>", test.args, out)
+		}
+		var exitcode int
+		if err, ok := err.(*exec.ExitError); ok {
+			exitcode = err.ExitCode() // requires go1.12
+		}
+		if exitcode != test.want {
+			t.Errorf("%s: exited %d, want %d", test.args, exitcode, test.want)
+		}
+	}
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/asmdecl/asmdecl.go b/vendor/golang.org/x/tools/go/analysis/passes/asmdecl/asmdecl.go
index 11dfbf6b..0f8abb57 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/asmdecl/asmdecl.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/asmdecl/asmdecl.go
@@ -243,16 +243,17 @@ Files:
 						}
 					}
 					if arch == "" {
-						badf("%s: cannot determine architecture for assembly file")
+						log.Printf("%s: cannot determine architecture for assembly file", fname)
 						continue Files
 					}
 				}
 				fnName = m[2]
-				if pkgName := strings.TrimSpace(m[1]); pkgName != "" {
-					pathParts := strings.Split(pkgName, "")
-					pkgName = pathParts[len(pathParts)-1]
-					if pkgName != pass.Pkg.Path() {
-						badf("[%s] cannot check cross-package assembly function: %s is in package %s", arch, fnName, pkgName)
+				if pkgPath := strings.TrimSpace(m[1]); pkgPath != "" {
+					// The assembler uses Unicode division slash within
+					// identifiers to represent the directory separator.
+					pkgPath = strings.Replace(pkgPath, "", "/", -1)
+					if pkgPath != pass.Pkg.Path() {
+						log.Printf("%s:%d: [%s] cannot check cross-package assembly function: %s is in package %s", fname, lineno, arch, fnName, pkgPath)
 						fn = nil
 						fnName = ""
 						continue
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/cgocall.go b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/cgocall.go
index 7eb24a4a..993f1ce3 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/cgocall.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/cgocall.go
@@ -9,18 +9,22 @@ package cgocall
 import (
 	"fmt"
 	"go/ast"
+	"go/build"
+	"go/format"
+	"go/parser"
 	"go/token"
 	"go/types"
 	"log"
-	"strings"
+	"os"
+	"strconv"
 
 	"golang.org/x/tools/go/analysis"
-	"golang.org/x/tools/go/analysis/passes/inspect"
 	"golang.org/x/tools/go/analysis/passes/internal/analysisutil"
-	"golang.org/x/tools/go/ast/inspector"
 )
 
-const Doc = `detect some violations of the cgo pointer passing rules
+const debug = false
+
+const doc = `detect some violations of the cgo pointer passing rules
 
 Check for invalid cgo pointer passing.
 This looks for code that uses cgo to call C code passing values
@@ -31,24 +35,41 @@ or slice to C, either directly, or via a pointer, array, or struct.`
 
 var Analyzer = &analysis.Analyzer{
 	Name:             "cgocall",
-	Doc:              Doc,
-	Requires:         []*analysis.Analyzer{inspect.Analyzer},
+	Doc:              doc,
 	RunDespiteErrors: true,
 	Run:              run,
 }
 
 func run(pass *analysis.Pass) (interface{}, error) {
-	inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)
+	if imports(pass.Pkg, "runtime/cgo") == nil {
+		return nil, nil // doesn't use cgo
+	}
 
-	nodeFilter := []ast.Node{
-		(*ast.CallExpr)(nil),
+	cgofiles, info, err := typeCheckCgoSourceFiles(pass.Fset, pass.Pkg, pass.Files, pass.TypesInfo)
+	if err != nil {
+		return nil, err
+	}
+	for _, f := range cgofiles {
+		checkCgo(pass.Fset, f, info, pass.Reportf)
 	}
-	inspect.WithStack(nodeFilter, func(n ast.Node, push bool, stack []ast.Node) bool {
-		if !push {
+	return nil, nil
+}
+
+func checkCgo(fset *token.FileSet, f *ast.File, info *types.Info, reportf func(token.Pos, string, ...interface{})) {
+	ast.Inspect(f, func(n ast.Node) bool {
+		call, ok := n.(*ast.CallExpr)
+		if !ok {
 			return true
 		}
-		call, name := findCall(pass.Fset, stack)
-		if call == nil {
+
+		// Is this a C.f() call?
+		var name string
+		if sel, ok := analysisutil.Unparen(call.Fun).(*ast.SelectorExpr); ok {
+			if id, ok := sel.X.(*ast.Ident); ok && id.Name == "C" {
+				name = sel.Sel.Name
+			}
+		}
+		if name == "" {
 			return true // not a call we need to check
 		}
 
@@ -57,92 +78,210 @@ func run(pass *analysis.Pass) (interface{}, error) {
 			return true
 		}
 
-		if false {
-			fmt.Printf("%s: inner call to C.%s\n", pass.Fset.Position(n.Pos()), name)
-			fmt.Printf("%s: outer call to C.%s\n", pass.Fset.Position(call.Lparen), name)
+		if debug {
+			log.Printf("%s: call to C.%s", fset.Position(call.Lparen), name)
 		}
 
 		for _, arg := range call.Args {
-			if !typeOKForCgoCall(cgoBaseType(pass.TypesInfo, arg), make(map[types.Type]bool)) {
-				pass.Reportf(arg.Pos(), "possibly passing Go type with embedded pointer to C")
+			if !typeOKForCgoCall(cgoBaseType(info, arg), make(map[types.Type]bool)) {
+				reportf(arg.Pos(), "possibly passing Go type with embedded pointer to C")
 				break
 			}
 
 			// Check for passing the address of a bad type.
 			if conv, ok := arg.(*ast.CallExpr); ok && len(conv.Args) == 1 &&
-				isUnsafePointer(pass.TypesInfo, conv.Fun) {
+				isUnsafePointer(info, conv.Fun) {
 				arg = conv.Args[0]
 			}
 			if u, ok := arg.(*ast.UnaryExpr); ok && u.Op == token.AND {
-				if !typeOKForCgoCall(cgoBaseType(pass.TypesInfo, u.X), make(map[types.Type]bool)) {
-					pass.Reportf(arg.Pos(), "possibly passing Go type with embedded pointer to C")
+				if !typeOKForCgoCall(cgoBaseType(info, u.X), make(map[types.Type]bool)) {
+					reportf(arg.Pos(), "possibly passing Go type with embedded pointer to C")
 					break
 				}
 			}
 		}
 		return true
 	})
-	return nil, nil
 }
 
-// findCall returns the CallExpr that we need to check, which may not be
-// the same as the one we're currently visiting, due to code generation.
-// It also returns the name of the function, such as "f" for C.f(...).
-//
-// This checker was initially written in vet to inpect unprocessed cgo
-// source files using partial type information. However, Analyzers in
-// the new analysis API are presented with the type-checked, processed
-// Go ASTs resulting from cgo processing files, so we must choose
-// between:
+// typeCheckCgoSourceFiles returns type-checked syntax trees for the raw
+// cgo files of a package (those that import "C"). Such files are not
+// Go, so there may be gaps in type information around C.f references.
 //
-// a) locating the cgo file (e.g. from //line directives)
-//    and working with that, or
-// b) working with the file generated by cgo.
+// This checker was initially written in vet to inpect raw cgo source
+// files using partial type information. However, Analyzers in the new
+// analysis API are presented with the type-checked, "cooked" Go ASTs
+// resulting from cgo-processing files, so we must choose between
+// working with the cooked file generated by cgo (which was tried but
+// proved fragile) or locating the raw cgo file (e.g. from //line
+// directives) and working with that, as we now do.
 //
-// We cannot use (a) because it does not provide type information, which
-// the analyzer needs, and it is infeasible for the analyzer to run the
-// type checker on this file. Thus we choose (b), which is fragile,
-// because the checker may need to change each time the cgo processor
-// changes.
+// Specifically, we must type-check the raw cgo source files (or at
+// least the subtrees needed for this analyzer) in an environment that
+// simulates the rest of the already type-checked package.
 //
-// Consider a cgo source file containing this header:
+// For example, for each raw cgo source file in the original package,
+// such as this one:
 //
-// 	 /* void f(void *x, *y); */
-//	 import "C"
+// 	package p
+// 	import "C"
+//	import "fmt"
+//	type T int
+//	const k = 3
+//	var x, y = fmt.Println()
+//	func f() { ... }
+//	func g() { ... C.malloc(k) ... }
+//	func (T) f(int) string { ... }
 //
-// The cgo tool expands a call such as:
+// we synthesize a new ast.File, shown below, that dot-imports the
+// orginal "cooked" package using a special name ("this"), so that all
+// references to package members resolve correctly. (References to
+// unexported names cause an "unexported" error, which we ignore.)
 //
-// 	 C.f(x, y)
+// To avoid shadowing names imported from the cooked package,
+// package-level declarations in the new source file are modified so
+// that they do not declare any names.
+// (The cgocall analysis is concerned with uses, not declarations.)
+// Specifically, type declarations are discarded;
+// all names in each var and const declaration are blanked out;
+// each method is turned into a regular function by turning
+// the receiver into the first parameter;
+// and all functions are renamed to "_".
 //
-// to this:
+// 	package p
+// 	import . "this" // declares T, k, x, y, f, g, T.f
+// 	import "C"
+//	import "fmt"
+//	const _ = 3
+//	var _, _ = fmt.Println()
+//	func _() { ... }
+//	func _() { ... C.malloc(k) ... }
+//	func _(T, int) string { ... }
 //
-// 1	func(param0, param1 unsafe.Pointer) {
-// 2		... various checks on params ...
-// 3		(_Cfunc_f)(param0, param1)
-// 4	}(x, y)
+// In this way, the raw function bodies and const/var initializer
+// expressions are preserved but refer to the "cooked" objects imported
+// from "this", and none of the transformed package-level declarations
+// actually declares anything. In the example above, the reference to k
+// in the argument of the call to C.malloc resolves to "this".k, which
+// has an accurate type.
 //
-// We first locate the _Cfunc_f call on line 3, then
-// walk up the stack of enclosing nodes until we find
-// the call on line 4.
+// This approach could in principle be generalized to more complex
+// analyses on raw cgo files. One could synthesize a "C" package so that
+// C.f would resolve to "this"._C_func_f, for example. But we have
+// limited ourselves here to preserving function bodies and initializer
+// expressions since that is all that the cgocall analyzer needs.
 //
-func findCall(fset *token.FileSet, stack []ast.Node) (*ast.CallExpr, string) {
-	last := len(stack) - 1
-	call := stack[last].(*ast.CallExpr)
-	if id, ok := analysisutil.Unparen(call.Fun).(*ast.Ident); ok {
-		if name := strings.TrimPrefix(id.Name, "_Cfunc_"); name != id.Name {
-			// Find the outer call with the arguments (x, y) we want to check.
-			for i := last - 1; i >= 0; i-- {
-				if outer, ok := stack[i].(*ast.CallExpr); ok {
-					return outer, name
+func typeCheckCgoSourceFiles(fset *token.FileSet, pkg *types.Package, files []*ast.File, info *types.Info) ([]*ast.File, *types.Info, error) {
+	const thispkg = "this"
+
+	// Which files are cgo files?
+	var cgoFiles []*ast.File
+	importMap := map[string]*types.Package{thispkg: pkg}
+	for _, raw := range files {
+		// If f is a cgo-generated file, Position reports
+		// the original file, honoring //line directives.
+		filename := fset.Position(raw.Pos()).Filename
+		f, err := parser.ParseFile(fset, filename, nil, parser.Mode(0))
+		if err != nil {
+			return nil, nil, fmt.Errorf("can't parse raw cgo file: %v", err)
+		}
+		found := false
+		for _, spec := range f.Imports {
+			if spec.Path.Value == `"C"` {
+				found = true
+				break
+			}
+		}
+		if !found {
+			continue // not a cgo file
+		}
+
+		// Record the original import map.
+		for _, spec := range raw.Imports {
+			path, _ := strconv.Unquote(spec.Path.Value)
+			importMap[path] = imported(info, spec)
+		}
+
+		// Add special dot-import declaration:
+		//    import . "this"
+		var decls []ast.Decl
+		decls = append(decls, &ast.GenDecl{
+			Tok: token.IMPORT,
+			Specs: []ast.Spec{
+				&ast.ImportSpec{
+					Name: &ast.Ident{Name: "."},
+					Path: &ast.BasicLit{
+						Kind:  token.STRING,
+						Value: strconv.Quote(thispkg),
+					},
+				},
+			},
+		})
+
+		// Transform declarations from the raw cgo file.
+		for _, decl := range f.Decls {
+			switch decl := decl.(type) {
+			case *ast.GenDecl:
+				switch decl.Tok {
+				case token.TYPE:
+					// Discard type declarations.
+					continue
+				case token.IMPORT:
+					// Keep imports.
+				case token.VAR, token.CONST:
+					// Blank the declared var/const names.
+					for _, spec := range decl.Specs {
+						spec := spec.(*ast.ValueSpec)
+						for i := range spec.Names {
+							spec.Names[i].Name = "_"
+						}
+					}
+				}
+			case *ast.FuncDecl:
+				// Blank the declared func name.
+				decl.Name.Name = "_"
+
+				// Turn a method receiver:  func (T) f(P) R {...}
+				// into regular parameter:  func _(T, P) R {...}
+				if decl.Recv != nil {
+					var params []*ast.Field
+					params = append(params, decl.Recv.List...)
+					params = append(params, decl.Type.Params.List...)
+					decl.Type.Params.List = params
+					decl.Recv = nil
 				}
 			}
-			// This shouldn't happen.
-			// Perhaps the code generator has changed?
-			log.Printf("%s: can't find outer call for C.%s(...)",
-				fset.Position(call.Lparen), name)
+			decls = append(decls, decl)
+		}
+		f.Decls = decls
+		if debug {
+			format.Node(os.Stderr, fset, f) // debugging
 		}
+		cgoFiles = append(cgoFiles, f)
+	}
+	if cgoFiles == nil {
+		return nil, nil, nil // nothing to do (can't happen?)
+	}
+
+	// Type-check the synthetic files.
+	tc := &types.Config{
+		FakeImportC: true,
+		Importer: importerFunc(func(path string) (*types.Package, error) {
+			return importMap[path], nil
+		}),
+		// TODO(adonovan): Sizes should probably be provided by analysis.Pass.
+		Sizes: types.SizesFor("gc", build.Default.GOARCH),
+		Error: func(error) {}, // ignore errors (e.g. unused import)
+	}
+
+	// It's tempting to record the new types in the
+	// existing pass.TypesInfo, but we don't own it.
+	altInfo := &types.Info{
+		Types: make(map[ast.Expr]types.TypeAndValue),
 	}
-	return nil, ""
+	tc.Check(pkg.Path(), fset, cgoFiles, altInfo)
+
+	return cgoFiles, altInfo, nil
 }
 
 // cgoBaseType tries to look through type conversions involving
@@ -224,3 +363,28 @@ func isUnsafePointer(info *types.Info, e ast.Expr) bool {
 	t := info.Types[e].Type
 	return t != nil && t.Underlying() == types.Typ[types.UnsafePointer]
 }
+
+type importerFunc func(path string) (*types.Package, error)
+
+func (f importerFunc) Import(path string) (*types.Package, error) { return f(path) }
+
+// TODO(adonovan): make this a library function or method of Info.
+func imported(info *types.Info, spec *ast.ImportSpec) *types.Package {
+	obj, ok := info.Implicits[spec]
+	if !ok {
+		obj = info.Defs[spec.Name] // renaming import
+	}
+	return obj.(*types.PkgName).Imported()
+}
+
+// imports reports whether pkg has path among its direct imports.
+// It returns the imported package if so, or nil if not.
+// TODO(adonovan): move to analysisutil.
+func imports(pkg *types.Package, path string) *types.Package {
+	for _, imp := range pkg.Imports() {
+		if imp.Path() == path {
+			return imp
+		}
+	}
+	return nil
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/cgocall_test.go b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/cgocall_test.go
index aebd4327..ba654261 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/cgocall_test.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/cgocall_test.go
@@ -13,5 +13,5 @@ import (
 
 func Test(t *testing.T) {
 	testdata := analysistest.TestData()
-	analysistest.Run(t, testdata, cgocall.Analyzer, "a", "b")
+	analysistest.Run(t, testdata, cgocall.Analyzer, "a", "b", "c")
 }
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo.go b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo.go
index 39ad897e..75464b29 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo.go
@@ -36,6 +36,10 @@ func CgoTests() {
 	C.f(*(*unsafe.Pointer)(unsafe.Pointer(&st))) // want "embedded pointer"
 	C.f(unsafe.Pointer(&st))                     // want "embedded pointer"
 
+	var st3 S
+	C.f(*(*unsafe.Pointer)(unsafe.Pointer(&st3))) // want "embedded pointer"
+	C.f(unsafe.Pointer(&st3))                     // want "embedded pointer"
+
 	// The following cases are OK.
 	var i int
 	C.f(*(*unsafe.Pointer)(unsafe.Pointer(&i)))
@@ -52,8 +56,16 @@ func CgoTests() {
 	C.f(*(*unsafe.Pointer)(unsafe.Pointer(&st2)))
 	C.f(unsafe.Pointer(&st2))
 
+	var st4 S2
+	C.f(*(*unsafe.Pointer)(unsafe.Pointer(&st4)))
+	C.f(unsafe.Pointer(&st4))
+
 	type cgoStruct struct{ p *cgoStruct }
 	C.f(unsafe.Pointer(&cgoStruct{}))
 
 	C.CBytes([]byte("hello"))
 }
+
+type S struct{ slice []int }
+
+type S2 struct{ int int }
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo3.go b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo3.go
index fd095166..4873db02 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo3.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo3.go
@@ -4,7 +4,18 @@
 
 package a
 
+// The purpose of this inherited test is unclear.
+
 import "C"
 
+const x = 1
+
+var a, b = 1, 2
+
 func F() {
 }
+
+func FAD(int, string) bool {
+	C.malloc(3)
+	return true
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo4.go b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo4.go
deleted file mode 100644
index fc1d1e5f..00000000
--- a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo4.go
+++ /dev/null
@@ -1,15 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Test the cgo checker on a file that doesn't use cgo, but has an
-// import named "C".
-
-package a
-
-import C "fmt"
-
-var _ = C.Println(*p(**p))
-
-// Passing a pointer (via a slice), but C is fmt, not cgo.
-var _ = C.Println([]int{3})
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/b/b.go b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/b/b.go
index 342b14be..ff2f2e19 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/b/b.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/b/b.go
@@ -9,7 +9,12 @@ package b
 
 import C "fmt"
 
-var _ = C.Println(*p(**p))
+import "unsafe"
 
-// Passing a pointer (via a slice), but C is fmt, not cgo.
-var _ = C.Println([]int{3})
+func init() {
+	var f func()
+	C.Println(unsafe.Pointer(&f))
+
+	// Passing a pointer (via a slice), but C is fmt, not cgo.
+	C.Println([]int{3})
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo2.go b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/c/c.go
similarity index 97%
rename from vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo2.go
rename to vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/c/c.go
index a624afb9..256e3dfb 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/a/cgo2.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/cgocall/testdata/src/c/c.go
@@ -4,7 +4,7 @@
 
 // Test the cgo checker on a file that doesn't use cgo.
 
-package a
+package c
 
 import "unsafe"
 
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/composite/composite.go b/vendor/golang.org/x/tools/go/analysis/passes/composite/composite.go
index b7cfe8a9..9cca7781 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/composite/composite.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/composite/composite.go
@@ -16,7 +16,7 @@ import (
 	"golang.org/x/tools/go/ast/inspector"
 )
 
-const Doc = `checked for unkeyed composite literals
+const Doc = `check for unkeyed composite literals
 
 This analyzer reports a diagnostic for composite literals of struct
 types imported from another package that do not use the field-keyed
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/lostcancel.go b/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/lostcancel.go
index fcf9f553..996ecc4d 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/lostcancel.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/lostcancel.go
@@ -132,11 +132,17 @@ func runFunc(pass *analysis.Pass, node ast.Node) {
 	var sig *types.Signature
 	switch node := node.(type) {
 	case *ast.FuncDecl:
-		g = cfgs.FuncDecl(node)
 		sig, _ = pass.TypesInfo.Defs[node.Name].Type().(*types.Signature)
+		if node.Name.Name == "main" && sig.Recv() == nil && pass.Pkg.Name() == "main" {
+			// Returning from main.main terminates the process,
+			// so there's no need to cancel contexts.
+			return
+		}
+		g = cfgs.FuncDecl(node)
+
 	case *ast.FuncLit:
-		g = cfgs.FuncLit(node)
 		sig, _ = pass.TypesInfo.Types[node.Type].Type.(*types.Signature)
+		g = cfgs.FuncLit(node)
 	}
 	if sig == nil {
 		return // missing type information
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/lostcancel_test.go b/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/lostcancel_test.go
index 5fe817b3..a1d8f854 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/lostcancel_test.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/lostcancel_test.go
@@ -13,5 +13,5 @@ import (
 
 func Test(t *testing.T) {
 	testdata := analysistest.TestData()
-	analysistest.Run(t, testdata, lostcancel.Analyzer, "a")
+	analysistest.Run(t, testdata, lostcancel.Analyzer, "a", "b")
 }
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/testdata/src/b/b.go b/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/testdata/src/b/b.go
new file mode 100644
index 00000000..18ef0348
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/passes/lostcancel/testdata/src/b/b.go
@@ -0,0 +1,26 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+import "context"
+
+// Return from main is handled specially.
+// Since the program exits, there's no need to call cancel.
+func main() {
+	_, cancel := context.WithCancel(nil)
+	if maybe {
+		cancel()
+	}
+}
+
+func notMain() {
+	_, cancel := context.WithCancel(nil) // want "cancel function.*not used"
+
+	if maybe {
+		cancel()
+	}
+} // want "return statement.*reached without using the cancel"
+
+var maybe bool
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/pkgfact/pkgfact.go b/vendor/golang.org/x/tools/go/analysis/passes/pkgfact/pkgfact.go
index eca0f256..e0530867 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/pkgfact/pkgfact.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/pkgfact/pkgfact.go
@@ -70,14 +70,14 @@ func run(pass *analysis.Pass) (interface{}, error) {
 		}
 	}
 
-	// At each "const _name = value", add a fact into env.
+	// At each "const _name_ = value", add a fact into env.
 	doConst := func(spec *ast.ValueSpec) {
 		if len(spec.Names) == len(spec.Values) {
 			for i := range spec.Names {
 				name := spec.Names[i].Name
 				if strings.HasPrefix(name, "_") && strings.HasSuffix(name, "_") {
 
-					if key := strings.Trim(name[1:], "_"); key != "" {
+					if key := strings.Trim(name, "_"); key != "" {
 						value := pass.TypesInfo.Types[spec.Values[i]].Value.String()
 						result[key] = value
 					}
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/printf/printf.go b/vendor/golang.org/x/tools/go/analysis/passes/printf/printf.go
index 23f634fd..9fa0a1c6 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/printf/printf.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/printf/printf.go
@@ -32,7 +32,7 @@ func init() {
 
 var Analyzer = &analysis.Analyzer{
 	Name:      "printf",
-	Doc:       "check printf-like invocations",
+	Doc:       doc,
 	Requires:  []*analysis.Analyzer{inspect.Analyzer},
 	Run:       run,
 	FactTypes: []analysis.Fact{new(isWrapper)},
@@ -43,12 +43,12 @@ const doc = `check consistency of Printf format strings and arguments
 The check applies to known functions (for example, those in package fmt)
 as well as any detected wrappers of known functions.
 
-A function that wants to avail itself of printf checking but does not
-get found by this analyzer's heuristics (for example, due to use of
+A function that wants to avail itself of printf checking but is not
+found by this analyzer's heuristics (for example, due to use of
 dynamic calls) can insert a bogus call:
 
 	if false {
-		fmt.Sprintf(format, args...) // enable printf checking
+		_ = fmt.Sprintf(format, args...) // enable printf checking
 	}
 
 The -funcs flag specifies a comma-separated list of names of additional
@@ -277,18 +277,56 @@ func checkPrintfFwd(pass *analysis.Pass, w *printfWrapper, call *ast.CallExpr, k
 // or case-insensitive identifiers such as "errorf".
 //
 // The -funcs flag adds to this set.
+//
+// The set below includes facts for many important standard library
+// functions, even though the analysis is capable of deducing that, for
+// example, fmt.Printf forwards to fmt.Fprintf. We avoid relying on the
+// driver applying analyzers to standard packages because "go vet" does
+// not do so with gccgo, and nor do some other build systems.
+// TODO(adonovan): eliminate the redundant facts once this restriction
+// is lifted.
+//
 var isPrint = stringSet{
 	"fmt.Errorf":   true,
 	"fmt.Fprint":   true,
 	"fmt.Fprintf":  true,
 	"fmt.Fprintln": true,
-	"fmt.Print":    true, // technically these three
-	"fmt.Printf":   true, // are redundant because they
-	"fmt.Println":  true, // forward to Fprint{,f,ln}
+	"fmt.Print":    true,
+	"fmt.Printf":   true,
+	"fmt.Println":  true,
 	"fmt.Sprint":   true,
 	"fmt.Sprintf":  true,
 	"fmt.Sprintln": true,
 
+	"runtime/trace.Logf": true,
+
+	"log.Print":             true,
+	"log.Printf":            true,
+	"log.Println":           true,
+	"log.Fatal":             true,
+	"log.Fatalf":            true,
+	"log.Fatalln":           true,
+	"log.Panic":             true,
+	"log.Panicf":            true,
+	"log.Panicln":           true,
+	"(*log.Logger).Fatal":   true,
+	"(*log.Logger).Fatalf":  true,
+	"(*log.Logger).Fatalln": true,
+	"(*log.Logger).Panic":   true,
+	"(*log.Logger).Panicf":  true,
+	"(*log.Logger).Panicln": true,
+	"(*log.Logger).Print":   true,
+	"(*log.Logger).Printf":  true,
+	"(*log.Logger).Println": true,
+
+	"(*testing.common).Error":  true,
+	"(*testing.common).Errorf": true,
+	"(*testing.common).Fatal":  true,
+	"(*testing.common).Fatalf": true,
+	"(*testing.common).Log":    true,
+	"(*testing.common).Logf":   true,
+	"(*testing.common).Skip":   true,
+	"(*testing.common).Skipf":  true,
 	// *testing.T and B are detected by induction, but testing.TB is
 	// an interface and the inference can't follow dynamic calls.
 	"(testing.TB).Error":  true,
@@ -805,7 +843,22 @@ func recursiveStringer(pass *analysis.Pass, e ast.Expr) bool {
 	}
 
 	// Is the expression e within the body of that String method?
-	return stringMethod.Pkg() == pass.Pkg && stringMethod.Scope().Contains(e.Pos())
+	if stringMethod.Pkg() != pass.Pkg || !stringMethod.Scope().Contains(e.Pos()) {
+		return false
+	}
+
+	// Is it the receiver r, or &r?
+	recv := stringMethod.Type().(*types.Signature).Recv()
+	if recv == nil {
+		return false
+	}
+	if u, ok := e.(*ast.UnaryExpr); ok && u.Op == token.AND {
+		e = u.X // strip off & from &r
+	}
+	if id, ok := e.(*ast.Ident); ok {
+		return pass.TypesInfo.Uses[id] == recv
+	}
+	return false
 }
 
 // isFunctionValue reports whether the expression is a function as opposed to a function call.
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/printf/testdata/src/a/a.go b/vendor/golang.org/x/tools/go/analysis/passes/printf/testdata/src/a/a.go
index b73d1cad..970b5122 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/printf/testdata/src/a/a.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/printf/testdata/src/a/a.go
@@ -237,7 +237,7 @@ func PrintfTests() {
 	Printf("%T", someFunction) // ok: maybe someone wants to see the type
 	// Bug: used to recur forever.
 	Printf("%p %x", recursiveStructV, recursiveStructV.next)
-	Printf("%p %x", recursiveStruct1V, recursiveStruct1V.next)
+	Printf("%p %x", recursiveStruct1V, recursiveStruct1V.next) // want `Printf format %x has arg recursiveStruct1V\.next of wrong type \*a\.RecursiveStruct2`
 	Printf("%p %x", recursiveSliceV, recursiveSliceV)
 	Printf("%p %x", recursiveMapV, recursiveMapV)
 	// Special handling for Log.
@@ -514,6 +514,19 @@ func (p *recursivePtrStringer) String() string {
 	return fmt.Sprintln(p) // want "Sprintln arg p causes recursive call to String method"
 }
 
+type cons struct {
+	car int
+	cdr *cons
+}
+
+func (cons *cons) String() string {
+	if cons == nil {
+		return "nil"
+	}
+	_ = fmt.Sprint(cons.cdr)                            // don't want "recursive call" diagnostic
+	return fmt.Sprintf("(%d . %v)", cons.car, cons.cdr) // don't want "recursive call" diagnostic
+}
+
 type BoolFormatter bool
 
 func (*BoolFormatter) Format(fmt.State, rune) {
@@ -654,6 +667,40 @@ func dbg(format string, args ...interface{}) {
 	fmt.Printf(format, args...)
 }
 
+func PointersToCompoundTypes() {
+	stringSlice := []string{"a", "b"}
+	fmt.Printf("%s", &stringSlice) // not an error
+
+	intSlice := []int{3, 4}
+	fmt.Printf("%s", &intSlice) // want `Printf format %s has arg &intSlice of wrong type \*\[\]int`
+
+	stringArray := [2]string{"a", "b"}
+	fmt.Printf("%s", &stringArray) // not an error
+
+	intArray := [2]int{3, 4}
+	fmt.Printf("%s", &intArray) // want `Printf format %s has arg &intArray of wrong type \*\[2\]int`
+
+	stringStruct := struct{ F string }{"foo"}
+	fmt.Printf("%s", &stringStruct) // not an error
+
+	intStruct := struct{ F int }{3}
+	fmt.Printf("%s", &intStruct) // want `Printf format %s has arg &intStruct of wrong type \*struct{F int}`
+
+	stringMap := map[string]string{"foo": "bar"}
+	fmt.Printf("%s", &stringMap) // not an error
+
+	intMap := map[int]int{3: 4}
+	fmt.Printf("%s", &intMap) // want `Printf format %s has arg &intMap of wrong type \*map\[int\]int`
+
+	type T2 struct {
+		X string
+	}
+	type T1 struct {
+		X *T2
+	}
+	fmt.Printf("%s\n", T1{&T2{"x"}}) // want `Printf format %s has arg T1{&T2{.x.}} of wrong type a\.T1`
+}
+
 // Printf wrappers from external package
 func externalPackage() {
 	b.Wrapf("%s", 1) // want "Wrapf format %s has arg 1 of wrong type int"
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/printf/types.go b/vendor/golang.org/x/tools/go/analysis/passes/printf/types.go
index 701d08be..0ebc8107 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/printf/types.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/printf/types.go
@@ -97,12 +97,25 @@ func matchArgTypeInternal(pass *analysis.Pass, t printfArgType, typ types.Type,
 		if t == argPointer {
 			return true
 		}
-		// If it's pointer to struct, that's equivalent in our analysis to whether we can print the struct.
-		if str, ok := typ.Elem().Underlying().(*types.Struct); ok {
-			return matchStructArgType(pass, t, str, arg, inProgress)
+
+		under := typ.Elem().Underlying()
+		switch under.(type) {
+		case *types.Struct: // see below
+		case *types.Array: // see below
+		case *types.Slice: // see below
+		case *types.Map: // see below
+		default:
+			// Check whether the rest can print pointers.
+			return t&argPointer != 0
 		}
-		// Check whether the rest can print pointers.
-		return t&argPointer != 0
+		// If it's a top-level pointer to a struct, array, slice, or
+		// map, that's equivalent in our analysis to whether we can
+		// print the type being pointed to. Pointers in nested levels
+		// are not supported to minimize fmt running into loops.
+		if len(inProgress) > 1 {
+			return false
+		}
+		return matchArgTypeInternal(pass, t, under, arg, inProgress)
 
 	case *types.Struct:
 		return matchStructArgType(pass, t, typ, arg, inProgress)
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow/main.go b/vendor/golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow/main.go
new file mode 100644
index 00000000..ccf7b5c9
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow/main.go
@@ -0,0 +1,9 @@
+// The shadow command runs the shadow analyzer.
+package main
+
+import (
+	"golang.org/x/tools/go/analysis/passes/shadow"
+	"golang.org/x/tools/go/analysis/singlechecker"
+)
+
+func main() { singlechecker.Main(shadow.Analyzer) }
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/stdmethods/stdmethods.go b/vendor/golang.org/x/tools/go/analysis/passes/stdmethods/stdmethods.go
index eead289e..b61c3220 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/stdmethods/stdmethods.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/stdmethods/stdmethods.go
@@ -7,10 +7,7 @@
 package stdmethods
 
 import (
-	"bytes"
-	"fmt"
 	"go/ast"
-	"go/printer"
 	"go/token"
 	"go/types"
 	"strings"
@@ -95,12 +92,12 @@ func run(pass *analysis.Pass) (interface{}, error) {
 		switch n := n.(type) {
 		case *ast.FuncDecl:
 			if n.Recv != nil {
-				canonicalMethod(pass, n.Name, n.Type)
+				canonicalMethod(pass, n.Name)
 			}
 		case *ast.InterfaceType:
 			for _, field := range n.Methods.List {
 				for _, id := range field.Names {
-					canonicalMethod(pass, id, field.Type.(*ast.FuncType))
+					canonicalMethod(pass, id)
 				}
 			}
 		}
@@ -108,7 +105,7 @@ func run(pass *analysis.Pass) (interface{}, error) {
 	return nil, nil
 }
 
-func canonicalMethod(pass *analysis.Pass, id *ast.Ident, t *ast.FuncType) {
+func canonicalMethod(pass *analysis.Pass, id *ast.Ident) {
 	// Expected input/output.
 	expect, ok := canonicalMethods[id.Name]
 	if !ok {
@@ -116,11 +113,9 @@ func canonicalMethod(pass *analysis.Pass, id *ast.Ident, t *ast.FuncType) {
 	}
 
 	// Actual input/output
-	args := typeFlatten(t.Params.List)
-	var results []ast.Expr
-	if t.Results != nil {
-		results = typeFlatten(t.Results.List)
-	}
+	sign := pass.TypesInfo.Defs[id].Type().(*types.Signature)
+	args := sign.Params()
+	results := sign.Results()
 
 	// Do the =s (if any) all match?
 	if !matchParams(pass, expect.args, args, "=") || !matchParams(pass, expect.results, results, "=") {
@@ -136,11 +131,7 @@ func canonicalMethod(pass *analysis.Pass, id *ast.Ident, t *ast.FuncType) {
 			expectFmt += " (" + argjoin(expect.results) + ")"
 		}
 
-		var buf bytes.Buffer
-		if err := printer.Fprint(&buf, pass.Fset, t); err != nil {
-			fmt.Fprintf(&buf, "<%s>", err)
-		}
-		actual := buf.String()
+		actual := types.TypeString(sign, (*types.Package).Name)
 		actual = strings.TrimPrefix(actual, "func")
 		actual = id.Name + actual
 
@@ -159,45 +150,27 @@ func argjoin(x []string) string {
 	return strings.Join(y, ", ")
 }
 
-// Turn parameter list into slice of types
-// (in the ast, types are Exprs).
-// Have to handle f(int, bool) and f(x, y, z int)
-// so not a simple 1-to-1 conversion.
-func typeFlatten(l []*ast.Field) []ast.Expr {
-	var t []ast.Expr
-	for _, f := range l {
-		if len(f.Names) == 0 {
-			t = append(t, f.Type)
-			continue
-		}
-		for range f.Names {
-			t = append(t, f.Type)
-		}
-	}
-	return t
-}
-
 // Does each type in expect with the given prefix match the corresponding type in actual?
-func matchParams(pass *analysis.Pass, expect []string, actual []ast.Expr, prefix string) bool {
+func matchParams(pass *analysis.Pass, expect []string, actual *types.Tuple, prefix string) bool {
 	for i, x := range expect {
 		if !strings.HasPrefix(x, prefix) {
 			continue
 		}
-		if i >= len(actual) {
+		if i >= actual.Len() {
 			return false
 		}
-		if !matchParamType(pass.Fset, pass.Pkg, x, actual[i]) {
+		if !matchParamType(pass.Fset, pass.Pkg, x, actual.At(i).Type()) {
 			return false
 		}
 	}
-	if prefix == "" && len(actual) > len(expect) {
+	if prefix == "" && actual.Len() > len(expect) {
 		return false
 	}
 	return true
 }
 
 // Does this one type match?
-func matchParamType(fset *token.FileSet, pkg *types.Package, expect string, actual ast.Expr) bool {
+func matchParamType(fset *token.FileSet, pkg *types.Package, expect string, actual types.Type) bool {
 	expect = strings.TrimPrefix(expect, "=")
 	// Strip package name if we're in that package.
 	if n := len(pkg.Name()); len(expect) > n && expect[:n] == pkg.Name() && expect[n] == '.' {
@@ -205,7 +178,5 @@ func matchParamType(fset *token.FileSet, pkg *types.Package, expect string, actu
 	}
 
 	// Overkill but easy.
-	var buf bytes.Buffer
-	printer.Fprint(&buf, fset, actual)
-	return buf.String() == expect
+	return actual.String() == expect
 }
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/stdmethods/testdata/src/a/a.go b/vendor/golang.org/x/tools/go/analysis/passes/stdmethods/testdata/src/a/a.go
index a007bbfb..9833f8fd 100644
--- a/vendor/golang.org/x/tools/go/analysis/passes/stdmethods/testdata/src/a/a.go
+++ b/vendor/golang.org/x/tools/go/analysis/passes/stdmethods/testdata/src/a/a.go
@@ -4,11 +4,14 @@
 
 package a
 
-import "fmt"
+import (
+	"encoding/xml"
+	"fmt"
+)
 
 type T int
 
-func (T) Scan(x fmt.ScanState, c byte) {} // want "should have signature Scan"
+func (T) Scan(x fmt.ScanState, c byte) {} // want `should have signature Scan\(fmt\.ScanState, rune\) error`
 
 func (T) Format(fmt.State, byte) {} // want `should have signature Format\(fmt.State, rune\)`
 
@@ -18,6 +21,9 @@ func (U) Format(byte) {} // no error: first parameter must be fmt.State to trigg
 
 func (U) GobDecode() {} // want `should have signature GobDecode\(\[\]byte\) error`
 
+// Test rendering of type names such as xml.Encoder in diagnostic.
+func (U) MarshalXML(*xml.Encoder) {} // want `method MarshalXML\(\*xml.Encoder\) should...`
+
 type I interface {
-	ReadByte() byte // want "should have signature ReadByte"
+	ReadByte() byte // want `should have signature ReadByte\(\) \(byte, error\)`
 }
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/cmd/unmarshal/main.go b/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/cmd/unmarshal/main.go
new file mode 100644
index 00000000..993bf745
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/cmd/unmarshal/main.go
@@ -0,0 +1,9 @@
+// The unmarshal command runs the unmarshal analyzer.
+package main
+
+import (
+	"golang.org/x/tools/go/analysis/passes/unmarshal"
+	"golang.org/x/tools/go/analysis/singlechecker"
+)
+
+func main() { singlechecker.Main(unmarshal.Analyzer) }
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/testdata/src/a/a.go b/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/testdata/src/a/a.go
new file mode 100644
index 00000000..5c47fe7c
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/testdata/src/a/a.go
@@ -0,0 +1,58 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// This file contains tests for the unmarshal checker.
+
+package testdata
+
+import (
+	"encoding/gob"
+	"encoding/json"
+	"encoding/xml"
+	"io"
+)
+
+func _() {
+	type t struct {
+		a int
+	}
+	var v t
+	var r io.Reader
+
+	json.Unmarshal([]byte{}, v) // want "call of Unmarshal passes non-pointer as second argument"
+	json.Unmarshal([]byte{}, &v)
+	json.NewDecoder(r).Decode(v) // want "call of Decode passes non-pointer"
+	json.NewDecoder(r).Decode(&v)
+	gob.NewDecoder(r).Decode(v) // want "call of Decode passes non-pointer"
+	gob.NewDecoder(r).Decode(&v)
+	xml.Unmarshal([]byte{}, v) // want "call of Unmarshal passes non-pointer as second argument"
+	xml.Unmarshal([]byte{}, &v)
+	xml.NewDecoder(r).Decode(v) // want "call of Decode passes non-pointer"
+	xml.NewDecoder(r).Decode(&v)
+
+	var p *t
+	json.Unmarshal([]byte{}, p)
+	json.Unmarshal([]byte{}, *p) // want "call of Unmarshal passes non-pointer as second argument"
+	json.NewDecoder(r).Decode(p)
+	json.NewDecoder(r).Decode(*p) // want "call of Decode passes non-pointer"
+	gob.NewDecoder(r).Decode(p)
+	gob.NewDecoder(r).Decode(*p) // want "call of Decode passes non-pointer"
+	xml.Unmarshal([]byte{}, p)
+	xml.Unmarshal([]byte{}, *p) // want "call of Unmarshal passes non-pointer as second argument"
+	xml.NewDecoder(r).Decode(p)
+	xml.NewDecoder(r).Decode(*p) // want "call of Decode passes non-pointer"
+
+	var i interface{}
+	json.Unmarshal([]byte{}, i)
+	json.NewDecoder(r).Decode(i)
+
+	json.Unmarshal([]byte{}, nil)               // want "call of Unmarshal passes non-pointer as second argument"
+	json.Unmarshal([]byte{}, []t{})             // want "call of Unmarshal passes non-pointer as second argument"
+	json.Unmarshal([]byte{}, map[string]int{})  // want "call of Unmarshal passes non-pointer as second argument"
+	json.NewDecoder(r).Decode(nil)              // want "call of Decode passes non-pointer"
+	json.NewDecoder(r).Decode([]t{})            // want "call of Decode passes non-pointer"
+	json.NewDecoder(r).Decode(map[string]int{}) // want "call of Decode passes non-pointer"
+
+	json.Unmarshal(func() ([]byte, interface{}) { return []byte{}, v }())
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/unmarshal.go b/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/unmarshal.go
new file mode 100644
index 00000000..6cf4358a
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/unmarshal.go
@@ -0,0 +1,92 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// The unmarshal package defines an Analyzer that checks for passing
+// non-pointer or non-interface types to unmarshal and decode functions.
+package unmarshal
+
+import (
+	"go/ast"
+	"go/types"
+
+	"golang.org/x/tools/go/analysis"
+	"golang.org/x/tools/go/analysis/passes/inspect"
+	"golang.org/x/tools/go/ast/inspector"
+	"golang.org/x/tools/go/types/typeutil"
+)
+
+const doc = `report passing non-pointer or non-interface values to unmarshal
+
+The unmarshal analysis reports calls to functions such as json.Unmarshal
+in which the argument type is not a pointer or an interface.`
+
+var Analyzer = &analysis.Analyzer{
+	Name:     "unmarshal",
+	Doc:      doc,
+	Requires: []*analysis.Analyzer{inspect.Analyzer},
+	Run:      run,
+}
+
+func run(pass *analysis.Pass) (interface{}, error) {
+	inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)
+
+	nodeFilter := []ast.Node{
+		(*ast.CallExpr)(nil),
+	}
+	inspect.Preorder(nodeFilter, func(n ast.Node) {
+		call := n.(*ast.CallExpr)
+		fn := typeutil.StaticCallee(pass.TypesInfo, call)
+		if fn == nil {
+			return // not a static call
+		}
+
+		// Classify the callee (without allocating memory).
+		argidx := -1
+		recv := fn.Type().(*types.Signature).Recv()
+		if fn.Name() == "Unmarshal" && recv == nil {
+			// "encoding/json".Unmarshal
+			//  "encoding/xml".Unmarshal
+			switch fn.Pkg().Path() {
+			case "encoding/json", "encoding/xml":
+				argidx = 1 // func([]byte, interface{})
+			}
+		} else if fn.Name() == "Decode" && recv != nil {
+			// (*"encoding/json".Decoder).Decode
+			// (* "encoding/gob".Decoder).Decode
+			// (* "encoding/xml".Decoder).Decode
+			t := recv.Type()
+			if ptr, ok := t.(*types.Pointer); ok {
+				t = ptr.Elem()
+			}
+			tname := t.(*types.Named).Obj()
+			if tname.Name() == "Decoder" {
+				switch tname.Pkg().Path() {
+				case "encoding/json", "encoding/xml", "encoding/gob":
+					argidx = 0 // func(interface{})
+				}
+			}
+		}
+		if argidx < 0 {
+			return // not a function we are interested in
+		}
+
+		if len(call.Args) < argidx+1 {
+			return // not enough arguments, e.g. called with return values of another function
+		}
+
+		t := pass.TypesInfo.Types[call.Args[argidx]].Type
+		switch t.Underlying().(type) {
+		case *types.Pointer, *types.Interface:
+			return
+		}
+
+		switch argidx {
+		case 0:
+			pass.Reportf(call.Lparen, "call of %s passes non-pointer", fn.Name())
+		case 1:
+			pass.Reportf(call.Lparen, "call of %s passes non-pointer as second argument", fn.Name())
+		}
+	})
+	return nil, nil
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/unmarshal_test.go b/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/unmarshal_test.go
new file mode 100644
index 00000000..ae19e5dd
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/passes/unmarshal/unmarshal_test.go
@@ -0,0 +1,17 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package unmarshal_test
+
+import (
+	"testing"
+
+	"golang.org/x/tools/go/analysis/analysistest"
+	"golang.org/x/tools/go/analysis/passes/unmarshal"
+)
+
+func Test(t *testing.T) {
+	testdata := analysistest.TestData()
+	analysistest.Run(t, testdata, unmarshal.Analyzer, "a")
+}
diff --git a/vendor/golang.org/x/tools/go/analysis/printf/printf.go b/vendor/golang.org/x/tools/go/analysis/printf/printf.go
deleted file mode 100644
index f980dcb5..00000000
--- a/vendor/golang.org/x/tools/go/analysis/printf/printf.go
+++ /dev/null
@@ -1,1072 +0,0 @@
-// +build ignore
-
-// Copyright 2010 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// This file contains the printf-checker.
-
-package main
-
-import (
-	"bytes"
-	"encoding/gob"
-	"flag"
-	"fmt"
-	"go/ast"
-	"go/constant"
-	"go/token"
-	"go/types"
-	"regexp"
-	"sort"
-	"strconv"
-	"strings"
-	"unicode/utf8"
-)
-
-var printfuncs = flag.String("printfuncs", "", "comma-separated list of print function names to check")
-
-func init() {
-	register("printf",
-		"check printf-like invocations",
-		checkFmtPrintfCall,
-		funcDecl, callExpr)
-	registerPkgCheck("printf", findPrintfLike)
-	registerExport("printf", exportPrintfLike)
-	gob.Register([]printfExport(nil))
-}
-
-func initPrintFlags() {
-	if *printfuncs == "" {
-		return
-	}
-	for _, name := range strings.Split(*printfuncs, ",") {
-		if len(name) == 0 {
-			flag.Usage()
-		}
-
-		// Backwards compatibility: skip optional first argument
-		// index after the colon.
-		if colon := strings.LastIndex(name, ":"); colon > 0 {
-			name = name[:colon]
-		}
-
-		if !strings.Contains(name, ".") {
-			name = strings.ToLower(name)
-		}
-		isPrint[name] = true
-	}
-}
-
-var localPrintfLike = make(map[string]int)
-
-type printfExport struct {
-	Name string
-	Kind int
-}
-
-// printfImported maps from package name to the printf vet data
-// exported by that package.
-var printfImported = make(map[string]map[string]int)
-
-type printfWrapper struct {
-	name    string
-	fn      *ast.FuncDecl
-	format  *ast.Field
-	args    *ast.Field
-	callers []printfCaller
-	failed  bool // if true, not a printf wrapper
-}
-
-type printfCaller struct {
-	w    *printfWrapper
-	call *ast.CallExpr
-}
-
-// maybePrintfWrapper decides whether decl (a declared function) may be a wrapper
-// around a fmt.Printf or fmt.Print function. If so it returns a printfWrapper
-// function describing the declaration. Later processing will analyze the
-// graph of potential printf wrappers to pick out the ones that are true wrappers.
-// A function may be a Printf or Print wrapper if its last argument is ...interface{}.
-// If the next-to-last argument is a string, then this may be a Printf wrapper.
-// Otherwise it may be a Print wrapper.
-func maybePrintfWrapper(decl ast.Decl) *printfWrapper {
-	// Look for functions with final argument type ...interface{}.
-	fn, ok := decl.(*ast.FuncDecl)
-	if !ok || fn.Body == nil {
-		return nil
-	}
-	name := fn.Name.Name
-	if fn.Recv != nil {
-		// For (*T).Name or T.name, use "T.name".
-		rcvr := fn.Recv.List[0].Type
-		if ptr, ok := rcvr.(*ast.StarExpr); ok {
-			rcvr = ptr.X
-		}
-		id, ok := rcvr.(*ast.Ident)
-		if !ok {
-			return nil
-		}
-		name = id.Name + "." + name
-	}
-	params := fn.Type.Params.List
-	if len(params) == 0 {
-		return nil
-	}
-	args := params[len(params)-1]
-	if len(args.Names) != 1 {
-		return nil
-	}
-	ddd, ok := args.Type.(*ast.Ellipsis)
-	if !ok {
-		return nil
-	}
-	iface, ok := ddd.Elt.(*ast.InterfaceType)
-	if !ok || len(iface.Methods.List) > 0 {
-		return nil
-	}
-	var format *ast.Field
-	if len(params) >= 2 {
-		p := params[len(params)-2]
-		if len(p.Names) == 1 {
-			if id, ok := p.Type.(*ast.Ident); ok && id.Name == "string" {
-				format = p
-			}
-		}
-	}
-
-	return &printfWrapper{
-		name:   name,
-		fn:     fn,
-		format: format,
-		args:   args,
-	}
-}
-
-// findPrintfLike scans the entire package to find printf-like functions.
-func findPrintfLike(pkg *Package) {
-	if vcfg.ImportPath == "" { // no type or vetx information; don't bother
-		return
-	}
-
-	// Gather potential wrappesr and call graph between them.
-	byName := make(map[string]*printfWrapper)
-	var wrappers []*printfWrapper
-	for _, file := range pkg.files {
-		if file.file == nil {
-			continue
-		}
-		for _, decl := range file.file.Decls {
-			w := maybePrintfWrapper(decl)
-			if w == nil {
-				continue
-			}
-			byName[w.name] = w
-			wrappers = append(wrappers, w)
-		}
-	}
-
-	// Walk the graph to figure out which are really printf wrappers.
-	for _, w := range wrappers {
-		// Scan function for calls that could be to other printf-like functions.
-		ast.Inspect(w.fn.Body, func(n ast.Node) bool {
-			if w.failed {
-				return false
-			}
-
-			// TODO: Relax these checks; issue 26555.
-			if assign, ok := n.(*ast.AssignStmt); ok {
-				for _, lhs := range assign.Lhs {
-					if match(lhs, w.format) || match(lhs, w.args) {
-						// Modifies the format
-						// string or args in
-						// some way, so not a
-						// simple wrapper.
-						w.failed = true
-						return false
-					}
-				}
-			}
-			if un, ok := n.(*ast.UnaryExpr); ok && un.Op == token.AND {
-				if match(un.X, w.format) || match(un.X, w.args) {
-					// Taking the address of the
-					// format string or args,
-					// so not a simple wrapper.
-					w.failed = true
-					return false
-				}
-			}
-
-			call, ok := n.(*ast.CallExpr)
-			if !ok || len(call.Args) == 0 || !match(call.Args[len(call.Args)-1], w.args) {
-				return true
-			}
-
-			pkgpath, name, kind := printfNameAndKind(pkg, call.Fun)
-			if kind != 0 {
-				checkPrintfFwd(pkg, w, call, kind)
-				return true
-			}
-
-			// If the call is to another function in this package,
-			// maybe we will find out it is printf-like later.
-			// Remember this call for later checking.
-			if pkgpath == "" && byName[name] != nil {
-				callee := byName[name]
-				callee.callers = append(callee.callers, printfCaller{w, call})
-			}
-
-			return true
-		})
-	}
-}
-
-func match(arg ast.Expr, param *ast.Field) bool {
-	id, ok := arg.(*ast.Ident)
-	return ok && id.Obj != nil && id.Obj.Decl == param
-}
-
-const (
-	kindPrintf = 1
-	kindPrint  = 2
-)
-
-// printfLike reports whether a call to fn should be considered a call to a printf-like function.
-// It returns 0 (indicating not a printf-like function), kindPrintf, or kindPrint.
-func printfLike(pkg *Package, fn ast.Expr, byName map[string]*printfWrapper) int {
-	if id, ok := fn.(*ast.Ident); ok && id.Obj != nil {
-		if w := byName[id.Name]; w != nil && id.Obj.Decl == w.fn {
-			// Found call to function in same package.
-			return localPrintfLike[id.Name]
-		}
-	}
-	if sel, ok := fn.(*ast.SelectorExpr); ok {
-		if id, ok := sel.X.(*ast.Ident); ok && id.Name == "fmt" && strings.Contains(sel.Sel.Name, "rint") {
-			if strings.HasSuffix(sel.Sel.Name, "f") {
-				return kindPrintf
-			}
-			return kindPrint
-		}
-	}
-	return 0
-}
-
-// checkPrintfFwd checks that a printf-forwarding wrapper is forwarding correctly.
-// It diagnoses writing fmt.Printf(format, args) instead of fmt.Printf(format, args...).
-func checkPrintfFwd(pkg *Package, w *printfWrapper, call *ast.CallExpr, kind int) {
-	matched := kind == kindPrint ||
-		kind == kindPrintf && len(call.Args) >= 2 && match(call.Args[len(call.Args)-2], w.format)
-	if !matched {
-		return
-	}
-
-	if !call.Ellipsis.IsValid() {
-		typ, ok := pkg.types[call.Fun].Type.(*types.Signature)
-		if !ok {
-			return
-		}
-		if len(call.Args) > typ.Params().Len() {
-			// If we're passing more arguments than what the
-			// print/printf function can take, adding an ellipsis
-			// would break the program. For example:
-			//
-			//   func foo(arg1 string, arg2 ...interface{} {
-			//       fmt.Printf("%s %v", arg1, arg2)
-			//   }
-			return
-		}
-		if !vcfg.VetxOnly {
-			desc := "printf"
-			if kind == kindPrint {
-				desc = "print"
-			}
-			pkg.files[0].Badf(call.Pos(), "missing ... in args forwarded to %s-like function", desc)
-		}
-		return
-	}
-	name := w.name
-	if localPrintfLike[name] == 0 {
-		localPrintfLike[name] = kind
-		for _, caller := range w.callers {
-			checkPrintfFwd(pkg, caller.w, caller.call, kind)
-		}
-	}
-}
-
-func exportPrintfLike() interface{} {
-	out := make([]printfExport, 0, len(localPrintfLike))
-	for name, kind := range localPrintfLike {
-		out = append(out, printfExport{
-			Name: name,
-			Kind: kind,
-		})
-	}
-	sort.Slice(out, func(i, j int) bool {
-		return out[i].Name < out[j].Name
-	})
-	return out
-}
-
-// isPrint records the print functions.
-// If a key ends in 'f' then it is assumed to be a formatted print.
-var isPrint = map[string]bool{
-	"fmt.Errorf":   true,
-	"fmt.Fprint":   true,
-	"fmt.Fprintf":  true,
-	"fmt.Fprintln": true,
-	"fmt.Print":    true,
-	"fmt.Printf":   true,
-	"fmt.Println":  true,
-	"fmt.Sprint":   true,
-	"fmt.Sprintf":  true,
-	"fmt.Sprintln": true,
-
-	// testing.B, testing.T not auto-detected
-	// because the methods are picked up by embedding.
-	"testing.B.Error":  true,
-	"testing.B.Errorf": true,
-	"testing.B.Fatal":  true,
-	"testing.B.Fatalf": true,
-	"testing.B.Log":    true,
-	"testing.B.Logf":   true,
-	"testing.B.Skip":   true,
-	"testing.B.Skipf":  true,
-	"testing.T.Error":  true,
-	"testing.T.Errorf": true,
-	"testing.T.Fatal":  true,
-	"testing.T.Fatalf": true,
-	"testing.T.Log":    true,
-	"testing.T.Logf":   true,
-	"testing.T.Skip":   true,
-	"testing.T.Skipf":  true,
-
-	// testing.TB is an interface, so can't detect wrapping.
-	"testing.TB.Error":  true,
-	"testing.TB.Errorf": true,
-	"testing.TB.Fatal":  true,
-	"testing.TB.Fatalf": true,
-	"testing.TB.Log":    true,
-	"testing.TB.Logf":   true,
-	"testing.TB.Skip":   true,
-	"testing.TB.Skipf":  true,
-}
-
-// formatString returns the format string argument and its index within
-// the given printf-like call expression.
-//
-// The last parameter before variadic arguments is assumed to be
-// a format string.
-//
-// The first string literal or string constant is assumed to be a format string
-// if the call's signature cannot be determined.
-//
-// If it cannot find any format string parameter, it returns ("", -1).
-func formatString(f *File, call *ast.CallExpr) (format string, idx int) {
-	typ := f.pkg.types[call.Fun].Type
-	if typ != nil {
-		if sig, ok := typ.(*types.Signature); ok {
-			if !sig.Variadic() {
-				// Skip checking non-variadic functions.
-				return "", -1
-			}
-			idx := sig.Params().Len() - 2
-			if idx < 0 {
-				// Skip checking variadic functions without
-				// fixed arguments.
-				return "", -1
-			}
-			s, ok := stringConstantArg(f, call, idx)
-			if !ok {
-				// The last argument before variadic args isn't a string.
-				return "", -1
-			}
-			return s, idx
-		}
-	}
-
-	// Cannot determine call's signature. Fall back to scanning for the first
-	// string constant in the call.
-	for idx := range call.Args {
-		if s, ok := stringConstantArg(f, call, idx); ok {
-			return s, idx
-		}
-		if f.pkg.types[call.Args[idx]].Type == types.Typ[types.String] {
-			// Skip checking a call with a non-constant format
-			// string argument, since its contents are unavailable
-			// for validation.
-			return "", -1
-		}
-	}
-	return "", -1
-}
-
-// stringConstantArg returns call's string constant argument at the index idx.
-//
-// ("", false) is returned if call's argument at the index idx isn't a string
-// constant.
-func stringConstantArg(f *File, call *ast.CallExpr, idx int) (string, bool) {
-	if idx >= len(call.Args) {
-		return "", false
-	}
-	arg := call.Args[idx]
-	lit := f.pkg.types[arg].Value
-	if lit != nil && lit.Kind() == constant.String {
-		return constant.StringVal(lit), true
-	}
-	return "", false
-}
-
-// checkCall triggers the print-specific checks if the call invokes a print function.
-func checkFmtPrintfCall(f *File, node ast.Node) {
-	if f.pkg.typesPkg == nil {
-		// This check now requires type information.
-		return
-	}
-
-	if d, ok := node.(*ast.FuncDecl); ok && isStringer(f, d) {
-		// Remember we saw this.
-		if f.stringerPtrs == nil {
-			f.stringerPtrs = make(map[*ast.Object]bool)
-		}
-		if l := d.Recv.List; len(l) == 1 {
-			if n := l[0].Names; len(n) == 1 {
-				typ := f.pkg.types[l[0].Type]
-				_, ptrRecv := typ.Type.(*types.Pointer)
-				f.stringerPtrs[n[0].Obj] = ptrRecv
-			}
-		}
-		return
-	}
-
-	call, ok := node.(*ast.CallExpr)
-	if !ok {
-		return
-	}
-
-	// Construct name like pkg.Printf or pkg.Type.Printf for lookup.
-	_, name, kind := printfNameAndKind(f.pkg, call.Fun)
-	if kind == kindPrintf {
-		f.checkPrintf(call, name)
-	}
-	if kind == kindPrint {
-		f.checkPrint(call, name)
-	}
-}
-
-func printfName(pkg *Package, called ast.Expr) (pkgpath, name string) {
-	switch x := called.(type) {
-	case *ast.Ident:
-		if fn, ok := pkg.uses[x].(*types.Func); ok {
-			if fn.Pkg() == nil || fn.Pkg() == pkg.typesPkg {
-				pkgpath = ""
-			} else {
-				pkgpath = fn.Pkg().Path()
-			}
-			return pkgpath, x.Name
-		}
-
-	case *ast.SelectorExpr:
-		// Check for "fmt.Printf".
-		if id, ok := x.X.(*ast.Ident); ok {
-			if pkgName, ok := pkg.uses[id].(*types.PkgName); ok {
-				return pkgName.Imported().Path(), x.Sel.Name
-			}
-		}
-
-		// Check for t.Logf where t is a *testing.T.
-		if sel := pkg.selectors[x]; sel != nil {
-			recv := sel.Recv()
-			if p, ok := recv.(*types.Pointer); ok {
-				recv = p.Elem()
-			}
-			if named, ok := recv.(*types.Named); ok {
-				obj := named.Obj()
-				if obj.Pkg() == nil || obj.Pkg() == pkg.typesPkg {
-					pkgpath = ""
-				} else {
-					pkgpath = obj.Pkg().Path()
-				}
-				return pkgpath, obj.Name() + "." + x.Sel.Name
-			}
-		}
-	}
-	return "", ""
-}
-
-func printfNameAndKind(pkg *Package, called ast.Expr) (pkgpath, name string, kind int) {
-	pkgpath, name = printfName(pkg, called)
-	if name == "" {
-		return pkgpath, name, 0
-	}
-
-	if pkgpath == "" {
-		kind = localPrintfLike[name]
-	} else if m, ok := printfImported[pkgpath]; ok {
-		kind = m[name]
-	} else {
-		var m map[string]int
-		if out, ok := readVetx(pkgpath, "printf").([]printfExport); ok {
-			m = make(map[string]int)
-			for _, x := range out {
-				m[x.Name] = x.Kind
-			}
-		}
-		printfImported[pkgpath] = m
-		kind = m[name]
-	}
-
-	if kind == 0 {
-		_, ok := isPrint[pkgpath+"."+name]
-		if !ok {
-			// Next look up just "printf", for use with -printfuncs.
-			short := name[strings.LastIndex(name, ".")+1:]
-			_, ok = isPrint[strings.ToLower(short)]
-		}
-		if ok {
-			if strings.HasSuffix(name, "f") {
-				kind = kindPrintf
-			} else {
-				kind = kindPrint
-			}
-		}
-	}
-	return pkgpath, name, kind
-}
-
-// isStringer returns true if the provided declaration is a "String() string"
-// method, an implementation of fmt.Stringer.
-func isStringer(f *File, d *ast.FuncDecl) bool {
-	return d.Recv != nil && d.Name.Name == "String" && d.Type.Results != nil &&
-		len(d.Type.Params.List) == 0 && len(d.Type.Results.List) == 1 &&
-		f.pkg.types[d.Type.Results.List[0].Type].Type == types.Typ[types.String]
-}
-
-// isFormatter reports whether t satisfies fmt.Formatter.
-// Unlike fmt.Stringer, it's impossible to satisfy fmt.Formatter without importing fmt.
-func (f *File) isFormatter(t types.Type) bool {
-	return formatterType != nil && types.Implements(t, formatterType)
-}
-
-// formatState holds the parsed representation of a printf directive such as "%3.*[4]d".
-// It is constructed by parsePrintfVerb.
-type formatState struct {
-	verb     rune   // the format verb: 'd' for "%d"
-	format   string // the full format directive from % through verb, "%.3d".
-	name     string // Printf, Sprintf etc.
-	flags    []byte // the list of # + etc.
-	argNums  []int  // the successive argument numbers that are consumed, adjusted to refer to actual arg in call
-	firstArg int    // Index of first argument after the format in the Printf call.
-	// Used only during parse.
-	file         *File
-	call         *ast.CallExpr
-	argNum       int  // Which argument we're expecting to format now.
-	hasIndex     bool // Whether the argument is indexed.
-	indexPending bool // Whether we have an indexed argument that has not resolved.
-	nbytes       int  // number of bytes of the format string consumed.
-}
-
-// checkPrintf checks a call to a formatted print routine such as Printf.
-func (f *File) checkPrintf(call *ast.CallExpr, name string) {
-	format, idx := formatString(f, call)
-	if idx < 0 {
-		if *verbose {
-			f.Warn(call.Pos(), "can't check non-constant format in call to", name)
-		}
-		return
-	}
-
-	firstArg := idx + 1 // Arguments are immediately after format string.
-	if !strings.Contains(format, "%") {
-		if len(call.Args) > firstArg {
-			f.Badf(call.Pos(), "%s call has arguments but no formatting directives", name)
-		}
-		return
-	}
-	// Hard part: check formats against args.
-	argNum := firstArg
-	maxArgNum := firstArg
-	anyIndex := false
-	for i, w := 0, 0; i < len(format); i += w {
-		w = 1
-		if format[i] != '%' {
-			continue
-		}
-		state := f.parsePrintfVerb(call, name, format[i:], firstArg, argNum)
-		if state == nil {
-			return
-		}
-		w = len(state.format)
-		if !f.okPrintfArg(call, state) { // One error per format is enough.
-			return
-		}
-		if state.hasIndex {
-			anyIndex = true
-		}
-		if len(state.argNums) > 0 {
-			// Continue with the next sequential argument.
-			argNum = state.argNums[len(state.argNums)-1] + 1
-		}
-		for _, n := range state.argNums {
-			if n >= maxArgNum {
-				maxArgNum = n + 1
-			}
-		}
-	}
-	// Dotdotdot is hard.
-	if call.Ellipsis.IsValid() && maxArgNum >= len(call.Args)-1 {
-		return
-	}
-	// If any formats are indexed, extra arguments are ignored.
-	if anyIndex {
-		return
-	}
-	// There should be no leftover arguments.
-	if maxArgNum != len(call.Args) {
-		expect := maxArgNum - firstArg
-		numArgs := len(call.Args) - firstArg
-		f.Badf(call.Pos(), "%s call needs %v but has %v", name, count(expect, "arg"), count(numArgs, "arg"))
-	}
-}
-
-// parseFlags accepts any printf flags.
-func (s *formatState) parseFlags() {
-	for s.nbytes < len(s.format) {
-		switch c := s.format[s.nbytes]; c {
-		case '#', '0', '+', '-', ' ':
-			s.flags = append(s.flags, c)
-			s.nbytes++
-		default:
-			return
-		}
-	}
-}
-
-// scanNum advances through a decimal number if present.
-func (s *formatState) scanNum() {
-	for ; s.nbytes < len(s.format); s.nbytes++ {
-		c := s.format[s.nbytes]
-		if c < '0' || '9' < c {
-			return
-		}
-	}
-}
-
-// parseIndex scans an index expression. It returns false if there is a syntax error.
-func (s *formatState) parseIndex() bool {
-	if s.nbytes == len(s.format) || s.format[s.nbytes] != '[' {
-		return true
-	}
-	// Argument index present.
-	s.nbytes++ // skip '['
-	start := s.nbytes
-	s.scanNum()
-	ok := true
-	if s.nbytes == len(s.format) || s.nbytes == start || s.format[s.nbytes] != ']' {
-		ok = false
-		s.nbytes = strings.Index(s.format, "]")
-		if s.nbytes < 0 {
-			s.file.Badf(s.call.Pos(), "%s format %s is missing closing ]", s.name, s.format)
-			return false
-		}
-	}
-	arg32, err := strconv.ParseInt(s.format[start:s.nbytes], 10, 32)
-	if err != nil || !ok || arg32 <= 0 || arg32 > int64(len(s.call.Args)-s.firstArg) {
-		s.file.Badf(s.call.Pos(), "%s format has invalid argument index [%s]", s.name, s.format[start:s.nbytes])
-		return false
-	}
-	s.nbytes++ // skip ']'
-	arg := int(arg32)
-	arg += s.firstArg - 1 // We want to zero-index the actual arguments.
-	s.argNum = arg
-	s.hasIndex = true
-	s.indexPending = true
-	return true
-}
-
-// parseNum scans a width or precision (or *). It returns false if there's a bad index expression.
-func (s *formatState) parseNum() bool {
-	if s.nbytes < len(s.format) && s.format[s.nbytes] == '*' {
-		if s.indexPending { // Absorb it.
-			s.indexPending = false
-		}
-		s.nbytes++
-		s.argNums = append(s.argNums, s.argNum)
-		s.argNum++
-	} else {
-		s.scanNum()
-	}
-	return true
-}
-
-// parsePrecision scans for a precision. It returns false if there's a bad index expression.
-func (s *formatState) parsePrecision() bool {
-	// If there's a period, there may be a precision.
-	if s.nbytes < len(s.format) && s.format[s.nbytes] == '.' {
-		s.flags = append(s.flags, '.') // Treat precision as a flag.
-		s.nbytes++
-		if !s.parseIndex() {
-			return false
-		}
-		if !s.parseNum() {
-			return false
-		}
-	}
-	return true
-}
-
-// parsePrintfVerb looks the formatting directive that begins the format string
-// and returns a formatState that encodes what the directive wants, without looking
-// at the actual arguments present in the call. The result is nil if there is an error.
-func (f *File) parsePrintfVerb(call *ast.CallExpr, name, format string, firstArg, argNum int) *formatState {
-	state := &formatState{
-		format:   format,
-		name:     name,
-		flags:    make([]byte, 0, 5),
-		argNum:   argNum,
-		argNums:  make([]int, 0, 1),
-		nbytes:   1, // There's guaranteed to be a percent sign.
-		firstArg: firstArg,
-		file:     f,
-		call:     call,
-	}
-	// There may be flags.
-	state.parseFlags()
-	// There may be an index.
-	if !state.parseIndex() {
-		return nil
-	}
-	// There may be a width.
-	if !state.parseNum() {
-		return nil
-	}
-	// There may be a precision.
-	if !state.parsePrecision() {
-		return nil
-	}
-	// Now a verb, possibly prefixed by an index (which we may already have).
-	if !state.indexPending && !state.parseIndex() {
-		return nil
-	}
-	if state.nbytes == len(state.format) {
-		f.Badf(call.Pos(), "%s format %s is missing verb at end of string", name, state.format)
-		return nil
-	}
-	verb, w := utf8.DecodeRuneInString(state.format[state.nbytes:])
-	state.verb = verb
-	state.nbytes += w
-	if verb != '%' {
-		state.argNums = append(state.argNums, state.argNum)
-	}
-	state.format = state.format[:state.nbytes]
-	return state
-}
-
-// printfArgType encodes the types of expressions a printf verb accepts. It is a bitmask.
-type printfArgType int
-
-const (
-	argBool printfArgType = 1 << iota
-	argInt
-	argRune
-	argString
-	argFloat
-	argComplex
-	argPointer
-	anyType printfArgType = ^0
-)
-
-type printVerb struct {
-	verb  rune   // User may provide verb through Formatter; could be a rune.
-	flags string // known flags are all ASCII
-	typ   printfArgType
-}
-
-// Common flag sets for printf verbs.
-const (
-	noFlag       = ""
-	numFlag      = " -+.0"
-	sharpNumFlag = " -+.0#"
-	allFlags     = " -+.0#"
-)
-
-// printVerbs identifies which flags are known to printf for each verb.
-var printVerbs = []printVerb{
-	// '-' is a width modifier, always valid.
-	// '.' is a precision for float, max width for strings.
-	// '+' is required sign for numbers, Go format for %v.
-	// '#' is alternate format for several verbs.
-	// ' ' is spacer for numbers
-	{'%', noFlag, 0},
-	{'b', numFlag, argInt | argFloat | argComplex},
-	{'c', "-", argRune | argInt},
-	{'d', numFlag, argInt | argPointer},
-	{'e', sharpNumFlag, argFloat | argComplex},
-	{'E', sharpNumFlag, argFloat | argComplex},
-	{'f', sharpNumFlag, argFloat | argComplex},
-	{'F', sharpNumFlag, argFloat | argComplex},
-	{'g', sharpNumFlag, argFloat | argComplex},
-	{'G', sharpNumFlag, argFloat | argComplex},
-	{'o', sharpNumFlag, argInt},
-	{'p', "-#", argPointer},
-	{'q', " -+.0#", argRune | argInt | argString},
-	{'s', " -+.0", argString},
-	{'t', "-", argBool},
-	{'T', "-", anyType},
-	{'U', "-#", argRune | argInt},
-	{'v', allFlags, anyType},
-	{'x', sharpNumFlag, argRune | argInt | argString | argPointer},
-	{'X', sharpNumFlag, argRune | argInt | argString | argPointer},
-}
-
-// okPrintfArg compares the formatState to the arguments actually present,
-// reporting any discrepancies it can discern. If the final argument is ellipsissed,
-// there's little it can do for that.
-func (f *File) okPrintfArg(call *ast.CallExpr, state *formatState) (ok bool) {
-	var v printVerb
-	found := false
-	// Linear scan is fast enough for a small list.
-	for _, v = range printVerbs {
-		if v.verb == state.verb {
-			found = true
-			break
-		}
-	}
-
-	// Does current arg implement fmt.Formatter?
-	formatter := false
-	if state.argNum < len(call.Args) {
-		if tv, ok := f.pkg.types[call.Args[state.argNum]]; ok {
-			formatter = f.isFormatter(tv.Type)
-		}
-	}
-
-	if !formatter {
-		if !found {
-			f.Badf(call.Pos(), "%s format %s has unknown verb %c", state.name, state.format, state.verb)
-			return false
-		}
-		for _, flag := range state.flags {
-			// TODO: Disable complaint about '0' for Go 1.10. To be fixed properly in 1.11.
-			// See issues 23598 and 23605.
-			if flag == '0' {
-				continue
-			}
-			if !strings.ContainsRune(v.flags, rune(flag)) {
-				f.Badf(call.Pos(), "%s format %s has unrecognized flag %c", state.name, state.format, flag)
-				return false
-			}
-		}
-	}
-	// Verb is good. If len(state.argNums)>trueArgs, we have something like %.*s and all
-	// but the final arg must be an integer.
-	trueArgs := 1
-	if state.verb == '%' {
-		trueArgs = 0
-	}
-	nargs := len(state.argNums)
-	for i := 0; i < nargs-trueArgs; i++ {
-		argNum := state.argNums[i]
-		if !f.argCanBeChecked(call, i, state) {
-			return
-		}
-		arg := call.Args[argNum]
-		if !f.matchArgType(argInt, nil, arg) {
-			f.Badf(call.Pos(), "%s format %s uses non-int %s as argument of *", state.name, state.format, f.gofmt(arg))
-			return false
-		}
-	}
-	if state.verb == '%' || formatter {
-		return true
-	}
-	argNum := state.argNums[len(state.argNums)-1]
-	if !f.argCanBeChecked(call, len(state.argNums)-1, state) {
-		return false
-	}
-	arg := call.Args[argNum]
-	if f.isFunctionValue(arg) && state.verb != 'p' && state.verb != 'T' {
-		f.Badf(call.Pos(), "%s format %s arg %s is a func value, not called", state.name, state.format, f.gofmt(arg))
-		return false
-	}
-	if !f.matchArgType(v.typ, nil, arg) {
-		typeString := ""
-		if typ := f.pkg.types[arg].Type; typ != nil {
-			typeString = typ.String()
-		}
-		f.Badf(call.Pos(), "%s format %s has arg %s of wrong type %s", state.name, state.format, f.gofmt(arg), typeString)
-		return false
-	}
-	if v.typ&argString != 0 && v.verb != 'T' && !bytes.Contains(state.flags, []byte{'#'}) && f.recursiveStringer(arg) {
-		f.Badf(call.Pos(), "%s format %s with arg %s causes recursive String method call", state.name, state.format, f.gofmt(arg))
-		return false
-	}
-	return true
-}
-
-// recursiveStringer reports whether the provided argument is r or &r for the
-// fmt.Stringer receiver identifier r.
-func (f *File) recursiveStringer(e ast.Expr) bool {
-	if len(f.stringerPtrs) == 0 {
-		return false
-	}
-	ptr := false
-	var obj *ast.Object
-	switch e := e.(type) {
-	case *ast.Ident:
-		obj = e.Obj
-	case *ast.UnaryExpr:
-		if id, ok := e.X.(*ast.Ident); ok && e.Op == token.AND {
-			obj = id.Obj
-			ptr = true
-		}
-	}
-
-	// It's unlikely to be a recursive stringer if it has a Format method.
-	if typ := f.pkg.types[e].Type; typ != nil {
-		if f.isFormatter(typ) {
-			return false
-		}
-	}
-
-	// We compare the underlying Object, which checks that the identifier
-	// is the one we declared as the receiver for the String method in
-	// which this printf appears.
-	ptrRecv, exist := f.stringerPtrs[obj]
-	if !exist {
-		return false
-	}
-	// We also need to check that using &t when we declared String
-	// on (t *T) is ok; in such a case, the address is printed.
-	if ptr && ptrRecv {
-		return false
-	}
-	return true
-}
-
-// isFunctionValue reports whether the expression is a function as opposed to a function call.
-// It is almost always a mistake to print a function value.
-func (f *File) isFunctionValue(e ast.Expr) bool {
-	if typ := f.pkg.types[e].Type; typ != nil {
-		_, ok := typ.(*types.Signature)
-		return ok
-	}
-	return false
-}
-
-// argCanBeChecked reports whether the specified argument is statically present;
-// it may be beyond the list of arguments or in a terminal slice... argument, which
-// means we can't see it.
-func (f *File) argCanBeChecked(call *ast.CallExpr, formatArg int, state *formatState) bool {
-	argNum := state.argNums[formatArg]
-	if argNum <= 0 {
-		// Shouldn't happen, so catch it with prejudice.
-		panic("negative arg num")
-	}
-	if argNum < len(call.Args)-1 {
-		return true // Always OK.
-	}
-	if call.Ellipsis.IsValid() {
-		return false // We just can't tell; there could be many more arguments.
-	}
-	if argNum < len(call.Args) {
-		return true
-	}
-	// There are bad indexes in the format or there are fewer arguments than the format needs.
-	// This is the argument number relative to the format: Printf("%s", "hi") will give 1 for the "hi".
-	arg := argNum - state.firstArg + 1 // People think of arguments as 1-indexed.
-	f.Badf(call.Pos(), "%s format %s reads arg #%d, but call has %v", state.name, state.format, arg, count(len(call.Args)-state.firstArg, "arg"))
-	return false
-}
-
-// printFormatRE is the regexp we match and report as a possible format string
-// in the first argument to unformatted prints like fmt.Print.
-// We exclude the space flag, so that printing a string like "x % y" is not reported as a format.
-var printFormatRE = regexp.MustCompile(`%` + flagsRE + numOptRE + `\.?` + numOptRE + indexOptRE + verbRE)
-
-const (
-	flagsRE    = `[+\-#]*`
-	indexOptRE = `(\[[0-9]+\])?`
-	numOptRE   = `([0-9]+|` + indexOptRE + `\*)?`
-	verbRE     = `[bcdefgopqstvxEFGTUX]`
-)
-
-// checkPrint checks a call to an unformatted print routine such as Println.
-func (f *File) checkPrint(call *ast.CallExpr, name string) {
-	firstArg := 0
-	typ := f.pkg.types[call.Fun].Type
-	if typ == nil {
-		// Skip checking functions with unknown type.
-		return
-	}
-	if sig, ok := typ.(*types.Signature); ok {
-		if !sig.Variadic() {
-			// Skip checking non-variadic functions.
-			return
-		}
-		params := sig.Params()
-		firstArg = params.Len() - 1
-
-		typ := params.At(firstArg).Type()
-		typ = typ.(*types.Slice).Elem()
-		it, ok := typ.(*types.Interface)
-		if !ok || !it.Empty() {
-			// Skip variadic functions accepting non-interface{} args.
-			return
-		}
-	}
-	args := call.Args
-	if len(args) <= firstArg {
-		// Skip calls without variadic args.
-		return
-	}
-	args = args[firstArg:]
-
-	if firstArg == 0 {
-		if sel, ok := call.Args[0].(*ast.SelectorExpr); ok {
-			if x, ok := sel.X.(*ast.Ident); ok {
-				if x.Name == "os" && strings.HasPrefix(sel.Sel.Name, "Std") {
-					f.Badf(call.Pos(), "%s does not take io.Writer but has first arg %s", name, f.gofmt(call.Args[0]))
-				}
-			}
-		}
-	}
-
-	arg := args[0]
-	if lit, ok := arg.(*ast.BasicLit); ok && lit.Kind == token.STRING {
-		// Ignore trailing % character in lit.Value.
-		// The % in "abc 0.0%" couldn't be a formatting directive.
-		s := strings.TrimSuffix(lit.Value, `%"`)
-		if strings.Contains(s, "%") {
-			m := printFormatRE.FindStringSubmatch(s)
-			if m != nil {
-				f.Badf(call.Pos(), "%s call has possible formatting directive %s", name, m[0])
-			}
-		}
-	}
-	if strings.HasSuffix(name, "ln") {
-		// The last item, if a string, should not have a newline.
-		arg = args[len(args)-1]
-		if lit, ok := arg.(*ast.BasicLit); ok && lit.Kind == token.STRING {
-			str, _ := strconv.Unquote(lit.Value)
-			if strings.HasSuffix(str, "\n") {
-				f.Badf(call.Pos(), "%s arg list ends with redundant newline", name)
-			}
-		}
-	}
-	for _, arg := range args {
-		if f.isFunctionValue(arg) {
-			f.Badf(call.Pos(), "%s arg %s is a func value, not called", name, f.gofmt(arg))
-		}
-		if f.recursiveStringer(arg) {
-			f.Badf(call.Pos(), "%s arg %s causes recursive call to String method", name, f.gofmt(arg))
-		}
-	}
-}
-
-// count(n, what) returns "1 what" or "N whats"
-// (assuming the plural of what is whats).
-func count(n int, what string) string {
-	if n == 1 {
-		return "1 " + what
-	}
-	return fmt.Sprintf("%d %ss", n, what)
-}
diff --git a/vendor/golang.org/x/tools/go/analysis/printf/testdata/src/a/a.go b/vendor/golang.org/x/tools/go/analysis/printf/testdata/src/a/a.go
deleted file mode 100644
index 88163b59..00000000
--- a/vendor/golang.org/x/tools/go/analysis/printf/testdata/src/a/a.go
+++ /dev/null
@@ -1,647 +0,0 @@
-// Copyright 2010 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// This file contains tests for the printf checker.
-
-package testdata
-
-import (
-	"fmt"
-	logpkg "log" // renamed to make it harder to see
-	"math"
-	"os"
-	"testing"
-	"unsafe" // just for test case printing unsafe.Pointer
-	// For testing printf-like functions from external package.
-	// "github.com/foobar/externalprintf"
-)
-
-func UnsafePointerPrintfTest() {
-	var up unsafe.Pointer
-	fmt.Printf("%p, %x %X", up, up, up)
-}
-
-// Error methods that do not satisfy the Error interface and should be checked.
-type errorTest1 int
-
-func (errorTest1) Error(...interface{}) string {
-	return "hi"
-}
-
-type errorTest2 int // Analogous to testing's *T type.
-func (errorTest2) Error(...interface{}) {
-}
-
-type errorTest3 int
-
-func (errorTest3) Error() { // No return value.
-}
-
-type errorTest4 int
-
-func (errorTest4) Error() int { // Different return type.
-	return 3
-}
-
-type errorTest5 int
-
-func (errorTest5) error() { // niladic; don't complain if no args (was bug)
-}
-
-// This function never executes, but it serves as a simple test for the program.
-// Test with make test.
-func PrintfTests() {
-	var b bool
-	var i int
-	var r rune
-	var s string
-	var x float64
-	var p *int
-	var imap map[int]int
-	var fslice []float64
-	var c complex64
-	// Some good format/argtypes
-	fmt.Printf("")
-	fmt.Printf("%b %b %b", 3, i, x)
-	fmt.Printf("%c %c %c %c", 3, i, 'x', r)
-	fmt.Printf("%d %d %d", 3, i, imap)
-	fmt.Printf("%e %e %e %e", 3e9, x, fslice, c)
-	fmt.Printf("%E %E %E %E", 3e9, x, fslice, c)
-	fmt.Printf("%f %f %f %f", 3e9, x, fslice, c)
-	fmt.Printf("%F %F %F %F", 3e9, x, fslice, c)
-	fmt.Printf("%g %g %g %g", 3e9, x, fslice, c)
-	fmt.Printf("%G %G %G %G", 3e9, x, fslice, c)
-	fmt.Printf("%b %b %b %b", 3e9, x, fslice, c)
-	fmt.Printf("%o %o", 3, i)
-	fmt.Printf("%p", p)
-	fmt.Printf("%q %q %q %q", 3, i, 'x', r)
-	fmt.Printf("%s %s %s", "hi", s, []byte{65})
-	fmt.Printf("%t %t", true, b)
-	fmt.Printf("%T %T", 3, i)
-	fmt.Printf("%U %U", 3, i)
-	fmt.Printf("%v %v", 3, i)
-	fmt.Printf("%x %x %x %x", 3, i, "hi", s)
-	fmt.Printf("%X %X %X %X", 3, i, "hi", s)
-	fmt.Printf("%.*s %d %g", 3, "hi", 23, 2.3)
-	fmt.Printf("%s", &stringerv)
-	fmt.Printf("%v", &stringerv)
-	fmt.Printf("%T", &stringerv)
-	fmt.Printf("%s", &embeddedStringerv)
-	fmt.Printf("%v", &embeddedStringerv)
-	fmt.Printf("%T", &embeddedStringerv)
-	fmt.Printf("%v", notstringerv)
-	fmt.Printf("%T", notstringerv)
-	fmt.Printf("%q", stringerarrayv)
-	fmt.Printf("%v", stringerarrayv)
-	fmt.Printf("%s", stringerarrayv)
-	fmt.Printf("%v", notstringerarrayv)
-	fmt.Printf("%T", notstringerarrayv)
-	fmt.Printf("%d", new(fmt.Formatter))
-	fmt.Printf("%*%", 2)               // Ridiculous but allowed.
-	fmt.Printf("%s", interface{}(nil)) // Nothing useful we can say.
-
-	fmt.Printf("%g", 1+2i)
-	fmt.Printf("%#e %#E %#f %#F %#g %#G", 1.2, 1.2, 1.2, 1.2, 1.2, 1.2) // OK since Go 1.9
-	// Some bad format/argTypes
-	fmt.Printf("%b", "hi")                      // ERROR "Printf format %b has arg \x22hi\x22 of wrong type string"
-	fmt.Printf("%t", c)                         // ERROR "Printf format %t has arg c of wrong type complex64"
-	fmt.Printf("%t", 1+2i)                      // ERROR "Printf format %t has arg 1 \+ 2i of wrong type complex128"
-	fmt.Printf("%c", 2.3)                       // ERROR "Printf format %c has arg 2.3 of wrong type float64"
-	fmt.Printf("%d", 2.3)                       // ERROR "Printf format %d has arg 2.3 of wrong type float64"
-	fmt.Printf("%e", "hi")                      // ERROR "Printf format %e has arg \x22hi\x22 of wrong type string"
-	fmt.Printf("%E", true)                      // ERROR "Printf format %E has arg true of wrong type bool"
-	fmt.Printf("%f", "hi")                      // ERROR "Printf format %f has arg \x22hi\x22 of wrong type string"
-	fmt.Printf("%F", 'x')                       // ERROR "Printf format %F has arg 'x' of wrong type rune"
-	fmt.Printf("%g", "hi")                      // ERROR "Printf format %g has arg \x22hi\x22 of wrong type string"
-	fmt.Printf("%g", imap)                      // ERROR "Printf format %g has arg imap of wrong type map\[int\]int"
-	fmt.Printf("%G", i)                         // ERROR "Printf format %G has arg i of wrong type int"
-	fmt.Printf("%o", x)                         // ERROR "Printf format %o has arg x of wrong type float64"
-	fmt.Printf("%p", nil)                       // ERROR "Printf format %p has arg nil of wrong type untyped nil"
-	fmt.Printf("%p", 23)                        // ERROR "Printf format %p has arg 23 of wrong type int"
-	fmt.Printf("%q", x)                         // ERROR "Printf format %q has arg x of wrong type float64"
-	fmt.Printf("%s", b)                         // ERROR "Printf format %s has arg b of wrong type bool"
-	fmt.Printf("%s", byte(65))                  // ERROR "Printf format %s has arg byte\(65\) of wrong type byte"
-	fmt.Printf("%t", 23)                        // ERROR "Printf format %t has arg 23 of wrong type int"
-	fmt.Printf("%U", x)                         // ERROR "Printf format %U has arg x of wrong type float64"
-	fmt.Printf("%x", nil)                       // ERROR "Printf format %x has arg nil of wrong type untyped nil"
-	fmt.Printf("%X", 2.3)                       // ERROR "Printf format %X has arg 2.3 of wrong type float64"
-	fmt.Printf("%s", stringerv)                 // ERROR "Printf format %s has arg stringerv of wrong type testdata.ptrStringer"
-	fmt.Printf("%t", stringerv)                 // ERROR "Printf format %t has arg stringerv of wrong type testdata.ptrStringer"
-	fmt.Printf("%s", embeddedStringerv)         // ERROR "Printf format %s has arg embeddedStringerv of wrong type testdata.embeddedStringer"
-	fmt.Printf("%t", embeddedStringerv)         // ERROR "Printf format %t has arg embeddedStringerv of wrong type testdata.embeddedStringer"
-	fmt.Printf("%q", notstringerv)              // ERROR "Printf format %q has arg notstringerv of wrong type testdata.notstringer"
-	fmt.Printf("%t", notstringerv)              // ERROR "Printf format %t has arg notstringerv of wrong type testdata.notstringer"
-	fmt.Printf("%t", stringerarrayv)            // ERROR "Printf format %t has arg stringerarrayv of wrong type testdata.stringerarray"
-	fmt.Printf("%t", notstringerarrayv)         // ERROR "Printf format %t has arg notstringerarrayv of wrong type testdata.notstringerarray"
-	fmt.Printf("%q", notstringerarrayv)         // ERROR "Printf format %q has arg notstringerarrayv of wrong type testdata.notstringerarray"
-	fmt.Printf("%d", BoolFormatter(true))       // ERROR "Printf format %d has arg BoolFormatter\(true\) of wrong type testdata.BoolFormatter"
-	fmt.Printf("%z", FormatterVal(true))        // correct (the type is responsible for formatting)
-	fmt.Printf("%d", FormatterVal(true))        // correct (the type is responsible for formatting)
-	fmt.Printf("%s", nonemptyinterface)         // correct (the type is responsible for formatting)
-	fmt.Printf("%.*s %d %6g", 3, "hi", 23, 'x') // ERROR "Printf format %6g has arg 'x' of wrong type rune"
-	fmt.Println()                               // not an error
-	fmt.Println("%s", "hi")                     // ERROR "Println call has possible formatting directive %s"
-	fmt.Println("%v", "hi")                     // ERROR "Println call has possible formatting directive %v"
-	fmt.Println("%T", "hi")                     // ERROR "Println call has possible formatting directive %T"
-	fmt.Println("0.0%")                         // correct (trailing % couldn't be a formatting directive)
-	fmt.Printf("%s", "hi", 3)                   // ERROR "Printf call needs 1 arg but has 2 args"
-	_ = fmt.Sprintf("%"+("s"), "hi", 3)         // ERROR "Sprintf call needs 1 arg but has 2 args"
-	fmt.Printf("%s%%%d", "hi", 3)               // correct
-	fmt.Printf("%08s", "woo")                   // correct
-	fmt.Printf("% 8s", "woo")                   // correct
-	fmt.Printf("%.*d", 3, 3)                    // correct
-	fmt.Printf("%.*d x", 3, 3, 3, 3)            // ERROR "Printf call needs 2 args but has 4 args"
-	fmt.Printf("%.*d x", "hi", 3)               // ERROR "Printf format %.*d uses non-int \x22hi\x22 as argument of \*"
-	fmt.Printf("%.*d x", i, 3)                  // correct
-	fmt.Printf("%.*d x", s, 3)                  // ERROR "Printf format %.\*d uses non-int s as argument of \*"
-	fmt.Printf("%*% x", 0.22)                   // ERROR "Printf format %\*% uses non-int 0.22 as argument of \*"
-	fmt.Printf("%q %q", multi()...)             // ok
-	fmt.Printf("%#q", `blah`)                   // ok
-	// printf("now is the time", "buddy")          // no error "printf call has arguments but no formatting directives"
-	Printf("now is the time", "buddy") // ERROR "Printf call has arguments but no formatting directives"
-	Printf("hi")                       // ok
-	const format = "%s %s\n"
-	Printf(format, "hi", "there")
-	Printf(format, "hi")              // ERROR "Printf format %s reads arg #2, but call has 1 arg$"
-	Printf("%s %d %.3v %q", "str", 4) // ERROR "Printf format %.3v reads arg #3, but call has 2 args"
-	f := new(ptrStringer)
-	f.Warn(0, "%s", "hello", 3)           // ERROR "Warn call has possible formatting directive %s"
-	f.Warnf(0, "%s", "hello", 3)          // ERROR "Warnf call needs 1 arg but has 2 args"
-	f.Warnf(0, "%r", "hello")             // ERROR "Warnf format %r has unknown verb r"
-	f.Warnf(0, "%#s", "hello")            // ERROR "Warnf format %#s has unrecognized flag #"
-	f.Warn2(0, "%s", "hello", 3)          // ERROR "Warn2 call has possible formatting directive %s"
-	f.Warnf2(0, "%s", "hello", 3)         // ERROR "Warnf2 call needs 1 arg but has 2 args"
-	f.Warnf2(0, "%r", "hello")            // ERROR "Warnf2 format %r has unknown verb r"
-	f.Warnf2(0, "%#s", "hello")           // ERROR "Warnf2 format %#s has unrecognized flag #"
-	f.Wrap(0, "%s", "hello", 3)           // ERROR "Wrap call has possible formatting directive %s"
-	f.Wrapf(0, "%s", "hello", 3)          // ERROR "Wrapf call needs 1 arg but has 2 args"
-	f.Wrapf(0, "%r", "hello")             // ERROR "Wrapf format %r has unknown verb r"
-	f.Wrapf(0, "%#s", "hello")            // ERROR "Wrapf format %#s has unrecognized flag #"
-	f.Wrap2(0, "%s", "hello", 3)          // ERROR "Wrap2 call has possible formatting directive %s"
-	f.Wrapf2(0, "%s", "hello", 3)         // ERROR "Wrapf2 call needs 1 arg but has 2 args"
-	f.Wrapf2(0, "%r", "hello")            // ERROR "Wrapf2 format %r has unknown verb r"
-	f.Wrapf2(0, "%#s", "hello")           // ERROR "Wrapf2 format %#s has unrecognized flag #"
-	fmt.Printf("%#s", FormatterVal(true)) // correct (the type is responsible for formatting)
-	Printf("d%", 2)                       // ERROR "Printf format % is missing verb at end of string"
-	Printf("%d", percentDV)
-	Printf("%d", &percentDV)
-	Printf("%d", notPercentDV)  // ERROR "Printf format %d has arg notPercentDV of wrong type testdata.notPercentDStruct"
-	Printf("%d", &notPercentDV) // ERROR "Printf format %d has arg &notPercentDV of wrong type \*testdata.notPercentDStruct"
-	Printf("%p", &notPercentDV) // Works regardless: we print it as a pointer.
-	Printf("%q", &percentDV)    // ERROR "Printf format %q has arg &percentDV of wrong type \*testdata.percentDStruct"
-	Printf("%s", percentSV)
-	Printf("%s", &percentSV)
-	// Good argument reorderings.
-	Printf("%[1]d", 3)
-	Printf("%[1]*d", 3, 1)
-	Printf("%[2]*[1]d", 1, 3)
-	Printf("%[2]*.[1]*[3]d", 2, 3, 4)
-	fmt.Fprintf(os.Stderr, "%[2]*.[1]*[3]d", 2, 3, 4) // Use Fprintf to make sure we count arguments correctly.
-	// Bad argument reorderings.
-	Printf("%[xd", 3)                      // ERROR "Printf format %\[xd is missing closing \]"
-	Printf("%[x]d x", 3)                   // ERROR "Printf format has invalid argument index \[x\]"
-	Printf("%[3]*s x", "hi", 2)            // ERROR "Printf format has invalid argument index \[3\]"
-	_ = fmt.Sprintf("%[3]d x", 2)          // ERROR "Sprintf format has invalid argument index \[3\]"
-	Printf("%[2]*.[1]*[3]d x", 2, "hi", 4) // ERROR "Printf format %\[2]\*\.\[1\]\*\[3\]d uses non-int \x22hi\x22 as argument of \*"
-	Printf("%[0]s x", "arg1")              // ERROR "Printf format has invalid argument index \[0\]"
-	Printf("%[0]d x", 1)                   // ERROR "Printf format has invalid argument index \[0\]"
-	// Something that satisfies the error interface.
-	var e error
-	fmt.Println(e.Error()) // ok
-	// Something that looks like an error interface but isn't, such as the (*T).Error method
-	// in the testing package.
-	var et1 *testing.T
-	et1.Error()        // ok
-	et1.Error("hi")    // ok
-	et1.Error("%d", 3) // ERROR "Error call has possible formatting directive %d"
-	var et3 errorTest3
-	et3.Error() // ok, not an error method.
-	var et4 errorTest4
-	et4.Error() // ok, not an error method.
-	var et5 errorTest5
-	et5.error() // ok, not an error method.
-	// Interfaces can be used with any verb.
-	var iface interface {
-		ToTheMadness() bool // Method ToTheMadness usually returns false
-	}
-	fmt.Printf("%f", iface) // ok: fmt treats interfaces as transparent and iface may well have a float concrete type
-	// Can't print a function.
-	Printf("%d", someFunction) // ERROR "Printf format %d arg someFunction is a func value, not called"
-	Printf("%v", someFunction) // ERROR "Printf format %v arg someFunction is a func value, not called"
-	Println(someFunction)      // ERROR "Println arg someFunction is a func value, not called"
-	Printf("%p", someFunction) // ok: maybe someone wants to see the pointer
-	Printf("%T", someFunction) // ok: maybe someone wants to see the type
-	// Bug: used to recur forever.
-	Printf("%p %x", recursiveStructV, recursiveStructV.next)
-	Printf("%p %x", recursiveStruct1V, recursiveStruct1V.next)
-	Printf("%p %x", recursiveSliceV, recursiveSliceV)
-	Printf("%p %x", recursiveMapV, recursiveMapV)
-	// Special handling for Log.
-	math.Log(3) // OK
-	var t *testing.T
-	t.Log("%d", 3) // ERROR "Log call has possible formatting directive %d"
-	t.Logf("%d", 3)
-	t.Logf("%d", "hi") // ERROR "Logf format %d has arg \x22hi\x22 of wrong type string"
-
-	Errorf(1, "%d", 3)    // OK
-	Errorf(1, "%d", "hi") // ERROR "Errorf format %d has arg \x22hi\x22 of wrong type string"
-
-	// Multiple string arguments before variadic args
-	errorf("WARNING", "foobar")            // OK
-	errorf("INFO", "s=%s, n=%d", "foo", 1) // OK
-	errorf("ERROR", "%d")                  // no error "errorf format %d reads arg #1, but call has 0 args"
-
-	// Printf from external package
-	// externalprintf.Printf("%d", 42) // OK
-	// externalprintf.Printf("foobar") // OK
-	// level := 123
-	// externalprintf.Logf(level, "%d", 42)                        // OK
-	// externalprintf.Errorf(level, level, "foo %q bar", "foobar") // OK
-	// externalprintf.Logf(level, "%d")                            // no error "Logf format %d reads arg #1, but call has 0 args"
-	// var formatStr = "%s %s"
-	// externalprintf.Sprintf(formatStr, "a", "b")     // OK
-	// externalprintf.Logf(level, formatStr, "a", "b") // OK
-
-	// user-defined Println-like functions
-	ss := &someStruct{}
-	ss.Log(someFunction, "foo")          // OK
-	ss.Error(someFunction, someFunction) // OK
-	ss.Println()                         // OK
-	ss.Println(1.234, "foo")             // OK
-	ss.Println(1, someFunction)          // no error "Println arg someFunction is a func value, not called"
-	ss.log(someFunction)                 // OK
-	ss.log(someFunction, "bar", 1.33)    // OK
-	ss.log(someFunction, someFunction)   // no error "log arg someFunction is a func value, not called"
-
-	// indexed arguments
-	Printf("%d %[3]d %d %[2]d x", 1, 2, 3, 4)             // OK
-	Printf("%d %[0]d %d %[2]d x", 1, 2, 3, 4)             // ERROR "Printf format has invalid argument index \[0\]"
-	Printf("%d %[3]d %d %[-2]d x", 1, 2, 3, 4)            // ERROR "Printf format has invalid argument index \[-2\]"
-	Printf("%d %[3]d %d %[2234234234234]d x", 1, 2, 3, 4) // ERROR "Printf format has invalid argument index \[2234234234234\]"
-	Printf("%d %[3]d %-10d %[2]d x", 1, 2, 3)             // ERROR "Printf format %-10d reads arg #4, but call has 3 args"
-	Printf("%[1][3]d x", 1, 2)                            // ERROR "Printf format %\[1\]\[ has unknown verb \["
-	Printf("%[1]d x", 1, 2)                               // OK
-	Printf("%d %[3]d %d %[2]d x", 1, 2, 3, 4, 5)          // OK
-
-	// wrote Println but meant Fprintln
-	Printf("%p\n", os.Stdout)   // OK
-	Println(os.Stdout, "hello") // ERROR "Println does not take io.Writer but has first arg os.Stdout"
-
-	Printf(someString(), "hello") // OK
-
-	// Printf wrappers in package log should be detected automatically
-	logpkg.Fatal("%d", 1)    // ERROR "Fatal call has possible formatting directive %d"
-	logpkg.Fatalf("%d", "x") // ERROR "Fatalf format %d has arg \x22x\x22 of wrong type string"
-	logpkg.Fatalln("%d", 1)  // ERROR "Fatalln call has possible formatting directive %d"
-	logpkg.Panic("%d", 1)    // ERROR "Panic call has possible formatting directive %d"
-	logpkg.Panicf("%d", "x") // ERROR "Panicf format %d has arg \x22x\x22 of wrong type string"
-	logpkg.Panicln("%d", 1)  // ERROR "Panicln call has possible formatting directive %d"
-	logpkg.Print("%d", 1)    // ERROR "Print call has possible formatting directive %d"
-	logpkg.Printf("%d", "x") // ERROR "Printf format %d has arg \x22x\x22 of wrong type string"
-	logpkg.Println("%d", 1)  // ERROR "Println call has possible formatting directive %d"
-
-	// Methods too.
-	var l *logpkg.Logger
-	l.Fatal("%d", 1)    // ERROR "Fatal call has possible formatting directive %d"
-	l.Fatalf("%d", "x") // ERROR "Fatalf format %d has arg \x22x\x22 of wrong type string"
-	l.Fatalln("%d", 1)  // ERROR "Fatalln call has possible formatting directive %d"
-	l.Panic("%d", 1)    // ERROR "Panic call has possible formatting directive %d"
-	l.Panicf("%d", "x") // ERROR "Panicf format %d has arg \x22x\x22 of wrong type string"
-	l.Panicln("%d", 1)  // ERROR "Panicln call has possible formatting directive %d"
-	l.Print("%d", 1)    // ERROR "Print call has possible formatting directive %d"
-	l.Printf("%d", "x") // ERROR "Printf format %d has arg \x22x\x22 of wrong type string"
-	l.Println("%d", 1)  // ERROR "Println call has possible formatting directive %d"
-
-	// Issue 26486
-	dbg("", 1) // no error "call has arguments but no formatting directive"
-}
-
-func someString() string { return "X" }
-
-type someStruct struct{}
-
-// Log is non-variadic user-define Println-like function.
-// Calls to this func must be skipped when checking
-// for Println-like arguments.
-func (ss *someStruct) Log(f func(), s string) {}
-
-// Error is variadic user-define Println-like function.
-// Calls to this func mustn't be checked for Println-like arguments,
-// since variadic arguments type isn't interface{}.
-func (ss *someStruct) Error(args ...func()) {}
-
-// Println is variadic user-defined Println-like function.
-// Calls to this func must be checked for Println-like arguments.
-func (ss *someStruct) Println(args ...interface{}) {}
-
-// log is variadic user-defined Println-like function.
-// Calls to this func must be checked for Println-like arguments.
-func (ss *someStruct) log(f func(), args ...interface{}) {}
-
-// A function we use as a function value; it has no other purpose.
-func someFunction() {}
-
-// Printf is used by the test so we must declare it.
-func Printf(format string, args ...interface{}) {
-	fmt.Printf(format, args...)
-}
-
-// Println is used by the test so we must declare it.
-func Println(args ...interface{}) {
-	fmt.Println(args...)
-}
-
-// printf is used by the test so we must declare it.
-func printf(format string, args ...interface{}) {
-	fmt.Printf(format, args...)
-}
-
-// Errorf is used by the test for a case in which the first parameter
-// is not a format string.
-func Errorf(i int, format string, args ...interface{}) {
-	_ = fmt.Errorf(format, args...)
-}
-
-// errorf is used by the test for a case in which the function accepts multiple
-// string parameters before variadic arguments
-func errorf(level, format string, args ...interface{}) {
-	_ = fmt.Errorf(format, args...)
-}
-
-// multi is used by the test.
-func multi() []interface{} {
-	panic("don't call - testing only")
-}
-
-type stringer int
-
-func (stringer) String() string { return "string" }
-
-type ptrStringer float64
-
-var stringerv ptrStringer
-
-func (*ptrStringer) String() string {
-	return "string"
-}
-
-func (p *ptrStringer) Warn2(x int, args ...interface{}) string {
-	return p.Warn(x, args...)
-}
-
-func (p *ptrStringer) Warnf2(x int, format string, args ...interface{}) string {
-	return p.Warnf(x, format, args...)
-}
-
-func (*ptrStringer) Warn(x int, args ...interface{}) string {
-	return "warn"
-}
-
-func (*ptrStringer) Warnf(x int, format string, args ...interface{}) string {
-	return "warnf"
-}
-
-func (p *ptrStringer) Wrap2(x int, args ...interface{}) string {
-	return p.Wrap(x, args...)
-}
-
-func (p *ptrStringer) Wrapf2(x int, format string, args ...interface{}) string {
-	return p.Wrapf(x, format, args...)
-}
-
-func (*ptrStringer) Wrap(x int, args ...interface{}) string {
-	return fmt.Sprint(args...)
-}
-
-func (*ptrStringer) Wrapf(x int, format string, args ...interface{}) string {
-	return fmt.Sprintf(format, args...)
-}
-
-func (*ptrStringer) BadWrap(x int, args ...interface{}) string {
-	return fmt.Sprint(args) // ERROR "missing ... in args forwarded to print-like function"
-}
-
-func (*ptrStringer) BadWrapf(x int, format string, args ...interface{}) string {
-	return fmt.Sprintf(format, args) // ERROR "missing ... in args forwarded to printf-like function"
-}
-
-func (*ptrStringer) WrapfFalsePositive(x int, arg1 string, arg2 ...interface{}) string {
-	return fmt.Sprintf("%s %v", arg1, arg2)
-}
-
-type embeddedStringer struct {
-	foo string
-	ptrStringer
-	bar int
-}
-
-var embeddedStringerv embeddedStringer
-
-type notstringer struct {
-	f float64
-}
-
-var notstringerv notstringer
-
-type stringerarray [4]float64
-
-func (stringerarray) String() string {
-	return "string"
-}
-
-var stringerarrayv stringerarray
-
-type notstringerarray [4]float64
-
-var notstringerarrayv notstringerarray
-
-var nonemptyinterface = interface {
-	f()
-}(nil)
-
-// A data type we can print with "%d".
-type percentDStruct struct {
-	a int
-	b []byte
-	c *float64
-}
-
-var percentDV percentDStruct
-
-// A data type we cannot print correctly with "%d".
-type notPercentDStruct struct {
-	a int
-	b []byte
-	c bool
-}
-
-var notPercentDV notPercentDStruct
-
-// A data type we can print with "%s".
-type percentSStruct struct {
-	a string
-	b []byte
-	C stringerarray
-}
-
-var percentSV percentSStruct
-
-type recursiveStringer int
-
-func (s recursiveStringer) String() string {
-	_ = fmt.Sprintf("%d", s)
-	_ = fmt.Sprintf("%#v", s)
-	_ = fmt.Sprintf("%v", s)  // ERROR "Sprintf format %v with arg s causes recursive String method call"
-	_ = fmt.Sprintf("%v", &s) // ERROR "Sprintf format %v with arg &s causes recursive String method call"
-	_ = fmt.Sprintf("%T", s)  // ok; does not recursively call String
-	return fmt.Sprintln(s)    // ERROR "Sprintln arg s causes recursive call to String method"
-}
-
-type recursivePtrStringer int
-
-func (p *recursivePtrStringer) String() string {
-	_ = fmt.Sprintf("%v", *p)
-	_ = fmt.Sprint(&p)     // ok; prints address
-	return fmt.Sprintln(p) // ERROR "Sprintln arg p causes recursive call to String method"
-}
-
-type BoolFormatter bool
-
-func (*BoolFormatter) Format(fmt.State, rune) {
-}
-
-// Formatter with value receiver
-type FormatterVal bool
-
-func (FormatterVal) Format(fmt.State, rune) {
-}
-
-type RecursiveSlice []RecursiveSlice
-
-var recursiveSliceV = &RecursiveSlice{}
-
-type RecursiveMap map[int]RecursiveMap
-
-var recursiveMapV = make(RecursiveMap)
-
-type RecursiveStruct struct {
-	next *RecursiveStruct
-}
-
-var recursiveStructV = &RecursiveStruct{}
-
-type RecursiveStruct1 struct {
-	next *RecursiveStruct2
-}
-
-type RecursiveStruct2 struct {
-	next *RecursiveStruct1
-}
-
-var recursiveStruct1V = &RecursiveStruct1{}
-
-type unexportedInterface struct {
-	f interface{}
-}
-
-// Issue 17798: unexported ptrStringer cannot be formatted.
-type unexportedStringer struct {
-	t ptrStringer
-}
-type unexportedStringerOtherFields struct {
-	s string
-	t ptrStringer
-	S string
-}
-
-// Issue 17798: unexported error cannot be formatted.
-type unexportedError struct {
-	e error
-}
-type unexportedErrorOtherFields struct {
-	s string
-	e error
-	S string
-}
-
-type errorer struct{}
-
-func (e errorer) Error() string { return "errorer" }
-
-type unexportedCustomError struct {
-	e errorer
-}
-
-type errorInterface interface {
-	error
-	ExtraMethod()
-}
-
-type unexportedErrorInterface struct {
-	e errorInterface
-}
-
-func UnexportedStringerOrError() {
-	fmt.Printf("%s", unexportedInterface{"foo"}) // ok; prints {foo}
-	fmt.Printf("%s", unexportedInterface{3})     // ok; we can't see the problem
-
-	us := unexportedStringer{}
-	fmt.Printf("%s", us)  // ERROR "Printf format %s has arg us of wrong type testdata.unexportedStringer"
-	fmt.Printf("%s", &us) // ERROR "Printf format %s has arg &us of wrong type [*]testdata.unexportedStringer"
-
-	usf := unexportedStringerOtherFields{
-		s: "foo",
-		S: "bar",
-	}
-	fmt.Printf("%s", usf)  // ERROR "Printf format %s has arg usf of wrong type testdata.unexportedStringerOtherFields"
-	fmt.Printf("%s", &usf) // ERROR "Printf format %s has arg &usf of wrong type [*]testdata.unexportedStringerOtherFields"
-
-	ue := unexportedError{
-		e: &errorer{},
-	}
-	fmt.Printf("%s", ue)  // ERROR "Printf format %s has arg ue of wrong type testdata.unexportedError"
-	fmt.Printf("%s", &ue) // ERROR "Printf format %s has arg &ue of wrong type [*]testdata.unexportedError"
-
-	uef := unexportedErrorOtherFields{
-		s: "foo",
-		e: &errorer{},
-		S: "bar",
-	}
-	fmt.Printf("%s", uef)  // ERROR "Printf format %s has arg uef of wrong type testdata.unexportedErrorOtherFields"
-	fmt.Printf("%s", &uef) // ERROR "Printf format %s has arg &uef of wrong type [*]testdata.unexportedErrorOtherFields"
-
-	uce := unexportedCustomError{
-		e: errorer{},
-	}
-	fmt.Printf("%s", uce) // ERROR "Printf format %s has arg uce of wrong type testdata.unexportedCustomError"
-
-	uei := unexportedErrorInterface{}
-	fmt.Printf("%s", uei)       // ERROR "Printf format %s has arg uei of wrong type testdata.unexportedErrorInterface"
-	fmt.Println("foo\n", "bar") // not an error
-
-	fmt.Println("foo\n")  // ERROR "Println arg list ends with redundant newline"
-	fmt.Println("foo\\n") // not an error
-	fmt.Println(`foo\n`)  // not an error
-
-	intSlice := []int{3, 4}
-	fmt.Printf("%s", intSlice) // ERROR "Printf format %s has arg intSlice of wrong type \[\]int"
-	nonStringerArray := [1]unexportedStringer{{}}
-	fmt.Printf("%s", nonStringerArray)  // ERROR "Printf format %s has arg nonStringerArray of wrong type \[1\]testdata.unexportedStringer"
-	fmt.Printf("%s", []stringer{3, 4})  // not an error
-	fmt.Printf("%s", [2]stringer{3, 4}) // not an error
-}
-
-// TODO: Disable complaint about '0' for Go 1.10. To be fixed properly in 1.11.
-// See issues 23598 and 23605.
-func DisableErrorForFlag0() {
-	fmt.Printf("%0t", true)
-}
-
-// Issue 26486.
-func dbg(format string, args ...interface{}) {
-	if format == "" {
-		format = "%v"
-	}
-	fmt.Printf(format, args...)
-}
diff --git a/vendor/golang.org/x/tools/go/analysis/singlechecker/singlechecker.go b/vendor/golang.org/x/tools/go/analysis/singlechecker/singlechecker.go
index da540220..5194183d 100644
--- a/vendor/golang.org/x/tools/go/analysis/singlechecker/singlechecker.go
+++ b/vendor/golang.org/x/tools/go/analysis/singlechecker/singlechecker.go
@@ -33,6 +33,7 @@ import (
 	"golang.org/x/tools/go/analysis"
 	"golang.org/x/tools/go/analysis/internal/analysisflags"
 	"golang.org/x/tools/go/analysis/internal/checker"
+	"golang.org/x/tools/go/analysis/unitchecker"
 )
 
 // Main is the main function for a checker command for a single analysis.
@@ -67,7 +68,10 @@ func Main(a *analysis.Analyzer) {
 		os.Exit(1)
 	}
 
-	if err := checker.Run(args, analyzers); err != nil {
-		log.Fatal(err)
+	if len(args) == 1 && strings.HasSuffix(args[0], ".cfg") {
+		unitchecker.Run(args[0], analyzers)
+		panic("unreachable")
 	}
+
+	os.Exit(checker.Run(args, analyzers))
 }
diff --git a/vendor/golang.org/x/tools/go/analysis/unitchecker/testdata/src/a/a.go b/vendor/golang.org/x/tools/go/analysis/unitchecker/testdata/src/a/a.go
new file mode 100644
index 00000000..9765e19a
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/unitchecker/testdata/src/a/a.go
@@ -0,0 +1,7 @@
+package a
+
+func _() {
+	MyFunc123()
+}
+
+func MyFunc123() {}
diff --git a/vendor/golang.org/x/tools/go/analysis/unitchecker/testdata/src/b/b.go b/vendor/golang.org/x/tools/go/analysis/unitchecker/testdata/src/b/b.go
new file mode 100644
index 00000000..a7b61254
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/unitchecker/testdata/src/b/b.go
@@ -0,0 +1,10 @@
+package b
+
+import "a"
+
+func _() {
+	a.MyFunc123()
+	MyFunc123()
+}
+
+func MyFunc123() {}
diff --git a/vendor/golang.org/x/tools/go/analysis/unitchecker/unitchecker.go b/vendor/golang.org/x/tools/go/analysis/unitchecker/unitchecker.go
new file mode 100644
index 00000000..59489f92
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/unitchecker/unitchecker.go
@@ -0,0 +1,382 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// The unitchecker package defines the main function for an analysis
+// driver that analyzes a single compilation unit during a build.
+// It is invoked by a build system such as "go vet":
+//
+//   $ go vet -vettool=$(which vet)
+//
+// It supports the following command-line protocol:
+//
+//      -V=full         describe executable               (to the build tool)
+//      -flags          describe flags                    (to the build tool)
+//      foo.cfg         description of compilation unit (from the build tool)
+//
+// This package does not depend on go/packages.
+// If you need a standalone tool, use multichecker,
+// which supports this mode but can also load packages
+// from source using go/packages.
+package unitchecker
+
+// TODO(adonovan):
+// - with gccgo, go build does not build standard library,
+//   so we will not get to analyze it. Yet we must in order
+//   to create base facts for, say, the fmt package for the
+//   printf checker.
+
+import (
+	"encoding/gob"
+	"encoding/json"
+	"flag"
+	"fmt"
+	"go/ast"
+	"go/build"
+	"go/importer"
+	"go/parser"
+	"go/token"
+	"go/types"
+	"io"
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"sort"
+	"strings"
+	"sync"
+	"time"
+
+	"golang.org/x/tools/go/analysis"
+	"golang.org/x/tools/go/analysis/internal/analysisflags"
+	"golang.org/x/tools/go/analysis/internal/facts"
+)
+
+// A Config describes a compilation unit to be analyzed.
+// It is provided to the tool in a JSON-encoded file
+// whose name ends with ".cfg".
+type Config struct {
+	ID                        string // e.g. "fmt [fmt.test]"
+	Compiler                  string
+	Dir                       string
+	ImportPath                string
+	GoFiles                   []string
+	NonGoFiles                []string
+	ImportMap                 map[string]string
+	PackageFile               map[string]string
+	Standard                  map[string]bool
+	PackageVetx               map[string]string
+	VetxOnly                  bool
+	VetxOutput                string
+	SucceedOnTypecheckFailure bool
+}
+
+// Main is the main function of a vet-like analysis tool that must be
+// invoked by a build system to analyze a single package.
+//
+// The protocol required by 'go vet -vettool=...' is that the tool must support:
+//
+//      -flags          describe flags in JSON
+//      -V=full         describe executable for build caching
+//      foo.cfg         perform separate modular analyze on the single
+//                      unit described by a JSON config file foo.cfg.
+//
+func Main(analyzers ...*analysis.Analyzer) {
+	progname := filepath.Base(os.Args[0])
+	log.SetFlags(0)
+	log.SetPrefix(progname + ": ")
+
+	if err := analysis.Validate(analyzers); err != nil {
+		log.Fatal(err)
+	}
+
+	flag.Usage = func() {
+		fmt.Fprintf(os.Stderr, `%[1]s is a tool for static analysis of Go programs.
+
+Usage of %[1]s:
+	%.16[1]s unit.cfg	# execute analysis specified by config file
+	%.16[1]s help    	# general help
+	%.16[1]s help name	# help on specific analyzer and its flags
+`, progname)
+		os.Exit(1)
+	}
+
+	analyzers = analysisflags.Parse(analyzers, true)
+
+	args := flag.Args()
+	if len(args) == 0 {
+		flag.Usage()
+	}
+	if args[0] == "help" {
+		analysisflags.Help(progname, analyzers, args[1:])
+		os.Exit(0)
+	}
+	if len(args) != 1 || !strings.HasSuffix(args[0], ".cfg") {
+		log.Fatalf("invalid command: want .cfg file (this reduced version of %s is intended to be run only by the 'go vet' command)", progname)
+	}
+	Run(args[0], analyzers)
+}
+
+// Run reads the *.cfg file, runs the analysis,
+// and calls os.Exit with an appropriate error code.
+// It assumes flags have already been set.
+func Run(configFile string, analyzers []*analysis.Analyzer) {
+	cfg, err := readConfig(configFile)
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	fset := token.NewFileSet()
+	results, err := run(fset, cfg, analyzers)
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	// In VetxOnly mode, the analysis is run only for facts.
+	if !cfg.VetxOnly {
+		if analysisflags.JSON {
+			// JSON output
+			tree := make(analysisflags.JSONTree)
+			for _, res := range results {
+				tree.Add(fset, cfg.ID, res.a.Name, res.diagnostics, res.err)
+			}
+			tree.Print()
+		} else {
+			// plain text
+			exit := 0
+			for _, res := range results {
+				if res.err != nil {
+					log.Println(res.err)
+					exit = 1
+				}
+			}
+			for _, res := range results {
+				for _, diag := range res.diagnostics {
+					analysisflags.PrintPlain(fset, diag)
+					exit = 1
+				}
+			}
+			os.Exit(exit)
+		}
+	}
+
+	os.Exit(0)
+}
+
+func readConfig(filename string) (*Config, error) {
+	data, err := ioutil.ReadFile(filename)
+	if err != nil {
+		return nil, err
+	}
+	cfg := new(Config)
+	if err := json.Unmarshal(data, cfg); err != nil {
+		return nil, fmt.Errorf("cannot decode JSON config file %s: %v", filename, err)
+	}
+	if len(cfg.GoFiles) == 0 {
+		// The go command disallows packages with no files.
+		// The only exception is unsafe, but the go command
+		// doesn't call vet on it.
+		return nil, fmt.Errorf("package has no files: %s", cfg.ImportPath)
+	}
+	return cfg, nil
+}
+
+func run(fset *token.FileSet, cfg *Config, analyzers []*analysis.Analyzer) ([]result, error) {
+	// Load, parse, typecheck.
+	var files []*ast.File
+	for _, name := range cfg.GoFiles {
+		f, err := parser.ParseFile(fset, name, nil, parser.ParseComments)
+		if err != nil {
+			if cfg.SucceedOnTypecheckFailure {
+				// Silently succeed; let the compiler
+				// report parse errors.
+				err = nil
+			}
+			return nil, err
+		}
+		files = append(files, f)
+	}
+	compilerImporter := importer.For(cfg.Compiler, func(path string) (io.ReadCloser, error) {
+		// path is a resolved package path, not an import path.
+		file, ok := cfg.PackageFile[path]
+		if !ok {
+			if cfg.Compiler == "gccgo" && cfg.Standard[path] {
+				return nil, nil // fall back to default gccgo lookup
+			}
+			return nil, fmt.Errorf("no package file for %q", path)
+		}
+		return os.Open(file)
+	})
+	importer := importerFunc(func(importPath string) (*types.Package, error) {
+		path, ok := cfg.ImportMap[importPath] // resolve vendoring, etc
+		if !ok {
+			return nil, fmt.Errorf("can't resolve import %q", path)
+		}
+		return compilerImporter.Import(path)
+	})
+	tc := &types.Config{
+		Importer: importer,
+		Sizes:    types.SizesFor("gc", build.Default.GOARCH), // assume gccgo  gc?
+	}
+	info := &types.Info{
+		Types:      make(map[ast.Expr]types.TypeAndValue),
+		Defs:       make(map[*ast.Ident]types.Object),
+		Uses:       make(map[*ast.Ident]types.Object),
+		Implicits:  make(map[ast.Node]types.Object),
+		Scopes:     make(map[ast.Node]*types.Scope),
+		Selections: make(map[*ast.SelectorExpr]*types.Selection),
+	}
+	pkg, err := tc.Check(cfg.ImportPath, fset, files, info)
+	if err != nil {
+		if cfg.SucceedOnTypecheckFailure {
+			// Silently succeed; let the compiler
+			// report type errors.
+			err = nil
+		}
+		return nil, err
+	}
+
+	// Register fact types with gob.
+	// In VetxOnly mode, analyzers are only for their facts,
+	// so we can skip any analysis that neither produces facts
+	// nor depends on any analysis that produces facts.
+	// Also build a map to hold working state and result.
+	type action struct {
+		once        sync.Once
+		result      interface{}
+		err         error
+		usesFacts   bool // (transitively uses)
+		diagnostics []analysis.Diagnostic
+	}
+	actions := make(map[*analysis.Analyzer]*action)
+	var registerFacts func(a *analysis.Analyzer) bool
+	registerFacts = func(a *analysis.Analyzer) bool {
+		act, ok := actions[a]
+		if !ok {
+			act = new(action)
+			var usesFacts bool
+			for _, f := range a.FactTypes {
+				usesFacts = true
+				gob.Register(f)
+			}
+			for _, req := range a.Requires {
+				if registerFacts(req) {
+					usesFacts = true
+				}
+			}
+			act.usesFacts = usesFacts
+			actions[a] = act
+		}
+		return act.usesFacts
+	}
+	var filtered []*analysis.Analyzer
+	for _, a := range analyzers {
+		if registerFacts(a) || !cfg.VetxOnly {
+			filtered = append(filtered, a)
+		}
+	}
+	analyzers = filtered
+
+	// Read facts from imported packages.
+	read := func(path string) ([]byte, error) {
+		if vetx, ok := cfg.PackageVetx[path]; ok {
+			return ioutil.ReadFile(vetx)
+		}
+		return nil, nil // no .vetx file, no facts
+	}
+	facts, err := facts.Decode(pkg, read)
+	if err != nil {
+		return nil, err
+	}
+
+	// In parallel, execute the DAG of analyzers.
+	var exec func(a *analysis.Analyzer) *action
+	var execAll func(analyzers []*analysis.Analyzer)
+	exec = func(a *analysis.Analyzer) *action {
+		act := actions[a]
+		act.once.Do(func() {
+			execAll(a.Requires) // prefetch dependencies in parallel
+
+			// The inputs to this analysis are the
+			// results of its prerequisites.
+			inputs := make(map[*analysis.Analyzer]interface{})
+			var failed []string
+			for _, req := range a.Requires {
+				reqact := exec(req)
+				if reqact.err != nil {
+					failed = append(failed, req.String())
+					continue
+				}
+				inputs[req] = reqact.result
+			}
+
+			// Report an error if any dependency failed.
+			if failed != nil {
+				sort.Strings(failed)
+				act.err = fmt.Errorf("failed prerequisites: %s", strings.Join(failed, ", "))
+				return
+			}
+
+			pass := &analysis.Pass{
+				Analyzer:          a,
+				Fset:              fset,
+				Files:             files,
+				OtherFiles:        cfg.NonGoFiles,
+				Pkg:               pkg,
+				TypesInfo:         info,
+				ResultOf:          inputs,
+				Report:            func(d analysis.Diagnostic) { act.diagnostics = append(act.diagnostics, d) },
+				ImportObjectFact:  facts.ImportObjectFact,
+				ExportObjectFact:  facts.ExportObjectFact,
+				ImportPackageFact: facts.ImportPackageFact,
+				ExportPackageFact: facts.ExportPackageFact,
+			}
+
+			t0 := time.Now()
+			act.result, act.err = a.Run(pass)
+			if false {
+				log.Printf("analysis %s = %s", pass, time.Since(t0))
+			}
+		})
+		return act
+	}
+	execAll = func(analyzers []*analysis.Analyzer) {
+		var wg sync.WaitGroup
+		for _, a := range analyzers {
+			wg.Add(1)
+			go func(a *analysis.Analyzer) {
+				_ = exec(a)
+				wg.Done()
+			}(a)
+		}
+		wg.Wait()
+	}
+
+	execAll(analyzers)
+
+	// Return diagnostics and errors from root analyzers.
+	results := make([]result, len(analyzers))
+	for i, a := range analyzers {
+		act := actions[a]
+		results[i].a = a
+		results[i].err = act.err
+		results[i].diagnostics = act.diagnostics
+	}
+
+	data := facts.Encode()
+	if err := ioutil.WriteFile(cfg.VetxOutput, data, 0666); err != nil {
+		return nil, fmt.Errorf("failed to write analysis facts: %v", err)
+	}
+
+	return results, nil
+}
+
+type result struct {
+	a           *analysis.Analyzer
+	diagnostics []analysis.Diagnostic
+	err         error
+}
+
+type importerFunc func(path string) (*types.Package, error)
+
+func (f importerFunc) Import(path string) (*types.Package, error) { return f(path) }
diff --git a/vendor/golang.org/x/tools/go/analysis/unitchecker/unitchecker_test.go b/vendor/golang.org/x/tools/go/analysis/unitchecker/unitchecker_test.go
new file mode 100644
index 00000000..3fc12a5b
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/analysis/unitchecker/unitchecker_test.go
@@ -0,0 +1,108 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build go1.12
+
+package unitchecker_test
+
+// This test depends on features such as
+// go vet's support for vetx files (1.11) and
+// the (*os.ProcessState).ExitCode method (1.12).
+
+import (
+	"flag"
+	"os"
+	"os/exec"
+	"runtime"
+	"strings"
+	"testing"
+
+	"golang.org/x/tools/go/analysis/analysistest"
+	"golang.org/x/tools/go/analysis/passes/findcall"
+	"golang.org/x/tools/go/analysis/passes/printf"
+	"golang.org/x/tools/go/analysis/unitchecker"
+)
+
+func TestMain(m *testing.M) {
+	if os.Getenv("UNITCHECKER_CHILD") == "1" {
+		// child process
+		main()
+		panic("unreachable")
+	}
+
+	// test
+	flag.Parse()
+	os.Exit(m.Run())
+}
+
+func main() {
+	unitchecker.Main(
+		findcall.Analyzer,
+		printf.Analyzer,
+	)
+}
+
+// This is a very basic integration test of modular
+// analysis with facts using unitchecker under "go vet".
+// It fork/execs the main function above.
+func TestIntegration(t *testing.T) {
+	if runtime.GOOS != "linux" {
+		t.Skipf("skipping fork/exec test on this platform")
+	}
+
+	testdata := analysistest.TestData()
+
+	const wantA = `# a
+testdata/src/a/a.go:4:11: call of MyFunc123(...)
+`
+	const wantB = `# b
+testdata/src/b/b.go:6:13: call of MyFunc123(...)
+testdata/src/b/b.go:7:11: call of MyFunc123(...)
+`
+	const wantAJSON = `# a
+{
+	"a": {
+		"findcall": [
+			{
+				"posn": "$GOPATH/src/a/a.go:4:11",
+				"message": "call of MyFunc123(...)"
+			}
+		]
+	}
+}
+`
+
+	for _, test := range []struct {
+		args     string
+		wantOut  string
+		wantExit int
+	}{
+		{args: "a", wantOut: wantA, wantExit: 2},
+		{args: "b", wantOut: wantB, wantExit: 2},
+		{args: "a b", wantOut: wantA + wantB, wantExit: 2},
+		{args: "-json a", wantOut: wantAJSON, wantExit: 0},
+		{args: "-c=0 a", wantOut: wantA + "4		MyFunc123()\n", wantExit: 2},
+	} {
+		cmd := exec.Command("go", "vet", "-vettool="+os.Args[0], "-findcall.name=MyFunc123")
+		cmd.Args = append(cmd.Args, strings.Fields(test.args)...)
+		cmd.Env = append(os.Environ(),
+			"UNITCHECKER_CHILD=1",
+			"GOPATH="+testdata,
+		)
+
+		out, err := cmd.CombinedOutput()
+		exitcode := 0
+		if exitErr, ok := err.(*exec.ExitError); ok {
+			exitcode = exitErr.ExitCode()
+		}
+		if exitcode != test.wantExit {
+			t.Errorf("%s: got exit code %d, want %d", test.args, exitcode, test.wantExit)
+		}
+		got := strings.Replace(string(out), testdata, "$GOPATH", -1)
+
+		if got != test.wantOut {
+			t.Errorf("%s: got <<%s>>, want <<%s>>", test.args, got, test.wantOut)
+		}
+	}
+}
diff --git a/vendor/golang.org/x/tools/go/ast/astutil/imports.go b/vendor/golang.org/x/tools/go/ast/astutil/imports.go
index 04ad6795..3e4b1953 100644
--- a/vendor/golang.org/x/tools/go/ast/astutil/imports.go
+++ b/vendor/golang.org/x/tools/go/ast/astutil/imports.go
@@ -14,26 +14,26 @@ import (
 )
 
 // AddImport adds the import path to the file f, if absent.
-func AddImport(fset *token.FileSet, f *ast.File, ipath string) (added bool) {
-	return AddNamedImport(fset, f, "", ipath)
+func AddImport(fset *token.FileSet, f *ast.File, path string) (added bool) {
+	return AddNamedImport(fset, f, "", path)
 }
 
-// AddNamedImport adds the import path to the file f, if absent.
+// AddNamedImport adds the import with the given name and path to the file f, if absent.
 // If name is not empty, it is used to rename the import.
 //
 // For example, calling
 //	AddNamedImport(fset, f, "pathpkg", "path")
 // adds
 //	import pathpkg "path"
-func AddNamedImport(fset *token.FileSet, f *ast.File, name, ipath string) (added bool) {
-	if imports(f, ipath) {
+func AddNamedImport(fset *token.FileSet, f *ast.File, name, path string) (added bool) {
+	if imports(f, name, path) {
 		return false
 	}
 
 	newImport := &ast.ImportSpec{
 		Path: &ast.BasicLit{
 			Kind:  token.STRING,
-			Value: strconv.Quote(ipath),
+			Value: strconv.Quote(path),
 		},
 	}
 	if name != "" {
@@ -43,14 +43,14 @@ func AddNamedImport(fset *token.FileSet, f *ast.File, name, ipath string) (added
 	// Find an import decl to add to.
 	// The goal is to find an existing import
 	// whose import path has the longest shared
-	// prefix with ipath.
+	// prefix with path.
 	var (
 		bestMatch  = -1         // length of longest shared prefix
 		lastImport = -1         // index in f.Decls of the file's final import decl
 		impDecl    *ast.GenDecl // import decl containing the best match
 		impIndex   = -1         // spec index in impDecl containing the best match
 
-		isThirdPartyPath = isThirdParty(ipath)
+		isThirdPartyPath = isThirdParty(path)
 	)
 	for i, decl := range f.Decls {
 		gen, ok := decl.(*ast.GenDecl)
@@ -81,7 +81,7 @@ func AddNamedImport(fset *token.FileSet, f *ast.File, name, ipath string) (added
 			for j, spec := range gen.Specs {
 				impspec := spec.(*ast.ImportSpec)
 				p := importPath(impspec)
-				n := matchLen(p, ipath)
+				n := matchLen(p, path)
 				if n > bestMatch || (bestMatch == 0 && !seenAnyThirdParty && isThirdPartyPath) {
 					bestMatch = n
 					impDecl = gen
@@ -197,11 +197,13 @@ func isThirdParty(importPath string) bool {
 }
 
 // DeleteImport deletes the import path from the file f, if present.
+// If there are duplicate import declarations, all matching ones are deleted.
 func DeleteImport(fset *token.FileSet, f *ast.File, path string) (deleted bool) {
 	return DeleteNamedImport(fset, f, "", path)
 }
 
 // DeleteNamedImport deletes the import with the given name and path from the file f, if present.
+// If there are duplicate import declarations, all matching ones are deleted.
 func DeleteNamedImport(fset *token.FileSet, f *ast.File, name, path string) (deleted bool) {
 	var delspecs []*ast.ImportSpec
 	var delcomments []*ast.CommentGroup
@@ -216,13 +218,7 @@ func DeleteNamedImport(fset *token.FileSet, f *ast.File, name, path string) (del
 		for j := 0; j < len(gen.Specs); j++ {
 			spec := gen.Specs[j]
 			impspec := spec.(*ast.ImportSpec)
-			if impspec.Name == nil && name != "" {
-				continue
-			}
-			if impspec.Name != nil && impspec.Name.Name != name {
-				continue
-			}
-			if importPath(impspec) != path {
+			if importName(impspec) != name || importPath(impspec) != path {
 				continue
 			}
 
@@ -383,9 +379,14 @@ func (fn visitFn) Visit(node ast.Node) ast.Visitor {
 	return fn
 }
 
-// imports returns true if f imports path.
-func imports(f *ast.File, path string) bool {
-	return importSpec(f, path) != nil
+// imports reports whether f has an import with the specified name and path.
+func imports(f *ast.File, name, path string) bool {
+	for _, s := range f.Imports {
+		if importName(s) == name && importPath(s) == path {
+			return true
+		}
+	}
+	return false
 }
 
 // importSpec returns the import spec if f imports path,
@@ -399,14 +400,23 @@ func importSpec(f *ast.File, path string) *ast.ImportSpec {
 	return nil
 }
 
+// importName returns the name of s,
+// or "" if the import is not named.
+func importName(s *ast.ImportSpec) string {
+	if s.Name == nil {
+		return ""
+	}
+	return s.Name.Name
+}
+
 // importPath returns the unquoted import path of s,
 // or "" if the path is not properly quoted.
 func importPath(s *ast.ImportSpec) string {
 	t, err := strconv.Unquote(s.Path.Value)
-	if err == nil {
-		return t
+	if err != nil {
+		return ""
 	}
-	return ""
+	return t
 }
 
 // declImports reports whether gen contains an import of path.
diff --git a/vendor/golang.org/x/tools/go/ast/astutil/imports_test.go b/vendor/golang.org/x/tools/go/ast/astutil/imports_test.go
index da775ef4..1d86e477 100644
--- a/vendor/golang.org/x/tools/go/ast/astutil/imports_test.go
+++ b/vendor/golang.org/x/tools/go/ast/astutil/imports_test.go
@@ -30,7 +30,7 @@ func print(t *testing.T, name string, f *ast.File) string {
 	if err := format.Node(&buf, fset, f); err != nil {
 		t.Fatalf("%s gofmt: %v", name, err)
 	}
-	return string(buf.Bytes())
+	return buf.String()
 }
 
 type test struct {
@@ -39,7 +39,7 @@ type test struct {
 	pkg        string
 	in         string
 	out        string
-	broken     bool // known broken
+	unchanged  bool // Expect added/deleted return value to be false.
 }
 
 var addTests = []test{
@@ -58,6 +58,7 @@ import (
 	"os"
 )
 `,
+		unchanged: true,
 	},
 	{
 		name: "import.1",
@@ -657,6 +658,117 @@ import (
 )
 `,
 	},
+
+	// Issue 28605: Add specified import, even if that import path is imported under another name
+	{
+		name:       "issue 28605 add unnamed path",
+		renamedPkg: "",
+		pkg:        "path",
+		in: `package main
+
+import (
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+		out: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+	},
+	{
+		name:       "issue 28605 add pathpkg-renamed path",
+		renamedPkg: "pathpkg",
+		pkg:        "path",
+		in: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+)
+`,
+		out: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+	},
+	{
+		name:       "issue 28605 add blank identifier path",
+		renamedPkg: "_",
+		pkg:        "path",
+		in: `package main
+
+import (
+	"path"
+	. "path"
+	pathpkg "path"
+)
+`,
+		out: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+	},
+	{
+		name:       "issue 28605 add dot import path",
+		renamedPkg: ".",
+		pkg:        "path",
+		in: `package main
+
+import (
+	"path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+		out: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+	},
+
+	{
+		name:       "duplicate import declarations, add existing one",
+		renamedPkg: "f",
+		pkg:        "fmt",
+		in: `package main
+
+import "fmt"
+import "fmt"
+import f "fmt"
+import f "fmt"
+`,
+		out: `package main
+
+import "fmt"
+import "fmt"
+import f "fmt"
+import f "fmt"
+`,
+		unchanged: true,
+	},
 }
 
 func TestAddImport(t *testing.T) {
@@ -664,18 +776,26 @@ func TestAddImport(t *testing.T) {
 		file := parse(t, test.name, test.in)
 		var before bytes.Buffer
 		ast.Fprint(&before, fset, file, nil)
-		AddNamedImport(fset, file, test.renamedPkg, test.pkg)
+		added := AddNamedImport(fset, file, test.renamedPkg, test.pkg)
 		if got := print(t, test.name, file); got != test.out {
-			if test.broken {
-				t.Logf("%s is known broken:\ngot: %s\nwant: %s", test.name, got, test.out)
-			} else {
-				t.Errorf("%s:\ngot: %s\nwant: %s", test.name, got, test.out)
-			}
+			t.Errorf("first run: %s:\ngot: %s\nwant: %s", test.name, got, test.out)
 			var after bytes.Buffer
 			ast.Fprint(&after, fset, file, nil)
-
 			t.Logf("AST before:\n%s\nAST after:\n%s\n", before.String(), after.String())
 		}
+		if got, want := added, !test.unchanged; got != want {
+			t.Errorf("first run: %s: added = %v, want %v", test.name, got, want)
+		}
+
+		// AddNamedImport should be idempotent. Verify that by calling it again,
+		// expecting no change to the AST, and the returned added value to always be false.
+		added = AddNamedImport(fset, file, test.renamedPkg, test.pkg)
+		if got := print(t, test.name, file); got != test.out {
+			t.Errorf("second run: %s:\ngot: %s\nwant: %s", test.name, got, test.out)
+		}
+		if got, want := added, false; got != want {
+			t.Errorf("second run: %s: added = %v, want %v", test.name, got, want)
+		}
 	}
 }
 
@@ -1405,14 +1525,161 @@ import (
 )
 `,
 	},
+
+	// Issue 28605: Delete specified import, even if that import path is imported under another name
+	{
+		name:       "import.38",
+		renamedPkg: "",
+		pkg:        "path",
+		in: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+		out: `package main
+
+import (
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+	},
+	{
+		name:       "import.39",
+		renamedPkg: "pathpkg",
+		pkg:        "path",
+		in: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+		out: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+)
+`,
+	},
+	{
+		name:       "import.40",
+		renamedPkg: "_",
+		pkg:        "path",
+		in: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+		out: `package main
+
+import (
+	"path"
+	. "path"
+	pathpkg "path"
+)
+`,
+	},
+	{
+		name:       "import.41",
+		renamedPkg: ".",
+		pkg:        "path",
+		in: `package main
+
+import (
+	"path"
+	. "path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+		out: `package main
+
+import (
+	"path"
+	_ "path"
+	pathpkg "path"
+)
+`,
+	},
+
+	// Duplicate import declarations, all matching ones are deleted.
+	{
+		name:       "import.42",
+		renamedPkg: "f",
+		pkg:        "fmt",
+		in: `package main
+
+import "fmt"
+import "fmt"
+import f "fmt"
+import f "fmt"
+`,
+		out: `package main
+
+import "fmt"
+import "fmt"
+`,
+	},
+	{
+		name:       "import.43",
+		renamedPkg: "x",
+		pkg:        "fmt",
+		in: `package main
+
+import "fmt"
+import "fmt"
+import f "fmt"
+import f "fmt"
+`,
+		out: `package main
+
+import "fmt"
+import "fmt"
+import f "fmt"
+import f "fmt"
+`,
+		unchanged: true,
+	},
 }
 
 func TestDeleteImport(t *testing.T) {
 	for _, test := range deleteTests {
 		file := parse(t, test.name, test.in)
-		DeleteNamedImport(fset, file, test.renamedPkg, test.pkg)
+		var before bytes.Buffer
+		ast.Fprint(&before, fset, file, nil)
+		deleted := DeleteNamedImport(fset, file, test.renamedPkg, test.pkg)
 		if got := print(t, test.name, file); got != test.out {
-			t.Errorf("%s:\ngot: %s\nwant: %s", test.name, got, test.out)
+			t.Errorf("first run: %s:\ngot: %s\nwant: %s", test.name, got, test.out)
+			var after bytes.Buffer
+			ast.Fprint(&after, fset, file, nil)
+			t.Logf("AST before:\n%s\nAST after:\n%s\n", before.String(), after.String())
+		}
+		if got, want := deleted, !test.unchanged; got != want {
+			t.Errorf("first run: %s: deleted = %v, want %v", test.name, got, want)
+		}
+
+		// DeleteNamedImport should be idempotent. Verify that by calling it again,
+		// expecting no change to the AST, and the returned deleted value to always be false.
+		deleted = DeleteNamedImport(fset, file, test.renamedPkg, test.pkg)
+		if got := print(t, test.name, file); got != test.out {
+			t.Errorf("second run: %s:\ngot: %s\nwant: %s", test.name, got, test.out)
+		}
+		if got, want := deleted, false; got != want {
+			t.Errorf("second run: %s: deleted = %v, want %v", test.name, got, want)
 		}
 	}
 }
diff --git a/vendor/golang.org/x/tools/go/callgraph/rta/rta.go b/vendor/golang.org/x/tools/go/callgraph/rta/rta.go
index 1a2dadf5..e6b44606 100644
--- a/vendor/golang.org/x/tools/go/callgraph/rta/rta.go
+++ b/vendor/golang.org/x/tools/go/callgraph/rta/rta.go
@@ -184,7 +184,7 @@ func (r *rta) visitDynCall(site ssa.CallInstruction) {
 	r.dynCallSites.Set(S, append(sites, site))
 
 	// For each function of signature S that we know is address-taken,
-	// mark it reachable.  We'll add the callgraph edges later.
+	// add an edge and mark it reachable.
 	funcs, _ := r.addrTakenFuncsBySig.At(S).(map[*ssa.Function]bool)
 	for g := range funcs {
 		r.addEdge(site, g, true)
diff --git a/vendor/golang.org/x/tools/go/expect/expect.go b/vendor/golang.org/x/tools/go/expect/expect.go
new file mode 100644
index 00000000..ec6e84cc
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/expect/expect.go
@@ -0,0 +1,149 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+/*
+Package expect provides support for interpreting structured comments in Go
+source code as test expectations.
+
+This is primarily intended for writing tests of things that process Go source
+files, although it does not directly depend on the testing package.
+
+Collect notes with the Extract or Parse functions, and use the
+MatchBefore function to find matches within the lines the comments were on.
+
+The interpretation of the notes depends on the application.
+For example, the test suite for a static checking tool might
+use a @diag note to indicate an expected diagnostic:
+
+   fmt.Printf("%s", 1) //@ diag("%s wants a string, got int")
+
+By contrast, the test suite for a source code navigation tool
+might use notes to indicate the positions of features of
+interest, the actions to be performed by the test,
+and their expected outcomes:
+
+   var x = 1 //@ x_decl
+   ...
+   print(x) //@ definition("x", x_decl)
+   print(x) //@ typeof("x", "int")
+
+
+Note comment syntax
+
+Note comments always start with the special marker @, which must be the
+very first character after the comment opening pair, so //@ or /*@ with no
+spaces.
+
+This is followed by a comma separated list of notes.
+
+A note always starts with an identifier, which is optionally followed by an
+argument list. The argument list is surrounded with parentheses and contains a
+comma-separated list of arguments.
+The empty parameter list and the missing parameter list are distinguishable if
+needed; they result in a nil or an empty list in the Args parameter respectively.
+
+Arguments are either identifiers or literals.
+The literals supported are the basic value literals, of string, float, integer
+true, false or nil. All the literals match the standard go conventions, with
+all bases of integers, and both quote and backtick strings.
+There is one extra literal type, which is a string literal preceded by the
+identifier "re" which is compiled to a regular expression.
+*/
+package expect
+
+import (
+	"bytes"
+	"fmt"
+	"go/token"
+	"regexp"
+)
+
+// Note is a parsed note from an expect comment.
+// It knows the position of the start of the comment, and the name and
+// arguments that make up the note.
+type Note struct {
+	Pos  token.Pos     // The position at which the note identifier appears
+	Name string        // the name associated with the note
+	Args []interface{} // the arguments for the note
+}
+
+// ReadFile  is the type of a function that can provide file contents for a
+// given filename.
+// This is used in MatchBefore to look up the content of the file in order to
+// find the line to match the pattern against.
+type ReadFile func(filename string) ([]byte, error)
+
+// MatchBefore attempts to match a pattern in the line before the supplied pos.
+// It uses the FileSet and the ReadFile to work out the contents of the line
+// that end is part of, and then matches the pattern against the content of the
+// start of that line up to the supplied position.
+// The pattern may be either a simple string, []byte or a *regexp.Regexp.
+// MatchBefore returns the range of the line that matched the pattern, and
+// invalid positions if there was no match, or an error if the line could not be
+// found.
+func MatchBefore(fset *token.FileSet, readFile ReadFile, end token.Pos, pattern interface{}) (token.Pos, token.Pos, error) {
+	f := fset.File(end)
+	content, err := readFile(f.Name())
+	if err != nil {
+		return token.NoPos, token.NoPos, fmt.Errorf("invalid file: %v", err)
+	}
+	position := f.Position(end)
+	startOffset := f.Offset(lineStart(f, position.Line))
+	endOffset := f.Offset(end)
+	line := content[startOffset:endOffset]
+	matchStart, matchEnd := -1, -1
+	switch pattern := pattern.(type) {
+	case string:
+		bytePattern := []byte(pattern)
+		matchStart = bytes.Index(line, bytePattern)
+		if matchStart >= 0 {
+			matchEnd = matchStart + len(bytePattern)
+		}
+	case []byte:
+		matchStart = bytes.Index(line, pattern)
+		if matchStart >= 0 {
+			matchEnd = matchStart + len(pattern)
+		}
+	case *regexp.Regexp:
+		match := pattern.FindIndex(line)
+		if len(match) > 0 {
+			matchStart = match[0]
+			matchEnd = match[1]
+		}
+	}
+	if matchStart < 0 {
+		return token.NoPos, token.NoPos, nil
+	}
+	return f.Pos(startOffset + matchStart), f.Pos(startOffset + matchEnd), nil
+}
+
+// this functionality was borrowed from the analysisutil package
+func lineStart(f *token.File, line int) token.Pos {
+	// Use binary search to find the start offset of this line.
+	//
+	// TODO(adonovan): eventually replace this function with the
+	// simpler and more efficient (*go/token.File).LineStart, added
+	// in go1.12.
+
+	min := 0        // inclusive
+	max := f.Size() // exclusive
+	for {
+		offset := (min + max) / 2
+		pos := f.Pos(offset)
+		posn := f.Position(pos)
+		if posn.Line == line {
+			return pos - (token.Pos(posn.Column) - 1)
+		}
+
+		if min+1 >= max {
+			return token.NoPos
+		}
+
+		if posn.Line < line {
+			min = offset
+		} else {
+			max = offset
+		}
+	}
+}
diff --git a/vendor/golang.org/x/tools/go/expect/expect_test.go b/vendor/golang.org/x/tools/go/expect/expect_test.go
new file mode 100644
index 00000000..0d1a8fb3
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/expect/expect_test.go
@@ -0,0 +1,135 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package expect_test
+
+import (
+	"bytes"
+	"go/token"
+	"io/ioutil"
+	"testing"
+
+	"golang.org/x/tools/go/expect"
+)
+
+func TestMarker(t *testing.T) {
+	const filename = "testdata/test.go"
+	content, err := ioutil.ReadFile(filename)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	const expectNotes = 11
+	expectMarkers := map[string]string{
+		"SimpleMarker": "",
+		"OffsetMarker":  "",
+		"RegexMarker":   "",
+		"Multiple":     "",
+		"Markers":      "",
+		"BlockMarker":  "",
+		"Declared":      "",
+		"Comment":       "",
+		"NonIdentifier": "+",
+	}
+	expectChecks := map[string][]interface{}{
+		"SimpleMarker": nil,
+		"StringAndInt":  []interface{}{"Number %d", int64(12)},
+		"Bool":          []interface{}{true},
+	}
+
+	readFile := func(string) ([]byte, error) { return content, nil }
+	markers := make(map[string]token.Pos)
+	for name, tok := range expectMarkers {
+		offset := bytes.Index(content, []byte(tok))
+		markers[name] = token.Pos(offset + 1)
+		end := bytes.Index(content[offset+1:], []byte(tok))
+		if end > 0 {
+			markers[name+"@"] = token.Pos(offset + end + 2)
+		}
+	}
+
+	fset := token.NewFileSet()
+	notes, err := expect.Parse(fset, filename, nil)
+	if err != nil {
+		t.Fatalf("Failed to extract notes: %v", err)
+	}
+	if len(notes) != expectNotes {
+		t.Errorf("Expected %v notes, got %v", expectNotes, len(notes))
+	}
+	for _, n := range notes {
+		switch {
+		case n.Args == nil:
+			// A //@foo note associates the name foo with the position of the
+			// first match of "foo" on the current line.
+			checkMarker(t, fset, readFile, markers, n.Pos, n.Name, n.Name)
+		case n.Name == "mark":
+			// A //@mark(name, "pattern") note associates the specified name
+			// with the position on the first match of pattern on the current line.
+			if len(n.Args) != 2 {
+				t.Errorf("%v: expected 2 args to mark, got %v", fset.Position(n.Pos), len(n.Args))
+				continue
+			}
+			ident, ok := n.Args[0].(expect.Identifier)
+			if !ok {
+				t.Errorf("%v: identifier, got %T", fset.Position(n.Pos), n.Args[0])
+				continue
+			}
+			checkMarker(t, fset, readFile, markers, n.Pos, string(ident), n.Args[1])
+
+		case n.Name == "check":
+			// A //@check(args, ...) note specifies some hypothetical action to
+			// be taken by the test driver and its expected outcome.
+			// In this test, the action is to compare the arguments
+			// against expectChecks.
+			if len(n.Args) < 1 {
+				t.Errorf("%v: expected 1 args to check, got %v", fset.Position(n.Pos), len(n.Args))
+				continue
+			}
+			ident, ok := n.Args[0].(expect.Identifier)
+			if !ok {
+				t.Errorf("%v: identifier, got %T", fset.Position(n.Pos), n.Args[0])
+				continue
+			}
+			args, ok := expectChecks[string(ident)]
+			if !ok {
+				t.Errorf("%v: unexpected check %v", fset.Position(n.Pos), ident)
+				continue
+			}
+			if len(n.Args) != len(args)+1 {
+				t.Errorf("%v: expected %v args to check, got %v", fset.Position(n.Pos), len(args)+1, len(n.Args))
+				continue
+			}
+			for i, got := range n.Args[1:] {
+				if args[i] != got {
+					t.Errorf("%v: arg %d expected %v, got %v", fset.Position(n.Pos), i, args[i], got)
+				}
+			}
+		default:
+			t.Errorf("Unexpected note %v at %v", n.Name, fset.Position(n.Pos))
+		}
+	}
+}
+
+func checkMarker(t *testing.T, fset *token.FileSet, readFile expect.ReadFile, markers map[string]token.Pos, pos token.Pos, name string, pattern interface{}) {
+	start, end, err := expect.MatchBefore(fset, readFile, pos, pattern)
+	if err != nil {
+		t.Errorf("%v: MatchBefore failed: %v", fset.Position(pos), err)
+		return
+	}
+	if start == token.NoPos {
+		t.Errorf("%v: Pattern %v did not match", fset.Position(pos), pattern)
+		return
+	}
+	expectStart, ok := markers[name]
+	if !ok {
+		t.Errorf("%v: unexpected marker %v", fset.Position(pos), name)
+		return
+	}
+	if start != expectStart {
+		t.Errorf("%v: Expected %v got %v", fset.Position(pos), fset.Position(expectStart), fset.Position(start))
+	}
+	if expectEnd, ok := markers[name+"@"]; ok && end != expectEnd {
+		t.Errorf("%v: Expected end %v got %v", fset.Position(pos), fset.Position(expectEnd), fset.Position(end))
+	}
+}
diff --git a/vendor/golang.org/x/tools/go/expect/extract.go b/vendor/golang.org/x/tools/go/expect/extract.go
new file mode 100644
index 00000000..b214b218
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/expect/extract.go
@@ -0,0 +1,221 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package expect
+
+import (
+	"fmt"
+	"go/ast"
+	"go/parser"
+	"go/token"
+	"regexp"
+	"strconv"
+	"strings"
+	"text/scanner"
+)
+
+const (
+	commentStart = "@"
+)
+
+// Identifier is the type for an identifier in an Note argument list.
+type Identifier string
+
+// Parse collects all the notes present in a file.
+// If content is nil, the filename specified is read and parsed, otherwise the
+// content is used and the filename is used for positions and error messages.
+// Each comment whose text starts with @ is parsed as a comma-separated
+// sequence of notes.
+// See the package documentation for details about the syntax of those
+// notes.
+func Parse(fset *token.FileSet, filename string, content []byte) ([]*Note, error) {
+	var src interface{}
+	if content != nil {
+		src = content
+	}
+	// TODO: We should write this in terms of the scanner.
+	// there are ways you can break the parser such that it will not add all the
+	// comments to the ast, which may result in files where the tests are silently
+	// not run.
+	file, err := parser.ParseFile(fset, filename, src, parser.ParseComments)
+	if file == nil {
+		return nil, err
+	}
+	return Extract(fset, file)
+}
+
+// Extract collects all the notes present in an AST.
+// Each comment whose text starts with @ is parsed as a comma-separated
+// sequence of notes.
+// See the package documentation for details about the syntax of those
+// notes.
+func Extract(fset *token.FileSet, file *ast.File) ([]*Note, error) {
+	var notes []*Note
+	for _, g := range file.Comments {
+		for _, c := range g.List {
+			text := c.Text
+			if strings.HasPrefix(text, "/*") {
+				text = strings.TrimSuffix(text, "*/")
+			}
+			text = text[2:] // remove "//" or "/*" prefix
+			if !strings.HasPrefix(text, commentStart) {
+				continue
+			}
+			text = text[len(commentStart):]
+			parsed, err := parse(fset, c.Pos()+4, text)
+			if err != nil {
+				return nil, err
+			}
+			notes = append(notes, parsed...)
+		}
+	}
+	return notes, nil
+}
+
+func parse(fset *token.FileSet, base token.Pos, text string) ([]*Note, error) {
+	var scanErr error
+	s := new(scanner.Scanner).Init(strings.NewReader(text))
+	s.Mode = scanner.GoTokens
+	s.Error = func(s *scanner.Scanner, msg string) {
+		scanErr = fmt.Errorf("%v:%s", fset.Position(base+token.Pos(s.Position.Offset)), msg)
+	}
+	notes, err := parseComment(s)
+	if err != nil {
+		return nil, fmt.Errorf("%v:%s", fset.Position(base+token.Pos(s.Position.Offset)), err)
+	}
+	if scanErr != nil {
+		return nil, scanErr
+	}
+	for _, n := range notes {
+		n.Pos += base
+	}
+	return notes, nil
+}
+
+func parseComment(s *scanner.Scanner) ([]*Note, error) {
+	var notes []*Note
+	for {
+		n, err := parseNote(s)
+		if err != nil {
+			return nil, err
+		}
+		notes = append(notes, n)
+		tok := s.Scan()
+		switch tok {
+		case ',':
+			// continue
+		case scanner.EOF:
+			return notes, nil
+		default:
+			return nil, fmt.Errorf("unexpected %s parsing comment", scanner.TokenString(tok))
+		}
+	}
+}
+
+func parseNote(s *scanner.Scanner) (*Note, error) {
+	if tok := s.Scan(); tok != scanner.Ident {
+		return nil, fmt.Errorf("expected identifier, got %s", scanner.TokenString(tok))
+	}
+	n := &Note{
+		Pos:  token.Pos(s.Position.Offset),
+		Name: s.TokenText(),
+	}
+	switch s.Peek() {
+	case ',', scanner.EOF:
+		// no argument list present
+		return n, nil
+	case '(':
+		// parse the argument list
+		if tok := s.Scan(); tok != '(' {
+			return nil, fmt.Errorf("expected ( got %s", scanner.TokenString(tok))
+		}
+		// special case the empty argument list
+		if s.Peek() == ')' {
+			if tok := s.Scan(); tok != ')' {
+				return nil, fmt.Errorf("expected ) got %s", scanner.TokenString(tok))
+			}
+			n.Args = []interface{}{} // @name() is represented by a non-nil empty slice.
+			return n, nil
+		}
+		// handle a normal argument list
+		for {
+			arg, err := parseArgument(s)
+			if err != nil {
+				return nil, err
+			}
+			n.Args = append(n.Args, arg)
+			switch s.Peek() {
+			case ')':
+				if tok := s.Scan(); tok != ')' {
+					return nil, fmt.Errorf("expected ) got %s", scanner.TokenString(tok))
+				}
+				return n, nil
+			case ',':
+				if tok := s.Scan(); tok != ',' {
+					return nil, fmt.Errorf("expected , got %s", scanner.TokenString(tok))
+				}
+				// continue
+			default:
+				return nil, fmt.Errorf("unexpected %s parsing argument list", scanner.TokenString(s.Scan()))
+			}
+		}
+	default:
+		return nil, fmt.Errorf("unexpected %s parsing note", scanner.TokenString(s.Scan()))
+	}
+}
+
+func parseArgument(s *scanner.Scanner) (interface{}, error) {
+	tok := s.Scan()
+	switch tok {
+	case scanner.Ident:
+		v := s.TokenText()
+		switch v {
+		case "true":
+			return true, nil
+		case "false":
+			return false, nil
+		case "nil":
+			return nil, nil
+		case "re":
+			tok := s.Scan()
+			switch tok {
+			case scanner.String, scanner.RawString:
+				pattern, _ := strconv.Unquote(s.TokenText()) // can't fail
+				re, err := regexp.Compile(pattern)
+				if err != nil {
+					return nil, fmt.Errorf("invalid regular expression %s: %v", pattern, err)
+				}
+				return re, nil
+			default:
+				return nil, fmt.Errorf("re must be followed by string, got %s", scanner.TokenString(tok))
+			}
+		default:
+			return Identifier(v), nil
+		}
+
+	case scanner.String, scanner.RawString:
+		v, _ := strconv.Unquote(s.TokenText()) // can't fail
+		return v, nil
+
+	case scanner.Int:
+		v, err := strconv.ParseInt(s.TokenText(), 0, 0)
+		if err != nil {
+			return nil, fmt.Errorf("cannot convert %v to int: %v", s.TokenText(), err)
+		}
+		return v, nil
+
+	case scanner.Float:
+		v, err := strconv.ParseFloat(s.TokenText(), 64)
+		if err != nil {
+			return nil, fmt.Errorf("cannot convert %v to float: %v", s.TokenText(), err)
+		}
+		return v, nil
+
+	case scanner.Char:
+		return nil, fmt.Errorf("unexpected char literal %s", s.TokenText())
+
+	default:
+		return nil, fmt.Errorf("unexpected %s parsing argument", scanner.TokenString(tok))
+	}
+}
diff --git a/vendor/golang.org/x/tools/go/expect/testdata/test.go b/vendor/golang.org/x/tools/go/expect/testdata/test.go
new file mode 100644
index 00000000..08d610aa
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/expect/testdata/test.go
@@ -0,0 +1,30 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package fake1
+
+// The greek letters in this file mark points we use for marker tests.
+// We use unique markers so we can make the tests stable against changes to
+// this file.
+
+const (
+	_                   int = iota
+	SimpleMarker          //@SimpleMarker
+	offsetMarker          //@mark(OffsetMarker, "")
+	regexMarker           //@mark(RegexMarker, re`\p{Greek}Ma`)
+	MultipleMarkers     //@Multiple,Markers
+	BlockMarker           /*@BlockMarker*/
+)
+
+/*Marker  inside  a comment*/ //@mark(Comment," inside ")
+
+func someFunc(a, b int) int {
+	// The line below must be the first occurrence of the plus operator
+	return a + b + 1 //@mark(NonIdentifier, re`\+[^\+]*`)
+}
+
+// And some extra checks for interesting action parameters
+//@check(SimpleMarker)
+//@check(StringAndInt, "Number %d", 12)
+//@check(Bool, true)
diff --git a/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter11_test.go b/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter11_test.go
index 720eac44..18186817 100644
--- a/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter11_test.go
+++ b/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter11_test.go
@@ -8,7 +8,6 @@ package gcimporter
 
 import (
 	"go/types"
-	"os"
 	"runtime"
 	"strings"
 	"testing"
@@ -126,9 +125,5 @@ func TestIssue25301(t *testing.T) {
 		t.Skip("avoid dealing with relative paths/drive letters on windows")
 	}
 
-	if f := compile(t, "testdata", "issue25301.go"); f != "" {
-		defer os.Remove(f)
-	}
-
-	importPkg(t, "./testdata/issue25301")
+	compileAndImportPkg(t, "issue25301")
 }
diff --git a/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter_test.go b/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter_test.go
index ef75f4e1..14622d34 100644
--- a/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter_test.go
+++ b/vendor/golang.org/x/tools/go/internal/gcimporter/gcimporter_test.go
@@ -73,17 +73,24 @@ func skipSpecialPlatforms(t *testing.T) {
 	}
 }
 
-func compile(t *testing.T, dirname, filename string) string {
+// compile runs the compiler on filename, with dirname as the working directory,
+// and writes the output file to outdirname.
+func compile(t *testing.T, dirname, filename, outdirname string) string {
 	/* testenv. */ MustHaveGoBuild(t)
-	cmd := exec.Command("go", "tool", "compile", filename)
+	// filename must end with ".go"
+	if !strings.HasSuffix(filename, ".go") {
+		t.Fatalf("filename doesn't end in .go: %s", filename)
+	}
+	basename := filepath.Base(filename)
+	outname := filepath.Join(outdirname, basename[:len(basename)-2]+"o")
+	cmd := exec.Command("go", "tool", "compile", "-o", outname, filename)
 	cmd.Dir = dirname
 	out, err := cmd.CombinedOutput()
 	if err != nil {
 		t.Logf("%s", out)
 		t.Fatalf("go tool compile %s failed: %s", filename, err)
 	}
-	// filename should end with ".go"
-	return filepath.Join(dirname, filename[:len(filename)-2]+"o")
+	return outname
 }
 
 func testPath(t *testing.T, path, srcDir string) *types.Package {
@@ -128,6 +135,18 @@ func testDir(t *testing.T, dir string, endTime time.Time) (nimports int) {
 	return
 }
 
+func mktmpdir(t *testing.T) string {
+	tmpdir, err := ioutil.TempDir("", "gcimporter_test")
+	if err != nil {
+		t.Fatal("mktmpdir:", err)
+	}
+	if err := os.Mkdir(filepath.Join(tmpdir, "testdata"), 0700); err != nil {
+		os.RemoveAll(tmpdir)
+		t.Fatal("mktmpdir:", err)
+	}
+	return tmpdir
+}
+
 const testfile = "exports.go"
 
 func TestImportTestdata(t *testing.T) {
@@ -136,13 +155,14 @@ func TestImportTestdata(t *testing.T) {
 		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
 	}
 
-	if outFn := compile(t, "testdata", testfile); outFn != "" {
-		defer os.Remove(outFn)
-	}
+	tmpdir := mktmpdir(t)
+	defer os.RemoveAll(tmpdir)
+
+	compile(t, "testdata", testfile, filepath.Join(tmpdir, "testdata"))
 
 	// filename should end with ".go"
 	filename := testfile[:len(testfile)-3]
-	if pkg := testPath(t, "./testdata/"+filename, "."); pkg != nil {
+	if pkg := testPath(t, "./testdata/"+filename, tmpdir); pkg != nil {
 		// The package's Imports list must include all packages
 		// explicitly imported by testfile, plus all packages
 		// referenced indirectly via exported objects in testfile.
@@ -175,6 +195,13 @@ func TestVersionHandling(t *testing.T) {
 		t.Fatal(err)
 	}
 
+	tmpdir := mktmpdir(t)
+	defer os.RemoveAll(tmpdir)
+	corruptdir := filepath.Join(tmpdir, "testdata", "versions")
+	if err := os.Mkdir(corruptdir, 0700); err != nil {
+		t.Fatal(err)
+	}
+
 	for _, f := range list {
 		name := f.Name()
 		if !strings.HasSuffix(name, ".a") {
@@ -222,12 +249,11 @@ func TestVersionHandling(t *testing.T) {
 		}
 		// 4) write the file
 		pkgpath += "_corrupted"
-		filename := filepath.Join(dir, pkgpath) + ".a"
+		filename := filepath.Join(corruptdir, pkgpath) + ".a"
 		ioutil.WriteFile(filename, data, 0666)
-		defer os.Remove(filename)
 
 		// test that importing the corrupted file results in an error
-		_, err = Import(make(map[string]*types.Package), pkgpath, dir, nil)
+		_, err = Import(make(map[string]*types.Package), pkgpath, corruptdir, nil)
 		if err == nil {
 			t.Errorf("import corrupted %q succeeded", pkgpath)
 		} else if msg := err.Error(); !strings.Contains(msg, "version skew") {
@@ -260,7 +286,7 @@ func TestIssue5815(t *testing.T) {
 		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
 	}
 
-	pkg := importPkg(t, "strings")
+	pkg := importPkg(t, "strings", ".")
 
 	scope := pkg.Scope()
 	for _, name := range scope.Names() {
@@ -318,15 +344,22 @@ func TestIssue13566(t *testing.T) {
 		t.Skip("avoid dealing with relative paths/drive letters on windows")
 	}
 
-	if f := compile(t, "testdata", "a.go"); f != "" {
-		defer os.Remove(f)
-	}
-	if f := compile(t, "testdata", "b.go"); f != "" {
-		defer os.Remove(f)
+	tmpdir := mktmpdir(t)
+	defer os.RemoveAll(tmpdir)
+	testoutdir := filepath.Join(tmpdir, "testdata")
+
+	// b.go needs to be compiled from the output directory so that the compiler can
+	// find the compiled package a. We pass the full path to compile() so that we
+	// don't have to copy the file to that directory.
+	bpath, err := filepath.Abs(filepath.Join("testdata", "b.go"))
+	if err != nil {
+		t.Fatal(err)
 	}
+	compile(t, "testdata", "a.go", testoutdir)
+	compile(t, testoutdir, bpath, testoutdir)
 
 	// import must succeed (test for issue at hand)
-	pkg := importPkg(t, "./testdata/b")
+	pkg := importPkg(t, "./testdata/b", tmpdir)
 
 	// make sure all indirectly imported packages have names
 	for _, imp := range pkg.Imports() {
@@ -396,9 +429,10 @@ func TestIssue15517(t *testing.T) {
 		t.Skip("avoid dealing with relative paths/drive letters on windows")
 	}
 
-	if f := compile(t, "testdata", "p.go"); f != "" {
-		defer os.Remove(f)
-	}
+	tmpdir := mktmpdir(t)
+	defer os.RemoveAll(tmpdir)
+
+	compile(t, "testdata", "p.go", filepath.Join(tmpdir, "testdata"))
 
 	// Multiple imports of p must succeed without redeclaration errors.
 	// We use an import path that's not cleaned up so that the eventual
@@ -414,7 +448,7 @@ func TestIssue15517(t *testing.T) {
 	// The same issue occurs with vendoring.)
 	imports := make(map[string]*types.Package)
 	for i := 0; i < 3; i++ {
-		if _, err := Import(imports, "./././testdata/p", ".", nil); err != nil {
+		if _, err := Import(imports, "./././testdata/p", tmpdir, nil); err != nil {
 			t.Fatal(err)
 		}
 	}
@@ -434,11 +468,7 @@ func TestIssue15920(t *testing.T) {
 		t.Skip("avoid dealing with relative paths/drive letters on windows")
 	}
 
-	if f := compile(t, "testdata", "issue15920.go"); f != "" {
-		defer os.Remove(f)
-	}
-
-	importPkg(t, "./testdata/issue15920")
+	compileAndImportPkg(t, "issue15920")
 }
 
 func TestIssue20046(t *testing.T) {
@@ -455,26 +485,29 @@ func TestIssue20046(t *testing.T) {
 		t.Skip("avoid dealing with relative paths/drive letters on windows")
 	}
 
-	if f := compile(t, "testdata", "issue20046.go"); f != "" {
-		defer os.Remove(f)
-	}
-
 	// "./issue20046".V.M must exist
-	pkg := importPkg(t, "./testdata/issue20046")
+	pkg := compileAndImportPkg(t, "issue20046")
 	obj := lookupObj(t, pkg.Scope(), "V")
 	if m, index, indirect := types.LookupFieldOrMethod(obj.Type(), false, nil, "M"); m == nil {
 		t.Fatalf("V.M not found (index = %v, indirect = %v)", index, indirect)
 	}
 }
 
-func importPkg(t *testing.T, path string) *types.Package {
-	pkg, err := Import(make(map[string]*types.Package), path, ".", nil)
+func importPkg(t *testing.T, path, srcDir string) *types.Package {
+	pkg, err := Import(make(map[string]*types.Package), path, srcDir, nil)
 	if err != nil {
 		t.Fatal(err)
 	}
 	return pkg
 }
 
+func compileAndImportPkg(t *testing.T, name string) *types.Package {
+	tmpdir := mktmpdir(t)
+	defer os.RemoveAll(tmpdir)
+	compile(t, "testdata", name+".go", filepath.Join(tmpdir, "testdata"))
+	return importPkg(t, "./testdata/"+name, tmpdir)
+}
+
 func lookupObj(t *testing.T, scope *types.Scope, name string) types.Object {
 	if obj := scope.Lookup(name); obj != nil {
 		return obj
diff --git a/vendor/golang.org/x/tools/go/packages/golist.go b/vendor/golang.org/x/tools/go/packages/golist.go
index a1e9c320..4b707a5e 100644
--- a/vendor/golang.org/x/tools/go/packages/golist.go
+++ b/vendor/golang.org/x/tools/go/packages/golist.go
@@ -8,19 +8,25 @@ import (
 	"bytes"
 	"encoding/json"
 	"fmt"
+	"go/types"
 	"io/ioutil"
 	"log"
 	"os"
 	"os/exec"
 	"path/filepath"
+	"reflect"
 	"regexp"
 	"strings"
 	"sync"
+	"time"
 
 	"golang.org/x/tools/internal/gopathwalk"
 	"golang.org/x/tools/internal/semver"
 )
 
+// debug controls verbose logging.
+const debug = false
+
 // A goTooOldError reports that the go command
 // found by exec.LookPath is too old to use the new go list behavior.
 type goTooOldError struct {
@@ -31,6 +37,17 @@ type goTooOldError struct {
 // the build system package structure.
 // See driver for more details.
 func goListDriver(cfg *Config, patterns ...string) (*driverResponse, error) {
+	var sizes types.Sizes
+	var sizeserr error
+	var sizeswg sync.WaitGroup
+	if cfg.Mode >= LoadTypes {
+		sizeswg.Add(1)
+		go func() {
+			sizes, sizeserr = getSizes(cfg)
+			sizeswg.Done()
+		}()
+	}
+
 	// Determine files requested in contains patterns
 	var containFiles []string
 	var packagesNamed []string
@@ -66,18 +83,6 @@ extractQueries:
 		}
 	}
 	patterns = restPatterns
-	// Look for the deprecated contains: syntax.
-	// TODO(matloob): delete this around mid-October 2018.
-	restPatterns = restPatterns[:0]
-	for _, pattern := range patterns {
-		if strings.HasPrefix(pattern, "contains:") {
-			containFile := strings.TrimPrefix(pattern, "contains:")
-			containFiles = append(containFiles, containFile)
-		} else {
-			restPatterns = append(restPatterns, pattern)
-		}
-	}
-	containFiles = absJoin(cfg.Dir, containFiles)
 
 	// TODO(matloob): Remove the definition of listfunc and just use golistPackages once go1.12 is released.
 	var listfunc driver
@@ -104,6 +109,13 @@ extractQueries:
 		response = &driverResponse{}
 	}
 
+	sizeswg.Wait()
+	if sizeserr != nil {
+		return nil, sizeserr
+	}
+	// types.SizesFor always returns nil or a *types.StdSizes
+	response.Sizes, _ = sizes.(*types.StdSizes)
+
 	if len(containFiles) == 0 && len(packagesNamed) == 0 {
 		return response, nil
 	}
@@ -131,7 +143,6 @@ extractQueries:
 		return nil, err
 	}
 	response.Roots = append(response.Roots, namedResults...)
-
 	return response, nil
 }
 
@@ -174,8 +185,12 @@ func runContainsQueries(cfg *Config, driver driver, addPkg func(*Package), queri
 var modCacheRegexp = regexp.MustCompile(`(.*)@([^/\\]*)(.*)`)
 
 func runNamedQueries(cfg *Config, driver driver, addPkg func(*Package), queries []string) ([]string, error) {
+	// calling `go env` isn't free; bail out if there's nothing to do.
+	if len(queries) == 0 {
+		return nil, nil
+	}
 	// Determine which directories are relevant to scan.
-	roots, modulesEnabled, err := roots(cfg)
+	roots, modRoot, err := roots(cfg)
 	if err != nil {
 		return nil, err
 	}
@@ -210,7 +225,31 @@ func runNamedQueries(cfg *Config, driver driver, addPkg func(*Package), queries
 			}
 		}
 	}
-	gopathwalk.Walk(roots, add, gopathwalk.Options{ModulesEnabled: modulesEnabled})
+
+	startWalk := time.Now()
+	gopathwalk.Walk(roots, add, gopathwalk.Options{ModulesEnabled: modRoot != "", Debug: debug})
+	if debug {
+		log.Printf("%v for walk", time.Since(startWalk))
+	}
+
+	// Weird special case: the top-level package in a module will be in
+	// whatever directory the user checked the repository out into. It's
+	// more reasonable for that to not match the package name. So, if there
+	// are any Go files in the mod root, query it just to be safe.
+	if modRoot != "" {
+		rel, err := filepath.Rel(cfg.Dir, modRoot)
+		if err != nil {
+			panic(err) // See above.
+		}
+
+		files, err := ioutil.ReadDir(modRoot)
+		for _, f := range files {
+			if strings.HasSuffix(f.Name(), ".go") {
+				simpleMatches = append(simpleMatches, rel)
+				break
+			}
+		}
+	}
 
 	var results []string
 	addResponse := func(r *driverResponse) {
@@ -268,6 +307,12 @@ func runNamedQueries(cfg *Config, driver driver, addPkg func(*Package), queries
 		gomod.WriteString(")\n")
 
 		tmpCfg := *cfg
+
+		// We're only trying to look at stuff in the module cache, so
+		// disable the network. This should speed things up, and has
+		// prevented errors in at least one case, #28518.
+		tmpCfg.Env = append(append([]string{"GOPROXY=off"}, cfg.Env...))
+
 		var err error
 		tmpCfg.Dir, err = ioutil.TempDir("", "gopackages-modquery")
 		if err != nil {
@@ -290,38 +335,53 @@ func runNamedQueries(cfg *Config, driver driver, addPkg func(*Package), queries
 	return results, nil
 }
 
+func getSizes(cfg *Config) (types.Sizes, error) {
+	stdout, err := invokeGo(cfg, "env", "GOARCH")
+	if err != nil {
+		return nil, err
+	}
+
+	goarch := strings.TrimSpace(stdout.String())
+	// Assume "gc" because SizesFor doesn't respond to other compilers.
+	// TODO(matloob): add support for gccgo as needed.
+	return types.SizesFor("gc", goarch), nil
+}
+
 // roots selects the appropriate paths to walk based on the passed-in configuration,
 // particularly the environment and the presence of a go.mod in cfg.Dir's parents.
-func roots(cfg *Config) ([]gopathwalk.Root, bool, error) {
+func roots(cfg *Config) ([]gopathwalk.Root, string, error) {
 	stdout, err := invokeGo(cfg, "env", "GOROOT", "GOPATH", "GOMOD")
 	if err != nil {
-		return nil, false, err
+		return nil, "", err
 	}
 
 	fields := strings.Split(stdout.String(), "\n")
 	if len(fields) != 4 || len(fields[3]) != 0 {
-		return nil, false, fmt.Errorf("go env returned unexpected output: %q", stdout.String())
+		return nil, "", fmt.Errorf("go env returned unexpected output: %q", stdout.String())
 	}
 	goroot, gopath, gomod := fields[0], filepath.SplitList(fields[1]), fields[2]
-	modsEnabled := gomod != ""
+	var modDir string
+	if gomod != "" {
+		modDir = filepath.Dir(gomod)
+	}
 
 	var roots []gopathwalk.Root
 	// Always add GOROOT.
 	roots = append(roots, gopathwalk.Root{filepath.Join(goroot, "/src"), gopathwalk.RootGOROOT})
 	// If modules are enabled, scan the module dir.
-	if modsEnabled {
-		roots = append(roots, gopathwalk.Root{filepath.Dir(gomod), gopathwalk.RootCurrentModule})
+	if modDir != "" {
+		roots = append(roots, gopathwalk.Root{modDir, gopathwalk.RootCurrentModule})
 	}
 	// Add either GOPATH/src or GOPATH/pkg/mod, depending on module mode.
 	for _, p := range gopath {
-		if modsEnabled {
+		if modDir != "" {
 			roots = append(roots, gopathwalk.Root{filepath.Join(p, "/pkg/mod"), gopathwalk.RootModuleCache})
 		} else {
 			roots = append(roots, gopathwalk.Root{filepath.Join(p, "/src"), gopathwalk.RootGOPATH})
 		}
 	}
 
-	return roots, modsEnabled, nil
+	return roots, modDir, nil
 }
 
 // These functions were copied from goimports. See further documentation there.
@@ -448,6 +508,7 @@ func golistDriverCurrent(cfg *Config, words ...string) (*driverResponse, error)
 	if err != nil {
 		return nil, err
 	}
+	seen := make(map[string]*jsonPackage)
 	// Decode the JSON and convert it to Package form.
 	var response driverResponse
 	for dec := json.NewDecoder(buf); dec.More(); {
@@ -470,6 +531,15 @@ func golistDriverCurrent(cfg *Config, words ...string) (*driverResponse, error)
 			return nil, fmt.Errorf("package missing import path: %+v", p)
 		}
 
+		if old, found := seen[p.ImportPath]; found {
+			if !reflect.DeepEqual(p, old) {
+				return nil, fmt.Errorf("go list repeated package %v with different values", p.ImportPath)
+			}
+			// skip the duplicate
+			continue
+		}
+		seen[p.ImportPath] = p
+
 		pkg := &Package{
 			Name:            p.Name,
 			ID:              p.ImportPath,
@@ -478,6 +548,17 @@ func golistDriverCurrent(cfg *Config, words ...string) (*driverResponse, error)
 			OtherFiles:      absJoin(p.Dir, otherFiles(p)...),
 		}
 
+		// Workaround for github.com/golang/go/issues/28749.
+		// TODO(adonovan): delete before go1.12 release.
+		out := pkg.CompiledGoFiles[:0]
+		for _, f := range pkg.CompiledGoFiles {
+			if strings.HasSuffix(f, ".s") {
+				continue
+			}
+			out = append(out, f)
+		}
+		pkg.CompiledGoFiles = out
+
 		// Extract the PkgPath from the package's ID.
 		if i := strings.IndexByte(pkg.ID, ' '); i >= 0 {
 			pkg.PkgPath = pkg.ID[:i]
@@ -524,7 +605,9 @@ func golistDriverCurrent(cfg *Config, words ...string) (*driverResponse, error)
 			response.Roots = append(response.Roots, pkg.ID)
 		}
 
-		// TODO(matloob): Temporary hack since CompiledGoFiles isn't always set.
+		// Work around for pre-go.1.11 versions of go list.
+		// TODO(matloob): they should be handled by the fallback.
+		// Can we delete this?
 		if len(pkg.CompiledGoFiles) == 0 {
 			pkg.CompiledGoFiles = pkg.GoFiles
 		}
@@ -570,6 +653,9 @@ func golistargs(cfg *Config, words []string) []string {
 
 // invokeGo returns the stdout of a go command invocation.
 func invokeGo(cfg *Config, args ...string) (*bytes.Buffer, error) {
+	if debug {
+		defer func(start time.Time) { log.Printf("%s for %v", time.Since(start), cmdDebugStr(cfg, args...)) }(time.Now())
+	}
 	stdout := new(bytes.Buffer)
 	stderr := new(bytes.Buffer)
 	cmd := exec.CommandContext(cfg.Context, "go", args...)
@@ -613,13 +699,24 @@ func invokeGo(cfg *Config, args ...string) (*bytes.Buffer, error) {
 	// be useful for debugging. Print them if $GOPACKAGESPRINTGOLISTERRORS
 	// is set.
 	if len(stderr.Bytes()) != 0 && os.Getenv("GOPACKAGESPRINTGOLISTERRORS") != "" {
-		fmt.Fprintf(os.Stderr, "go %v stderr: <<%s>>\n", args, stderr)
+		fmt.Fprintf(os.Stderr, "%s stderr: <<%s>>\n", cmdDebugStr(cfg, args...), stderr)
 	}
 
 	// debugging
 	if false {
-		fmt.Fprintf(os.Stderr, "go %v stdout: <<%s>>\n", args, stdout)
+		fmt.Fprintf(os.Stderr, "%s stdout: <<%s>>\n", cmdDebugStr(cfg, args...), stdout)
 	}
 
 	return stdout, nil
 }
+
+func cmdDebugStr(cfg *Config, args ...string) string {
+	env := make(map[string]string)
+	for _, kv := range cfg.Env {
+		split := strings.Split(kv, "=")
+		k, v := split[0], split[1]
+		env[k] = v
+	}
+
+	return fmt.Sprintf("GOROOT=%v GOPATH=%v GO111MODULE=%v PWD=%v go %v", env["GOROOT"], env["GOPATH"], env["GO111MODULE"], env["PWD"], args)
+}
diff --git a/vendor/golang.org/x/tools/go/packages/golist_fallback.go b/vendor/golang.org/x/tools/go/packages/golist_fallback.go
index ac0c34f0..8e88607a 100644
--- a/vendor/golang.org/x/tools/go/packages/golist_fallback.go
+++ b/vendor/golang.org/x/tools/go/packages/golist_fallback.go
@@ -46,7 +46,7 @@ func golistDriverFallback(cfg *Config, words ...string) (*driverResponse, error)
 
 	var response driverResponse
 	allPkgs := make(map[string]bool)
-	addPackage := func(p *jsonPackage) {
+	addPackage := func(p *jsonPackage, isRoot bool) {
 		id := p.ImportPath
 
 		if allPkgs[id] {
@@ -54,7 +54,6 @@ func golistDriverFallback(cfg *Config, words ...string) (*driverResponse, error)
 		}
 		allPkgs[id] = true
 
-		isRoot := original[id] != nil
 		pkgpath := id
 
 		if pkgpath == "unsafe" {
@@ -221,7 +220,7 @@ func golistDriverFallback(cfg *Config, words ...string) (*driverResponse, error)
 	}
 
 	for _, pkg := range original {
-		addPackage(pkg)
+		addPackage(pkg, true)
 	}
 	if cfg.Mode < LoadImports || len(deps) == 0 {
 		return &response, nil
@@ -239,18 +238,13 @@ func golistDriverFallback(cfg *Config, words ...string) (*driverResponse, error)
 			return nil, fmt.Errorf("JSON decoding failed: %v", err)
 		}
 
-		addPackage(p)
+		addPackage(p, false)
 	}
 
 	for _, v := range needsTestVariant {
 		createTestVariants(&response, v.pkg, v.xtestPkg)
 	}
 
-	// TODO(matloob): Is this the right ordering?
-	sort.SliceStable(response.Packages, func(i, j int) bool {
-		return response.Packages[i].PkgPath < response.Packages[j].PkgPath
-	})
-
 	return &response, nil
 }
 
@@ -361,14 +355,13 @@ func vendorlessPath(ipath string) string {
 }
 
 // getDeps runs an initial go list to determine all the dependency packages.
-func getDeps(cfg *Config, words ...string) (originalSet map[string]*jsonPackage, deps []string, err error) {
+func getDeps(cfg *Config, words ...string) (initial []*jsonPackage, deps []string, err error) {
 	buf, err := invokeGo(cfg, golistArgsFallback(cfg, words)...)
 	if err != nil {
 		return nil, nil, err
 	}
 
 	depsSet := make(map[string]bool)
-	originalSet = make(map[string]*jsonPackage)
 	var testImports []string
 
 	// Extract deps from the JSON.
@@ -378,7 +371,7 @@ func getDeps(cfg *Config, words ...string) (originalSet map[string]*jsonPackage,
 			return nil, nil, fmt.Errorf("JSON decoding failed: %v", err)
 		}
 
-		originalSet[p.ImportPath] = p
+		initial = append(initial, p)
 		for _, dep := range p.Deps {
 			depsSet[dep] = true
 		}
@@ -412,8 +405,8 @@ func getDeps(cfg *Config, words ...string) (originalSet map[string]*jsonPackage,
 		}
 	}
 
-	for orig := range originalSet {
-		delete(depsSet, orig)
+	for _, orig := range initial {
+		delete(depsSet, orig.ImportPath)
 	}
 
 	deps = make([]string, 0, len(depsSet))
@@ -421,7 +414,7 @@ func getDeps(cfg *Config, words ...string) (originalSet map[string]*jsonPackage,
 		deps = append(deps, dep)
 	}
 	sort.Strings(deps) // ensure output is deterministic
-	return originalSet, deps, nil
+	return initial, deps, nil
 }
 
 func golistArgsFallback(cfg *Config, words []string) []string {
diff --git a/vendor/golang.org/x/tools/go/packages/packages.go b/vendor/golang.org/x/tools/go/packages/packages.go
index 84a3dbb1..c1110f3c 100644
--- a/vendor/golang.org/x/tools/go/packages/packages.go
+++ b/vendor/golang.org/x/tools/go/packages/packages.go
@@ -19,8 +19,6 @@ import (
 	"log"
 	"os"
 	"path/filepath"
-	"runtime"
-	"strings"
 	"sync"
 
 	"golang.org/x/tools/go/gcexportdata"
@@ -59,7 +57,7 @@ const (
 	LoadAllSyntax
 )
 
-// An Config specifies details about how packages should be loaded.
+// A Config specifies details about how packages should be loaded.
 // The zero value is a valid configuration.
 // Calls to Load do not modify this struct.
 type Config struct {
@@ -139,6 +137,9 @@ type driver func(cfg *Config, patterns ...string) (*driverResponse, error)
 
 // driverResponse contains the results for a driver query.
 type driverResponse struct {
+	// Sizes, if not nil, is the types.Sizes to use when type checking.
+	Sizes *types.StdSizes
+
 	// Roots is the set of package IDs that make up the root packages.
 	// We have to encode this separately because when we encode a single package
 	// we cannot know if it is one of the roots as that requires knowledge of the
@@ -173,6 +174,7 @@ func Load(cfg *Config, patterns ...string) ([]*Package, error) {
 	if err != nil {
 		return nil, err
 	}
+	l.sizes = response.Sizes
 	return l.refine(response.Roots, response.Packages...)
 }
 
@@ -367,6 +369,7 @@ type loaderPackage struct {
 type loader struct {
 	pkgs map[string]*loaderPackage
 	Config
+	sizes    types.Sizes
 	exportMu sync.Mutex // enforces mutual exclusion of exportdata operations
 }
 
@@ -411,28 +414,37 @@ func newLoader(cfg *Config) *loader {
 // refine connects the supplied packages into a graph and then adds type and
 // and syntax information as requested by the LoadMode.
 func (ld *loader) refine(roots []string, list ...*Package) ([]*Package, error) {
-	isRoot := make(map[string]bool, len(roots))
-	for _, root := range roots {
-		isRoot[root] = true
+	rootMap := make(map[string]int, len(roots))
+	for i, root := range roots {
+		rootMap[root] = i
 	}
 	ld.pkgs = make(map[string]*loaderPackage)
 	// first pass, fixup and build the map and roots
-	var initial []*loaderPackage
+	var initial = make([]*loaderPackage, len(roots))
 	for _, pkg := range list {
+		rootIndex := -1
+		if i, found := rootMap[pkg.ID]; found {
+			rootIndex = i
+		}
 		lpkg := &loaderPackage{
 			Package: pkg,
 			needtypes: ld.Mode >= LoadAllSyntax ||
-				ld.Mode >= LoadTypes && isRoot[pkg.ID],
+				ld.Mode >= LoadTypes && rootIndex >= 0,
 			needsrc: ld.Mode >= LoadAllSyntax ||
-				ld.Mode >= LoadSyntax && isRoot[pkg.ID] ||
+				ld.Mode >= LoadSyntax && rootIndex >= 0 ||
 				pkg.ExportFile == "" && pkg.PkgPath != "unsafe",
 		}
 		ld.pkgs[lpkg.ID] = lpkg
-		if isRoot[lpkg.ID] {
-			initial = append(initial, lpkg)
+		if rootIndex >= 0 {
+			initial[rootIndex] = lpkg
 			lpkg.initial = true
 		}
 	}
+	for i, root := range roots {
+		if initial[i] == nil {
+			return nil, fmt.Errorf("root package %v is missing", root)
+		}
+	}
 
 	// Materialize the import graph.
 
@@ -683,17 +695,6 @@ func (ld *loader) loadPackage(lpkg *loaderPackage) {
 		panic("unreachable")
 	})
 
-	// This is only an approximation.
-	// TODO(adonovan): derive Sizes from the underlying build system.
-	goarch := runtime.GOARCH
-	const goarchPrefix = "GOARCH="
-	for _, e := range ld.Config.Env {
-		if strings.HasPrefix(e, goarchPrefix) {
-			goarch = e[len(goarchPrefix):]
-		}
-	}
-	sizes := types.SizesFor("gc", goarch)
-
 	// type-check
 	tc := &types.Config{
 		Importer: importer,
@@ -704,7 +705,7 @@ func (ld *loader) loadPackage(lpkg *loaderPackage) {
 		IgnoreFuncBodies: ld.Mode < LoadAllSyntax && !lpkg.initial,
 
 		Error: appendError,
-		Sizes: sizes,
+		Sizes: ld.sizes,
 	}
 	types.NewChecker(tc, ld.Fset, lpkg.Types, lpkg.TypesInfo).Files(lpkg.Syntax)
 
diff --git a/vendor/golang.org/x/tools/go/packages/packages_test.go b/vendor/golang.org/x/tools/go/packages/packages_test.go
index 778d631a..5f6c2eb7 100644
--- a/vendor/golang.org/x/tools/go/packages/packages_test.go
+++ b/vendor/golang.org/x/tools/go/packages/packages_test.go
@@ -298,8 +298,10 @@ func TestLoadAbsolutePath(t *testing.T) {
 	for _, p := range initial {
 		got = append(got, p.ID)
 	}
-	if !reflect.DeepEqual(got, []string{"golang.org/gopatha/a", "golang.org/gopathb/b"}) {
-		t.Fatalf("initial packages loaded: got [%s], want [a b]", got)
+	sort.Strings(got)
+	want := []string{"golang.org/gopatha/a", "golang.org/gopathb/b"}
+	if !reflect.DeepEqual(got, want) {
+		t.Fatalf("initial packages loaded: got [%s], want [%s]", got, want)
 	}
 }
 
@@ -1145,10 +1147,13 @@ func TestName_Modules(t *testing.T) {
 		t.Skip("pre-modules version of Go")
 	}
 
+	// Test the top-level package case described in runNamedQueries.
+	// Note that overriding GOPATH below prevents Export from
+	// creating more than one module.
 	exported := packagestest.Export(t, packagestest.Modules, []packagestest.Module{{
-		Name: "golang.org/fake",
+		Name: "golang.org/pkg",
 		Files: map[string]interface{}{
-			"pkg/pkg.go": `package pkg`,
+			"pkg.go": `package pkg`,
 		}}})
 	defer exported.Cleanup()
 
@@ -1170,7 +1175,7 @@ func TestName_Modules(t *testing.T) {
 	wantGraph := `
 * github.com/heschik/tools-testrepo/pkg
 * github.com/heschik/tools-testrepo/v2/pkg
-* golang.org/fake/pkg
+* golang.org/pkg
 `[1:]
 	if graph != wantGraph {
 		t.Errorf("wrong import graph: got <<%s>>, want <<%s>>", graph, wantGraph)
@@ -1405,24 +1410,41 @@ func testPatternPassthrough(t *testing.T, exporter packagestest.Exporter) {
 
 func TestConfigDefaultEnv(t *testing.T) { packagestest.TestAll(t, testConfigDefaultEnv) }
 func testConfigDefaultEnv(t *testing.T, exporter packagestest.Exporter) {
-	if runtime.GOOS == "windows" {
+	const driverJSON = `{
+  "Roots": ["gopackagesdriver"],
+  "Packages": [{"ID": "gopackagesdriver", "Name": "gopackagesdriver"}]
+}`
+	var (
+		pathKey      string
+		driverScript packagestest.Writer
+	)
+	switch runtime.GOOS {
+	case "windows":
 		// TODO(jayconrod): write an equivalent batch script for windows.
 		// Hint: "type" can be used to read a file to stdout.
 		t.Skip("test requires sh")
+	case "plan9":
+		pathKey = "path"
+		driverScript = packagestest.Script(`#!/bin/rc
+
+cat <<'EOF'
+` + driverJSON + `
+EOF
+`)
+	default:
+		pathKey = "PATH"
+		driverScript = packagestest.Script(`#!/bin/sh
+
+cat - <<'EOF'
+` + driverJSON + `
+EOF
+`)
 	}
 	exported := packagestest.Export(t, exporter, []packagestest.Module{{
 		Name: "golang.org/fake",
 		Files: map[string]interface{}{
-			"bin/gopackagesdriver": packagestest.Script(`#!/bin/sh
-
-cat - <<'EOF'
-{
-  "Roots": ["gopackagesdriver"],
-  "Packages": [{"ID": "gopackagesdriver", "Name": "gopackagesdriver"}]
-}
-EOF
-`),
-			"golist/golist.go": "package golist",
+			"bin/gopackagesdriver": driverScript,
+			"golist/golist.go":     "package golist",
 		}}})
 	defer exported.Cleanup()
 	driver := exported.File("golang.org/fake", "bin/gopackagesdriver")
@@ -1431,7 +1453,7 @@ EOF
 		t.Fatal(err)
 	}
 
-	path, ok := os.LookupEnv("PATH")
+	path, ok := os.LookupEnv(pathKey)
 	var pathWithDriver string
 	if ok {
 		pathWithDriver = binDir + string(os.PathListSeparator) + path
@@ -1463,9 +1485,9 @@ EOF
 		},
 	} {
 		t.Run(test.desc, func(t *testing.T) {
-			oldPath := os.Getenv("PATH")
-			os.Setenv("PATH", test.path)
-			defer os.Setenv("PATH", oldPath)
+			oldPath := os.Getenv(pathKey)
+			os.Setenv(pathKey, test.path)
+			defer os.Setenv(pathKey, oldPath)
 			exported.Config.Env = append(coreEnv, "GOPACKAGESDRIVER="+test.driver)
 			pkgs, err := packages.Load(exported.Config, "golist")
 			if err != nil {
@@ -1483,6 +1505,31 @@ EOF
 	}
 }
 
+// This test that a simple x test package layout loads correctly.
+// There was a bug in go list where it returned multiple copies of the same
+// package (specifically in this case of golang.org/fake/a), and this triggered
+// a bug in go/packages where it would leave an empty entry in the root package
+// list. This would then cause a nil pointer crash.
+// This bug was triggered by the simple package layout below, and thus this
+// test will make sure the bug remains fixed.
+func TestBasicXTest(t *testing.T) { packagestest.TestAll(t, testBasicXTest) }
+func testBasicXTest(t *testing.T, exporter packagestest.Exporter) {
+	exported := packagestest.Export(t, exporter, []packagestest.Module{{
+		Name: "golang.org/fake",
+		Files: map[string]interface{}{
+			"a/a.go":      `package a;`,
+			"a/a_test.go": `package a_test;`,
+		}}})
+	defer exported.Cleanup()
+
+	exported.Config.Mode = packages.LoadFiles
+	exported.Config.Tests = true
+	_, err := packages.Load(exported.Config, "golang.org/fake/a")
+	if err != nil {
+		t.Fatal(err)
+	}
+}
+
 func errorMessages(errors []packages.Error) []string {
 	var msgs []string
 	for _, err := range errors {
diff --git a/vendor/golang.org/x/tools/go/packages/packagestest/expect.go b/vendor/golang.org/x/tools/go/packages/packagestest/expect.go
new file mode 100644
index 00000000..960f1151
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/packages/packagestest/expect.go
@@ -0,0 +1,328 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packagestest
+
+import (
+	"fmt"
+	"go/token"
+	"reflect"
+	"regexp"
+	"strings"
+
+	"golang.org/x/tools/go/expect"
+)
+
+const (
+	markMethod    = "mark"
+	eofIdentifier = "EOF"
+)
+
+// Expect invokes the supplied methods for all expectation notes found in
+// the exported source files.
+//
+// All exported go source files are parsed to collect the expectation
+// notes.
+// See the documentation for expect.Parse for how the notes are collected
+// and parsed.
+//
+// The methods are supplied as a map of name to function, and those functions
+// will be matched against the expectations by name.
+// Notes with no matching function will be skipped, and functions with no
+// matching notes will not be invoked.
+// If there are no registered markers yet, a special pass will be run first
+// which adds any markers declared with @mark(Name, pattern) or @name. These
+// call the Mark method to add the marker to the global set.
+// You can register the "mark" method to override these in your own call to
+// Expect. The bound Mark function is usable directly in your method map, so
+//    exported.Expect(map[string]interface{}{"mark": exported.Mark})
+// replicates the built in behavior.
+//
+// Method invocation
+//
+// When invoking a method the expressions in the parameter list need to be
+// converted to values to be passed to the method.
+// There are a very limited set of types the arguments are allowed to be.
+//   expect.Comment : passed the Comment instance being evaluated.
+//   string : can be supplied either a string literal or an identifier.
+//   int : can only be supplied an integer literal.
+//   token.Pos : has a file position calculated as described below.
+//   token.Position : has a file position calculated as described below.
+//
+// Position calculation
+//
+// There is some extra handling when a parameter is being coerced into a
+// token.Pos, token.Position or Range type argument.
+//
+// If the parameter is an identifier, it will be treated as the name of an
+// marker to look up (as if markers were global variables).
+//
+// If it is a string or regular expression, then it will be passed to
+// expect.MatchBefore to look up a match in the line at which it was declared.
+//
+// It is safe to call this repeatedly with different method sets, but it is
+// not safe to call it concurrently.
+func (e *Exported) Expect(methods map[string]interface{}) error {
+	if err := e.getNotes(); err != nil {
+		return err
+	}
+	if err := e.getMarkers(); err != nil {
+		return err
+	}
+	var err error
+	ms := make(map[string]method, len(methods))
+	for name, f := range methods {
+		mi := method{f: reflect.ValueOf(f)}
+		mi.converters = make([]converter, mi.f.Type().NumIn())
+		for i := 0; i < len(mi.converters); i++ {
+			mi.converters[i], err = e.buildConverter(mi.f.Type().In(i))
+			if err != nil {
+				return fmt.Errorf("invalid method %v: %v", name, err)
+			}
+		}
+		ms[name] = mi
+	}
+	for _, n := range e.notes {
+		if n.Args == nil {
+			// simple identifier form, convert to a call to mark
+			n = &expect.Note{
+				Pos:  n.Pos,
+				Name: markMethod,
+				Args: []interface{}{n.Name, n.Name},
+			}
+		}
+		mi, ok := ms[n.Name]
+		if !ok {
+			continue
+		}
+		params := make([]reflect.Value, len(mi.converters))
+		args := n.Args
+		for i, convert := range mi.converters {
+			params[i], args, err = convert(n, args)
+			if err != nil {
+				return fmt.Errorf("%v: %v", e.fset.Position(n.Pos), err)
+			}
+		}
+		if len(args) > 0 {
+			return fmt.Errorf("%v: unwanted args got %+v extra", e.fset.Position(n.Pos), args)
+		}
+		//TODO: catch the error returned from the method
+		mi.f.Call(params)
+	}
+	return nil
+}
+
+type Range struct {
+	Start token.Pos
+	End   token.Pos
+}
+
+// Mark adds a new marker to the known set.
+func (e *Exported) Mark(name string, r Range) {
+	if e.markers == nil {
+		e.markers = make(map[string]Range)
+	}
+	e.markers[name] = r
+}
+
+func (e *Exported) getNotes() error {
+	if e.notes != nil {
+		return nil
+	}
+	notes := []*expect.Note{}
+	for _, module := range e.written {
+		for _, filename := range module {
+			if !strings.HasSuffix(filename, ".go") {
+				continue
+			}
+			l, err := expect.Parse(e.fset, filename, nil)
+			if err != nil {
+				return fmt.Errorf("Failed to extract expectations: %v", err)
+			}
+			notes = append(notes, l...)
+		}
+	}
+	e.notes = notes
+	return nil
+}
+
+func (e *Exported) getMarkers() error {
+	if e.markers != nil {
+		return nil
+	}
+	// set markers early so that we don't call getMarkers again from Expect
+	e.markers = make(map[string]Range)
+	return e.Expect(map[string]interface{}{
+		markMethod: e.Mark,
+	})
+}
+
+var (
+	noteType       = reflect.TypeOf((*expect.Note)(nil))
+	identifierType = reflect.TypeOf(expect.Identifier(""))
+	posType        = reflect.TypeOf(token.Pos(0))
+	positionType   = reflect.TypeOf(token.Position{})
+	rangeType      = reflect.TypeOf(Range{})
+)
+
+// converter converts from a marker's argument parsed from the comment to
+// reflect values passed to the method during Invoke.
+// It takes the args remaining, and returns the args it did not consume.
+// This allows a converter to consume 0 args for well known types, or multiple
+// args for compound types.
+type converter func(*expect.Note, []interface{}) (reflect.Value, []interface{}, error)
+
+// method is used to track information about Invoke methods that is expensive to
+// calculate so that we can work it out once rather than per marker.
+type method struct {
+	f          reflect.Value // the reflect value of the passed in method
+	converters []converter   // the parameter converters for the method
+}
+
+// buildConverter works out what function should be used to go from an ast expressions to a reflect
+// value of the type expected by a method.
+// It is called when only the target type is know, it returns converters that are flexible across
+// all supported expression types for that target type.
+func (e *Exported) buildConverter(pt reflect.Type) (converter, error) {
+	switch {
+	case pt == noteType:
+		return func(n *expect.Note, args []interface{}) (reflect.Value, []interface{}, error) {
+			return reflect.ValueOf(n), args, nil
+		}, nil
+	case pt == posType:
+		return func(n *expect.Note, args []interface{}) (reflect.Value, []interface{}, error) {
+			r, remains, err := e.rangeConverter(n, args)
+			if err != nil {
+				return reflect.Value{}, nil, err
+			}
+			return reflect.ValueOf(r.Start), remains, nil
+		}, nil
+	case pt == positionType:
+		return func(n *expect.Note, args []interface{}) (reflect.Value, []interface{}, error) {
+			r, remains, err := e.rangeConverter(n, args)
+			if err != nil {
+				return reflect.Value{}, nil, err
+			}
+			return reflect.ValueOf(e.fset.Position(r.Start)), remains, nil
+		}, nil
+	case pt == rangeType:
+		return func(n *expect.Note, args []interface{}) (reflect.Value, []interface{}, error) {
+			r, remains, err := e.rangeConverter(n, args)
+			if err != nil {
+				return reflect.Value{}, nil, err
+			}
+			return reflect.ValueOf(r), remains, nil
+		}, nil
+	case pt == identifierType:
+		return func(n *expect.Note, args []interface{}) (reflect.Value, []interface{}, error) {
+			arg := args[0]
+			args = args[1:]
+			switch arg := arg.(type) {
+			case expect.Identifier:
+				return reflect.ValueOf(arg), args, nil
+			default:
+				return reflect.Value{}, nil, fmt.Errorf("cannot convert %v to string", arg)
+			}
+		}, nil
+	case pt.Kind() == reflect.String:
+		return func(n *expect.Note, args []interface{}) (reflect.Value, []interface{}, error) {
+			arg := args[0]
+			args = args[1:]
+			switch arg := arg.(type) {
+			case expect.Identifier:
+				return reflect.ValueOf(string(arg)), args, nil
+			case string:
+				return reflect.ValueOf(arg), args, nil
+			default:
+				return reflect.Value{}, nil, fmt.Errorf("cannot convert %v to string", arg)
+			}
+		}, nil
+	case pt.Kind() == reflect.Int64:
+		return func(n *expect.Note, args []interface{}) (reflect.Value, []interface{}, error) {
+			arg := args[0]
+			args = args[1:]
+			switch arg := arg.(type) {
+			case int64:
+				return reflect.ValueOf(arg), args, nil
+			default:
+				return reflect.Value{}, nil, fmt.Errorf("cannot convert %v to int", arg)
+			}
+		}, nil
+	case pt.Kind() == reflect.Bool:
+		return func(n *expect.Note, args []interface{}) (reflect.Value, []interface{}, error) {
+			arg := args[0]
+			args = args[1:]
+			b, ok := arg.(bool)
+			if !ok {
+				return reflect.Value{}, nil, fmt.Errorf("cannot convert %v to bool", arg)
+			}
+			return reflect.ValueOf(b), args, nil
+		}, nil
+	case pt.Kind() == reflect.Slice:
+		return func(n *expect.Note, args []interface{}) (reflect.Value, []interface{}, error) {
+			converter, err := e.buildConverter(pt.Elem())
+			if err != nil {
+				return reflect.Value{}, nil, err
+			}
+			result := reflect.MakeSlice(reflect.SliceOf(pt.Elem()), 0, len(args))
+			for range args {
+				value, remains, err := converter(n, args)
+				if err != nil {
+					return reflect.Value{}, nil, err
+				}
+				result = reflect.Append(result, value)
+				args = remains
+			}
+			return result, args, nil
+		}, nil
+	default:
+		return nil, fmt.Errorf("param has invalid type %v", pt)
+	}
+}
+
+func (e *Exported) rangeConverter(n *expect.Note, args []interface{}) (Range, []interface{}, error) {
+	if len(args) < 1 {
+		return Range{}, nil, fmt.Errorf("missing argument")
+	}
+	arg := args[0]
+	args = args[1:]
+	switch arg := arg.(type) {
+	case expect.Identifier:
+		// handle the special identifiers
+		switch arg {
+		case eofIdentifier:
+			// end of file identifier, look up the current file
+			f := e.fset.File(n.Pos)
+			eof := f.Pos(f.Size())
+			return Range{Start: eof, End: token.NoPos}, args, nil
+		default:
+			// look up an marker by name
+			mark, ok := e.markers[string(arg)]
+			if !ok {
+				return Range{}, nil, fmt.Errorf("cannot find marker %v", arg)
+			}
+			return mark, args, nil
+		}
+	case string:
+		start, end, err := expect.MatchBefore(e.fset, e.fileContents, n.Pos, arg)
+		if err != nil {
+			return Range{}, nil, err
+		}
+		if start == token.NoPos {
+			return Range{}, nil, fmt.Errorf("%v: pattern %s did not match", e.fset.Position(n.Pos), arg)
+		}
+		return Range{Start: start, End: end}, args, nil
+	case *regexp.Regexp:
+		start, end, err := expect.MatchBefore(e.fset, e.fileContents, n.Pos, arg)
+		if err != nil {
+			return Range{}, nil, err
+		}
+		if start == token.NoPos {
+			return Range{}, nil, fmt.Errorf("%v: pattern %s did not match", e.fset.Position(n.Pos), arg)
+		}
+		return Range{Start: start, End: end}, args, nil
+	default:
+		return Range{}, nil, fmt.Errorf("cannot convert %v to pos", arg)
+	}
+}
diff --git a/vendor/golang.org/x/tools/go/packages/packagestest/expect_test.go b/vendor/golang.org/x/tools/go/packages/packagestest/expect_test.go
new file mode 100644
index 00000000..a51946d6
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/packages/packagestest/expect_test.go
@@ -0,0 +1,66 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packagestest_test
+
+import (
+	"go/token"
+	"testing"
+
+	"golang.org/x/tools/go/expect"
+	"golang.org/x/tools/go/packages/packagestest"
+)
+
+func TestExpect(t *testing.T) {
+	exported := packagestest.Export(t, packagestest.GOPATH, []packagestest.Module{{
+		Name:  "golang.org/fake",
+		Files: packagestest.MustCopyFileTree("testdata"),
+	}})
+	defer exported.Cleanup()
+	count := 0
+	if err := exported.Expect(map[string]interface{}{
+		"check": func(src, target token.Position) {
+			count++
+		},
+		"boolArg": func(n *expect.Note, yes, no bool) {
+			if !yes {
+				t.Errorf("Expected boolArg first param to be true")
+			}
+			if no {
+				t.Errorf("Expected boolArg second param to be false")
+			}
+		},
+		"intArg": func(n *expect.Note, i int64) {
+			if i != 42 {
+				t.Errorf("Expected intarg to be 42")
+			}
+		},
+		"stringArg": func(n *expect.Note, name expect.Identifier, value string) {
+			if string(name) != value {
+				t.Errorf("Got string arg %v expected %v", value, name)
+			}
+		},
+		"directNote": func(n *expect.Note) {},
+		"range": func(r packagestest.Range) {
+			if r.Start == token.NoPos || r.Start == 0 {
+				t.Errorf("Range had no valid starting position")
+			}
+			if r.End == token.NoPos || r.End == 0 {
+				t.Errorf("Range had no valid ending position")
+			} else if r.End <= r.Start {
+				t.Errorf("Range ending was not greater than start")
+			}
+		},
+		"checkEOF": func(n *expect.Note, p token.Pos) {
+			if p <= n.Pos {
+				t.Errorf("EOF was before the checkEOF note")
+			}
+		},
+	}); err != nil {
+		t.Fatal(err)
+	}
+	if count == 0 {
+		t.Fatalf("No tests were run")
+	}
+}
diff --git a/vendor/golang.org/x/tools/go/packages/packagestest/export.go b/vendor/golang.org/x/tools/go/packages/packagestest/export.go
index 1181ec24..cb290fdd 100644
--- a/vendor/golang.org/x/tools/go/packages/packagestest/export.go
+++ b/vendor/golang.org/x/tools/go/packages/packagestest/export.go
@@ -14,6 +14,7 @@ package packagestest
 import (
 	"flag"
 	"fmt"
+	"go/token"
 	"io/ioutil"
 	"log"
 	"os"
@@ -21,17 +22,10 @@ import (
 	"strings"
 	"testing"
 
+	"golang.org/x/tools/go/expect"
 	"golang.org/x/tools/go/packages"
 )
 
-const (
-	// gorootModule is a special module name that indicates it contains source files
-	// that should replace the normal GOROOT
-	// in general you should not use this, it only exists for some very specialized
-	// tests.
-	gorootModule = "GOROOT"
-)
-
 var (
 	skipCleanup = flag.Bool("skip-cleanup", false, "Do not delete the temporary export folders") // for debugging
 )
@@ -59,9 +53,13 @@ type Exported struct {
 	// Exactly what it will contain varies depending on the Exporter being used.
 	Config *packages.Config
 
-	temp    string
-	primary string
-	written map[string]map[string]string
+	temp     string                       // the temporary directory that was exported to
+	primary  string                       // the first non GOROOT module that was exported
+	written  map[string]map[string]string // the full set of exported files
+	fset     *token.FileSet               // The file set used when parsing expectations
+	notes    []*expect.Note               // The list of expectations extracted from go source files
+	markers  map[string]Range             // The set of markers extracted from go source files
+	contents map[string][]byte
 }
 
 // Exporter implementations are responsible for converting from the generic description of some
@@ -87,8 +85,12 @@ var All []Exporter
 // the All global.
 // Each exporter will be run as a sub-test named after the exporter being used.
 func TestAll(t *testing.T, f func(*testing.T, Exporter)) {
+	t.Helper()
 	for _, e := range All {
-		t.Run(e.Name(), func(t *testing.T) { f(t, e) })
+		t.Run(e.Name(), func(t *testing.T) {
+			t.Helper()
+			f(t, e)
+		})
 	}
 }
 
@@ -102,7 +104,10 @@ func TestAll(t *testing.T, f func(*testing.T, Exporter)) {
 // flag when invoking the test, allowing the temporary directory to be left for
 // debugging tests.
 func Export(t *testing.T, exporter Exporter, modules []Module) *Exported {
-	temp, err := ioutil.TempDir("", strings.Replace(t.Name(), "/", "_", -1))
+	t.Helper()
+	dirname := strings.Replace(t.Name(), "/", "_", -1)
+	dirname = strings.Replace(dirname, "#", "_", -1) // duplicate subtests get a #NNN suffix.
+	temp, err := ioutil.TempDir("", dirname)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -111,8 +116,11 @@ func Export(t *testing.T, exporter Exporter, modules []Module) *Exported {
 			Dir: temp,
 			Env: append(os.Environ(), "GOPACKAGESDRIVER=off"),
 		},
-		temp:    temp,
-		written: map[string]map[string]string{},
+		temp:     temp,
+		primary:  modules[0].Name,
+		written:  map[string]map[string]string{},
+		fset:     token.NewFileSet(),
+		contents: map[string][]byte{},
 	}
 	defer func() {
 		if t.Failed() || t.Skipped() {
@@ -120,9 +128,6 @@ func Export(t *testing.T, exporter Exporter, modules []Module) *Exported {
 		}
 	}()
 	for _, module := range modules {
-		if exported.primary == "" && module.Name != gorootModule {
-			exported.primary = module.Name
-		}
 		for fragment, value := range module.Files {
 			fullpath := exporter.Filename(exported, module.Name, filepath.FromSlash(fragment))
 			written, ok := exported.written[module.Name]
@@ -210,6 +215,33 @@ func Copy(source string) Writer {
 	}
 }
 
+// MustCopyFileTree returns a file set for a module based on a real directory tree.
+// It scans the directory tree anchored at root and adds a Copy writer to the
+// map for every file found.
+// This is to enable the common case in tests where you have a full copy of the
+// package in your testdata.
+// This will panic if there is any kind of error trying to walk the file tree.
+func MustCopyFileTree(root string) map[string]interface{} {
+	result := map[string]interface{}{}
+	if err := filepath.Walk(filepath.FromSlash(root), func(path string, info os.FileInfo, err error) error {
+		if err != nil {
+			return err
+		}
+		if info.IsDir() {
+			return nil
+		}
+		fragment, err := filepath.Rel(root, path)
+		if err != nil {
+			return err
+		}
+		result[fragment] = Copy(path)
+		return nil
+	}); err != nil {
+		log.Panic(fmt.Sprintf("MustCopyFileTree failed: %v", err))
+	}
+	return result
+}
+
 // Cleanup removes the temporary directory (unless the --skip-cleanup flag was set)
 // It is safe to call cleanup multiple times.
 func (e *Exported) Cleanup() {
@@ -236,3 +268,14 @@ func (e *Exported) File(module, fragment string) string {
 	}
 	return ""
 }
+
+func (e *Exported) fileContents(filename string) ([]byte, error) {
+	if content, found := e.contents[filename]; found {
+		return content, nil
+	}
+	content, err := ioutil.ReadFile(filename)
+	if err != nil {
+		return nil, err
+	}
+	return content, nil
+}
diff --git a/vendor/golang.org/x/tools/go/packages/packagestest/export_test.go b/vendor/golang.org/x/tools/go/packages/packagestest/export_test.go
index 0e0b53a1..decfd7c0 100644
--- a/vendor/golang.org/x/tools/go/packages/packagestest/export_test.go
+++ b/vendor/golang.org/x/tools/go/packages/packagestest/export_test.go
@@ -24,6 +24,11 @@ var testdata = []packagestest.Module{{
 	Files: map[string]interface{}{
 		"other/a.go": "package fake2",
 	},
+}, {
+	Name: "golang.org/fake2/v2",
+	Files: map[string]interface{}{
+		"other/a.go": "package fake2",
+	},
 }}
 
 type fileTest struct {
diff --git a/vendor/golang.org/x/tools/go/packages/packagestest/gopath.go b/vendor/golang.org/x/tools/go/packages/packagestest/gopath.go
index 149d73e3..54016859 100644
--- a/vendor/golang.org/x/tools/go/packages/packagestest/gopath.go
+++ b/vendor/golang.org/x/tools/go/packages/packagestest/gopath.go
@@ -27,7 +27,7 @@ import (
 //              golang.org
 //                  repob
 //                      b
-//     										 b.go
+//                          b.go
 // GOPATH would be set to
 //     /sometemporarydirectory/repoa;/sometemporarydirectory/repob
 // and the working directory would be
@@ -56,10 +56,6 @@ func (gopath) Finalize(exported *Exported) error {
 			gopath += string(filepath.ListSeparator)
 		}
 		dir := gopathDir(exported, module)
-		if module == gorootModule {
-			exported.Config.Env = append(exported.Config.Env, "GOROOT="+dir)
-			continue
-		}
 		gopath += dir
 		if module == exported.primary {
 			exported.Config.Dir = filepath.Join(dir, "src")
@@ -70,5 +66,9 @@ func (gopath) Finalize(exported *Exported) error {
 }
 
 func gopathDir(exported *Exported, module string) string {
-	return filepath.Join(exported.temp, path.Base(module))
+	dir := path.Base(module)
+	if versionSuffixRE.MatchString(dir) {
+		dir = path.Base(path.Dir(module)) + "_" + dir
+	}
+	return filepath.Join(exported.temp, dir)
 }
diff --git a/vendor/golang.org/x/tools/go/packages/packagestest/gopath_test.go b/vendor/golang.org/x/tools/go/packages/packagestest/gopath_test.go
index bc6f62ce..a251dbce 100644
--- a/vendor/golang.org/x/tools/go/packages/packagestest/gopath_test.go
+++ b/vendor/golang.org/x/tools/go/packages/packagestest/gopath_test.go
@@ -23,5 +23,6 @@ func TestGOPATHExport(t *testing.T) {
 		{"golang.org/fake1", "a.go", "fake1/src/golang.org/fake1/a.go", checkLink("testdata/a.go")},
 		{"golang.org/fake1", "b.go", "fake1/src/golang.org/fake1/b.go", checkContent("package fake1")},
 		{"golang.org/fake2", "other/a.go", "fake2/src/golang.org/fake2/other/a.go", checkContent("package fake2")},
+		{"golang.org/fake2/v2", "other/a.go", "fake2_v2/src/golang.org/fake2/v2/other/a.go", checkContent("package fake2")},
 	})
 }
diff --git a/vendor/golang.org/x/tools/go/packages/packagestest/modules.go b/vendor/golang.org/x/tools/go/packages/packagestest/modules.go
index 01004c05..58137bc6 100644
--- a/vendor/golang.org/x/tools/go/packages/packagestest/modules.go
+++ b/vendor/golang.org/x/tools/go/packages/packagestest/modules.go
@@ -5,11 +5,17 @@
 package packagestest
 
 import (
+	"archive/zip"
 	"bytes"
 	"fmt"
 	"io/ioutil"
+	"os"
+	"os/exec"
 	"path"
 	"path/filepath"
+	"regexp"
+
+	"golang.org/x/tools/go/packages"
 )
 
 // Modules is the exporter that produces module layouts.
@@ -39,38 +45,166 @@ func (modules) Name() string {
 }
 
 func (modules) Filename(exported *Exported, module, fragment string) string {
+	if module == exported.primary {
+		return filepath.Join(primaryDir(exported), fragment)
+	}
 	return filepath.Join(moduleDir(exported, module), fragment)
 }
 
 func (modules) Finalize(exported *Exported) error {
-	exported.Config.Env = append(exported.Config.Env, "GO111MODULE=on")
-	for module, files := range exported.written {
-		dir := gopathDir(exported, module)
-		if module == gorootModule {
-			exported.Config.Env = append(exported.Config.Env, "GOROOT="+dir)
+	// Write out the primary module. This module can use symlinks and
+	// other weird stuff, and will be the working dir for the go command.
+	// It depends on all the other modules.
+	primaryDir := primaryDir(exported)
+	exported.Config.Dir = primaryDir
+	exported.written[exported.primary]["go.mod"] = filepath.Join(primaryDir, "go.mod")
+	primaryGomod := "module " + exported.primary + "\nrequire (\n"
+	for other := range exported.written {
+		if other == exported.primary {
 			continue
 		}
-		buf := &bytes.Buffer{}
-		fmt.Fprintf(buf, "module %v\n", module)
-		// add replace directives to the paths of all other modules written
-		for other := range exported.written {
-			if other == gorootModule || other == module {
-				continue
-			}
-			fmt.Fprintf(buf, "replace %v => %v\n", other, moduleDir(exported, other))
+		primaryGomod += fmt.Sprintf("\t%v %v\n", other, moduleVersion(other))
+	}
+	primaryGomod += ")\n"
+	if err := ioutil.WriteFile(filepath.Join(primaryDir, "go.mod"), []byte(primaryGomod), 0644); err != nil {
+		return err
+	}
+
+	// Create the mod cache so we can rename it later, even if we don't need it.
+	if err := os.MkdirAll(modCache(exported), 0755); err != nil {
+		return err
+	}
+
+	// Write out the go.mod files for the other modules.
+	for module, files := range exported.written {
+		if module == exported.primary {
+			continue
 		}
+		dir := moduleDir(exported, module)
+
 		modfile := filepath.Join(dir, "go.mod")
-		if err := ioutil.WriteFile(modfile, buf.Bytes(), 0644); err != nil {
+		if err := ioutil.WriteFile(modfile, []byte("module "+module+"\n"), 0644); err != nil {
 			return err
 		}
 		files["go.mod"] = modfile
+	}
+
+	// Zip up all the secondary modules into the proxy dir.
+	proxyDir := filepath.Join(exported.temp, "modproxy")
+	for module, files := range exported.written {
 		if module == exported.primary {
-			exported.Config.Dir = dir
+			continue
+		}
+		dir := filepath.Join(proxyDir, module, "@v")
+
+		if err := writeModuleProxy(dir, module, files); err != nil {
+			return fmt.Errorf("creating module proxy dir for %v: %v", module, err)
 		}
 	}
+
+	// Discard the original mod cache dir, which contained the files written
+	// for us by Export.
+	if err := os.Rename(modCache(exported), modCache(exported)+".orig"); err != nil {
+		return err
+	}
+	exported.Config.Env = append(exported.Config.Env,
+		"GO111MODULE=on",
+		"GOPATH="+filepath.Join(exported.temp, "modcache"),
+		"GOPROXY=file://"+filepath.ToSlash(proxyDir))
+
+	// Run go mod download to recreate the mod cache dir with all the extra
+	// stuff in cache. All the files created by Export should be recreated.
+	if err := invokeGo(exported.Config, "mod", "download"); err != nil {
+		return err
+	}
+
 	return nil
 }
 
+// writeModuleProxy creates a directory in the proxy dir for a module.
+func writeModuleProxy(dir, module string, files map[string]string) error {
+	ver := moduleVersion(module)
+	if err := os.MkdirAll(dir, 0755); err != nil {
+		return err
+	}
+
+	// list file. Just the single version.
+	if err := ioutil.WriteFile(filepath.Join(dir, "list"), []byte(ver+"\n"), 0644); err != nil {
+		return err
+	}
+
+	// go.mod, copied from the file written in Finalize.
+	modContents, err := ioutil.ReadFile(files["go.mod"])
+	if err != nil {
+		return err
+	}
+	if err := ioutil.WriteFile(filepath.Join(dir, ver+".mod"), modContents, 0644); err != nil {
+		return err
+	}
+
+	// info file, just the bare bones.
+	infoContents := []byte(fmt.Sprintf(`{"Version": "%v", "Time":"2017-12-14T13:08:43Z"}`, ver))
+	if err := ioutil.WriteFile(filepath.Join(dir, ver+".info"), infoContents, 0644); err != nil {
+		return err
+	}
+
+	// zip of all the source files.
+	f, err := os.OpenFile(filepath.Join(dir, ver+".zip"), os.O_CREATE|os.O_WRONLY, 0644)
+	if err != nil {
+		return err
+	}
+	z := zip.NewWriter(f)
+	for name, path := range files {
+		zf, err := z.Create(module + "@" + ver + "/" + name)
+		if err != nil {
+			return err
+		}
+		contents, err := ioutil.ReadFile(path)
+		if err != nil {
+			return err
+		}
+		if _, err := zf.Write(contents); err != nil {
+			return err
+		}
+	}
+	if err := z.Close(); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func invokeGo(cfg *packages.Config, args ...string) error {
+	stdout := new(bytes.Buffer)
+	stderr := new(bytes.Buffer)
+	cmd := exec.Command("go", args...)
+	cmd.Env = append(append([]string{}, cfg.Env...), "PWD="+cfg.Dir)
+	cmd.Dir = cfg.Dir
+	cmd.Stdout = stdout
+	cmd.Stderr = stderr
+	if err := cmd.Run(); err != nil {
+		return fmt.Errorf("go %v: %s: %s", args, err, stderr)
+	}
+	return nil
+}
+
+func modCache(exported *Exported) string {
+	return filepath.Join(exported.temp, "modcache/pkg/mod")
+}
+
+func primaryDir(exported *Exported) string {
+	return filepath.Join(exported.temp, "primarymod", path.Base(exported.primary))
+}
+
 func moduleDir(exported *Exported, module string) string {
-	return filepath.Join(exported.temp, path.Base(module))
+	return filepath.Join(modCache(exported), path.Dir(module), path.Base(module)+"@"+moduleVersion(module))
+}
+
+var versionSuffixRE = regexp.MustCompile(`v\d+`)
+
+func moduleVersion(module string) string {
+	if versionSuffixRE.MatchString(path.Base(module)) {
+		return path.Base(module) + ".0.0"
+	}
+	return "v1.0.0"
 }
diff --git a/vendor/golang.org/x/tools/go/packages/packagestest/modules_test.go b/vendor/golang.org/x/tools/go/packages/packagestest/modules_test.go
index 3530f079..8a85ae16 100644
--- a/vendor/golang.org/x/tools/go/packages/packagestest/modules_test.go
+++ b/vendor/golang.org/x/tools/go/packages/packagestest/modules_test.go
@@ -17,15 +17,16 @@ func TestModulesExport(t *testing.T) {
 	exported := packagestest.Export(t, packagestest.Modules, testdata)
 	defer exported.Cleanup()
 	// Check that the cfg contains all the right bits
-	var expectDir = filepath.Join(exported.Temp(), "fake1")
+	var expectDir = filepath.Join(exported.Temp(), "primarymod/fake1")
 	if exported.Config.Dir != expectDir {
 		t.Errorf("Got working directory %v expected %v", exported.Config.Dir, expectDir)
 	}
 	checkFiles(t, exported, []fileTest{
-		{"golang.org/fake1", "go.mod", "fake1/go.mod", nil},
-		{"golang.org/fake1", "a.go", "fake1/a.go", checkLink("testdata/a.go")},
-		{"golang.org/fake1", "b.go", "fake1/b.go", checkContent("package fake1")},
-		{"golang.org/fake2", "go.mod", "fake2/go.mod", nil},
-		{"golang.org/fake2", "other/a.go", "fake2/other/a.go", checkContent("package fake2")},
+		{"golang.org/fake1", "go.mod", "primarymod/fake1/go.mod", nil},
+		{"golang.org/fake1", "a.go", "primarymod/fake1/a.go", checkLink("testdata/a.go")},
+		{"golang.org/fake1", "b.go", "primarymod/fake1/b.go", checkContent("package fake1")},
+		{"golang.org/fake2", "go.mod", "modcache/pkg/mod/golang.org/fake2@v1.0.0/go.mod", nil},
+		{"golang.org/fake2", "other/a.go", "modcache/pkg/mod/golang.org/fake2@v1.0.0/other/a.go", checkContent("package fake2")},
+		{"golang.org/fake2/v2", "other/a.go", "modcache/pkg/mod/golang.org/fake2/v2@v2.0.0/other/a.go", checkContent("package fake2")},
 	})
 }
diff --git a/vendor/golang.org/x/tools/go/packages/packagestest/testdata/test.go b/vendor/golang.org/x/tools/go/packages/packagestest/testdata/test.go
new file mode 100644
index 00000000..13fc12b9
--- /dev/null
+++ b/vendor/golang.org/x/tools/go/packages/packagestest/testdata/test.go
@@ -0,0 +1,24 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package fake1
+
+// This is a test file for the behaviors in Exported.Expect.
+
+type AThing string //@AThing,mark(StringThing, "AThing"),mark(REThing,re`.T.*g`)
+
+type Match string //@check("Match",re`[[:upper:]]`)
+
+//@check(AThing, StringThing)
+//@check(AThing, REThing)
+
+//@boolArg(true, false)
+//@intArg(42)
+//@stringArg(PlainString, "PlainString")
+//@stringArg(IdentAsString,IdentAsString)
+//@directNote()
+//@range(AThing)
+
+// The following test should remain at the bottom of the file
+//@checkEOF(EOF)
diff --git a/vendor/golang.org/x/tools/go/packages/stdlib_test.go b/vendor/golang.org/x/tools/go/packages/stdlib_test.go
index ddecff1c..72665241 100644
--- a/vendor/golang.org/x/tools/go/packages/stdlib_test.go
+++ b/vendor/golang.org/x/tools/go/packages/stdlib_test.go
@@ -35,6 +35,9 @@ func TestStdlibMetadata(t *testing.T) {
 	if err != nil {
 		t.Fatalf("failed to load metadata: %v", err)
 	}
+	if packages.PrintErrors(pkgs) > 0 {
+		t.Fatal("there were errors loading standard library")
+	}
 
 	t1 := time.Now()
 	runtime.GC()
@@ -99,6 +102,10 @@ func TestCgoOption(t *testing.T) {
 			t.Errorf("Load failed: %v", err)
 			continue
 		}
+		if packages.PrintErrors(pkgs) > 0 {
+			t.Error("there were errors loading standard library")
+			continue
+		}
 		pkg := pkgs[0]
 		obj := pkg.Types.Scope().Lookup(test.name)
 		if obj == nil {
diff --git a/vendor/golang.org/x/tools/go/packages/visit.go b/vendor/golang.org/x/tools/go/packages/visit.go
index c1a4b28c..b13cb081 100644
--- a/vendor/golang.org/x/tools/go/packages/visit.go
+++ b/vendor/golang.org/x/tools/go/packages/visit.go
@@ -24,7 +24,7 @@ func Visit(pkgs []*Package, pre func(*Package) bool, post func(*Package)) {
 				for path := range pkg.Imports {
 					paths = append(paths, path)
 				}
-				sort.Strings(paths) // for determinism
+				sort.Strings(paths) // Imports is a map, this makes visit stable
 				for _, path := range paths {
 					visit(pkg.Imports[path])
 				}
diff --git a/vendor/golang.org/x/tools/go/ssa/example_test.go b/vendor/golang.org/x/tools/go/ssa/example_test.go
index c33b6d62..de5ed5e1 100644
--- a/vendor/golang.org/x/tools/go/ssa/example_test.go
+++ b/vendor/golang.org/x/tools/go/ssa/example_test.go
@@ -49,7 +49,7 @@ func main() {
 // with similar functionality. It is located at
 // golang.org/x/tools/cmd/ssadump.
 //
-func ExampleBuildPackage() {
+func Example_buildPackage() {
 	// Parse the source files.
 	fset := token.NewFileSet()
 	f, err := parser.ParseFile(fset, "hello.go", hello, parser.ParseComments)
@@ -117,7 +117,7 @@ func ExampleBuildPackage() {
 // This example builds SSA code for a set of packages using the
 // x/tools/go/packages API. This is what you would typically use for a
 // analysis capable of operating on a single package.
-func ExampleLoadPackages() {
+func Example_loadPackages() {
 	// Load, parse, and type-check the initial packages.
 	cfg := &packages.Config{Mode: packages.LoadSyntax}
 	initial, err := packages.Load(cfg, "fmt", "net/http")
@@ -147,7 +147,7 @@ func ExampleLoadPackages() {
 // This example builds SSA code for a set of packages plus all their dependencies,
 // using the x/tools/go/packages API.
 // This is what you'd typically use for a whole-program analysis.
-func ExampleLoadWholeProgram() {
+func Example_loadWholeProgram() {
 	// Load, parse, and type-check the whole program.
 	cfg := packages.Config{Mode: packages.LoadAllSyntax}
 	initial, err := packages.Load(&cfg, "fmt", "net/http")
diff --git a/vendor/golang.org/x/tools/go/ssa/methods.go b/vendor/golang.org/x/tools/go/ssa/methods.go
index 080dca96..9cf38391 100644
--- a/vendor/golang.org/x/tools/go/ssa/methods.go
+++ b/vendor/golang.org/x/tools/go/ssa/methods.go
@@ -23,14 +23,14 @@ import (
 //
 func (prog *Program) MethodValue(sel *types.Selection) *Function {
 	if sel.Kind() != types.MethodVal {
-		panic(fmt.Sprintf("Method(%s) kind != MethodVal", sel))
+		panic(fmt.Sprintf("MethodValue(%s) kind != MethodVal", sel))
 	}
 	T := sel.Recv()
 	if isInterface(T) {
 		return nil // abstract method
 	}
 	if prog.mode&LogSource != 0 {
-		defer logStack("Method %s %v", T, sel)()
+		defer logStack("MethodValue %s %v", T, sel)()
 	}
 
 	prog.methodsMu.Lock()
diff --git a/vendor/golang.org/x/tools/go/ssa/sanity.go b/vendor/golang.org/x/tools/go/ssa/sanity.go
index 6eb64328..0a7abc5e 100644
--- a/vendor/golang.org/x/tools/go/ssa/sanity.go
+++ b/vendor/golang.org/x/tools/go/ssa/sanity.go
@@ -408,8 +408,8 @@ func (s *sanity) checkFunction(fn *Function) bool {
 		s.errorf("nil Prog")
 	}
 
-	fn.String()            // must not crash
-	fn.RelString(fn.pkg()) // must not crash
+	_ = fn.String()            // must not crash
+	_ = fn.RelString(fn.pkg()) // must not crash
 
 	// All functions have a package, except delegates (which are
 	// shared across packages, or duplicated as weak symbols in a
@@ -499,7 +499,7 @@ func sanityCheckPackage(pkg *Package) {
 	if pkg.Pkg == nil {
 		panic(fmt.Sprintf("Package %s has no Object", pkg))
 	}
-	pkg.String() // must not crash
+	_ = pkg.String() // must not crash
 
 	for name, mem := range pkg.Members {
 		if name != mem.Name() {
diff --git a/vendor/golang.org/x/tools/go/ssa/ssa.go b/vendor/golang.org/x/tools/go/ssa/ssa.go
index 7f7998a5..78272c54 100644
--- a/vendor/golang.org/x/tools/go/ssa/ssa.go
+++ b/vendor/golang.org/x/tools/go/ssa/ssa.go
@@ -654,7 +654,7 @@ type ChangeInterface struct {
 // value of a concrete type.
 //
 // Use Program.MethodSets.MethodSet(X.Type()) to find the method-set
-// of X, and Program.Method(m) to find the implementation of a method.
+// of X, and Program.MethodValue(m) to find the implementation of a method.
 //
 // To construct the zero value of an interface type T, use:
 // 	NewConst(constant.MakeNil(), T, pos)
diff --git a/vendor/golang.org/x/tools/godoc/redirect/redirect.go b/vendor/golang.org/x/tools/godoc/redirect/redirect.go
index 3bec5337..8208518c 100644
--- a/vendor/golang.org/x/tools/godoc/redirect/redirect.go
+++ b/vendor/golang.org/x/tools/godoc/redirect/redirect.go
@@ -115,7 +115,7 @@ var redirects = map[string]string{
 	"/tour":  "http://tour.golang.org",
 	"/wiki":  "https://github.com/golang/go/wiki",
 
-	"/doc/articles/c_go_cgo.html": "/blog/c-go-cgo",
+	"/doc/articles/c_go_cgo.html":                    "/blog/c-go-cgo",
 	"/doc/articles/concurrency_patterns.html":        "/blog/go-concurrency-patterns-timing-out-and",
 	"/doc/articles/defer_panic_recover.html":         "/blog/defer-panic-and-recover",
 	"/doc/articles/error_handling.html":              "/blog/error-handling-and-go",
@@ -191,9 +191,13 @@ func clHandler(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 	target := ""
-	// the first CL in rietveld is about 152046, so only treat the id as
-	// a rietveld CL if it is larger than 150000.
-	if n, err := strconv.Atoi(id); err == nil && n > 150000 {
+
+	if n, err := strconv.Atoi(id); err == nil && isRietveldCL(n) {
+		// TODO: Issue 28836: if this Rietveld CL happens to
+		// also be a Gerrit CL, render a disambiguation HTML
+		// page with two links instead. We'll need to make an
+		// RPC (to maintner?) to figure that out. For now just
+		// redirect to rietveld.
 		target = "https://codereview.appspot.com/" + id
 	} else {
 		target = "https://go-review.googlesource.com/" + id
diff --git a/vendor/golang.org/x/tools/godoc/redirect/redirect_test.go b/vendor/golang.org/x/tools/godoc/redirect/redirect_test.go
index a242f4fa..804bfb00 100644
--- a/vendor/golang.org/x/tools/godoc/redirect/redirect_test.go
+++ b/vendor/golang.org/x/tools/godoc/redirect/redirect_test.go
@@ -62,6 +62,15 @@ func TestRedirects(t *testing.T) {
 		"/cl/1/":         {302, "https://go-review.googlesource.com/1"},
 		"/cl/267120043":  {302, "https://codereview.appspot.com/267120043"},
 		"/cl/267120043/": {302, "https://codereview.appspot.com/267120043"},
+
+		// Verify that we're using the Rietveld CL table:
+		"/cl/152046": {302, "https://codereview.appspot.com/152046"},
+		"/cl/152047": {302, "https://go-review.googlesource.com/152047"},
+		"/cl/152048": {302, "https://codereview.appspot.com/152048"},
+
+		// And verify we're using the the "bigEnoughAssumeRietveld" value:
+		"/cl/299999": {302, "https://go-review.googlesource.com/299999"},
+		"/cl/300000": {302, "https://codereview.appspot.com/300000"},
 	}
 
 	mux := http.NewServeMux()
diff --git a/vendor/golang.org/x/tools/godoc/redirect/rietveld.go b/vendor/golang.org/x/tools/godoc/redirect/rietveld.go
new file mode 100644
index 00000000..81b1094d
--- /dev/null
+++ b/vendor/golang.org/x/tools/godoc/redirect/rietveld.go
@@ -0,0 +1,1093 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package redirect
+
+// bigEnoughAssumeRietveld is the value where CLs equal or great are
+// assumed to be on Rietveld. By including this threshold we shrink
+// the size of the table below. When Go amasses 150,000 more CLs, we'll
+// need to bump this number and regenerate the list below.
+const bigEnoughAssumeRietveld = 300000
+
+// isRietveldCL reports whether cl was a Rietveld CL number.
+func isRietveldCL(cl int) bool {
+	return cl >= bigEnoughAssumeRietveld || lowRietveldCL[cl]
+}
+
+// lowRietveldCLs are the old CL numbers assigned by Rietveld code
+// review system as used by Go prior to Gerrit which are less than
+// bigEnoughAssumeRietveld.
+//
+// This list of numbers is registered with the /cl/NNNN redirect
+// handler to disambiguate which code review system a particular
+// number corresponds to. In some rare cases there may be duplicates,
+// in which case we might render an HTML choice for the user.
+//
+// To re-generate this list, run:
+//
+// $ cd $GOROOT
+// $ git log 7d7c6a9..94151eb | grep "^    https://golang.org/cl/" | perl -ne 's,^\s+https://golang.org/cl/(\d+).*$,$1,; chomp; print "$_: true,\n" if $_ < 300000' | sort -n | uniq
+//
+// Note that we ignore the x/* repos because we didn't start using
+// "subrepos" until the Rietveld CLs numbers were already 4,000,000+,
+// well above bigEnoughAssumeRietveld.
+var lowRietveldCL = map[int]bool{
+	152046: true,
+	152048: true,
+	152049: true,
+	152050: true,
+	152051: true,
+	152052: true,
+	152055: true,
+	152056: true,
+	152057: true,
+	152072: true,
+	152073: true,
+	152075: true,
+	152076: true,
+	152077: true,
+	152078: true,
+	152079: true,
+	152080: true,
+	152082: true,
+	152084: true,
+	152085: true,
+	152086: true,
+	152088: true,
+	152089: true,
+	152091: true,
+	152098: true,
+	152101: true,
+	152102: true,
+	152105: true,
+	152106: true,
+	152107: true,
+	152108: true,
+	152109: true,
+	152110: true,
+	152114: true,
+	152117: true,
+	152118: true,
+	152120: true,
+	152123: true,
+	152124: true,
+	152128: true,
+	152130: true,
+	152131: true,
+	152138: true,
+	152141: true,
+	152142: true,
+	153048: true,
+	153049: true,
+	153050: true,
+	153051: true,
+	153055: true,
+	153056: true,
+	153057: true,
+	154043: true,
+	154044: true,
+	154045: true,
+	154049: true,
+	154055: true,
+	154057: true,
+	154058: true,
+	154059: true,
+	154061: true,
+	154064: true,
+	154065: true,
+	154067: true,
+	154068: true,
+	154069: true,
+	154071: true,
+	154072: true,
+	154073: true,
+	154076: true,
+	154079: true,
+	154096: true,
+	154097: true,
+	154099: true,
+	154100: true,
+	154101: true,
+	154102: true,
+	154108: true,
+	154118: true,
+	154121: true,
+	154122: true,
+	154123: true,
+	154125: true,
+	154126: true,
+	154128: true,
+	154136: true,
+	154138: true,
+	154139: true,
+	154140: true,
+	154141: true,
+	154142: true,
+	154143: true,
+	154144: true,
+	154145: true,
+	154146: true,
+	154152: true,
+	154153: true,
+	154156: true,
+	154159: true,
+	154161: true,
+	154166: true,
+	154167: true,
+	154169: true,
+	154171: true,
+	154172: true,
+	154173: true,
+	154174: true,
+	154175: true,
+	154176: true,
+	154177: true,
+	154178: true,
+	154179: true,
+	154180: true,
+	155041: true,
+	155042: true,
+	155045: true,
+	155047: true,
+	155048: true,
+	155049: true,
+	155050: true,
+	155054: true,
+	155055: true,
+	155056: true,
+	155057: true,
+	155058: true,
+	155059: true,
+	155061: true,
+	155062: true,
+	155063: true,
+	155065: true,
+	155067: true,
+	155069: true,
+	155072: true,
+	155074: true,
+	155075: true,
+	155077: true,
+	155078: true,
+	155079: true,
+	156041: true,
+	156044: true,
+	156045: true,
+	156046: true,
+	156047: true,
+	156051: true,
+	156052: true,
+	156054: true,
+	156055: true,
+	156056: true,
+	156058: true,
+	156059: true,
+	156060: true,
+	156061: true,
+	156062: true,
+	156063: true,
+	156066: true,
+	156067: true,
+	156070: true,
+	156071: true,
+	156073: true,
+	156075: true,
+	156077: true,
+	156079: true,
+	156080: true,
+	156081: true,
+	156083: true,
+	156084: true,
+	156085: true,
+	156086: true,
+	156089: true,
+	156091: true,
+	156092: true,
+	156093: true,
+	156094: true,
+	156097: true,
+	156099: true,
+	156100: true,
+	156102: true,
+	156103: true,
+	156104: true,
+	156106: true,
+	156107: true,
+	156108: true,
+	156109: true,
+	156110: true,
+	156113: true,
+	156115: true,
+	156116: true,
+	157041: true,
+	157042: true,
+	157043: true,
+	157044: true,
+	157046: true,
+	157053: true,
+	157055: true,
+	157056: true,
+	157058: true,
+	157060: true,
+	157061: true,
+	157062: true,
+	157065: true,
+	157066: true,
+	157067: true,
+	157068: true,
+	157069: true,
+	157071: true,
+	157072: true,
+	157073: true,
+	157074: true,
+	157075: true,
+	157076: true,
+	157077: true,
+	157082: true,
+	157084: true,
+	157085: true,
+	157087: true,
+	157088: true,
+	157091: true,
+	157095: true,
+	157096: true,
+	157099: true,
+	157100: true,
+	157101: true,
+	157102: true,
+	157103: true,
+	157104: true,
+	157106: true,
+	157110: true,
+	157111: true,
+	157112: true,
+	157114: true,
+	157116: true,
+	157119: true,
+	157140: true,
+	157142: true,
+	157143: true,
+	157144: true,
+	157146: true,
+	157147: true,
+	157149: true,
+	157151: true,
+	157152: true,
+	157153: true,
+	157154: true,
+	157156: true,
+	157157: true,
+	157158: true,
+	157159: true,
+	157160: true,
+	157162: true,
+	157166: true,
+	157167: true,
+	157168: true,
+	157170: true,
+	158041: true,
+	159044: true,
+	159049: true,
+	159050: true,
+	159051: true,
+	160043: true,
+	160044: true,
+	160045: true,
+	160046: true,
+	160047: true,
+	160054: true,
+	160056: true,
+	160057: true,
+	160059: true,
+	160060: true,
+	160061: true,
+	160064: true,
+	160065: true,
+	160069: true,
+	160070: true,
+	161049: true,
+	161050: true,
+	161056: true,
+	161058: true,
+	161060: true,
+	161061: true,
+	161069: true,
+	161070: true,
+	161073: true,
+	161075: true,
+	162041: true,
+	162044: true,
+	162046: true,
+	162053: true,
+	162054: true,
+	162055: true,
+	162056: true,
+	162057: true,
+	162058: true,
+	162059: true,
+	162061: true,
+	162062: true,
+	163042: true,
+	163044: true,
+	163049: true,
+	163050: true,
+	163051: true,
+	163052: true,
+	163053: true,
+	163055: true,
+	163058: true,
+	163061: true,
+	163062: true,
+	163064: true,
+	163067: true,
+	163068: true,
+	163069: true,
+	163070: true,
+	163071: true,
+	163072: true,
+	163082: true,
+	163083: true,
+	163085: true,
+	163088: true,
+	163091: true,
+	163092: true,
+	163097: true,
+	163098: true,
+	164043: true,
+	164047: true,
+	164049: true,
+	164052: true,
+	164053: true,
+	164056: true,
+	164059: true,
+	164060: true,
+	164062: true,
+	164068: true,
+	164069: true,
+	164071: true,
+	164073: true,
+	164074: true,
+	164075: true,
+	164078: true,
+	164079: true,
+	164081: true,
+	164082: true,
+	164083: true,
+	164085: true,
+	164086: true,
+	164088: true,
+	164090: true,
+	164091: true,
+	164092: true,
+	164093: true,
+	164094: true,
+	164095: true,
+	165042: true,
+	165044: true,
+	165045: true,
+	165048: true,
+	165049: true,
+	165050: true,
+	165051: true,
+	165055: true,
+	165057: true,
+	165058: true,
+	165059: true,
+	165061: true,
+	165062: true,
+	165063: true,
+	165064: true,
+	165065: true,
+	165068: true,
+	165070: true,
+	165076: true,
+	165078: true,
+	165080: true,
+	165083: true,
+	165086: true,
+	165097: true,
+	165100: true,
+	165101: true,
+	166041: true,
+	166043: true,
+	166044: true,
+	166047: true,
+	166049: true,
+	166052: true,
+	166053: true,
+	166055: true,
+	166058: true,
+	166059: true,
+	166060: true,
+	166064: true,
+	166066: true,
+	166067: true,
+	166068: true,
+	166070: true,
+	166071: true,
+	166072: true,
+	166073: true,
+	166074: true,
+	166076: true,
+	166077: true,
+	166078: true,
+	166080: true,
+	167043: true,
+	167044: true,
+	167047: true,
+	167050: true,
+	167055: true,
+	167057: true,
+	167058: true,
+	168041: true,
+	168045: true,
+	170042: true,
+	170043: true,
+	170044: true,
+	170046: true,
+	170047: true,
+	170048: true,
+	170049: true,
+	171044: true,
+	171046: true,
+	171047: true,
+	171048: true,
+	171051: true,
+	172041: true,
+	172042: true,
+	172043: true,
+	172045: true,
+	172049: true,
+	173041: true,
+	173044: true,
+	173045: true,
+	174042: true,
+	174047: true,
+	174048: true,
+	174050: true,
+	174051: true,
+	174052: true,
+	174053: true,
+	174063: true,
+	174064: true,
+	174072: true,
+	174076: true,
+	174077: true,
+	174078: true,
+	174082: true,
+	174083: true,
+	174087: true,
+	175045: true,
+	175046: true,
+	175047: true,
+	175048: true,
+	176056: true,
+	176057: true,
+	176058: true,
+	176061: true,
+	176062: true,
+	176063: true,
+	176064: true,
+	176066: true,
+	176067: true,
+	176070: true,
+	176071: true,
+	176076: true,
+	178043: true,
+	178044: true,
+	178046: true,
+	178048: true,
+	179047: true,
+	179055: true,
+	179061: true,
+	179062: true,
+	179063: true,
+	179067: true,
+	179069: true,
+	179070: true,
+	179072: true,
+	179079: true,
+	179088: true,
+	179095: true,
+	179096: true,
+	179097: true,
+	179099: true,
+	179105: true,
+	179106: true,
+	179108: true,
+	179118: true,
+	179120: true,
+	179125: true,
+	179126: true,
+	179128: true,
+	179129: true,
+	179130: true,
+	180044: true,
+	180045: true,
+	180046: true,
+	180047: true,
+	180048: true,
+	180049: true,
+	180050: true,
+	180052: true,
+	180053: true,
+	180054: true,
+	180055: true,
+	180056: true,
+	180057: true,
+	180059: true,
+	180061: true,
+	180064: true,
+	180065: true,
+	180068: true,
+	180069: true,
+	180070: true,
+	180074: true,
+	180075: true,
+	180081: true,
+	180082: true,
+	180085: true,
+	180092: true,
+	180099: true,
+	180105: true,
+	180108: true,
+	180112: true,
+	180118: true,
+	181041: true,
+	181043: true,
+	181044: true,
+	181045: true,
+	181049: true,
+	181050: true,
+	181055: true,
+	181057: true,
+	181058: true,
+	181059: true,
+	181063: true,
+	181071: true,
+	181073: true,
+	181075: true,
+	181077: true,
+	181080: true,
+	181083: true,
+	181084: true,
+	181085: true,
+	181086: true,
+	181087: true,
+	181089: true,
+	181097: true,
+	181099: true,
+	181102: true,
+	181111: true,
+	181130: true,
+	181135: true,
+	181137: true,
+	181138: true,
+	181139: true,
+	181151: true,
+	181152: true,
+	181153: true,
+	181155: true,
+	181156: true,
+	181157: true,
+	181158: true,
+	181160: true,
+	181161: true,
+	181163: true,
+	181164: true,
+	181171: true,
+	181179: true,
+	181183: true,
+	181184: true,
+	181186: true,
+	182041: true,
+	182043: true,
+	182044: true,
+	183042: true,
+	183043: true,
+	183044: true,
+	183047: true,
+	183049: true,
+	183065: true,
+	183066: true,
+	183073: true,
+	183074: true,
+	183075: true,
+	183083: true,
+	183084: true,
+	183087: true,
+	183088: true,
+	183090: true,
+	183095: true,
+	183104: true,
+	183107: true,
+	183109: true,
+	183111: true,
+	183112: true,
+	183113: true,
+	183116: true,
+	183123: true,
+	183124: true,
+	183125: true,
+	183126: true,
+	183132: true,
+	183133: true,
+	183135: true,
+	183136: true,
+	183137: true,
+	183138: true,
+	183139: true,
+	183140: true,
+	183141: true,
+	183142: true,
+	183153: true,
+	183155: true,
+	183156: true,
+	183157: true,
+	183160: true,
+	184043: true,
+	184055: true,
+	184058: true,
+	184059: true,
+	184068: true,
+	184069: true,
+	184079: true,
+	184080: true,
+	184081: true,
+	185043: true,
+	185045: true,
+	186042: true,
+	186043: true,
+	186073: true,
+	186076: true,
+	186077: true,
+	186078: true,
+	186079: true,
+	186081: true,
+	186095: true,
+	186108: true,
+	186113: true,
+	186115: true,
+	186116: true,
+	186118: true,
+	186119: true,
+	186132: true,
+	186137: true,
+	186138: true,
+	186139: true,
+	186143: true,
+	186144: true,
+	186145: true,
+	186146: true,
+	186147: true,
+	186148: true,
+	186159: true,
+	186160: true,
+	186161: true,
+	186165: true,
+	186169: true,
+	186173: true,
+	186180: true,
+	186210: true,
+	186211: true,
+	186212: true,
+	186213: true,
+	186214: true,
+	186215: true,
+	186216: true,
+	186228: true,
+	186229: true,
+	186230: true,
+	186232: true,
+	186234: true,
+	186255: true,
+	186263: true,
+	186276: true,
+	186279: true,
+	186282: true,
+	186283: true,
+	188043: true,
+	189042: true,
+	189057: true,
+	189059: true,
+	189062: true,
+	189078: true,
+	189080: true,
+	189083: true,
+	189088: true,
+	189093: true,
+	189095: true,
+	189096: true,
+	189098: true,
+	189100: true,
+	190041: true,
+	190042: true,
+	190043: true,
+	190044: true,
+	190059: true,
+	190062: true,
+	190068: true,
+	190074: true,
+	190076: true,
+	190077: true,
+	190079: true,
+	190085: true,
+	190088: true,
+	190103: true,
+	190104: true,
+	193055: true,
+	193066: true,
+	193067: true,
+	193070: true,
+	193075: true,
+	193079: true,
+	193080: true,
+	193081: true,
+	193091: true,
+	193092: true,
+	193095: true,
+	193101: true,
+	193104: true,
+	194043: true,
+	194045: true,
+	194046: true,
+	194050: true,
+	194051: true,
+	194052: true,
+	194053: true,
+	194064: true,
+	194066: true,
+	194069: true,
+	194071: true,
+	194072: true,
+	194073: true,
+	194074: true,
+	194076: true,
+	194077: true,
+	194078: true,
+	194082: true,
+	194084: true,
+	194085: true,
+	194090: true,
+	194091: true,
+	194092: true,
+	194094: true,
+	194097: true,
+	194098: true,
+	194099: true,
+	194100: true,
+	194114: true,
+	194116: true,
+	194118: true,
+	194119: true,
+	194120: true,
+	194121: true,
+	194122: true,
+	194126: true,
+	194129: true,
+	194131: true,
+	194132: true,
+	194133: true,
+	194134: true,
+	194146: true,
+	194151: true,
+	194156: true,
+	194157: true,
+	194159: true,
+	194161: true,
+	194165: true,
+	195041: true,
+	195044: true,
+	195050: true,
+	195051: true,
+	195052: true,
+	195068: true,
+	195075: true,
+	195076: true,
+	195079: true,
+	195080: true,
+	195081: true,
+	196042: true,
+	196044: true,
+	196050: true,
+	196051: true,
+	196055: true,
+	196056: true,
+	196061: true,
+	196063: true,
+	196065: true,
+	196070: true,
+	196071: true,
+	196075: true,
+	196077: true,
+	196079: true,
+	196087: true,
+	196088: true,
+	196090: true,
+	196091: true,
+	197041: true,
+	197042: true,
+	197043: true,
+	197044: true,
+	198044: true,
+	198045: true,
+	198046: true,
+	198048: true,
+	198049: true,
+	198050: true,
+	198053: true,
+	198057: true,
+	198058: true,
+	198066: true,
+	198071: true,
+	198074: true,
+	198081: true,
+	198084: true,
+	198085: true,
+	198102: true,
+	199042: true,
+	199044: true,
+	199045: true,
+	199046: true,
+	199047: true,
+	199052: true,
+	199054: true,
+	199057: true,
+	199066: true,
+	199070: true,
+	199082: true,
+	199091: true,
+	199094: true,
+	199096: true,
+	201041: true,
+	201042: true,
+	201043: true,
+	201047: true,
+	201048: true,
+	201049: true,
+	201058: true,
+	201061: true,
+	201064: true,
+	201065: true,
+	201068: true,
+	202042: true,
+	202043: true,
+	202044: true,
+	202051: true,
+	202054: true,
+	202055: true,
+	203043: true,
+	203050: true,
+	203051: true,
+	203053: true,
+	203060: true,
+	203062: true,
+	204042: true,
+	204044: true,
+	204048: true,
+	204052: true,
+	204053: true,
+	204061: true,
+	204062: true,
+	204064: true,
+	204065: true,
+	204067: true,
+	204068: true,
+	204069: true,
+	205042: true,
+	205044: true,
+	206043: true,
+	206044: true,
+	206047: true,
+	206050: true,
+	206051: true,
+	206052: true,
+	206053: true,
+	206054: true,
+	206055: true,
+	206058: true,
+	206059: true,
+	206060: true,
+	206067: true,
+	206069: true,
+	206077: true,
+	206078: true,
+	206079: true,
+	206084: true,
+	206089: true,
+	206101: true,
+	206107: true,
+	206109: true,
+	207043: true,
+	207044: true,
+	207049: true,
+	207050: true,
+	207051: true,
+	207052: true,
+	207053: true,
+	207054: true,
+	207055: true,
+	207061: true,
+	207062: true,
+	207069: true,
+	207071: true,
+	207085: true,
+	207086: true,
+	207087: true,
+	207088: true,
+	207095: true,
+	207096: true,
+	207102: true,
+	207103: true,
+	207106: true,
+	207108: true,
+	207110: true,
+	207111: true,
+	207112: true,
+	209041: true,
+	209042: true,
+	209043: true,
+	209044: true,
+	210042: true,
+	210043: true,
+	210044: true,
+	210047: true,
+	211041: true,
+	212041: true,
+	212045: true,
+	212046: true,
+	212047: true,
+	213041: true,
+	213042: true,
+	214042: true,
+	214046: true,
+	214049: true,
+	214050: true,
+	215042: true,
+	215048: true,
+	215050: true,
+	216043: true,
+	216046: true,
+	216047: true,
+	216052: true,
+	216053: true,
+	216054: true,
+	216059: true,
+	216068: true,
+	217041: true,
+	217044: true,
+	217047: true,
+	217048: true,
+	217049: true,
+	217056: true,
+	217058: true,
+	217059: true,
+	217060: true,
+	217061: true,
+	217064: true,
+	217066: true,
+	217069: true,
+	217071: true,
+	217085: true,
+	217086: true,
+	217088: true,
+	217093: true,
+	217094: true,
+	217108: true,
+	217109: true,
+	217111: true,
+	217115: true,
+	217116: true,
+	218042: true,
+	218044: true,
+	218046: true,
+	218050: true,
+	218060: true,
+	218061: true,
+	218063: true,
+	218064: true,
+	218065: true,
+	218070: true,
+	218071: true,
+	218072: true,
+	218074: true,
+	218076: true,
+	222041: true,
+	223041: true,
+	223043: true,
+	223044: true,
+	223050: true,
+	223052: true,
+	223054: true,
+	223058: true,
+	223059: true,
+	223061: true,
+	223068: true,
+	223069: true,
+	223070: true,
+	223071: true,
+	223073: true,
+	223075: true,
+	223076: true,
+	223083: true,
+	223087: true,
+	223094: true,
+	223096: true,
+	223101: true,
+	223106: true,
+	223108: true,
+	224041: true,
+	224042: true,
+	224043: true,
+	224045: true,
+	224051: true,
+	224053: true,
+	224057: true,
+	224060: true,
+	224061: true,
+	224062: true,
+	224063: true,
+	224068: true,
+	224069: true,
+	224081: true,
+	224084: true,
+	224087: true,
+	224090: true,
+	224096: true,
+	224105: true,
+	225042: true,
+	227041: true,
+	229045: true,
+	229046: true,
+	229048: true,
+	229049: true,
+	229050: true,
+	231042: true,
+	236041: true,
+	237041: true,
+	238041: true,
+	238042: true,
+	240041: true,
+	240042: true,
+	240043: true,
+	241041: true,
+	243041: true,
+	244041: true,
+	245041: true,
+	247041: true,
+	250041: true,
+	252041: true,
+	253041: true,
+	253045: true,
+	254043: true,
+	255042: true,
+	255043: true,
+	257041: true,
+	257042: true,
+	258041: true,
+	261041: true,
+	264041: true,
+	294042: true,
+	296042: true,
+}
diff --git a/vendor/golang.org/x/tools/imports/fix.go b/vendor/golang.org/x/tools/imports/fix.go
index 1e3bd095..187bc7d3 100644
--- a/vendor/golang.org/x/tools/imports/fix.go
+++ b/vendor/golang.org/x/tools/imports/fix.go
@@ -932,15 +932,3 @@ func findImportStdlib(shortPkg string, symbols map[string]bool) (importPath stri
 	}
 	return importPath, importPath != ""
 }
-
-// fileInDir reports whether the provided file path looks like
-// it's in dir. (without hitting the filesystem)
-func fileInDir(file, dir string) bool {
-	rest := strings.TrimPrefix(file, dir)
-	if len(rest) == len(file) {
-		// dir is not a prefix of file.
-		return false
-	}
-	// Check for boundary: either nothing (file == dir), or a slash.
-	return len(rest) == 0 || rest[0] == '/' || rest[0] == '\\'
-}
diff --git a/vendor/golang.org/x/tools/imports/fix_test.go b/vendor/golang.org/x/tools/imports/fix_test.go
index ede39c98..7d71ecd7 100644
--- a/vendor/golang.org/x/tools/imports/fix_test.go
+++ b/vendor/golang.org/x/tools/imports/fix_test.go
@@ -7,13 +7,13 @@ package imports
 import (
 	"fmt"
 	"go/build"
-	"io/ioutil"
-	"os"
 	"path/filepath"
 	"runtime"
 	"strings"
 	"sync"
 	"testing"
+
+	"golang.org/x/tools/go/packages/packagestest"
 )
 
 var tests = []struct {
@@ -55,11 +55,11 @@ func bar() {
 import (
   "fmt"
 
-  "appengine"
+  "github.com/golang/snappy"
 )
 func bar() {
 var b bytes.Buffer
-_ = appengine.IsDevServer
+_ = snappy.ErrCorrupt
 fmt.Println(b.String())
 }
 `,
@@ -69,12 +69,12 @@ import (
 	"bytes"
 	"fmt"
 
-	"appengine"
+	"github.com/golang/snappy"
 )
 
 func bar() {
 	var b bytes.Buffer
-	_ = appengine.IsDevServer
+	_ = snappy.ErrCorrupt
 	fmt.Println(b.String())
 }
 `,
@@ -88,12 +88,12 @@ func bar() {
 import (
   "fmt"
 
-  "appengine"
+  "github.com/golang/snappy"
 )
 func bar() {
 _ = math.NaN
 _ = fmt.Sprintf
-_ = appengine.IsDevServer
+_ = snappy.ErrCorrupt
 }
 `,
 		out: `package foo
@@ -102,13 +102,13 @@ import (
 	"fmt"
 	"math"
 
-	"appengine"
+	"github.com/golang/snappy"
 )
 
 func bar() {
 	_ = math.NaN
 	_ = fmt.Sprintf
-	_ = appengine.IsDevServer
+	_ = snappy.ErrCorrupt
 }
 `,
 	},
@@ -352,7 +352,7 @@ import (
 
 func foo () {
 _, _ = os.Args, fmt.Println
-_, _ = appengine.Main, datastore.ErrInvalidEntityType
+_, _ = snappy.ErrCorrupt, p.P
 }
 `,
 		out: `package foo
@@ -361,13 +361,13 @@ import (
 	"fmt"
 	"os"
 
-	"appengine"
-	"appengine/datastore"
+	"github.com/golang/snappy"
+	"rsc.io/p"
 )
 
 func foo() {
 	_, _ = os.Args, fmt.Println
-	_, _ = appengine.Main, datastore.ErrInvalidEntityType
+	_, _ = snappy.ErrCorrupt, p.P
 }
 `,
 	},
@@ -426,7 +426,7 @@ import (
 	"fmt"
 	"net"
 
-	"code.google.com/p/snappy-go/snappy"
+	"github.com/golang/snappy"
 )
 
 func f() {
@@ -443,7 +443,7 @@ func f() {
 		in: `package foo
 
 import (
-	"code.google.com/p/snappy-go/snappy"
+	"github.com/golang/snappy"
 	"fmt"
 	"net"
 )
@@ -460,7 +460,7 @@ import (
 	"fmt"
 	"net"
 
-	"code.google.com/p/snappy-go/snappy"
+	"github.com/golang/snappy"
 )
 
 func f() {
@@ -501,12 +501,12 @@ import (
 "fmt"
 
 "gu"
-"github.com/foo/bar"
+"manypackages.com/packagea"
 )
 
 var (
-a = bar.a
-b = gu.a
+a = packagea.A
+b = gu.A
 c = fmt.Printf
 )
 `,
@@ -517,12 +517,12 @@ import (
 
 	"gu"
 
-	"github.com/foo/bar"
+	"manypackages.com/packagea"
 )
 
 var (
-	a = bar.a
-	b = gu.a
+	a = packagea.A
+	b = gu.A
 	c = fmt.Printf
 )
 `,
@@ -556,14 +556,14 @@ func notmain() { fmt.Println("Hello, world") }`,
 import (
 	"fmt"
 
-	"github.com/foo/bar"
-	"github.com/foo/qux"
+	"manypackages.com/packagea"
+	"manypackages.com/packageb"
 )
 
 func main() {
 	var _ = fmt.Println
-	//var _ = bar.A
-	var _ = qux.B
+	//var _ = packagea.A
+	var _ = packageb.B
 }
 `,
 		out: `package main
@@ -571,13 +571,13 @@ func main() {
 import (
 	"fmt"
 
-	"github.com/foo/qux"
+	"manypackages.com/packageb"
 )
 
 func main() {
 	var _ = fmt.Println
-	//var _ = bar.A
-	var _ = qux.B
+	//var _ = packagea.A
+	var _ = packageb.B
 }
 `,
 	},
@@ -590,34 +590,34 @@ func main() {
 
 import (
 	"fmt"
-	renamed_bar "github.com/foo/bar"
+	renamed_packagea "manypackages.com/packagea"
 
-	. "github.com/foo/baz"
+	. "manypackages.com/packageb"
 	"io"
 
-	_ "github.com/foo/qux"
+	_ "manypackages.com/packagec"
 	"strings"
 )
 
-var _, _, _, _, _ = fmt.Errorf, io.Copy, strings.Contains, renamed_bar.A, B
+var _, _, _, _, _ = fmt.Errorf, io.Copy, strings.Contains, renamed_packagea.A, B
 `,
 		out: `package main
 
 import (
 	"fmt"
 
-	renamed_bar "github.com/foo/bar"
+	renamed_packagea "manypackages.com/packagea"
 
 	"io"
 
-	. "github.com/foo/baz"
+	. "manypackages.com/packageb"
 
 	"strings"
 
-	_ "github.com/foo/qux"
+	_ "manypackages.com/packagec"
 )
 
-var _, _, _, _, _ = fmt.Errorf, io.Copy, strings.Contains, renamed_bar.A, B
+var _, _, _, _, _ = fmt.Errorf, io.Copy, strings.Contains, renamed_packagea.A, B
 `,
 	},
 
@@ -630,7 +630,7 @@ var _, _, _, _, _ = fmt.Errorf, io.Copy, strings.Contains, renamed_bar.A, B
 import (
 	"fmt"                     // A
 	"go/ast"                  // B
-	_ "launchpad.net/gocheck" // C
+	_ "manypackages.com/packagec"    // C
 )
 
 func main() { _, _ = fmt.Print, ast.Walk }
@@ -641,7 +641,7 @@ import (
 	"fmt"    // A
 	"go/ast" // B
 
-	_ "launchpad.net/gocheck" // C
+	_ "manypackages.com/packagec" // C
 )
 
 func main() { _, _ = fmt.Print, ast.Walk }
@@ -761,7 +761,7 @@ func main() { fmt.Println() }
 
 import (
 "fmt"
-"golang.org/x/foo"
+"manypackages.com/packagea"
 )
 
 func main() {}
@@ -771,7 +771,7 @@ func main() {}
 import (
 	"fmt"
 
-	"golang.org/x/foo"
+	"manypackages.com/packagea"
 )
 
 func main() {}
@@ -818,7 +818,7 @@ func main() {
 import (
 	"time"
 
-	"code.google.com/p/snappy-go/snappy"
+	"github.com/golang/snappy"
 	"rsc.io/p"
 )
 
@@ -837,7 +837,7 @@ func main() {
 import (
 	"time"
 
-	"code.google.com/p/snappy-go/snappy"
+	"github.com/golang/snappy"
 )
 
 func main() {
@@ -851,7 +851,7 @@ func main() {
 import (
 	"time"
 
-	"code.google.com/p/snappy-go/snappy"
+	"github.com/golang/snappy"
 	"rsc.io/p"
 )
 
@@ -863,8 +863,9 @@ func main() {
 `,
 	},
 
+	// golang.org/issue/12097
 	{
-		name: "issue #12097",
+		name: "package_statement_insertion_preserves_comments",
 		in: `// a
 // b
 // c
@@ -980,7 +981,7 @@ import (
 	_ "net/http/pprof" // install the pprof http handlers
 	"strings"
 
-	"github.com/pkg/errors"
+	"manypackages.com/packagea"
 )
 
 func main() {
@@ -989,7 +990,7 @@ func main() {
 	var (
 		_ json.Number
 		_ *http.Request
-		_ errors.Frame
+		_ packagea.A
 	)
 }
 `,
@@ -1002,7 +1003,7 @@ import (
 	_ "net/http/pprof" // install the pprof http handlers
 	"strings"
 
-	"github.com/pkg/errors"
+	"manypackages.com/packagea"
 )
 
 func main() {
@@ -1011,7 +1012,7 @@ func main() {
 	var (
 		_ json.Number
 		_ *http.Request
-		_ errors.Frame
+		_ packagea.A
 	)
 }
 `,
@@ -1108,7 +1109,7 @@ var _, _ = rand.Read, rand.NewZipf
 
 func TestSimpleCases(t *testing.T) {
 	defer func(lp string) { LocalPrefix = lp }(LocalPrefix)
-	LocalPrefix = "local,github.com/local"
+	LocalPrefix = "local.com,github.com/local"
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
 			options := &Options{
@@ -1119,20 +1120,80 @@ func TestSimpleCases(t *testing.T) {
 				FormatOnly: tt.formatOnly,
 			}
 			testConfig{
-				// Skeleton non-stdlib packages for use during testing.
-				// Each includes one arbitrary symbol, e.g. the first declaration in the first file.
-				// Try not to add more without a good reason.
-				gopathFiles: map[string]string{
-					"appengine/x.go":                          "package appengine\nfunc Main(){}\n",
-					"appengine/datastore/x.go":                "package datastore\nvar ErrInvalidEntityType error\n",
-					"rsc.io/p/x.go":                           "package p\nfunc P(){}\n",
-					"code.google.com/p/snappy-go/snappy/x.go": "package snappy\nvar ErrCorrupt error\n",
-					"x/x.go": tt.in,
+				modules: []packagestest.Module{
+					{
+						Name:  "golang.org/fake",
+						Files: fm{"x.go": tt.in},
+					},
+					// Skeleton non-stdlib packages for use during testing.
+					// Each includes one arbitrary symbol, e.g. the first declaration in the first file.
+					// Try not to add more without a good reason.
+					// DO NOT USE PACKAGES NOT LISTED HERE -- they will be downloaded!
+					{
+						Name:  "rsc.io",
+						Files: fm{"p/x.go": "package p\nfunc P(){}\n"},
+					},
+					{
+						Name:  "github.com/golang/snappy",
+						Files: fm{"x.go": "package snappy\nvar ErrCorrupt error\n"},
+					},
+					{
+						Name: "manypackages.com",
+						Files: fm{
+							"packagea/x.go": "package packagea\nfunc A(){}\n",
+							"packageb/x.go": "package packageb\nfunc B(){}\n",
+							"packagec/x.go": "package packagec\nfunc C(){}\n",
+							"packaged/x.go": "package packaged\nfunc D(){}\n",
+						},
+					},
+					{
+						Name:  "local.com",
+						Files: fm{"foo/x.go": "package foo\nfunc Foo(){}\n"},
+					},
+					{
+						Name:  "github.com/local",
+						Files: fm{"bar/x.go": "package bar\nfunc Bar(){}\n"},
+					},
 				},
-			}.processTest(t, "x/x.go", nil, options, tt.out)
+			}.processTest(t, "golang.org/fake", "x.go", nil, options, tt.out)
 		})
 	}
+}
+
+func TestAppengine(t *testing.T) {
+	const input = `package p
+
+var _, _, _ = fmt.Printf, appengine.Main, datastore.ErrInvalidEntityType
+`
+
+	const want = `package p
+
+import (
+	"fmt"
+
+	"appengine"
+	"appengine/datastore"
+)
 
+var _, _, _ = fmt.Printf, appengine.Main, datastore.ErrInvalidEntityType
+`
+
+	testConfig{
+		gopathOnly: true, // can't create a module named appengine, so no module tests.
+		modules: []packagestest.Module{
+			{
+				Name:  "golang.org/fake",
+				Files: fm{"x.go": input},
+			},
+			{
+				Name: "appengine",
+				Files: fm{
+					"x.go":           "package appengine\nfunc Main(){}\n",
+					"datastore/x.go": "package datastore\nvar ErrInvalidEntityType error\n",
+				},
+			},
+		},
+	}.processTest(t, "golang.org/fake", "x.go", nil, nil, want)
 }
 
 func TestReadFromFilesystem(t *testing.T) {
@@ -1182,10 +1243,11 @@ func bar() {
 				Fragment:  true,
 			}
 			testConfig{
-				gopathFiles: map[string]string{
-					"x.go": tt.in,
+				module: packagestest.Module{
+					Name:  "golang.org/fake",
+					Files: fm{"x.go": tt.in},
 				},
-			}.processTest(t, "x.go", nil, options, tt.out)
+			}.processTest(t, "golang.org/fake", "x.go", nil, options, tt.out)
 		})
 	}
 
@@ -1210,7 +1272,8 @@ var (
 
 import (
 	"fmt"
-	"x/mypkg"
+
+	"golang.org/fake/x/y/mypkg"
 )
 
 var (
@@ -1220,13 +1283,16 @@ var (
 `
 
 	testConfig{
-		gopathFiles: map[string]string{
-			"../target/f.go":             "package mypkg\nvar Foo = 123\n",
-			"x/mypkg":                    "LINK:../../target", // valid symlink
-			"x/apkg":                     "LINK:..",           // symlink loop
-			"myotherpackage/toformat.go": input,
+		module: packagestest.Module{
+			Name: "golang.org/fake",
+			Files: fm{
+				"target/f.go":                "package mypkg\nvar Foo = 123\n",
+				"x/y/mypkg":                  packagestest.Symlink("../../target"), // valid symlink
+				"x/y/apkg":                   packagestest.Symlink(".."),           // symlink loop
+				"myotherpackage/toformat.go": input,
+			},
 		},
-	}.processTest(t, "myotherpackage/toformat.go", nil, nil, want)
+	}.processTest(t, "golang.org/fake", "myotherpackage/toformat.go", nil, nil, want)
 }
 
 func TestImportSymlinksWithIgnore(t *testing.T) {
@@ -1253,14 +1319,18 @@ var (
 `
 
 	testConfig{
-		gopathFiles: map[string]string{
-			"../target/f.go":         "package mypkg\nvar Foo = 123\n",
-			"x/mypkg":                "LINK:../../target", // valid symlink
-			"x/apkg":                 "LINK:..",           // symlink loop
-			"myotherpkg/toformat.go": input,
-			".goimportsignore":       "x/mypkg\n",
+		gopathOnly: true,
+		module: packagestest.Module{
+			Name: "golang.org/fake",
+			Files: fm{
+				"target/f.go":            "package mypkg\nvar Foo = 123\n",
+				"x/y/mypkg":              packagestest.Symlink("../../target"), // valid symlink
+				"x/y/apkg":               packagestest.Symlink(".."),           // symlink loop
+				"myotherpkg/toformat.go": input,
+				"../../.goimportsignore": "golang.org/fake/x/y/mypkg\n",
+			},
 		},
-	}.processTest(t, "myotherpkg/toformat.go", nil, nil, want)
+	}.processTest(t, "golang.org/fake", "myotherpkg/toformat.go", nil, nil, want)
 }
 
 // Test for x/y/v2 convention for package y.
@@ -1280,10 +1350,11 @@ var (
 `
 
 	testConfig{
-		gopathFiles: map[string]string{
-			"mypkg.com/outpkg/toformat.go": input,
+		module: packagestest.Module{
+			Name:  "mypkg.com/outpkg",
+			Files: fm{"toformat.go": input},
 		},
-	}.processTest(t, "mypkg.com/outpkg/toformat.go", nil, nil, input)
+	}.processTest(t, "mypkg.com/outpkg", "toformat.go", nil, nil, input)
 }
 
 // Test for correctly identifying the name of a vendored package when it
@@ -1305,11 +1376,15 @@ var (
 )
 `
 	testConfig{
-		gopathFiles: map[string]string{
-			"mypkg.com/outpkg/vendor/mypkg.com/mypkg.v1/f.go": "package mypkg\nvar Foo = 123\n",
-			"mypkg.com/outpkg/toformat.go":                    input,
+		gopathOnly: true,
+		module: packagestest.Module{
+			Name: "mypkg.com/outpkg",
+			Files: fm{
+				"vendor/mypkg.com/mypkg.v1/f.go": "package mypkg\nvar Foo = 123\n",
+				"toformat.go":                    input,
+			},
 		},
-	}.processTest(t, "mypkg.com/outpkg/toformat.go", nil, nil, input)
+	}.processTest(t, "mypkg.com/outpkg", "toformat.go", nil, nil, input)
 }
 
 func TestInternal(t *testing.T) {
@@ -1319,26 +1394,35 @@ var _ = race.Acquire
 `
 	const importAdded = `package bar
 
-import "foo/internal/race"
+import "foo.com/internal/race"
 
 var _ = race.Acquire
 `
 
 	// Packages under the same directory should be able to use internal packages.
 	testConfig{
-		gopathFiles: map[string]string{
-			"foo/internal/race/x.go": "package race\n func Acquire(){}\n",
-			"foo/bar/x.go":           input,
+		module: packagestest.Module{
+			Name: "foo.com",
+			Files: fm{
+				"internal/race/x.go": "package race\n func Acquire(){}\n",
+				"bar/x.go":           input,
+			},
 		},
-	}.processTest(t, "foo/bar/x.go", nil, nil, importAdded)
+	}.processTest(t, "foo.com", "bar/x.go", nil, nil, importAdded)
 
 	// Packages outside the same directory should not.
 	testConfig{
-		gopathFiles: map[string]string{
-			"foo/internal/race/x.go": "package race\n func Acquire(){}\n",
-			"bar/x.go":               input,
+		modules: []packagestest.Module{
+			{
+				Name:  "foo.com",
+				Files: fm{"internal/race/x.go": "package race\n func Acquire(){}\n"},
+			},
+			{
+				Name:  "bar.com",
+				Files: fm{"x.go": input},
+			},
 		},
-	}.processTest(t, "bar/x.go", nil, nil, input)
+	}.processTest(t, "bar.com", "x.go", nil, nil, input)
 }
 
 func TestProcessVendor(t *testing.T) {
@@ -1353,11 +1437,14 @@ import "golang.org/x/net/http2/hpack"
 var _ = hpack.HuffmanDecode
 `
 	testConfig{
-		gopathFiles: map[string]string{
-			"vendor/golang.org/x/net/http2/hpack/huffman.go": "package hpack\nfunc HuffmanDecode() { }\n",
-			"bar/x.go": input,
+		module: packagestest.Module{
+			Name: "foo.com",
+			Files: fm{
+				"vendor/golang.org/x/net/http2/hpack/huffman.go": "package hpack\nfunc HuffmanDecode() { }\n",
+				"bar/x.go": input,
+			},
 		},
-	}.processTest(t, "bar/x.go", nil, nil, want)
+	}.processTest(t, "foo.com", "bar/x.go", nil, nil, want)
 }
 
 func TestFindStdlib(t *testing.T) {
@@ -1388,118 +1475,86 @@ func TestFindStdlib(t *testing.T) {
 }
 
 type testConfig struct {
-	// goroot and gopath optionally specifies the path on disk
-	// to use for the GOROOT and GOPATH. If empty, a temp directory
-	// is made if needed.
-	goroot, gopath string
-
-	// gorootFiles optionally specifies the complete contents of GOROOT to use,
-	// If nil, the normal current $GOROOT is used.
-	gorootFiles map[string]string // paths relative to $GOROOT/src to contents
-
-	// gopathFiles is like gorootFiles, but for $GOPATH.
-	// If nil, there is no GOPATH, though.
-	gopathFiles map[string]string // paths relative to $GOPATH/src to contents
-}
-
-func mustTempDir(t *testing.T, prefix string) string {
-	t.Helper()
-	dir, err := ioutil.TempDir("", prefix)
-	if err != nil {
-		t.Fatal(err)
-	}
-	return dir
+	gopathOnly bool
+	module     packagestest.Module
+	modules    []packagestest.Module
 }
 
-func mapToDir(destDir string, files map[string]string) error {
-	for path, contents := range files {
-		file := filepath.Join(destDir, "src", path)
-		if err := os.MkdirAll(filepath.Dir(file), 0755); err != nil {
-			return err
-		}
-		var err error
-		if strings.HasPrefix(contents, "LINK:") {
-			err = os.Symlink(strings.TrimPrefix(contents, "LINK:"), file)
-		} else {
-			err = ioutil.WriteFile(file, []byte(contents), 0644)
-		}
-		if err != nil {
-			return err
-		}
-	}
-	return nil
-}
+// fm is the type for a packagestest.Module's Files, abbreviated for shorter lines.
+type fm map[string]interface{}
 
 func (c testConfig) test(t *testing.T, fn func(*goimportTest)) {
 	t.Helper()
 
-	goroot := c.goroot
-	gopath := c.gopath
-
-	if c.gorootFiles != nil && goroot == "" {
-		goroot = mustTempDir(t, "goroot-")
-		defer os.RemoveAll(goroot)
-	}
-	if err := mapToDir(goroot, c.gorootFiles); err != nil {
-		t.Fatal(err)
+	var exported *packagestest.Exported
+	if c.module.Name != "" {
+		c.modules = []packagestest.Module{c.module}
 	}
 
-	if c.gopathFiles != nil && gopath == "" {
-		gopath = mustTempDir(t, "gopath-")
-		defer os.RemoveAll(gopath)
-	}
-	if err := mapToDir(gopath, c.gopathFiles); err != nil {
-		t.Fatal(err)
-	}
+	for _, exporter := range []packagestest.Exporter{packagestest.GOPATH} {
+		t.Run(exporter.Name(), func(t *testing.T) {
+			t.Helper()
+			exported = packagestest.Export(t, exporter, c.modules)
+			defer exported.Cleanup()
+
+			env := make(map[string]string)
+			for _, kv := range exported.Config.Env {
+				split := strings.Split(kv, "=")
+				k, v := split[0], split[1]
+				env[k] = v
+			}
 
-	scanOnce = sync.Once{}
+			goroot := env["GOROOT"]
+			gopath := env["GOPATH"]
 
-	oldGOPATH := build.Default.GOPATH
-	oldGOROOT := build.Default.GOROOT
-	oldCompiler := build.Default.Compiler
-	build.Default.GOPATH = ""
-	build.Default.Compiler = "gc"
+			scanOnce = sync.Once{}
 
-	defer func() {
-		build.Default.GOPATH = oldGOPATH
-		build.Default.GOROOT = oldGOROOT
-		build.Default.Compiler = oldCompiler
-	}()
+			oldGOPATH := build.Default.GOPATH
+			oldGOROOT := build.Default.GOROOT
+			oldCompiler := build.Default.Compiler
+			build.Default.GOROOT = goroot
+			build.Default.GOPATH = gopath
+			build.Default.Compiler = "gc"
 
-	if goroot != "" {
-		build.Default.GOROOT = goroot
-	}
-	build.Default.GOPATH = gopath
+			defer func() {
+				build.Default.GOPATH = oldGOPATH
+				build.Default.GOROOT = oldGOROOT
+				build.Default.Compiler = oldCompiler
+			}()
 
-	it := &goimportTest{
-		T:      t,
-		goroot: build.Default.GOROOT,
-		gopath: gopath,
-		ctx:    &build.Default,
+			it := &goimportTest{
+				T:        t,
+				gopath:   gopath,
+				exported: exported,
+			}
+			fn(it)
+		})
 	}
-	fn(it)
 }
 
-func (c testConfig) processTest(t *testing.T, file string, contents []byte, opts *Options, want string) {
+func (c testConfig) processTest(t *testing.T, module, file string, contents []byte, opts *Options, want string) {
 	t.Helper()
 	c.test(t, func(t *goimportTest) {
 		t.Helper()
-		t.process(file, contents, opts, want)
+		t.process(module, file, contents, opts, want)
 	})
 }
 
 type goimportTest struct {
 	*testing.T
-	ctx    *build.Context
-	goroot string
-	gopath string
+	gopath   string
+	exported *packagestest.Exported
 }
 
-func (t *goimportTest) process(file string, contents []byte, opts *Options, want string) {
+func (t *goimportTest) process(module, file string, contents []byte, opts *Options, want string) {
 	t.Helper()
-	buf, err := Process(filepath.Join(t.gopath, "src", file), contents, opts)
+	f := t.exported.File(module, file)
+	if f == "" {
+		t.Fatalf("%v not found in exported files (typo in filename?)", file)
+	}
+	buf, err := Process(f, contents, opts)
 	if err != nil {
-		t.Fatal(err)
+		t.Fatalf("Process() = %v", err)
 	}
 	if string(buf) != want {
 		t.Errorf("Got:\n%s\nWant:\n%s", buf, want)
@@ -1516,41 +1571,49 @@ func TestRenameWhenPackageNameMismatch(t *testing.T) {
 
 	const want = `package main
 
-import bar "foo/bar/v1"
+import bar "foo.com/foo/bar/v1"
 
 const Y = bar.X
 `
 	testConfig{
-		gopathFiles: map[string]string{
-			"foo/bar/v1/x.go": "package bar \n const X = 1",
-			"test/t.go":       input,
+		module: packagestest.Module{
+			Name: "foo.com",
+			Files: fm{
+				"foo/bar/v1/x.go": "package bar \n const X = 1",
+				"test/t.go":       input,
+			},
 		},
-	}.processTest(t, "test/t.go", nil, nil, want)
+	}.processTest(t, "foo.com", "test/t.go", nil, nil, want)
 }
 
 // Tests that the LocalPrefix option causes imports
 // to be added into a later group (num=3).
 func TestLocalPrefix(t *testing.T) {
 	tests := []struct {
-		config      testConfig
+		name        string
+		modules     []packagestest.Module
 		localPrefix string
 		src         string
 		want        string
 	}{
 		{
-			config: testConfig{
-				gopathFiles: map[string]string{
-					"foo/bar/bar.go": "package bar \n const X = 1",
+			name: "one_local",
+			modules: []packagestest.Module{
+				{
+					Name: "foo.com",
+					Files: fm{
+						"bar/bar.go": "package bar \n const X = 1",
+					},
 				},
 			},
-			localPrefix: "foo/",
+			localPrefix: "foo.com/",
 			src:         "package main \n const Y = bar.X \n const _ = runtime.GOOS",
 			want: `package main
 
 import (
 	"runtime"
 
-	"foo/bar"
+	"foo.com/bar"
 )
 
 const Y = bar.X
@@ -1558,21 +1621,25 @@ const _ = runtime.GOOS
 `,
 		},
 		{
-			config: testConfig{
-				gopathFiles: map[string]string{
-					"foo/foo.go":     "package foo \n const X = 1",
-					"foo/bar/bar.go": "package bar \n const X = 1",
+			name: "two_local",
+			modules: []packagestest.Module{
+				{
+					Name: "foo.com",
+					Files: fm{
+						"foo/foo.go":     "package foo \n const X = 1",
+						"foo/bar/bar.go": "package bar \n const X = 1",
+					},
 				},
 			},
-			localPrefix: "foo/",
+			localPrefix: "foo.com/foo",
 			src:         "package main \n const Y = bar.X \n const Z = foo.X \n const _ = runtime.GOOS",
 			want: `package main
 
 import (
 	"runtime"
 
-	"foo"
-	"foo/bar"
+	"foo.com/foo"
+	"foo.com/foo/bar"
 )
 
 const Y = bar.X
@@ -1581,14 +1648,22 @@ const _ = runtime.GOOS
 `,
 		},
 		{
-			config: testConfig{
-				gopathFiles: map[string]string{
-					"example.org/pkg/pkg.go":          "package pkg \n const A = 1",
-					"foo/bar/bar.go":                  "package bar \n const B = 1",
-					"code.org/r/p/expproj/expproj.go": "package expproj \n const C = 1",
+			name: "three_prefixes",
+			modules: []packagestest.Module{
+				{
+					Name:  "example.org/pkg",
+					Files: fm{"pkg.go": "package pkg \n const A = 1"},
+				},
+				{
+					Name:  "foo.com",
+					Files: fm{"bar/bar.go": "package bar \n const B = 1"},
+				},
+				{
+					Name:  "code.org/r/p",
+					Files: fm{"expproj/expproj.go": "package expproj \n const C = 1"},
 				},
 			},
-			localPrefix: "example.org/pkg,foo/,code.org",
+			localPrefix: "example.org/pkg,foo.com/,code.org",
 			src:         "package main \n const X = pkg.A \n const Y = bar.B \n const Z = expproj.C \n const _ = runtime.GOOS",
 			want: `package main
 
@@ -1597,7 +1672,7 @@ import (
 
 	"code.org/r/p/expproj"
 	"example.org/pkg"
-	"foo/bar"
+	"foo.com/bar"
 )
 
 const X = pkg.A
@@ -1609,10 +1684,18 @@ const _ = runtime.GOOS
 	}
 
 	for _, tt := range tests {
-		tt.config.test(t, func(t *goimportTest) {
-			defer func(s string) { LocalPrefix = s }(LocalPrefix)
-			LocalPrefix = tt.localPrefix
-			t.process("test/t.go", []byte(tt.src), nil, tt.want)
+		t.Run(tt.name, func(t *testing.T) {
+			testConfig{
+				// The module being processed has to be first so it's the primary module.
+				modules: append([]packagestest.Module{{
+					Name:  "test.com",
+					Files: fm{"t.go": tt.src},
+				}}, tt.modules...),
+			}.test(t, func(t *goimportTest) {
+				defer func(s string) { LocalPrefix = s }(LocalPrefix)
+				LocalPrefix = tt.localPrefix
+				t.process("test.com", "t.go", nil, nil, tt.want)
+			})
 		})
 	}
 }
@@ -1625,18 +1708,21 @@ const Y = foo.X
 `
 	const want = `package x
 
-import "foo"
+import "foo.com/foo"
 
 const Y = foo.X
 `
 
 	testConfig{
-		gopathFiles: map[string]string{
-			"foo/foo.go": "package foo\nconst X = 1\n",
-			"foo/doc.go": "package documentation \n // just to confuse things\n",
-			"x/x.go":     input,
+		module: packagestest.Module{
+			Name: "foo.com",
+			Files: fm{
+				"foo/foo.go": "package foo\nconst X = 1\n",
+				"foo/doc.go": "package documentation \n // just to confuse things\n",
+				"x/x.go":     input,
+			},
 		},
-	}.processTest(t, "x/x.go", nil, nil, want)
+	}.processTest(t, "foo.com", "x/x.go", nil, nil, want)
 }
 
 // Tests importPathToNameGoPathParse and in particular that it stops
@@ -1645,11 +1731,15 @@ const Y = foo.X
 // never make it that far).
 func TestImportPathToNameGoPathParse(t *testing.T) {
 	testConfig{
-		gopathFiles: map[string]string{
-			"example.net/pkg/doc.go": "package documentation\n", // ignored
-			"example.net/pkg/gen.go": "package main\n",          // also ignored
-			"example.net/pkg/pkg.go": "package the_pkg_name_to_find\n  and this syntax error is ignored because of parser.PackageClauseOnly",
-			"example.net/pkg/z.go":   "package inconsistent\n", // inconsistent but ignored
+		gopathOnly: true,
+		module: packagestest.Module{
+			Name: "example.net/pkg",
+			Files: fm{
+				"doc.go": "package documentation\n", // ignored
+				"gen.go": "package main\n",          // also ignored
+				"pkg.go": "package the_pkg_name_to_find\n  and this syntax error is ignored because of parser.PackageClauseOnly",
+				"z.go":   "package inconsistent\n", // inconsistent but ignored
+			},
 		},
 	}.test(t, func(t *goimportTest) {
 		got, err := importPathToNameGoPathParse("example.net/pkg", filepath.Join(t.gopath, "src", "other.net"))
@@ -1670,19 +1760,23 @@ const _ = pkg.X
 `
 	const want = `package x
 
-import "otherwise-longer-so-worse.example.net/foo/pkg"
+import "foo.com/otherwise-longer-so-worse-example/foo/pkg"
 
 const _ = pkg.X
 `
 
 	testConfig{
-		gopathFiles: map[string]string{
-			".goimportsignore":       "# comment line\n\n example.net", // tests comment, blank line, whitespace trimming
-			"example.net/pkg/pkg.go": "package pkg\nconst X = 1",
-			"otherwise-longer-so-worse.example.net/foo/pkg/pkg.go": "package pkg\nconst X = 1",
-			"x/x.go": input,
+		gopathOnly: true,
+		module: packagestest.Module{
+			Name: "foo.com",
+			Files: fm{
+				"../.goimportsignore":                              "# comment line\n\n foo.com/example", // tests comment, blank line, whitespace trimming
+				"example/pkg/pkg.go":                               "package pkg\nconst X = 1",
+				"otherwise-longer-so-worse-example/foo/pkg/pkg.go": "package pkg\nconst X = 1",
+				"x/x.go": input,
+			},
 		},
-	}.processTest(t, "x/x.go", nil, nil, want)
+	}.processTest(t, "foo.com", "x/x.go", nil, nil, want)
 }
 
 // Skip "node_modules" directory.
@@ -1693,43 +1787,22 @@ const _ = pkg.X
 `
 	const want = `package x
 
-import "otherwise-longer.net/not_modules/pkg"
+import "foo.com/otherwise-longer/not_modules/pkg"
 
 const _ = pkg.X
 `
 
 	testConfig{
-		gopathFiles: map[string]string{
-			"example.net/node_modules/pkg/a.go":         "package pkg\nconst X = 1",
-			"otherwise-longer.net/not_modules/pkg/a.go": "package pkg\nconst X = 1",
-			"x/x.go": input,
-		},
-	}.processTest(t, "x/x.go", nil, nil, want)
-}
-
-// golang.org/issue/16458 -- if GOROOT is a prefix of GOPATH, GOPATH is ignored.
-func TestGoRootPrefixOfGoPath(t *testing.T) {
-	const input = `package x
-
-const _ = foo.X
-`
-	const want = `package x
-
-import "example.com/foo"
-
-const _ = foo.X
-`
-
-	dir := mustTempDir(t, "importstest")
-	defer os.RemoveAll(dir)
-	testConfig{
-		goroot: filepath.Join(dir, "go"),
-		gopath: filepath.Join(dir, "gopath"),
-		gopathFiles: map[string]string{
-			"example.com/foo/pkg.go": "package foo\nconst X = 1",
-			"x/x.go":                 input,
+		gopathOnly: true,
+		module: packagestest.Module{
+			Name: "foo.com",
+			Files: fm{
+				"example/node_modules/pkg/a.go":         "package pkg\nconst X = 1",
+				"otherwise-longer/not_modules/pkg/a.go": "package pkg\nconst X = 1",
+				"x/x.go":                                input,
+			},
 		},
-	}.processTest(t, "x/x.go", nil, nil, want)
+	}.processTest(t, "foo.com", "x/x.go", nil, nil, want)
 }
 
 // Tests that package global variables with the same name and function name as
@@ -1755,11 +1828,14 @@ var time Time
 `
 
 	testConfig{
-		gopathFiles: map[string]string{
-			"pkg/uses.go":   usesGlobal,
-			"pkg/global.go": declaresGlobal,
+		module: packagestest.Module{
+			Name: "foo.com",
+			Files: fm{
+				"pkg/uses.go":   usesGlobal,
+				"pkg/global.go": declaresGlobal,
+			},
 		},
-	}.processTest(t, "pkg/uses.go", nil, nil, usesGlobal)
+	}.processTest(t, "foo.com", "pkg/uses.go", nil, nil, usesGlobal)
 }
 
 // Tests that sibling files - other files in the same package - can provide an
@@ -1804,11 +1880,14 @@ func LogSomethingElse() {
 `
 
 	testConfig{
-		gopathFiles: map[string]string{
-			"p/needs_import.go":    need,
-			"p/provides_import.go": provide,
+		module: packagestest.Module{
+			Name: "foo.com",
+			Files: fm{
+				"p/needs_import.go":    need,
+				"p/provides_import.go": provide,
+			},
 		},
-	}.processTest(t, "p/needs_import.go", nil, nil, want)
+	}.processTest(t, "foo.com", "p/needs_import.go", nil, nil, want)
 }
 
 func TestPkgIsCandidate(t *testing.T) {
@@ -1978,13 +2057,24 @@ var c = &config.SystemConfig{}
 `
 
 	testConfig{
-		gopathFiles: map[string]string{
-			"config.net/config/config.go":         "package config\n type SystemConfig struct {}", // Will match but should not be first choice
-			"mycompany.net/config/config.go":      "package config\n type SystemConfig struct {}", // Will match but should not be first choice
-			"mycompany.net/tool/config/config.go": "package config\n type SystemConfig struct {}", // Local package should be promoted over shorter package
-			"mycompany.net/tool/main.go":          input,
+		modules: []packagestest.Module{
+			{
+				Name:  "config.net/config",
+				Files: fm{"config.go": "package config\n type SystemConfig struct {}"}, // Will match but should not be first choice
+			},
+			{
+				Name:  "mycompany.net/config",
+				Files: fm{"config.go": "package config\n type SystemConfig struct {}"}, // Will match but should not be first choice
+			},
+			{
+				Name: "mycompany.net/tool",
+				Files: fm{
+					"config/config.go": "package config\n type SystemConfig struct {}", // Local package should be promoted over shorter package
+					"main.go":          input,
+				},
+			},
 		},
-	}.processTest(t, "mycompany.net/tool/main.go", nil, nil, want)
+	}.processTest(t, "mycompany.net/tool", "main.go", nil, nil, want)
 }
 
 // Tests FindImportInLocalGoFiles looks at the import lines for other Go files in the
@@ -2003,13 +2093,38 @@ import "bytes.net/bytes"
 var _ = &bytes.Buffer{}
 `
 	testConfig{
-		gopathFiles: map[string]string{
-			"bytes.net/bytes/bytes.go":   "package bytes\n type Buffer struct {}",                               // Should be selected over standard library
-			"mycompany.net/tool/io.go":   "package main\n import \"bytes.net/bytes\"\n var _ = &bytes.Buffer{}", // Contains package import that will cause stdlib to be ignored
-			"mycompany.net/tool/err.go":  "package main\n import \"bogus.net/bytes\"\n var _ = &bytes.Buffer{}", // Contains import which is not resolved, so it is ignored
-			"mycompany.net/tool/main.go": input,
+		modules: []packagestest.Module{
+			{
+				Name: "mycompany.net/tool",
+				Files: fm{
+					"io.go":   "package main\n import \"bytes.net/bytes\"\n var _ = &bytes.Buffer{}", // Contains package import that will cause stdlib to be ignored
+					"main.go": input,
+				},
+			},
+			{
+				Name:  "bytes.net/bytes",
+				Files: fm{"bytes.go": "package bytes\n type Buffer struct {}"}, // Should be selected over standard library
+			},
+		},
+	}.processTest(t, "mycompany.net/tool", "main.go", nil, nil, want)
+}
+
+func TestInMemoryFile(t *testing.T) {
+	const input = `package main
+ var _ = &bytes.Buffer{}`
+
+	const want = `package main
+
+import "bytes"
+
+var _ = &bytes.Buffer{}
+`
+	testConfig{
+		module: packagestest.Module{
+			Name:  "foo.com",
+			Files: fm{"x.go": "package x\n"},
 		},
-	}.processTest(t, "mycompany.net/tool/main.go", nil, nil, want)
+	}.processTest(t, "foo.com", "x.go", []byte(input), nil, want)
 }
 
 func TestImportNoGoFiles(t *testing.T) {
@@ -2023,7 +2138,13 @@ import "bytes"
 var _ = &bytes.Buffer{}
 `
 
-	testConfig{}.processTest(t, "mycompany.net/tool/main.go", []byte(input), nil, want)
+	buf, err := Process("mycompany.net/tool/main.go", []byte(input), nil)
+	if err != nil {
+		t.Fatalf("Process() = %v", err)
+	}
+	if string(buf) != want {
+		t.Errorf("Got:\n%s\nWant:\n%s", buf, want)
+	}
 }
 
 // Ensures a token as large as 500000 bytes can be handled
@@ -2034,12 +2155,11 @@ func TestProcessLargeToken(t *testing.T) {
 	input := `package testimports
 
 import (
-	"fmt"
-	"mydomain.mystuff/mypkg"
+	"bytes"
 )
 
 const s = fmt.Sprintf("%s", "` + largeString + `")
-const x = mypkg.Sprintf("%s", "my package")
+var _ = bytes.Buffer{}
 
 // end
 `
@@ -2047,18 +2167,21 @@ const x = mypkg.Sprintf("%s", "my package")
 	want := `package testimports
 
 import (
+	"bytes"
 	"fmt"
-
-	"mydomain.mystuff/mypkg"
 )
 
 const s = fmt.Sprintf("%s", "` + largeString + `")
-const x = mypkg.Sprintf("%s", "my package")
+
+var _ = bytes.Buffer{}
 
 // end
 `
 
 	testConfig{
-		gopathFiles: map[string]string{"foo.go": input},
-	}.processTest(t, "foo.go", nil, nil, want)
+		module: packagestest.Module{
+			Name:  "foo.com",
+			Files: fm{"foo.go": input},
+		},
+	}.processTest(t, "foo.com", "foo.go", nil, nil, want)
 }
diff --git a/vendor/golang.org/x/tools/internal/fastwalk/fastwalk_dirent_namlen_linux.go b/vendor/golang.org/x/tools/internal/fastwalk/fastwalk_dirent_namlen_linux.go
index 61896ffe..e880d358 100644
--- a/vendor/golang.org/x/tools/internal/fastwalk/fastwalk_dirent_namlen_linux.go
+++ b/vendor/golang.org/x/tools/internal/fastwalk/fastwalk_dirent_namlen_linux.go
@@ -16,7 +16,12 @@ import (
 func direntNamlen(dirent *syscall.Dirent) uint64 {
 	const fixedHdr = uint16(unsafe.Offsetof(syscall.Dirent{}.Name))
 	nameBuf := (*[unsafe.Sizeof(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]))
-	nameLen := bytes.IndexByte(nameBuf[:dirent.Reclen-fixedHdr], 0)
+	const nameBufLen = uint16(len(nameBuf))
+	limit := dirent.Reclen - fixedHdr
+	if limit > nameBufLen {
+		limit = nameBufLen
+	}
+	nameLen := bytes.IndexByte(nameBuf[:limit], 0)
 	if nameLen < 0 {
 		panic("failed to find terminating 0 byte in dirent")
 	}
diff --git a/vendor/golang.org/x/tools/internal/fastwalk/fastwalk_test.go b/vendor/golang.org/x/tools/internal/fastwalk/fastwalk_test.go
index efb813c6..a122ddf6 100644
--- a/vendor/golang.org/x/tools/internal/fastwalk/fastwalk_test.go
+++ b/vendor/golang.org/x/tools/internal/fastwalk/fastwalk_test.go
@@ -98,6 +98,23 @@ func TestFastWalk_Basic(t *testing.T) {
 		})
 }
 
+func TestFastWalk_LongFileName(t *testing.T) {
+	longFileName := strings.Repeat("x", 255)
+
+	testFastWalk(t, map[string]string{
+		longFileName: "one",
+	},
+		func(path string, typ os.FileMode) error {
+			return nil
+		},
+		map[string]os.FileMode{
+			"":                     os.ModeDir,
+			"/src":                 os.ModeDir,
+			"/src/" + longFileName: 0,
+		},
+	)
+}
+
 func TestFastWalk_Symlink(t *testing.T) {
 	switch runtime.GOOS {
 	case "windows", "plan9":
diff --git a/vendor/golang.org/x/tools/internal/gopathwalk/walk.go b/vendor/golang.org/x/tools/internal/gopathwalk/walk.go
index dc085fc1..a561f9f4 100644
--- a/vendor/golang.org/x/tools/internal/gopathwalk/walk.go
+++ b/vendor/golang.org/x/tools/internal/gopathwalk/walk.go
@@ -11,12 +11,13 @@ import (
 	"bytes"
 	"fmt"
 	"go/build"
-	"golang.org/x/tools/internal/fastwalk"
 	"io/ioutil"
 	"log"
 	"os"
 	"path/filepath"
 	"strings"
+
+	"golang.org/x/tools/internal/fastwalk"
 )
 
 // Options controls the behavior of a Walk call.
@@ -176,7 +177,9 @@ func (w *walker) walk(path string, typ os.FileMode) error {
 	if typ == os.ModeDir {
 		base := filepath.Base(path)
 		if base == "" || base[0] == '.' || base[0] == '_' ||
-			base == "testdata" || (!w.opts.ModulesEnabled && base == "node_modules") {
+			base == "testdata" ||
+			(w.root.Type == RootGOROOT && w.opts.ModulesEnabled && base == "vendor") ||
+			(!w.opts.ModulesEnabled && base == "node_modules") {
 			return filepath.SkipDir
 		}
 		fi, err := os.Lstat(path)
diff --git a/vendor/golang.org/x/tools/internal/jsonrpc2/jsonrpc2.go b/vendor/golang.org/x/tools/internal/jsonrpc2/jsonrpc2.go
index f981e868..e465d3ab 100644
--- a/vendor/golang.org/x/tools/internal/jsonrpc2/jsonrpc2.go
+++ b/vendor/golang.org/x/tools/internal/jsonrpc2/jsonrpc2.go
@@ -13,6 +13,7 @@ import (
 	"fmt"
 	"sync"
 	"sync/atomic"
+	"time"
 )
 
 // Conn is a JSON RPC 2 client server connection.
@@ -28,15 +29,15 @@ type Conn struct {
 	pendingMu  sync.Mutex // protects the pending map
 	pending    map[ID]chan *Response
 	handlingMu sync.Mutex // protects the handling map
-	handling   map[ID]context.CancelFunc
+	handling   map[ID]handling
 }
 
 // Handler is an option you can pass to NewConn to handle incoming requests.
-// If the request returns true from IsNotify then the Handler should not return a
-// result or error, otherwise it should handle the Request and return either
-// an encoded result, or an error.
-// Handlers must be concurrency-safe.
-type Handler = func(context.Context, *Conn, *Request) (interface{}, *Error)
+// If the request returns false from IsNotify then the Handler must eventually
+// call Reply on the Conn with the supplied request.
+// Handlers are called synchronously, they should pass the work off to a go
+// routine if they are going to take a long time.
+type Handler func(context.Context, *Conn, *Request)
 
 // Canceler is an option you can pass to NewConn which is invoked for
 // cancelled outgoing requests.
@@ -45,11 +46,7 @@ type Handler = func(context.Context, *Conn, *Request) (interface{}, *Error)
 // It is okay to use the connection to send notifications, but the context will
 // be in the cancelled state, so you must do it with the background context
 // instead.
-type Canceler = func(context.Context, *Conn, *Request)
-
-// Logger is an option you can pass to NewConn which is invoked for
-// all messages flowing through a Conn.
-type Logger = func(mode string, id *ID, method string, payload *json.RawMessage, err *Error)
+type Canceler func(context.Context, *Conn, *Request)
 
 // NewErrorf builds a Error struct for the suppied message and code.
 // If args is not empty, message and args will be passed to Sprintf.
@@ -67,7 +64,7 @@ func NewConn(ctx context.Context, s Stream, options ...interface{}) *Conn {
 		stream:   s,
 		done:     make(chan struct{}),
 		pending:  make(map[ID]chan *Response),
-		handling: make(map[ID]context.CancelFunc),
+		handling: make(map[ID]handling),
 	}
 	for _, opt := range options {
 		switch opt := opt.(type) {
@@ -92,8 +89,10 @@ func NewConn(ctx context.Context, s Stream, options ...interface{}) *Conn {
 	}
 	if conn.handle == nil {
 		// the default handler reports a method error
-		conn.handle = func(ctx context.Context, c *Conn, r *Request) (interface{}, *Error) {
-			return nil, NewErrorf(CodeMethodNotFound, "method %q not found", r.Method)
+		conn.handle = func(ctx context.Context, c *Conn, r *Request) {
+			if r.IsNotify() {
+				c.Reply(ctx, r, nil, NewErrorf(CodeMethodNotFound, "method %q not found", r.Method))
+			}
 		}
 	}
 	if conn.cancel == nil {
@@ -102,7 +101,7 @@ func NewConn(ctx context.Context, s Stream, options ...interface{}) *Conn {
 	}
 	if conn.log == nil {
 		// the default logger does nothing
-		conn.log = func(string, *ID, string, *json.RawMessage, *Error) {}
+		conn.log = func(Direction, *ID, time.Duration, string, *json.RawMessage, *Error) {}
 	}
 	go func() {
 		conn.err = conn.run(ctx)
@@ -129,10 +128,10 @@ func (c *Conn) Wait(ctx context.Context) error {
 // to propagate the cancel.
 func (c *Conn) Cancel(id ID) {
 	c.handlingMu.Lock()
-	cancel := c.handling[id]
+	handling, found := c.handling[id]
 	c.handlingMu.Unlock()
-	if cancel != nil {
-		cancel()
+	if found {
+		handling.cancel()
 	}
 }
 
@@ -152,7 +151,7 @@ func (c *Conn) Notify(ctx context.Context, method string, params interface{}) er
 	if err != nil {
 		return fmt.Errorf("marshalling notify request: %v", err)
 	}
-	c.log("notify <=", nil, request.Method, request.Params, nil)
+	c.log(Send, nil, -1, request.Method, request.Params, nil)
 	return c.stream.Write(ctx, data)
 }
 
@@ -189,7 +188,8 @@ func (c *Conn) Call(ctx context.Context, method string, params, result interface
 		c.pendingMu.Unlock()
 	}()
 	// now we are ready to send
-	c.log("call <=", request.ID, request.Method, request.Params, nil)
+	before := time.Now()
+	c.log(Send, request.ID, -1, request.Method, request.Params, nil)
 	if err := c.stream.Write(ctx, data); err != nil {
 		// sending failed, we will never get a response, so don't leave it pending
 		return err
@@ -197,6 +197,8 @@ func (c *Conn) Call(ctx context.Context, method string, params, result interface
 	// now wait for the response
 	select {
 	case response := <-rchan:
+		elapsed := time.Since(before)
+		c.log(Send, response.ID, elapsed, request.Method, response.Result, response.Error)
 		// is it an error response?
 		if response.Error != nil {
 			return response.Error
@@ -215,6 +217,59 @@ func (c *Conn) Call(ctx context.Context, method string, params, result interface
 	}
 }
 
+// Reply sends a reply to the given request.
+// It is an error to call this if request was not a call.
+// You must call this exactly once for any given request.
+// If err is set then result will be ignored.
+func (c *Conn) Reply(ctx context.Context, req *Request, result interface{}, err error) error {
+	if req.IsNotify() {
+		return fmt.Errorf("reply not invoked with a valid call")
+	}
+	c.handlingMu.Lock()
+	handling, found := c.handling[*req.ID]
+	if found {
+		delete(c.handling, *req.ID)
+	}
+	c.handlingMu.Unlock()
+	if !found {
+		return fmt.Errorf("not a call in progress: %v", req.ID)
+	}
+
+	elapsed := time.Since(handling.start)
+	var raw *json.RawMessage
+	if err == nil {
+		raw, err = marshalToRaw(result)
+	}
+	response := &Response{
+		Result: raw,
+		ID:     req.ID,
+	}
+	if err != nil {
+		if callErr, ok := err.(*Error); ok {
+			response.Error = callErr
+		} else {
+			response.Error = NewErrorf(0, "%s", err)
+		}
+	}
+	data, err := json.Marshal(response)
+	if err != nil {
+		return err
+	}
+	c.log(Send, response.ID, elapsed, req.Method, response.Result, response.Error)
+	if err = c.stream.Write(ctx, data); err != nil {
+		// TODO(iancottrell): if a stream write fails, we really need to shut down
+		// the whole stream
+		return err
+	}
+	return nil
+}
+
+type handling struct {
+	request *Request
+	cancel  context.CancelFunc
+	start   time.Time
+}
+
 // combined has all the fields of both Request and Response.
 // We can decode this and then work out which it is.
 type combined struct {
@@ -230,7 +285,6 @@ type combined struct {
 // It must be called exactly once for each Conn.
 // It returns only when the reader is closed or there is an error in the stream.
 func (c *Conn) run(ctx context.Context) error {
-	ctx, cancelRun := context.WithCancel(ctx)
 	for {
 		// get the data for a message
 		data, err := c.stream.Read(ctx)
@@ -243,7 +297,7 @@ func (c *Conn) run(ctx context.Context) error {
 		if err := json.Unmarshal(data, msg); err != nil {
 			// a badly formed message arrived, log it and continue
 			// we trust the stream to have isolated the error to just this message
-			c.log("read", nil, "", nil, NewErrorf(0, "unmarshal failed: %v", err))
+			c.log(Receive, nil, -1, "", nil, NewErrorf(0, "unmarshal failed: %v", err))
 			continue
 		}
 		// work out which kind of message we have
@@ -256,57 +310,21 @@ func (c *Conn) run(ctx context.Context) error {
 				ID:     msg.ID,
 			}
 			if request.IsNotify() {
-				c.log("notify =>", request.ID, request.Method, request.Params, nil)
+				c.log(Receive, request.ID, -1, request.Method, request.Params, nil)
 				// we have a Notify, forward to the handler in a go routine
-				go func() {
-					if _, err := c.handle(ctx, c, request); err != nil {
-						// notify produced an error, we can't forward it to the other side
-						// because there is no id, so we just log it
-						c.log("notify failed", nil, request.Method, nil, err)
-					}
-				}()
+				c.handle(ctx, c, request)
 			} else {
 				// we have a Call, forward to the handler in another go routine
 				reqCtx, cancelReq := context.WithCancel(ctx)
 				c.handlingMu.Lock()
-				c.handling[*request.ID] = cancelReq
+				c.handling[*request.ID] = handling{
+					request: request,
+					cancel:  cancelReq,
+					start:   time.Now(),
+				}
 				c.handlingMu.Unlock()
-				go func() {
-					defer func() {
-						// clean up the cancel handler on the way out
-						c.handlingMu.Lock()
-						delete(c.handling, *request.ID)
-						c.handlingMu.Unlock()
-						cancelReq()
-					}()
-					c.log("call =>", request.ID, request.Method, request.Params, nil)
-					resp, callErr := c.handle(reqCtx, c, request)
-					var result *json.RawMessage
-					if result, err = marshalToRaw(resp); err != nil {
-						callErr = &Error{Message: err.Error()}
-					}
-					response := &Response{
-						Result: result,
-						Error:  callErr,
-						ID:     request.ID,
-					}
-					data, err := json.Marshal(response)
-					if err != nil {
-						// failure to marshal leaves the call without a response
-						// possibly we could attempt to respond with a different message
-						// but we can probably rely on timeouts instead
-						c.log("respond =!>", request.ID, request.Method, nil, NewErrorf(0, "%s", err))
-						return
-					}
-					c.log("respond =>", response.ID, "", response.Result, response.Error)
-					if err = c.stream.Write(ctx, data); err != nil {
-						// if a stream write fails, we really need to shut down the whole
-						// stream and return from the run
-						c.log("respond =!>", nil, request.Method, nil, NewErrorf(0, "%s", err))
-						cancelRun()
-						return
-					}
-				}()
+				c.log(Receive, request.ID, -1, request.Method, request.Params, nil)
+				c.handle(reqCtx, c, request)
 			}
 		case msg.ID != nil:
 			// we have a response, get the pending entry from the map
@@ -322,11 +340,10 @@ func (c *Conn) run(ctx context.Context) error {
 				Error:  msg.Error,
 				ID:     msg.ID,
 			}
-			c.log("response =>", response.ID, "", response.Result, response.Error)
 			rchan <- response
 			close(rchan)
 		default:
-			c.log("invalid =>", nil, "", nil, NewErrorf(0, "message not a call, notify or response, ignoring"))
+			c.log(Receive, nil, -1, "", nil, NewErrorf(0, "message not a call, notify or response, ignoring"))
 		}
 	}
 }
diff --git a/vendor/golang.org/x/tools/internal/jsonrpc2/jsonrpc2_test.go b/vendor/golang.org/x/tools/internal/jsonrpc2/jsonrpc2_test.go
index 2556083e..264200b0 100644
--- a/vendor/golang.org/x/tools/internal/jsonrpc2/jsonrpc2_test.go
+++ b/vendor/golang.org/x/tools/internal/jsonrpc2/jsonrpc2_test.go
@@ -102,7 +102,7 @@ func prepare(ctx context.Context, t *testing.T, withHeaders bool) (*testHandler,
 		} else {
 			h.stream = jsonrpc2.NewStream(h.reader, h.writer)
 		}
-		args := []interface{}{handle}
+		args := []interface{}{jsonrpc2.Handler(handle)}
 		if *logRPC {
 			args = append(args, jsonrpc2.Log)
 		}
@@ -128,32 +128,36 @@ type testHandler struct {
 	*jsonrpc2.Conn
 }
 
-func handle(ctx context.Context, c *jsonrpc2.Conn, r *jsonrpc2.Request) (interface{}, *jsonrpc2.Error) {
+func handle(ctx context.Context, c *jsonrpc2.Conn, r *jsonrpc2.Request) {
 	switch r.Method {
 	case "no_args":
 		if r.Params != nil {
-			return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeInvalidParams, "Expected no params")
+			c.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeInvalidParams, "Expected no params"))
+			return
 		}
-		return true, nil
+		c.Reply(ctx, r, true, nil)
 	case "one_string":
 		var v string
 		if err := json.Unmarshal(*r.Params, &v); err != nil {
-			return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err.Error())
+			c.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err.Error()))
+			return
 		}
-		return "got:" + v, nil
+		c.Reply(ctx, r, "got:"+v, nil)
 	case "one_number":
 		var v int
 		if err := json.Unmarshal(*r.Params, &v); err != nil {
-			return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err.Error())
+			c.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err.Error()))
+			return
 		}
-		return fmt.Sprintf("got:%d", v), nil
+		c.Reply(ctx, r, fmt.Sprintf("got:%d", v), nil)
 	case "join":
 		var v []string
 		if err := json.Unmarshal(*r.Params, &v); err != nil {
-			return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err.Error())
+			c.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err.Error()))
+			return
 		}
-		return path.Join(v...), nil
+		c.Reply(ctx, r, path.Join(v...), nil)
 	default:
-		return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeMethodNotFound, "method %q not found", r.Method)
+		c.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeMethodNotFound, "method %q not found", r.Method))
 	}
 }
diff --git a/vendor/golang.org/x/tools/internal/jsonrpc2/log.go b/vendor/golang.org/x/tools/internal/jsonrpc2/log.go
index 3dbde8f7..f0e8c7f2 100644
--- a/vendor/golang.org/x/tools/internal/jsonrpc2/log.go
+++ b/vendor/golang.org/x/tools/internal/jsonrpc2/log.go
@@ -5,30 +5,55 @@
 package jsonrpc2
 
 import (
-	"bytes"
 	"encoding/json"
-	"fmt"
 	"log"
+	"time"
 )
 
+// Logger is an option you can pass to NewConn which is invoked for
+// all messages flowing through a Conn.
+// direction indicates if the message being recieved or sent
+// id is the message id, if not set it was a notification
+// elapsed is the time between a call being seen and the response, and is
+// negative for anything that is not a response.
+// method is the method name specified in the message
+// payload is the parameters for a call or notification, and the result for a
+// response
+type Logger = func(direction Direction, id *ID, elapsed time.Duration, method string, payload *json.RawMessage, err *Error)
+
+// Direction is used to indicate to a logger whether the logged message was being
+// sent or received.
+type Direction bool
+
+const (
+	// Send indicates the message is outgoing.
+	Send = Direction(true)
+	// Receive indicates the message is incoming.
+	Receive = Direction(false)
+)
+
+func (d Direction) String() string {
+	switch d {
+	case Send:
+		return "send"
+	case Receive:
+		return "receive"
+	default:
+		panic("unreachable")
+	}
+}
+
 // Log is an implementation of Logger that outputs using log.Print
 // It is not used by default, but is provided for easy logging in users code.
-func Log(mode string, id *ID, method string, payload *json.RawMessage, err *Error) {
-	buf := &bytes.Buffer{}
-	fmt.Fprint(buf, mode)
-	if id == nil {
-		fmt.Fprintf(buf, " []")
-	} else {
-		fmt.Fprintf(buf, " [%v]", id)
-	}
-	if method != "" {
-		fmt.Fprintf(buf, " %s", method)
-	}
-	if payload != nil {
-		fmt.Fprintf(buf, " %s", *payload)
-	}
-	if err != nil {
-		fmt.Fprintf(buf, " failed: %s", err)
+func Log(direction Direction, id *ID, elapsed time.Duration, method string, payload *json.RawMessage, err *Error) {
+	switch {
+	case err != nil:
+		log.Printf("%v failure [%v] %s %v", direction, id, method, err)
+	case id == nil:
+		log.Printf("%v notification %s %s", direction, method, *payload)
+	case elapsed >= 0:
+		log.Printf("%v response in %v [%v] %s %s", direction, elapsed, id, method, *payload)
+	default:
+		log.Printf("%v call [%v] %s %s", direction, id, method, *payload)
 	}
-	log.Print(buf)
 }
diff --git a/vendor/golang.org/x/tools/internal/jsonrpc2/wire.go b/vendor/golang.org/x/tools/internal/jsonrpc2/wire.go
index 3ff0c384..bb59ad55 100644
--- a/vendor/golang.org/x/tools/internal/jsonrpc2/wire.go
+++ b/vendor/golang.org/x/tools/internal/jsonrpc2/wire.go
@@ -114,6 +114,9 @@ func (VersionTag) UnmarshalJSON(data []byte) error {
 // The representation is non ambiguous, string forms are quoted, number forms
 // are preceded by a #
 func (id *ID) String() string {
+	if id == nil {
+		return ""
+	}
 	if id.Name != "" {
 		return strconv.Quote(id.Name)
 	}
diff --git a/vendor/golang.org/x/tools/internal/lsp/completion.go b/vendor/golang.org/x/tools/internal/lsp/completion.go
new file mode 100644
index 00000000..583822d8
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/completion.go
@@ -0,0 +1,53 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package lsp
+
+import (
+	"sort"
+
+	"golang.org/x/tools/internal/lsp/protocol"
+	"golang.org/x/tools/internal/lsp/source"
+)
+
+func toProtocolCompletionItems(items []source.CompletionItem) []protocol.CompletionItem {
+	var results []protocol.CompletionItem
+	sort.Slice(items, func(i, j int) bool {
+		return items[i].Score > items[j].Score
+	})
+	for _, item := range items {
+		results = append(results, protocol.CompletionItem{
+			Label:  item.Label,
+			Detail: item.Detail,
+			Kind:   float64(toProtocolCompletionItemKind(item.Kind)),
+		})
+	}
+	return results
+}
+
+func toProtocolCompletionItemKind(kind source.CompletionItemKind) protocol.CompletionItemKind {
+	switch kind {
+	case source.InterfaceCompletionItem:
+		return protocol.InterfaceCompletion
+	case source.StructCompletionItem:
+		return protocol.StructCompletion
+	case source.TypeCompletionItem:
+		return protocol.TypeParameterCompletion // ??
+	case source.ConstantCompletionItem:
+		return protocol.ConstantCompletion
+	case source.FieldCompletionItem:
+		return protocol.FieldCompletion
+	case source.ParameterCompletionItem, source.VariableCompletionItem:
+		return protocol.VariableCompletion
+	case source.FunctionCompletionItem:
+		return protocol.FunctionCompletion
+	case source.MethodCompletionItem:
+		return protocol.MethodCompletion
+	case source.PackageCompletionItem:
+		return protocol.ModuleCompletion // ??
+	default:
+		return protocol.TextCompletion
+	}
+
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/diagnostics.go b/vendor/golang.org/x/tools/internal/lsp/diagnostics.go
index 1a38d734..39694eae 100644
--- a/vendor/golang.org/x/tools/internal/lsp/diagnostics.go
+++ b/vendor/golang.org/x/tools/internal/lsp/diagnostics.go
@@ -1,85 +1,38 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
 package lsp
 
 import (
-	"go/token"
-	"strconv"
-	"strings"
-
-	"golang.org/x/tools/go/packages"
 	"golang.org/x/tools/internal/lsp/protocol"
+	"golang.org/x/tools/internal/lsp/source"
 )
 
-func (v *view) diagnostics(uri protocol.DocumentURI) (map[string][]protocol.Diagnostic, error) {
-	pkg, err := v.typeCheck(uri)
-	if err != nil {
-		return nil, err
-	}
-	reports := make(map[string][]protocol.Diagnostic)
-	for _, filename := range pkg.GoFiles {
-		reports[filename] = []protocol.Diagnostic{}
-	}
-	var parseErrors, typeErrors []packages.Error
-	for _, err := range pkg.Errors {
-		switch err.Kind {
-		case packages.ParseError:
-			parseErrors = append(parseErrors, err)
-		case packages.TypeError:
-			typeErrors = append(typeErrors, err)
-		default:
-			// ignore other types of errors
-			continue
-		}
-	}
-	// Don't report type errors if there are parse errors.
-	errors := typeErrors
-	if len(parseErrors) > 0 {
-		errors = parseErrors
-	}
-	for _, err := range errors {
-		pos := parseErrorPos(err)
-		line := float64(pos.Line) - 1
-		col := float64(pos.Column) - 1
-		diagnostic := protocol.Diagnostic{
-			// TODO(rstambler): Add support for diagnostic ranges.
-			Range: protocol.Range{
-				Start: protocol.Position{
-					Line:      line,
-					Character: col,
-				},
-				End: protocol.Position{
-					Line:      line,
-					Character: col,
-				},
-			},
-			Severity: protocol.SeverityError,
-			Source:   "LSP: Go compiler",
-			Message:  err.Msg,
-		}
-		if _, ok := reports[pos.Filename]; ok {
-			reports[pos.Filename] = append(reports[pos.Filename], diagnostic)
-		}
-	}
-	return reports, nil
+func toProtocolDiagnostics(v *source.View, diagnostics []source.Diagnostic) []protocol.Diagnostic {
+	reports := []protocol.Diagnostic{}
+	for _, diag := range diagnostics {
+		tok := v.Config.Fset.File(diag.Range.Start)
+		reports = append(reports, protocol.Diagnostic{
+			Message:  diag.Message,
+			Range:    toProtocolRange(tok, diag.Range),
+			Severity: toProtocolSeverity(diag.Severity),
+			Source:   "LSP",
+		})
+	}
+	return reports
 }
 
-func parseErrorPos(pkgErr packages.Error) (pos token.Position) {
-	split := strings.Split(pkgErr.Pos, ":")
-	if len(split) <= 1 {
-		return pos
-	}
-	pos.Filename = split[0]
-	line, err := strconv.ParseInt(split[1], 10, 64)
-	if err != nil {
-		return pos
-	}
-	pos.Line = int(line)
-	if len(split) == 3 {
-		col, err := strconv.ParseInt(split[2], 10, 64)
-		if err != nil {
-			return pos
-		}
-		pos.Column = int(col)
-	}
-	return pos
-
+func toProtocolSeverity(severity source.DiagnosticSeverity) protocol.DiagnosticSeverity {
+	switch severity {
+	case source.SeverityError:
+		return protocol.SeverityError
+	case source.SeverityWarning:
+		return protocol.SeverityWarning
+	case source.SeverityHint:
+		return protocol.SeverityHint
+	case source.SeverityInformation:
+		return protocol.SeverityInformation
+	}
+	return protocol.SeverityError // default
 }
diff --git a/vendor/golang.org/x/tools/internal/lsp/format.go b/vendor/golang.org/x/tools/internal/lsp/format.go
deleted file mode 100644
index a19def2a..00000000
--- a/vendor/golang.org/x/tools/internal/lsp/format.go
+++ /dev/null
@@ -1,83 +0,0 @@
-package lsp
-
-import (
-	"bytes"
-	"fmt"
-	"go/format"
-
-	"golang.org/x/tools/internal/lsp/protocol"
-)
-
-// format formats a document with a given range.
-func (s *server) format(uri protocol.DocumentURI, rng *protocol.Range) ([]protocol.TextEdit, error) {
-	data, err := s.readActiveFile(uri)
-	if err != nil {
-		return nil, err
-	}
-	if rng != nil {
-		start, err := positionToOffset(data, int(rng.Start.Line), int(rng.Start.Character))
-		if err != nil {
-			return nil, err
-		}
-		end, err := positionToOffset(data, int(rng.End.Line), int(rng.End.Character))
-		if err != nil {
-			return nil, err
-		}
-		data = data[start:end]
-		// format.Source will fail if the substring is not a balanced expression tree.
-		// TODO(rstambler): parse the file and use astutil.PathEnclosingInterval to
-		// find the largest ast.Node n contained within start:end, and format the
-		// region n.Pos-n.End instead.
-	}
-	// format.Source changes slightly from one release to another, so the version
-	// of Go used to build the LSP server will determine how it formats code.
-	// This should be acceptable for all users, who likely be prompted to rebuild
-	// the LSP server on each Go release.
-	fmted, err := format.Source([]byte(data))
-	if err != nil {
-		return nil, err
-	}
-	if rng == nil {
-		// Get the ending line and column numbers for the original file.
-		line := bytes.Count(data, []byte("\n"))
-		col := len(data) - bytes.LastIndex(data, []byte("\n")) - 1
-		if col < 0 {
-			col = 0
-		}
-		rng = &protocol.Range{
-			Start: protocol.Position{
-				Line:      0,
-				Character: 0,
-			},
-			End: protocol.Position{
-				Line:      float64(line),
-				Character: float64(col),
-			},
-		}
-	}
-	// TODO(rstambler): Compute text edits instead of replacing whole file.
-	return []protocol.TextEdit{
-		{
-			Range:   *rng,
-			NewText: string(fmted),
-		},
-	}, nil
-}
-
-// positionToOffset converts a 0-based line and column number in a file
-// to a byte offset value.
-func positionToOffset(contents []byte, line, col int) (int, error) {
-	start := 0
-	for i := 0; i < int(line); i++ {
-		if start >= len(contents) {
-			return 0, fmt.Errorf("file contains %v lines, not %v lines", i, line)
-		}
-		index := bytes.IndexByte(contents[start:], '\n')
-		if index == -1 {
-			return 0, fmt.Errorf("file contains %v lines, not %v lines", i, line)
-		}
-		start += index + 1
-	}
-	offset := start + int(col)
-	return offset, nil
-}
diff --git a/vendor/golang.org/x/tools/internal/lsp/lsp_test.go b/vendor/golang.org/x/tools/internal/lsp/lsp_test.go
new file mode 100644
index 00000000..418da422
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/lsp_test.go
@@ -0,0 +1,244 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package lsp
+
+import (
+	"bytes"
+	"context"
+	"go/token"
+	"os/exec"
+	"path/filepath"
+	"reflect"
+	"sort"
+	"strings"
+	"testing"
+
+	"golang.org/x/tools/go/packages"
+	"golang.org/x/tools/go/packages/packagestest"
+	"golang.org/x/tools/internal/lsp/protocol"
+	"golang.org/x/tools/internal/lsp/source"
+)
+
+func TestLSP(t *testing.T) {
+	packagestest.TestAll(t, testLSP)
+}
+
+func testLSP(t *testing.T, exporter packagestest.Exporter) {
+	const dir = "testdata"
+
+	files := packagestest.MustCopyFileTree(dir)
+	for fragment, operation := range files {
+		if trimmed := strings.TrimSuffix(fragment, ".in"); trimmed != fragment {
+			delete(files, fragment)
+			files[trimmed] = operation
+		}
+	}
+	modules := []packagestest.Module{
+		{
+			Name:  "golang.org/x/tools/internal/lsp",
+			Files: files,
+		},
+	}
+	exported := packagestest.Export(t, exporter, modules)
+	defer exported.Cleanup()
+
+	dirs := make(map[string]bool)
+
+	// collect results for certain tests
+	expectedDiagnostics := make(map[string][]protocol.Diagnostic)
+	expectedCompletions := make(map[token.Position]*protocol.CompletionItem)
+	expectedFormat := make(map[string]string)
+
+	s := &server{
+		view: source.NewView(),
+	}
+	// merge the config objects
+	cfg := *exported.Config
+	cfg.Fset = s.view.Config.Fset
+	cfg.Mode = packages.LoadSyntax
+	s.view.Config = &cfg
+
+	for _, module := range modules {
+		for fragment := range module.Files {
+			if !strings.HasSuffix(fragment, ".go") {
+				continue
+			}
+			filename := exporter.Filename(exported, module.Name, fragment)
+			expectedDiagnostics[filename] = []protocol.Diagnostic{}
+			dirs[filepath.Dir(filename)] = true
+		}
+	}
+	// Do a first pass to collect special markers
+	if err := exported.Expect(map[string]interface{}{
+		"item": func(name string, r packagestest.Range, _, _ string) {
+			exported.Mark(name, r)
+		},
+	}); err != nil {
+		t.Fatal(err)
+	}
+	// Collect any data that needs to be used by subsequent tests.
+	if err := exported.Expect(map[string]interface{}{
+		"diag": func(pos token.Position, msg string) {
+			collectDiagnostics(t, expectedDiagnostics, pos, msg)
+		},
+		"item": func(pos token.Position, label, detail, kind string) {
+			collectCompletionItems(expectedCompletions, pos, label, detail, kind)
+		},
+		"format": func(pos token.Position) {
+			collectFormat(expectedFormat, pos)
+		},
+	}); err != nil {
+		t.Fatal(err)
+	}
+
+	// test completion
+	testCompletion(t, exported, s, expectedCompletions)
+
+	// test diagnostics
+	var dirList []string
+	for dir := range dirs {
+		dirList = append(dirList, dir)
+	}
+	exported.Config.Mode = packages.LoadFiles
+	pkgs, err := packages.Load(exported.Config, dirList...)
+	if err != nil {
+		t.Fatal(err)
+	}
+	testDiagnostics(t, s.view, pkgs, expectedDiagnostics)
+
+	// test format
+	testFormat(t, s, expectedFormat)
+}
+
+func testCompletion(t *testing.T, exported *packagestest.Exported, s *server, wants map[token.Position]*protocol.CompletionItem) {
+	if err := exported.Expect(map[string]interface{}{
+		"complete": func(src token.Position, expected []token.Position) {
+			var want []protocol.CompletionItem
+			for _, pos := range expected {
+				want = append(want, *wants[pos])
+			}
+			list, err := s.Completion(context.Background(), &protocol.CompletionParams{
+				TextDocumentPositionParams: protocol.TextDocumentPositionParams{
+					TextDocument: protocol.TextDocumentIdentifier{
+						URI: protocol.DocumentURI(source.ToURI(src.Filename)),
+					},
+					Position: protocol.Position{
+						Line:      float64(src.Line - 1),
+						Character: float64(src.Column - 1),
+					},
+				},
+			})
+			if err != nil {
+				t.Fatal(err)
+			}
+			got := list.Items
+			if equal := reflect.DeepEqual(want, got); !equal {
+				t.Errorf("completion failed for %s:%v:%v: (expected: %v), (got: %v)", filepath.Base(src.Filename), src.Line, src.Column, want, got)
+			}
+		},
+	}); err != nil {
+		t.Fatal(err)
+	}
+}
+
+func collectCompletionItems(expectedCompletions map[token.Position]*protocol.CompletionItem, pos token.Position, label, detail, kind string) {
+	var k protocol.CompletionItemKind
+	switch kind {
+	case "struct":
+		k = protocol.StructCompletion
+	case "func":
+		k = protocol.FunctionCompletion
+	case "var":
+		k = protocol.VariableCompletion
+	case "type":
+		k = protocol.TypeParameterCompletion
+	case "field":
+		k = protocol.FieldCompletion
+	case "interface":
+		k = protocol.InterfaceCompletion
+	case "const":
+		k = protocol.ConstantCompletion
+	case "method":
+		k = protocol.MethodCompletion
+	}
+	expectedCompletions[pos] = &protocol.CompletionItem{
+		Label:  label,
+		Detail: detail,
+		Kind:   float64(k),
+	}
+}
+
+func testDiagnostics(t *testing.T, v *source.View, pkgs []*packages.Package, wants map[string][]protocol.Diagnostic) {
+	for _, pkg := range pkgs {
+		for _, filename := range pkg.GoFiles {
+			f := v.GetFile(source.ToURI(filename))
+			diagnostics, err := source.Diagnostics(context.Background(), v, f)
+			if err != nil {
+				t.Fatal(err)
+			}
+			got := toProtocolDiagnostics(v, diagnostics[filename])
+			sort.Slice(got, func(i int, j int) bool {
+				return got[i].Range.Start.Line < got[j].Range.Start.Line
+			})
+			want := wants[filename]
+			if equal := reflect.DeepEqual(want, got); !equal {
+				t.Errorf("diagnostics failed for %s: (expected: %v), (got: %v)", filepath.Base(filename), want, got)
+			}
+		}
+	}
+}
+
+func collectDiagnostics(t *testing.T, expectedDiagnostics map[string][]protocol.Diagnostic, pos token.Position, msg string) {
+	line := float64(pos.Line - 1)
+	col := float64(pos.Column - 1)
+	want := protocol.Diagnostic{
+		Range: protocol.Range{
+			Start: protocol.Position{
+				Line:      line,
+				Character: col,
+			},
+			End: protocol.Position{
+				Line:      line,
+				Character: col,
+			},
+		},
+		Severity: protocol.SeverityError,
+		Source:   "LSP",
+		Message:  msg,
+	}
+	if _, ok := expectedDiagnostics[pos.Filename]; ok {
+		expectedDiagnostics[pos.Filename] = append(expectedDiagnostics[pos.Filename], want)
+	} else {
+		t.Errorf("unexpected filename: %v", pos.Filename)
+	}
+}
+
+func testFormat(t *testing.T, s *server, expectedFormat map[string]string) {
+	for filename, gofmted := range expectedFormat {
+		edits, err := s.Formatting(context.Background(), &protocol.DocumentFormattingParams{
+			TextDocument: protocol.TextDocumentIdentifier{
+				URI: protocol.DocumentURI(source.ToURI(filename)),
+			},
+		})
+		if err != nil || len(edits) == 0 {
+			if gofmted != "" {
+				t.Error(err)
+			}
+			return
+		}
+		edit := edits[0]
+		if edit.NewText != gofmted {
+			t.Errorf("formatting failed: (got: %s), (expected: %s)", edit.NewText, gofmted)
+		}
+	}
+}
+
+func collectFormat(expectedFormat map[string]string, pos token.Position) {
+	cmd := exec.Command("gofmt", pos.Filename)
+	stdout := bytes.NewBuffer(nil)
+	cmd.Stdout = stdout
+	cmd.Run() // ignore error, sometimes we have intentionally ungofmt-able files
+	expectedFormat[pos.Filename] = stdout.String()
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/position.go b/vendor/golang.org/x/tools/internal/lsp/position.go
new file mode 100644
index 00000000..de4ce674
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/position.go
@@ -0,0 +1,114 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package lsp
+
+import (
+	"go/token"
+
+	"golang.org/x/tools/internal/lsp/protocol"
+	"golang.org/x/tools/internal/lsp/source"
+)
+
+// fromProtocolLocation converts from a protocol location to a source range.
+// It will return an error if the file of the location was not valid.
+// It uses fromProtocolRange to convert the start and end positions.
+func fromProtocolLocation(v *source.View, loc protocol.Location) (source.Range, error) {
+	f := v.GetFile(source.URI(loc.URI))
+	tok, err := f.GetToken()
+	if err != nil {
+		return source.Range{}, err
+	}
+	return fromProtocolRange(tok, loc.Range), nil
+}
+
+// toProtocolLocation converts from a source range back to a protocol location.
+func toProtocolLocation(v *source.View, r source.Range) protocol.Location {
+	tokFile := v.Config.Fset.File(r.Start)
+	file := v.GetFile(source.ToURI(tokFile.Name()))
+	return protocol.Location{
+		URI:   protocol.DocumentURI(file.URI),
+		Range: toProtocolRange(tokFile, r),
+	}
+}
+
+// fromProtocolRange converts a protocol range to a source range.
+// It uses fromProtocolPosition to convert the start and end positions, which
+// requires the token file the positions belongs to.
+func fromProtocolRange(f *token.File, r protocol.Range) source.Range {
+	start := fromProtocolPosition(f, r.Start)
+	var end token.Pos
+	switch {
+	case r.End == r.Start:
+		end = start
+	case r.End.Line < 0:
+		end = token.NoPos
+	default:
+		end = fromProtocolPosition(f, r.End)
+	}
+	return source.Range{
+		Start: start,
+		End:   end,
+	}
+}
+
+// toProtocolRange converts from a source range back to a protocol range.
+func toProtocolRange(f *token.File, r source.Range) protocol.Range {
+	return protocol.Range{
+		Start: toProtocolPosition(f, r.Start),
+		End:   toProtocolPosition(f, r.End),
+	}
+}
+
+// fromProtocolPosition converts a protocol position (0-based line and column
+// number) to a token.Pos (byte offset value).
+// It requires the token file the pos belongs to in order to do this.
+func fromProtocolPosition(f *token.File, pos protocol.Position) token.Pos {
+	line := lineStart(f, int(pos.Line)+1)
+	return line + token.Pos(pos.Character) // TODO: this is wrong, bytes not characters
+}
+
+// toProtocolPosition converts from a token pos (byte offset) to a protocol
+// position  (0-based line and column number)
+// It requires the token file the pos belongs to in order to do this.
+func toProtocolPosition(f *token.File, pos token.Pos) protocol.Position {
+	if !pos.IsValid() {
+		return protocol.Position{Line: -1.0, Character: -1.0}
+	}
+	p := f.Position(pos)
+	return protocol.Position{
+		Line:      float64(p.Line - 1),
+		Character: float64(p.Column - 1),
+	}
+}
+
+// this functionality was borrowed from the analysisutil package
+func lineStart(f *token.File, line int) token.Pos {
+	// Use binary search to find the start offset of this line.
+	//
+	// TODO(adonovan): eventually replace this function with the
+	// simpler and more efficient (*go/token.File).LineStart, added
+	// in go1.12.
+
+	min := 0        // inclusive
+	max := f.Size() // exclusive
+	for {
+		offset := (min + max) / 2
+		pos := f.Pos(offset)
+		posn := f.Position(pos)
+		if posn.Line == line {
+			return pos - (token.Pos(posn.Column) - 1)
+		}
+
+		if min+1 >= max {
+			return token.NoPos
+		}
+
+		if posn.Line < line {
+			min = offset
+		} else {
+			max = offset
+		}
+	}
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/protocol/client.go b/vendor/golang.org/x/tools/internal/lsp/protocol/client.go
index 1e713289..d16eef2b 100644
--- a/vendor/golang.org/x/tools/internal/lsp/protocol/client.go
+++ b/vendor/golang.org/x/tools/internal/lsp/protocol/client.go
@@ -25,121 +25,103 @@ type Client interface {
 }
 
 func clientHandler(client Client) jsonrpc2.Handler {
-	return func(ctx context.Context, conn *jsonrpc2.Conn, r *jsonrpc2.Request) (interface{}, *jsonrpc2.Error) {
+	return func(ctx context.Context, conn *jsonrpc2.Conn, r *jsonrpc2.Request) {
 		switch r.Method {
 		case "$/cancelRequest":
 			var params CancelParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			conn.Cancel(params.ID)
-			return nil, nil
 
 		case "window/showMessage":
 			var params ShowMessageParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			if err := client.ShowMessage(ctx, &params); err != nil {
-				return nil, toJSONError(err)
-			}
-			return nil, nil
+			unhandledError(client.ShowMessage(ctx, &params))
 
 		case "window/showMessageRequest":
 			var params ShowMessageRequestParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := client.ShowMessageRequest(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "window/logMessage":
 			var params LogMessageParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
-			}
-			if err := client.LogMessage(ctx, &params); err != nil {
-				return nil, toJSONError(err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			return nil, nil
+			unhandledError(client.LogMessage(ctx, &params))
 
 		case "telemetry/event":
 			var params interface{}
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			if err := client.Telemetry(ctx, &params); err != nil {
-				return nil, toJSONError(err)
-			}
-			return nil, nil
+			unhandledError(client.Telemetry(ctx, &params))
 
 		case "client/registerCapability":
 			var params RegistrationParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
-			}
-			if err := client.RegisterCapability(ctx, &params); err != nil {
-				return nil, toJSONError(err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			return nil, nil
+			unhandledError(client.RegisterCapability(ctx, &params))
 
 		case "client/unregisterCapability":
 			var params UnregistrationParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
-			}
-			if err := client.UnregisterCapability(ctx, &params); err != nil {
-				return nil, toJSONError(err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			return nil, nil
+			unhandledError(client.UnregisterCapability(ctx, &params))
 
 		case "workspace/workspaceFolders":
 			if r.Params != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeInvalidParams, "Expected no params")
+				conn.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeInvalidParams, "Expected no params"))
+				return
 			}
 			resp, err := client.WorkspaceFolders(ctx)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "workspace/configuration":
 			var params ConfigurationParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := client.Configuration(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "workspace/applyEdit":
 			var params ApplyWorkspaceEditParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := client.ApplyEdit(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/publishDiagnostics":
 			var params PublishDiagnosticsParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			if err := client.PublishDiagnostics(ctx, &params); err != nil {
-				return nil, toJSONError(err)
-			}
-			return nil, nil
+			unhandledError(client.PublishDiagnostics(ctx, &params))
 
 		default:
-			return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeMethodNotFound, "method %q not found", r.Method)
+			if r.IsNotify() {
+				conn.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeMethodNotFound, "method %q not found", r.Method))
+			}
 		}
 	}
 }
diff --git a/vendor/golang.org/x/tools/internal/lsp/protocol/language.go b/vendor/golang.org/x/tools/internal/lsp/protocol/language.go
index 78732b13..b9fe9ccc 100644
--- a/vendor/golang.org/x/tools/internal/lsp/protocol/language.go
+++ b/vendor/golang.org/x/tools/internal/lsp/protocol/language.go
@@ -176,7 +176,7 @@ type CompletionItem struct {
 	 * *Note:* The range of the edit must be a single line range and it must contain the position at which completion
 	 * has been requested.
 	 */
-	TextEdit TextEdit `json:"textEdit,omitempty"`
+	TextEdit *TextEdit `json:"textEdit,omitempty"`
 
 	/**
 	 * An optional array of additional text edits that are applied when
@@ -201,7 +201,7 @@ type CompletionItem struct {
 	 * additional modifications to the current document should be described with the
 	 * additionalTextEdits-property.
 	 */
-	Command Command `json:"command,omitempty"`
+	Command *Command `json:"command,omitempty"`
 
 	/**
 	 * An data entry field that is preserved on a completion item between
diff --git a/vendor/golang.org/x/tools/internal/lsp/protocol/printers.go b/vendor/golang.org/x/tools/internal/lsp/protocol/printers.go
new file mode 100644
index 00000000..e658af96
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/protocol/printers.go
@@ -0,0 +1,39 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// This file contains formatting functions for types that
+// are commonly printed in debugging information.
+// They are separated from their types and gathered here as
+// they are hand written and not generated from the spec.
+// They should not be relied on for programmatic use (their
+// results should never be parsed for instance) but are meant
+// for temporary debugging and error messages.
+
+package protocol
+
+import (
+	"fmt"
+)
+
+func (p Position) Format(f fmt.State, c rune) {
+	fmt.Fprintf(f, "%d", int(p.Line))
+	if p.Character >= 0 {
+		fmt.Fprintf(f, ":%d", int(p.Character))
+	}
+}
+
+func (r Range) Format(f fmt.State, c rune) {
+	switch {
+	case r.Start == r.End || r.End.Line < 0:
+		fmt.Fprintf(f, "%v", r.Start)
+	case r.End.Line == r.Start.Line:
+		fmt.Fprintf(f, "%v%d", r.Start, int(r.End.Character))
+	default:
+		fmt.Fprintf(f, "%v%v", r.Start, r.End)
+	}
+}
+
+func (l Location) Format(f fmt.State, c rune) {
+	fmt.Fprintf(f, "%s:%v", l.URI, l.Range)
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/protocol/protocol.go b/vendor/golang.org/x/tools/internal/lsp/protocol/protocol.go
index 27682502..5d11c3c8 100644
--- a/vendor/golang.org/x/tools/internal/lsp/protocol/protocol.go
+++ b/vendor/golang.org/x/tools/internal/lsp/protocol/protocol.go
@@ -6,6 +6,7 @@ package protocol
 
 import (
 	"context"
+	"log"
 
 	"golang.org/x/tools/internal/jsonrpc2"
 )
@@ -15,20 +16,34 @@ func canceller(ctx context.Context, conn *jsonrpc2.Conn, req *jsonrpc2.Request)
 }
 
 func RunClient(ctx context.Context, stream jsonrpc2.Stream, client Client, opts ...interface{}) (*jsonrpc2.Conn, Server) {
-	opts = append([]interface{}{clientHandler(client), canceller}, opts...)
+	opts = append([]interface{}{clientHandler(client), jsonrpc2.Canceler(canceller)}, opts...)
 	conn := jsonrpc2.NewConn(ctx, stream, opts...)
 	return conn, &serverDispatcher{Conn: conn}
 }
 
 func RunServer(ctx context.Context, stream jsonrpc2.Stream, server Server, opts ...interface{}) (*jsonrpc2.Conn, Client) {
-	opts = append([]interface{}{serverHandler(server), canceller}, opts...)
+	opts = append([]interface{}{serverHandler(server), jsonrpc2.Canceler(canceller)}, opts...)
 	conn := jsonrpc2.NewConn(ctx, stream, opts...)
 	return conn, &clientDispatcher{Conn: conn}
 }
 
-func toJSONError(err error) *jsonrpc2.Error {
-	if jsonError, ok := err.(*jsonrpc2.Error); ok {
-		return jsonError
+func sendParseError(ctx context.Context, conn *jsonrpc2.Conn, req *jsonrpc2.Request, err error) {
+	if _, ok := err.(*jsonrpc2.Error); !ok {
+		err = jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
 	}
-	return jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+	unhandledError(conn.Reply(ctx, req, nil, err))
+}
+
+// unhandledError is used in places where an error may occur that cannot be handled.
+// This occurs in things like rpc handlers that are a notify, where we cannot
+// reply to the caller, or in a call when we are actually attempting to reply.
+// In these cases, there is nothing we can do with the error except log it, so
+// we do that in this function, and the presence of this function acts as a
+// useful reminder of why we are effectively dropping the error and also a
+// good place to hook in when debugging those kinds of errors.
+func unhandledError(err error) {
+	if err == nil {
+		return
+	}
+	log.Printf("%v", err)
 }
diff --git a/vendor/golang.org/x/tools/internal/lsp/protocol/server.go b/vendor/golang.org/x/tools/internal/lsp/protocol/server.go
index 22694f15..548812d8 100644
--- a/vendor/golang.org/x/tools/internal/lsp/protocol/server.go
+++ b/vendor/golang.org/x/tools/internal/lsp/protocol/server.go
@@ -52,411 +52,339 @@ type Server interface {
 }
 
 func serverHandler(server Server) jsonrpc2.Handler {
-	return func(ctx context.Context, conn *jsonrpc2.Conn, r *jsonrpc2.Request) (interface{}, *jsonrpc2.Error) {
+	return func(ctx context.Context, conn *jsonrpc2.Conn, r *jsonrpc2.Request) {
 		switch r.Method {
 		case "initialize":
 			var params InitializeParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.Initialize(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "initialized":
 			var params InitializedParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
-			}
-			if err := server.Initialized(ctx, &params); err != nil {
-				return nil, toJSONError(err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			return nil, nil
+			unhandledError(server.Initialized(ctx, &params))
 
 		case "shutdown":
 			if r.Params != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeInvalidParams, "Expected no params")
-			}
-			if err := server.Shutdown(ctx); err != nil {
-				return nil, toJSONError(err)
+				conn.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeInvalidParams, "Expected no params"))
+				return
 			}
-			return nil, nil
+			unhandledError(server.Shutdown(ctx))
 
 		case "exit":
 			if r.Params != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeInvalidParams, "Expected no params")
+				conn.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeInvalidParams, "Expected no params"))
+				return
 			}
-			if err := server.Exit(ctx); err != nil {
-				return nil, toJSONError(err)
-			}
-			return nil, nil
+			unhandledError(server.Exit(ctx))
 
 		case "$/cancelRequest":
 			var params CancelParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			conn.Cancel(params.ID)
-			return nil, nil
 
 		case "workspace/didChangeWorkspaceFolders":
 			var params DidChangeWorkspaceFoldersParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
-			}
-			if err := server.DidChangeWorkspaceFolders(ctx, &params); err != nil {
-				return nil, toJSONError(err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			return nil, nil
+			unhandledError(server.DidChangeWorkspaceFolders(ctx, &params))
 
 		case "workspace/didChangeConfiguration":
 			var params DidChangeConfigurationParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			if err := server.DidChangeConfiguration(ctx, &params); err != nil {
-				return nil, toJSONError(err)
-			}
-			return nil, nil
+			unhandledError(server.DidChangeConfiguration(ctx, &params))
 
 		case "workspace/didChangeWatchedFiles":
 			var params DidChangeWatchedFilesParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
-			}
-			if err := server.DidChangeWatchedFiles(ctx, &params); err != nil {
-				return nil, toJSONError(err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			return nil, nil
+			unhandledError(server.DidChangeWatchedFiles(ctx, &params))
 
 		case "workspace/symbol":
 			var params WorkspaceSymbolParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.Symbols(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "workspace/executeCommand":
 			var params ExecuteCommandParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.ExecuteCommand(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/didOpen":
 			var params DidOpenTextDocumentParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
-			}
-			if err := server.DidOpen(ctx, &params); err != nil {
-				return nil, toJSONError(err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			return nil, nil
+			unhandledError(server.DidOpen(ctx, &params))
 
 		case "textDocument/didChange":
 			var params DidChangeTextDocumentParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			if err := server.DidChange(ctx, &params); err != nil {
-				return nil, toJSONError(err)
-			}
-			return nil, nil
+			unhandledError(server.DidChange(ctx, &params))
 
 		case "textDocument/willSave":
 			var params WillSaveTextDocumentParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
-			}
-			if err := server.WillSave(ctx, &params); err != nil {
-				return nil, toJSONError(err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			return nil, nil
+			unhandledError(server.WillSave(ctx, &params))
 
 		case "textDocument/willSaveWaitUntil":
 			var params WillSaveTextDocumentParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.WillSaveWaitUntil(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/didSave":
 			var params DidSaveTextDocumentParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			if err := server.DidSave(ctx, &params); err != nil {
-				return nil, toJSONError(err)
-			}
-			return nil, nil
+			unhandledError(server.DidSave(ctx, &params))
 
 		case "textDocument/didClose":
 			var params DidCloseTextDocumentParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
-			}
-			if err := server.DidClose(ctx, &params); err != nil {
-				return nil, toJSONError(err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
-			return nil, nil
+			unhandledError(server.DidClose(ctx, &params))
 
 		case "textDocument/completion":
 			var params CompletionParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.Completion(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "completionItem/resolve":
 			var params CompletionItem
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.CompletionResolve(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/hover":
 			var params TextDocumentPositionParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.Hover(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/signatureHelp":
 			var params TextDocumentPositionParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.SignatureHelp(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/definition":
 			var params TextDocumentPositionParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.Definition(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/typeDefinition":
 			var params TextDocumentPositionParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.TypeDefinition(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/implementation":
 			var params TextDocumentPositionParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.Implementation(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/references":
 			var params ReferenceParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.References(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/documentHighlight":
 			var params TextDocumentPositionParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.DocumentHighlight(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/documentSymbol":
 			var params DocumentSymbolParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.DocumentSymbol(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/codeAction":
 			var params CodeActionParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.CodeAction(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/codeLens":
 			var params CodeLensParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.CodeLens(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "codeLens/resolve":
 			var params CodeLens
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.CodeLensResolve(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/documentLink":
 			var params DocumentLinkParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.DocumentLink(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "documentLink/resolve":
 			var params DocumentLink
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.DocumentLinkResolve(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/documentColor":
 			var params DocumentColorParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.DocumentColor(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/colorPresentation":
 			var params ColorPresentationParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.ColorPresentation(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/formatting":
 			var params DocumentFormattingParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.Formatting(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/rangeFormatting":
 			var params DocumentRangeFormattingParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.RangeFormatting(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/onTypeFormatting":
 			var params DocumentOnTypeFormattingParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.OnTypeFormatting(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/rename":
 			var params RenameParams
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.Rename(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 
 		case "textDocument/foldingRanges":
 			var params FoldingRangeRequestParam
 			if err := json.Unmarshal(*r.Params, &params); err != nil {
-				return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeParseError, "%v", err)
+				sendParseError(ctx, conn, r, err)
+				return
 			}
 			resp, err := server.FoldingRanges(ctx, &params)
-			if err != nil {
-				return nil, toJSONError(err)
-			}
-			return resp, nil
+			unhandledError(conn.Reply(ctx, r, resp, err))
 		default:
-			return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeMethodNotFound, "method %q not found", r.Method)
+			if r.IsNotify() {
+				conn.Reply(ctx, r, nil, jsonrpc2.NewErrorf(jsonrpc2.CodeMethodNotFound, "method %q not found", r.Method))
+			}
 		}
 	}
 }
diff --git a/vendor/golang.org/x/tools/internal/lsp/server.go b/vendor/golang.org/x/tools/internal/lsp/server.go
index c2462707..00c90756 100644
--- a/vendor/golang.org/x/tools/internal/lsp/server.go
+++ b/vendor/golang.org/x/tools/internal/lsp/server.go
@@ -6,19 +6,19 @@ package lsp
 
 import (
 	"context"
+	"go/token"
 	"os"
 	"sync"
 
 	"golang.org/x/tools/internal/jsonrpc2"
 	"golang.org/x/tools/internal/lsp/protocol"
+	"golang.org/x/tools/internal/lsp/source"
 )
 
 // RunServer starts an LSP server on the supplied stream, and waits until the
 // stream is closed.
 func RunServer(ctx context.Context, stream jsonrpc2.Stream, opts ...interface{}) error {
-	s := &server{
-		view: newView(),
-	}
+	s := &server{}
 	conn, client := protocol.RunServer(ctx, stream, s, opts...)
 	s.client = client
 	return conn.Wait(ctx)
@@ -30,7 +30,7 @@ type server struct {
 	initializedMu sync.Mutex
 	initialized   bool // set once the server has received "initialize" request
 
-	*view
+	view *source.View
 }
 
 func (s *server) Initialize(ctx context.Context, params *protocol.InitializeParams) (*protocol.InitializeResult, error) {
@@ -39,15 +39,23 @@ func (s *server) Initialize(ctx context.Context, params *protocol.InitializePara
 	if s.initialized {
 		return nil, jsonrpc2.NewErrorf(jsonrpc2.CodeInvalidRequest, "server already initialized")
 	}
+	s.view = source.NewView()
 	s.initialized = true
 	return &protocol.InitializeResult{
 		Capabilities: protocol.ServerCapabilities{
+			CompletionProvider: protocol.CompletionOptions{
+				TriggerCharacters: []string{"."},
+			},
+			DefinitionProvider:              true,
+			DocumentFormattingProvider:      true,
+			DocumentRangeFormattingProvider: true,
+			SignatureHelpProvider: protocol.SignatureHelpOptions{
+				TriggerCharacters: []string{"("},
+			},
 			TextDocumentSync: protocol.TextDocumentSyncOptions{
 				Change:    float64(protocol.Full), // full contents of file sent on each update
 				OpenClose: true,
 			},
-			DocumentFormattingProvider:      true,
-			DocumentRangeFormattingProvider: true,
 		},
 	}, nil
 }
@@ -111,18 +119,19 @@ func (s *server) DidChange(ctx context.Context, params *protocol.DidChangeTextDo
 }
 
 func (s *server) cacheAndDiagnoseFile(ctx context.Context, uri protocol.DocumentURI, text string) {
-	s.view.activeFilesMu.Lock()
-	s.view.activeFiles[uri] = []byte(text)
-	s.view.activeFilesMu.Unlock()
+	f := s.view.GetFile(source.URI(uri))
+	f.SetContent([]byte(text))
 	go func() {
-		reports, err := s.diagnostics(uri)
-		if err == nil {
-			for filename, diagnostics := range reports {
-				s.client.PublishDiagnostics(ctx, &protocol.PublishDiagnosticsParams{
-					URI:         filenameToURI(filename),
-					Diagnostics: diagnostics,
-				})
-			}
+		f := s.view.GetFile(source.URI(uri))
+		reports, err := source.Diagnostics(ctx, s.view, f)
+		if err != nil {
+			return // handle error?
+		}
+		for filename, diagnostics := range reports {
+			s.client.PublishDiagnostics(ctx, &protocol.PublishDiagnosticsParams{
+				URI:         protocol.DocumentURI(source.ToURI(filename)),
+				Diagnostics: toProtocolDiagnostics(s.view, diagnostics),
+			})
 		}
 	}()
 }
@@ -141,12 +150,25 @@ func (s *server) DidSave(context.Context, *protocol.DidSaveTextDocumentParams) e
 }
 
 func (s *server) DidClose(ctx context.Context, params *protocol.DidCloseTextDocumentParams) error {
-	s.clearActiveFile(params.TextDocument.URI)
+	s.view.GetFile(source.URI(params.TextDocument.URI)).SetContent(nil)
 	return nil
 }
 
-func (s *server) Completion(context.Context, *protocol.CompletionParams) (*protocol.CompletionList, error) {
-	return nil, notImplemented("Completion")
+func (s *server) Completion(ctx context.Context, params *protocol.CompletionParams) (*protocol.CompletionList, error) {
+	f := s.view.GetFile(source.URI(params.TextDocument.URI))
+	tok, err := f.GetToken()
+	if err != nil {
+		return nil, err
+	}
+	pos := fromProtocolPosition(tok, params.Position)
+	items, err := source.Completion(ctx, f, pos)
+	if err != nil {
+		return nil, err
+	}
+	return &protocol.CompletionList{
+		IsIncomplete: false,
+		Items:        toProtocolCompletionItems(items),
+	}, nil
 }
 
 func (s *server) CompletionResolve(context.Context, *protocol.CompletionItem) (*protocol.CompletionItem, error) {
@@ -157,12 +179,32 @@ func (s *server) Hover(context.Context, *protocol.TextDocumentPositionParams) (*
 	return nil, notImplemented("Hover")
 }
 
-func (s *server) SignatureHelp(context.Context, *protocol.TextDocumentPositionParams) (*protocol.SignatureHelp, error) {
-	return nil, notImplemented("SignatureHelp")
+func (s *server) SignatureHelp(ctx context.Context, params *protocol.TextDocumentPositionParams) (*protocol.SignatureHelp, error) {
+	f := s.view.GetFile(source.URI(params.TextDocument.URI))
+	tok, err := f.GetToken()
+	if err != nil {
+		return nil, err
+	}
+	pos := fromProtocolPosition(tok, params.Position)
+	info, err := source.SignatureHelp(ctx, f, pos)
+	if err != nil {
+		return nil, err
+	}
+	return toProtocolSignatureHelp(info), nil
 }
 
-func (s *server) Definition(context.Context, *protocol.TextDocumentPositionParams) ([]protocol.Location, error) {
-	return nil, notImplemented("Definition")
+func (s *server) Definition(ctx context.Context, params *protocol.TextDocumentPositionParams) ([]protocol.Location, error) {
+	f := s.view.GetFile(source.URI(params.TextDocument.URI))
+	tok, err := f.GetToken()
+	if err != nil {
+		return nil, err
+	}
+	pos := fromProtocolPosition(tok, params.Position)
+	r, err := source.Definition(ctx, f, pos)
+	if err != nil {
+		return nil, err
+	}
+	return []protocol.Location{toProtocolLocation(s.view, r)}, nil
 }
 
 func (s *server) TypeDefinition(context.Context, *protocol.TextDocumentPositionParams) ([]protocol.Location, error) {
@@ -214,11 +256,46 @@ func (s *server) ColorPresentation(context.Context, *protocol.ColorPresentationP
 }
 
 func (s *server) Formatting(ctx context.Context, params *protocol.DocumentFormattingParams) ([]protocol.TextEdit, error) {
-	return s.format(params.TextDocument.URI, nil)
+	return formatRange(ctx, s.view, params.TextDocument.URI, nil)
 }
 
 func (s *server) RangeFormatting(ctx context.Context, params *protocol.DocumentRangeFormattingParams) ([]protocol.TextEdit, error) {
-	return s.format(params.TextDocument.URI, &params.Range)
+	return formatRange(ctx, s.view, params.TextDocument.URI, &params.Range)
+}
+
+// formatRange formats a document with a given range.
+func formatRange(ctx context.Context, v *source.View, uri protocol.DocumentURI, rng *protocol.Range) ([]protocol.TextEdit, error) {
+	f := v.GetFile(source.URI(uri))
+	tok, err := f.GetToken()
+	if err != nil {
+		return nil, err
+	}
+	var r source.Range
+	if rng == nil {
+		r.Start = tok.Pos(0)
+		r.End = tok.Pos(tok.Size())
+	} else {
+		r = fromProtocolRange(tok, *rng)
+	}
+	edits, err := source.Format(ctx, f, r)
+	if err != nil {
+		return nil, err
+	}
+	return toProtocolEdits(tok, edits), nil
+}
+
+func toProtocolEdits(f *token.File, edits []source.TextEdit) []protocol.TextEdit {
+	if edits == nil {
+		return nil
+	}
+	result := make([]protocol.TextEdit, len(edits))
+	for i, edit := range edits {
+		result[i] = protocol.TextEdit{
+			Range:   toProtocolRange(f, edit.Range),
+			NewText: edit.NewText,
+		}
+	}
+	return result
 }
 
 func (s *server) OnTypeFormatting(context.Context, *protocol.DocumentOnTypeFormattingParams) ([]protocol.TextEdit, error) {
diff --git a/vendor/golang.org/x/tools/internal/lsp/signature_help.go b/vendor/golang.org/x/tools/internal/lsp/signature_help.go
new file mode 100644
index 00000000..0e54a507
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/signature_help.go
@@ -0,0 +1,33 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package lsp
+
+import (
+	"golang.org/x/tools/internal/lsp/protocol"
+	"golang.org/x/tools/internal/lsp/source"
+)
+
+func toProtocolSignatureHelp(info *source.SignatureInformation) *protocol.SignatureHelp {
+	return &protocol.SignatureHelp{
+		ActiveParameter: float64(info.ActiveParameter),
+		ActiveSignature: 0, // there is only ever one possible signature
+		Signatures: []protocol.SignatureInformation{
+			{
+				Label:      info.Label,
+				Parameters: toProtocolParameterInformation(info.Parameters),
+			},
+		},
+	}
+}
+
+func toProtocolParameterInformation(info []source.ParameterInformation) []protocol.ParameterInformation {
+	var result []protocol.ParameterInformation
+	for _, p := range info {
+		result = append(result, protocol.ParameterInformation{
+			Label: p.Label,
+		})
+	}
+	return result
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/source/completion.go b/vendor/golang.org/x/tools/internal/lsp/source/completion.go
new file mode 100644
index 00000000..2230f608
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/source/completion.go
@@ -0,0 +1,734 @@
+package source
+
+import (
+	"bytes"
+	"context"
+	"fmt"
+	"go/ast"
+	"go/token"
+	"go/types"
+	"strings"
+
+	"golang.org/x/tools/go/ast/astutil"
+)
+
+type CompletionItem struct {
+	Label, Detail string
+	Kind          CompletionItemKind
+	Score         int
+}
+
+type CompletionItemKind int
+
+const (
+	Unknown CompletionItemKind = iota
+	InterfaceCompletionItem
+	StructCompletionItem
+	TypeCompletionItem
+	ConstantCompletionItem
+	FieldCompletionItem
+	ParameterCompletionItem
+	VariableCompletionItem
+	FunctionCompletionItem
+	MethodCompletionItem
+	PackageCompletionItem
+)
+
+func Completion(ctx context.Context, f *File, pos token.Pos) ([]CompletionItem, error) {
+	file, err := f.GetAST()
+	if err != nil {
+		return nil, err
+	}
+	pkg, err := f.GetPackage()
+	if err != nil {
+		return nil, err
+	}
+	items, _, err := completions(file, pos, pkg.Fset, pkg.Types, pkg.TypesInfo)
+	return items, err
+}
+
+type finder func(types.Object, float64, []CompletionItem) []CompletionItem
+
+// completions returns the map of possible candidates for completion, given a
+// position, a file AST, and type information. The prefix is computed based on
+// the preceding identifier and can be used by the client to score the quality
+// of the completion. For instance, some clients may tolerate imperfect matches
+// as valid completion results, since users may make typos.
+func completions(file *ast.File, pos token.Pos, fset *token.FileSet, pkg *types.Package, info *types.Info) (items []CompletionItem, prefix string, err error) {
+	path, _ := astutil.PathEnclosingInterval(file, pos, pos)
+	if path == nil {
+		return nil, "", fmt.Errorf("cannot find node enclosing position")
+	}
+	// If the position is not an identifier but immediately follows
+	// an identifier or selector period (as is common when
+	// requesting a completion), use the path to the preceding node.
+	if _, ok := path[0].(*ast.Ident); !ok {
+		if p, _ := astutil.PathEnclosingInterval(file, pos-1, pos-1); p != nil {
+			switch p[0].(type) {
+			case *ast.Ident, *ast.SelectorExpr:
+				path = p // use preceding ident/selector
+			}
+		}
+	}
+
+	// Save certain facts about the query position, including the expected type
+	// of the completion result, the signature of the function enclosing the
+	// position.
+	typ := expectedType(path, pos, info)
+	sig := enclosingFunction(path, pos, info)
+	pkgStringer := qualifier(file, pkg, info)
+
+	seen := make(map[types.Object]bool)
+
+	// found adds a candidate completion.
+	// Only the first candidate of a given name is considered.
+	found := func(obj types.Object, weight float64, items []CompletionItem) []CompletionItem {
+		if obj.Pkg() != nil && obj.Pkg() != pkg && !obj.Exported() {
+			return items // inaccessible
+		}
+		if !seen[obj] {
+			seen[obj] = true
+			if typ != nil && matchingTypes(typ, obj.Type()) {
+				weight *= 10
+			}
+			if !strings.HasPrefix(obj.Name(), prefix) {
+				return items
+			}
+			item := formatCompletion(obj, pkgStringer, weight, func(v *types.Var) bool {
+				return isParameter(sig, v)
+			})
+			items = append(items, item)
+		}
+		return items
+	}
+
+	// The position is within a composite literal.
+	if items, ok := complit(path, pos, pkg, info, found); ok {
+		return items, "", nil
+	}
+	switch n := path[0].(type) {
+	case *ast.Ident:
+		// Set the filter prefix.
+		prefix = n.Name[:pos-n.Pos()]
+
+		// Is this the Sel part of a selector?
+		if sel, ok := path[1].(*ast.SelectorExpr); ok && sel.Sel == n {
+			return selector(sel, info, found)
+		}
+		// reject defining identifiers
+		if obj, ok := info.Defs[n]; ok {
+			if v, ok := obj.(*types.Var); ok && v.IsField() {
+				// An anonymous field is also a reference to a type.
+			} else {
+				of := ""
+				if obj != nil {
+					qual := types.RelativeTo(pkg)
+					of += ", of " + types.ObjectString(obj, qual)
+				}
+				return nil, "", fmt.Errorf("this is a definition%s", of)
+			}
+		}
+
+		items = append(items, lexical(path, pos, pkg, info, found)...)
+
+	// The function name hasn't been typed yet, but the parens are there:
+	//   recv.(arg)
+	case *ast.TypeAssertExpr:
+		// Create a fake selector expression.
+		return selector(&ast.SelectorExpr{X: n.X}, info, found)
+
+	case *ast.SelectorExpr:
+		return selector(n, info, found)
+
+	default:
+		// fallback to lexical completions
+		return lexical(path, pos, pkg, info, found), "", nil
+	}
+
+	return items, prefix, nil
+}
+
+// selector finds completions for
+// the specified selector expression.
+// TODO(rstambler): Set the prefix filter correctly for selectors.
+func selector(sel *ast.SelectorExpr, info *types.Info, found finder) (items []CompletionItem, prefix string, err error) {
+	// Is sel a qualified identifier?
+	if id, ok := sel.X.(*ast.Ident); ok {
+		if pkgname, ok := info.Uses[id].(*types.PkgName); ok {
+			// Enumerate package members.
+			// TODO(adonovan): can Imported() be nil?
+			scope := pkgname.Imported().Scope()
+			// TODO testcase: bad import
+			for _, name := range scope.Names() {
+				items = found(scope.Lookup(name), 1, items)
+			}
+			return items, prefix, nil
+		}
+	}
+
+	// Inv: sel is a true selector.
+	tv, ok := info.Types[sel.X]
+	if !ok {
+		return nil, "", fmt.Errorf("cannot resolve %s", sel.X)
+	}
+
+	// methods of T
+	mset := types.NewMethodSet(tv.Type)
+	for i := 0; i < mset.Len(); i++ {
+		items = found(mset.At(i).Obj(), 1, items)
+	}
+
+	// methods of *T
+	if tv.Addressable() && !types.IsInterface(tv.Type) && !isPointer(tv.Type) {
+		mset := types.NewMethodSet(types.NewPointer(tv.Type))
+		for i := 0; i < mset.Len(); i++ {
+			items = found(mset.At(i).Obj(), 1, items)
+		}
+	}
+
+	// fields of T
+	for _, f := range fieldSelections(tv.Type) {
+		items = found(f, 1, items)
+	}
+
+	return items, prefix, nil
+}
+
+// lexical finds completions in the lexical environment.
+func lexical(path []ast.Node, pos token.Pos, pkg *types.Package, info *types.Info, found finder) (items []CompletionItem) {
+	var scopes []*types.Scope // scopes[i], where i<len(path), is the possibly nil Scope of path[i].
+	for _, n := range path {
+		switch node := n.(type) {
+		case *ast.FuncDecl:
+			n = node.Type
+		case *ast.FuncLit:
+			n = node.Type
+		}
+		scopes = append(scopes, info.Scopes[n])
+	}
+	scopes = append(scopes, pkg.Scope())
+
+	// Process scopes innermost first.
+	for i, scope := range scopes {
+		if scope == nil {
+			continue
+		}
+		for _, name := range scope.Names() {
+			declScope, obj := scope.LookupParent(name, pos)
+			if declScope != scope {
+				continue // Name was declared in some enclosing scope, or not at all.
+			}
+			// If obj's type is invalid, find the AST node that defines the lexical block
+			// containing the declaration of obj. Don't resolve types for packages.
+			if _, ok := obj.(*types.PkgName); !ok && obj.Type() == types.Typ[types.Invalid] {
+				// Match the scope to its ast.Node. If the scope is the package scope,
+				// use the *ast.File as the starting node.
+				var node ast.Node
+				if i < len(path) {
+					node = path[i]
+				} else if i == len(path) { // use the *ast.File for package scope
+					node = path[i-1]
+				}
+				if node != nil {
+					if resolved := resolveInvalid(obj, node, info); resolved != nil {
+						obj = resolved
+					}
+				}
+			}
+
+			score := 1.0
+			// Rank builtins significantly lower than other results.
+			if scope == types.Universe {
+				score *= 0.1
+			}
+			items = found(obj, score, items)
+		}
+	}
+	return items
+}
+
+// complit finds completions for field names inside a composite literal.
+// It reports whether the node was handled as part of a composite literal.
+func complit(path []ast.Node, pos token.Pos, pkg *types.Package, info *types.Info, found finder) (items []CompletionItem, ok bool) {
+	var lit *ast.CompositeLit
+
+	// First, determine if the pos is within a composite literal.
+	switch n := path[0].(type) {
+	case *ast.CompositeLit:
+		// The enclosing node will be a composite literal if the user has just
+		// opened the curly brace (e.g. &x{<>) or the completion request is triggered
+		// from an already completed composite literal expression (e.g. &x{foo: 1, <>})
+		//
+		// If the cursor position is within a key-value expression inside the composite
+		// literal, we try to determine if it is before or after the colon. If it is before
+		// the colon, we return field completions. If the cursor does not belong to any
+		// expression within the composite literal, we show composite literal completions.
+		var expr ast.Expr
+		for _, e := range n.Elts {
+			if e.Pos() <= pos && pos < e.End() {
+				expr = e
+				break
+			}
+		}
+		lit = n
+		// If the position belongs to a key-value expression and is after the colon,
+		// don't show composite literal completions.
+		if kv, ok := expr.(*ast.KeyValueExpr); ok && pos > kv.Colon {
+			lit = nil
+		}
+	case *ast.KeyValueExpr:
+		// If the enclosing node is a key-value expression (e.g. &x{foo: <>}),
+		// we show composite literal completions if the cursor position is before the colon.
+		if len(path) > 1 && pos < n.Colon {
+			if l, ok := path[1].(*ast.CompositeLit); ok {
+				lit = l
+			}
+		}
+	case *ast.Ident:
+		// If the enclosing node is an identifier, it can either be an identifier that is
+		// part of a composite literal (e.g. &x{fo<>}), or it can be an identifier that is
+		// part of a key-value expression, which is part of a composite literal (e.g. &x{foo: ba<>).
+		// We handle both of these cases, showing composite literal completions only if
+		// the cursor position for the key-value expression is before the colon.
+		if len(path) > 1 {
+			if l, ok := path[1].(*ast.CompositeLit); ok {
+				lit = l
+			} else if len(path) > 2 {
+				if l, ok := path[2].(*ast.CompositeLit); ok {
+					// Confirm that cursor position is inside curly braces.
+					if l.Lbrace <= pos && pos <= l.Rbrace {
+						lit = l
+						if kv, ok := path[1].(*ast.KeyValueExpr); ok {
+							if pos > kv.Colon {
+								lit = nil
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	// We are not in a composite literal.
+	if lit == nil {
+		return nil, false
+	}
+	// Mark fields of the composite literal that have already been set,
+	// except for the current field.
+	hasKeys := false // true if the composite literal already has key-value pairs
+	addedFields := make(map[*types.Var]bool)
+	for _, el := range lit.Elts {
+		if kv, ok := el.(*ast.KeyValueExpr); ok {
+			hasKeys = true
+			if kv.Pos() <= pos && pos <= kv.End() {
+				continue
+			}
+			if key, ok := kv.Key.(*ast.Ident); ok {
+				if used, ok := info.Uses[key]; ok {
+					if usedVar, ok := used.(*types.Var); ok {
+						addedFields[usedVar] = true
+					}
+				}
+			}
+		}
+	}
+	// If the underlying type of the composite literal is a struct,
+	// collect completions for the fields of this struct.
+	if tv, ok := info.Types[lit]; ok {
+		var structPkg *types.Package // package containing the struct type declaration
+		if s, ok := tv.Type.Underlying().(*types.Struct); ok {
+			for i := 0; i < s.NumFields(); i++ {
+				field := s.Field(i)
+				if i == 0 {
+					structPkg = field.Pkg()
+				}
+				if !addedFields[field] {
+					items = found(field, 10, items)
+				}
+			}
+			// Add lexical completions if the user hasn't typed a key value expression
+			// and if the struct fields are defined in the same package as the user is in.
+			if !hasKeys && structPkg == pkg {
+				items = append(items, lexical(path, pos, pkg, info, found)...)
+			}
+			return items, true
+		}
+	}
+	return items, false
+}
+
+// formatCompletion creates a completion item for a given types.Object.
+func formatCompletion(obj types.Object, qualifier types.Qualifier, score float64, isParam func(*types.Var) bool) CompletionItem {
+	label := obj.Name()
+	detail := types.TypeString(obj.Type(), qualifier)
+	var kind CompletionItemKind
+
+	switch o := obj.(type) {
+	case *types.TypeName:
+		detail, kind = formatType(o.Type(), qualifier)
+		if obj.Parent() == types.Universe {
+			detail = ""
+		}
+	case *types.Const:
+		if obj.Parent() == types.Universe {
+			detail = ""
+		} else {
+			val := o.Val().ExactString()
+			if !strings.Contains(val, "\\n") { // skip any multiline constants
+				label += " = " + o.Val().ExactString()
+			}
+		}
+		kind = ConstantCompletionItem
+	case *types.Var:
+		if _, ok := o.Type().(*types.Struct); ok {
+			detail = "struct{...}" // for anonymous structs
+		}
+		if o.IsField() {
+			kind = FieldCompletionItem
+		} else if isParam(o) {
+			kind = ParameterCompletionItem
+		} else {
+			kind = VariableCompletionItem
+		}
+	case *types.Func:
+		if sig, ok := o.Type().(*types.Signature); ok {
+			label += formatParams(sig.Params(), sig.Variadic(), qualifier)
+			detail = strings.Trim(types.TypeString(sig.Results(), qualifier), "()")
+			kind = FunctionCompletionItem
+			if sig.Recv() != nil {
+				kind = MethodCompletionItem
+			}
+		}
+	case *types.Builtin:
+		item, ok := builtinDetails[obj.Name()]
+		if !ok {
+			break
+		}
+		label, detail = item.label, item.detail
+		kind = FunctionCompletionItem
+	case *types.PkgName:
+		kind = PackageCompletionItem
+		detail = fmt.Sprintf("\"%s\"", o.Imported().Path())
+	case *types.Nil:
+		kind = VariableCompletionItem
+		detail = ""
+	}
+	detail = strings.TrimPrefix(detail, "untyped ")
+
+	return CompletionItem{
+		Label:  label,
+		Detail: detail,
+		Kind:   kind,
+	}
+}
+
+// formatType returns the detail and kind for an object of type *types.TypeName.
+func formatType(typ types.Type, qualifier types.Qualifier) (detail string, kind CompletionItemKind) {
+	if types.IsInterface(typ) {
+		detail = "interface{...}"
+		kind = InterfaceCompletionItem
+	} else if _, ok := typ.(*types.Struct); ok {
+		detail = "struct{...}"
+		kind = StructCompletionItem
+	} else if typ != typ.Underlying() {
+		detail, kind = formatType(typ.Underlying(), qualifier)
+	} else {
+		detail = types.TypeString(typ, qualifier)
+		kind = TypeCompletionItem
+	}
+	return detail, kind
+}
+
+// formatParams correctly format the parameters of a function.
+func formatParams(t *types.Tuple, variadic bool, qualifier types.Qualifier) string {
+	var b bytes.Buffer
+	b.WriteByte('(')
+	for i := 0; i < t.Len(); i++ {
+		if i > 0 {
+			b.WriteString(", ")
+		}
+		el := t.At(i)
+		typ := types.TypeString(el.Type(), qualifier)
+		// Handle a variadic parameter (can only be the final parameter).
+		if variadic && i == t.Len()-1 {
+			typ = strings.Replace(typ, "[]", "...", 1)
+		}
+		fmt.Fprintf(&b, "%v %v", el.Name(), typ)
+	}
+	b.WriteByte(')')
+	return b.String()
+}
+
+// isParameter returns true if the given *types.Var is a parameter to the given
+// *types.Signature.
+func isParameter(sig *types.Signature, v *types.Var) bool {
+	if sig == nil {
+		return false
+	}
+	for i := 0; i < sig.Params().Len(); i++ {
+		if sig.Params().At(i) == v {
+			return true
+		}
+	}
+	return false
+}
+
+// qualifier returns a function that appropriately formats a types.PkgName
+// appearing in a *ast.File.
+func qualifier(f *ast.File, pkg *types.Package, info *types.Info) types.Qualifier {
+	// Construct mapping of import paths to their defined or implicit names.
+	imports := make(map[*types.Package]string)
+	for _, imp := range f.Imports {
+		var obj types.Object
+		if imp.Name != nil {
+			obj = info.Defs[imp.Name]
+		} else {
+			obj = info.Implicits[imp]
+		}
+		if pkgname, ok := obj.(*types.PkgName); ok {
+			imports[pkgname.Imported()] = pkgname.Name()
+		}
+	}
+	// Define qualifier to replace full package paths with names of the imports.
+	return func(pkg *types.Package) string {
+		if pkg == pkg {
+			return ""
+		}
+		if name, ok := imports[pkg]; ok {
+			return name
+		}
+		return pkg.Name()
+	}
+}
+
+// enclosingFunction returns the signature of the function enclosing the given
+// position.
+func enclosingFunction(path []ast.Node, pos token.Pos, info *types.Info) *types.Signature {
+	for _, node := range path {
+		switch t := node.(type) {
+		case *ast.FuncDecl:
+			if obj, ok := info.Defs[t.Name]; ok {
+				return obj.Type().(*types.Signature)
+			}
+		case *ast.FuncLit:
+			if typ, ok := info.Types[t]; ok {
+				return typ.Type.(*types.Signature)
+			}
+		}
+	}
+	return nil
+}
+
+// expectedType returns the expected type for an expression at the query position.
+func expectedType(path []ast.Node, pos token.Pos, info *types.Info) types.Type {
+	for i, node := range path {
+		if i == 2 {
+			break
+		}
+		switch expr := node.(type) {
+		case *ast.BinaryExpr:
+			// Determine if query position comes from left or right of op.
+			e := expr.X
+			if pos < expr.OpPos {
+				e = expr.Y
+			}
+			if tv, ok := info.Types[e]; ok {
+				return tv.Type
+			}
+		case *ast.AssignStmt:
+			// Only rank completions if you are on the right side of the token.
+			if pos <= expr.TokPos {
+				break
+			}
+			i := exprAtPos(pos, expr.Rhs)
+			if i >= len(expr.Lhs) {
+				i = len(expr.Lhs) - 1
+			}
+			if tv, ok := info.Types[expr.Lhs[i]]; ok {
+				return tv.Type
+			}
+		case *ast.CallExpr:
+			if tv, ok := info.Types[expr.Fun]; ok {
+				if sig, ok := tv.Type.(*types.Signature); ok {
+					if sig.Params().Len() == 0 {
+						return nil
+					}
+					i := exprAtPos(pos, expr.Args)
+					// Make sure not to run past the end of expected parameters.
+					if i >= sig.Params().Len() {
+						i = sig.Params().Len() - 1
+					}
+					return sig.Params().At(i).Type()
+				}
+			}
+		}
+	}
+	return nil
+}
+
+// matchingTypes reports whether actual is a good candidate type
+// for a completion in a context of the expected type.
+func matchingTypes(expected, actual types.Type) bool {
+	// Use a function's return type as its type.
+	if sig, ok := actual.(*types.Signature); ok {
+		if sig.Results().Len() == 1 {
+			actual = sig.Results().At(0).Type()
+		}
+	}
+	return types.Identical(types.Default(expected), types.Default(actual))
+}
+
+// exprAtPos returns the index of the expression containing pos.
+func exprAtPos(pos token.Pos, args []ast.Expr) int {
+	for i, expr := range args {
+		if expr.Pos() <= pos && pos <= expr.End() {
+			return i
+		}
+	}
+	return len(args)
+}
+
+// fieldSelections returns the set of fields that can
+// be selected from a value of type T.
+func fieldSelections(T types.Type) (fields []*types.Var) {
+	// TODO(adonovan): this algorithm doesn't exclude ambiguous
+	// selections that match more than one field/method.
+	// types.NewSelectionSet should do that for us.
+
+	seen := make(map[types.Type]bool) // for termination on recursive types
+	var visit func(T types.Type)
+	visit = func(T types.Type) {
+		if !seen[T] {
+			seen[T] = true
+			if T, ok := deref(T).Underlying().(*types.Struct); ok {
+				for i := 0; i < T.NumFields(); i++ {
+					f := T.Field(i)
+					fields = append(fields, f)
+					if f.Anonymous() {
+						visit(f.Type())
+					}
+				}
+			}
+		}
+	}
+	visit(T)
+
+	return fields
+}
+
+func isPointer(T types.Type) bool {
+	_, ok := T.(*types.Pointer)
+	return ok
+}
+
+// deref returns a pointer's element type; otherwise it returns typ.
+func deref(typ types.Type) types.Type {
+	if p, ok := typ.Underlying().(*types.Pointer); ok {
+		return p.Elem()
+	}
+	return typ
+}
+
+// resolveInvalid traverses the node of the AST that defines the scope
+// containing the declaration of obj, and attempts to find a user-friendly
+// name for its invalid type. The resulting Object and its Type are fake.
+func resolveInvalid(obj types.Object, node ast.Node, info *types.Info) types.Object {
+	// Construct a fake type for the object and return a fake object with this type.
+	formatResult := func(expr ast.Expr) types.Object {
+		var typename string
+		switch t := expr.(type) {
+		case *ast.SelectorExpr:
+			typename = fmt.Sprintf("%s.%s", t.X, t.Sel)
+		case *ast.Ident:
+			typename = t.String()
+		default:
+			return nil
+		}
+		typ := types.NewNamed(types.NewTypeName(token.NoPos, obj.Pkg(), typename, nil), nil, nil)
+		return types.NewVar(obj.Pos(), obj.Pkg(), obj.Name(), typ)
+	}
+	var resultExpr ast.Expr
+	ast.Inspect(node, func(node ast.Node) bool {
+		switch n := node.(type) {
+		case *ast.ValueSpec:
+			for _, name := range n.Names {
+				if info.Defs[name] == obj {
+					resultExpr = n.Type
+				}
+			}
+			return false
+		case *ast.Field: // This case handles parameters and results of a FuncDecl or FuncLit.
+			for _, name := range n.Names {
+				if info.Defs[name] == obj {
+					resultExpr = n.Type
+				}
+			}
+			return false
+		// TODO(rstambler): Handle range statements.
+		default:
+			return true
+		}
+	})
+	return formatResult(resultExpr)
+}
+
+type itemDetails struct {
+	label, detail string
+}
+
+var builtinDetails = map[string]itemDetails{
+	"append": { // append(slice []T, elems ...T)
+		label:  "append(slice []T, elems ...T)",
+		detail: "[]T",
+	},
+	"cap": { // cap(v []T) int
+		label:  "cap(v []T)",
+		detail: "int",
+	},
+	"close": { // close(c chan<- T)
+		label: "close(c chan<- T)",
+	},
+	"complex": { // complex(r, i float64) complex128
+		label:  "complex(real, imag float64)",
+		detail: "complex128",
+	},
+	"copy": { // copy(dst, src []T) int
+		label:  "copy(dst, src []T)",
+		detail: "int",
+	},
+	"delete": { // delete(m map[T]T1, key T)
+		label: "delete(m map[K]V, key K)",
+	},
+	"imag": { // imag(c complex128) float64
+		label:  "imag(complex128)",
+		detail: "float64",
+	},
+	"len": { // len(v T) int
+		label:  "len(T)",
+		detail: "int",
+	},
+	"make": { // make(t T, size ...int) T
+		label:  "make(t T, size ...int)",
+		detail: "T",
+	},
+	"new": { // new(T) *T
+		label:  "new(T)",
+		detail: "*T",
+	},
+	"panic": { // panic(v interface{})
+		label: "panic(interface{})",
+	},
+	"print": { // print(args ...T)
+		label: "print(args ...T)",
+	},
+	"println": { // println(args ...T)
+		label: "println(args ...T)",
+	},
+	"real": { // real(c complex128) float64
+		label:  "real(complex128)",
+		detail: "float64",
+	},
+	"recover": { // recover() interface{}
+		label:  "recover()",
+		detail: "interface{}",
+	},
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/source/definition.go b/vendor/golang.org/x/tools/internal/lsp/source/definition.go
new file mode 100644
index 00000000..0df2bd13
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/source/definition.go
@@ -0,0 +1,95 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package source
+
+import (
+	"context"
+	"fmt"
+	"go/ast"
+	"go/token"
+	"go/types"
+
+	"golang.org/x/tools/go/ast/astutil"
+)
+
+func Definition(ctx context.Context, f *File, pos token.Pos) (Range, error) {
+	fAST, err := f.GetAST()
+	if err != nil {
+		return Range{}, err
+	}
+	pkg, err := f.GetPackage()
+	if err != nil {
+		return Range{}, err
+	}
+	i, err := findIdentifier(fAST, pos)
+	if err != nil {
+		return Range{}, err
+	}
+	if i.ident == nil {
+		return Range{}, fmt.Errorf("definition was not a valid identifier")
+	}
+	obj := pkg.TypesInfo.ObjectOf(i.ident)
+	if obj == nil {
+		return Range{}, fmt.Errorf("no object")
+	}
+	if i.wasEmbeddedField {
+		// the original position was on the embedded field declaration
+		// so we try to dig out the type and jump to that instead
+		if v, ok := obj.(*types.Var); ok {
+			if n, ok := v.Type().(*types.Named); ok {
+				obj = n.Obj()
+			}
+		}
+	}
+	return Range{
+		Start: obj.Pos(),
+		End:   obj.Pos() + token.Pos(len([]byte(obj.Name()))), // TODO: use real range of obj
+	}, nil
+}
+
+// ident returns the ident plus any extra information needed
+type ident struct {
+	ident            *ast.Ident
+	wasEmbeddedField bool
+}
+
+// findIdentifier returns the ast.Ident for a position
+// in a file, accounting for a potentially incomplete selector.
+func findIdentifier(f *ast.File, pos token.Pos) (ident, error) {
+	m, err := checkIdentifier(f, pos)
+	if err != nil {
+		return ident{}, err
+	}
+	if m.ident != nil {
+		return m, nil
+	}
+	// If the position is not an identifier but immediately follows
+	// an identifier or selector period (as is common when
+	// requesting a completion), use the path to the preceding node.
+	return checkIdentifier(f, pos-1)
+}
+
+// checkIdentifier checks a single position for a potential identifier.
+func checkIdentifier(f *ast.File, pos token.Pos) (ident, error) {
+	path, _ := astutil.PathEnclosingInterval(f, pos, pos)
+	result := ident{}
+	if path == nil {
+		return result, fmt.Errorf("can't find node enclosing position")
+	}
+	switch node := path[0].(type) {
+	case *ast.Ident:
+		result.ident = node
+	case *ast.SelectorExpr:
+		result.ident = node.Sel
+	}
+	if result.ident != nil {
+		for _, n := range path[1:] {
+			if field, ok := n.(*ast.Field); ok {
+				result.wasEmbeddedField = len(field.Names) == 0
+			}
+		}
+	}
+	return result, nil
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/source/diagnostics.go b/vendor/golang.org/x/tools/internal/lsp/source/diagnostics.go
new file mode 100644
index 00000000..d1ecedb1
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/source/diagnostics.go
@@ -0,0 +1,148 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package source
+
+import (
+	"context"
+	"go/token"
+	"strconv"
+	"strings"
+
+	"golang.org/x/tools/go/packages"
+)
+
+type Diagnostic struct {
+	Range    Range
+	Severity DiagnosticSeverity
+	Message  string
+}
+
+type DiagnosticSeverity int
+
+const (
+	SeverityError DiagnosticSeverity = iota
+	SeverityWarning
+	SeverityHint
+	SeverityInformation
+)
+
+func Diagnostics(ctx context.Context, v *View, f *File) (map[string][]Diagnostic, error) {
+	pkg, err := f.GetPackage()
+	if err != nil {
+		return nil, err
+	}
+	// Prepare the reports we will send for this package.
+	reports := make(map[string][]Diagnostic)
+	for _, filename := range pkg.GoFiles {
+		reports[filename] = []Diagnostic{}
+	}
+	var parseErrors, typeErrors []packages.Error
+	for _, err := range pkg.Errors {
+		switch err.Kind {
+		case packages.ParseError:
+			parseErrors = append(parseErrors, err)
+		case packages.TypeError:
+			typeErrors = append(typeErrors, err)
+		default:
+			// ignore other types of errors
+			continue
+		}
+	}
+	// Don't report type errors if there are parse errors.
+	diags := typeErrors
+	if len(parseErrors) > 0 {
+		diags = parseErrors
+	}
+	for _, diag := range diags {
+		filename, start := v.errorPos(diag)
+		// TODO(rstambler): Add support for diagnostic ranges.
+		end := start
+		diagnostic := Diagnostic{
+			Range: Range{
+				Start: start,
+				End:   end,
+			},
+			Message:  diag.Msg,
+			Severity: SeverityError,
+		}
+		if _, ok := reports[filename]; ok {
+			reports[filename] = append(reports[filename], diagnostic)
+		}
+	}
+	return reports, nil
+}
+
+func (v *View) errorPos(pkgErr packages.Error) (string, token.Pos) {
+	remainder1, first, hasLine := chop(pkgErr.Pos)
+	remainder2, second, hasColumn := chop(remainder1)
+	var pos token.Position
+	if hasLine && hasColumn {
+		pos.Filename = remainder2
+		pos.Line = second
+		pos.Column = first
+	} else if hasLine {
+		pos.Filename = remainder1
+		pos.Line = first
+	}
+	f := v.GetFile(ToURI(pos.Filename))
+	if f == nil {
+		return "", token.NoPos
+	}
+	tok, err := f.GetToken()
+	if err != nil {
+		return "", token.NoPos
+	}
+	return pos.Filename, fromTokenPosition(tok, pos)
+}
+
+func chop(text string) (remainder string, value int, ok bool) {
+	i := strings.LastIndex(text, ":")
+	if i < 0 {
+		return text, 0, false
+	}
+	v, err := strconv.ParseInt(text[i+1:], 10, 64)
+	if err != nil {
+		return text, 0, false
+	}
+	return text[:i], int(v), true
+}
+
+// fromTokenPosition converts a token.Position (1-based line and column
+// number) to a token.Pos (byte offset value).
+// It requires the token file the pos belongs to in order to do this.
+func fromTokenPosition(f *token.File, pos token.Position) token.Pos {
+	line := lineStart(f, pos.Line)
+	return line + token.Pos(pos.Column-1) // TODO: this is wrong, bytes not characters
+}
+
+// this functionality was borrowed from the analysisutil package
+func lineStart(f *token.File, line int) token.Pos {
+	// Use binary search to find the start offset of this line.
+	//
+	// TODO(adonovan): eventually replace this function with the
+	// simpler and more efficient (*go/token.File).LineStart, added
+	// in go1.12.
+
+	min := 0        // inclusive
+	max := f.Size() // exclusive
+	for {
+		offset := (min + max) / 2
+		pos := f.Pos(offset)
+		posn := f.Position(pos)
+		if posn.Line == line {
+			return pos - (token.Pos(posn.Column) - 1)
+		}
+
+		if min+1 >= max {
+			return token.NoPos
+		}
+
+		if posn.Line < line {
+			min = offset
+		} else {
+			max = offset
+		}
+	}
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/source/file.go b/vendor/golang.org/x/tools/internal/lsp/source/file.go
new file mode 100644
index 00000000..dc7bd85e
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/source/file.go
@@ -0,0 +1,131 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package source
+
+import (
+	"fmt"
+	"go/ast"
+	"go/token"
+	"io/ioutil"
+
+	"golang.org/x/tools/go/packages"
+)
+
+// File holds all the information we know about a file.
+type File struct {
+	URI     URI
+	view    *View
+	active  bool
+	content []byte
+	ast     *ast.File
+	token   *token.File
+	pkg     *packages.Package
+}
+
+// Range represents a start and end position.
+// Because Range is based purely on two token.Pos entries, it is not self
+// contained. You need access to a token.FileSet to regain the file
+// information.
+type Range struct {
+	Start token.Pos
+	End   token.Pos
+}
+
+// TextEdit represents a change to a section of a document.
+// The text within the specified range should be replaced by the supplied new text.
+type TextEdit struct {
+	Range   Range
+	NewText string
+}
+
+// SetContent sets the overlay contents for a file.
+// Setting it to nil will revert it to the on disk contents, and remove it
+// from the active set.
+func (f *File) SetContent(content []byte) {
+	f.view.mu.Lock()
+	defer f.view.mu.Unlock()
+	f.content = content
+	// the ast and token fields are invalid
+	f.ast = nil
+	f.token = nil
+	f.pkg = nil
+	// and we might need to update the overlay
+	switch {
+	case f.active && content == nil:
+		// we were active, and want to forget the content
+		f.active = false
+		if filename, err := f.URI.Filename(); err == nil {
+			delete(f.view.Config.Overlay, filename)
+		}
+		f.content = nil
+	case content != nil:
+		// an active overlay, update the map
+		f.active = true
+		if filename, err := f.URI.Filename(); err == nil {
+			f.view.Config.Overlay[filename] = f.content
+		}
+	}
+}
+
+// Read returns the contents of the file, reading it from file system if needed.
+func (f *File) Read() ([]byte, error) {
+	f.view.mu.Lock()
+	defer f.view.mu.Unlock()
+	return f.read()
+}
+
+func (f *File) GetToken() (*token.File, error) {
+	f.view.mu.Lock()
+	defer f.view.mu.Unlock()
+	if f.token == nil {
+		if err := f.view.parse(f.URI); err != nil {
+			return nil, err
+		}
+		if f.token == nil {
+			return nil, fmt.Errorf("failed to find or parse %v", f.URI)
+		}
+	}
+	return f.token, nil
+}
+
+func (f *File) GetAST() (*ast.File, error) {
+	f.view.mu.Lock()
+	defer f.view.mu.Unlock()
+	if f.ast == nil {
+		if err := f.view.parse(f.URI); err != nil {
+			return nil, err
+		}
+	}
+	return f.ast, nil
+}
+
+func (f *File) GetPackage() (*packages.Package, error) {
+	f.view.mu.Lock()
+	defer f.view.mu.Unlock()
+	if f.pkg == nil {
+		if err := f.view.parse(f.URI); err != nil {
+			return nil, err
+		}
+	}
+	return f.pkg, nil
+}
+
+// read is the internal part of Read that presumes the lock is already held
+func (f *File) read() ([]byte, error) {
+	if f.content != nil {
+		return f.content, nil
+	}
+	// we don't know the content yet, so read it
+	filename, err := f.URI.Filename()
+	if err != nil {
+		return nil, err
+	}
+	content, err := ioutil.ReadFile(filename)
+	if err != nil {
+		return nil, err
+	}
+	f.content = content
+	return f.content, nil
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/source/format.go b/vendor/golang.org/x/tools/internal/lsp/source/format.go
new file mode 100644
index 00000000..c7b46d23
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/source/format.go
@@ -0,0 +1,59 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package source
+
+import (
+	"bytes"
+	"context"
+	"fmt"
+	"go/ast"
+	"go/format"
+
+	"golang.org/x/tools/go/ast/astutil"
+)
+
+// Format formats a document with a given range.
+func Format(ctx context.Context, f *File, rng Range) ([]TextEdit, error) {
+	fAST, err := f.GetAST()
+	if err != nil {
+		return nil, err
+	}
+	path, exact := astutil.PathEnclosingInterval(fAST, rng.Start, rng.End)
+	if !exact || len(path) == 0 {
+		return nil, fmt.Errorf("no exact AST node matching the specified range")
+	}
+	node := path[0]
+	// format.Node can fail when the AST contains a bad expression or
+	// statement. For now, we preemptively check for one.
+	// TODO(rstambler): This should really return an error from format.Node.
+	var isBad bool
+	ast.Inspect(node, func(n ast.Node) bool {
+		switch n.(type) {
+		case *ast.BadDecl, *ast.BadExpr, *ast.BadStmt:
+			isBad = true
+			return false
+		default:
+			return true
+		}
+	})
+	if isBad {
+		return nil, fmt.Errorf("unable to format file due to a badly formatted AST")
+	}
+	// format.Node changes slightly from one release to another, so the version
+	// of Go used to build the LSP server will determine how it formats code.
+	// This should be acceptable for all users, who likely be prompted to rebuild
+	// the LSP server on each Go release.
+	buf := &bytes.Buffer{}
+	if err := format.Node(buf, f.view.Config.Fset, node); err != nil {
+		return nil, err
+	}
+	// TODO(rstambler): Compute text edits instead of replacing whole file.
+	return []TextEdit{
+		{
+			Range:   rng,
+			NewText: buf.String(),
+		},
+	}, nil
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/source/signature_help.go b/vendor/golang.org/x/tools/internal/lsp/source/signature_help.go
new file mode 100644
index 00000000..ecccdd9f
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/source/signature_help.go
@@ -0,0 +1,118 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package source
+
+import (
+	"context"
+	"fmt"
+	"go/ast"
+	"go/token"
+	"go/types"
+
+	"golang.org/x/tools/go/ast/astutil"
+)
+
+type SignatureInformation struct {
+	Label           string
+	Parameters      []ParameterInformation
+	ActiveParameter int
+}
+
+type ParameterInformation struct {
+	Label string
+}
+
+func SignatureHelp(ctx context.Context, f *File, pos token.Pos) (*SignatureInformation, error) {
+	fAST, err := f.GetAST()
+	if err != nil {
+		return nil, err
+	}
+	pkg, err := f.GetPackage()
+	if err != nil {
+		return nil, err
+	}
+
+	// Find a call expression surrounding the query position.
+	var callExpr *ast.CallExpr
+	path, _ := astutil.PathEnclosingInterval(fAST, pos, pos)
+	if path == nil {
+		return nil, fmt.Errorf("cannot find node enclosing position")
+	}
+	for _, node := range path {
+		if c, ok := node.(*ast.CallExpr); ok {
+			callExpr = c
+			break
+		}
+	}
+	if callExpr == nil || callExpr.Fun == nil {
+		return nil, fmt.Errorf("cannot find an enclosing function")
+	}
+
+	// Get the type information for the function corresponding to the call expression.
+	var obj types.Object
+	switch t := callExpr.Fun.(type) {
+	case *ast.Ident:
+		obj = pkg.TypesInfo.ObjectOf(t)
+	case *ast.SelectorExpr:
+		obj = pkg.TypesInfo.ObjectOf(t.Sel)
+	default:
+		return nil, fmt.Errorf("the enclosing function is malformed")
+	}
+	if obj == nil {
+		return nil, fmt.Errorf("cannot resolve %s", callExpr.Fun)
+	}
+	// Find the signature corresponding to the object.
+	var sig *types.Signature
+	switch obj.(type) {
+	case *types.Var:
+		if underlying, ok := obj.Type().Underlying().(*types.Signature); ok {
+			sig = underlying
+		}
+	case *types.Func:
+		sig = obj.Type().(*types.Signature)
+	}
+	if sig == nil {
+		return nil, fmt.Errorf("no function signatures found for %s", obj.Name())
+	}
+	pkgStringer := qualifier(fAST, pkg.Types, pkg.TypesInfo)
+	var paramInfo []ParameterInformation
+	for i := 0; i < sig.Params().Len(); i++ {
+		param := sig.Params().At(i)
+		label := types.TypeString(param.Type(), pkgStringer)
+		if param.Name() != "" {
+			label = fmt.Sprintf("%s %s", param.Name(), label)
+		}
+		paramInfo = append(paramInfo, ParameterInformation{
+			Label: label,
+		})
+	}
+	// Determine the query position relative to the number of parameters in the function.
+	var activeParam int
+	var start, end token.Pos
+	for i, expr := range callExpr.Args {
+		if start == token.NoPos {
+			start = expr.Pos()
+		}
+		end = expr.End()
+		if i < len(callExpr.Args)-1 {
+			end = callExpr.Args[i+1].Pos() - 1 // comma
+		}
+		if start <= pos && pos <= end {
+			break
+		}
+		activeParam++
+		start = expr.Pos() + 1 // to account for commas
+	}
+	// Label for function, qualified by package name.
+	label := obj.Name()
+	if pkg := pkgStringer(obj.Pkg()); pkg != "" {
+		label = pkg + "." + label
+	}
+	return &SignatureInformation{
+		Label:           label + formatParams(sig.Params(), sig.Variadic(), pkgStringer),
+		Parameters:      paramInfo,
+		ActiveParameter: activeParam,
+	}, nil
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/source/uri.go b/vendor/golang.org/x/tools/internal/lsp/source/uri.go
new file mode 100644
index 00000000..59429292
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/source/uri.go
@@ -0,0 +1,47 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package source
+
+import (
+	"fmt"
+	"net/url"
+	"path/filepath"
+	"runtime"
+	"strings"
+)
+
+const fileSchemePrefix = "file://"
+
+// URI represents the full uri for a file.
+type URI string
+
+// Filename gets the file path for the URI.
+// It will return an error if the uri is not valid, or if the URI was not
+// a file URI
+func (uri URI) Filename() (string, error) {
+	s := string(uri)
+	if !strings.HasPrefix(s, fileSchemePrefix) {
+		return "", fmt.Errorf("only file URI's are supported, got %v", uri)
+	}
+	s = s[len(fileSchemePrefix):]
+	s, err := url.PathUnescape(s)
+	if err != nil {
+		return s, err
+	}
+	s = filepath.FromSlash(s)
+	return s, nil
+}
+
+// ToURI returns a protocol URI for the supplied path.
+// It will always have the file scheme.
+func ToURI(path string) URI {
+	const prefix = "$GOROOT"
+	if strings.EqualFold(prefix, path[:len(prefix)]) {
+		suffix := path[len(prefix):]
+		//TODO: we need a better way to get the GOROOT that uses the packages api
+		path = runtime.GOROOT() + suffix
+	}
+	return URI(fileSchemePrefix + filepath.ToSlash(path))
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/source/view.go b/vendor/golang.org/x/tools/internal/lsp/source/view.go
new file mode 100644
index 00000000..2433bce5
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/source/view.go
@@ -0,0 +1,82 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package source
+
+import (
+	"fmt"
+	"go/token"
+	"sync"
+
+	"golang.org/x/tools/go/packages"
+)
+
+type View struct {
+	mu sync.Mutex // protects all mutable state of the view
+
+	Config *packages.Config
+
+	files map[URI]*File
+}
+
+func NewView() *View {
+	return &View{
+		Config: &packages.Config{
+			Mode:    packages.LoadSyntax,
+			Fset:    token.NewFileSet(),
+			Tests:   true,
+			Overlay: make(map[string][]byte),
+		},
+		files: make(map[URI]*File),
+	}
+}
+
+// GetFile returns a File for the given uri.
+// It will always succeed, adding the file to the managed set if needed.
+func (v *View) GetFile(uri URI) *File {
+	v.mu.Lock()
+	f := v.getFile(uri)
+	v.mu.Unlock()
+	return f
+}
+
+// getFile is the unlocked internal implementation of GetFile.
+func (v *View) getFile(uri URI) *File {
+	f, found := v.files[uri]
+	if !found {
+		f = &File{
+			URI:  uri,
+			view: v,
+		}
+		v.files[f.URI] = f
+	}
+	return f
+}
+
+func (v *View) parse(uri URI) error {
+	path, err := uri.Filename()
+	if err != nil {
+		return err
+	}
+	pkgs, err := packages.Load(v.Config, fmt.Sprintf("file=%s", path))
+	if len(pkgs) == 0 {
+		if err == nil {
+			err = fmt.Errorf("no packages found for %s", path)
+		}
+		return err
+	}
+	for _, pkg := range pkgs {
+		// add everything we find to the files cache
+		for _, fAST := range pkg.Syntax {
+			// if a file was in multiple packages, which token/ast/pkg do we store
+			fToken := v.Config.Fset.File(fAST.Pos())
+			fURI := ToURI(fToken.Name())
+			f := v.getFile(fURI)
+			f.token = fToken
+			f.ast = fAST
+			f.pkg = pkg
+		}
+	}
+	return nil
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/bad/bad.go b/vendor/golang.org/x/tools/internal/lsp/testdata/bad/bad.go
new file mode 100644
index 00000000..8500d069
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/bad/bad.go
@@ -0,0 +1,21 @@
+// +build go1.11
+
+package bad
+
+func stuff() {
+	x := "heeeeyyyy"
+	random2(x) //@diag("x", "cannot use x (variable of type string) as int value in argument to random2")
+	random2(1)
+	y := 3 //@diag("y", "y declared but not used")
+}
+
+type bob struct {
+	x int
+}
+
+func _() {
+	var q int
+	_ = &bob{
+		f: q, //@diag("f", "unknown field f in struct literal")
+	}
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/bad/bad_util.go b/vendor/golang.org/x/tools/internal/lsp/testdata/bad/bad_util.go
new file mode 100644
index 00000000..f6a0e7d9
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/bad/bad_util.go
@@ -0,0 +1,8 @@
+// +build go1.11
+
+package bad
+
+func random2(y int) int {
+	x := 6 //@diag("x", "x declared but not used")
+	return y
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/bar/bar.go b/vendor/golang.org/x/tools/internal/lsp/testdata/bar/bar.go
new file mode 100644
index 00000000..f9f99af0
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/bar/bar.go
@@ -0,0 +1,7 @@
+package bar
+
+import "golang.org/x/tools/internal/lsp/foo"
+
+func Bar() {
+	foo.Foo()
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/baz/baz.go b/vendor/golang.org/x/tools/internal/lsp/testdata/baz/baz.go
new file mode 100644
index 00000000..3b95ee2f
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/baz/baz.go
@@ -0,0 +1,7 @@
+package baz
+
+import "golang.org/x/tools/internal/lsp/bar"
+
+func Baz() {
+	bar.Bar()
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/foo/foo.go b/vendor/golang.org/x/tools/internal/lsp/testdata/foo/foo.go
new file mode 100644
index 00000000..27c1b42c
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/foo/foo.go
@@ -0,0 +1,23 @@
+package foo
+
+type StructFoo struct { //@item(StructFoo, "StructFoo", "struct{...}", "struct")
+	Value int //@item(Value, "Value", "int", "field")
+}
+
+// TODO(rstambler): Create pre-set builtins?
+/* Error() */ //@item(Error, "Error()", "string", "method")
+
+func Foo() { //@item(Foo, "Foo()", "", "func")
+	var err error
+	err.Error() //@complete("E", Error)
+}
+
+func _() {
+	var sFoo StructFoo           //@complete("t", StructFoo)
+	if x := sFoo; x.Value == 1 { //@complete("V", Value)
+		return
+	}
+}
+
+//@complete("", Foo, IntFoo, StructFoo)
+type IntFoo int //@item(IntFoo, "IntFoo", "int", "type")
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/format/bad_format.go b/vendor/golang.org/x/tools/internal/lsp/testdata/format/bad_format.go
new file mode 100644
index 00000000..77f0861c
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/format/bad_format.go
@@ -0,0 +1,21 @@
+package format //@format("package")
+
+import (
+	"fmt"
+	"runtime"
+
+	"log"
+)
+
+func hello() {
+
+	var x int //@diag("x", "x declared but not used")
+}
+
+func hi() {
+
+	runtime.GOROOT()
+	fmt.Printf("")
+
+	log.Printf("")
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/format/good_format.go b/vendor/golang.org/x/tools/internal/lsp/testdata/format/good_format.go
new file mode 100644
index 00000000..01cb1610
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/format/good_format.go
@@ -0,0 +1,9 @@
+package format //@format("package")
+
+import (
+	"log"
+)
+
+func goodbye() {
+	log.Printf("byeeeee")
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/good/good.go b/vendor/golang.org/x/tools/internal/lsp/testdata/good/good.go
new file mode 100644
index 00000000..14b41e63
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/good/good.go
@@ -0,0 +1,6 @@
+package good
+
+func stuff() {
+	x := 5
+	random2(x)
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/good/good_util.go b/vendor/golang.org/x/tools/internal/lsp/testdata/good/good_util.go
new file mode 100644
index 00000000..ae71ad43
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/good/good_util.go
@@ -0,0 +1,10 @@
+package good
+
+func random() int {
+	y := 6 + 7
+	return y
+}
+
+func random2(y int) int {
+	return y
+}
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/noparse/noparse.go.in b/vendor/golang.org/x/tools/internal/lsp/testdata/noparse/noparse.go.in
new file mode 100644
index 00000000..9dede9c7
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/noparse/noparse.go.in
@@ -0,0 +1,11 @@
+package noparse
+
+func bye(x int) {
+	hi()
+}
+
+func stuff() {
+	x := 5
+}
+
+func .() {} //@diag(".", "expected 'IDENT', found '.'")
diff --git a/vendor/golang.org/x/tools/internal/lsp/testdata/noparse_format/noparse_format.go.in b/vendor/golang.org/x/tools/internal/lsp/testdata/noparse_format/noparse_format.go.in
new file mode 100644
index 00000000..eb2ad2e6
--- /dev/null
+++ b/vendor/golang.org/x/tools/internal/lsp/testdata/noparse_format/noparse_format.go.in
@@ -0,0 +1,9 @@
+// +build go1.11
+
+package noparse_format //@format("package")
+
+func what() {
+	var b int
+	if {		hi() //@diag("{", "missing condition in if statement")
+	}
+}
\ No newline at end of file
diff --git a/vendor/golang.org/x/tools/internal/lsp/view.go b/vendor/golang.org/x/tools/internal/lsp/view.go
deleted file mode 100644
index 825981fc..00000000
--- a/vendor/golang.org/x/tools/internal/lsp/view.go
+++ /dev/null
@@ -1,78 +0,0 @@
-package lsp
-
-import (
-	"fmt"
-	"go/token"
-	"strings"
-	"sync"
-
-	"golang.org/x/tools/go/packages"
-	"golang.org/x/tools/internal/lsp/protocol"
-)
-
-type view struct {
-	activeFilesMu sync.Mutex
-	activeFiles   map[protocol.DocumentURI][]byte
-
-	fset *token.FileSet
-}
-
-func newView() *view {
-	return &view{
-		activeFiles: make(map[protocol.DocumentURI][]byte),
-		fset:        token.NewFileSet(),
-	}
-}
-
-func (v *view) overlay() map[string][]byte {
-	over := make(map[string][]byte)
-
-	v.activeFilesMu.Lock()
-	defer v.activeFilesMu.Unlock()
-
-	for uri, content := range v.activeFiles {
-		over[uriToFilename(uri)] = content
-	}
-	return over
-}
-
-func (v *view) readActiveFile(uri protocol.DocumentURI) ([]byte, error) {
-	v.activeFilesMu.Lock()
-	defer v.activeFilesMu.Unlock()
-
-	content, ok := v.activeFiles[uri]
-	if !ok {
-		return nil, fmt.Errorf("file not found: %s", uri)
-	}
-	return content, nil
-}
-
-func (v *view) clearActiveFile(uri protocol.DocumentURI) {
-	v.activeFilesMu.Lock()
-	delete(v.activeFiles, uri)
-	v.activeFilesMu.Unlock()
-}
-
-// typeCheck type-checks the package for the given package path.
-func (v *view) typeCheck(uri protocol.DocumentURI) (*packages.Package, error) {
-	cfg := &packages.Config{
-		Mode:    packages.LoadSyntax,
-		Fset:    v.fset,
-		Overlay: v.overlay(),
-		Tests:   true,
-	}
-	pkgs, err := packages.Load(cfg, fmt.Sprintf("file=%s", uriToFilename(uri)))
-	if len(pkgs) == 0 {
-		return nil, err
-	}
-	pkg := pkgs[0]
-	return pkg, nil
-}
-
-func uriToFilename(uri protocol.DocumentURI) string {
-	return strings.TrimPrefix(string(uri), "file://")
-}
-
-func filenameToURI(filename string) protocol.DocumentURI {
-	return protocol.DocumentURI("file://" + filename)
-}
diff --git a/vendor/google.golang.org/appengine/.travis.yml b/vendor/google.golang.org/appengine/.travis.yml
index 7ef8b6c7..70ffe89d 100644
--- a/vendor/google.golang.org/appengine/.travis.yml
+++ b/vendor/google.golang.org/appengine/.travis.yml
@@ -1,24 +1,20 @@
 language: go
 
-go:
-  - 1.6.x
-  - 1.7.x
-  - 1.8.x
-  - 1.9.x
-
 go_import_path: google.golang.org/appengine
 
 install:
-  - go get -u -v $(go list -f '{{join .Imports "\n"}}{{"\n"}}{{join .TestImports "\n"}}' ./... | sort | uniq | grep -v appengine)
-  - mkdir /tmp/sdk
-  - curl -o /tmp/sdk.zip "https://storage.googleapis.com/appengine-sdks/featured/go_appengine_sdk_linux_amd64-1.9.40.zip"
-  - unzip -q /tmp/sdk.zip -d /tmp/sdk
-  - export PATH="$PATH:/tmp/sdk/go_appengine"
-  - export APPENGINE_DEV_APPSERVER=/tmp/sdk/go_appengine/dev_appserver.py
+  - ./travis_install.sh
 
 script:
-  - goapp version
-  - go version
-  - go test -v google.golang.org/appengine/...
-  - go test -v -race google.golang.org/appengine/...
-  - goapp test -v google.golang.org/appengine/...
+  - ./travis_test.sh
+
+matrix:
+  include:
+    - go: 1.8.x
+      env: GOAPP=true
+    - go: 1.9.x
+      env: GOAPP=true
+    - go: 1.10.x
+      env: GOAPP=false
+    - go: 1.11.x
+      env: GO111MODULE=on
diff --git a/vendor/google.golang.org/appengine/appengine.go b/vendor/google.golang.org/appengine/appengine.go
index 76dedc81..79525454 100644
--- a/vendor/google.golang.org/appengine/appengine.go
+++ b/vendor/google.golang.org/appengine/appengine.go
@@ -60,6 +60,24 @@ func IsDevAppServer() bool {
 	return internal.IsDevAppServer()
 }
 
+// IsStandard reports whether the App Engine app is running in the standard
+// environment. This includes both the first generation runtimes (<= Go 1.9)
+// and the second generation runtimes (>= Go 1.11).
+func IsStandard() bool {
+	return internal.IsStandard()
+}
+
+// IsFlex reports whether the App Engine app is running in the flexible environment.
+func IsFlex() bool {
+	return internal.IsFlex()
+}
+
+// IsAppEngine reports whether the App Engine app is running on App Engine, in either
+// the standard or flexible environment.
+func IsAppEngine() bool {
+	return internal.IsAppEngine()
+}
+
 // NewContext returns a context for an in-flight HTTP request.
 // This function is cheap.
 func NewContext(req *http.Request) context.Context {
diff --git a/vendor/google.golang.org/appengine/delay/delay.go b/vendor/google.golang.org/appengine/delay/delay.go
index 52915a42..2809f427 100644
--- a/vendor/google.golang.org/appengine/delay/delay.go
+++ b/vendor/google.golang.org/appengine/delay/delay.go
@@ -46,6 +46,7 @@ package delay // import "google.golang.org/appengine/delay"
 
 import (
 	"bytes"
+	stdctx "context"
 	"encoding/gob"
 	"errors"
 	"fmt"
@@ -89,8 +90,14 @@ var (
 
 	// context keys
 	headersContextKey contextKey = 0
+	stdContextType               = reflect.TypeOf((*stdctx.Context)(nil)).Elem()
+	netContextType               = reflect.TypeOf((*context.Context)(nil)).Elem()
 )
 
+func isContext(t reflect.Type) bool {
+	return t == stdContextType || t == netContextType
+}
+
 // Func declares a new Function. The second argument must be a function with a
 // first argument of type context.Context.
 // This function must be called at program initialization time. That means it
diff --git a/vendor/google.golang.org/appengine/delay/delay_go17.go b/vendor/google.golang.org/appengine/delay/delay_go17.go
deleted file mode 100644
index 9a59e8b0..00000000
--- a/vendor/google.golang.org/appengine/delay/delay_go17.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright 2017 Google Inc. All rights reserved.
-// Use of this source code is governed by the Apache 2.0
-// license that can be found in the LICENSE file.
-
-//+build go1.7
-
-package delay
-
-import (
-	stdctx "context"
-	"reflect"
-
-	netctx "golang.org/x/net/context"
-)
-
-var (
-	stdContextType = reflect.TypeOf((*stdctx.Context)(nil)).Elem()
-	netContextType = reflect.TypeOf((*netctx.Context)(nil)).Elem()
-)
-
-func isContext(t reflect.Type) bool {
-	return t == stdContextType || t == netContextType
-}
diff --git a/vendor/google.golang.org/appengine/delay/delay_go17_test.go b/vendor/google.golang.org/appengine/delay/delay_go17_test.go
deleted file mode 100644
index 0e708d00..00000000
--- a/vendor/google.golang.org/appengine/delay/delay_go17_test.go
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright 2017 Google Inc. All rights reserved.
-// Use of this source code is governed by the Apache 2.0
-// license that can be found in the LICENSE file.
-
-//+build go1.7
-
-package delay
-
-import (
-	"bytes"
-	stdctx "context"
-	"net/http"
-	"net/http/httptest"
-	"testing"
-
-	netctx "golang.org/x/net/context"
-	"google.golang.org/appengine/taskqueue"
-)
-
-var (
-	stdCtxRuns = 0
-	stdCtxFunc = Func("stdctx", func(c stdctx.Context) {
-		stdCtxRuns++
-	})
-)
-
-func TestStandardContext(t *testing.T) {
-	// Fake out the adding of a task.
-	var task *taskqueue.Task
-	taskqueueAdder = func(_ netctx.Context, tk *taskqueue.Task, queue string) (*taskqueue.Task, error) {
-		if queue != "" {
-			t.Errorf(`Got queue %q, expected ""`, queue)
-		}
-		task = tk
-		return tk, nil
-	}
-
-	c := newFakeContext()
-	stdCtxRuns = 0 // reset state
-	if err := stdCtxFunc.Call(c.ctx); err != nil {
-		t.Fatal("Function.Call:", err)
-	}
-
-	// Simulate the Task Queue service.
-	req, err := http.NewRequest("POST", path, bytes.NewBuffer(task.Payload))
-	if err != nil {
-		t.Fatalf("Failed making http.Request: %v", err)
-	}
-	rw := httptest.NewRecorder()
-	runFunc(c.ctx, rw, req)
-
-	if stdCtxRuns != 1 {
-		t.Errorf("stdCtxRuns: got %d, want 1", stdCtxRuns)
-	}
-}
diff --git a/vendor/google.golang.org/appengine/delay/delay_pre17.go b/vendor/google.golang.org/appengine/delay/delay_pre17.go
deleted file mode 100644
index d30c75df..00000000
--- a/vendor/google.golang.org/appengine/delay/delay_pre17.go
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2017 Google Inc. All rights reserved.
-// Use of this source code is governed by the Apache 2.0
-// license that can be found in the LICENSE file.
-
-//+build !go1.7
-
-package delay
-
-import (
-	"reflect"
-
-	"golang.org/x/net/context"
-)
-
-var contextType = reflect.TypeOf((*context.Context)(nil)).Elem()
-
-func isContext(t reflect.Type) bool {
-	return t == contextType
-}
diff --git a/vendor/google.golang.org/appengine/delay/delay_test.go b/vendor/google.golang.org/appengine/delay/delay_test.go
index 3df2bf7e..1cb9609c 100644
--- a/vendor/google.golang.org/appengine/delay/delay_test.go
+++ b/vendor/google.golang.org/appengine/delay/delay_test.go
@@ -6,6 +6,7 @@ package delay
 
 import (
 	"bytes"
+	stdctx "context"
 	"encoding/gob"
 	"errors"
 	"fmt"
@@ -102,6 +103,11 @@ var (
 		reqFuncRuns++
 		reqFuncHeaders, reqFuncErr = RequestHeaders(c)
 	})
+
+	stdCtxRuns = 0
+	stdCtxFunc = Func("stdctx", func(c stdctx.Context) {
+		stdCtxRuns++
+	})
 )
 
 type fakeContext struct {
@@ -426,3 +432,33 @@ func TestGetRequestHeadersFromContext(t *testing.T) {
 		t.Errorf("reqFuncErr: got %v, want nil", reqFuncErr)
 	}
 }
+
+func TestStandardContext(t *testing.T) {
+	// Fake out the adding of a task.
+	var task *taskqueue.Task
+	taskqueueAdder = func(_ context.Context, tk *taskqueue.Task, queue string) (*taskqueue.Task, error) {
+		if queue != "" {
+			t.Errorf(`Got queue %q, expected ""`, queue)
+		}
+		task = tk
+		return tk, nil
+	}
+
+	c := newFakeContext()
+	stdCtxRuns = 0 // reset state
+	if err := stdCtxFunc.Call(c.ctx); err != nil {
+		t.Fatal("Function.Call:", err)
+	}
+
+	// Simulate the Task Queue service.
+	req, err := http.NewRequest("POST", path, bytes.NewBuffer(task.Payload))
+	if err != nil {
+		t.Fatalf("Failed making http.Request: %v", err)
+	}
+	rw := httptest.NewRecorder()
+	runFunc(c.ctx, rw, req)
+
+	if stdCtxRuns != 1 {
+		t.Errorf("stdCtxRuns: got %d, want 1", stdCtxRuns)
+	}
+}
diff --git a/vendor/google.golang.org/appengine/go.sum b/vendor/google.golang.org/appengine/go.sum
index 5e644c2e..1a221c08 100644
--- a/vendor/google.golang.org/appengine/go.sum
+++ b/vendor/google.golang.org/appengine/go.sum
@@ -1,3 +1,6 @@
+github.com/golang/protobuf v1.2.0 h1:P3YflyNX/ehuJFLhxviNdFxQPkGK5cDcApsge1SqnvM=
 github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
+golang.org/x/net v0.0.0-20180724234803-3673e40ba225 h1:kNX+jCowfMYzvlSvJu5pQWEmyWFrBXJ3PBy10xKMXK8=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
+golang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
diff --git a/vendor/google.golang.org/appengine/internal/api.go b/vendor/google.golang.org/appengine/internal/api.go
index 16f87c5d..c9514952 100644
--- a/vendor/google.golang.org/appengine/internal/api.go
+++ b/vendor/google.golang.org/appengine/internal/api.go
@@ -3,7 +3,6 @@
 // license that can be found in the LICENSE file.
 
 // +build !appengine
-// +build go1.7
 
 package internal
 
@@ -130,7 +129,13 @@ func handleHTTP(w http.ResponseWriter, r *http.Request) {
 		flushes++
 	}
 	c.pendingLogs.Unlock()
-	go c.flushLog(false)
+	flushed := make(chan struct{})
+	go func() {
+		defer close(flushed)
+		// Force a log flush, because with very short requests we
+		// may not ever flush logs.
+		c.flushLog(true)
+	}()
 	w.Header().Set(logFlushHeader, strconv.Itoa(flushes))
 
 	// Avoid nil Write call if c.Write is never called.
@@ -140,6 +145,9 @@ func handleHTTP(w http.ResponseWriter, r *http.Request) {
 	if c.outBody != nil {
 		w.Write(c.outBody)
 	}
+	// Wait for the last flush to complete before returning,
+	// otherwise the security ticket will not be valid.
+	<-flushed
 }
 
 func executeRequestSafely(c *context, r *http.Request) {
diff --git a/vendor/google.golang.org/appengine/internal/api_pre17.go b/vendor/google.golang.org/appengine/internal/api_pre17.go
deleted file mode 100644
index 028b4f05..00000000
--- a/vendor/google.golang.org/appengine/internal/api_pre17.go
+++ /dev/null
@@ -1,682 +0,0 @@
-// Copyright 2011 Google Inc. All rights reserved.
-// Use of this source code is governed by the Apache 2.0
-// license that can be found in the LICENSE file.
-
-// +build !appengine
-// +build !go1.7
-
-package internal
-
-import (
-	"bytes"
-	"errors"
-	"fmt"
-	"io/ioutil"
-	"log"
-	"net"
-	"net/http"
-	"net/url"
-	"os"
-	"runtime"
-	"strconv"
-	"strings"
-	"sync"
-	"sync/atomic"
-	"time"
-
-	"github.com/golang/protobuf/proto"
-	netcontext "golang.org/x/net/context"
-
-	basepb "google.golang.org/appengine/internal/base"
-	logpb "google.golang.org/appengine/internal/log"
-	remotepb "google.golang.org/appengine/internal/remote_api"
-)
-
-const (
-	apiPath             = "/rpc_http"
-	defaultTicketSuffix = "/default.20150612t184001.0"
-)
-
-var (
-	// Incoming headers.
-	ticketHeader       = http.CanonicalHeaderKey("X-AppEngine-API-Ticket")
-	dapperHeader       = http.CanonicalHeaderKey("X-Google-DapperTraceInfo")
-	traceHeader        = http.CanonicalHeaderKey("X-Cloud-Trace-Context")
-	curNamespaceHeader = http.CanonicalHeaderKey("X-AppEngine-Current-Namespace")
-	userIPHeader       = http.CanonicalHeaderKey("X-AppEngine-User-IP")
-	remoteAddrHeader   = http.CanonicalHeaderKey("X-AppEngine-Remote-Addr")
-
-	// Outgoing headers.
-	apiEndpointHeader      = http.CanonicalHeaderKey("X-Google-RPC-Service-Endpoint")
-	apiEndpointHeaderValue = []string{"app-engine-apis"}
-	apiMethodHeader        = http.CanonicalHeaderKey("X-Google-RPC-Service-Method")
-	apiMethodHeaderValue   = []string{"/VMRemoteAPI.CallRemoteAPI"}
-	apiDeadlineHeader      = http.CanonicalHeaderKey("X-Google-RPC-Service-Deadline")
-	apiContentType         = http.CanonicalHeaderKey("Content-Type")
-	apiContentTypeValue    = []string{"application/octet-stream"}
-	logFlushHeader         = http.CanonicalHeaderKey("X-AppEngine-Log-Flush-Count")
-
-	apiHTTPClient = &http.Client{
-		Transport: &http.Transport{
-			Proxy: http.ProxyFromEnvironment,
-			Dial:  limitDial,
-		},
-	}
-
-	defaultTicketOnce sync.Once
-	defaultTicket     string
-)
-
-func apiURL() *url.URL {
-	host, port := "appengine.googleapis.internal", "10001"
-	if h := os.Getenv("API_HOST"); h != "" {
-		host = h
-	}
-	if p := os.Getenv("API_PORT"); p != "" {
-		port = p
-	}
-	return &url.URL{
-		Scheme: "http",
-		Host:   host + ":" + port,
-		Path:   apiPath,
-	}
-}
-
-func handleHTTP(w http.ResponseWriter, r *http.Request) {
-	c := &context{
-		req:       r,
-		outHeader: w.Header(),
-		apiURL:    apiURL(),
-	}
-	stopFlushing := make(chan int)
-
-	ctxs.Lock()
-	ctxs.m[r] = c
-	ctxs.Unlock()
-	defer func() {
-		ctxs.Lock()
-		delete(ctxs.m, r)
-		ctxs.Unlock()
-	}()
-
-	// Patch up RemoteAddr so it looks reasonable.
-	if addr := r.Header.Get(userIPHeader); addr != "" {
-		r.RemoteAddr = addr
-	} else if addr = r.Header.Get(remoteAddrHeader); addr != "" {
-		r.RemoteAddr = addr
-	} else {
-		// Should not normally reach here, but pick a sensible default anyway.
-		r.RemoteAddr = "127.0.0.1"
-	}
-	// The address in the headers will most likely be of these forms:
-	//	123.123.123.123
-	//	2001:db8::1
-	// net/http.Request.RemoteAddr is specified to be in "IP:port" form.
-	if _, _, err := net.SplitHostPort(r.RemoteAddr); err != nil {
-		// Assume the remote address is only a host; add a default port.
-		r.RemoteAddr = net.JoinHostPort(r.RemoteAddr, "80")
-	}
-
-	// Start goroutine responsible for flushing app logs.
-	// This is done after adding c to ctx.m (and stopped before removing it)
-	// because flushing logs requires making an API call.
-	go c.logFlusher(stopFlushing)
-
-	executeRequestSafely(c, r)
-	c.outHeader = nil // make sure header changes aren't respected any more
-
-	stopFlushing <- 1 // any logging beyond this point will be dropped
-
-	// Flush any pending logs asynchronously.
-	c.pendingLogs.Lock()
-	flushes := c.pendingLogs.flushes
-	if len(c.pendingLogs.lines) > 0 {
-		flushes++
-	}
-	c.pendingLogs.Unlock()
-	go c.flushLog(false)
-	w.Header().Set(logFlushHeader, strconv.Itoa(flushes))
-
-	// Avoid nil Write call if c.Write is never called.
-	if c.outCode != 0 {
-		w.WriteHeader(c.outCode)
-	}
-	if c.outBody != nil {
-		w.Write(c.outBody)
-	}
-}
-
-func executeRequestSafely(c *context, r *http.Request) {
-	defer func() {
-		if x := recover(); x != nil {
-			logf(c, 4, "%s", renderPanic(x)) // 4 == critical
-			c.outCode = 500
-		}
-	}()
-
-	http.DefaultServeMux.ServeHTTP(c, r)
-}
-
-func renderPanic(x interface{}) string {
-	buf := make([]byte, 16<<10) // 16 KB should be plenty
-	buf = buf[:runtime.Stack(buf, false)]
-
-	// Remove the first few stack frames:
-	//   this func
-	//   the recover closure in the caller
-	// That will root the stack trace at the site of the panic.
-	const (
-		skipStart  = "internal.renderPanic"
-		skipFrames = 2
-	)
-	start := bytes.Index(buf, []byte(skipStart))
-	p := start
-	for i := 0; i < skipFrames*2 && p+1 < len(buf); i++ {
-		p = bytes.IndexByte(buf[p+1:], '\n') + p + 1
-		if p < 0 {
-			break
-		}
-	}
-	if p >= 0 {
-		// buf[start:p+1] is the block to remove.
-		// Copy buf[p+1:] over buf[start:] and shrink buf.
-		copy(buf[start:], buf[p+1:])
-		buf = buf[:len(buf)-(p+1-start)]
-	}
-
-	// Add panic heading.
-	head := fmt.Sprintf("panic: %v\n\n", x)
-	if len(head) > len(buf) {
-		// Extremely unlikely to happen.
-		return head
-	}
-	copy(buf[len(head):], buf)
-	copy(buf, head)
-
-	return string(buf)
-}
-
-var ctxs = struct {
-	sync.Mutex
-	m  map[*http.Request]*context
-	bg *context // background context, lazily initialized
-	// dec is used by tests to decorate the netcontext.Context returned
-	// for a given request. This allows tests to add overrides (such as
-	// WithAppIDOverride) to the context. The map is nil outside tests.
-	dec map[*http.Request]func(netcontext.Context) netcontext.Context
-}{
-	m: make(map[*http.Request]*context),
-}
-
-// context represents the context of an in-flight HTTP request.
-// It implements the appengine.Context and http.ResponseWriter interfaces.
-type context struct {
-	req *http.Request
-
-	outCode   int
-	outHeader http.Header
-	outBody   []byte
-
-	pendingLogs struct {
-		sync.Mutex
-		lines   []*logpb.UserAppLogLine
-		flushes int
-	}
-
-	apiURL *url.URL
-}
-
-var contextKey = "holds a *context"
-
-// fromContext returns the App Engine context or nil if ctx is not
-// derived from an App Engine context.
-func fromContext(ctx netcontext.Context) *context {
-	c, _ := ctx.Value(&contextKey).(*context)
-	return c
-}
-
-func withContext(parent netcontext.Context, c *context) netcontext.Context {
-	ctx := netcontext.WithValue(parent, &contextKey, c)
-	if ns := c.req.Header.Get(curNamespaceHeader); ns != "" {
-		ctx = withNamespace(ctx, ns)
-	}
-	return ctx
-}
-
-func toContext(c *context) netcontext.Context {
-	return withContext(netcontext.Background(), c)
-}
-
-func IncomingHeaders(ctx netcontext.Context) http.Header {
-	if c := fromContext(ctx); c != nil {
-		return c.req.Header
-	}
-	return nil
-}
-
-func ReqContext(req *http.Request) netcontext.Context {
-	return WithContext(netcontext.Background(), req)
-}
-
-func WithContext(parent netcontext.Context, req *http.Request) netcontext.Context {
-	ctxs.Lock()
-	c := ctxs.m[req]
-	d := ctxs.dec[req]
-	ctxs.Unlock()
-
-	if d != nil {
-		parent = d(parent)
-	}
-
-	if c == nil {
-		// Someone passed in an http.Request that is not in-flight.
-		// We panic here rather than panicking at a later point
-		// so that stack traces will be more sensible.
-		log.Panic("appengine: NewContext passed an unknown http.Request")
-	}
-	return withContext(parent, c)
-}
-
-// DefaultTicket returns a ticket used for background context or dev_appserver.
-func DefaultTicket() string {
-	defaultTicketOnce.Do(func() {
-		if IsDevAppServer() {
-			defaultTicket = "testapp" + defaultTicketSuffix
-			return
-		}
-		appID := partitionlessAppID()
-		escAppID := strings.Replace(strings.Replace(appID, ":", "_", -1), ".", "_", -1)
-		majVersion := VersionID(nil)
-		if i := strings.Index(majVersion, "."); i > 0 {
-			majVersion = majVersion[:i]
-		}
-		defaultTicket = fmt.Sprintf("%s/%s.%s.%s", escAppID, ModuleName(nil), majVersion, InstanceID())
-	})
-	return defaultTicket
-}
-
-func BackgroundContext() netcontext.Context {
-	ctxs.Lock()
-	defer ctxs.Unlock()
-
-	if ctxs.bg != nil {
-		return toContext(ctxs.bg)
-	}
-
-	// Compute background security ticket.
-	ticket := DefaultTicket()
-
-	ctxs.bg = &context{
-		req: &http.Request{
-			Header: http.Header{
-				ticketHeader: []string{ticket},
-			},
-		},
-		apiURL: apiURL(),
-	}
-
-	// TODO(dsymonds): Wire up the shutdown handler to do a final flush.
-	go ctxs.bg.logFlusher(make(chan int))
-
-	return toContext(ctxs.bg)
-}
-
-// RegisterTestRequest registers the HTTP request req for testing, such that
-// any API calls are sent to the provided URL. It returns a closure to delete
-// the registration.
-// It should only be used by aetest package.
-func RegisterTestRequest(req *http.Request, apiURL *url.URL, decorate func(netcontext.Context) netcontext.Context) (*http.Request, func()) {
-	c := &context{
-		req:    req,
-		apiURL: apiURL,
-	}
-	ctxs.Lock()
-	defer ctxs.Unlock()
-	if _, ok := ctxs.m[req]; ok {
-		log.Panic("req already associated with context")
-	}
-	if _, ok := ctxs.dec[req]; ok {
-		log.Panic("req already associated with context")
-	}
-	if ctxs.dec == nil {
-		ctxs.dec = make(map[*http.Request]func(netcontext.Context) netcontext.Context)
-	}
-	ctxs.m[req] = c
-	ctxs.dec[req] = decorate
-
-	return req, func() {
-		ctxs.Lock()
-		delete(ctxs.m, req)
-		delete(ctxs.dec, req)
-		ctxs.Unlock()
-	}
-}
-
-var errTimeout = &CallError{
-	Detail:  "Deadline exceeded",
-	Code:    int32(remotepb.RpcError_CANCELLED),
-	Timeout: true,
-}
-
-func (c *context) Header() http.Header { return c.outHeader }
-
-// Copied from $GOROOT/src/pkg/net/http/transfer.go. Some response status
-// codes do not permit a response body (nor response entity headers such as
-// Content-Length, Content-Type, etc).
-func bodyAllowedForStatus(status int) bool {
-	switch {
-	case status >= 100 && status <= 199:
-		return false
-	case status == 204:
-		return false
-	case status == 304:
-		return false
-	}
-	return true
-}
-
-func (c *context) Write(b []byte) (int, error) {
-	if c.outCode == 0 {
-		c.WriteHeader(http.StatusOK)
-	}
-	if len(b) > 0 && !bodyAllowedForStatus(c.outCode) {
-		return 0, http.ErrBodyNotAllowed
-	}
-	c.outBody = append(c.outBody, b...)
-	return len(b), nil
-}
-
-func (c *context) WriteHeader(code int) {
-	if c.outCode != 0 {
-		logf(c, 3, "WriteHeader called multiple times on request.") // error level
-		return
-	}
-	c.outCode = code
-}
-
-func (c *context) post(body []byte, timeout time.Duration) (b []byte, err error) {
-	hreq := &http.Request{
-		Method: "POST",
-		URL:    c.apiURL,
-		Header: http.Header{
-			apiEndpointHeader: apiEndpointHeaderValue,
-			apiMethodHeader:   apiMethodHeaderValue,
-			apiContentType:    apiContentTypeValue,
-			apiDeadlineHeader: []string{strconv.FormatFloat(timeout.Seconds(), 'f', -1, 64)},
-		},
-		Body:          ioutil.NopCloser(bytes.NewReader(body)),
-		ContentLength: int64(len(body)),
-		Host:          c.apiURL.Host,
-	}
-	if info := c.req.Header.Get(dapperHeader); info != "" {
-		hreq.Header.Set(dapperHeader, info)
-	}
-	if info := c.req.Header.Get(traceHeader); info != "" {
-		hreq.Header.Set(traceHeader, info)
-	}
-
-	tr := apiHTTPClient.Transport.(*http.Transport)
-
-	var timedOut int32 // atomic; set to 1 if timed out
-	t := time.AfterFunc(timeout, func() {
-		atomic.StoreInt32(&timedOut, 1)
-		tr.CancelRequest(hreq)
-	})
-	defer t.Stop()
-	defer func() {
-		// Check if timeout was exceeded.
-		if atomic.LoadInt32(&timedOut) != 0 {
-			err = errTimeout
-		}
-	}()
-
-	hresp, err := apiHTTPClient.Do(hreq)
-	if err != nil {
-		return nil, &CallError{
-			Detail: fmt.Sprintf("service bridge HTTP failed: %v", err),
-			Code:   int32(remotepb.RpcError_UNKNOWN),
-		}
-	}
-	defer hresp.Body.Close()
-	hrespBody, err := ioutil.ReadAll(hresp.Body)
-	if hresp.StatusCode != 200 {
-		return nil, &CallError{
-			Detail: fmt.Sprintf("service bridge returned HTTP %d (%q)", hresp.StatusCode, hrespBody),
-			Code:   int32(remotepb.RpcError_UNKNOWN),
-		}
-	}
-	if err != nil {
-		return nil, &CallError{
-			Detail: fmt.Sprintf("service bridge response bad: %v", err),
-			Code:   int32(remotepb.RpcError_UNKNOWN),
-		}
-	}
-	return hrespBody, nil
-}
-
-func Call(ctx netcontext.Context, service, method string, in, out proto.Message) error {
-	if ns := NamespaceFromContext(ctx); ns != "" {
-		if fn, ok := NamespaceMods[service]; ok {
-			fn(in, ns)
-		}
-	}
-
-	if f, ctx, ok := callOverrideFromContext(ctx); ok {
-		return f(ctx, service, method, in, out)
-	}
-
-	// Handle already-done contexts quickly.
-	select {
-	case <-ctx.Done():
-		return ctx.Err()
-	default:
-	}
-
-	c := fromContext(ctx)
-	if c == nil {
-		// Give a good error message rather than a panic lower down.
-		return errNotAppEngineContext
-	}
-
-	// Apply transaction modifications if we're in a transaction.
-	if t := transactionFromContext(ctx); t != nil {
-		if t.finished {
-			return errors.New("transaction context has expired")
-		}
-		applyTransaction(in, &t.transaction)
-	}
-
-	// Default RPC timeout is 60s.
-	timeout := 60 * time.Second
-	if deadline, ok := ctx.Deadline(); ok {
-		timeout = deadline.Sub(time.Now())
-	}
-
-	data, err := proto.Marshal(in)
-	if err != nil {
-		return err
-	}
-
-	ticket := c.req.Header.Get(ticketHeader)
-	// Use a test ticket under test environment.
-	if ticket == "" {
-		if appid := ctx.Value(&appIDOverrideKey); appid != nil {
-			ticket = appid.(string) + defaultTicketSuffix
-		}
-	}
-	// Fall back to use background ticket when the request ticket is not available in Flex or dev_appserver.
-	if ticket == "" {
-		ticket = DefaultTicket()
-	}
-	req := &remotepb.Request{
-		ServiceName: &service,
-		Method:      &method,
-		Request:     data,
-		RequestId:   &ticket,
-	}
-	hreqBody, err := proto.Marshal(req)
-	if err != nil {
-		return err
-	}
-
-	hrespBody, err := c.post(hreqBody, timeout)
-	if err != nil {
-		return err
-	}
-
-	res := &remotepb.Response{}
-	if err := proto.Unmarshal(hrespBody, res); err != nil {
-		return err
-	}
-	if res.RpcError != nil {
-		ce := &CallError{
-			Detail: res.RpcError.GetDetail(),
-			Code:   *res.RpcError.Code,
-		}
-		switch remotepb.RpcError_ErrorCode(ce.Code) {
-		case remotepb.RpcError_CANCELLED, remotepb.RpcError_DEADLINE_EXCEEDED:
-			ce.Timeout = true
-		}
-		return ce
-	}
-	if res.ApplicationError != nil {
-		return &APIError{
-			Service: *req.ServiceName,
-			Detail:  res.ApplicationError.GetDetail(),
-			Code:    *res.ApplicationError.Code,
-		}
-	}
-	if res.Exception != nil || res.JavaException != nil {
-		// This shouldn't happen, but let's be defensive.
-		return &CallError{
-			Detail: "service bridge returned exception",
-			Code:   int32(remotepb.RpcError_UNKNOWN),
-		}
-	}
-	return proto.Unmarshal(res.Response, out)
-}
-
-func (c *context) Request() *http.Request {
-	return c.req
-}
-
-func (c *context) addLogLine(ll *logpb.UserAppLogLine) {
-	// Truncate long log lines.
-	// TODO(dsymonds): Check if this is still necessary.
-	const lim = 8 << 10
-	if len(*ll.Message) > lim {
-		suffix := fmt.Sprintf("...(length %d)", len(*ll.Message))
-		ll.Message = proto.String((*ll.Message)[:lim-len(suffix)] + suffix)
-	}
-
-	c.pendingLogs.Lock()
-	c.pendingLogs.lines = append(c.pendingLogs.lines, ll)
-	c.pendingLogs.Unlock()
-}
-
-var logLevelName = map[int64]string{
-	0: "DEBUG",
-	1: "INFO",
-	2: "WARNING",
-	3: "ERROR",
-	4: "CRITICAL",
-}
-
-func logf(c *context, level int64, format string, args ...interface{}) {
-	if c == nil {
-		panic("not an App Engine context")
-	}
-	s := fmt.Sprintf(format, args...)
-	s = strings.TrimRight(s, "\n") // Remove any trailing newline characters.
-	c.addLogLine(&logpb.UserAppLogLine{
-		TimestampUsec: proto.Int64(time.Now().UnixNano() / 1e3),
-		Level:         &level,
-		Message:       &s,
-	})
-	log.Print(logLevelName[level] + ": " + s)
-}
-
-// flushLog attempts to flush any pending logs to the appserver.
-// It should not be called concurrently.
-func (c *context) flushLog(force bool) (flushed bool) {
-	c.pendingLogs.Lock()
-	// Grab up to 30 MB. We can get away with up to 32 MB, but let's be cautious.
-	n, rem := 0, 30<<20
-	for ; n < len(c.pendingLogs.lines); n++ {
-		ll := c.pendingLogs.lines[n]
-		// Each log line will require about 3 bytes of overhead.
-		nb := proto.Size(ll) + 3
-		if nb > rem {
-			break
-		}
-		rem -= nb
-	}
-	lines := c.pendingLogs.lines[:n]
-	c.pendingLogs.lines = c.pendingLogs.lines[n:]
-	c.pendingLogs.Unlock()
-
-	if len(lines) == 0 && !force {
-		// Nothing to flush.
-		return false
-	}
-
-	rescueLogs := false
-	defer func() {
-		if rescueLogs {
-			c.pendingLogs.Lock()
-			c.pendingLogs.lines = append(lines, c.pendingLogs.lines...)
-			c.pendingLogs.Unlock()
-		}
-	}()
-
-	buf, err := proto.Marshal(&logpb.UserAppLogGroup{
-		LogLine: lines,
-	})
-	if err != nil {
-		log.Printf("internal.flushLog: marshaling UserAppLogGroup: %v", err)
-		rescueLogs = true
-		return false
-	}
-
-	req := &logpb.FlushRequest{
-		Logs: buf,
-	}
-	res := &basepb.VoidProto{}
-	c.pendingLogs.Lock()
-	c.pendingLogs.flushes++
-	c.pendingLogs.Unlock()
-	if err := Call(toContext(c), "logservice", "Flush", req, res); err != nil {
-		log.Printf("internal.flushLog: Flush RPC: %v", err)
-		rescueLogs = true
-		return false
-	}
-	return true
-}
-
-const (
-	// Log flushing parameters.
-	flushInterval      = 1 * time.Second
-	forceFlushInterval = 60 * time.Second
-)
-
-func (c *context) logFlusher(stop <-chan int) {
-	lastFlush := time.Now()
-	tick := time.NewTicker(flushInterval)
-	for {
-		select {
-		case <-stop:
-			// Request finished.
-			tick.Stop()
-			return
-		case <-tick.C:
-			force := time.Now().Sub(lastFlush) > forceFlushInterval
-			if c.flushLog(force) {
-				lastFlush = time.Now()
-			}
-		}
-	}
-}
-
-func ContextForTesting(req *http.Request) netcontext.Context {
-	return toContext(&context{req: req})
-}
diff --git a/vendor/google.golang.org/appengine/internal/api_test.go b/vendor/google.golang.org/appengine/internal/api_test.go
index 1743254f..8369b335 100644
--- a/vendor/google.golang.org/appengine/internal/api_test.go
+++ b/vendor/google.golang.org/appengine/internal/api_test.go
@@ -250,11 +250,12 @@ func TestDelayedLogFlushing(t *testing.T) {
 	f, c, cleanup := setup()
 	defer cleanup()
 
-	http.HandleFunc("/quick_log", func(w http.ResponseWriter, r *http.Request) {
+	http.HandleFunc("/slow_log", func(w http.ResponseWriter, r *http.Request) {
 		logC := WithContext(netcontext.Background(), r)
 		fromContext(logC).apiURL = c.apiURL // Otherwise it will try to use the default URL.
 		Logf(logC, 1, "It's a lovely day.")
 		w.WriteHeader(200)
+		time.Sleep(1200 * time.Millisecond)
 		w.Write(make([]byte, 100<<10)) // write 100 KB to force HTTP flush
 	})
 
@@ -262,31 +263,65 @@ func TestDelayedLogFlushing(t *testing.T) {
 		Method: "GET",
 		URL: &url.URL{
 			Scheme: "http",
-			Path:   "/quick_log",
+			Path:   "/slow_log",
 		},
 		Header: c.req.Header,
 		Body:   ioutil.NopCloser(bytes.NewReader(nil)),
 	}
 	w := httptest.NewRecorder()
 
-	// Check that log flushing does not hold up the HTTP response.
-	start := time.Now()
-	handleHTTP(w, r)
-	if d := time.Since(start); d > 10*time.Millisecond {
-		t.Errorf("handleHTTP took %v, want under 10ms", d)
+	handled := make(chan struct{})
+	go func() {
+		defer close(handled)
+		handleHTTP(w, r)
+	}()
+	// Check that the log flush eventually comes in.
+	time.Sleep(1200 * time.Millisecond)
+	if f := atomic.LoadInt32(&f.LogFlushes); f != 1 {
+		t.Errorf("After 1.2s: f.LogFlushes = %d, want 1", f)
 	}
+
+	<-handled
 	const hdr = "X-AppEngine-Log-Flush-Count"
-	if h := w.HeaderMap.Get(hdr); h != "1" {
-		t.Errorf("%s header = %q, want %q", hdr, h, "1")
+	if got, want := w.HeaderMap.Get(hdr), "1"; got != want {
+		t.Errorf("%s header = %q, want %q", hdr, got, want)
 	}
-	if f := atomic.LoadInt32(&f.LogFlushes); f != 0 {
-		t.Errorf("After HTTP response: f.LogFlushes = %d, want 0", f)
+	if got, want := atomic.LoadInt32(&f.LogFlushes), int32(2); got != want {
+		t.Errorf("After HTTP response: f.LogFlushes = %d, want %d", got, want)
 	}
 
-	// Check that the log flush eventually comes in.
-	time.Sleep(100 * time.Millisecond)
-	if f := atomic.LoadInt32(&f.LogFlushes); f != 1 {
-		t.Errorf("After 100ms: f.LogFlushes = %d, want 1", f)
+}
+
+func TestLogFlushing(t *testing.T) {
+	f, c, cleanup := setup()
+	defer cleanup()
+
+	http.HandleFunc("/quick_log", func(w http.ResponseWriter, r *http.Request) {
+		logC := WithContext(netcontext.Background(), r)
+		fromContext(logC).apiURL = c.apiURL // Otherwise it will try to use the default URL.
+		Logf(logC, 1, "It's a lovely day.")
+		w.WriteHeader(200)
+		w.Write(make([]byte, 100<<10)) // write 100 KB to force HTTP flush
+	})
+
+	r := &http.Request{
+		Method: "GET",
+		URL: &url.URL{
+			Scheme: "http",
+			Path:   "/quick_log",
+		},
+		Header: c.req.Header,
+		Body:   ioutil.NopCloser(bytes.NewReader(nil)),
+	}
+	w := httptest.NewRecorder()
+
+	handleHTTP(w, r)
+	const hdr = "X-AppEngine-Log-Flush-Count"
+	if got, want := w.HeaderMap.Get(hdr), "1"; got != want {
+		t.Errorf("%s header = %q, want %q", hdr, got, want)
+	}
+	if got, want := atomic.LoadInt32(&f.LogFlushes), int32(1); got != want {
+		t.Errorf("After HTTP response: f.LogFlushes = %d, want %d", got, want)
 	}
 }
 
diff --git a/vendor/google.golang.org/appengine/internal/identity.go b/vendor/google.golang.org/appengine/internal/identity.go
index d538701a..6d89d637 100644
--- a/vendor/google.golang.org/appengine/internal/identity.go
+++ b/vendor/google.golang.org/appengine/internal/identity.go
@@ -4,11 +4,46 @@
 
 package internal
 
-import netcontext "golang.org/x/net/context"
+import (
+	"os"
 
-// These functions are implementations of the wrapper functions
-// in ../appengine/identity.go. See that file for commentary.
+	netcontext "golang.org/x/net/context"
+)
 
+var (
+	// This is set to true in identity_classic.go, which is behind the appengine build tag.
+	// The appengine build tag is set for the first generation runtimes (<= Go 1.9) but not
+	// the second generation runtimes (>= Go 1.11), so this indicates whether we're on a
+	// first-gen runtime. See IsStandard below for the second-gen check.
+	appengineStandard bool
+
+	// This is set to true in identity_flex.go, which is behind the appenginevm build tag.
+	appengineFlex bool
+)
+
+// AppID is the implementation of the wrapper function of the same name in
+// ../identity.go. See that file for commentary.
 func AppID(c netcontext.Context) string {
 	return appID(FullyQualifiedAppID(c))
 }
+
+// IsStandard is the implementation of the wrapper function of the same name in
+// ../appengine.go. See that file for commentary.
+func IsStandard() bool {
+	// appengineStandard will be true for first-gen runtimes (<= Go 1.9) but not
+	// second-gen (>= Go 1.11). Second-gen runtimes set $GAE_ENV so we use that
+	// to check if we're on a second-gen runtime.
+	return appengineStandard || os.Getenv("GAE_ENV") == "standard"
+}
+
+// IsFlex is the implementation of the wrapper function of the same name in
+// ../appengine.go. See that file for commentary.
+func IsFlex() bool {
+	return appengineFlex
+}
+
+// IsAppEngine is the implementation of the wrapper function of the same name in
+// ../appengine.go. See that file for commentary.
+func IsAppEngine() bool {
+	return IsStandard() || IsFlex()
+}
diff --git a/vendor/google.golang.org/appengine/internal/identity_classic.go b/vendor/google.golang.org/appengine/internal/identity_classic.go
index b59603f1..4e979f45 100644
--- a/vendor/google.golang.org/appengine/internal/identity_classic.go
+++ b/vendor/google.golang.org/appengine/internal/identity_classic.go
@@ -12,6 +12,10 @@ import (
 	netcontext "golang.org/x/net/context"
 )
 
+func init() {
+	appengineStandard = true
+}
+
 func DefaultVersionHostname(ctx netcontext.Context) string {
 	c := fromContext(ctx)
 	if c == nil {
diff --git a/vendor/google.golang.org/appengine/internal/identity_flex.go b/vendor/google.golang.org/appengine/internal/identity_flex.go
new file mode 100644
index 00000000..d5e2e7b5
--- /dev/null
+++ b/vendor/google.golang.org/appengine/internal/identity_flex.go
@@ -0,0 +1,11 @@
+// Copyright 2018 Google LLC. All rights reserved.
+// Use of this source code is governed by the Apache 2.0
+// license that can be found in the LICENSE file.
+
+// +build appenginevm
+
+package internal
+
+func init() {
+	appengineFlex = true
+}
diff --git a/vendor/google.golang.org/appengine/travis_install.sh b/vendor/google.golang.org/appengine/travis_install.sh
new file mode 100755
index 00000000..785b62f4
--- /dev/null
+++ b/vendor/google.golang.org/appengine/travis_install.sh
@@ -0,0 +1,18 @@
+#!/bin/bash
+set -e
+
+if [[ $GO111MODULE == "on" ]]; then
+  go get .
+else
+  go get -u -v $(go list -f '{{join .Imports "\n"}}{{"\n"}}{{join .TestImports "\n"}}' ./... | sort | uniq | grep -v appengine)
+fi
+
+if [[ $GOAPP == "true" ]]; then
+  mkdir /tmp/sdk
+  curl -o /tmp/sdk.zip "https://storage.googleapis.com/appengine-sdks/featured/go_appengine_sdk_linux_amd64-1.9.68.zip"
+  unzip -q /tmp/sdk.zip -d /tmp/sdk
+  # NOTE: Set the following env vars in the test script:
+  # export PATH="$PATH:/tmp/sdk/go_appengine"
+  # export APPENGINE_DEV_APPSERVER=/tmp/sdk/go_appengine/dev_appserver.py
+fi
+
diff --git a/vendor/google.golang.org/appengine/travis_test.sh b/vendor/google.golang.org/appengine/travis_test.sh
new file mode 100755
index 00000000..d4390f04
--- /dev/null
+++ b/vendor/google.golang.org/appengine/travis_test.sh
@@ -0,0 +1,12 @@
+#!/bin/bash
+set -e
+
+go version
+go test -v google.golang.org/appengine/...
+go test -v -race google.golang.org/appengine/...
+if [[ $GOAPP == "true" ]]; then
+  export PATH="$PATH:/tmp/sdk/go_appengine"
+  export APPENGINE_DEV_APPSERVER=/tmp/sdk/go_appengine/dev_appserver.py
+  goapp version
+  goapp test -v google.golang.org/appengine/...
+fi
diff --git a/vendor/gopkg.in/yaml.v2/decode_test.go b/vendor/gopkg.in/yaml.v2/decode_test.go
index 9269f12b..b05c466e 100644
--- a/vendor/gopkg.in/yaml.v2/decode_test.go
+++ b/vendor/gopkg.in/yaml.v2/decode_test.go
@@ -714,6 +714,14 @@ var unmarshalTests = []struct {
 		"---\nhello\n...\n}not yaml",
 		"hello",
 	},
+	{
+		"a: 5\n",
+		&struct{ A jsonNumberT }{"5"},
+	},
+	{
+		"a: 5.5\n",
+		&struct{ A jsonNumberT }{"5.5"},
+	},
 }
 
 type M map[interface{}]interface{}
diff --git a/vendor/gopkg.in/yaml.v2/encode.go b/vendor/gopkg.in/yaml.v2/encode.go
index a14435e8..0ee738e1 100644
--- a/vendor/gopkg.in/yaml.v2/encode.go
+++ b/vendor/gopkg.in/yaml.v2/encode.go
@@ -13,6 +13,19 @@ import (
 	"unicode/utf8"
 )
 
+// jsonNumber is the interface of the encoding/json.Number datatype.
+// Repeating the interface here avoids a dependency on encoding/json, and also
+// supports other libraries like jsoniter, which use a similar datatype with
+// the same interface. Detecting this interface is useful when dealing with
+// structures containing json.Number, which is a string under the hood. The
+// encoder should prefer the use of Int64(), Float64() and string(), in that
+// order, when encoding this type.
+type jsonNumber interface {
+	Float64() (float64, error)
+	Int64() (int64, error)
+	String() string
+}
+
 type encoder struct {
 	emitter yaml_emitter_t
 	event   yaml_event_t
@@ -89,6 +102,21 @@ func (e *encoder) marshal(tag string, in reflect.Value) {
 	}
 	iface := in.Interface()
 	switch m := iface.(type) {
+	case jsonNumber:
+		integer, err := m.Int64()
+		if err == nil {
+			// In this case the json.Number is a valid int64
+			in = reflect.ValueOf(integer)
+			break
+		}
+		float, err := m.Float64()
+		if err == nil {
+			// In this case the json.Number is a valid float64
+			in = reflect.ValueOf(float)
+			break
+		}
+		// fallback case - no number could be obtained
+		in = reflect.ValueOf(m.String())
 	case time.Time, *time.Time:
 		// Although time.Time implements TextMarshaler,
 		// we don't want to treat it as a string for YAML
diff --git a/vendor/gopkg.in/yaml.v2/encode_test.go b/vendor/gopkg.in/yaml.v2/encode_test.go
index f0911a76..4a266008 100644
--- a/vendor/gopkg.in/yaml.v2/encode_test.go
+++ b/vendor/gopkg.in/yaml.v2/encode_test.go
@@ -15,6 +15,24 @@ import (
 	"gopkg.in/yaml.v2"
 )
 
+type jsonNumberT string
+
+func (j jsonNumberT) Int64() (int64, error) {
+	val, err := strconv.Atoi(string(j))
+	if err != nil {
+		return 0, err
+	}
+	return int64(val), nil
+}
+
+func (j jsonNumberT) Float64() (float64, error) {
+	return strconv.ParseFloat(string(j), 64)
+}
+
+func (j jsonNumberT) String() string {
+	return string(j)
+}
+
 var marshalIntTest = 123
 
 var marshalTests = []struct {
@@ -367,6 +385,18 @@ var marshalTests = []struct {
 		map[string]string{"a": " #comment"},
 		"a: ' #comment'\n",
 	},
+	{
+		map[string]interface{}{"a": jsonNumberT("5")},
+		"a: 5\n",
+	},
+	{
+		map[string]interface{}{"a": jsonNumberT("100.5")},
+		"a: 100.5\n",
+	},
+	{
+		map[string]interface{}{"a": jsonNumberT("bogus")},
+		"a: bogus\n",
+	},
 }
 
 func (s *S) TestMarshal(c *C) {
