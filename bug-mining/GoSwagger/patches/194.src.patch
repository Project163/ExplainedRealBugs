diff --git a/fixtures/goparsing/classification/models/nomodel.go b/fixtures/goparsing/classification/models/nomodel.go
index 7766beb0..c18f9c3f 100644
--- a/fixtures/goparsing/classification/models/nomodel.go
+++ b/fixtures/goparsing/classification/models/nomodel.go
@@ -191,6 +191,12 @@ type OverridingOne struct {
 	Age int64
 }
 
+// An OverridingOneIgnore is composed of a SimpleOne and overrides a field to ignore it
+type OverridingOneIgnore struct {
+	SimpleOne
+	Age int32 `json:"-"`
+}
+
 // An AllOfModel is composed out of embedded structs but it should build
 // an allOf property
 type AllOfModel struct {
diff --git a/scan/schema.go b/scan/schema.go
index cdcb6252..b12c76f2 100644
--- a/scan/schema.go
+++ b/scan/schema.go
@@ -252,11 +252,11 @@ func (scp *schemaParser) parseDecl(definitions map[string]spec.Schema, decl *sch
 	// * the following lines are the description
 	switch tpe := decl.TypeSpec.Type.(type) {
 	case *ast.StructType:
-		if err := scp.parseStructType(decl.File, schPtr, tpe, make(map[string]struct{})); err != nil {
+		if err := scp.parseStructType(decl.File, schPtr, tpe, make(map[string]string)); err != nil {
 			return err
 		}
 	case *ast.InterfaceType:
-		if err := scp.parseInterfaceType(decl.File, schPtr, tpe, make(map[string]struct{})); err != nil {
+		if err := scp.parseInterfaceType(decl.File, schPtr, tpe, make(map[string]string)); err != nil {
 			return err
 		}
 	case *ast.Ident:
@@ -344,7 +344,7 @@ func (scp *schemaParser) parseNamedType(gofile *ast.File, expr ast.Expr, prop sw
 		if schema == nil {
 			return fmt.Errorf("items doesn't support embedded structs")
 		}
-		return scp.parseStructType(gofile, prop.Schema(), ftpe, make(map[string]struct{}))
+		return scp.parseStructType(gofile, prop.Schema(), ftpe, make(map[string]string))
 
 	case *ast.SelectorExpr:
 		err := scp.typeForSelector(gofile, ftpe, prop)
@@ -389,7 +389,7 @@ func (scp *schemaParser) parseNamedType(gofile *ast.File, expr ast.Expr, prop sw
 	return nil
 }
 
-func (scp *schemaParser) parseEmbeddedType(gofile *ast.File, schema *spec.Schema, expr ast.Expr, seenPreviously map[string]struct{}) error {
+func (scp *schemaParser) parseEmbeddedType(gofile *ast.File, schema *spec.Schema, expr ast.Expr, seenPreviously map[string]string) error {
 	switch tpe := expr.(type) {
 	case *ast.Ident:
 		// do lookup of type
@@ -441,7 +441,7 @@ func (scp *schemaParser) parseEmbeddedType(gofile *ast.File, schema *spec.Schema
 	return fmt.Errorf("unable to resolve embedded struct for: %v", expr)
 }
 
-func (scp *schemaParser) parseAllOfMember(gofile *ast.File, schema *spec.Schema, expr ast.Expr, seenPreviously map[string]struct{}) error {
+func (scp *schemaParser) parseAllOfMember(gofile *ast.File, schema *spec.Schema, expr ast.Expr, seenPreviously map[string]string) error {
 	// TODO: check if struct is annotated with swagger:model or known in the definitions otherwise
 	var pkg *loader.PackageInfo
 	var file *ast.File
@@ -495,7 +495,7 @@ func (scp *schemaParser) parseAllOfMember(gofile *ast.File, schema *spec.Schema,
 
 	return nil
 }
-func (scp *schemaParser) parseInterfaceType(gofile *ast.File, bschema *spec.Schema, tpe *ast.InterfaceType, seenPreviously map[string]struct{}) error {
+func (scp *schemaParser) parseInterfaceType(gofile *ast.File, bschema *spec.Schema, tpe *ast.InterfaceType, seenPreviously map[string]string) error {
 	if tpe.Methods == nil {
 		return nil
 	}
@@ -592,7 +592,7 @@ func (scp *schemaParser) parseInterfaceType(gofile *ast.File, bschema *spec.Sche
 			if ps.Ref.String() == "" && nm != gnm {
 				ps.AddExtension("x-go-name", gnm)
 			}
-			seenProperties[nm] = struct{}{}
+			seenProperties[nm] = gnm
 			schema.Properties[nm] = ps
 		}
 
@@ -608,7 +608,7 @@ func (scp *schemaParser) parseInterfaceType(gofile *ast.File, bschema *spec.Sche
 	return nil
 }
 
-func (scp *schemaParser) parseStructType(gofile *ast.File, bschema *spec.Schema, tpe *ast.StructType, seenPreviously map[string]struct{}) error {
+func (scp *schemaParser) parseStructType(gofile *ast.File, bschema *spec.Schema, tpe *ast.StructType, seenPreviously map[string]string) error {
 	if tpe.Fields == nil {
 		return nil
 	}
@@ -688,6 +688,12 @@ func (scp *schemaParser) parseStructType(gofile *ast.File, bschema *spec.Schema,
 				return err
 			}
 			if ignore {
+				for seenTagName, seenFieldName := range seenPreviously {
+					if seenFieldName == gnm {
+						delete(schema.Properties, seenTagName)
+						break
+					}
+				}
 				continue
 			}
 
@@ -707,7 +713,11 @@ func (scp *schemaParser) parseStructType(gofile *ast.File, bschema *spec.Schema,
 			if ps.Ref.String() == "" && nm != gnm {
 				ps.AddExtension("x-go-name", gnm)
 			}
-			seenProperties[nm] = struct{}{}
+			// we have 2 cases:
+			// 1. field with different name override tag
+			// 2. field with different name removes tag
+			// so we need to save both tag&name
+			seenProperties[nm] = gnm
 			schema.Properties[nm] = ps
 		}
 	}
@@ -1205,7 +1215,7 @@ func parseProperty(scp *schemaParser, gofile *ast.File, fld ast.Expr, prop swagg
 		if schema == nil {
 			return fmt.Errorf("items doesn't support embedded structs")
 		}
-		return scp.parseStructType(gofile, prop.Schema(), ftpe, make(map[string]struct{}))
+		return scp.parseStructType(gofile, prop.Schema(), ftpe, make(map[string]string))
 
 	case *ast.SelectorExpr:
 		err := scp.typeForSelector(gofile, ftpe, prop)
diff --git a/scan/schema_test.go b/scan/schema_test.go
index 20592e38..53606f3d 100644
--- a/scan/schema_test.go
+++ b/scan/schema_test.go
@@ -215,6 +215,14 @@ func TestEmbeddedStarExpr(t *testing.T) {
 	assertProperty(t, &schema, "integer", "notEmbedded", "int64", "NotEmbedded")
 }
 
+func TestOverridingOneIgnore(t *testing.T) {
+	schema := noModelDefs["OverridingOneIgnore"]
+
+	assertProperty(t, &schema, "integer", "id", "int64", "ID")
+	assertProperty(t, &schema, "string", "name", "", "Name")
+	assert.Len(t, schema.Properties, 2)
+}
+
 func TestAliasedTypes(t *testing.T) {
 	schema := noModelDefs["OtherTypes"]
 	assertRef(t, &schema, "named", "Named", "#/definitions/SomeStringType")
