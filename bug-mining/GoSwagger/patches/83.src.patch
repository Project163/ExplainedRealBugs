diff --git a/cmd/swagger/commands/initcmd.go b/cmd/swagger/commands/initcmd.go
new file mode 100644
index 00000000..9163fa00
--- /dev/null
+++ b/cmd/swagger/commands/initcmd.go
@@ -0,0 +1,12 @@
+package commands
+
+import "github.com/go-swagger/go-swagger/cmd/swagger/commands/initcmd"
+
+// InitCmd is a command namespace for initializing things like a swagger spec.
+type InitCmd struct {
+	Model *initcmd.Spec `command:"spec"`
+}
+
+func (i *InitCmd) Execute(args []string) error {
+	return nil
+}
diff --git a/cmd/swagger/commands/initcmd/spec.go b/cmd/swagger/commands/initcmd/spec.go
new file mode 100644
index 00000000..8d902ae6
--- /dev/null
+++ b/cmd/swagger/commands/initcmd/spec.go
@@ -0,0 +1,120 @@
+package initcmd
+
+import (
+	"encoding/json"
+	"fmt"
+	"log"
+	"os"
+	"path/filepath"
+
+	"gopkg.in/yaml.v1"
+
+	"github.com/go-swagger/go-swagger/spec"
+	"github.com/go-swagger/swag"
+)
+
+// Spec a command struct for initializing a new swagger application.
+type Spec struct {
+	Format      string   `long:"format" description:"the format for the spec document" default:"yaml" choice:"yaml" choice:"json"`
+	Title       string   `long:"title" description:"the title of the API"`
+	Description string   `long:"description" description:"the description of the API"`
+	Version     string   `long:"version" description:"the version of the API" default:"0.1.0"`
+	Terms       string   `long:"terms" description:"the terms of services"`
+	Consumes    []string `long:"consumes" description:"add a content type to the global consumes definitions, can repeat" default:"application/json"`
+	Produces    []string `long:"produces" description:"add a content type to the global produces definitions, can repeat" default:"application/json"`
+	Schemes     []string `long:"scheme" description:"add a scheme to the global schemes definition, can repeat" default:"http"`
+	Contact     struct {
+		Name  string `long:"contact.name" description:"name of the primary contact for the API"`
+		URL   string `long:"contact.url" description:"url of the primary contact for the API"`
+		Email string `long:"contact.email" description:"email of the primary contact for the API"`
+	}
+	License struct {
+		Name string `long:"license.name" description:"name of the license for the API"`
+		URL  string `long:"license.url" description:"url of the license for the API"`
+	}
+}
+
+// Execute this command
+func (s *Spec) Execute(args []string) error {
+	targetPath := "."
+	if len(args) > 0 {
+		targetPath = args[0]
+	}
+	realPath, err := filepath.Abs(targetPath)
+	if err != nil {
+		return err
+	}
+	var file *os.File
+	switch s.Format {
+	case "json":
+		file, err = os.Create(filepath.Join(realPath, "swagger.json"))
+		if err != nil {
+			return err
+		}
+	case "yaml", "yml":
+		file, err = os.Create(filepath.Join(realPath, "swagger.yml"))
+		if err != nil {
+			return err
+		}
+	default:
+		return fmt.Errorf("invalid format: %s", s.Format)
+	}
+	defer file.Close()
+	log.Println("creating specification document in", filepath.Join(targetPath, file.Name()))
+
+	var doc spec.Swagger
+	info := new(spec.Info)
+	doc.Info = info
+
+	doc.Swagger = "2.0"
+	doc.Paths = new(spec.Paths)
+	doc.Definitions = make(spec.Definitions)
+
+	info.Title = s.Title
+	if info.Title == "" {
+		info.Title = swag.ToHumanNameTitle(filepath.Base(realPath))
+	}
+	info.Description = s.Description
+	info.Version = s.Version
+	info.TermsOfService = s.Terms
+	if s.Contact.Name != "" || s.Contact.Email != "" || s.Contact.URL != "" {
+		var contact spec.ContactInfo
+		contact.Name = s.Contact.Name
+		contact.Email = s.Contact.Email
+		contact.URL = s.Contact.URL
+		info.Contact = &contact
+	}
+	if s.License.Name != "" || s.License.URL != "" {
+		var license spec.License
+		license.Name = s.License.Name
+		license.URL = s.License.URL
+		info.License = &license
+	}
+
+	for _, cons := range s.Consumes {
+		doc.Consumes = append(doc.Consumes, cons)
+	}
+	for _, prods := range s.Produces {
+		doc.Produces = append(doc.Produces, prods)
+	}
+	for _, scheme := range s.Schemes {
+		doc.Schemes = append(doc.Schemes, scheme)
+	}
+
+	if s.Format == "json" {
+		enc := json.NewEncoder(file)
+		if err := enc.Encode(doc); err != nil {
+			return err
+		}
+		return nil
+	}
+
+	b, err := yaml.Marshal(swag.ToDynamicJSON(doc))
+	if err != nil {
+		return err
+	}
+	if _, err := file.Write(b); err != nil {
+		return err
+	}
+	return nil
+}
diff --git a/cmd/swagger/swagger.go b/cmd/swagger/swagger.go
index 5407dace..b6e3b404 100644
--- a/cmd/swagger/swagger.go
+++ b/cmd/swagger/swagger.go
@@ -32,7 +32,15 @@ Swagger tries to support you as best as possible when building API's.
 
 It aims to represent the contract of your API with a language agnostic description of your application in json or yaml.
 `
-	parser.AddCommand("validate", "validate the swagger document", "validate the provided swagger document against a swagger spec", &commands.ValidateSpec{})
+	_, err := parser.AddCommand("validate", "validate the swagger document", "validate the provided swagger document against a swagger spec", &commands.ValidateSpec{})
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	_, err = parser.AddCommand("init", "initialize a spec document", "initialize a swagger spec document", &commands.InitCmd{})
+	if err != nil {
+		log.Fatal(err)
+	}
 
 	genpar, err := parser.AddCommand("generate", "genererate go code", "generate go code for the swagger spec file", &commands.Generate{})
 	if err != nil {
diff --git a/docs/content/use/middleware.md b/docs/content/use/middleware.md
index fe3a2bac..43e8b079 100644
--- a/docs/content/use/middleware.md
+++ b/docs/content/use/middleware.md
@@ -7,13 +7,11 @@ weight = 6
 series = ["home"]
 +++
 
-Go-swagger chose the golang `net/http` package as base abstraction. That means that for _any_ supported transport by
-the toolkit you can reuse _any_ middleware existing middlewares that following the stdlib middlware pattern.
+Go-swagger chose the golang `net/http` package as base abstraction. That means that for _any_ supported transport by the toolkit you can reuse _any_ middleware existing middlewares that following the stdlib middlware pattern.
 
 <!--more-->
 
-There are several projects providing middleware libraries for weaving all kinds of functionality into your request
-handling. None of those things are the job of go-swagger, go-swagger just serves your specs.
+There are several projects providing middleware libraries for weaving all kinds of functionality into your request handling. None of those things are the job of go-swagger, go-swagger just serves your specs.
 
 The server takes care of a number of things when a request arrives:
 
@@ -122,4 +120,3 @@ func setupMiddlewares(handler http.Handler) http.Handler {
 ```
 
 And with this you've added rate limitting to your application.
-
diff --git a/spec/paths.go b/spec/paths.go
index aa11f775..b058ca2f 100644
--- a/spec/paths.go
+++ b/spec/paths.go
@@ -81,12 +81,10 @@ func (p Paths) MarshalJSON() ([]byte, error) {
 	if err != nil {
 		return nil, err
 	}
-	var pths map[string]PathItem
+
+	pths := make(map[string]PathItem)
 	for k, v := range p.Paths {
 		if strings.HasPrefix(k, "/") {
-			if pths == nil {
-				pths = make(map[string]PathItem)
-			}
 			pths[k] = v
 		}
 	}
diff --git a/spec/swagger.go b/spec/swagger.go
index 0812689c..97c5a1b7 100644
--- a/spec/swagger.go
+++ b/spec/swagger.go
@@ -55,8 +55,8 @@ type swaggerProps struct {
 	Info                *Info                  `json:"info,omitempty"`
 	Host                string                 `json:"host,omitempty"`
 	BasePath            string                 `json:"basePath,omitempty"` // must start with a leading "/"
-	Paths               *Paths                 `json:"paths,omitempty"`    // required
-	Definitions         Definitions            `json:"definitions,omitempty"`
+	Paths               *Paths                 `json:"paths"`              // required
+	Definitions         Definitions            `json:"definitions"`
 	Parameters          map[string]Parameter   `json:"parameters,omitempty"`
 	Responses           map[string]Response    `json:"responses,omitempty"`
 	SecurityDefinitions SecurityDefinitions    `json:"securityDefinitions,omitempty"`
