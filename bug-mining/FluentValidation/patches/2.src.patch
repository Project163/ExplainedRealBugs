diff --git a/src/FluentValidation/DefaultValidatorExtensions.cs b/src/FluentValidation/DefaultValidatorExtensions.cs
index efbb59ed..9a32b4e4 100644
--- a/src/FluentValidation/DefaultValidatorExtensions.cs
+++ b/src/FluentValidation/DefaultValidatorExtensions.cs
@@ -67,6 +67,21 @@ public static class DefaultValidatorExtensions {
 			return ruleBuilder.SetValidator(new LengthValidator(min, max));
 		}
 
+        /// <summary>
+        /// Defines a length validator on the current rule builder, but only for string properties.
+        /// Validation will fail if the length of the string is outside of the specifed range. The range is inclusive.
+        /// </summary>
+        /// <typeparam name="T">Type of object being validated</typeparam>
+        /// <param name="ruleBuilder">The rule builder on which the validator should be defined</param>
+        /// <returns></returns>
+        public static IRuleBuilderOptions<T, string> Length<T>(this IRuleBuilder<T, string> ruleBuilder, Expression<Func<T, int>> min, Expression<Func<T, int>> max)
+        {
+            var minFunc = min.Compile();
+            var maxFunc = max.Compile();
+
+            return ruleBuilder.SetValidator(new LengthValidator(minFunc.CoerceToNonGeneric(), maxFunc.CoerceToNonGeneric()));
+        }
+
 		/// <summary>
 		/// Defines a length validator on the current rule builder, but only for string properties.
 		/// Validation will fail if the length of the string is not equal to the length specified.
@@ -78,6 +93,19 @@ public static class DefaultValidatorExtensions {
 			return ruleBuilder.SetValidator(new ExactLengthValidator(exactLength));
 		}
 
+        /// <summary>
+        /// Defines a length validator on the current rule builder, but only for string properties.
+        /// Validation will fail if the length of the string is not equal to the length specified.
+        /// </summary>
+        /// <typeparam name="T">Type of object being validated</typeparam>
+        /// <param name="ruleBuilder">The rule builder on which the validator should be defined</param>
+        /// <returns></returns>
+        public static IRuleBuilderOptions<T, string> Length<T>(this IRuleBuilder<T, string> ruleBuilder, Expression<Func<T, int>> exactLength)
+        {
+            var func = exactLength.Compile();
+            return ruleBuilder.SetValidator(new ExactLengthValidator(func.CoerceToNonGeneric()));
+        }
+
 		/// <summary>
 		/// Defines a regular expression validator on the current rule builder, but only for string properties.
 		/// Validation will fail if the value returned by the lambda does not match the regular expression.
@@ -90,6 +118,20 @@ public static class DefaultValidatorExtensions {
 			return ruleBuilder.SetValidator(new RegularExpressionValidator(expression));
 		}
 
+        /// <summary>
+        /// Defines a regular expression validator on the current rule builder, but only for string properties.
+        /// Validation will fail if the value returned by the lambda does not match the regular expression.
+        /// </summary>
+        /// <typeparam name="T">Type of object being validated</typeparam>
+        /// <param name="ruleBuilder">The rule builder on which the validator should be defined</param>
+        /// <param name="expression">The regular expression to check the value against.</param>
+        /// <returns></returns>
+        public static IRuleBuilderOptions<T, string> Matches<T>(this IRuleBuilder<T, string> ruleBuilder, Expression<Func<T, string>> expression)
+        {
+            var func = expression.Compile();
+            return ruleBuilder.SetValidator(new RegularExpressionValidator(func.CoerceToNonGeneric()));
+        }
+
 
 		/// <summary>
 		/// Defines a regular expression validator on the current rule builder, but only for string properties.
@@ -103,6 +145,20 @@ public static class DefaultValidatorExtensions {
 			return ruleBuilder.SetValidator(new RegularExpressionValidator(regex));
 		}
 
+        /// <summary>
+        /// Defines a regular expression validator on the current rule builder, but only for string properties.
+        /// Validation will fail if the value returned by the lambda does not match the regular expression.
+        /// </summary>
+        /// <typeparam name="T">Type of object being validated</typeparam>
+        /// <param name="ruleBuilder">The rule builder on which the validator should be defined</param>
+        /// <param name="regex">The regular expression to use</param>
+        /// <returns></returns>
+        public static IRuleBuilderOptions<T, string> Matches<T>(this IRuleBuilder<T, string> ruleBuilder, Expression<Func<T, Regex>> regex)
+        {
+            var func = regex.Compile();
+            return ruleBuilder.SetValidator(new RegularExpressionValidator(func.CoerceToNonGeneric()));
+        }
+
 
 		/// <summary>
 		/// Defines a regular expression validator on the current rule builder, but only for string properties.
@@ -117,6 +173,21 @@ public static class DefaultValidatorExtensions {
 			return ruleBuilder.SetValidator(new RegularExpressionValidator(expression, options));
 		}
 
+        /// <summary>
+        /// Defines a regular expression validator on the current rule builder, but only for string properties.
+        /// Validation will fail if the value returned by the lambda does not match the regular expression.
+        /// </summary>
+        /// <typeparam name="T">Type of object being validated</typeparam>
+        /// <param name="ruleBuilder">The rule builder on which the validator should be defined</param>
+        /// <param name="expression">The regular expression to check the value against.</param>
+        /// <param name="options">Regex options</param>
+        /// <returns></returns>
+        public static IRuleBuilderOptions<T, string> Matches<T>(this IRuleBuilder<T, string> ruleBuilder, Expression<Func<T, string>> expression, RegexOptions options)
+        {
+            var func = expression.Compile();
+            return ruleBuilder.SetValidator(new RegularExpressionValidator(func.CoerceToNonGeneric(), options));
+        }
+
 		/// <summary>
 		/// Defines a regular expression validator on the current rule builder, but only for string properties.
 		/// Validation will fail if the value returned by the lambda is not a valid email address.
diff --git a/src/FluentValidation/Internal/Extensions.cs b/src/FluentValidation/Internal/Extensions.cs
index 72a31826..e5c83102 100644
--- a/src/FluentValidation/Internal/Extensions.cs
+++ b/src/FluentValidation/Internal/Extensions.cs
@@ -118,6 +118,26 @@ public static class Extensions {
 			return x => func((T)x);
 		}
 
+        public static Func<object, int> CoerceToNonGeneric<T>(this Func<T, int> func)
+        {
+            return x => func((T)x);
+        }
+
+        public static Func<object, long> CoerceToNonGeneric<T>(this Func<T, long> func)
+        {
+            return x => func((T)x);
+        }
+
+        public static Func<object, string> CoerceToNonGeneric<T>(this Func<T, string> func)
+        {
+            return x => func((T)x);
+        }
+
+        public static Func<object, System.Text.RegularExpressions.Regex> CoerceToNonGeneric<T>(this Func<T, System.Text.RegularExpressions.Regex> func)
+        {
+            return x => func((T)x);
+        }
+
 		public static Action<object> CoerceToNonGeneric<T>(this Action<T> action) {
 			return x => action((T)x);
 		}
diff --git a/src/FluentValidation/Validators/LengthValidator.cs b/src/FluentValidation/Validators/LengthValidator.cs
index 598e18f6..79ac6393 100644
--- a/src/FluentValidation/Validators/LengthValidator.cs
+++ b/src/FluentValidation/Validators/LengthValidator.cs
@@ -26,6 +26,10 @@ public class LengthValidator : PropertyValidator, ILengthValidator {
 		public int Min { get; private set; }
 		public int Max { get; private set; }
 
+        public Func<object, int> MinFunc { get; set; }
+
+        public Func<object, int> MaxFunc { get; set; }
+
 		public LengthValidator(int min, int max) : this(min, max, () => Messages.length_error) {
 		}
 
@@ -38,9 +42,24 @@ public class LengthValidator : PropertyValidator, ILengthValidator {
 			}
 		}
 
+        public LengthValidator(Func<object, int> min, Func<object, int> max)
+            : this(min, max, () => Messages.length_error) {
+        }
+
+        public LengthValidator(Func<object, int> min, Func<object, int> max, Expression<Func<string>> errorMessageResourceSelector) : base(errorMessageResourceSelector) {
+            MaxFunc = max;
+            MinFunc = min;
+        }
+
 		protected override bool IsValid(PropertyValidatorContext context) {
 			if (context.PropertyValue == null) return true;
 
+            if (MaxFunc != null && MinFunc != null)
+            {
+                Max = (int)MaxFunc(context.Instance);
+                Min = (int)MinFunc(context.Instance);
+            }
+
 			int length = context.PropertyValue.ToString().Length;
 
 			if (length < Min || (length > Max && Max != -1)) {
@@ -60,6 +79,11 @@ public class ExactLengthValidator : LengthValidator {
 		public ExactLengthValidator(int length) : base(length,length, () => Messages.exact_length_error) {
 			
 		}
+
+        public ExactLengthValidator(Func<object, int> length)
+            : base(length, length, () => Messages.exact_length_error) {
+
+        }
 	}
 
     public class MaximumLengthValidator : LengthValidator {
@@ -71,6 +95,16 @@ public MaximumLengthValidator(int max, Expression<Func<string>> errorMessageReso
             : base(0, max, errorMessageResourceSelector) {
 
         }
+
+        public MaximumLengthValidator(Func<object, int> max) : 
+            this(max, () => Messages.length_error) { 
+
+        }
+
+        public MaximumLengthValidator(Func<object, int> max, Expression<Func<string>> errorMessageResourceSelector)
+            : base(obj => 0, max, errorMessageResourceSelector) {
+
+        }
     }
 
     public class MinimumLengthValidator : LengthValidator {
@@ -82,6 +116,16 @@ public MinimumLengthValidator(int min, Expression<Func<string>> errorMessageReso
             : base(min, -1, errorMessageResourceSelector) {
 
         }
+
+        public MinimumLengthValidator(Func<object, int> min)
+            : this(min, () => Messages.length_error) {
+
+        }
+
+        public MinimumLengthValidator(Func<object, int> min, Expression<Func<string>> errorMessageResourceSelector)
+            : base(min, obj => -1, errorMessageResourceSelector) {
+
+        }
     }
 
 	public interface ILengthValidator : IPropertyValidator {
diff --git a/src/FluentValidation/Validators/RegularExpressionValidator.cs b/src/FluentValidation/Validators/RegularExpressionValidator.cs
index 1606afc7..7ebb5348 100644
--- a/src/FluentValidation/Validators/RegularExpressionValidator.cs
+++ b/src/FluentValidation/Validators/RegularExpressionValidator.cs
@@ -26,25 +26,81 @@ namespace FluentValidation.Validators {
 
 	public class RegularExpressionValidator : PropertyValidator, IRegularExpressionValidator {
 		readonly string expression;
-		readonly Regex regex;
+		readonly RegexOptions? regexOptions;
+
+        readonly Func<object, string> expressionFunc;
+        readonly Func<object, Regex> regexFunc;
 
 		public RegularExpressionValidator(string expression) : base(() => Messages.regex_error) {
 			this.expression = expression;
-			regex = new Regex(expression);
-
 		}
 
 		public RegularExpressionValidator(Regex regex) : base(() => Messages.regex_error) {
 			this.expression = regex.ToString();
-			this.regex = regex;
 		}
 
 		public RegularExpressionValidator(string expression, RegexOptions options) : base(() => Messages.regex_error) {
 			this.expression = expression;
-			this.regex = new Regex(expression, options);
+            this.regexOptions = options;
 		}
 
+        public RegularExpressionValidator(Func<object, string> expression)
+            : base(() => Messages.regex_error)
+        {
+            this.expressionFunc = expression;
+        }
+
+        public RegularExpressionValidator(Func<object, Regex> regex)
+            : base(() => Messages.regex_error)
+        {
+            this.regexFunc = regex;
+        }
+
+        public RegularExpressionValidator(Func<object, string> expression, RegexOptions options)
+            : base(() => Messages.regex_error)
+        {
+            this.expressionFunc = expression;
+            this.regexOptions = options;
+        }
+
 		protected override bool IsValid(PropertyValidatorContext context) {
+            Regex regex = null;
+
+            if (regexOptions.HasValue)
+            {
+                if (regexFunc != null)
+                {
+                    Regex regexOrig = regexFunc(context.Instance);
+                    regex = new Regex(regexOrig.ToString(), regexOptions.Value);
+                }
+                else if (expressionFunc != null)
+                {
+                    string expressionOrig = expressionFunc(context.Instance);
+                    regex = new Regex(expressionOrig, regexOptions.Value);
+                }
+                else
+                {
+                    regex = new Regex(expression, regexOptions.Value);
+                }
+            }
+            else
+            {
+                if (regexFunc != null)
+                {
+                    regex = regexFunc(context.Instance);
+                }
+                else if (expressionFunc != null)
+                {
+                    string expressionOrig = expressionFunc(context.Instance);
+                    regex = new Regex(expressionOrig);
+                }
+                else
+                {
+                    regex = new Regex(expression);
+                }
+
+            }            
+
 			if (context.PropertyValue != null && !regex.IsMatch((string)context.PropertyValue)) {
 				context.MessageFormatter.AppendArgument("RegularExpression", this.expression);
 				return false;
