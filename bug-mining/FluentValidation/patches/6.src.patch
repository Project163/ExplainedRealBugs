diff --git a/Changelog.txt b/Changelog.txt
index fd03ab40..d52226f5 100644
--- a/Changelog.txt
+++ b/Changelog.txt
@@ -1,3 +1,6 @@
+9.2.2 - 20 September 2020
+Fix one of the inheritance validator overloads not working correctly (#1528)
+
 9.2.1 - 19 September 2020
 Add non-generic Add method to inheritance validator.
 Updates to Persian translations (#1513)
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index 74217534..2a3dc29c 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -1,6 +1,6 @@
 <Project>
   <PropertyGroup>
-    <VersionPrefix>9.2.1</VersionPrefix>
+    <VersionPrefix>9.2.2</VersionPrefix>
     <VersionSuffix></VersionSuffix>
     <!-- Use CI build number as version suffix (if defined) -->
     <!--<VersionSuffix Condition="'$(GITHUB_RUN_NUMBER)'!=''">ci-$(GITHUB_RUN_NUMBER)</VersionSuffix>-->
diff --git a/src/FluentValidation.Tests/InheritanceValidatorTest.cs b/src/FluentValidation.Tests/InheritanceValidatorTest.cs
index 9b1e6473..71d970d6 100644
--- a/src/FluentValidation.Tests/InheritanceValidatorTest.cs
+++ b/src/FluentValidation.Tests/InheritanceValidatorTest.cs
@@ -167,6 +167,68 @@ public class InheritanceValidatorTest {
 
 		}
 
+		[Fact]
+		public void Validates_with_callback_accepting_derived() {
+			var validator = new InlineValidator<Root>();
+			var impl1Validator = new InlineValidator<FooImpl1>();
+			var impl2Validator = new InlineValidator<FooImpl2>();
+
+			impl1Validator.RuleFor(x => x.Name).NotNull();
+			impl2Validator.RuleFor(x => x.Number).GreaterThan(0);
+
+			validator.RuleFor(x => x.Foo).SetInheritanceValidator(v => {
+				v.Add<FooImpl1>((x, impl1) => {
+						Assert.NotNull(impl1);
+						return impl1Validator;
+					})
+					.Add<FooImpl2>((x, impl2) => {
+						Assert.NotNull(impl2);
+						return impl2Validator;
+					});
+			});
+
+			var result = validator.Validate(new Root {Foo = new FooImpl1()});
+			result.Errors.Count.ShouldEqual(1);
+			result.Errors[0].PropertyName.ShouldEqual("Foo.Name");
+
+			result = validator.Validate(new Root {Foo = new FooImpl2()});
+			result.Errors.Count.ShouldEqual(1);
+			result.Errors[0].PropertyName.ShouldEqual("Foo.Number");
+
+		}
+
+		[Fact]
+		public async Task Validates_with_callback_accepting_derived_async() {
+			var validator = new InlineValidator<Root>();
+			var impl1Validator = new InlineValidator<FooImpl1>();
+			var impl2Validator = new InlineValidator<FooImpl2>();
+
+			impl1Validator.RuleFor(x => x.Name).MustAsync((s, token) => Task.FromResult(s != null));
+			impl2Validator.RuleFor(x => x.Number).MustAsync((i, token) => Task.FromResult(i > 0));
+
+			validator.RuleFor(x => x.Foo).SetInheritanceValidator(v => {
+				v.Add<FooImpl1>((x, impl1) => {
+						Assert.NotNull(impl1);
+						return impl1Validator;
+					})
+					.Add<FooImpl2>((x, impl2) => {
+						Assert.NotNull(impl2);
+						return impl2Validator;
+					});
+			});
+
+			var result = await validator.ValidateAsync(new Root {Foo = new FooImpl1()});
+			result.Errors.Count.ShouldEqual(1);
+			result.Errors[0].PropertyName.ShouldEqual("Foo.Name");
+
+			result = await validator.ValidateAsync(new Root {Foo = new FooImpl2()});
+			result.Errors.Count.ShouldEqual(1);
+			result.Errors[0].PropertyName.ShouldEqual("Foo.Number");
+
+		}
+
+
+
 		[Fact]
 		public void Validates_ruleset() {
 			var validator = new InlineValidator<Root>();
diff --git a/src/FluentValidation/FluentValidation.csproj b/src/FluentValidation/FluentValidation.csproj
index d79630c9..8560b7a0 100644
--- a/src/FluentValidation/FluentValidation.csproj
+++ b/src/FluentValidation/FluentValidation.csproj
@@ -5,9 +5,8 @@
     <PackageReleaseNotes>
 FluentValidation 9 is a major release. Please read the upgrade notes at https://docs.fluentvalidation.net/en/latest/upgrading-to-9.html
 
-Changes in 9.3.0:
-* Improvements to LanguageManager's lazy loading of resources.
-* Deprecate IStringSource and its implementors. Use delegates instead. 
+Changes in 9.2.2:
+* Fix one of the inheritance validator overloads not working correctly.
 
 Changes in 9.2.1:
 * Add non-generic Add method to inheritance validator.
diff --git a/src/FluentValidation/Validators/PolymorphicValidator.cs b/src/FluentValidation/Validators/PolymorphicValidator.cs
index f7d9d6cb..83cc7766 100644
--- a/src/FluentValidation/Validators/PolymorphicValidator.cs
+++ b/src/FluentValidation/Validators/PolymorphicValidator.cs
@@ -32,7 +32,7 @@ namespace FluentValidation.Validators {
 	/// <typeparam name="T">Root model type</typeparam>
 	/// <typeparam name="TProperty">Base type of property being validated.</typeparam>
 	public class PolymorphicValidator<T, TProperty> : ChildValidatorAdaptor<T, TProperty> {
-		readonly Dictionary<Type, ValidatorWrapper> _derivedValidators = new Dictionary<Type, ValidatorWrapper>();
+		readonly Dictionary<Type, DerivedValidatorFactory> _derivedValidators = new Dictionary<Type, DerivedValidatorFactory>();
 
 		// Need the base constructor call, even though we're just passing null.
 		public PolymorphicValidator() : base((IValidator<TProperty>) null, typeof(IValidator<TProperty>)) {
@@ -47,7 +47,7 @@ public class PolymorphicValidator<T, TProperty> : ChildValidatorAdaptor<T, TProp
 		/// <returns></returns>
 		public PolymorphicValidator<T, TProperty> Add<TDerived>(IValidator<TDerived> derivedValidator, params string[] ruleSets) where TDerived : TProperty {
 			if (derivedValidator == null) throw new ArgumentNullException(nameof(derivedValidator));
-			_derivedValidators[typeof(TDerived)] = new ValidatorWrapper(derivedValidator, ruleSets);
+			_derivedValidators[typeof(TDerived)] = new DerivedValidatorFactory(derivedValidator, ruleSets);
 			return this;
 		}
 
@@ -60,7 +60,7 @@ public class PolymorphicValidator<T, TProperty> : ChildValidatorAdaptor<T, TProp
 		/// <returns></returns>
 		public PolymorphicValidator<T, TProperty> Add<TDerived>(Func<T, IValidator<TDerived>> validatorFactory, params string[] ruleSets) where TDerived : TProperty {
 			if (validatorFactory == null) throw new ArgumentNullException(nameof(validatorFactory));
-			_derivedValidators[typeof(TDerived)] = new ValidatorWrapper(context => validatorFactory((T)context.ParentContext.InstanceToValidate), ruleSets);
+			_derivedValidators[typeof(TDerived)] = new DerivedValidatorFactory(context => validatorFactory((T)context.ParentContext.InstanceToValidate), ruleSets);
 			return this;
 		}
 
@@ -73,7 +73,7 @@ public class PolymorphicValidator<T, TProperty> : ChildValidatorAdaptor<T, TProp
 		/// <returns></returns>
 		public PolymorphicValidator<T, TProperty> Add<TDerived>(Func<T, TDerived, IValidator<TDerived>> validatorFactory, params string[] ruleSets) where TDerived : TProperty {
 			if (validatorFactory == null) throw new ArgumentNullException(nameof(validatorFactory));
-			_derivedValidators[typeof(TDerived)] = new ValidatorWrapper(context => validatorFactory((T)context.ParentContext.InstanceToValidate, (TDerived)context.PropertyValue), ruleSets);
+			_derivedValidators[typeof(TDerived)] = new DerivedValidatorFactory(context => validatorFactory((T)context.ParentContext.InstanceToValidate, (TDerived)context.PropertyValue), ruleSets);
 			return this;
 		}
 
@@ -94,7 +94,7 @@ public class PolymorphicValidator<T, TProperty> : ChildValidatorAdaptor<T, TProp
 				throw new InvalidOperationException($"Validator {validator.GetType().Name} can't validate instances of type {subclassType.Name}");
 			}
 
-			_derivedValidators[subclassType] = new ValidatorWrapper(validator, ruleSets);
+			_derivedValidators[subclassType] = new DerivedValidatorFactory(validator, ruleSets);
 			return this;
 		}
 
@@ -102,8 +102,8 @@ public class PolymorphicValidator<T, TProperty> : ChildValidatorAdaptor<T, TProp
 			// bail out if the current item is null
 			if (context.PropertyValue == null) return null;
 
-			if (_derivedValidators.TryGetValue(context.PropertyValue.GetType(), out var derivedValidator)) {
-				return derivedValidator;
+			if (_derivedValidators.TryGetValue(context.PropertyValue.GetType(), out var derivedValidatorFactory)) {
+				return new ValidatorWrapper(derivedValidatorFactory.GetValidator(context), derivedValidatorFactory.RuleSets);
 			}
 
 			return null;
@@ -122,12 +122,31 @@ public class PolymorphicValidator<T, TProperty> : ChildValidatorAdaptor<T, TProp
 			return newContext;
 		}
 
+		private class DerivedValidatorFactory {
+			private IValidator _innerValidator;
+			private readonly Func<PropertyValidatorContext, IValidator> _factory;
+			public string[] RuleSets { get; }
+
+			public DerivedValidatorFactory(IValidator innerValidator, string[] ruleSets) {
+				_innerValidator = innerValidator;
+				RuleSets = ruleSets;
+			}
+
+			public DerivedValidatorFactory(Func<PropertyValidatorContext, IValidator> factory, string[] ruleSets) {
+				RuleSets = ruleSets;
+				_factory = factory;
+			}
+
+			public IValidator GetValidator(PropertyValidatorContext context) {
+				return _factory?.Invoke(context) ?? _innerValidator;
+			}
+		}
+
 
 		// This validator is a pass-through to handle the type conversion.
 		private class ValidatorWrapper : IValidator<TProperty> {
 
 			private readonly IValidator _innerValidator;
-			private readonly Func<ICommonContext, IValidator> _validatorFactory;
 			public string[] RuleSets { get; }
 
 			public ValidatorWrapper(IValidator innerValidator, string[] ruleSets) {
@@ -135,21 +154,12 @@ private class ValidatorWrapper : IValidator<TProperty> {
 				RuleSets = ruleSets;
 			}
 
-			public ValidatorWrapper(Func<ICommonContext, IValidator> validatorFactory, string[] ruleSets) {
-				_validatorFactory = validatorFactory;
-				RuleSets = ruleSets;
-			}
-
 			public ValidationResult Validate(IValidationContext context) {
-				return _validatorFactory != null
-					? _validatorFactory(context).Validate(context)
-					: _innerValidator.Validate(context);
+				return _innerValidator.Validate(context);
 			}
 
 			public Task<ValidationResult> ValidateAsync(IValidationContext context, CancellationToken cancellation = new CancellationToken()) {
-				return _validatorFactory != null
-					? _validatorFactory(context).ValidateAsync(context, cancellation)
-					: _innerValidator.ValidateAsync(context, cancellation);
+				return _innerValidator.ValidateAsync(context, cancellation);
 			}
 
 			public IValidatorDescriptor CreateDescriptor() {
