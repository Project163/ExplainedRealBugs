diff --git a/src/Monolog/Handler/FilterHandler.php b/src/Monolog/Handler/FilterHandler.php
index 938c1a7e..11ede52e 100644
--- a/src/Monolog/Handler/FilterHandler.php
+++ b/src/Monolog/Handler/FilterHandler.php
@@ -12,6 +12,7 @@
 namespace Monolog\Handler;
 
 use Monolog\Logger;
+use Monolog\Formatter\FormatterInterface;
 
 /**
  * Simple handler wrapper that filters records based on a list of levels
@@ -45,7 +46,7 @@ class FilterHandler extends AbstractHandler
     protected $bubble;
 
     /**
-     * @param callable|HandlerInterface $handler        Handler or factory callable($record, $this).
+     * @param callable|HandlerInterface $handler        Handler or factory callable($record|null, $filterHandler).
      * @param int|array                 $minLevelOrList A list of levels to accept or a minimum level if maxLevel is provided
      * @param int                       $maxLevel       Maximum level to accept, only used if $minLevelOrList is not an array
      * @param bool                      $bubble         Whether the messages that are handled can bubble up the stack or not
@@ -104,21 +105,13 @@ class FilterHandler extends AbstractHandler
             return false;
         }
 
-        // The same logic as in FingersCrossedHandler
-        if (!$this->handler instanceof HandlerInterface) {
-            $this->handler = call_user_func($this->handler, $record, $this);
-            if (!$this->handler instanceof HandlerInterface) {
-                throw new \RuntimeException("The factory callable should return a HandlerInterface");
-            }
-        }
-
         if ($this->processors) {
             foreach ($this->processors as $processor) {
                 $record = call_user_func($processor, $record);
             }
         }
 
-        $this->handler->handle($record);
+        $this->getHandler($record)->handle($record);
 
         return false === $this->bubble;
     }
@@ -135,6 +128,43 @@ class FilterHandler extends AbstractHandler
             }
         }
 
-        $this->handler->handleBatch($filtered);
+        $this->getHandler($filtered[count($filtered) - 1])->handleBatch($filtered);
+    }
+
+    /**
+     * Return the nested handler
+     *
+     * If the handler was provided as a factory callable, this will trigger the handler's instantiation.
+     *
+     * @return HandlerInterface
+     */
+    public function getHandler(array $record = null)
+    {
+        if (!$this->handler instanceof HandlerInterface) {
+            $this->handler = call_user_func($this->handler, $record, $this);
+            if (!$this->handler instanceof HandlerInterface) {
+                throw new \RuntimeException("The factory callable should return a HandlerInterface");
+            }
+        }
+
+        return $this->handler;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function setFormatter(FormatterInterface $formatter)
+    {
+        $this->getHandler()->setFormatter($formatter);
+
+        return $this;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getFormatter()
+    {
+        return $this->getHandler()->getFormatter();
     }
 }
diff --git a/src/Monolog/Handler/FingersCrossedHandler.php b/src/Monolog/Handler/FingersCrossedHandler.php
index 275fd513..cdabc445 100644
--- a/src/Monolog/Handler/FingersCrossedHandler.php
+++ b/src/Monolog/Handler/FingersCrossedHandler.php
@@ -15,6 +15,7 @@ use Monolog\Handler\FingersCrossed\ErrorLevelActivationStrategy;
 use Monolog\Handler\FingersCrossed\ActivationStrategyInterface;
 use Monolog\Logger;
 use Monolog\ResettableInterface;
+use Monolog\Formatter\FormatterInterface;
 
 /**
  * Buffers all records until a certain level is reached
@@ -39,7 +40,7 @@ class FingersCrossedHandler extends AbstractHandler
     protected $passthruLevel;
 
     /**
-     * @param callable|HandlerInterface       $handler            Handler or factory callable($record, $fingersCrossedHandler).
+     * @param callable|HandlerInterface       $handler            Handler or factory callable($record|null, $fingersCrossedHandler).
      * @param int|ActivationStrategyInterface $activationStrategy Strategy which determines when this handler takes action
      * @param int                             $bufferSize         How many entries should be buffered at most, beyond that the oldest items are removed from the buffer.
      * @param bool                            $bubble             Whether the messages that are handled can bubble up the stack or not
@@ -88,15 +89,7 @@ class FingersCrossedHandler extends AbstractHandler
         if ($this->stopBuffering) {
             $this->buffering = false;
         }
-        if (!$this->handler instanceof HandlerInterface) {
-            $record = end($this->buffer) ?: null;
-
-            $this->handler = call_user_func($this->handler, $record, $this);
-            if (!$this->handler instanceof HandlerInterface) {
-                throw new \RuntimeException("The factory callable should return a HandlerInterface");
-            }
-        }
-        $this->handler->handleBatch($this->buffer);
+        $this->getHandler(end($this->buffer) ?: null)->handleBatch($this->buffer);
         $this->buffer = array();
     }
 
@@ -120,7 +113,7 @@ class FingersCrossedHandler extends AbstractHandler
                 $this->activate();
             }
         } else {
-            $this->handler->handle($record);
+            $this->getHandler($record)->handle($record);
         }
 
         return false === $this->bubble;
@@ -140,8 +133,8 @@ class FingersCrossedHandler extends AbstractHandler
 
         parent::reset();
 
-        if ($this->handler instanceof ResettableInterface) {
-            $this->handler->reset();
+        if ($this->getHandler() instanceof ResettableInterface) {
+            $this->getHandler()->reset();
         }
     }
 
@@ -167,11 +160,48 @@ class FingersCrossedHandler extends AbstractHandler
                 return $record['level'] >= $level;
             });
             if (count($this->buffer) > 0) {
-                $this->handler->handleBatch($this->buffer);
+                $this->getHandler(end($this->buffer) ?: null)->handleBatch($this->buffer);
             }
         }
 
         $this->buffer = array();
         $this->buffering = true;
     }
+
+    /**
+     * Return the nested handler
+     *
+     * If the handler was provided as a factory callable, this will trigger the handler's instantiation.
+     *
+     * @return HandlerInterface
+     */
+    public function getHandler(array $record = null)
+    {
+        if (!$this->handler instanceof HandlerInterface) {
+            $this->handler = call_user_func($this->handler, $record, $this);
+            if (!$this->handler instanceof HandlerInterface) {
+                throw new \RuntimeException("The factory callable should return a HandlerInterface");
+            }
+        }
+
+        return $this->handler;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function setFormatter(FormatterInterface $formatter)
+    {
+        $this->getHandler()->setFormatter($formatter);
+
+        return $this;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getFormatter()
+    {
+        return $this->getHandler()->getFormatter();
+    }
 }
diff --git a/src/Monolog/Handler/SamplingHandler.php b/src/Monolog/Handler/SamplingHandler.php
index 9509ae37..b547ed7d 100644
--- a/src/Monolog/Handler/SamplingHandler.php
+++ b/src/Monolog/Handler/SamplingHandler.php
@@ -11,6 +11,8 @@
 
 namespace Monolog\Handler;
 
+use Monolog\Formatter\FormatterInterface;
+
 /**
  * Sampling handler
  *
@@ -38,7 +40,7 @@ class SamplingHandler extends AbstractHandler
     protected $factor;
 
     /**
-     * @param callable|HandlerInterface $handler Handler or factory callable($record, $fingersCrossedHandler).
+     * @param callable|HandlerInterface $handler Handler or factory callable($record|null, $samplingHandler).
      * @param int                       $factor  Sample factor
      */
     public function __construct($handler, $factor)
@@ -54,29 +56,58 @@ class SamplingHandler extends AbstractHandler
 
     public function isHandling(array $record)
     {
-        return $this->handler->isHandling($record);
+        return $this->getHandler($record)->isHandling($record);
     }
 
     public function handle(array $record)
     {
         if ($this->isHandling($record) && mt_rand(1, $this->factor) === 1) {
-            // The same logic as in FingersCrossedHandler
-            if (!$this->handler instanceof HandlerInterface) {
-                $this->handler = call_user_func($this->handler, $record, $this);
-                if (!$this->handler instanceof HandlerInterface) {
-                    throw new \RuntimeException("The factory callable should return a HandlerInterface");
-                }
-            }
-
             if ($this->processors) {
                 foreach ($this->processors as $processor) {
                     $record = call_user_func($processor, $record);
                 }
             }
 
-            $this->handler->handle($record);
+            $this->getHandler($record)->handle($record);
         }
 
         return false === $this->bubble;
     }
+
+    /**
+     * Return the nested handler
+     *
+     * If the handler was provided as a factory callable, this will trigger the handler's instantiation.
+     *
+     * @return HandlerInterface
+     */
+    public function getHandler(array $record = null)
+    {
+        if (!$this->handler instanceof HandlerInterface) {
+            $this->handler = call_user_func($this->handler, $record, $this);
+            if (!$this->handler instanceof HandlerInterface) {
+                throw new \RuntimeException("The factory callable should return a HandlerInterface");
+            }
+        }
+
+        return $this->handler;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function setFormatter(FormatterInterface $formatter)
+    {
+        $this->getHandler()->setFormatter($formatter);
+
+        return $this;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getFormatter()
+    {
+        return $this->getHandler()->getFormatter();
+    }
 }
