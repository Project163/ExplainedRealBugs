diff --git a/src/main/java/com/nerdwin15/stash/webhook/service/BranchEvaluator.java b/src/main/java/com/nerdwin15/stash/webhook/service/BranchEvaluator.java
new file mode 100644
index 0000000..32c6339
--- /dev/null
+++ b/src/main/java/com/nerdwin15/stash/webhook/service/BranchEvaluator.java
@@ -0,0 +1,22 @@
+package com.nerdwin15.stash.webhook.service;
+
+import java.util.Collection;
+
+import com.atlassian.stash.repository.RefChange;
+
+/**
+ * An evaluator that provides the branches that were affected by various
+ * RefChanges.
+ *
+ * @author Michael Irwin (mikesir87)
+ */
+public interface BranchEvaluator {
+
+  /**
+   * Get the branches that were affected by the provided refChanges.
+   * @param refChanges The changes due to a commit.
+   * @return The branch names affected by the provided ref changes.
+   */
+  Iterable<String> getBranches(Collection<RefChange> refChanges);
+  
+}
diff --git a/src/main/java/com/nerdwin15/stash/webhook/service/ConcreteBranchEvaluator.java b/src/main/java/com/nerdwin15/stash/webhook/service/ConcreteBranchEvaluator.java
new file mode 100644
index 0000000..cbfeaee
--- /dev/null
+++ b/src/main/java/com/nerdwin15/stash/webhook/service/ConcreteBranchEvaluator.java
@@ -0,0 +1,45 @@
+package com.nerdwin15.stash.webhook.service;
+
+import java.util.Collection;
+
+import com.atlassian.stash.repository.RefChange;
+import com.atlassian.stash.repository.RefChangeType;
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterables;
+
+/**
+ * A concrete implementation of the {@link BranchEvaluator} that uses sample
+ * code from the Atlassian stash-webhook-plugin:
+ * 
+ * https://bitbucket.org/atlassian/stash-webhook-plugin/src/a18713fad2959e670e355df64c840b79a806d8ab/src/main/java/com/atlassian/stash/plugin/webook/WebHook.java?at=master
+ *
+ * @author Michael Irwin (mikesir87)
+ */
+public class ConcreteBranchEvaluator implements BranchEvaluator {
+
+  private static final String REFS_HEADS = "refs/heads/";
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public Iterable<String> getBranches(Collection<RefChange> refChanges) {
+    return Iterables.transform(
+        Iterables.filter(refChanges, new Predicate<RefChange>() {
+          @Override
+          public boolean apply(RefChange input) {
+            // We only care about non-deleted branches
+            return input.getType() != RefChangeType.DELETE
+                && input.getRefId().startsWith(REFS_HEADS);
+          }
+        }), new Function<RefChange, String>() {
+          @Override
+          public String apply(RefChange input) {
+            // Not 100% sure whether this is _just_ branch or is full ref?
+            return input.getRefId().replace(REFS_HEADS, "");
+          }
+        });
+  }
+
+}
diff --git a/src/main/java/com/nerdwin15/stash/webhook/service/eligibility/BranchEligibilityFilter.java b/src/main/java/com/nerdwin15/stash/webhook/service/eligibility/BranchEligibilityFilter.java
new file mode 100644
index 0000000..497f6f2
--- /dev/null
+++ b/src/main/java/com/nerdwin15/stash/webhook/service/eligibility/BranchEligibilityFilter.java
@@ -0,0 +1,81 @@
+package com.nerdwin15.stash.webhook.service.eligibility;
+
+import com.atlassian.stash.event.RepositoryPushEvent;
+import com.atlassian.stash.setting.Settings;
+import com.nerdwin15.stash.webhook.Notifier;
+import com.nerdwin15.stash.webhook.service.BranchEvaluator;
+import com.nerdwin15.stash.webhook.service.SettingsService;
+
+/**
+ * Defines an eligibility filter that provides the ability to create a 
+ * black/whitelist of branches to ignore or accept commits for notification
+ * sending.
+ * 
+ * @author Michael Irwin (mikesir87)
+ */
+public class BranchEligibilityFilter 
+    implements EligibilityFilter {
+
+  private SettingsService settingsService;
+  private BranchEvaluator branchEvaluator;
+  
+  /**
+   * Create a new instance.
+   * @param settingsService The settings service
+   * @param branchEvaluator An evaluator to determine affected branches.
+   */
+  public BranchEligibilityFilter(SettingsService settingsService, 
+      BranchEvaluator branchEvaluator) {
+    this.settingsService = settingsService;
+    this.branchEvaluator = branchEvaluator;
+  }
+  
+  
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public boolean shouldDeliverNotification(EventContext context) {
+    if (!RepositoryPushEvent.class.isAssignableFrom(context.getEventSource()
+        .getClass()))
+      return true;
+    
+    RepositoryPushEvent event = (RepositoryPushEvent) context.getEventSource();
+
+    final Settings settings = settingsService.getSettings(
+        context.getRepository());
+    String branchOption = settings.getString(Notifier.BRANCH_OPTIONS);
+    if (branchOption == null || 
+        (!branchOption.equals("blacklist") && !branchOption.equals("whitelist")))
+      return true;
+    
+    String[] branchesSettings = 
+        settings.getString(Notifier.BRANCH_OPTIONS_BRANCHES).split(" ");
+    Iterable<String> branches = 
+        branchEvaluator.getBranches(event.getRefChanges());
+    
+    boolean haveMatch = hasMatch(branchesSettings, branches);
+    if (haveMatch && branchOption.equals("blacklist"))
+      return false;
+    else if (!haveMatch && branchOption.equals("whitelist"))
+      return false;
+    return true;
+  }
+  
+  protected boolean hasMatch(String[] settings, 
+      Iterable<String> affectedBranches) {
+    for (String branch : affectedBranches) {
+      branch = branch.toLowerCase();
+      for (String s : settings) {
+        s = s.toLowerCase();
+        if (s.endsWith("*") && branch.startsWith(s.substring(0, s.length() - 1)))
+          return true;
+        if (s.equals(branch))
+          return true;
+      }
+    }
+    
+    return false;
+  }
+
+}
diff --git a/src/main/resources/atlassian-plugin.xml b/src/main/resources/atlassian-plugin.xml
index 6024cfb..e091ad1 100644
--- a/src/main/resources/atlassian-plugin.xml
+++ b/src/main/resources/atlassian-plugin.xml
@@ -10,7 +10,10 @@
     <component-import key="navBuilder" interface="com.atlassian.stash.nav.NavBuilder"/>
     <component-import key="applicationProperties" interface="com.atlassian.sal.api.ApplicationProperties"/>
 
+    <component key="branchEvaluator" class="com.nerdwin15.stash.webhook.service.ConcreteBranchEvaluator" />
+
     <!-- Eligibility Filter Setup -->
+    <component key="branchesFilter" class="com.nerdwin15.stash.webhook.service.eligibility.BranchEligibilityFilter" />
     <component key="ignoreCommitersFilter" class="com.nerdwin15.stash.webhook.service.eligibility.IgnoreCommittersEligibilityFilter" />
     <component key="isMergeableEligibilityFilter" class="com.nerdwin15.stash.webhook.service.eligibility.IsMergeableEligibilityFilter" />
     <component key="pullRequestRescopeEligibilityFilter" class="com.nerdwin15.stash.webhook.service.eligibility.PullRequestRescopeEligibilityFilter" />
diff --git a/src/test/java/com/nerdwin15/stash/webhook/service/eligibility/BranchEligibilityFilterTest.java b/src/test/java/com/nerdwin15/stash/webhook/service/eligibility/BranchEligibilityFilterTest.java
new file mode 100644
index 0000000..a4cc3a0
--- /dev/null
+++ b/src/test/java/com/nerdwin15/stash/webhook/service/eligibility/BranchEligibilityFilterTest.java
@@ -0,0 +1,135 @@
+package com.nerdwin15.stash.webhook.service.eligibility;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import com.atlassian.stash.event.RepositoryPushEvent;
+import com.atlassian.stash.repository.RefChange;
+import com.atlassian.stash.repository.Repository;
+import com.atlassian.stash.setting.Settings;
+import com.nerdwin15.stash.webhook.Notifier;
+import com.nerdwin15.stash.webhook.service.BranchEvaluator;
+import com.nerdwin15.stash.webhook.service.SettingsService;
+
+/**
+ * Test case for the {@link BranchEligibilityFilter} filter.
+ *
+ * @author Michael Irwin (mikesir87)
+ */
+public class BranchEligibilityFilterTest {
+
+  private SettingsService settingsService;
+  private Settings settings;
+  private BranchEvaluator branchEvaluator;
+  private BranchEligibilityFilter filter;
+  private Repository repo;
+  private RepositoryPushEvent event;
+  private EventContext eventContext;
+  private String branches = "ignoreMe wild*";
+  private Collection<RefChange> changes = new ArrayList<RefChange>();
+  
+  /**
+   * Perform setup tasks
+   */
+  @Before
+  public void setUp() {
+    settingsService = mock(SettingsService.class);
+    settings = mock(Settings.class);
+    branchEvaluator = mock(BranchEvaluator.class);
+    event = mock(RepositoryPushEvent.class);
+    repo = mock(Repository.class);
+    eventContext = mock(EventContext.class);
+    
+    when(event.getRefChanges()).thenReturn(changes);
+    when(eventContext.getEventSource()).thenReturn(event);
+    when(eventContext.getRepository()).thenReturn(repo);
+    when(settingsService.getSettings(repo)).thenReturn(settings);
+    when(settings.getString(Notifier.BRANCH_OPTIONS)).thenReturn("blacklist");
+    when(settings.getString(Notifier.BRANCH_OPTIONS_BRANCHES))
+        .thenReturn(branches);
+    
+    filter = new BranchEligibilityFilter(settingsService, branchEvaluator);    
+  }
+  
+  /**
+   * Validate that the matcher works as expected
+   */
+  @Test
+  public void testHasMatchMethod() {
+    assertTrue(filter.hasMatch(array("master"), iterable("master")));
+    assertTrue(filter.hasMatch(array("mas*"), iterable("master")));
+    assertFalse(filter.hasMatch(array("master"), iterable("develop")));
+    assertTrue(filter.hasMatch(array("master", "deve*"), iterable("develop")));
+    assertFalse(filter.hasMatch(array("mas*", "dev*"), iterable("issue")));
+    assertTrue(filter.hasMatch(array("MASTER", "DEVE*"), iterable("develop")));
+    assertTrue(filter.hasMatch(array("master", "deve*"), iterable("DEVELOP")));
+  }
+  
+  /**
+   * Validate that if another event type is provided, the filter doesn't process
+   * it.
+   */
+  @Test
+  public void testEnsureOnlyWorksWithRepositoryPushEvents() {
+    when(eventContext.getEventSource()).thenReturn("Something else");
+    assertTrue(filter.shouldDeliverNotification(eventContext));
+  }
+  
+  /**
+   * Validate that if no branch option (blacklist/whitelist) was provided, the
+   * filter passes the notification.
+   */
+  @Test
+  public void testEnsureIfNoBranchOptionIsProvidedFilterPasses() {
+    when(settings.getString(Notifier.BRANCH_OPTIONS)).thenReturn(null);
+    assertTrue(filter.shouldDeliverNotification(eventContext));
+    
+    when(settingsService.getSettings(repo)).thenReturn(settings);
+    when(settings.getString(Notifier.BRANCH_OPTIONS)).thenReturn("somethingElse");
+    assertTrue(filter.shouldDeliverNotification(eventContext));
+  }
+  
+  /**
+   * Ensure that if a branch is blacklisted, a notification isn't sent for it.
+   */
+  @Test
+  public void testBlacklistingWorks() {
+    when(branchEvaluator.getBranches(changes)).thenReturn(iterable("wildCard"));
+    assertFalse(filter.shouldDeliverNotification(eventContext));
+
+    when(branchEvaluator.getBranches(changes)).thenReturn(iterable("asdf"));
+    assertTrue(filter.shouldDeliverNotification(eventContext));
+  }
+  
+  /**
+   * Ensure that if a branch is blacklisted, a notification isn't sent for it.
+   */
+  @Test
+  public void testWhitelistingWorks() {
+    when(settings.getString(Notifier.BRANCH_OPTIONS)).thenReturn("whitelist");
+    when(branchEvaluator.getBranches(changes)).thenReturn(iterable("wildCard"));
+    assertTrue(filter.shouldDeliverNotification(eventContext));
+
+    when(branchEvaluator.getBranches(changes)).thenReturn(iterable("asdf"));
+    assertFalse(filter.shouldDeliverNotification(eventContext));
+  }
+  
+  private String[] array(String... elements) {
+    return elements;
+  }
+  
+  private List<String> iterable(String... elements) {
+    return new ArrayList<String>(Arrays.asList(elements));
+  }
+  
+}
