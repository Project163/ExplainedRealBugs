diff --git a/LottieSample/src/androidTest/java/com/airbnb/lottie/LottieSnapshotProvider.java b/LottieSample/src/androidTest/java/com/airbnb/lottie/LottieSnapshotProvider.java
index 009b3c1b..6c7b9e7d 100644
--- a/LottieSample/src/androidTest/java/com/airbnb/lottie/LottieSnapshotProvider.java
+++ b/LottieSample/src/androidTest/java/com/airbnb/lottie/LottieSnapshotProvider.java
@@ -79,6 +79,7 @@ public class LottieSnapshotProvider extends SnapshotProvider {
     testDynamicProperties();
     testSwitchingToDrawableAndBack();
     testStartEndFrameWithStartEndProgress();
+    testUrl();
   }
 
   private void snapshotAssets(String[] animations) {
@@ -561,6 +562,11 @@ public class LottieSnapshotProvider extends SnapshotProvider {
 
   }
 
+  private void testUrl() {
+    LottieComposition composition = LottieCompositionFactory.fromUrlSync(context, "https://www.lottiefiles.com/download/427").getValue();
+    drawComposition(composition, "GiftBox from LottieFiles URL (427)");
+  }
+
   private int dpToPx(int dp) {
     Resources resources = context.getResources();
     return (int) TypedValue.applyDimension(1, (float) dp, resources.getDisplayMetrics());
diff --git a/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/LottieApplication.kt b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/LottieApplication.kt
index 84ee79f7..5bfcf820 100644
--- a/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/LottieApplication.kt
+++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/LottieApplication.kt
@@ -1,6 +1,7 @@
 package com.airbnb.lottie.samples
 
 import android.support.multidex.MultiDexApplication
+import com.airbnb.lottie.L
 import com.google.gson.FieldNamingPolicy
 import com.google.gson.GsonBuilder
 import okhttp3.OkHttpClient
@@ -31,4 +32,9 @@ class LottieApplication : MultiDexApplication() {
     }
 
     val lottiefilesService by lazy { retrofit.create(LottiefilesService::class.java) }
+
+    override fun onCreate() {
+        super.onCreate()
+        L.DBG = true;
+    }
 }
\ No newline at end of file
diff --git a/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/PlayerViewModel.kt b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/PlayerViewModel.kt
index 4ebece11..ac90cc81 100644
--- a/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/PlayerViewModel.kt
+++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/PlayerViewModel.kt
@@ -1,31 +1,17 @@
 package com.airbnb.lottie.samples
 
-import android.annotation.SuppressLint
 import android.app.Application
 import android.arch.lifecycle.AndroidViewModel
 import android.arch.lifecycle.MutableLiveData
-import android.graphics.Bitmap
-import android.graphics.BitmapFactory
 import android.net.Uri
 import android.os.Handler
 import android.os.Looper
 import com.airbnb.lottie.LottieComposition
 import com.airbnb.lottie.LottieCompositionFactory
-import com.airbnb.lottie.samples.R.id.url
+import com.airbnb.lottie.LottieTask
 import com.airbnb.lottie.samples.model.CompositionArgs
-import io.reactivex.Observable
-import io.reactivex.android.schedulers.AndroidSchedulers
-import io.reactivex.schedulers.Schedulers
-import okhttp3.CacheControl
-import okhttp3.MediaType
-import okhttp3.Request
-import okhttp3.Response
-import okhttp3.ResponseBody
 import java.io.FileInputStream
 import java.io.FileNotFoundException
-import java.io.IOException
-import java.util.concurrent.TimeUnit
-import java.util.zip.ZipInputStream
 
 class PlayerViewModel(application: Application) : AndroidViewModel(application) {
 
@@ -36,110 +22,33 @@ class PlayerViewModel(application: Application) : AndroidViewModel(application)
 
     fun fetchAnimation(args: CompositionArgs) {
         val url = args.url ?: args.animationData?.lottieLink
-        if (url != null) {
-            fetchAnimationByUrl(url)
-        } else if (args.fileUri != null) {
-            fetchAnimationByFileUri(args.fileUri)
-        } else if (args.asset != null) {
-            fetchAnimationByAsset(args.asset)
-        }
-    }
-
-    private fun fetchAnimationByUrl(url: String) {
-        val request = try {
-            Request.Builder()
-                    .cacheControl(CacheControl.Builder()
-                            .maxAge(Int.MAX_VALUE, TimeUnit.DAYS)
-                            .build())
-                    .url(url)
-                    .build()
-        } catch (e: IllegalArgumentException) {
-            error.value = e
-            return
-        }
-        getApplication<LottieApplication>().okHttpClient
-                .newCall(request)
-                ?.enqueue(OkHttpCallback(
-                        onFailure = { _, e -> onFailure(e) },
-                        onResponse = { _, response -> onResponse(url, response) }
-                ))
-    }
-
-    private fun onFailure(e: Exception) {
-        handler.post { error.value = e }
-    }
 
-    fun onResponse(url: String, response: Response) {
-        handler.post {
-            if (!response.isSuccessful) {
-                onFailure(IllegalStateException("Response was unsuccessful."))
-            } else {
-                if (response.body()?.contentType() == MediaType.parse("application/zip")) {
-                    handleZipResponse(response.body()!!, url)
-                } else {
-                    val string = response.body()?.string()
-                    if (string == null) {
-                        onFailure(IllegalStateException("Response body was null"))
-                        return@post
-                    }
-                    handleJsonResponse(string, url)
-                }
-            }
+        val task = when {
+            url != null -> LottieCompositionFactory.fromUrl(getApplication(), url)
+            args.fileUri != null -> taskForUri(args.fileUri)
+            args.asset != null -> LottieCompositionFactory.fromAsset(getApplication(), args.asset)
+            else -> throw IllegalArgumentException("Don't know how to fetch animation for $args")
         }
+        registerTask(task)
     }
 
-    private fun handleJsonResponse(jsonString: String, cacheKey: String) {
-        LottieCompositionFactory.fromJsonString(jsonString, cacheKey)
-                .addListener {
-                    this.composition.value = it
-                }
-                .addFailureListener {
-                    this.error.value = it
-                }
-    }
-
-    @SuppressLint("CheckResult")
-    private fun handleZipResponse(body: ResponseBody, cacheKey: String) {
-        LottieCompositionFactory.fromZipStream(ZipInputStream(body.byteStream()), cacheKey)
-                .addListener {
-                    composition.value = it
-                }
-                .addFailureListener {
-                    error.value = it
-                }
-    }
-
-    private fun fetchAnimationByFileUri(uri: Uri) {
+    private fun taskForUri(uri: Uri): LottieTask<LottieComposition> {
         val fis = try {
             when (uri.scheme) {
                 "file" -> FileInputStream(uri.path)
                 "content" -> getApplication<LottieApplication>().contentResolver.openInputStream(uri)
-                else -> {
-                    error.value = IllegalArgumentException("Unknown scheme ${uri.scheme}")
-                    return
-                }
+                else -> return LottieTask() { throw IllegalArgumentException("Unknown scheme ${uri.scheme}") }
             }
         } catch (e: FileNotFoundException) {
-            error.value = e
-            return
+            return LottieTask() { throw e }
         }
 
-        LottieCompositionFactory.fromJsonInputStream(fis, uri.toString())
-                .addListener {
-                    this.composition.value = it
-                }
-                .addFailureListener {
-                    this.error.value = it
-                }
+        return LottieCompositionFactory.fromJsonInputStream(fis, uri.toString())
     }
 
-    private fun fetchAnimationByAsset(asset: String) {
-        LottieCompositionFactory.fromAsset(getApplication(), asset)
-                .addListener {
-                    composition.value = it
-                }
-                .addFailureListener {
-                    error.value = it
-                }
+    private fun registerTask(task: LottieTask<LottieComposition>) {
+        task
+                .addListener { composition.value = it }
+                .addFailureListener { error.value = it }
     }
 }
\ No newline at end of file
diff --git a/lottie/src/main/java/com/airbnb/lottie/L.java b/lottie/src/main/java/com/airbnb/lottie/L.java
index 79ecf25b..1e1dda9a 100644
--- a/lottie/src/main/java/com/airbnb/lottie/L.java
+++ b/lottie/src/main/java/com/airbnb/lottie/L.java
@@ -10,7 +10,7 @@ import java.util.Set;
 @RestrictTo(RestrictTo.Scope.LIBRARY)
 public class L {
   public static final String TAG = "LOTTIE";
-  public static final boolean DBG = false;
+  public static boolean DBG = false;
 
   /**
    * Set to ensure that we only log each message one time max.
@@ -24,6 +24,10 @@ public class L {
   private static int traceDepth = 0;
   private static int depthPastMaxDepth = 0;
 
+  public static void debug(String msg) {
+    if (DBG) Log.d(TAG, msg);
+  }
+
   /**
    * Warn to logcat. Keeps track of messages so they are only logged once ever.
    */
diff --git a/lottie/src/main/java/com/airbnb/lottie/LottieCompositionFactory.java b/lottie/src/main/java/com/airbnb/lottie/LottieCompositionFactory.java
index 725db2ad..581f6900 100644
--- a/lottie/src/main/java/com/airbnb/lottie/LottieCompositionFactory.java
+++ b/lottie/src/main/java/com/airbnb/lottie/LottieCompositionFactory.java
@@ -10,6 +10,7 @@ import android.support.annotation.WorkerThread;
 import android.util.JsonReader;
 
 import com.airbnb.lottie.model.LottieCompositionCache;
+import com.airbnb.lottie.network.NetworkFetcher;
 import com.airbnb.lottie.parser.LottieCompositionParser;
 
 import org.json.JSONObject;
@@ -34,6 +35,32 @@ public class LottieCompositionFactory {
   private LottieCompositionFactory() {
   }
 
+  /**
+   * Fetch an animation from an http url. Once it is downloaded once, Lottie will cache the file to disk for
+   * future use. Because of this, you may call `fromUrl` ahead of time to warm the cache if you think you
+   * might need an animation in the future.
+   */
+  public static LottieTask<LottieComposition> fromUrl(Context context, String url) {
+    return NetworkFetcher.fetch(context, url);
+  }
+
+  /**
+   * Fetch an animation from an http url. Once it is downloaded once, Lottie will cache the file to disk for
+   * future use. Because of this, you may call `fromUrl` ahead of time to warm the cache if you think you
+   * might need an animation in the future.
+   */
+  @WorkerThread
+  public static LottieResult<LottieComposition> fromUrlSync(Context context, String url) {
+    return NetworkFetcher.fetchSync(context, url);
+  }
+
+  /**
+   * Parse an animation from src/main/assets. It is recommended to use {@link #fromRawRes(Context, int)} instead.
+   * The asset file name will be used as a cache key so future usages won't have to parse the json again.
+   * However, if your animation has images, you may package the json and images as a single flattened zip file in assets.
+   *
+   * @see #fromZipStream(ZipInputStream, String)
+   */
   public static LottieTask<LottieComposition> fromAsset(Context context, final String fileName) {
     // Prevent accidentally leaking an Activity.
     final Context appContext = context.getApplicationContext();
@@ -45,8 +72,9 @@ public class LottieCompositionFactory {
   }
 
   /**
-   * Name of a files in src/main/assets. If it ends with zip, it will be parsed as a zip file. Otherwise, it will
-   * be parsed as json.
+   * Parse an animation from src/main/assets. It is recommended to use {@link #fromRawRes(Context, int)} instead.
+   * The asset file name will be used as a cache key so future usages won't have to parse the json again.
+   * However, if your animation has images, you may package the json and images as a single flattened zip file in assets.
    *
    * @see #fromZipStreamSync(ZipInputStream, String)
    */
@@ -63,6 +91,11 @@ public class LottieCompositionFactory {
     }
   }
 
+  /**
+   * Parse an animation from raw/res. This is recommended over putting your animation in assets because
+   * it uses a hard reference to R.
+   * The resource id will be used as a cache key so future usages won't parse the json again.
+   */
   public static LottieTask<LottieComposition> fromRawRes(Context context, @RawRes final int rawRes) {
     // Prevent accidentally leaking an Activity.
     final Context appContext = context.getApplicationContext();
@@ -73,6 +106,11 @@ public class LottieCompositionFactory {
     });
   }
 
+  /**
+   * Parse an animation from raw/res. This is recommended over putting your animation in assets because
+   * it uses a hard reference to R.
+   * The resource id will be used as a cache key so future usages won't parse the json again.
+   */
   @WorkerThread
   public static LottieResult<LottieComposition> fromRawResSync(Context context, @RawRes int resId) {
     try {
@@ -193,7 +231,7 @@ public class LottieCompositionFactory {
    * It will automatically store and configure any images inside the animation if they exist.
    */
   @WorkerThread
-  private static LottieResult<LottieComposition> fromZipStreamSync(ZipInputStream inputStream, @Nullable String cacheKey) {
+  public static LottieResult<LottieComposition> fromZipStreamSync(ZipInputStream inputStream, @Nullable String cacheKey) {
     try {
       return fromZipStreamSyncInternal(inputStream, cacheKey);
     } finally {
diff --git a/lottie/src/main/java/com/airbnb/lottie/LottieTask.java b/lottie/src/main/java/com/airbnb/lottie/LottieTask.java
index 2e154489..6421b828 100644
--- a/lottie/src/main/java/com/airbnb/lottie/LottieTask.java
+++ b/lottie/src/main/java/com/airbnb/lottie/LottieTask.java
@@ -12,7 +12,10 @@ import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+import java.util.concurrent.ThreadPoolExecutor;
 
 /**
  * Helper to run asynchronous tasks with a result.
@@ -23,6 +26,12 @@ import java.util.concurrent.FutureTask;
  */
 public class LottieTask<T> {
 
+  /**
+   * Set this to change the executor that LottieTasks are run on. This will be the executor that composition parsing and url
+   * fetching happens on.
+   */
+  public final Executor EXECUTOR = Executors.newCachedThreadPool();
+
   @Nullable private Thread taskObserver;
 
   /* Preserve add order. */
@@ -50,7 +59,7 @@ public class LottieTask<T> {
         setResult(new LottieResult<T>(e));
       }
     } else {
-      task.run();
+      EXECUTOR.execute(task);
       startTaskObserverIfNeeded();
     }
   }
@@ -173,23 +182,23 @@ public class LottieTask<T> {
     }
     taskObserver = new Thread("LottieTaskObserver") {
       @Override public void run() {
-        if (isInterrupted()) {
-          return;
-        }
-        if (task.isDone()) {
-          try {
-            setResult(task.get());
-          } catch (InterruptedException | ExecutionException e) {
-            setResult(new LottieResult<T>(e));
+        while (true) {
+          if (isInterrupted()) {
+            return;
+          }
+          if (task.isDone()) {
+            try {
+              setResult(task.get());
+            } catch (InterruptedException | ExecutionException e) {
+              setResult(new LottieResult<T>(e));
+            }
+            stopTaskObserverIfNeeded();
           }
-          stopTaskObserverIfNeeded();
         }
       }
     };
     taskObserver.start();
-    if (L.DBG) {
-      Log.d(L.TAG, "Starting TaskObserver thread");
-    }
+    L.debug("Starting TaskObserver thread");
   }
 
   /**
@@ -201,9 +210,8 @@ public class LottieTask<T> {
     }
     if (successListeners.isEmpty() || result != null) {
       taskObserver.interrupt();
-      if (L.DBG) {
-        Log.d(L.TAG, "Stopping TaskObserver thread");
-      }
+      taskObserver = null;
+      L.debug("Stopping TaskObserver thread");
     }
   }
 
diff --git a/lottie/src/main/java/com/airbnb/lottie/model/content/MergePaths.java b/lottie/src/main/java/com/airbnb/lottie/model/content/MergePaths.java
index 5223caef..5ce9fecc 100644
--- a/lottie/src/main/java/com/airbnb/lottie/model/content/MergePaths.java
+++ b/lottie/src/main/java/com/airbnb/lottie/model/content/MergePaths.java
@@ -55,7 +55,7 @@ public class MergePaths implements ContentModel {
 
   @Override @Nullable public Content toContent(LottieDrawable drawable, BaseLayer layer) {
     if (!drawable.enableMergePathsForKitKatAndAbove()) {
-      Log.w(L.TAG, "Animation contains merge paths but they are disabled.");
+      L.warn("Animation contains merge paths but they are disabled.");
       return null;
     }
     return new MergePathsContent(this);
diff --git a/lottie/src/main/java/com/airbnb/lottie/network/FileExtension.java b/lottie/src/main/java/com/airbnb/lottie/network/FileExtension.java
new file mode 100644
index 00000000..d8974679
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/network/FileExtension.java
@@ -0,0 +1,38 @@
+package com.airbnb.lottie.network;
+
+import android.util.JsonReader;
+
+import com.airbnb.lottie.L;
+
+/**
+ * Helpers for known Lottie file types.
+ */
+public enum FileExtension {
+  Json(".json"),
+  Zip(".zip");
+
+  public final String extension;
+
+  FileExtension(String extension) {
+    this.extension = extension;
+  }
+
+  public String tempExtension() {
+    return ".temp" + extension;
+  }
+
+  @Override public String toString() {
+    return extension;
+  }
+
+  public static FileExtension forFile(String filename) {
+    for (FileExtension e : values()) {
+      if (filename.endsWith(e.extension)) {
+        return e;
+      }
+    }
+    // Default to Json.
+    L.warn("Unable to find correct extension for " + filename);
+    return Json;
+  }
+}
diff --git a/lottie/src/main/java/com/airbnb/lottie/network/NetworkCache.java b/lottie/src/main/java/com/airbnb/lottie/network/NetworkCache.java
new file mode 100644
index 00000000..ccd50acd
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/network/NetworkCache.java
@@ -0,0 +1,133 @@
+package com.airbnb.lottie.network;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+import android.support.annotation.WorkerThread;
+import android.support.v4.util.Pair;
+
+import com.airbnb.lottie.L;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Helper class to save and restore animations fetched from an URL to the app disk cache.
+ */
+class NetworkCache {
+  private final Context appContext;
+  private final String url;
+
+  NetworkCache(Context appContext, String url) {
+    this.appContext = appContext.getApplicationContext();
+    this.url = url;
+  }
+
+  /**
+   * If the animation doesn't exist in the cache, null will be returned.
+   *
+   * Once the animation is successfully parsed, {@link #renameTempFile(FileExtension)} must be
+   * called to move the file from a temporary location to its permanent cache location so it can
+   * be used in the future.
+   */
+  @Nullable
+  @WorkerThread
+  Pair<FileExtension, InputStream> fetch() {
+    File cachedFile = null;
+    try {
+      cachedFile = getCachedFile(url);
+    } catch (FileNotFoundException e) {
+      return null;
+    }
+    if (cachedFile == null) {
+      return null;
+    }
+
+    FileInputStream inputStream;
+    try {
+      inputStream = new FileInputStream(cachedFile);
+    } catch (FileNotFoundException e) {
+      return null;
+    }
+
+    FileExtension extension;
+    if (cachedFile.getAbsolutePath().endsWith(".zip")) {
+      extension = FileExtension.Zip;
+    } else {
+      extension = FileExtension.Json;
+    }
+
+    L.debug("Cache hit for " + url + " at " + cachedFile.getAbsolutePath());
+    return new Pair<>(extension, (InputStream) inputStream);
+  }
+
+  /**
+   * Writes an InputStream from a network response to a temporary file. If the file successfully parses
+   * to an composition, {@link #renameTempFile(FileExtension)} should be called to move the file
+   * to its final location for future cache hits.
+   */
+  File writeTempCacheFile(InputStream stream, FileExtension extension) throws IOException {
+    String fileName = filenameForUrl(url, extension, true);
+    File file = new File(appContext.getCacheDir(), fileName);
+    try {
+      OutputStream output = new FileOutputStream(file);
+      //noinspection TryFinallyCanBeTryWithResources
+      try {
+        byte[] buffer = new byte[1024];
+        int read;
+
+        while ((read = stream.read(buffer)) != -1) {
+          output.write(buffer, 0, read);
+        }
+
+        output.flush();
+      } finally {
+        output.close();
+      }
+    } finally {
+      stream.close();
+    }
+    return file;
+  }
+
+  /**
+   * If the file created by {@link #writeTempCacheFile(InputStream, FileExtension)} was successfully parsed,
+   * this should be called to remove the temporary part of its name which will allow it to be a cache hit in the future.
+   */
+  void renameTempFile(FileExtension extension) {
+    String fileName = filenameForUrl(url, extension, true);
+    File file = new File(appContext.getCacheDir(), fileName);
+    String newFileName = file.getAbsolutePath().replace(".temp", "");
+    File newFile = new File(newFileName);
+    boolean renamed = file.renameTo(newFile);
+    L.debug("Copying temp file to real file (" + newFile + ")");
+    if (!renamed) {
+      L.warn( "Unable to rename cache file " + file.getAbsolutePath() + " to " + newFile.getAbsolutePath() + ".");
+    }
+  }
+
+  /**
+   * Returns the cache file for the given url if it exists. Checks for both json and zip.
+   * Returns null if neither exist.
+   */
+  @Nullable
+  private File getCachedFile(String url) throws FileNotFoundException {
+    File jsonFile = new File(appContext.getCacheDir(), filenameForUrl(url, FileExtension.Json, false));
+    if (jsonFile.exists()) {
+      return jsonFile;
+    }
+    File zipFile = new File(appContext.getCacheDir(), filenameForUrl(url, FileExtension.Zip, false));
+    if (zipFile.exists()) {
+      return zipFile;
+    }
+    return null;
+  }
+
+  private static String filenameForUrl(String url, FileExtension extension, boolean isTemp) {
+    return "lottie_cache_" + url.replaceAll("\\W+", "") + (isTemp ? extension.extension : extension.tempExtension());
+  }
+}
diff --git a/lottie/src/main/java/com/airbnb/lottie/network/NetworkFetcher.java b/lottie/src/main/java/com/airbnb/lottie/network/NetworkFetcher.java
new file mode 100644
index 00000000..01841ab9
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/network/NetworkFetcher.java
@@ -0,0 +1,144 @@
+package com.airbnb.lottie.network;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+import android.support.annotation.WorkerThread;
+import android.support.v4.util.Pair;
+
+import com.airbnb.lottie.L;
+import com.airbnb.lottie.LottieComposition;
+import com.airbnb.lottie.LottieCompositionFactory;
+import com.airbnb.lottie.LottieResult;
+import com.airbnb.lottie.LottieTask;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.concurrent.Callable;
+import java.util.zip.ZipInputStream;
+
+public class NetworkFetcher {
+
+  private final Context appContext;
+  private final String url;
+
+  private final NetworkCache networkCache;
+
+  public static LottieTask<LottieComposition> fetch(Context context, String url) {
+    return new NetworkFetcher(context, url).fetch();
+  }
+
+  public static LottieResult<LottieComposition> fetchSync(Context context, String url) {
+    return new NetworkFetcher(context, url).fetchSync();
+  }
+
+  private NetworkFetcher(Context context, String url) {
+    appContext = context.getApplicationContext();
+    this.url = url;
+    networkCache = new NetworkCache(appContext, url);
+  }
+
+  private LottieTask<LottieComposition> fetch() {
+    return new LottieTask<>(new Callable<LottieResult<LottieComposition>>() {
+      @Override public LottieResult<LottieComposition> call() throws Exception {
+        return fetchSync();
+      }
+    });
+  }
+
+  @WorkerThread
+  public LottieResult<LottieComposition> fetchSync() {
+    LottieComposition result = fetchFromCache();
+    if (result != null) {
+      return new LottieResult<>(result);
+    }
+
+    L.debug("Animation for " + url + " not found in cache. Fetching from network.");
+    return fetchFromNetwork();
+  }
+
+  /**
+   * Returns null if the animation doesn't exist in the cache.
+   */
+  @Nullable
+  @WorkerThread
+  private LottieComposition fetchFromCache() {
+    Pair<FileExtension, InputStream> cacheResult = networkCache.fetch();
+    if (cacheResult == null) {
+      return null;
+    }
+
+    FileExtension extension = cacheResult.first;
+    InputStream inputStream = cacheResult.second;
+    LottieResult<LottieComposition> result;
+    if (extension == FileExtension.Zip) {
+      result = LottieCompositionFactory.fromZipStreamSync(new ZipInputStream(inputStream), url);
+    } else {
+      result = LottieCompositionFactory.fromJsonInputStreamSync(inputStream, url);
+    }
+    if (result.getValue() != null) {
+      return result.getValue();
+    }
+    return null;
+  }
+
+  @WorkerThread
+  private LottieResult<LottieComposition> fetchFromNetwork() {
+    try {
+      return fetchFromNetworkInternal();
+    } catch (IOException e) {
+      return new LottieResult<>(e);
+    }
+  }
+
+  @WorkerThread
+  private LottieResult fetchFromNetworkInternal() throws IOException {
+    L.debug( "Fetching " + url);
+    HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();
+
+    connection.setRequestMethod("GET");
+    connection.connect();
+
+    if (connection.getErrorStream() != null || connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
+      BufferedReader r = new BufferedReader(new InputStreamReader(connection.getErrorStream()));
+      StringBuilder error = new StringBuilder();
+      String line;
+      while ((line = r.readLine()) != null) {
+        error.append(line).append('\n');
+      }
+      return new LottieResult<>(new IllegalArgumentException("Unable to fetch " + url + ". Failed with " +
+          connection.getResponseCode() + "\n" + error));
+    }
+
+    File file;
+    FileExtension extension;
+    LottieResult<LottieComposition> result;
+    switch (connection.getContentType()) {
+      case "application/zip":
+        L.debug("Handling zip response.");
+        extension = FileExtension.Zip;
+        file = networkCache.writeTempCacheFile(connection.getInputStream(), extension);
+        result = LottieCompositionFactory.fromZipStreamSync(new ZipInputStream(new FileInputStream(file)), url);
+        break;
+      case "application/json":
+      default:
+        L.debug("Received json response.");
+        extension = FileExtension.Json;
+        file = networkCache.writeTempCacheFile(connection.getInputStream(), extension);
+        result = LottieCompositionFactory.fromJsonInputStreamSync(new FileInputStream(new File(file.getAbsolutePath())), url);
+        break;
+    }
+
+    if (result.getValue() != null) {
+      networkCache.renameTempFile(extension);
+    }
+
+    L.debug("Completed fetch from network. Success: " + (result.getValue() != null));
+    return result;
+  }
+}
diff --git a/lottie/src/main/java/com/airbnb/lottie/network/package-info.java b/lottie/src/main/java/com/airbnb/lottie/network/package-info.java
new file mode 100644
index 00000000..b85ad1b3
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/network/package-info.java
@@ -0,0 +1,6 @@
+@RestrictTo(LIBRARY)
+package com.airbnb.lottie.network;
+
+import android.support.annotation.RestrictTo;
+
+import static android.support.annotation.RestrictTo.Scope.LIBRARY;
\ No newline at end of file
