diff --git a/lottie/build.gradle b/lottie/build.gradle
index ceb32a22..6ffdf5de 100644
--- a/lottie/build.gradle
+++ b/lottie/build.gradle
@@ -25,7 +25,7 @@ android {
 dependencies {
   compile "com.android.support:appcompat-v7:$supportLibVersion"
   testCompile 'junit:junit:4.12'
-  testCompile "org.robolectric:robolectric:3.3.2"
+  testCompile "org.robolectric:robolectric:3.4.2"
 }
 
 task javadoc(type: Javadoc) {
diff --git a/lottie/src/main/java/com/airbnb/lottie/LottieAnimationView.java b/lottie/src/main/java/com/airbnb/lottie/LottieAnimationView.java
index 9b118d18..2448044c 100644
--- a/lottie/src/main/java/com/airbnb/lottie/LottieAnimationView.java
+++ b/lottie/src/main/java/com/airbnb/lottie/LottieAnimationView.java
@@ -414,87 +414,118 @@ import java.util.Map;
     return lottieDrawable.hasMatte();
   }
 
-  public void addAnimatorUpdateListener(ValueAnimator.AnimatorUpdateListener updateListener) {
-    lottieDrawable.addAnimatorUpdateListener(updateListener);
-  }
-
-  public void removeUpdateListener(ValueAnimator.AnimatorUpdateListener updateListener) {
-    lottieDrawable.removeAnimatorUpdateListener(updateListener);
-  }
-
-  public void addAnimatorListener(Animator.AnimatorListener listener) {
-    lottieDrawable.addAnimatorListener(listener);
-  }
-
-  public void removeAnimatorListener(Animator.AnimatorListener listener) {
-    lottieDrawable.removeAnimatorListener(listener);
-  }
-
-  public void loop(boolean loop) {
-    lottieDrawable.loop(loop);
-  }
-
-  public boolean isAnimating() {
-    return lottieDrawable.isAnimating();
-  }
-
+  /**
+   * Plays the animation from the beginning. If speed is < 0, it will start at the end
+   * and play towards the beginning
+   */
   public void playAnimation() {
     lottieDrawable.playAnimation();
     enableOrDisableHardwareLayer();
   }
 
+  /**
+   * Continues playing the animation from its current position. If speed < 0, it will play backwards
+   * from the current position.
+   */
   public void resumeAnimation() {
     lottieDrawable.resumeAnimation();
     enableOrDisableHardwareLayer();
   }
 
-  public void playAnimation(final int startFrame, final int endFrame) {
-    lottieDrawable.playAnimation(startFrame, endFrame);
-  }
-
-  public void playAnimation(@FloatRange(from = 0f, to = 1f) float startProgress,
-      @FloatRange(from = 0f, to = 1f) float endProgress) {
-    lottieDrawable.playAnimation(startProgress, endProgress);
-  }
-
-  public void reverseAnimation() {
-    lottieDrawable.reverseAnimation();
-    enableOrDisableHardwareLayer();
-  }
-
+  /**
+   * Sets the minimum frame that the animation will start from when playing or looping.
+   */
   public void setMinFrame(int startFrame) {
     lottieDrawable.setMinFrame(startFrame);
   }
 
+  /**
+   * Sets the minimum progress that the animation will start from when playing or looping.
+   */
   public void setMinProgress(float startProgress) {
     lottieDrawable.setMinProgress(startProgress);
   }
 
+  /**
+   * Sets the maximum frame that the animation will end at when playing or looping.
+   */
   public void setMaxFrame(int endFrame) {
     lottieDrawable.setMaxFrame(endFrame);
   }
 
-  public void setMaxProgress(float endProgress) {
+  /**
+   * Sets the maximum progress that the animation will end at when playing or looping.
+   */
+  public void setMaxProgress(@FloatRange(from = 0f, to = 1f) float endProgress) {
     lottieDrawable.setMaxProgress(endProgress);
   }
 
+  /**
+   * @see #setMinFrame(int)
+   * @see #setMaxFrame(int)
+   */
   public void setMinAndMaxFrame(int minFrame, int maxFrame) {
     lottieDrawable.setMinAndMaxFrame(minFrame, maxFrame);
   }
 
-  public void setMinAndMaxProgress(float minProgress, float maxProgress) {
+  /**
+   * @see #setMinProgress(float)
+   * @see #setMaxProgress(float)
+   */
+  public void setMinAndMaxProgress(
+      @FloatRange(from = 0f, to = 1f) float minProgress,
+      @FloatRange(from = 0f, to = 1f) float maxProgress) {
     lottieDrawable.setMinAndMaxProgress(minProgress, maxProgress);
   }
 
-  public void resumeReverseAnimation() {
-    lottieDrawable.resumeReverseAnimation();
-    enableOrDisableHardwareLayer();
+  /**
+   * Reverses the current animation speed. This does NOT play the animation.
+   * @see #setSpeed(float)
+   * @see #playAnimation()
+   * @see #resumeAnimation()
+   */
+  public void reverseAnimationSpeed() {
+    lottieDrawable.reverseAnimationSpeed();
   }
 
+  /**
+   * Sets the playback speed. If speed < 0, the animation will play backwards.
+   */
   public void setSpeed(float speed) {
     lottieDrawable.setSpeed(speed);
   }
 
+  /**
+   * Returns the current playback speed. This will be < 0 if the animation is playing backwards.
+   */
+  public float getSpeed() {
+    return lottieDrawable.getSpeed();
+  }
+
+  public void addAnimatorUpdateListener(ValueAnimator.AnimatorUpdateListener updateListener) {
+    lottieDrawable.addAnimatorUpdateListener(updateListener);
+  }
+
+  public void removeUpdateListener(ValueAnimator.AnimatorUpdateListener updateListener) {
+    lottieDrawable.removeAnimatorUpdateListener(updateListener);
+  }
+
+  public void addAnimatorListener(Animator.AnimatorListener listener) {
+    lottieDrawable.addAnimatorListener(listener);
+  }
+
+  public void removeAnimatorListener(Animator.AnimatorListener listener) {
+    lottieDrawable.removeAnimatorListener(listener);
+  }
+
+  public void loop(boolean loop) {
+    lottieDrawable.loop(loop);
+  }
+
+  public boolean isAnimating() {
+    return lottieDrawable.isAnimating();
+  }
+
   /**
    * If you use image assets, you must explicitly specify the folder in assets/ in which they are
    * located because bodymovin uses the name filenames across all compositions (img_#).
@@ -574,9 +605,7 @@ import java.util.Map;
   }
 
   public void pauseAnimation() {
-    float progress = getProgress();
-    lottieDrawable.cancelAnimation();
-    setProgress(progress);
+    lottieDrawable.pauseAnimation();
     enableOrDisableHardwareLayer();
   }
 
diff --git a/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
index c620246b..cc715c27 100644
--- a/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
+++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
@@ -17,7 +17,6 @@ import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 import android.view.View;
-import android.view.animation.LinearInterpolator;
 
 import com.airbnb.lottie.manager.FontAssetManager;
 import com.airbnb.lottie.manager.ImageAssetManager;
@@ -41,7 +40,6 @@ import java.util.Set;
  */
 @SuppressWarnings({"WeakerAccess", "unused"}) public class LottieDrawable extends Drawable implements Drawable.Callback {
   private static final String TAG = LottieDrawable.class.getSimpleName();
-  private boolean systemAnimationsAreDisabled;
 
   private interface LazyCompositionTask {
     void run(LottieComposition composition);
@@ -50,7 +48,6 @@ import java.util.Set;
   private final Matrix matrix = new Matrix();
   private LottieComposition composition;
   private final LottieValueAnimator animator = new LottieValueAnimator();
-  private float speed = 1f;
   private float scale = 1f;
 
   private final Set<ColorFilterData> colorFilterData = new HashSet<>();
@@ -67,12 +64,10 @@ import java.util.Set;
   private boolean performanceTrackingEnabled;
 
   public LottieDrawable() {
-    animator.setRepeatCount(0);
-    animator.setInterpolator(new LinearInterpolator());
     animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
       @Override public void onAnimationUpdate(ValueAnimator animation) {
         if (compositionLayer != null) {
-          compositionLayer.setProgress(animator.getProgress());
+          compositionLayer.setProgress(animator.getValue());
         }
       }
     });
@@ -156,9 +151,10 @@ import java.util.Set;
       return false;
     }
 
+    setProgress(0f);
     clearComposition();
     this.composition = composition;
-    setSpeed(speed);
+    animator.setCompositionDuration(composition.getDuration());
     setScale(scale);
     updateBounds();
     buildCompositionLayer();
@@ -176,8 +172,6 @@ import java.util.Set;
 
     composition.setPerformanceTrackingEnabled(performanceTrackingEnabled);
 
-    animator.forceUpdate();
-
     return true;
   }
 
@@ -211,8 +205,12 @@ import java.util.Set;
     }
   }
 
-  private void clearComposition() {
+  public void clearComposition() {
     recycleBitmaps();
+    if (animator.isRunning()) {
+      animator.cancel();
+    }
+    composition = null;
     compositionLayer = null;
     imageAssetManager = null;
     invalidateSelf();
@@ -348,101 +346,43 @@ import java.util.Set;
     }
   }
 
-  void systemAnimationsAreDisabled() {
-    systemAnimationsAreDisabled = true;
-    animator.systemAnimationsAreDisabled();
-  }
-
-  public void loop(boolean loop) {
-    animator.setRepeatCount(loop ? ValueAnimator.INFINITE : 0);
-  }
-
-  public boolean isLooping() {
-    return animator.getRepeatCount() == ValueAnimator.INFINITE;
-  }
-
-  public boolean isAnimating() {
-    return animator.isRunning();
-  }
+// <editor-fold desc="animator">
 
+  /**
+   * Plays the animation from the beginning. If speed is < 0, it will start at the end
+   * and play towards the beginning
+   */
   public void playAnimation() {
-    playAnimation(true);
-  }
-
-  public void resumeAnimation() {
-    // Reset if they try to resume from the end of the animation
-    // or if system animations are disabled.
-    // If they are disabled then LottieValueAnimator will have it jump to its
-    // max progress.
-    playAnimation(
-        animator.getAnimatedFraction() == animator.getMaxProgress() ||
-        systemAnimationsAreDisabled);
-  }
-
-  private void playAnimation(final boolean resetProgress) {
     if (compositionLayer == null) {
       lazyCompositionTasks.add(new LazyCompositionTask() {
         @Override public void run(LottieComposition composition) {
-          playAnimation(resetProgress);
-        }
-      });
-      return;
-    }
-    if (resetProgress) {
-      animator.start();
-    } else {
-      animator.resumeAnimation();
-    }
-  }
-
-  public void playAnimation(final int startFrame, final int endFrame) {
-    if (composition == null) {
-      lazyCompositionTasks.add(new LazyCompositionTask() {
-        @Override public void run(LottieComposition composition) {
-          playAnimation(startFrame, endFrame);
+          playAnimation();
         }
       });
       return;
     }
-    playAnimation(startFrame / composition.getDurationFrames(),
-        endFrame / composition.getDurationFrames());
-  }
-
-  public void playAnimation(@FloatRange(from = 0f, to = 1f) float startProgress,
-      @FloatRange(from = 0f, to = 1f) float endProgress) {
-    animator.updateValues(startProgress, endProgress);
-    animator.setCurrentPlayTime(0);
-    setProgress(startProgress);
-    playAnimation(false);
+    animator.playAnimation();
   }
 
-  public void resumeReverseAnimation() {
-    reverseAnimation(false);
-  }
-
-  public void reverseAnimation() {
-    float progress = getProgress();
-    reverseAnimation(true);
-  }
-
-  private void reverseAnimation(final boolean resetProgress) {
+  /**
+   * Continues playing the animation from its current position. If speed < 0, it will play backwards
+   * from the current position.
+   */
+  public void resumeAnimation() {
     if (compositionLayer == null) {
       lazyCompositionTasks.add(new LazyCompositionTask() {
         @Override public void run(LottieComposition composition) {
-          reverseAnimation(resetProgress);
+          resumeAnimation();
         }
       });
       return;
     }
-    float progress = animator.getProgress();
-    animator.reverse();
-    if (resetProgress || getProgress() == 1f) {
-      animator.setProgress(animator.getMinProgress());
-    } else {
-      animator.setProgress(progress);
-    }
+    animator.resumeAnimation();
   }
 
+  /**
+   * Sets the minimum frame that the animation will start from when playing or looping.
+   */
   public void setMinFrame(final int minFrame) {
     if (composition == null) {
       lazyCompositionTasks.add(new LazyCompositionTask() {
@@ -455,10 +395,16 @@ import java.util.Set;
     setMinProgress(minFrame / composition.getDurationFrames());
   }
 
+  /**
+   * Sets the minimum progress that the animation will start from when playing or looping.
+   */
    public void setMinProgress(float minProgress) {
-    animator.setMinProgress(minProgress);
+    animator.setMinValue(minProgress);
   }
 
+  /**
+   * Sets the maximum frame that the animation will end at when playing or looping.
+   */
   public void setMaxFrame(final int maxFrame) {
     if (composition == null) {
       lazyCompositionTasks.add(new LazyCompositionTask() {
@@ -471,40 +417,98 @@ import java.util.Set;
     setMaxProgress(maxFrame / composition.getDurationFrames());
   }
 
-  public void setMaxProgress(float maxProgress) {
-    animator.setMaxProgress(maxProgress);
+  /**
+   * Sets the maximum progress that the animation will end at when playing or looping.
+   */
+  public void setMaxProgress(@FloatRange(from = 0f, to = 1f) float maxProgress) {
+    animator.setMaxValue(maxProgress);
   }
 
+  /**
+   * @see #setMinFrame(int)
+   * @see #setMaxFrame(int)
+   */
   public void setMinAndMaxFrame(int minFrame, int maxFrame) {
     setMinFrame(minFrame);
     setMaxFrame(maxFrame);
   }
 
-  public void setMinAndMaxProgress(float minProgress, float maxProgress) {
+  /**
+   * @see #setMinProgress(float)
+   * @see #setMaxProgress(float)
+   */
+  public void setMinAndMaxProgress(
+      @FloatRange(from = 0f, to = 1f) float minProgress,
+      @FloatRange(from = 0f, to = 1f) float maxProgress) {
     setMinProgress(minProgress);
     setMaxProgress(maxProgress);
   }
 
+  /**
+   * Reverses the current animation speed. This does NOT play the animation.
+   * @see #setSpeed(float)
+   * @see #playAnimation()
+   * @see #resumeAnimation()
+   */
+  public void reverseAnimationSpeed() {
+    animator.reverseAnimationSpeed();
+  }
+
+  /**
+   * Sets the playback speed. If speed < 0, the animation will play backwards.
+   */
   public void setSpeed(float speed) {
-    this.speed = speed;
-    animator.setIsReversed(speed < 0);
+    animator.setSpeed(speed);
+  }
 
-    if (composition != null) {
-      animator.setDuration((long) (composition.getDuration() / Math.abs(speed)));
-    }
+  /**
+   * Returns the current playback speed. This will be < 0 if the animation is playing backwards.
+   */
+  public float getSpeed() {
+    return animator.getSpeed();
+  }
+
+  public void addAnimatorUpdateListener(ValueAnimator.AnimatorUpdateListener updateListener) {
+    animator.addUpdateListener(updateListener);
+  }
+
+  public void removeAnimatorUpdateListener(ValueAnimator.AnimatorUpdateListener updateListener) {
+    animator.removeUpdateListener(updateListener);
+  }
+
+  public void addAnimatorListener(Animator.AnimatorListener listener) {
+    animator.addListener(listener);
+  }
+
+  public void removeAnimatorListener(Animator.AnimatorListener listener) {
+    animator.removeListener(listener);
   }
 
   public void setProgress(@FloatRange(from = 0f, to = 1f) float progress) {
-    animator.setProgress(progress);
+    animator.setValue(progress);
     if (compositionLayer != null) {
       compositionLayer.setProgress(progress);
     }
   }
 
-  public float getProgress() {
-    return animator.getProgress();
+  public void loop(boolean loop) {
+    animator.setRepeatCount(loop ? ValueAnimator.INFINITE : 0);
+  }
+
+  public boolean isLooping() {
+    return animator.getRepeatCount() == ValueAnimator.INFINITE;
+  }
+
+  public boolean isAnimating() {
+    return animator.isRunning();
   }
 
+  void systemAnimationsAreDisabled() {
+    animator.systemAnimationsAreDisabled();
+  }
+
+// </editor-fold>
+
   /**
    * Set the scale on the current composition. The only cost of this function is re-rendering the
    * current frame so you may call it frequent to scale something up or down.
@@ -577,20 +581,14 @@ import java.util.Set;
     animator.cancel();
   }
 
-  public void addAnimatorUpdateListener(ValueAnimator.AnimatorUpdateListener updateListener) {
-    animator.addUpdateListener(updateListener);
-  }
-
-  public void removeAnimatorUpdateListener(ValueAnimator.AnimatorUpdateListener updateListener) {
-    animator.removeUpdateListener(updateListener);
-  }
-
-  public void addAnimatorListener(Animator.AnimatorListener listener) {
-    animator.addListener(listener);
+  public void pauseAnimation() {
+    lazyCompositionTasks.clear();
+    animator.pauseAnimation();
   }
 
-  public void removeAnimatorListener(Animator.AnimatorListener listener) {
-    animator.removeListener(listener);
+  @FloatRange(from = 0f, to = 1f)
+  public float getProgress() {
+    return animator.getValue();
   }
 
   @Override public int getIntrinsicWidth() {
diff --git a/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java b/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java
index b422fb2f..77da5c18 100644
--- a/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java
+++ b/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java
@@ -1,7 +1,5 @@
 package com.airbnb.lottie.utils;
 
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
 import android.animation.ValueAnimator;
 import android.support.annotation.FloatRange;
 
@@ -11,142 +9,122 @@ import android.support.annotation.FloatRange;
  */
 public class LottieValueAnimator extends ValueAnimator {
   private boolean systemAnimationsAreDisabled = false;
-  private boolean isReversed = false;
-  private float minProgress = 0f;
-  private float maxProgress = 1f;
-  private long originalDuration;
-
-  private float progress = 0f;
+  private long compositionDuration;
+  private float speed = 1f;
+  @FloatRange(from = 0f, to = 1f) private float value = 0f;
+  @FloatRange(from = 0f, to = 1f) private float minValue = 0f;
+  @FloatRange(from = 0f, to = 1f) private float maxValue = 1f;
 
   public LottieValueAnimator() {
-    setFloatValues(0f, 1f);
-
-    /*
-      This allows us to reset the values if they were temporarily reset by
-      updateValues(float, float, long, boolean)
-     */
-    addListener(new AnimatorListenerAdapter() {
-      @Override public void onAnimationEnd(Animator animation) {
-        updateValues(minProgress, maxProgress);
-      }
-
-      @Override public void onAnimationCancel(Animator animation) {
-        updateValues(minProgress, maxProgress);
-      }
-    });
-
+    setInterpolator(null);
     addUpdateListener(new AnimatorUpdateListener() {
       @Override public void onAnimationUpdate(ValueAnimator animation) {
+        // On older devices, getAnimatedValue and getAnimatedFraction
+        // will always return 0 if animations are disabled.
         if (!systemAnimationsAreDisabled) {
-          // On older devices, getAnimatedValue and getAnimatedFraction
-          // will always return 0 if animations are disabled.
-          progress = (float) animation.getAnimatedValue();
+          value = (float) animation.getAnimatedValue();
         }
       }
     });
-  }
-
-  @Override public void start() {
-    if (systemAnimationsAreDisabled) {
-      setProgress(getMaxProgress());
-      end();
-    } else {
-      super.start();
-    }
+    updateValues();
   }
 
   public void systemAnimationsAreDisabled() {
     this.systemAnimationsAreDisabled = true;
   }
 
-  @Override public ValueAnimator setDuration(long duration) {
-    this.originalDuration = duration;
-    updateValues(minProgress, maxProgress);
-    return this;
+  public void setCompositionDuration(long compositionDuration) {
+    this.compositionDuration = compositionDuration;
+    updateValues();
   }
 
   /**
-   * This progress is from 0 to 1 and doesn't take into account setMinProgress or setMaxProgress.
-   * In other words, if you have set the min and max progress to 0.2 and 0.4, setting this to
-   * 0.5f will set the progress to 0.5, not 0.3. However, the value will be clamped between 0.2 and
-   * 0.4 so the resulting progress would be 0.4.
+   * Sets the current animator value. This will update the play time as well.
+   * It will also be clamped to the values set with {@link #setMinValue(float)} and
+   * {@link #setMaxValue(float)}.
    */
-  public void setProgress(@FloatRange(from = 0f, to = 1f) float progress) {
-    if (this.progress == progress) {
-      return;
+  public void setValue(@FloatRange(from = 0f, to = 1f) float value) {
+    value = MiscUtils.clamp(value, minValue, maxValue);
+
+    this.value = value;
+    float distFromStart = isReversed() ? (maxValue - value) : (value - minValue);
+    float range = Math.abs(maxValue - minValue);
+    float animatedPercentage = distFromStart / range;
+    if (getDuration() > 0) {
+      setCurrentPlayTime((long) (getDuration() * animatedPercentage));
     }
-    setProgressInternal(progress);
   }
 
-  /**
-   * Forces the animation to update even if the progress hasn't changed.
-   */
-  public void forceUpdate() {
-    setProgressInternal(getProgress());
+  public float getValue() {
+    return value;
   }
 
-  private void setProgressInternal(@FloatRange(from = 0f, to = 1f) float progress) {
-    if (progress < minProgress) {
-      progress = minProgress;
-    } else if (progress > maxProgress) {
-      progress = maxProgress;
-    }
-    this.progress = progress;
-    if (getDuration() > 0) {
-      float offsetProgress = (progress - minProgress) / (maxProgress - minProgress);
-      setCurrentPlayTime((long) (getDuration() * offsetProgress));
+  public void setMinValue(@FloatRange(from = 0f, to = 1f) float minValue) {
+    if (minValue >= maxValue) {
+      throw new IllegalArgumentException("Min value must be smaller then max value.");
     }
+    this.minValue = minValue;
+    updateValues();
   }
 
-  public float getProgress() {
-    return progress;
+  public void setMaxValue(@FloatRange(from = 0f, to = 1f) float maxValue) {
+    if (maxValue <= minValue) {
+      throw new IllegalArgumentException("Max value must be greater than min value.");
+    }
+    this.maxValue = maxValue;
+    updateValues();
   }
 
-
-  public void setIsReversed(boolean isReversed) {
-    this.isReversed = isReversed;
-    updateValues(minProgress, maxProgress);
+  public void reverseAnimationSpeed() {
+    setSpeed(-getSpeed());
   }
 
-  public void setMinProgress(float minProgress) {
-    this.minProgress = minProgress;
-    updateValues(minProgress, maxProgress);
+  public void setSpeed(float speed) {
+    this.speed = speed;
+    updateValues();
   }
 
-  public void setMaxProgress(float maxProgress) {
-    this.maxProgress = maxProgress;
-    updateValues(minProgress, maxProgress);
+  public float getSpeed() {
+    return speed;
   }
 
-  public float getMinProgress() {
-    return minProgress;
+  public void playAnimation() {
+    start();
+    setValue(isReversed() ? maxValue : minValue);
   }
 
-  public float getMaxProgress() {
-    return maxProgress;
+  public void pauseAnimation() {
+    float value = this.value;
+    cancel();
+    setValue(value);
   }
 
   public void resumeAnimation() {
-    float startingProgress = progress;
+    float value = this.value;
+    if (isReversed() && this.value == minValue) {
+      value = maxValue;
+    } else if (!isReversed() && this.value == maxValue) {
+      value = minValue;
+    }
     start();
-    // This has to call through setCurrentPlayTime for compatibility reasons.
-    setProgress(startingProgress);
+    setValue(value);
+  }
+
+  private boolean isReversed() {
+    return speed < 0;
   }
 
   /**
-   * This lets you set the start and end progress for a single play of the animator. After the next
-   * time the animation ends or is cancelled, the values will be reset to those set by
-   * {@link #setMinProgress(float)} or {@link #setMaxProgress(float)}.
+   * Update the float values of the animator, scales the duration for the current min/max range
+   * and updates the play time so that it matches the new min/max range.
    */
-  @SuppressWarnings("WeakerAccess")
-  public void updateValues(float startProgress, float endProgress) {
-    float minValue = Math.min(startProgress, endProgress);
-    float maxValue = Math.max(startProgress, endProgress);
+  private void updateValues() {
+    setDuration((long) (compositionDuration * (maxValue - minValue) / Math.abs(speed)));
     setFloatValues(
-        isReversed ? maxValue : minValue,
-        isReversed ? minValue : maxValue
+        speed < 0 ? maxValue : minValue,
+        speed < 0 ? minValue : maxValue
     );
-    super.setDuration((long) (originalDuration * (maxValue - minValue)));
-    setProgress(getProgress());
+    // This will force the play time to be correct for the current value.
+    setValue(value);
   }
 }
diff --git a/lottie/src/test/java/com/airbnb/lottie/LottieValueAnimatorUnitTest.java b/lottie/src/test/java/com/airbnb/lottie/LottieValueAnimatorUnitTest.java
new file mode 100644
index 00000000..85c471dc
--- /dev/null
+++ b/lottie/src/test/java/com/airbnb/lottie/LottieValueAnimatorUnitTest.java
@@ -0,0 +1,104 @@
+package com.airbnb.lottie;
+
+import com.airbnb.lottie.utils.LottieValueAnimator;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import static junit.framework.Assert.assertEquals;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class LottieValueAnimatorUnitTest {
+
+  private LottieValueAnimator animator;
+
+  @Before
+  public void setup() {
+    animator = new LottieValueAnimator();
+    animator.setCompositionDuration(1000);
+  }
+
+  @Test
+  public void testInitialState() {
+    assertEquals(0f, animator.getValue());
+  }
+
+  @Test
+    public void testResumingMaintainsValue() {
+    animator.setValue(0.5f);
+    animator.resumeAnimation();
+    assertEquals(0.5f, animator.getValue());
+  }
+
+  @Test
+    public void testPlayingResetsValue() {
+    animator.setValue(0.5f);
+    animator.playAnimation();
+    assertEquals(0f, animator.getValue());
+    assertEquals(0f, animator.getAnimatedFraction());
+  }
+
+  @Test
+  public void testReversingMaintainsValue() {
+    animator.setValue(0.25f);
+    animator.reverseAnimationSpeed();
+    assertEquals(0.25f, animator.getValue());
+    assertEquals(0.75f, animator.getAnimatedFraction());
+  }
+
+  @Test
+    public void testReversingWithMinValueMaintainsValue() {
+    animator.setMinValue(0.1f);
+    animator.setValue(1f);
+    animator.reverseAnimationSpeed();
+    assertEquals(1f, animator.getValue());
+    assertEquals(0f, animator.getAnimatedFraction());
+  }
+
+  @Test
+  public void testReversingWithMaxValueMaintainsValue() {
+    animator.setMaxValue(0.9f);
+    animator.reverseAnimationSpeed();
+    assertEquals(0f, animator.getValue());
+    assertEquals(1f, animator.getAnimatedFraction());
+  }
+
+  @Test
+  public void testResumeReversingWithMinValueMaintainsValue() {
+    animator.setMaxValue(0.9f);
+    animator.reverseAnimationSpeed();
+    animator.resumeAnimation();
+    assertEquals(0.9f, animator.getValue());
+    assertEquals(0f, animator.getAnimatedFraction());
+  }
+
+  @Test
+  public void testPlayReversingWithMinValueMaintainsValue() {
+    animator.setMaxValue(0.9f);
+    animator.reverseAnimationSpeed();
+    animator.playAnimation();
+    assertEquals(0.9f, animator.getValue());
+    assertEquals(0f, animator.getAnimatedFraction());
+  }
+
+  @Test
+  public void testMinAndMaxBothSet() {
+    animator.setMinValue(0.2f);
+    animator.setMaxValue(0.8f);
+    animator.setValue(0.4f);
+    assertEquals(0.33f, animator.getAnimatedFraction(), 0.01);
+    animator.reverseAnimationSpeed();
+    assertEquals(0.4f, animator.getValue(), 0.01);
+    assertEquals(0.66f, animator.getAnimatedFraction(), 0.01);
+    animator.resumeAnimation();
+    assertEquals(0.4f, animator.getValue(), 0.01);
+    assertEquals(0.66f, animator.getAnimatedFraction(), 0.01);
+    animator.playAnimation();
+    assertEquals(0.8f, animator.getValue());
+    assertEquals(0f, animator.getAnimatedFraction());
+  }
+}
