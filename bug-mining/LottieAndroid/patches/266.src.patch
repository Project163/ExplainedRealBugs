diff --git a/lottie/src/main/java/com/airbnb/lottie/LottieCompositionFactory.java b/lottie/src/main/java/com/airbnb/lottie/LottieCompositionFactory.java
index 1ff727ba..7f8b3bd3 100644
--- a/lottie/src/main/java/com/airbnb/lottie/LottieCompositionFactory.java
+++ b/lottie/src/main/java/com/airbnb/lottie/LottieCompositionFactory.java
@@ -9,11 +9,13 @@ import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.graphics.Typeface;
 
 import androidx.annotation.Nullable;
 import androidx.annotation.RawRes;
 import androidx.annotation.WorkerThread;
 
+import com.airbnb.lottie.model.Font;
 import com.airbnb.lottie.model.LottieCompositionCache;
 import com.airbnb.lottie.parser.LottieCompositionMoshiParser;
 import com.airbnb.lottie.parser.moshi.JsonReader;
@@ -23,8 +25,12 @@ import com.airbnb.lottie.utils.Utils;
 import org.json.JSONObject;
 
 import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 import java.lang.ref.WeakReference;
 import java.util.HashMap;
 import java.util.Map;
@@ -94,7 +100,7 @@ public class LottieCompositionFactory {
    */
   public static LottieTask<LottieComposition> fromUrl(final Context context, final String url, @Nullable final String cacheKey) {
     return cache(cacheKey, () -> {
-      LottieResult<LottieComposition> result = L.networkFetcher(context).fetchSync(url, cacheKey);
+      LottieResult<LottieComposition> result = L.networkFetcher(context).fetchSync(context, url, cacheKey);
       if (cacheKey != null && result.getValue() != null) {
         LottieCompositionCache.getInstance().put(cacheKey, result.getValue());
       }
@@ -120,7 +126,7 @@ public class LottieCompositionFactory {
    */
   @WorkerThread
   public static LottieResult<LottieComposition> fromUrlSync(Context context, String url, @Nullable String cacheKey) {
-    LottieResult<LottieComposition> result = L.networkFetcher(context).fetchSync(url, cacheKey);
+    LottieResult<LottieComposition> result = L.networkFetcher(context).fetchSync(context, url, cacheKey);
     if (cacheKey != null && result.getValue() != null) {
       LottieCompositionCache.getInstance().put(cacheKey, result.getValue());
     }
@@ -163,7 +169,7 @@ public class LottieCompositionFactory {
    * <p>
    * To skip the cache, add null as a third parameter.
    *
-   * @see #fromZipStreamSync(ZipInputStream, String)
+   * @see #fromZipStreamSync(Context, ZipInputStream, String)
    */
   @WorkerThread
   public static LottieResult<LottieComposition> fromAssetSync(Context context, String fileName) {
@@ -178,13 +184,13 @@ public class LottieCompositionFactory {
    * <p>
    * Pass null as the cache key to skip the cache.
    *
-   * @see #fromZipStreamSync(ZipInputStream, String)
+   * @see #fromZipStreamSync(Context, ZipInputStream, String)
    */
   @WorkerThread
   public static LottieResult<LottieComposition> fromAssetSync(Context context, String fileName, @Nullable String cacheKey) {
     try {
       if (fileName.endsWith(".zip") || fileName.endsWith(".lottie")) {
-        return fromZipStreamSync(new ZipInputStream(context.getAssets().open(fileName)), cacheKey);
+        return fromZipStreamSync(context, new ZipInputStream(context.getAssets().open(fileName)), cacheKey);
       }
       return fromJsonInputStreamSync(context.getAssets().open(fileName), cacheKey);
     } catch (IOException e) {
@@ -254,7 +260,7 @@ public class LottieCompositionFactory {
     try {
       BufferedSource source = Okio.buffer(source(context.getResources().openRawResource(rawRes)));
       if (isZipCompressed(source)) {
-        return fromZipStreamSync(new ZipInputStream(source.inputStream()), cacheKey);
+        return fromZipStreamSync(context, new ZipInputStream(source.inputStream()), cacheKey);
       }
       return fromJsonInputStreamSync(source.inputStream(), cacheKey);
     } catch (Resources.NotFoundException e) {
@@ -374,28 +380,56 @@ public class LottieCompositionFactory {
   }
 
 
+  /**
+   * In this overload, embedded fonts will NOT be parsed. If your zip file has custom fonts, use the overload
+   * that takes Context as the first parameter.
+   */
   public static LottieTask<LottieComposition> fromZipStream(final ZipInputStream inputStream, @Nullable final String cacheKey) {
-    return cache(cacheKey, () -> fromZipStreamSync(inputStream, cacheKey));
+    return fromZipStream(null, inputStream, cacheKey);
+  }
+
+  /**
+   * @see #fromZipStreamSync(Context, ZipInputStream, String)
+   */
+  public static LottieTask<LottieComposition> fromZipStream(Context context, final ZipInputStream inputStream, @Nullable final String cacheKey) {
+    return cache(cacheKey, () -> fromZipStreamSync(context, inputStream, cacheKey));
   }
 
   /**
    * Parses a zip input stream into a Lottie composition.
    * Your zip file should just be a folder with your json file and images zipped together.
    * It will automatically store and configure any images inside the animation if they exist.
+   *
+   * In this overload, embedded fonts will NOT be parsed. If your zip file has custom fonts, use the overload
+   * that takes Context as the first parameter.
    */
-  @WorkerThread
   public static LottieResult<LottieComposition> fromZipStreamSync(ZipInputStream inputStream, @Nullable String cacheKey) {
+    return fromZipStreamSync(null, inputStream, cacheKey);
+  }
+
+    /**
+     * Parses a zip input stream into a Lottie composition.
+     * Your zip file should just be a folder with your json file and images zipped together.
+     * It will automatically store and configure any images inside the animation if they exist.
+     *
+     * @param context is optional and only needed if your zip file contains ttf or otf fonts. If yours doesn't, you may pass null.
+     *                Embedded fonts may be .ttf or .otf files, can be in subdirectories, but must have the same name as the
+     *                font family (fFamily) in your animation file.
+     */
+  @WorkerThread
+  public static LottieResult<LottieComposition> fromZipStreamSync(@Nullable Context context, ZipInputStream inputStream, @Nullable String cacheKey) {
     try {
-      return fromZipStreamSyncInternal(inputStream, cacheKey);
+      return fromZipStreamSyncInternal(context, inputStream, cacheKey);
     } finally {
       closeQuietly(inputStream);
     }
   }
 
   @WorkerThread
-  private static LottieResult<LottieComposition> fromZipStreamSyncInternal(ZipInputStream inputStream, @Nullable String cacheKey) {
+  private static LottieResult<LottieComposition> fromZipStreamSyncInternal(Context context, ZipInputStream inputStream, @Nullable String cacheKey) {
     LottieComposition composition = null;
     Map<String, Bitmap> images = new HashMap<>();
+    Map<String, Typeface> fonts = new HashMap<>();
 
     try {
       ZipEntry entry = inputStream.getNextEntry();
@@ -412,6 +446,29 @@ public class LottieCompositionFactory {
           String[] splitName = entryName.split("/");
           String name = splitName[splitName.length - 1];
           images.put(name, BitmapFactory.decodeStream(inputStream));
+        } else if (entryName.contains(".ttf") || entryName.contains(".otf")) {
+          String[] splitName = entryName.split("/");
+          String fileName = splitName[splitName.length - 1];
+          String fontFamily = fileName.split("\\.")[0];
+          File tempFile = new File(context.getCacheDir(), fileName);
+          FileOutputStream fos = new FileOutputStream(tempFile);
+          try {
+            try (OutputStream output = new FileOutputStream(tempFile)) {
+              byte[] buffer = new byte[4 * 1024];
+              int read;
+              while ((read = inputStream.read(buffer)) != -1) {
+                output.write(buffer, 0, read);
+              }
+              output.flush();
+            }
+          } catch (Throwable e) {
+            Logger.warning("Unable to save font " + fontFamily + " to the temporary file: " + fileName + ". ", e);
+          }
+          Typeface typeface = Typeface.createFromFile(tempFile);
+          if (!tempFile.delete()) {
+            Logger.warning("Failed to delete temp font file " + tempFile.getAbsolutePath() + ".");
+          }
+          fonts.put(fontFamily, typeface);
         } else {
           inputStream.closeEntry();
         }
@@ -434,6 +491,19 @@ public class LottieCompositionFactory {
       }
     }
 
+    for (Map.Entry<String, Typeface> e : fonts.entrySet()) {
+      boolean found = false;
+      for (Font font : composition.getFonts().values()) {
+        if (font.getFamily().equals(e.getKey())) {
+          found = true;
+          font.setTypeface(e.getValue());
+        }
+      }
+      if (!found) {
+        Logger.warning("Parsed font for " + e.getKey() + " however it was not found in the animation.");
+      }
+    }
+
     // Ensure that all bitmaps have been set.
     for (Map.Entry<String, LottieImageAsset> entry : composition.getImages().entrySet()) {
       if (entry.getValue().getBitmap() == null) {
diff --git a/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
index 59500a00..ac5d92be 100644
--- a/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
+++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
@@ -33,6 +33,7 @@ import androidx.annotation.RestrictTo;
 import com.airbnb.lottie.animation.LPaint;
 import com.airbnb.lottie.manager.FontAssetManager;
 import com.airbnb.lottie.manager.ImageAssetManager;
+import com.airbnb.lottie.model.Font;
 import com.airbnb.lottie.model.KeyPath;
 import com.airbnb.lottie.model.Marker;
 import com.airbnb.lottie.model.layer.CompositionLayer;
@@ -1244,10 +1245,11 @@ public class LottieDrawable extends Drawable implements Drawable.Callback, Anima
   }
 
   @Nullable
-  public Typeface getTypeface(String fontFamily, String style) {
+  @RestrictTo(RestrictTo.Scope.LIBRARY)
+  public Typeface getTypeface(Font font) {
     FontAssetManager assetManager = getFontAssetManager();
     if (assetManager != null) {
-      return assetManager.getTypeface(fontFamily, style);
+      return assetManager.getTypeface(font);
     }
     return null;
   }
diff --git a/lottie/src/main/java/com/airbnb/lottie/manager/FontAssetManager.java b/lottie/src/main/java/com/airbnb/lottie/manager/FontAssetManager.java
index 9e0de5ef..a1bec17f 100644
--- a/lottie/src/main/java/com/airbnb/lottie/manager/FontAssetManager.java
+++ b/lottie/src/main/java/com/airbnb/lottie/manager/FontAssetManager.java
@@ -8,6 +8,7 @@ import android.view.View;
 import androidx.annotation.Nullable;
 
 import com.airbnb.lottie.FontAssetDelegate;
+import com.airbnb.lottie.model.Font;
 import com.airbnb.lottie.model.MutablePair;
 import com.airbnb.lottie.utils.Logger;
 
@@ -55,19 +56,20 @@ public class FontAssetManager {
     this.defaultFontFileExtension = defaultFontFileExtension;
   }
 
-  public Typeface getTypeface(String fontFamily, String style) {
-    tempPair.set(fontFamily, style);
+  public Typeface getTypeface(Font font) {
+    tempPair.set(font.getFamily(), font.getStyle());
     Typeface typeface = fontMap.get(tempPair);
     if (typeface != null) {
       return typeface;
     }
-    Typeface typefaceWithDefaultStyle = getFontFamily(fontFamily);
-    typeface = typefaceForStyle(typefaceWithDefaultStyle, style);
+    Typeface typefaceWithDefaultStyle = getFontFamily(font);
+    typeface = typefaceForStyle(typefaceWithDefaultStyle, font.getStyle());
     fontMap.put(tempPair, typeface);
     return typeface;
   }
 
-  private Typeface getFontFamily(String fontFamily) {
+  private Typeface getFontFamily(Font font) {
+    String fontFamily = font.getFamily();
     Typeface defaultTypeface = fontFamilies.get(fontFamily);
     if (defaultTypeface != null) {
       return defaultTypeface;
@@ -85,6 +87,10 @@ public class FontAssetManager {
       }
     }
 
+    if (font.getTypeface() != null) {
+      return font.getTypeface();
+    }
+
     if (typeface == null) {
       String path = "fonts/" + fontFamily + defaultFontFileExtension;
       typeface = Typeface.createFromAsset(assetManager, path);
diff --git a/lottie/src/main/java/com/airbnb/lottie/model/layer/TextLayer.java b/lottie/src/main/java/com/airbnb/lottie/model/layer/TextLayer.java
index 9963a0f3..0de25a34 100644
--- a/lottie/src/main/java/com/airbnb/lottie/model/layer/TextLayer.java
+++ b/lottie/src/main/java/com/airbnb/lottie/model/layer/TextLayer.java
@@ -300,7 +300,7 @@ public class TextLayer extends BaseLayer {
         return callbackTypeface;
       }
     }
-    Typeface drawableTypeface = lottieDrawable.getTypeface(font.getFamily(), font.getStyle());
+    Typeface drawableTypeface = lottieDrawable.getTypeface(font);
     if (drawableTypeface != null) {
       return drawableTypeface;
     }
diff --git a/lottie/src/main/java/com/airbnb/lottie/network/NetworkFetcher.java b/lottie/src/main/java/com/airbnb/lottie/network/NetworkFetcher.java
index c98caaaa..09e7a120 100644
--- a/lottie/src/main/java/com/airbnb/lottie/network/NetworkFetcher.java
+++ b/lottie/src/main/java/com/airbnb/lottie/network/NetworkFetcher.java
@@ -1,5 +1,6 @@
 package com.airbnb.lottie.network;
 
+import android.content.Context;
 import android.util.Pair;
 
 import androidx.annotation.NonNull;
@@ -33,20 +34,20 @@ public class NetworkFetcher {
 
   @NonNull
   @WorkerThread
-  public LottieResult<LottieComposition> fetchSync(@NonNull String url, @Nullable String cacheKey) {
-    LottieComposition result = fetchFromCache(url, cacheKey);
+  public LottieResult<LottieComposition> fetchSync(Context context, @NonNull String url, @Nullable String cacheKey) {
+    LottieComposition result = fetchFromCache(context, url, cacheKey);
     if (result != null) {
       return new LottieResult<>(result);
     }
 
     Logger.debug("Animation for " + url + " not found in cache. Fetching from network.");
 
-    return fetchFromNetwork(url, cacheKey);
+    return fetchFromNetwork(context, url, cacheKey);
   }
 
   @Nullable
   @WorkerThread
-  private LottieComposition fetchFromCache(@NonNull String url, @Nullable String cacheKey) {
+  private LottieComposition fetchFromCache(Context context, @NonNull String url, @Nullable String cacheKey) {
     if (cacheKey == null) {
       return null;
     }
@@ -59,7 +60,7 @@ public class NetworkFetcher {
     InputStream inputStream = cacheResult.second;
     LottieResult<LottieComposition> result;
     if (extension == FileExtension.ZIP) {
-      result = LottieCompositionFactory.fromZipStreamSync(new ZipInputStream(inputStream), url);
+      result = LottieCompositionFactory.fromZipStreamSync(context, new ZipInputStream(inputStream), url);
     } else {
       result = LottieCompositionFactory.fromJsonInputStreamSync(inputStream, url);
     }
@@ -71,7 +72,7 @@ public class NetworkFetcher {
 
   @NonNull
   @WorkerThread
-  private LottieResult<LottieComposition> fetchFromNetwork(@NonNull String url, @Nullable String cacheKey) {
+  private LottieResult<LottieComposition> fetchFromNetwork(Context context, @NonNull String url, @Nullable String cacheKey) {
     Logger.debug("Fetching " + url);
 
     LottieFetchResult fetchResult = null;
@@ -80,7 +81,7 @@ public class NetworkFetcher {
       if (fetchResult.isSuccessful()) {
         InputStream inputStream = fetchResult.bodyByteStream();
         String contentType = fetchResult.contentType();
-        LottieResult<LottieComposition> result = fromInputStream(url, inputStream, contentType, cacheKey);
+        LottieResult<LottieComposition> result = fromInputStream(context, url, inputStream, contentType, cacheKey);
         Logger.debug("Completed fetch from network. Success: " + (result.getValue() != null));
         return result;
       } else {
@@ -100,7 +101,7 @@ public class NetworkFetcher {
   }
 
   @NonNull
-  private LottieResult<LottieComposition> fromInputStream(@NonNull String url, @NonNull InputStream inputStream, @Nullable String contentType,
+  private LottieResult<LottieComposition> fromInputStream(Context context, @NonNull String url, @NonNull InputStream inputStream, @Nullable String contentType,
       @Nullable String cacheKey) throws IOException {
     FileExtension extension;
     LottieResult<LottieComposition> result;
@@ -115,7 +116,7 @@ public class NetworkFetcher {
         url.split("\\?")[0].endsWith(".lottie")) {
       Logger.debug("Handling zip response.");
       extension = FileExtension.ZIP;
-      result = fromZipStream(url, inputStream, cacheKey);
+      result = fromZipStream(context, url, inputStream, cacheKey);
     } else {
       Logger.debug("Received json response.");
       extension = FileExtension.JSON;
@@ -130,13 +131,13 @@ public class NetworkFetcher {
   }
 
   @NonNull
-  private LottieResult<LottieComposition> fromZipStream(@NonNull String url, @NonNull InputStream inputStream, @Nullable String cacheKey)
+  private LottieResult<LottieComposition> fromZipStream(Context context, @NonNull String url, @NonNull InputStream inputStream, @Nullable String cacheKey)
       throws IOException {
     if (cacheKey == null) {
-      return LottieCompositionFactory.fromZipStreamSync(new ZipInputStream(inputStream), null);
+      return LottieCompositionFactory.fromZipStreamSync(context, new ZipInputStream(inputStream), null);
     }
     File file = networkCache.writeTempCacheFile(url, inputStream, FileExtension.ZIP);
-    return LottieCompositionFactory.fromZipStreamSync(new ZipInputStream(new FileInputStream(file)), url);
+    return LottieCompositionFactory.fromZipStreamSync(context, new ZipInputStream(new FileInputStream(file)), url);
   }
 
   @NonNull
diff --git a/snapshot-tests/src/main/assets/Tests/EmbeddedFont.zip b/snapshot-tests/src/main/assets/Tests/EmbeddedFont.zip
new file mode 100644
index 00000000..74ffd4bb
Binary files /dev/null and b/snapshot-tests/src/main/assets/Tests/EmbeddedFont.zip differ
