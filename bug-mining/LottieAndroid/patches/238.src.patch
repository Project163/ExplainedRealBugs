diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
index 6590c651..039bde02 100644
--- a/.idea/inspectionProfiles/Project_Default.xml
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -5,6 +5,7 @@
       <option name="REPORT_INDEXED_LOOP" value="false" />
       <option name="ignoreUntypedCollections" value="false" />
     </inspection_tool>
+    <inspection_tool class="IfStatementWithIdenticalBranches" enabled="false" level="WEAK WARNING" enabled_by_default="false" />
     <inspection_tool class="PreviewAnnotationInFunctionWithParameters" enabled="true" level="ERROR" enabled_by_default="true">
       <option name="previewFile" value="true" />
     </inspection_tool>
diff --git a/lottie/src/main/java/com/airbnb/lottie/animation/content/RectangleContent.java b/lottie/src/main/java/com/airbnb/lottie/animation/content/RectangleContent.java
index 0e90e027..89a966ff 100644
--- a/lottie/src/main/java/com/airbnb/lottie/animation/content/RectangleContent.java
+++ b/lottie/src/main/java/com/airbnb/lottie/animation/content/RectangleContent.java
@@ -32,6 +32,8 @@ public class RectangleContent
   private final BaseKeyframeAnimation<?, Float> cornerRadiusAnimation;
 
   private final CompoundTrimPathContent trimPaths = new CompoundTrimPathContent();
+  /** This corner radius is from a layer item. The first one is from the roundedness on this specific rect. */
+  @Nullable private BaseKeyframeAnimation<Float, Float> roundedCornersAnimation = null;
   private boolean isPathValid;
 
   public RectangleContent(LottieDrawable lottieDrawable, BaseLayer layer, RectangleShape rectShape) {
@@ -75,6 +77,8 @@ public class RectangleContent
         TrimPathContent trimPath = (TrimPathContent) content;
         trimPaths.addTrimPath(trimPath);
         trimPath.addListener(this);
+      } else if (content instanceof RoundedCornersContent) {
+        roundedCornersAnimation = ((RoundedCornersContent) content).getRoundedCorners();
       }
     }
   }
@@ -97,6 +101,9 @@ public class RectangleContent
     float halfHeight = size.y / 2f;
     float radius = cornerRadiusAnimation == null ?
         0f : ((FloatKeyframeAnimation) cornerRadiusAnimation).getFloatValue();
+    if (radius == 0f && this.roundedCornersAnimation != null) {
+      radius = Math.min(roundedCornersAnimation.getValue(), Math.min(halfWidth, halfHeight));
+    }
     float maxRadius = Math.min(halfWidth, halfHeight);
     if (radius > maxRadius) {
       radius = maxRadius;
diff --git a/lottie/src/main/java/com/airbnb/lottie/animation/content/RoundedCornersContent.java b/lottie/src/main/java/com/airbnb/lottie/animation/content/RoundedCornersContent.java
new file mode 100644
index 00000000..06a3bb15
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/animation/content/RoundedCornersContent.java
@@ -0,0 +1,225 @@
+package com.airbnb.lottie.animation.content;
+
+import android.graphics.PointF;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.airbnb.lottie.LottieDrawable;
+import com.airbnb.lottie.animation.keyframe.BaseKeyframeAnimation;
+import com.airbnb.lottie.model.CubicCurveData;
+import com.airbnb.lottie.model.content.RoundedCorners;
+import com.airbnb.lottie.model.content.ShapeData;
+import com.airbnb.lottie.model.layer.BaseLayer;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class RoundedCornersContent implements ShapeModifierContent, BaseKeyframeAnimation.AnimationListener {
+  /**
+   * Copied from:
+   * https://github.com/airbnb/lottie-web/blob/bb71072a26e03f1ca993da60915860f39aae890b/player/js/utils/common.js#L47
+   */
+  private static final float ROUNDED_CORNER_MAGIC_NUMBER = 0.5519f;
+
+  private final LottieDrawable lottieDrawable;
+  private final String name;
+  private final BaseKeyframeAnimation<Float, Float> roundedCorners;
+  @Nullable private ShapeData shapeData;
+
+  public RoundedCornersContent(LottieDrawable lottieDrawable, BaseLayer layer, RoundedCorners roundedCorners) {
+    this.lottieDrawable = lottieDrawable;
+    this.name = roundedCorners.getName();
+    this.roundedCorners = roundedCorners.getCornerRadius().createAnimation();
+    layer.addAnimation(this.roundedCorners);
+    this.roundedCorners.addUpdateListener(this);
+  }
+
+  @Override public String getName() {
+    return name;
+  }
+
+  @Override public void onValueChanged() {
+    lottieDrawable.invalidateSelf();
+  }
+
+  @Override public void setContents(List<Content> contentsBefore, List<Content> contentsAfter) {
+    // Do nothing.
+  }
+
+  public BaseKeyframeAnimation<Float, Float> getRoundedCorners() {
+    return roundedCorners;
+  }
+
+  /**
+   * Rounded corner algorithm:
+   * Iterate through each vertex.
+   * If a vertex is a sharp corner, it rounds it.
+   * If a vertex has control points, it is already rounded, so it does nothing.
+   * <p>
+   * To round a vertex:
+   * Split the vertex into two.
+   * Move vertex 1 directly towards the previous vertex.
+   * Set vertex 1's in control point to itself so it is not rounded on that side.
+   * Extend vertex 1's out control point towards the original vertex.
+   * <p>
+   * Repeat for vertex 2:
+   * Move vertex 2 directly towards the next vertex.
+   * Set vertex 2's out point to itself so it is not rounded on that side.
+   * Extend vertex 2's in control point towards the original vertex.
+   * <p>
+   * The distance that the vertices and control points are moved are relative to the
+   * shape's vertex distances and the roundedness set in the animation.
+   */
+  @Override public ShapeData modifyShape(ShapeData startingShapeData) {
+    List<CubicCurveData> startingCurves = startingShapeData.getCurves();
+    if (startingCurves.size() <= 2) {
+      return startingShapeData;
+    }
+    float roundedness = roundedCorners.getValue();
+    if (roundedness == 0f) {
+      return startingShapeData;
+    }
+
+    ShapeData modifiedShapeData = getShapeData(startingShapeData);
+    modifiedShapeData.setInitialPoint(startingShapeData.getInitialPoint().x, startingShapeData.getInitialPoint().y);
+    List<CubicCurveData> modifiedCurves = modifiedShapeData.getCurves();
+    int modifiedCurvesIndex = 0;
+    boolean isClosed = startingShapeData.isClosed();
+
+    // i represents which vertex we are currently on. Refer to the docs of CubicCurveData prior to working with
+    // this code.
+    // When i == 0
+    //    vertex=ShapeData.initialPoint
+    //    inCp=if closed vertex else curves[size - 1].cp2
+    //    outCp=curves[0].cp1
+    // When i == 1
+    //    vertex=curves[0].vertex
+    //    inCp=curves[0].cp2
+    //    outCp=curves[1].cp1.
+    // When i == size - 1
+    //    vertex=curves[size - 1].vertex
+    //    inCp=curves[size - 1].cp2
+    //    outCp=if closed vertex else curves[0].cp1
+    for (int i = 0; i < startingCurves.size(); i++) {
+      CubicCurveData startingCurve = startingCurves.get(i);
+      CubicCurveData previousCurve = startingCurves.get(floorMod(i - 1, startingCurves.size()));
+      CubicCurveData previousPreviousCurve = startingCurves.get(floorMod(i - 2, startingCurves.size()));
+      PointF vertex = (i == 0 && !isClosed) ? startingShapeData.getInitialPoint() : previousCurve.getVertex();
+      PointF inPoint = (i == 0 && !isClosed) ? vertex : previousCurve.getControlPoint2();
+      PointF outPoint = startingCurve.getControlPoint1();
+      PointF previousVertex = previousPreviousCurve.getVertex();
+      PointF nextVertex = startingCurve.getVertex();
+
+      // We can't round the corner of the end of a non-closed curve.
+      boolean isEndOfCurve = !startingShapeData.isClosed() && (i == 0 && i == startingCurves.size() - 1);
+      if (inPoint.equals(vertex) && outPoint.equals(vertex) && !isEndOfCurve) {
+        // This vertex is a point. Round its corners
+        float dxToPreviousVertex = vertex.x - previousVertex.x;
+        float dyToPreviousVertex = vertex.y - previousVertex.y;
+        float dxToNextVertex = nextVertex.x - vertex.x;
+        float dyToNextVertex = nextVertex.y - vertex.y;
+
+        float dToPreviousVertex = (float) Math.hypot(dxToPreviousVertex, dyToPreviousVertex);
+        float dToNextVertex = (float) Math.hypot(dxToNextVertex, dyToNextVertex);
+
+        float previousVertexPercent = Math.min(roundedness / dToPreviousVertex, 0.5f);
+        float nextVertexPercent = Math.min(roundedness / dToNextVertex, 0.5f);
+
+        // Split the vertex into two and move each vertex towards the previous/next vertex.
+        float newVertex1X = vertex.x + (previousVertex.x - vertex.x) * previousVertexPercent;
+        float newVertex1Y = vertex.y + (previousVertex.y - vertex.y) * previousVertexPercent;
+        float newVertex2X = vertex.x + (nextVertex.x - vertex.x) * nextVertexPercent;
+        float newVertex2Y = vertex.y + (nextVertex.y - vertex.y) * nextVertexPercent;
+
+        // Extend the new vertex control point towards the original vertex.
+        float newVertex1OutPointX = newVertex1X - (newVertex1X - vertex.x) * ROUNDED_CORNER_MAGIC_NUMBER;
+        float newVertex1OutPointY = newVertex1Y - (newVertex1Y - vertex.y) * ROUNDED_CORNER_MAGIC_NUMBER;
+        float newVertex2InPointX = newVertex2X - (newVertex2X - vertex.x) * ROUNDED_CORNER_MAGIC_NUMBER;
+        float newVertex2InPointY = newVertex2Y - (newVertex2Y - vertex.y) * ROUNDED_CORNER_MAGIC_NUMBER;
+
+        // Remap vertex/in/out point to CubicCurveData.
+        // Refer to the docs for CubicCurveData for more info on the difference.
+        CubicCurveData previousCurveData = modifiedCurves.get(floorMod(modifiedCurvesIndex - 1, modifiedCurves.size()));
+        CubicCurveData currentCurveData = modifiedCurves.get(modifiedCurvesIndex);
+        previousCurveData.setControlPoint2(newVertex1X, newVertex1Y);
+        previousCurveData.setVertex(newVertex1X, newVertex1Y);
+        if (i == 0) {
+          modifiedShapeData.setInitialPoint(newVertex1X, newVertex1Y);
+        }
+        currentCurveData.setControlPoint1(newVertex1OutPointX, newVertex1OutPointY);
+        modifiedCurvesIndex++;
+
+        previousCurveData = currentCurveData;
+        currentCurveData = modifiedCurves.get(modifiedCurvesIndex);
+        previousCurveData.setControlPoint2(newVertex2InPointX, newVertex2InPointY);
+        previousCurveData.setVertex(newVertex2X, newVertex2Y);
+        currentCurveData.setControlPoint1(newVertex2X, newVertex2Y);
+        modifiedCurvesIndex++;
+      } else {
+        // This vertex is not a point. Don't modify it. Refer to the documentation above and for CubicCurveData for mapping a vertex
+        // oriented point to CubicCurveData (path segments).
+        CubicCurveData previousCurveData = modifiedCurves.get(floorMod(modifiedCurvesIndex - 1, modifiedCurves.size()));
+        CubicCurveData currentCurveData = modifiedCurves.get(modifiedCurvesIndex);
+        previousCurveData.setControlPoint2(previousCurve.getVertex().x, previousCurve.getVertex().y);
+        previousCurveData.setVertex(previousCurve.getVertex().x, previousCurve.getVertex().y);
+        currentCurveData.setControlPoint1(startingCurve.getVertex().x, startingCurve.getVertex().y);
+        modifiedCurvesIndex++;
+      }
+    }
+    return modifiedShapeData;
+  }
+
+  /**
+   * Returns a shape data with the correct number of vertices for the rounded corners shape.
+   * This just returns the object. It does not update any values within the shape.
+   */
+  @NonNull
+  private ShapeData getShapeData(ShapeData startingShapeData) {
+    List<CubicCurveData> startingCurves = startingShapeData.getCurves();
+    boolean isClosed = startingShapeData.isClosed();
+    int vertices = 0;
+    for (int i = startingCurves.size() - 1; i >= 0; i--) {
+      CubicCurveData startingCurve = startingCurves.get(i);
+      CubicCurveData previousCurve = startingCurves.get(floorMod(i - 1, startingCurves.size()));
+      PointF vertex = (i == 0 && !isClosed) ? startingShapeData.getInitialPoint() : previousCurve.getVertex();
+      PointF inPoint = (i == 0 && !isClosed) ? vertex : previousCurve.getControlPoint2();
+      PointF outPoint = startingCurve.getControlPoint1();
+
+      boolean isEndOfCurve = !startingShapeData.isClosed() && (i == 0 && i == startingCurves.size() - 1);
+      if (inPoint.equals(vertex) && outPoint.equals(vertex) && !isEndOfCurve) {
+        vertices += 2;
+      } else {
+        vertices += 1;
+      }
+    }
+    if (shapeData == null || shapeData.getCurves().size() != vertices) {
+      List<CubicCurveData> newCurves = new ArrayList<>(vertices);
+      for (int i = 0; i < vertices; i++) {
+        newCurves.add(new CubicCurveData());
+      }
+      shapeData = new ShapeData(new PointF(0f, 0f), false, newCurves);
+    }
+    shapeData.setClosed(isClosed);
+    return shapeData;
+  }
+
+  /**
+   * Copied from the API 24+ AOSP source.
+   */
+  private static int floorMod(int x, int y) {
+    return x - floorDiv(x, y) * y;
+  }
+
+  /**
+   * Copied from the API 24+ AOSP source.
+   */
+  private static int floorDiv(int x, int y) {
+    int r = x / y;
+    // if the signs are different and modulo not zero, round down
+    if ((x ^ y) < 0 && (r * y != x)) {
+      r--;
+    }
+    return r;
+  }
+}
diff --git a/lottie/src/main/java/com/airbnb/lottie/animation/content/ShapeContent.java b/lottie/src/main/java/com/airbnb/lottie/animation/content/ShapeContent.java
index 8d4c862e..1f54ac09 100644
--- a/lottie/src/main/java/com/airbnb/lottie/animation/content/ShapeContent.java
+++ b/lottie/src/main/java/com/airbnb/lottie/animation/content/ShapeContent.java
@@ -2,12 +2,16 @@ package com.airbnb.lottie.animation.content;
 
 import android.graphics.Path;
 
+import androidx.annotation.Nullable;
+
 import com.airbnb.lottie.LottieDrawable;
 import com.airbnb.lottie.animation.keyframe.BaseKeyframeAnimation;
+import com.airbnb.lottie.animation.keyframe.ShapeKeyframeAnimation;
 import com.airbnb.lottie.model.content.ShapePath;
 import com.airbnb.lottie.model.content.ShapeTrimPath;
 import com.airbnb.lottie.model.layer.BaseLayer;
 
+import java.util.ArrayList;
 import java.util.List;
 
 public class ShapeContent implements PathContent, BaseKeyframeAnimation.AnimationListener {
@@ -16,7 +20,8 @@ public class ShapeContent implements PathContent, BaseKeyframeAnimation.Animatio
   private final String name;
   private final boolean hidden;
   private final LottieDrawable lottieDrawable;
-  private final BaseKeyframeAnimation<?, Path> shapeAnimation;
+  private final ShapeKeyframeAnimation shapeAnimation;
+  @Nullable private List<ShapeModifierContent> shapeModifierContents;
 
   private boolean isPathValid;
   private final CompoundTrimPathContent trimPaths = new CompoundTrimPathContent();
@@ -40,6 +45,7 @@ public class ShapeContent implements PathContent, BaseKeyframeAnimation.Animatio
   }
 
   @Override public void setContents(List<Content> contentsBefore, List<Content> contentsAfter) {
+    @Nullable List<ShapeModifierContent> shapeModifierContents = null;
     for (int i = 0; i < contentsBefore.size(); i++) {
       Content content = contentsBefore.get(i);
       if (content instanceof TrimPathContent &&
@@ -48,8 +54,14 @@ public class ShapeContent implements PathContent, BaseKeyframeAnimation.Animatio
         TrimPathContent trimPath = (TrimPathContent) content;
         trimPaths.addTrimPath(trimPath);
         trimPath.addListener(this);
+      } else if (content instanceof ShapeModifierContent) {
+        if (shapeModifierContents == null) {
+          shapeModifierContents = new ArrayList<>();
+        }
+        shapeModifierContents.add((ShapeModifierContent) content);
       }
     }
+    shapeAnimation.setShapeModifiers(shapeModifierContents);
   }
 
   @Override public Path getPath() {
diff --git a/lottie/src/main/java/com/airbnb/lottie/animation/content/ShapeModifierContent.java b/lottie/src/main/java/com/airbnb/lottie/animation/content/ShapeModifierContent.java
new file mode 100644
index 00000000..759ede7f
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/animation/content/ShapeModifierContent.java
@@ -0,0 +1,7 @@
+package com.airbnb.lottie.animation.content;
+
+import com.airbnb.lottie.model.content.ShapeData;
+
+public interface ShapeModifierContent extends Content {
+  ShapeData modifyShape(ShapeData shapeData);
+}
diff --git a/lottie/src/main/java/com/airbnb/lottie/animation/keyframe/ShapeKeyframeAnimation.java b/lottie/src/main/java/com/airbnb/lottie/animation/keyframe/ShapeKeyframeAnimation.java
index 07e0fcec..0abd3029 100644
--- a/lottie/src/main/java/com/airbnb/lottie/animation/keyframe/ShapeKeyframeAnimation.java
+++ b/lottie/src/main/java/com/airbnb/lottie/animation/keyframe/ShapeKeyframeAnimation.java
@@ -2,6 +2,9 @@ package com.airbnb.lottie.animation.keyframe;
 
 import android.graphics.Path;
 
+import androidx.annotation.Nullable;
+
+import com.airbnb.lottie.animation.content.ShapeModifierContent;
 import com.airbnb.lottie.model.content.ShapeData;
 import com.airbnb.lottie.utils.MiscUtils;
 import com.airbnb.lottie.value.Keyframe;
@@ -12,6 +15,8 @@ public class ShapeKeyframeAnimation extends BaseKeyframeAnimation<ShapeData, Pat
   private final ShapeData tempShapeData = new ShapeData();
   private final Path tempPath = new Path();
 
+  private List<ShapeModifierContent> shapeModifiers;
+
   public ShapeKeyframeAnimation(List<Keyframe<ShapeData>> keyframes) {
     super(keyframes);
   }
@@ -21,7 +26,17 @@ public class ShapeKeyframeAnimation extends BaseKeyframeAnimation<ShapeData, Pat
     ShapeData endShapeData = keyframe.endValue;
 
     tempShapeData.interpolateBetween(startShapeData, endShapeData, keyframeProgress);
-    MiscUtils.getPathFromData(tempShapeData, tempPath);
+    ShapeData modifiedShapeData = tempShapeData;
+    if (shapeModifiers != null) {
+      for (int i = shapeModifiers.size() - 1; i >= 0; i--) {
+        modifiedShapeData = shapeModifiers.get(i).modifyShape(modifiedShapeData);
+      }
+    }
+    MiscUtils.getPathFromData(modifiedShapeData, tempPath);
     return tempPath;
   }
+
+  public void setShapeModifiers(@Nullable List<ShapeModifierContent> shapeModifiers) {
+    this.shapeModifiers = shapeModifiers;
+  }
 }
diff --git a/lottie/src/main/java/com/airbnb/lottie/model/CubicCurveData.java b/lottie/src/main/java/com/airbnb/lottie/model/CubicCurveData.java
index 63cfeee7..ba4fa024 100644
--- a/lottie/src/main/java/com/airbnb/lottie/model/CubicCurveData.java
+++ b/lottie/src/main/java/com/airbnb/lottie/model/CubicCurveData.java
@@ -2,10 +2,38 @@ package com.airbnb.lottie.model;
 
 import static androidx.annotation.RestrictTo.Scope.LIBRARY;
 
+import android.annotation.SuppressLint;
 import android.graphics.PointF;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.RestrictTo;
 
+/**
+ * One cubic path operation. CubicCurveData is structured such that it is easy to iterate through
+ * it and build a path. However, it is modeled differently than most path operations.
+ *
+ * CubicCurveData
+ * |                     - vertex
+ * |                   /
+ * |    cp1          cp2
+ * |   /
+ * |  |
+ * | /
+ * --------------------------
+ *
+ * When incrementally building a path, it will already have a "current point" so that is
+ * not captured in this data structure.
+ * The control points here represent {@link android.graphics.Path#cubicTo(float, float, float, float, float, float)}.
+ *
+ * Most path operations are centered around a vertex and its in control point and out control point like this:
+ * |           outCp
+ * |          /
+ * |         |
+ * |         v
+ * |        /
+ * |      inCp
+ * --------------------------
+ */
 @RestrictTo(LIBRARY)
 public class CubicCurveData {
   private final PointF controlPoint1;
@@ -44,7 +72,20 @@ public class CubicCurveData {
     vertex.set(x, y);
   }
 
+  public void setFrom(CubicCurveData curveData) {
+    setVertex(curveData.vertex.x, curveData.vertex.y);
+    setControlPoint1(curveData.controlPoint1.x, curveData.controlPoint1.y);
+    setControlPoint2(curveData.controlPoint2.x, curveData.controlPoint2.y);
+  }
+
   public PointF getVertex() {
     return vertex;
   }
+
+  @SuppressLint("DefaultLocale")
+  @NonNull
+  @Override public String toString() {
+    return String.format("v=%.2f,%.2f cp1=%.2f,%.2f cp2=%.2f,%.2f",
+        vertex.x, vertex.y, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y);
+  }
 }
diff --git a/lottie/src/main/java/com/airbnb/lottie/model/animatable/AnimatableShapeValue.java b/lottie/src/main/java/com/airbnb/lottie/model/animatable/AnimatableShapeValue.java
index d88dacf8..8db80d6c 100644
--- a/lottie/src/main/java/com/airbnb/lottie/model/animatable/AnimatableShapeValue.java
+++ b/lottie/src/main/java/com/airbnb/lottie/model/animatable/AnimatableShapeValue.java
@@ -2,7 +2,6 @@ package com.airbnb.lottie.model.animatable;
 
 import android.graphics.Path;
 
-import com.airbnb.lottie.animation.keyframe.BaseKeyframeAnimation;
 import com.airbnb.lottie.animation.keyframe.ShapeKeyframeAnimation;
 import com.airbnb.lottie.model.content.ShapeData;
 import com.airbnb.lottie.value.Keyframe;
@@ -15,7 +14,7 @@ public class AnimatableShapeValue extends BaseAnimatableValue<ShapeData, Path> {
     super(keyframes);
   }
 
-  @Override public BaseKeyframeAnimation<ShapeData, Path> createAnimation() {
+  @Override public ShapeKeyframeAnimation createAnimation() {
     return new ShapeKeyframeAnimation(keyframes);
   }
 }
diff --git a/lottie/src/main/java/com/airbnb/lottie/model/content/RoundedCorners.java b/lottie/src/main/java/com/airbnb/lottie/model/content/RoundedCorners.java
new file mode 100644
index 00000000..0541e468
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/model/content/RoundedCorners.java
@@ -0,0 +1,31 @@
+package com.airbnb.lottie.model.content;
+
+import androidx.annotation.Nullable;
+
+import com.airbnb.lottie.LottieDrawable;
+import com.airbnb.lottie.animation.content.Content;
+import com.airbnb.lottie.animation.content.RoundedCornersContent;
+import com.airbnb.lottie.model.animatable.AnimatableValue;
+import com.airbnb.lottie.model.layer.BaseLayer;
+
+public class RoundedCorners implements ContentModel {
+  private final String name;
+  private final AnimatableValue<Float, Float> cornerRadius;
+
+  public RoundedCorners(String name, AnimatableValue<Float, Float> cornerRadius) {
+    this.name = name;
+    this.cornerRadius = cornerRadius;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public AnimatableValue<Float, Float> getCornerRadius() {
+    return cornerRadius;
+  }
+
+  @Nullable @Override public Content toContent(LottieDrawable drawable, BaseLayer layer) {
+    return new RoundedCornersContent(drawable, layer, this);
+  }
+}
diff --git a/lottie/src/main/java/com/airbnb/lottie/model/content/ShapeData.java b/lottie/src/main/java/com/airbnb/lottie/model/content/ShapeData.java
index 97d381ce..a49ce9b8 100644
--- a/lottie/src/main/java/com/airbnb/lottie/model/content/ShapeData.java
+++ b/lottie/src/main/java/com/airbnb/lottie/model/content/ShapeData.java
@@ -26,7 +26,7 @@ public class ShapeData {
     curves = new ArrayList<>();
   }
 
-  private void setInitialPoint(float x, float y) {
+  public void setInitialPoint(float x, float y) {
     if (initialPoint == null) {
       initialPoint = new PointF();
     }
@@ -37,6 +37,10 @@ public class ShapeData {
     return initialPoint;
   }
 
+  public void setClosed(boolean closed) {
+    this.closed = closed;
+  }
+
   public boolean isClosed() {
     return closed;
   }
diff --git a/lottie/src/main/java/com/airbnb/lottie/parser/ContentModelParser.java b/lottie/src/main/java/com/airbnb/lottie/parser/ContentModelParser.java
index ee4374bd..16b06741 100644
--- a/lottie/src/main/java/com/airbnb/lottie/parser/ContentModelParser.java
+++ b/lottie/src/main/java/com/airbnb/lottie/parser/ContentModelParser.java
@@ -92,6 +92,9 @@ class ContentModelParser {
       case "rp":
         model = RepeaterParser.parse(reader, composition);
         break;
+      case "rd":
+        model = RoundedCornersParser.parse(reader, composition);
+        break;
       default:
         Logger.warning("Unknown shape type " + type);
     }
diff --git a/lottie/src/main/java/com/airbnb/lottie/parser/RoundedCornersParser.java b/lottie/src/main/java/com/airbnb/lottie/parser/RoundedCornersParser.java
new file mode 100644
index 00000000..f4072b3a
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/parser/RoundedCornersParser.java
@@ -0,0 +1,51 @@
+package com.airbnb.lottie.parser;
+
+import android.graphics.PointF;
+
+import androidx.annotation.Nullable;
+
+import com.airbnb.lottie.LottieComposition;
+import com.airbnb.lottie.model.animatable.AnimatableFloatValue;
+import com.airbnb.lottie.model.animatable.AnimatableValue;
+import com.airbnb.lottie.model.content.RectangleShape;
+import com.airbnb.lottie.model.content.RoundedCorners;
+import com.airbnb.lottie.parser.moshi.JsonReader;
+
+import java.io.IOException;
+
+public class RoundedCornersParser {
+  private static final JsonReader.Options NAMES = JsonReader.Options.of(
+      "nm", // 0
+      "r",  // 1
+      "hd"  // 1
+  );
+
+  private RoundedCornersParser() {
+  }
+
+  @Nullable
+  static RoundedCorners parse(
+      JsonReader reader, LottieComposition composition) throws IOException {
+    String name = null;
+    AnimatableValue<Float, Float> cornerRadius = null;
+    boolean hidden = false;
+
+    while (reader.hasNext()) {
+      switch (reader.selectName(NAMES)) {
+        case 0: //nm
+          name = reader.nextString();
+          break;
+        case 1: // r
+          cornerRadius = AnimatableValueParser.parseFloat(reader, composition, true);
+          break;
+        case 2: // hd
+          hidden = reader.nextBoolean();
+          break;
+        default:
+          reader.skipValue();
+      }
+    }
+
+    return hidden ? null : new RoundedCorners(name, cornerRadius);
+  }
+}
diff --git a/snapshot-tests/src/main/assets/Tests/RoundedCorners.json b/snapshot-tests/src/main/assets/Tests/RoundedCorners.json
new file mode 100644
index 00000000..87aaa519
--- /dev/null
+++ b/snapshot-tests/src/main/assets/Tests/RoundedCorners.json
@@ -0,0 +1 @@
+{"v":"5.8.1","fr":29.9700012207031,"ip":0,"op":900.000036657751,"w":1000,"h":1000,"nm":"Rounded Corners","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Shape Layer 1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[500,500,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-75,-475],[-75,-75],[-475,-75],[-475,-475]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"rc","d":1,"s":{"a":0,"k":[400,400],"ix":2},"p":{"a":0,"k":[275,-275],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false},{"ty":"sr","sy":1,"d":1,"pt":{"a":0,"k":5,"ix":3},"p":{"a":0,"k":[275,275],"ix":4},"r":{"a":0,"k":0,"ix":5},"ir":{"a":0,"k":107,"ix":6},"is":{"a":0,"k":0,"ix":8},"or":{"a":0,"k":275,"ix":7},"os":{"a":0,"k":0,"ix":9},"ix":3,"nm":"Polystar Path 1","mn":"ADBE Vector Shape - Star","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-275,0],[-212.107,188.435],[-13.459,190.02],[-173.237,308.065],[-113.359,497.48],[-275,382],[-436.641,497.48],[-376.763,308.065],[-536.541,190.02],[-337.893,188.435]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":136,"ix":1},"ix":5,"mn":"ADBE Vector Filter - RC","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false}],"ip":0,"op":900.000036657751,"st":0,"bm":0}],"markers":[]}
\ No newline at end of file
