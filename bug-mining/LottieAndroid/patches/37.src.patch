diff --git a/lottie/src/main/java/com/airbnb/lottie/BaseStrokeContent.java b/lottie/src/main/java/com/airbnb/lottie/BaseStrokeContent.java
new file mode 100644
index 00000000..f3744fbd
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/BaseStrokeContent.java
@@ -0,0 +1,260 @@
+package com.airbnb.lottie;
+
+import android.graphics.Canvas;
+import android.graphics.DashPathEffect;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.graphics.PathMeasure;
+import android.graphics.RectF;
+import android.support.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+
+abstract class BaseStrokeContent implements DrawingContent, BaseKeyframeAnimation.AnimationListener {
+  private final PathMeasure pm = new PathMeasure();
+  private final Path path = new Path();
+  private final Path trimPathPath = new Path();
+  private final RectF rect = new RectF();
+  private final LottieDrawable lottieDrawable;
+  private final List<PathGroup> pathGroups = new ArrayList<>();
+  private final float[] dashPatternValues;
+  final Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+
+  private final BaseKeyframeAnimation<?, Float> widthAnimation;
+  private final BaseKeyframeAnimation<?, Integer> opacityAnimation;
+  private final List<BaseKeyframeAnimation<?, Float>> dashPatternAnimations;
+  @Nullable private final BaseKeyframeAnimation<?, Float> dashPatternOffsetAnimation;
+
+  BaseStrokeContent(final LottieDrawable lottieDrawable, BaseLayer layer, Paint.Cap cap,
+      Paint.Join join, AnimatableIntegerValue opacity, AnimatableFloatValue width,
+      List<AnimatableFloatValue> dashPattern, AnimatableFloatValue offset) {
+    this.lottieDrawable = lottieDrawable;
+    paint.setStyle(Paint.Style.STROKE);
+    paint.setStrokeCap(cap);
+    paint.setStrokeJoin(join);
+
+    opacityAnimation = opacity.createAnimation();
+    widthAnimation = width.createAnimation();
+
+    if (offset == null) {
+      dashPatternOffsetAnimation = null;
+    } else {
+      dashPatternOffsetAnimation = offset.createAnimation();
+    }
+    dashPatternAnimations = new ArrayList<>(dashPattern.size());
+    dashPatternValues = new float[dashPattern.size()];
+
+    for (int i = 0; i < dashPattern.size(); i++) {
+      dashPatternAnimations.add(dashPattern.get(i).createAnimation());
+    }
+
+    layer.addAnimation(opacityAnimation);
+    layer.addAnimation(widthAnimation);
+    for (int i = 0; i < dashPatternAnimations.size(); i++) {
+      layer.addAnimation(dashPatternAnimations.get(i));
+    }
+    if (dashPatternOffsetAnimation != null) {
+      layer.addAnimation(dashPatternOffsetAnimation);
+    }
+
+    opacityAnimation.addUpdateListener(this);
+    widthAnimation.addUpdateListener(this);
+
+    for (int i = 0; i < dashPattern.size(); i++) {
+      dashPatternAnimations.get(i).addUpdateListener(this);
+    }
+    if (dashPatternOffsetAnimation != null) {
+      dashPatternOffsetAnimation.addUpdateListener(this);
+    }
+  }
+
+  @Override public void onValueChanged() {
+    lottieDrawable.invalidateSelf();
+  }
+
+  @Override public void setContents(List<Content> contentsBefore, List<Content> contentsAfter) {
+    TrimPathContent trimPathContentBefore = null;
+    for (int i = contentsBefore.size() - 1; i >= 0; i--) {
+      Content content = contentsBefore.get(i);
+      if (content instanceof TrimPathContent &&
+          ((TrimPathContent) content).getType() == ShapeTrimPath.Type.Individually) {
+        trimPathContentBefore = (TrimPathContent) content;
+      }
+    }
+    if (trimPathContentBefore != null) {
+      trimPathContentBefore.addListener(this);
+    }
+
+    PathGroup currentPathGroup = null;
+    for (int i = contentsAfter.size() - 1; i >= 0; i--) {
+      Content content = contentsAfter.get(i);
+      if (content instanceof TrimPathContent &&
+          ((TrimPathContent) content).getType() == ShapeTrimPath.Type.Individually) {
+        if (currentPathGroup != null) {
+          pathGroups.add(currentPathGroup);
+        }
+        currentPathGroup = new PathGroup((TrimPathContent) content);
+        ((TrimPathContent) content).addListener(this);
+      } else if (content instanceof PathContent) {
+        if (currentPathGroup == null) {
+          currentPathGroup = new PathGroup(trimPathContentBefore);
+        }
+        currentPathGroup.paths.add((PathContent) content);
+      }
+    }
+    pathGroups.add(currentPathGroup);
+  }
+
+  @Override public void draw(Canvas canvas, Matrix parentMatrix, int parentAlpha) {
+    int alpha = (int) ((parentAlpha / 255f * opacityAnimation.getValue() / 100f) * 255);
+    paint.setAlpha(alpha);
+    paint.setStrokeWidth(widthAnimation.getValue() * Utils.getScale(parentMatrix));
+    if (paint.getStrokeWidth() <= 0) {
+      // Android draws a hairline stroke for 0, After Effects doesn't.
+      return;
+    }
+    applyDashPatternIfNeeded();
+
+    for (int i = 0; i < pathGroups.size(); i++) {
+      PathGroup pathGroup = pathGroups.get(i);
+
+
+      if (pathGroup.trimPath != null) {
+        applyTrimPath(canvas, pathGroup, parentMatrix);
+      } else {
+        path.reset();
+        for (int j = pathGroup.paths.size() - 1; j >= 0; j--) {
+          path.addPath(pathGroup.paths.get(j).getPath(), parentMatrix);
+        }
+        canvas.drawPath(path, paint);
+      }
+    }
+  }
+
+  private void applyTrimPath(Canvas canvas, PathGroup pathGroup, Matrix parentMatrix) {
+    if (pathGroup.trimPath == null) {
+      return;
+    }
+    path.reset();
+    for (int j = pathGroup.paths.size() - 1; j >= 0; j--) {
+      path.addPath(pathGroup.paths.get(j).getPath(), parentMatrix);
+    }
+    pm.setPath(path, false);
+    float totalLength = pm.getLength();
+    while (pm.nextContour()) {
+      totalLength += pm.getLength();
+    }
+    float offsetLength = totalLength * pathGroup.trimPath.getOffset().getValue() / 360f;
+    float startLength =
+        totalLength * pathGroup.trimPath.getStart().getValue() / 100f + offsetLength;
+    float endLength =
+        totalLength * pathGroup.trimPath.getEnd().getValue() / 100f + offsetLength;
+
+    float currentLength = 0;
+    for (int j = pathGroup.paths.size() - 1; j >= 0; j--) {
+      trimPathPath.set(pathGroup.paths.get(j).getPath());
+      trimPathPath.transform(parentMatrix);
+      pm.setPath(trimPathPath, false);
+      float length = pm.getLength();
+      if (endLength > totalLength && endLength - totalLength < currentLength + length &&
+          currentLength < endLength - totalLength) {
+        // Draw the segment when the end is greater than the length which wraps around to the
+        // beginning.
+        float startValue;
+        if (startLength > totalLength) {
+          startValue = (startLength - totalLength) / length;
+        } else {
+          startValue = 0;
+        }
+        float endValue = Math.min((endLength - totalLength) / length, 1);
+        Utils.applyTrimPathIfNeeded(trimPathPath, startValue, endValue, 0);
+        canvas.drawPath(trimPathPath, paint);
+      } else //noinspection StatementWithEmptyBody
+        if (currentLength + length < startLength || currentLength > endLength) {
+          // Do nothing
+        } else if (currentLength + length <= endLength && startLength < currentLength) {
+          canvas.drawPath(trimPathPath, paint);
+        } else {
+          float startValue;
+          if (startLength < currentLength) {
+            startValue = 0;
+          } else {
+            startValue = (startLength - currentLength) / length;
+          }
+          float endValue;
+          if (endLength > currentLength + length) {
+            endValue = 1f;
+          } else {
+            endValue = (endLength - currentLength) / length;
+          }
+          Utils.applyTrimPathIfNeeded(trimPathPath, startValue, endValue, 0);
+          canvas.drawPath(trimPathPath, paint);
+        }
+      currentLength += length;
+    }
+  }
+
+  @Override public void getBounds(RectF outBounds, Matrix parentMatrix) {
+    path.reset();
+    for (int i = 0; i < pathGroups.size(); i++) {
+      PathGroup pathGroup = pathGroups.get(i);
+      for (int j = 0; j < pathGroup.paths.size(); j++) {
+        path.addPath(pathGroup.paths.get(i).getPath(), parentMatrix);
+      }
+    }
+    path.computeBounds(rect, false);
+
+    float width = widthAnimation.getValue();
+    rect.set(rect.left - width / 2f, rect.top - width / 2f,
+        rect.right + width / 2f, rect.bottom + width / 2f);
+    outBounds.set(rect);
+    // Add padding to account for rounding errors.
+    outBounds.set(
+        outBounds.left - 1,
+        outBounds.top - 1,
+        outBounds.right + 1,
+        outBounds.bottom + 1
+    );
+  }
+
+  private void applyDashPatternIfNeeded() {
+    if (dashPatternAnimations.isEmpty()) {
+      return;
+    }
+
+    float scale = lottieDrawable.getScale();
+    for (int i = 0; i < dashPatternAnimations.size(); i++) {
+      dashPatternValues[i] = dashPatternAnimations.get(i).getValue();
+      // If the value of the dash pattern or gap is too small, the number of individual sections
+      // approaches infinity as the value approaches 0.
+      // To mitigate this, we essentially put a minimum value on the dash pattern size of 1px
+      // and a minimum gap size of 0.01.
+      if (i % 2 == 0) {
+        if (dashPatternValues[i] < 1f) {
+          dashPatternValues[i] = 1f;
+        }
+      } else {
+        if (dashPatternValues[i] < 0.1f) {
+          dashPatternValues[i] = 0.1f;
+        }
+      }
+      dashPatternValues[i] *= scale;
+    }
+    float offset = dashPatternOffsetAnimation == null ? 0f : dashPatternOffsetAnimation.getValue();
+    paint.setPathEffect(new DashPathEffect(dashPatternValues, offset));
+  }
+
+  /**
+   * Data class to help drawing trim paths individually.
+   */
+  private static final class PathGroup {
+    private final List<PathContent> paths = new ArrayList<>();
+    @Nullable private final TrimPathContent trimPath;
+
+    private PathGroup(@Nullable TrimPathContent trimPath) {
+      this.trimPath = trimPath;
+    }
+  }
+}
\ No newline at end of file
diff --git a/lottie/src/main/java/com/airbnb/lottie/ContentGroup.java b/lottie/src/main/java/com/airbnb/lottie/ContentGroup.java
index b7ad3555..c7b84563 100644
--- a/lottie/src/main/java/com/airbnb/lottie/ContentGroup.java
+++ b/lottie/src/main/java/com/airbnb/lottie/ContentGroup.java
@@ -46,6 +46,8 @@ class ContentGroup implements DrawingContent, PathContent,
         contents.add(new GradientFillContent(lottieDrawable, layer, (GradientFill) item));
       } else if (item instanceof ShapeStroke) {
         contents.add(new StrokeContent(lottieDrawable, layer, (ShapeStroke) item));
+      } else if (item instanceof GradientStroke) {
+        contents.add(new GradientStrokeContent(lottieDrawable, layer, (GradientStroke) item));
       } else if (item instanceof ShapeGroup) {
         contents.add(new ContentGroup(lottieDrawable, layer, (ShapeGroup) item));
       } else if (item instanceof RectangleShape) {
diff --git a/lottie/src/main/java/com/airbnb/lottie/GradientFill.java b/lottie/src/main/java/com/airbnb/lottie/GradientFill.java
index 2fccc96b..a5a99ac3 100644
--- a/lottie/src/main/java/com/airbnb/lottie/GradientFill.java
+++ b/lottie/src/main/java/com/airbnb/lottie/GradientFill.java
@@ -7,11 +7,6 @@ import org.json.JSONObject;
 
 class GradientFill {
 
-  enum GradientType {
-    Linear,
-    Radial
-  }
-
   private final GradientType gradientType;
   private final Path.FillType fillType;
   private final AnimatableGradientColorValue gradientColor;
diff --git a/lottie/src/main/java/com/airbnb/lottie/GradientFillContent.java b/lottie/src/main/java/com/airbnb/lottie/GradientFillContent.java
index 6f47c0db..d106aa1c 100644
--- a/lottie/src/main/java/com/airbnb/lottie/GradientFillContent.java
+++ b/lottie/src/main/java/com/airbnb/lottie/GradientFillContent.java
@@ -25,7 +25,7 @@ class GradientFillContent implements DrawingContent, BaseKeyframeAnimation.Anima
   private final Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
   private final RectF boundsRect = new RectF();
   private final List<PathContent> paths = new ArrayList<>();
-  private final GradientFill.GradientType type;
+  private final GradientType type;
   private final KeyframeAnimation<GradientColor> colorAnimation;
   private final KeyframeAnimation<Integer> opacityAnimation;
   private final KeyframeAnimation<PointF> startPointAnimation;
@@ -77,7 +77,7 @@ class GradientFillContent implements DrawingContent, BaseKeyframeAnimation.Anima
 
     path.computeBounds(boundsRect, false);
 
-    if (type == GradientFill.GradientType.Linear) {
+    if (type == GradientType.Linear) {
       paint.setShader(getLinearGradient());
     } else {
       paint.setShader(getRadialGradient());
diff --git a/lottie/src/main/java/com/airbnb/lottie/GradientStroke.java b/lottie/src/main/java/com/airbnb/lottie/GradientStroke.java
new file mode 100644
index 00000000..f75d507e
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/GradientStroke.java
@@ -0,0 +1,149 @@
+package com.airbnb.lottie;
+
+import android.support.annotation.Nullable;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.List;
+
+class GradientStroke {
+
+  private final GradientType gradientType;
+  private final AnimatableGradientColorValue gradientColor;
+  private final AnimatableIntegerValue opacity;
+  private final AnimatablePointValue startPoint;
+  private final AnimatablePointValue endPoint;
+  private final AnimatableFloatValue width;
+  private final ShapeStroke.LineCapType capType;
+  private final ShapeStroke.LineJoinType joinType;
+  private final List<AnimatableFloatValue> lineDashPattern;
+  @Nullable private final AnimatableFloatValue dashOffset;
+
+  private GradientStroke(GradientType gradientType, AnimatableGradientColorValue
+      gradientColor,
+      AnimatableIntegerValue opacity, AnimatablePointValue startPoint,
+      AnimatablePointValue endPoint, AnimatableFloatValue width, ShapeStroke.LineCapType capType,
+      ShapeStroke.LineJoinType joinType, List<AnimatableFloatValue> lineDashPattern,
+      @Nullable AnimatableFloatValue dashOffset) {
+    this.gradientType = gradientType;
+    this.gradientColor = gradientColor;
+    this.opacity = opacity;
+    this.startPoint = startPoint;
+    this.endPoint = endPoint;
+    this.width = width;
+    this.capType = capType;
+    this.joinType = joinType;
+    this.lineDashPattern = lineDashPattern;
+    this.dashOffset = dashOffset;
+  }
+
+  GradientType getGradientType() {
+    return gradientType;
+  }
+
+  AnimatableGradientColorValue getGradientColor() {
+    return gradientColor;
+  }
+
+  AnimatableIntegerValue getOpacity() {
+    return opacity;
+  }
+
+  AnimatablePointValue getStartPoint() {
+    return startPoint;
+  }
+
+  AnimatablePointValue getEndPoint() {
+    return endPoint;
+  }
+
+  AnimatableFloatValue getWidth() {
+    return width;
+  }
+
+  ShapeStroke.LineCapType getCapType() {
+    return capType;
+  }
+
+  ShapeStroke.LineJoinType getJoinType() {
+    return joinType;
+  }
+
+  List<AnimatableFloatValue> getLineDashPattern() {
+    return lineDashPattern;
+  }
+
+  @Nullable AnimatableFloatValue getDashOffset() {
+    return dashOffset;
+  }
+
+  static class Factory {
+    private Factory() {
+    }
+
+    static GradientStroke newInstance(JSONObject json, LottieComposition composition) {
+      JSONObject jsonColor = json.optJSONObject("g");
+      if (jsonColor != null && jsonColor.has("k")) {
+        jsonColor = jsonColor.optJSONObject("k");
+      }
+      AnimatableGradientColorValue color = null;
+      if (jsonColor != null) {
+        color = AnimatableGradientColorValue.Factory.newInstance(jsonColor, composition);
+      }
+
+      JSONObject jsonOpacity = json.optJSONObject("o");
+      AnimatableIntegerValue opacity = null;
+      if (jsonOpacity != null) {
+        opacity = AnimatableIntegerValue.Factory.newInstance(jsonOpacity, composition);
+      }
+
+      int gradientTypeInt = json.optInt("t", 1);
+      GradientType gradientType = gradientTypeInt == 1 ? GradientType.Linear : GradientType.Radial;
+
+      JSONObject jsonStartPoint = json.optJSONObject("s");
+      AnimatablePointValue startPoint = null;
+      if (jsonStartPoint != null) {
+        startPoint = AnimatablePointValue.Factory.newInstance(jsonStartPoint, composition);
+      }
+
+      JSONObject jsonEndPoint = json.optJSONObject("e");
+      AnimatablePointValue endPoint = null;
+      if (jsonEndPoint != null) {
+        endPoint = AnimatablePointValue.Factory.newInstance(jsonEndPoint, composition);
+      }
+      AnimatableFloatValue width = AnimatableFloatValue.Factory.newInstance(json.optJSONObject("w"),
+          composition);
+
+
+      ShapeStroke.LineCapType capType = ShapeStroke.LineCapType.values()[json.optInt("lc") - 1];
+      ShapeStroke.LineJoinType joinType = ShapeStroke.LineJoinType.values()[json.optInt("lj") - 1];
+
+      AnimatableFloatValue offset = null;
+      List<AnimatableFloatValue> lineDashPattern = new ArrayList<>();
+      if (json.has("d")) {
+        JSONArray dashesJson = json.optJSONArray("d");
+        for (int i = 0; i < dashesJson.length(); i++) {
+          JSONObject dashJson = dashesJson.optJSONObject(i);
+          String n = dashJson.optString("n");
+          if (n.equals("o")) {
+            JSONObject value = dashJson.optJSONObject("v");
+            offset = AnimatableFloatValue.Factory.newInstance(value, composition);
+          } else if (n.equals("d") || n.equals("g")) {
+            JSONObject value = dashJson.optJSONObject("v");
+            lineDashPattern.add(AnimatableFloatValue.Factory.newInstance(value, composition));
+          }
+        }
+        if (lineDashPattern.size() == 1) {
+          // If there is only 1 value then it is assumed to be equal parts on and off.
+          lineDashPattern.add(lineDashPattern.get(0));
+        }
+      }
+
+      return new GradientStroke(
+          gradientType, color, opacity, startPoint, endPoint, width, capType, joinType,
+          lineDashPattern, offset);
+    }
+  }
+}
diff --git a/lottie/src/main/java/com/airbnb/lottie/GradientStrokeContent.java b/lottie/src/main/java/com/airbnb/lottie/GradientStrokeContent.java
new file mode 100644
index 00000000..bb9e1885
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/GradientStrokeContent.java
@@ -0,0 +1,112 @@
+package com.airbnb.lottie;
+
+import android.graphics.Canvas;
+import android.graphics.LinearGradient;
+import android.graphics.Matrix;
+import android.graphics.PointF;
+import android.graphics.RadialGradient;
+import android.graphics.RectF;
+import android.graphics.Shader;
+import android.support.v4.util.LongSparseArray;
+
+public class GradientStrokeContent extends BaseStrokeContent {
+  /**
+   * Cache the gradients such that it runs at 30fps.
+   */
+  private static final int CACHE_STEPS_MS = 32;
+
+  private final LongSparseArray<LinearGradient> linearGradientCache = new LongSparseArray<>();
+  private final LongSparseArray<RadialGradient> radialGradientCache = new LongSparseArray<>();
+  private final RectF boundsRect = new RectF();
+
+  private final GradientType type;
+  private final int cacheSteps;
+  private final KeyframeAnimation<GradientColor> colorAnimation;
+  private final KeyframeAnimation<PointF> startPointAnimation;
+  private final KeyframeAnimation<PointF> endPointAnimation;
+
+  GradientStrokeContent(
+      final LottieDrawable lottieDrawable, BaseLayer layer, GradientStroke stroke) {
+    super(lottieDrawable, layer, stroke.getCapType().toPaintCap(),
+        stroke.getJoinType().toPaintJoin(), stroke.getOpacity(), stroke.getWidth(),
+        stroke.getLineDashPattern(), stroke.getDashOffset());
+
+    type = stroke.getGradientType();
+    cacheSteps = (int) (lottieDrawable.getComposition().getDuration() / CACHE_STEPS_MS);
+
+    colorAnimation = stroke.getGradientColor().createAnimation();
+    colorAnimation.addUpdateListener(this);
+    layer.addAnimation(colorAnimation);
+
+    startPointAnimation = stroke.getStartPoint().createAnimation();
+    startPointAnimation.addUpdateListener(this);
+    layer.addAnimation(startPointAnimation);
+
+    endPointAnimation = stroke.getEndPoint().createAnimation();
+    endPointAnimation.addUpdateListener(this);
+    layer.addAnimation(endPointAnimation);
+  }
+
+  @Override public void draw(Canvas canvas, Matrix parentMatrix, int parentAlpha) {
+    getBounds(boundsRect, parentMatrix);
+    if (type == GradientType.Linear) {
+      paint.setShader(getLinearGradient());
+    } else {
+      paint.setShader(getRadialGradient());
+    }
+
+    super.draw(canvas, parentMatrix, parentAlpha);
+  }
+
+  private LinearGradient getLinearGradient() {
+    int gradientHash = getGradientHash();
+    LinearGradient gradient = linearGradientCache.get(gradientHash);
+    if (gradient != null) {
+      return gradient;
+    }
+    PointF startPoint = startPointAnimation.getValue();
+    PointF endPoint = endPointAnimation.getValue();
+    GradientColor gradientColor = colorAnimation.getValue();
+    int[] colors = gradientColor.getColors();
+    float[] positions = gradientColor.getPositions();
+    int x0 = (int) (boundsRect.left + boundsRect.width() / 2 + startPoint.x);
+    int y0 = (int) (boundsRect.top + boundsRect.height() / 2 + startPoint.y);
+    int x1 = (int) (boundsRect.left + boundsRect.width() / 2 + endPoint.x);
+    int y1 = (int) (boundsRect.top + boundsRect.height() / 2 + endPoint.y);
+    gradient = new LinearGradient(x0, y0, x1, y1, colors, positions, Shader.TileMode.CLAMP);
+    linearGradientCache.put(gradientHash, gradient);
+    return gradient;
+  }
+
+  private RadialGradient getRadialGradient() {
+    int gradientHash = getGradientHash();
+    RadialGradient gradient = radialGradientCache.get(gradientHash);
+    if (gradient != null) {
+      return gradient;
+    }
+    PointF startPoint = startPointAnimation.getValue();
+    PointF endPoint = endPointAnimation.getValue();
+    GradientColor gradientColor = colorAnimation.getValue();
+    int[] colors = gradientColor.getColors();
+    float[] positions = gradientColor.getPositions();
+    int x0 = (int) (boundsRect.left + boundsRect.width() / 2 + startPoint.x);
+    int y0 = (int) (boundsRect.top + boundsRect.height() / 2 + startPoint.y);
+    int x1 = (int) (boundsRect.left + boundsRect.width() / 2 + endPoint.x);
+    int y1 = (int) (boundsRect.top + boundsRect.height() / 2 + endPoint.y);
+    float r = (float) Math.hypot(x1 - x0, y1 - y0);
+    gradient = new RadialGradient(x0, y0, r, colors, positions, Shader.TileMode.CLAMP);
+    radialGradientCache.put(gradientHash, gradient);
+    return gradient;
+  }
+
+  private int getGradientHash() {
+    int startPointProgress = Math.round(startPointAnimation.getProgress() * cacheSteps);
+    int endPointProgress = Math.round(endPointAnimation.getProgress() * cacheSteps);
+    int colorProgress = Math.round(colorAnimation.getProgress() * cacheSteps);
+    int hash = 17;
+    hash = hash * 31 * startPointProgress;
+    hash = hash * 31 * endPointProgress;
+    hash = hash * 31 * colorProgress;
+    return hash;
+  }
+}
diff --git a/lottie/src/main/java/com/airbnb/lottie/GradientType.java b/lottie/src/main/java/com/airbnb/lottie/GradientType.java
new file mode 100644
index 00000000..051a9ed3
--- /dev/null
+++ b/lottie/src/main/java/com/airbnb/lottie/GradientType.java
@@ -0,0 +1,6 @@
+package com.airbnb.lottie;
+
+enum GradientType {
+  Linear,
+  Radial
+}
diff --git a/lottie/src/main/java/com/airbnb/lottie/ShapeGroup.java b/lottie/src/main/java/com/airbnb/lottie/ShapeGroup.java
index 2aa30f4d..e6ff438a 100644
--- a/lottie/src/main/java/com/airbnb/lottie/ShapeGroup.java
+++ b/lottie/src/main/java/com/airbnb/lottie/ShapeGroup.java
@@ -19,6 +19,8 @@ class ShapeGroup {
         return ShapeGroup.Factory.newInstance(json, composition);
       case "st":
         return ShapeStroke.Factory.newInstance(json, composition);
+      case "gs":
+        return GradientStroke.Factory.newInstance(json, composition);
       case "fl":
         return ShapeFill.Factory.newInstance(json, composition);
       case "gf":
diff --git a/lottie/src/main/java/com/airbnb/lottie/StrokeContent.java b/lottie/src/main/java/com/airbnb/lottie/StrokeContent.java
index 0d94e674..5d78a7ad 100644
--- a/lottie/src/main/java/com/airbnb/lottie/StrokeContent.java
+++ b/lottie/src/main/java/com/airbnb/lottie/StrokeContent.java
@@ -1,264 +1,23 @@
 package com.airbnb.lottie;
 
 import android.graphics.Canvas;
-import android.graphics.DashPathEffect;
 import android.graphics.Matrix;
-import android.graphics.Paint;
-import android.graphics.Path;
-import android.graphics.PathMeasure;
-import android.graphics.RectF;
-import android.support.annotation.Nullable;
 
-import java.util.ArrayList;
-import java.util.List;
+class StrokeContent extends BaseStrokeContent {
 
-class StrokeContent implements DrawingContent, BaseKeyframeAnimation.AnimationListener {
-  private final PathMeasure pm = new PathMeasure();
-  private final Path path = new Path();
-  private final Path trimPathPath = new Path();
-  private final Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private final RectF rect = new RectF();
-  private final LottieDrawable lottieDrawable;
-  private final List<PathGroup> pathGroups = new ArrayList<>();
-  private final float[] dashPatternValues;
-
-  private final BaseKeyframeAnimation<?, Integer> colorAnimation;
-  private final BaseKeyframeAnimation<?, Float> widthAnimation;
-  private final BaseKeyframeAnimation<?, Integer> opacityAnimation;
-  private final List<BaseKeyframeAnimation<?, Float>> dashPatternAnimations;
-  @Nullable private final BaseKeyframeAnimation<?, Float> dashPatternOffsetAnimation;
+  private final KeyframeAnimation<Integer> colorAnimation;
 
   StrokeContent(final LottieDrawable lottieDrawable, BaseLayer layer, ShapeStroke stroke) {
-    this.lottieDrawable = lottieDrawable;
-    paint.setStyle(Paint.Style.STROKE);
-    paint.setStrokeCap(stroke.getCapType().toPaintCap());
-    paint.setStrokeJoin(stroke.getJoinType().toPaintJoin());
-
+    super(lottieDrawable, layer, stroke.getCapType().toPaintCap(),
+        stroke.getJoinType().toPaintJoin(), stroke.getOpacity(), stroke.getWidth(),
+        stroke.getLineDashPattern(), stroke.getDashOffset());
     colorAnimation = stroke.getColor().createAnimation();
-    opacityAnimation = stroke.getOpacity().createAnimation();
-    widthAnimation = stroke.getWidth().createAnimation();
-
-    if (stroke.getDashOffset() == null) {
-      dashPatternOffsetAnimation = null;
-    } else {
-      dashPatternOffsetAnimation = stroke.getDashOffset().createAnimation();
-    }
-    List<AnimatableFloatValue> dashPattern = stroke.getLineDashPattern();
-    dashPatternAnimations = new ArrayList<>(dashPattern.size());
-    dashPatternValues = new float[dashPattern.size()];
-
-    for (int i = 0; i < dashPattern.size(); i++) {
-      dashPatternAnimations.add(dashPattern.get(i).createAnimation());
-    }
-
-    layer.addAnimation(colorAnimation);
-    layer.addAnimation(opacityAnimation);
-    layer.addAnimation(widthAnimation);
-    for (int i = 0; i < dashPatternAnimations.size(); i++) {
-      layer.addAnimation(dashPatternAnimations.get(i));
-    }
-    if (dashPatternOffsetAnimation != null) {
-      layer.addAnimation(dashPatternOffsetAnimation);
-    }
-
     colorAnimation.addUpdateListener(this);
-    opacityAnimation.addUpdateListener(this);
-    widthAnimation.addUpdateListener(this);
-
-    for (int i = 0; i < dashPattern.size(); i++) {
-      dashPatternAnimations.get(i).addUpdateListener(this);
-    }
-    if (dashPatternOffsetAnimation != null) {
-      dashPatternOffsetAnimation.addUpdateListener(this);
-    }
-  }
-
-  @Override public void onValueChanged() {
-    lottieDrawable.invalidateSelf();
-  }
-
-  @Override public void setContents(List<Content> contentsBefore, List<Content> contentsAfter) {
-    TrimPathContent trimPathContentBefore = null;
-    for (int i = contentsBefore.size() - 1; i >= 0; i--) {
-      Content content = contentsBefore.get(i);
-      if (content instanceof TrimPathContent &&
-          ((TrimPathContent) content).getType() == ShapeTrimPath.Type.Individually) {
-        trimPathContentBefore = (TrimPathContent) content;
-      }
-    }
-    if (trimPathContentBefore != null) {
-      trimPathContentBefore.addListener(this);
-    }
-
-    PathGroup currentPathGroup = null;
-    for (int i = contentsAfter.size() - 1; i >= 0; i--) {
-      Content content = contentsAfter.get(i);
-      if (content instanceof TrimPathContent &&
-          ((TrimPathContent) content).getType() == ShapeTrimPath.Type.Individually) {
-        if (currentPathGroup != null) {
-          pathGroups.add(currentPathGroup);
-        }
-        currentPathGroup = new PathGroup((TrimPathContent) content);
-        ((TrimPathContent) content).addListener(this);
-      } else if (content instanceof PathContent) {
-        if (currentPathGroup == null) {
-          currentPathGroup = new PathGroup(trimPathContentBefore);
-        }
-        currentPathGroup.paths.add((PathContent) content);
-      }
-    }
-    pathGroups.add(currentPathGroup);
+    layer.addAnimation(colorAnimation);
   }
 
   @Override public void draw(Canvas canvas, Matrix parentMatrix, int parentAlpha) {
     paint.setColor(colorAnimation.getValue());
-    int alpha = (int) ((parentAlpha / 255f * opacityAnimation.getValue() / 100f) * 255);
-    paint.setAlpha(alpha);
-    paint.setStrokeWidth(widthAnimation.getValue() * Utils.getScale(parentMatrix));
-    if (paint.getStrokeWidth() <= 0) {
-      // Android draws a hairline stroke for 0, After Effects doesn't.
-      return;
-    }
-    applyDashPatternIfNeeded();
-
-    for (int i = 0; i < pathGroups.size(); i++) {
-      PathGroup pathGroup = pathGroups.get(i);
-
-
-      if (pathGroup.trimPath != null) {
-        applyTrimPath(canvas, pathGroup, parentMatrix);
-      } else {
-        path.reset();
-        for (int j = pathGroup.paths.size() - 1; j >= 0; j--) {
-          path.addPath(pathGroup.paths.get(j).getPath(), parentMatrix);
-        }
-        canvas.drawPath(path, paint);
-      }
-    }
-  }
-
-  private void applyTrimPath(Canvas canvas, PathGroup pathGroup, Matrix parentMatrix) {
-    if (pathGroup.trimPath == null) {
-      return;
-    }
-    path.reset();
-    for (int j = pathGroup.paths.size() - 1; j >= 0; j--) {
-      path.addPath(pathGroup.paths.get(j).getPath(), parentMatrix);
-    }
-    pm.setPath(path, false);
-    float totalLength = pm.getLength();
-    while (pm.nextContour()) {
-      totalLength += pm.getLength();
-    }
-    float offsetLength = totalLength * pathGroup.trimPath.getOffset().getValue() / 360f;
-    float startLength =
-        totalLength * pathGroup.trimPath.getStart().getValue() / 100f + offsetLength;
-    float endLength =
-        totalLength * pathGroup.trimPath.getEnd().getValue() / 100f + offsetLength;
-
-    float currentLength = 0;
-    for (int j = pathGroup.paths.size() - 1; j >= 0; j--) {
-      trimPathPath.set(pathGroup.paths.get(j).getPath());
-      trimPathPath.transform(parentMatrix);
-      pm.setPath(trimPathPath, false);
-      float length = pm.getLength();
-      if (endLength > totalLength && endLength - totalLength < currentLength + length &&
-          currentLength < endLength - totalLength) {
-        // Draw the segment when the end is greater than the length which wraps around to the
-        // beginning.
-        float startValue;
-        if (startLength > totalLength) {
-          startValue = (startLength - totalLength) / length;
-        } else {
-          startValue = 0;
-        }
-        float endValue = Math.min((endLength - totalLength) / length, 1);
-        Utils.applyTrimPathIfNeeded(trimPathPath, startValue, endValue, 0);
-        canvas.drawPath(trimPathPath, paint);
-      } else //noinspection StatementWithEmptyBody
-        if (currentLength + length < startLength || currentLength > endLength) {
-        // Do nothing
-      } else if (currentLength + length <= endLength && startLength < currentLength) {
-        canvas.drawPath(trimPathPath, paint);
-      } else {
-        float startValue;
-        if (startLength < currentLength) {
-          startValue = 0;
-        } else {
-          startValue = (startLength - currentLength) / length;
-        }
-        float endValue;
-        if (endLength > currentLength + length) {
-          endValue = 1f;
-        } else {
-          endValue = (endLength - currentLength) / length;
-        }
-        Utils.applyTrimPathIfNeeded(trimPathPath, startValue, endValue, 0);
-        canvas.drawPath(trimPathPath, paint);
-      }
-      currentLength += length;
-    }
-  }
-
-  @Override public void getBounds(RectF outBounds, Matrix parentMatrix) {
-    path.reset();
-    for (int i = 0; i < pathGroups.size(); i++) {
-      PathGroup pathGroup = pathGroups.get(i);
-      for (int j = 0; j < pathGroup.paths.size(); j++) {
-        path.addPath(pathGroup.paths.get(i).getPath(), parentMatrix);
-      }
-    }
-    path.computeBounds(rect, false);
-
-    float width = widthAnimation.getValue();
-    rect.set(rect.left - width / 2f, rect.top - width / 2f,
-        rect.right + width / 2f, rect.bottom + width / 2f);
-    outBounds.set(rect);
-    // Add padding to account for rounding errors.
-    outBounds.set(
-        outBounds.left - 1,
-        outBounds.top - 1,
-        outBounds.right + 1,
-        outBounds.bottom + 1
-    );
-  }
-
-  private void applyDashPatternIfNeeded() {
-    if (dashPatternAnimations.isEmpty()) {
-      return;
-    }
-
-    float scale = lottieDrawable.getScale();
-    for (int i = 0; i < dashPatternAnimations.size(); i++) {
-      dashPatternValues[i] = dashPatternAnimations.get(i).getValue();
-      // If the value of the dash pattern or gap is too small, the number of individual sections
-      // approaches infinity as the value approaches 0.
-      // To mitigate this, we essentially put a minimum value on the dash pattern size of 1px
-      // and a minimum gap size of 0.01.
-      if (i % 2 == 0) {
-        if (dashPatternValues[i] < 1f) {
-          dashPatternValues[i] = 1f;
-        }
-      } else {
-        if (dashPatternValues[i] < 0.1f) {
-          dashPatternValues[i] = 0.1f;
-        }
-      }
-      dashPatternValues[i] *= scale;
-    }
-    float offset = dashPatternOffsetAnimation == null ? 0f : dashPatternOffsetAnimation.getValue();
-    paint.setPathEffect(new DashPathEffect(dashPatternValues, offset));
-  }
-
-  /**
-   * Data class to help drawing trim paths individually.
-   */
-  private static final class PathGroup {
-    private final List<PathContent> paths = new ArrayList<>();
-    @Nullable private final TrimPathContent trimPath;
-
-    private PathGroup(@Nullable TrimPathContent trimPath) {
-      this.trimPath = trimPath;
-    }
+    super.draw(canvas, parentMatrix, parentAlpha);
   }
 }
