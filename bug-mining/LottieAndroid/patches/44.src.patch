diff --git a/lottie/src/main/java/com/airbnb/lottie/AnimatableGradientColorValue.java b/lottie/src/main/java/com/airbnb/lottie/AnimatableGradientColorValue.java
index 51b0bf17..a65dc5a6 100644
--- a/lottie/src/main/java/com/airbnb/lottie/AnimatableGradientColorValue.java
+++ b/lottie/src/main/java/com/airbnb/lottie/AnimatableGradientColorValue.java
@@ -1,6 +1,7 @@
 package com.airbnb.lottie;
 
 import android.graphics.Color;
+import android.support.annotation.IntRange;
 import android.util.Log;
 
 import org.json.JSONArray;
@@ -28,7 +29,7 @@ class AnimatableGradientColorValue extends BaseAnimatableValue<GradientColor, Gr
     static AnimatableGradientColorValue newInstance(
         JSONObject json, LottieComposition composition) {
       AnimatableValueParser.Result<GradientColor> result = AnimatableValueParser
-          .newInstance(json, 1, composition, ValueFactory.INSTANCE)
+          .newInstance(json, 1, composition, new ValueFactory(json.optInt("p")))
           .parseJson();
       GradientColor initialValue = result.initialValue;
       return new AnimatableGradientColorValue(result.keyframes, initialValue);
@@ -36,26 +37,46 @@ class AnimatableGradientColorValue extends BaseAnimatableValue<GradientColor, Gr
   }
 
   private static class ValueFactory implements AnimatableValue.Factory<GradientColor> {
-    private static final ValueFactory INSTANCE = new ValueFactory();
+    private final int colorPoints;
 
-    private ValueFactory() {
+    private ValueFactory(int colorPoints) {
+      this.colorPoints = colorPoints;
     }
 
+    /**
+     * Both the color stops and opacity stops are in the same array.
+     * There are {@link #colorPoints} colors sequentially as:
+     * [
+     *     ...,
+     *     position,
+     *     red,
+     *     green,
+     *     blue,
+     *     ...
+     * ]
+     *
+     * The remainder of the array is the opacity stops sequentially as:
+     * [
+     *     ...,
+     *     position,
+     *     opacity,
+     *     ...
+     * ]
+     */
     @Override public GradientColor valueFromObject(Object object, float scale) {
       JSONArray array = (JSONArray) object;
-      int size = array.length() / 4;
-      float[] positions = new float[size];
-      int[] colors = new int[size];
+      float[] positions = new float[colorPoints];
+      int[] colors = new int[colorPoints];
       GradientColor gradientColor = new GradientColor(positions, colors);
       int r = 0;
       int g = 0;
-      if (array.length() != size * 4) {
+      if (array.length() != colorPoints * 4) {
         Log.w(L.TAG, "Unexpected gradient length: " + array.length() +
-            ". Expected " + (size * 4) + ". This may affect the appearance of the gradient. " +
+            ". Expected " + (colorPoints * 4) + ". This may affect the appearance of the gradient. " +
             "Make sure to save your After Effects file before exporting an animation with " +
             "gradients.");
       }
-      for (int i = 0; i < size * 4; i++) {
+      for (int i = 0; i < colorPoints * 4; i++) {
         int colorIndex = i / 4;
         double value = array.optDouble(i);
         switch (i % 4) {
@@ -75,7 +96,62 @@ class AnimatableGradientColorValue extends BaseAnimatableValue<GradientColor, Gr
             break;
         }
       }
+
+      addOpacityStopsToGradientIfNeeded(gradientColor, array);
       return gradientColor;
     }
+
+    /**
+     * This cheats a little bit.
+     * Opacity stops can be at arbitrary intervals independent of color stops.
+     * This uses the existing color stops and modifies the opacity at each existing color stop
+     * based on what the opacity would be.
+     *
+     * This should be a good approximation is nearly all cases. However, if there are many more
+     * opacity stops than color stops, information will be lost.
+     */
+    private void addOpacityStopsToGradientIfNeeded(GradientColor gradientColor, JSONArray array) {
+      int startIndex = colorPoints * 4;
+      if (array.length() <= startIndex) {
+        return;
+      }
+
+      int opacityStops = (array.length() - startIndex) / 2;
+      double[] positions = new double[opacityStops];
+      double[] opacities = new double[opacityStops];
+
+      for (int i = startIndex, j = 0; i < array.length(); i++) {
+        if (i % 2 == 0) {
+          positions[j] = array.optDouble(i);
+        } else {
+          opacities[j] = array.optDouble(i);
+          j++;
+        }
+      }
+
+      for (int i = 0; i < gradientColor.getSize(); i++) {
+        int color = gradientColor.getColors()[i];
+        color = Color.argb(
+            getOpacityAtPosition(gradientColor.getPositions()[i], positions, opacities),
+            Color.red(color),
+            Color.green(color),
+            Color.blue(color)
+        );
+        gradientColor.getColors()[i] = color;
+      }
+    }
+
+    @IntRange(from=0, to=255)
+    private int getOpacityAtPosition(double position, double[] positions, double[] opacities) {
+      for (int i = 1; i < positions.length; i++) {
+        double lastPosition = positions[i - 1];
+        double thisPosition = positions[i];
+        if (positions[i] >= position) {
+          double progress = (position - lastPosition) / (thisPosition - lastPosition);
+          return (int) (255 * MiscUtils.lerp(opacities[i - 1], opacities[i], progress));
+        }
+      }
+      return (int) (255 * opacities[opacities.length - 1]);
+    }
   }
 }
diff --git a/lottie/src/main/java/com/airbnb/lottie/GradientFill.java b/lottie/src/main/java/com/airbnb/lottie/GradientFill.java
index a7313c44..d911d1c1 100644
--- a/lottie/src/main/java/com/airbnb/lottie/GradientFill.java
+++ b/lottie/src/main/java/com/airbnb/lottie/GradientFill.java
@@ -3,6 +3,7 @@ package com.airbnb.lottie;
 import android.graphics.Path;
 import android.support.annotation.Nullable;
 
+import org.json.JSONException;
 import org.json.JSONObject;
 
 class GradientFill {
@@ -78,7 +79,15 @@ class GradientFill {
 
       JSONObject jsonColor = json.optJSONObject("g");
       if (jsonColor != null && jsonColor.has("k")) {
+        // This is a hack because the "p" value which contains the number of color points is outside
+        // of "k" which contains the useful data.
+        int points = jsonColor.optInt("p");
         jsonColor = jsonColor.optJSONObject("k");
+        try {
+          jsonColor.put("p", points);
+        } catch (JSONException e) {
+          // Do nothing. This shouldn't fail.
+        }
       }
       AnimatableGradientColorValue color = null;
       if (jsonColor != null) {
diff --git a/lottie/src/main/java/com/airbnb/lottie/MiscUtils.java b/lottie/src/main/java/com/airbnb/lottie/MiscUtils.java
index d135b91f..760cfc6c 100644
--- a/lottie/src/main/java/com/airbnb/lottie/MiscUtils.java
+++ b/lottie/src/main/java/com/airbnb/lottie/MiscUtils.java
@@ -28,6 +28,10 @@ class MiscUtils {
     return a + percentage * (b - a);
   }
 
+  static double lerp(double a, double b, @FloatRange(from = 0f, to = 1f) double percentage) {
+    return a + percentage * (b - a);
+  }
+
   static int lerp(int a, int b, @FloatRange(from = 0f, to = 1f) float percentage) {
     return (int) (a + percentage * (b - a));
   }
