diff --git a/lottie/src/main/java/com/airbnb/lottie/LottieTask.java b/lottie/src/main/java/com/airbnb/lottie/LottieTask.java
index 8a62b3b5..30f95950 100644
--- a/lottie/src/main/java/com/airbnb/lottie/LottieTask.java
+++ b/lottie/src/main/java/com/airbnb/lottie/LottieTask.java
@@ -28,15 +28,24 @@ import java.util.concurrent.FutureTask;
  */
 @SuppressWarnings("UnusedReturnValue")
 public class LottieTask<T> {
+  static final String DIRECT_EXECUTOR_PROPERTY_NAME = "lottie.testing.directExecutor";
 
   /**
-   * Set this to change the executor that LottieTasks are run on. This will be the executor that composition parsing and url
-   * fetching happens on.
+   * The executor which runs {@code LottieTask}s such as composition parsing and url fetching.
    * <p>
-   * You may change this to run deserialization synchronously for testing.
+   * You may change this to run synchronously for testing. Additionally, if the
+   * {@code lottie.testing.directExecutor} system property is set to "true", the initial value
+   * will be a synchronous executor suitable for use in tests.
    */
   @SuppressWarnings("WeakerAccess")
-  public static Executor EXECUTOR = Executors.newCachedThreadPool(new LottieThreadFactory());
+  public static Executor EXECUTOR;
+  static {
+    if ("true".equals(System.getProperty(DIRECT_EXECUTOR_PROPERTY_NAME))) {
+      EXECUTOR = Runnable::run;
+    } else {
+      EXECUTOR = Executors.newCachedThreadPool(new LottieThreadFactory());
+    }
+  }
 
   /* Preserve add order. */
   private final Set<LottieListener<T>> successListeners = new LinkedHashSet<>(1);
diff --git a/lottie/src/test/java/com/airbnb/lottie/LottieInitializeTest.java b/lottie/src/test/java/com/airbnb/lottie/LottieInitializeTest.java
index 688dd73c..852d383c 100644
--- a/lottie/src/test/java/com/airbnb/lottie/LottieInitializeTest.java
+++ b/lottie/src/test/java/com/airbnb/lottie/LottieInitializeTest.java
@@ -10,6 +10,7 @@ import androidx.test.platform.app.InstrumentationRegistry;
 
 import com.airbnb.lottie.network.LottieFetchResult;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -17,6 +18,7 @@ import org.junit.rules.TemporaryFolder;
 
 import java.io.InputStream;
 import java.util.Objects;
+import java.util.concurrent.Executor;
 
 public class LottieInitializeTest extends BaseTest {
 
@@ -28,11 +30,18 @@ public class LottieInitializeTest extends BaseTest {
 
   private final Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
 
+  private final Executor originalExecutor = LottieTask.EXECUTOR;
+
   @Before
   public void setExecutor() {
     LottieTask.EXECUTOR = Runnable::run;
   }
 
+  @After
+  public void resetExecutor() {
+    LottieTask.EXECUTOR = originalExecutor;
+  }
+
   @Test
   public void fetchAfterSecondInitialize() {
     initializeLottie(temporaryFolder1);
diff --git a/lottie/src/test/java/com/airbnb/lottie/LottieTaskTest.java b/lottie/src/test/java/com/airbnb/lottie/LottieTaskTest.java
index 91eeea16..0d1fda68 100644
--- a/lottie/src/test/java/com/airbnb/lottie/LottieTaskTest.java
+++ b/lottie/src/test/java/com/airbnb/lottie/LottieTaskTest.java
@@ -7,9 +7,15 @@ import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
+import java.io.IOException;
+import java.io.InputStream;
 import java.util.concurrent.Callable;
+import java.util.concurrent.Executor;
 import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicBoolean;
 
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoInteractions;
@@ -87,4 +93,44 @@ public class LottieTaskTest extends BaseTest {
     verify(successListener, times(1)).onResult(5);
     verifyNoInteractions(failureListener);
   }
+
+  @Test
+  public void executorIsRealThreadPoolByDefault() {
+    AtomicBoolean isDirect = new AtomicBoolean();
+    LottieTask.EXECUTOR.execute(() -> isDirect.set(true));
+    assertFalse(isDirect.get());
+  }
+
+  @Test
+  public void executorIsDirectWhenTestingPropertySetToTrue() throws Exception {
+    // Use a custom ClassLoader to force a new class instance which will cause the
+    // static initializers to run and observe the new system property set below.
+    String lottieTaskName = LottieTask.class.getName();
+    ClassLoader customLoader = new ClassLoader() {
+      @Override public Class<?> loadClass(String name) throws ClassNotFoundException {
+        if (name.equals(lottieTaskName)) {
+          try (InputStream in = ClassLoader.getSystemResourceAsStream(lottieTaskName.replace('.', '/') + ".class")) {
+            byte[] bytes = new byte[10 * 1024 * 1024];
+            int read  = in.read(bytes);
+            return defineClass(name, bytes, 0, read);
+          } catch (IOException e) {
+            throw new ClassNotFoundException(name, e);
+          }
+        }
+        return super.loadClass(name);
+      }
+    };
+
+    System.setProperty(LottieTask.DIRECT_EXECUTOR_PROPERTY_NAME, "true");
+    try {
+      Class<?> c = customLoader.loadClass(lottieTaskName);
+      Executor e = (Executor) c.getField("EXECUTOR").get(null);
+
+      AtomicBoolean isDirect = new AtomicBoolean();
+      e.execute(() -> isDirect.set(true));
+      assertTrue(isDirect.get());
+    } finally {
+      System.clearProperty(LottieTask.DIRECT_EXECUTOR_PROPERTY_NAME);
+    }
+  }
 }
