diff --git a/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/AnimationFragment.kt b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/AnimationFragment.kt
index f1ea666b..09f4a88f 100644
--- a/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/AnimationFragment.kt
+++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/AnimationFragment.kt
@@ -1,6 +1,5 @@
 package com.airbnb.lottie.samples
 
-import android.Manifest
 import android.app.Activity
 import android.app.AlertDialog
 import android.content.Intent
@@ -106,8 +105,10 @@ class AnimationFragment : Fragment() {
                 }
         ))
 
-        view.animationView.addAnimatorUpdateListener {
-            animation -> seekBar.progress = ((animation.animatedValue as Float) * 100f).toInt()
+        view.animationView.addAnimatorUpdateListener { animation ->
+            if (animation.isRunning) {
+                seekBar.progress = (animation.animatedValue as Float * 100f).toInt()
+            }
         }
 
         view.seekBar.setOnSeekBarChangeListener(OnSeekBarChangeListenerAdapter(
@@ -120,7 +121,6 @@ class AnimationFragment : Fragment() {
 
         view.trimView.setCallback({ startProgress, endProgress ->
             animationView.setMinAndMaxProgress(startProgress, endProgress)
-            animationView.progress = startProgress
         })
 
         view.scaleSeekBar.setOnSeekBarChangeListener(OnSeekBarChangeListenerAdapter(
diff --git a/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/TrimView.kt b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/TrimView.kt
index a6dc2f85..307c590c 100644
--- a/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/TrimView.kt
+++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/TrimView.kt
@@ -31,10 +31,10 @@ class TrimView @JvmOverloads constructor(
         override fun getViewHorizontalDragRange(child: View) = width
 
         override fun clampViewPositionHorizontal(child: View, left: Int, dx: Int): Int {
-            if (child == leftAnchor) {
-                return maxOf(minOf(left, rightAnchor.left - leftAnchor.width), 0)
+            return if (child == leftAnchor) {
+                maxOf(minOf(left, rightAnchor.left - leftAnchor.width), 0)
             } else {
-                return minOf(maxOf(leftAnchor.right, left), width - rightAnchor.width)
+                minOf(maxOf(leftAnchor.right, left), width - rightAnchor.width)
             }
         }
 
diff --git a/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
index 6681482f..53c173cb 100644
--- a/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
+++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
@@ -50,7 +50,6 @@ import java.util.Set;
   private LottieComposition composition;
   private final LottieValueAnimator animator = new LottieValueAnimator();
   private float speed = 1f;
-  private float progress = 0f;
   private float scale = 1f;
 
   private final Set<ColorFilterData> colorFilterData = new HashSet<>();
@@ -75,7 +74,7 @@ import java.util.Set;
         if (systemAnimationsAreDisabled) {
           setProgress(1f);
         } else {
-          setProgress((float) animation.getAnimatedValue());
+          setProgress((Float) animation.getAnimatedValue());
         }
       }
     });
@@ -166,8 +165,6 @@ import java.util.Set;
     buildCompositionLayer();
     applyColorFilters();
 
-    setProgress(progress);
-
     // We copy the tasks to a new ArrayList so that if this method is called from multiple threads,
     // then there won't be two iterators iterating and removing at the same time.
     Iterator<LazyCompositionTask> it = new ArrayList<>(lazyCompositionTasks).iterator();
@@ -362,26 +359,28 @@ import java.util.Set;
   }
 
   public void playAnimation() {
-    playAnimation((progress > 0.0 && progress < 1.0));
+    playAnimation(true);
   }
 
   public void resumeAnimation() {
-    playAnimation(true);
+    playAnimation(animator.getAnimatedFraction() == 1f);
   }
 
-  private void playAnimation(boolean setStartTime) {
+  private void playAnimation(final boolean resetProgress) {
     if (compositionLayer == null) {
       lazyCompositionTasks.add(new LazyCompositionTask() {
         @Override public void run(LottieComposition composition) {
-          playAnimation();
+          playAnimation(resetProgress);
         }
       });
       return;
     }
-    long playTime = setStartTime ? (long) (progress * animator.getDuration()) : 0;
+    float progress = animator.getProgress();
     animator.start();
-    if (setStartTime) {
-      animator.setCurrentPlayTime(playTime);
+    if (resetProgress || animator.getAnimatedFraction() == 1f) {
+      animator.setProgress(animator.getMinProgress());
+    } else {
+      animator.setProgress(progress);
     }
   }
 
@@ -389,8 +388,7 @@ import java.util.Set;
     if (composition == null) {
       lazyCompositionTasks.add(new LazyCompositionTask() {
         @Override public void run(LottieComposition composition) {
-          playAnimation(startFrame / composition.getDurationFrames(),
-              endFrame / composition.getDurationFrames());
+          playAnimation(startFrame, endFrame);
         }
       });
       return;
@@ -408,58 +406,62 @@ import java.util.Set;
   }
 
   public void resumeReverseAnimation() {
-    reverseAnimation(true);
+    reverseAnimation(false);
   }
 
   public void reverseAnimation() {
-    reverseAnimation((progress > 0.0 && progress < 1.0));
+    float progress = getProgress();
+    reverseAnimation(true);
   }
 
-  private void reverseAnimation(boolean setStartTime) {
+  private void reverseAnimation(final boolean resetProgress) {
     if (compositionLayer == null) {
       lazyCompositionTasks.add(new LazyCompositionTask() {
         @Override public void run(LottieComposition composition) {
-          reverseAnimation();
+          reverseAnimation(resetProgress);
         }
       });
       return;
     }
-    if (setStartTime) {
-      animator.setCurrentPlayTime((long) (progress * animator.getDuration()));
-    }
+    float progress = animator.getProgress();
     animator.reverse();
+    if (resetProgress || getProgress() == 1f) {
+      animator.setProgress(animator.getMinProgress());
+    } else {
+      animator.setProgress(progress);
+    }
   }
 
-  public void setMinFrame(final int startFrame) {
+  public void setMinFrame(final int minFrame) {
     if (composition == null) {
       lazyCompositionTasks.add(new LazyCompositionTask() {
         @Override public void run(LottieComposition composition) {
-          setMinProgress(startFrame / composition.getDurationFrames());
+          setMinFrame(minFrame);
         }
       });
       return;
     }
-    setMinProgress(startFrame / composition.getDurationFrames());
+    setMinProgress(minFrame / composition.getDurationFrames());
   }
 
-   public void setMinProgress(float startProgress) {
-    animator.setStartProgress(startProgress);
+   public void setMinProgress(float minProgress) {
+    animator.setMinProgress(minProgress);
   }
 
-  public void setMaxFrame(final int endFrame) {
+  public void setMaxFrame(final int maxFrame) {
     if (composition == null) {
       lazyCompositionTasks.add(new LazyCompositionTask() {
         @Override public void run(LottieComposition composition) {
-          setMaxProgress(endFrame / composition.getDurationFrames());
+          setMaxFrame(maxFrame);
         }
       });
       return;
     }
-    setMaxProgress(endFrame / composition.getDurationFrames());
+    setMaxProgress(maxFrame / composition.getDurationFrames());
   }
 
-  public void setMaxProgress(float endProgress) {
-    animator.setEndProgress(endProgress);
+  public void setMaxProgress(float maxProgress) {
+    animator.setMaxProgress(maxProgress);
   }
 
   public void setMinAndMaxFrame(int minFrame, int maxFrame) {
@@ -482,14 +484,14 @@ import java.util.Set;
   }
 
   public void setProgress(@FloatRange(from = 0f, to = 1f) float progress) {
-    this.progress = progress;
+    animator.setProgress(progress);
     if (compositionLayer != null) {
       compositionLayer.setProgress(progress);
     }
   }
 
   public float getProgress() {
-    return progress;
+    return animator.getProgress();
   }
 
   /**
diff --git a/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java b/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java
index 80cf2115..86222f2f 100644
--- a/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java
+++ b/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java
@@ -3,6 +3,7 @@ package com.airbnb.lottie.utils;
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.animation.ValueAnimator;
+import android.support.annotation.FloatRange;
 
 /**
  * This is a slightly modified {@link ValueAnimator} that allows us to update start and end values
@@ -10,9 +11,11 @@ import android.animation.ValueAnimator;
  */
 public class LottieValueAnimator extends ValueAnimator {
   private boolean isReversed = false;
-  private float startProgress = 0f;
-  private float endProgress = 1f;
-  private long duration;
+  private float minProgress = 0f;
+  private float maxProgress = 1f;
+  private long originalDuration;
+
+  private float progress = 0f;
 
   public LottieValueAnimator() {
     setFloatValues(0f, 1f);
@@ -23,45 +26,86 @@ public class LottieValueAnimator extends ValueAnimator {
      */
     addListener(new AnimatorListenerAdapter() {
       @Override public void onAnimationEnd(Animator animation) {
-        updateValues();
+        updateValues(minProgress, maxProgress);
       }
 
       @Override public void onAnimationCancel(Animator animation) {
-        updateValues();
+        updateValues(minProgress, maxProgress);
+      }
+    });
+
+    addUpdateListener(new AnimatorUpdateListener() {
+      @Override public void onAnimationUpdate(ValueAnimator animation) {
+        progress = (float) animation.getAnimatedValue();
       }
     });
   }
 
   @Override public ValueAnimator setDuration(long duration) {
-    this.duration = duration;
-    updateValues();
+    this.originalDuration = duration;
+    updateValues(minProgress, maxProgress);
     return this;
   }
 
-  @Override public long getDuration() {
-    return duration;
+  /**
+   * This progress is from 0 to 1 and doesn't take into account setMinProgress or setMaxProgress.
+   * In other words, if you have set the min and max progress to 0.2 and 0.4, setting this to
+   * 0.5f will set the progress to 0.5, not 0.3. However, the value will be clamped between 0.2 and
+   * 0.4 so the resulting progress would be 0.4.
+   */
+  public void setProgress(@FloatRange(from = 0f, to = 1f) float progress) {
+    if (this.progress == progress) {
+      return;
+    }
+    if (progress < minProgress) {
+      progress = minProgress;
+    } else if (progress > maxProgress) {
+      progress = maxProgress;
+    }
+    this.progress = progress;
+    if (getDuration() > 0) {
+      float offsetProgress = (progress - minProgress) / (maxProgress - minProgress);
+      setCurrentPlayTime((long) (getDuration() * offsetProgress));
+    }
+  }
+
+  public float getProgress() {
+    return progress;
   }
 
+
   public void setIsReversed(boolean isReversed) {
     this.isReversed = isReversed;
-    updateValues();
+    updateValues(minProgress, maxProgress);
+  }
+
+  public void setMinProgress(float minProgress) {
+    this.minProgress = minProgress;
+    updateValues(minProgress, maxProgress);
   }
 
-  public void setStartProgress(float startProgress) {
-    this.startProgress = startProgress;
-    updateValues();
+  public void setMaxProgress(float maxProgress) {
+    this.maxProgress = maxProgress;
+    updateValues(minProgress, maxProgress);
   }
 
-  public void setEndProgress(float endProgress) {
-    this.endProgress = endProgress;
-    updateValues();
+  public float getMinProgress() {
+    return minProgress;
+  }
+
+  @Override public void resume() {
+    float startingProgress = progress;
+    start();
+    // This has to call through setCurrentPlayTime for compatibility reasons.
+    setProgress(startingProgress);
   }
 
   /**
    * This lets you set the start and end progress for a single play of the animator. After the next
    * time the animation ends or is cancelled, the values will be reset to those set by
-   * {@link #setStartProgress(float)} or {@link #setEndProgress(float)}.
+   * {@link #setMinProgress(float)} or {@link #setMaxProgress(float)}.
    */
+  @SuppressWarnings("WeakerAccess")
   public void updateValues(float startProgress, float endProgress) {
     float minValue = Math.min(startProgress, endProgress);
     float maxValue = Math.max(startProgress, endProgress);
@@ -69,10 +113,7 @@ public class LottieValueAnimator extends ValueAnimator {
         isReversed ? maxValue : minValue,
         isReversed ? minValue : maxValue
     );
-    super.setDuration((long) (duration * (maxValue - minValue)));
-  }
-
-  private void updateValues() {
-    updateValues(startProgress, endProgress);
+    super.setDuration((long) (originalDuration * (maxValue - minValue)));
+    setProgress(getProgress());
   }
 }
