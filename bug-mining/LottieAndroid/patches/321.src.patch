diff --git a/lottie/src/main/java/com/airbnb/lottie/L.java b/lottie/src/main/java/com/airbnb/lottie/L.java
index c22cb114..bf8f326f 100644
--- a/lottie/src/main/java/com/airbnb/lottie/L.java
+++ b/lottie/src/main/java/com/airbnb/lottie/L.java
@@ -46,6 +46,10 @@ public class L {
     }
   }
 
+  public static boolean isTraceEnabled(){
+    return traceEnabled;
+  }
+
   public static void setNetworkCacheEnabled(boolean enabled) {
     networkCacheEnabled = enabled;
   }
diff --git a/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
index 37395fa6..89ec1a81 100644
--- a/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
+++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java
@@ -687,7 +687,9 @@ public class LottieDrawable extends Drawable implements Drawable.Callback, Anima
       if (asyncUpdatesEnabled) {
         setProgressDrawLock.acquire();
       }
-      L.beginSection("Drawable#draw");
+      if (L.isTraceEnabled()) {
+        L.beginSection("Drawable#draw");
+      }
 
       if (asyncUpdatesEnabled && shouldSetProgressBeforeDrawing()) {
         setProgress(animator.getAnimatedValueAbsolute());
@@ -715,7 +717,9 @@ public class LottieDrawable extends Drawable implements Drawable.Callback, Anima
     } catch (InterruptedException e) {
       // Do nothing.
     } finally {
-      L.endSection("Drawable#draw");
+      if (L.isTraceEnabled()) {
+        L.endSection("Drawable#draw");
+      }
       if (asyncUpdatesEnabled) {
         setProgressDrawLock.release();
         if (compositionLayer.getProgress() != animator.getAnimatedValueAbsolute()) {
@@ -1137,9 +1141,13 @@ public class LottieDrawable extends Drawable implements Drawable.Callback, Anima
       lazyCompositionTasks.add(c -> setProgress(progress));
       return;
     }
-    L.beginSection("Drawable#setProgress");
+    if (L.isTraceEnabled()) {
+      L.beginSection("Drawable#setProgress");
+    }
     animator.setFrame(composition.getFrameForProgress(progress));
-    L.endSection("Drawable#setProgress");
+    if (L.isTraceEnabled()) {
+      L.endSection("Drawable#setProgress");
+    }
   }
 
   /**
diff --git a/lottie/src/main/java/com/airbnb/lottie/animation/content/BaseStrokeContent.java b/lottie/src/main/java/com/airbnb/lottie/animation/content/BaseStrokeContent.java
index 7ed31f16..fe4eb306 100644
--- a/lottie/src/main/java/com/airbnb/lottie/animation/content/BaseStrokeContent.java
+++ b/lottie/src/main/java/com/airbnb/lottie/animation/content/BaseStrokeContent.java
@@ -155,9 +155,13 @@ public abstract class BaseStrokeContent
   }
 
   @Override public void draw(Canvas canvas, Matrix parentMatrix, int parentAlpha) {
-    L.beginSection("StrokeContent#draw");
+    if (L.isTraceEnabled()) {
+      L.beginSection("StrokeContent#draw");
+    }
     if (Utils.hasZeroScaleAxis(parentMatrix)) {
-      L.endSection("StrokeContent#draw");
+      if (L.isTraceEnabled()) {
+        L.endSection("StrokeContent#draw");
+      }
       return;
     }
     int alpha = (int) ((parentAlpha / 255f * ((IntegerKeyframeAnimation) opacityAnimation).getIntValue() / 100f) * 255);
@@ -165,7 +169,9 @@ public abstract class BaseStrokeContent
     paint.setStrokeWidth(((FloatKeyframeAnimation) widthAnimation).getFloatValue() * Utils.getScale(parentMatrix));
     if (paint.getStrokeWidth() <= 0) {
       // Android draws a hairline stroke for 0, After Effects doesn't.
-      L.endSection("StrokeContent#draw");
+      if (L.isTraceEnabled()) {
+        L.endSection("StrokeContent#draw");
+      }
       return;
     }
     applyDashPatternIfNeeded(parentMatrix);
@@ -195,24 +201,36 @@ public abstract class BaseStrokeContent
       if (pathGroup.trimPath != null) {
         applyTrimPath(canvas, pathGroup, parentMatrix);
       } else {
-        L.beginSection("StrokeContent#buildPath");
+        if (L.isTraceEnabled()) {
+          L.beginSection("StrokeContent#buildPath");
+        }
         path.reset();
         for (int j = pathGroup.paths.size() - 1; j >= 0; j--) {
           path.addPath(pathGroup.paths.get(j).getPath(), parentMatrix);
         }
-        L.endSection("StrokeContent#buildPath");
-        L.beginSection("StrokeContent#drawPath");
+        if (L.isTraceEnabled()) {
+          L.endSection("StrokeContent#buildPath");
+          L.beginSection("StrokeContent#drawPath");
+        }
         canvas.drawPath(path, paint);
-        L.endSection("StrokeContent#drawPath");
+        if (L.isTraceEnabled()) {
+          L.endSection("StrokeContent#drawPath");
+        }
       }
     }
-    L.endSection("StrokeContent#draw");
+    if (L.isTraceEnabled()) {
+      L.endSection("StrokeContent#draw");
+    }
   }
 
   private void applyTrimPath(Canvas canvas, PathGroup pathGroup, Matrix parentMatrix) {
-    L.beginSection("StrokeContent#applyTrimPath");
+    if (L.isTraceEnabled()) {
+      L.beginSection("StrokeContent#applyTrimPath");
+    }
     if (pathGroup.trimPath == null) {
-      L.endSection("StrokeContent#applyTrimPath");
+      if (L.isTraceEnabled()) {
+        L.endSection("StrokeContent#applyTrimPath");
+      }
       return;
     }
     path.reset();
@@ -226,7 +244,9 @@ public abstract class BaseStrokeContent
     // If the start-end is ~100, consider it to be the full path.
     if (animStartValue < 0.01f && animEndValue > 0.99f) {
       canvas.drawPath(path, paint);
-      L.endSection("StrokeContent#applyTrimPath");
+      if (L.isTraceEnabled()) {
+        L.endSection("StrokeContent#applyTrimPath");
+      }
       return;
     }
 
@@ -282,11 +302,15 @@ public abstract class BaseStrokeContent
         }
       currentLength += length;
     }
-    L.endSection("StrokeContent#applyTrimPath");
+    if (L.isTraceEnabled()) {
+      L.endSection("StrokeContent#applyTrimPath");
+    }
   }
 
   @Override public void getBounds(RectF outBounds, Matrix parentMatrix, boolean applyParents) {
-    L.beginSection("StrokeContent#getBounds");
+    if (L.isTraceEnabled()) {
+      L.beginSection("StrokeContent#getBounds");
+    }
     path.reset();
     for (int i = 0; i < pathGroups.size(); i++) {
       PathGroup pathGroup = pathGroups.get(i);
@@ -307,13 +331,19 @@ public abstract class BaseStrokeContent
         outBounds.right + 1,
         outBounds.bottom + 1
     );
-    L.endSection("StrokeContent#getBounds");
+    if (L.isTraceEnabled()) {
+      L.endSection("StrokeContent#getBounds");
+    }
   }
 
   private void applyDashPatternIfNeeded(Matrix parentMatrix) {
-    L.beginSection("StrokeContent#applyDashPattern");
+    if (L.isTraceEnabled()) {
+      L.beginSection("StrokeContent#applyDashPattern");
+    }
     if (dashPatternAnimations.isEmpty()) {
-      L.endSection("StrokeContent#applyDashPattern");
+      if (L.isTraceEnabled()) {
+        L.endSection("StrokeContent#applyDashPattern");
+      }
       return;
     }
 
@@ -337,7 +367,9 @@ public abstract class BaseStrokeContent
     }
     float offset = dashPatternOffsetAnimation == null ? 0f : dashPatternOffsetAnimation.getValue() * scale;
     paint.setPathEffect(new DashPathEffect(dashPatternValues, offset));
-    L.endSection("StrokeContent#applyDashPattern");
+    if (L.isTraceEnabled()) {
+      L.endSection("StrokeContent#applyDashPattern");
+    }
   }
 
   @Override public void resolveKeyPath(
diff --git a/lottie/src/main/java/com/airbnb/lottie/animation/content/FillContent.java b/lottie/src/main/java/com/airbnb/lottie/animation/content/FillContent.java
index 0e89c78e..1690989c 100644
--- a/lottie/src/main/java/com/airbnb/lottie/animation/content/FillContent.java
+++ b/lottie/src/main/java/com/airbnb/lottie/animation/content/FillContent.java
@@ -101,7 +101,9 @@ public class FillContent
     if (hidden) {
       return;
     }
-    L.beginSection("FillContent#draw");
+    if (L.isTraceEnabled()) {
+      L.beginSection("FillContent#draw");
+    }
     int color = ((ColorKeyframeAnimation) this.colorAnimation).getIntValue();
     int alpha = (int) ((parentAlpha / 255f * opacityAnimation.getValue() / 100f) * 255);
     paint.setColor((clamp(alpha, 0, 255) << 24) | (color & 0xFFFFFF));
@@ -131,7 +133,9 @@ public class FillContent
 
     canvas.drawPath(path, paint);
 
-    L.endSection("FillContent#draw");
+    if (L.isTraceEnabled()) {
+      L.endSection("FillContent#draw");
+    }
   }
 
   @Override public void getBounds(RectF outBounds, Matrix parentMatrix, boolean applyParents) {
diff --git a/lottie/src/main/java/com/airbnb/lottie/animation/content/GradientFillContent.java b/lottie/src/main/java/com/airbnb/lottie/animation/content/GradientFillContent.java
index 16def664..783bbb08 100644
--- a/lottie/src/main/java/com/airbnb/lottie/animation/content/GradientFillContent.java
+++ b/lottie/src/main/java/com/airbnb/lottie/animation/content/GradientFillContent.java
@@ -117,7 +117,9 @@ public class GradientFillContent
     if (hidden) {
       return;
     }
-    L.beginSection("GradientFillContent#draw");
+    if (L.isTraceEnabled()) {
+      L.beginSection("GradientFillContent#draw");
+    }
     path.reset();
     for (int i = 0; i < paths.size(); i++) {
       path.addPath(paths.get(i).getPath(), parentMatrix);
@@ -156,7 +158,9 @@ public class GradientFillContent
     paint.setAlpha(clamp(alpha, 0, 255));
 
     canvas.drawPath(path, paint);
-    L.endSection("GradientFillContent#draw");
+    if (L.isTraceEnabled()) {
+      L.endSection("GradientFillContent#draw");
+    }
   }
 
   @Override public void getBounds(RectF outBounds, Matrix parentMatrix, boolean applyParents) {
diff --git a/lottie/src/main/java/com/airbnb/lottie/animation/keyframe/BaseKeyframeAnimation.java b/lottie/src/main/java/com/airbnb/lottie/animation/keyframe/BaseKeyframeAnimation.java
index 5f94a927..cb634387 100644
--- a/lottie/src/main/java/com/airbnb/lottie/animation/keyframe/BaseKeyframeAnimation.java
+++ b/lottie/src/main/java/com/airbnb/lottie/animation/keyframe/BaseKeyframeAnimation.java
@@ -49,9 +49,13 @@ public abstract class BaseKeyframeAnimation<K, A> {
   }
 
   public void setProgress(@FloatRange(from = 0f, to = 1f) float progress) {
-    L.beginSection("BaseKeyframeAnimation#setProgress");
+    if (L.isTraceEnabled()) {
+      L.beginSection("BaseKeyframeAnimation#setProgress");
+    }
     if (keyframesWrapper.isEmpty()) {
-      L.endSection("BaseKeyframeAnimation#setProgress");
+      if (L.isTraceEnabled()) {
+        L.endSection("BaseKeyframeAnimation#setProgress");
+      }
       return;
     }
     if (progress < getStartDelayProgress()) {
@@ -61,28 +65,40 @@ public abstract class BaseKeyframeAnimation<K, A> {
     }
 
     if (progress == this.progress) {
-      L.endSection("BaseKeyframeAnimation#setProgress");
+      if (L.isTraceEnabled()) {
+        L.endSection("BaseKeyframeAnimation#setProgress");
+      }
       return;
     }
     this.progress = progress;
     if (keyframesWrapper.isValueChanged(progress)) {
       notifyListeners();
     }
-    L.endSection("BaseKeyframeAnimation#setProgress");
+    if (L.isTraceEnabled()) {
+      L.endSection("BaseKeyframeAnimation#setProgress");
+    }
   }
 
   public void notifyListeners() {
-    L.beginSection("BaseKeyframeAnimation#notifyListeners");
+    if (L.isTraceEnabled()) {
+      L.beginSection("BaseKeyframeAnimation#notifyListeners");
+    }
     for (int i = 0; i < listeners.size(); i++) {
       listeners.get(i).onValueChanged();
     }
-    L.endSection("BaseKeyframeAnimation#notifyListeners");
+    if (L.isTraceEnabled()) {
+      L.endSection("BaseKeyframeAnimation#notifyListeners");
+    }
   }
 
   protected Keyframe<K> getCurrentKeyframe() {
-    L.beginSection("BaseKeyframeAnimation#getCurrentKeyframe");
+    if (L.isTraceEnabled()) {
+      L.beginSection("BaseKeyframeAnimation#getCurrentKeyframe");
+    }
     final Keyframe<K> keyframe = keyframesWrapper.getCurrentKeyframe();
-    L.endSection("BaseKeyframeAnimation#getCurrentKeyframe");
+    if (L.isTraceEnabled()) {
+      L.endSection("BaseKeyframeAnimation#getCurrentKeyframe");
+    }
     return keyframe;
   }
 
diff --git a/lottie/src/main/java/com/airbnb/lottie/model/layer/BaseLayer.java b/lottie/src/main/java/com/airbnb/lottie/model/layer/BaseLayer.java
index 427cb65d..5a4afc01 100644
--- a/lottie/src/main/java/com/airbnb/lottie/model/layer/BaseLayer.java
+++ b/lottie/src/main/java/com/airbnb/lottie/model/layer/BaseLayer.java
@@ -235,13 +235,17 @@ public abstract class BaseLayer
       return;
     }
     buildParentLayerListIfNeeded();
-    L.beginSection("Layer#parentMatrix");
+    if (L.isTraceEnabled()) {
+      L.beginSection("Layer#parentMatrix");
+    }
     matrix.reset();
     matrix.set(parentMatrix);
     for (int i = parentLayers.size() - 1; i >= 0; i--) {
       matrix.preConcat(parentLayers.get(i).transform.getMatrix());
     }
-    L.endSection("Layer#parentMatrix");
+    if (L.isTraceEnabled()) {
+      L.endSection("Layer#parentMatrix");
+    }
     // It is unclear why but getting the opacity here would sometimes NPE.
     // The extra code here is designed to avoid this.
     // https://github.com/airbnb/lottie-android/issues/2083
@@ -256,14 +260,20 @@ public abstract class BaseLayer
     int alpha = (int) ((parentAlpha / 255f * (float) opacity / 100f) * 255);
     if (!hasMatteOnThisLayer() && !hasMasksOnThisLayer()) {
       matrix.preConcat(transform.getMatrix());
-      L.beginSection("Layer#drawLayer");
+      if (L.isTraceEnabled()) {
+        L.beginSection("Layer#drawLayer");
+      }
       drawLayer(canvas, matrix, alpha);
-      L.endSection("Layer#drawLayer");
+      if (L.isTraceEnabled()) {
+        L.endSection("Layer#drawLayer");
+      }
       recordRenderTime(L.endSection(drawTraceName));
       return;
     }
 
-    L.beginSection("Layer#computeBounds");
+    if (L.isTraceEnabled()) {
+      L.beginSection("Layer#computeBounds");
+    }
     getBounds(rect, matrix, false);
 
     intersectBoundsWithMatte(rect, parentMatrix);
@@ -285,44 +295,66 @@ public abstract class BaseLayer
       rect.set(0, 0, 0, 0);
     }
 
-    L.endSection("Layer#computeBounds");
+    if (L.isTraceEnabled()) {
+      L.endSection("Layer#computeBounds");
+    }
 
     // Ensure that what we are drawing is >=1px of width and height.
     // On older devices, drawing to an offscreen buffer of <1px would draw back as a black bar.
     // https://github.com/airbnb/lottie-android/issues/1625
     if (rect.width() >= 1f && rect.height() >= 1f) {
-      L.beginSection("Layer#saveLayer");
+      if (L.isTraceEnabled()) {
+        L.beginSection("Layer#saveLayer");
+      }
       contentPaint.setAlpha(255);
       Utils.saveLayerCompat(canvas, rect, contentPaint);
-      L.endSection("Layer#saveLayer");
+      if (L.isTraceEnabled()) {
+        L.endSection("Layer#saveLayer");
+      }
 
       // Clear the off screen buffer. This is necessary for some phones.
       clearCanvas(canvas);
-      L.beginSection("Layer#drawLayer");
+      if (L.isTraceEnabled()) {
+        L.beginSection("Layer#drawLayer");
+      }
       drawLayer(canvas, matrix, alpha);
-      L.endSection("Layer#drawLayer");
+      if (L.isTraceEnabled()) {
+        L.endSection("Layer#drawLayer");
+      }
 
       if (hasMasksOnThisLayer()) {
         applyMasks(canvas, matrix);
       }
 
       if (hasMatteOnThisLayer()) {
-        L.beginSection("Layer#drawMatte");
-        L.beginSection("Layer#saveLayer");
+        if (L.isTraceEnabled()) {
+          L.beginSection("Layer#drawMatte");
+          L.beginSection("Layer#saveLayer");
+        }
         Utils.saveLayerCompat(canvas, rect, mattePaint, SAVE_FLAGS);
-        L.endSection("Layer#saveLayer");
+        if (L.isTraceEnabled()) {
+          L.endSection("Layer#saveLayer");
+        }
         clearCanvas(canvas);
         //noinspection ConstantConditions
         matteLayer.draw(canvas, parentMatrix, alpha);
-        L.beginSection("Layer#restoreLayer");
+        if (L.isTraceEnabled()) {
+          L.beginSection("Layer#restoreLayer");
+        }
         canvas.restore();
-        L.endSection("Layer#restoreLayer");
-        L.endSection("Layer#drawMatte");
+        if (L.isTraceEnabled()) {
+          L.endSection("Layer#restoreLayer");
+          L.endSection("Layer#drawMatte");
+        }
       }
 
-      L.beginSection("Layer#restoreLayer");
+      if (L.isTraceEnabled()) {
+        L.beginSection("Layer#restoreLayer");
+      }
       canvas.restore();
-      L.endSection("Layer#restoreLayer");
+      if (L.isTraceEnabled()) {
+        L.endSection("Layer#restoreLayer");
+      }
     }
 
     if (outlineMasksAndMattes && outlineMasksAndMattesPaint != null) {
@@ -345,10 +377,14 @@ public abstract class BaseLayer
   }
 
   private void clearCanvas(Canvas canvas) {
-    L.beginSection("Layer#clearLayer");
+    if (L.isTraceEnabled()) {
+      L.beginSection("Layer#clearLayer");
+    }
     // If we don't pad the clear draw, some phones leave a 1px border of the graphics buffer.
     canvas.drawRect(rect.left - 1, rect.top - 1, rect.right + 1, rect.bottom + 1, clearPaint);
-    L.endSection("Layer#clearLayer");
+    if (L.isTraceEnabled()) {
+      L.endSection("Layer#clearLayer");
+    }
   }
 
   private void intersectBoundsWithMask(RectF rect, Matrix matrix) {
@@ -429,14 +465,18 @@ public abstract class BaseLayer
   abstract void drawLayer(Canvas canvas, Matrix parentMatrix, int parentAlpha);
 
   private void applyMasks(Canvas canvas, Matrix matrix) {
-    L.beginSection("Layer#saveLayer");
+    if (L.isTraceEnabled()) {
+      L.beginSection("Layer#saveLayer");
+    }
     Utils.saveLayerCompat(canvas, rect, dstInPaint, SAVE_FLAGS);
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.P) {
       // Pre-Pie, offscreen buffers were opaque which meant that outer border of a mask
       // might get drawn depending on the result of float rounding.
       clearCanvas(canvas);
     }
-    L.endSection("Layer#saveLayer");
+    if (L.isTraceEnabled()) {
+      L.endSection("Layer#saveLayer");
+    }
     for (int i = 0; i < mask.getMasks().size(); i++) {
       Mask mask = this.mask.getMasks().get(i);
       BaseKeyframeAnimation<ShapeData, Path> maskAnimation = this.mask.getMaskAnimations().get(i);
@@ -480,9 +520,13 @@ public abstract class BaseLayer
           break;
       }
     }
-    L.beginSection("Layer#restoreLayer");
+    if (L.isTraceEnabled()) {
+      L.beginSection("Layer#restoreLayer");
+    }
     canvas.restore();
-    L.endSection("Layer#restoreLayer");
+    if (L.isTraceEnabled()) {
+      L.endSection("Layer#restoreLayer");
+    }
   }
 
   private boolean areAllMasksNone() {
@@ -572,34 +616,54 @@ public abstract class BaseLayer
   }
 
   void setProgress(@FloatRange(from = 0f, to = 1f) float progress) {
-    L.beginSection("BaseLayer#setProgress");
-    // Time stretch should not be applied to the layer transform.
-    L.beginSection("BaseLayer#setProgress.transform");
+    if (L.isTraceEnabled()) {
+      L.beginSection("BaseLayer#setProgress");
+      // Time stretch should not be applied to the layer transform.
+      L.beginSection("BaseLayer#setProgress.transform");
+    }
     transform.setProgress(progress);
-    L.endSection("BaseLayer#setProgress.transform");
+    if (L.isTraceEnabled()) {
+      L.endSection("BaseLayer#setProgress.transform");
+    }
     if (mask != null) {
-      L.beginSection("BaseLayer#setProgress.mask");
+      if (L.isTraceEnabled()) {
+        L.beginSection("BaseLayer#setProgress.mask");
+      }
       for (int i = 0; i < mask.getMaskAnimations().size(); i++) {
         mask.getMaskAnimations().get(i).setProgress(progress);
       }
-      L.endSection("BaseLayer#setProgress.mask");
+      if (L.isTraceEnabled()) {
+        L.endSection("BaseLayer#setProgress.mask");
+      }
     }
     if (inOutAnimation != null) {
-      L.beginSection("BaseLayer#setProgress.inout");
+      if (L.isTraceEnabled()) {
+        L.beginSection("BaseLayer#setProgress.inout");
+      }
       inOutAnimation.setProgress(progress);
-      L.endSection("BaseLayer#setProgress.inout");
+      if (L.isTraceEnabled()) {
+        L.endSection("BaseLayer#setProgress.inout");
+      }
     }
     if (matteLayer != null) {
-      L.beginSection("BaseLayer#setProgress.matte");
+      if (L.isTraceEnabled()) {
+        L.beginSection("BaseLayer#setProgress.matte");
+      }
       matteLayer.setProgress(progress);
-      L.endSection("BaseLayer#setProgress.matte");
+      if (L.isTraceEnabled()) {
+        L.endSection("BaseLayer#setProgress.matte");
+      }
+    }
+    if (L.isTraceEnabled()) {
+      L.beginSection("BaseLayer#setProgress.animations." + animations.size());
     }
-    L.beginSection("BaseLayer#setProgress.animations." + animations.size());
     for (int i = 0; i < animations.size(); i++) {
       animations.get(i).setProgress(progress);
     }
-    L.endSection("BaseLayer#setProgress.animations." + animations.size());
-    L.endSection("BaseLayer#setProgress");
+    if (L.isTraceEnabled()) {
+      L.endSection("BaseLayer#setProgress.animations." + animations.size());
+      L.endSection("BaseLayer#setProgress");
+    }
   }
 
   private void buildParentLayerListIfNeeded() {
diff --git a/lottie/src/main/java/com/airbnb/lottie/model/layer/CompositionLayer.java b/lottie/src/main/java/com/airbnb/lottie/model/layer/CompositionLayer.java
index 7c923a65..92745ab7 100644
--- a/lottie/src/main/java/com/airbnb/lottie/model/layer/CompositionLayer.java
+++ b/lottie/src/main/java/com/airbnb/lottie/model/layer/CompositionLayer.java
@@ -104,7 +104,9 @@ public class CompositionLayer extends BaseLayer {
   }
 
   @Override void drawLayer(Canvas canvas, Matrix parentMatrix, int parentAlpha) {
-    L.beginSection("CompositionLayer#draw");
+    if (L.isTraceEnabled()) {
+      L.beginSection("CompositionLayer#draw");
+    }
     newClipRect.set(0, 0, layerModel.getPreCompWidth(), layerModel.getPreCompHeight());
     parentMatrix.mapRect(newClipRect);
 
@@ -131,7 +133,9 @@ public class CompositionLayer extends BaseLayer {
       }
     }
     canvas.restore();
-    L.endSection("CompositionLayer#draw");
+    if (L.isTraceEnabled()) {
+      L.endSection("CompositionLayer#draw");
+    }
   }
 
   @Override public void getBounds(RectF outBounds, Matrix parentMatrix, boolean applyParents) {
@@ -144,7 +148,9 @@ public class CompositionLayer extends BaseLayer {
   }
 
   @Override public void setProgress(@FloatRange(from = 0f, to = 1f) float progress) {
-    L.beginSection("CompositionLayer#setProgress");
+    if (L.isTraceEnabled()) {
+      L.beginSection("CompositionLayer#setProgress");
+    }
     this.progress = progress;
     super.setProgress(progress);
     if (timeRemapping != null) {
@@ -166,7 +172,9 @@ public class CompositionLayer extends BaseLayer {
     for (int i = layers.size() - 1; i >= 0; i--) {
       layers.get(i).setProgress(progress);
     }
-    L.endSection("CompositionLayer#setProgress");
+    if (L.isTraceEnabled()) {
+      L.endSection("CompositionLayer#setProgress");
+    }
   }
 
   public float getProgress() {
diff --git a/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java b/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java
index aa953a33..a5fff5a6 100644
--- a/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java
+++ b/lottie/src/main/java/com/airbnb/lottie/utils/LottieValueAnimator.java
@@ -90,7 +90,9 @@ public class LottieValueAnimator extends BaseLottieAnimator implements Choreogra
       return;
     }
 
-    L.beginSection("LottieValueAnimator#doFrame");
+    if (L.isTraceEnabled()) {
+      L.beginSection("LottieValueAnimator#doFrame");
+    }
     long timeSinceFrame = lastFrameTimeNs == 0 ? 0 : frameTimeNanos - lastFrameTimeNs;
     float frameDuration = getFrameDurationNs();
     float dFrames = timeSinceFrame / frameDuration;
@@ -127,7 +129,9 @@ public class LottieValueAnimator extends BaseLottieAnimator implements Choreogra
     }
 
     verifyFrame();
-    L.endSection("LottieValueAnimator#doFrame");
+    if (L.isTraceEnabled()) {
+      L.endSection("LottieValueAnimator#doFrame");
+    }
   }
 
   private float getFrameDurationNs() {
diff --git a/lottie/src/main/java/com/airbnb/lottie/utils/Utils.java b/lottie/src/main/java/com/airbnb/lottie/utils/Utils.java
index dc07d4bc..efa9dd87 100644
--- a/lottie/src/main/java/com/airbnb/lottie/utils/Utils.java
+++ b/lottie/src/main/java/com/airbnb/lottie/utils/Utils.java
@@ -136,7 +136,9 @@ public final class Utils {
 
   public static void applyTrimPathIfNeeded(
       Path path, float startValue, float endValue, float offsetValue) {
-    L.beginSection("applyTrimPathIfNeeded");
+    if (L.isTraceEnabled()) {
+      L.beginSection("applyTrimPathIfNeeded");
+    }
     final PathMeasure pathMeasure = threadLocalPathMeasure.get();
     final Path tempPath = threadLocalTempPath.get();
     final Path tempPath2 = threadLocalTempPath2.get();
@@ -145,11 +147,15 @@ public final class Utils {
 
     float length = pathMeasure.getLength();
     if (startValue == 1f && endValue == 0f) {
-      L.endSection("applyTrimPathIfNeeded");
+      if (L.isTraceEnabled()) {
+        L.endSection("applyTrimPathIfNeeded");
+      }
       return;
     }
     if (length < 1f || Math.abs(endValue - startValue - 1) < .01) {
-      L.endSection("applyTrimPathIfNeeded");
+      if (L.isTraceEnabled()) {
+        L.endSection("applyTrimPathIfNeeded");
+      }
       return;
     }
     float start = length * startValue;
@@ -177,7 +183,9 @@ public final class Utils {
     // If the start and end are equals, return an empty path.
     if (newStart == newEnd) {
       path.reset();
-      L.endSection("applyTrimPathIfNeeded");
+      if (L.isTraceEnabled()) {
+        L.endSection("applyTrimPathIfNeeded");
+      }
       return;
     }
 
@@ -210,7 +218,9 @@ public final class Utils {
       tempPath.addPath(tempPath2);
     }
     path.set(tempPath);
-    L.endSection("applyTrimPathIfNeeded");
+    if (L.isTraceEnabled()) {
+      L.endSection("applyTrimPathIfNeeded");
+    }
   }
 
   @SuppressWarnings("SameParameterValue")
@@ -291,7 +301,9 @@ public final class Utils {
   }
 
   public static void saveLayerCompat(Canvas canvas, RectF rect, Paint paint, int flag) {
-    L.beginSection("Utils#saveLayer");
+    if (L.isTraceEnabled()) {
+      L.beginSection("Utils#saveLayer");
+    }
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
       // This method was deprecated in API level 26 and not recommended since 22, but its
       // 2-parameter replacement is only available starting at API level 21.
@@ -299,7 +311,9 @@ public final class Utils {
     } else {
       canvas.saveLayer(rect, paint);
     }
-    L.endSection("Utils#saveLayer");
+    if (L.isTraceEnabled()) {
+      L.endSection("Utils#saveLayer");
+    }
   }
 
   /**
