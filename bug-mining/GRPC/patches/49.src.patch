diff --git a/src/python/grpcio/grpc/_cython/_cygrpc/aio/common.pyx.pxi b/src/python/grpcio/grpc/_cython/_cygrpc/aio/common.pyx.pxi
index 0e3e8de00b..c3e31fb15b 100644
--- a/src/python/grpcio/grpc/_cython/_cygrpc/aio/common.pyx.pxi
+++ b/src/python/grpcio/grpc/_cython/_cygrpc/aio/common.pyx.pxi
@@ -13,8 +13,9 @@
 # limitations under the License.
 
 import warnings
+import threading
 
-from cpython.version cimport PY_MAJOR_VERSION, PY_MINOR_VERSION
+from cpython.version cimport PY_MINOR_VERSION
 
 TYPE_METADATA_STRING = "Tuple[Tuple[str, Union[str, bytes]]...]"
 
@@ -173,29 +174,89 @@ async def generator_to_async_generator(object gen, object loop, object thread_po
     await future
 
 
-if PY_MAJOR_VERSION >= 3 and PY_MINOR_VERSION >= 7:
-    def get_working_loop():
-        """Returns a running event loop.
-
-        Due to a defect of asyncio.get_event_loop, its returned event loop might
-        not be set as the default event loop for the main thread.
-        """
+def _loop_policy_try_to_get_default_loop(policy):
+    # TODO(#39518): migrate to asyncio.get_event_loop().
+    with warnings.catch_warnings():
+        # Convert DeprecationWarning to errors so we can capture them with except
         try:
-            return asyncio.get_running_loop()
+            warnings.simplefilter("error", DeprecationWarning)
+            loop = policy.get_event_loop()
+            _LOGGER.debug(f"[_cygrpc] Loaded policy loop: {id(loop)=}")
+            return loop
+        except DeprecationWarning:
+            # Since version 3.12, DeprecationWarning is emitted if there is no
+            # current event loop.
+            return None
         except RuntimeError:
-            with warnings.catch_warnings():
-                # Convert DeprecationWarning to errors so we can capture them with except
-                warnings.simplefilter("error", DeprecationWarning)
-                try:
-                    return asyncio.get_event_loop_policy().get_event_loop()
-                # Since version 3.12, DeprecationWarning is emitted if there is no
-                # current event loop.
-                except DeprecationWarning:
-                    return asyncio.get_event_loop_policy().new_event_loop()
-else:
-    def get_working_loop():
-        """Returns a running event loop."""
-        return asyncio.get_event_loop()
+            # TODO(#40748): fix behavior in non-main threads.
+
+            # In non-main threads, BaseDefaultEventLoopPolicy always throws
+            # when there's no loop set. We'll preserve this behavior for now.
+            if PY_MINOR_VERSION < 14:
+                raise
+
+            # Python 3.14+ throws even in the main loop. We'll keep the behavior
+            # for non-main threads, but create a new loop for the main.
+            if threading.current_thread() is not threading.main_thread():
+                raise
+
+            _LOGGER.debug(
+                f"[_cygrpc] Python 3.14+ loop in main thread custom behavior"
+            )
+            return None
+
+
+def _loop_policy_create_new_loop(policy):
+    # TODO(#39518): migrate to asyncio.new_event_loop().
+    with warnings.catch_warnings():
+        warnings.simplefilter("ignore", DeprecationWarning)
+        loop = policy.new_event_loop()
+        _LOGGER.debug(f"[_cygrpc] Created policy loop: {id(loop)=}")
+        # TODO(#40748): set the new loop via asyncio.set_event_loop().
+        return loop
+
+
+def _get_event_loop_policy():
+    # TODO(#39518): migrate off of policies, issue deprecations from our side.
+    with warnings.catch_warnings():
+        warnings.simplefilter("ignore", DeprecationWarning)
+        return asyncio.get_event_loop_policy()
+
+
+def _get_or_create_default_loop():
+    # TODO(#39518): migrate off of policies before 3.16.
+    policy = _get_event_loop_policy()
+    if not policy:
+        raise RuntimeError("Couldn't load asyncio.get_event_loop_policy()")
+
+    default_policy_loop = _loop_policy_try_to_get_default_loop(policy)
+    if default_policy_loop is not None:
+        return default_policy_loop
+
+    # TODO(#40748): issue deprecation when the loop is not running.
+    return _loop_policy_create_new_loop(policy)
+
+
+def _get_running_loop():
+    try:
+        loop = asyncio.get_running_loop()
+        _LOGGER.debug(f"[_cygrpc] Loaded running loop: {id(loop)=}")
+        return loop
+    except RuntimeError:
+        return None
+
+
+def get_working_loop():
+    """Returns a running event loop.
+
+    Due to a defect of asyncio.get_event_loop, its returned event loop might
+    not be set as the default event loop for the main thread.
+    """
+    running_loop = _get_running_loop()
+    if running_loop:
+        return running_loop
+
+    return _get_or_create_default_loop()
 
 
 def raise_if_not_valid_trailing_metadata(object metadata):
diff --git a/src/python/grpcio_tests/tests_aio/unit/_common.py b/src/python/grpcio_tests/tests_aio/unit/_common.py
index af6b3c5543..87c3afb873 100644
--- a/src/python/grpcio_tests/tests_aio/unit/_common.py
+++ b/src/python/grpcio_tests/tests_aio/unit/_common.py
@@ -13,6 +13,7 @@
 # limitations under the License.
 
 import asyncio
+import logging
 from typing import AsyncIterable, Union
 
 import grpc
@@ -27,6 +28,18 @@ from tests.unit.framework.common import test_constants
 ADHOC_METHOD = "/test/AdHoc"
 
 
+def setup_absl_like_logging(level=logging.DEBUG):
+    logging.basicConfig(
+        level=level,
+        style="{",
+        format=(
+            "{levelname[0]}{asctime}.{msecs:03.0f} {thread} "
+            "{filename}:{lineno}] {message}"
+        ),
+        datefmt="%m%d %H:%M:%S",
+    )
+
+
 def seen_metadata(expected: Metadata, actual: Metadata):
     return not bool(set(tuple(expected)) - set(tuple(actual)))
 
diff --git a/src/python/grpcio_tests/tests_aio/unit/init_test.py b/src/python/grpcio_tests/tests_aio/unit/init_test.py
index f7de4c6677..31468c22dd 100644
--- a/src/python/grpcio_tests/tests_aio/unit/init_test.py
+++ b/src/python/grpcio_tests/tests_aio/unit/init_test.py
@@ -12,28 +12,34 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 import logging
-import sys
 import unittest
 
+from typing_extensions import override
+
+from tests_aio.unit import _common
+
 
-@unittest.skipIf(
-    sys.version_info >= (3, 14),
-    "Skip for Python 3.14+ until https://github.com/grpc/grpc/pull/40293 is merged",
-)
 class TestInit(unittest.TestCase):
+    @classmethod
+    @override
+    def setUpClass(cls):
+        # Logging config in setUpClass compatible with bazel-based runner.
+        _common.setup_absl_like_logging()
+
     def test_grpc(self):
         import grpc  # pylint: disable=wrong-import-position
 
         channel = grpc.aio.insecure_channel("phony")
+        logging.info(f"Created grpc Channel<{id(channel._loop)=}>")
         self.assertIsInstance(channel, grpc.aio.Channel)
 
     def test_grpc_dot_aio(self):
         import grpc.aio  # pylint: disable=wrong-import-position
 
         channel = grpc.aio.insecure_channel("phony")
+        logging.info(f"Created grpc.aio Channel<{id(channel._loop)=}>")
         self.assertIsInstance(channel, grpc.aio.Channel)
 
 
 if __name__ == "__main__":
-    logging.basicConfig(level=logging.DEBUG)
     unittest.main(verbosity=2)
diff --git a/src/python/grpcio_tests/tests_aio/unit/outside_init_test.py b/src/python/grpcio_tests/tests_aio/unit/outside_init_test.py
index 27df76c620..cdafafa1e4 100644
--- a/src/python/grpcio_tests/tests_aio/unit/outside_init_test.py
+++ b/src/python/grpcio_tests/tests_aio/unit/outside_init_test.py
@@ -20,19 +20,23 @@ import unittest
 
 import grpc
 from grpc.experimental import aio
+from typing_extensions import override
 
 from src.proto.grpc.testing import messages_pb2
 from src.proto.grpc.testing import test_pb2_grpc
+from tests_aio.unit import _common
 from tests_aio.unit._test_server import start_test_server
 
 _NUM_OF_LOOPS = 50
 
 
-@unittest.skipIf(
-    sys.version_info >= (3, 14),
-    "Skip for Python 3.14+ until https://github.com/grpc/grpc/pull/40293 is merged",
-)
 class TestOutsideInit(unittest.TestCase):
+    @classmethod
+    @override
+    def setUpClass(cls):
+        # Logging config in setUpClass compatible with bazel-based runner.
+        _common.setup_absl_like_logging()
+
     def test_behavior_outside_asyncio(self):
         # Ensures non-AsyncIO object can be initiated
         channel_creds = grpc.ssl_channel_credentials()
@@ -55,6 +59,8 @@ class TestOutsideInit(unittest.TestCase):
         async def ping_pong():
             address, server = await start_test_server()
             channel = aio.insecure_channel(address)
+            logging.info(f"Channel loop: {id(channel._loop)=}")
+
             stub = test_pb2_grpc.TestServiceStub(channel)
 
             await stub.UnaryCall(messages_pb2.SimpleRequest())
@@ -63,10 +69,17 @@ class TestOutsideInit(unittest.TestCase):
             await server.stop(None)
 
         for i in range(_NUM_OF_LOOPS):
-            old_loop = asyncio.get_event_loop()
-            old_loop.close()
+            # In python 3.14+, the first time we attempt getting the old loop,
+            # it won't exist: get_event_loop() now raises error when there's
+            # no running loop.
+            # TODO(sergiitk): revisit after getting rid of the loop policies.
+            if sys.version_info < (3, 14) or i > 0:
+                old_loop = asyncio.get_event_loop()
+                logging.info(f"Closing old loop: {id(old_loop)}")
+                old_loop.close()
 
             loop = asyncio.new_event_loop()
+            logging.info(f"Created new loop: {id(loop)}")
             loop.set_debug(True)
             asyncio.set_event_loop(loop)
 
@@ -76,5 +89,4 @@ class TestOutsideInit(unittest.TestCase):
 
 
 if __name__ == "__main__":
-    logging.basicConfig(level=logging.DEBUG)
     unittest.main(verbosity=2)
diff --git a/tools/run_tests/run_tests.py b/tools/run_tests/run_tests.py
index 3b852a8ffa..9144b7ba03 100755
--- a/tools/run_tests/run_tests.py
+++ b/tools/run_tests/run_tests.py
@@ -876,6 +876,7 @@ class PythonLanguage(object):
                 # Default set tested on master. Test oldest and newest.
                 return (
                     python39_config,
+                    python312_config,
                     python314_config,
                 )
         elif args.compiler == "python3.9":
