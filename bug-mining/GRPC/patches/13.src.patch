diff --git a/src/python/grpcio/grpc/__init__.py b/src/python/grpcio/grpc/__init__.py
index afbf861619..9f07579ab8 100644
--- a/src/python/grpcio/grpc/__init__.py
+++ b/src/python/grpcio/grpc/__init__.py
@@ -1390,6 +1390,13 @@ class ServerInterceptor(abc.ABC):
     def intercept_service(self, continuation, handler_call_details):
         """Intercepts incoming RPCs before handing them over to a handler.
 
+        State can be passed from an interceptor to downstream interceptors
+        via contextvars. The first interceptor is called from an empty
+        contextvars.Context, and the same Context is used for downstream
+        interceptors and for the final handler call. Note that there are no
+        guarantees that interceptors and handlers will be called from the
+        same thread.
+
         Args:
           continuation: A function that takes a HandlerCallDetails and
             proceeds to invoke the next interceptor in the chain, if any,
diff --git a/src/python/grpcio/grpc/_server.py b/src/python/grpcio/grpc/_server.py
index 425aff8c95..595056136b 100644
--- a/src/python/grpcio/grpc/_server.py
+++ b/src/python/grpcio/grpc/_server.py
@@ -17,6 +17,7 @@ from __future__ import annotations
 
 import collections
 from concurrent import futures
+import contextvars
 import enum
 import logging
 import threading
@@ -121,6 +122,7 @@ class _HandlerCallDetails(
 
 
 class _RPCState(object):
+    context: contextvars.Context
     condition: threading.Condition
     due = Set[str]
     request: Any
@@ -137,6 +139,7 @@ class _RPCState(object):
     aborted: bool
 
     def __init__(self):
+        self.context = contextvars.Context()
         self.condition = threading.Condition()
         self.due = set()
         self.request = None
@@ -843,6 +846,7 @@ def _handle_unary_unary(
         method_handler.unary_unary, default_thread_pool
     )
     return thread_pool.submit(
+        state.context.run,
         _unary_response_in_pool,
         rpc_event,
         state,
@@ -866,6 +870,7 @@ def _handle_unary_stream(
         method_handler.unary_stream, default_thread_pool
     )
     return thread_pool.submit(
+        state.context.run,
         _stream_response_in_pool,
         rpc_event,
         state,
@@ -889,6 +894,7 @@ def _handle_stream_unary(
         method_handler.stream_unary, default_thread_pool
     )
     return thread_pool.submit(
+        state.context.run,
         _unary_response_in_pool,
         rpc_event,
         state,
@@ -912,6 +918,7 @@ def _handle_stream_stream(
         method_handler.stream_stream, default_thread_pool
     )
     return thread_pool.submit(
+        state.context.run,
         _stream_response_in_pool,
         rpc_event,
         state,
@@ -924,6 +931,7 @@ def _handle_stream_stream(
 
 def _find_method_handler(
     rpc_event: cygrpc.BaseEvent,
+    state: _RPCState,
     generic_handlers: List[grpc.GenericRpcHandler],
     interceptor_pipeline: Optional[_interceptor._ServicePipeline],
 ) -> Optional[grpc.RpcMethodHandler]:
@@ -942,17 +950,19 @@ def _find_method_handler(
     )
 
     if interceptor_pipeline is not None:
-        return interceptor_pipeline.execute(
-            query_handlers, handler_call_details
+        return state.context.run(
+            interceptor_pipeline.execute, query_handlers, handler_call_details
         )
     else:
-        return query_handlers(handler_call_details)
+        return state.context.run(query_handlers, handler_call_details)
 
 
 def _reject_rpc(
-    rpc_event: cygrpc.BaseEvent, status: cygrpc.StatusCode, details: bytes
-) -> _RPCState:
-    rpc_state = _RPCState()
+    rpc_event: cygrpc.BaseEvent,
+    rpc_state: _RPCState,
+    status: cygrpc.StatusCode,
+    details: bytes,
+):
     operations = (
         _get_initial_metadata_operation(rpc_state, None),
         cygrpc.ReceiveCloseOnServerOperation(_EMPTY_FLAGS),
@@ -967,15 +977,14 @@ def _reject_rpc(
             (),
         ),
     )
-    return rpc_state
 
 
 def _handle_with_method_handler(
     rpc_event: cygrpc.BaseEvent,
+    state: _RPCState,
     method_handler: grpc.RpcMethodHandler,
     thread_pool: futures.ThreadPoolExecutor,
-) -> Tuple[_RPCState, futures.Future]:
-    state = _RPCState()
+) -> futures.Future:
     with state.condition:
         rpc_event.call.start_server_batch(
             (cygrpc.ReceiveCloseOnServerOperation(_EMPTY_FLAGS),),
@@ -984,20 +993,20 @@ def _handle_with_method_handler(
         state.due.add(_RECEIVE_CLOSE_ON_SERVER_TOKEN)
         if method_handler.request_streaming:
             if method_handler.response_streaming:
-                return state, _handle_stream_stream(
+                return _handle_stream_stream(
                     rpc_event, state, method_handler, thread_pool
                 )
             else:
-                return state, _handle_stream_unary(
+                return _handle_stream_unary(
                     rpc_event, state, method_handler, thread_pool
                 )
         else:
             if method_handler.response_streaming:
-                return state, _handle_unary_stream(
+                return _handle_unary_stream(
                     rpc_event, state, method_handler, thread_pool
                 )
             else:
-                return state, _handle_unary_unary(
+                return _handle_unary_unary(
                     rpc_event, state, method_handler, thread_pool
                 )
 
@@ -1012,42 +1021,43 @@ def _handle_call(
     if not rpc_event.success:
         return None, None
     if rpc_event.call_details.method is not None:
+        rpc_state = _RPCState()
         try:
             method_handler = _find_method_handler(
-                rpc_event, generic_handlers, interceptor_pipeline
+                rpc_event, rpc_state, generic_handlers, interceptor_pipeline
             )
         except Exception as exception:  # pylint: disable=broad-except
             details = "Exception servicing handler: {}".format(exception)
             _LOGGER.exception(details)
-            return (
-                _reject_rpc(
-                    rpc_event,
-                    cygrpc.StatusCode.unknown,
-                    b"Error in service handler!",
-                ),
-                None,
+            _reject_rpc(
+                rpc_event,
+                rpc_state,
+                cygrpc.StatusCode.unknown,
+                b"Error in service handler!",
             )
+            return rpc_state, None
         if method_handler is None:
-            return (
-                _reject_rpc(
-                    rpc_event,
-                    cygrpc.StatusCode.unimplemented,
-                    b"Method not found!",
-                ),
-                None,
+            _reject_rpc(
+                rpc_event,
+                rpc_state,
+                cygrpc.StatusCode.unimplemented,
+                b"Method not found!",
             )
+            return rpc_state, None
         elif concurrency_exceeded:
-            return (
-                _reject_rpc(
-                    rpc_event,
-                    cygrpc.StatusCode.resource_exhausted,
-                    b"Concurrent RPC limit exceeded!",
-                ),
-                None,
+            _reject_rpc(
+                rpc_event,
+                rpc_state,
+                cygrpc.StatusCode.resource_exhausted,
+                b"Concurrent RPC limit exceeded!",
             )
+            return rpc_state, None
         else:
-            return _handle_with_method_handler(
-                rpc_event, method_handler, thread_pool
+            return (
+                rpc_state,
+                _handle_with_method_handler(
+                    rpc_event, rpc_state, method_handler, thread_pool
+                ),
             )
     else:
         return None, None
diff --git a/src/python/grpcio/grpc/aio/_interceptor.py b/src/python/grpcio/grpc/aio/_interceptor.py
index dc750926df..38312b7955 100644
--- a/src/python/grpcio/grpc/aio/_interceptor.py
+++ b/src/python/grpcio/grpc/aio/_interceptor.py
@@ -69,6 +69,13 @@ class ServerInterceptor(metaclass=ABCMeta):
     ) -> grpc.RpcMethodHandler:
         """Intercepts incoming RPCs before handing them over to a handler.
 
+        State can be passed from an interceptor to downstream interceptors
+        via contextvars. The first interceptor is called from an empty
+        contextvars.Context, and the same Context is used for downstream
+        interceptors and for the final handler call. Note that there are no
+        guarantees that interceptors and handlers will be called from the
+        same thread.
+
         Args:
             continuation: A function that takes a HandlerCallDetails and
                 proceeds to invoke the next interceptor in the chain, if any,
diff --git a/src/python/grpcio_tests/tests/unit/_interceptor_test.py b/src/python/grpcio_tests/tests/unit/_interceptor_test.py
index 60119da4d7..9bbff1f6be 100644
--- a/src/python/grpcio_tests/tests/unit/_interceptor_test.py
+++ b/src/python/grpcio_tests/tests/unit/_interceptor_test.py
@@ -15,6 +15,7 @@
 
 import collections
 from concurrent import futures
+from contextvars import ContextVar
 import itertools
 import logging
 import os
@@ -40,6 +41,8 @@ _UNARY_STREAM = "/test/UnaryStream"
 _STREAM_UNARY = "/test/StreamUnary"
 _STREAM_STREAM = "/test/StreamStream"
 
+_TEST_CONTEXT_VAR: ContextVar[str] = ContextVar("")
+
 
 class _ApplicationErrorStandin(Exception):
     pass
@@ -65,10 +68,18 @@ class _Callback(object):
 
 
 class _Handler(object):
-    def __init__(self, control):
+    def __init__(self, control, record):
         self._control = control
+        self._record = record
+
+    def _append_to_log(self, message: str) -> None:
+        context_var_value = _TEST_CONTEXT_VAR.get("")
+        if context_var_value:
+            context_var_value = "[{}]".format(context_var_value)
+        self._record.append("handler:" + message + context_var_value)
 
     def handle_unary_unary(self, request, servicer_context):
+        self._append_to_log("handle_unary_unary")
         self._control.control()
         if servicer_context is not None:
             servicer_context.set_trailing_metadata(
@@ -84,6 +95,7 @@ class _Handler(object):
         return request
 
     def handle_unary_stream(self, request, servicer_context):
+        self._append_to_log("handle_unary_stream")
         if request == _EXCEPTION_REQUEST:
             raise _ApplicationErrorStandin()
         for _ in range(test_constants.STREAM_LENGTH):
@@ -101,6 +113,7 @@ class _Handler(object):
             )
 
     def handle_stream_unary(self, request_iterator, servicer_context):
+        self._append_to_log("handle_stream_unary")
         if servicer_context is not None:
             servicer_context.invocation_metadata()
         self._control.control()
@@ -123,6 +136,7 @@ class _Handler(object):
         return b"".join(response_elements)
 
     def handle_stream_stream(self, request_iterator, servicer_context):
+        self._append_to_log("handle_stream_stream")
         self._control.control()
         if servicer_context is not None:
             servicer_context.set_trailing_metadata(
@@ -293,6 +307,21 @@ class _GenericClientInterceptor(
         return postprocess(response_it) if postprocess else response_it
 
 
+class _ContextVarSettingInterceptor(grpc.ServerInterceptor):
+    def __init__(self, value: str) -> None:
+        self.value = value
+
+    def intercept_service(self, continuation, handler_call_details):
+        old_value = _TEST_CONTEXT_VAR.get("")
+        assert (
+            not old_value
+        ), "expected context var to have no value but was '{}'".format(
+            old_value
+        )
+        _TEST_CONTEXT_VAR.set(self.value)
+        return continuation(handler_call_details)
+
+
 class _LoggingInterceptor(
     grpc.ServerInterceptor,
     grpc.UnaryUnaryClientInterceptor,
@@ -304,12 +333,18 @@ class _LoggingInterceptor(
         self.tag = tag
         self.record = record
 
+    def _append_to_log(self, message: str) -> None:
+        context_var_value = _TEST_CONTEXT_VAR.get("")
+        if context_var_value:
+            context_var_value = "[{}]".format(context_var_value)
+        self.record.append(self.tag + message + context_var_value)
+
     def intercept_service(self, continuation, handler_call_details):
-        self.record.append(self.tag + ":intercept_service")
+        self._append_to_log(":intercept_service")
         return continuation(handler_call_details)
 
     def intercept_unary_unary(self, continuation, client_call_details, request):
-        self.record.append(self.tag + ":intercept_unary_unary")
+        self._append_to_log(":intercept_unary_unary")
         result = continuation(client_call_details, request)
         assert isinstance(
             result, grpc.Call
@@ -326,13 +361,13 @@ class _LoggingInterceptor(
     def intercept_unary_stream(
         self, continuation, client_call_details, request
     ):
-        self.record.append(self.tag + ":intercept_unary_stream")
+        self._append_to_log(":intercept_unary_stream")
         return continuation(client_call_details, request)
 
     def intercept_stream_unary(
         self, continuation, client_call_details, request_iterator
     ):
-        self.record.append(self.tag + ":intercept_stream_unary")
+        self._append_to_log(":intercept_stream_unary")
         result = continuation(client_call_details, request_iterator)
         assert isinstance(
             result, grpc.Call
@@ -345,7 +380,7 @@ class _LoggingInterceptor(
     def intercept_stream_stream(
         self, continuation, client_call_details, request_iterator
     ):
-        self.record.append(self.tag + ":intercept_stream_stream")
+        self._append_to_log(":intercept_stream_stream")
         return continuation(client_call_details, request_iterator)
 
 
@@ -420,10 +455,10 @@ def _filter_server_interceptor(condition, interceptor):
 class InterceptorTest(unittest.TestCase):
     def setUp(self):
         self._control = test_control.PauseFailControl()
-        self._handler = _Handler(self._control)
+        self._record = []
+        self._handler = _Handler(self._control, self._record)
         self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)
 
-        self._record = []
         conditional_interceptor = _filter_server_interceptor(
             lambda x: ("secret", "42") in x.invocation_metadata,
             _LoggingInterceptor("s3", self._record),
@@ -435,6 +470,7 @@ class InterceptorTest(unittest.TestCase):
             interceptors=(
                 _LoggingInterceptor("s1", self._record),
                 conditional_interceptor,
+                _ContextVarSettingInterceptor("context-var-value"),
                 _LoggingInterceptor("s2", self._record),
             ),
         )
@@ -543,7 +579,8 @@ class InterceptorTest(unittest.TestCase):
                 "c2:intercept_unary_unary",
                 "s1:intercept_service",
                 "s3:intercept_service",
-                "s2:intercept_service",
+                "s2:intercept_service[context-var-value]",
+                "handler:handle_unary_unary[context-var-value]",
             ],
         )
 
@@ -572,7 +609,8 @@ class InterceptorTest(unittest.TestCase):
                 "c1:intercept_unary_unary",
                 "c2:intercept_unary_unary",
                 "s1:intercept_service",
-                "s2:intercept_service",
+                "s2:intercept_service[context-var-value]",
+                "handler:handle_unary_unary[context-var-value]",
             ],
         )
 
@@ -631,7 +669,8 @@ class InterceptorTest(unittest.TestCase):
                 "c1:intercept_unary_unary",
                 "c2:intercept_unary_unary",
                 "s1:intercept_service",
-                "s2:intercept_service",
+                "s2:intercept_service[context-var-value]",
+                "handler:handle_unary_unary[context-var-value]",
             ],
         )
 
@@ -658,7 +697,8 @@ class InterceptorTest(unittest.TestCase):
                 "c1:intercept_unary_unary",
                 "c2:intercept_unary_unary",
                 "s1:intercept_service",
-                "s2:intercept_service",
+                "s2:intercept_service[context-var-value]",
+                "handler:handle_unary_unary[context-var-value]",
             ],
         )
 
@@ -685,7 +725,8 @@ class InterceptorTest(unittest.TestCase):
                 "c1:intercept_unary_stream",
                 "c2:intercept_unary_stream",
                 "s1:intercept_service",
-                "s2:intercept_service",
+                "s2:intercept_service[context-var-value]",
+                "handler:handle_unary_stream[context-var-value]",
             ],
         )
 
@@ -741,7 +782,8 @@ class InterceptorTest(unittest.TestCase):
                 "c1:intercept_stream_unary",
                 "c2:intercept_stream_unary",
                 "s1:intercept_service",
-                "s2:intercept_service",
+                "s2:intercept_service[context-var-value]",
+                "handler:handle_stream_unary[context-var-value]",
             ],
         )
 
@@ -775,7 +817,8 @@ class InterceptorTest(unittest.TestCase):
                 "c1:intercept_stream_unary",
                 "c2:intercept_stream_unary",
                 "s1:intercept_service",
-                "s2:intercept_service",
+                "s2:intercept_service[context-var-value]",
+                "handler:handle_stream_unary[context-var-value]",
             ],
         )
 
@@ -805,7 +848,8 @@ class InterceptorTest(unittest.TestCase):
                 "c1:intercept_stream_unary",
                 "c2:intercept_stream_unary",
                 "s1:intercept_service",
-                "s2:intercept_service",
+                "s2:intercept_service[context-var-value]",
+                "handler:handle_stream_unary[context-var-value]",
             ],
         )
 
@@ -863,7 +907,8 @@ class InterceptorTest(unittest.TestCase):
                 "c1:intercept_stream_stream",
                 "c2:intercept_stream_stream",
                 "s1:intercept_service",
-                "s2:intercept_service",
+                "s2:intercept_service[context-var-value]",
+                "handler:handle_stream_stream[context-var-value]",
             ],
         )
 
diff --git a/src/python/grpcio_tests/tests_aio/unit/_test_server.py b/src/python/grpcio_tests/tests_aio/unit/_test_server.py
index bcc29cd2a6..5d25272f30 100644
--- a/src/python/grpcio_tests/tests_aio/unit/_test_server.py
+++ b/src/python/grpcio_tests/tests_aio/unit/_test_server.py
@@ -13,7 +13,9 @@
 # limitations under the License.
 
 import asyncio
+from contextvars import ContextVar
 import datetime
+from typing import Optional
 
 import grpc
 from grpc.experimental import aio
@@ -27,6 +29,8 @@ from tests_aio.unit import _constants
 _INITIAL_METADATA_KEY = "x-grpc-test-echo-initial"
 _TRAILING_METADATA_KEY = "x-grpc-test-echo-trailing-bin"
 
+TEST_CONTEXT_VAR: ContextVar[str] = ContextVar("")
+
 
 async def _maybe_echo_metadata(servicer_context):
     """Copies metadata from request to response if it is present."""
@@ -56,7 +60,14 @@ async def _maybe_echo_status(
 
 
 class TestServiceServicer(test_pb2_grpc.TestServiceServicer):
+    def __init__(self, record: Optional[list] = None):
+        self.record = record if record is not None else []
+
+    def _append_to_log(self):
+        self.record.append("servicer:" + TEST_CONTEXT_VAR.get("service"))
+
     async def UnaryCall(self, request, context):
+        self._append_to_log()
         await _maybe_echo_metadata(context)
         await _maybe_echo_status(request, context)
         return messages_pb2.SimpleResponse(
@@ -67,11 +78,13 @@ class TestServiceServicer(test_pb2_grpc.TestServiceServicer):
         )
 
     async def EmptyCall(self, request, context):
+        self._append_to_log()
         return empty_pb2.Empty()
 
     async def StreamingOutputCall(
         self, request: messages_pb2.StreamingOutputCallRequest, unused_context
     ):
+        self._append_to_log()
         for response_parameters in request.response_parameters:
             if response_parameters.interval_us != 0:
                 await asyncio.sleep(
@@ -93,10 +106,12 @@ class TestServiceServicer(test_pb2_grpc.TestServiceServicer):
     # when the sever is instantiated. They are not being provided by
     # the proto file.
     async def UnaryCallWithSleep(self, unused_request, unused_context):
+        self._append_to_log()
         await asyncio.sleep(_constants.UNARY_CALL_WITH_SLEEP_VALUE)
         return messages_pb2.SimpleResponse()
 
     async def StreamingInputCall(self, request_async_iterator, unused_context):
+        self._append_to_log()
         aggregate_size = 0
         async for request in request_async_iterator:
             if request.payload is not None and request.payload.body:
@@ -106,6 +121,7 @@ class TestServiceServicer(test_pb2_grpc.TestServiceServicer):
         )
 
     async def FullDuplexCall(self, request_async_iterator, context):
+        self._append_to_log()
         await _maybe_echo_metadata(context)
         async for request in request_async_iterator:
             await _maybe_echo_status(request, context)
@@ -143,12 +159,16 @@ def _create_extra_generic_handler(servicer: TestServiceServicer):
 
 
 async def start_test_server(
-    port=0, secure=False, server_credentials=None, interceptors=None
+    port=0,
+    secure=False,
+    server_credentials=None,
+    interceptors=None,
+    record: Optional[list] = None,
 ):
     server = aio.server(
         options=(("grpc.so_reuseport", 0),), interceptors=interceptors
     )
-    servicer = TestServiceServicer()
+    servicer = TestServiceServicer(record)
     test_pb2_grpc.add_TestServiceServicer_to_server(servicer, server)
 
     server.add_generic_rpc_handlers((_create_extra_generic_handler(servicer),))
diff --git a/src/python/grpcio_tests/tests_aio/unit/server_interceptor_test.py b/src/python/grpcio_tests/tests_aio/unit/server_interceptor_test.py
index 1975403e3a..15f504759a 100644
--- a/src/python/grpcio_tests/tests_aio/unit/server_interceptor_test.py
+++ b/src/python/grpcio_tests/tests_aio/unit/server_interceptor_test.py
@@ -26,6 +26,7 @@ from grpc.experimental import wrap_server_method_handler
 from src.proto.grpc.testing import messages_pb2
 from src.proto.grpc.testing import test_pb2_grpc
 from tests_aio.unit._test_base import AioTestBase
+from tests_aio.unit._test_server import TEST_CONTEXT_VAR
 from tests_aio.unit._test_server import start_test_server
 
 _NUM_STREAM_RESPONSES = 5
@@ -45,7 +46,28 @@ class _LoggingInterceptor(aio.ServerInterceptor):
         ],
         handler_call_details: grpc.HandlerCallDetails,
     ) -> grpc.RpcMethodHandler:
-        self.record.append(self.tag + ":intercept_service")
+        self.record.append(
+            self.tag + ":" + TEST_CONTEXT_VAR.get("intercept_service")
+        )
+        return await continuation(handler_call_details)
+
+
+class _ContextVarSettingInterceptor(aio.ServerInterceptor):
+    def __init__(self, value: str) -> None:
+        self.value = value
+
+    async def intercept_service(
+        self,
+        continuation: Callable[
+            [grpc.HandlerCallDetails], Awaitable[grpc.RpcMethodHandler]
+        ],
+        handler_call_details: grpc.HandlerCallDetails,
+    ) -> grpc.RpcMethodHandler:
+        new_value = self.value
+        old_value = TEST_CONTEXT_VAR.get("")
+        if old_value:
+            new_value = old_value + ":" + new_value
+        TEST_CONTEXT_VAR.set(new_value)
         return await continuation(handler_call_details)
 
 
@@ -138,13 +160,15 @@ class _CacheInterceptor(aio.ServerInterceptor):
 
 
 async def _create_server_stub_pair(
-    *interceptors: aio.ServerInterceptor,
+    record: list, *interceptors: aio.ServerInterceptor
 ) -> Tuple[aio.Server, test_pb2_grpc.TestServiceStub]:
-    """Creates a server-stub pair with given interceptors.
+    """Creates a server-stub pair with given record and interceptors.
 
     Returning the server object to protect it from being garbage collected.
     """
-    server_target, server = await start_test_server(interceptors=interceptors)
+    server_target, server = await start_test_server(
+        interceptors=interceptors, record=record
+    )
     channel = aio.insecure_channel(server_target)
     return server, test_pb2_grpc.TestServiceStub(channel)
 
@@ -162,10 +186,12 @@ class TestServerInterceptor(AioTestBase):
     async def test_executed_right_order(self):
         record = []
         server_target, _ = await start_test_server(
+            record=record,
             interceptors=(
                 _LoggingInterceptor("log1", record),
+                _ContextVarSettingInterceptor("context_var_value"),
                 _LoggingInterceptor("log2", record),
-            )
+            ),
         )
 
         async with aio.insecure_channel(server_target) as channel:
@@ -177,17 +203,54 @@ class TestServerInterceptor(AioTestBase):
             call = multicallable(messages_pb2.SimpleRequest())
             response = await call
 
-            # Check that all interceptors were executed, and were executed
-            # in the right order.
+            # Check that all interceptors were executed--and were executed
+            # in the right order--before calling the servicer.
             self.assertSequenceEqual(
                 [
                     "log1:intercept_service",
-                    "log2:intercept_service",
+                    "log2:context_var_value",
+                    "servicer:context_var_value",
                 ],
                 record,
             )
             self.assertIsInstance(response, messages_pb2.SimpleResponse)
 
+    async def test_unique_context_per_call(self):
+        record = []
+        server, stub = await _create_server_stub_pair(
+            record,
+            _LoggingInterceptor("log1", record),
+            _ContextVarSettingInterceptor("context_var_value"),
+            _LoggingInterceptor("log2", record),
+        )
+
+        response = await stub.UnaryCall(
+            messages_pb2.SimpleRequest(response_size=42)
+        )
+
+        self.assertSequenceEqual(
+            [
+                "log1:intercept_service",
+                "log2:context_var_value",
+                "servicer:context_var_value",
+            ],
+            record,
+        )
+        record.clear()
+
+        response = await stub.UnaryCall(
+            messages_pb2.SimpleRequest(response_size=42)
+        )
+
+        self.assertSequenceEqual(
+            [
+                "log1:intercept_service",
+                "log2:context_var_value",
+                "servicer:context_var_value",
+            ],
+            record,
+        )
+
     async def test_response_ok(self):
         record = []
         server_target, _ = await start_test_server(
@@ -270,7 +333,7 @@ class TestServerInterceptor(AioTestBase):
         )
 
         # Constructs a server with the cache interceptor
-        server, stub = await _create_server_stub_pair(interceptor)
+        server, stub = await _create_server_stub_pair([], interceptor)
 
         # Tests if the cache store is used
         response = await stub.UnaryCall(
@@ -293,7 +356,9 @@ class TestServerInterceptor(AioTestBase):
     async def test_interceptor_unary_stream(self):
         record = []
         server, stub = await _create_server_stub_pair(
-            _LoggingInterceptor("log_unary_stream", record)
+            record,
+            _ContextVarSettingInterceptor("context_var_value"),
+            _LoggingInterceptor("log_unary_stream", record),
         )
 
         # Prepares the request
@@ -315,7 +380,8 @@ class TestServerInterceptor(AioTestBase):
 
         self.assertSequenceEqual(
             [
-                "log_unary_stream:intercept_service",
+                "log_unary_stream:context_var_value",
+                "servicer:context_var_value",
             ],
             record,
         )
@@ -323,7 +389,9 @@ class TestServerInterceptor(AioTestBase):
     async def test_interceptor_stream_unary(self):
         record = []
         server, stub = await _create_server_stub_pair(
-            _LoggingInterceptor("log_stream_unary", record)
+            record,
+            _ContextVarSettingInterceptor("context_var_value"),
+            _LoggingInterceptor("log_stream_unary", record),
         )
 
         # Invokes the actual RPC
@@ -350,7 +418,8 @@ class TestServerInterceptor(AioTestBase):
 
         self.assertSequenceEqual(
             [
-                "log_stream_unary:intercept_service",
+                "log_stream_unary:context_var_value",
+                "servicer:context_var_value",
             ],
             record,
         )
@@ -358,7 +427,9 @@ class TestServerInterceptor(AioTestBase):
     async def test_interceptor_stream_stream(self):
         record = []
         server, stub = await _create_server_stub_pair(
-            _LoggingInterceptor("log_stream_stream", record)
+            record,
+            _ContextVarSettingInterceptor("context_var_value"),
+            _LoggingInterceptor("log_stream_stream", record),
         )
 
         # Prepares the request
@@ -384,7 +455,8 @@ class TestServerInterceptor(AioTestBase):
 
         self.assertSequenceEqual(
             [
-                "log_stream_stream:intercept_service",
+                "log_stream_stream:context_var_value",
+                "servicer:context_var_value",
             ],
             record,
         )
