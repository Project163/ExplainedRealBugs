{"url":"https://api.github.com/repos/grpc/grpc/issues/40444","repository_url":"https://api.github.com/repos/grpc/grpc","labels_url":"https://api.github.com/repos/grpc/grpc/issues/40444/labels{/name}","comments_url":"https://api.github.com/repos/grpc/grpc/issues/40444/comments","events_url":"https://api.github.com/repos/grpc/grpc/issues/40444/events","html_url":"https://github.com/grpc/grpc/issues/40444","id":3322149084,"node_id":"I_kwDOAacf2M7GA_jc","number":40444,"title":"Python multiprocessing example doesn't achieve true parallelism","user":{"login":"LjubeBoskovski","id":26672556,"node_id":"MDQ6VXNlcjI2NjcyNTU2","avatar_url":"https://avatars.githubusercontent.com/u/26672556?v=4","gravatar_id":"","url":"https://api.github.com/users/LjubeBoskovski","html_url":"https://github.com/LjubeBoskovski","followers_url":"https://api.github.com/users/LjubeBoskovski/followers","following_url":"https://api.github.com/users/LjubeBoskovski/following{/other_user}","gists_url":"https://api.github.com/users/LjubeBoskovski/gists{/gist_id}","starred_url":"https://api.github.com/users/LjubeBoskovski/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LjubeBoskovski/subscriptions","organizations_url":"https://api.github.com/users/LjubeBoskovski/orgs","repos_url":"https://api.github.com/users/LjubeBoskovski/repos","events_url":"https://api.github.com/users/LjubeBoskovski/events{/privacy}","received_events_url":"https://api.github.com/users/LjubeBoskovski/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":155504842,"node_id":"MDU6TGFiZWwxNTU1MDQ4NDI=","url":"https://api.github.com/repos/grpc/grpc/labels/kind/bug","name":"kind/bug","color":"93732c","default":false,"description":null},{"id":168238186,"node_id":"MDU6TGFiZWwxNjgyMzgxODY=","url":"https://api.github.com/repos/grpc/grpc/labels/lang/Python","name":"lang/Python","color":"fad8c7","default":false,"description":null},{"id":360790193,"node_id":"MDU6TGFiZWwzNjA3OTAxOTM=","url":"https://api.github.com/repos/grpc/grpc/labels/priority/P2","name":"priority/P2","color":"dd7172","default":false,"description":""}],"state":"closed","locked":false,"assignee":{"login":"asheshvidyut","id":134911583,"node_id":"U_kgDOCAqWXw","avatar_url":"https://avatars.githubusercontent.com/u/134911583?v=4","gravatar_id":"","url":"https://api.github.com/users/asheshvidyut","html_url":"https://github.com/asheshvidyut","followers_url":"https://api.github.com/users/asheshvidyut/followers","following_url":"https://api.github.com/users/asheshvidyut/following{/other_user}","gists_url":"https://api.github.com/users/asheshvidyut/gists{/gist_id}","starred_url":"https://api.github.com/users/asheshvidyut/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/asheshvidyut/subscriptions","organizations_url":"https://api.github.com/users/asheshvidyut/orgs","repos_url":"https://api.github.com/users/asheshvidyut/repos","events_url":"https://api.github.com/users/asheshvidyut/events{/privacy}","received_events_url":"https://api.github.com/users/asheshvidyut/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"sergiitk","id":672669,"node_id":"MDQ6VXNlcjY3MjY2OQ==","avatar_url":"https://avatars.githubusercontent.com/u/672669?v=4","gravatar_id":"","url":"https://api.github.com/users/sergiitk","html_url":"https://github.com/sergiitk","followers_url":"https://api.github.com/users/sergiitk/followers","following_url":"https://api.github.com/users/sergiitk/following{/other_user}","gists_url":"https://api.github.com/users/sergiitk/gists{/gist_id}","starred_url":"https://api.github.com/users/sergiitk/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sergiitk/subscriptions","organizations_url":"https://api.github.com/users/sergiitk/orgs","repos_url":"https://api.github.com/users/sergiitk/repos","events_url":"https://api.github.com/users/sergiitk/events{/privacy}","received_events_url":"https://api.github.com/users/sergiitk/received_events","type":"User","user_view_type":"public","site_admin":false},{"login":"sreenithi","id":22791051,"node_id":"MDQ6VXNlcjIyNzkxMDUx","avatar_url":"https://avatars.githubusercontent.com/u/22791051?v=4","gravatar_id":"","url":"https://api.github.com/users/sreenithi","html_url":"https://github.com/sreenithi","followers_url":"https://api.github.com/users/sreenithi/followers","following_url":"https://api.github.com/users/sreenithi/following{/other_user}","gists_url":"https://api.github.com/users/sreenithi/gists{/gist_id}","starred_url":"https://api.github.com/users/sreenithi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sreenithi/subscriptions","organizations_url":"https://api.github.com/users/sreenithi/orgs","repos_url":"https://api.github.com/users/sreenithi/repos","events_url":"https://api.github.com/users/sreenithi/events{/privacy}","received_events_url":"https://api.github.com/users/sreenithi/received_events","type":"User","user_view_type":"public","site_admin":false},{"login":"asheshvidyut","id":134911583,"node_id":"U_kgDOCAqWXw","avatar_url":"https://avatars.githubusercontent.com/u/134911583?v=4","gravatar_id":"","url":"https://api.github.com/users/asheshvidyut","html_url":"https://github.com/asheshvidyut","followers_url":"https://api.github.com/users/asheshvidyut/followers","following_url":"https://api.github.com/users/asheshvidyut/following{/other_user}","gists_url":"https://api.github.com/users/asheshvidyut/gists{/gist_id}","starred_url":"https://api.github.com/users/asheshvidyut/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/asheshvidyut/subscriptions","organizations_url":"https://api.github.com/users/asheshvidyut/orgs","repos_url":"https://api.github.com/users/asheshvidyut/repos","events_url":"https://api.github.com/users/asheshvidyut/events{/privacy}","received_events_url":"https://api.github.com/users/asheshvidyut/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":3,"created_at":"2025-08-14T12:55:35Z","updated_at":"2025-10-07T17:32:19Z","closed_at":"2025-10-07T17:32:19Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### What version of gRPC and what language are you using?\n\ngRPC version: 1.74.0\nLanguage: Python\n\n### What operating system (Linux, Windows,...) and version?\n\nmacOS Darwin 24.6.0 (Darwin Kernel Version 24.6.0, ARM64)\n\n### What runtime / compiler are you using (e.g. python version or version of gcc)\n\nPython 3.13.5\n\n###  What did you do?\n\n1. Ran the official gRPC Python multiprocessing example from\nexamples/python/multiprocessing/\n2. Modified the server.py to log PIDs when processes start and when handling requests\n3. Created a test that tracks which processes actually handle requests\n\nHere's the test that demonstrates the issue followed by the modified `server.py` file with additional logging:\n```py\n\"\"\"\nTest for multiprocessing example. Save under\ngrpc/examples/python/multiprocessing/test/test_multiprocessing_so_reuseport.py\n\"\"\"\n\nimport ast\nimport logging\nimport math\nimport os\nimport re\nimport subprocess\nimport tempfile\nimport unittest\n\n_BINARY_DIR = os.path.realpath(\n    os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\")\n)\n_SERVER_PATH = os.path.join(_BINARY_DIR, \"server.py\")\n_CLIENT_PATH = os.path.join(_BINARY_DIR, \"client.py\")\n\n\ndef is_prime(n):\n    for i in range(2, int(math.ceil(math.sqrt(n)))):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\n\ndef _get_server_address(server_stream):\n    while True:\n        server_stream.seek(0)\n        line = server_stream.readline()\n        while line:\n            matches = re.search(\"Binding to '(.+)'\", line)\n            if matches is not None:\n                return matches.groups()[0]\n            line = server_stream.readline()\n\n\nclass MultiprocessingExampleTest(unittest.TestCase):\n    def test_multiprocessing_example(self):\n        import time\n        server_stdout = tempfile.TemporaryFile(mode=\"r\")\n        server_process = subprocess.Popen(\n            (\"python3\", _SERVER_PATH), \n            stdout=server_stdout,\n            stderr=subprocess.STDOUT\n        )\n        \n        # Wait for server to start and get address\n        server_address = None\n        start_time = time.time()\n        while time.time() - start_time < 5:\n            server_stdout.seek(0)\n            content = server_stdout.read()\n            match = re.search(r\"Binding to '(.+)'\", content)\n            if match:\n                server_address = match.group(1)\n                break\n            time.sleep(0.1)\n        \n        if not server_address:\n            server_process.terminate()\n            self.fail(\"Could not get server address\")\n        \n        # Give server processes time to fully start\n        time.sleep(1)\n        \n        client_stdout = tempfile.TemporaryFile(mode=\"r\")\n        client_process = subprocess.Popen(\n            (\n                \"python3\",\n                _CLIENT_PATH,\n                server_address,\n            ),\n            stdout=client_stdout,\n            stderr=subprocess.STDOUT\n        )\n        client_process.wait(timeout=30)\n        server_process.terminate()\n        \n        # Read and analyze server output to check PIDs\n        server_stdout.seek(0)\n        server_output = server_stdout.read()\n        \n        # Extract PIDs that started servers\n        started_pids = set()\n        request_pids = set()\n        \n        for line in server_output.split('\\n'):\n            # Match lines like \"[PID 12345] Starting new server with PID 12345\"\n            start_match = re.search(r'Starting new server with PID (\\d+)', line)\n            if start_match:\n                started_pids.add(int(start_match.group(1)))\n            \n            # Match lines like \"[PID 12345] PID 12345: Determining primality of 2\"\n            request_match = re.search(r'PID (\\d+): Determining primality of \\d+', line)\n            if request_match:\n                request_pids.add(int(request_match.group(1)))\n        \n        print(f\"\\nStarted server PIDs: {sorted(started_pids)}\")\n        print(f\"PIDs that handled requests: {sorted(request_pids)}\")\n        print(f\"Number of server processes started: {len(started_pids)}\")\n        print(f\"Number of processes that handled requests: {len(request_pids)}\")\n        \n        client_stdout.seek(0)\n        results = ast.literal_eval(client_stdout.read().strip().split(\"\\n\")[-1])\n        values = tuple(result[0] for result in results)\n        self.assertSequenceEqual(range(2, 10000), values)\n        for result in results:\n            self.assertEqual(is_prime(result[0]), result[1])\n\n        # Fail the test if load was not balanced across all processes\n        self.assertEqual(\n            len(request_pids), \n            len(started_pids),\n            f\"Load balancing failed: {len(started_pids)} processes started but only \"\n            f\"{len(request_pids)} process(es) handled requests. \"\n            f\"All requests went to PID(s): {sorted(request_pids)}\"\n        )\n\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig()\n    unittest.main(verbosity=2)\n```\n\n```py\n\"\"\" Modified grpc/examples/python/multiprocessing/server.py \"\"\"\n# Copyright 2019 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"An example of multiprocess concurrency with gRPC.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom concurrent import futures\nimport contextlib\nimport datetime\nimport logging\nimport math\nimport multiprocessing\nimport os\nimport socket\nimport sys\nimport time\n\nimport grpc\nimport prime_pb2\nimport prime_pb2_grpc\n\n_LOGGER = logging.getLogger(__name__)\n\n_ONE_DAY = datetime.timedelta(days=1)\n_PROCESS_COUNT = multiprocessing.cpu_count()\n_THREAD_CONCURRENCY = _PROCESS_COUNT\n\n\ndef is_prime(n):\n    for i in range(2, int(math.ceil(math.sqrt(n)))):\n        if n % i == 0:\n            return False\n    else:\n        return True\n\n\nclass PrimeChecker(prime_pb2_grpc.PrimeCheckerServicer):\n    def check(self, request, context):\n        _LOGGER.info(\"PID %d: Determining primality of %s\", os.getpid(), request.candidate)\n        sys.stdout.flush()  # Ensure output is flushed\n        return prime_pb2.Primality(isPrime=is_prime(request.candidate))\n\n\ndef _wait_forever(server):\n    try:\n        while True:\n            time.sleep(_ONE_DAY.total_seconds())\n    except KeyboardInterrupt:\n        server.stop(None)\n\n\ndef _run_server(bind_address):\n    \"\"\"Start a server in a subprocess.\"\"\"\n    # Setup logging for this subprocess\n    import logging\n    logger = logging.getLogger(__name__)\n    if not logger.handlers:\n        handler = logging.StreamHandler(sys.stdout)\n        formatter = logging.Formatter(\"[PID %(process)d] %(message)s\")\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        logger.setLevel(logging.INFO)\n    \n    logger.info(\"Starting new server with PID %d\", os.getpid())\n    sys.stdout.flush()  # Ensure output is flushed\n    options = ((\"grpc.so_reuseport\", 1),)\n\n    server = grpc.server(\n        futures.ThreadPoolExecutor(\n            max_workers=_THREAD_CONCURRENCY,\n        ),\n        options=options,\n    )\n    prime_pb2_grpc.add_PrimeCheckerServicer_to_server(PrimeChecker(), server)\n    server.add_insecure_port(bind_address)\n    server.start()\n    _wait_forever(server)\n\n\n@contextlib.contextmanager\ndef _reserve_port():\n    \"\"\"Find and reserve a port for all subprocesses to use.\"\"\"\n    sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n    if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT) == 0:\n        raise RuntimeError(\"Failed to set SO_REUSEPORT.\")\n    sock.bind((\"\", 0))\n    try:\n        yield sock.getsockname()[1]\n    finally:\n        sock.close()\n\n\ndef main():\n    with _reserve_port() as port:\n        bind_address = \"localhost:{}\".format(port)\n        _LOGGER.info(\"Binding to '%s'\", bind_address)\n        sys.stdout.flush()  # Ensure binding message is flushed\n        workers = []\n        for _ in range(_PROCESS_COUNT):\n            # NOTE: It is imperative that the worker subprocesses be forked before\n            # any gRPC servers start up. See\n            # https://github.com/grpc/grpc/issues/16001 for more details.\n            worker = multiprocessing.Process(\n                target=_run_server, args=(bind_address,)\n            )\n            worker.start()\n            workers.append(worker)\n        for worker in workers:\n            worker.join()\n\n\nif __name__ == \"__main__\":\n    handler = logging.StreamHandler(sys.stdout)\n    formatter = logging.Formatter(\"[PID %(process)d] %(message)s\")\n    handler.setFormatter(formatter)\n    _LOGGER.addHandler(handler)\n    _LOGGER.setLevel(logging.INFO)\n    main()\n```\n\nThe test can be executed from the `grpc` repo top-level directory by running\n```\npython3 examples/python/multiprocessing/test/test_multiprocessing_so_reuseport.py\n```\n\n\nThe test shows that despite spawning multiple processes (8 on an 8-core machine),\nonly one process handles all ~10,000 requests.\n\n### What did you expect to see?\n\nBased on the `README.md` statement:\n> \"Multiprocessing allows application developers to sidestep the Python global interpreter lock and achieve true parallelism on multicore systems\"\nI expected:\n\n1. The load to be balanced across all spawned processes\n2. Each process to handle a roughly equal share of requests\n3. True parallel processing utilizing multiple CPU cores\n\n### What did you see instead?\n\n- 8 server processes are spawned (on an 8-core system)\n- Only 1 process handles ALL ~10,000 requests\n- The other 7 processes sit idle\n- No load balancing occurs despite using SO_REUSEPORT\n\nTest output:\n```\nStarted server PIDs: [54048, 54049, 54050, 54051, 54052, 54053, 54054, 54055]\nPIDs that handled requests: [54053]\nNumber of server processes started: 8\nNumber of processes that handled requests: 1\n\nAssertionError: 1 != 8 : Load balancing failed: 8 processes started but only 1\nhandled requests\n```\n\nThis makes the example misleading as it does not achieve \"true parallelism\" for\nrequest handling. The issue appears to be related to SO_REUSEPORT behavior on macOS/Darwin\nwhere the kernel assigns all requests for the same connection to the same process\n(which is the last one to bind to the port). This results in only one process\nhandling all requests, while the others remain idle, effectively serializing request\nprocessing across processes which defeats the purpose of multiprocessing in this example.\n\nThe example should either:\n1. Be fixed to actually demonstrate load balancing across processes independent on platform\n2. Have its documentation updated to clarify that it doesn't achieve parallel request\n processing if SO_REUSEPORT is used depending on Platform and connection behavior\n3. Include a warning about SO_REUSEPORT limitations on certain platforms (especially\nmacOS)\n","closed_by":{"login":"sergiitk","id":672669,"node_id":"MDQ6VXNlcjY3MjY2OQ==","avatar_url":"https://avatars.githubusercontent.com/u/672669?v=4","gravatar_id":"","url":"https://api.github.com/users/sergiitk","html_url":"https://github.com/sergiitk","followers_url":"https://api.github.com/users/sergiitk/followers","following_url":"https://api.github.com/users/sergiitk/following{/other_user}","gists_url":"https://api.github.com/users/sergiitk/gists{/gist_id}","starred_url":"https://api.github.com/users/sergiitk/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sergiitk/subscriptions","organizations_url":"https://api.github.com/users/sergiitk/orgs","repos_url":"https://api.github.com/users/sergiitk/repos","events_url":"https://api.github.com/users/sergiitk/events{/privacy}","received_events_url":"https://api.github.com/users/sergiitk/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/grpc/grpc/issues/40444/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/grpc/grpc/issues/40444/timeline","performed_via_github_app":null,"state_reason":"completed"}