{"url":"https://api.github.com/repos/syncthing/syncthing/issues/5372","repository_url":"https://api.github.com/repos/syncthing/syncthing","labels_url":"https://api.github.com/repos/syncthing/syncthing/issues/5372/labels{/name}","comments_url":"https://api.github.com/repos/syncthing/syncthing/issues/5372/comments","events_url":"https://api.github.com/repos/syncthing/syncthing/issues/5372/events","html_url":"https://github.com/syncthing/syncthing/issues/5372","id":390382410,"node_id":"MDU6SXNzdWUzOTAzODI0MTA=","number":5372,"title":"Event system can cause deadlock","user":{"login":"calmh","id":125426,"node_id":"MDQ6VXNlcjEyNTQyNg==","avatar_url":"https://avatars.githubusercontent.com/u/125426?v=4","gravatar_id":"","url":"https://api.github.com/users/calmh","html_url":"https://github.com/calmh","followers_url":"https://api.github.com/users/calmh/followers","following_url":"https://api.github.com/users/calmh/following{/other_user}","gists_url":"https://api.github.com/users/calmh/gists{/gist_id}","starred_url":"https://api.github.com/users/calmh/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/calmh/subscriptions","organizations_url":"https://api.github.com/users/calmh/orgs","repos_url":"https://api.github.com/users/calmh/repos","events_url":"https://api.github.com/users/calmh/events{/privacy}","received_events_url":"https://api.github.com/users/calmh/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":67767665,"node_id":"MDU6TGFiZWw2Nzc2NzY2NQ==","url":"https://api.github.com/repos/syncthing/syncthing/labels/bug","name":"bug","color":"d93f0b","default":true,"description":"A problem with current functionality, as opposed to missing functionality (enhancement)"},{"id":628314330,"node_id":"MDU6TGFiZWw2MjgzMTQzMzA=","url":"https://api.github.com/repos/syncthing/syncthing/labels/frozen-due-to-age","name":"frozen-due-to-age","color":"eeeeee","default":false,"description":"Issues closed and untouched for a long time, together with being locked for discussion"}],"state":"closed","locked":true,"assignee":{"login":"calmh","id":125426,"node_id":"MDQ6VXNlcjEyNTQyNg==","avatar_url":"https://avatars.githubusercontent.com/u/125426?v=4","gravatar_id":"","url":"https://api.github.com/users/calmh","html_url":"https://github.com/calmh","followers_url":"https://api.github.com/users/calmh/followers","following_url":"https://api.github.com/users/calmh/following{/other_user}","gists_url":"https://api.github.com/users/calmh/gists{/gist_id}","starred_url":"https://api.github.com/users/calmh/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/calmh/subscriptions","organizations_url":"https://api.github.com/users/calmh/orgs","repos_url":"https://api.github.com/users/calmh/repos","events_url":"https://api.github.com/users/calmh/events{/privacy}","received_events_url":"https://api.github.com/users/calmh/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"calmh","id":125426,"node_id":"MDQ6VXNlcjEyNTQyNg==","avatar_url":"https://avatars.githubusercontent.com/u/125426?v=4","gravatar_id":"","url":"https://api.github.com/users/calmh","html_url":"https://github.com/calmh","followers_url":"https://api.github.com/users/calmh/followers","following_url":"https://api.github.com/users/calmh/following{/other_user}","gists_url":"https://api.github.com/users/calmh/gists{/gist_id}","starred_url":"https://api.github.com/users/calmh/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/calmh/subscriptions","organizations_url":"https://api.github.com/users/calmh/orgs","repos_url":"https://api.github.com/users/calmh/repos","events_url":"https://api.github.com/users/calmh/events{/privacy}","received_events_url":"https://api.github.com/users/calmh/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":{"url":"https://api.github.com/repos/syncthing/syncthing/milestones/28","html_url":"https://github.com/syncthing/syncthing/milestone/28","labels_url":"https://api.github.com/repos/syncthing/syncthing/milestones/28/labels","id":3786376,"node_id":"MDk6TWlsZXN0b25lMzc4NjM3Ng==","number":28,"title":"v1.0.0","description":"ðŸŽ† ","creator":{"login":"calmh","id":125426,"node_id":"MDQ6VXNlcjEyNTQyNg==","avatar_url":"https://avatars.githubusercontent.com/u/125426?v=4","gravatar_id":"","url":"https://api.github.com/users/calmh","html_url":"https://github.com/calmh","followers_url":"https://api.github.com/users/calmh/followers","following_url":"https://api.github.com/users/calmh/following{/other_user}","gists_url":"https://api.github.com/users/calmh/gists{/gist_id}","starred_url":"https://api.github.com/users/calmh/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/calmh/subscriptions","organizations_url":"https://api.github.com/users/calmh/orgs","repos_url":"https://api.github.com/users/calmh/repos","events_url":"https://api.github.com/users/calmh/events{/privacy}","received_events_url":"https://api.github.com/users/calmh/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":0,"closed_issues":23,"state":"closed","created_at":"2018-10-31T19:47:49Z","updated_at":"2019-01-01T08:25:47Z","due_on":"2019-01-01T08:00:00Z","closed_at":"2019-01-01T08:25:47Z"},"comments":1,"created_at":"2018-12-12T19:50:04Z","updated_at":"2019-12-14T07:02:10Z","closed_at":"2018-12-13T12:42:34Z","author_association":"MEMBER","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"There's an issue with the event system which can cause what is effectively a deadlock during normal operations. It's not a logical deadlock, it's just that sending events can end up taking forever, which blocks other things. We often send events while holding other locks, which makes it worse.\r\n\r\nSpecifically, when an event listener no longer polls for events the Log() call will block for 150 ms per non-polling listener. If there are several dead listeners this can add up, and it blocks other Log() calls during this time as well due to needing to hold the lock. \r\n\r\nThere are a couple of places where we can end up with dead event listeners. The [watch aggregator can exit but never unsubscribes](https://github.com/syncthing/syncthing/blob/c9349183478321cc434b92cd8d7dc9bfefed82db/lib/watchaggregator/aggregator.go#L135-L162). But more seriously, anything that 1) ceases to process events 2) unsubscribes, perhaps as part of a defer, causes this issue. For example, [sendIndexes](https://github.com/syncthing/syncthing/blob/c9349183478321cc434b92cd8d7dc9bfefed82db/lib/model/model.go#L1823-L1861).\r\n\r\nThe reason for the latter is that once we stop reading events, the Unsubscribe() can take effectively forever. There might be a thousand event senders producing events quite frequently (for example, lots of folders which are scanning on a short interval). These all compete for the mutex which must be held to unsubscribe. As each of these calls can take over a second and there are thousands and thousands of them waiting for the lock, the odds that our Unsubscribe() call actually gets to acquire the lock in reasonable time are slim.\r\n\r\nI have a test that reproduces this sad situation.\r\n\r\nI see several potential solutions; first of all we must ensure that every subscribe is matched by an unsubscribe. Then;\r\n\r\n1. We can use a [priority lock](https://github.com/platinummonkey/priority-lock) to prioritize Subscribe()/Unsubscribe() over Log(). This works nicely in my testing, because the unsubscribe gets to happen ahead of the queue and then everything else is quick again.\r\n\r\n2. We can use BufferedSubscriptions() everywhere, as these continue reading the actual event stream in the background until the unsubscribe has actually gotten through.\r\n\r\n3. We can make the event system more lossy, putting the burden to keep up with the events more on the receiving side. A normal Subscription already has a buffered channel; we could simply skip the timeout handling in Log() and use a non-blocking send.\r\n\r\nI think we should do number 1 at minimum, and possibly number 3. In the cases where we expect many events and have to catch 'em all, that's what the buffered subscription is for.\r\n\r\nAs a motivator, here's a massive backtrace showing the problem (on 0.14.48).\r\n\r\n[backtrace.txt](https://github.com/syncthing/syncthing/files/2673301/backtrace.txt)\r\n","closed_by":{"login":"calmh","id":125426,"node_id":"MDQ6VXNlcjEyNTQyNg==","avatar_url":"https://avatars.githubusercontent.com/u/125426?v=4","gravatar_id":"","url":"https://api.github.com/users/calmh","html_url":"https://github.com/calmh","followers_url":"https://api.github.com/users/calmh/followers","following_url":"https://api.github.com/users/calmh/following{/other_user}","gists_url":"https://api.github.com/users/calmh/gists{/gist_id}","starred_url":"https://api.github.com/users/calmh/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/calmh/subscriptions","organizations_url":"https://api.github.com/users/calmh/orgs","repos_url":"https://api.github.com/users/calmh/repos","events_url":"https://api.github.com/users/calmh/events{/privacy}","received_events_url":"https://api.github.com/users/calmh/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/syncthing/syncthing/issues/5372/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/syncthing/syncthing/issues/5372/timeline","performed_via_github_app":null,"state_reason":"completed"}