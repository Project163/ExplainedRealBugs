diff --git a/lib/config/folderconfiguration.go b/lib/config/folderconfiguration.go
index 756ed333b..395c13bb8 100644
--- a/lib/config/folderconfiguration.go
+++ b/lib/config/folderconfiguration.go
@@ -96,7 +96,7 @@ func (f *FolderConfiguration) CreateMarker() error {
 		}
 		if dir, err := fs.Open("."); err == nil {
 			if serr := dir.Sync(); err != nil {
-				l.Infof("fsync %q failed: %v", ".", serr)
+				l.Debugln("fsync %q failed: %v", ".", serr)
 			}
 		} else {
 			l.Infof("fsync %q failed: %v", ".", err)
diff --git a/lib/fs/basicfs.go b/lib/fs/basicfs.go
index f1f62ced8..4a0dc0919 100644
--- a/lib/fs/basicfs.go
+++ b/lib/fs/basicfs.go
@@ -317,22 +317,6 @@ func (f fsFile) Stat() (FileInfo, error) {
 	return fsFileInfo{info}, nil
 }
 
-func (f fsFile) Sync() error {
-	err := f.File.Sync()
-	if err == nil || runtime.GOOS != "windows" {
-		return err
-	}
-	// On Windows, fsyncing a directory returns a "handle is invalid" (localized so can't check for strings)
-	// So we swallow that and let things go through in order not to have to add
-	// a separate way of syncing directories versus files.
-	if stat, serr := f.Stat(); serr != nil {
-		return serr
-	} else if stat.IsDir() {
-		return nil
-	}
-	return err
-}
-
 // fsFileInfo implements the fs.FileInfo interface on top of an os.FileInfo.
 type fsFileInfo struct {
 	os.FileInfo
diff --git a/lib/model/rwfolder.go b/lib/model/rwfolder.go
index 21886cee9..060d0fa1d 100644
--- a/lib/model/rwfolder.go
+++ b/lib/model/rwfolder.go
@@ -1543,11 +1543,11 @@ func (f *sendReceiveFolder) dbUpdaterRoutine() {
 			delete(changedDirs, dir)
 			fd, err := f.fs.Open(dir)
 			if err != nil {
-				l.Infof("fsync %q failed: %v", dir, err)
+				l.Debugf("fsync %q failed: %v", dir, err)
 				continue
 			}
 			if err := fd.Sync(); err != nil {
-				l.Infof("fsync %q failed: %v", dir, err)
+				l.Debugf("fsync %q failed: %v", dir, err)
 			}
 			fd.Close()
 		}
