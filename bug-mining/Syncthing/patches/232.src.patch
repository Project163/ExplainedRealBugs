diff --git a/cmd/syncthing/main.go b/cmd/syncthing/main.go
index 1ae0d6f14..14fa8660a 100644
--- a/cmd/syncthing/main.go
+++ b/cmd/syncthing/main.go
@@ -50,6 +50,7 @@ var (
 	BuildHost   = "unknown"
 	BuildUser   = "unknown"
 	IsRelease   bool
+	IsBeta      bool
 	LongVersion string
 )
 
@@ -80,6 +81,7 @@ func init() {
 	// Check for a clean release build.
 	exp := regexp.MustCompile(`^v\d+\.\d+\.\d+(-beta[\d\.]+)?$`)
 	IsRelease = exp.MatchString(Version)
+	IsBeta = strings.Contains(Version, "beta")
 
 	stamp, _ := strconv.Atoi(BuildStamp)
 	BuildDate = time.Unix(int64(stamp), 0)
@@ -510,6 +512,15 @@ func syncthingMain() {
 
 	m := model.NewModel(cfg, myID, myName, "syncthing", Version, ldb)
 
+	if t := os.Getenv("STDEADLOCKTIMEOUT"); len(t) > 0 {
+		it, err := strconv.Atoi(t)
+		if err == nil {
+			m.StartDeadlockDetector(time.Duration(it) * time.Second)
+		}
+	} else if !IsRelease || IsBeta {
+		m.StartDeadlockDetector(20 * 60 * time.Second)
+	}
+
 	// GUI
 
 	setupGUI(cfg, m)
diff --git a/internal/model/model.go b/internal/model/model.go
index 022a3d35e..fa122d8af 100644
--- a/internal/model/model.go
+++ b/internal/model/model.go
@@ -17,7 +17,6 @@ import (
 	"net"
 	"os"
 	"path/filepath"
-	"strconv"
 	"strings"
 	"sync"
 	"time"
@@ -118,18 +117,17 @@ func NewModel(cfg *config.Wrapper, id protocol.DeviceID, deviceName, clientName,
 		go m.progressEmitter.Serve()
 	}
 
-	var timeout = 20 * 60 // seconds
-	if t := os.Getenv("STDEADLOCKTIMEOUT"); len(t) > 0 {
-		it, err := strconv.Atoi(t)
-		if err == nil {
-			timeout = it
-		}
-	}
-	deadlockDetect(&m.fmut, time.Duration(timeout)*time.Second)
-	deadlockDetect(&m.pmut, time.Duration(timeout)*time.Second)
 	return m
 }
 
+// Starts deadlock detector on the models locks which causes panics in case
+// the locks cannot be acquired in the given timeout period.
+func (m *Model) StartDeadlockDetector(timeout time.Duration) {
+	l.Infof("Starting deadlock detector with %v timeout", timeout)
+	deadlockDetect(&m.fmut, timeout)
+	deadlockDetect(&m.pmut, timeout)
+}
+
 // StartRW starts read/write processing on the current model. When in
 // read/write mode the model will attempt to keep in sync with the cluster by
 // pulling needed files from peer devices.
