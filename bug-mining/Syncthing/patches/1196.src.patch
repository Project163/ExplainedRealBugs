diff --git a/lib/model/sharedpullerstate.go b/lib/model/sharedpullerstate.go
index df940c91c..d6d26e92d 100644
--- a/lib/model/sharedpullerstate.go
+++ b/lib/model/sharedpullerstate.go
@@ -376,6 +376,7 @@ func (s *sharedPullerState) Progress() *pullerProgress {
 	defer s.mut.RUnlock()
 	total := s.reused + s.copyTotal + s.pullTotal
 	done := total - s.copyNeeded - s.pullNeeded
+	file := len(s.file.Blocks)
 	return &pullerProgress{
 		Total:               total,
 		Reused:              s.reused,
@@ -383,8 +384,8 @@ func (s *sharedPullerState) Progress() *pullerProgress {
 		CopiedFromElsewhere: s.copyTotal - s.copyNeeded - s.copyOrigin,
 		Pulled:              s.pullTotal - s.pullNeeded,
 		Pulling:             s.pullNeeded,
-		BytesTotal:          blocksToSize(s.file.BlockSize(), total),
-		BytesDone:           blocksToSize(s.file.BlockSize(), done),
+		BytesTotal:          blocksToSize(total, file, s.file.BlockSize(), s.file.Size),
+		BytesDone:           blocksToSize(done, file, s.file.BlockSize(), s.file.Size),
 	}
 }
 
@@ -412,9 +413,12 @@ func (s *sharedPullerState) Available() []int {
 	return blocks
 }
 
-func blocksToSize(size int, num int) int64 {
-	if num < 2 {
-		return int64(size / 2)
+func blocksToSize(blocks, blocksInFile, blockSize int, fileSize int64) int64 {
+	// The last/only block has somewhere between 1 and blockSize bytes. We do
+	// not know whether the smaller block is part of the blocks and use an
+	// estimate assuming a random chance that the small block is contained.
+	if blocksInFile == 0 {
+		return 0
 	}
-	return int64(num-1)*int64(size) + int64(size/2)
+	return int64(blocks)*int64(blockSize) - (int64(blockSize)-fileSize%int64(blockSize))*int64(blocks)/int64(blocksInFile)
 }
