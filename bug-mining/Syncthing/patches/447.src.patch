diff --git a/lib/model/rwfolder_test.go b/lib/model/rwfolder_test.go
index 0dd6d6053..cf8c087ee 100644
--- a/lib/model/rwfolder_test.go
+++ b/lib/model/rwfolder_test.go
@@ -67,14 +67,18 @@ func setUpModel(file protocol.FileInfo) *Model {
 }
 
 func setUpRwFolder(model *Model) rwFolder {
-	f := rwFolder{
+	return rwFolder{
+		folder: folder{
+			stateTracker: stateTracker{
+				folderID: "default",
+			},
+			model: model,
+		},
 		dir:       "testdata",
+		queue:     newJobQueue(),
 		errors:    make(map[string]string),
 		errorsMut: sync.NewMutex(),
 	}
-	f.folderID = "default"
-	f.model = model
-	return f
 }
 
 // Layout of the files: (indexes from the above array)
@@ -93,10 +97,10 @@ func TestHandleFile(t *testing.T) {
 	requiredFile.Blocks = blocks[1:]
 
 	m := setUpModel(existingFile)
-	p := setUpRwFolder(m)
+	f := setUpRwFolder(m)
 	copyChan := make(chan copyBlocksState, 1)
 
-	p.handleFile(requiredFile, copyChan, nil)
+	f.handleFile(requiredFile, copyChan, nil)
 
 	// Receive the results
 	toCopy := <-copyChan
@@ -134,10 +138,10 @@ func TestHandleFileWithTemp(t *testing.T) {
 	requiredFile.Blocks = blocks[1:]
 
 	m := setUpModel(existingFile)
-	p := setUpRwFolder(m)
+	f := setUpRwFolder(m)
 	copyChan := make(chan copyBlocksState, 1)
 
-	p.handleFile(requiredFile, copyChan, nil)
+	f.handleFile(requiredFile, copyChan, nil)
 
 	// Receive the results
 	toCopy := <-copyChan
@@ -182,15 +186,15 @@ func TestCopierFinder(t *testing.T) {
 	requiredFile.Name = "file2"
 
 	m := setUpModel(existingFile)
-	p := setUpRwFolder(m)
+	f := setUpRwFolder(m)
 	copyChan := make(chan copyBlocksState)
 	pullChan := make(chan pullBlockState, 4)
 	finisherChan := make(chan *sharedPullerState, 1)
 
 	// Run a single fetcher routine
-	go p.copierRoutine(copyChan, pullChan, finisherChan)
+	go f.copierRoutine(copyChan, pullChan, finisherChan)
 
-	p.handleFile(requiredFile, copyChan, finisherChan)
+	f.handleFile(requiredFile, copyChan, finisherChan)
 
 	pulls := []pullBlockState{<-pullChan, <-pullChan, <-pullChan, <-pullChan}
 	finish := <-finisherChan
@@ -291,16 +295,16 @@ func TestLastResortPulling(t *testing.T) {
 		return true
 	}
 
-	p := setUpRwFolder(m)
+	f := setUpRwFolder(m)
 
 	copyChan := make(chan copyBlocksState)
 	pullChan := make(chan pullBlockState, 1)
 	finisherChan := make(chan *sharedPullerState, 1)
 
 	// Run a single copier routine
-	go p.copierRoutine(copyChan, pullChan, finisherChan)
+	go f.copierRoutine(copyChan, pullChan, finisherChan)
 
-	p.handleFile(file, copyChan, finisherChan)
+	f.handleFile(file, copyChan, finisherChan)
 
 	// Copier should hash empty file, realise that the region it has read
 	// doesn't match the hash which was advertised by the block map, fix it
@@ -329,24 +333,13 @@ func TestDeregisterOnFailInCopy(t *testing.T) {
 	m := NewModel(defaultConfig, protocol.LocalDeviceID, "device", "syncthing", "dev", db, nil)
 	m.AddFolder(defaultFolderConfig)
 
-	emitter := NewProgressEmitter(defaultConfig)
-	m.progressEmitter = emitter
-	go emitter.Serve()
-
-	p := rwFolder{
-		dir:       "testdata",
-		queue:     newJobQueue(),
-		errors:    make(map[string]string),
-		errorsMut: sync.NewMutex(),
-	}
-	p.folderID = "default"
-	p.model = m
+	f := setUpRwFolder(m)
 
 	// queue.Done should be called by the finisher routine
-	p.queue.Push("filex", 0, 0)
-	p.queue.Pop()
+	f.queue.Push("filex", 0, 0)
+	f.queue.Pop()
 
-	if p.queue.lenProgress() != 1 {
+	if f.queue.lenProgress() != 1 {
 		t.Fatal("Expected file in progress")
 	}
 
@@ -355,10 +348,10 @@ func TestDeregisterOnFailInCopy(t *testing.T) {
 	finisherBufferChan := make(chan *sharedPullerState)
 	finisherChan := make(chan *sharedPullerState)
 
-	go p.copierRoutine(copyChan, pullChan, finisherBufferChan)
-	go p.finisherRoutine(finisherChan)
+	go f.copierRoutine(copyChan, pullChan, finisherBufferChan)
+	go f.finisherRoutine(finisherChan)
 
-	p.handleFile(file, copyChan, finisherChan)
+	f.handleFile(file, copyChan, finisherChan)
 
 	// Receive a block at puller, to indicate that at least a single copier
 	// loop has been performed.
@@ -374,7 +367,7 @@ func TestDeregisterOnFailInCopy(t *testing.T) {
 	case state := <-finisherBufferChan:
 		// At this point the file should still be registered with both the job
 		// queue, and the progress emitter. Verify this.
-		if p.model.progressEmitter.lenRegistry() != 1 || p.queue.lenProgress() != 1 || p.queue.lenQueued() != 0 {
+		if f.model.progressEmitter.lenRegistry() != 1 || f.queue.lenProgress() != 1 || f.queue.lenQueued() != 0 {
 			t.Fatal("Could not find file")
 		}
 
@@ -389,16 +382,16 @@ func TestDeregisterOnFailInCopy(t *testing.T) {
 			t.Fatal("File not closed?")
 		}
 
-		if p.model.progressEmitter.lenRegistry() != 0 || p.queue.lenProgress() != 0 || p.queue.lenQueued() != 0 {
-			t.Fatal("Still registered", p.model.progressEmitter.lenRegistry(), p.queue.lenProgress(), p.queue.lenQueued())
+		if f.model.progressEmitter.lenRegistry() != 0 || f.queue.lenProgress() != 0 || f.queue.lenQueued() != 0 {
+			t.Fatal("Still registered", f.model.progressEmitter.lenRegistry(), f.queue.lenProgress(), f.queue.lenQueued())
 		}
 
 		// Doing it again should have no effect
 		finisherChan <- state
 		time.Sleep(100 * time.Millisecond)
 
-		if p.model.progressEmitter.lenRegistry() != 0 || p.queue.lenProgress() != 0 || p.queue.lenQueued() != 0 {
-			t.Fatal("Still registered", p.model.progressEmitter.lenRegistry(), p.queue.lenProgress(), p.queue.lenQueued())
+		if f.model.progressEmitter.lenRegistry() != 0 || f.queue.lenProgress() != 0 || f.queue.lenQueued() != 0 {
+			t.Fatal("Still registered", f.model.progressEmitter.lenRegistry(), f.queue.lenProgress(), f.queue.lenQueued())
 		}
 	case <-time.After(time.Second):
 		t.Fatal("Didn't get anything to the finisher")
@@ -413,24 +406,13 @@ func TestDeregisterOnFailInPull(t *testing.T) {
 	m := NewModel(defaultConfig, protocol.LocalDeviceID, "device", "syncthing", "dev", db, nil)
 	m.AddFolder(defaultFolderConfig)
 
-	emitter := NewProgressEmitter(defaultConfig)
-	m.progressEmitter = emitter
-	go emitter.Serve()
-
-	p := rwFolder{
-		dir:       "testdata",
-		queue:     newJobQueue(),
-		errors:    make(map[string]string),
-		errorsMut: sync.NewMutex(),
-	}
-	p.folderID = "default"
-	p.model = m
+	f := setUpRwFolder(m)
 
 	// queue.Done should be called by the finisher routine
-	p.queue.Push("filex", 0, 0)
-	p.queue.Pop()
+	f.queue.Push("filex", 0, 0)
+	f.queue.Pop()
 
-	if p.queue.lenProgress() != 1 {
+	if f.queue.lenProgress() != 1 {
 		t.Fatal("Expected file in progress")
 	}
 
@@ -439,11 +421,11 @@ func TestDeregisterOnFailInPull(t *testing.T) {
 	finisherBufferChan := make(chan *sharedPullerState)
 	finisherChan := make(chan *sharedPullerState)
 
-	go p.copierRoutine(copyChan, pullChan, finisherBufferChan)
-	go p.pullerRoutine(pullChan, finisherBufferChan)
-	go p.finisherRoutine(finisherChan)
+	go f.copierRoutine(copyChan, pullChan, finisherBufferChan)
+	go f.pullerRoutine(pullChan, finisherBufferChan)
+	go f.finisherRoutine(finisherChan)
 
-	p.handleFile(file, copyChan, finisherChan)
+	f.handleFile(file, copyChan, finisherChan)
 
 	// Receive at finisher, we should error out as puller has nowhere to pull
 	// from.
@@ -451,7 +433,7 @@ func TestDeregisterOnFailInPull(t *testing.T) {
 	case state := <-finisherBufferChan:
 		// At this point the file should still be registered with both the job
 		// queue, and the progress emitter. Verify this.
-		if p.model.progressEmitter.lenRegistry() != 1 || p.queue.lenProgress() != 1 || p.queue.lenQueued() != 0 {
+		if f.model.progressEmitter.lenRegistry() != 1 || f.queue.lenProgress() != 1 || f.queue.lenQueued() != 0 {
 			t.Fatal("Could not find file")
 		}
 
@@ -466,16 +448,16 @@ func TestDeregisterOnFailInPull(t *testing.T) {
 			t.Fatal("File not closed?")
 		}
 
-		if p.model.progressEmitter.lenRegistry() != 0 || p.queue.lenProgress() != 0 || p.queue.lenQueued() != 0 {
-			t.Fatal("Still registered", p.model.progressEmitter.lenRegistry(), p.queue.lenProgress(), p.queue.lenQueued())
+		if f.model.progressEmitter.lenRegistry() != 0 || f.queue.lenProgress() != 0 || f.queue.lenQueued() != 0 {
+			t.Fatal("Still registered", f.model.progressEmitter.lenRegistry(), f.queue.lenProgress(), f.queue.lenQueued())
 		}
 
 		// Doing it again should have no effect
 		finisherChan <- state
 		time.Sleep(100 * time.Millisecond)
 
-		if p.model.progressEmitter.lenRegistry() != 0 || p.queue.lenProgress() != 0 || p.queue.lenQueued() != 0 {
-			t.Fatal("Still registered", p.model.progressEmitter.lenRegistry(), p.queue.lenProgress(), p.queue.lenQueued())
+		if f.model.progressEmitter.lenRegistry() != 0 || f.queue.lenProgress() != 0 || f.queue.lenQueued() != 0 {
+			t.Fatal("Still registered", f.model.progressEmitter.lenRegistry(), f.queue.lenProgress(), f.queue.lenQueued())
 		}
 	case <-time.After(time.Second):
 		t.Fatal("Didn't get anything to the finisher")
