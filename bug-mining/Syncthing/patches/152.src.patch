diff --git a/cmd/syncthing/gui.go b/cmd/syncthing/gui.go
index 6ee627d46..98a809334 100644
--- a/cmd/syncthing/gui.go
+++ b/cmd/syncthing/gui.go
@@ -73,7 +73,8 @@ func startGUI(cfg config.GUIConfiguration, assetDir string, m *model.Model) erro
 
 		// When generating the HTTPS certificate, use the system host name per
 		// default. If that isn't available, use the "syncthing" default.
-		name, err := os.Hostname()
+		var name string
+		name, err = os.Hostname()
 		if err != nil {
 			name = tlsDefaultCommonName
 		}
diff --git a/test/cli_test.go b/test/cli_test.go
index 6cefdaed6..78c0deb53 100644
--- a/test/cli_test.go
+++ b/test/cli_test.go
@@ -21,6 +21,7 @@ import (
 	"os"
 	"os/exec"
 	"testing"
+	"time"
 )
 
 func TestCLIReset(t *testing.T) {
@@ -80,3 +81,63 @@ func TestCLIGenerate(t *testing.T) {
 		}
 	}
 }
+
+func TestCLIFirstStartup(t *testing.T) {
+	err := os.RemoveAll("home.out")
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	// First startup should create config, BEP certificate, and HTTP certificate.
+
+	cmd := exec.Command("../bin/syncthing", "-home", "home.out")
+	cmd.Env = append(os.Environ(), "STNORESTART=1")
+	cmd.Stdout = os.Stdout
+	cmd.Stderr = os.Stdout
+	err = cmd.Start()
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	exitError := make(chan error, 1)
+	filesOk := make(chan struct{})
+	processDone := make(chan struct{})
+
+	go func() {
+		// Wait for process exit.
+		exitError <- cmd.Wait()
+		close(processDone)
+	}()
+
+	go func() {
+	again:
+		for {
+			select {
+			case <-processDone:
+				return
+			default:
+				// Verify that the files that should have been created have been
+				for _, f := range []string{"home.out/config.xml", "home.out/cert.pem", "home.out/key.pem", "home.out/https-cert.pem", "home.out/https-key.pem"} {
+					_, err := os.Stat(f)
+					if err != nil {
+						time.Sleep(500 * time.Millisecond)
+						continue again
+					}
+				}
+
+				// Make sure the process doesn't exit with an error just after creating certificates.
+				time.Sleep(time.Second)
+				filesOk <- struct{}{}
+				return
+			}
+		}
+	}()
+
+	select {
+	case e := <-exitError:
+		t.Error(e)
+	case <-filesOk:
+		cmd.Process.Kill()
+		return
+	}
+}
