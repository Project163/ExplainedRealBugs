diff --git a/lib/ignore/ignore.go b/lib/ignore/ignore.go
index 58d8ed71b..7578446ba 100644
--- a/lib/ignore/ignore.go
+++ b/lib/ignore/ignore.go
@@ -545,6 +545,14 @@ func parseIgnoreFile(fs fs.Filesystem, fd io.Reader, currentFile string, cd Chan
 
 // WriteIgnores is a convenience function to avoid code duplication
 func WriteIgnores(filesystem fs.Filesystem, path string, content []string) error {
+	if len(content) == 0 {
+		err := filesystem.Remove(path)
+		if fs.IsNotExist(err) {
+			return nil
+		}
+		return err
+	}
+
 	fd, err := osutil.CreateAtomicFilesystem(filesystem, path)
 	if err != nil {
 		return err
diff --git a/lib/model/model_test.go b/lib/model/model_test.go
index aee4991e4..dae429bad 100644
--- a/lib/model/model_test.go
+++ b/lib/model/model_test.go
@@ -1514,6 +1514,41 @@ func TestIgnores(t *testing.T) {
 	changeIgnores(t, m, []string{})
 }
 
+func TestEmptyIgnores(t *testing.T) {
+	testOs := &fatalOs{t}
+
+	// Assure a clean start state
+	testOs.RemoveAll(filepath.Join("testdata", config.DefaultMarkerName))
+	testOs.MkdirAll(filepath.Join("testdata", config.DefaultMarkerName), 0644)
+
+	m := setupModel(defaultCfgWrapper)
+	defer cleanupModel(m)
+
+	m.removeFolder(defaultFolderConfig)
+	m.addFolder(defaultFolderConfig)
+
+	if err := m.SetIgnores("default", []string{}); err != nil {
+		t.Error(err)
+	}
+	if _, err := os.Stat("testdata/.stignore"); err == nil {
+		t.Error(".stignore was created despite being empty")
+	}
+
+	if err := m.SetIgnores("default", []string{".*", "quux"}); err != nil {
+		t.Error(err)
+	}
+	if _, err := os.Stat("testdata/.stignore"); os.IsNotExist(err) {
+		t.Error(".stignore does not exist")
+	}
+
+	if err := m.SetIgnores("default", []string{}); err != nil {
+		t.Error(err)
+	}
+	if _, err := os.Stat("testdata/.stignore"); err == nil {
+		t.Error(".stignore should have been deleted because it is empty")
+	}
+}
+
 func waitForState(t *testing.T, m *model, folder, status string) {
 	t.Helper()
 	timeout := time.Now().Add(2 * time.Second)
