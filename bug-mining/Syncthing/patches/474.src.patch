diff --git a/lib/ignore/ignore_test.go b/lib/ignore/ignore_test.go
index 1696f019b..bad9be6ff 100644
--- a/lib/ignore/ignore_test.go
+++ b/lib/ignore/ignore_test.go
@@ -703,3 +703,18 @@ func TestIssue3164(t *testing.T) {
 		}
 	}
 }
+
+func TestIssue3174(t *testing.T) {
+	stignore := `
+	*ä*
+	`
+	pats := New(true)
+	err := pats.Parse(bytes.NewBufferString(stignore), ".stignore")
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	if !pats.Match("åäö").IsIgnored() {
+		t.Error("Should match")
+	}
+}
diff --git a/vendor/github.com/gobwas/glob/compiler.go b/vendor/github.com/gobwas/glob/compiler.go
index 16c241b6b..bc485599e 100644
--- a/vendor/github.com/gobwas/glob/compiler.go
+++ b/vendor/github.com/gobwas/glob/compiler.go
@@ -385,20 +385,25 @@ func compileMatchers(matchers []match.Matcher) (match.Matcher, error) {
 		return m, nil
 	}
 
-	var (
-		val match.Matcher
-		idx int
-	)
+	idx := -1
 	maxLen := -1
+	var val match.Matcher
 	for i, matcher := range matchers {
-		l := matcher.Len()
-		if l >= maxLen {
+		if l := matcher.Len(); l != -1 && l >= maxLen {
 			maxLen = l
 			idx = i
 			val = matcher
 		}
 	}
 
+	if val == nil { // not found matcher with static length
+		r, err := compileMatchers(matchers[1:])
+		if err != nil {
+			return nil, err
+		}
+		return match.NewBTree(matchers[0], nil, r), nil
+	}
+
 	left := matchers[:idx]
 	var right []match.Matcher
 	if len(matchers) > idx+1 {
@@ -424,74 +429,8 @@ func compileMatchers(matchers []match.Matcher) (match.Matcher, error) {
 	return match.NewBTree(val, l, r), nil
 }
 
-//func complexity(m match.Matcher) int {
-//	var matchers []match.Matcher
-//	var k int
-//
-//	switch matcher := m.(type) {
-//
-//	case match.Nothing:
-//		return 0
-//
-//	case match.Max, match.Range, match.Suffix, match.Text:
-//		return 1
-//
-//	case match.PrefixSuffix, match.Single, match.Row:
-//		return 2
-//
-//	case match.Any, match.Contains, match.List, match.Min, match.Prefix, match.Super:
-//		return 4
-//
-//	case match.BTree:
-//		matchers = append(matchers, matcher.Value)
-//		if matcher.Left != nil {
-//			matchers = append(matchers, matcher.Left)
-//		}
-//		if matcher.Right != nil {
-//			matchers = append(matchers, matcher.Right)
-//		}
-//		k = 1
-//
-//	case match.AnyOf:
-//		matchers = matcher.Matchers
-//		k = 1
-//	case match.EveryOf:
-//		matchers = matcher.Matchers
-//		k = 1
-//
-//	default:
-//		return 0
-//	}
-//
-//	var sum int
-//	for _, m := range matchers {
-//		sum += complexity(m)
-//	}
-//
-//	return sum * k
-//}
-
-func doAnyOf(n *nodeAnyOf, s []rune) (match.Matcher, error) {
-	var matchers []match.Matcher
-	for _, desc := range n.children() {
-		if desc == nil {
-			matchers = append(matchers, match.NewNothing())
-			continue
-		}
-
-		m, err := do(desc, s)
-		if err != nil {
-			return nil, err
-		}
-		matchers = append(matchers, optimize(m))
-	}
-
-	return match.NewAnyOf(matchers...), nil
-}
-
 func do(leaf node, s []rune) (m match.Matcher, err error) {
 	switch n := leaf.(type) {
-
 	case *nodeAnyOf:
 		// todo this could be faster on pattern_alternatives_combine_lite
 		if n := minimizeAnyOf(n.children()); n != nil {
@@ -559,120 +498,7 @@ func do(leaf node, s []rune) (m match.Matcher, err error) {
 	return optimize(m), nil
 }
 
-func do2(node node, s []rune) ([]match.Matcher, error) {
-	var result []match.Matcher
-
-	switch n := node.(type) {
-
-	case *nodePattern:
-		ways := [][]match.Matcher{[]match.Matcher{}}
-
-		for _, desc := range node.children() {
-			variants, err := do2(desc, s)
-			if err != nil {
-				return nil, err
-			}
-
-			fmt.Println("variants pat", variants)
-
-			for i, l := 0, len(ways); i < l; i++ {
-				for i := 0; i < len(variants); i++ {
-					o := optimize(variants[i])
-					if i == len(variants)-1 {
-						ways[i] = append(ways[i], o)
-					} else {
-						var w []match.Matcher
-						copy(w, ways[i])
-						ways = append(ways, append(w, o))
-					}
-				}
-			}
-
-			fmt.Println("ways pat", ways)
-		}
-
-		for _, matchers := range ways {
-			c, err := compileMatchers(minimizeMatchers(matchers))
-			if err != nil {
-				return nil, err
-			}
-			result = append(result, c)
-		}
-
-	case *nodeAnyOf:
-		ways := make([][]match.Matcher, len(node.children()))
-		for _, desc := range node.children() {
-			variants, err := do2(desc, s)
-			if err != nil {
-				return nil, err
-			}
-
-			fmt.Println("variants any", variants)
-
-			for x, l := 0, len(ways); x < l; x++ {
-				for i := 0; i < len(variants); i++ {
-					o := optimize(variants[i])
-					if i == len(variants)-1 {
-						ways[x] = append(ways[x], o)
-					} else {
-						var w []match.Matcher
-						copy(w, ways[x])
-						ways = append(ways, append(w, o))
-					}
-				}
-			}
-
-			fmt.Println("ways any", ways)
-		}
-
-		for _, matchers := range ways {
-			c, err := compileMatchers(minimizeMatchers(matchers))
-			if err != nil {
-				return nil, err
-			}
-			result = append(result, c)
-		}
-
-	case *nodeList:
-		result = append(result, match.NewList([]rune(n.chars), n.not))
-
-	case *nodeRange:
-		result = append(result, match.NewRange(n.lo, n.hi, n.not))
-
-	case *nodeAny:
-		result = append(result, match.NewAny(s))
-
-	case *nodeSuper:
-		result = append(result, match.NewSuper())
-
-	case *nodeSingle:
-		result = append(result, match.NewSingle(s))
-
-	case *nodeText:
-		result = append(result, match.NewText(n.text))
-
-	default:
-		return nil, fmt.Errorf("could not compile tree: unknown node type")
-	}
-
-	for i, m := range result {
-		result[i] = optimize(m)
-	}
-
-	return result, nil
-}
-
 func compile(ast *nodePattern, s []rune) (Glob, error) {
-	//	ms, err := do2(ast, s)
-	//	if err != nil {
-	//		return nil, err
-	//	}
-	//	if len(ms) == 1 {
-	//		return ms[0], nil
-	//	} else {
-	//		return match.NewAnyOf(ms), nil
-	//	}
-
 	g, err := do(ast, s)
 	if err != nil {
 		return nil, err
diff --git a/vendor/github.com/gobwas/glob/compiler_test.go b/vendor/github.com/gobwas/glob/compiler_test.go
deleted file mode 100644
index f2d0c709f..000000000
--- a/vendor/github.com/gobwas/glob/compiler_test.go
+++ /dev/null
@@ -1,546 +0,0 @@
-package glob
-
-import (
-	"github.com/gobwas/glob/match"
-	"reflect"
-	"testing"
-)
-
-var separators = []rune{'.'}
-
-func TestGlueMatchers(t *testing.T) {
-	for id, test := range []struct {
-		in  []match.Matcher
-		exp match.Matcher
-	}{
-		{
-			[]match.Matcher{
-				match.NewSuper(),
-				match.NewSingle(nil),
-			},
-			match.NewMin(1),
-		},
-		{
-			[]match.Matcher{
-				match.NewAny(separators),
-				match.NewSingle(separators),
-			},
-			match.EveryOf{match.Matchers{
-				match.NewMin(1),
-				match.NewContains(string(separators), true),
-			}},
-		},
-		{
-			[]match.Matcher{
-				match.NewSingle(nil),
-				match.NewSingle(nil),
-				match.NewSingle(nil),
-			},
-			match.EveryOf{match.Matchers{
-				match.NewMin(3),
-				match.NewMax(3),
-			}},
-		},
-		{
-			[]match.Matcher{
-				match.NewList([]rune{'a'}, true),
-				match.NewAny([]rune{'a'}),
-			},
-			match.EveryOf{match.Matchers{
-				match.NewMin(1),
-				match.NewContains("a", true),
-			}},
-		},
-	} {
-		act, err := compileMatchers(test.in)
-		if err != nil {
-			t.Errorf("#%d convert matchers error: %s", id, err)
-			continue
-		}
-
-		if !reflect.DeepEqual(act, test.exp) {
-			t.Errorf("#%d unexpected convert matchers result:\nact: %#v;\nexp: %#v", id, act, test.exp)
-			continue
-		}
-	}
-}
-
-func TestCompileMatchers(t *testing.T) {
-	for id, test := range []struct {
-		in  []match.Matcher
-		exp match.Matcher
-	}{
-		{
-			[]match.Matcher{
-				match.NewSuper(),
-				match.NewSingle(separators),
-				match.NewText("c"),
-			},
-			match.NewBTree(
-				match.NewText("c"),
-				match.NewBTree(
-					match.NewSingle(separators),
-					match.NewSuper(),
-					nil,
-				),
-				nil,
-			),
-		},
-		{
-			[]match.Matcher{
-				match.NewAny(nil),
-				match.NewText("c"),
-				match.NewAny(nil),
-			},
-			match.NewBTree(
-				match.NewText("c"),
-				match.NewAny(nil),
-				match.NewAny(nil),
-			),
-		},
-		{
-			[]match.Matcher{
-				match.NewRange('a', 'c', true),
-				match.NewList([]rune{'z', 't', 'e'}, false),
-				match.NewText("c"),
-				match.NewSingle(nil),
-			},
-			match.NewRow(
-				4,
-				match.Matchers{
-					match.NewRange('a', 'c', true),
-					match.NewList([]rune{'z', 't', 'e'}, false),
-					match.NewText("c"),
-					match.NewSingle(nil),
-				}...,
-			),
-		},
-	} {
-		act, err := compileMatchers(test.in)
-		if err != nil {
-			t.Errorf("#%d convert matchers error: %s", id, err)
-			continue
-		}
-
-		if !reflect.DeepEqual(act, test.exp) {
-			t.Errorf("#%d unexpected convert matchers result:\nact: %#v\nexp: %#v", id, act, test.exp)
-			continue
-		}
-	}
-}
-
-func TestConvertMatchers(t *testing.T) {
-	for id, test := range []struct {
-		in, exp []match.Matcher
-	}{
-		{
-			[]match.Matcher{
-				match.NewRange('a', 'c', true),
-				match.NewList([]rune{'z', 't', 'e'}, false),
-				match.NewText("c"),
-				match.NewSingle(nil),
-				match.NewAny(nil),
-			},
-			[]match.Matcher{
-				match.NewRow(
-					4,
-					[]match.Matcher{
-						match.NewRange('a', 'c', true),
-						match.NewList([]rune{'z', 't', 'e'}, false),
-						match.NewText("c"),
-						match.NewSingle(nil),
-					}...,
-				),
-				match.NewAny(nil),
-			},
-		},
-		{
-			[]match.Matcher{
-				match.NewRange('a', 'c', true),
-				match.NewList([]rune{'z', 't', 'e'}, false),
-				match.NewText("c"),
-				match.NewSingle(nil),
-				match.NewAny(nil),
-				match.NewSingle(nil),
-				match.NewSingle(nil),
-				match.NewAny(nil),
-			},
-			[]match.Matcher{
-				match.NewRow(
-					3,
-					match.Matchers{
-						match.NewRange('a', 'c', true),
-						match.NewList([]rune{'z', 't', 'e'}, false),
-						match.NewText("c"),
-					}...,
-				),
-				match.NewMin(3),
-			},
-		},
-	} {
-		act := minimizeMatchers(test.in)
-		if !reflect.DeepEqual(act, test.exp) {
-			t.Errorf("#%d unexpected convert matchers 2 result:\nact: %#v\nexp: %#v", id, act, test.exp)
-			continue
-		}
-	}
-}
-
-func pattern(nodes ...node) *nodePattern {
-	return &nodePattern{
-		nodeImpl: nodeImpl{
-			desc: nodes,
-		},
-	}
-}
-func anyOf(nodes ...node) *nodeAnyOf {
-	return &nodeAnyOf{
-		nodeImpl: nodeImpl{
-			desc: nodes,
-		},
-	}
-}
-func TestCompiler(t *testing.T) {
-	for id, test := range []struct {
-		ast    *nodePattern
-		result Glob
-		sep    []rune
-	}{
-		{
-			ast:    pattern(&nodeText{text: "abc"}),
-			result: match.NewText("abc"),
-		},
-		{
-			ast:    pattern(&nodeAny{}),
-			sep:    separators,
-			result: match.NewAny(separators),
-		},
-		{
-			ast:    pattern(&nodeAny{}),
-			result: match.NewSuper(),
-		},
-		{
-			ast:    pattern(&nodeSuper{}),
-			result: match.NewSuper(),
-		},
-		{
-			ast:    pattern(&nodeSingle{}),
-			sep:    separators,
-			result: match.NewSingle(separators),
-		},
-		{
-			ast: pattern(&nodeRange{
-				lo:  'a',
-				hi:  'z',
-				not: true,
-			}),
-			result: match.NewRange('a', 'z', true),
-		},
-		{
-			ast: pattern(&nodeList{
-				chars: "abc",
-				not:   true,
-			}),
-			result: match.NewList([]rune{'a', 'b', 'c'}, true),
-		},
-		{
-			ast: pattern(&nodeAny{}, &nodeSingle{}, &nodeSingle{}, &nodeSingle{}),
-			sep: separators,
-			result: match.EveryOf{Matchers: match.Matchers{
-				match.NewMin(3),
-				match.NewContains(string(separators), true),
-			}},
-		},
-		{
-			ast:    pattern(&nodeAny{}, &nodeSingle{}, &nodeSingle{}, &nodeSingle{}),
-			result: match.NewMin(3),
-		},
-		{
-			ast: pattern(&nodeAny{}, &nodeText{text: "abc"}, &nodeSingle{}),
-			sep: separators,
-			result: match.NewBTree(
-				match.NewRow(
-					4,
-					match.Matchers{
-						match.NewText("abc"),
-						match.NewSingle(separators),
-					}...,
-				),
-				match.NewAny(separators),
-				nil,
-			),
-		},
-		{
-			ast: pattern(&nodeSuper{}, &nodeSingle{}, &nodeText{text: "abc"}, &nodeSingle{}),
-			sep: separators,
-			result: match.NewBTree(
-				match.NewRow(
-					5,
-					match.Matchers{
-						match.NewSingle(separators),
-						match.NewText("abc"),
-						match.NewSingle(separators),
-					}...,
-				),
-				match.NewSuper(),
-				nil,
-			),
-		},
-		{
-			ast:    pattern(&nodeAny{}, &nodeText{text: "abc"}),
-			result: match.NewSuffix("abc"),
-		},
-		{
-			ast:    pattern(&nodeText{text: "abc"}, &nodeAny{}),
-			result: match.NewPrefix("abc"),
-		},
-		{
-			ast:    pattern(&nodeText{text: "abc"}, &nodeAny{}, &nodeText{text: "def"}),
-			result: match.NewPrefixSuffix("abc", "def"),
-		},
-		{
-			ast:    pattern(&nodeAny{}, &nodeAny{}, &nodeAny{}, &nodeText{text: "abc"}, &nodeAny{}, &nodeAny{}),
-			result: match.NewContains("abc", false),
-		},
-		{
-			ast: pattern(&nodeAny{}, &nodeAny{}, &nodeAny{}, &nodeText{text: "abc"}, &nodeAny{}, &nodeAny{}),
-			sep: separators,
-			result: match.NewBTree(
-				match.NewText("abc"),
-				match.NewAny(separators),
-				match.NewAny(separators),
-			),
-		},
-		{
-			ast: pattern(&nodeSuper{}, &nodeSingle{}, &nodeText{text: "abc"}, &nodeSuper{}, &nodeSingle{}),
-			result: match.NewBTree(
-				match.NewText("abc"),
-				match.NewMin(1),
-				match.NewMin(1),
-			),
-		},
-		{
-			ast:    pattern(anyOf(&nodeText{text: "abc"})),
-			result: match.NewText("abc"),
-		},
-		{
-			ast:    pattern(anyOf(pattern(anyOf(pattern(&nodeText{text: "abc"}))))),
-			result: match.NewText("abc"),
-		},
-		{
-			ast: pattern(anyOf(
-				pattern(
-					&nodeText{text: "abc"},
-					&nodeSingle{},
-				),
-				pattern(
-					&nodeText{text: "abc"},
-					&nodeList{chars: "def"},
-				),
-				pattern(
-					&nodeText{text: "abc"},
-				),
-				pattern(
-					&nodeText{text: "abc"},
-				),
-			)),
-			result: match.NewBTree(
-				match.NewText("abc"),
-				nil,
-				match.AnyOf{Matchers: match.Matchers{
-					match.NewSingle(nil),
-					match.NewList([]rune{'d', 'e', 'f'}, false),
-					match.NewNothing(),
-				}},
-			),
-		},
-		{
-			ast: pattern(
-				&nodeRange{lo: 'a', hi: 'z'},
-				&nodeRange{lo: 'a', hi: 'x', not: true},
-				&nodeAny{},
-			),
-			result: match.NewBTree(
-				match.NewRow(
-					2,
-					match.Matchers{
-						match.NewRange('a', 'z', false),
-						match.NewRange('a', 'x', true),
-					}...,
-				),
-				nil,
-				match.NewSuper(),
-			),
-		},
-		{
-			ast: pattern(anyOf(
-				pattern(
-					&nodeText{text: "abc"},
-					&nodeList{chars: "abc"},
-					&nodeText{text: "ghi"},
-				),
-				pattern(
-					&nodeText{text: "abc"},
-					&nodeList{chars: "def"},
-					&nodeText{text: "ghi"},
-				),
-			)),
-			result: match.NewRow(
-				7,
-				match.Matchers{
-					match.NewText("abc"),
-					match.AnyOf{Matchers: match.Matchers{
-						match.NewList([]rune{'a', 'b', 'c'}, false),
-						match.NewList([]rune{'d', 'e', 'f'}, false),
-					}},
-					match.NewText("ghi"),
-				}...,
-			),
-		},
-		//				{
-		//			ast: pattern(
-		//				anyOf(&nodeText{text: "a"}, &nodeText{text: "b"}),
-		//				anyOf(&nodeText{text: "c"}, &nodeText{text: "d"}),
-		//			),
-		//			result: match.AnyOf{Matchers: match.Matchers{
-		//				match.NewRow(Matchers: match.Matchers{match.Raw{"a"}, match.Raw{"c", 1}}),
-		//				match.NewRow(Matchers: match.Matchers{match.Raw{"a"}, match.Raw{"d"}}),
-		//				match.NewRow(Matchers: match.Matchers{match.Raw{"b"}, match.Raw{"c", 1}}),
-		//				match.NewRow(Matchers: match.Matchers{match.Raw{"b"}, match.Raw{"d"}}),
-		//			}},
-		//		},
-	} {
-		m, err := compile(test.ast, test.sep)
-		if err != nil {
-			t.Errorf("compilation error: %s", err)
-			continue
-		}
-
-		if !reflect.DeepEqual(m, test.result) {
-			t.Errorf("#%d results are not equal:\nexp: %#v\nact: %#v", id, test.result, m)
-			continue
-		}
-	}
-}
-
-const complexityString = "abcd"
-
-//func BenchmarkComplexityAny(b *testing.B) {
-//	m := match.NewAny(nil)
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityContains(b *testing.B) {
-//	m := match.NewContains()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityList(b *testing.B) {
-//	m := match.NewList()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityMax(b *testing.B) {
-//	m := match.NewMax()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityMin(b *testing.B) {
-//	m := match.NewMin()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityNothing(b *testing.B) {
-//	m := match.NewNothing()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityPrefix(b *testing.B) {
-//	m := match.NewPrefix()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityPrefixSuffix(b *testing.B) {
-//	m := match.NewPrefixSuffix()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityRange(b *testing.B) {
-//	m := match.NewRange()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityRow(b *testing.B) {
-//	m := match.NewRow()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexitySingle(b *testing.B) {
-//	m := match.NewSingle(nil)
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexitySuffix(b *testing.B) {
-//	m := match.NewSuffix()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexitySuper(b *testing.B) {
-//	m := match.NewSuper()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityText(b *testing.B) {
-//	m := match.NewText()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityAnyOf(b *testing.B) {
-//	m := match.NewAnyOf()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityBTree(b *testing.B) {
-//	m := match.NewBTree(match.NewText("abc"), match.NewText("d"), match.NewText("e"))
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
-//func BenchmarkComplexityEveryOf(b *testing.B) {
-//	m := match.NewEveryOf()
-//	for i := 0; i < b.N; i++ {
-//		_ = m.Match(complexityString)
-//		_, _ = m.Index(complexityString)
-//	}
-//}
diff --git a/vendor/github.com/gobwas/glob/glob_test.go b/vendor/github.com/gobwas/glob/glob_test.go
deleted file mode 100644
index 6fe73a629..000000000
--- a/vendor/github.com/gobwas/glob/glob_test.go
+++ /dev/null
@@ -1,507 +0,0 @@
-package glob
-
-import (
-	"regexp"
-	"testing"
-)
-
-const (
-	pattern_all          = "[a-z][!a-x]*cat*[h][!b]*eyes*"
-	regexp_all           = `^[a-z][^a-x].*cat.*[h][^b].*eyes.*$`
-	fixture_all_match    = "my cat has very bright eyes"
-	fixture_all_mismatch = "my dog has very bright eyes"
-
-	pattern_plain          = "google.com"
-	regexp_plain           = `^google\.com$`
-	fixture_plain_match    = "google.com"
-	fixture_plain_mismatch = "gobwas.com"
-
-	pattern_multiple          = "https://*.google.*"
-	regexp_multiple           = `^https:\/\/.*\.google\..*$`
-	fixture_multiple_match    = "https://account.google.com"
-	fixture_multiple_mismatch = "https://google.com"
-
-	pattern_alternatives          = "{https://*.google.*,*yandex.*,*yahoo.*,*mail.ru}"
-	regexp_alternatives           = `^(https:\/\/.*\.google\..*|.*yandex\..*|.*yahoo\..*|.*mail\.ru)$`
-	fixture_alternatives_match    = "http://yahoo.com"
-	fixture_alternatives_mismatch = "http://google.com"
-
-	pattern_alternatives_suffix                = "{https://*gobwas.com,http://exclude.gobwas.com}"
-	regexp_alternatives_suffix                 = `^(https:\/\/.*gobwas\.com|http://exclude.gobwas.com)$`
-	fixture_alternatives_suffix_first_match    = "https://safe.gobwas.com"
-	fixture_alternatives_suffix_first_mismatch = "http://safe.gobwas.com"
-	fixture_alternatives_suffix_second         = "http://exclude.gobwas.com"
-
-	pattern_prefix                 = "abc*"
-	regexp_prefix                  = `^abc.*$`
-	pattern_suffix                 = "*def"
-	regexp_suffix                  = `^.*def$`
-	pattern_prefix_suffix          = "ab*ef"
-	regexp_prefix_suffix           = `^ab.*ef$`
-	fixture_prefix_suffix_match    = "abcdef"
-	fixture_prefix_suffix_mismatch = "af"
-
-	pattern_alternatives_combine_lite = "{abc*def,abc?def,abc[zte]def}"
-	regexp_alternatives_combine_lite  = `^(abc.*def|abc.def|abc[zte]def)$`
-	fixture_alternatives_combine_lite = "abczdef"
-
-	pattern_alternatives_combine_hard = "{abc*[a-c]def,abc?[d-g]def,abc[zte]?def}"
-	regexp_alternatives_combine_hard  = `^(abc.*[a-c]def|abc.[d-g]def|abc[zte].def)$`
-	fixture_alternatives_combine_hard = "abczqdef"
-)
-
-type test struct {
-	pattern, match string
-	should         bool
-	delimiters     []rune
-}
-
-func glob(s bool, p, m string, d ...rune) test {
-	return test{p, m, s, d}
-}
-
-func TestGlob(t *testing.T) {
-	for _, test := range []test{
-		glob(true, "* ?at * eyes", "my cat has very bright eyes"),
-
-		glob(true, "abc", "abc"),
-		glob(true, "a*c", "abc"),
-		glob(true, "a*c", "a12345c"),
-		glob(true, "a?c", "a1c"),
-		glob(true, "a.b", "a.b", '.'),
-		glob(true, "a.*", "a.b", '.'),
-		glob(true, "a.**", "a.b.c", '.'),
-		glob(true, "a.?.c", "a.b.c", '.'),
-		glob(true, "a.?.?", "a.b.c", '.'),
-		glob(true, "?at", "cat"),
-		glob(true, "?at", "fat"),
-		glob(true, "*", "abc"),
-		glob(true, `\*`, "*"),
-		glob(true, "**", "a.b.c", '.'),
-
-		glob(false, "?at", "at"),
-		glob(false, "?at", "fat", 'f'),
-		glob(false, "a.*", "a.b.c", '.'),
-		glob(false, "a.?.c", "a.bb.c", '.'),
-		glob(false, "*", "a.b.c", '.'),
-
-		glob(true, "*test", "this is a test"),
-		glob(true, "this*", "this is a test"),
-		glob(true, "*is *", "this is a test"),
-		glob(true, "*is*a*", "this is a test"),
-		glob(true, "**test**", "this is a test"),
-		glob(true, "**is**a***test*", "this is a test"),
-
-		glob(false, "*is", "this is a test"),
-		glob(false, "*no*", "this is a test"),
-		glob(true, "[!a]*", "this is a test3"),
-
-		glob(true, "*abc", "abcabc"),
-		glob(true, "**abc", "abcabc"),
-		glob(true, "???", "abc"),
-		glob(true, "?*?", "abc"),
-		glob(true, "?*?", "ac"),
-
-		glob(true, "{abc,def}ghi", "defghi"),
-		glob(true, "{abc,abcd}a", "abcda"),
-		glob(true, "{a,ab}{bc,f}", "abc"),
-		glob(true, "{*,**}{a,b}", "ab"),
-		glob(false, "{*,**}{a,b}", "ac"),
-
-		glob(true, pattern_all, fixture_all_match),
-		glob(false, pattern_all, fixture_all_mismatch),
-
-		glob(true, pattern_plain, fixture_plain_match),
-		glob(false, pattern_plain, fixture_plain_mismatch),
-
-		glob(true, pattern_multiple, fixture_multiple_match),
-		glob(false, pattern_multiple, fixture_multiple_mismatch),
-
-		glob(true, pattern_alternatives, fixture_alternatives_match),
-		glob(false, pattern_alternatives, fixture_alternatives_mismatch),
-
-		glob(true, pattern_alternatives_suffix, fixture_alternatives_suffix_first_match),
-		glob(false, pattern_alternatives_suffix, fixture_alternatives_suffix_first_mismatch),
-		glob(true, pattern_alternatives_suffix, fixture_alternatives_suffix_second),
-
-		glob(true, pattern_alternatives_combine_hard, fixture_alternatives_combine_hard),
-
-		glob(true, pattern_alternatives_combine_lite, fixture_alternatives_combine_lite),
-
-		glob(true, pattern_prefix, fixture_prefix_suffix_match),
-		glob(false, pattern_prefix, fixture_prefix_suffix_mismatch),
-
-		glob(true, pattern_suffix, fixture_prefix_suffix_match),
-		glob(false, pattern_suffix, fixture_prefix_suffix_mismatch),
-
-		glob(true, pattern_prefix_suffix, fixture_prefix_suffix_match),
-		glob(false, pattern_prefix_suffix, fixture_prefix_suffix_mismatch),
-	} {
-		g, err := Compile(test.pattern, test.delimiters...)
-		if err != nil {
-			t.Errorf("parsing pattern %q error: %s", test.pattern, err)
-			continue
-		}
-
-		result := g.Match(test.match)
-		if result != test.should {
-			t.Errorf("pattern %q matching %q should be %v but got %v\n%s", test.pattern, test.match, test.should, result, g)
-		}
-	}
-}
-
-func TestQuoteMeta(t *testing.T) {
-	specialsQuoted := make([]byte, len(specials)*2)
-	for i, j := 0, 0; i < len(specials); i, j = i+1, j+2 {
-		specialsQuoted[j] = '\\'
-		specialsQuoted[j+1] = specials[i]
-	}
-
-	for id, test := range []struct {
-		in, out string
-	}{
-		{
-			in:  `[foo*]`,
-			out: `\[foo\*\]`,
-		},
-		{
-			in:  string(specials),
-			out: string(specialsQuoted),
-		},
-		{
-			in:  string(append([]byte("some text and"), specials...)),
-			out: string(append([]byte("some text and"), specialsQuoted...)),
-		},
-	} {
-		act := QuoteMeta(test.in)
-		if act != test.out {
-			t.Errorf("#%d QuoteMeta(%q) = %q; want %q", id, test.in, act, test.out)
-		}
-		if _, err := Compile(act); err != nil {
-			t.Errorf("#%d _, err := Compile(QuoteMeta(%q) = %q); err = %q", id, test.in, act, err)
-		}
-	}
-}
-
-func BenchmarkParseGlob(b *testing.B) {
-	for i := 0; i < b.N; i++ {
-		Compile(pattern_all)
-	}
-}
-func BenchmarkParseRegexp(b *testing.B) {
-	for i := 0; i < b.N; i++ {
-		regexp.MustCompile(regexp_all)
-	}
-}
-
-func BenchmarkAllGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_all)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_all_match)
-	}
-}
-func BenchmarkAllGlobMatchParallel(b *testing.B) {
-	m, _ := Compile(pattern_all)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_ = m.Match(fixture_all_match)
-		}
-	})
-}
-
-func BenchmarkAllRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_all)
-	f := []byte(fixture_all_match)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkAllGlobMismatch(b *testing.B) {
-	m, _ := Compile(pattern_all)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_all_mismatch)
-	}
-}
-func BenchmarkAllGlobMismatchParallel(b *testing.B) {
-	m, _ := Compile(pattern_all)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_ = m.Match(fixture_all_mismatch)
-		}
-	})
-}
-func BenchmarkAllRegexpMismatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_all)
-	f := []byte(fixture_all_mismatch)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-
-func BenchmarkMultipleGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_multiple)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_multiple_match)
-	}
-}
-func BenchmarkMultipleRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_multiple)
-	f := []byte(fixture_multiple_match)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkMultipleGlobMismatch(b *testing.B) {
-	m, _ := Compile(pattern_multiple)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_multiple_mismatch)
-	}
-}
-func BenchmarkMultipleRegexpMismatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_multiple)
-	f := []byte(fixture_multiple_mismatch)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-
-func BenchmarkAlternativesGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_alternatives)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_alternatives_match)
-	}
-}
-func BenchmarkAlternativesGlobMismatch(b *testing.B) {
-	m, _ := Compile(pattern_alternatives)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_alternatives_mismatch)
-	}
-}
-func BenchmarkAlternativesRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_alternatives)
-	f := []byte(fixture_alternatives_match)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkAlternativesRegexpMismatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_alternatives)
-	f := []byte(fixture_alternatives_mismatch)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-
-func BenchmarkAlternativesSuffixFirstGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_alternatives_suffix)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_alternatives_suffix_first_match)
-	}
-}
-func BenchmarkAlternativesSuffixFirstGlobMismatch(b *testing.B) {
-	m, _ := Compile(pattern_alternatives_suffix)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_alternatives_suffix_first_mismatch)
-	}
-}
-func BenchmarkAlternativesSuffixSecondGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_alternatives_suffix)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_alternatives_suffix_second)
-	}
-}
-func BenchmarkAlternativesCombineLiteGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_alternatives_combine_lite)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_alternatives_combine_lite)
-	}
-}
-func BenchmarkAlternativesCombineHardGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_alternatives_combine_hard)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_alternatives_combine_hard)
-	}
-}
-func BenchmarkAlternativesSuffixFirstRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_alternatives_suffix)
-	f := []byte(fixture_alternatives_suffix_first_match)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkAlternativesSuffixFirstRegexpMismatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_alternatives_suffix)
-	f := []byte(fixture_alternatives_suffix_first_mismatch)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkAlternativesSuffixSecondRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_alternatives_suffix)
-	f := []byte(fixture_alternatives_suffix_second)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkAlternativesCombineLiteRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_alternatives_combine_lite)
-	f := []byte(fixture_alternatives_combine_lite)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkAlternativesCombineHardRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_alternatives_combine_hard)
-	f := []byte(fixture_alternatives_combine_hard)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-
-func BenchmarkPlainGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_plain)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_plain_match)
-	}
-}
-func BenchmarkPlainRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_plain)
-	f := []byte(fixture_plain_match)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkPlainGlobMismatch(b *testing.B) {
-	m, _ := Compile(pattern_plain)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_plain_mismatch)
-	}
-}
-func BenchmarkPlainRegexpMismatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_plain)
-	f := []byte(fixture_plain_mismatch)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-
-func BenchmarkPrefixGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_prefix)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_prefix_suffix_match)
-	}
-}
-func BenchmarkPrefixRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_prefix)
-	f := []byte(fixture_prefix_suffix_match)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkPrefixGlobMismatch(b *testing.B) {
-	m, _ := Compile(pattern_prefix)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_prefix_suffix_mismatch)
-	}
-}
-func BenchmarkPrefixRegexpMismatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_prefix)
-	f := []byte(fixture_prefix_suffix_mismatch)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-
-func BenchmarkSuffixGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_suffix)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_prefix_suffix_match)
-	}
-}
-func BenchmarkSuffixRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_suffix)
-	f := []byte(fixture_prefix_suffix_match)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkSuffixGlobMismatch(b *testing.B) {
-	m, _ := Compile(pattern_suffix)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_prefix_suffix_mismatch)
-	}
-}
-func BenchmarkSuffixRegexpMismatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_suffix)
-	f := []byte(fixture_prefix_suffix_mismatch)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-
-func BenchmarkPrefixSuffixGlobMatch(b *testing.B) {
-	m, _ := Compile(pattern_prefix_suffix)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_prefix_suffix_match)
-	}
-}
-func BenchmarkPrefixSuffixRegexpMatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_prefix_suffix)
-	f := []byte(fixture_prefix_suffix_match)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
-func BenchmarkPrefixSuffixGlobMismatch(b *testing.B) {
-	m, _ := Compile(pattern_prefix_suffix)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(fixture_prefix_suffix_mismatch)
-	}
-}
-func BenchmarkPrefixSuffixRegexpMismatch(b *testing.B) {
-	m := regexp.MustCompile(regexp_prefix_suffix)
-	f := []byte(fixture_prefix_suffix_mismatch)
-
-	for i := 0; i < b.N; i++ {
-		_ = m.Match(f)
-	}
-}
diff --git a/vendor/github.com/gobwas/glob/lexer.go b/vendor/github.com/gobwas/glob/lexer.go
index 81cfb22d2..9b756dcab 100644
--- a/vendor/github.com/gobwas/glob/lexer.go
+++ b/vendor/github.com/gobwas/glob/lexer.go
@@ -3,7 +3,7 @@ package glob
 import (
 	"bytes"
 	"fmt"
-	"strings"
+	"github.com/gobwas/glob/runes"
 	"unicode/utf8"
 )
 
@@ -34,10 +34,6 @@ func special(c byte) bool {
 	return bytes.IndexByte(specials, c) != -1
 }
 
-var eof rune = 0
-
-type stateFn func(*lexer) stateFn
-
 type itemType int
 
 const (
@@ -120,375 +116,257 @@ type item struct {
 }
 
 func (i item) String() string {
-	return fmt.Sprintf("%v<%s>", i.t, i.s)
+	return fmt.Sprintf("%v<%q>", i.t, i.s)
 }
 
-type lexer struct {
-	input       string
-	start       int
-	pos         int
-	width       int
-	runes       int
-	termScopes  []int
-	termPhrases map[int]int
-	state       stateFn
-	items       chan item
+type stubLexer struct {
+	Items []item
+	pos   int
 }
 
-func newLexer(source string) *lexer {
-	l := &lexer{
-		input:       source,
-		state:       lexRaw,
-		items:       make(chan item, len(source)),
-		termPhrases: make(map[int]int),
+func (s *stubLexer) nextItem() (ret item) {
+	if s.pos == len(s.Items) {
+		return item{item_eof, ""}
 	}
-	return l
-}
-
-func (l *lexer) run() {
-	for state := lexRaw; state != nil; {
-		state = state(l)
-	}
-	close(l.items)
+	ret = s.Items[s.pos]
+	s.pos++
+	return
 }
 
-func (l *lexer) nextItem() item {
-	for {
-		select {
-		case item := <-l.items:
-			return item
-		default:
-			if l.state == nil {
-				return item{t: item_eof}
-			}
+type items []item
 
-			l.state = l.state(l)
-		}
-	}
+func (i *items) shift() (ret item) {
+	ret = (*i)[0]
+	copy(*i, (*i)[1:])
+	*i = (*i)[:len(*i)-1]
+	return
+}
 
-	panic("something went wrong")
+func (i *items) push(v item) {
+	*i = append(*i, v)
 }
 
-func (l *lexer) read() (r rune) {
-	if l.pos >= len(l.input) {
-		return eof
-	}
+func (i *items) empty() bool {
+	return len(*i) == 0
+}
 
-	r, l.width = utf8.DecodeRuneInString(l.input[l.pos:])
-	l.pos += l.width
-	l.runes++
+var eof rune = 0
 
-	return
-}
+type lexer struct {
+	data string
+	pos  int
+	err  error
 
-func (l *lexer) unread() {
-	l.pos -= l.width
-	l.runes--
-}
+	items      items
+	termsLevel int
 
-func (l *lexer) reset() {
-	l.pos = l.start
-	l.runes = 0
+	lastRune     rune
+	lastRuneSize int
+	hasRune      bool
 }
 
-func (l *lexer) ignore() {
-	l.start = l.pos
-	l.runes = 0
+func newLexer(source string) *lexer {
+	l := &lexer{
+		data:  source,
+		items: items(make([]item, 0, 4)),
+	}
+	return l
 }
 
-func (l *lexer) lookahead() rune {
-	r := l.read()
-	if r != eof {
-		l.unread()
+func (l *lexer) peek() (r rune, w int) {
+	if l.pos == len(l.data) {
+		return eof, 0
 	}
-	return r
-}
 
-func (l *lexer) accept(valid string) bool {
-	if strings.IndexRune(valid, l.read()) != -1 {
-		return true
+	r, w = utf8.DecodeRuneInString(l.data[l.pos:])
+	if r == utf8.RuneError {
+		l.errorf("could not read rune")
+		r = eof
+		w = 0
 	}
-	l.unread()
-	return false
+
+	return
 }
 
-func (l *lexer) acceptAll(valid string) {
-	for strings.IndexRune(valid, l.read()) != -1 {
+func (l *lexer) read() rune {
+	if l.hasRune {
+		l.hasRune = false
+		l.seek(l.lastRuneSize)
+		return l.lastRune
 	}
-	l.unread()
+
+	r, s := l.peek()
+	l.seek(s)
+
+	l.lastRune = r
+	l.lastRuneSize = s
+
+	return r
 }
 
-func (l *lexer) emitCurrent(t itemType) {
-	l.emit(t, l.input[l.start:l.pos])
+func (l *lexer) seek(w int) {
+	l.pos += w
 }
 
-func (l *lexer) emit(t itemType, s string) {
-	l.items <- item{t, s}
-	l.start = l.pos
-	l.runes = 0
-	l.width = 0
+func (l *lexer) unread() {
+	if l.hasRune {
+		l.errorf("could not unread rune")
+		return
+	}
+	l.seek(-l.lastRuneSize)
+	l.hasRune = true
 }
 
-func (l *lexer) errorf(format string, args ...interface{}) {
-	l.items <- item{item_error, fmt.Sprintf(format, args...)}
+func (l *lexer) errorf(f string, v ...interface{}) {
+	l.err = fmt.Errorf(f, v...)
 }
 
 func (l *lexer) inTerms() bool {
-	return len(l.termScopes) > 0
+	return l.termsLevel > 0
 }
 
-func lexRaw(l *lexer) stateFn {
-	for {
-		c := l.read()
-		if c == eof {
-			break
-		}
-
-		switch c {
-		case char_single:
-			l.unread()
-			return lexSingle
-
-		case char_any:
-			var n stateFn
-			if l.lookahead() == char_any {
-				n = lexSuper
-			} else {
-				n = lexAny
-			}
-
-			l.unread()
-			return n
-
-		case char_range_open:
-			l.unread()
-			return lexRangeOpen
+func (l *lexer) termsEnter() {
+	l.termsLevel++
+}
 
-		case char_terms_open:
-			l.unread()
-			return lexTermsOpen
+func (l *lexer) termsLeave() {
+	l.termsLevel--
+}
 
-		case char_terms_close:
-			l.unread()
-			return lexTermsClose
+func (l *lexer) nextItem() item {
+	if l.err != nil {
+		return item{item_error, l.err.Error()}
+	}
+	if !l.items.empty() {
+		return l.items.shift()
+	}
 
-		case char_comma:
-			if l.inTerms() { // if we are not in terms
-				l.unread()
-				return lexSeparator
-			}
-			fallthrough
+	l.fetchItem()
+	return l.nextItem()
+}
 
-		default:
-			l.unread()
-			return lexText
-		}
-	}
+var inTextBreakers = []rune{char_single, char_any, char_range_open, char_terms_open}
+var inTermsBreakers = append(inTextBreakers, char_terms_close, char_comma)
 
-	if l.pos > l.start {
-		l.emitCurrent(item_text)
-	}
+func (l *lexer) fetchItem() {
+	r := l.read()
+	switch {
+	case r == eof:
+		l.items.push(item{item_eof, ""})
 
-	if len(l.termScopes) != 0 {
-		l.errorf("invalid pattern syntax: unclosed terms")
-		return nil
-	}
+	case r == char_terms_open:
+		l.termsEnter()
+		l.items.push(item{item_terms_open, string(r)})
 
-	l.emitCurrent(item_eof)
+	case r == char_comma && l.inTerms():
+		l.items.push(item{item_separator, string(r)})
 
-	return nil
-}
+	case r == char_terms_close && l.inTerms():
+		l.items.push(item{item_terms_close, string(r)})
+		l.termsLeave()
 
-func lexText(l *lexer) stateFn {
-	var escaped bool
-	var data []rune
+	case r == char_range_open:
+		l.items.push(item{item_range_open, string(r)})
+		l.fetchRange()
 
-scan:
-	for c := l.read(); c != eof; c = l.read() {
-		switch {
-		case c == char_escape:
-			escaped = true
-			continue
+	case r == char_single:
+		l.items.push(item{item_single, string(r)})
 
-		case !escaped && c == char_comma && l.inTerms():
+	case r == char_any:
+		if l.read() == char_any {
+			l.items.push(item{item_super, string(r) + string(r)})
+		} else {
 			l.unread()
-			break scan
+			l.items.push(item{item_any, string(r)})
+		}
 
-		case !escaped && utf8.RuneLen(c) == 1 && special(byte(c)):
-			l.unread()
-			break scan
+	default:
+		l.unread()
 
-		default:
-			data = append(data, c)
+		var breakers []rune
+		if l.inTerms() {
+			breakers = inTermsBreakers
+		} else {
+			breakers = inTextBreakers
 		}
-
-		escaped = false
+		l.fetchText(breakers)
 	}
-
-	l.emit(item_text, string(data))
-	return lexRaw
 }
 
-func lexInsideRange(l *lexer) stateFn {
+func (l *lexer) fetchRange() {
+	var wantHi bool
+	var wantClose bool
+	var seenNot bool
 	for {
-		c := l.read()
-		if c == eof {
-			l.errorf("unclosed range construction")
-			return nil
+		r := l.read()
+		if r == eof {
+			l.errorf("unexpected end of input")
+			return
 		}
 
-		switch c {
-		case char_range_not:
-			// only first char makes sense
-			if l.pos-l.width == l.start {
-				l.emitCurrent(item_not)
-			}
-
-		case char_range_between:
-			if l.runes != 2 {
-				l.errorf("unexpected length of lo char inside range")
-				return nil
+		if wantClose {
+			if r != char_range_close {
+				l.errorf("expected close range character")
+			} else {
+				l.items.push(item{item_range_close, string(r)})
 			}
+			return
+		}
 
-			l.reset()
-			return lexRangeHiLo
+		if wantHi {
+			l.items.push(item{item_range_hi, string(r)})
+			wantClose = true
+			continue
+		}
 
-		case char_range_close:
-			if l.runes == 1 {
-				l.errorf("range should contain at least single char")
-				return nil
-			}
+		if !seenNot && r == char_range_not {
+			l.items.push(item{item_not, string(r)})
+			seenNot = true
+			continue
+		}
 
-			l.unread()
-			l.emitCurrent(item_text)
-			return lexRangeClose
+		if n, w := l.peek(); n == char_range_between {
+			l.seek(w)
+			l.items.push(item{item_range_lo, string(r)})
+			l.items.push(item{item_range_between, string(n)})
+			wantHi = true
+			continue
 		}
+
+		l.unread() // unread first peek and fetch as text
+		l.fetchText([]rune{char_range_close})
+		wantClose = true
 	}
 }
 
-func lexRangeHiLo(l *lexer) stateFn {
-	start := l.start
+func (l *lexer) fetchText(breakers []rune) {
+	var data []rune
+	var escaped bool
 
+reading:
 	for {
-		c := l.read()
-		if c == eof {
-			l.errorf("unexpected end of input")
-			return nil
+		r := l.read()
+		if r == eof {
+			break
 		}
 
-		switch c {
-		case char_range_between:
-			if l.runes != 1 {
-				l.errorf("unexpected length of range: single character expected before minus")
-				return nil
-			}
-
-			l.emitCurrent(item_range_between)
-
-		case char_range_close:
-			l.unread()
-
-			if l.runes != 1 {
-				l.errorf("unexpected length of range: single character expected before close")
-				return nil
-			}
-
-			l.emitCurrent(item_range_hi)
-			return lexRangeClose
-
-		default:
-			if start != l.start {
+		if !escaped {
+			if r == char_escape {
+				escaped = true
 				continue
 			}
 
-			if l.runes != 1 {
-				l.errorf("unexpected length of range: single character expected at the begining")
-				return nil
+			if runes.IndexRune(breakers, r) != -1 {
+				l.unread()
+				break reading
 			}
-
-			l.emitCurrent(item_range_lo)
 		}
-	}
-}
-
-func lexAny(l *lexer) stateFn {
-	l.pos += 1
-	l.emitCurrent(item_any)
-	return lexRaw
-}
-
-func lexSuper(l *lexer) stateFn {
-	l.pos += 2
-	l.emitCurrent(item_super)
-	return lexRaw
-}
-
-func lexSingle(l *lexer) stateFn {
-	l.pos += 1
-	l.emitCurrent(item_single)
-	return lexRaw
-}
-
-func lexSeparator(l *lexer) stateFn {
-	posOpen := l.termScopes[len(l.termScopes)-1]
-
-	if l.pos-posOpen == 1 {
-		l.errorf("syntax error: empty term before separator")
-		return nil
-	}
 
-	l.termPhrases[posOpen] += 1
-	l.pos += 1
-	l.emitCurrent(item_separator)
-	return lexRaw
-}
-
-func lexTermsOpen(l *lexer) stateFn {
-	l.termScopes = append(l.termScopes, l.pos)
-	l.pos += 1
-	l.emitCurrent(item_terms_open)
-
-	return lexRaw
-}
-
-func lexTermsClose(l *lexer) stateFn {
-	if len(l.termScopes) == 0 {
-		l.errorf("unexpected closing of terms: there is no opened terms")
-		return nil
-	}
-
-	lastOpen := len(l.termScopes) - 1
-	posOpen := l.termScopes[lastOpen]
-
-	// if it is empty term
-	if posOpen == l.pos-1 {
-		l.errorf("term could not be empty")
-		return nil
+		escaped = false
+		data = append(data, r)
 	}
 
-	if l.termPhrases[posOpen] == 0 {
-		l.errorf("term must contain >1 phrases")
-		return nil
+	if len(data) > 0 {
+		l.items.push(item{item_text, string(data)})
 	}
-
-	// cleanup
-	l.termScopes = l.termScopes[:lastOpen]
-	delete(l.termPhrases, posOpen)
-
-	l.pos += 1
-	l.emitCurrent(item_terms_close)
-
-	return lexRaw
-}
-
-func lexRangeOpen(l *lexer) stateFn {
-	l.pos += 1
-	l.emitCurrent(item_range_open)
-	return lexInsideRange
-}
-
-func lexRangeClose(l *lexer) stateFn {
-	l.pos += 1
-	l.emitCurrent(item_range_close)
-	return lexRaw
 }
diff --git a/vendor/github.com/gobwas/glob/lexer_test.go b/vendor/github.com/gobwas/glob/lexer_test.go
deleted file mode 100644
index 664dd7114..000000000
--- a/vendor/github.com/gobwas/glob/lexer_test.go
+++ /dev/null
@@ -1,155 +0,0 @@
-package glob
-
-import (
-	"testing"
-)
-
-func TestLexGood(t *testing.T) {
-	for id, test := range []struct {
-		pattern string
-		items   []item
-	}{
-		{
-			pattern: "hello",
-			items: []item{
-				item{item_text, "hello"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "hello,world",
-			items: []item{
-				item{item_text, "hello,world"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "hello\\,world",
-			items: []item{
-				item{item_text, "hello,world"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "hello\\{world",
-			items: []item{
-				item{item_text, "hello{world"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "hello?",
-			items: []item{
-				item{item_text, "hello"},
-				item{item_single, "?"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "hellof*",
-			items: []item{
-				item{item_text, "hellof"},
-				item{item_any, "*"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "hello**",
-			items: []item{
-				item{item_text, "hello"},
-				item{item_super, "**"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "[日-語]",
-			items: []item{
-				item{item_range_open, "["},
-				item{item_range_lo, "日"},
-				item{item_range_between, "-"},
-				item{item_range_hi, "語"},
-				item{item_range_close, "]"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "[!日-語]",
-			items: []item{
-				item{item_range_open, "["},
-				item{item_not, "!"},
-				item{item_range_lo, "日"},
-				item{item_range_between, "-"},
-				item{item_range_hi, "語"},
-				item{item_range_close, "]"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "[日本語]",
-			items: []item{
-				item{item_range_open, "["},
-				item{item_text, "日本語"},
-				item{item_range_close, "]"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "[!日本語]",
-			items: []item{
-				item{item_range_open, "["},
-				item{item_not, "!"},
-				item{item_text, "日本語"},
-				item{item_range_close, "]"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "{a,b}",
-			items: []item{
-				item{item_terms_open, "{"},
-				item{item_text, "a"},
-				item{item_separator, ","},
-				item{item_text, "b"},
-				item{item_terms_close, "}"},
-				item{item_eof, ""},
-			},
-		},
-		{
-			pattern: "{[!日-語],*,?,{a,b,\\c}}",
-			items: []item{
-				item{item_terms_open, "{"},
-				item{item_range_open, "["},
-				item{item_not, "!"},
-				item{item_range_lo, "日"},
-				item{item_range_between, "-"},
-				item{item_range_hi, "語"},
-				item{item_range_close, "]"},
-				item{item_separator, ","},
-				item{item_any, "*"},
-				item{item_separator, ","},
-				item{item_single, "?"},
-				item{item_separator, ","},
-				item{item_terms_open, "{"},
-				item{item_text, "a"},
-				item{item_separator, ","},
-				item{item_text, "b"},
-				item{item_separator, ","},
-				item{item_text, "c"},
-				item{item_terms_close, "}"},
-				item{item_terms_close, "}"},
-				item{item_eof, ""},
-			},
-		},
-	} {
-		lexer := newLexer(test.pattern)
-		for i, exp := range test.items {
-			act := lexer.nextItem()
-			if act.t != exp.t {
-				t.Errorf("#%d %q: wrong %d-th item type: exp: %q; act: %q\n\t(%s vs %s)", id, test.pattern, i, exp.t, act.t, exp, act)
-			}
-			if act.s != exp.s {
-				t.Errorf("#%d %q: wrong %d-th item contents: exp: %q; act: %q\n\t(%s vs %s)", id, test.pattern, i, exp.s, act.s, exp, act)
-			}
-		}
-	}
-}
diff --git a/vendor/github.com/gobwas/glob/match/any_of.go b/vendor/github.com/gobwas/glob/match/any_of.go
index ffae2f6a0..60370433a 100644
--- a/vendor/github.com/gobwas/glob/match/any_of.go
+++ b/vendor/github.com/gobwas/glob/match/any_of.go
@@ -63,16 +63,15 @@ func (self AnyOf) Len() (l int) {
 	l = -1
 	for _, m := range self.Matchers {
 		ml := m.Len()
-		if ml == -1 {
-			return -1
-		}
-
-		if l == -1 {
+		switch {
+		case l == -1:
 			l = ml
 			continue
-		}
 
-		if l != ml {
+		case ml == -1:
+			return -1
+
+		case l != ml:
 			return -1
 		}
 	}
diff --git a/vendor/github.com/gobwas/glob/match/any_of_test.go b/vendor/github.com/gobwas/glob/match/any_of_test.go
deleted file mode 100644
index 3b478cf5f..000000000
--- a/vendor/github.com/gobwas/glob/match/any_of_test.go
+++ /dev/null
@@ -1,53 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestAnyOfIndex(t *testing.T) {
-	for id, test := range []struct {
-		matchers Matchers
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			Matchers{
-				NewAny(nil),
-				NewText("b"),
-				NewText("c"),
-			},
-			"abc",
-			0,
-			[]int{0, 1, 2, 3},
-		},
-		{
-			Matchers{
-				NewPrefix("b"),
-				NewSuffix("c"),
-			},
-			"abc",
-			0,
-			[]int{3},
-		},
-		{
-			Matchers{
-				NewList([]rune("[def]"), false),
-				NewList([]rune("[abc]"), false),
-			},
-			"abcdef",
-			0,
-			[]int{1},
-		},
-	} {
-		everyOf := NewAnyOf(test.matchers...)
-		index, segments := everyOf.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
diff --git a/vendor/github.com/gobwas/glob/match/any_test.go b/vendor/github.com/gobwas/glob/match/any_test.go
deleted file mode 100644
index 358f5534e..000000000
--- a/vendor/github.com/gobwas/glob/match/any_test.go
+++ /dev/null
@@ -1,57 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestAnyIndex(t *testing.T) {
-	for id, test := range []struct {
-		sep      []rune
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			[]rune{'.'},
-			"abc",
-			0,
-			[]int{0, 1, 2, 3},
-		},
-		{
-			[]rune{'.'},
-			"abc.def",
-			0,
-			[]int{0, 1, 2, 3},
-		},
-	} {
-		p := NewAny(test.sep)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexAny(b *testing.B) {
-	m := NewAny(bench_separators)
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexAnyParallel(b *testing.B) {
-	m := NewAny(bench_separators)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/btree_test.go b/vendor/github.com/gobwas/glob/match/btree_test.go
deleted file mode 100644
index 3bd9ea55e..000000000
--- a/vendor/github.com/gobwas/glob/match/btree_test.go
+++ /dev/null
@@ -1,90 +0,0 @@
-package match
-
-import (
-	"testing"
-)
-
-func TestBTree(t *testing.T) {
-	for id, test := range []struct {
-		tree BTree
-		str  string
-		exp  bool
-	}{
-		{
-			NewBTree(NewText("abc"), NewSuper(), NewSuper()),
-			"abc",
-			true,
-		},
-		{
-			NewBTree(NewText("a"), NewSingle(nil), NewSingle(nil)),
-			"aaa",
-			true,
-		},
-		{
-			NewBTree(NewText("b"), NewSingle(nil), nil),
-			"bbb",
-			false,
-		},
-		{
-			NewBTree(
-				NewText("c"),
-				NewBTree(
-					NewSingle(nil),
-					NewSuper(),
-					nil,
-				),
-				nil,
-			),
-			"abc",
-			true,
-		},
-	} {
-		act := test.tree.Match(test.str)
-		if act != test.exp {
-			t.Errorf("#%d match %q error: act: %t; exp: %t", id, test.str, act, test.exp)
-			continue
-		}
-	}
-}
-
-type fakeMatcher struct {
-	len  int
-	name string
-}
-
-func (f *fakeMatcher) Match(string) bool {
-	return true
-}
-
-var i = 3
-
-func (f *fakeMatcher) Index(s string) (int, []int) {
-	seg := make([]int, 0, i)
-	for x := 0; x < i; x++ {
-		seg = append(seg, x)
-	}
-	return 0, seg
-}
-func (f *fakeMatcher) Len() int {
-	return f.len
-}
-func (f *fakeMatcher) String() string {
-	return f.name
-}
-
-func BenchmarkMatchBTree(b *testing.B) {
-	l := &fakeMatcher{4, "left_fake"}
-	r := &fakeMatcher{4, "right_fake"}
-	v := &fakeMatcher{2, "value_fake"}
-
-	// must be <= len(l + r + v)
-	fixture := "abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij"
-
-	bt := NewBTree(v, l, r)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			bt.Match(fixture)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/contains_test.go b/vendor/github.com/gobwas/glob/match/contains_test.go
deleted file mode 100644
index 931322ebb..000000000
--- a/vendor/github.com/gobwas/glob/match/contains_test.go
+++ /dev/null
@@ -1,74 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestContainsIndex(t *testing.T) {
-	for id, test := range []struct {
-		prefix   string
-		not      bool
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			"ab",
-			false,
-			"abc",
-			0,
-			[]int{2, 3},
-		},
-		{
-			"ab",
-			false,
-			"fffabfff",
-			0,
-			[]int{5, 6, 7, 8},
-		},
-		{
-			"ab",
-			true,
-			"abc",
-			0,
-			[]int{0},
-		},
-		{
-			"ab",
-			true,
-			"fffabfff",
-			0,
-			[]int{0, 1, 2, 3},
-		},
-	} {
-		p := NewContains(test.prefix, test.not)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexContains(b *testing.B) {
-	m := NewContains(string(bench_separators), true)
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexContainsParallel(b *testing.B) {
-	m := NewContains(string(bench_separators), true)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/every_of_test.go b/vendor/github.com/gobwas/glob/match/every_of_test.go
deleted file mode 100644
index eb83f862f..000000000
--- a/vendor/github.com/gobwas/glob/match/every_of_test.go
+++ /dev/null
@@ -1,45 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestEveryOfIndex(t *testing.T) {
-	for id, test := range []struct {
-		matchers Matchers
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			Matchers{
-				NewAny(nil),
-				NewText("b"),
-				NewText("c"),
-			},
-			"dbc",
-			-1,
-			nil,
-		},
-		{
-			Matchers{
-				NewAny(nil),
-				NewPrefix("b"),
-				NewSuffix("c"),
-			},
-			"abc",
-			1,
-			[]int{2},
-		},
-	} {
-		everyOf := NewEveryOf(test.matchers...)
-		index, segments := everyOf.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
diff --git a/vendor/github.com/gobwas/glob/match/list_test.go b/vendor/github.com/gobwas/glob/match/list_test.go
deleted file mode 100644
index 10a54379d..000000000
--- a/vendor/github.com/gobwas/glob/match/list_test.go
+++ /dev/null
@@ -1,58 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestListIndex(t *testing.T) {
-	for id, test := range []struct {
-		list     []rune
-		not      bool
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			[]rune("ab"),
-			false,
-			"abc",
-			0,
-			[]int{1},
-		},
-		{
-			[]rune("ab"),
-			true,
-			"fffabfff",
-			0,
-			[]int{1},
-		},
-	} {
-		p := NewList(test.list, test.not)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexList(b *testing.B) {
-	m := NewList([]rune("def"), false)
-
-	for i := 0; i < b.N; i++ {
-		m.Index(bench_pattern)
-	}
-}
-
-func BenchmarkIndexListParallel(b *testing.B) {
-	m := NewList([]rune("def"), false)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			m.Index(bench_pattern)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/match_test.go b/vendor/github.com/gobwas/glob/match/match_test.go
deleted file mode 100644
index 3b60a7c87..000000000
--- a/vendor/github.com/gobwas/glob/match/match_test.go
+++ /dev/null
@@ -1,90 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-	"unicode/utf8"
-)
-
-var bench_separators = []rune{'.'}
-
-const bench_pattern = "abcdefghijklmnopqrstuvwxyz0123456789"
-
-func TestAppendMerge(t *testing.T) {
-	for id, test := range []struct {
-		segments [2][]int
-		exp      []int
-	}{
-		{
-			[2][]int{
-				[]int{0, 6, 7},
-				[]int{0, 1, 3},
-			},
-			[]int{0, 1, 3, 6, 7},
-		},
-		{
-			[2][]int{
-				[]int{0, 1, 3, 6, 7},
-				[]int{0, 1, 10},
-			},
-			[]int{0, 1, 3, 6, 7, 10},
-		},
-	} {
-		act := appendMerge(test.segments[0], test.segments[1])
-		if !reflect.DeepEqual(act, test.exp) {
-			t.Errorf("#%d merge sort segments unexpected:\nact: %v\nexp:%v", id, act, test.exp)
-			continue
-		}
-	}
-}
-
-func BenchmarkAppendMerge(b *testing.B) {
-	s1 := []int{0, 1, 3, 6, 7}
-	s2 := []int{0, 1, 3}
-
-	for i := 0; i < b.N; i++ {
-		appendMerge(s1, s2)
-	}
-}
-
-func BenchmarkAppendMergeParallel(b *testing.B) {
-	s1 := []int{0, 1, 3, 6, 7}
-	s2 := []int{0, 1, 3}
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			appendMerge(s1, s2)
-		}
-	})
-}
-
-func BenchmarkReverse(b *testing.B) {
-	for i := 0; i < b.N; i++ {
-		reverseSegments([]int{1, 2, 3, 4})
-	}
-}
-
-func getTable() []int {
-	table := make([]int, utf8.MaxRune+1)
-	for i := 0; i <= utf8.MaxRune; i++ {
-		table[i] = utf8.RuneLen(rune(i))
-	}
-
-	return table
-}
-
-var table = getTable()
-
-const runeToLen = 'q'
-
-func BenchmarkRuneLenFromTable(b *testing.B) {
-	for i := 0; i < b.N; i++ {
-		_ = table[runeToLen]
-	}
-}
-
-func BenchmarkRuneLenFromUTF8(b *testing.B) {
-	for i := 0; i < b.N; i++ {
-		_ = utf8.RuneLen(runeToLen)
-	}
-}
diff --git a/vendor/github.com/gobwas/glob/match/max_test.go b/vendor/github.com/gobwas/glob/match/max_test.go
deleted file mode 100644
index 23676284b..000000000
--- a/vendor/github.com/gobwas/glob/match/max_test.go
+++ /dev/null
@@ -1,57 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestMaxIndex(t *testing.T) {
-	for id, test := range []struct {
-		limit    int
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			3,
-			"abc",
-			0,
-			[]int{0, 1, 2, 3},
-		},
-		{
-			3,
-			"abcdef",
-			0,
-			[]int{0, 1, 2, 3},
-		},
-	} {
-		p := NewMax(test.limit)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexMax(b *testing.B) {
-	m := NewMax(10)
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexMaxParallel(b *testing.B) {
-	m := NewMax(10)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/min_test.go b/vendor/github.com/gobwas/glob/match/min_test.go
deleted file mode 100644
index ab854ae0c..000000000
--- a/vendor/github.com/gobwas/glob/match/min_test.go
+++ /dev/null
@@ -1,57 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestMinIndex(t *testing.T) {
-	for id, test := range []struct {
-		limit    int
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			1,
-			"abc",
-			0,
-			[]int{1, 2, 3},
-		},
-		{
-			3,
-			"abcd",
-			0,
-			[]int{3, 4},
-		},
-	} {
-		p := NewMin(test.limit)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexMin(b *testing.B) {
-	m := NewMin(10)
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexMinParallel(b *testing.B) {
-	m := NewMin(10)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/nothing_test.go b/vendor/github.com/gobwas/glob/match/nothing_test.go
deleted file mode 100644
index 941c22d1c..000000000
--- a/vendor/github.com/gobwas/glob/match/nothing_test.go
+++ /dev/null
@@ -1,54 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestNothingIndex(t *testing.T) {
-	for id, test := range []struct {
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			"abc",
-			0,
-			[]int{0},
-		},
-		{
-			"",
-			0,
-			[]int{0},
-		},
-	} {
-		p := NewNothing()
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexNothing(b *testing.B) {
-	m := NewNothing()
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexNothingParallel(b *testing.B) {
-	m := NewNothing()
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/prefix_suffix_test.go b/vendor/github.com/gobwas/glob/match/prefix_suffix_test.go
deleted file mode 100644
index 79b17b202..000000000
--- a/vendor/github.com/gobwas/glob/match/prefix_suffix_test.go
+++ /dev/null
@@ -1,67 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestPrefixSuffixIndex(t *testing.T) {
-	for id, test := range []struct {
-		prefix   string
-		suffix   string
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			"a",
-			"c",
-			"abc",
-			0,
-			[]int{3},
-		},
-		{
-			"f",
-			"f",
-			"fffabfff",
-			0,
-			[]int{1, 2, 3, 6, 7, 8},
-		},
-		{
-			"ab",
-			"bc",
-			"abc",
-			0,
-			[]int{3},
-		},
-	} {
-		p := NewPrefixSuffix(test.prefix, test.suffix)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexPrefixSuffix(b *testing.B) {
-	m := NewPrefixSuffix("qew", "sqw")
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexPrefixSuffixParallel(b *testing.B) {
-	m := NewPrefixSuffix("qew", "sqw")
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/prefix_test.go b/vendor/github.com/gobwas/glob/match/prefix_test.go
deleted file mode 100644
index 22a296e6a..000000000
--- a/vendor/github.com/gobwas/glob/match/prefix_test.go
+++ /dev/null
@@ -1,57 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestPrefixIndex(t *testing.T) {
-	for id, test := range []struct {
-		prefix   string
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			"ab",
-			"abc",
-			0,
-			[]int{2, 3},
-		},
-		{
-			"ab",
-			"fffabfff",
-			3,
-			[]int{2, 3, 4, 5},
-		},
-	} {
-		p := NewPrefix(test.prefix)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexPrefix(b *testing.B) {
-	m := NewPrefix("qew")
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexPrefixParallel(b *testing.B) {
-	m := NewPrefix("qew")
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/range_test.go b/vendor/github.com/gobwas/glob/match/range_test.go
deleted file mode 100644
index 0dddcfdb6..000000000
--- a/vendor/github.com/gobwas/glob/match/range_test.go
+++ /dev/null
@@ -1,67 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestRangeIndex(t *testing.T) {
-	for id, test := range []struct {
-		lo, hi   rune
-		not      bool
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			'a', 'z',
-			false,
-			"abc",
-			0,
-			[]int{1},
-		},
-		{
-			'a', 'c',
-			false,
-			"abcd",
-			0,
-			[]int{1},
-		},
-		{
-			'a', 'c',
-			true,
-			"abcd",
-			3,
-			[]int{1},
-		},
-	} {
-		m := NewRange(test.lo, test.hi, test.not)
-		index, segments := m.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexRange(b *testing.B) {
-	m := NewRange('0', '9', false)
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexRangeParallel(b *testing.B) {
-	m := NewRange('0', '9', false)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/row_test.go b/vendor/github.com/gobwas/glob/match/row_test.go
deleted file mode 100644
index c9e65ef5e..000000000
--- a/vendor/github.com/gobwas/glob/match/row_test.go
+++ /dev/null
@@ -1,82 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestRowIndex(t *testing.T) {
-	for id, test := range []struct {
-		matchers Matchers
-		length   int
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			Matchers{
-				NewText("abc"),
-				NewText("def"),
-				NewSingle(nil),
-			},
-			7,
-			"qweabcdefghij",
-			3,
-			[]int{7},
-		},
-		{
-			Matchers{
-				NewText("abc"),
-				NewText("def"),
-				NewSingle(nil),
-			},
-			7,
-			"abcd",
-			-1,
-			nil,
-		},
-	} {
-		p := NewRow(test.length, test.matchers...)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkRowIndex(b *testing.B) {
-	m := NewRow(
-		7,
-		Matchers{
-			NewText("abc"),
-			NewText("def"),
-			NewSingle(nil),
-		}...,
-	)
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexRowParallel(b *testing.B) {
-	m := NewRow(
-		7,
-		Matchers{
-			NewText("abc"),
-			NewText("def"),
-			NewSingle(nil),
-		}...,
-	)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/segments_test.go b/vendor/github.com/gobwas/glob/match/segments_test.go
deleted file mode 100644
index 1ce1123d5..000000000
--- a/vendor/github.com/gobwas/glob/match/segments_test.go
+++ /dev/null
@@ -1,83 +0,0 @@
-package match
-
-import (
-	"sync"
-	"testing"
-)
-
-func benchPool(i int, b *testing.B) {
-	pool := sync.Pool{New: func() interface{} {
-		return make([]int, 0, i)
-	}}
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			s := pool.Get().([]int)[:0]
-			pool.Put(s)
-		}
-	})
-}
-
-func benchMake(i int, b *testing.B) {
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_ = make([]int, 0, i)
-		}
-	})
-}
-
-func BenchmarkSegmentsPool_1(b *testing.B) {
-	benchPool(1, b)
-}
-func BenchmarkSegmentsPool_2(b *testing.B) {
-	benchPool(2, b)
-}
-func BenchmarkSegmentsPool_4(b *testing.B) {
-	benchPool(4, b)
-}
-func BenchmarkSegmentsPool_8(b *testing.B) {
-	benchPool(8, b)
-}
-func BenchmarkSegmentsPool_16(b *testing.B) {
-	benchPool(16, b)
-}
-func BenchmarkSegmentsPool_32(b *testing.B) {
-	benchPool(32, b)
-}
-func BenchmarkSegmentsPool_64(b *testing.B) {
-	benchPool(64, b)
-}
-func BenchmarkSegmentsPool_128(b *testing.B) {
-	benchPool(128, b)
-}
-func BenchmarkSegmentsPool_256(b *testing.B) {
-	benchPool(256, b)
-}
-
-func BenchmarkSegmentsMake_1(b *testing.B) {
-	benchMake(1, b)
-}
-func BenchmarkSegmentsMake_2(b *testing.B) {
-	benchMake(2, b)
-}
-func BenchmarkSegmentsMake_4(b *testing.B) {
-	benchMake(4, b)
-}
-func BenchmarkSegmentsMake_8(b *testing.B) {
-	benchMake(8, b)
-}
-func BenchmarkSegmentsMake_16(b *testing.B) {
-	benchMake(16, b)
-}
-func BenchmarkSegmentsMake_32(b *testing.B) {
-	benchMake(32, b)
-}
-func BenchmarkSegmentsMake_64(b *testing.B) {
-	benchMake(64, b)
-}
-func BenchmarkSegmentsMake_128(b *testing.B) {
-	benchMake(128, b)
-}
-func BenchmarkSegmentsMake_256(b *testing.B) {
-	benchMake(256, b)
-}
diff --git a/vendor/github.com/gobwas/glob/match/single_test.go b/vendor/github.com/gobwas/glob/match/single_test.go
deleted file mode 100644
index a62d72042..000000000
--- a/vendor/github.com/gobwas/glob/match/single_test.go
+++ /dev/null
@@ -1,57 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestSingleIndex(t *testing.T) {
-	for id, test := range []struct {
-		separators []rune
-		fixture    string
-		index      int
-		segments   []int
-	}{
-		{
-			[]rune{'.'},
-			".abc",
-			1,
-			[]int{1},
-		},
-		{
-			[]rune{'.'},
-			".",
-			-1,
-			nil,
-		},
-	} {
-		p := NewSingle(test.separators)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexSingle(b *testing.B) {
-	m := NewSingle(bench_separators)
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexSingleParallel(b *testing.B) {
-	m := NewSingle(bench_separators)
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/suffix_test.go b/vendor/github.com/gobwas/glob/match/suffix_test.go
deleted file mode 100644
index 490476346..000000000
--- a/vendor/github.com/gobwas/glob/match/suffix_test.go
+++ /dev/null
@@ -1,57 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestSuffixIndex(t *testing.T) {
-	for id, test := range []struct {
-		prefix   string
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			"ab",
-			"abc",
-			0,
-			[]int{2},
-		},
-		{
-			"ab",
-			"fffabfff",
-			0,
-			[]int{5},
-		},
-	} {
-		p := NewSuffix(test.prefix)
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexSuffix(b *testing.B) {
-	m := NewSuffix("qwe")
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexSuffixParallel(b *testing.B) {
-	m := NewSuffix("qwe")
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/super_test.go b/vendor/github.com/gobwas/glob/match/super_test.go
deleted file mode 100644
index 10418dc2a..000000000
--- a/vendor/github.com/gobwas/glob/match/super_test.go
+++ /dev/null
@@ -1,54 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestSuperIndex(t *testing.T) {
-	for id, test := range []struct {
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			"abc",
-			0,
-			[]int{0, 1, 2, 3},
-		},
-		{
-			"",
-			0,
-			[]int{0},
-		},
-	} {
-		p := NewSuper()
-		index, segments := p.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexSuper(b *testing.B) {
-	m := NewSuper()
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexSuperParallel(b *testing.B) {
-	m := NewSuper()
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/match/text_test.go b/vendor/github.com/gobwas/glob/match/text_test.go
deleted file mode 100644
index a3de40eaa..000000000
--- a/vendor/github.com/gobwas/glob/match/text_test.go
+++ /dev/null
@@ -1,57 +0,0 @@
-package match
-
-import (
-	"reflect"
-	"testing"
-)
-
-func TestTextIndex(t *testing.T) {
-	for id, test := range []struct {
-		text     string
-		fixture  string
-		index    int
-		segments []int
-	}{
-		{
-			"b",
-			"abc",
-			1,
-			[]int{1},
-		},
-		{
-			"f",
-			"abcd",
-			-1,
-			nil,
-		},
-	} {
-		m := NewText(test.text)
-		index, segments := m.Index(test.fixture)
-		if index != test.index {
-			t.Errorf("#%d unexpected index: exp: %d, act: %d", id, test.index, index)
-		}
-		if !reflect.DeepEqual(segments, test.segments) {
-			t.Errorf("#%d unexpected segments: exp: %v, act: %v", id, test.segments, segments)
-		}
-	}
-}
-
-func BenchmarkIndexText(b *testing.B) {
-	m := NewText("foo")
-
-	for i := 0; i < b.N; i++ {
-		_, s := m.Index(bench_pattern)
-		releaseSegments(s)
-	}
-}
-
-func BenchmarkIndexTextParallel(b *testing.B) {
-	m := NewText("foo")
-
-	b.RunParallel(func(pb *testing.PB) {
-		for pb.Next() {
-			_, s := m.Index(bench_pattern)
-			releaseSegments(s)
-		}
-	})
-}
diff --git a/vendor/github.com/gobwas/glob/parser.go b/vendor/github.com/gobwas/glob/parser.go
index 43da13a8b..760ec96fc 100644
--- a/vendor/github.com/gobwas/glob/parser.go
+++ b/vendor/github.com/gobwas/glob/parser.go
@@ -11,6 +11,11 @@ type node interface {
 	append(node)
 }
 
+// todo may be split it into another package
+type lexerIface interface {
+	nextItem() item
+}
+
 type nodeImpl struct {
 	desc []node
 }
@@ -72,9 +77,9 @@ func (t *tree) leave() {
 	t.current = t.path[len(t.path)-1]
 }
 
-type parseFn func(*tree, *lexer) (parseFn, error)
+type parseFn func(*tree, lexerIface) (parseFn, error)
 
-func parse(lexer *lexer) (*nodePattern, error) {
+func parse(lexer lexerIface) (*nodePattern, error) {
 	var parser parseFn
 
 	root := &nodePattern{}
@@ -97,7 +102,7 @@ func parse(lexer *lexer) (*nodePattern, error) {
 	return root, nil
 }
 
-func parserMain(tree *tree, lexer *lexer) (parseFn, error) {
+func parserMain(tree *tree, lexer lexerIface) (parseFn, error) {
 	for stop := false; !stop; {
 		item := lexer.nextItem()
 
@@ -151,7 +156,7 @@ func parserMain(tree *tree, lexer *lexer) (parseFn, error) {
 	return nil, nil
 }
 
-func parserRange(tree *tree, lexer *lexer) (parseFn, error) {
+func parserRange(tree *tree, lexer lexerIface) (parseFn, error) {
 	var (
 		not   bool
 		lo    rune
diff --git a/vendor/github.com/gobwas/glob/parser_test.go b/vendor/github.com/gobwas/glob/parser_test.go
deleted file mode 100644
index 159c1ffda..000000000
--- a/vendor/github.com/gobwas/glob/parser_test.go
+++ /dev/null
@@ -1,219 +0,0 @@
-package glob
-
-import (
-	"fmt"
-	"reflect"
-	"testing"
-)
-
-func TestParseString(t *testing.T) {
-	for id, test := range []struct {
-		pattern string
-		tree    node
-	}{
-		{
-			pattern: "abc",
-			tree: &nodePattern{
-				nodeImpl: nodeImpl{
-					desc: []node{
-						&nodeText{text: "abc"},
-					},
-				},
-			},
-		},
-		{
-			pattern: "a*c",
-			tree: &nodePattern{
-				nodeImpl: nodeImpl{
-					desc: []node{
-						&nodeText{text: "a"},
-						&nodeAny{},
-						&nodeText{text: "c"},
-					},
-				},
-			},
-		},
-		{
-			pattern: "a**c",
-			tree: &nodePattern{
-				nodeImpl: nodeImpl{
-					desc: []node{
-						&nodeText{text: "a"},
-						&nodeSuper{},
-						&nodeText{text: "c"},
-					},
-				},
-			},
-		},
-		{
-			pattern: "a?c",
-			tree: &nodePattern{
-				nodeImpl: nodeImpl{
-					desc: []node{
-						&nodeText{text: "a"},
-						&nodeSingle{},
-						&nodeText{text: "c"},
-					},
-				},
-			},
-		},
-		{
-			pattern: "[!a-z]",
-			tree: &nodePattern{
-				nodeImpl: nodeImpl{
-					desc: []node{
-						&nodeRange{lo: 'a', hi: 'z', not: true},
-					},
-				},
-			},
-		},
-		{
-			pattern: "[az]",
-			tree: &nodePattern{
-				nodeImpl: nodeImpl{
-					desc: []node{
-						&nodeList{chars: "az"},
-					},
-				},
-			},
-		},
-		{
-			pattern: "{a,z}",
-			tree: &nodePattern{
-				nodeImpl: nodeImpl{
-					desc: []node{
-						&nodeAnyOf{nodeImpl: nodeImpl{desc: []node{
-							&nodePattern{
-								nodeImpl: nodeImpl{desc: []node{
-									&nodeText{text: "a"},
-								}},
-							},
-							&nodePattern{
-								nodeImpl: nodeImpl{desc: []node{
-									&nodeText{text: "z"},
-								}},
-							},
-						}}},
-					},
-				},
-			},
-		},
-		{
-			pattern: "{a,{x,y},?,[a-z],[!qwe]}",
-			tree: &nodePattern{
-				nodeImpl: nodeImpl{
-					desc: []node{
-						&nodeAnyOf{nodeImpl: nodeImpl{desc: []node{
-							&nodePattern{
-								nodeImpl: nodeImpl{desc: []node{
-									&nodeText{text: "a"},
-								}},
-							},
-							&nodePattern{
-								nodeImpl: nodeImpl{desc: []node{
-									&nodeAnyOf{nodeImpl: nodeImpl{desc: []node{
-										&nodePattern{
-											nodeImpl: nodeImpl{desc: []node{
-												&nodeText{text: "x"},
-											}},
-										},
-										&nodePattern{
-											nodeImpl: nodeImpl{desc: []node{
-												&nodeText{text: "y"},
-											}},
-										},
-									}}},
-								}},
-							},
-							&nodePattern{
-								nodeImpl: nodeImpl{desc: []node{
-									&nodeSingle{},
-								}},
-							},
-							&nodePattern{
-								nodeImpl: nodeImpl{
-									desc: []node{
-										&nodeRange{lo: 'a', hi: 'z', not: false},
-									},
-								},
-							},
-							&nodePattern{
-								nodeImpl: nodeImpl{
-									desc: []node{
-										&nodeList{chars: "qwe", not: true},
-									},
-								},
-							},
-						}}},
-					},
-				},
-			},
-		},
-	} {
-		pattern, err := parse(newLexer(test.pattern))
-		if err != nil {
-			t.Errorf("#%d %s", id, err)
-			continue
-		}
-
-		if !reflect.DeepEqual(test.tree, pattern) {
-			t.Errorf("#%d tries are not equal", id)
-			if err = nodeEqual(test.tree, pattern); err != nil {
-				t.Errorf("#%d %s", id, err)
-				continue
-			}
-		}
-	}
-}
-
-const abstractNodeImpl = "nodeImpl"
-
-func nodeEqual(a, b node) error {
-	if (a == nil || b == nil) && a != b {
-		return fmt.Errorf("nodes are not equal: exp %s, act %s", a, b)
-	}
-
-	aValue, bValue := reflect.Indirect(reflect.ValueOf(a)), reflect.Indirect(reflect.ValueOf(b))
-	aType, bType := aValue.Type(), bValue.Type()
-	if aType != bType {
-		return fmt.Errorf("nodes are not equal: exp %s, act %s", aValue.Type(), bValue.Type())
-	}
-
-	for i := 0; i < aType.NumField(); i++ {
-		var eq bool
-
-		f := aType.Field(i).Name
-		if f == abstractNodeImpl {
-			continue
-		}
-
-		af, bf := aValue.FieldByName(f), bValue.FieldByName(f)
-
-		switch af.Kind() {
-		case reflect.String:
-			eq = af.String() == bf.String()
-		case reflect.Bool:
-			eq = af.Bool() == bf.Bool()
-		default:
-			eq = fmt.Sprint(af) == fmt.Sprint(bf)
-		}
-
-		if !eq {
-			return fmt.Errorf("nodes<%s> %q fields are not equal: exp %q, act %q", aType, f, af, bf)
-		}
-	}
-
-	for i, aDesc := range a.children() {
-		if len(b.children())-1 < i {
-			return fmt.Errorf("node does not have enough children (got %d children, wanted %d-th token)", len(b.children()), i)
-		}
-
-		bDesc := b.children()[i]
-
-		if err := nodeEqual(aDesc, bDesc); err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
diff --git a/vendor/github.com/gobwas/glob/runes/runes_test.go b/vendor/github.com/gobwas/glob/runes/runes_test.go
deleted file mode 100644
index 54498eb8e..000000000
--- a/vendor/github.com/gobwas/glob/runes/runes_test.go
+++ /dev/null
@@ -1,222 +0,0 @@
-package runes
-
-import (
-	"strings"
-	"testing"
-)
-
-type indexTest struct {
-	s   []rune
-	sep []rune
-	out int
-}
-
-type equalTest struct {
-	a   []rune
-	b   []rune
-	out bool
-}
-
-func newIndexTest(s, sep string, out int) indexTest {
-	return indexTest{[]rune(s), []rune(sep), out}
-}
-func newEqualTest(s, sep string, out bool) equalTest {
-	return equalTest{[]rune(s), []rune(sep), out}
-}
-
-var dots = "1....2....3....4"
-
-var indexTests = []indexTest{
-	newIndexTest("", "", 0),
-	newIndexTest("", "a", -1),
-	newIndexTest("", "foo", -1),
-	newIndexTest("fo", "foo", -1),
-	newIndexTest("foo", "foo", 0),
-	newIndexTest("oofofoofooo", "f", 2),
-	newIndexTest("oofofoofooo", "foo", 4),
-	newIndexTest("barfoobarfoo", "foo", 3),
-	newIndexTest("foo", "", 0),
-	newIndexTest("foo", "o", 1),
-	newIndexTest("abcABCabc", "A", 3),
-	// cases with one byte strings - test special case in Index()
-	newIndexTest("", "a", -1),
-	newIndexTest("x", "a", -1),
-	newIndexTest("x", "x", 0),
-	newIndexTest("abc", "a", 0),
-	newIndexTest("abc", "b", 1),
-	newIndexTest("abc", "c", 2),
-	newIndexTest("abc", "x", -1),
-}
-
-var lastIndexTests = []indexTest{
-	newIndexTest("", "", 0),
-	newIndexTest("", "a", -1),
-	newIndexTest("", "foo", -1),
-	newIndexTest("fo", "foo", -1),
-	newIndexTest("foo", "foo", 0),
-	newIndexTest("foo", "f", 0),
-	newIndexTest("oofofoofooo", "f", 7),
-	newIndexTest("oofofoofooo", "foo", 7),
-	newIndexTest("barfoobarfoo", "foo", 9),
-	newIndexTest("foo", "", 3),
-	newIndexTest("foo", "o", 2),
-	newIndexTest("abcABCabc", "A", 3),
-	newIndexTest("abcABCabc", "a", 6),
-}
-
-var indexAnyTests = []indexTest{
-	newIndexTest("", "", -1),
-	newIndexTest("", "a", -1),
-	newIndexTest("", "abc", -1),
-	newIndexTest("a", "", -1),
-	newIndexTest("a", "a", 0),
-	newIndexTest("aaa", "a", 0),
-	newIndexTest("abc", "xyz", -1),
-	newIndexTest("abc", "xcz", 2),
-	newIndexTest("a☺b☻c☹d", "uvw☻xyz", 3),
-	newIndexTest("aRegExp*", ".(|)*+?^$[]", 7),
-	newIndexTest(dots+dots+dots, " ", -1),
-}
-
-// Execute f on each test case.  funcName should be the name of f; it's used
-// in failure reports.
-func runIndexTests(t *testing.T, f func(s, sep []rune) int, funcName string, testCases []indexTest) {
-	for _, test := range testCases {
-		actual := f(test.s, test.sep)
-		if actual != test.out {
-			t.Errorf("%s(%q,%q) = %v; want %v", funcName, test.s, test.sep, actual, test.out)
-		}
-	}
-}
-
-func TestIndex(t *testing.T)     { runIndexTests(t, Index, "Index", indexTests) }
-func TestLastIndex(t *testing.T) { runIndexTests(t, LastIndex, "LastIndex", lastIndexTests) }
-func TestIndexAny(t *testing.T)  { runIndexTests(t, IndexAny, "IndexAny", indexAnyTests) }
-
-var equalTests = []equalTest{
-	newEqualTest("a", "a", true),
-	newEqualTest("a", "b", false),
-	newEqualTest("a☺b☻c☹d", "uvw☻xyz", false),
-	newEqualTest("a☺b☻c☹d", "a☺b☻c☹d", true),
-}
-
-func TestEqual(t *testing.T) {
-	for _, test := range equalTests {
-		actual := Equal(test.a, test.b)
-		if actual != test.out {
-			t.Errorf("Equal(%q,%q) = %v; want %v", test.a, test.b, actual, test.out)
-		}
-	}
-}
-
-func BenchmarkLastIndexRunes(b *testing.B) {
-	r := []rune("abcdef")
-	n := []rune("cd")
-
-	for i := 0; i < b.N; i++ {
-		LastIndex(r, n)
-	}
-}
-func BenchmarkLastIndexStrings(b *testing.B) {
-	r := "abcdef"
-	n := "cd"
-
-	for i := 0; i < b.N; i++ {
-		strings.LastIndex(r, n)
-	}
-}
-
-func BenchmarkIndexAnyRunes(b *testing.B) {
-	s := []rune("...b...")
-	c := []rune("abc")
-
-	for i := 0; i < b.N; i++ {
-		IndexAny(s, c)
-	}
-}
-func BenchmarkIndexAnyStrings(b *testing.B) {
-	s := "...b..."
-	c := "abc"
-
-	for i := 0; i < b.N; i++ {
-		strings.IndexAny(s, c)
-	}
-}
-
-func BenchmarkIndexRuneRunes(b *testing.B) {
-	s := []rune("...b...")
-	r := 'b'
-
-	for i := 0; i < b.N; i++ {
-		IndexRune(s, r)
-	}
-}
-func BenchmarkIndexRuneStrings(b *testing.B) {
-	s := "...b..."
-	r := 'b'
-
-	for i := 0; i < b.N; i++ {
-		strings.IndexRune(s, r)
-	}
-}
-
-func BenchmarkIndexRunes(b *testing.B) {
-	r := []rune("abcdef")
-	n := []rune("cd")
-
-	for i := 0; i < b.N; i++ {
-		Index(r, n)
-	}
-}
-func BenchmarkIndexStrings(b *testing.B) {
-	r := "abcdef"
-	n := "cd"
-
-	for i := 0; i < b.N; i++ {
-		strings.Index(r, n)
-	}
-}
-
-func BenchmarkEqualRunes(b *testing.B) {
-	x := []rune("abc")
-	y := []rune("abc")
-
-	for i := 0; i < b.N; i++ {
-		if Equal(x, y) {
-			continue
-		}
-	}
-}
-
-func BenchmarkEqualStrings(b *testing.B) {
-	x := "abc"
-	y := "abc"
-
-	for i := 0; i < b.N; i++ {
-		if x == y {
-			continue
-		}
-	}
-}
-
-func BenchmarkNotEqualRunes(b *testing.B) {
-	x := []rune("abc")
-	y := []rune("abcd")
-
-	for i := 0; i < b.N; i++ {
-		if Equal(x, y) {
-			continue
-		}
-	}
-}
-
-func BenchmarkNotEqualStrings(b *testing.B) {
-	x := "abc"
-	y := "abcd"
-
-	for i := 0; i < b.N; i++ {
-		if x == y {
-			continue
-		}
-	}
-}
diff --git a/vendor/manifest b/vendor/manifest
index 7b962ecdc..63e5d7522 100644
--- a/vendor/manifest
+++ b/vendor/manifest
@@ -47,8 +47,9 @@
 		{
 			"importpath": "github.com/gobwas/glob",
 			"repository": "https://github.com/gobwas/glob",
-			"revision": "82e8d7da03805cde651f981f9702a4b4d8cf58eb",
-			"branch": "master"
+			"revision": "70f1304bc31c066b52b681dfbaecf0e913527632",
+			"branch": "newlexer",
+			"notests": true
 		},
 		{
 			"importpath": "github.com/golang/snappy",
