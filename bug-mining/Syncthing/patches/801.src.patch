diff --git a/lib/db/meta.go b/lib/db/meta.go
index 93dc2a59d..508b5250a 100644
--- a/lib/db/meta.go
+++ b/lib/db/meta.go
@@ -93,6 +93,11 @@ func (m *metadataTracker) countsPtr(dev protocol.DeviceID, flags uint32) *Counts
 // addFile adds a file to the counts, adjusting the sequence number as
 // appropriate
 func (m *metadataTracker) addFile(dev protocol.DeviceID, f FileIntf) {
+	if f.IsInvalid() && f.FileLocalFlags() == 0 {
+		// This is a remote invalid file; it does not count.
+		return
+	}
+
 	m.mut.Lock()
 
 	if flags := f.FileLocalFlags(); flags == 0 {
@@ -130,6 +135,11 @@ func (m *metadataTracker) addFileLocked(dev protocol.DeviceID, flags uint32, f F
 
 // removeFile removes a file from the counts
 func (m *metadataTracker) removeFile(dev protocol.DeviceID, f FileIntf) {
+	if f.IsInvalid() && f.FileLocalFlags() == 0 {
+		// This is a remote invalid file; it does not count.
+		return
+	}
+
 	m.mut.Lock()
 
 	if flags := f.FileLocalFlags(); flags == 0 {
diff --git a/lib/db/set_test.go b/lib/db/set_test.go
index 53087a579..3f133608a 100644
--- a/lib/db/set_test.go
+++ b/lib/db/set_test.go
@@ -1199,6 +1199,27 @@ func TestNeedAfterUnignore(t *testing.T) {
 	}
 }
 
+func TestRemoteInvalidNotAccounted(t *testing.T) {
+	// Remote files with the invalid bit should not count.
+
+	ldb := db.OpenMemory()
+	s := db.NewFileSet("test", fs.NewFilesystem(fs.FilesystemTypeBasic, "."), ldb)
+
+	files := []protocol.FileInfo{
+		{Name: "a", Size: 1234, Sequence: 42, Version: protocol.Vector{Counters: []protocol.Counter{{ID: myID, Value: 1003}}}},                   // valid, should count
+		{Name: "b", Size: 1234, Sequence: 43, Version: protocol.Vector{Counters: []protocol.Counter{{ID: myID, Value: 1003}}}, RawInvalid: true}, // invalid, doesn't count
+	}
+	s.Update(remoteDevice0, files)
+
+	global := s.GlobalSize()
+	if global.Files != 1 {
+		t.Error("Expected one file in global size, not", global.Files)
+	}
+	if global.Bytes != 1234 {
+		t.Error("Expected 1234 bytes in global size, not", global.Bytes)
+	}
+}
+
 func replace(fs *db.FileSet, device protocol.DeviceID, files []protocol.FileInfo) {
 	fs.Drop(device)
 	fs.Update(device, files)
