diff --git a/internal/db/leveldb.go b/internal/db/leveldb.go
index 6960498c6..0c2f2d4e2 100644
--- a/internal/db/leveldb.go
+++ b/internal/db/leveldb.go
@@ -586,6 +586,16 @@ func ldbWithAllFolderTruncated(db *leveldb.DB, folder []byte, fn func(device []b
 		if err != nil {
 			panic(err)
 		}
+
+		if f.Name == "" {
+			l.Infoln("Dropping invalid nil filename from database")
+			batch := new(leveldb.Batch)
+			ldbRemoveFromGlobal(db, batch, folder, device, nil)
+			batch.Delete(dbi.Key())
+			db.Write(batch, nil)
+			continue
+		}
+
 		if cont := fn(device, f); !cont {
 			return
 		}
diff --git a/internal/protocol/protocol.go b/internal/protocol/protocol.go
index 0c59ef56e..5fe7cc344 100644
--- a/internal/protocol/protocol.go
+++ b/internal/protocol/protocol.go
@@ -477,14 +477,37 @@ func (c *rawConnection) handleIndex(im IndexMessage) {
 	if debug {
 		l.Debugf("Index(%v, %v, %d files)", c.id, im.Folder, len(im.Files))
 	}
-	c.receiver.Index(c.id, im.Folder, im.Files)
+	c.receiver.Index(c.id, im.Folder, filterIndexMessageFiles(im.Files))
 }
 
 func (c *rawConnection) handleIndexUpdate(im IndexMessage) {
 	if debug {
 		l.Debugf("queueing IndexUpdate(%v, %v, %d files)", c.id, im.Folder, len(im.Files))
 	}
-	c.receiver.IndexUpdate(c.id, im.Folder, im.Files)
+	c.receiver.IndexUpdate(c.id, im.Folder, filterIndexMessageFiles(im.Files))
+}
+
+func filterIndexMessageFiles(fs []FileInfo) []FileInfo {
+	var out []FileInfo
+	for i, f := range fs {
+		if f.Name == "" {
+			l.Infoln("Dropping nil filename from incoming index")
+			if out == nil {
+				// Most incoming updates won't contain anything invalid, so we
+				// delay the allocation and copy to output slice until we
+				// really need to do it, then copy all the so var valid files
+				// to it.
+				out = make([]FileInfo, i, len(fs)-1)
+				copy(out, fs)
+			}
+		} else if out != nil {
+			out = append(out, f)
+		}
+	}
+	if out != nil {
+		return out
+	}
+	return fs
 }
 
 func (c *rawConnection) handleRequest(msgID int, req RequestMessage) {
