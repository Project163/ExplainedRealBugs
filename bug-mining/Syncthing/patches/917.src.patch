diff --git a/lib/model/folder_sendrecv.go b/lib/model/folder_sendrecv.go
index 5b0921073..b52294558 100644
--- a/lib/model/folder_sendrecv.go
+++ b/lib/model/folder_sendrecv.go
@@ -310,6 +310,7 @@ func (f *sendReceiveFolder) processNeeded(dbUpdateChan chan<- dbUpdateJob, copyC
 		}
 
 		if f.IgnoreDelete && intf.IsDeleted() {
+			f.resetPullError(intf.FileName())
 			l.Debugln(f, "ignore file deletion (config)", intf.FileName())
 			return true
 		}
@@ -318,6 +319,7 @@ func (f *sendReceiveFolder) processNeeded(dbUpdateChan chan<- dbUpdateJob, copyC
 
 		switch {
 		case f.ignores.ShouldIgnore(file.Name):
+			f.resetPullError(file.Name)
 			file.SetIgnored(f.shortID)
 			l.Debugln(f, "Handling ignored file", file)
 			dbUpdateChan <- dbUpdateJob{file, dbUpdateInvalidate}
@@ -352,6 +354,7 @@ func (f *sendReceiveFolder) processNeeded(dbUpdateChan chan<- dbUpdateJob, copyC
 				// We are supposed to copy the entire file, and then fetch nothing. We
 				// are only updating metadata, so we don't actually *need* to make the
 				// copy.
+				f.resetPullError(file.Name)
 				f.shortcutFile(file, curFile, dbUpdateChan)
 			} else {
 				// Queue files for processing after directories and symlinks.
@@ -359,6 +362,7 @@ func (f *sendReceiveFolder) processNeeded(dbUpdateChan chan<- dbUpdateJob, copyC
 			}
 
 		case runtime.GOOS == "windows" && file.IsSymlink():
+			f.resetPullError(file.Name)
 			file.SetUnsupported(f.shortID)
 			l.Debugln(f, "Invalidating symlink (unsupported)", file.Name)
 			dbUpdateChan <- dbUpdateJob{file, dbUpdateInvalidate}
@@ -367,6 +371,7 @@ func (f *sendReceiveFolder) processNeeded(dbUpdateChan chan<- dbUpdateJob, copyC
 		case file.IsDirectory() && !file.IsSymlink():
 			changed++
 			l.Debugln(f, "Handling directory", file.Name)
+			f.resetPullError(file.Name)
 			if f.checkParent(file.Name, scanChan) {
 				f.handleDir(file, dbUpdateChan, scanChan)
 			}
@@ -374,6 +379,7 @@ func (f *sendReceiveFolder) processNeeded(dbUpdateChan chan<- dbUpdateJob, copyC
 		case file.IsSymlink():
 			changed++
 			l.Debugln(f, "Handling symlink", file.Name)
+			f.resetPullError(file.Name)
 			if f.checkParent(file.Name, scanChan) {
 				f.handleSymlink(file, dbUpdateChan, scanChan)
 			}
@@ -424,6 +430,8 @@ nextFile:
 			break
 		}
 
+		f.resetPullError(fileName)
+
 		fi, ok := f.fset.GetGlobal(fileName)
 		if !ok {
 			// File is no longer in the index. Mark it as done and drop it.
@@ -497,6 +505,7 @@ func (f *sendReceiveFolder) processDeletions(fileDeletions map[string]protocol.F
 		}
 
 		l.Debugln(f, "Deleting file", file.Name)
+		f.resetPullError(file.Name)
 		if update, err := f.deleteFile(file, scanChan); err != nil {
 			f.newPullError(file.Name, errors.Wrap(err, "delete file"))
 		} else {
@@ -504,14 +513,14 @@ func (f *sendReceiveFolder) processDeletions(fileDeletions map[string]protocol.F
 		}
 	}
 
-	for i := range dirDeletions {
+	for _, dir := range dirDeletions {
 		select {
 		case <-f.ctx.Done():
 			return
 		default:
 		}
 
-		dir := dirDeletions[len(dirDeletions)-i-1]
+		f.resetPullError(dir.Name)
 		l.Debugln(f, "Deleting dir", dir.Name)
 		f.deleteDir(dir, dbUpdateChan, scanChan)
 	}
@@ -1755,6 +1764,14 @@ func (f *sendReceiveFolder) newPullError(path string, err error) {
 	f.pullErrors[path] = fmt.Sprintln("syncing:", err)
 }
 
+// resetPullError removes the error at path in case there was an error on a
+// previous pull iteration.
+func (f *sendReceiveFolder) resetPullError(path string) {
+	f.pullErrorsMut.Lock()
+	delete(f.pullErrors, path)
+	f.pullErrorsMut.Unlock()
+}
+
 func (f *sendReceiveFolder) clearPullErrors() {
 	f.pullErrorsMut.Lock()
 	f.pullErrors = make(map[string]string)
