diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/AvroCoder.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/AvroCoder.java
index bfe3a2ba7b4..09214909ce1 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/AvroCoder.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/AvroCoder.java
@@ -80,17 +80,16 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.base.Suppliers;
  * <pre>{@code
  * PCollection<MyCustomElement> records =
  *     input.apply(...)
- *          .setCoder(AvroCoder.of(MyCustomElement.class);
+ *          .setCoder(AvroCoder.of(MyCustomElement.class));
  * }</pre>
  *
  * <p>or annotate the element class using {@code @DefaultCoder}.
  *
- * <pre><code>
- * {@literal @}DefaultCoder(AvroCoder.class)
+ * <pre>{@code @DefaultCoder(AvroCoder.class)
  * public class MyCustomElement {
- *   ...
+ *     ...
  * }
- * </code></pre>
+ * }</pre>
  *
  * <p>The implementation attempts to determine if the Avro encoding of the given type will satisfy
  * the criteria of {@link Coder#verifyDeterministic} by inspecting both the type and the Schema
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java
index 8ebab5f9f72..e4f9ee01b04 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java
@@ -66,8 +66,8 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
  *
  * <p>The generated class corresponds to the following Java class:
  *
- * <pre>{@code
- * class SchemaRowCoder extends Coder<Row> {
+ * <pre><code>
+ * class SchemaRowCoder extends{@literal Coder<Row>} {
  *   // Generated array containing a coder for each field in the Schema.
  *   private static final Coder[] FIELD_CODERS;
  *
@@ -77,17 +77,19 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
  *     return schema;
  *   }
  *
- *   {@literal @}Override public void encode(T value, OutputStream outStream) {
+ *  {@literal @}Override
+ *   public void encode(T value, OutputStream outStream) {
  *     // Delegate to a method that evaluates each coder in the static array.
  *     encodeDelegate(FIELD_CODERS, value, outStream);
  *   }
  *
- *   {@literal @}Overide public abstract T decode(InputStream inStream) {
+ *  {@literal @}Overide
+ *   public abstract T decode(InputStream inStream) {
  *     // Delegate to a method that evaluates each coder in the static array.
  *     return decodeDelegate(FIELD_CODERS, inStream);
  *   }
  * }
- * }</pre>
+ * </code></pre>
  */
 public abstract class RowCoderGenerator {
   private static final ByteBuddy BYTE_BUDDY = new ByteBuddy();
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/fs/ResourceId.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/fs/ResourceId.java
index 7843d11398d..d1294a9d778 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/fs/ResourceId.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/fs/ResourceId.java
@@ -74,10 +74,10 @@ public interface ResourceId extends Serializable {
    * <ul>
    *   <li>{@code resourceId.resolve("..", StandardResolveOptions.RESOLVE_DIRECTORY)} returns the
    *       parent directory of this {@code ResourceId}.
-   *   <li>{@code resourceId.resolve("{@literal *}", StandardResolveOptions.RESOLVE_FILE)} returns a
-   *       {@code ResourceId} which matches all files in this {@code ResourceId}.
-   *   <li>{@code resourceId.resolve("{@literal *}", StandardResolveOptions.RESOLVE_DIRECTORY)}
-   *       returns a {@code ResourceId} which matches all directories in this {@code ResourceId}.
+   *   <li>{@code resourceId.resolve("*", StandardResolveOptions.RESOLVE_FILE)} returns a {@code
+   *       ResourceId} which matches all files in this {@code ResourceId}.
+   *   <li>{@code resourceId.resolve("*", StandardResolveOptions.RESOLVE_DIRECTORY)} returns a
+   *       {@code ResourceId} which matches all directories in this {@code ResourceId}.
    * </ul>
    *
    * @throws IllegalStateException if this {@link ResourceId} is not a directory.
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/metrics/Metrics.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/metrics/Metrics.java
index df3666a038a..aa26aacf6b4 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/metrics/Metrics.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/metrics/Metrics.java
@@ -38,17 +38,15 @@ import org.apache.beam.sdk.annotations.Experimental.Kind;
  *
  * <p>Example:
  *
- * <pre>{@code
- * class SomeDoFn extends DoFn<String, String> {
+ * <pre><code> class SomeDoFn extends{@literal DoFn<String, String>} {
  *   private Counter counter = Metrics.counter(SomeDoFn.class, "my-counter");
  *
- *   {@literal @}ProcessElement
+ *  {@literal @}ProcessElement
  *   public void processElement(ProcessContext c) {
  *     counter.inc();
  *     Metrics.counter(SomeDoFn.class, "my-counter2").inc();
  *   }
- * }
- * }</pre>
+ * }</code></pre>
  *
  * <p>See {@link MetricResults} (available from the {@code PipelineResults} interface) for an
  * example off how to query metrics.
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/DefaultSchema.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/DefaultSchema.java
index 66a7ad461b3..00c93767476 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/DefaultSchema.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/DefaultSchema.java
@@ -47,14 +47,13 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
  * <p>For example, if your class is JavaBean, the JavaBeanSchema provider class knows how to vend
  * schemas for this class. You can annotate it as follows:
  *
- * <pre><code>
- *   {@literal @}DefaultSchema(JavaBeanSchema.class)
- *   class MyClass {
- *     public String getFoo();
- *     void setFoo(String foo);
- *           ....
- *   }
- * </code></pre>
+ * <pre>{@code @DefaultSchema(JavaBeanSchema.class)
+ * class MyClass {
+ *   public String getFoo();
+ *   void setFoo(String foo);
+ *         ....
+ * }
+ * }</pre>
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
@@ -62,6 +61,8 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
 @SuppressWarnings("rawtypes")
 @Experimental(Kind.SCHEMAS)
 public @interface DefaultSchema {
+
+  /** The schema provider implementation that knows how to vend schemas for the annotated class. */
   @CheckForNull
   Class<? extends SchemaProvider> value();
 
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaCreate.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaCreate.java
index a3c51b28859..fa2fa38b10d 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaCreate.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaCreate.java
@@ -32,12 +32,12 @@ import org.apache.beam.sdk.annotations.Experimental.Kind;
  * <p>For example, the following Java POJO.
  *
  * <pre><code>
- *   {@literal @}DefaultSchema(JavaBeanSchema.class)
+ * {@literal @}DefaultSchema(JavaBeanSchema.class)
  *  class MyClass {
  *    public final String user;
  *    public final int age;
  *
- *    {@literal @}SchemaCreate
+ *   {@literal @}SchemaCreate
  *    public MyClass(String user, int age) {
  *      this.user = user;
  *      this.age = age;
@@ -53,14 +53,14 @@ import org.apache.beam.sdk.annotations.Experimental.Kind;
  *
  * <pre><code>
  * {@literal @}DefaultSchema(JavaBeanSchema.class)
- * class MyClass {
- *   public final String user;
- *   public final int age;
+ *  class MyClass {
+ *    public final String user;
+ *    public final int age;
  *
- *   private MyClass(String user, int age) { this.user = user; this.age = age; }
+ *    private MyClass(String user, int age) { this.user = user; this.age = age; }
  *
  *   {@literal @}SchemaCreate
- *   public static MyClass create(String user, int age) {
+ *    public static MyClass create(String user, int age) {
  *      return new MyClass(user, age);
  *    }
  * }
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaFieldName.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaFieldName.java
index 88c1de8a08c..ee0a9c9fc90 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaFieldName.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaFieldName.java
@@ -33,10 +33,11 @@ import org.apache.beam.sdk.annotations.Experimental.Kind;
  * <p>For example, a Java POJO with a field that we want in our schema but under a different name.
  *
  * <pre><code>
- *   {@literal @}DefaultSchema(JavaBeanSchema.class)
+ *  {@literal @}DefaultSchema(JavaBeanSchema.class)
  *   class MyClass {
  *     public String user;
- *     {@literal @}SchemaFieldName("age")
+ *
+ *    {@literal @}SchemaFieldName("age")
  *     public int ageInYears;
  *   }
  * </code></pre>
@@ -49,6 +50,8 @@ import org.apache.beam.sdk.annotations.Experimental.Kind;
 @SuppressWarnings("rawtypes")
 @Experimental(Kind.SCHEMAS)
 public @interface SchemaFieldName {
+
+  /** The name to use for the generated schema field. */
   @Nonnull
   String value();
 }
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaIgnore.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaIgnore.java
index b7419d5aa2b..7b6e67351a2 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaIgnore.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/annotations/SchemaIgnore.java
@@ -29,19 +29,21 @@ import org.apache.beam.sdk.annotations.Experimental.Kind;
  * When used on a POJO field or a JavaBean getter, that field or getter is ignored from the inferred
  * schema.
  *
- * <p>For example, a Java POJO with a field that we don't want included in the schema.
+ * <p>For example, a Java POJO with a field that we don't want included in the schema:
  *
  * <pre><code>
- *   {@literal @}DefaultSchema(JavaBeanSchema.class)
+ *  {@literal @}DefaultSchema(JavaBeanSchema.class)
  *   class MyClass {
  *     public String user;
  *     public int age;
- *     {@literal @}SchemaIgnore public String pleaseDontAddToSchema;
+ *
+ *    {@literal @}SchemaIgnore
+ *     public String pleaseDontAddToSchema;
  *   }
  * </code></pre>
  *
- * <p>In this case, the pleaseDontAddToSchema will be excluded from the schema, and implicitly
- * dropped from calculations.
+ * <p>In this case, the {@code pleaseDontAddToSchema} will be excluded from the schema, and
+ * implicitly dropped from calculations.
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/CoGroup.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/CoGroup.java
index 1ee6fadf756..ebcf418d57c 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/CoGroup.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/CoGroup.java
@@ -50,15 +50,14 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
  *
  * <p>This transform has similarites to {@link CoGroupByKey}, however works on PCollections that
  * have schemas. This allows users of the transform to simply specify schema fields to join on. The
- * output type of the transform is a {@literal KV<Row, Row>} where the value contains one field for
+ * output type of the transform is a {@code KV<Row, Row>} where the value contains one field for
  * every input PCollection and the key represents the fields that were joined on. By default the
  * cross product is not expanded, so all fields in the output row are array fields.
  *
  * <p>For example, the following demonstrates joining three PCollections on the "user" and "country"
- * fields.
+ * fields:
  *
- * <pre>{@code
- * TupleTag<Input1Type> input1Tag = new TupleTag<>("input1");
+ * <pre>{@code TupleTag<Input1Type> input1Tag = new TupleTag<>("input1");
  * TupleTag<Input2Type> input2Tag = new TupleTag<>("input2");
  * TupleTag<Input3Type> input3Tag = new TupleTag<>("input3");
  * PCollection<KV<Row, Row>> joined = PCollectionTuple
@@ -77,8 +76,7 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
  *
  * <p>To put it in other words, the key schema is convertible to the following POJO:
  *
- * <pre>{@code
- * {@literal @}DefaultSchema(JavaFieldSchema.class)
+ * <pre>{@code @DefaultSchema(JavaFieldSchema.class)
  * public class JoinedKey {
  *   public String user;
  *   public String country;
@@ -89,10 +87,9 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
  *     .apply(Convert.to(JoinedKey.class));
  * }</pre>
  *
- * The value schema is convertible to the following POJO:
+ * <p>The value schema is convertible to the following POJO:
  *
- * <pre>{@code
- * {@literal @}DefaultSchema(JavaFieldSchema.class)
+ * <pre>{@code @DefaultSchema(JavaFieldSchema.class)
  * public class JoinedValue {
  *   // The below lists contain all values from each of the three inputs that match on the given
  *   // key.
@@ -110,8 +107,7 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
  * those fields match. In this case, fields must be specified for every input PCollection. For
  * example:
  *
- * <pre>{@code
- * PCollection<KV<Row, Row>> joined = PCollectionTuple
+ * <pre>{@code PCollection<KV<Row, Row>> joined = PCollectionTuple
  *     .of(input1Tag, input1)
  *     .and(input2Tag, input2)
  *   .apply(CoGroup
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Group.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Group.java
index d1d4206d3e4..5ccd8afedc1 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Group.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Group.java
@@ -45,8 +45,7 @@ import org.apache.beam.sdk.values.Row;
  * the need for the user to explicitly extract the keys. For example, consider the following input
  * type:
  *
- * <pre>{@code
- * {@literal @DefaultSchema(JavaFieldSchema.class)}
+ * <pre>{@code @DefaultSchema(JavaFieldSchema.class)
  * public class UserPurchase {
  *   public String userId;
  *   public String country;
@@ -54,14 +53,13 @@ import org.apache.beam.sdk.values.Row;
  *   public double transactionDuration;
  * }
  *
- * {@literal PCollection<UserPurchase>} purchases = readUserPurchases();
+ * PCollection<UserPurchase> purchases = readUserPurchases();
  * }</pre>
  *
  * <p>You can group all purchases by user and country as follows:
  *
- * <pre>{@code
- * {@literal @DefaultSchema}(JavaFieldSchema.class)
- * {@literal PCollection<KV<Row, Iterable<UserPurchase>>} byUser =
+ * <pre>{@code @DefaultSchema(JavaFieldSchema.class)
+ * PCollection<KV<Row, Iterable<UserPurchase>> byUser =
  *   purchases.apply(Group.byFieldNames("userId', "country"));
  * }</pre>
  *
@@ -75,7 +73,7 @@ import org.apache.beam.sdk.values.Row;
  *          .aggregateField("cost", Sum.ofLongs(), "total_cost")
  *          .aggregateField("cost", Top.<Long>largestLongsFn(10), "top_purchases")
  *          .aggregateField("cost", ApproximateQuantilesCombineFn.create(21),
- *            Field.of("transactionDurations", FieldType.array(FieldType.INT64)));
+ *              Field.of("transactionDurations", FieldType.array(FieldType.INT64)));
  * }</pre>
  *
  * <p>The result will be a new row schema containing the fields total_cost, top_purchases, and
@@ -462,8 +460,8 @@ public class Group {
   /**
    * a {@link PTransform} that groups schema elements based on the given fields.
    *
-   * <p>The output of this transform is a KV where the key type is a {@link Row} containing the
-   * extracted fields.
+   * <p>The output of this transform is a {@link KV} where the key type is a {@link Row} containing
+   * the extracted fields.
    */
   public static class ByFields<InputT>
       extends PTransform<PCollection<InputT>, PCollection<KV<Row, Iterable<InputT>>>> {
@@ -480,7 +478,7 @@ public class Group {
 
     /**
      * Aggregate the grouped data using the specified {@link CombineFn}. The resulting {@link
-     * PCollection} will have type {@literal PCollection<KV<Row, OutputT>>}.
+     * PCollection} will have type {@code PCollection<KV<Row, OutputT>>}.
      */
     public <OutputT> CombineByFields<InputT, OutputT> aggregate(
         CombineFn<InputT, ?, OutputT> combineFn) {
@@ -654,8 +652,8 @@ public class Group {
   /**
    * a {@link PTransform} that does a per0-key combine using a specified {@link CombineFn}.
    *
-   * <p>The output of this transform is a {@literal <KV<Row, OutputT>} where the key type is a
-   * {@link Row} containing the extracted fields.
+   * <p>The output of this transform is a {@code <KV<Row, OutputT>>} where the key type is a {@link
+   * Row} containing the extracted fields.
    */
   public static class CombineByFields<InputT, OutputT>
       extends PTransform<PCollection<InputT>, PCollection<KV<Row, OutputT>>> {
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Select.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Select.java
index 1f26a8f7403..266e2d0c1f2 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Select.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Select.java
@@ -49,21 +49,19 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
  *
  * <p>For example, consider the following POJO type:
  *
- * <pre>{@code
- * {@literal @}DefaultSchema(JavaFieldSchema.class)
+ * <pre>{@code @DefaultSchema(JavaFieldSchema.class)
  * public class UserEvent {
  *   public String userId;
  *   public String eventId;
  *   public int eventType;
  *   public Location location;
- * }
+ * }}</pre>
  *
- * {@literal @}DefaultSchema(JavaFieldSchema.class)
+ * <pre>{@code @DefaultSchema(JavaFieldSchema.class)
  * public class Location {
  *   public double latitude;
  *   public double longtitude;
- * }
- * }</pre>
+ * }}</pre>
  *
  * Say you want to select just the set of userId, eventId pairs from each element, you would write
  * the following:
@@ -78,7 +76,7 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
  *
  * <pre>{@code
  * PCollection<UserEvent> events = readUserEvents();
- * PCollection<Row> rows = event.apply(Select.fieldNames("location.*"))
+ * PCollection<Row> rows = event.apply(Select.fieldNames("location.*"));
  * }</pre>
  */
 @Experimental(Kind.SCHEMAS)
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/utils/POJOUtils.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/utils/POJOUtils.java
index dda263441d9..68d9cbf1d6d 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/utils/POJOUtils.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/utils/POJOUtils.java
@@ -63,7 +63,7 @@ import org.apache.beam.sdk.util.common.ReflectHelpers;
 import org.apache.beam.sdk.values.TypeDescriptor;
 import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;
 
-/** A set of utilities yo generate getter and setter classes for POJOs. */
+/** A set of utilities to generate getter and setter classes for POJOs. */
 @Experimental(Kind.SCHEMAS)
 public class POJOUtils {
   public static Schema schemaFromPojoClass(
@@ -229,7 +229,7 @@ public class POJOUtils {
    *   class Getter implements {@literal FieldValueGetter<POJO, FieldType>} {
    *     {@literal @}Override public String name() { return field.getName(); }
    *     {@literal @}Override public Class type() { return field.getType(); }
-   *      {@literal @}Override public FieldType get(POJO pojo) {
+   *     {@literal @}Override public FieldType get(POJO pojo) {
    *        return convert(pojo.field);
    *      }
    *   }
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/testing/TestPipeline.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/testing/TestPipeline.java
index 23a562096d8..6967a649d63 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/testing/TestPipeline.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/testing/TestPipeline.java
@@ -73,7 +73,7 @@ import org.junit.runners.model.Statement;
  *     "--runner=TestDataflowRunner",
  *     "--project=mygcpproject",
  *     "--stagingLocation=gs://mygcsbucket/path"
- *     ]}</pre>
+ * ]}</pre>
  *       Note that the set of pipeline options required is pipeline runner specific.
  *   <li>Jars containing the SDK and test classes must be available on the classpath.
  * </ul>
@@ -83,15 +83,15 @@ import org.junit.runners.model.Statement;
  *
  * <pre><code>
  * {@literal @Rule}
- * public final transient TestPipeline p = TestPipeline.create();
+ *  public final transient TestPipeline p = TestPipeline.create();
  *
  * {@literal @Test}
  * {@literal @Category}(NeedsRunner.class)
- * public void myPipelineTest() throws Exception {
- *   final PCollection&lt;String&gt; pCollection = pipeline.apply(...)
- *   PAssert.that(pCollection).containsInAnyOrder(...);
- *   pipeline.run();
- * }
+ *  public void myPipelineTest() throws Exception {
+ *    final PCollection&lt;String&gt; pCollection = pipeline.apply(...)
+ *    PAssert.that(pCollection).containsInAnyOrder(...);
+ *    pipeline.run();
+ *  }
  * </code></pre>
  *
  * <p>For pipeline runners, it is required that they must throw an {@link AssertionError} containing
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Combine.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Combine.java
index aad7c42d5fd..2c544663212 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Combine.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Combine.java
@@ -252,13 +252,13 @@ public class Combine {
    *
    * <p>For example:
    *
-   * <pre>{@code
-   * public class AverageFn extends CombineFn<Integer, AverageFn.Accum, Double> {
+   * <pre><code>
+   * public class AverageFn extends{@literal CombineFn<Integer, AverageFn.Accum, Double>} {
    *   public static class Accum implements Serializable {
    *     int sum = 0;
    *     int count = 0;
    *
-   *    {@literal@}Override
+   *    {@literal @Override}
    *     public boolean equals(Object other) {
    *       if (other == null) return false;
    *       if (other == this) return true;
@@ -277,12 +277,14 @@ public class Combine {
    *   public Accum createAccumulator() {
    *     return new Accum();
    *   }
+   *
    *   public Accum addInput(Accum accum, Integer input) {
    *       accum.sum += input;
    *       accum.count++;
    *       return accum;
    *   }
-   *   public Accum mergeAccumulators(Iterable<Accum> accums) {
+   *
+   *   public Accum{@literal mergeAccumulators(Iterable<Accum> accums)} {
    *     Accum merged = createAccumulator();
    *     for (Accum accum : accums) {
    *       merged.sum += accum.sum;
@@ -290,13 +292,14 @@ public class Combine {
    *     }
    *     return merged;
    *   }
+   *
    *   public Double extractOutput(Accum accum) {
    *     return ((double) accum.sum) / accum.count;
    *   }
-   * }
+   * }{@literal
    * PCollection<Integer> pc = ...;
    * PCollection<Double> average = pc.apply(Combine.globally(new AverageFn()));
-   * }</pre>
+   * }</code></pre>
    *
    * <p>Combining functions used by {@link Combine.Globally}, {@link Combine.PerKey}, {@link
    * Combine.GroupedValues}, and {@code PTransforms} derived from them should be <i>associative</i>
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/CombineFns.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/CombineFns.java
index 41d5c0dc428..6a848c70702 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/CombineFns.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/CombineFns.java
@@ -59,37 +59,37 @@ public class CombineFns {
    *
    * <p>Example:
    *
-   * <pre>{@code
-   * PCollection<Integer> globalLatencies = ...;
+   * <pre>{@code  PCollection<Integer> globalLatencies = ...;
    *
-   * TupleTag<Integer> maxLatencyTag = new TupleTag<Integer>();
-   * TupleTag<Double> meanLatencyTag = new TupleTag<Double>();
+   *  TupleTag<Integer> maxLatencyTag = new TupleTag<Integer>();
+   *  TupleTag<Double> meanLatencyTag = new TupleTag<Double>();}
    *
-   * SimpleFunction<Integer, Integer> identityFn =
-   *     new SimpleFunction<Integer, Integer>() {
-   *       {@literal @}Override
+   * {@code SimpleFunction<Integer, Integer> identityFn =
+   *     new SimpleFunction<Integer, Integer>() }{
+   *      {@code @Override
    *       public Integer apply(Integer input) {
    *           return input;
-   *       }};
-   * PCollection<CoCombineResult> maxAndMean = globalLatencies.apply(
+   *       }}};
+   *
+   * {@code PCollection<CoCombineResult> maxAndMean = globalLatencies.apply(
    *     Combine.globally(
    *         CombineFns.compose()
    *            .with(identityFn, new MaxIntegerFn(), maxLatencyTag)
-   *            .with(identityFn, new MeanFn<Integer>(), meanLatencyTag)));
+   *            .with(identityFn, new MeanFn<Integer>(), meanLatencyTag)))};
    *
-   * PCollection<T> finalResultCollection = maxAndMean
+   * {@code PCollection<T> finalResultCollection = maxAndMean
    *     .apply(ParDo.of(
-   *         new DoFn<CoCombineResult, T>() {
-   *          {@literal @}ProcessElement
-   *           public void processElement(
-   *            {@literal @}Element CoCombineResult e, OutputReceiver<T> r) throws Exception {
-   *             Integer maxLatency = e.get(maxLatencyTag);
-   *             Double meanLatency = e.get(meanLatencyTag);
-   *             .... Do Something ....
-   *             r.output(...some T...);
-   *           }
-   *         }));
-   * }</pre>
+   *         new DoFn<CoCombineResult, T>() }{
+   *            {@code @ProcessElement
+   *             public void processElement(}
+   *                  {@code @Element CoCombineResult e, OutputReceiver<T> r) throws Exception {
+   *                 Integer maxLatency = e.get(maxLatencyTag);
+   *                 Double meanLatency = e.get(meanLatencyTag);
+   *                 .... Do Something ....
+   *                 r.output(...some T...);
+   *              }
+   *         }}));
+   * </pre>
    */
   public static ComposeCombineFnBuilder compose() {
     return new ComposeCombineFnBuilder();
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupByKey.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupByKey.java
index cdeca11b52b..78efbf7e322 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupByKey.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupByKey.java
@@ -64,14 +64,14 @@ import org.apache.beam.sdk.values.WindowingStrategy;
  * PCollection<KV<String, Iterable<Doc>>> urlToDocs =
  *     urlDocPairs.apply(GroupByKey.<String, Doc>create());
  * PCollection<R> results =
- *     urlToDocs.apply(ParDo.of(new DoFn<KV<String, Iterable<Doc>>, R>() {
- *      {@literal @}ProcessElement
+ *     urlToDocs.apply(ParDo.of(new DoFn<KV<String, Iterable<Doc>>, R>() }{
+ *      {@code @ProcessElement
  *       public void processElement(ProcessContext c) {
  *         String url = c.element().getKey();
  *         Iterable<Doc> docsWithThatUrl = c.element().getValue();
  *         ... process all docs having that url ...
- *       }}));
- * }</pre>
+ *       }}}));
+ * </pre>
  *
  * <p>{@code GroupByKey} is a key primitive in data-parallel processing, since it is the main way to
  * efficiently bring associated data together into one location. It is also a key determiner of the
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ParDo.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ParDo.java
index e7ef933256e..3eccffb546f 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ParDo.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ParDo.java
@@ -119,26 +119,25 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.ImmutableLis
  *
  * <p>For example:
  *
- * <pre>{@code
- * PCollection<String> lines = ...;
+ * <pre>{@code PCollection<String> lines = ...;
  * PCollection<String> words =
- *     lines.apply(ParDo.of(new DoFn<String, String>() {
- *        {@literal @}ProcessElement
- *         public void processElement({@literal @}Element String line,
+ *     lines.apply(ParDo.of(new DoFn<String, String>() }{
+ *        {@code @ProcessElement
+ *         public void processElement(@Element String line,
  *           OutputReceiver<String> r) {
  *           for (String word : line.split("[^a-zA-Z']+")) {
  *             r.output(word);
  *           }
- *         }}));
- * PCollection<Integer> wordLengths =
- *     words.apply(ParDo.of(new DoFn<String, Integer>() {
- *        {@literal @}ProcessElement
- *         public void processElement({@literal @}Element String word,
+ *         }}}));
+ * {@code PCollection<Integer> wordLengths =
+ *     words.apply(ParDo.of(new DoFn<String, Integer>() }{
+ *        {@code @ProcessElement
+ *         public void processElement(@Element String word,
  *           OutputReceiver<Integer> r) {
  *           Integer length = word.length();
  *           r.output(length);
- *         }}));
- * }</pre>
+ *         }}}));
+ * </pre>
  *
  * <p>Each output element has the same timestamp and is in the same windows as its corresponding
  * input element, and the output {@code PCollection} has the same {@link WindowFn} associated with
@@ -153,8 +152,7 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.ImmutableLis
  *
  * <p>For example:
  *
- * <pre>{@code
- * PCollection<String> words =
+ * <pre>{@code PCollection<String> words =
  *     lines.apply("ExtractWords", ParDo.of(new DoFn<String, String>() { ... }));
  * PCollection<Integer> wordLengths =
  *     words.apply("ComputeWordLengths", ParDo.of(new DoFn<String, Integer>() { ... }));
@@ -169,22 +167,21 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.ImmutableLis
  * using {@link SingleOutput#withSideInputs}, and their contents accessible to each of the {@link
  * DoFn} operations via {@link DoFn.ProcessContext#sideInput sideInput}. For example:
  *
- * <pre>{@code
- * PCollection<String> words = ...;
+ * <pre>{@code PCollection<String> words = ...;
  * PCollection<Integer> maxWordLengthCutOff = ...; // Singleton PCollection
  * final PCollectionView<Integer> maxWordLengthCutOffView =
  *     maxWordLengthCutOff.apply(View.<Integer>asSingleton());
  * PCollection<String> wordsBelowCutOff =
- *     words.apply(ParDo.of(new DoFn<String, String>() {
- *        {@literal @}ProcessElement
+ *     words.apply(ParDo.of(new DoFn<String, String>() }{
+ *        {@code @ProcessElement
  *         public void processElement(ProcessContext c) {
- *           String word = c.element();
- *           int lengthCutOff = c.sideInput(maxWordLengthCutOffView);
- *           if (word.length() <= lengthCutOff) {
- *             c.output(word);
- *           }
- *         }}).withSideInputs(maxWordLengthCutOffView));
- * }</pre>
+ *             String word = c.element();
+ *             int lengthCutOff = c.sideInput(maxWordLengthCutOffView);
+ *             if (word.length() <= lengthCutOff) {
+ *                 c.output(word);
+ *             }
+ *         }}}).withSideInputs(maxWordLengthCutOffView));
+ * </pre>
  *
  * <h2>Additional Outputs</h2>
  *
@@ -198,8 +195,7 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.ImmutableLis
  * normal, using {@link WindowedContext#output(Object)}, while an element is added to any additional
  * output {@link PCollection} using {@link WindowedContext#output(TupleTag, Object)}. For example:
  *
- * <pre>{@code
- * PCollection<String> words = ...;
+ * <pre>{@code PCollection<String> words = ...;
  * // Select words whose length is below a cut off,
  * // plus the lengths of words that are above the cut off.
  * // Also select words starting with "MARKER".
@@ -217,8 +213,8 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.ImmutableLis
  *         .of(new DoFn<String, String>() {
  *             // Create a tag for the unconsumed output.
  *             final TupleTag<String> specialWordsTag =
- *                 new TupleTag<String>(){};
- *            {@literal @}ProcessElement
+ *                 new TupleTag<String>(){};}}
+ *            {@code @ProcessElement
  *             public void processElement(@Element String word, MultiOutputReceiver r) {
  *               if (word.length() <= wordLengthCutOff) {
  *                 // Emit this short word to the main output.
@@ -235,13 +231,13 @@ import org.apache.beam.vendor.guava.v20_0.com.google.common.collect.ImmutableLis
  *                 // Emit this word to the unconsumed output.
  *                 r.output(specialWordsTag, word);
  *               }
- *             }})
+ *             }}})
  *             // Specify the main and consumed output tags of the
  *             // PCollectionTuple result:
  *         .withOutputTags(wordsBelowCutOffTag,
  *             TupleTagList.of(wordLengthsAboveCutOffTag)
  *                         .and(markedWordsTag)));
- * // Extract the PCollection results, by tag.
+ * // Extract the PCollection results, by tag.{@code
  * PCollection<String> wordsBelowCutOff =
  *     results.get(wordsBelowCutOffTag);
  * PCollection<Integer> wordLengthsAboveCutOff =
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java
index a11335475e1..df1debb15df 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java
@@ -109,16 +109,16 @@ import org.apache.beam.sdk.values.PCollectionViews;
  *
  * PCollection<PageVisit> pageVisits = urlVisits
  *     .apply(ParDo.withSideInputs(urlToPageView)
- *         .of(new DoFn<UrlVisit, PageVisit>() {
- *             {@literal @}Override
+ *         .of(new DoFn<UrlVisit, PageVisit>() }{
+ *            {@code @Override
  *             void processElement(ProcessContext context) {
- *               UrlVisit urlVisit = context.element();
- *               Map<URL, Page> urlToPage = context.sideInput(urlToPageView);
- *               Page page = urlToPage.get(urlVisit.getUrl());
- *               c.output(new PageVisit(page, urlVisit.getVisitData()));
+ *                 UrlVisit urlVisit = context.element();
+ *                 Map<URL, Page> urlToPage = context.sideInput(urlToPageView);
+ *                 Page page = urlToPage.get(urlVisit.getUrl());
+ *                 c.output(new PageVisit(page, urlVisit.getVisitData()));
  *             }
- *         }));
- * }</pre>
+ *         }}));
+ * </pre>
  *
  * <p>See {@link ParDo.SingleOutput#withSideInputs} for details on how to access this variable
  * inside a {@link ParDo} over another {@link PCollection}.
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/display/DisplayData.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/display/DisplayData.java
index 366f54b51b5..24d60479435 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/display/DisplayData.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/display/DisplayData.java
@@ -85,8 +85,7 @@ public class DisplayData implements Serializable {
    *
    * <p>Use this method if the type of metadata is not known at compile time. For example:
    *
-   * <pre>{@code
-   * {@literal @}Override
+   * <pre>{@code @Override
    * public void populateDisplayData(DisplayData.Builder builder) {
    *   Optional<DisplayData.Type> type = DisplayData.inferType(foo);
    *   if (type.isPresent()) {
@@ -150,7 +149,7 @@ public class DisplayData implements Serializable {
      * {@link PTransform} which delegates to a user-provided function can implement {@link
      * HasDisplayData} on the function and include it from the {@link PTransform}:
      *
-     * <pre><code>{@literal @Override}
+     * <pre>{@code @Override
      * public void populateDisplayData(DisplayData.Builder builder) {
      *   super.populateDisplayData(builder);
      *
@@ -160,7 +159,7 @@ public class DisplayData implements Serializable {
      *     // To allow the userFn to register additional display data
      *     .include("userFn", userFn);
      * }
-     * </code></pre>
+     * }</pre>
      *
      * <p>Using {@code include(path, subcomponent)} will associate each of the registered items with
      * the namespace of the {@code subcomponent} being registered, with the specified path element
@@ -181,11 +180,11 @@ public class DisplayData implements Serializable {
      * display data from the wrapped component. Such components should implement {@code
      * populateDisplayData} as:
      *
-     * <pre><code>{@literal @Override}
+     * <pre>{@code @Override
      * public void populateDisplayData(DisplayData.Builder builder) {
      *   builder.delegate(wrapped);
      * }
-     * </code></pre>
+     * }</pre>
      */
     Builder delegate(HasDisplayData component);
 
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/join/CoGroupByKey.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/join/CoGroupByKey.java
index 9053ad0b172..367299c40f8 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/join/CoGroupByKey.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/join/CoGroupByKey.java
@@ -54,8 +54,8 @@ import org.apache.beam.sdk.values.PCollectionList;
  *
  * PCollection<T> finalResultCollection =
  *   coGbkResultCollection.apply(ParDo.of(
- *     new DoFn<KV<K, CoGbkResult>, T>() {
- *       {@literal @}ProcessElement
+ *     new DoFn<KV<K, CoGbkResult>, T>() }{
+ *      {@code @ProcessElement
  *       public void processElement(ProcessContext c) {
  *         KV<K, CoGbkResult> e = c.element();
  *         Iterable<V1> pt1Vals = e.getValue().getAll(t1);
@@ -63,8 +63,8 @@ import org.apache.beam.sdk.values.PCollectionList;
  *          ... Do Something ....
  *         c.output(...some T...);
  *       }
- *     }));
- * }</pre>
+ *     }}));
+ * </pre>
  *
  * @param <K> the type of the keys in the input and output {@code PCollection}s
  */
