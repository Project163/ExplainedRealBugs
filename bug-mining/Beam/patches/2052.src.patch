diff --git a/CHANGES.md b/CHANGES.md
index 9e6906f7797..6d7cdfb23e7 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -73,6 +73,11 @@
 * In Interactive Beam, ib.show() and ib.collect() now have "n" and "duration" as parameters. These mean read only up to "n" elements and up to "duration" seconds of data read from the recording ([BEAM-10603](https://issues.apache.org/jira/browse/BEAM-10603)).
 * Initial preview of [Dataframes](https://s.apache.org/simpler-python-pipelines-2020#slide=id.g905ac9257b_1_21) support.
     See also example at apache_beam/examples/wordcount_dataframe.py
+* Fixed support for type hints on `@ptransform_fn` decorators in the Python SDK.
+  ([BEAM-4091](https://issues.apache.org/jira/browse/BEAM-4091))
+  This has not enabled by default to preserve backwards compatibility; use the
+  `--type_check_additional=ptransform_fn` flag to enable. It may be enabled by
+  default in future versions of Beam.
 * X feature added (Java/Python) ([BEAM-X](https://issues.apache.org/jira/browse/BEAM-X)).
 
 ## Breaking Changes
diff --git a/sdks/python/apache_beam/options/pipeline_options.py b/sdks/python/apache_beam/options/pipeline_options.py
index 654810f6c21..01889883e6e 100644
--- a/sdks/python/apache_beam/options/pipeline_options.py
+++ b/sdks/python/apache_beam/options/pipeline_options.py
@@ -34,6 +34,7 @@ from typing import Optional
 from typing import Type
 from typing import TypeVar
 
+import apache_beam as beam
 from apache_beam.options.value_provider import RuntimeValueProvider
 from apache_beam.options.value_provider import StaticValueProvider
 from apache_beam.options.value_provider import ValueProvider
@@ -445,6 +446,22 @@ class CrossLanguageOptions(PipelineOptions):
             'artifacts (e.g. jar files) expansion endpoints (e.g. host:port).'))
 
 
+def additional_option_ptransform_fn():
+  beam.transforms.ptransform.ptransform_fn_typehints_enabled = True
+
+
+# Optional type checks that aren't enabled by default.
+additional_type_checks = {
+    'ptransform_fn': additional_option_ptransform_fn,
+}  # type: Dict[str, Callable[[], None]]
+
+
+def enable_all_additional_type_checks():
+  """Same as passing --type_check_additional=all."""
+  for f in additional_type_checks.values():
+    f()
+
+
 class TypeOptions(PipelineOptions):
   @classmethod
   def _add_argparse_args(cls, parser):
@@ -455,6 +472,12 @@ class TypeOptions(PipelineOptions):
         choices=['ALL_REQUIRED', 'DEFAULT_TO_ANY'],
         help='The level of exhaustive manual type-hint '
         'annotation required')
+    parser.add_argument(
+        '--type_check_additional',
+        default='',
+        help='Comma separated list of additional type checking features to '
+        'enable. Options: all, ptransform_fn. For details see:'
+        'https://beam.apache.org/documentation/sdks/python-type-safety/')
     parser.add_argument(
         '--no_pipeline_type_check',
         dest='pipeline_type_check',
@@ -476,6 +499,26 @@ class TypeOptions(PipelineOptions):
         'time. NOTE: only supported with portable runners '
         '(including the DirectRunner)')
 
+  def validate(self, unused_validator):
+    errors = []
+    if beam.version.__version__ >= '3':
+      errors.append(
+          'Update --type_check_additional default to include all '
+          'available additional checks at Beam 3.0 release time.')
+    keys = self.type_check_additional.split(',')
+
+    for key in keys:
+      if not key:
+        continue
+      elif key == 'all':
+        enable_all_additional_type_checks()
+      elif key in additional_type_checks:
+        additional_type_checks[key]()
+      else:
+        errors.append('Unrecognized --type_check_additional feature: %s' % key)
+
+    return errors
+
 
 class DirectOptions(PipelineOptions):
   """DirectRunner-specific execution options."""
diff --git a/sdks/python/apache_beam/options/pipeline_options_validator_test.py b/sdks/python/apache_beam/options/pipeline_options_validator_test.py
index ebdde4d3f5c..47ff2d75be0 100644
--- a/sdks/python/apache_beam/options/pipeline_options_validator_test.py
+++ b/sdks/python/apache_beam/options/pipeline_options_validator_test.py
@@ -556,6 +556,25 @@ class SetupTest(unittest.TestCase):
         only_contains(
             contains_string('Invalid transform name mapping format.')))
 
+  def test_type_check_additional(self):
+    runner = MockRunners.OtherRunner()
+    options = PipelineOptions(['--type_check_additional=all'])
+    validator = PipelineOptionsValidator(options, runner)
+    errors = validator.validate()
+    self.assertFalse(errors)
+
+    options = PipelineOptions(['--type_check_additional='])
+    validator = PipelineOptionsValidator(options, runner)
+    errors = validator.validate()
+    self.assertFalse(errors)
+
+  def test_type_check_additional_unrecognized_feature(self):
+    runner = MockRunners.OtherRunner()
+    options = PipelineOptions(['--type_check_additional=all,dfgdf'])
+    validator = PipelineOptionsValidator(options, runner)
+    errors = validator.validate()
+    self.assertTrue(errors)
+
 
 if __name__ == '__main__':
   logging.getLogger().setLevel(logging.INFO)
diff --git a/sdks/python/apache_beam/transforms/ptransform.py b/sdks/python/apache_beam/transforms/ptransform.py
index a33d24725a1..b1f5bec4385 100644
--- a/sdks/python/apache_beam/transforms/ptransform.py
+++ b/sdks/python/apache_beam/transforms/ptransform.py
@@ -40,6 +40,7 @@ from __future__ import absolute_import
 
 import copy
 import itertools
+import logging
 import operator
 import os
 import sys
@@ -96,10 +97,13 @@ __all__ = [
     'label_from_callable',
 ]
 
+_LOGGER = logging.getLogger(__name__)
+
 T = TypeVar('T')
 PTransformT = TypeVar('PTransformT', bound='PTransform')
 ConstructorFn = Callable[
     ['beam_runner_api_pb2.PTransform', Optional[Any], 'PipelineContext'], Any]
+ptransform_fn_typehints_enabled = False
 
 
 class _PValueishTransform(object):
@@ -939,8 +943,6 @@ class _PTransformFnPTransform(PTransform):
 def ptransform_fn(fn):
   """A decorator for a function-based PTransform.
 
-  Experimental; no backwards-compatibility guarantees.
-
   Args:
     fn: A function implementing a custom PTransform.
 
@@ -954,11 +956,15 @@ def ptransform_fn(fn):
   resulting PCollection. For example::
 
     @ptransform_fn
+    @beam.typehints.with_input_types(..)
+    @beam.typehints.with_output_types(..)
     def CustomMapper(pcoll, mapfn):
       return pcoll | ParDo(mapfn)
 
   The equivalent approach using PTransform subclassing::
 
+    @beam.typehints.with_input_types(..)
+    @beam.typehints.with_output_types(..)
     class CustomMapper(PTransform):
 
       def __init__(self, mapfn):
@@ -976,11 +982,28 @@ def ptransform_fn(fn):
   Note that for both solutions the underlying implementation of the pipe
   operator (i.e., `|`) will inject the pcoll argument in its proper place
   (first argument if no label was specified and second argument otherwise).
+
+  Type hint support needs to be enabled via the
+  --type_check_additional=ptransform_fn flag in Beam 2.
+  If CustomMapper is a Cython function, you can still specify input and output
+  types provided the decorators appear before @ptransform_fn.
   """
   # TODO(robertwb): Consider removing staticmethod to allow for self parameter.
   @wraps(fn)
   def callable_ptransform_factory(*args, **kwargs):
-    return _PTransformFnPTransform(fn, *args, **kwargs)
+    res = _PTransformFnPTransform(fn, *args, **kwargs)
+    if ptransform_fn_typehints_enabled:
+      # Apply type hints applied before or after the ptransform_fn decorator,
+      # falling back on PTransform defaults.
+      # If the @with_{input,output}_types decorator comes before ptransform_fn,
+      # the type hints get applied to this function. If it comes after they will
+      # get applied to fn, and @wraps will copy the _type_hints attribute to
+      # this function.
+      type_hints = get_type_hints(callable_ptransform_factory)
+      res._set_type_hints(type_hints.with_defaults(res.get_type_hints()))
+      _LOGGER.debug(
+          'type hints for %s: %s', res.default_label(), res.get_type_hints())
+    return res
 
   return callable_ptransform_factory
 
diff --git a/sdks/python/apache_beam/transforms/util.py b/sdks/python/apache_beam/transforms/util.py
index b31ed67a375..e6662f07978 100644
--- a/sdks/python/apache_beam/transforms/util.py
+++ b/sdks/python/apache_beam/transforms/util.py
@@ -1009,7 +1009,7 @@ class Regex(object):
 
   @staticmethod
   @typehints.with_input_types(str)
-  @typehints.with_output_types(Union[List[str], Tuple[str, str]])
+  @typehints.with_output_types(Union[List[str], List[Tuple[str, str]]])
   @ptransform_fn
   def find_all(pcoll, regex, group=0, outputEmpty=True):
     """
diff --git a/sdks/python/apache_beam/typehints/decorators.py b/sdks/python/apache_beam/typehints/decorators.py
index 4cd7681d7b5..c0ebe9d022d 100644
--- a/sdks/python/apache_beam/typehints/decorators.py
+++ b/sdks/python/apache_beam/typehints/decorators.py
@@ -579,6 +579,10 @@ class WithTypeHints(object):
             self.default_type_hints()).with_defaults(
                 get_type_hints(self.__class__)))
 
+  def _set_type_hints(self, type_hints):
+    # type: (IOTypeHints) -> None
+    self._type_hints = type_hints
+
   def default_type_hints(self):
     return None
 
diff --git a/sdks/python/apache_beam/typehints/typed_pipeline_test.py b/sdks/python/apache_beam/typehints/typed_pipeline_test.py
index 4ad44af037e..21a1803f40f 100644
--- a/sdks/python/apache_beam/typehints/typed_pipeline_test.py
+++ b/sdks/python/apache_beam/typehints/typed_pipeline_test.py
@@ -206,6 +206,64 @@ class MainInputTest(unittest.TestCase):
       assert_that(res_even, equal_to([2]), label='even_check')
       assert_that(res_odd, equal_to([1, 3]), label='odd_check')
 
+  def test_typed_ptransform_fn_pre_hints(self):
+    # Test that type hints are propagated to the created PTransform.
+    # Decorator appears before type hints. This is the more common style.
+    @beam.ptransform_fn
+    @typehints.with_input_types(int)
+    def MyMap(pcoll):
+      return pcoll | beam.ParDo(lambda x: [x])
+
+    self.assertListEqual([1, 2, 3], [1, 2, 3] | MyMap())
+    with self.assertRaises(typehints.TypeCheckError):
+      _ = ['a'] | MyMap()
+
+  def test_typed_ptransform_fn_post_hints(self):
+    # Test that type hints are propagated to the created PTransform.
+    # Decorator appears after type hints. This style is required for Cython
+    # functions, since they don't accept assigning attributes to them.
+    @typehints.with_input_types(int)
+    @beam.ptransform_fn
+    def MyMap(pcoll):
+      return pcoll | beam.ParDo(lambda x: [x])
+
+    self.assertListEqual([1, 2, 3], [1, 2, 3] | MyMap())
+    with self.assertRaises(typehints.TypeCheckError):
+      _ = ['a'] | MyMap()
+
+  def test_typed_ptransform_fn_multi_input_types_pos(self):
+    @beam.ptransform_fn
+    @beam.typehints.with_input_types(str, int)
+    def multi_input(pcoll_tuple, additional_arg):
+      _, _ = pcoll_tuple
+      assert additional_arg == 'additional_arg'
+
+    with TestPipeline() as p:
+      pcoll1 = p | 'c1' >> beam.Create(['a'])
+      pcoll2 = p | 'c2' >> beam.Create([1])
+      _ = (pcoll1, pcoll2) | multi_input('additional_arg')
+      with self.assertRaises(typehints.TypeCheckError):
+        _ = (pcoll2, pcoll1) | 'fails' >> multi_input('additional_arg')
+
+  def test_typed_ptransform_fn_multi_input_types_kw(self):
+    @beam.ptransform_fn
+    @beam.typehints.with_input_types(strings=str, integers=int)
+    def multi_input(pcoll_dict, additional_arg):
+      _ = pcoll_dict['strings']
+      _ = pcoll_dict['integers']
+      assert additional_arg == 'additional_arg'
+
+    with TestPipeline() as p:
+      pcoll1 = p | 'c1' >> beam.Create(['a'])
+      pcoll2 = p | 'c2' >> beam.Create([1])
+      _ = {
+          'strings': pcoll1, 'integers': pcoll2
+      } | multi_input('additional_arg')
+      with self.assertRaises(typehints.TypeCheckError):
+        _ = {
+            'strings': pcoll2, 'integers': pcoll1
+        } | 'fails' >> multi_input('additional_arg')
+
 
 class NativeTypesTest(unittest.TestCase):
   def test_good_main_input(self):
diff --git a/sdks/python/apache_beam/typehints/typed_pipeline_test_py3.py b/sdks/python/apache_beam/typehints/typed_pipeline_test_py3.py
index 88a367436c9..6c45c5ceb8d 100644
--- a/sdks/python/apache_beam/typehints/typed_pipeline_test_py3.py
+++ b/sdks/python/apache_beam/typehints/typed_pipeline_test_py3.py
@@ -202,6 +202,38 @@ class MainInputTest(unittest.TestCase):
     result = [1, 2] | beam.ParDo(do_fn)
     self.assertEqual([['1', '1'], ['2', '2']], sorted(result))
 
+  def test_typed_ptransform_fn(self):
+    # Test that type hints are propagated to the created PTransform.
+    @beam.ptransform_fn
+    @typehints.with_input_types(int)
+    def MyMap(pcoll):
+      def fn(element: int):
+        yield element
+
+      return pcoll | beam.ParDo(fn)
+
+    self.assertListEqual([1, 2, 3], [1, 2, 3] | MyMap())
+    with self.assertRaisesRegex(typehints.TypeCheckError, r'int.*got.*str'):
+      _ = ['a'] | MyMap()
+
+  def test_typed_ptransform_fn_conflicting_hints(self):
+    # In this case, both MyMap and its contained ParDo have separate type
+    # checks (that disagree with each other).
+    @beam.ptransform_fn
+    @typehints.with_input_types(int)
+    def MyMap(pcoll):
+      def fn(element: float):
+        yield element
+
+      return pcoll | beam.ParDo(fn)
+
+    with self.assertRaisesRegex(typehints.TypeCheckError,
+                                r'ParDo.*requires.*float.*got.*int'):
+      _ = [1, 2, 3] | MyMap()
+    with self.assertRaisesRegex(typehints.TypeCheckError,
+                                r'MyMap.*expected.*int.*got.*str'):
+      _ = ['a'] | MyMap()
+
   def test_typed_dofn_string_literals(self):
     class MyDoFn(beam.DoFn):
       def process(self, element: 'int') -> 'typehints.List[str]':
diff --git a/sdks/python/conftest.py b/sdks/python/conftest.py
index 8baa13df944..6c36b3e1aae 100644
--- a/sdks/python/conftest.py
+++ b/sdks/python/conftest.py
@@ -20,6 +20,8 @@ from __future__ import absolute_import
 
 import sys
 
+from apache_beam.options import pipeline_options
+
 MAX_SUPPORTED_PYTHON_VERSION = (3, 8)
 
 # See pytest.ini for main collection rules.
@@ -30,3 +32,8 @@ else:
   for minor in range(sys.version_info.minor + 1,
                      MAX_SUPPORTED_PYTHON_VERSION[1] + 1):
     collect_ignore_glob.append('*_py3%d.py' % minor)
+
+
+def pytest_configure(config):
+  # Enable optional type checks on all tests.
+  pipeline_options.enable_all_additional_type_checks()
diff --git a/website/www/site/content/en/documentation/sdks/python-type-safety.md b/website/www/site/content/en/documentation/sdks/python-type-safety.md
index 8e17aae2ff3..c4602a14ed7 100644
--- a/website/www/site/content/en/documentation/sdks/python-type-safety.md
+++ b/website/www/site/content/en/documentation/sdks/python-type-safety.md
@@ -34,6 +34,13 @@ These flags control Beam type safety:
 
   Enables runtime type checking of every element.
   This may affect pipeline performance, so the default is to skip these checks.
+- `--type_check_additional`
+
+  Enables additional type checks. These are no enabled by default to preserve
+  backwards compatibility. This flag accepts a comma-separate list of options:
+  - `all`: Enable all additional checks.
+  - `ptransform_fn`: Enable type hint decorators when used with the
+    `@ptransform_fn` decorator.
 
 ## Benefits of Type Hints
 
