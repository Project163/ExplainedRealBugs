diff --git a/sdks/python/apache_beam/pipeline_test.py b/sdks/python/apache_beam/pipeline_test.py
index c50a21979ce..201324a2f80 100644
--- a/sdks/python/apache_beam/pipeline_test.py
+++ b/sdks/python/apache_beam/pipeline_test.py
@@ -57,6 +57,7 @@ from apache_beam.transforms import WindowInto
 from apache_beam.transforms.userstate import BagStateSpec
 from apache_beam.transforms.window import SlidingWindows
 from apache_beam.transforms.window import TimestampedValue
+from apache_beam.utils import windowed_value
 from apache_beam.utils.timestamp import MIN_TIMESTAMP
 
 # TODO(BEAM-1555): Test is failing on the service, with FakeSource.
@@ -682,6 +683,23 @@ class DoFnTest(unittest.TestCase):
           p | Create([1, 2]) | beam.Map(lambda _, t=DoFn.TimestampParam: t),
           equal_to([MIN_TIMESTAMP, MIN_TIMESTAMP]))
 
+  def test_pane_info_param(self):
+    with TestPipeline() as p:
+      pc = p | Create([(None, None)])
+      assert_that(
+          pc | beam.Map(lambda _, p=DoFn.PaneInfoParam: p),
+          equal_to([windowed_value.PANE_INFO_UNKNOWN]),
+          label='CheckUngrouped')
+      assert_that(
+          pc | beam.GroupByKey() | beam.Map(lambda _, p=DoFn.PaneInfoParam: p),
+          equal_to([windowed_value.PaneInfo(
+              is_first=True,
+              is_last=True,
+              timing=windowed_value.PaneInfoTiming.ON_TIME,
+              index=0,
+              nonspeculative_index=0)]),
+          label='CheckGrouped')
+
   def test_incomparable_default(self):
 
     class IncomparableType(object):
diff --git a/sdks/python/apache_beam/runners/common.py b/sdks/python/apache_beam/runners/common.py
index 541959a5cf9..3e14f3b7e1d 100644
--- a/sdks/python/apache_beam/runners/common.py
+++ b/sdks/python/apache_beam/runners/common.py
@@ -507,6 +507,8 @@ class PerWindowInvoker(DoFnInvoker):
         args_with_placeholders.append(ArgPlaceholder(d))
       elif core.DoFn.TimestampParam == d:
         args_with_placeholders.append(ArgPlaceholder(d))
+      elif core.DoFn.PaneInfoParam == d:
+        args_with_placeholders.append(ArgPlaceholder(d))
       elif core.DoFn.SideInputParam == d:
         # If no more args are present then the value must be passed via kwarg
         try:
@@ -635,6 +637,8 @@ class PerWindowInvoker(DoFnInvoker):
         args_for_process[i] = window
       elif core.DoFn.TimestampParam == p:
         args_for_process[i] = windowed_value.timestamp
+      elif core.DoFn.PaneInfoParam == p:
+        args_for_process[i] = windowed_value.pane_info
       elif isinstance(p, core.DoFn.StateParam):
         args_for_process[i] = (
             self.user_state_context.get_state(p.state_spec, key, window))
diff --git a/sdks/python/apache_beam/runners/direct/transform_evaluator.py b/sdks/python/apache_beam/runners/direct/transform_evaluator.py
index e1fc3cd1640..f8f6ca3d66b 100644
--- a/sdks/python/apache_beam/runners/direct/transform_evaluator.py
+++ b/sdks/python/apache_beam/runners/direct/transform_evaluator.py
@@ -814,8 +814,10 @@ class _StreamingGroupAlsoByWindowEvaluator(_TransformEvaluator):
           timer_firing.window, timer_firing.name, timer_firing.time_domain,
           timer_firing.timestamp, state):
         self.gabw_items.append(wvalue.with_value((k, wvalue.value)))
+    watermark = self._evaluation_context._watermark_manager.get_watermarks(
+        self._applied_ptransform).output_watermark
     if vs:
-      for wvalue in self.driver.process_elements(state, vs, MIN_TIMESTAMP):
+      for wvalue in self.driver.process_elements(state, vs, watermark):
         self.gabw_items.append(wvalue.with_value((k, wvalue.value)))
 
     self.keyed_holds[encoded_k] = state.get_earliest_hold()
diff --git a/sdks/python/apache_beam/runners/portability/fn_api_runner.py b/sdks/python/apache_beam/runners/portability/fn_api_runner.py
index d7e0f3370ff..dd0c1e2d498 100644
--- a/sdks/python/apache_beam/runners/portability/fn_api_runner.py
+++ b/sdks/python/apache_beam/runners/portability/fn_api_runner.py
@@ -73,9 +73,11 @@ from apache_beam.runners.worker.channel_factory import GRPCChannelFactory
 from apache_beam.runners.worker.sdk_worker import _Future
 from apache_beam.runners.worker.statecache import StateCache
 from apache_beam.transforms import trigger
+from apache_beam.transforms.window import GlobalWindow
 from apache_beam.transforms.window import GlobalWindows
 from apache_beam.utils import profiler
 from apache_beam.utils import proto_utils
+from apache_beam.utils import windowed_value
 
 # This module is experimental. No backwards-compatibility guarantees.
 
@@ -234,7 +236,15 @@ class _GroupingBuffer(object):
     """
     if not self._grouped_output:
       if self._windowing.is_default():
-        globally_window = GlobalWindows.windowed_value(None).with_value
+        globally_window = GlobalWindows.windowed_value(
+            None,
+            timestamp=GlobalWindow().max_timestamp(),
+            pane_info=windowed_value.PaneInfo(
+                is_first=True,
+                is_last=True,
+                timing=windowed_value.PaneInfoTiming.ON_TIME,
+                index=0,
+                nonspeculative_index=0)).with_value
         windowed_key_values = lambda key, values: [
             globally_window((key, values))]
       else:
diff --git a/sdks/python/apache_beam/testing/data/trigger_transcripts.yaml b/sdks/python/apache_beam/testing/data/trigger_transcripts.yaml
index 2ddc584ea4c..0e01ad90542 100644
--- a/sdks/python/apache_beam/testing/data/trigger_transcripts.yaml
+++ b/sdks/python/apache_beam/testing/data/trigger_transcripts.yaml
@@ -22,7 +22,7 @@ transcript:                       # Ordered list of events.
   - input: [1, 2, 3, 10, 11]      # The elements are the timestamps.
   - watermark: 25
   - expect:                       # Every expected output from the last action.
-      - {window: [0, 9], values: [1, 2, 3]}
+      - {window: [0, 9], values: [1, 2, 3], index: 0}
       - {window: [10, 19], values: [10, 11]}   # Partial match on attributes OK.
 
 ---
@@ -113,26 +113,30 @@ transcript:
 
 ---
 name: early_late_sessions
+broken_on:
+  # Watermark regresses, causing what should be late data to not be late.
+  - SwitchingDirectRunner
 window_fn: Sessions(10)
 trigger_fn: AfterWatermark(early=AfterCount(2), late=AfterCount(3))
 timestamp_combiner: OUTPUT_AT_EOW
 transcript:
     - input: [1, 2, 3]
     - expect:
-        - {window: [1, 12], values: [1, 2, 3], timestamp: 12, early: true}
+        - {window: [1, 12], values: [1, 2, 3], timestamp: 12, early: true, index: 0}
     - input: [4]    # no output
     - input: [5]
     - expect:
-        - {window: [1, 14], values: [1, 2, 3, 4, 5], timestamp: 14, early: true}
+        - {window: [1, 14], values: [1, 2, 3, 4, 5], timestamp: 14, early: true, index: 1}
     - input: [6]
     - watermark: 100
     - expect:
         - {window: [1, 15], values:[1, 2, 3, 4, 5, 6], timestamp: 15,
-           final: true}
+           index: 2, nonspeculative_index: 0}
     - input: [1]
     - input: [3, 4]
     - expect:
-        - {window: [1, 15], values: [1, 1, 2, 3, 3, 4, 4, 5, 6], timestamp: 15}
+        - {window: [1, 15], values: [1, 1, 2, 3, 3, 4, 4, 5, 6], timestamp: 15,
+           final: false, index: 3, nonspeculative_index: 1}
 
 ---
 name: garbage_collection
diff --git a/sdks/python/apache_beam/transforms/trigger.py b/sdks/python/apache_beam/transforms/trigger.py
index 5fe08249bc4..9761da21336 100644
--- a/sdks/python/apache_beam/transforms/trigger.py
+++ b/sdks/python/apache_beam/transforms/trigger.py
@@ -45,6 +45,7 @@ from apache_beam.transforms.window import GlobalWindows
 from apache_beam.transforms.window import TimestampCombiner
 from apache_beam.transforms.window import WindowedValue
 from apache_beam.transforms.window import WindowFn
+from apache_beam.utils import windowed_value
 from apache_beam.utils.timestamp import MAX_TIMESTAMP
 from apache_beam.utils.timestamp import MIN_TIMESTAMP
 from apache_beam.utils.timestamp import TIME_GRANULARITY
@@ -816,7 +817,7 @@ class SimpleState(with_metaclass(ABCMeta, object)):
     pass
 
   def at(self, window, clock):
-    return TriggerContext(self, window, clock)
+    return NestedContext(TriggerContext(self, window, clock), 'trigger')
 
 
 class UnmergedState(SimpleState):
@@ -944,12 +945,12 @@ def create_trigger_driver(windowing,
   # TODO(robertwb): We can do more if we know elements are in timestamp
   # sorted order.
   if windowing.is_default() and is_batch:
-    driver = DiscardingGlobalTriggerDriver()
+    driver = BatchGlobalTriggerDriver()
   elif (windowing.windowfn == GlobalWindows()
         and windowing.triggerfn == AfterCount(1)
-        and windowing.accumulation_mode == AccumulationMode.DISCARDING):
-    # Here we also just pass through all the values every time.
-    driver = DiscardingGlobalTriggerDriver()
+        and is_batch):
+    # Here we also just pass through all the values exactly once.
+    driver = BatchGlobalTriggerDriver()
   else:
     driver = GeneralTriggerDriver(windowing, clock)
 
@@ -1024,16 +1025,23 @@ coder_impl.FastPrimitivesCoderImpl.register_iterable_like_type(
     _UnwindowedValues)
 
 
-class DiscardingGlobalTriggerDriver(TriggerDriver):
+class BatchGlobalTriggerDriver(TriggerDriver):
   """Groups all received values together.
   """
   GLOBAL_WINDOW_TUPLE = (GlobalWindow(),)
+  ONLY_FIRING = windowed_value.PaneInfo(
+      is_first=True,
+      is_last=True,
+      timing=windowed_value.PaneInfoTiming.ON_TIME,
+      index=0,
+      nonspeculative_index=0)
 
   def process_elements(self, state, windowed_values, unused_output_watermark):
     yield WindowedValue(
         _UnwindowedValues(windowed_values),
         MIN_TIMESTAMP,
-        self.GLOBAL_WINDOW_TUPLE)
+        self.GLOBAL_WINDOW_TUPLE,
+        self.ONLY_FIRING)
 
   def process_timer(self, window_id, name, time_domain, timestamp, state):
     raise TypeError('Triggers never set or called for batch default windowing.')
@@ -1066,6 +1074,9 @@ class GeneralTriggerDriver(TriggerDriver):
   """
   ELEMENTS = _ListStateTag('elements')
   TOMBSTONE = _CombiningValueStateTag('tombstone', combiners.CountCombineFn())
+  INDEX = _CombiningValueStateTag('index', combiners.CountCombineFn())
+  NONSPECULATIVE_INDEX = _CombiningValueStateTag(
+      'nonspeculative_index', combiners.CountCombineFn())
 
   def __init__(self, windowing, clock):
     self.clock = clock
@@ -1146,7 +1157,7 @@ class GeneralTriggerDriver(TriggerDriver):
       if self.trigger_fn.should_fire(TimeDomain.WATERMARK, watermark,
                                      window, context):
         finished = self.trigger_fn.on_fire(watermark, window, context)
-        yield self._output(window, finished, state)
+        yield self._output(window, finished, state, output_watermark, False)
 
   def process_timer(self, window_id, unused_name, time_domain, timestamp,
                     state):
@@ -1162,12 +1173,38 @@ class GeneralTriggerDriver(TriggerDriver):
         if self.trigger_fn.should_fire(time_domain, timestamp,
                                        window, context):
           finished = self.trigger_fn.on_fire(timestamp, window, context)
-          yield self._output(window, finished, state)
+          yield self._output(window, finished, state, timestamp,
+                             time_domain == TimeDomain.WATERMARK)
     else:
       raise Exception('Unexpected time domain: %s' % time_domain)
 
-  def _output(self, window, finished, state):
+  def _output(self, window, finished, state, watermark, maybe_ontime):
     """Output window and clean up if appropriate."""
+    index = state.get_state(window, self.INDEX)
+    state.add_state(window, self.INDEX, 1)
+    if watermark <= window.max_timestamp():
+      nonspeculative_index = -1
+      timing = windowed_value.PaneInfoTiming.EARLY
+      if state.get_state(window, self.NONSPECULATIVE_INDEX):
+        nonspeculative_index = state.get_state(
+            window, self.NONSPECULATIVE_INDEX)
+        state.add_state(window, self.NONSPECULATIVE_INDEX, 1)
+        windowed_value.PaneInfoTiming.LATE
+        logging.warning('Watermark moved backwards in time '
+                        'or late data moved window end forward.')
+    else:
+      nonspeculative_index = state.get_state(window, self.NONSPECULATIVE_INDEX)
+      state.add_state(window, self.NONSPECULATIVE_INDEX, 1)
+      timing = (
+          windowed_value.PaneInfoTiming.ON_TIME
+          if maybe_ontime and nonspeculative_index == 0
+          else windowed_value.PaneInfoTiming.LATE)
+    pane_info = windowed_value.PaneInfo(
+        index == 0,
+        finished,
+        timing,
+        index,
+        nonspeculative_index)
 
     values = state.get_state(window, self.ELEMENTS)
     if finished:
@@ -1184,7 +1221,7 @@ class GeneralTriggerDriver(TriggerDriver):
     else:
       state.clear_state(window, self.WATERMARK_HOLD)
 
-    return WindowedValue(values, timestamp, (window,))
+    return WindowedValue(values, timestamp, (window,), pane_info)
 
 
 class InMemoryUnmergedState(UnmergedState):
diff --git a/sdks/python/apache_beam/transforms/trigger_test.py b/sdks/python/apache_beam/transforms/trigger_test.py
index c5f53f35253..dbc4bcdeaa2 100644
--- a/sdks/python/apache_beam/transforms/trigger_test.py
+++ b/sdks/python/apache_beam/transforms/trigger_test.py
@@ -53,7 +53,6 @@ from apache_beam.transforms.trigger import GeneralTriggerDriver
 from apache_beam.transforms.trigger import InMemoryUnmergedState
 from apache_beam.transforms.trigger import Repeatedly
 from apache_beam.transforms.trigger import TriggerFn
-from apache_beam.transforms.window import MIN_TIMESTAMP
 from apache_beam.transforms.window import FixedWindows
 from apache_beam.transforms.window import IntervalWindow
 from apache_beam.transforms.window import Sessions
@@ -61,6 +60,9 @@ from apache_beam.transforms.window import TimestampCombiner
 from apache_beam.transforms.window import TimestampedValue
 from apache_beam.transforms.window import WindowedValue
 from apache_beam.transforms.window import WindowFn
+from apache_beam.utils.timestamp import MAX_TIMESTAMP
+from apache_beam.utils.timestamp import MIN_TIMESTAMP
+from apache_beam.utils.windowed_value import PaneInfoTiming
 
 
 class CustomTimestampingFixedWindowsWindowFn(FixedWindows):
@@ -132,7 +134,7 @@ class TriggerTest(unittest.TestCase):
           actual_panes[window].append(set(wvalue.value))
 
     for bundle in late_bundles:
-      for wvalue in driver.process_elements(state, bundle, MIN_TIMESTAMP):
+      for wvalue in driver.process_elements(state, bundle, MAX_TIMESTAMP):
         window, = wvalue.windows
         self.assertEqual(window.max_timestamp(), wvalue.timestamp)
         actual_panes[window].append(set(wvalue.value))
@@ -385,7 +387,7 @@ class TriggerTest(unittest.TestCase):
 
   def test_picklable_output(self):
     global_window = (trigger.GlobalWindow(),)
-    driver = trigger.DiscardingGlobalTriggerDriver()
+    driver = trigger.BatchGlobalTriggerDriver()
     unpicklable = (WindowedValue(k, 0, global_window)
                    for k in range(10))
     with self.assertRaises(TypeError):
@@ -616,6 +618,11 @@ class TranscriptTest(unittest.TestCase):
         'window': [int(window.start), int(window.max_timestamp())],
         'values': sorted(windowed_value.value),
         'timestamp': int(windowed_value.timestamp),
+        'index': windowed_value.pane_info.index,
+        'nonspeculative_index': windowed_value.pane_info.nonspeculative_index,
+        'early': windowed_value.pane_info.timing == PaneInfoTiming.EARLY,
+        'late': windowed_value.pane_info.timing == PaneInfoTiming.LATE,
+        'final': windowed_value.pane_info.is_last,
     }
 
 
@@ -784,10 +791,11 @@ class TestStreamTranscriptTest(TranscriptTest):
           | beam.MapTuple(
               lambda k, vs,
                      window=beam.DoFn.WindowParam,
-                     t=beam.DoFn.TimestampParam: (
+                     t=beam.DoFn.TimestampParam,
+                     p=beam.DoFn.PaneInfoParam: (
                          k,
-                         self._windowed_value_info(
-                             WindowedValue(vs, windows=[window], timestamp=t))))
+                         self._windowed_value_info(WindowedValue(
+                             vs, windows=[window], timestamp=t, pane_info=p))))
           # Place outputs back into the global window to allow flattening
           # and share a single state in Check.
           | 'Global' >> beam.WindowInto(beam.transforms.window.GlobalWindows()))
diff --git a/sdks/python/apache_beam/transforms/window.py b/sdks/python/apache_beam/transforms/window.py
index e477303eebd..cfbbae16b83 100644
--- a/sdks/python/apache_beam/transforms/window.py
+++ b/sdks/python/apache_beam/transforms/window.py
@@ -325,8 +325,12 @@ class GlobalWindows(NonMergingWindowFn):
   """A windowing function that assigns everything to one global window."""
 
   @classmethod
-  def windowed_value(cls, value, timestamp=MIN_TIMESTAMP):
-    return WindowedValue(value, timestamp, (GlobalWindow(),))
+  def windowed_value(
+      cls,
+      value,
+      timestamp=MIN_TIMESTAMP,
+      pane_info=windowed_value.PANE_INFO_UNKNOWN):
+    return WindowedValue(value, timestamp, (GlobalWindow(),), pane_info)
 
   def assign(self, assign_context):
     return [GlobalWindow()]
diff --git a/sdks/python/apache_beam/utils/windowed_value.py b/sdks/python/apache_beam/utils/windowed_value.py
index 5570c4513b8..95016c5f12e 100644
--- a/sdks/python/apache_beam/utils/windowed_value.py
+++ b/sdks/python/apache_beam/utils/windowed_value.py
@@ -44,6 +44,15 @@ class PaneInfoTiming(object):
   LATE = 2
   UNKNOWN = 3
 
+  @classmethod
+  def to_string(cls, value):
+    return {
+        cls.EARLY: 'EARLY',
+        cls.ON_TIME: 'ON_TIME',
+        cls.LATE: 'LATE',
+        cls.UNKNOWN: 'UNKNOWN',
+    }[value]
+
 
 class PaneInfo(object):
   """Describes the trigger firing information for a given WindowedValue.
@@ -106,9 +115,10 @@ class PaneInfo(object):
 
   def __repr__(self):
     return ('PaneInfo(first: %r, last: %r, timing: %s, index: %d, '
-            'nonspeculative_index: %d)') % (self.is_first, self.is_last,
-                                            self.timing, self.index,
-                                            self.nonspeculative_index)
+            'nonspeculative_index: %d)') % (
+                self.is_first, self.is_last,
+                PaneInfoTiming.to_string(self.timing),
+                self.index, self.nonspeculative_index)
 
   def __eq__(self, other):
     if self is other:
