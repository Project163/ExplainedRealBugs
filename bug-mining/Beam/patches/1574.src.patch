diff --git a/sdks/java/io/file-based-io-tests/src/test/java/org/apache/beam/sdk/io/tfrecord/TFRecordIOIT.java b/sdks/java/io/file-based-io-tests/src/test/java/org/apache/beam/sdk/io/tfrecord/TFRecordIOIT.java
index 59ac5911ad4..547392611e8 100644
--- a/sdks/java/io/file-based-io-tests/src/test/java/org/apache/beam/sdk/io/tfrecord/TFRecordIOIT.java
+++ b/sdks/java/io/file-based-io-tests/src/test/java/org/apache/beam/sdk/io/tfrecord/TFRecordIOIT.java
@@ -80,6 +80,12 @@ import org.junit.runners.JUnit4;
 public class TFRecordIOIT {
   private static final String TFRECORD_NAMESPACE = TFRecordIOIT.class.getName();
 
+  // Metric names
+  private static final String WRITE_TIME = "write_time";
+  private static final String READ_TIME = "read_time";
+  private static final String DATASET_SIZE = "dataset_size";
+  private static final String RUN_TIME = "run_time";
+
   private static String filenamePrefix;
   private static String bigQueryDataset;
   private static String bigQueryTable;
@@ -111,7 +117,7 @@ public class TFRecordIOIT {
   // TODO: There are two pipelines due to: https://issues.apache.org/jira/browse/BEAM-3267
   @Test
   public void writeThenReadAll() {
-    TFRecordIO.Write writeTransform =
+    final TFRecordIO.Write writeTransform =
         TFRecordIO.write()
             .to(filenamePrefix)
             .withCompression(compressionType)
@@ -125,10 +131,11 @@ public class TFRecordIOIT {
         .apply("Transform strings to bytes", MapElements.via(new StringToByteArray()))
         .apply(
             "Record time before writing",
-            ParDo.of(new TimeMonitor<>(TFRECORD_NAMESPACE, "writeTime")))
+            ParDo.of(new TimeMonitor<>(TFRECORD_NAMESPACE, WRITE_TIME)))
         .apply("Write content to files", writeTransform);
 
-    writePipeline.run().waitUntilFinish();
+    final PipelineResult writeResult = writePipeline.run();
+    writeResult.waitUntilFinish();
 
     String filenamePattern = createFilenamePattern();
     PCollection<String> consolidatedHashcode =
@@ -136,7 +143,7 @@ public class TFRecordIOIT {
             .apply(TFRecordIO.read().from(filenamePattern).withCompression(AUTO))
             .apply(
                 "Record time after reading",
-                ParDo.of(new TimeMonitor<>(TFRECORD_NAMESPACE, "readTime")))
+                ParDo.of(new TimeMonitor<>(TFRECORD_NAMESPACE, READ_TIME)))
             .apply("Transform bytes to strings", MapElements.via(new ByteArrayToString()))
             .apply("Calculate hashcode", Combine.globally(new HashingFn()))
             .apply(Reshuffle.viaRandomKey());
@@ -149,54 +156,62 @@ public class TFRecordIOIT {
             "Delete test files",
             ParDo.of(new DeleteFileFn())
                 .withSideInputs(consolidatedHashcode.apply(View.asSingleton())));
-    PipelineResult result = readPipeline.run();
-    result.waitUntilFinish();
-    collectAndPublishMetrics(result);
+    final PipelineResult readResult = readPipeline.run();
+    readResult.waitUntilFinish();
+    collectAndPublishMetrics(writeResult, readResult);
   }
 
-  private void collectAndPublishMetrics(PipelineResult result) {
-    String uuid = UUID.randomUUID().toString();
-    String timestamp = Timestamp.now().toString();
+  private void collectAndPublishMetrics(
+      final PipelineResult writeResults, final PipelineResult readResults) {
+    final String uuid = UUID.randomUUID().toString();
+    final String timestamp = Timestamp.now().toString();
+    final Set<NamedTestResult> results = new HashSet<>();
+
+    results.add(
+        NamedTestResult.create(uuid, timestamp, RUN_TIME, getRunTime(writeResults, readResults)));
+    results.addAll(
+        MetricsReader.ofResults(writeResults, TFRECORD_NAMESPACE)
+            .readAll(getWriteMetricSuppliers(uuid, timestamp)));
+    results.addAll(
+        MetricsReader.ofResults(readResults, TFRECORD_NAMESPACE)
+            .readAll(getReadMetricSuppliers(uuid, timestamp)));
+
+    IOITMetrics.publish(uuid, timestamp, bigQueryDataset, bigQueryTable, results);
+  }
 
-    Set<Function<MetricsReader, NamedTestResult>> metricSuppliers =
-        fillMetricSuppliers(uuid, timestamp);
-    new IOITMetrics(metricSuppliers, result, TFRECORD_NAMESPACE, uuid, timestamp)
-        .publish(bigQueryDataset, bigQueryTable);
+  private static Set<Function<MetricsReader, NamedTestResult>> getWriteMetricSuppliers(
+      final String uuid, final String timestamp) {
+    final Set<Function<MetricsReader, NamedTestResult>> suppliers = new HashSet<>();
+    suppliers.add(getTimeMetric(uuid, timestamp, WRITE_TIME));
+    suppliers.add(ignored -> NamedTestResult.create(uuid, timestamp, DATASET_SIZE, datasetSize));
+    return suppliers;
   }
 
-  private Set<Function<MetricsReader, NamedTestResult>> fillMetricSuppliers(
-      String uuid, String timestamp) {
-    Set<Function<MetricsReader, NamedTestResult>> suppliers = new HashSet<>();
-    suppliers.add(
-        reader -> {
-          long writeStart = reader.getStartTimeMetric("writeTime");
-          long writeEnd = reader.getEndTimeMetric("writeTime");
-          double writeTime = (writeEnd - writeStart) / 1e3;
-          return NamedTestResult.create(uuid, timestamp, "write_time", writeTime);
-        });
-
-    suppliers.add(
-        reader -> {
-          long readStart = reader.getStartTimeMetric("readTime");
-          long readEnd = reader.getEndTimeMetric("readTime");
-          double readTime = (readEnd - readStart) / 1e3;
-          return NamedTestResult.create(uuid, timestamp, "read_time", readTime);
-        });
-
-    suppliers.add(
-        reader -> {
-          long writeStart = reader.getStartTimeMetric("writeTime");
-          long readEnd = reader.getEndTimeMetric("readTime");
-          double runTime = (readEnd - writeStart) / 1e3;
-          return NamedTestResult.create(uuid, timestamp, "run_time", runTime);
-        });
-    if (datasetSize != null) {
-      suppliers.add(
-          (ignored) -> NamedTestResult.create(uuid, timestamp, "dataset_size", datasetSize));
-    }
+  private static Set<Function<MetricsReader, NamedTestResult>> getReadMetricSuppliers(
+      final String uuid, final String timestamp) {
+    final Set<Function<MetricsReader, NamedTestResult>> suppliers = new HashSet<>();
+    suppliers.add(getTimeMetric(uuid, timestamp, READ_TIME));
     return suppliers;
   }
 
+  private static Function<MetricsReader, NamedTestResult> getTimeMetric(
+      final String uuid, final String timestamp, final String metricName) {
+    return reader -> {
+      final long startTime = reader.getStartTimeMetric(metricName);
+      final long endTime = reader.getEndTimeMetric(metricName);
+      return NamedTestResult.create(uuid, timestamp, metricName, (endTime - startTime) / 1e3);
+    };
+  }
+
+  private static double getRunTime(
+      final PipelineResult writeResults, final PipelineResult readResult) {
+    final long startTime =
+        MetricsReader.ofResults(writeResults, TFRECORD_NAMESPACE).getStartTimeMetric(WRITE_TIME);
+    final long endTime =
+        MetricsReader.ofResults(readResult, TFRECORD_NAMESPACE).getEndTimeMetric(READ_TIME);
+    return (endTime - startTime) / 1e3;
+  }
+
   static class StringToByteArray extends SimpleFunction<String, byte[]> {
     @Override
     public byte[] apply(String input) {
diff --git a/sdks/java/testing/test-utils/src/main/java/org/apache/beam/sdk/testutils/metrics/MetricsReader.java b/sdks/java/testing/test-utils/src/main/java/org/apache/beam/sdk/testutils/metrics/MetricsReader.java
index 986d568d7a5..7fee6a297bb 100644
--- a/sdks/java/testing/test-utils/src/main/java/org/apache/beam/sdk/testutils/metrics/MetricsReader.java
+++ b/sdks/java/testing/test-utils/src/main/java/org/apache/beam/sdk/testutils/metrics/MetricsReader.java
@@ -17,6 +17,9 @@
  */
 package org.apache.beam.sdk.testutils.metrics;
 
+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;
+
+import com.sun.istack.internal.NotNull;
 import java.util.Collection;
 import java.util.NoSuchElementException;
 import java.util.Optional;
@@ -164,4 +167,19 @@ public class MetricsReader {
   private boolean isCredible(long value) {
     return (Math.abs(value - now) <= Duration.standardDays(10000).getMillis());
   }
+
+  /**
+   * Factory method. Returns instance of {@link MetricsReader}.
+   *
+   * @param results pipeline from which metrics are read from
+   * @param namespace namespace is required due to fact methods uses it internally
+   * @return instance of {@link MetricsReader}
+   */
+  @NotNull
+  public static MetricsReader ofResults(
+      @NotNull final PipelineResult results, @NotNull final String namespace) {
+    checkNotNull(results);
+    checkNotNull(namespace);
+    return new MetricsReader(results, namespace);
+  }
 }
