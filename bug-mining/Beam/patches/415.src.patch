diff --git a/sdks/java/harness/pom.xml b/sdks/java/harness/pom.xml
index de24f7f1df2..e965923e32b 100644
--- a/sdks/java/harness/pom.xml
+++ b/sdks/java/harness/pom.xml
@@ -112,13 +112,6 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-surefire-plugin</artifactId>
-        <configuration>
-          <excludes>
-            <!-- Flaky in Precommit. See BEAM-1487 https://issues.apache.org/jira/browse/BEAM-1487 -->
-            <exclude>org.apache.beam.fn.harness.logging.BeamFnLoggingClientTest</exclude>
-            <exclude>org.apache.beam.fn.harness.stream.BufferingStreamObserverTest</exclude>
-          </excludes>
-        </configuration>
       </plugin>
     </plugins>
   </build>
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/logging/BeamFnLoggingClient.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/logging/BeamFnLoggingClient.java
index d43ab25698f..b19277a0cc3 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/logging/BeamFnLoggingClient.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/logging/BeamFnLoggingClient.java
@@ -145,12 +145,6 @@ public class BeamFnLoggingClient implements AutoCloseable {
   @Override
   public void close() throws Exception {
     try {
-      // Hang up with the server
-      logRecordHandler.close();
-
-      // Wait for the server to hang up
-      inboundObserverCompletion.get();
-    } finally {
       // Reset the logging configuration to what it is at startup
       for (Logger logger : configuredLoggers) {
         logger.setLevel(null);
@@ -158,6 +152,12 @@ public class BeamFnLoggingClient implements AutoCloseable {
       configuredLoggers.clear();
       LogManager.getLogManager().readConfiguration();
 
+      // Hang up with the server
+      logRecordHandler.close();
+
+      // Wait for the server to hang up
+      inboundObserverCompletion.get();
+    } finally {
       // Shut the channel down
       channel.shutdown();
       if (!channel.awaitTermination(10, TimeUnit.SECONDS)) {
@@ -255,6 +255,14 @@ public class BeamFnLoggingClient implements AutoCloseable {
           outboundObserver.onNext(builder.build());
           additionalLogEntries.clear();
         }
+
+        // Perform one more final check to see if there are any log entries to guarantee that
+        // if a log entry was added on the thread performing termination that we will send it.
+        bufferedLogEntries.drainTo(additionalLogEntries);
+        if (!additionalLogEntries.isEmpty()) {
+          outboundObserver.onNext(
+              BeamFnApi.LogEntry.List.newBuilder().addAllLogEntries(additionalLogEntries).build());
+        }
       } catch (Throwable t) {
         thrown = t;
       }
@@ -281,7 +289,7 @@ public class BeamFnLoggingClient implements AutoCloseable {
 
       // Terminate the phaser that we block on when attempting to honor flow control on the
       // outbound observer.
-      phaser.arriveAndDeregister();
+      phaser.forceTermination();
 
       try {
         bufferedLogWriter.get();
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/stream/BufferingStreamObserver.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/stream/BufferingStreamObserver.java
index cda3a4bab5e..cd964409c0b 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/stream/BufferingStreamObserver.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/stream/BufferingStreamObserver.java
@@ -105,10 +105,10 @@ public final class BufferingStreamObserver<T> implements StreamObserver<T> {
         // We check to see if we were able to successfully insert the poison pill at the front of
         // the queue to cancel the processing thread eagerly or if the processing thread is done.
         try {
-          // The order of these checks is important because short circuiting will cause us to
-          // insert into the queue first and only if it fails do we check that the thread is done.
-          while (!queue.offerFirst((T) POISON_PILL, 60, TimeUnit.SECONDS)
-              || !queueDrainer.isDone()) {
+          // We shouldn't attempt to insert into the queue if the queue drainer thread is done
+          // since the queue may be full and nothing will be emptying it.
+          while (!queueDrainer.isDone()
+              && !queue.offerFirst((T) POISON_PILL, 60, TimeUnit.SECONDS)) {
           }
         } catch (InterruptedException e) {
           Thread.currentThread().interrupt();
@@ -130,10 +130,10 @@ public final class BufferingStreamObserver<T> implements StreamObserver<T> {
         // the queue forcing the remainder of the elements to be processed or if the processing
         // thread is done.
         try {
-          // The order of these checks is important because short circuiting will cause us to
-          // insert into the queue first and only if it fails do we check that the thread is done.
-          while (!queue.offer((T) POISON_PILL, 60, TimeUnit.SECONDS)
-              || !queueDrainer.isDone()) {
+          // We shouldn't attempt to insert into the queue if the queue drainer thread is done
+          // since the queue may be full and nothing will be emptying it.
+          while (!queueDrainer.isDone()
+              && !queue.offerLast((T) POISON_PILL, 60, TimeUnit.SECONDS)) {
           }
         } catch (InterruptedException e) {
           Thread.currentThread().interrupt();
diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/stream/BufferingStreamObserverTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/stream/BufferingStreamObserverTest.java
index 76b7ef02f90..b26e8e15e2b 100644
--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/stream/BufferingStreamObserverTest.java
+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/stream/BufferingStreamObserverTest.java
@@ -61,7 +61,7 @@ public class BufferingStreamObserverTest {
                     // critical section. Any thread that enters purposefully blocks by sleeping
                     // to increase the contention between threads artificially.
                     assertFalse(isCriticalSectionShared.getAndSet(true));
-                    Uninterruptibles.sleepUninterruptibly(50, TimeUnit.MILLISECONDS);
+                    Uninterruptibles.sleepUninterruptibly(1, TimeUnit.MILLISECONDS);
                     onNextValues.add(t);
                     assertTrue(isCriticalSectionShared.getAndSet(false));
                   }
@@ -134,7 +134,7 @@ public class BufferingStreamObserverTest {
     }
 
     // Have them wait and then flip that we do allow elements and wake up those awaiting
-    Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);
+    Uninterruptibles.sleepUninterruptibly(10, TimeUnit.MILLISECONDS);
     elementsAllowed.set(true);
     phaser.arrive();
 
