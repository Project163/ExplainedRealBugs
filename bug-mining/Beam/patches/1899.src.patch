diff --git a/sdks/python/apache_beam/typehints/opcodes.py b/sdks/python/apache_beam/typehints/opcodes.py
index 8b03f684db1..2f638c17651 100644
--- a/sdks/python/apache_beam/typehints/opcodes.py
+++ b/sdks/python/apache_beam/typehints/opcodes.py
@@ -51,6 +51,10 @@ from apache_beam.typehints.typehints import List
 from apache_beam.typehints.typehints import Tuple
 from apache_beam.typehints.typehints import Union
 
+# This is missing in the builtin types module.  str.upper is arbitrary, any
+# method on a C-implemented type will do.
+_MethodDescriptorType = type(str.upper)
+
 
 def pop_one(state, unused_arg):
   del state.stack[-1:]
@@ -267,6 +271,9 @@ def build_map(state, unused_arg):
 def load_attr(state, arg):
   """Replaces the top of the stack, TOS, with
   getattr(TOS, co_names[arg])
+
+  Will replace with Any for builtin methods, but these don't have bytecode in
+  CPython so that's okay.
   """
   o = state.stack.pop()
   name = state.get_name(arg)
@@ -293,8 +300,15 @@ def load_method(state, arg):
     method = Const(getattr(o.value, name))
   elif isinstance(o, typehints.AnyTypeConstraint):
     method = typehints.Any
+  elif hasattr(o, name):
+    attr = getattr(o, name)
+    if isinstance(attr, _MethodDescriptorType):
+      # Skip builtins since they don't disassemble.
+      method = typehints.Any
+    else:
+      method = Const(BoundMethod(attr, o))
   else:
-    method = Const(BoundMethod(getattr(o, name), o))
+    method = typehints.Any
 
   state.stack.append(method)
 
diff --git a/sdks/python/apache_beam/typehints/trivial_inference.py b/sdks/python/apache_beam/typehints/trivial_inference.py
index 252bc431203..3a83b8160d5 100644
--- a/sdks/python/apache_beam/typehints/trivial_inference.py
+++ b/sdks/python/apache_beam/typehints/trivial_inference.py
@@ -474,12 +474,14 @@ def infer_return_type_func(f, input_types, debug=False, depth=0):
           pop_count = arg + 1
           if depth <= 0:
             return_type = Any
-          else:
+          elif isinstance(state.stack[-pop_count], Const):
             return_type = infer_return_type(
                 state.stack[-pop_count].value,
                 state.stack[1 - pop_count:],
                 debug=debug,
                 depth=depth - 1)
+          else:
+            return_type = Any
         elif opname == 'CALL_FUNCTION_KW':
           # TODO(udim): Handle keyword arguments. Requires passing them by name
           #   to infer_return_type.
diff --git a/sdks/python/apache_beam/typehints/trivial_inference_test.py b/sdks/python/apache_beam/typehints/trivial_inference_test.py
index 6ba50735595..3897a60ea79 100644
--- a/sdks/python/apache_beam/typehints/trivial_inference_test.py
+++ b/sdks/python/apache_beam/typehints/trivial_inference_test.py
@@ -203,6 +203,21 @@ class TrivialInferenceTest(unittest.TestCase):
     self.assertReturnType(int, lambda: A().m(3))
     self.assertReturnType(float, lambda: A.m(A(), 3.0))
 
+  def testCallFunctionOnAny(self):
+    # Tests inference when CALL_FUNCTION/CALL_METHOD's function argument is Any.
+    # The function cannot be called but inference should continue. Also tests
+    # that LOAD_ATTR/LOAD_METHOD implementations don't load builtin functions,
+    # which also break inference since they don't disassemble.
+    def call_function_on_any(s):
+      # str.split is a builtin so opcodes.load_attr (load_method in Py3.7+)
+      # should put Any on the stack.
+      # If infer_return_type_func raises while trying to simulate CALL_FUNCTION
+      # on Any, the result will be Any instead of int.
+      s.split()
+      return 0
+
+    self.assertReturnType(int, call_function_on_any, [str])
+
   def testAlwaysReturnsEarly(self):
     def some_fn(v):
       if v:
