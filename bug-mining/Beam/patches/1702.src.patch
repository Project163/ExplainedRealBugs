diff --git a/sdks/python/apache_beam/runners/interactive/caching/streaming_cache.py b/sdks/python/apache_beam/runners/interactive/caching/streaming_cache.py
index 9b4b20bbcb3..f43fe985ee3 100644
--- a/sdks/python/apache_beam/runners/interactive/caching/streaming_cache.py
+++ b/sdks/python/apache_beam/runners/interactive/caching/streaming_cache.py
@@ -27,6 +27,8 @@ import time
 import traceback
 from collections import OrderedDict
 
+from google.protobuf.message import DecodeError
+
 import apache_beam as beam
 from apache_beam.portability.api.beam_interactive_api_pb2 import TestStreamFileHeader
 from apache_beam.portability.api.beam_interactive_api_pb2 import TestStreamFileRecord
@@ -152,6 +154,7 @@ class StreamingCacheSource:
     self._cache_dir = cache_dir
     self._coder = coder
     self._labels = labels
+    self._path = os.path.join(self._cache_dir, *self._labels)
     self._is_cache_complete = (
         is_cache_complete if is_cache_complete else lambda _: True)
 
@@ -166,13 +169,15 @@ class StreamingCacheSource:
 
     # Wait for up to `timeout_secs` for the file to be available.
     start = time.time()
-    path = os.path.join(self._cache_dir, *self._labels)
-    while not os.path.exists(path):
+    while not os.path.exists(self._path):
       time.sleep(1)
       if time.time() - start > timeout_timestamp_secs:
+        from apache_beam.runners.interactive.pipeline_instrument import CacheKey
+        pcollection_var = CacheKey.from_str(self._labels[-1]).var
         raise RuntimeError(
-            "Timed out waiting for file '{}' to be available".format(path))
-    return open(path, mode='rb')
+            'Timed out waiting for cache file for PCollection `{}` to be '
+            'available with path {}.'.format(pcollection_var, self._path))
+    return open(self._path, mode='rb')
 
   def _emit_from_file(self, fh, tail):
     """Emits the TestStreamFile(Header|Record)s from file.
@@ -202,14 +207,27 @@ class StreamingCacheSource:
         # The first line at pos = 0 is always the header. Read the line without
         # the new line.
         to_decode = line[:-1]
-        if pos == 0:
-          header = TestStreamFileHeader()
-          header.ParseFromString(self._coder.decode(to_decode))
-          yield header
+        proto_cls = TestStreamFileHeader if pos == 0 else TestStreamFileRecord
+        msg = self._try_parse_as(proto_cls, to_decode)
+        if msg:
+          yield msg
         else:
-          record = TestStreamFileRecord()
-          record.ParseFromString(self._coder.decode(to_decode))
-          yield record
+          break
+
+  def _try_parse_as(self, proto_cls, to_decode):
+    try:
+      msg = proto_cls()
+      msg.ParseFromString(self._coder.decode(to_decode))
+    except DecodeError:
+      _LOGGER.error(
+          'Could not parse as %s. This can indicate that the cache is '
+          'corruputed. Please restart the kernel. '
+          '\nfile: %s \nmessage: %s',
+          proto_cls,
+          self._path,
+          to_decode)
+      msg = None
+    return msg
 
   def read(self, tail):
     """Reads all TestStreamFile(Header|TestStreamFileRecord)s from file.
diff --git a/sdks/python/apache_beam/runners/interactive/interactive_runner.py b/sdks/python/apache_beam/runners/interactive/interactive_runner.py
index 1281373dbaf..f79826f814f 100644
--- a/sdks/python/apache_beam/runners/interactive/interactive_runner.py
+++ b/sdks/python/apache_beam/runners/interactive/interactive_runner.py
@@ -170,8 +170,13 @@ class InteractiveRunner(runners.PipelineRunner):
               user_pipeline)):
         streaming_cache_manager = ie.current_env().cache_manager()
         if streaming_cache_manager:
+
+          def exception_handler(e):
+            _LOGGER.error(str(e))
+            return True
+
           test_stream_service = TestStreamServiceController(
-              streaming_cache_manager)
+              streaming_cache_manager, exception_handler=exception_handler)
           test_stream_service.start()
           ie.current_env().set_test_stream_service_controller(
               user_pipeline, test_stream_service)
diff --git a/sdks/python/apache_beam/testing/test_stream_service.py b/sdks/python/apache_beam/testing/test_stream_service.py
index 480a6e17698..d69465f697e 100644
--- a/sdks/python/apache_beam/testing/test_stream_service.py
+++ b/sdks/python/apache_beam/testing/test_stream_service.py
@@ -32,7 +32,7 @@ class TestStreamServiceController(TestStreamServiceServicer):
 
   This server is used as a way for TestStreams to receive events from file.
   """
-  def __init__(self, reader, endpoint=None):
+  def __init__(self, reader, endpoint=None, exception_handler=None):
     self._server = grpc.server(ThreadPoolExecutor(max_workers=10))
 
     if endpoint:
@@ -45,6 +45,9 @@ class TestStreamServiceController(TestStreamServiceServicer):
     beam_runner_api_pb2_grpc.add_TestStreamServiceServicer_to_server(
         self, self._server)
     self._reader = reader
+    self._exception_handler = exception_handler
+    if not self._exception_handler:
+      self._exception_handler = lambda _: False
 
   def start(self):
     self._server.start()
@@ -62,6 +65,13 @@ class TestStreamServiceController(TestStreamServiceServicer):
     # TODO(srohde): Once we get rid of the CacheManager, get rid of this 'full'
     # label.
     tags = [None if tag == 'None' else tag for tag in request.output_ids]
-    reader = self._reader.read_multiple([('full', tag) for tag in tags])
-    for e in reader:
-      yield e
+    try:
+      reader = self._reader.read_multiple([('full', tag) for tag in tags])
+      while True:
+        e = next(reader)
+        yield e
+    except StopIteration:
+      pass
+    except Exception as e:
+      if not self._exception_handler(e):
+        raise e
