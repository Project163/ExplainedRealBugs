diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/TFRecordIO.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/TFRecordIO.java
index bb65e777dd0..6f8227eb036 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/TFRecordIO.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/TFRecordIO.java
@@ -643,7 +643,8 @@ public class TFRecordIO {
    * Codec for TFRecords file format. See
    * https://www.tensorflow.org/versions/r1.11/api_guides/python/python_io#TFRecords_Format_Details
    */
-  private static class TFRecordCodec {
+  @VisibleForTesting
+  static class TFRecordCodec {
     private static final int HEADER_LEN = (Long.SIZE + Integer.SIZE) / Byte.SIZE;
     private static final int FOOTER_LEN = Integer.SIZE / Byte.SIZE;
     private static HashFunction crc32c = Hashing.crc32c();
@@ -669,15 +670,15 @@ public class TFRecordIO {
 
     public @Nullable byte[] read(ReadableByteChannel inChannel) throws IOException {
       header.clear();
-      int headerBytes = inChannel.read(header);
-      if (headerBytes <= 0) {
+      int headerBytes = read(inChannel, header);
+      if (headerBytes == 0) {
         return null;
       }
       checkState(headerBytes == HEADER_LEN, "Not a valid TFRecord. Fewer than 12 bytes.");
 
       header.rewind();
-      long length = header.getLong();
-      long lengthHash = hashLong(length);
+      long length64 = header.getLong();
+      long lengthHash = hashLong(length64);
       int maskedCrc32OfLength = header.getInt();
       if (lengthHash != maskedCrc32OfLength) {
         throw new IOException(
@@ -685,18 +686,16 @@ public class TFRecordIO {
                 "Mismatch of length mask when reading a record. Expected %d but received %d.",
                 maskedCrc32OfLength, lengthHash));
       }
-
-      ByteBuffer data = ByteBuffer.allocate((int) length);
-      while (data.hasRemaining() && inChannel.read(data) >= 0) {}
-      if (data.hasRemaining()) {
-        throw new IOException(
-            String.format(
-                "EOF while reading record of length %d. Read only %d bytes. Input might be truncated.",
-                length, data.position()));
+      int length = (int) length64;
+      if (length != length64) {
+        throw new IOException(String.format("length overflow %d", length64));
       }
 
+      ByteBuffer data = ByteBuffer.allocate(length);
+      readFully(inChannel, data);
+
       footer.clear();
-      inChannel.read(footer);
+      readFully(inChannel, footer);
       footer.rewind();
 
       int maskedCrc32OfData = footer.getInt();
@@ -717,14 +716,36 @@ public class TFRecordIO {
       header.clear();
       header.putLong(data.length).putInt(maskedCrc32OfLength);
       header.rewind();
-      outChannel.write(header);
+      writeFully(outChannel, header);
 
-      outChannel.write(ByteBuffer.wrap(data));
+      writeFully(outChannel, ByteBuffer.wrap(data));
 
       footer.clear();
       footer.putInt(maskedCrc32OfData);
       footer.rewind();
-      outChannel.write(footer);
+      writeFully(outChannel, footer);
+    }
+
+    @VisibleForTesting
+    static void readFully(ReadableByteChannel in, ByteBuffer bb) throws IOException {
+      int expected = bb.remaining();
+      int actual = read(in, bb);
+      if (expected != actual) {
+        throw new IOException(String.format("expected %d, but got %d", expected, actual));
+      }
+    }
+
+    private static int read(ReadableByteChannel in, ByteBuffer bb) throws IOException {
+      int expected = bb.remaining();
+      while (bb.hasRemaining() && in.read(bb) >= 0) {}
+      return expected - bb.remaining();
+    }
+
+    @VisibleForTesting
+    static void writeFully(WritableByteChannel channel, ByteBuffer buffer) throws IOException {
+      while (buffer.hasRemaining()) {
+        channel.write(buffer);
+      }
     }
   }
 }
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/TFRecordIOTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/TFRecordIOTest.java
index 37ddc595374..4ecfe6abd35 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/TFRecordIOTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/TFRecordIOTest.java
@@ -27,20 +27,36 @@ import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.in;
 import static org.hamcrest.core.Is.is;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.internal.matchers.ThrowableMessageMatcher.hasMessage;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.io.FilterInputStream;
+import java.io.FilterOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.Arrays;
+import java.util.Base64;
+import java.util.Base64.Decoder;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.ThreadLocalRandom;
 import org.apache.beam.sdk.coders.StringUtf8Coder;
 import org.apache.beam.sdk.io.FileIO.ReadableFile;
+import org.apache.beam.sdk.io.TFRecordIO.TFRecordCodec;
 import org.apache.beam.sdk.io.fs.MatchResult.Metadata;
 import org.apache.beam.sdk.testing.NeedsRunner;
 import org.apache.beam.sdk.testing.PAssert;
@@ -440,4 +456,118 @@ public class TFRecordIOTest {
       c.output(c.element().getBytes(Charsets.UTF_8));
     }
   }
+
+  static boolean maybeThisTime() {
+    return ThreadLocalRandom.current().nextBoolean();
+  }
+
+  static class PickyReadChannel extends FilterInputStream implements ReadableByteChannel {
+    protected PickyReadChannel(InputStream in) {
+      super(in);
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int read(ByteBuffer dst) throws IOException {
+      if (!maybeThisTime() || !dst.hasRemaining()) {
+        return 0;
+      }
+      int n = read();
+      if (n == -1) {
+        return -1;
+      }
+      dst.put((byte) n);
+      return 1;
+    }
+
+    @Override
+    public boolean isOpen() {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  static class PickyWriteChannel extends FilterOutputStream implements WritableByteChannel {
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    public PickyWriteChannel(OutputStream out) {
+      super(out);
+    }
+
+    @Override
+    public int write(ByteBuffer src) throws IOException {
+      if (!maybeThisTime() || !src.hasRemaining()) {
+        return 0;
+      }
+      write(src.get());
+      return 1;
+    }
+
+    @Override
+    public boolean isOpen() {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  @Test
+  public void testReadFully() throws IOException {
+    byte[] data = "Hello World".getBytes(StandardCharsets.UTF_8);
+    ReadableByteChannel chan = new PickyReadChannel(new ByteArrayInputStream(data));
+
+    ByteBuffer buffer = ByteBuffer.allocate(data.length);
+    TFRecordCodec.readFully(chan, buffer);
+
+    assertArrayEquals(data, buffer.array());
+  }
+
+  @Test
+  public void testReadFullyFail() throws IOException {
+    byte[] trunc = "Hello Wo".getBytes(StandardCharsets.UTF_8);
+    ReadableByteChannel chan = new PickyReadChannel(new ByteArrayInputStream(trunc));
+    ByteBuffer buffer = ByteBuffer.allocate(trunc.length + 1);
+
+    expectedException.expect(IOException.class);
+    expectedException.expectMessage("expected 9, but got 8");
+    TFRecordCodec.readFully(chan, buffer);
+  }
+
+  @Test
+  public void testWriteFully() throws IOException {
+    byte[] data = "Hello World".getBytes(StandardCharsets.UTF_8);
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    WritableByteChannel chan = new PickyWriteChannel(baos);
+
+    ByteBuffer buffer = ByteBuffer.wrap(data);
+    TFRecordCodec.writeFully(chan, buffer);
+
+    assertArrayEquals(data, baos.toByteArray());
+  }
+
+  @Test
+  public void testTFRecordCodec() throws IOException {
+    Decoder b64 = Base64.getDecoder();
+    TFRecordCodec codec = new TFRecordCodec();
+
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    PickyWriteChannel outChan = new PickyWriteChannel(baos);
+
+    codec.write(outChan, "foo".getBytes(StandardCharsets.UTF_8));
+    assertArrayEquals(b64.decode(FOO_RECORD_BASE64), baos.toByteArray());
+    codec.write(outChan, "bar".getBytes(StandardCharsets.UTF_8));
+    assertArrayEquals(b64.decode(FOO_BAR_RECORD_BASE64), baos.toByteArray());
+
+    PickyReadChannel inChan = new PickyReadChannel(new ByteArrayInputStream(baos.toByteArray()));
+    byte[] foo = codec.read(inChan);
+    byte[] bar = codec.read(inChan);
+    assertNull(codec.read(inChan));
+
+    assertEquals("foo", new String(foo, StandardCharsets.UTF_8));
+    assertEquals("bar", new String(bar, StandardCharsets.UTF_8));
+  }
 }
