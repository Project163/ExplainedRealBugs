diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java
index fc6eb5efdea..67eb832f13b 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java
@@ -782,6 +782,9 @@ public class Schema implements Serializable {
           return false;
         }
       }
+      if (!Objects.equals(getNullable(), other.getNullable())) {
+        return false;
+      }
       if (!Objects.equals(getMetadata(), other.getMetadata())) {
         return false;
       }
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTest.java
index 1369f5912e5..c8542c87ada 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTest.java
@@ -309,11 +309,30 @@ public class SchemaTest {
     assertEquals(schema1, schema2); // Logical types are the same.
 
     Schema schema3 =
-        Schema.builder().addLogicalTypeField("logical", new TestType("id2", "arg")).build();
-    assertNotEquals(schema1, schema3); // Logical type id is different.
+        Schema.builder()
+            .addNullableField("logical", Schema.FieldType.logicalType(new TestType("id", "arg")))
+            .build();
+    assertNotEquals(schema1, schema3); // schema1 and schema3 differ in Nullability
 
     Schema schema4 =
+        Schema.builder().addLogicalTypeField("logical", new TestType("id2", "arg")).build();
+    assertNotEquals(schema1, schema4); // Logical type id is different.
+
+    Schema schema5 =
         Schema.builder().addLogicalTypeField("logical", new TestType("id", "arg2")).build();
-    assertNotEquals(schema1, schema4); // Logical type arg is different.
+    assertNotEquals(schema1, schema5); // Logical type arg is different.
+  }
+
+  @Test
+  public void testTypesEquality() {
+    Schema schema1 = Schema.builder().addStringField("foo").build();
+    Schema schema2 = Schema.builder().addStringField("bar").build();
+    assertTrue(schema1.typesEqual(schema2)); // schema1 and schema2 only differ by names
+
+    Schema schema3 = Schema.builder().addNullableField("foo", FieldType.STRING).build();
+    assertFalse(schema1.typesEqual(schema3)); // schema1 and schema3 differ in Nullability
+
+    Schema schema4 = Schema.builder().addInt32Field("foo").build();
+    assertFalse(schema1.typesEqual(schema4)); // schema1 and schema4 differ by types
   }
 }
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java
index f4a2ce678fc..9434f781981 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java
@@ -293,15 +293,18 @@ public class BeamCalcRel extends AbstractBeamCalcRel {
     Expression valueDateTime = value;
 
     // First, convert to millis
-    if (CalciteUtils.TIMESTAMP.typesEqual(toType)) {
+    if (CalciteUtils.TIMESTAMP.typesEqual(toType)
+        || CalciteUtils.NULLABLE_TIMESTAMP.typesEqual(toType)) {
       if (value.getType() == java.sql.Timestamp.class) {
         valueDateTime = Expressions.call(BuiltInMethod.TIMESTAMP_TO_LONG.method, valueDateTime);
       }
-    } else if (CalciteUtils.TIME.typesEqual(toType)) {
+    } else if (CalciteUtils.TIME.typesEqual(toType)
+        || CalciteUtils.NULLABLE_TIME.typesEqual(toType)) {
       if (value.getType() == java.sql.Time.class) {
         valueDateTime = Expressions.call(BuiltInMethod.TIME_TO_INT.method, valueDateTime);
       }
-    } else if (CalciteUtils.DATE.typesEqual(toType)) {
+    } else if (CalciteUtils.DATE.typesEqual(toType)
+        || CalciteUtils.NULLABLE_DATE.typesEqual(toType)) {
       if (value.getType() == java.sql.Date.class) {
         valueDateTime = Expressions.call(BuiltInMethod.DATE_TO_INT.method, valueDateTime);
       }
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/utils/CalciteUtils.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/utils/CalciteUtils.java
index 90c49aafe90..e0b994d5815 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/utils/CalciteUtils.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/utils/CalciteUtils.java
@@ -129,10 +129,15 @@ public class CalciteUtils {
   public static final FieldType VARCHAR = FieldType.STRING;
   public static final FieldType CHAR = FieldType.logicalType(new CharType());
   public static final FieldType DATE = FieldType.logicalType(new DateType());
+  public static final FieldType NULLABLE_DATE =
+      FieldType.logicalType(new DateType()).withNullable(true);
   public static final FieldType TIME = FieldType.logicalType(new TimeType());
+  public static final FieldType NULLABLE_TIME =
+      FieldType.logicalType(new TimeType()).withNullable(true);
   public static final FieldType TIME_WITH_LOCAL_TZ =
       FieldType.logicalType(new TimeWithLocalTzType());
   public static final FieldType TIMESTAMP = FieldType.DATETIME;
+  public static final FieldType NULLABLE_TIMESTAMP = FieldType.DATETIME.withNullable(true);
   public static final FieldType TIMESTAMP_WITH_LOCAL_TZ =
       FieldType.logicalType(new TimestampWithLocalTzType());
 
