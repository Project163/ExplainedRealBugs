diff --git a/runners/core-construction-java/build.gradle b/runners/core-construction-java/build.gradle
index e7f48992ea9..1b9759793eb 100644
--- a/runners/core-construction-java/build.gradle
+++ b/runners/core-construction-java/build.gradle
@@ -42,6 +42,7 @@ dependencies {
   compile library.java.jackson_databind
   compile library.java.joda_time
   compile library.java.slf4j_api
+  testCompile project(path: ":sdks:java:core", configuration: "testRuntime")
   testCompile library.java.hamcrest_core
   testCompile library.java.hamcrest_library
   testCompile library.java.junit
diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/PipelineResources.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/PipelineResources.java
index f63e0822bf9..6c5e91e672f 100644
--- a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/PipelineResources.java
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/PipelineResources.java
@@ -29,37 +29,58 @@ import java.net.URLClassLoader;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
 import org.apache.beam.sdk.util.ZipFiles;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Splitter;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Strings;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.hash.Funnels;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.hash.Hasher;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.hash.Hashing;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /** Utilities for working with classpath resources for pipelines. */
 public class PipelineResources {
 
+  private static final Logger LOG = LoggerFactory.getLogger(PipelineResources.class);
+
   /**
-   * Attempts to detect all the resources the class loader has access to. This does not recurse to
-   * class loader parents stopping it from pulling in resources from the system class loader.
+   * Attempts to detect all the resources using either URLClassLoader (if it is available) or via
+   * the "java.class.path" system property. URLClassLoader is not available for Java 9 and above,
+   * hence the alternative approach was introduced.
    *
-   * @param classLoader The URLClassLoader to use to detect resources to stage.
-   * @throws IllegalArgumentException If either the class loader is not a URLClassLoader or one of
-   *     the resources the class loader exposes is not a file resource.
+   * @param classLoader The URLClassLoader to use to detect resources to stage (optional).
+   * @throws IllegalArgumentException If one of the resources the class loader exposes is not a file
+   *     resource.
    * @return A list of absolute paths to the resources the class loader uses.
    */
   public static List<String> detectClassPathResourcesToStage(ClassLoader classLoader) {
     if (!(classLoader instanceof URLClassLoader)) {
-      String message =
-          String.format(
-              "Unable to use ClassLoader to detect classpath elements. "
-                  + "Current ClassLoader is %s, only URLClassLoaders are supported.",
-              classLoader);
-      throw new IllegalArgumentException(message);
+      return scanClasspathForResourcesToStage();
+    } else {
+      LOG.info("Using URLClassLoader to detect classpath resources.");
+      return scanClasspathForResourcesToStage((URLClassLoader) classLoader);
     }
+  }
+
+  private static List<String> scanClasspathForResourcesToStage() {
+    LOG.info("Scanning classpath for resources to stage via the java.class.path system property.");
+
+    Iterable<String> classpathEntries =
+        Splitter.on(File.pathSeparator).split(System.getProperty("java.class.path"));
+
+    return StreamSupport.stream(classpathEntries.spliterator(), false)
+        .map(File::new)
+        .map(File::getAbsolutePath)
+        .collect(Collectors.toList());
+  }
+
+  private static List<String> scanClasspathForResourcesToStage(URLClassLoader classLoader) {
+    LOG.info("Scanning classpath for resources to stage via the URLClassLoader.");
 
     List<String> files = new ArrayList<>();
-    for (URL url : ((URLClassLoader) classLoader).getURLs()) {
+    for (URL url : classLoader.getURLs()) {
       try {
         files.add(new File(url.toURI()).getAbsolutePath());
       } catch (IllegalArgumentException | URISyntaxException e) {
diff --git a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/PipelineResourcesTest.java b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/PipelineResourcesTest.java
index 27b42e2689c..bb7794d8e43 100644
--- a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/PipelineResourcesTest.java
+++ b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/PipelineResourcesTest.java
@@ -18,6 +18,9 @@
 package org.apache.beam.runners.core.construction;
 
 import static junit.framework.TestCase.assertTrue;
+import static org.hamcrest.CoreMatchers.hasItems;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
 
@@ -28,6 +31,7 @@ import java.net.URLClassLoader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import org.apache.beam.sdk.testing.RestoreSystemProperties;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.junit.Rule;
 import org.junit.Test;
@@ -35,7 +39,6 @@ import org.junit.rules.ExpectedException;
 import org.junit.rules.TemporaryFolder;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-import org.mockito.Mockito;
 
 /** Tests for PipelineResources. */
 @RunWith(JUnit4.class)
@@ -43,6 +46,7 @@ public class PipelineResourcesTest {
 
   @Rule public transient TemporaryFolder tmpFolder = new TemporaryFolder();
   @Rule public transient ExpectedException thrown = ExpectedException.none();
+  @Rule public transient RestoreSystemProperties systemProperties = new RestoreSystemProperties();
 
   @Test
   public void detectClassPathResourceWithFileResources() throws Exception {
@@ -56,15 +60,6 @@ public class PipelineResourcesTest {
         PipelineResources.detectClassPathResourcesToStage(classLoader));
   }
 
-  @Test
-  public void detectClassPathResourcesWithUnsupportedClassLoader() {
-    ClassLoader mockClassLoader = Mockito.mock(ClassLoader.class);
-    thrown.expect(IllegalArgumentException.class);
-    thrown.expectMessage("Unable to use ClassLoader to detect classpath elements.");
-
-    PipelineResources.detectClassPathResourcesToStage(mockClassLoader);
-  }
-
   @Test
   public void detectClassPathResourceWithNonFileResources() throws Exception {
     String url = "http://www.google.com/all-the-secrets.jar";
@@ -75,6 +70,19 @@ public class PipelineResourcesTest {
     PipelineResources.detectClassPathResourcesToStage(classLoader);
   }
 
+  @Test
+  public void detectClassPathResourceWithoutURLClassLoader() throws IOException {
+    String path = tmpFolder.newFile("file").getAbsolutePath();
+    String path2 = tmpFolder.newFile("file2").getAbsolutePath();
+    String classpath = String.join(File.pathSeparator, path, path2);
+    System.setProperty("java.class.path", classpath);
+
+    List<String> resources = PipelineResources.detectClassPathResourcesToStage(null);
+
+    assertThat(resources, hasItems(path, path2));
+    assertThat(resources, hasSize(2));
+  }
+
   @Test
   public void testFailOnNonExistingPaths() throws IOException {
     String nonexistentFilePath = tmpFolder.getRoot().getPath() + "/nonexistent/file";
