diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUncollectRel.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUncollectRel.java
index 20ec78b03a2..b031a5026a0 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUncollectRel.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUncollectRel.java
@@ -101,7 +101,12 @@ public class BeamUncollectRel extends Uncollect implements BeamRelNode {
     @ProcessElement
     public void process(@Element Row inputRow, OutputReceiver<Row> output) {
       for (Object element : inputRow.getArray(0)) {
-        output.output(Row.withSchema(schema).addValue(element).build());
+        if (element instanceof Row) {
+          Row nestedRow = (Row) element;
+          output.output(Row.withSchema(schema).addValues(nestedRow.getValues()).build());
+        } else {
+          output.output(Row.withSchema(schema).addValue(element).build());
+        }
       }
     }
   }
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUnnestRel.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUnnestRel.java
index 7ea7c623895..0af4ee3a029 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUnnestRel.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUnnestRel.java
@@ -134,13 +134,24 @@ public class BeamUnnestRel extends Uncollect implements BeamRelNode {
       if (rawValues == null) {
         return;
       }
+      Schema.TypeName typeName =
+          outputSchema.getField(unnestIndex).getType().getCollectionElementType().getTypeName();
 
       for (Object uncollectedValue : rawValues) {
-        out.output(
-            Row.withSchema(outputSchema)
-                .addValues(row.getValues())
-                .addValue(uncollectedValue)
-                .build());
+        if (typeName.equals(Schema.TypeName.ROW)) {
+          Row nestedRow = (Row) uncollectedValue;
+          out.output(
+              Row.withSchema(outputSchema)
+                  .addValues(row.getValues())
+                  .addValues(nestedRow.getValues())
+                  .build());
+        } else {
+          out.output(
+              Row.withSchema(outputSchema)
+                  .addValues(row.getValues())
+                  .addValue(uncollectedValue)
+                  .build());
+        }
       }
     }
   }
diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUncollectRelTest.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUncollectRelTest.java
index 2992c72412b..d5b28574a05 100644
--- a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUncollectRelTest.java
+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUncollectRelTest.java
@@ -17,13 +17,26 @@
  */
 package org.apache.beam.sdk.extensions.sql.impl.rel;
 
+import java.util.Arrays;
+import java.util.List;
+import org.apache.beam.sdk.extensions.sql.TestUtils;
 import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;
+import org.apache.beam.sdk.extensions.sql.meta.provider.test.TestBoundedTable;
+import org.apache.beam.sdk.schemas.Schema;
+import org.apache.beam.sdk.testing.PAssert;
+import org.apache.beam.sdk.testing.TestPipeline;
+import org.apache.beam.sdk.values.PCollection;
+import org.apache.beam.sdk.values.Row;
 import org.apache.calcite.rel.RelNode;
 import org.junit.Assert;
+import org.junit.Rule;
 import org.junit.Test;
 
 /** Tests for {@code BeamUncollectRel}. */
 public class BeamUncollectRelTest extends BaseRelTest {
+
+  @Rule public final TestPipeline pipeline = TestPipeline.create();
+
   private NodeStats getEstimateOf(String sql) {
     RelNode root = env.parseQuery(sql);
 
@@ -44,4 +57,47 @@ public class BeamUncollectRelTest extends BaseRelTest {
     Assert.assertEquals(4d, estimate.getWindow(), 0.001);
     Assert.assertEquals(0., estimate.getRate(), 0.001);
   }
+
+  @Test
+  public void testUncollectPrimitive() {
+    String sql = "SELECT * FROM unnest(ARRAY [1, 2, 3])";
+
+    PCollection<Row> rows = compilePipeline(sql, pipeline);
+    PAssert.that(rows)
+        .containsInAnyOrder(
+            TestUtils.RowsBuilder.of(Schema.FieldType.INT32, "intField")
+                .addRows(1, 2, 3)
+                .getRows());
+    pipeline.run();
+  }
+
+  @Test
+  public void testUncollectNested() {
+    Schema rowSchema =
+        Schema.builder().addStringField("stringField").addInt32Field("intField").build();
+    List<Row> nestedRows =
+        Arrays.asList(
+            Row.withSchema(rowSchema).addValues("test1", 1).build(),
+            Row.withSchema(rowSchema).addValues("test2", 2).build());
+    registerTable(
+        "NESTED",
+        TestBoundedTable.of(
+                Schema.FieldType.STRING,
+                "user_id",
+                Schema.FieldType.array(Schema.FieldType.row(rowSchema)),
+                "nested")
+            .addRows("1", nestedRows));
+
+    String sql = "SELECT intField, stringField FROM unnest(SELECT nested from NESTED)";
+
+    PCollection<Row> rows = compilePipeline(sql, pipeline);
+    PAssert.that(rows)
+        .containsInAnyOrder(
+            TestUtils.RowsBuilder.of(
+                    Schema.FieldType.INT32, "intField",
+                    Schema.FieldType.STRING, "stringField")
+                .addRows(1, "test1", 2, "test2")
+                .getRows());
+    pipeline.run();
+  }
 }
diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUnnestRelTest.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUnnestRelTest.java
new file mode 100644
index 00000000000..c103ac5ae18
--- /dev/null
+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamUnnestRelTest.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.extensions.sql.impl.rel;
+
+import java.util.Arrays;
+import java.util.List;
+import org.apache.beam.sdk.extensions.sql.TestUtils;
+import org.apache.beam.sdk.extensions.sql.meta.provider.test.TestBoundedTable;
+import org.apache.beam.sdk.schemas.Schema;
+import org.apache.beam.sdk.testing.PAssert;
+import org.apache.beam.sdk.testing.TestPipeline;
+import org.apache.beam.sdk.values.PCollection;
+import org.apache.beam.sdk.values.Row;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+
+/** Test for {@code BeamUnnestRel}. */
+public class BeamUnnestRelTest extends BaseRelTest {
+  @Rule public final TestPipeline pipeline = TestPipeline.create();
+
+  @BeforeClass
+  public static void prepare() {
+    Schema rowSchema =
+        Schema.builder().addStringField("stringField").addInt32Field("intField").build();
+    List<Row> nestedRows =
+        Arrays.asList(
+            Row.withSchema(rowSchema).addValues("test1", 1).build(),
+            Row.withSchema(rowSchema).addValues("test2", 2).build());
+    registerTable(
+        "NESTED",
+        TestBoundedTable.of(
+                Schema.FieldType.STRING,
+                "user_id",
+                Schema.FieldType.array(Schema.FieldType.row(rowSchema)),
+                "nested")
+            .addRows("1", nestedRows));
+  }
+
+  @Test
+  public void testUnnest() {
+    String sql =
+        "SELECT user_id, p.intField, p.stringField FROM NESTED as t, unnest(t.nested) as p";
+
+    PCollection<Row> rows = compilePipeline(sql, pipeline);
+    PAssert.that(rows)
+        .containsInAnyOrder(
+            TestUtils.RowsBuilder.of(
+                    Schema.FieldType.STRING, "user_id",
+                    Schema.FieldType.INT32, "intField",
+                    Schema.FieldType.STRING, "stringField")
+                .addRows("1", 1, "test1", "1", 2, "test2")
+                .getRows());
+    pipeline.run();
+  }
+}
