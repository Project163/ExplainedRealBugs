diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/RenameFields.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/RenameFields.java
index 7b8da25a846..bdb5bea453c 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/RenameFields.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/RenameFields.java
@@ -17,11 +17,16 @@
  */
 package org.apache.beam.sdk.schemas.transforms;
 
+import com.google.auto.value.AutoValue;
 import java.io.Serializable;
+import java.util.BitSet;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.UUID;
 import java.util.stream.Collectors;
+import javax.annotation.Nullable;
 import org.apache.beam.sdk.annotations.Experimental;
 import org.apache.beam.sdk.annotations.Experimental.Kind;
 import org.apache.beam.sdk.schemas.FieldAccessDescriptor;
@@ -33,12 +38,13 @@ import org.apache.beam.sdk.transforms.PTransform;
 import org.apache.beam.sdk.transforms.ParDo;
 import org.apache.beam.sdk.values.PCollection;
 import org.apache.beam.sdk.values.Row;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ArrayListMultimap;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Maps;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Multimap;
-import org.apache.commons.compress.utils.Lists;
 
 /**
  * A transform for renaming fields inside an existing schema. Top level or nested fields can be
@@ -64,64 +70,95 @@ public class RenameFields {
     return new Inner<>();
   }
 
-  // Describes a single renameSchema rule.
-  private static class RenamePair implements Serializable {
+  // Describes a single renameSchema rule
+  @AutoValue
+  abstract static class RenamePair implements Serializable {
     // The FieldAccessDescriptor describing the field to renameSchema. Must reference a singleton
     // field.
-    private final FieldAccessDescriptor fieldAccessDescriptor;
+    abstract FieldAccessDescriptor getFieldAccessDescriptor();
     // The new name for the field.
-    private final String newName;
+    abstract String getNewName();
 
-    RenamePair(FieldAccessDescriptor fieldAccessDescriptor, String newName) {
-      this.fieldAccessDescriptor = fieldAccessDescriptor;
-      this.newName = newName;
+    static RenamePair of(FieldAccessDescriptor fieldAccessDescriptor, String newName) {
+      return new AutoValue_RenameFields_RenamePair(fieldAccessDescriptor, newName);
     }
 
     RenamePair resolve(Schema schema) {
-      FieldAccessDescriptor resolved = fieldAccessDescriptor.resolve(schema);
+      FieldAccessDescriptor resolved = getFieldAccessDescriptor().resolve(schema);
       if (!resolved.referencesSingleField()) {
         throw new IllegalArgumentException(resolved + " references multiple fields.");
       }
-      return new RenamePair(resolved, newName);
+      return RenamePair.of(resolved, getNewName());
     }
   }
 
-  private static FieldType renameFieldType(FieldType inputType, Collection<RenamePair> renames) {
+  private static FieldType renameFieldType(
+      FieldType inputType,
+      Collection<RenamePair> renames,
+      Map<UUID, Schema> renamedSchemasMap,
+      Map<UUID, BitSet> nestedFieldRenamedMap) {
+    if (renames.isEmpty()) {
+      return inputType;
+    }
+
     switch (inputType.getTypeName()) {
       case ROW:
-        return FieldType.row(renameSchema(inputType.getRowSchema(), renames));
+        renameSchema(inputType.getRowSchema(), renames, renamedSchemasMap, nestedFieldRenamedMap);
+        return FieldType.row(renamedSchemasMap.get(inputType.getRowSchema().getUUID()));
       case ARRAY:
-        return FieldType.array(renameFieldType(inputType.getCollectionElementType(), renames));
+        return FieldType.array(
+            renameFieldType(
+                inputType.getCollectionElementType(),
+                renames,
+                renamedSchemasMap,
+                nestedFieldRenamedMap));
       case ITERABLE:
-        return FieldType.iterable(renameFieldType(inputType.getCollectionElementType(), renames));
+        return FieldType.iterable(
+            renameFieldType(
+                inputType.getCollectionElementType(),
+                renames,
+                renamedSchemasMap,
+                nestedFieldRenamedMap));
       case MAP:
         return FieldType.map(
-            renameFieldType(inputType.getMapKeyType(), renames),
-            renameFieldType(inputType.getMapValueType(), renames));
+            renameFieldType(
+                inputType.getMapKeyType(), renames, renamedSchemasMap, nestedFieldRenamedMap),
+            renameFieldType(
+                inputType.getMapValueType(), renames, renamedSchemasMap, nestedFieldRenamedMap));
+      case LOGICAL_TYPE:
+        throw new RuntimeException("RenameFields does not support renaming logical types.");
       default:
         return inputType;
     }
   }
 
   // Apply the user-specified renames to the input schema.
-  private static Schema renameSchema(Schema inputSchema, Collection<RenamePair> renames) {
+  @VisibleForTesting
+  static void renameSchema(
+      Schema inputSchema,
+      Collection<RenamePair> renames,
+      Map<UUID, Schema> renamedSchemasMap,
+      Map<UUID, BitSet> nestedFieldRenamedMap) {
     // The mapping of renames to apply at this level of the schema.
     Map<Integer, String> topLevelRenames = Maps.newHashMap();
     // For nested schemas, collect all applicable renames here.
     Multimap<Integer, RenamePair> nestedRenames = ArrayListMultimap.create();
 
     for (RenamePair rename : renames) {
-      FieldAccessDescriptor access = rename.fieldAccessDescriptor;
+      FieldAccessDescriptor access = rename.getFieldAccessDescriptor();
       if (!access.fieldIdsAccessed().isEmpty()) {
         // This references a field at this level of the schema.
         Integer fieldId = Iterables.getOnlyElement(access.fieldIdsAccessed());
-        topLevelRenames.put(fieldId, rename.newName);
+        topLevelRenames.put(fieldId, rename.getNewName());
       } else {
         // This references a nested field.
         Map.Entry<Integer, FieldAccessDescriptor> nestedAccess =
             Iterables.getOnlyElement(access.nestedFieldsById().entrySet());
+        nestedFieldRenamedMap
+            .computeIfAbsent(inputSchema.getUUID(), s -> new BitSet(inputSchema.getFieldCount()))
+            .set(nestedAccess.getKey());
         nestedRenames.put(
-            nestedAccess.getKey(), new RenamePair(nestedAccess.getValue(), rename.newName));
+            nestedAccess.getKey(), RenamePair.of(nestedAccess.getValue(), rename.getNewName()));
       }
     }
 
@@ -130,16 +167,13 @@ public class RenameFields {
       Field field = inputSchema.getField(i);
       FieldType fieldType = field.getType();
       String newName = topLevelRenames.getOrDefault(i, field.getName());
-      Collection<RenamePair> nestedFieldRenames = nestedRenames.asMap().get(i);
-      if (nestedFieldRenames != null) {
-        // There are nested field renames. Recursively renameSchema the rest of the schema.
-        builder.addField(newName, renameFieldType(fieldType, nestedFieldRenames));
-      } else {
-        // No renameSchema for this field. Just add it back as is, potentially with a new name.
-        builder.addField(newName, fieldType);
-      }
+      Collection<RenamePair> nestedFieldRenames =
+          nestedRenames.asMap().getOrDefault(i, Collections.emptyList());
+      builder.addField(
+          newName,
+          renameFieldType(fieldType, nestedFieldRenames, renamedSchemasMap, nestedFieldRenamedMap));
     }
-    return builder.build();
+    renamedSchemasMap.put(inputSchema.getUUID(), builder.build());
   }
 
   /** The class implementing the actual PTransform. */
@@ -164,7 +198,7 @@ public class RenameFields {
       List<RenamePair> newList =
           ImmutableList.<RenamePair>builder()
               .addAll(renames)
-              .add(new RenamePair(field, newName))
+              .add(RenamePair.of(field, newName))
               .build();
 
       return new Inner<>(newList);
@@ -172,21 +206,104 @@ public class RenameFields {
 
     @Override
     public PCollection<Row> expand(PCollection<T> input) {
-      Schema inputSchema = input.getSchema();
+      final Map<UUID, Schema> renamedSchemasMap = Maps.newHashMap();
+      final Map<UUID, BitSet> nestedFieldRenamedMap = Maps.newHashMap();
 
-      List<RenamePair> pairs =
-          renames.stream().map(r -> r.resolve(inputSchema)).collect(Collectors.toList());
-      final Schema outputSchema = renameSchema(inputSchema, pairs);
+      List<RenamePair> resolvedRenames =
+          renames.stream().map(r -> r.resolve(input.getSchema())).collect(Collectors.toList());
+      renameSchema(input.getSchema(), resolvedRenames, renamedSchemasMap, nestedFieldRenamedMap);
+      final Schema outputSchema = renamedSchemasMap.get(input.getSchema().getUUID());
+      final BitSet nestedRenames = nestedFieldRenamedMap.get(input.getSchema().getUUID());
       return input
           .apply(
               ParDo.of(
                   new DoFn<T, Row>() {
                     @ProcessElement
                     public void processElement(@Element Row row, OutputReceiver<Row> o) {
-                      o.output(Row.withSchema(outputSchema).attachValues(row.getValues()));
+                      o.output(
+                          renameRow(
+                              row,
+                              outputSchema,
+                              nestedRenames,
+                              renamedSchemasMap,
+                              nestedFieldRenamedMap));
                     }
                   }))
           .setRowSchema(outputSchema);
     }
   }
+
+  // TODO(reuvenlax): For better performance, we should reuse functionality in
+  // SelectByteBuddyHelpers to generate
+  // byte code to do the rename. This would allow us to skip walking over the schema on each row.
+  // For now we added
+  // the optimization to skip schema walking if there are no nested renames (as determined by the
+  // nestedFieldRenamedMap).
+  @VisibleForTesting
+  static Row renameRow(
+      Row row,
+      Schema schema,
+      @Nullable BitSet nestedRenames,
+      Map<UUID, Schema> renamedSubSchemasMap,
+      Map<UUID, BitSet> nestedFieldRenamedMap) {
+    if (nestedRenames == null || nestedRenames.isEmpty()) {
+      // Fast path, short circuit subschems.
+      return Row.withSchema(schema).attachValues(row.getValues());
+    } else {
+      List<Object> values = Lists.newArrayListWithCapacity(row.getValues().size());
+      for (int i = 0; i < schema.getFieldCount(); ++i) {
+        if (nestedRenames.get(i)) {
+          values.add(
+              renameFieldValue(
+                  row.getValue(i),
+                  schema.getField(i).getType(),
+                  renamedSubSchemasMap,
+                  nestedFieldRenamedMap));
+        } else {
+          values.add(row.getValue(i));
+        }
+      }
+      return Row.withSchema(schema).attachValues(values);
+    }
+  }
+
+  private static Object renameFieldValue(
+      Object value,
+      FieldType fieldType,
+      Map<UUID, Schema> renamedSubSchemas,
+      Map<UUID, BitSet> nestedFieldRenamed) {
+    switch (fieldType.getTypeName()) {
+      case ARRAY:
+      case ITERABLE:
+        List<Object> renamedValues = Lists.newArrayList();
+        for (Object o : (List) value) {
+          renamedValues.add(
+              renameFieldValue(
+                  o, fieldType.getCollectionElementType(), renamedSubSchemas, nestedFieldRenamed));
+        }
+        return renamedValues;
+      case MAP:
+        Map<Object, Object> renamedMap = Maps.newHashMap();
+        for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) value).entrySet()) {
+          renamedMap.put(
+              renameFieldValue(
+                  entry.getKey(), fieldType.getMapKeyType(), renamedSubSchemas, nestedFieldRenamed),
+              renameFieldValue(
+                  entry.getValue(),
+                  fieldType.getMapValueType(),
+                  renamedSubSchemas,
+                  nestedFieldRenamed));
+        }
+        return renamedMap;
+      case ROW:
+        return renameRow(
+            (Row) value,
+            fieldType.getRowSchema(),
+            nestedFieldRenamed.get(fieldType.getRowSchema().getUUID()),
+            renamedSubSchemas,
+            nestedFieldRenamed);
+      default:
+        return value;
+    }
+  }
 }
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/RenameFieldsTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/RenameFieldsTest.java
index 963fff8f6e7..df2af441081 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/RenameFieldsTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/RenameFieldsTest.java
@@ -19,8 +19,14 @@ package org.apache.beam.sdk.schemas.transforms;
 
 import static junit.framework.TestCase.assertEquals;
 
+import java.util.BitSet;
 import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import org.apache.beam.sdk.schemas.FieldAccessDescriptor;
 import org.apache.beam.sdk.schemas.Schema;
+import org.apache.beam.sdk.schemas.transforms.RenameFields.RenamePair;
 import org.apache.beam.sdk.testing.NeedsRunner;
 import org.apache.beam.sdk.testing.PAssert;
 import org.apache.beam.sdk.testing.TestPipeline;
@@ -29,6 +35,7 @@ import org.apache.beam.sdk.values.PCollection;
 import org.apache.beam.sdk.values.Row;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Maps;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
@@ -258,4 +265,65 @@ public class RenameFieldsTest {
     PAssert.that(renamed).containsInAnyOrder(expectedRows);
     pipeline.run();
   }
+
+  @Test
+  public void testRenameRow() {
+    Schema nestedSchema = Schema.builder().addStringField("field1").addInt32Field("field2").build();
+    Schema schema =
+        Schema.builder().addStringField("field1").addRowField("nested", nestedSchema).build();
+
+    Schema expectedNestedSchema =
+        Schema.builder().addStringField("bottom1").addInt32Field("bottom2").build();
+    Schema expectedSchema =
+        Schema.builder()
+            .addStringField("top1")
+            .addRowField("top_nested", expectedNestedSchema)
+            .build();
+
+    List<RenamePair> renames =
+        ImmutableList.of(
+                RenamePair.of(FieldAccessDescriptor.withFieldNames("field1"), "top1"),
+                RenamePair.of(FieldAccessDescriptor.withFieldNames("nested"), "top_nested"),
+                RenamePair.of(FieldAccessDescriptor.withFieldNames("nested.field1"), "bottom1"),
+                RenamePair.of(FieldAccessDescriptor.withFieldNames("nested.field2"), "bottom2"))
+            .stream()
+            .map(r -> r.resolve(schema))
+            .collect(Collectors.toList());
+
+    final Map<UUID, Schema> renamedSchemasMap = Maps.newHashMap();
+    final Map<UUID, BitSet> nestedFieldRenamedMap = Maps.newHashMap();
+    RenameFields.renameSchema(schema, renames, renamedSchemasMap, nestedFieldRenamedMap);
+
+    assertEquals(expectedSchema, renamedSchemasMap.get(schema.getUUID()));
+
+    Row row =
+        Row.withSchema(schema)
+            .withFieldValue("field1", "one")
+            .withFieldValue(
+                "nested",
+                Row.withSchema(nestedSchema)
+                    .withFieldValue("field1", "one")
+                    .withFieldValue("field2", 1)
+                    .build())
+            .build();
+    Row expectedRow =
+        Row.withSchema(expectedSchema)
+            .withFieldValue("top1", "one")
+            .withFieldValue(
+                "top_nested",
+                Row.withSchema(expectedNestedSchema)
+                    .withFieldValue("bottom1", "one")
+                    .withFieldValue("bottom2", 1)
+                    .build())
+            .build();
+
+    Row renamedRow =
+        RenameFields.renameRow(
+            row,
+            renamedSchemasMap.get(schema.getUUID()),
+            nestedFieldRenamedMap.get(schema.getUUID()),
+            renamedSchemasMap,
+            nestedFieldRenamedMap);
+    assertEquals(expectedRow, renamedRow);
+  }
 }
