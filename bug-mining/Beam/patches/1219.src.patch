diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
index f60d4178b3f..230a65e2098 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
@@ -82,6 +82,7 @@ import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.PCollectionView;
 import org.apache.beam.sdk.values.TupleTag;
 import org.apache.beam.sdk.values.WindowingStrategy;
+import org.apache.beam.vendor.grpc.v1p13p1.com.google.protobuf.ByteString;
 import org.apache.beam.vendor.guava.v20_0.com.google.common.base.Preconditions;
 import org.apache.flink.api.java.functions.KeySelector;
 import org.apache.flink.runtime.state.KeyedStateBackend;
@@ -241,8 +242,8 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
     return StateRequestHandlers.delegateBasedUponType(handlerMap);
   }
 
-  private static class BagUserStateFactory
-      implements StateRequestHandlers.BagUserStateHandlerFactory {
+  private static class BagUserStateFactory<K extends ByteString, V, W extends BoundedWindow>
+      implements StateRequestHandlers.BagUserStateHandlerFactory<K, V, W> {
 
     private final StateInternals stateInternals;
     private final KeyedStateBackend<ByteBuffer> keyedStateBackend;
@@ -259,13 +260,12 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
     }
 
     @Override
-    public <K, V, W extends BoundedWindow>
-        StateRequestHandlers.BagUserStateHandler<K, V, W> forUserState(
-            String pTransformId,
-            String userStateId,
-            Coder<K> keyCoder,
-            Coder<V> valueCoder,
-            Coder<W> windowCoder) {
+    public StateRequestHandlers.BagUserStateHandler<K, V, W> forUserState(
+        String pTransformId,
+        String userStateId,
+        Coder<K> keyCoder,
+        Coder<V> valueCoder,
+        Coder<W> windowCoder) {
       return new StateRequestHandlers.BagUserStateHandler<K, V, W>() {
         @Override
         public Iterable<V> get(K key, W window) {
@@ -339,7 +339,8 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
           // Key for state request is shipped already encoded as ByteString,
           // this is mostly a wrapping with ByteBuffer. We still follow the
           // usual key encoding procedure.
-          final ByteBuffer encodedKey = FlinkKeyUtils.encodeKey(key, keyCoder);
+          // final ByteBuffer encodedKey = FlinkKeyUtils.encodeKey(key, keyCoder);
+          final ByteBuffer encodedKey = ByteBuffer.wrap(key.toByteArray());
           keyedStateBackend.setCurrentKey(encodedKey);
         }
       };
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java
index f14c7f37590..61ec24d538b 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java
@@ -34,8 +34,8 @@ import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
  * Holds user state in memory. Only one key is active at a time due to the GroupReduceFunction being
  * called once per key. Needs to be reset via {@code resetForNewKey()} before processing a new key.
  */
-public class InMemoryBagUserStateFactory
-    implements StateRequestHandlers.BagUserStateHandlerFactory {
+public class InMemoryBagUserStateFactory<K, V, W extends BoundedWindow>
+    implements StateRequestHandlers.BagUserStateHandlerFactory<K, V, W> {
 
   private List<InMemorySingleKeyBagState> handlers;
 
@@ -44,13 +44,12 @@ public class InMemoryBagUserStateFactory
   }
 
   @Override
-  public <K, V, W extends BoundedWindow>
-      StateRequestHandlers.BagUserStateHandler<K, V, W> forUserState(
-          String pTransformId,
-          String userStateId,
-          Coder<K> keyCoder,
-          Coder<V> valueCoder,
-          Coder<W> windowCoder) {
+  public StateRequestHandlers.BagUserStateHandler<K, V, W> forUserState(
+      String pTransformId,
+      String userStateId,
+      Coder<K> keyCoder,
+      Coder<V> valueCoder,
+      Coder<W> windowCoder) {
 
     InMemorySingleKeyBagState<K, V, W> bagUserStateHandler =
         new InMemorySingleKeyBagState<>(userStateId, valueCoder, windowCoder);
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java
index 0656e30d078..33fcb426fdf 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java
@@ -145,8 +145,8 @@ public class StateRequestHandlers {
    * <p>Note that this factory should be thread safe.
    */
   @ThreadSafe
-  public interface BagUserStateHandlerFactory {
-    <K, V, W extends BoundedWindow> BagUserStateHandler<K, V, W> forUserState(
+  public interface BagUserStateHandlerFactory<K, V, W extends BoundedWindow> {
+    BagUserStateHandler<K, V, W> forUserState(
         String pTransformId,
         String userStateId,
         Coder<K> keyCoder,
@@ -154,10 +154,10 @@ public class StateRequestHandlers {
         Coder<W> windowCoder);
 
     /** Throws a {@link UnsupportedOperationException} on the first access. */
-    static BagUserStateHandlerFactory unsupported() {
-      return new BagUserStateHandlerFactory() {
+    static <K, V, W extends BoundedWindow> BagUserStateHandlerFactory<K, V, W> unsupported() {
+      return new BagUserStateHandlerFactory<K, V, W>() {
         @Override
-        public <K, V, W extends BoundedWindow> BagUserStateHandler<K, V, W> forUserState(
+        public BagUserStateHandler<K, V, W> forUserState(
             String pTransformId,
             String userStateId,
             Coder<K> keyCoder,
diff --git a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java
index be03ab91f5b..f66e37b1e1a 100644
--- a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java
+++ b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java
@@ -884,27 +884,28 @@ public class RemoteExecutionTest implements Serializable {
     StateRequestHandler stateRequestHandler =
         StateRequestHandlers.forBagUserStateHandlerFactory(
             descriptor,
-            new BagUserStateHandlerFactory() {
+            new BagUserStateHandlerFactory<ByteString, Object, BoundedWindow>() {
               @Override
-              public <K, V, W extends BoundedWindow> BagUserStateHandler<K, V, W> forUserState(
+              public BagUserStateHandler<ByteString, Object, BoundedWindow> forUserState(
                   String pTransformId,
                   String userStateId,
-                  Coder<K> keyCoder,
-                  Coder<V> valueCoder,
-                  Coder<W> windowCoder) {
-                return new BagUserStateHandler<K, V, W>() {
+                  Coder<ByteString> keyCoder,
+                  Coder<Object> valueCoder,
+                  Coder<BoundedWindow> windowCoder) {
+                return new BagUserStateHandler<ByteString, Object, BoundedWindow>() {
                   @Override
-                  public Iterable<V> get(K key, W window) {
+                  public Iterable<Object> get(ByteString key, BoundedWindow window) {
                     return (Iterable) userStateData.get(userStateId);
                   }
 
                   @Override
-                  public void append(K key, W window, Iterator<V> values) {
+                  public void append(
+                      ByteString key, BoundedWindow window, Iterator<Object> values) {
                     Iterators.addAll(userStateData.get(userStateId), (Iterator) values);
                   }
 
                   @Override
-                  public void clear(K key, W window) {
+                  public void clear(ByteString key, BoundedWindow window) {
                     userStateData.get(userStateId).clear();
                   }
                 };
