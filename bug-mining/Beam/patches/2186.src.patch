diff --git a/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/DataflowRunner.java b/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/DataflowRunner.java
index cf3555af169..4ac6b940757 100644
--- a/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/DataflowRunner.java
+++ b/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/DataflowRunner.java
@@ -480,10 +480,17 @@ public class DataflowRunner extends PipelineRunner<DataflowPipelineJob> {
     }
     if (streaming) {
       if (!hasExperiment(options, "enable_custom_pubsub_source")) {
-        overridesBuilder.add(
-            PTransformOverride.of(
-                PTransformMatchers.classEqualTo(PubsubUnboundedSource.class),
-                new StreamingPubsubIOReadOverrideFactory()));
+        if (useUnifiedWorker(options)) {
+          overridesBuilder.add(
+              PTransformOverride.of(
+                  PTransformMatchers.classEqualTo(PubsubUnboundedSource.class),
+                  new DataflowReadFromPubsubSourceForRunnerV2OverrideFactory()));
+        } else {
+          overridesBuilder.add(
+              PTransformOverride.of(
+                  PTransformMatchers.classEqualTo(PubsubUnboundedSource.class),
+                  new StreamingPubsubIOReadOverrideFactory()));
+        }
       }
       if (!hasExperiment(options, "enable_custom_pubsub_sink")) {
         if (useUnifiedWorker(options)) {
@@ -1416,12 +1423,35 @@ public class DataflowRunner extends PipelineRunner<DataflowPipelineJob> {
     }
   }
 
+  private static class DataflowReadFromPubsubSourceForRunnerV2OverrideFactory
+      implements PTransformOverrideFactory<
+          PBegin, PCollection<PubsubMessage>, PubsubUnboundedSource> {
+
+    @Override
+    public PTransformReplacement<PBegin, PCollection<PubsubMessage>> getReplacementTransform(
+        AppliedPTransform<PBegin, PCollection<PubsubMessage>, PubsubUnboundedSource> transform) {
+      return PTransformReplacement.of(
+          transform.getPipeline().begin(),
+          new DataflowReadFromPubsubForRunnerV2(transform.getTransform()));
+    }
+
+    @Override
+    public Map<PCollection<?>, ReplacementOutput> mapOutputs(
+        Map<TupleTag<?>, PCollection<?>> outputs, PCollection<PubsubMessage> newOutput) {
+      return ReplacementOutputs.singleton(outputs, newOutput);
+    }
+  }
+
+  private interface PubsubUnboundedSourceOverrider {
+    PubsubUnboundedSource getOverriddenTransform();
+  }
+
   /**
    * Suppress application of {@link PubsubUnboundedSource#expand} in streaming mode so that we can
    * instead defer to Windmill's implementation.
    */
-  private static class StreamingPubsubIORead
-      extends PTransform<PBegin, PCollection<PubsubMessage>> {
+  private static class StreamingPubsubIORead extends PTransform<PBegin, PCollection<PubsubMessage>>
+      implements PubsubUnboundedSourceOverrider {
 
     private final PubsubUnboundedSource transform;
 
@@ -1429,7 +1459,8 @@ public class DataflowRunner extends PipelineRunner<DataflowPipelineJob> {
       this.transform = transform;
     }
 
-    PubsubUnboundedSource getOverriddenTransform() {
+    @Override
+    public PubsubUnboundedSource getOverriddenTransform() {
       return transform;
     }
 
@@ -1454,57 +1485,131 @@ public class DataflowRunner extends PipelineRunner<DataflowPipelineJob> {
     }
   }
 
-  /** Rewrite {@link StreamingPubsubIORead} to the appropriate internal node. */
-  private static class StreamingPubsubIOReadTranslator
-      implements TransformTranslator<StreamingPubsubIORead> {
+  private static class DataflowPubsubSourceRunnerV2 extends PTransform<PBegin, PCollection<byte[]>>
+      implements PubsubUnboundedSourceOverrider {
+
+    private final PubsubUnboundedSource transform;
+
+    public DataflowPubsubSourceRunnerV2(PubsubUnboundedSource transform) {
+      this.transform = transform;
+    }
 
     @Override
-    public void translate(StreamingPubsubIORead transform, TranslationContext context) {
-      checkArgument(
-          context.getPipelineOptions().isStreaming(),
-          "StreamingPubsubIORead is only for streaming pipelines.");
-      PubsubUnboundedSource overriddenTransform = transform.getOverriddenTransform();
-      StepTranslationContext stepContext = context.addStep(transform, "ParallelRead");
-      stepContext.addInput(PropertyNames.FORMAT, "pubsub");
-      if (overriddenTransform.getTopicProvider() != null) {
-        if (overriddenTransform.getTopicProvider().isAccessible()) {
-          stepContext.addInput(
-              PropertyNames.PUBSUB_TOPIC, overriddenTransform.getTopic().getV1Beta1Path());
-        } else {
-          stepContext.addInput(
-              PropertyNames.PUBSUB_TOPIC_OVERRIDE,
-              ((NestedValueProvider) overriddenTransform.getTopicProvider()).propertyName());
-        }
-      }
-      if (overriddenTransform.getSubscriptionProvider() != null) {
-        if (overriddenTransform.getSubscriptionProvider().isAccessible()) {
-          stepContext.addInput(
-              PropertyNames.PUBSUB_SUBSCRIPTION,
-              overriddenTransform.getSubscription().getV1Beta1Path());
-        } else {
-          stepContext.addInput(
-              PropertyNames.PUBSUB_SUBSCRIPTION_OVERRIDE,
-              ((NestedValueProvider) overriddenTransform.getSubscriptionProvider()).propertyName());
-        }
+    public PubsubUnboundedSource getOverriddenTransform() {
+      return this.transform;
+    }
+
+    @Override
+    public PCollection<byte[]> expand(PBegin input) {
+      ByteArrayCoder coder = ByteArrayCoder.of();
+      return PCollection.createPrimitiveOutputInternal(
+              input.getPipeline(), WindowingStrategy.globalDefault(), IsBounded.UNBOUNDED, coder)
+          .setCoder(coder);
+    }
+
+    @Override
+    protected String getKindString() {
+      return "DataflowPubsubSourceRunnerV2";
+    }
+
+    static {
+      DataflowPipelineTranslator.registerTransformTranslator(
+          DataflowPubsubSourceRunnerV2.class, new DataflowPubsubSourceRunnerV2Translator());
+    }
+  }
+
+  public static class DataflowReadFromPubsubForRunnerV2
+      extends PTransform<PBegin, PCollection<PubsubMessage>> {
+
+    private final PubsubUnboundedSource transform;
+
+    public DataflowReadFromPubsubForRunnerV2(PubsubUnboundedSource transform) {
+      this.transform = transform;
+    }
+
+    @Override
+    public PCollection<PubsubMessage> expand(PBegin input) {
+      if (transform.getNeedsAttributes() || transform.getNeedsMessageId()) {
+        return input
+            .apply(
+                "DataflowReadFromPubsubRunnerV2", new DataflowPubsubSourceRunnerV2(this.transform))
+            .apply(
+                "MapBytesToPubsubMessages",
+                MapElements.into(TypeDescriptor.of(PubsubMessage.class))
+                    .via(new PubsubMessages.ParsePubsubMessageProtoAsPayload()));
       }
-      if (overriddenTransform.getTimestampAttribute() != null) {
+      return input.apply(new StreamingPubsubIORead(transform));
+    }
+  }
+
+  private static StepTranslationContext translateOverriddenPubsubSourceStep(
+      PTransform transform, TransformTranslator.TranslationContext translationContext) {
+    checkArgument(
+        translationContext.getPipelineOptions().isStreaming(),
+        "StreamingPubsubIORead is only for streaming pipelines.");
+    checkArgument(transform instanceof PubsubUnboundedSourceOverrider);
+    PubsubUnboundedSource overriddenTransform =
+        ((PubsubUnboundedSourceOverrider) transform).getOverriddenTransform();
+    StepTranslationContext stepContext = translationContext.addStep(transform, "ParallelRead");
+    stepContext.addInput(PropertyNames.FORMAT, "pubsub");
+    if (overriddenTransform.getTopicProvider() != null) {
+      if (overriddenTransform.getTopicProvider().isAccessible()) {
         stepContext.addInput(
-            PropertyNames.PUBSUB_TIMESTAMP_ATTRIBUTE, overriddenTransform.getTimestampAttribute());
-      }
-      if (overriddenTransform.getIdAttribute() != null) {
+            PropertyNames.PUBSUB_TOPIC, overriddenTransform.getTopic().getV1Beta1Path());
+      } else {
         stepContext.addInput(
-            PropertyNames.PUBSUB_ID_ATTRIBUTE, overriddenTransform.getIdAttribute());
+            PropertyNames.PUBSUB_TOPIC_OVERRIDE,
+            ((NestedValueProvider) overriddenTransform.getTopicProvider()).propertyName());
       }
-      // In both cases, the transform needs to read PubsubMessage. However, in case it needs
-      // the attributes or messageId, we supply an identity "parse fn" so the worker will
-      // read PubsubMessage's from Windmill and simply pass them around; and in case it
-      // doesn't need attributes, we're already implicitly using a "Coder" that interprets
-      // the data as a PubsubMessage's payload.
-      if (overriddenTransform.getNeedsAttributes() || overriddenTransform.getNeedsMessageId()) {
+    }
+    if (overriddenTransform.getSubscriptionProvider() != null) {
+      if (overriddenTransform.getSubscriptionProvider().isAccessible()) {
+        stepContext.addInput(
+            PropertyNames.PUBSUB_SUBSCRIPTION,
+            overriddenTransform.getSubscription().getV1Beta1Path());
+      } else {
         stepContext.addInput(
-            PropertyNames.PUBSUB_SERIALIZED_ATTRIBUTES_FN,
-            byteArrayToJsonString(serializeToByteArray(new IdentityMessageFn())));
+            PropertyNames.PUBSUB_SUBSCRIPTION_OVERRIDE,
+            ((NestedValueProvider) overriddenTransform.getSubscriptionProvider()).propertyName());
       }
+    }
+    if (overriddenTransform.getTimestampAttribute() != null) {
+      stepContext.addInput(
+          PropertyNames.PUBSUB_TIMESTAMP_ATTRIBUTE, overriddenTransform.getTimestampAttribute());
+    }
+    if (overriddenTransform.getIdAttribute() != null) {
+      stepContext.addInput(PropertyNames.PUBSUB_ID_ATTRIBUTE, overriddenTransform.getIdAttribute());
+    }
+    // In both cases, the transform needs to read PubsubMessage. However, in case it needs
+    // the attributes or messageId, we supply an identity "parse fn" so the worker will
+    // read PubsubMessage's from Windmill and simply pass them around; and in case it
+    // doesn't need attributes, we're already implicitly using a "Coder" that interprets
+    // the data as a PubsubMessage's payload.
+    if (overriddenTransform.getNeedsAttributes() || overriddenTransform.getNeedsMessageId()) {
+      stepContext.addInput(
+          PropertyNames.PUBSUB_SERIALIZED_ATTRIBUTES_FN,
+          byteArrayToJsonString(serializeToByteArray(new IdentityMessageFn())));
+    }
+    return stepContext;
+  }
+
+  /** Rewrite {@link StreamingPubsubIORead} to the appropriate internal node. */
+  private static class StreamingPubsubIOReadTranslator
+      implements TransformTranslator<StreamingPubsubIORead> {
+
+    @Override
+    public void translate(StreamingPubsubIORead transform, TranslationContext context) {
+      StepTranslationContext stepContext = translateOverriddenPubsubSourceStep(transform, context);
+      stepContext.addOutput(PropertyNames.OUTPUT, context.getOutput(transform));
+    }
+  }
+
+  private static class DataflowPubsubSourceRunnerV2Translator
+      implements TransformTranslator<DataflowPubsubSourceRunnerV2> {
+
+    @Override
+    public void translate(DataflowPubsubSourceRunnerV2 transform, TranslationContext context) {
+      StepTranslationContext stepContext = translateOverriddenPubsubSourceStep(transform, context);
       stepContext.addOutput(PropertyNames.OUTPUT, context.getOutput(transform));
     }
   }
@@ -1608,7 +1713,7 @@ public class DataflowRunner extends PipelineRunner<DataflowPipelineJob> {
       public void translate(DataflowRunnerV2PubsubSink transform, TranslationContext context) {
         checkArgument(
             context.getPipelineOptions().isStreaming(),
-            "StreamingPubsubIOWrite is only for streaming pipelines.");
+            "DataflowRunnerV2PubsubSink is only for streaming pipelines.");
         StepTranslationContext stepContext = context.addStep(transform, "ParallelWrite");
         StreamingPubsubSinkTranslators.translate(
             transform.getOverriddenTransform(), stepContext, context.getInput(transform));
