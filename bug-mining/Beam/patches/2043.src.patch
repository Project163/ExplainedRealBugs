diff --git a/model/fn-execution/src/main/resources/org/apache/beam/model/fnexecution/v1/standard_coders.yaml b/model/fn-execution/src/main/resources/org/apache/beam/model/fnexecution/v1/standard_coders.yaml
index 854e5bd210b..528ad73fbd1 100644
--- a/model/fn-execution/src/main/resources/org/apache/beam/model/fnexecution/v1/standard_coders.yaml
+++ b/model/fn-execution/src/main/resources/org/apache/beam/model/fnexecution/v1/standard_coders.yaml
@@ -407,9 +407,8 @@ coder:
 examples:
   "\x01\x00\x00\x00\x00\x00": {f_map: {}}
   "\x01\x00\x00\x00\x00\x02\x03foo\x01\xa9F\x03bar\x01\xff\xff\xff\xff\xff\xff\xff\xff\x7f": {f_map: {"foo": 9001, "bar": 9223372036854775807}}
-  "\x01\x00\x00\x00\x00\x04\neverything\x00\x02is\x00\x05null!\x00\r\xc2\xaf\\_(\xe3\x83\x84)_/\xc2\xaf\x00": {f_map: {"everything":null, "is": null, "null!": null, "¯\\_(ツ)_/¯": null}}
+  "\x01\x00\x00\x00\x00\x04\neverything\x00\x02is\x00\x05null!\x00\r\xc2\xaf\\_(\xe3\x83\x84)_/\xc2\xaf\x00": {f_map: {"everything": null, "is": null, "null!": null, "¯\\_(ツ)_/¯": null}}
 
----
 
 coder:
   urn: "beam:coder:row:v1"
@@ -417,3 +416,4 @@ coder:
   payload: "\n\x7f\n\x0bf_timestamp\x1ap:n\n#beam:logical_type:micros_instant:v1\x1aG2E\nC\n\r\n\x07seconds\x1a\x02\x10\x04\n\x0c\n\x06micros\x1a\x02\x10\x04\x12$4d3f6e8f-7412-4ad7-bfd9-b424a1664aef\n\x0e\n\x08f_string\x1a\x02\x10\x07\n\x0b\n\x05f_int\x1a\x02\x10\x04\x12$33dafd37-397c-4083-a84e-42177d122221"
 examples:
     "\x03\x00\x02\x00\xb6\x95\xd5\xf9\x05\xc0\xc4\x07\x1b2020-08-13T14:14:14.123456Z\xc0\xf7\x85\xda\xae\x98\xeb\x02": {f_timestamp: {seconds: 1597328054, micros: 123456}, f_string: "2020-08-13T14:14:14.123456Z", f_int: 1597328054123456}
+
diff --git a/sdks/go/gogradle.lock b/sdks/go/gogradle.lock
index a57228be689..42be24d659a 100644
--- a/sdks/go/gogradle.lock
+++ b/sdks/go/gogradle.lock
@@ -321,6 +321,13 @@ dependencies:
       vcs: "git"
     vendorPath: "vendor/github.com/kr/pty"
     transitive: false
+  - urls:
+    - "https://github.com/linkedin/goavro.git"
+    - "git@github.com:linkedin/goavro.git"
+    vcs: "git"
+    name: "github.com/linkedin/goavro"
+    commit: "94a7a9db615f35a39dd2b82089398b92fabad2ba"
+    transitive: false
   - urls:
     - "https://github.com/magiconair/properties.git"
     - "git@github.com:magiconair/properties.git"
@@ -646,15 +653,10 @@ dependencies:
     commit: "37707fdb30a5b38865cfb95e5aab41707daec7fd"
     url: "https://go.googlesource.com/sys"
     transitive: false
-  - name: "golang.org/x/text"
-    host:
-      name: "github.com/etcd-io/etcd"
-      commit: "11214aa33bf5a47d3d9d8dafe0f6b97237dfe921"
-      urls:
-      - "https://github.com/etcd-io/etcd.git"
-      - "git@github.com:etcd-io/etcd.git"
-      vcs: "git"
-    vendorPath: "vendor/golang.org/x/text"
+  - vcs: "git"
+    name: "golang.org/x/text"
+    commit: "23ae387dee1f90d29a23c0e87ee0b46038fbed0e"
+    url: "https://go.googlesource.com/text"
     transitive: false
   - name: "golang.org/x/time"
     host:
diff --git a/sdks/go/pkg/beam/core/graph/coder/coder.go b/sdks/go/pkg/beam/core/graph/coder/coder.go
index 1e37c23c657..61908b809cd 100644
--- a/sdks/go/pkg/beam/core/graph/coder/coder.go
+++ b/sdks/go/pkg/beam/core/graph/coder/coder.go
@@ -162,14 +162,21 @@ type Kind string
 // Tags for the various Beam encoding strategies. https://beam.apache.org/documentation/programming-guide/#coders
 // documents the usage of coders in the Beam environment.
 const (
-	Custom        Kind = "Custom" // Implicitly length-prefixed
-	Bytes         Kind = "bytes"  // Implicitly length-prefixed as part of the encoding
-	String        Kind = "string" // Implicitly length-prefixed as part of the encoding.
-	Bool          Kind = "bool"
-	VarInt        Kind = "varint"
-	Double        Kind = "double"
-	WindowedValue Kind = "W"
-	KV            Kind = "KV"
+	Custom             Kind = "Custom" // Implicitly length-prefixed
+	Bytes              Kind = "bytes"  // Implicitly length-prefixed as part of the encoding
+	String             Kind = "string" // Implicitly length-prefixed as part of the encoding.
+	Bool               Kind = "bool"
+	VarInt             Kind = "varint"
+	Double             Kind = "double"
+	Row                Kind = "R"
+	Timer              Kind = "T"
+	WindowedValue      Kind = "W"
+	ParamWindowedValue Kind = "PW"
+	Iterable           Kind = "I"
+	KV                 Kind = "KV"
+	LP                 Kind = "LP" // Explicitly length prefixed, likely at the runner's direction.
+
+	Window Kind = "window" // A debug wrapper around a window coder.
 
 	// CoGBK is currently equivalent to either
 	//
@@ -250,9 +257,9 @@ func (c *Coder) String() string {
 		ret += fmt.Sprintf("<%v>", strings.Join(args, ","))
 	}
 	switch c.Kind {
-	case WindowedValue:
+	case WindowedValue, ParamWindowedValue, Window, Timer:
 		ret += fmt.Sprintf("!%v", c.Window)
-	case KV, CoGBK, Bytes, Bool, VarInt, Double: // No additional info.
+	case KV, CoGBK, Bytes, Bool, VarInt, Double, String, LP: // No additional info.
 	default:
 		ret += fmt.Sprintf("[%v]", c.T)
 	}
@@ -307,6 +314,65 @@ func NewW(c *Coder, w *WindowCoder) *Coder {
 	}
 }
 
+// NewPW returns a ParamWindowedValue coder for the window of elements.
+func NewPW(c *Coder, w *WindowCoder) *Coder {
+	if c == nil {
+		panic("coder must not be nil")
+	}
+	if w == nil {
+		panic("window must not be nil")
+	}
+
+	return &Coder{
+		Kind:       ParamWindowedValue,
+		T:          typex.NewW(c.T),
+		Window:     w,
+		Components: []*Coder{c},
+	}
+}
+
+// NewT returns a timer coder for the window of elements.
+func NewT(c *Coder, w *WindowCoder) *Coder {
+	if c == nil {
+		panic("coder must not be nil")
+	}
+	if w == nil {
+		panic("window must not be nil")
+	}
+
+	// TODO(BEAM-10660): Implement proper timer support.
+	return &Coder{
+		Kind: Timer,
+		T: typex.New(reflect.TypeOf((*struct {
+			Key                          []byte // elm type.
+			Tag                          string
+			Windows                      []byte // []typex.Window
+			Clear                        bool
+			FireTimestamp, HoldTimestamp int64
+			Span                         int
+		})(nil)).Elem()),
+		Window:     w,
+		Components: []*Coder{c},
+	}
+}
+
+// NewI returns an iterable coder in the form of a slice.
+func NewI(c *Coder) *Coder {
+	if c == nil {
+		panic("coder must not be nil")
+	}
+	t := typex.New(reflect.SliceOf(c.T.Type()), c.T)
+	return &Coder{Kind: Iterable, T: t, Components: []*Coder{c}}
+}
+
+// NewR returns a schema row coder for the type.
+func NewR(t typex.FullType) *Coder {
+	return &Coder{
+		Kind: Row,
+		T:    t,
+	}
+}
+
 // IsKV returns true iff the coder is for key-value pairs.
 func IsKV(c *Coder) bool {
 	return c.Kind == KV
diff --git a/sdks/go/pkg/beam/core/graph/coder/coder_test.go b/sdks/go/pkg/beam/core/graph/coder/coder_test.go
index 5f7939b61b7..fe976d2e462 100644
--- a/sdks/go/pkg/beam/core/graph/coder/coder_test.go
+++ b/sdks/go/pkg/beam/core/graph/coder/coder_test.go
@@ -123,10 +123,16 @@ func TestValidDecoderForms(t *testing.T) {
 	}
 }
 
+type namedTypeForTest struct {
+	A, B int64
+	C    string
+}
+
 func TestCoder_String(t *testing.T) {
 	ints := NewVarInt()
 	bytes := NewBytes()
 	bools := NewBool()
+	doubles := NewDouble()
 	global := NewGlobalWindow()
 	interval := NewIntervalWindow()
 	cusString, err := NewCustomCoder("customString", reflectx.String, func(string) []byte { return nil }, func([]byte) string { return "" })
@@ -171,6 +177,21 @@ func TestCoder_String(t *testing.T) {
 	}, {
 		want: "CoGBK<bytes,varint,string[customString]>",
 		c:    NewCoGBK([]*Coder{bytes, ints, custom}),
+	}, {
+		want: "PW<bytes>!IWC",
+		c:    NewPW(bytes, interval),
+	}, {
+		want: "T<varint>!GWC",
+		c:    NewT(ints, global),
+	}, {
+		want: "I<double>[[]float64]",
+		c:    NewI(doubles),
+	}, {
+		want: "R[*coder.namedTypeForTest]",
+		c:    NewR(typex.New(reflect.TypeOf((*namedTypeForTest)(nil)))),
+	}, {
+		want: "window!GWC",
+		c:    &Coder{Kind: Window, Window: global},
 	},
 	}
 	for _, test := range tests {
diff --git a/sdks/go/pkg/beam/core/graph/coder/row.go b/sdks/go/pkg/beam/core/graph/coder/row.go
index 00b4c265da0..714e1500c1f 100644
--- a/sdks/go/pkg/beam/core/graph/coder/row.go
+++ b/sdks/go/pkg/beam/core/graph/coder/row.go
@@ -296,6 +296,7 @@ func containerEncoderForType(t reflect.Type) func(reflect.Value, io.Writer) erro
 }
 
 type typeEncoderReflect struct {
+	debug  []string
 	fields []func(reflect.Value, io.Writer) error
 }
 
@@ -303,6 +304,7 @@ type typeEncoderReflect struct {
 func encoderForStructReflect(t reflect.Type) func(reflect.Value, io.Writer) error {
 	var coder typeEncoderReflect
 	for i := 0; i < t.NumField(); i++ {
+		coder.debug = append(coder.debug, t.Field(i).Type.Name())
 		coder.fields = append(coder.fields, encoderForSingleTypeReflect(t.Field(i).Type))
 	}
 
@@ -320,7 +322,7 @@ func encoderForStructReflect(t reflect.Type) func(reflect.Value, io.Writer) erro
 				}
 			}
 			if err := f(rvf, w); err != nil {
-				return err
+				return errors.Wrapf(err, "encoding %v, expected: %v", rvf.Type(), coder.debug[i])
 			}
 		}
 		return nil
diff --git a/sdks/go/pkg/beam/core/graph/coder/windows.go b/sdks/go/pkg/beam/core/graph/coder/windows.go
index b05d2608392..c6fe15e3004 100644
--- a/sdks/go/pkg/beam/core/graph/coder/windows.go
+++ b/sdks/go/pkg/beam/core/graph/coder/windows.go
@@ -18,6 +18,8 @@ package coder
 // WindowKind represents a kind of window coder.
 type WindowKind string
 
+// Available window coders. The same coder could be used for
+// more than one kind of windowing strategy.
 const (
 	GlobalWindow   WindowKind = "GWC"
 	IntervalWindow WindowKind = "IWC"
@@ -25,11 +27,14 @@ const (
 
 // WindowCoder represents a Window coder.
 type WindowCoder struct {
-	Kind WindowKind
+	Kind    WindowKind
+	Payload string // Payload is only populated for parameterized window coders.
 }
 
+// Equals returns whether passed in WindowCoder has the same
+// Kind and Payload as this WindowCoder.
 func (w *WindowCoder) Equals(o *WindowCoder) bool {
-	return w.Kind == o.Kind
+	return w.Kind == o.Kind && w.Payload == o.Payload
 }
 
 func (w *WindowCoder) String() string {
diff --git a/sdks/go/pkg/beam/core/runtime/exec/coder.go b/sdks/go/pkg/beam/core/runtime/exec/coder.go
index 115ff528498..447d3ac0356 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/coder.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/coder.go
@@ -19,6 +19,7 @@ import (
 	"fmt"
 	"io"
 	"reflect"
+	"strings"
 
 	"bytes"
 
@@ -36,7 +37,7 @@ import (
 // we handle the top GBK/CoGBK layer in the processing node directly.
 
 // ElementEncoder handles FullValue serialization to a byte stream. The encoder
-// can be reused, even if an error is encountered. Concurrency-safe.
+// can be reused, even if an error is encountered.
 type ElementEncoder interface {
 	// Encode serializes the given value to the writer.
 	Encode(*FullValue, io.Writer) error
@@ -53,7 +54,7 @@ func EncodeElement(c ElementEncoder, val interface{}) ([]byte, error) {
 }
 
 // ElementDecoder handles FullValue deserialization from a byte stream. The decoder
-// can be reused, even if an error is encountered.  Concurrency-safe.
+// can be reused, even if an error is encountered.
 type ElementDecoder interface {
 	// Decode deserializes a value from the given reader.
 	Decode(io.Reader) (*FullValue, error)
@@ -61,8 +62,8 @@ type ElementDecoder interface {
 	DecodeTo(io.Reader, *FullValue) error
 }
 
-// MakeElementEncoder returns a ElementCoder for the given coder. It panics
-// if given a coder with stream types, such as GBK.
+// MakeElementEncoder returns a ElementCoder for the given coder.
+// It panics if given an unknown coder, or a coder with stream types, such as GBK.
 func MakeElementEncoder(c *coder.Coder) ElementEncoder {
 	switch c.Kind {
 	case coder.Bytes:
@@ -81,10 +82,34 @@ func MakeElementEncoder(c *coder.Coder) ElementEncoder {
 		return &stringEncoder{}
 
 	case coder.Custom:
-		return &customEncoder{
+		enc := &customEncoder{
 			t:   c.Custom.Type,
 			enc: makeEncoder(c.Custom.Enc.Fn),
 		}
+		if c.Custom.Name != "schema" {
+			return enc
+		}
+		// Custom schema coding uses the beam row coder, but wraps it in a
+		// length prefix and treats it as an opaque coder.
+
+		// Specialization to handle slice and array types.
+		switch c.T.Type().Kind() {
+		case reflect.Slice, reflect.Array:
+			// We don't permit registering custom coders for slice types
+			// so we must length prefix the entire iterable.
+			return &lpEncoder{
+				enc: &iterableEncoder{
+					t:   c.Custom.Type,
+					enc: enc,
+				},
+			}
+		}
+		return enc
+
+	case coder.LP:
+		return &lpEncoder{
+			enc: MakeElementEncoder(c.Components[0]),
+		}
 
 	case coder.KV:
 		return &kvEncoder{
@@ -92,13 +117,49 @@ func MakeElementEncoder(c *coder.Coder) ElementEncoder {
 			snd: MakeElementEncoder(c.Components[1]),
 		}
 
+	case coder.Window:
+		return &wrappedWindowEncoder{
+			enc: MakeWindowEncoder(c.Window),
+		}
+
+	case coder.Iterable:
+		return &iterableEncoder{
+			enc: MakeElementEncoder(c.Components[0]),
+		}
+
+	case coder.WindowedValue:
+		return &windowedValueEncoder{
+			elm: MakeElementEncoder(c.Components[0]),
+			win: MakeWindowEncoder(c.Window),
+		}
+
+	case coder.ParamWindowedValue:
+		return &paramWindowedValueEncoder{
+			elm: MakeElementEncoder(c.Components[0]),
+			win: MakeWindowEncoder(c.Window),
+		}
+
+	case coder.Timer:
+		return &timerEncoder{
+			elm: MakeElementEncoder(c.Components[0]),
+		}
+
+	case coder.Row:
+		enc, err := coder.RowEncoderForStruct(c.T.Type())
+		if err != nil {
+			panic(err)
+		}
+		return &rowEncoder{
+			enc: enc,
+		}
+
 	default:
 		panic(fmt.Sprintf("Unexpected coder: %v", c))
 	}
 }
 
-// MakeElementDecoder returns a ElementDecoder for the given coder. It panics
-// if given a coder with stream types, such as GBK.
+// MakeElementDecoder returns a ElementDecoder for the given coder.
+// It panics if given an unknown coder, or a coder with stream types, such as GBK.
 func MakeElementDecoder(c *coder.Coder) ElementDecoder {
 	switch c.Kind {
 	case coder.Bytes:
@@ -117,17 +178,89 @@ func MakeElementDecoder(c *coder.Coder) ElementDecoder {
 		return &stringDecoder{}
 
 	case coder.Custom:
-		return &customDecoder{
+		dec := &customDecoder{
 			t:   c.Custom.Type,
 			dec: makeDecoder(c.Custom.Dec.Fn),
 		}
 
+		if c.Custom.Name != "schema" {
+			return dec
+		}
+		// Custom schema coding uses the beam row coder, but wraps it in a
+		// length prefix and treats it as an opaque coder.
+
+		// Specialization to handle slice and array types.
+		switch c.T.Type().Kind() {
+		case reflect.Slice:
+			return &lpDecoder{
+				dec: &iterableDecoder{
+					t:   c.Custom.Type,
+					dec: dec,
+				},
+			}
+		case reflect.Array:
+			return &lpDecoder{
+				dec: &arrayDecoder{
+					t:   c.Custom.Type,
+					dec: dec,
+				},
+			}
+		}
+		return dec
+
+	case coder.LP:
+		return &lpDecoder{
+			dec: MakeElementDecoder(c.Components[0]),
+		}
+
 	case coder.KV:
 		return &kvDecoder{
 			fst: MakeElementDecoder(c.Components[0]),
 			snd: MakeElementDecoder(c.Components[1]),
 		}
 
+	// The following cases are not expected to be executed in the normal
+	// course of a pipeline, however including them here enables simpler
+	// end to end validation of standard coders against
+	// the standard_coders.yaml specs.
+	case coder.Window:
+		return &wrappedWindowDecoder{
+			dec: MakeWindowDecoder(c.Window),
+		}
+
+	// Note: Iterables in CoGBK are handled in datasource.go instead.
+	case coder.Iterable:
+		return &iterableDecoder{
+			t:   c.T.Type(),
+			dec: MakeElementDecoder(c.Components[0]),
+		}
+
+	case coder.WindowedValue:
+		return &windowedValueDecoder{
+			elm: MakeElementDecoder(c.Components[0]),
+			win: MakeWindowDecoder(c.Window),
+		}
+
+	case coder.ParamWindowedValue:
+		return &paramWindowedValueDecoder{
+			elm: MakeElementDecoder(c.Components[0]),
+			win: MakeWindowDecoder(c.Window),
+		}
+
+	case coder.Timer:
+		return &timerDecoder{
+			elm: MakeElementDecoder(c.Components[0]),
+		}
+
+	case coder.Row:
+		dec, err := coder.RowDecoderForStruct(c.T.Type())
+		if err != nil {
+			panic(err)
+		}
+		return &rowDecoder{
+			dec: dec,
+		}
+
 	default:
 		panic(fmt.Sprintf("Unexpected coder: %v", c))
 	}
@@ -142,25 +275,14 @@ func (*bytesEncoder) Encode(val *FullValue, w io.Writer) error {
 	if !ok {
 		return errors.Errorf("received unknown value type: want []byte, got %T", val.Elm)
 	}
-	size := len(data)
-
-	if err := coder.EncodeVarInt((int64)(size), w); err != nil {
-		return err
-	}
-	_, err := w.Write(data)
-	return err
+	return coder.EncodeBytes(data, w)
 }
 
 type bytesDecoder struct{}
 
 func (*bytesDecoder) DecodeTo(r io.Reader, fv *FullValue) error {
 	// Encoding: size (varint) + raw data
-
-	size, err := coder.DecodeVarInt(r)
-	if err != nil {
-		return err
-	}
-	data, err := ioutilx.ReadN(r, (int)(size))
+	data, err := coder.DecodeBytes(r)
 	if err != nil {
 		return err
 	}
@@ -361,6 +483,53 @@ func (c *customDecoder) Decode(r io.Reader) (*FullValue, error) {
 	return fv, nil
 }
 
+type lpEncoder struct {
+	enc ElementEncoder
+	buf bytes.Buffer
+}
+
+func (c *lpEncoder) Encode(val *FullValue, w io.Writer) error {
+	// (1) Call encode
+	if err := c.enc.Encode(val, &c.buf); err != nil {
+		return err
+	}
+
+	// (2) Add length prefix
+	data := c.buf.Bytes()
+	size := len(data)
+	if err := coder.EncodeVarInt((int64)(size), w); err != nil {
+		return err
+	}
+	_, err := w.Write(data)
+	c.buf.Reset()
+	return err
+}
+
+type lpDecoder struct {
+	dec ElementDecoder
+	r   io.LimitedReader
+}
+
+func (c *lpDecoder) DecodeTo(r io.Reader, fv *FullValue) error {
+	// (1) Read length-prefixed encoded data
+	size, err := coder.DecodeVarInt(r)
+	if err != nil {
+		return err
+	}
+	c.r = io.LimitedReader{R: r, N: size}
+
+	// (2) Call decode
+	return c.dec.DecodeTo(&c.r, fv)
+}
+
+func (c *lpDecoder) Decode(r io.Reader) (*FullValue, error) {
+	fv := &FullValue{}
+	if err := c.DecodeTo(r, fv); err != nil {
+		return nil, err
+	}
+	return fv, nil
+}
+
 type kvEncoder struct {
 	fst, snd ElementEncoder
 	cached   FullValue
@@ -434,6 +603,274 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {
 	return allocated
 }
 
+type iterableEncoder struct {
+	t   reflect.Type
+	enc ElementEncoder
+}
+
+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {
+	// Do a reflect, get the length.
+	rv := reflect.ValueOf(val.Elm)
+	size := rv.Len()
+	if err := coder.EncodeInt32((int32)(size), w); err != nil {
+		return err
+	}
+	var e FullValue
+	for i := 0; i < size; i++ {
+		e.Elm = rv.Index(i).Interface()
+		err := c.enc.Encode(&e, w)
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+type iterableDecoder struct {
+	t   reflect.Type
+	dec ElementDecoder
+}
+
+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {
+	// (1) Read count prefixed encoded data
+
+	size, err := coder.DecodeInt32(r)
+	if err != nil {
+		return err
+	}
+	n := int(size)
+	switch {
+	case n >= 0:
+		rv, err := c.decodeToSlice(n, r)
+		if err != nil {
+			return err
+		}
+		*fv = FullValue{Elm: rv.Interface()}
+		return nil
+	case n == -1:
+		rv := reflect.MakeSlice(c.t, 0, 0)
+		chunk, err := coder.DecodeVarInt(r)
+		if err != nil {
+			return err
+		}
+		for chunk != 0 {
+			rvi, err := c.decodeToSlice(int(chunk), r)
+			if err != nil {
+				return err
+			}
+			rv = reflect.AppendSlice(rv, rvi)
+			chunk, err = coder.DecodeVarInt(r)
+			if err != nil {
+				return err
+			}
+		}
+		*fv = FullValue{Elm: rv.Interface()}
+	}
+
+	return nil
+}
+
+func (c *iterableDecoder) decodeToSlice(n int, r io.Reader) (reflect.Value, error) {
+	var e FullValue
+	rv := reflect.MakeSlice(c.t, n, n)
+	for i := 0; i < n; i++ {
+		err := c.dec.DecodeTo(r, &e)
+		if err != nil {
+			return reflect.Value{}, err
+		}
+		if e.Elm != nil {
+			rv.Index(i).Set(reflect.ValueOf(e.Elm))
+		} else {
+			// Hack to support testing the standard window coders
+			// against standard_coders.yaml.
+			// It is not supported for BeamGo pipelines to treat windows
+			// as elements natively.
+			rv.Index(i).Set(reflect.ValueOf(e.Windows[0]))
+		}
+	}
+	return rv, nil
+}
+
+func (c *iterableDecoder) Decode(r io.Reader) (*FullValue, error) {
+	fv := &FullValue{}
+	if err := c.DecodeTo(r, fv); err != nil {
+		return nil, err
+	}
+	return fv, nil
+}
+
+// arrayDecoder reads the same format as iterableDecoder but
+// produces arrays instead of slices, taking the encoded length
+// as the length of the array.
+type arrayDecoder struct {
+	t   reflect.Type // array type
+	dec ElementDecoder
+}
+
+func (c *arrayDecoder) DecodeTo(r io.Reader, fv *FullValue) error {
+	// (1) Read count prefixed encoded data
+
+	size, err := coder.DecodeInt32(r)
+	if err != nil {
+		return err
+	}
+	n := int(size)
+	if n != c.t.Len() {
+		return errors.Errorf("array len mismatch. decoding %v but only have %v elements.", c.t, n)
+	}
+	switch {
+	case n >= 0:
+		rv := reflect.New(c.t).Elem()
+		var e FullValue
+		for i := 0; i < int(n); i++ {
+			err := c.dec.DecodeTo(r, &e)
+			if err != nil {
+				return err
+			}
+			if e.Elm != nil {
+				rv.Index(i).Set(reflect.ValueOf(e.Elm))
+			}
+		}
+		*fv = FullValue{Elm: rv.Interface()}
+		return nil
+	default:
+		return errors.Errorf("unable to decode array with iterable marker %v", n)
+	}
+}
+
+func (c *arrayDecoder) Decode(r io.Reader) (*FullValue, error) {
+	fv := &FullValue{}
+	if err := c.DecodeTo(r, fv); err != nil {
+		return nil, err
+	}
+	return fv, nil
+}
+
+type windowedValueEncoder struct {
+	elm ElementEncoder
+	win WindowEncoder
+}
+
+func (e *windowedValueEncoder) Encode(val *FullValue, w io.Writer) error {
+	if err := EncodeWindowedValueHeader(e.win, val.Windows, val.Timestamp, w); err != nil {
+		return err
+	}
+	return e.elm.Encode(val, w)
+}
+
+type windowedValueDecoder struct {
+	elm ElementDecoder
+	win WindowDecoder
+}
+
+func (d *windowedValueDecoder) DecodeTo(r io.Reader, fv *FullValue) error {
+	// Encoding: beam utf8 string (length prefix + run of bytes)
+	w, et, err := DecodeWindowedValueHeader(d.win, r)
+	if err != nil {
+		return err
+	}
+	if err := d.elm.DecodeTo(r, fv); err != nil {
+		return err
+	}
+	fv.Windows = w
+	fv.Timestamp = et
+	return nil
+}
+
+func (d *windowedValueDecoder) Decode(r io.Reader) (*FullValue, error) {
+	fv := &FullValue{}
+	if err := d.DecodeTo(r, fv); err != nil {
+		return nil, err
+	}
+	return fv, nil
+}
+
+type paramWindowedValueEncoder struct {
+	elm ElementEncoder
+	win WindowEncoder
+}
+
+func (*paramWindowedValueEncoder) Encode(val *FullValue, w io.Writer) error {
+	// Encoding: beam utf8 string (length prefix + run of bytes)
+	return coder.EncodeStringUTF8(val.Elm.(string), w)
+}
+
+type paramWindowedValueDecoder struct {
+	elm ElementDecoder
+	win WindowDecoder
+}
+
+func (*paramWindowedValueDecoder) DecodeTo(r io.Reader, fv *FullValue) error {
+	// Encoding: beam utf8 string (length prefix + run of bytes)
+	f, err := coder.DecodeStringUTF8(r)
+	if err != nil {
+		return err
+	}
+	*fv = FullValue{Elm: f}
+	return nil
+}
+
+func (d *paramWindowedValueDecoder) Decode(r io.Reader) (*FullValue, error) {
+	fv := &FullValue{}
+	if err := d.DecodeTo(r, fv); err != nil {
+		return nil, err
+	}
+	return fv, nil
+}
+
+type timerEncoder struct {
+	elm ElementEncoder
+}
+
+func (e *timerEncoder) Encode(val *FullValue, w io.Writer) error {
+	return e.elm.Encode(val, w)
+}
+
+type timerDecoder struct {
+	elm ElementDecoder
+}
+
+func (d *timerDecoder) DecodeTo(r io.Reader, fv *FullValue) error {
+	return d.elm.DecodeTo(r, fv)
+}
+
+func (d *timerDecoder) Decode(r io.Reader) (*FullValue, error) {
+	fv := &FullValue{}
+	if err := d.DecodeTo(r, fv); err != nil {
+		return nil, err
+	}
+	return fv, nil
+}
+
+type rowEncoder struct {
+	enc func(interface{}, io.Writer) error
+}
+
+func (e *rowEncoder) Encode(val *FullValue, w io.Writer) error {
+	return e.enc(val.Elm, w)
+}
+
+type rowDecoder struct {
+	dec func(r io.Reader) (interface{}, error)
+}
+
+func (d *rowDecoder) DecodeTo(r io.Reader, fv *FullValue) error {
+	v, err := d.dec(r)
+	if err != nil {
+		return err
+	}
+	*fv = FullValue{Elm: v}
+	return nil
+}
+
+func (d *rowDecoder) Decode(r io.Reader) (*FullValue, error) {
+	fv := &FullValue{}
+	if err := d.DecodeTo(r, fv); err != nil {
+		return nil, err
+	}
+	return fv, nil
+}
+
 // WindowEncoder handles Window serialization to a byte stream. The encoder
 // can be reused, even if an error is encountered. Concurrency-safe.
 type WindowEncoder interface {
@@ -457,10 +894,15 @@ func EncodeWindow(c WindowEncoder, w typex.Window) ([]byte, error) {
 type WindowDecoder interface {
 	// Decode deserializes a value from the given reader.
 	Decode(io.Reader) ([]typex.Window, error)
+	// DecodeSingle decodes a single window from the given reader.
+	DecodeSingle(io.Reader) (typex.Window, error)
 }
 
 // MakeWindowEncoder returns a WindowEncoder for the given window coder.
 func MakeWindowEncoder(c *coder.WindowCoder) WindowEncoder {
+	if c.Payload != "" {
+		return &payloadWindowEncoder{payload: []byte(c.Payload)}
+	}
 	switch c.Kind {
 	case coder.GlobalWindow:
 		return &globalWindowEncoder{}
@@ -475,16 +917,85 @@ func MakeWindowEncoder(c *coder.WindowCoder) WindowEncoder {
 
 // MakeWindowDecoder returns a WindowDecoder for the given window coder.
 func MakeWindowDecoder(c *coder.WindowCoder) WindowDecoder {
+	var w WindowDecoder
 	switch c.Kind {
 	case coder.GlobalWindow:
-		return &globalWindowDecoder{}
+		w = &globalWindowDecoder{}
 
 	case coder.IntervalWindow:
-		return &intervalWindowDecoder{}
+		w = &intervalWindowDecoder{}
 
 	default:
 		panic(fmt.Sprintf("Unexpected window coder: %v", c))
 	}
+	if c.Payload != "" {
+		w = &payloadWindowDecoder{dec: w, payload: c.Payload, payloadR: strings.NewReader(c.Payload)}
+	}
+	return w
+}
+
+// wrappedWindowEncoder wraps a WindowEncoder for the ElementEncoder interface.
+type wrappedWindowEncoder struct {
+	enc WindowEncoder
+}
+
+func (e *wrappedWindowEncoder) Encode(val *FullValue, w io.Writer) error {
+	if len(val.Windows) == 0 {
+		return nil
+	}
+	return e.enc.EncodeSingle(val.Windows[0], w)
+}
+
+// wrappedWindowDecoder wraps a WindowDecoder for the ElementDecoder interface.
+type wrappedWindowDecoder struct {
+	dec WindowDecoder
+}
+
+func (d *wrappedWindowDecoder) DecodeTo(r io.Reader, fv *FullValue) error {
+	ws, err := d.dec.DecodeSingle(r)
+	if err != nil {
+		return err
+	}
+	fv.Windows = []typex.Window{ws}
+	return nil
+}
+
+func (d *wrappedWindowDecoder) Decode(r io.Reader) (*FullValue, error) {
+	fv := &FullValue{}
+	if err := d.DecodeTo(r, fv); err != nil {
+		return nil, err
+	}
+	return fv, nil
+}
+
+type payloadWindowEncoder struct {
+	payload []byte
+}
+
+func (e *payloadWindowEncoder) Encode(ws []typex.Window, w io.Writer) error {
+	_, err := w.Write(e.payload)
+	return err
+}
+
+func (e *payloadWindowEncoder) EncodeSingle(ws typex.Window, w io.Writer) error {
+	_, err := w.Write(e.payload)
+	return err
+}
+
+type payloadWindowDecoder struct {
+	dec      WindowDecoder
+	payload  string
+	payloadR *strings.Reader
+}
+
+func (d *payloadWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {
+	d.payloadR.Reset(d.payload)
+	return d.dec.Decode(d.payloadR)
+}
+
+func (d *payloadWindowDecoder) DecodeSingle(r io.Reader) (typex.Window, error) {
+	d.payloadR.Reset(d.payload)
+	return d.dec.DecodeSingle(d.payloadR)
 }
 
 type globalWindowEncoder struct{}
@@ -504,6 +1015,9 @@ func (*globalWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {
 	_, err := coder.DecodeInt32(r) // #windows
 	return window.SingleGlobalWindow, err
 }
+func (*globalWindowDecoder) DecodeSingle(r io.Reader) (typex.Window, error) {
+	return window.SingleGlobalWindow[0], nil
+}
 
 type intervalWindowEncoder struct{}
 
@@ -534,26 +1048,34 @@ func (*intervalWindowEncoder) EncodeSingle(elm typex.Window, w io.Writer) error
 
 type intervalWindowDecoder struct{}
 
-func (*intervalWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {
+func (d *intervalWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {
 	// Encoding: upper bound and duration
 
 	n, err := coder.DecodeInt32(r) // #windows
 
 	ret := make([]typex.Window, n, n)
 	for i := int32(0); i < n; i++ {
-		end, err := coder.DecodeEventTime(r)
-		if err != nil {
-			return nil, err
-		}
-		duration, err := coder.DecodeVarUint64(r)
+		w, err := d.DecodeSingle(r)
 		if err != nil {
 			return nil, err
 		}
-		ret[i] = window.IntervalWindow{Start: mtime.FromMilliseconds(end.Milliseconds() - int64(duration)), End: end}
+		ret[i] = w
 	}
 	return ret, err
 }
 
+func (*intervalWindowDecoder) DecodeSingle(r io.Reader) (typex.Window, error) {
+	end, err := coder.DecodeEventTime(r)
+	if err != nil {
+		return nil, err
+	}
+	duration, err := coder.DecodeVarUint64(r)
+	if err != nil {
+		return nil, err
+	}
+	return window.IntervalWindow{Start: mtime.FromMilliseconds(end.Milliseconds() - int64(duration)), End: end}, nil
+}
+
 var paneNoFiring = []byte{0xf}
 
 // EncodeWindowedValueHeader serializes a windowed value header.
diff --git a/sdks/go/pkg/beam/core/runtime/exec/hash.go b/sdks/go/pkg/beam/core/runtime/exec/hash.go
index 3914ace6916..10bbeecd40a 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/hash.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/hash.go
@@ -45,6 +45,13 @@ func makeElementHasher(c *coder.Coder) elementHasher {
 	case coder.String:
 		return &stringHasher{hash: hasher}
 
+	case coder.Row:
+		enc := MakeElementEncoder(c)
+		return &rowHasher{
+			hash:  hasher,
+			coder: enc,
+		}
+
 	case coder.Custom:
 		// Shortcut for primitives where we know we can do better.
 		switch c.Custom.Type {
@@ -133,6 +140,22 @@ func (h *numberHasher) Hash(element interface{}) (uint64, error) {
 	return val, nil
 }
 
+type rowHasher struct {
+	hash  hash.Hash64
+	coder ElementEncoder
+	fv    FullValue
+}
+
+func (h *rowHasher) Hash(element interface{}) (uint64, error) {
+	h.hash.Reset()
+	h.fv.Elm = element
+	if err := h.coder.Encode(&h.fv, h.hash); err != nil {
+		return 0, err
+	}
+	h.fv.Elm = nil
+	return h.hash.Sum64(), nil
+}
+
 type customEncodedHasher struct {
 	hash  hash.Hash64
 	t     reflect.Type
diff --git a/sdks/go/pkg/beam/core/runtime/exec/hash_test.go b/sdks/go/pkg/beam/core/runtime/exec/hash_test.go
index babf7d7ec92..00852072edf 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/hash_test.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/hash_test.go
@@ -23,7 +23,9 @@ import (
 	"strings"
 	"testing"
 
+	"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/coderx"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/typex"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx"
 )
 
@@ -108,7 +110,8 @@ func BenchmarkPrimitives(b *testing.B) {
 			typ := reflect.TypeOf(test)
 			b.Run(fmt.Sprint(typ.String()), func(b *testing.B) {
 				encoded := &customEncodedHasher{hash: myHash, coder: &jsonEncoder{}}
-				hashbench(b, test, encoded, nil)
+				dedicated := &rowHasher{hash: myHash, coder: MakeElementEncoder(coder.NewR(typex.New(typ)))}
+				hashbench(b, test, encoded, dedicated)
 			})
 		}
 	})
diff --git a/sdks/go/pkg/beam/core/runtime/graphx/coder.go b/sdks/go/pkg/beam/core/runtime/graphx/coder.go
index e364f9f2cf4..c8be1d9183e 100644
--- a/sdks/go/pkg/beam/core/runtime/graphx/coder.go
+++ b/sdks/go/pkg/beam/core/runtime/graphx/coder.go
@@ -18,8 +18,10 @@ package graphx
 import (
 	"encoding/json"
 	"fmt"
+	"reflect"
 
 	"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx/schema"
 	v1pb "github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx/v1"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/typex"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/util/protox"
@@ -41,6 +43,9 @@ const (
 	urnIterableCoder            = "beam:coder:iterable:v1"
 	urnStateBackedIterableCoder = "beam:coder:state_backed_iterable:v1"
 	urnWindowedValueCoder       = "beam:coder:windowed_value:v1"
+	urnParamWindowedValueCoder  = "beam:coder:param_windowed_value:v1"
+	urnTimerCoder               = "beam:coder:timer:v1"
+	urnRowCoder                 = "beam:coder:row:v1"
 
 	urnGlobalWindow   = "beam:coder:global_window:v1"
 	urnIntervalWindow = "beam:coder:interval_window:v1"
@@ -65,6 +70,8 @@ func knownStandardCoders() []string {
 		urnWindowedValueCoder,
 		urnGlobalWindow,
 		urnIntervalWindow,
+		// TODO(BEAM-9615): Add urnRowCoder once finalized.
+		// TODO(BEAM-10660): Add urnTimerCoder once finalized.
 	}
 }
 
@@ -132,7 +139,7 @@ func (b *CoderUnmarshaller) Coder(id string) (*coder.Coder, error) {
 		return nil, errors.WithContextf(err, "unmarshalling coder %v", id)
 	}
 
-	ret, err := b.makeCoder(c)
+	ret, err := b.makeCoder(id, c)
 	if err != nil {
 		return nil, errors.WithContextf(err, "unmarshalling coder %v", id)
 	}
@@ -169,7 +176,7 @@ func urnToWindowCoder(urn string) *coder.WindowCoder {
 	}
 }
 
-func (b *CoderUnmarshaller) makeCoder(c *pipepb.Coder) (*coder.Coder, error) {
+func (b *CoderUnmarshaller) makeCoder(id string, c *pipepb.Coder) (*coder.Coder, error) {
 	urn := c.GetSpec().GetUrn()
 	components := c.GetComponentCoderIds()
 
@@ -249,31 +256,34 @@ func (b *CoderUnmarshaller) makeCoder(c *pipepb.Coder) (*coder.Coder, error) {
 			return nil, err
 		}
 
-		// No payload means this coder was length prefixed by the runner
-		// but is likely self describing - AKA a beam coder.
-		if len(sub.GetSpec().GetPayload()) == 0 {
-			return b.makeCoder(sub)
-		}
 		// TODO(lostluck) 2018/10/17: Make this strict again, once dataflow can use
 		// the portable pipeline model directly (BEAM-2885)
-		if sub.GetSpec().GetUrn() != "" && sub.GetSpec().GetUrn() != urnCustomCoder {
-			// TODO(herohde) 11/17/2017: revisit this restriction
-			return nil, errors.Errorf("could not unmarshal length prefix coder from %v, want a custom coder as a sub component but got %v", c, sub)
-		}
-
-		var ref v1pb.CustomCoder
-		if err := protox.DecodeBase64(string(sub.GetSpec().GetPayload()), &ref); err != nil {
-			return nil, err
-		}
-		custom, err := decodeCustomCoder(&ref)
-		if err != nil {
-			return nil, err
+		switch u := sub.GetSpec().GetUrn(); u {
+		case "", urnCustomCoder:
+			var ref v1pb.CustomCoder
+			if err := protox.DecodeBase64(string(sub.GetSpec().GetPayload()), &ref); err != nil {
+				return nil, err
+			}
+			custom, err := decodeCustomCoder(&ref)
+			if err != nil {
+				return nil, err
+			}
+			custom.ID = components[0]
+			t := typex.New(custom.Type)
+			cc := &coder.Coder{Kind: coder.Custom, T: t, Custom: custom}
+			return cc, nil
+		case urnBytesCoder, urnStringCoder: // implicitly length prefixed types.
+			return b.makeCoder(components[0], sub)
+		default:
+			// Handle Length prefixing dictated by the runner.
+			cc, err := b.makeCoder(components[0], sub)
+			if err != nil {
+				return nil, err
+			}
+			return &coder.Coder{Kind: coder.LP, T: cc.T, Components: []*coder.Coder{cc}}, nil
 		}
-		custom.ID = components[0]
-		t := typex.New(custom.Type)
-		return &coder.Coder{Kind: coder.Custom, T: t, Custom: custom}, nil
 
-	case urnWindowedValueCoder:
+	case urnWindowedValueCoder, urnParamWindowedValueCoder:
 		if len(components) != 2 {
 			return nil, errors.Errorf("could not unmarshal windowed value coder from %v, expected two components but got %d", c, len(components))
 		}
@@ -287,7 +297,13 @@ func (b *CoderUnmarshaller) makeCoder(c *pipepb.Coder) (*coder.Coder, error) {
 			return nil, err
 		}
 		t := typex.New(typex.WindowedValueType, elm.T)
-		return &coder.Coder{Kind: coder.WindowedValue, T: t, Components: []*coder.Coder{elm}, Window: w}, nil
+		wvc := &coder.Coder{Kind: coder.WindowedValue, T: t, Components: []*coder.Coder{elm}, Window: w}
+		if urn == urnWindowedValueCoder {
+			return wvc, nil
+		}
+		wvc.Kind = coder.ParamWindowedValue
+		wvc.Window.Payload = string(c.GetSpec().GetPayload())
+		return wvc, nil
 
 	case streamType:
 		return nil, errors.Errorf("could not unmarshal stream type coder from %v, stream must be pair value", c)
@@ -308,6 +324,57 @@ func (b *CoderUnmarshaller) makeCoder(c *pipepb.Coder) (*coder.Coder, error) {
 		}
 		return c, nil
 
+	case urnIterableCoder:
+		if len(components) != 1 {
+			return nil, errors.Errorf("could not unmarshal iterable coder from %v, expected one component but got %d", c, len(components))
+		}
+		elm, err := b.Coder(components[0])
+		if err != nil {
+			return nil, err
+		}
+		return coder.NewI(elm), nil
+	case urnTimerCoder:
+		if len(components) != 2 {
+			return nil, errors.Errorf("could not unmarshal timer coder from %v, expected two component but got %d", c, len(components))
+		}
+		elm, err := b.Coder(components[0])
+		if err != nil {
+			return nil, err
+		}
+		w, err := b.WindowCoder(components[1])
+		if err != nil {
+			return nil, err
+		}
+		return coder.NewT(elm, w), nil
+	case urnRowCoder:
+		var s pipepb.Schema
+		if err := proto.Unmarshal(c.GetSpec().GetPayload(), &s); err != nil {
+			return nil, err
+		}
+		t, err := schema.ToType(&s)
+		if err != nil {
+			return nil, err
+		}
+		return coder.NewR(typex.New(t)), nil
+
+	// Special handling for window coders so they can be treated as
+	// a general coder. Generally window coders are not used outside of
+	// specific contexts, but this enables improved testing.
+	// Window types are not permitted to be fulltypes, so
+	// we use assignably equivalent anonymous struct types.
+	case urnIntervalWindow:
+		w, err := b.WindowCoder(id)
+		if err != nil {
+			return nil, err
+		}
+		return &coder.Coder{Kind: coder.Window, T: typex.New(reflect.TypeOf((*struct{ Start, End int64 })(nil)).Elem()), Window: w}, nil
+	case urnGlobalWindow:
+		w, err := b.WindowCoder(id)
+		if err != nil {
+			return nil, err
+		}
+		return &coder.Coder{Kind: coder.Window, T: typex.New(reflect.TypeOf((*struct{})(nil)).Elem()), Window: w}, nil
+
 	default:
 		return nil, errors.Errorf("could not unmarshal coder from %v, unknown URN %v", c, urn)
 	}
@@ -417,8 +484,18 @@ func (b *CoderMarshaller) Add(c *coder.Coder) string {
 	case coder.String:
 		return b.internBuiltInCoder(urnStringCoder)
 
+	case coder.Row:
+		rt := c.T.Type()
+		s, err := schema.FromType(rt)
+		if err != nil {
+			panic(errors.SetTopLevelMsgf(err, "Failed to convert type %v to a schema.", rt))
+		}
+		return b.internRowCoder(s)
+
+	// TODO(BEAM-10660): Handle coder.Timer support.
+
 	default:
-		panic(fmt.Sprintf("Failed to marshal custom coder %v, unexpected coder kind: %v", c, c.Kind))
+		panic(fmt.Sprintf("Failed to marshal coder %v, unexpected coder kind: %v", c, c.Kind))
 	}
 }
 
@@ -458,6 +535,16 @@ func (b *CoderMarshaller) internBuiltInCoder(urn string, components ...string) s
 	})
 }
 
+func (b *CoderMarshaller) internRowCoder(schema *pipepb.Schema) string {
+	payload := protox.MustEncode(schema)
+	return b.internCoder(&pipepb.Coder{
+		Spec: &pipepb.FunctionSpec{
+			Urn:     urnRowCoder,
+			Payload: payload,
+		},
+	})
+}
+
 func (b *CoderMarshaller) internCoder(coder *pipepb.Coder) string {
 	key := proto.MarshalTextString(coder)
 	if id, exists := b.coder2id[key]; exists {
diff --git a/sdks/go/pkg/beam/core/runtime/graphx/coder_test.go b/sdks/go/pkg/beam/core/runtime/graphx/coder_test.go
index 4c577bb3b00..cb9dcff291d 100644
--- a/sdks/go/pkg/beam/core/runtime/graphx/coder_test.go
+++ b/sdks/go/pkg/beam/core/runtime/graphx/coder_test.go
@@ -22,6 +22,7 @@ import (
 	"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx/schema"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/typex"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx"
 )
@@ -31,6 +32,15 @@ func init() {
 	runtime.RegisterFunction(enc)
 }
 
+type registeredNamedTypeForTest struct {
+	A, B int64
+	C    string
+}
+
+func init() {
+	schema.RegisterType(reflect.TypeOf((*registeredNamedTypeForTest)(nil)))
+}
+
 // TestMarshalUnmarshalCoders verifies that coders survive a proto roundtrip.
 func TestMarshalUnmarshalCoders(t *testing.T) {
 	foo := custom("foo", reflectx.Bool)
@@ -89,6 +99,10 @@ func TestMarshalUnmarshalCoders(t *testing.T) {
 			"CoGBK<foo,bar,baz>",
 			coder.NewCoGBK([]*coder.Coder{foo, bar, baz}),
 		},
+		{
+			name: "R[*graphx.registeredNamedTypeForTest]",
+			c:    coder.NewR(typex.New(reflect.TypeOf((*registeredNamedTypeForTest)(nil)))),
+		},
 	}
 
 	for _, test := range tests {
diff --git a/sdks/go/pkg/beam/core/runtime/graphx/dataflow.go b/sdks/go/pkg/beam/core/runtime/graphx/dataflow.go
index cbc4febbffa..30079e8e146 100644
--- a/sdks/go/pkg/beam/core/runtime/graphx/dataflow.go
+++ b/sdks/go/pkg/beam/core/runtime/graphx/dataflow.go
@@ -17,10 +17,12 @@ package graphx
 
 import (
 	"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx/schema"
 	v1pb "github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx/v1"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/typex"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/util/protox"
 	"github.com/apache/beam/sdks/go/pkg/beam/internal/errors"
+	pipepb "github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1"
 )
 
 // TODO(herohde) 7/17/2018: move CoderRef to dataflowlib once Dataflow
@@ -47,6 +49,7 @@ const (
 	streamType        = "kind:stream"
 	pairType          = "kind:pair"
 	lengthPrefixType  = "kind:length_prefix"
+	rowType           = "kind:row"
 
 	globalWindowType   = "kind:global_window"
 	intervalWindowType = "kind:interval_window"
@@ -168,6 +171,20 @@ func EncodeCoderRef(c *coder.Coder) (*CoderRef, error) {
 			Components: []*CoderRef{{Type: stringType, PipelineProtoCoderID: c.ID}},
 		}, nil
 
+	case coder.Row:
+		schm, err := schema.FromType(c.T.Type())
+		if err != nil {
+			return nil, err
+		}
+		data, err := protox.EncodeBase64(schm)
+		if err != nil {
+			return nil, err
+		}
+		return &CoderRef{
+			Type:       rowType,
+			Components: []*CoderRef{{Type: data}},
+		}, nil
+
 	default:
 		return nil, errors.Errorf("bad coder kind: %v", c.Kind)
 	}
@@ -280,6 +297,18 @@ func DecodeCoderRef(c *CoderRef) (*coder.Coder, error) {
 	case streamType:
 		return nil, errors.Errorf("stream must be pair value: %+v", c)
 
+	case rowType:
+		subC := c.Components[0]
+		schm := &pipepb.Schema{}
+		if err := protox.DecodeBase64(subC.Type, schm); err != nil {
+			return nil, err
+		}
+		t, err := schema.ToType(schm)
+		if err != nil {
+			return nil, err
+		}
+		return &coder.Coder{Kind: coder.Row, T: typex.New(t)}, nil
+
 	default:
 		return nil, errors.Errorf("custom coders must be length prefixed: %+v", c)
 	}
diff --git a/sdks/go/test/regression/coders/fromyaml/fromyaml.go b/sdks/go/test/regression/coders/fromyaml/fromyaml.go
new file mode 100644
index 00000000000..c7d67d360f9
--- /dev/null
+++ b/sdks/go/test/regression/coders/fromyaml/fromyaml.go
@@ -0,0 +1,420 @@
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements.  See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// fromyaml generates a resource file from the standard_coders.yaml
+// file for use in these coder regression tests.
+//
+// It expects to be run in it's test directory, or via it's go test.
+package main
+
+import (
+	"bytes"
+	"fmt"
+	"io/ioutil"
+	"log"
+	"math"
+	"reflect"
+	"runtime/debug"
+	"strconv"
+	"strings"
+
+	"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx"
+	pipepb "github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1"
+	"github.com/google/go-cmp/cmp"
+	"golang.org/x/text/encoding/charmap"
+	yaml "gopkg.in/yaml.v2"
+)
+
+var unimplementedCoders = map[string]bool{
+	"beam:coder:param_windowed_value:v1": true,
+	"beam:coder:timer:v1":                true,
+}
+
+// Coder is a representation a serialized beam coder.
+type Coder struct {
+	Urn              string  `yaml:"urn,omitempty"`
+	Payload          string  `yaml:"payload,omitempty"`
+	Components       []Coder `yaml:"components,omitempty"`
+	NonDeterministic bool    `yaml:"non_deterministic,omitempty"`
+}
+
+type logger interface {
+	Errorf(string, ...interface{})
+	Logf(string, ...interface{})
+}
+
+// Spec is a set of conditions that a coder must pass.
+type Spec struct {
+	Coder    Coder         `yaml:"coder,omitempty"`
+	Nested   *bool         `yaml:"nested,omitempty"`
+	Examples yaml.MapSlice `yaml:"examples,omitempty"`
+	Log      logger
+
+	id       int // for generating coder ids.
+	coderPBs map[string]*pipepb.Coder
+}
+
+func (s *Spec) nextID() string {
+	ret := fmt.Sprintf("%d", s.id)
+	s.id++
+	return ret
+}
+
+func (s *Spec) testStandardCoder() (err error) {
+	if unimplementedCoders[s.Coder.Urn] {
+		log.Printf("skipping unimplemented coder urn: %v", s.Coder.Urn)
+		return nil
+	}
+	// TODO(BEAM-9615): Support Logical types, and produce a better error message.
+	if strings.Contains(s.Coder.Payload, "logical") {
+		log.Printf("skipping coder with logical type. Unsupported in the Go SDK for now. Payload: %v", s.Coder.Payload)
+		return nil
+	}
+	// Construct the coder proto equivalents.
+
+	// Only nested tests need to be run, since nestedness is a pre-portability
+	// concept.
+	// For legacy Java reasons, the row coder examples are all marked nested: false
+	// so we need to check that before skipping unnested tests.
+	if s.Coder.Urn != "beam:coder:row:v1" && s.Nested != nil && !*s.Nested {
+		log.Printf("skipping unnested coder spec: %v\n", s.Coder)
+		return nil
+	}
+
+	s.coderPBs = make(map[string]*pipepb.Coder)
+	id := s.parseCoder(s.Coder)
+	b := graphx.NewCoderUnmarshaller(s.coderPBs)
+	underTest, err := b.Coder(id)
+	if err != nil {
+		return fmt.Errorf("unable to create coder: %v", err)
+	}
+
+	defer func() {
+		if e := recover(); e != nil {
+			err = fmt.Errorf("panicked on coder %v || %v:\n\t%v :\n%s", underTest, s.Coder, e, debug.Stack())
+		}
+	}()
+
+	var decFails, encFails int
+	for _, eg := range s.Examples {
+
+		// Test Decoding
+		// Ideally we'd use the beam package coders, but KVs make that complicated.
+		// This can be cleaned up once a type parametered beam.KV type exists.
+		dec := exec.MakeElementDecoder(underTest)
+		encoded := eg.Key.(string)
+		var elem exec.FullValue
+
+		// What I would have expected.
+		//		r := charmap.ISO8859_1.NewDecoder().Reader(strings.NewReader(encoded))
+		recoded, err := charmap.ISO8859_1.NewEncoder().String(encoded)
+		if err != nil {
+			return err
+		}
+		r := strings.NewReader(recoded)
+		if err := dec.DecodeTo(r, &elem); err != nil {
+			return fmt.Errorf("err decoding %q: %v", encoded, err)
+		}
+		if !diff(s.Coder, &elem, eg) {
+			decFails++
+			continue
+		}
+
+		// Test Encoding
+		if s.Coder.NonDeterministic {
+			// Skip verifying nondeterministic encodings.
+			continue
+		}
+		enc := exec.MakeElementEncoder(underTest)
+		var out bytes.Buffer
+		if err := enc.Encode(&elem, &out); err != nil {
+			return err
+		}
+		if d := cmp.Diff(recoded, string(out.Bytes())); d != "" {
+			log.Printf("Encoding error: diff(-want,+got): %v\n", d)
+		}
+	}
+	if decFails+encFails > 0 {
+		return fmt.Errorf("failed to decode %v times, and encode %v times", decFails, encFails)
+	}
+
+	return nil
+}
+
+var cmpOpts = []cmp.Option{
+	cmp.Transformer("bytes2string", func(in []byte) (out string) {
+		return string(in)
+	}),
+}
+
+func diff(c Coder, elem *exec.FullValue, eg yaml.MapItem) bool {
+	var got, want interface{}
+	switch c.Urn {
+	case "beam:coder:bytes:v1":
+		got = string(elem.Elm.([]byte))
+		switch egv := eg.Value.(type) {
+		case string:
+			want = egv
+		case []byte:
+			want = string(egv)
+		}
+	case "beam:coder:varint:v1":
+		got, want = elem.Elm.(int64), int64(eg.Value.(int))
+	case "beam:coder:double:v1":
+		got = elem.Elm.(float64)
+		switch v := eg.Value.(string); v {
+		case "NaN":
+			// Do the NaN comparison here since NaN by definition != NaN.
+			if math.IsNaN(got.(float64)) {
+				want, got = 1, 1
+			} else {
+				want = math.NaN()
+			}
+		case "-Infinity":
+			want = math.Inf(-1)
+		case "Infinity":
+			want = math.Inf(1)
+		default:
+			want, _ = strconv.ParseFloat(v, 64)
+		}
+
+	case "beam:coder:kv:v1":
+		v := eg.Value.(yaml.MapSlice)
+		pass := true
+		if !diff(c.Components[0], &exec.FullValue{Elm: elem.Elm}, v[0]) {
+			pass = false
+		}
+		if !diff(c.Components[1], &exec.FullValue{Elm: elem.Elm2}, v[1]) {
+			pass = false
+		}
+		return pass
+
+	case "beam:coder:iterable:v1":
+		pass := true
+		gotrv := reflect.ValueOf(elem.Elm)
+		wantrv := reflect.ValueOf(eg.Value)
+		if gotrv.Len() != wantrv.Len() {
+			log.Printf("Lengths don't match. got %v, want %v;  %v, %v", gotrv.Len(), wantrv.Len(), gotrv, wantrv)
+			return false
+		}
+		for i := 0; i < wantrv.Len(); i++ {
+			if !diff(c.Components[0],
+				&exec.FullValue{Elm: gotrv.Index(i).Interface()},
+				yaml.MapItem{Value: wantrv.Index(i).Interface()}) {
+				pass = false
+			}
+
+		}
+		return pass
+	case "beam:coder:interval_window:v1":
+		var a, b int
+		val := eg.Value
+		if is, ok := eg.Value.([]interface{}); ok {
+			val = is[0]
+		}
+		v := val.(yaml.MapSlice)
+
+		a = v[0].Value.(int)
+		b = v[1].Value.(int)
+		end := mtime.FromMilliseconds(int64(a))
+		start := end - mtime.Time(int64(b))
+		want = window.IntervalWindow{Start: start, End: end}
+		// If this is nested in an iterable, windows won't be populated.
+		if len(elem.Windows) == 0 {
+			got = elem.Elm
+		} else {
+			got = elem.Windows[0]
+		}
+
+	case "beam:coder:global_window:v1":
+		want = window.GlobalWindow{}
+		// If this is nested in an iterable, windows won't be populated.
+		if len(elem.Windows) == 0 {
+			got = window.GlobalWindow(elem.Elm.(struct{}))
+		} else {
+			got = elem.Windows[0]
+		}
+	case "beam:coder:windowed_value:v1", "beam:coder:param_windowed_value:v1":
+		// elem contains all the information, but we need to compare the element+timestamp
+		// separately from the windows, to avoid repeated expected value parsing logic.
+		pass := true
+		vs := eg.Value.(yaml.MapSlice)
+		if !diff(c.Components[0], elem, vs[0]) {
+			pass = false
+		}
+		if d := cmp.Diff(
+			mtime.FromMilliseconds(int64(vs[1].Value.(int))),
+			elem.Timestamp, cmpOpts...); d != "" {
+
+			pass = false
+		}
+		if !diff(c.Components[1], elem, vs[3]) {
+			pass = false
+		}
+		// TODO compare pane information.
+		return pass
+	case "beam:coder:row:v1":
+		fs := eg.Value.(yaml.MapSlice)
+		var rfs []reflect.StructField
+		// There are only 2 pointer examples, but they reuse field names,
+		// so we key off the proto hash to know which example we're handling.
+		ptrEg := strings.Contains(c.Payload, "51ace21c7393")
+		for _, rf := range fs {
+			name := rf.Key.(string)
+			t := nameToType[name]
+			if ptrEg {
+				t = reflect.PtrTo(t)
+			}
+			rfs = append(rfs, reflect.StructField{
+				Name: strings.ToUpper(name[:1]) + name[1:],
+				Type: t,
+				Tag:  reflect.StructTag(fmt.Sprintf("beam:\"%v\"", name)),
+			})
+		}
+		rv := reflect.New(reflect.StructOf(rfs)).Elem()
+		for i, rf := range fs {
+			setField(rv, i, rf.Value)
+		}
+
+		got, want = elem.Elm, rv.Interface()
+	default:
+		got, want = elem.Elm, eg.Value
+	}
+	if d := cmp.Diff(want, got, cmpOpts...); d != "" {
+		log.Printf("Decoding error: diff(-want,+got): %v\n", d)
+		return false
+	}
+	return true
+}
+
+// standard_coders.yaml uses the name for type indication, except for nullability.
+var nameToType = map[string]reflect.Type{
+	"str":     reflectx.String,
+	"i32":     reflectx.Int32,
+	"f64":     reflectx.Float64,
+	"arr":     reflect.SliceOf(reflectx.String),
+	"f_bool":  reflectx.Bool,
+	"f_bytes": reflect.PtrTo(reflectx.ByteSlice),
+	"f_map":   reflect.MapOf(reflectx.String, reflect.PtrTo(reflectx.Int64)),
+}
+
+func setField(rv reflect.Value, i int, v interface{}) {
+	if v == nil {
+		return
+	}
+	rf := rv.Field(i)
+	if rf.Kind() == reflect.Ptr {
+		// Ensure it's initialized.
+		rf.Set(reflect.New(rf.Type().Elem()))
+		rf = rf.Elem()
+	}
+	switch rf.Kind() {
+	case reflect.String:
+		rf.SetString(v.(string))
+	case reflect.Int32:
+		rf.SetInt(int64(v.(int)))
+	case reflect.Float64:
+		c, err := strconv.ParseFloat(v.(string), 64)
+		if err != nil {
+			panic(err)
+		}
+		rf.SetFloat(c)
+	case reflect.Slice:
+		if rf.Type() == reflectx.ByteSlice {
+			rf.Set(reflect.ValueOf([]byte(v.(string))))
+			break
+		}
+		// Value is a []interface{} with string values.
+		var arr []string
+		for _, a := range v.([]interface{}) {
+			arr = append(arr, a.(string))
+		}
+		rf.Set(reflect.ValueOf(arr))
+	case reflect.Bool:
+		rf.SetBool(v.(bool))
+	case reflect.Map:
+		// only f_map presently, which is always map[string]*int64
+		rm := reflect.MakeMap(rf.Type())
+		for _, a := range v.(yaml.MapSlice) {
+			rk := reflect.ValueOf(a.Key.(string))
+			rv := reflect.Zero(rf.Type().Elem())
+			if a.Value != nil {
+				rv = reflect.New(reflectx.Int64)
+				rv.Elem().SetInt(int64(a.Value.(int)))
+			}
+			rm.SetMapIndex(rk, rv)
+		}
+		rf.Set(rm)
+
+	}
+}
+
+func (s *Spec) parseCoder(c Coder) string {
+	id := s.nextID()
+	var compIDs []string
+	for _, comp := range c.Components {
+		compIDs = append(compIDs, s.parseCoder(comp))
+	}
+	s.coderPBs[id] = &pipepb.Coder{
+		Spec: &pipepb.FunctionSpec{
+			Urn:     c.Urn,
+			Payload: []byte(c.Payload),
+		},
+		ComponentCoderIds: compIDs,
+	}
+	return id
+}
+
+// Simple logger to run as main program.
+type logLogger struct{}
+
+func (*logLogger) Errorf(format string, v ...interface{}) {
+	log.Printf(format, v...)
+}
+
+func (*logLogger) Logf(format string, v ...interface{}) {
+	log.Printf(format, v...)
+}
+
+const yamlPath = "../../../../../../model/fn-execution/src/main/resources/org/apache/beam/model/fnexecution/v1/standard_coders.yaml"
+
+func main() {
+	data, err := ioutil.ReadFile(yamlPath)
+	if err != nil {
+		log.Fatalf("Couldn't read %v: %v", yamlPath, err)
+	}
+	specs := bytes.Split(data, []byte("\n---\n"))
+	var failures bool
+	var l logLogger
+	for _, data := range specs {
+		cs := Spec{Log: &l}
+		if err := yaml.Unmarshal(data, &cs); err != nil {
+			failures = true
+			l.Logf("unable to parse yaml: %v %q", err, data)
+			continue
+		}
+		if err := cs.testStandardCoder(); err != nil {
+			failures = true
+			l.Logf("Failed \"%v\": %v", cs.Coder, err)
+		}
+	}
+	if !failures {
+		log.Println("PASS")
+	}
+}
diff --git a/sdks/go/test/regression/coders/fromyaml/fromyaml_test.go b/sdks/go/test/regression/coders/fromyaml/fromyaml_test.go
new file mode 100644
index 00000000000..c92261a4187
--- /dev/null
+++ b/sdks/go/test/regression/coders/fromyaml/fromyaml_test.go
@@ -0,0 +1,47 @@
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements.  See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"bytes"
+	"io/ioutil"
+	"log"
+	"testing"
+
+	yaml "gopkg.in/yaml.v2"
+)
+
+func TestStandardCoders(t *testing.T) {
+	data, err := ioutil.ReadFile(yamlPath)
+	if err != nil {
+		log.Fatalf("Couldn't read %v: %v", yamlPath, err)
+	}
+	specs := bytes.Split(data, []byte("\n---\n"))
+	var l logLogger
+	for _, data := range specs {
+		cs := Spec{Log: t}
+		if err := yaml.Unmarshal(data, &cs); err != nil {
+			l.Logf("unable to parse yaml: %v %q", err, data)
+			continue
+		}
+		t.Run(cs.Coder.Urn, func(t *testing.T) {
+			if err := cs.testStandardCoder(); err != nil {
+				t.Errorf("Failed \"%v\": %v", cs.Coder, err)
+			}
+		})
+	}
+
+}
