diff --git a/sdks/python/apache_beam/coders/coder_impl.pxd b/sdks/python/apache_beam/coders/coder_impl.pxd
index 66590789b32..fd04dc74350 100644
--- a/sdks/python/apache_beam/coders/coder_impl.pxd
+++ b/sdks/python/apache_beam/coders/coder_impl.pxd
@@ -81,11 +81,13 @@ cdef set _ITERABLE_LIKE_TYPES
 cdef class FastPrimitivesCoderImpl(StreamCoderImpl):
   cdef CoderImpl fallback_coder_impl
   cdef CoderImpl iterable_coder_impl
+  cdef object requires_deterministic
   @cython.locals(dict_value=dict, int_value=libc.stdint.int64_t,
                  unicode_value=unicode)
   cpdef encode_to_stream(self, value, OutputStream stream, bint nested)
   @cython.locals(t=int)
   cpdef decode_from_stream(self, InputStream stream, bint nested)
+  cdef _encode_special_deterministic(self, value, OutputStream stream)
 
 
 cdef class BytesCoderImpl(CoderImpl):
diff --git a/sdks/python/apache_beam/coders/coder_impl.py b/sdks/python/apache_beam/coders/coder_impl.py
index f262f1f3c52..3a4753d8120 100644
--- a/sdks/python/apache_beam/coders/coder_impl.py
+++ b/sdks/python/apache_beam/coders/coder_impl.py
@@ -49,11 +49,16 @@ from typing import Set
 from typing import Tuple
 from typing import Type
 
+try:
+  import dataclasses
+except ImportError:
+  dataclasses = None
+
+import dill
 from fastavro import parse_schema
 from fastavro import schemaless_reader
 from fastavro import schemaless_writer
-from past.builtins import unicode as past_unicode
-from past.builtins import long
+from google.protobuf.message import Message
 
 from apache_beam.coders import observable
 from apache_beam.coders.avro_record import AvroRecord
@@ -281,52 +286,6 @@ class CallbackCoderImpl(CoderImpl):
         self._encoder, self._decoder)
 
 
-class DeterministicFastPrimitivesCoderImpl(CoderImpl):
-  """For internal use only; no backwards-compatibility guarantees."""
-  def __init__(self, coder, step_label):
-    self._underlying_coder = coder
-    self._step_label = step_label
-
-  def _check_safe(self, value):
-    if isinstance(value, (bytes, past_unicode, long, int, float, bool)):
-      pass
-    elif value is None:
-      pass
-    elif isinstance(value, (tuple, list)):
-      for x in value:
-        self._check_safe(x)
-    else:
-      raise TypeError(
-          "Unable to deterministically encode '%s' of type '%s', "
-          "please provide a type hint for the input of '%s'" %
-          (value, type(value), self._step_label))
-
-  def encode_to_stream(self, value, stream, nested):
-    # type: (Any, create_OutputStream, bool) -> None
-    self._check_safe(value)
-    return self._underlying_coder.encode_to_stream(value, stream, nested)
-
-  def decode_from_stream(self, stream, nested):
-    # type: (create_InputStream, bool) -> Any
-    return self._underlying_coder.decode_from_stream(stream, nested)
-
-  def encode(self, value):
-    self._check_safe(value)
-    return self._underlying_coder.encode(value)
-
-  def decode(self, encoded):
-    return self._underlying_coder.decode(encoded)
-
-  def estimate_size(self, value, nested=False):
-    # type: (Any, bool) -> int
-    return self._underlying_coder.estimate_size(value, nested)
-
-  def get_estimated_size_and_observables(self, value, nested=False):
-    # type: (Any, bool) -> Tuple[int, Observables]
-    return self._underlying_coder.get_estimated_size_and_observables(
-        value, nested)
-
-
 class ProtoCoderImpl(SimpleCoderImpl):
   """For internal use only; no backwards-compatibility guarantees."""
   def __init__(self, proto_message_type):
@@ -360,6 +319,9 @@ DICT_TYPE = 7
 SET_TYPE = 8
 ITERABLE_LIKE_TYPE = 10
 
+PROTO_TYPE = 100
+DATACLASS_TYPE = 101
+
 # Types that can be encoded as iterables, but are not literally
 # lists, etc. due to being lazy.  The actual type is not preserved
 # through encoding, only the elements. This is particularly useful
@@ -369,9 +331,10 @@ _ITERABLE_LIKE_TYPES = set()  # type: Set[Type]
 
 class FastPrimitivesCoderImpl(StreamCoderImpl):
   """For internal use only; no backwards-compatibility guarantees."""
-  def __init__(self, fallback_coder_impl):
+  def __init__(self, fallback_coder_impl, requires_deterministic=None):
     self.fallback_coder_impl = fallback_coder_impl
     self.iterable_coder_impl = IterableCoderImpl(self)
+    self.requires_deterministic = requires_deterministic
 
   @staticmethod
   def register_iterable_like_type(t):
@@ -415,16 +378,25 @@ class FastPrimitivesCoderImpl(StreamCoderImpl):
     elif t is bytes:
       stream.write_byte(BYTES_TYPE)
       stream.write(value, nested)
-    elif t is past_unicode:
+    elif t is str:
       unicode_value = value  # for typing
       stream.write_byte(UNICODE_TYPE)
       stream.write(unicode_value.encode('utf-8'), nested)
-    elif t is list or t is tuple or t is set:
-      stream.write_byte(
-          LIST_TYPE if t is list else TUPLE_TYPE if t is tuple else SET_TYPE)
+    elif t is list or t is tuple:
+      stream.write_byte(LIST_TYPE if t is list else TUPLE_TYPE)
       stream.write_var_int64(len(value))
       for e in value:
         self.encode_to_stream(e, stream, True)
+    elif t is bool:
+      stream.write_byte(BOOL_TYPE)
+      stream.write_byte(value)
+    elif t in _ITERABLE_LIKE_TYPES:
+      stream.write_byte(ITERABLE_LIKE_TYPE)
+      self.iterable_coder_impl.encode_to_stream(value, stream, nested)
+    # All deterministic encodings should be above this clause,
+    # all non-deterministic ones below.
+    elif self.requires_deterministic is not None:
+      self._encode_special_deterministic(value, stream)
     elif t is dict:
       dict_value = value  # for typing
       stream.write_byte(DICT_TYPE)
@@ -432,16 +404,38 @@ class FastPrimitivesCoderImpl(StreamCoderImpl):
       for k, v in dict_value.items():
         self.encode_to_stream(k, stream, True)
         self.encode_to_stream(v, stream, True)
-    elif t is bool:
-      stream.write_byte(BOOL_TYPE)
-      stream.write_byte(value)
-    elif t in _ITERABLE_LIKE_TYPES:
-      stream.write_byte(ITERABLE_LIKE_TYPE)
-      self.iterable_coder_impl.encode_to_stream(value, stream, nested)
+    elif t is set:
+      stream.write_byte(SET_TYPE)
+      stream.write_var_int64(len(value))
+      for e in value:
+        self.encode_to_stream(e, stream, True)
     else:
       stream.write_byte(UNKNOWN_TYPE)
       self.fallback_coder_impl.encode_to_stream(value, stream, nested)
 
+  def _encode_special_deterministic(self, value, stream):
+    if isinstance(value, Message):
+      stream.write_byte(PROTO_TYPE)
+      stream.write(dill.dumps(type(value)), True)
+      stream.write(value.SerializePartialToString(deterministic=True), True)
+    elif dataclasses and dataclasses.is_dataclass(value):
+      stream.write_byte(DATACLASS_TYPE)
+      if not type(value).__dataclass_params__.frozen:
+        raise TypeError(
+            "Unable to deterministically encode non-frozen '%s' of type '%s' "
+            "for the input of '%s'" %
+            (value, type(value), self.requires_deterministic))
+      stream.write(dill.dumps(type(value)), True)
+      self.iterable_coder_impl.encode_to_stream(
+          (getattr(value, field.name) for field in dataclasses.fields(value)),
+          stream,
+          True)
+    else:
+      raise TypeError(
+          "Unable to deterministically encode '%s' of type '%s', "
+          "please provide a type hint for the input of '%s'" %
+          (value, type(value), self.requires_deterministic))
+
   def decode_from_stream(self, stream, nested):
     # type: (create_InputStream, bool) -> Any
     t = stream.read_byte()
@@ -474,6 +468,14 @@ class FastPrimitivesCoderImpl(StreamCoderImpl):
       return not not stream.read_byte()
     elif t == ITERABLE_LIKE_TYPE:
       return self.iterable_coder_impl.decode_from_stream(stream, nested)
+    elif t == PROTO_TYPE:
+      cls = dill.loads(stream.read_all(True))
+      msg = cls()
+      msg.ParseFromString(stream.read_all(True))
+      return msg
+    elif t == DATACLASS_TYPE:
+      cls = dill.loads(stream.read_all(True))
+      return cls(*self.iterable_coder_impl.decode_from_stream(stream, True))
     elif t == UNKNOWN_TYPE:
       return self.fallback_coder_impl.decode_from_stream(stream, nested)
     else:
@@ -773,7 +775,7 @@ small_ints = [chr(_).encode('latin-1') for _ in range(128)]
 class VarIntCoderImpl(StreamCoderImpl):
   """For internal use only; no backwards-compatibility guarantees.
 
-  A coder for long/int objects."""
+  A coder for int objects."""
   def encode_to_stream(self, value, out, nested):
     # type: (int, create_OutputStream, bool) -> None
     out.write_var_int64(value)
diff --git a/sdks/python/apache_beam/coders/coders.py b/sdks/python/apache_beam/coders/coders.py
index e5c6f6185a6..8dd2029b2b3 100644
--- a/sdks/python/apache_beam/coders/coders.py
+++ b/sdks/python/apache_beam/coders/coders.py
@@ -752,7 +752,7 @@ class PickleCoder(_PickleCoderBase):
         lambda x: dumps(x, protocol), pickle.loads)
 
   def as_deterministic_coder(self, step_label, error_message=None):
-    return DeterministicFastPrimitivesCoder(self, step_label)
+    return FastPrimitivesCoder(self, requires_deterministic=step_label)
 
   def to_type_hint(self):
     return Any
@@ -771,8 +771,9 @@ class DeterministicFastPrimitivesCoder(FastCoder):
     self._step_label = step_label
 
   def _create_impl(self):
-    return coder_impl.DeterministicFastPrimitivesCoderImpl(
-        self._underlying_coder.get_impl(), self._step_label)
+    return coder_impl.FastPrimitivesCoderImpl(
+        self._underlying_coder.get_impl(),
+        requires_deterministic=self._step_label)
 
   def is_deterministic(self):
     # type: () -> bool
diff --git a/sdks/python/apache_beam/coders/coders_test_common.py b/sdks/python/apache_beam/coders/coders_test_common.py
index 55fcda0a3f2..537d345d588 100644
--- a/sdks/python/apache_beam/coders/coders_test_common.py
+++ b/sdks/python/apache_beam/coders/coders_test_common.py
@@ -25,6 +25,11 @@ from builtins import range
 from typing import Any
 from typing import List
 
+try:
+  import dataclasses
+except ImportError:
+  dataclasses = None
+
 import pytest
 
 from apache_beam.coders import proto2_coder_test_messages_pb2 as test_message
@@ -54,6 +59,19 @@ class CustomCoder(coders.Coder):
     return int(encoded) - 1
 
 
+if dataclasses is not None:
+
+  @dataclasses.dataclass(frozen=True)
+  class FrozenDataClass:
+    a: Any
+    b: int
+
+  @dataclasses.dataclass
+  class UnFrozenDataClass:
+    x: int
+    y: int
+
+
 # These tests need to all be run in the same process due to the asserts
 # in tearDownClass.
 @pytest.mark.no_xdist
@@ -176,6 +194,17 @@ class CodersTest(unittest.TestCase):
         coders.TupleCoder((deterministic_coder, coder)), (1, dict()),
         ('a', [dict()]))
 
+    self.check_coder(deterministic_coder, test_message.MessageA(field1='value'))
+
+    if dataclasses is not None:
+      self.check_coder(deterministic_coder, FrozenDataClass(1, 2))
+
+      with self.assertRaises(TypeError):
+        self.check_coder(deterministic_coder, UnFrozenDataClass(1, 2))
+      with self.assertRaises(TypeError):
+        self.check_coder(
+            deterministic_coder, FrozenDataClass(UnFrozenDataClass(1, 2), 3))
+
   def test_dill_coder(self):
     cell_value = (lambda x: lambda: x)(0).__closure__[0]
     self.check_coder(coders.DillCoder(), 'a', 1, cell_value)
