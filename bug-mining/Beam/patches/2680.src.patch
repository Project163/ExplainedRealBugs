diff --git a/CHANGES.md b/CHANGES.md
index 138949f45a6..037d0422726 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -78,6 +78,7 @@
 ## Bugfixes
 
 * Fixed X (Java/Python) ([BEAM-X](https://issues.apache.org/jira/browse/BEAM-X)).
+* Properly check output timestamps on elements output from DoFns, timers, and onWindowExpiration in Java [BEAM-12931](https://issues.apache.org/jira/browse/BEAM-12931).
 
 ## Known Issues
 
diff --git a/runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java b/runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java
index 320faca1496..c71f174cd8d 100644
--- a/runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java
+++ b/runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java
@@ -435,19 +435,23 @@ public class SimpleDoFnRunner<InputT, OutputT> implements DoFnRunner<InputT, Out
 
     @SuppressWarnings("deprecation") // Allowed Skew is deprecated for users, but must be respected
     private void checkTimestamp(Instant timestamp) {
-      // The documentation of getAllowedTimestampSkew explicitly permits Long.MAX_VALUE to be used
-      // for infinite skew. Defend against underflow in that case for timestamps before the epoch
-      if (fn.getAllowedTimestampSkew().getMillis() != Long.MAX_VALUE
-          && timestamp.isBefore(elem.getTimestamp().minus(fn.getAllowedTimestampSkew()))) {
+      Instant lowerBound;
+      try {
+        lowerBound = elem.getTimestamp().minus(fn.getAllowedTimestampSkew());
+      } catch (ArithmeticException e) {
+        lowerBound = BoundedWindow.TIMESTAMP_MIN_VALUE;
+      }
+      if (timestamp.isBefore(lowerBound) || timestamp.isAfter(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
         throw new IllegalArgumentException(
             String.format(
                 "Cannot output with timestamp %s. Output timestamps must be no earlier than the "
-                    + "timestamp of the current input (%s) minus the allowed skew (%s). See the "
-                    + "DoFn#getAllowedTimestampSkew() Javadoc for details on changing the allowed "
-                    + "skew.",
+                    + "timestamp of the current input (%s) minus the allowed skew (%s) and no "
+                    + "later than %s. See the DoFn#getAllowedTimestampSkew() Javadoc for details "
+                    + "on changing the allowed skew.",
                 timestamp,
                 elem.getTimestamp(),
-                PeriodFormat.getDefault().print(fn.getAllowedTimestampSkew().toPeriod())));
+                PeriodFormat.getDefault().print(fn.getAllowedTimestampSkew().toPeriod()),
+                BoundedWindow.TIMESTAMP_MAX_VALUE));
       }
     }
 
@@ -845,6 +849,7 @@ public class SimpleDoFnRunner<InputT, OutputT> implements DoFnRunner<InputT, Out
 
     @Override
     public void outputWithTimestamp(OutputT output, Instant timestamp) {
+      checkTimestamp(timestamp);
       outputWithTimestamp(mainOutputTag, output, timestamp);
     }
 
@@ -855,6 +860,7 @@ public class SimpleDoFnRunner<InputT, OutputT> implements DoFnRunner<InputT, Out
 
     @Override
     public <T> void outputWithTimestamp(TupleTag<T> tag, T output, Instant timestamp) {
+      checkTimestamp(timestamp);
       outputWindowedValue(tag, WindowedValue.of(output, timestamp, window(), PaneInfo.NO_FIRING));
     }
 
@@ -863,6 +869,28 @@ public class SimpleDoFnRunner<InputT, OutputT> implements DoFnRunner<InputT, Out
       throw new UnsupportedOperationException(
           "Bundle finalization is not supported in non-portable pipelines.");
     }
+
+    @SuppressWarnings("deprecation") // Allowed Skew is deprecated for users, but must be respected
+    private void checkTimestamp(Instant timestamp) {
+      Instant lowerBound;
+      try {
+        lowerBound = timestamp().minus(fn.getAllowedTimestampSkew());
+      } catch (ArithmeticException e) {
+        lowerBound = BoundedWindow.TIMESTAMP_MIN_VALUE;
+      }
+      if (timestamp.isBefore(lowerBound) || timestamp.isAfter(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
+        throw new IllegalArgumentException(
+            String.format(
+                "Cannot output with timestamp %s. Output timestamps must be no earlier than the "
+                    + "output timestamp of the timer (%s) minus the allowed skew (%s) and no "
+                    + "later than %s. See the DoFn#getAllowedTimestampSkew() Javadoc for details "
+                    + "on changing the allowed skew.",
+                timestamp,
+                timestamp(),
+                PeriodFormat.getDefault().print(fn.getAllowedTimestampSkew().toPeriod()),
+                BoundedWindow.TIMESTAMP_MAX_VALUE));
+      }
+    }
   }
 
   /**
@@ -1059,6 +1087,7 @@ public class SimpleDoFnRunner<InputT, OutputT> implements DoFnRunner<InputT, Out
 
     @Override
     public <T> void outputWithTimestamp(TupleTag<T> tag, T output, Instant timestamp) {
+      checkTimestamp(timestamp);
       outputWindowedValue(tag, WindowedValue.of(output, timestamp, window(), PaneInfo.NO_FIRING));
     }
 
@@ -1067,6 +1096,28 @@ public class SimpleDoFnRunner<InputT, OutputT> implements DoFnRunner<InputT, Out
       throw new UnsupportedOperationException(
           "Bundle finalization is not supported in non-portable pipelines.");
     }
+
+    @SuppressWarnings("deprecation") // Allowed Skew is deprecated for users, but must be respected
+    private void checkTimestamp(Instant timestamp) {
+      Instant lowerBound;
+      try {
+        lowerBound = this.timestamp.minus(fn.getAllowedTimestampSkew());
+      } catch (ArithmeticException e) {
+        lowerBound = BoundedWindow.TIMESTAMP_MIN_VALUE;
+      }
+      if (timestamp.isBefore(lowerBound) || timestamp.isAfter(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
+        throw new IllegalArgumentException(
+            String.format(
+                "Cannot output with timestamp %s. Output timestamps must be no earlier than the "
+                    + "output timestamp of the window (%s) minus the allowed skew (%s) and no "
+                    + "later than %s. See the DoFn#getAllowedTimestampSkew() Javadoc for details "
+                    + "on changing the allowed skew.",
+                timestamp,
+                this.timestamp,
+                PeriodFormat.getDefault().print(fn.getAllowedTimestampSkew().toPeriod()),
+                BoundedWindow.TIMESTAMP_MAX_VALUE));
+      }
+    }
   }
 
   private class TimerInternalsTimer implements Timer {
@@ -1191,11 +1242,26 @@ public class SimpleDoFnRunner<InputT, OutputT> implements DoFnRunner<InputT, Out
     private void setAndVerifyOutputTimestamp() {
 
       if (outputTimestamp != null) {
-        checkArgument(
-            !outputTimestamp.isBefore(elementInputTimestamp),
-            "output timestamp %s should be after input message timestamp or output timestamp of firing timers %s",
-            outputTimestamp,
-            elementInputTimestamp);
+        Instant lowerBound;
+        try {
+          lowerBound = elementInputTimestamp.minus(fn.getAllowedTimestampSkew());
+        } catch (ArithmeticException e) {
+          lowerBound = BoundedWindow.TIMESTAMP_MIN_VALUE;
+        }
+        if (outputTimestamp.isBefore(lowerBound)
+            || outputTimestamp.isAfter(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
+          throw new IllegalArgumentException(
+              String.format(
+                  "Cannot output timer with output timestamp %s. Output timestamps must be no "
+                      + "earlier than the timestamp of the current input or timer (%s) minus the "
+                      + "allowed skew (%s) and no later than %s. See the "
+                      + "DoFn#getAllowedTimestampSkew() Javadoc for details on changing the "
+                      + "allowed skew.details on changing the allowed skew.",
+                  outputTimestamp,
+                  elementInputTimestamp,
+                  PeriodFormat.getDefault().print(fn.getAllowedTimestampSkew().toPeriod()),
+                  BoundedWindow.TIMESTAMP_MAX_VALUE));
+        }
       }
 
       // Output timestamp is set to the delivery time if not initialized by an user.
diff --git a/runners/core-java/src/test/java/org/apache/beam/runners/core/SimpleDoFnRunnerTest.java b/runners/core-java/src/test/java/org/apache/beam/runners/core/SimpleDoFnRunnerTest.java
index 2588863c165..0cb53ed7b2f 100644
--- a/runners/core-java/src/test/java/org/apache/beam/runners/core/SimpleDoFnRunnerTest.java
+++ b/runners/core-java/src/test/java/org/apache/beam/runners/core/SimpleDoFnRunnerTest.java
@@ -18,9 +18,12 @@
 package org.apache.beam.runners.core;
 
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.allOf;
 import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.isA;
+import static org.junit.Assert.assertThrows;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -34,6 +37,7 @@ import org.apache.beam.sdk.state.TimeDomain;
 import org.apache.beam.sdk.state.Timer;
 import org.apache.beam.sdk.state.TimerSpec;
 import org.apache.beam.sdk.state.TimerSpecs;
+import org.apache.beam.sdk.testing.TestPipeline;
 import org.apache.beam.sdk.transforms.DoFn;
 import org.apache.beam.sdk.transforms.DoFnSchemaInformation;
 import org.apache.beam.sdk.transforms.reflect.DoFnSignature.TimerDeclaration;
@@ -43,6 +47,7 @@ import org.apache.beam.sdk.transforms.windowing.GlobalWindows;
 import org.apache.beam.sdk.transforms.windowing.WindowFn;
 import org.apache.beam.sdk.util.UserCodeException;
 import org.apache.beam.sdk.util.WindowedValue;
+import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.TupleTag;
 import org.apache.beam.sdk.values.WindowingStrategy;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ArrayListMultimap;
@@ -68,6 +73,8 @@ import org.mockito.MockitoAnnotations;
 public class SimpleDoFnRunnerTest {
   @Rule public ExpectedException thrown = ExpectedException.none();
 
+  @Rule public final transient TestPipeline p = TestPipeline.create();
+
   @Mock StepContext mockStepContext;
 
   @Mock TimerInternals mockTimerInternals;
@@ -295,17 +302,27 @@ public class SimpleDoFnRunnerTest {
     // An element output at the current timestamp is fine.
     runner.processElement(
         WindowedValue.timestampedValueInGlobalWindow(Duration.ZERO, new Instant(0)));
-    thrown.expect(UserCodeException.class);
-    thrown.expectCause(isA(IllegalArgumentException.class));
-    thrown.expectMessage("must be no earlier");
-    thrown.expectMessage(
-        String.format("timestamp of the current input (%s)", new Instant(0).toString()));
-    thrown.expectMessage(
-        String.format(
-            "the allowed skew (%s)", PeriodFormat.getDefault().print(Duration.ZERO.toPeriod())));
-    // An element output before (current time - skew) is forbidden
-    runner.processElement(
-        WindowedValue.timestampedValueInGlobalWindow(Duration.millis(1L), new Instant(0)));
+    Exception exception =
+        assertThrows(
+            UserCodeException.class,
+            () -> {
+              // An element output before (current time - skew) is forbidden
+              runner.processElement(
+                  WindowedValue.timestampedValueInGlobalWindow(
+                      Duration.millis(1L), new Instant(0)));
+            });
+
+    assertThat(exception.getCause(), isA(IllegalArgumentException.class));
+    assertThat(
+        exception.getMessage(),
+        allOf(
+            containsString("must be no earlier"),
+            containsString(
+                String.format("timestamp of the current input (%s)", new Instant(0).toString())),
+            containsString(
+                String.format(
+                    "the allowed skew (%s)",
+                    PeriodFormat.getDefault().print(Duration.ZERO.toPeriod())))));
   }
 
   /**
@@ -335,18 +352,28 @@ public class SimpleDoFnRunnerTest {
     // Outputting between "now" and "now - allowed skew" succeeds.
     runner.processElement(
         WindowedValue.timestampedValueInGlobalWindow(Duration.standardMinutes(5L), new Instant(0)));
-    thrown.expect(UserCodeException.class);
-    thrown.expectCause(isA(IllegalArgumentException.class));
-    thrown.expectMessage("must be no earlier");
-    thrown.expectMessage(
-        String.format("timestamp of the current input (%s)", new Instant(0).toString()));
-    thrown.expectMessage(
-        String.format(
-            "the allowed skew (%s)",
-            PeriodFormat.getDefault().print(Duration.standardMinutes(10L).toPeriod())));
-    // Outputting before "now - allowed skew" fails.
-    runner.processElement(
-        WindowedValue.timestampedValueInGlobalWindow(Duration.standardHours(1L), new Instant(0)));
+
+    Exception exception =
+        assertThrows(
+            UserCodeException.class,
+            () -> {
+              // Outputting before "now - allowed skew" fails.
+              runner.processElement(
+                  WindowedValue.timestampedValueInGlobalWindow(
+                      Duration.standardHours(1L), new Instant(0)));
+            });
+
+    assertThat(exception.getCause(), isA(IllegalArgumentException.class));
+    assertThat(
+        exception.getMessage(),
+        allOf(
+            containsString("must be no earlier"),
+            containsString(
+                String.format("timestamp of the current input (%s)", new Instant(0).toString())),
+            containsString(
+                String.format(
+                    "the allowed skew (%s)",
+                    PeriodFormat.getDefault().print(Duration.standardMinutes(10L).toPeriod())))));
   }
 
   /**
@@ -387,6 +414,225 @@ public class SimpleDoFnRunnerTest {
             BoundedWindow.TIMESTAMP_MAX_VALUE));
   }
 
+  /**
+   * Demonstrates that attempting to set a timer with an output timestamp before the timestamp of
+   * the current element with zero {@link DoFn#getAllowedTimestampSkew() allowed timestamp skew}
+   * throws.
+   */
+  @Test
+  public void testTimerBackwardsInTimeNoSkew() {
+    TimerSkewDoFn fn = new TimerSkewDoFn(Duration.ZERO);
+    DoFnRunner<KV<String, Duration>, Duration> runner =
+        new SimpleDoFnRunner<>(
+            null,
+            fn,
+            NullSideInputReader.empty(),
+            new ListOutputManager(),
+            new TupleTag<>(),
+            Collections.emptyList(),
+            mockStepContext,
+            null,
+            Collections.emptyMap(),
+            WindowingStrategy.of(new GlobalWindows()),
+            DoFnSchemaInformation.create(),
+            Collections.emptyMap());
+
+    runner.startBundle();
+    // A timer with output timestamp at the current timestamp is fine.
+    runner.processElement(
+        WindowedValue.timestampedValueInGlobalWindow(KV.of("1", Duration.ZERO), new Instant(0)));
+
+    Exception exception =
+        assertThrows(
+            UserCodeException.class,
+            () -> {
+              // A timer with output timestamp before (current time - skew) is forbidden
+              runner.processElement(
+                  WindowedValue.timestampedValueInGlobalWindow(
+                      KV.of("2", Duration.millis(1L)), new Instant(0)));
+            });
+
+    assertThat(exception.getCause(), isA(IllegalArgumentException.class));
+    assertThat(
+        exception.getMessage(),
+        allOf(
+            containsString("Cannot output timer with"),
+            containsString(
+                String.format("output timestamp %s", new Instant(0).minus(Duration.millis(1L)))),
+            containsString(
+                String.format(
+                    "allowed skew (%s)",
+                    PeriodFormat.getDefault().print(Duration.ZERO.toPeriod())))));
+  }
+
+  /**
+   * Demonstrates that attempting to have a timer with output timestamp before the timestamp of the
+   * current element plus the value of {@link DoFn#getAllowedTimestampSkew()} throws, but between
+   * that value and the current timestamp succeeds.
+   */
+  @Test
+  public void testTimerSkew() {
+    TimerSkewDoFn fn = new TimerSkewDoFn(Duration.standardMinutes(10L));
+    DoFnRunner<KV<String, Duration>, Duration> runner =
+        new SimpleDoFnRunner<>(
+            null,
+            fn,
+            NullSideInputReader.empty(),
+            new ListOutputManager(),
+            new TupleTag<>(),
+            Collections.emptyList(),
+            mockStepContext,
+            null,
+            Collections.emptyMap(),
+            WindowingStrategy.of(new GlobalWindows()),
+            DoFnSchemaInformation.create(),
+            Collections.emptyMap());
+
+    runner.startBundle();
+    // Timer with output timestamp between "now" and "now - allowed skew" succeeds.
+    runner.processElement(
+        WindowedValue.timestampedValueInGlobalWindow(
+            KV.of("1", Duration.standardMinutes(5L)), new Instant(0)));
+
+    Exception exception =
+        assertThrows(
+            UserCodeException.class,
+            () -> {
+              // A timer with output timestamp before (current time - skew) is forbidden
+              runner.processElement(
+                  WindowedValue.timestampedValueInGlobalWindow(
+                      KV.of("2", Duration.standardHours(1L)), new Instant(0)));
+            });
+
+    assertThat(exception.getCause(), isA(IllegalArgumentException.class));
+    assertThat(
+        exception.getMessage(),
+        allOf(
+            containsString("Cannot output timer with"),
+            containsString(
+                String.format(
+                    "output timestamp %s", new Instant(0).minus(Duration.standardHours(1L)))),
+            containsString(
+                String.format(
+                    "allowed skew (%s)",
+                    PeriodFormat.getDefault().print(Duration.standardMinutes(10L).toPeriod())))));
+  }
+
+  /**
+   * Demonstrates that attempting to output an element with a timestamp before the current one
+   * always succeeds when {@link DoFn#getAllowedTimestampSkew()} is equal to {@link Long#MAX_VALUE}
+   * milliseconds.
+   */
+  @Test
+  public void testTimerInfiniteSkew() {
+    TimerSkewDoFn fn = new TimerSkewDoFn(Duration.millis(Long.MAX_VALUE));
+    DoFnRunner<KV<String, Duration>, Duration> runner =
+        new SimpleDoFnRunner<>(
+            null,
+            fn,
+            NullSideInputReader.empty(),
+            new ListOutputManager(),
+            new TupleTag<>(),
+            Collections.emptyList(),
+            mockStepContext,
+            null,
+            Collections.emptyMap(),
+            WindowingStrategy.of(new GlobalWindows()),
+            DoFnSchemaInformation.create(),
+            Collections.emptyMap());
+
+    runner.startBundle();
+    runner.processElement(
+        WindowedValue.timestampedValueInGlobalWindow(
+            KV.of("1", Duration.millis(1L)), new Instant(0)));
+    runner.processElement(
+        WindowedValue.timestampedValueInGlobalWindow(
+            KV.of("2", Duration.millis(1L)),
+            BoundedWindow.TIMESTAMP_MIN_VALUE.plus(Duration.millis(1))));
+    runner.processElement(
+        WindowedValue.timestampedValueInGlobalWindow(
+            KV.of(
+                "3",
+                // This is the maximum amount a timestamp in beam can move (from the maximum
+                // timestamp
+                // to the minimum timestamp).
+                Duration.millis(BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis())
+                    .minus(Duration.millis(BoundedWindow.TIMESTAMP_MIN_VALUE.getMillis()))),
+            BoundedWindow.TIMESTAMP_MAX_VALUE));
+  }
+
+  @Test
+  public void testOnTimerAllowedSkew() {
+    TimerOutputSkewingDoFn fn = new TimerOutputSkewingDoFn(Duration.millis(10), Duration.millis(5));
+    DoFnRunner<KV<String, Duration>, Duration> runner =
+        new SimpleDoFnRunner<>(
+            null,
+            fn,
+            NullSideInputReader.empty(),
+            new ListOutputManager(),
+            null,
+            Collections.emptyList(),
+            mockStepContext,
+            null,
+            Collections.emptyMap(),
+            WindowingStrategy.of(new GlobalWindows()),
+            DoFnSchemaInformation.create(),
+            Collections.emptyMap());
+
+    runner.onTimer(
+        TimerDeclaration.PREFIX + TimerOutputSkewingDoFn.TIMER_ID,
+        "",
+        null,
+        GlobalWindow.INSTANCE,
+        new Instant(0),
+        new Instant(0),
+        TimeDomain.EVENT_TIME);
+  }
+
+  @Test
+  public void testOnTimerNoSkew() {
+    TimerOutputSkewingDoFn fn = new TimerOutputSkewingDoFn(Duration.ZERO, Duration.millis(5));
+    DoFnRunner<KV<String, Duration>, Duration> runner =
+        new SimpleDoFnRunner<>(
+            null,
+            fn,
+            NullSideInputReader.empty(),
+            null,
+            null,
+            Collections.emptyList(),
+            mockStepContext,
+            null,
+            Collections.emptyMap(),
+            WindowingStrategy.of(new GlobalWindows()),
+            DoFnSchemaInformation.create(),
+            Collections.emptyMap());
+
+    Exception exception =
+        assertThrows(
+            UserCodeException.class,
+            () -> {
+              runner.onTimer(
+                  TimerDeclaration.PREFIX + TimerOutputSkewingDoFn.TIMER_ID,
+                  "",
+                  null,
+                  GlobalWindow.INSTANCE,
+                  new Instant(0),
+                  new Instant(0),
+                  TimeDomain.EVENT_TIME);
+            });
+
+    assertThat(exception.getCause(), isA(IllegalArgumentException.class));
+    assertThat(
+        exception.getMessage(),
+        allOf(
+            containsString("must be no earlier"),
+            containsString(String.format("timestamp of the timer (%s)", new Instant(0).toString())),
+            containsString(
+                String.format(
+                    "the allowed skew (%s)",
+                    PeriodFormat.getDefault().print(Duration.ZERO.toPeriod())))));
+  }
+
   static class ThrowingDoFn extends DoFn<String, String> {
     final Exception exceptionToThrow = new UnsupportedOperationException("Expected exception");
 
@@ -473,6 +719,69 @@ public class SimpleDoFnRunnerTest {
     }
   }
 
+  /**
+   * A {@link DoFn} that creates/sets a timer with an output timestamp equal to the input timestamp
+   * minus the input element's value. Keys are ignored but required for timers.
+   */
+  private static class TimerSkewDoFn extends DoFn<KV<String, Duration>, Duration> {
+    static final String TIMER_ID = "testTimerId";
+    private final Duration allowedSkew;
+
+    @TimerId(TIMER_ID)
+    private static final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);
+
+    private TimerSkewDoFn(Duration allowedSkew) {
+      this.allowedSkew = allowedSkew;
+    }
+
+    @ProcessElement
+    public void processElement(ProcessContext context, @TimerId(TIMER_ID) Timer timer) {
+      timer
+          .withOutputTimestamp(context.timestamp().minus(context.element().getValue()))
+          .set(new Instant(0));
+    }
+
+    @OnTimer(TIMER_ID)
+    public void onTimer() {}
+
+    @Override
+    public Duration getAllowedTimestampSkew() {
+      return allowedSkew;
+    }
+  }
+
+  /**
+   * A {@link DoFn} that creates/sets a timer with an output timestamp equal to the input timestamp
+   * minus the input element's value. Keys are ignored but required for timers.
+   */
+  private static class TimerOutputSkewingDoFn extends DoFn<KV<String, Duration>, Duration> {
+    static final String TIMER_ID = "testTimerId";
+    private final Duration allowedSkew;
+    private final Duration outputTimestampSkew;
+
+    @TimerId(TIMER_ID)
+    private static final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);
+
+    private TimerOutputSkewingDoFn(Duration allowedSkew, Duration outputTimestampSkew) {
+      this.allowedSkew = allowedSkew;
+      this.outputTimestampSkew = outputTimestampSkew;
+    }
+
+    @ProcessElement
+    public void processElement(ProcessContext context) {}
+
+    @OnTimer(TIMER_ID)
+    public void onTimer(OnTimerContext context) {
+      Instant outputTimestamp = context.timestamp().minus(outputTimestampSkew);
+      context.outputWithTimestamp(Duration.ZERO, outputTimestamp);
+    }
+
+    @Override
+    public Duration getAllowedTimestampSkew() {
+      return allowedSkew;
+    }
+  }
+
   private static class ListOutputManager implements OutputManager {
     private ListMultimap<TupleTag<?>, WindowedValue<?>> outputs = ArrayListMultimap.create();
 
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java
index 901898726af..afce041f796 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java
@@ -118,6 +118,7 @@ import org.apache.beam.sdk.testing.UsesTimerMap;
 import org.apache.beam.sdk.testing.UsesTimersInParDo;
 import org.apache.beam.sdk.testing.UsesUnboundedPCollections;
 import org.apache.beam.sdk.testing.ValidatesRunner;
+import org.apache.beam.sdk.transforms.Create.TimestampedValues;
 import org.apache.beam.sdk.transforms.DoFn.OnTimer;
 import org.apache.beam.sdk.transforms.DoFn.ProcessElement;
 import org.apache.beam.sdk.transforms.Mean.CountSum;
@@ -158,6 +159,7 @@ import org.joda.time.DateTimeUtils;
 import org.joda.time.Duration;
 import org.joda.time.Instant;
 import org.joda.time.MutableDateTime;
+import org.joda.time.format.PeriodFormat;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
@@ -1789,6 +1791,172 @@ public class ParDoTest implements Serializable {
   /** Tests to validate output timestamps. */
   @RunWith(JUnit4.class)
   public static class TimestampTests extends SharedTestBase implements Serializable {
+
+    static final String TIMER_ELEMENT = "timer";
+    static final String OUTPUT_ELEMENT = "output";
+
+    /**
+     * Checks that the given message is correct and includes the element timestamp, allowed skew,
+     * and output timestamp.
+     */
+    static boolean hasExpectedError(
+        IllegalArgumentException e,
+        Duration allowedSkew,
+        Instant elementTimestamp,
+        Instant outputTimestamp) {
+      return e.getMessage().contains("timestamp of the ")
+          && e.getMessage().contains(elementTimestamp.toString())
+          && e.getMessage().contains("timestamp " + outputTimestamp)
+          && e.getMessage()
+              .contains("allowed skew (" + PeriodFormat.getDefault().print(allowedSkew.toPeriod()))
+          && e.getMessage().contains("getAllowedTimestampSkew");
+    }
+
+    /**
+     * A {@link DoFn} that outputs an element at and creates/sets a timer with an output timestamp
+     * equal to the input timestamp minus the input element's value. Keys are ignored but required
+     * for timers.
+     */
+    private static class ProcessElementTimestampSkewingDoFn
+        extends DoFn<KV<String, Duration>, String> {
+
+      static final String TIMER_ID = "testTimerId";
+      private final Duration allowedSkew;
+
+      @TimerId(TIMER_ID)
+      private static final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);
+
+      private ProcessElementTimestampSkewingDoFn(Duration allowedSkew) {
+        this.allowedSkew = allowedSkew;
+      }
+
+      @ProcessElement
+      public void processElement(ProcessContext context, @TimerId(TIMER_ID) Timer timer) {
+        Instant outputTimestamp = context.timestamp().minus(context.element().getValue());
+        try {
+          context.outputWithTimestamp(OUTPUT_ELEMENT, outputTimestamp);
+        } catch (IllegalArgumentException e) {
+          if (hasExpectedError(e, allowedSkew, context.timestamp(), outputTimestamp)) {
+            context.output(OUTPUT_ELEMENT + outputTimestamp.toString());
+          }
+        }
+        try {
+          timer.withOutputTimestamp(outputTimestamp).set(new Instant(0));
+          context.output(TIMER_ELEMENT);
+        } catch (IllegalArgumentException e) {
+          if (hasExpectedError(e, allowedSkew, context.timestamp(), outputTimestamp)) {
+            context.output(TIMER_ELEMENT + outputTimestamp.toString());
+          }
+        }
+      }
+
+      @OnTimer(TIMER_ID)
+      public void onTimer(OnTimerContext context) {}
+
+      @Override
+      public Duration getAllowedTimestampSkew() {
+        return allowedSkew;
+      }
+    }
+
+    /**
+     * A {@link DoFn} that sets a timer that outputs an element and sets a second timer with an
+     * output timestamp equal to the input timestamp minus the input element's value. Keys are
+     * ignored but required for timers.
+     */
+    private static class OnTimerTimestampSkewingDoFn extends DoFn<KV<String, String>, String> {
+
+      static final String FIRST_TIMER_ID = "firstTestTimerId";
+      static final String SECOND_TIMER_ID = "secondTestTimerId";
+      private final Duration allowedSkew;
+      private final Duration outputTimestampSkew;
+
+      @TimerId(FIRST_TIMER_ID)
+      private static final TimerSpec firstTimer = TimerSpecs.timer(TimeDomain.EVENT_TIME);
+
+      @TimerId(SECOND_TIMER_ID)
+      private static final TimerSpec secondTimer = TimerSpecs.timer(TimeDomain.EVENT_TIME);
+
+      private OnTimerTimestampSkewingDoFn(Duration allowedSkew, Duration outputTimestampSkew) {
+        this.allowedSkew = allowedSkew;
+        this.outputTimestampSkew = outputTimestampSkew;
+      }
+
+      @ProcessElement
+      public void processElement(ProcessContext context, @TimerId(FIRST_TIMER_ID) Timer timer) {
+        timer.set(context.timestamp());
+      }
+
+      @OnTimer(SECOND_TIMER_ID)
+      public void onSecondTimer(OnTimerContext context) {}
+
+      @OnTimer(FIRST_TIMER_ID)
+      public void onFirstTimer(OnTimerContext context, @TimerId(SECOND_TIMER_ID) Timer timer) {
+        Instant outputTimestamp = context.timestamp().minus(outputTimestampSkew);
+        try {
+          context.outputWithTimestamp(OUTPUT_ELEMENT, outputTimestamp);
+        } catch (IllegalArgumentException e) {
+          if (hasExpectedError(e, allowedSkew, context.timestamp(), outputTimestamp)) {
+            context.output(OUTPUT_ELEMENT + outputTimestamp);
+          }
+        }
+        try {
+          timer.withOutputTimestamp(outputTimestamp).set(context.timestamp());
+          context.output(TIMER_ELEMENT);
+        } catch (IllegalArgumentException e) {
+          if (hasExpectedError(e, allowedSkew, context.timestamp(), outputTimestamp)) {
+            context.output(TIMER_ELEMENT + outputTimestamp);
+          }
+        }
+      }
+
+      @Override
+      public Duration getAllowedTimestampSkew() {
+        return allowedSkew;
+      }
+    }
+
+    /**
+     * A {@link DoFn} that on window expiration outputs an element with an output timestamp equal to
+     * the input timestamp minus the input element's value. Keys are ignored but required by timers.
+     */
+    private static class OnWindowExpirationTimestampSkewingDoFn
+        extends DoFn<KV<String, String>, String> {
+
+      private final Duration allowedSkew;
+      private final Duration outputTimestampSkew;
+
+      // Using state is required because of BEAM-13213.
+      @StateId("ignored")
+      private final StateSpec<ValueState<String>> ignoredState = StateSpecs.value();
+
+      private OnWindowExpirationTimestampSkewingDoFn(
+          Duration allowedSkew, Duration outputTimestampSkew) {
+        this.allowedSkew = allowedSkew;
+        this.outputTimestampSkew = outputTimestampSkew;
+      }
+
+      @ProcessElement
+      public void processElement(ProcessContext context) {}
+
+      @OnWindowExpiration
+      public void onWindowExpiration(@Timestamp Instant timestamp, OutputReceiver<String> output) {
+        Instant outputTimestamp = timestamp.minus(outputTimestampSkew);
+        try {
+          output.outputWithTimestamp(OUTPUT_ELEMENT, outputTimestamp);
+        } catch (IllegalArgumentException e) {
+          if (hasExpectedError(e, allowedSkew, timestamp, outputTimestamp)) {
+            output.output(OUTPUT_ELEMENT + outputTimestamp);
+          }
+        }
+      }
+
+      @Override
+      public Duration getAllowedTimestampSkew() {
+        return allowedSkew;
+      }
+    }
+
     @Test
     @Category(ValidatesRunner.class)
     public void testParDoOutputWithTimestamp() {
@@ -1886,7 +2054,7 @@ public class ParDoTest implements Serializable {
       thrown.expectMessage("Cannot output with timestamp");
       thrown.expectMessage(
           "Output timestamps must be no earlier than the timestamp of the current input");
-      thrown.expectMessage("minus the allowed skew (1 second).");
+      thrown.expectMessage("minus the allowed skew (1 second)");
       pipeline.run();
     }
 
@@ -1903,7 +2071,7 @@ public class ParDoTest implements Serializable {
       thrown.expectMessage("Cannot output with timestamp");
       thrown.expectMessage(
           "Output timestamps must be no earlier than the timestamp of the current input");
-      thrown.expectMessage("minus the allowed skew (0 milliseconds).");
+      thrown.expectMessage("minus the allowed skew (0 milliseconds)");
       pipeline.run();
     }
 
@@ -1956,6 +2124,90 @@ public class ParDoTest implements Serializable {
 
       pipeline.run();
     }
+
+    @Test
+    @Category({ValidatesRunner.class, UsesTimersInParDo.class})
+    public void testProcessElementSkew() {
+      TimestampedValues<KV<String, Duration>> input =
+          Create.timestamped(Arrays.asList(KV.of("2", Duration.millis(1L))), Arrays.asList(1L));
+
+      PCollection<String> noSkew =
+          pipeline
+              .apply("createNoSkew", input)
+              .apply("noSkew", ParDo.of(new ProcessElementTimestampSkewingDoFn(Duration.ZERO)));
+      PAssert.that(noSkew)
+          .containsInAnyOrder(TIMER_ELEMENT + new Instant(0L), OUTPUT_ELEMENT + new Instant(0L));
+
+      PCollection<String> skew =
+          pipeline
+              .apply("createSkew", input)
+              .apply("skew", ParDo.of(new ProcessElementTimestampSkewingDoFn(Duration.millis(2L))));
+      PAssert.that(skew).containsInAnyOrder(TIMER_ELEMENT, OUTPUT_ELEMENT);
+      pipeline.run();
+    }
+
+    @Test
+    @Category({UsesTimersInParDo.class, ValidatesRunner.class})
+    public void testOnTimerTimestampSkew() {
+      TimestampedValues<KV<String, String>> input =
+          Create.timestamped(Arrays.asList(KV.of("0", "0")), Arrays.asList(0L));
+      PCollection<String> noSkew =
+          pipeline
+              .apply("createNoSkew", input)
+              .apply(
+                  "noskew",
+                  ParDo.of(
+                      new OnTimerTimestampSkewingDoFn(Duration.millis(0L), Duration.millis(3L))));
+      PAssert.that(noSkew)
+          .containsInAnyOrder(OUTPUT_ELEMENT + new Instant(-3L), TIMER_ELEMENT + new Instant(-3L));
+      PCollection<String> skew =
+          pipeline
+              .apply("createSkew", input)
+              .apply(
+                  "skew",
+                  ParDo.of(
+                      new OnTimerTimestampSkewingDoFn(Duration.millis(3L), Duration.millis(2L))));
+      PAssert.that(skew).containsInAnyOrder(OUTPUT_ELEMENT, TIMER_ELEMENT);
+      pipeline.run();
+    }
+
+    @Test
+    @Category({UsesOnWindowExpiration.class, UsesTimersInParDo.class, ValidatesRunner.class})
+    public void testOnWindowTimestampSkew() {
+      Duration windowDuration = Duration.millis(10L);
+      TimestampedValues<KV<String, String>> input =
+          Create.timestamped(Arrays.asList(KV.of("key", "0")), Arrays.asList(0L));
+
+      PCollection<String> noSkew =
+          pipeline
+              .apply("createNoSkew", input)
+              .apply("noSkewWindow", Window.into(FixedWindows.of(windowDuration)))
+              .apply(
+                  "noskew",
+                  ParDo.of(
+                      new OnWindowExpirationTimestampSkewingDoFn(
+                          Duration.millis(0L), Duration.millis(3L))));
+      PAssert.that(noSkew)
+          .containsInAnyOrder(
+              OUTPUT_ELEMENT
+                  + new Instant(
+                      windowDuration
+                          .minus(Duration.millis(3L))
+                          .minus(Duration.millis(1L))
+                          .getMillis()));
+
+      PCollection<String> skew =
+          pipeline
+              .apply("createSkew", input)
+              .apply("skewWindow", Window.into(FixedWindows.of(windowDuration)))
+              .apply(
+                  "skew",
+                  ParDo.of(
+                      new OnWindowExpirationTimestampSkewingDoFn(
+                          Duration.millis(4L), Duration.millis(3L))));
+      PAssert.that(skew).containsInAnyOrder(OUTPUT_ELEMENT);
+      pipeline.run();
+    }
   }
 
   /** Tests to validate ParDo state. */
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java
index f38a5e9efc9..14eae0fa077 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java
@@ -129,6 +129,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
 import org.joda.time.DateTimeUtils;
 import org.joda.time.Duration;
 import org.joda.time.Instant;
+import org.joda.time.format.PeriodFormat;
 
 /**
  * A {@link DoFnRunner} specific to integrating with the Fn Api. This is to remove the layers of
@@ -1887,14 +1888,28 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
       return Timer.cleared(userKey, dynamicTimerTag, Collections.singletonList(boundedWindow));
     }
 
+    @SuppressWarnings("deprecation") // Allowed Skew is deprecated for users, but must be respected
     private Timer<K> getTimerForTime(Instant scheduledTime) {
       if (outputTimestamp != null) {
-        checkArgument(
-            !outputTimestamp.isBefore(elementTimestampOrTimerHoldTimestamp),
-            "output timestamp %s should be after input message timestamp or output timestamp of"
-                + " firing timers %s",
-            outputTimestamp,
-            elementTimestampOrTimerHoldTimestamp);
+        Instant lowerBound;
+        try {
+          lowerBound = elementTimestampOrTimerHoldTimestamp.minus(doFn.getAllowedTimestampSkew());
+        } catch (ArithmeticException e) {
+          lowerBound = BoundedWindow.TIMESTAMP_MIN_VALUE;
+        }
+        if (outputTimestamp.isBefore(lowerBound)
+            || outputTimestamp.isAfter(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
+          throw new IllegalArgumentException(
+              String.format(
+                  "Cannot output timer with output timestamp %s. Output timestamps must be no "
+                      + "earlier than the timestamp of the current input (%s) minus the allowed skew "
+                      + "(%s) and no later than %s. See the DoFn#getAllowedTimestampSkew() Javadoc for "
+                      + "details on changing the allowed skew.",
+                  outputTimestamp,
+                  elementTimestampOrTimerHoldTimestamp,
+                  PeriodFormat.getDefault().print(doFn.getAllowedTimestampSkew().toPeriod()),
+                  BoundedWindow.TIMESTAMP_MAX_VALUE));
+        }
       }
 
       // Output timestamp is set to the delivery time if not initialized by an user.
@@ -1989,6 +2004,28 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
     }
   }
 
+  @SuppressWarnings("deprecation") // Allowed Skew is deprecated for users, but must be respected
+  private void checkTimestamp(Instant timestamp) {
+    Instant lowerBound;
+    try {
+      lowerBound = currentElement.getTimestamp().minus(doFn.getAllowedTimestampSkew());
+    } catch (ArithmeticException e) {
+      lowerBound = BoundedWindow.TIMESTAMP_MIN_VALUE;
+    }
+    if (timestamp.isBefore(lowerBound) || timestamp.isAfter(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
+      throw new IllegalArgumentException(
+          String.format(
+              "Cannot output with timestamp %s. Output timestamps must be no earlier than the "
+                  + "timestamp of the current input (%s) minus the allowed skew (%s) and no later "
+                  + "than %s. See the DoFn#getAllowedTimestampSkew() Javadoc for details on "
+                  + "changing the allowed skew.",
+              timestamp,
+              currentElement.getTimestamp(),
+              PeriodFormat.getDefault().print(doFn.getAllowedTimestampSkew().toPeriod()),
+              BoundedWindow.TIMESTAMP_MAX_VALUE));
+    }
+  }
+
   private class StartBundleArgumentProvider extends BaseArgumentProvider<InputT, OutputT> {
     private class Context extends DoFn<InputT, OutputT>.StartBundleContext {
       Context() {
@@ -2149,6 +2186,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
 
     @Override
     public void outputWithTimestamp(OutputT output, Instant timestamp) {
+      // TODO: Check that timestamp is valid once all runners can provide proper timestamps.
       outputTo(
           mainOutputConsumers,
           WindowedValue.of(output, timestamp, currentWindow, currentElement.getPane()));
@@ -2156,6 +2194,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
 
     @Override
     public <T> void outputWithTimestamp(TupleTag<T> tag, T output, Instant timestamp) {
+      // TODO: Check that timestamp is valid once all runners can provide proper timestamps.
       Collection<FnDataReceiver<WindowedValue<T>>> consumers =
           (Collection) localNameToConsumer.get(tag.getId());
       if (consumers == null) {
@@ -2178,6 +2217,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
     @Override
     // OutputT == RestrictionT
     public void outputWithTimestamp(OutputT output, Instant timestamp) {
+      checkTimestamp(timestamp);
       double size =
           doFnInvoker.invokeGetSize(
               new DelegatingArgumentProvider<InputT, OutputT>(
@@ -2224,6 +2264,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
     @Override
     // OutputT == RestrictionT
     public void outputWithTimestamp(OutputT output, Instant timestamp) {
+      checkTimestamp(timestamp);
       double size =
           doFnInvoker.invokeGetSize(
               new DelegatingArgumentProvider<InputT, OutputT>(
@@ -2262,6 +2303,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
   private class NonWindowObservingProcessBundleContext extends ProcessBundleContextBase {
     @Override
     public void outputWithTimestamp(OutputT output, Instant timestamp) {
+      checkTimestamp(timestamp);
       outputTo(
           mainOutputConsumers,
           WindowedValue.of(
@@ -2270,6 +2312,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
 
     @Override
     public <T> void outputWithTimestamp(TupleTag<T> tag, T output, Instant timestamp) {
+      checkTimestamp(timestamp);
       Collection<FnDataReceiver<WindowedValue<T>>> consumers =
           (Collection) localNameToConsumer.get(tag.getId());
       if (consumers == null) {
@@ -2493,11 +2536,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
 
       @Override
       public void outputWithTimestamp(OutputT output, Instant timestamp) {
-        checkArgument(
-            !currentTimer.getHoldTimestamp().isAfter(timestamp),
-            "Output time %s can not be before timer timestamp %s.",
-            timestamp,
-            currentTimer.getHoldTimestamp());
+        checkTimerTimestamp(timestamp);
         outputTo(
             mainOutputConsumers,
             WindowedValue.of(output, timestamp, currentWindow, currentTimer.getPane()));
@@ -2518,11 +2557,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
 
       @Override
       public <T> void outputWithTimestamp(TupleTag<T> tag, T output, Instant timestamp) {
-        checkArgument(
-            !currentTimer.getHoldTimestamp().isAfter(timestamp),
-            "Output time %s can not be before timer timestamp %s.",
-            timestamp,
-            currentTimer.getHoldTimestamp());
+        checkTimerTimestamp(timestamp);
         Collection<FnDataReceiver<WindowedValue<T>>> consumers =
             (Collection) localNameToConsumer.get(tag.getId());
         if (consumers == null) {
@@ -2546,6 +2581,30 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator
       public Instant timestamp() {
         return currentTimer.getHoldTimestamp();
       }
+
+      @SuppressWarnings(
+          "deprecation") // Allowed Skew is deprecated for users, but must be respected
+      private void checkTimerTimestamp(Instant timestamp) {
+        Instant lowerBound;
+        try {
+          lowerBound = currentTimer.getHoldTimestamp().minus(doFn.getAllowedTimestampSkew());
+        } catch (ArithmeticException e) {
+          lowerBound = BoundedWindow.TIMESTAMP_MIN_VALUE;
+        }
+        if (timestamp.isBefore(lowerBound)
+            || timestamp.isAfter(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
+          throw new IllegalArgumentException(
+              String.format(
+                  "Cannot output with timestamp %s. Output timestamps must be no earlier than the "
+                      + "timestamp of the timer (%s) minus the allowed skew (%s) and no later "
+                      + "than %s. See the DoFn#getAllowedTimestampSkew() Javadoc for details on "
+                      + "changing the allowed skew.",
+                  timestamp,
+                  currentTimer.getHoldTimestamp(),
+                  PeriodFormat.getDefault().print(doFn.getAllowedTimestampSkew().toPeriod()),
+                  BoundedWindow.TIMESTAMP_MAX_VALUE));
+        }
+      }
     }
 
     private final OnTimerContext.Context context = new OnTimerContext.Context();
diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java
index e1f9624d6be..52a522f0037 100644
--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java
+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java
@@ -23,14 +23,17 @@ import static org.apache.beam.sdk.util.WindowedValue.timestampedValueInGlobalWin
 import static org.apache.beam.sdk.util.WindowedValue.valueInGlobalWindow;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.allOf;
 import static org.hamcrest.Matchers.contains;
 import static org.hamcrest.Matchers.containsInAnyOrder;
+import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -125,6 +128,7 @@ import org.apache.beam.sdk.transforms.windowing.PaneInfo;
 import org.apache.beam.sdk.transforms.windowing.SlidingWindows;
 import org.apache.beam.sdk.transforms.windowing.Window;
 import org.apache.beam.sdk.util.CoderUtils;
+import org.apache.beam.sdk.util.UserCodeException;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.PCollection;
@@ -140,6 +144,7 @@ import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterable
 import org.hamcrest.collection.IsMapContaining;
 import org.joda.time.Duration;
 import org.joda.time.Instant;
+import org.joda.time.format.PeriodFormat;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -1496,6 +1501,11 @@ public class FnApiDoFnRunnerTest implements Serializable {
         }
       }
 
+      @Override
+      public Duration getAllowedTimestampSkew() {
+        return Duration.millis(Long.MAX_VALUE);
+      }
+
       @Override
       @TruncateRestriction
       public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)
@@ -3597,6 +3607,142 @@ public class FnApiDoFnRunnerTest implements Serializable {
       Iterables.getOnlyElement(context.getTearDownFunctions()).run();
       assertThat(mainOutputValues, empty());
     }
+
+    /**
+     * A {@link DoFn} that outputs elements with timestamp equal to the input timestamp minus the
+     * input element.
+     */
+    private static class SkewingDoFn extends DoFn<String, String> {
+      private final Duration allowedSkew;
+
+      private SkewingDoFn(Duration allowedSkew) {
+        this.allowedSkew = allowedSkew;
+      }
+
+      @ProcessElement
+      public void processElement(ProcessContext context) {
+        Duration duration = Duration.millis(Long.valueOf(context.element()));
+        context.outputWithTimestamp(context.element(), context.timestamp().minus(duration));
+      }
+
+      @Override
+      public Duration getAllowedTimestampSkew() {
+        return allowedSkew;
+      }
+    }
+
+    private static class OutputFnDataReceiver implements FnDataReceiver<WindowedValue> {
+      OutputFnDataReceiver(List<WindowedValue<String>> mainOutputValues) {
+        this.mainOutputValues = mainOutputValues;
+      }
+
+      private final List<WindowedValue<String>> mainOutputValues;
+
+      @Override
+      public void accept(WindowedValue input) throws Exception {
+        mainOutputValues.add(input);
+      }
+    }
+
+    @Test
+    public void testDoFnSkewNotAllowed() throws Exception {
+      Pipeline p = Pipeline.create();
+      PCollection<String> valuePCollection = p.apply(Create.of("0", "1"));
+      PCollection<String> outputPCollection =
+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new SkewingDoFn(Duration.ZERO)));
+
+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());
+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);
+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);
+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);
+      RunnerApi.PTransform pTransform =
+          pProto
+              .getComponents()
+              .getTransformsOrThrow(
+                  pProto
+                      .getComponents()
+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)
+                      .getSubtransforms(0));
+
+      PTransformRunnerFactoryTestContext context =
+          PTransformRunnerFactoryTestContext.builder(TEST_TRANSFORM_ID, pTransform)
+              .processBundleInstructionId("57")
+              .pCollections(pProto.getComponentsOrBuilder().getPcollectionsMap())
+              .coders(pProto.getComponents().getCodersMap())
+              .windowingStrategies(pProto.getComponents().getWindowingStrategiesMap())
+              .build();
+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();
+      Coder coder = StringUtf8Coder.of();
+      context.addPCollectionConsumer(
+          outputPCollectionId, (FnDataReceiver) new OutputFnDataReceiver(mainOutputValues), coder);
+
+      new FnApiDoFnRunner.Factory<>().createRunnerForPTransform(context);
+
+      mainOutputValues.clear();
+      FnDataReceiver<WindowedValue<?>> mainInput =
+          context.getPCollectionConsumer(inputPCollectionId);
+      mainInput.accept(valueInGlobalWindow("0"));
+
+      String message =
+          assertThrows(
+                  UserCodeException.class,
+                  () -> {
+                    mainInput.accept(timestampedValueInGlobalWindow("1", new Instant(0L)));
+                  })
+              .getMessage();
+
+      assertThat(
+          message,
+          allOf(
+              containsString(
+                  String.format("timestamp %s", new Instant(0).minus(Duration.millis(1L)))),
+              containsString(
+                  String.format(
+                      "allowed skew (%s)",
+                      PeriodFormat.getDefault().print(Duration.ZERO.toPeriod())))));
+    }
+
+    @Test
+    public void testDoFnSkewAllowed() throws Exception {
+      Pipeline p = Pipeline.create();
+      PCollection<String> valuePCollection = p.apply(Create.of("0", "3"));
+      PCollection<String> outputPCollection =
+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new SkewingDoFn(Duration.millis(5L))));
+
+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());
+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);
+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);
+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);
+      RunnerApi.PTransform pTransform =
+          pProto
+              .getComponents()
+              .getTransformsOrThrow(
+                  pProto
+                      .getComponents()
+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)
+                      .getSubtransforms(0));
+
+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();
+      PTransformRunnerFactoryTestContext context =
+          PTransformRunnerFactoryTestContext.builder(TEST_TRANSFORM_ID, pTransform)
+              .processBundleInstructionId("57")
+              .pCollections(pProto.getComponentsOrBuilder().getPcollectionsMap())
+              .coders(pProto.getComponents().getCodersMap())
+              .windowingStrategies(pProto.getComponents().getWindowingStrategiesMap())
+              .build();
+      Coder coder = StringUtf8Coder.of();
+      context.addPCollectionConsumer(
+          outputPCollectionId, (FnDataReceiver) new OutputFnDataReceiver(mainOutputValues), coder);
+
+      new FnApiDoFnRunner.Factory<>().createRunnerForPTransform(context);
+
+      mainOutputValues.clear();
+
+      FnDataReceiver<WindowedValue<?>> mainInput =
+          context.getPCollectionConsumer(inputPCollectionId);
+      mainInput.accept(valueInGlobalWindow("0"));
+      mainInput.accept(timestampedValueInGlobalWindow("3", new Instant(0L)));
+    }
   }
 
   @RunWith(JUnit4.class)
