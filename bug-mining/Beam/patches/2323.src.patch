diff --git a/runners/core-java/src/main/java/org/apache/beam/runners/core/WatermarkHold.java b/runners/core-java/src/main/java/org/apache/beam/runners/core/WatermarkHold.java
index e1606db67d4..099d5dbd5aa 100644
--- a/runners/core-java/src/main/java/org/apache/beam/runners/core/WatermarkHold.java
+++ b/runners/core-java/src/main/java/org/apache/beam/runners/core/WatermarkHold.java
@@ -113,7 +113,10 @@ class WatermarkHold<W extends BoundedWindow> implements Serializable {
    * output time function.
    */
   private Instant shift(Instant timestamp, W window) {
-    Instant shifted = windowingStrategy.getTimestampCombiner().assign(window, timestamp);
+    Instant shifted =
+        windowingStrategy
+            .getTimestampCombiner()
+            .assign(window, windowingStrategy.getWindowFn().getOutputTime(timestamp, window));
     // Don't call checkState(), to avoid calling BoundedWindow.formatTimestamp() every time
     if (shifted.isBefore(timestamp)) {
       throw new IllegalStateException(
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkNonMergingReduceFunction.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkNonMergingReduceFunction.java
index 5a41d875462..b1ad8d0d2a9 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkNonMergingReduceFunction.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkNonMergingReduceFunction.java
@@ -84,7 +84,10 @@ public class FlinkNonMergingReduceFunction<K, InputT>
     final WindowedValue<KV<K, InputT>> first = iterator.peek();
     final BoundedWindow window = Iterables.getOnlyElement(first.getWindows());
     @SuppressWarnings("unchecked")
-    final Instant outputTimestamp = first.getTimestamp();
+    final Instant outputTimestamp =
+        ((WindowingStrategy) windowingStrategy)
+            .getWindowFn()
+            .getOutputTime(first.getTimestamp(), window);
     final Instant combinedTimestamp =
         windowingStrategy.getTimestampCombiner().assign(window, outputTimestamp);
     final Iterable<InputT> values;
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/HashingFlinkCombineRunner.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/HashingFlinkCombineRunner.java
index e11eadd3f98..6cf9ac7c62c 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/HashingFlinkCombineRunner.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/HashingFlinkCombineRunner.java
@@ -59,6 +59,7 @@ public class HashingFlinkCombineRunner<K, InputT, AccumT, OutputT, W extends Bou
 
     @SuppressWarnings("unchecked")
     TimestampCombiner timestampCombiner = windowingStrategy.getTimestampCombiner();
+    WindowFn<Object, W> windowFn = windowingStrategy.getWindowFn();
 
     // Flink Iterable can be iterated over only once.
     List<WindowedValue<KV<K, InputT>>> inputs = new ArrayList<>();
@@ -85,7 +86,8 @@ public class HashingFlinkCombineRunner<K, InputT, AccumT, OutputT, W extends Bou
               flinkCombiner.firstInput(
                   key, currentValue.getValue().getValue(), options, sideInputReader, singletonW);
           Instant windowTimestamp =
-              timestampCombiner.assign(mergedWindow, currentValue.getTimestamp());
+              timestampCombiner.assign(
+                  mergedWindow, windowFn.getOutputTime(currentValue.getTimestamp(), mergedWindow));
           accumAndInstant = new Tuple2<>(accumT, windowTimestamp);
           mapState.put(mergedWindow, accumAndInstant);
         } else {
@@ -100,7 +102,11 @@ public class HashingFlinkCombineRunner<K, InputT, AccumT, OutputT, W extends Bou
           accumAndInstant.f1 =
               timestampCombiner.combine(
                   accumAndInstant.f1,
-                  timestampCombiner.assign(mergedWindow, currentValue.getTimestamp()));
+                  timestampCombiner.assign(
+                      mergedWindow,
+                      windowingStrategy
+                          .getWindowFn()
+                          .getOutputTime(currentValue.getTimestamp(), mergedWindow)));
         }
       }
       if (iterator.hasNext()) {
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/SingleWindowFlinkCombineRunner.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/SingleWindowFlinkCombineRunner.java
index 68795debe8f..e5977388f5d 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/SingleWindowFlinkCombineRunner.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/SingleWindowFlinkCombineRunner.java
@@ -24,6 +24,7 @@ import org.apache.beam.sdk.options.PipelineOptions;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.sdk.transforms.windowing.PaneInfo;
 import org.apache.beam.sdk.transforms.windowing.TimestampCombiner;
+import org.apache.beam.sdk.transforms.windowing.WindowFn;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.WindowingStrategy;
@@ -52,6 +53,7 @@ public class SingleWindowFlinkCombineRunner<K, InputT, AccumT, OutputT, W extend
       Iterable<WindowedValue<KV<K, InputT>>> elements,
       Collector<WindowedValue<KV<K, OutputT>>> out) {
     final TimestampCombiner timestampCombiner = windowingStrategy.getTimestampCombiner();
+    final WindowFn<Object, W> windowFn = windowingStrategy.getWindowFn();
     final PeekingIterator<WindowedValue<KV<K, InputT>>> iterator =
         Iterators.peekingIterator(elements.iterator());
 
@@ -74,7 +76,8 @@ public class SingleWindowFlinkCombineRunner<K, InputT, AccumT, OutputT, W extend
                 sideInputReader,
                 Collections.singleton(currentWindow));
         Instant windowTimestamp =
-            timestampCombiner.assign(currentWindow, currentValue.getTimestamp());
+            timestampCombiner.assign(
+                currentWindow, windowFn.getOutputTime(currentValue.getTimestamp(), currentWindow));
         combinedState = new Tuple2<>(accumT, windowTimestamp);
       } else {
         combinedState.f0 =
@@ -88,7 +91,11 @@ public class SingleWindowFlinkCombineRunner<K, InputT, AccumT, OutputT, W extend
         combinedState.f1 =
             timestampCombiner.combine(
                 combinedState.f1,
-                timestampCombiner.assign(currentWindow, currentValue.getTimestamp()));
+                timestampCombiner.assign(
+                    currentWindow,
+                    windowingStrategy
+                        .getWindowFn()
+                        .getOutputTime(currentValue.getTimestamp(), currentWindow)));
       }
     }
 
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/SortingFlinkCombineRunner.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/SortingFlinkCombineRunner.java
index 309e8312640..fa1ef044181 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/SortingFlinkCombineRunner.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/SortingFlinkCombineRunner.java
@@ -26,6 +26,7 @@ import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.sdk.transforms.windowing.IntervalWindow;
 import org.apache.beam.sdk.transforms.windowing.PaneInfo;
 import org.apache.beam.sdk.transforms.windowing.TimestampCombiner;
+import org.apache.beam.sdk.transforms.windowing.WindowFn;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.WindowingStrategy;
@@ -55,6 +56,7 @@ public class SortingFlinkCombineRunner<K, InputT, AccumT, OutputT, W extends Bou
     @SuppressWarnings("unchecked")
     TimestampCombiner timestampCombiner =
         (TimestampCombiner) windowingStrategy.getTimestampCombiner();
+    WindowFn<Object, W> windowFn = windowingStrategy.getWindowFn();
 
     // get all elements so that we can sort them, has to fit into
     // memory
@@ -88,7 +90,9 @@ public class SortingFlinkCombineRunner<K, InputT, AccumT, OutputT, W extends Bou
             key, firstValue, options, sideInputReader, currentValue.getWindows());
 
     // we use this to keep track of the timestamps assigned by the TimestampCombiner
-    Instant windowTimestamp = timestampCombiner.assign(currentWindow, currentValue.getTimestamp());
+    Instant windowTimestamp =
+        timestampCombiner.assign(
+            currentWindow, windowFn.getOutputTime(currentValue.getTimestamp(), currentWindow));
 
     while (iterator.hasNext()) {
       WindowedValue<KV<K, InputT>> nextValue = iterator.next();
@@ -104,7 +108,10 @@ public class SortingFlinkCombineRunner<K, InputT, AccumT, OutputT, W extends Bou
 
         windowTimestamp =
             timestampCombiner.combine(
-                windowTimestamp, timestampCombiner.assign(currentWindow, nextValue.getTimestamp()));
+                windowTimestamp,
+                timestampCombiner.assign(
+                    currentWindow,
+                    windowFn.getOutputTime(nextValue.getTimestamp(), currentWindow)));
 
       } else {
         // emit the value that we currently have
@@ -124,7 +131,9 @@ public class SortingFlinkCombineRunner<K, InputT, AccumT, OutputT, W extends Bou
         accumulator =
             flinkCombiner.firstInput(
                 key, value, options, sideInputReader, currentValue.getWindows());
-        windowTimestamp = timestampCombiner.assign(currentWindow, nextValue.getTimestamp());
+        windowTimestamp =
+            timestampCombiner.assign(
+                currentWindow, windowFn.getOutputTime(nextValue.getTimestamp(), currentWindow));
       }
     }
 
diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/BatchGroupAlsoByWindowAndCombineFn.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/BatchGroupAlsoByWindowAndCombineFn.java
index 12fd94e00f0..37b11362e16 100644
--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/BatchGroupAlsoByWindowAndCombineFn.java
+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/BatchGroupAlsoByWindowAndCombineFn.java
@@ -134,7 +134,11 @@ class BatchGroupAlsoByWindowAndCombineFn<K, InputT, AccumT, OutputT, W extends B
       Collection<W> windows = (Collection<W>) e.getWindows();
       for (W window : windows) {
         Instant outputTime =
-            windowingStrategy.getTimestampCombiner().assign(window, e.getTimestamp());
+            windowingStrategy
+                .getTimestampCombiner()
+                .assign(
+                    window,
+                    windowingStrategy.getWindowFn().getOutputTime(e.getTimestamp(), window));
         Instant accumulatorOutputTime = accumulatorOutputTimestamps.get(window);
         if (accumulatorOutputTime == null) {
           accumulatorOutputTimestamps.put(window, outputTime);
diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/BatchGroupAlsoByWindowViaIteratorsFn.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/BatchGroupAlsoByWindowViaIteratorsFn.java
index 9c16882f7c0..b3837136d47 100644
--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/BatchGroupAlsoByWindowViaIteratorsFn.java
+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/BatchGroupAlsoByWindowViaIteratorsFn.java
@@ -127,7 +127,11 @@ class BatchGroupAlsoByWindowViaIteratorsFn<K, V, W extends BoundedWindow>
           windows.put(window.maxTimestamp(), window);
           output.outputWindowedValue(
               KV.of(key, (Iterable<V>) new WindowReiterable<V>(iterator, window)),
-              strategy.getTimestampCombiner().assign(typedWindow, e.getTimestamp()),
+              strategy
+                  .getTimestampCombiner()
+                  .assign(
+                      typedWindow,
+                      strategy.getWindowFn().getOutputTime(e.getTimestamp(), typedWindow)),
               Arrays.asList(window),
               PaneInfo.ON_TIME_AND_ONLY_FIRING);
         }
diff --git a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/StreamingGroupAlsoByWindowFnsTest.java b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/StreamingGroupAlsoByWindowFnsTest.java
index bae006ea4f0..6f3fff27403 100644
--- a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/StreamingGroupAlsoByWindowFnsTest.java
+++ b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/StreamingGroupAlsoByWindowFnsTest.java
@@ -314,13 +314,16 @@ public class StreamingGroupAlsoByWindowFnsTest {
                 isKv(equalTo(KEY), containsInAnyOrder("v0", "v1")),
                 equalTo(new Instant(2)),
                 equalTo(window(-10, 10))),
+
+            // For this sliding window, the minimum output timestmap was 10, since we didn't want to
+            // overlap with the previous window that was [-10, 10).
             WindowMatchers.isSingleWindowedValue(
                 isKv(equalTo(KEY), containsInAnyOrder("v0", "v1", "v2")),
-                equalTo(new Instant(2)),
+                equalTo(window(-10, 10).maxTimestamp().plus(1)),
                 equalTo(window(0, 20))),
             WindowMatchers.isSingleWindowedValue(
                 isKv(equalTo(KEY), containsInAnyOrder("v2")),
-                equalTo(new Instant(15)),
+                equalTo(window(0, 20).maxTimestamp().plus(1)),
                 equalTo(window(10, 30)))));
   }
 
@@ -399,13 +402,16 @@ public class StreamingGroupAlsoByWindowFnsTest {
                 isKv(equalTo(KEY), emptyIterable()),
                 equalTo(window(-10, 10).maxTimestamp()),
                 equalTo(window(-10, 10))),
+
+            // For this sliding window, the minimum output timestmap was 10, since we didn't want to
+            // overlap with the previous window that was [-10, 10).
             WindowMatchers.isSingleWindowedValue(
                 isKv(equalTo(KEY), containsInAnyOrder("v0", "v1", "v2")),
-                equalTo(new Instant(2)),
+                equalTo(window(-10, 10).maxTimestamp().plus(1)),
                 equalTo(window(0, 20))),
             WindowMatchers.isSingleWindowedValue(
                 isKv(equalTo(KEY), containsInAnyOrder("v2")),
-                equalTo(new Instant(15)),
+                equalTo(window(0, 20).maxTimestamp().plus(1)),
                 equalTo(window(10, 30)))));
 
     long droppedValues =
diff --git a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/GroupAlsoByWindowProperties.java b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/GroupAlsoByWindowProperties.java
index 79c2b9a1a2e..e2cdfe43a5c 100644
--- a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/GroupAlsoByWindowProperties.java
+++ b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/GroupAlsoByWindowProperties.java
@@ -175,12 +175,14 @@ public class GroupAlsoByWindowProperties {
     TimestampedValue<KV<String, Iterable<String>>> item1 =
         getOnlyElementInWindow(result, window(0, 20));
     assertThat(item1.getValue().getValue(), containsInAnyOrder("v1", "v2"));
-    assertThat(item1.getTimestamp(), equalTo(new Instant(5)));
+    // Timestamp adjusted by WindowFn to exceed the end of the prior sliding window
+    assertThat(item1.getTimestamp(), equalTo(new Instant(10)));
 
     TimestampedValue<KV<String, Iterable<String>>> item2 =
         getOnlyElementInWindow(result, window(10, 30));
     assertThat(item2.getValue().getValue(), contains("v2"));
-    assertThat(item2.getTimestamp(), equalTo(new Instant(15)));
+    // Timestamp adjusted by WindowFn to exceed the end of the prior sliding window
+    assertThat(item2.getTimestamp(), equalTo(new Instant(20)));
   }
 
   /**
@@ -229,12 +231,14 @@ public class GroupAlsoByWindowProperties {
     TimestampedValue<KV<String, Long>> item1 = getOnlyElementInWindow(result, window(0, 20));
     assertThat(item1.getValue().getKey(), equalTo("k"));
     assertThat(item1.getValue().getValue(), equalTo(combineFn.apply(ImmutableList.of(1L, 2L, 4L))));
-    assertThat(item1.getTimestamp(), equalTo(new Instant(5L)));
+    // Timestamp adjusted by WindowFn to exceed the end of the prior sliding window
+    assertThat(item1.getTimestamp(), equalTo(new Instant(10L)));
 
     TimestampedValue<KV<String, Long>> item2 = getOnlyElementInWindow(result, window(10, 30));
     assertThat(item2.getValue().getKey(), equalTo("k"));
     assertThat(item2.getValue().getValue(), equalTo(combineFn.apply(ImmutableList.of(2L, 4L))));
-    assertThat(item2.getTimestamp(), equalTo(new Instant(15L)));
+    // Timestamp adjusted by WindowFn to exceed the end of the prior sliding window
+    assertThat(item2.getTimestamp(), equalTo(new Instant(20L)));
   }
 
   /**
diff --git a/runners/spark/2/src/main/java/org/apache/beam/runners/spark/structuredstreaming/translation/batch/AggregatorCombiner.java b/runners/spark/2/src/main/java/org/apache/beam/runners/spark/structuredstreaming/translation/batch/AggregatorCombiner.java
index d0f46ea807c..fd759d6bdad 100644
--- a/runners/spark/2/src/main/java/org/apache/beam/runners/spark/structuredstreaming/translation/batch/AggregatorCombiner.java
+++ b/runners/spark/2/src/main/java/org/apache/beam/runners/spark/structuredstreaming/translation/batch/AggregatorCombiner.java
@@ -161,7 +161,11 @@ class AggregatorCombiner<K, InputT, AccumT, OutputT, W extends BoundedWindow>
         Tuple2<AccumT, Instant> accumAndInstant =
             new Tuple2<>(
                 accumT,
-                timestampCombiner.assign(mergedWindowForAccumulator, accumulatorWv.getTimestamp()));
+                timestampCombiner.assign(
+                    mergedWindowForAccumulator,
+                    windowingStrategy
+                        .getWindowFn()
+                        .getOutputTime(accumulatorWv.getTimestamp(), mergedWindowForAccumulator)));
         if (mergedWindowToAccumulators.get(mergedWindowForAccumulator) == null) {
           mergedWindowToAccumulators.put(
               mergedWindowForAccumulator, Lists.newArrayList(accumAndInstant));
diff --git a/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/GroupNonMergingWindowsFunctions.java b/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/GroupNonMergingWindowsFunctions.java
index b75db5e0811..6b2bfe107dd 100644
--- a/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/GroupNonMergingWindowsFunctions.java
+++ b/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/GroupNonMergingWindowsFunctions.java
@@ -250,7 +250,13 @@ public class GroupNonMergingWindowsFunctions {
       @SuppressWarnings("unchecked")
       final W window = (W) Iterables.getOnlyElement(windowedValue.getWindows());
       final Instant timestamp =
-          windowingStrategy.getTimestampCombiner().assign(window, windowedValue.getTimestamp());
+          windowingStrategy
+              .getTimestampCombiner()
+              .assign(
+                  window,
+                  windowingStrategy
+                      .getWindowFn()
+                      .getOutputTime(windowedValue.getTimestamp(), window));
       // BEAM-7341: Elements produced by GbK are always ON_TIME and ONLY_FIRING
       return WindowedValue.of(
           KV.of(key, value), timestamp, window, PaneInfo.ON_TIME_AND_ONLY_FIRING);
diff --git a/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkCombineFn.java b/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkCombineFn.java
index b9fcb400ed2..9e9c574b4bb 100644
--- a/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkCombineFn.java
+++ b/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkCombineFn.java
@@ -204,7 +204,10 @@ public class SparkCombineFn<InputT, ValueT, AccumT, OutputT> implements Serializ
       BoundedWindow window = getWindow(value);
       SparkCombineContext ctx = context.ctxtForValue(value);
       TimestampCombiner combiner = context.windowingStrategy.getTimestampCombiner();
-      Instant windowTimestamp = combiner.assign(window, value.getTimestamp());
+      Instant windowTimestamp =
+          combiner.assign(
+              window,
+              context.windowingStrategy.getWindowFn().getOutputTime(value.getTimestamp(), window));
       final AccumT acc;
       final Instant timestamp;
       if (windowAccumulator == null) {
@@ -298,7 +301,10 @@ public class SparkCombineFn<InputT, ValueT, AccumT, OutputT> implements Serializ
         SparkCombineContext ctx = context.ctxtForValue(v);
         BoundedWindow window = getWindow(v);
         TimestampCombiner combiner = context.windowingStrategy.getTimestampCombiner();
-        Instant windowTimestamp = combiner.assign(window, v.getTimestamp());
+        Instant windowTimestamp =
+            combiner.assign(
+                window,
+                context.windowingStrategy.getWindowFn().getOutputTime(v.getTimestamp(), window));
         map.compute(
             window,
             (w, windowAccumulator) -> {
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/testing/WindowFnTestUtils.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/testing/WindowFnTestUtils.java
index 10c2d2517b2..83c60c0f01e 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/testing/WindowFnTestUtils.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/testing/WindowFnTestUtils.java
@@ -20,9 +20,12 @@ package org.apache.beam.sdk.testing;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -198,6 +201,96 @@ public class WindowFnTestUtils {
     }
   }
 
+  /**
+   * Assigns the given {@code timestamp} to windows using the specified {@code windowFn}, and
+   * verifies that result of {@code windowFn.getOutputTimestamp} for each window is within the
+   * proper bound.
+   */
+  public static <T, W extends BoundedWindow> void validateNonInterferingOutputTimes(
+      WindowFn<T, W> windowFn, long timestamp) throws Exception {
+    validateNonInterferingOutputTimesWithValue(
+        windowFn, TimestampedValue.of((T) null, new Instant(timestamp)));
+  }
+  /**
+   * Assigns the given {@code timestampedValue} to windows using the specified {@code windowFn}, and
+   * verifies that result of {@code windowFn.getOutputTimestamp} for each window is within the
+   * proper bound. This version allows passing a {@link TimestampedValue} in case the value is
+   * needed to assign windows.
+   */
+  public static <T, W extends BoundedWindow> void validateNonInterferingOutputTimesWithValue(
+      WindowFn<T, W> windowFn, TimestampedValue<T> timestampedValue) throws Exception {
+    Collection<W> windows = assignedWindowsWithValue(windowFn, timestampedValue);
+
+    Instant instant = timestampedValue.getTimestamp();
+    for (W window : windows) {
+      Instant outputTimestamp = windowFn.getOutputTime(instant, window);
+      assertFalse(
+          "getOutputTime must be greater than or equal to input timestamp",
+          outputTimestamp.isBefore(instant));
+      assertFalse(
+          "getOutputTime must be less than or equal to the max timestamp",
+          outputTimestamp.isAfter(window.maxTimestamp()));
+    }
+  }
+
+  /**
+   * Assigns the given {@code timestamp} to windows using the specified {@code windowFn}, and
+   * verifies that result of {@link WindowFn#getOutputTime windowFn.getOutputTime} for later windows
+   * (as defined by {@code maxTimestamp} won't prevent the watermark from passing the end of earlier
+   * windows.
+   *
+   * <p>This verifies that overlapping windows don't interfere at all. Depending on the {@code
+   * windowFn} this may be stricter than desired.
+   */
+  public static <T, W extends BoundedWindow> void validateGetOutputTimestamp(
+      WindowFn<T, W> windowFn, long timestamp) throws Exception {
+    validateGetOutputTimestampWithValue(
+        windowFn, TimestampedValue.of((T) null, new Instant(timestamp)));
+  }
+
+  /**
+   * Assigns the given {@code timestampedValue} to windows using the specified {@code windowFn}, and
+   * verifies that result of {@link WindowFn#getOutputTime windowFn.getOutputTime} for later windows
+   * (as defined by {@code maxTimestamp} won't prevent the watermark from passing the end of earlier
+   * windows.
+   *
+   * <p>This verifies that overlapping windows don't interfere at all. Depending on the {@code
+   * windowFn} this may be stricter than desired. This version allows passing a {@link
+   * TimestampedValue} in case the value is needed to assign windows.
+   */
+  public static <T, W extends BoundedWindow> void validateGetOutputTimestampWithValue(
+      WindowFn<T, W> windowFn, TimestampedValue<T> timestampedValue) throws Exception {
+    Collection<W> windows = assignedWindowsWithValue(windowFn, timestampedValue);
+    List<W> sortedWindows = new ArrayList<>(windows);
+    sortedWindows.sort(Comparator.comparing(BoundedWindow::maxTimestamp));
+
+    Instant instant = timestampedValue.getTimestamp();
+    Instant endOfPrevious = null;
+    for (W window : sortedWindows) {
+      Instant outputTimestamp = windowFn.getOutputTime(instant, window);
+      if (endOfPrevious == null) {
+        // If this is the first window, the output timestamp can be anything, as long as it is in
+        // the valid range.
+        assertFalse(
+            "getOutputTime must be greater than or equal to input timestamp",
+            outputTimestamp.isBefore(instant));
+        assertFalse(
+            "getOutputTime must be less than or equal to the max timestamp",
+            outputTimestamp.isAfter(window.maxTimestamp()));
+      } else {
+        // If this is a later window, the output timestamp must be after the end of the previous
+        // window
+        assertTrue(
+            "getOutputTime must be greater than the end of the previous window",
+            outputTimestamp.isAfter(endOfPrevious));
+        assertFalse(
+            "getOutputTime must be less than or equal to the max timestamp",
+            outputTimestamp.isAfter(window.maxTimestamp()));
+      }
+      endOfPrevious = window.maxTimestamp();
+    }
+  }
+
   /**
    * Verifies that later-ending merged windows from any of the timestamps hold up output of
    * earlier-ending windows, using the provided {@link WindowFn} and {@link TimestampCombiner}.
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/GlobalWindows.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/GlobalWindows.java
index d15ffa8242c..db07b15fe01 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/GlobalWindows.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/GlobalWindows.java
@@ -22,6 +22,7 @@ import java.util.Collection;
 import java.util.Collections;
 import org.apache.beam.sdk.coders.Coder;
 import org.checkerframework.checker.nullness.qual.Nullable;
+import org.joda.time.Instant;
 
 /**
  * A {@link WindowFn} that assigns all data to the same window.
@@ -76,6 +77,11 @@ public class GlobalWindows extends NonMergingWindowFn<Object, GlobalWindow> {
     }
   }
 
+  @Override
+  public Instant getOutputTime(Instant inputTimestamp, GlobalWindow window) {
+    return inputTimestamp;
+  }
+
   @Override
   public boolean assignsToOneWindow() {
     return true;
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/PartitioningWindowFn.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/PartitioningWindowFn.java
index ae36a4bf59d..b4f8a4660d2 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/PartitioningWindowFn.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/PartitioningWindowFn.java
@@ -52,6 +52,11 @@ public abstract class PartitioningWindowFn<T, W extends BoundedWindow>
     };
   }
 
+  @Override
+  public Instant getOutputTime(Instant inputTimestamp, W window) {
+    return inputTimestamp;
+  }
+
   @Override
   public final boolean assignsToOneWindow() {
     return true;
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/SlidingWindows.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/SlidingWindows.java
index 5bbc2c9a720..acc01a02bd8 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/SlidingWindows.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/SlidingWindows.java
@@ -21,6 +21,8 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Objects;
+import org.apache.beam.sdk.annotations.Experimental;
+import org.apache.beam.sdk.annotations.Experimental.Kind;
 import org.apache.beam.sdk.coders.Coder;
 import org.apache.beam.sdk.transforms.display.DisplayData;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -196,6 +198,21 @@ public class SlidingWindows extends NonMergingWindowFn<Object, IntervalWindow> {
     return offset;
   }
 
+  /**
+   * Ensures that later sliding windows have an output time that is past the end of earlier windows.
+   *
+   * <p>If this is the earliest sliding window containing {@code inputTimestamp}, that's fine.
+   * Otherwise, we pick the earliest time that doesn't overlap with earlier windows.
+   */
+  @Experimental(Kind.OUTPUT_TIME)
+  @Override
+  public Instant getOutputTime(Instant inputTimestamp, IntervalWindow window) {
+    Instant startOfLastSegment = window.maxTimestamp().minus(period);
+    return startOfLastSegment.isBefore(inputTimestamp)
+        ? inputTimestamp
+        : startOfLastSegment.plus(1);
+  }
+
   @Override
   public boolean equals(@Nullable Object object) {
     if (!(object instanceof SlidingWindows)) {
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/WindowFn.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/WindowFn.java
index e9a348362c0..869bd868c82 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/WindowFn.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/windowing/WindowFn.java
@@ -19,6 +19,8 @@ package org.apache.beam.sdk.transforms.windowing;
 
 import java.io.Serializable;
 import java.util.Collection;
+import org.apache.beam.sdk.annotations.Experimental;
+import org.apache.beam.sdk.annotations.Experimental.Kind;
 import org.apache.beam.sdk.coders.Coder;
 import org.apache.beam.sdk.transforms.display.DisplayData;
 import org.apache.beam.sdk.transforms.display.HasDisplayData;
@@ -122,6 +124,27 @@ public abstract class WindowFn<T, W extends BoundedWindow> implements Serializab
    */
   public abstract WindowMappingFn<W> getDefaultWindowMappingFn();
 
+  /**
+   * Returns the output timestamp to use for data depending on the given {@code inputTimestamp} in
+   * the specified {@code window}.
+   *
+   * <p>The result of this method must be between {@code inputTimestamp} and {@code
+   * window.maxTimestamp()} (inclusive on both sides).
+   *
+   * <p>This function must be monotonic across input timestamps. Specifically, if {@code A < B},
+   * then {@code getOutputTime(A, window) <= getOutputTime(B, window)}.
+   *
+   * <p>For a {@link WindowFn} that doesn't produce overlapping windows, this can (and typically
+   * should) just return {@code inputTimestamp}. In the presence of overlapping windows, it is
+   * suggested that the result in later overlapping windows is past the end of earlier windows so
+   * that the later windows don't prevent the watermark from progressing past the end of the earlier
+   * window.
+   */
+  @Experimental(Kind.OUTPUT_TIME)
+  public Instant getOutputTime(Instant inputTimestamp, W window) {
+    return inputTimestamp;
+  }
+
   /** Returns true if this {@code WindowFn} never needs to merge any windows. */
   public boolean isNonMerging() {
     return false;
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/util/IdentityWindowFn.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/util/IdentityWindowFn.java
index ca78dc60f2f..c9cda579a92 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/util/IdentityWindowFn.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/util/IdentityWindowFn.java
@@ -30,6 +30,7 @@ import org.apache.beam.sdk.transforms.windowing.Window;
 import org.apache.beam.sdk.transforms.windowing.WindowFn;
 import org.apache.beam.sdk.transforms.windowing.WindowMappingFn;
 import org.apache.beam.sdk.values.PCollection;
+import org.joda.time.Instant;
 
 /**
  * A {@link WindowFn} that leaves all associations between elements and windows unchanged.
@@ -105,6 +106,11 @@ public class IdentityWindowFn<T> extends NonMergingWindowFn<T, BoundedWindow> {
             getClass().getCanonicalName()));
   }
 
+  @Override
+  public Instant getOutputTime(Instant inputTimestamp, BoundedWindow window) {
+    return inputTimestamp;
+  }
+
   @Override
   public boolean assignsToOneWindow() {
     return true;
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/FixedWindowsTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/FixedWindowsTest.java
index 3dd7c28a348..c3c9db0897c 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/FixedWindowsTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/FixedWindowsTest.java
@@ -32,6 +32,7 @@ import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
+import org.apache.beam.sdk.testing.WindowFnTestUtils;
 import org.apache.beam.sdk.transforms.display.DisplayData;
 import org.joda.time.Duration;
 import org.joda.time.Instant;
@@ -157,6 +158,13 @@ public class FixedWindowsTest {
     FixedWindows.of(new Duration(10)).verifyCompatibility(FixedWindows.of(new Duration(20)));
   }
 
+  @Test
+  public void testValidOutputTimes() throws Exception {
+    for (long timestamp : Arrays.asList(200, 800, 700)) {
+      WindowFnTestUtils.validateGetOutputTimestamp(FixedWindows.of(new Duration(500)), timestamp);
+    }
+  }
+
   @Test
   public void testDisplayData() {
     Duration offset = Duration.standardSeconds(1234);
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/SessionsTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/SessionsTest.java
index 9d05cee7f67..4183dd5f686 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/SessionsTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/SessionsTest.java
@@ -114,6 +114,15 @@ public class SessionsTest {
         .verifyCompatibility(FixedWindows.of(new Duration(10)));
   }
 
+  /** Validates that the output timestamp for aggregate data falls within the acceptable range. */
+  @Test
+  public void testValidOutputTimes() throws Exception {
+    for (long timestamp : Arrays.asList(200, 800, 700)) {
+      WindowFnTestUtils.validateGetOutputTimestamp(
+          Sessions.withGapDuration(Duration.millis(500)), timestamp);
+    }
+  }
+
   /**
    * Test to confirm that {@link Sessions} with the default {@link TimestampCombiner} holds up the
    * watermark potentially indefinitely.
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/SlidingWindowsTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/SlidingWindowsTest.java
index 3418b19b8eb..d9a9fe28832 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/SlidingWindowsTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/SlidingWindowsTest.java
@@ -31,6 +31,7 @@ import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
+import org.apache.beam.sdk.testing.WindowFnTestUtils;
 import org.apache.beam.sdk.transforms.display.DisplayData;
 import org.joda.time.Duration;
 import org.joda.time.Instant;
@@ -189,6 +190,22 @@ public class SlidingWindowsTest {
         mapping.getSideInputWindow(new IntervalWindow(new Instant(0), new Instant(1341))));
   }
 
+  @Test
+  public void testValidOutputTimes() throws Exception {
+    for (long timestamp : Arrays.asList(200, 800, 499, 500, 501, 700, 1000)) {
+      WindowFnTestUtils.validateGetOutputTimestamp(
+          SlidingWindows.of(new Duration(1000)).every(new Duration(500)), timestamp);
+    }
+  }
+
+  @Test
+  public void testOutputTimesNonInterference() throws Exception {
+    for (long timestamp : Arrays.asList(200, 800, 700)) {
+      WindowFnTestUtils.validateNonInterferingOutputTimes(
+          SlidingWindows.of(new Duration(1000)).every(new Duration(500)), timestamp);
+    }
+  }
+
   @Test
   public void testDisplayData() {
     Duration windowSize = Duration.standardSeconds(1234);
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/WindowingTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/WindowingTest.java
index 3a447f0d72d..c9756153501 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/WindowingTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/windowing/WindowingTest.java
@@ -142,10 +142,10 @@ public class WindowingTest implements Serializable {
     PAssert.that(output)
         .containsInAnyOrder(
             output("a", 1, 1, -5, 5),
-            output("a", 2, 1, 0, 10),
-            output("a", 1, 7, 5, 15),
+            output("a", 2, 5, 0, 10),
+            output("a", 1, 10, 5, 15),
             output("b", 1, 8, 0, 10),
-            output("b", 1, 8, 5, 15));
+            output("b", 1, 10, 5, 15));
 
     p.run();
   }
diff --git a/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryIOWriteTest.java b/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryIOWriteTest.java
index 0e7eab6260f..59a5bc85b6a 100644
--- a/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryIOWriteTest.java
+++ b/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryIOWriteTest.java
@@ -1166,6 +1166,11 @@ public class BigQueryIOWriteTest implements Serializable {
       throw new UnsupportedOperationException(
           "PartitionedGlobalWindows is not allowed in side inputs");
     }
+
+    @Override
+    public Instant getOutputTime(Instant inputTimestamp, PartitionedGlobalWindow window) {
+      return inputTimestamp;
+    }
   }
 
   /** Custom Window object that encodes a String value. */
diff --git a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/WinningBids.java b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/WinningBids.java
index 684924458e4..4fb34764a72 100644
--- a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/WinningBids.java
+++ b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/WinningBids.java
@@ -283,6 +283,29 @@ public class WinningBids extends PTransform<PCollection<Event>, PCollection<Auct
     public WindowMappingFn<AuctionOrBidWindow> getDefaultWindowMappingFn() {
       throw new UnsupportedOperationException("AuctionWindowFn not supported for side inputs");
     }
+
+    /**
+     * Below we will GBK auctions and bids on their auction ids. Then we will reduce those per id to
+     * emit {@code (auction, winning bid)} pairs for auctions which have expired with at least one
+     * valid bid. We would like those output pairs to have a timestamp of the auction's expiry
+     * (since that's the earliest we know for sure we have the correct winner). We would also like
+     * to make that winning results are available to following stages at the auction's expiry.
+     *
+     * <p>Each result of the GBK will have a timestamp of the min of the result of this object's
+     * assignOutputTime over all records which end up in one of its iterables. Thus we get the
+     * desired behavior if we ignore each record's timestamp and always return the auction window's
+     * 'maxTimestamp', which will correspond to the auction's expiry.
+     *
+     * <p>In contrast, if this object's assignOutputTime were to return 'inputTimestamp' (the usual
+     * implementation), then each GBK record will take as its timestamp the minimum of the
+     * timestamps of all bids and auctions within it, which will always be the auction's timestamp.
+     * An auction which expires well into the future would thus hold up the watermark of the GBK
+     * results until that auction expired. That in turn would hold up all winning pairs.
+     */
+    @Override
+    public Instant getOutputTime(Instant inputTimestamp, AuctionOrBidWindow window) {
+      return window.maxTimestamp();
+    }
   }
 
   private final AuctionOrBidWindowFn auctionOrBidWindowFn;
