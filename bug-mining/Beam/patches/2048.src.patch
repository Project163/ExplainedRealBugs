diff --git a/sdks/python/apache_beam/examples/snippets/transforms/aggregation/groupby_test.py b/sdks/python/apache_beam/examples/snippets/transforms/aggregation/groupby_test.py
index 02e05f8499b..879446a6962 100644
--- a/sdks/python/apache_beam/examples/snippets/transforms/aggregation/groupby_test.py
+++ b/sdks/python/apache_beam/examples/snippets/transforms/aggregation/groupby_test.py
@@ -48,13 +48,16 @@ class UnorderedList(object):
   def __hash__(self):
     return hash(tuple(sorted(self._contents)))
 
+  def __repr__(self):
+    return 'UnorderedList(%r)' % self._contents
+
 
 def normalize(x):
   if isinstance(x, tuple) and hasattr(x, '_fields'):
     # A named tuple.
     return beam.Row(**dict(zip(x._fields, x)))
   elif isinstance(x, typing.Iterable) and not isinstance(x, (str, beam.Row)):
-    return UnorderedList(x)
+    return UnorderedList(normalize(e) for e in x)
   else:
     return x
 
diff --git a/sdks/python/apache_beam/pvalue.py b/sdks/python/apache_beam/pvalue.py
index 2624d9d514b..5196525a643 100644
--- a/sdks/python/apache_beam/pvalue.py
+++ b/sdks/python/apache_beam/pvalue.py
@@ -660,6 +660,9 @@ class Row(object):
   def __init__(self, **kwargs):
     self.__dict__.update(kwargs)
 
+  def as_dict(self):
+    return dict(self.__dict__)
+
   def __iter__(self):
     for _, value in sorted(self.__dict__.items()):
       yield value
diff --git a/sdks/python/apache_beam/transforms/core.py b/sdks/python/apache_beam/transforms/core.py
index 92756c5a74b..b27f55a08be 100644
--- a/sdks/python/apache_beam/transforms/core.py
+++ b/sdks/python/apache_beam/transforms/core.py
@@ -102,6 +102,7 @@ __all__ = [
     'CombineValues',
     'GroupBy',
     'GroupByKey',
+    'Select',
     'Partition',
     'Windowing',
     'WindowInto',
@@ -2519,6 +2520,45 @@ class _GroupAndAggregate(PTransform):
             (*(key + value))))
 
 
+class Select(PTransform):
+  """Converts the elements of a PCollection into a schema'd PCollection of Rows.
+
+  `Select(...)` is roughly equivalent to `Map(lambda x: Row(...))` where each
+  argument (which may be a string or callable) of `ToRow` is applied to `x`.
+  For example,
+
+      pcoll | beam.Select('a', b=lambda x: foo(x))
+
+  is the same as
+
+      pcoll | beam.Map(lambda x: beam.Row(a=x.a, b=foo(x)))
+  """
+  def __init__(self,
+               *args,  # type: typing.Union[str, callable]
+               **kwargs  # type: typing.Union[str, callable]
+               ):
+    self._fields = [(
+        expr if isinstance(expr, str) else 'arg%02d' % ix,
+        _expr_to_callable(expr, ix)) for (ix, expr) in enumerate(args)
+                    ] + [(name, _expr_to_callable(expr, name))
+                         for (name, expr) in kwargs.items()]
+
+  def default_label(self):
+    return 'ToRows(%s)' % ', '.join(name for name, _ in self._fields)
+
+  def expand(self, pcoll):
+    return pcoll | Map(
+        lambda x: pvalue.Row(**{name: expr(x)
+                                for name, expr in self._fields}))
+
+  def infer_output_type(self, input_type):
+    from apache_beam.typehints import row_type
+    return row_type.RowTypeConstraint([
+        (name, trivial_inference.infer_return_type(expr, [input_type]))
+        for (name, expr) in self._fields
+    ])
+
+
 class Partition(PTransformWithSideInputs):
   """Split a PCollection into several partitions.
 
diff --git a/sdks/python/apache_beam/transforms/ptransform_test.py b/sdks/python/apache_beam/transforms/ptransform_test.py
index 2238013fa9f..d32b8c0a0c3 100644
--- a/sdks/python/apache_beam/transforms/ptransform_test.py
+++ b/sdks/python/apache_beam/transforms/ptransform_test.py
@@ -896,6 +896,36 @@ class TestGroupBy(unittest.TestCase):
           ]))
 
 
+class SelectTest(unittest.TestCase):
+  def test_simple(self):
+    with TestPipeline() as p:
+      rows = (
+          p | beam.Create([1, 2, 10])
+          | beam.Select(a=lambda x: x * x, b=lambda x: -x))
+
+      assert_that(
+          rows,
+          equal_to([
+              beam.Row(a=1, b=-1),
+              beam.Row(a=4, b=-2),
+              beam.Row(a=100, b=-10),
+          ]),
+          label='CheckFromLambdas')
+
+      from_attr = rows | beam.Select('b', z='a')
+      assert_that(
+          from_attr,
+          equal_to([
+              beam.Row(b=-1, z=1),
+              beam.Row(b=-2, z=4),
+              beam.Row(
+                  b=-10,
+                  z=100,
+              ),
+          ]),
+          label='CheckFromAttrs')
+
+
 @beam.ptransform_fn
 def SamplePTransform(pcoll):
   """Sample transform using the @ptransform_fn decorator."""
diff --git a/sdks/python/apache_beam/typehints/opcodes.py b/sdks/python/apache_beam/typehints/opcodes.py
index 17c62a5184b..8ba2c913df3 100644
--- a/sdks/python/apache_beam/typehints/opcodes.py
+++ b/sdks/python/apache_beam/typehints/opcodes.py
@@ -39,6 +39,7 @@ from functools import reduce
 
 from past.builtins import unicode
 
+from apache_beam.typehints import row_type
 from apache_beam.typehints import typehints
 from apache_beam.typehints.trivial_inference import BoundMethod
 from apache_beam.typehints.trivial_inference import Const
@@ -297,8 +298,12 @@ def load_attr(state, arg):
   """
   o = state.stack.pop()
   name = state.get_name(arg)
+  state.stack.append(_getattr(o, name))
+
+
+def _getattr(o, name):
   if isinstance(o, Const) and hasattr(o.value, name):
-    state.stack.append(Const(getattr(o.value, name)))
+    return Const(getattr(o.value, name))
   elif (inspect.isclass(o) and
         isinstance(getattr(o, name, None),
                    (types.MethodType, types.FunctionType))):
@@ -307,9 +312,11 @@ def load_attr(state, arg):
       func = getattr(o, name).__func__
     else:
       func = getattr(o, name)  # Python 3 has no unbound methods
-    state.stack.append(Const(BoundMethod(func, o)))
+    return Const(BoundMethod(func, o))
+  elif isinstance(o, row_type.RowTypeConstraint):
+    return o.get_type_for(name)
   else:
-    state.stack.append(Any)
+    return Any
 
 
 def load_method(state, arg):
diff --git a/sdks/python/apache_beam/typehints/row_type.py b/sdks/python/apache_beam/typehints/row_type.py
index 6a09db8130e..715297a8996 100644
--- a/sdks/python/apache_beam/typehints/row_type.py
+++ b/sdks/python/apache_beam/typehints/row_type.py
@@ -51,3 +51,6 @@ class RowTypeConstraint(typehints.TypeConstraint):
     return 'Row(%s)' % ', '.join(
         '%s=%s' % (name, typehints._unified_repr(t)) for name,
         t in self._fields)
+
+  def get_type_for(self, name):
+    return dict(self._fields)[name]
diff --git a/sdks/python/apache_beam/typehints/trivial_inference.py b/sdks/python/apache_beam/typehints/trivial_inference.py
index 99a045c02f0..038ba8f455c 100644
--- a/sdks/python/apache_beam/typehints/trivial_inference.py
+++ b/sdks/python/apache_beam/typehints/trivial_inference.py
@@ -35,6 +35,7 @@ from builtins import object
 from builtins import zip
 from functools import reduce
 
+from apache_beam import pvalue
 from apache_beam.typehints import Any
 from apache_beam.typehints import row_type
 from apache_beam.typehints import typehints
@@ -58,6 +59,10 @@ def instance_to_type(o):
   t = type(o)
   if o is None:
     return type(None)
+  elif t == pvalue.Row:
+    return row_type.RowTypeConstraint([
+        (name, instance_to_type(value)) for name, value in o.as_dict().items()
+    ])
   elif t not in typehints.DISALLOWED_PRIMITIVE_TYPES:
     # pylint: disable=deprecated-types-field
     if sys.version_info[0] == 2 and t == types.InstanceType:
@@ -320,6 +325,10 @@ def infer_return_type(c, input_types, debug=False, depth=5):
             dict: typehints.Dict[Any, Any]
         }[c]
       return c
+    elif (c == getattr and len(input_types) == 2 and
+          isinstance(input_types[1], Const)):
+      from apache_beam.typehints import opcodes
+      return opcodes._getattr(input_types[0], input_types[1].value)
     else:
       return Any
   except TypeInferenceError:
diff --git a/sdks/python/apache_beam/typehints/trivial_inference_test.py b/sdks/python/apache_beam/typehints/trivial_inference_test.py
index 8aafa57adb3..3f33490ece7 100644
--- a/sdks/python/apache_beam/typehints/trivial_inference_test.py
+++ b/sdks/python/apache_beam/typehints/trivial_inference_test.py
@@ -361,6 +361,7 @@ class TrivialInferenceTest(unittest.TestCase):
         (MyClass, MyClass()),
         (type(MyClass.method), MyClass.method),
         (types.MethodType, MyClass().method),
+        (row_type.RowTypeConstraint([('x', int)]), beam.Row(x=37)),
     ]
     for expected_type, instance in test_cases:
       self.assertEqual(
@@ -377,6 +378,12 @@ class TrivialInferenceTest(unittest.TestCase):
         row_type.RowTypeConstraint([('x', int), ('y', str)]),
         lambda x: beam.Row(x=x, y=str(x)), [int])
 
+  def testRowAttr(self):
+    self.assertReturnType(
+        typehints.Tuple[int, str],
+        lambda row: (row.x, getattr(row, 'y')),
+        [row_type.RowTypeConstraint([('x', int), ('y', str)])])
+
 
 if __name__ == '__main__':
   unittest.main()
diff --git a/sdks/python/apache_beam/typehints/typehints.py b/sdks/python/apache_beam/typehints/typehints.py
index 7297e11249f..3920d810338 100644
--- a/sdks/python/apache_beam/typehints/typehints.py
+++ b/sdks/python/apache_beam/typehints/typehints.py
@@ -1047,7 +1047,8 @@ class IteratorHint(CompositeTypeHint):
 IteratorTypeConstraint = IteratorHint.IteratorTypeConstraint
 
 
-class WindowedTypeConstraint(with_metaclass(GetitemConstructor, TypeConstraint)):  # type: ignore[misc]
+class WindowedTypeConstraint(with_metaclass(GetitemConstructor, TypeConstraint)
+                             ):  # type: ignore[misc]
   """A type constraint for WindowedValue objects.
 
   Mostly for internal use.
