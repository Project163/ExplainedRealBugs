diff --git a/playground/backend/cmd/server/controller.go b/playground/backend/cmd/server/controller.go
index ec24c94bef9..c42823462c6 100644
--- a/playground/backend/cmd/server/controller.go
+++ b/playground/backend/cmd/server/controller.go
@@ -59,7 +59,7 @@ func (controller *playgroundController) RunCode(ctx context.Context, info *pb.Ru
 	cacheExpirationTime := controller.env.ApplicationEnvs.CacheEnvs().KeyExpirationTime()
 	pipelineId := uuid.New()
 
-	lc, err := life_cycle.Setup(info.Sdk, info.Code, pipelineId, controller.env.ApplicationEnvs.WorkingDir())
+	lc, err := life_cycle.Setup(info.Sdk, info.Code, pipelineId, controller.env.ApplicationEnvs.WorkingDir(), controller.env.BeamSdkEnvs.PreparedModDir())
 	if err != nil {
 		logger.Errorf("RunCode(): error during setup file system: %s\n", err.Error())
 		return nil, errors.InternalError("Run code", "Error during setup file system: "+err.Error())
@@ -68,10 +68,12 @@ func (controller *playgroundController) RunCode(ctx context.Context, info *pb.Ru
 	compileBuilder, err := compile_builder.Setup(lc.GetAbsoluteSourceFilePath(), lc.GetAbsoluteBaseFolderPath(), info.Sdk, controller.env.BeamSdkEnvs.ExecutorConfig)
 	if err != nil {
 		logger.Errorf("RunCode(): error during setup run builder: %s\n", err.Error())
+		code_processing.DeleteFolders(pipelineId, lc)
 		return nil, errors.InvalidArgumentError("Run code", "Error during setup compile builder: "+err.Error())
 	}
 
 	if err = utils.SetToCache(ctx, controller.cacheService, pipelineId, cache.Status, pb.Status_STATUS_VALIDATING); err != nil {
+		code_processing.DeleteFolders(pipelineId, lc)
 		return nil, errors.InternalError("Run code()", "Error during set value to cache: "+err.Error())
 	}
 	if err = utils.SetToCache(ctx, controller.cacheService, pipelineId, cache.RunOutputIndex, 0); err != nil {
@@ -79,6 +81,7 @@ func (controller *playgroundController) RunCode(ctx context.Context, info *pb.Ru
 	}
 	if err = controller.cacheService.SetExpTime(ctx, pipelineId, cacheExpirationTime); err != nil {
 		logger.Errorf("%s: RunCode(): cache.SetExpTime(): %s\n", pipelineId, err.Error())
+		code_processing.DeleteFolders(pipelineId, lc)
 		return nil, errors.InternalError("Run code()", "Error during set expiration to cache: "+err.Error())
 	}
 
diff --git a/playground/backend/internal/code_processing/code_processing.go b/playground/backend/internal/code_processing/code_processing.go
index 0763cfe3581..26de6676f77 100644
--- a/playground/backend/internal/code_processing/code_processing.go
+++ b/playground/backend/internal/code_processing/code_processing.go
@@ -47,7 +47,7 @@ func Process(ctx context.Context, cacheService cache.Cache, lc *fs_tool.LifeCycl
 	ctxWithTimeout, finishCtxFunc := context.WithTimeout(ctx, appEnv.PipelineExecuteTimeout())
 	defer func(lc *fs_tool.LifeCycle) {
 		finishCtxFunc()
-		deleteFolders(pipelineId, lc)
+		DeleteFolders(pipelineId, lc)
 	}(lc)
 
 	errorChannel := make(chan error, 1)
@@ -235,8 +235,8 @@ func cancelCheck(ctx context.Context, pipelineId uuid.UUID, cancelChannel chan b
 	}
 }
 
-// deleteFolders removes all prepared folders for received LifeCycle
-func deleteFolders(pipelineId uuid.UUID, lc *fs_tool.LifeCycle) {
+// DeleteFolders removes all prepared folders for received LifeCycle
+func DeleteFolders(pipelineId uuid.UUID, lc *fs_tool.LifeCycle) {
 	logger.Infof("%s: DeleteFolders() ...\n", pipelineId)
 	if err := lc.DeleteFolders(); err != nil {
 		logger.Error("%s: DeleteFolders(): %s\n", pipelineId, err.Error())
diff --git a/playground/backend/internal/environment/beam.go b/playground/backend/internal/environment/beam.go
index e6af17869ab..e05b16525bb 100644
--- a/playground/backend/internal/environment/beam.go
+++ b/playground/backend/internal/environment/beam.go
@@ -40,9 +40,15 @@ func NewExecutorConfig(compileCmd string, runCmd string, compileArgs []string, r
 type BeamEnvs struct {
 	ApacheBeamSdk  pb.Sdk
 	ExecutorConfig *ExecutorConfig
+	preparedModDir string
 }
 
 // NewBeamEnvs is a BeamEnvs constructor
-func NewBeamEnvs(apacheBeamSdk pb.Sdk, executorConfig *ExecutorConfig) *BeamEnvs {
-	return &BeamEnvs{ApacheBeamSdk: apacheBeamSdk, ExecutorConfig: executorConfig}
+func NewBeamEnvs(apacheBeamSdk pb.Sdk, executorConfig *ExecutorConfig, preparedModDir string) *BeamEnvs {
+	return &BeamEnvs{ApacheBeamSdk: apacheBeamSdk, ExecutorConfig: executorConfig, preparedModDir: preparedModDir}
+}
+
+// PreparedModDir returns the path to the directory where prepared go.mod and go.sum are located
+func (b *BeamEnvs) PreparedModDir() string {
+	return b.preparedModDir
 }
diff --git a/playground/backend/internal/environment/beam_test.go b/playground/backend/internal/environment/beam_test.go
new file mode 100644
index 00000000000..53b515b6c4c
--- /dev/null
+++ b/playground/backend/internal/environment/beam_test.go
@@ -0,0 +1,57 @@
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements.  See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package environment
+
+import (
+	playground "beam.apache.org/playground/backend/internal/api/v1"
+	"testing"
+)
+
+func TestBeamEnvs_PreparedModDir(t *testing.T) {
+	preparedModDir := "testModDir"
+	type fields struct {
+		ApacheBeamSdk  playground.Sdk
+		ExecutorConfig *ExecutorConfig
+		preparedModDir string
+	}
+	tests := []struct {
+		name   string
+		fields fields
+		want   string
+	}{
+		{
+			name: "get path to prepared directory of the go.mod",
+			fields: fields{
+				ApacheBeamSdk:  0,
+				ExecutorConfig: nil,
+				preparedModDir: preparedModDir,
+			},
+			want: preparedModDir,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			b := &BeamEnvs{
+				ApacheBeamSdk:  tt.fields.ApacheBeamSdk,
+				ExecutorConfig: tt.fields.ExecutorConfig,
+				preparedModDir: tt.fields.preparedModDir,
+			}
+			if got := b.PreparedModDir(); got != tt.want {
+				t.Errorf("PreparedModDir() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/playground/backend/internal/environment/environment_service.go b/playground/backend/internal/environment/environment_service.go
index 78b90b548d0..8d3d4273ba5 100644
--- a/playground/backend/internal/environment/environment_service.go
+++ b/playground/backend/internal/environment/environment_service.go
@@ -33,6 +33,7 @@ const (
 	serverPortKey                 = "SERVER_PORT"
 	beamSdkKey                    = "BEAM_SDK"
 	workingDirKey                 = "APP_WORK_DIR"
+	preparedModDirKey             = "PREPARED_MOD_DIR"
 	cacheTypeKey                  = "CACHE_TYPE"
 	cacheAddressKey               = "CACHE_ADDRESS"
 	beamPathKey                   = "BEAM_PATH"
@@ -139,6 +140,7 @@ func GetNetworkEnvsFromOsEnvs() (*NetworkEnvs, error) {
 // Configures ExecutorConfig with config file.
 func ConfigureBeamEnvs(workDir string) (*BeamEnvs, error) {
 	sdk := pb.Sdk_SDK_UNSPECIFIED
+	preparedModDir, modDirExist := os.LookupEnv(preparedModDirKey)
 	if value, present := os.LookupEnv(beamSdkKey); present {
 
 		switch value {
@@ -146,6 +148,9 @@ func ConfigureBeamEnvs(workDir string) (*BeamEnvs, error) {
 			sdk = pb.Sdk_SDK_JAVA
 		case pb.Sdk_SDK_GO.String():
 			sdk = pb.Sdk_SDK_GO
+			if !modDirExist {
+				return nil, errors.New("env PREPARED_MOD_DIR must be specified in the environment variables for GO sdk")
+			}
 		case pb.Sdk_SDK_PYTHON.String():
 			sdk = pb.Sdk_SDK_PYTHON
 		case pb.Sdk_SDK_SCIO.String():
@@ -160,7 +165,7 @@ func ConfigureBeamEnvs(workDir string) (*BeamEnvs, error) {
 	if err != nil {
 		return nil, err
 	}
-	return NewBeamEnvs(sdk, executorConfig), nil
+	return NewBeamEnvs(sdk, executorConfig, preparedModDir), nil
 }
 
 // createExecutorConfig creates ExecutorConfig that corresponds to specific Apache Beam SDK.
diff --git a/playground/backend/internal/environment/environment_service_test.go b/playground/backend/internal/environment/environment_service_test.go
index 0b2f1c0c5fc..f61a135d3c9 100644
--- a/playground/backend/internal/environment/environment_service_test.go
+++ b/playground/backend/internal/environment/environment_service_test.go
@@ -72,13 +72,14 @@ func setOsEnvs(envsToSet map[string]string) error {
 
 func TestNewEnvironment(t *testing.T) {
 	executorConfig := NewExecutorConfig("javac", "java", []string{""}, []string{""})
+	preparedModDir := ""
 	tests := []struct {
 		name string
 		want *Environment
 	}{
 		{name: "create env service with default envs", want: &Environment{
 			NetworkEnvs:     *NewNetworkEnvs(defaultIp, defaultPort, defaultProtocol),
-			BeamSdkEnvs:     *NewBeamEnvs(defaultSdk, executorConfig),
+			BeamSdkEnvs:     *NewBeamEnvs(defaultSdk, executorConfig, preparedModDir),
 			ApplicationEnvs: *NewApplicationEnvs("/app", &CacheEnvs{defaultCacheType, defaultCacheAddress, defaultCacheKeyExpirationTime}, defaultPipelineExecuteTimeout),
 		}},
 	}
@@ -86,7 +87,7 @@ func TestNewEnvironment(t *testing.T) {
 		t.Run(tt.name, func(t *testing.T) {
 			if got := NewEnvironment(
 				*NewNetworkEnvs(defaultIp, defaultPort, defaultProtocol),
-				*NewBeamEnvs(defaultSdk, executorConfig),
+				*NewBeamEnvs(defaultSdk, executorConfig, preparedModDir),
 				*NewApplicationEnvs("/app", &CacheEnvs{defaultCacheType, defaultCacheAddress, defaultCacheKeyExpirationTime}, defaultPipelineExecuteTimeout)); !reflect.DeepEqual(got, tt.want) {
 				t.Errorf("NewEnvironment() = %v, want %v", got, tt.want)
 			}
@@ -97,6 +98,7 @@ func TestNewEnvironment(t *testing.T) {
 func Test_getSdkEnvsFromOsEnvs(t *testing.T) {
 	jars := strings.Join([]string{defaultBeamSdkPath, defaultBeamRunner, defaultSLF4j}, ":")
 	workingDir := "./"
+	preparedModDir := ""
 	tests := []struct {
 		name      string
 		want      *BeamEnvs
@@ -111,13 +113,13 @@ func Test_getSdkEnvsFromOsEnvs(t *testing.T) {
 		},
 		{
 			name:      "default beam envs",
-			want:      NewBeamEnvs(defaultSdk, NewExecutorConfig("javac", "java", []string{"-d", "bin", "-classpath", defaultBeamSdkPath}, []string{"-cp", "bin:" + jars})),
+			want:      NewBeamEnvs(defaultSdk, NewExecutorConfig("javac", "java", []string{"-d", "bin", "-classpath", defaultBeamSdkPath}, []string{"-cp", "bin:" + jars}), preparedModDir),
 			envsToSet: map[string]string{beamSdkKey: "SDK_JAVA"},
 			wantErr:   false,
 		},
 		{
 			name:      "specific sdk key in os envs",
-			want:      NewBeamEnvs(defaultSdk, NewExecutorConfig("javac", "java", []string{"-d", "bin", "-classpath", defaultBeamSdkPath}, []string{"-cp", "bin:" + jars})),
+			want:      NewBeamEnvs(defaultSdk, NewExecutorConfig("javac", "java", []string{"-d", "bin", "-classpath", defaultBeamSdkPath}, []string{"-cp", "bin:" + jars}), preparedModDir),
 			envsToSet: map[string]string{beamSdkKey: "SDK_JAVA"},
 			wantErr:   false,
 		},
diff --git a/playground/backend/internal/fs_tool/fs.go b/playground/backend/internal/fs_tool/fs.go
index 5d4721a6751..4bb30ff03d6 100644
--- a/playground/backend/internal/fs_tool/fs.go
+++ b/playground/backend/internal/fs_tool/fs.go
@@ -19,6 +19,7 @@ import (
 	pb "beam.apache.org/playground/backend/internal/api/v1"
 	"fmt"
 	"github.com/google/uuid"
+	"io"
 	"io/fs"
 	"os"
 	"path/filepath"
@@ -111,6 +112,50 @@ func (l *LifeCycle) GetAbsoluteSourceFilePath() string {
 	return absoluteFilePath
 }
 
+// CopyFiles copies a prepared go.mod and go.sum in baseFileFolder for executing beam pipeline with go SDK
+func (l *LifeCycle) CopyFiles(workingDir, preparedModDir string) error {
+	err := copyFile("go.mod", preparedModDir, filepath.Join(workingDir, baseFileFolder))
+	if err != nil {
+		return err
+	}
+	err = copyFile("go.sum", preparedModDir, filepath.Join(workingDir, baseFileFolder))
+	if err != nil {
+		return err
+	}
+	return nil
+}
+
+// copyFile copies a file with fileName from sourceDir to destinationDir.
+func copyFile(fileName, sourceDir, destinationDir string) (err error) {
+	absSourcePath := filepath.Join(sourceDir, fileName)
+	absDestinationPath := filepath.Join(destinationDir, fileName)
+	sourceFileStat, err := os.Stat(absSourcePath)
+	if err != nil {
+		return err
+	}
+
+	if !sourceFileStat.Mode().IsRegular() {
+		return fmt.Errorf("%s is not a regular file", fileName)
+	}
+
+	sourceFile, err := os.Open(absSourcePath)
+	if err != nil {
+		return err
+	}
+	defer sourceFile.Close()
+
+	destinationFile, err := os.Create(absDestinationPath)
+	if err != nil {
+		return err
+	}
+	defer destinationFile.Close()
+	_, err = io.Copy(destinationFile, sourceFile)
+	if err != nil {
+		return err
+	}
+	return nil
+}
+
 // GetAbsoluteExecutableFilePath returns absolute filepath to compiled file (/path/to/workingDir/executable_files/{pipelineId}/bin/{pipelineId}.{executableExtension}).
 func (l *LifeCycle) GetAbsoluteExecutableFilePath() string {
 	fileName := l.pipelineId.String() + l.Extension.ExecutableFileExtension
diff --git a/playground/backend/internal/fs_tool/fs_test.go b/playground/backend/internal/fs_tool/fs_test.go
index ef3b0a6f19c..f6d7f2ab055 100644
--- a/playground/backend/internal/fs_tool/fs_test.go
+++ b/playground/backend/internal/fs_tool/fs_test.go
@@ -17,6 +17,7 @@ package fs_tool
 
 import (
 	pb "beam.apache.org/playground/backend/internal/api/v1"
+	"beam.apache.org/playground/backend/internal/logger"
 	"fmt"
 	"github.com/google/uuid"
 	"io/fs"
@@ -26,6 +27,53 @@ import (
 	"testing"
 )
 
+const (
+	preparedModDir  = "testModDir"
+	preparedWorkDir = "workingDir"
+)
+
+func TestMain(m *testing.M) {
+	err := setupPreparedFiles()
+	if err != nil {
+		logger.Fatal(err)
+	}
+	defer teardown()
+	m.Run()
+}
+
+func setupPreparedFiles() error {
+	err := os.Mkdir(preparedModDir, 0755)
+	if err != nil {
+		return err
+	}
+	err = os.MkdirAll(filepath.Join(preparedWorkDir, baseFileFolder), 0755)
+	if err != nil {
+		return err
+	}
+	testModFile := filepath.Join(preparedModDir, "go.mod")
+	testSumFile := filepath.Join(preparedModDir, "go.sum")
+	_, err = os.Create(testModFile)
+	if err != nil {
+		return err
+	}
+	_, err = os.Create(testSumFile)
+	if err != nil {
+		return err
+	}
+	return nil
+}
+
+func teardown() {
+	err := os.RemoveAll(preparedModDir)
+	if err != nil {
+		logger.Fatal(err)
+	}
+	err = os.RemoveAll(preparedWorkDir)
+	if err != nil {
+		logger.Fatal(err)
+	}
+}
+
 func TestLifeCycle_CreateExecutableFile(t *testing.T) {
 	pipelineId := uuid.New()
 	baseFileFolder := fmt.Sprintf("%s_%s", baseFileFolder, pipelineId)
@@ -401,3 +449,68 @@ func TestLifeCycle_ExecutableName(t *testing.T) {
 		})
 	}
 }
+
+func TestLifeCycle_CopyFiles(t *testing.T) {
+	type fields struct {
+		folderGlobs    []string
+		Folder         Folder
+		Extension      Extension
+		ExecutableName func(uuid.UUID, string) (string, error)
+		pipelineId     uuid.UUID
+	}
+	type args struct {
+		workingDir     string
+		preparedModDir string
+	}
+	tests := []struct {
+		name    string
+		fields  fields
+		args    args
+		wantErr bool
+	}{
+		{
+			name: "go.mod and go.sum exists in current dir",
+			fields: fields{
+				folderGlobs:    nil,
+				Folder:         Folder{},
+				Extension:      Extension{},
+				ExecutableName: nil,
+				pipelineId:     uuid.UUID{},
+			},
+			args: args{
+				workingDir:     preparedWorkDir,
+				preparedModDir: preparedModDir,
+			},
+			wantErr: false,
+		},
+		{
+			name: "go.mod or go.sum does not exists in current dir",
+			fields: fields{
+				folderGlobs:    nil,
+				Folder:         Folder{},
+				Extension:      Extension{},
+				ExecutableName: nil,
+				pipelineId:     uuid.UUID{},
+			},
+			args: args{
+				workingDir:     preparedWorkDir,
+				preparedModDir: "",
+			},
+			wantErr: true,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			l := &LifeCycle{
+				folderGlobs:    tt.fields.folderGlobs,
+				Folder:         tt.fields.Folder,
+				Extension:      tt.fields.Extension,
+				ExecutableName: tt.fields.ExecutableName,
+				pipelineId:     tt.fields.pipelineId,
+			}
+			if err := l.CopyFiles(tt.args.workingDir, tt.args.preparedModDir); (err != nil) != tt.wantErr {
+				t.Errorf("CopyFiles() error = %v, wantErr %v", err, tt.wantErr)
+			}
+		})
+	}
+}
diff --git a/playground/backend/internal/setup_tools/life_cycle/life_cycle_setuper.go b/playground/backend/internal/setup_tools/life_cycle/life_cycle_setuper.go
index b13d7bff6c2..41743b370c6 100644
--- a/playground/backend/internal/setup_tools/life_cycle/life_cycle_setuper.go
+++ b/playground/backend/internal/setup_tools/life_cycle/life_cycle_setuper.go
@@ -24,7 +24,7 @@ import (
 
 // Setup returns fs_tool.LifeCycle.
 // Also, prepares files and folders needed to code processing according to sdk
-func Setup(sdk pb.Sdk, code string, pipelineId uuid.UUID, workingDir string) (*fs_tool.LifeCycle, error) {
+func Setup(sdk pb.Sdk, code string, pipelineId uuid.UUID, workingDir string, preparedModDir string) (*fs_tool.LifeCycle, error) {
 	// create file system service
 	lc, err := fs_tool.NewLifeCycle(sdk, pipelineId, workingDir)
 	if err != nil {
@@ -39,10 +39,21 @@ func Setup(sdk pb.Sdk, code string, pipelineId uuid.UUID, workingDir string) (*f
 		return nil, err
 	}
 
+	// copy necessary files
+	if sdk == pb.Sdk_SDK_GO {
+		err = lc.CopyFiles(workingDir, preparedModDir)
+		if err != nil {
+			logger.Errorf("%s: RunCode(): CopyFiles(): %s\n", pipelineId, err.Error())
+			lc.DeleteFolders()
+			return nil, err
+		}
+	}
+
 	// create file with code
 	_, err = lc.CreateSourceCodeFile(code)
 	if err != nil {
 		logger.Errorf("%s: RunCode(): CreateSourceCodeFile(): %s\n", pipelineId, err.Error())
+		lc.DeleteFolders()
 		return nil, err
 	}
 	return lc, nil
diff --git a/playground/backend/internal/setup_tools/life_cycle/life_cycle_setuper_test.go b/playground/backend/internal/setup_tools/life_cycle/life_cycle_setuper_test.go
index 25cd757f194..1c6e9e159ae 100644
--- a/playground/backend/internal/setup_tools/life_cycle/life_cycle_setuper_test.go
+++ b/playground/backend/internal/setup_tools/life_cycle/life_cycle_setuper_test.go
@@ -32,10 +32,11 @@ func TestSetup(t *testing.T) {
 		panic(err)
 	}
 	type args struct {
-		sdk        playground.Sdk
-		code       string
-		pipelineId uuid.UUID
-		workingDir string
+		sdk            playground.Sdk
+		code           string
+		pipelineId     uuid.UUID
+		workingDir     string
+		preparedModDir string
 	}
 	tests := []struct {
 		name    string
@@ -68,10 +69,11 @@ func TestSetup(t *testing.T) {
 			// As a result, want to receive an expected life cycle.
 			name: "correct sdk",
 			args: args{
-				sdk:        playground.Sdk_SDK_JAVA,
-				code:       "",
-				pipelineId: successPipelineId,
-				workingDir: "",
+				sdk:            playground.Sdk_SDK_JAVA,
+				code:           "",
+				pipelineId:     successPipelineId,
+				workingDir:     "",
+				preparedModDir: "",
 			},
 			check: func() bool {
 				if _, err := os.Stat("executable_files/" + successPipelineId.String()); os.IsNotExist(err) {
@@ -94,7 +96,7 @@ func TestSetup(t *testing.T) {
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			got, err := Setup(tt.args.sdk, tt.args.code, tt.args.pipelineId, tt.args.workingDir)
+			got, err := Setup(tt.args.sdk, tt.args.code, tt.args.pipelineId, tt.args.workingDir, tt.args.preparedModDir)
 			if (err != nil) != tt.wantErr {
 				t.Errorf("Setup() error = %v, wantErr %v", err, tt.wantErr)
 				return
