diff --git a/sdks/python/apache_beam/runners/interactive/sql/beam_sql_magics.py b/sdks/python/apache_beam/runners/interactive/sql/beam_sql_magics.py
index d27fc61688d..bf4c4c0380e 100644
--- a/sdks/python/apache_beam/runners/interactive/sql/beam_sql_magics.py
+++ b/sdks/python/apache_beam/runners/interactive/sql/beam_sql_magics.py
@@ -24,6 +24,7 @@ import argparse
 import importlib
 import keyword
 import logging
+import traceback
 from typing import Dict
 from typing import List
 from typing import Optional
@@ -201,6 +202,7 @@ class BeamSqlMagics(Magics):
           'Runner "%s" is not supported. Supported runners are %s.',
           runner,
           _SUPPORTED_RUNNERS)
+      return
     query = ' '.join(query)
 
     found = find_pcolls(query, pcoll_by_name(), verbose=verbose)
@@ -250,7 +252,7 @@ def collect_data_for_local_run(query: str, found: Dict[str, beam.PCollection]):
       _ = ib.collect(pcoll)
     except (KeyboardInterrupt, SystemExit):
       raise
-    except:
+    except:  # pylint: disable=bare-except
       _LOGGER.error(
           'Cannot collect data for PCollection %s. Please make sure the '
           'PCollections queried in the sql "%s" are all from a single '
@@ -299,8 +301,9 @@ def apply_sql(
       return output_name, output, chain
     except (KeyboardInterrupt, SystemExit):
       raise
-    except Exception as e:
-      on_error('Error when applying the Beam SQL: %s', e)
+    except:  # pylint: disable=bare-except
+      on_error('Error when applying the Beam SQL: %s', traceback.format_exc())
+      raise
   else:
     return output_name, chain.current, chain
 
@@ -451,8 +454,9 @@ def cache_output(output_name: str, output: PValue) -> None:
     output.pipeline.run().wait_until_finish()
   except (KeyboardInterrupt, SystemExit):
     raise
-  except Exception as e:
-    _LOGGER.warning(_NOT_SUPPORTED_MSG, e, output.pipeline.runner)
+  except:  # pylint: disable=bare-except
+    _LOGGER.warning(
+        _NOT_SUPPORTED_MSG, traceback.format_exc(), output.pipeline.runner)
     return
   ie.current_env().mark_pcollection_computed([output])
   visualize_computed_pcoll(
diff --git a/sdks/python/apache_beam/runners/interactive/sql/utils.py b/sdks/python/apache_beam/runners/interactive/sql/utils.py
index b2e75c88c93..471240ee7b5 100644
--- a/sdks/python/apache_beam/runners/interactive/sql/utils.py
+++ b/sdks/python/apache_beam/runners/interactive/sql/utils.py
@@ -115,7 +115,8 @@ def pformat_namedtuple(schema: NamedTuple) -> str:
   return '{}({})'.format(
       schema.__name__,
       ', '.join([
-          '{}: {}'.format(k, v.__name__) for k,
+          '{}: {}'.format(k, v.__name__ if hasattr(v, '__name__') else repr(v))
+          for k,
           v in schema.__annotations__.items()
       ]))
 
diff --git a/sdks/python/apache_beam/runners/interactive/sql/utils_test.py b/sdks/python/apache_beam/runners/interactive/sql/utils_test.py
index 16d03f57115..c3bfc75407c 100644
--- a/sdks/python/apache_beam/runners/interactive/sql/utils_test.py
+++ b/sdks/python/apache_beam/runners/interactive/sql/utils_test.py
@@ -21,6 +21,8 @@
 
 import unittest
 from typing import NamedTuple
+from typing import Optional
+from typing import Union
 from unittest.mock import patch
 
 import pytest
@@ -42,6 +44,10 @@ class ANamedTuple(NamedTuple):
   b: str
 
 
+class OptionalUnionType(NamedTuple):
+  unnamed: Optional[Union[int, str]]
+
+
 class UtilsTest(unittest.TestCase):
   def test_register_coder_for_schema(self):
     self.assertNotIsInstance(
@@ -73,6 +79,11 @@ class UtilsTest(unittest.TestCase):
     self.assertEqual(
         'ANamedTuple(a: int, b: str)', pformat_namedtuple(ANamedTuple))
 
+  def test_pformat_namedtuple_with_unnamed_fields(self):
+    self.assertEqual(
+        f'OptionalUnionType(unnamed: {repr(Optional[Union[int, str]])})',
+        pformat_namedtuple(OptionalUnionType))
+
   def test_pformat_dict(self):
     self.assertEqual('{\na: 1,\nb: 2\n}', pformat_dict({'a': 1, 'b': '2'}))
 
