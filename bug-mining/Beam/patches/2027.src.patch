diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
index 3c59e623766..db125213c43 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
@@ -78,6 +78,7 @@ import org.apache.beam.sdk.transforms.reflect.DoFnInvokers;
 import org.apache.beam.sdk.transforms.reflect.DoFnSignature;
 import org.apache.beam.sdk.transforms.reflect.DoFnSignatures;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;
 import org.apache.beam.sdk.util.NoopLock;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.values.KV;
@@ -314,8 +315,20 @@ public class DoFnOperator<InputT, OutputT>
       DoFnRunner<InputT, OutputT> wrappedRunner, StepContext stepContext) {
 
     if (keyCoder != null) {
-      StatefulDoFnRunner.CleanupTimer cleanupTimer =
-          new StatefulDoFnRunner.TimeInternalsCleanupTimer(timerInternals, windowingStrategy);
+      StatefulDoFnRunner.CleanupTimer<InputT> cleanupTimer =
+          new StatefulDoFnRunner.TimeInternalsCleanupTimer<InputT>(
+              timerInternals, windowingStrategy) {
+            @Override
+            public void setForWindow(InputT input, BoundedWindow window) {
+              if (!window.equals(GlobalWindow.INSTANCE)) {
+                // Skip setting a cleanup timer for the global window as these timers
+                // lead to potentially unbounded state growth in the runner, depending on key
+                // cardinality. Cleanup for global window will be performed upon arrival of the
+                // final watermark.
+                super.setForWindow(input, window);
+              }
+            }
+          };
 
       // we don't know the window type
       @SuppressWarnings({"unchecked", "rawtypes"})
@@ -753,6 +766,13 @@ public class DoFnOperator<InputT, OutputT>
       LOG.debug("Emitting watermark {}", watermark);
       currentOutputWatermark = watermark;
       output.emitWatermark(new Watermark(watermark));
+
+      // Check if the final watermark was triggered to perform state cleanup for global window
+      if (keyedStateInternals != null
+          && currentOutputWatermark
+              > adjustTimestampForFlink(GlobalWindow.INSTANCE.maxTimestamp().getMillis())) {
+        keyedStateInternals.clearGlobalState();
+      }
     }
   }
 
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
index df7e5f92a1b..bc7cf460f9c 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
@@ -593,35 +593,12 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
         return currentOutputWatermark;
       }
     } else {
-      // Check if the final watermark was triggered to perform state cleanup for global window
-      if (potentialOutputWatermark > BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()
-          && currentOutputWatermark <= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {
-        cleanupGlobalWindowState();
-      }
       // No bundle was started when we advanced the input watermark.
       // Thus, we can safely set a new output watermark.
       return potentialOutputWatermark;
     }
   }
 
-  private void cleanupGlobalWindowState() {
-    List<String> userStateNames =
-        executableStage.getUserStates().stream()
-            .map(UserStateReference::localName)
-            .collect(Collectors.toList());
-
-    StateNamespace namespace =
-        StateNamespaces.window(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE);
-    for (String userState : userStateNames) {
-      StateTag<BagState<Void>> bagStateStateTag = StateTags.bag(userState, VoidCoder.of());
-      try {
-        keyedStateInternals.clearBagStates(namespace, bagStateStateTag);
-      } catch (Exception e) {
-        throw new RuntimeException("Failed to clear user state in global window.", e);
-      }
-    }
-  }
-
   private void preBundleStartCallback() {
     inputWatermarkBeforeBundleStart = getEffectiveInputWatermark();
   }
@@ -899,7 +876,7 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
   }
 
   static class CleanupTimer<InputT> implements StatefulDoFnRunner.CleanupTimer<InputT> {
-    private static final String GC_TIMER_ID = "__user-state-cleanup__";
+    public static final String GC_TIMER_ID = "__user-state-cleanup__";
 
     private final TimerInternals timerInternals;
     private final Lock stateBackendLock;
@@ -926,15 +903,12 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
     @Override
     public void setForWindow(InputT input, BoundedWindow window) {
       Preconditions.checkNotNull(input, "Null input passed to CleanupTimer");
-
-      // Skip setting a cleanup timer for the global window as these timers
-      // lead to potentially unbounded state growth in the runner, depending on key cardinality.
-      // Cleanup for global window will be performed upon arrival of the final watermark
-      // in in cleanupGlobalWindowState.
       if (window.equals(GlobalWindow.INSTANCE)) {
+        // Skip setting a cleanup timer for the global window as these timers
+        // lead to potentially unbounded state growth in the runner, depending on key cardinality.
+        // Cleanup for global window will be performed upon arrival of the final watermark.
         return;
       }
-
       // needs to match the encoding in prepareStateBackend for state request handler
       final ByteBuffer key = FlinkKeyUtils.encodeKey(((KV) input).getKey(), keyCoder);
       // Ensure the state backend is not concurrently accessed by the state requests
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
index da8173d1555..e4a3c7bba6c 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
@@ -19,12 +19,15 @@ package org.apache.beam.runners.flink.translation.wrappers.streaming.state;
 
 import java.nio.ByteBuffer;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.Set;
 import java.util.stream.Stream;
 import javax.annotation.Nonnull;
 import org.apache.beam.runners.core.StateInternals;
 import org.apache.beam.runners.core.StateNamespace;
+import org.apache.beam.runners.core.StateNamespaces;
 import org.apache.beam.runners.core.StateTag;
 import org.apache.beam.runners.flink.translation.types.CoderTypeSerializer;
 import org.apache.beam.runners.flink.translation.wrappers.streaming.FlinkKeyUtils;
@@ -46,6 +49,7 @@ import org.apache.beam.sdk.state.ValueState;
 import org.apache.beam.sdk.state.WatermarkHoldState;
 import org.apache.beam.sdk.transforms.Combine;
 import org.apache.beam.sdk.transforms.CombineWithContext;
+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;
 import org.apache.beam.sdk.transforms.windowing.TimestampCombiner;
 import org.apache.beam.sdk.util.CombineContextFactory;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
@@ -56,6 +60,7 @@ import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.TreeMult
 import org.apache.flink.api.common.state.ListState;
 import org.apache.flink.api.common.state.ListStateDescriptor;
 import org.apache.flink.api.common.state.MapStateDescriptor;
+import org.apache.flink.api.common.state.StateDescriptor;
 import org.apache.flink.api.common.state.ValueStateDescriptor;
 import org.apache.flink.api.common.typeutils.base.BooleanSerializer;
 import org.apache.flink.api.common.typeutils.base.StringSerializer;
@@ -74,8 +79,18 @@ import org.joda.time.Instant;
  */
 public class FlinkStateInternals<K> implements StateInternals {
 
+  private static final StateNamespace globalWindowNamespace =
+      StateNamespaces.window(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE);
+
   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;
-  private Coder<K> keyCoder;
+  private final Coder<K> keyCoder;
+
+  /**
+   * A set which contains all state descriptors created in the global window. Used for cleanup on
+   * final watermark.
+   */
+  @SuppressWarnings("unchecked")
+  private final Set<StateDescriptor> globalWindowStateDescriptors = new HashSet<>();
 
   // Watermark holds for all keys/windows of this partition, allows efficient lookup of the minimum
   private final TreeMultiset<Long> watermarkHolds = TreeMultiset.create();
@@ -114,16 +129,26 @@ public class FlinkStateInternals<K> implements StateInternals {
     return address.getSpec().bind(address.getId(), new FlinkStateBinder(namespace, context));
   }
 
-  public void clearBagStates(StateNamespace namespace, StateTag<? extends BagState> address)
-      throws Exception {
-    CoderTypeSerializer typeSerializer = new CoderTypeSerializer<>(VoidCoder.of());
-    flinkStateBackend.applyToAllKeys(
-        namespace.stringKey(),
-        StringSerializer.INSTANCE,
-        new ListStateDescriptor<>(address.getId(), typeSerializer),
-        (key, state) -> {
-          state.clear();
-        });
+  /**
+   * Allows to clear all state for the global watermark when the maximum watermark arrives. We do
+   * not clean up the global window state via timers which would lead to an unbounded number of keys
+   * and cleanup timers. Instead, the cleanup code below should be run when we finally receive the
+   * max watermark.
+   */
+  public void clearGlobalState() {
+    try {
+      for (StateDescriptor stateDescriptor : globalWindowStateDescriptors) {
+        flinkStateBackend.applyToAllKeys(
+            globalWindowNamespace.stringKey(),
+            StringSerializer.INSTANCE,
+            stateDescriptor,
+            (key, state) -> state.clear());
+      }
+      // Clear set to avoid repeating the cleanup
+      globalWindowStateDescriptors.clear();
+    } catch (Exception e) {
+      throw new RuntimeException("Failed to cleanup global state.", e);
+    }
   }
 
   private class FlinkStateBinder implements StateBinder {
@@ -139,17 +164,25 @@ public class FlinkStateInternals<K> implements StateInternals {
     @Override
     public <T2> ValueState<T2> bindValue(
         String id, StateSpec<ValueState<T2>> spec, Coder<T2> coder) {
-      return new FlinkValueState<>(flinkStateBackend, id, namespace, coder);
+      FlinkValueState<T2> valueState =
+          new FlinkValueState<>(flinkStateBackend, id, namespace, coder);
+      collectGlobalWindowStateDescriptor(valueState.flinkStateDescriptor);
+      return valueState;
     }
 
     @Override
     public <T2> BagState<T2> bindBag(String id, StateSpec<BagState<T2>> spec, Coder<T2> elemCoder) {
-      return new FlinkBagState<>(flinkStateBackend, id, namespace, elemCoder);
+      FlinkBagState<Object, T2> bagState =
+          new FlinkBagState<>(flinkStateBackend, id, namespace, elemCoder);
+      collectGlobalWindowStateDescriptor(bagState.flinkStateDescriptor);
+      return bagState;
     }
 
     @Override
     public <T2> SetState<T2> bindSet(String id, StateSpec<SetState<T2>> spec, Coder<T2> elemCoder) {
-      return new FlinkSetState<>(flinkStateBackend, id, namespace, elemCoder);
+      FlinkSetState<T2> setState = new FlinkSetState<>(flinkStateBackend, id, namespace, elemCoder);
+      collectGlobalWindowStateDescriptor(setState.flinkStateDescriptor);
+      return setState;
     }
 
     @Override
@@ -158,7 +191,10 @@ public class FlinkStateInternals<K> implements StateInternals {
         StateSpec<MapState<KeyT, ValueT>> spec,
         Coder<KeyT> mapKeyCoder,
         Coder<ValueT> mapValueCoder) {
-      return new FlinkMapState<>(flinkStateBackend, id, namespace, mapKeyCoder, mapValueCoder);
+      FlinkMapState<KeyT, ValueT> mapState =
+          new FlinkMapState<>(flinkStateBackend, id, namespace, mapKeyCoder, mapValueCoder);
+      collectGlobalWindowStateDescriptor(mapState.flinkStateDescriptor);
+      return mapState;
     }
 
     @Override
@@ -174,7 +210,10 @@ public class FlinkStateInternals<K> implements StateInternals {
         StateSpec<CombiningState<InputT, AccumT, OutputT>> spec,
         Coder<AccumT> accumCoder,
         Combine.CombineFn<InputT, AccumT, OutputT> combineFn) {
-      return new FlinkCombiningState<>(flinkStateBackend, id, combineFn, namespace, accumCoder);
+      FlinkCombiningState<Object, InputT, AccumT, OutputT> combiningState =
+          new FlinkCombiningState<>(flinkStateBackend, id, combineFn, namespace, accumCoder);
+      collectGlobalWindowStateDescriptor(combiningState.flinkStateDescriptor);
+      return combiningState;
     }
 
     @Override
@@ -184,21 +223,32 @@ public class FlinkStateInternals<K> implements StateInternals {
             StateSpec<CombiningState<InputT, AccumT, OutputT>> spec,
             Coder<AccumT> accumCoder,
             CombineWithContext.CombineFnWithContext<InputT, AccumT, OutputT> combineFn) {
-      return new FlinkCombiningStateWithContext<>(
-          flinkStateBackend,
-          id,
-          combineFn,
-          namespace,
-          accumCoder,
-          CombineContextFactory.createFromStateContext(stateContext));
+      FlinkCombiningStateWithContext<Object, InputT, AccumT, OutputT> combiningStateWithContext =
+          new FlinkCombiningStateWithContext<>(
+              flinkStateBackend,
+              id,
+              combineFn,
+              namespace,
+              accumCoder,
+              CombineContextFactory.createFromStateContext(stateContext));
+      collectGlobalWindowStateDescriptor(combiningStateWithContext.flinkStateDescriptor);
+      return combiningStateWithContext;
     }
 
     @Override
     public WatermarkHoldState bindWatermark(
         String id, StateSpec<WatermarkHoldState> spec, TimestampCombiner timestampCombiner) {
+      collectGlobalWindowStateDescriptor(watermarkHoldStateDescriptor);
       return new FlinkWatermarkHoldState(
           flinkStateBackend, watermarkHoldStateDescriptor, id, namespace, timestampCombiner);
     }
+
+    /** Take note of state bound to the global window for cleanup in clearGlobalState(). */
+    private void collectGlobalWindowStateDescriptor(StateDescriptor descriptor) {
+      if (globalWindowNamespace.equals(namespace)) {
+        globalWindowStateDescriptors.add(descriptor);
+      }
+    }
   }
 
   private static class FlinkValueState<T> implements ValueState<T> {
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java
index 06217b44080..83d84c24eb4 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java
@@ -508,13 +508,138 @@ public class DoFnOperatorTest {
 
     WindowingStrategy<Object, IntervalWindow> windowingStrategy =
         WindowingStrategy.of(FixedWindows.of(new Duration(10))).withAllowedLateness(Duration.ZERO);
+    final int offset = 5000;
+    final int timerOutput = 4093;
+
+    KeyedOneInputStreamOperatorTestHarness<
+            ByteBuffer, WindowedValue<KV<String, Integer>>, WindowedValue<KV<String, Integer>>>
+        testHarness =
+            getHarness(
+                windowingStrategy,
+                offset,
+                (window) -> new Instant(window.maxTimestamp()),
+                timerOutput);
+
+    testHarness.open();
+
+    testHarness.processWatermark(0);
+
+    assertEquals(0, testHarness.numKeyedStateEntries());
+
+    IntervalWindow window1 = new IntervalWindow(new Instant(0), Duration.millis(10));
+
+    testHarness.processElement(
+        new StreamRecord<>(
+            WindowedValue.of(KV.of("key1", 5), new Instant(1), window1, PaneInfo.NO_FIRING)));
+
+    testHarness.processElement(
+        new StreamRecord<>(
+            WindowedValue.of(KV.of("key2", 7), new Instant(3), window1, PaneInfo.NO_FIRING)));
+
+    assertThat(
+        stripStreamRecordFromWindowedValue(testHarness.getOutput()),
+        contains(
+            WindowedValue.of(
+                KV.of("key1", 5 + offset), new Instant(1), window1, PaneInfo.NO_FIRING),
+            WindowedValue.of(
+                KV.of("key2", 7 + offset), new Instant(3), window1, PaneInfo.NO_FIRING)));
+
+    // 2 entries for the elements and 2 for the pending timers
+    assertEquals(4, testHarness.numKeyedStateEntries());
+
+    testHarness.getOutput().clear();
+
+    // this should trigger both the window.maxTimestamp() timer and the GC timer
+    // this tests that the GC timer fires after the user timer
+    // we have to add 1 here because Flink timers fire when watermark >= timestamp while Beam
+    // timers fire when watermark > timestamp
+    testHarness.processWatermark(
+        window1
+                .maxTimestamp()
+                .plus(windowingStrategy.getAllowedLateness())
+                .plus(StatefulDoFnRunner.TimeInternalsCleanupTimer.GC_DELAY_MS)
+                .getMillis()
+            + 1);
+
+    assertThat(
+        stripStreamRecordFromWindowedValue(testHarness.getOutput()),
+        contains(
+            WindowedValue.of(
+                KV.of("key1", timerOutput), new Instant(9), window1, PaneInfo.NO_FIRING),
+            WindowedValue.of(
+                KV.of("key2", timerOutput), new Instant(9), window1, PaneInfo.NO_FIRING)));
+
+    testHarness.close();
+  }
+
+  @Test
+  public void testGCForGlobalWindow() throws Exception {
+    WindowingStrategy<Object, GlobalWindow> windowingStrategy = WindowingStrategy.globalDefault();
+
+    KeyedOneInputStreamOperatorTestHarness<
+            ByteBuffer, WindowedValue<KV<String, Integer>>, WindowedValue<KV<String, Integer>>>
+        testHarness = getHarness(windowingStrategy, 5000, (window) -> new Instant(50), 4092);
+
+    testHarness.open();
+
+    testHarness.processWatermark(0);
+
+    // ensure the state was garbage collected and the pending timers have been removed
+    assertEquals(0, testHarness.numKeyedStateEntries());
+
+    // Check global window cleanup via final watermark, _without_ cleanup timers
+    testHarness.processElement(
+        new StreamRecord<>(
+            WindowedValue.of(
+                KV.of("key1", 5), new Instant(23), GlobalWindow.INSTANCE, PaneInfo.NO_FIRING)));
+    testHarness.processElement(
+        new StreamRecord<>(
+            WindowedValue.of(
+                KV.of("key2", 6), new Instant(42), GlobalWindow.INSTANCE, PaneInfo.NO_FIRING)));
 
+    // timers set by the transform
+    assertThat(testHarness.numEventTimeTimers(), is(2));
+    // state has been written which needs to be cleaned up (includes timers)
+    assertThat(testHarness.numKeyedStateEntries(), is(4));
+
+    // Fire timers set
+    testHarness.processWatermark(51);
+    assertThat(testHarness.numEventTimeTimers(), is(0));
+    assertThat(testHarness.numKeyedStateEntries(), is(2));
+
+    // Should not trigger garbage collection yet
+    testHarness.processWatermark(GlobalWindow.INSTANCE.maxTimestamp().plus(1).getMillis());
+    assertThat(testHarness.numEventTimeTimers(), is(0));
+    assertThat(testHarness.numKeyedStateEntries(), is(2));
+
+    // Cleanup due to end of global window
+    testHarness.processWatermark(GlobalWindow.INSTANCE.maxTimestamp().plus(2).getMillis());
+    assertThat(testHarness.numEventTimeTimers(), is(0));
+    assertThat(testHarness.numKeyedStateEntries(), is(0));
+
+    // Any new state will also be cleaned up on close
+    testHarness.processElement(
+        new StreamRecord<>(
+            WindowedValue.of(
+                KV.of("key2", 6), new Instant(42), GlobalWindow.INSTANCE, PaneInfo.NO_FIRING)));
+
+    // Close sends Flink's max watermark and will cleanup again
+    testHarness.close();
+    assertThat(testHarness.numEventTimeTimers(), is(0));
+    assertThat(testHarness.numKeyedStateEntries(), is(0));
+  }
+
+  private static KeyedOneInputStreamOperatorTestHarness<
+          ByteBuffer, WindowedValue<KV<String, Integer>>, WindowedValue<KV<String, Integer>>>
+      getHarness(
+          WindowingStrategy windowingStrategy,
+          int elementOffset,
+          Function<BoundedWindow, Instant> timerTimestamp,
+          int timerOutput)
+          throws Exception {
     final String timerId = "boo";
     final String stateId = "dazzle";
 
-    final int offset = 5000;
-    final int timerOutput = 4093;
-
     DoFn<KV<String, Integer>, KV<String, Integer>> fn =
         new DoFn<KV<String, Integer>, KV<String, Integer>>() {
 
@@ -531,10 +656,10 @@ public class DoFnOperatorTest {
               @TimerId(timerId) Timer timer,
               @StateId(stateId) ValueState<String> state,
               BoundedWindow window) {
-            timer.set(window.maxTimestamp());
+            timer.set(timerTimestamp.apply(window));
             state.write(context.element().getKey());
             context.output(
-                KV.of(context.element().getKey(), context.element().getValue() + offset));
+                KV.of(context.element().getKey(), context.element().getValue() + elementOffset));
           }
 
           @OnTimer(timerId)
@@ -578,60 +703,7 @@ public class DoFnOperatorTest {
                 doFnOperator,
                 keySelector,
                 new CoderTypeInformation<>(FlinkKeyUtils.ByteBufferCoder.of()));
-
-    testHarness.open();
-
-    testHarness.processWatermark(0);
-
-    assertEquals(0, testHarness.numKeyedStateEntries());
-
-    IntervalWindow window1 = new IntervalWindow(new Instant(0), Duration.millis(10));
-
-    testHarness.processElement(
-        new StreamRecord<>(
-            WindowedValue.of(KV.of("key1", 5), new Instant(1), window1, PaneInfo.NO_FIRING)));
-
-    testHarness.processElement(
-        new StreamRecord<>(
-            WindowedValue.of(KV.of("key2", 7), new Instant(3), window1, PaneInfo.NO_FIRING)));
-
-    assertThat(
-        stripStreamRecordFromWindowedValue(testHarness.getOutput()),
-        contains(
-            WindowedValue.of(
-                KV.of("key1", 5 + offset), new Instant(1), window1, PaneInfo.NO_FIRING),
-            WindowedValue.of(
-                KV.of("key2", 7 + offset), new Instant(3), window1, PaneInfo.NO_FIRING)));
-
-    // 2 entries for the elements and 2 for the pending timers
-    assertEquals(4, testHarness.numKeyedStateEntries());
-
-    testHarness.getOutput().clear();
-
-    // this should trigger both the window.maxTimestamp() timer and the GC timer
-    // this tests that the GC timer fires after the user timer
-    // we have to add 1 here because Flink timers fire when watermark >= timestamp while Beam
-    // timers fire when watermark > timestamp
-    testHarness.processWatermark(
-        window1
-                .maxTimestamp()
-                .plus(windowingStrategy.getAllowedLateness())
-                .plus(StatefulDoFnRunner.TimeInternalsCleanupTimer.GC_DELAY_MS)
-                .getMillis()
-            + 1);
-
-    assertThat(
-        stripStreamRecordFromWindowedValue(testHarness.getOutput()),
-        contains(
-            WindowedValue.of(
-                KV.of("key1", timerOutput), new Instant(9), window1, PaneInfo.NO_FIRING),
-            WindowedValue.of(
-                KV.of("key2", timerOutput), new Instant(9), window1, PaneInfo.NO_FIRING)));
-
-    // ensure the state was garbage collected and the pending timers have been removed
-    assertEquals(0, testHarness.numKeyedStateEntries());
-
-    testHarness.close();
+    return testHarness;
   }
 
   @Test
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
index d73ba0e6bc3..2bd3a69fb0c 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
@@ -23,7 +23,6 @@ import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.nullValue;
 import static org.hamcrest.collection.IsIterableContainingInOrder.contains;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
@@ -32,7 +31,6 @@ import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
@@ -608,33 +606,17 @@ public class ExecutableStageDoFnOperatorTest {
     KeyedStateBackend keyedStateBackend = Mockito.mock(KeyedStateBackend.class);
     Lock stateBackendLock = Mockito.mock(Lock.class);
     StringUtf8Coder keyCoder = StringUtf8Coder.of();
+    IntervalWindow window = new IntervalWindow(new Instant(0), new Instant(10));
+    Coder<IntervalWindow> windowCoder = IntervalWindow.getCoder();
 
-    // Test that no cleanup timer is set for the global window
-    WindowingStrategy windowingStrategy = WindowingStrategy.globalDefault();
-    BoundedWindow window = GlobalWindow.INSTANCE;
+    // Test that cleanup timer is set correctly
     ExecutableStageDoFnOperator.CleanupTimer cleanupTimer =
         new ExecutableStageDoFnOperator.CleanupTimer<>(
             inMemoryTimerInternals,
             stateBackendLock,
-            windowingStrategy,
-            keyCoder,
-            windowingStrategy.getWindowFn().windowCoder(),
-            keyedStateBackend);
-    cleanupTimer.setForWindow(KV.of("key", "string"), window);
-    Mockito.verify(stateBackendLock, never()).lock();
-    Mockito.verify(stateBackendLock, never()).unlock();
-    assertThat(inMemoryTimerInternals.getNextTimer(TimeDomain.EVENT_TIME), nullValue());
-
-    // Test that cleanup timer is set correctly for non-global window
-    windowingStrategy = WindowingStrategy.of(FixedWindows.of(Duration.millis(10)));
-    window = new IntervalWindow(new Instant(0), new Instant(9));
-    cleanupTimer =
-        new ExecutableStageDoFnOperator.CleanupTimer<>(
-            inMemoryTimerInternals,
-            stateBackendLock,
-            windowingStrategy,
+            WindowingStrategy.globalDefault(),
             keyCoder,
-            windowingStrategy.getWindowFn().windowCoder(),
+            windowCoder,
             keyedStateBackend);
     cleanupTimer.setForWindow(KV.of("key", "string"), window);
 
@@ -910,6 +892,9 @@ public class ExecutableStageDoFnOperatorTest {
         operator.keyedStateInternals.state(
             stateNamespace, StateTags.bag(stateId, ByteStringCoder.of()));
     state.add(ByteString.copyFrom("userstate".getBytes(Charsets.UTF_8)));
+    // No timers have been set for cleanup
+    assertThat(testHarness.numEventTimeTimers(), is(0));
+    // State has been created
     assertThat(testHarness.numKeyedStateEntries(), is(1));
 
     // Generate final watermark to trigger state cleanup
@@ -917,14 +902,6 @@ public class ExecutableStageDoFnOperatorTest {
         new Watermark(BoundedWindow.TIMESTAMP_MAX_VALUE.plus(1).getMillis()));
 
     assertThat(testHarness.numKeyedStateEntries(), is(0));
-
-    // Close should not repeat state cleanup
-    state.add(ByteString.copyFrom("userstate".getBytes(Charsets.UTF_8)));
-    assertThat(testHarness.numKeyedStateEntries(), is(1));
-
-    testHarness.close();
-
-    assertThat(testHarness.numKeyedStateEntries(), is(1));
   }
 
   @Test
