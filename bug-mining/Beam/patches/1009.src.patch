diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java
index 1a1efaddbbc..8ebab5f9f72 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java
@@ -95,6 +95,7 @@ public abstract class RowCoderGenerator {
   private static final ForLoadedType LIST_CODER_TYPE = new ForLoadedType(ListCoder.class);
   private static final ForLoadedType MAP_CODER_TYPE = new ForLoadedType(MapCoder.class);
   private static final BitSetCoder NULL_LIST_CODER = BitSetCoder.of();
+  private static final ForLoadedType NULLABLE_CODER = new ForLoadedType(NullableCoder.class);
 
   private static final String CODERS_FIELD_NAME = "FIELD_CODERS";
 
@@ -305,7 +306,9 @@ public abstract class RowCoderGenerator {
     List<StackManipulation> componentCoders =
         Lists.newArrayListWithCapacity(schema.getFieldCount());
     for (int i = 0; i < schema.getFieldCount(); i++) {
-      componentCoders.add(getCoder(schema.getField(i).getType()));
+      // We use withNullable(false) as nulls are handled by the RowCoder and the individual
+      // component coders therefore do not need to handle nulls.
+      componentCoders.add(getCoder(schema.getField(i).getType().withNullable(false)));
     }
 
     return builder
@@ -346,7 +349,20 @@ public abstract class RowCoderGenerator {
       Coder<Row> nestedCoder = generate(fieldType.getRowSchema(), UUID.randomUUID());
       return rowCoder(nestedCoder.getClass());
     } else {
-      return coderForPrimitiveType(fieldType.getTypeName());
+      StackManipulation primitiveCoder = coderForPrimitiveType(fieldType.getTypeName());
+
+      if (fieldType.getNullable()) {
+        primitiveCoder =
+            new Compound(
+                primitiveCoder,
+                MethodInvocation.invoke(
+                    NULLABLE_CODER
+                        .getDeclaredMethods()
+                        .filter(ElementMatchers.named("of"))
+                        .getOnly()));
+      }
+
+      return primitiveCoder;
     }
   }
 
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java
index 84e89d6be55..33980fac2c1 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java
@@ -500,6 +500,8 @@ public class Schema implements Serializable {
       return FieldType.forTypeName(TypeName.ARRAY).setCollectionElementType(elementType).build();
     }
 
+    /** @deprecated Set the nullability on the elementType instead */
+    @Deprecated
     public static final FieldType array(FieldType elementType, boolean nullable) {
       return FieldType.forTypeName(TypeName.ARRAY)
           .setCollectionElementType(elementType.withNullable(nullable))
@@ -514,6 +516,8 @@ public class Schema implements Serializable {
           .build();
     }
 
+    /** @deprecated Set the nullability on the valueType instead */
+    @Deprecated
     public static final FieldType map(
         FieldType keyType, FieldType valueType, boolean valueTypeNullable) {
       return FieldType.forTypeName(TypeName.MAP)
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/coders/org/apache/beam/sdk/coders/RowCoderTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/coders/RowCoderTest.java
similarity index 89%
rename from sdks/java/core/src/test/java/org/apache/beam/sdk/coders/org/apache/beam/sdk/coders/RowCoderTest.java
rename to sdks/java/core/src/test/java/org/apache/beam/sdk/coders/RowCoderTest.java
index 21091bc424c..f0d814c5cdb 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/coders/org/apache/beam/sdk/coders/RowCoderTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/coders/RowCoderTest.java
@@ -15,14 +15,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.beam.sdk.coders.org.apache.beam.sdk.coders;
+package org.apache.beam.sdk.coders;
 
 import java.math.BigDecimal;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import org.apache.beam.sdk.coders.Coder.NonDeterministicException;
-import org.apache.beam.sdk.coders.RowCoder;
 import org.apache.beam.sdk.schemas.Schema;
 import org.apache.beam.sdk.schemas.Schema.FieldType;
 import org.apache.beam.sdk.testing.CoderProperties;
@@ -210,4 +210,29 @@ public class RowCoderTest {
 
     CoderProperties.coderConsistentWithEquals(coder, row1, row2);
   }
+
+  @Test
+  public void testConsistentWithEqualsArrayWithNull() throws Exception {
+    Schema schema =
+        Schema.builder()
+            .addField("a", Schema.FieldType.array(Schema.FieldType.INT32, true))
+            .build();
+
+    Row row = Row.withSchema(schema).addValue(Arrays.asList(1, null)).build();
+    CoderProperties.coderDecodeEncodeEqual(RowCoder.of(schema), row);
+  }
+
+  @Test
+  public void testConsistentWithEqualsMapWithNull() throws Exception {
+    Schema schema =
+        Schema.builder()
+            .addField(
+                "a",
+                Schema.FieldType.map(
+                    Schema.FieldType.INT32, Schema.FieldType.INT32.withNullable(true)))
+            .build();
+
+    Row row = Row.withSchema(schema).addValue(Collections.singletonMap(1, null)).build();
+    CoderProperties.coderDecodeEncodeEqual(RowCoder.of(schema), row);
+  }
 }
