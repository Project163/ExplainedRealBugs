diff --git a/sdks/python/apache_beam/runners/portability/fn_api_runner_test.py b/sdks/python/apache_beam/runners/portability/fn_api_runner_test.py
index 55156466fba..882692dfa92 100644
--- a/sdks/python/apache_beam/runners/portability/fn_api_runner_test.py
+++ b/sdks/python/apache_beam/runners/portability/fn_api_runner_test.py
@@ -250,7 +250,7 @@ class FnApiRunnerTest(unittest.TestCase):
                    'TODO: BEAM-5692')
   def test_pardo_state_only(self):
     index_state_spec = userstate.CombiningValueStateSpec(
-        'index', beam.coders.VarIntCoder(), sum)
+        'index', beam.coders.IterableCoder(beam.coders.VarIntCoder()), sum)
 
     # TODO(ccy): State isn't detected with Map/FlatMap.
     class AddIndex(beam.DoFn):
diff --git a/sdks/python/apache_beam/runners/worker/operations.pxd b/sdks/python/apache_beam/runners/worker/operations.pxd
index 22134cd69a0..c412da9a932 100644
--- a/sdks/python/apache_beam/runners/worker/operations.pxd
+++ b/sdks/python/apache_beam/runners/worker/operations.pxd
@@ -98,6 +98,7 @@ cdef class CombineOperation(Operation):
 cdef class PGBKCVOperation(Operation):
   cdef public object combine_fn
   cdef public object combine_fn_add_input
+  cdef public object combine_fn_compact_accumulator
   cdef dict table
   cdef long max_keys
   cdef long key_count
diff --git a/sdks/python/apache_beam/runners/worker/operations.py b/sdks/python/apache_beam/runners/worker/operations.py
index 0bbfd36375d..051c32a2701 100644
--- a/sdks/python/apache_beam/runners/worker/operations.py
+++ b/sdks/python/apache_beam/runners/worker/operations.py
@@ -24,6 +24,7 @@ from __future__ import absolute_import
 
 import collections
 import logging
+import sys
 from builtins import filter
 from builtins import object
 from builtins import zip
@@ -634,6 +635,13 @@ class PGBKCVOperation(Operation):
     fn, args, kwargs = pickler.loads(self.spec.combine_fn)[:3]
     self.combine_fn = curry_combine_fn(fn, args, kwargs)
     self.combine_fn_add_input = self.combine_fn.add_input
+    base_compact_accumulator = (
+        core.CombineFn.compact_accumulator if sys.version_info >= (3,)
+        else core.CombineFn.compact_accumulator.__func__)
+    if self.combine_fn.compact_accumulator.__func__ is base_compact_accumulator:
+      self.combine_fn_compact_accumulator = None
+    else:
+      self.combine_fn_compact_accumulator = self.combine_fn.compact_accumulator
     # Optimization for the (known tiny accumulator, often wide keyspace)
     # combine functions.
     # TODO(b/36567833): Bound by in-memory size rather than key count.
@@ -682,8 +690,12 @@ class PGBKCVOperation(Operation):
     self.table = {}
     self.key_count = 0
 
-  def output_key(self, wkey, value):
+  def output_key(self, wkey, accumulator):
     windows, key = wkey
+    if self.combine_fn_compact_accumulator is None:
+      value = accumulator
+    else:
+      value = self.combine_fn_compact_accumulator(accumulator)
     if windows is 0:
       self.output(_globally_windowed_value.with_value((key, value)))
     else:
diff --git a/sdks/python/apache_beam/transforms/combiners.py b/sdks/python/apache_beam/transforms/combiners.py
index dbb143e6e16..7ea6ef9f275 100644
--- a/sdks/python/apache_beam/transforms/combiners.py
+++ b/sdks/python/apache_beam/transforms/combiners.py
@@ -722,6 +722,9 @@ class _CurriedFn(core.CombineFn):
   def extract_output(self, accumulator):
     return self.fn.extract_output(accumulator, *self.args, **self.kwargs)
 
+  def compact_accumulator(self, accumulator):
+    return self.fn.compact_accumulator(accumulator, *self.args, **self.kwargs)
+
   def apply(self, elements):
     return self.fn.apply(elements, *self.args, **self.kwargs)
 
diff --git a/sdks/python/apache_beam/transforms/core.py b/sdks/python/apache_beam/transforms/core.py
index 1390822206c..959f2c21550 100644
--- a/sdks/python/apache_beam/transforms/core.py
+++ b/sdks/python/apache_beam/transforms/core.py
@@ -611,6 +611,23 @@ class CombineFn(WithTypeHints, HasDisplayData, urns.RunnerApiFn):
     """
     raise NotImplementedError(str(self))
 
+  def compact_accumulator(self, accumulator, *args, **kwargs):
+    """Optionally returns a more compact represenation of the accumulator.
+
+    This is called before an accumulator is sent across the wire, and can
+    be useful in cases where values are buffered or otherwise lazily
+    kept unprocessed when added to the accumulator.  Should return an
+    equivalent, though possibly modified, accumulator.
+
+    By default returns the accumulator unmodified.
+
+    Args:
+      accumulator: the current accumulator
+      *args: Additional arguments and side inputs.
+      **kwargs: Additional arguments and side inputs.
+    """
+    return accumulator
+
   def extract_output(self, accumulator, *args, **kwargs):
     """Return result of converting accumulator into the output value.
 
@@ -673,9 +690,9 @@ class CallableWrapperCombineFn(CombineFn):
   The purpose of this class is to conveniently wrap simple functions and use
   them in Combine transforms.
   """
-  _EMPTY = object()
+  _DEFAULT_BUFFER_SIZE = 10
 
-  def __init__(self, fn):
+  def __init__(self, fn, buffer_size=_DEFAULT_BUFFER_SIZE):
     """Initializes a CallableFn object wrapping a callable.
 
     Args:
@@ -692,6 +709,7 @@ class CallableWrapperCombineFn(CombineFn):
 
     super(CallableWrapperCombineFn, self).__init__()
     self._fn = fn
+    self._buffer_size = buffer_size
 
   def display_data(self):
     return {'fn_dd': self._fn}
@@ -700,37 +718,41 @@ class CallableWrapperCombineFn(CombineFn):
     return "CallableWrapperCombineFn(%s)" % self._fn
 
   def create_accumulator(self, *args, **kwargs):
-    return self._EMPTY
+    return []
 
   def add_input(self, accumulator, element, *args, **kwargs):
-    if accumulator is self._EMPTY:
-      return element
-    return self._fn([accumulator, element], *args, **kwargs)
+    accumulator.append(element)
+    if len(accumulator) > self._buffer_size:
+      accumulator = [self._fn(accumulator, *args, **kwargs)]
+    return accumulator
 
   def add_inputs(self, accumulator, elements, *args, **kwargs):
-    if accumulator is self._EMPTY:
-      return self._fn(elements, *args, **kwargs)
-    elif isinstance(elements, (list, tuple)):
-      return self._fn([accumulator] + list(elements), *args, **kwargs)
-
-    def union():
-      yield accumulator
-      for e in elements:
-        yield e
-    return self._fn(union(), *args, **kwargs)
+    accumulator.extend(elements)
+    if len(accumulator) > self._buffer_size:
+      accumulator = [self._fn(accumulator, *args, **kwargs)]
+    return accumulator
 
   def merge_accumulators(self, accumulators, *args, **kwargs):
-    filter_fn = lambda x: x is not self._EMPTY
-
-    class ReiterableNonEmptyAccumulators(object):
+    class ReiterableChain(object):
       def __iter__(self):
-        return filter(filter_fn, accumulators)
-
-    # It's (weakly) assumed that self._fn is associative.
-    return self._fn(ReiterableNonEmptyAccumulators(), *args, **kwargs)
+        for accumulator in accumulators:
+          for item in accumulator:
+            yield item
+      def __bool__(self):
+        for accumulator in accumulators:
+          for item in accumulator:
+            return True
+        return False
+    return [self._fn(ReiterableChain(), *args, **kwargs)]
+
+  def compact_accumulator(self, accumulator, *args, **kwargs):
+    if len(accumulator) <= 1:
+      return accumulator
+    else:
+      return [self._fn(accumulator, *args, **kwargs)]
 
   def extract_output(self, accumulator, *args, **kwargs):
-    return self._fn(()) if accumulator is self._EMPTY else accumulator
+    return self._fn(accumulator, *args, **kwargs)
 
   def default_type_hints(self):
     fn_hints = get_type_hints(self._fn)
diff --git a/sdks/python/apache_beam/transforms/trigger.py b/sdks/python/apache_beam/transforms/trigger.py
index 460e7111a22..b53e7564eb3 100644
--- a/sdks/python/apache_beam/transforms/trigger.py
+++ b/sdks/python/apache_beam/transforms/trigger.py
@@ -114,6 +114,15 @@ class _CombiningValueStateTag(_StateTag):
   def with_prefix(self, prefix):
     return _CombiningValueStateTag(prefix + self.tag, self.combine_fn)
 
+  def without_extraction(self):
+    class NoExtractionCombineFn(core.CombineFn):
+      create_accumulator = self.combine_fn.create_accumulator
+      add_input = self.combine_fn.add_input
+      merge_accumulators = self.combine_fn.merge_accumulators
+      compact_accumulator = self.combine_fn.compact_accumulator
+      extract_output = staticmethod(lambda x: x)
+    return _CombiningValueStateTag(self.tag, NoExtractionCombineFn())
+
 
 class _ListStateTag(_StateTag):
   """StateTag pointing to a list of elements."""
@@ -838,24 +847,21 @@ class MergeableStateAdapter(SimpleState):
     if isinstance(tag, _ValueStateTag):
       raise ValueError(
           'Merging requested for non-mergeable state tag: %r.' % tag)
+    elif isinstance(tag, _CombiningValueStateTag):
+      tag = tag.without_extraction()
     self.raw_state.add_state(self._get_id(window), tag, value)
 
   def get_state(self, window, tag):
+    if isinstance(tag, _CombiningValueStateTag):
+      original_tag, tag = tag, tag.without_extraction()
     values = [self.raw_state.get_state(window_id, tag)
               for window_id in self._get_ids(window)]
     if isinstance(tag, _ValueStateTag):
       raise ValueError(
           'Merging requested for non-mergeable state tag: %r.' % tag)
     elif isinstance(tag, _CombiningValueStateTag):
-      # TODO(robertwb): Strip combine_fn.extract_output from raw_state tag.
-      if not values:
-        accumulator = tag.combine_fn.create_accumulator()
-      elif len(values) == 1:
-        accumulator = values[0]
-      else:
-        accumulator = tag.combine_fn.merge_accumulators(values)
-        # TODO(robertwb): Store the merged value in the first tag.
-      return tag.combine_fn.extract_output(accumulator)
+      return original_tag.combine_fn.extract_output(
+          original_tag.combine_fn.merge_accumulators(values))
     elif isinstance(tag, _ListStateTag):
       return [v for vs in values for v in vs]
     elif isinstance(tag, _WatermarkHoldStateTag):
@@ -1211,6 +1217,7 @@ class InMemoryUnmergedState(UnmergedState):
     if isinstance(tag, _ValueStateTag):
       self.state[window][tag.tag] = value
     elif isinstance(tag, _CombiningValueStateTag):
+      # TODO(robertwb): Store merged accumulators.
       self.state[window][tag.tag].append(value)
     elif isinstance(tag, _ListStateTag):
       self.state[window][tag.tag].append(value)
