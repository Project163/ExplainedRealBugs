diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/TypedCombineFnDelegate.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/TypedCombineFnDelegate.java
new file mode 100644
index 00000000000..e77e6a382aa
--- /dev/null
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/TypedCombineFnDelegate.java
@@ -0,0 +1,164 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.extensions.sql;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.TypeVariable;
+import java.util.Optional;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import org.apache.beam.sdk.annotations.Experimental;
+import org.apache.beam.sdk.coders.CannotProvideCoderException;
+import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.CoderRegistry;
+import org.apache.beam.sdk.transforms.Combine;
+import org.apache.beam.sdk.transforms.display.DisplayData;
+import org.apache.beam.sdk.util.Preconditions;
+import org.apache.beam.sdk.values.TypeDescriptor;
+
+/**
+ * A {@link Combine.CombineFn} delegating all relevant calls to given delegate. This is used to
+ * create a type anonymous class for cases where the CombineFn is a generic class. The anonymous
+ * class can then be used in a UDAF as
+ *
+ * <pre>
+ *   .registerUdaf("UDAF", new TypedCombineFnDelegate<>(genericCombineFn) {})
+ * </pre>
+ *
+ * @param <InputT> the type of input
+ * @param <AccumT> the type of accumulator
+ * @param <OutputT> the type of output
+ */
+@Experimental
+public class TypedCombineFnDelegate<InputT, AccumT, OutputT>
+    extends Combine.CombineFn<InputT, AccumT, OutputT> {
+
+  private final Combine.CombineFn<InputT, AccumT, OutputT> delegate;
+
+  protected TypedCombineFnDelegate(Combine.CombineFn<InputT, AccumT, OutputT> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public TypeDescriptor<OutputT> getOutputType() {
+    return Optional.<TypeDescriptor<OutputT>>ofNullable(getGenericSuperTypeAtIndex(2))
+        .orElse(delegate.getOutputType());
+  }
+
+  @Override
+  public TypeDescriptor<InputT> getInputType() {
+    return Optional.<TypeDescriptor<InputT>>ofNullable(getGenericSuperTypeAtIndex(0))
+        .orElse(delegate.getInputType());
+  }
+
+  @Override
+  public AccumT createAccumulator() {
+    return delegate.createAccumulator();
+  }
+
+  @Override
+  public AccumT addInput(AccumT mutableAccumulator, InputT input) {
+    return delegate.addInput(mutableAccumulator, input);
+  }
+
+  @Override
+  public AccumT mergeAccumulators(Iterable<AccumT> accumulators) {
+    return delegate.mergeAccumulators(accumulators);
+  }
+
+  @Override
+  public OutputT extractOutput(AccumT accumulator) {
+    return delegate.extractOutput(accumulator);
+  }
+
+  @Override
+  public AccumT compact(AccumT accumulator) {
+    return delegate.compact(accumulator);
+  }
+
+  @Override
+  public OutputT apply(Iterable<? extends InputT> inputs) {
+    return delegate.apply(inputs);
+  }
+
+  @Override
+  public OutputT defaultValue() {
+    return delegate.defaultValue();
+  }
+
+  @Override
+  public Coder<AccumT> getAccumulatorCoder(CoderRegistry registry, Coder<InputT> inputCoder)
+      throws CannotProvideCoderException {
+    return delegate.getAccumulatorCoder(registry, inputCoder);
+  }
+
+  @Override
+  public Coder<OutputT> getDefaultOutputCoder(CoderRegistry registry, Coder<InputT> inputCoder)
+      throws CannotProvideCoderException {
+    return delegate.getDefaultOutputCoder(registry, inputCoder);
+  }
+
+  @Override
+  public String getIncompatibleGlobalWindowErrorMessage() {
+    return delegate.getIncompatibleGlobalWindowErrorMessage();
+  }
+
+  @Override
+  public TypeVariable<?> getInputTVariable() {
+    return delegate.getInputTVariable();
+  }
+
+  @Override
+  public TypeVariable<?> getAccumTVariable() {
+    return delegate.getAccumTVariable();
+  }
+
+  @Override
+  public TypeVariable<?> getOutputTVariable() {
+    return delegate.getOutputTVariable();
+  }
+
+  @Override
+  public void populateDisplayData(DisplayData.Builder builder) {
+    delegate.populateDisplayData(builder);
+  }
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  private <T> TypeDescriptor<T> getGenericSuperTypeAtIndex(int index) {
+    Class<?> cls = Preconditions.checkArgumentNotNull(getClass());
+    do {
+      Class<?> superClass = cls.getSuperclass();
+      if (superClass == null) {
+        break;
+      }
+      if (superClass.equals(TypedCombineFnDelegate.class)) {
+        @Nonnull
+        ParameterizedType superType =
+            (ParameterizedType) Preconditions.checkArgumentNotNull(cls.getGenericSuperclass());
+        TypeDescriptor<T> candidate =
+            (TypeDescriptor<T>) TypeDescriptor.of(superType.getActualTypeArguments()[index]);
+        if (!(candidate instanceof TypeVariable)) {
+          return candidate;
+        }
+      }
+      cls = superClass;
+    } while (true);
+    return null;
+  }
+}
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/UdafImpl.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/UdafImpl.java
index 5d7b0d40e2c..78cfd3b2534 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/UdafImpl.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/UdafImpl.java
@@ -20,8 +20,10 @@ package org.apache.beam.sdk.extensions.sql.impl;
 import java.io.Serializable;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import org.apache.beam.sdk.annotations.Experimental;
 import org.apache.beam.sdk.annotations.Internal;
 import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;
@@ -70,7 +72,16 @@ public class UdafImpl<InputT, AccumT, OutputT>
 
           @Override
           public RelDataType getType(RelDataTypeFactory typeFactory) {
-            return CalciteUtils.sqlTypeWithAutoCast(typeFactory, getInputType());
+            Type inputType = getInputType();
+            if (inputType instanceof TypeVariable) {
+              throw new IllegalArgumentException(
+                  "Unable to infer SQL type from type variable "
+                      + inputType
+                      + ". This usually means you are trying to use a generic type whose type information "
+                      + "is not known at runtime. You can wrap your CombineFn into typed subclass"
+                      + " by 'new TypedCombineFnDelegate<...>(combineFn) {}'");
+            }
+            return CalciteUtils.sqlTypeWithAutoCast(typeFactory, inputType);
           }
 
           @Override
@@ -94,6 +105,10 @@ public class UdafImpl<InputT, AccumT, OutputT>
   }
 
   protected Type getInputType() {
+    @Nullable Type inputType = combineFn.getInputType().getType();
+    if (inputType != null && !(inputType instanceof TypeVariable)) {
+      return inputType;
+    }
     ParameterizedType parameterizedType = findCombineFnSuperClass();
     return parameterizedType.getActualTypeArguments()[0];
   }
@@ -103,7 +118,9 @@ public class UdafImpl<InputT, AccumT, OutputT>
   }
 
   private ParameterizedType findCombineFnSuperClass() {
+
     Class clazz = combineFn.getClass();
+
     while (!clazz.getSuperclass().equals(CombineFn.class)) {
       clazz = clazz.getSuperclass();
     }
@@ -111,8 +128,7 @@ public class UdafImpl<InputT, AccumT, OutputT>
     if (!(clazz.getGenericSuperclass() instanceof ParameterizedType)) {
       throw new IllegalStateException(
           "Subclass of " + CombineFn.class + " must be parameterized to be used as a UDAF");
-    } else {
-      return (ParameterizedType) clazz.getGenericSuperclass();
     }
+    return (ParameterizedType) clazz.getGenericSuperclass();
   }
 }
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/utils/CalciteUtils.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/utils/CalciteUtils.java
index 7b580ef0a1c..bf7b7e1859f 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/utils/CalciteUtils.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/utils/CalciteUtils.java
@@ -17,6 +17,7 @@
  */
 package org.apache.beam.sdk.extensions.sql.impl.utils;
 
+import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.Date;
@@ -313,16 +314,22 @@ public class CalciteUtils {
     } else if (type instanceof ParameterizedType) {
       ParameterizedType parameterizedType = (ParameterizedType) type;
       if (java.util.List.class.isAssignableFrom((Class<?>) parameterizedType.getRawType())) {
-        Class<?> genericType = (Class<?>) parameterizedType.getActualTypeArguments()[0];
-        RelDataType collectionElementType = typeFactory.createJavaType(genericType);
-        return typeFactory.createArrayType(collectionElementType, UNLIMITED_ARRAY_SIZE);
+        RelDataType elementType =
+            sqlTypeWithAutoCast(typeFactory, parameterizedType.getActualTypeArguments()[0]);
+        return typeFactory.createArrayType(elementType, UNLIMITED_ARRAY_SIZE);
       } else if (java.util.Map.class.isAssignableFrom((Class<?>) parameterizedType.getRawType())) {
-        Class<?> genericKeyType = (Class<?>) parameterizedType.getActualTypeArguments()[0];
-        Class<?> genericValueType = (Class<?>) parameterizedType.getActualTypeArguments()[1];
-        RelDataType mapElementKeyType = typeFactory.createJavaType(genericKeyType);
-        RelDataType mapElementValueType = typeFactory.createJavaType(genericValueType);
+        RelDataType mapElementKeyType =
+            sqlTypeWithAutoCast(typeFactory, parameterizedType.getActualTypeArguments()[0]);
+        RelDataType mapElementValueType =
+            sqlTypeWithAutoCast(typeFactory, parameterizedType.getActualTypeArguments()[1]);
         return typeFactory.createMapType(mapElementKeyType, mapElementValueType);
       }
+    } else if (type instanceof GenericArrayType) {
+      throw new IllegalArgumentException(
+          "Cannot infer types from "
+              + type
+              + ". This is currently unsupported, use List instead "
+              + "of Array.");
     }
     return typeFactory.createJavaType((Class) type);
   }
diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/TypedCombineFnDelegateTest.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/TypedCombineFnDelegateTest.java
new file mode 100644
index 00000000000..b9daa02e2d1
--- /dev/null
+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/TypedCombineFnDelegateTest.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.extensions.sql;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.Serializable;
+import java.util.Comparator;
+import java.util.List;
+import org.apache.beam.sdk.extensions.sql.impl.UdafImpl;
+import org.apache.beam.sdk.transforms.Combine;
+import org.apache.beam.sdk.transforms.Max;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.jdbc.JavaTypeFactoryImpl;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeFactory;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeSystem;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.schema.FunctionParameter;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlTypeName;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+public class TypedCombineFnDelegateTest {
+
+  @Rule public ExpectedException exceptions = ExpectedException.none();
+
+  @Test
+  public void testParameterExtractionFromCombineFn_CombineFnDelegate() {
+    Combine.BinaryCombineFn<String> max =
+        Max.of(
+            (Comparator<String> & Serializable) (a, b) -> Integer.compare(a.length(), b.length()));
+    UdafImpl<String, Combine.Holder<String>, String> udaf =
+        new UdafImpl<>(new TypedCombineFnDelegate<String, Combine.Holder<String>, String>(max) {});
+    RelDataTypeFactory typeFactory = new JavaTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
+    List<FunctionParameter> parameters = udaf.getParameters();
+    assertEquals(1, parameters.size());
+    assertEquals(SqlTypeName.VARCHAR, parameters.get(0).getType(typeFactory).getSqlTypeName());
+  }
+
+  @Test
+  public void testParameterExtractionFromCombineFn_CombineFnDelegate_WithGenericArray() {
+    Combine.BinaryCombineFn<List<String>[]> max =
+        Max.of(
+            (Comparator<List<String>[]> & Serializable)
+                (a, b) -> Integer.compare(a[0].get(0).length(), b[0].get(0).length()));
+    UdafImpl<List<String>[], Combine.Holder<List<String>[]>, List<String>[]> udaf =
+        new UdafImpl<>(
+            new TypedCombineFnDelegate<
+                List<String>[], Combine.Holder<List<String>[]>, List<String>[]>(max) {});
+    exceptions.expect(IllegalArgumentException.class);
+    RelDataTypeFactory typeFactory = new JavaTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
+    udaf.getParameters().get(0).getType(typeFactory);
+  }
+
+  @Test
+  public void testParameterExtractionFromCombineFn_CombineFnDelegate_WithListInsteadOfArray() {
+    Combine.BinaryCombineFn<List<List<String>>> max =
+        Max.of(
+            (Comparator<List<List<String>>> & Serializable)
+                (a, b) -> Integer.compare(a.get(0).get(0).length(), b.get(0).get(0).length()));
+    UdafImpl<List<List<String>>, Combine.Holder<List<List<String>>>, List<List<String>>> udaf =
+        new UdafImpl<>(
+            new TypedCombineFnDelegate<
+                List<List<String>>, Combine.Holder<List<List<String>>>, List<List<String>>>(
+                max) {});
+    RelDataTypeFactory typeFactory = new JavaTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
+    List<FunctionParameter> parameters = udaf.getParameters();
+    assertEquals(1, parameters.size());
+    assertEquals(SqlTypeName.ARRAY, parameters.get(0).getType(typeFactory).getSqlTypeName());
+  }
+}
