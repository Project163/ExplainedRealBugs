diff --git a/sdks/python/apache_beam/examples/snippets/snippets.py b/sdks/python/apache_beam/examples/snippets/snippets.py
index fcf183d784b..2fb6e590eb1 100644
--- a/sdks/python/apache_beam/examples/snippets/snippets.py
+++ b/sdks/python/apache_beam/examples/snippets/snippets.py
@@ -1444,3 +1444,51 @@ def accessing_valueprovider_info_after_run():
         | beam.combiners.Sum.Globally())
 
   # [END AccessingValueProviderInfoAfterRunSnip1]
+
+
+def side_input_slow_update(
+    src_file_pattern,
+    first_timestamp,
+    last_timestamp,
+    interval,
+    sample_main_input_elements,
+    main_input_windowing_interval):
+  # [START SideInputSlowUpdateSnip1]
+  from apache_beam.transforms.periodicsequence import PeriodicImpulse
+  from apache_beam.transforms.window import TimestampedValue
+  from apache_beam.transforms import window
+
+  # from apache_beam.utils.timestamp import MAX_TIMESTAMP
+  # last_timestamp = MAX_TIMESTAMP to go on indefninitely
+
+  # Any user-defined function.
+  # cross join is used as an example.
+  def cross_join(left, rights):
+    for x in rights:
+      yield (left, x)
+
+  # Create pipeline.
+  pipeline_options = PipelineOptions()
+  p = beam.Pipeline(options=pipeline_options)
+  side_input = (
+      p
+      | 'PeriodicImpulse' >> PeriodicImpulse(
+          first_timestamp, last_timestamp, interval, True)
+      | 'MapToFileName' >> beam.Map(lambda x: src_file_pattern + str(x))
+      | 'ReadFromFile' >> beam.io.ReadAllFromText())
+
+  main_input = (
+      p
+      | 'MpImpulse' >> beam.Create(sample_main_input_elements)
+      |
+      'MapMpToTimestamped' >> beam.Map(lambda src: TimestampedValue(src, src))
+      | 'WindowMpInto' >> beam.WindowInto(
+          window.FixedWindows(main_input_windowing_interval)))
+
+  result = (
+      main_input
+      | 'ApplyCrossJoin' >> beam.FlatMap(
+          cross_join, rights=beam.pvalue.AsIter(side_input)))
+  # [END SideInputSlowUpdateSnip1]
+
+  return p, result
diff --git a/sdks/python/apache_beam/examples/snippets/snippets_test.py b/sdks/python/apache_beam/examples/snippets/snippets_test.py
index 7f83395bbf4..793ff0519df 100644
--- a/sdks/python/apache_beam/examples/snippets/snippets_test.py
+++ b/sdks/python/apache_beam/examples/snippets/snippets_test.py
@@ -25,9 +25,11 @@ from __future__ import division
 import glob
 import gzip
 import logging
+import math
 import os
 import sys
 import tempfile
+import time
 import unittest
 import uuid
 from builtins import map
@@ -38,6 +40,7 @@ from builtins import zip
 import mock
 
 import apache_beam as beam
+import apache_beam.transforms.combiners as combiners
 from apache_beam import WindowInto
 from apache_beam import coders
 from apache_beam import pvalue
@@ -1302,6 +1305,55 @@ class PTransformTest(unittest.TestCase):
       assert_that(lengths, equal_to([1, 2, 3]))
 
 
+class SlowlyChangingSideInputsTest(unittest.TestCase):
+  """Tests for PTransform."""
+  def test_side_input_slow_update(self):
+    temp_file = tempfile.NamedTemporaryFile(delete=True)
+    src_file_pattern = temp_file.name
+    temp_file.close()
+
+    first_ts = math.floor(time.time()) - 30
+    interval = 5
+    main_input_windowing_interval = 7
+
+    # aligning timestamp to get persistent results
+    first_ts = first_ts - (
+        first_ts % (interval * main_input_windowing_interval))
+    last_ts = first_ts + 45
+
+    for i in range(-1, 10, 1):
+      count = i + 2
+      idstr = str(first_ts + interval * i)
+      with open(src_file_pattern + idstr, "w") as f:
+        for j in range(count):
+          f.write('f' + idstr + 'a' + str(j) + '\n')
+
+    sample_main_input_elements = ([first_ts - 2, # no output due to no SI
+                                   first_ts + 1,  # First window
+                                   first_ts + 8,  # Second window
+                                   first_ts + 15,  # Third window
+                                   first_ts + 22,  # Fourth window
+                                   ])
+
+    pipeline, pipeline_result = snippets.side_input_slow_update(
+      src_file_pattern, first_ts, last_ts, interval,
+      sample_main_input_elements, main_input_windowing_interval)
+
+    try:
+      with pipeline:
+        pipeline_result = (
+            pipeline_result
+            | 'AddKey' >> beam.Map(lambda v: ('key', v))
+            | combiners.Count.PerKey())
+
+        assert_that(
+            pipeline_result,
+            equal_to([('key', 3), ('key', 4), ('key', 6), ('key', 7)]))
+    finally:
+      for i in range(-1, 10, 1):
+        os.unlink(src_file_pattern + str(first_ts + interval * i))
+
+
 if __name__ == '__main__':
   logging.getLogger().setLevel(logging.INFO)
   unittest.main()
diff --git a/sdks/python/apache_beam/transforms/periodicsequence.py b/sdks/python/apache_beam/transforms/periodicsequence.py
new file mode 100644
index 00000000000..cddb4839c77
--- /dev/null
+++ b/sdks/python/apache_beam/transforms/periodicsequence.py
@@ -0,0 +1,192 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+from __future__ import absolute_import
+
+import time
+
+import apache_beam as beam
+import apache_beam.runners.sdf_utils as sdf_utils
+from apache_beam.io.restriction_trackers import OffsetRange
+from apache_beam.io.restriction_trackers import OffsetRestrictionTracker
+from apache_beam.transforms import core
+from apache_beam.transforms import window
+from apache_beam.transforms.ptransform import PTransform
+from apache_beam.transforms.window import TimestampedValue
+from apache_beam.utils import timestamp
+from apache_beam.utils.timestamp import MAX_TIMESTAMP
+from apache_beam.utils.timestamp import Timestamp
+
+
+class ImpulseSeqGenRestrictionProvider(core.RestrictionProvider):
+  def initial_restriction(self, element):
+    start, end, interval = element
+    return OffsetRange(start - interval, end)
+
+  def create_tracker(self, restriction):
+    return ImpulseSeqGenRestrictionTracker(restriction)
+
+  def restriction_size(self, unused_element, restriction):
+    return restriction.size()
+
+
+class ImpulseSeqGenRestrictionTracker(OffsetRestrictionTracker):
+  def try_split(self, fraction_of_remainder):
+    if not self._checkpointed:
+      if fraction_of_remainder != 0:
+        return None
+
+      if self._current_position is None:
+        cur = self._range.start
+      else:
+        cur = self._current_position
+      split_point = cur
+
+      if split_point < self._range.stop:
+        self._checkpointed = True
+        self._range, residual_range = self._range.split_at(split_point)
+        return self._range, residual_range
+
+  def cur_pos(self):
+    return self._current_position
+
+  def try_claim(self, pos):
+    if ((self._last_claim_attempt is None) or
+        (pos > self._last_claim_attempt and pos == self._range.stop)):
+      self._last_claim_attempt = pos
+      return True
+    else:
+      return super(ImpulseSeqGenRestrictionTracker, self).try_claim(pos)
+
+
+class ImpulseSeqGenDoFn(beam.DoFn):
+  '''
+  ImpulseSeqGenDoFn fn receives tuple elements with three parts:
+
+  * first_timestamp = first timestamp to output element for.
+  * last_timestamp = last timestamp/time to output element for.
+  * fire_interval = how often to fire an element.
+
+  For each input element received, ImpulseSeqGenDoFn fn will start
+  generating output elements in following pattern:
+
+  * if element timestamp is less than current runtime then output element.
+  * if element timestamp is greater than current runtime, wait until next
+    element timestamp.
+
+  ImpulseSeqGenDoFn can't guarantee that each element is output at exact time.
+  ImpulseSeqGenDoFn guarantees that elements would not be output prior to
+  given runtime timestamp.
+  '''
+  def process(
+      self,
+      element,
+      restriction_tracker=beam.DoFn.RestrictionParam(
+          ImpulseSeqGenRestrictionProvider())):
+    '''
+    :param element: (start_timestamp, end_timestamp, interval)
+    :param restriction_tracker:
+    :return: yields elements at processing real-time intervals with value of
+      target output timestamp for the element.
+    '''
+    _, _, interval = element
+
+    assert isinstance(restriction_tracker, sdf_utils.RestrictionTrackerView)
+
+    current_time = time.time()
+    restriction = restriction_tracker.current_restriction()
+    current_output_timestamp = restriction.start
+
+    restriction_tracker.try_claim(current_output_timestamp)
+    if current_output_timestamp <= current_time:
+      if restriction_tracker.try_claim(current_output_timestamp + interval):
+        current_output_timestamp += interval
+        yield current_output_timestamp
+
+    if current_output_timestamp + interval >= restriction.stop:
+      restriction_tracker.try_claim(restriction.stop)
+    else:
+      restriction_tracker.defer_remainder(
+          timestamp.Timestamp(current_output_timestamp))
+
+
+class PeriodicSequence(PTransform):
+  '''
+  PeriodicSequence transform receives tuple elements with three parts:
+
+  * first_timestamp = first timestamp to output element for.
+  * last_timestamp = last timestamp/time to output element for.
+  * fire_interval = how often to fire an element.
+
+  For each input element received, PeriodicSequence transform will start
+  generating output elements in following pattern:
+
+  * if element timestamp is less than current runtime then output element.
+  * if element timestamp is greater than current runtime, wait until next
+    element timestamp.
+
+  PeriodicSequence can't guarantee that each element is output at exact time.
+  PeriodicSequence guarantees that elements would not be output prior to given
+  runtime timestamp.
+  '''
+  def __init_(self):
+    pass
+
+  def expand(self, pcoll):
+    return (
+        pcoll
+        | 'GenSequence' >> beam.ParDo(ImpulseSeqGenDoFn())
+        | 'MapToTimestamped' >> beam.Map(lambda tt: TimestampedValue(tt, tt)))
+
+
+class PeriodicImpulse(PTransform):
+  '''
+  PeriodicImpulse transform generates an infinite sequence of elements with
+  given runtime interval.
+
+  PeriodicImpulse transform behaves same as {@link PeriodicSequence} transform,
+  but can be used as first transform in pipeline.
+  '''
+  def __init__(
+      self,
+      start_timestamp=Timestamp.now(),
+      stop_timestamp=MAX_TIMESTAMP,
+      fire_interval=360.0,
+      apply_windowing=False):
+    '''
+    :param start_timestamp: Timestamp for first element.
+    :param stop_timestamp: Timestamp after which no elements will be output.
+    :param fire_interval: Interval at which to output elements.
+    :param apply_windowing: Whether each element should be assigned to
+      individual window. If false, all elements will reside in global window.
+    '''
+    self.start_ts = start_timestamp
+    self.stop_ts = stop_timestamp
+    self.interval = fire_interval
+    self.apply_windowing = apply_windowing
+
+  def expand(self, pbegin):
+    result = (
+        pbegin
+        | 'ImpulseElement' >> beam.Create(
+            [(self.start_ts, self.stop_ts, self.interval)])
+        | 'GenSequence' >> beam.ParDo(ImpulseSeqGenDoFn())
+        | 'MapToTimestamped' >> beam.Map(lambda tt: TimestampedValue(tt, tt)))
+    if self.apply_windowing:
+      result = result | 'ApplyWindowing' >> beam.WindowInto(
+          window.FixedWindows(self.interval))
+    return result
diff --git a/sdks/python/apache_beam/transforms/periodicsequence_test.py b/sdks/python/apache_beam/transforms/periodicsequence_test.py
new file mode 100644
index 00000000000..544eb5b3730
--- /dev/null
+++ b/sdks/python/apache_beam/transforms/periodicsequence_test.py
@@ -0,0 +1,102 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+"""Unit tests for the PTransform and descendants."""
+
+# pytype: skip-file
+
+from __future__ import absolute_import
+from __future__ import division
+from __future__ import print_function
+
+import time
+import unittest
+from builtins import range
+
+import apache_beam as beam
+from apache_beam.testing.test_pipeline import TestPipeline
+from apache_beam.testing.util import assert_that
+from apache_beam.testing.util import equal_to
+from apache_beam.transforms.periodicsequence import PeriodicImpulse
+from apache_beam.transforms.periodicsequence import PeriodicSequence
+
+# Disable frequent lint warning due to pipe operator for chaining transforms.
+# pylint: disable=expression-not-assigned
+
+
+class PeriodicSequenceTest(unittest.TestCase):
+  # Enable nose tests running in parallel
+
+  def test_periodicsequence_outputs_valid_sequence(self):
+    start_offset = 1
+    start_time = time.time() + start_offset
+    duration = 1
+    end_time = start_time + duration
+    interval = 0.25
+
+    with TestPipeline() as p:
+      result = (
+          p
+          | 'ImpulseElement' >> beam.Create([(start_time, end_time, interval)])
+          | 'ImpulseSeqGen' >> PeriodicSequence())
+
+      k = [
+          start_time + x * interval
+          for x in range(0, int(duration / interval), 1)
+      ]
+
+      assert_that(result, equal_to(k))
+
+  def test_periodicimpulse_windowing_on_si(self):
+    start_offset = -15
+    it = time.time() + start_offset
+    duration = 15
+    et = it + duration
+    interval = 5
+
+    with TestPipeline() as p:
+      si = (
+          p
+          | 'PeriodicImpulse' >> PeriodicImpulse(it, et, interval, True)
+          | 'AddKey' >> beam.Map(lambda v: ('key', v))
+          | 'GBK' >> beam.GroupByKey()
+          | 'SortGBK' >> beam.MapTuple(lambda k, vs: (k, sorted(vs))))
+
+      actual = si
+      k = [('key', [it + x * interval])
+           for x in range(0, int(duration / interval), 1)]
+      assert_that(actual, equal_to(k))
+
+  def test_periodicsequence_outputs_valid_sequence_in_past(self):
+    start_offset = -10000
+    it = time.time() + start_offset
+    duration = 5
+    et = it + duration
+    interval = 1
+
+    with TestPipeline() as p:
+      result = (
+          p
+          | 'ImpulseElement' >> beam.Create([(it, et, interval)])
+          | 'ImpulseSeqGen' >> PeriodicSequence())
+
+      k = [it + x * interval for x in range(0, int(duration / interval), 1)]
+      assert_that(result, equal_to(k))
+
+
+if __name__ == '__main__':
+  unittest.main()
diff --git a/website/src/documentation/patterns/side-inputs.md b/website/src/documentation/patterns/side-inputs.md
index 854c2768127..973c6356ac5 100644
--- a/website/src/documentation/patterns/side-inputs.md
+++ b/website/src/documentation/patterns/side-inputs.md
@@ -29,11 +29,11 @@ You can retrieve side inputs from global windows to use them in a pipeline job w
 To slowly update global window side inputs in pipelines with non-global windows:
 
 1. Write a `DoFn` that periodically pulls data from a bounded source into a global window.
-    
+
     a. Use the `GenerateSequence` source transform to periodically emit a value.
 
     b. Instantiate a data-driven trigger that activates on each element and pulls data from a bounded source.
-    
+
     c. Fire the trigger to pass the data into the global window.
 
 1. Create the side input for downstream transforms. The side input should fit into memory.
@@ -45,4 +45,30 @@ For instance, the following code sample uses a `Map` to create a `DoFn`. The `Ma
 ```java
 {% github_sample /apache/beam/blob/master/examples/java/src/main/java/org/apache/beam/examples/snippets/Snippets.java tag:SideInputPatternSlowUpdateGlobalWindowSnip1
 %}
-```
\ No newline at end of file
+```
+
+
+## Slowly updating side input using windowing
+
+You can read side input pcollection periodically into distinct windows.
+Later, when you apply side input to your main input, windows will be matched automatically 1:1.
+This way, you can guarantee side input consistency on the duration of the single window.
+
+To do this, you can utilize PeriodicSequence PTransform that will generate infinite sequence
+of elements with some real-time period:
+
+1. Use the PeriodicImpulse transform to generate windowed periodic sequence.
+
+    a. MAX_TIMESTAMP can be replaced with some closer boundary if you want to stop generating elements at some point.
+
+1. Read data using Read operation triggered by arrival of PCollection element.
+
+1. Apply side input.
+
+```python
+{% github_sample /apache/beam/blob/master/sdks/python/apache_beam/examples/snippets/snippets.py tag:SideInputSlowUpdateSnip1
+%}
+```
+
+
+
