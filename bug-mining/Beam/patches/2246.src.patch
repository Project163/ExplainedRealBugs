diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java
index 4982066642e..09464db3ae7 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java
@@ -62,6 +62,7 @@ import org.apache.beam.sdk.values.TypeDescriptor;
 import org.apache.beam.sdk.values.ValueWithRecordId;
 import org.apache.beam.sdk.values.ValueWithRecordId.StripIdsDoFn;
 import org.apache.beam.sdk.values.ValueWithRecordId.ValueWithRecordIdCoder;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.Cache;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.CacheBuilder;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.RemovalListener;
@@ -175,7 +176,8 @@ public class Read {
   public static class Unbounded<T> extends PTransform<PBegin, PCollection<T>> {
     private final UnboundedSource<T, CheckpointMark> source;
 
-    private Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {
+    @VisibleForTesting
+    Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {
       super(name);
       this.source =
           (UnboundedSource<T, CheckpointMark>) SerializableUtils.ensureSerializable(source);
@@ -214,10 +216,7 @@ public class Read {
               .apply(ParDo.of(new OutputSingleSource<>(source)))
               .setCoder(
                   SerializableCoder.of(new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {}))
-              .apply(
-                  ParDo.of(
-                      new UnboundedSourceAsSDFWrapperFn<>(
-                          (Coder<CheckpointMark>) source.getCheckpointMarkCoder())))
+              .apply(ParDo.of(createUnboundedSdfWrapper()))
               .setCoder(ValueWithRecordIdCoder.of(source.getOutputCoder()));
 
       if (source.requiresDeduping()) {
@@ -229,6 +228,11 @@ public class Read {
       return outputWithIds.apply(ParDo.of(new StripIdsDoFn<>()));
     }
 
+    @VisibleForTesting
+    UnboundedSourceAsSDFWrapperFn<T, CheckpointMark> createUnboundedSdfWrapper() {
+      return new UnboundedSourceAsSDFWrapperFn<>(source.getCheckpointMarkCoder());
+    }
+
     /** Returns the {@code UnboundedSource} used to create this {@code Read} {@code PTransform}. */
     public UnboundedSource<T, ?> getSource() {
       return source;
@@ -447,7 +451,8 @@ public class Read {
     private Cache<Object, UnboundedReader<OutputT>> cachedReaders;
     private Coder<UnboundedSourceRestriction<OutputT, CheckpointT>> restrictionCoder;
 
-    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> checkpointCoder) {
+    @VisibleForTesting
+    UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> checkpointCoder) {
       this.checkpointCoder = checkpointCoder;
     }
 
@@ -535,6 +540,7 @@ public class Read {
 
       UnboundedSourceValue<OutputT>[] out = new UnboundedSourceValue[1];
       while (tracker.tryClaim(out) && out[0] != null) {
+        watermarkEstimator.setWatermark(out[0].getWatermark());
         receiver.outputWithTimestamp(
             new ValueWithRecordId<>(out[0].getValue(), out[0].getId()), out[0].getTimestamp());
       }
@@ -542,8 +548,11 @@ public class Read {
       UnboundedSourceRestriction<OutputT, CheckpointT> currentRestriction =
           tracker.currentRestriction();
 
-      // Advance the watermark even if zero elements may have been output.
-      watermarkEstimator.setWatermark(currentRestriction.getWatermark());
+      // Advance the watermark even if zero elements may have been output, if we have not
+      // split the restriction
+      if (!currentRestriction.isSplit()) {
+        watermarkEstimator.setWatermark(currentRestriction.getWatermark());
+      }
 
       // Add the checkpoint mark to be finalized if the checkpoint mark isn't trivial and is not
       // the initial restriction. The initial restriction would have been finalized as part of
@@ -602,9 +611,11 @@ public class Read {
     @AutoValue
     abstract static class UnboundedSourceValue<T> {
 
-      public static <T> UnboundedSourceValue<T> create(byte[] id, T value, Instant timestamp) {
+      public static <T> UnboundedSourceValue<T> create(
+          byte[] id, T value, Instant timestamp, Instant watermark) {
+
         return new AutoValue_Read_UnboundedSourceAsSDFWrapperFn_UnboundedSourceValue<T>(
-            id, value, timestamp);
+            id, value, timestamp, watermark);
       }
 
       @SuppressWarnings("mutable")
@@ -613,6 +624,8 @@ public class Read {
       public abstract T getValue();
 
       public abstract Instant getTimestamp();
+
+      public abstract Instant getWatermark();
     }
 
     /**
@@ -636,6 +649,10 @@ public class Read {
       public abstract @Nullable CheckpointT getCheckpoint();
 
       public abstract Instant getWatermark();
+
+      public boolean isSplit() {
+        return getSource() instanceof EmptyUnboundedSource;
+      }
     }
 
     /** A {@link Coder} for {@link UnboundedSourceRestriction}s. */
@@ -846,7 +863,8 @@ public class Read {
               UnboundedSourceValue.create(
                   currentReader.getCurrentRecordId(),
                   currentReader.getCurrent(),
-                  currentReader.getCurrentTimestamp());
+                  currentReader.getCurrentTimestamp(),
+                  currentReader.getWatermark());
           return true;
         } catch (IOException e) {
           if (currentReader != null) {
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/ReadTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/ReadTest.java
index 5f77b07ae47..e80a97235c6 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/ReadTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/ReadTest.java
@@ -17,18 +17,30 @@
  */
 package org.apache.beam.sdk.io;
 
+import static org.apache.beam.sdk.testing.SerializableMatchers.greaterThanOrEqualTo;
 import static org.apache.beam.sdk.transforms.display.DisplayDataMatchers.hasDisplayItem;
 import static org.apache.beam.sdk.transforms.display.DisplayDataMatchers.includesDisplayDataFor;
 import static org.hamcrest.MatcherAssert.assertThat;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import java.util.NoSuchElementException;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Consumer;
 import java.util.stream.Collectors;
 import java.util.stream.LongStream;
 import org.apache.beam.sdk.coders.AvroCoder;
 import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.CoderException;
+import org.apache.beam.sdk.coders.CustomCoder;
 import org.apache.beam.sdk.coders.StringUtf8Coder;
 import org.apache.beam.sdk.coders.VarLongCoder;
 import org.apache.beam.sdk.io.CountingSource.CounterMark;
@@ -38,11 +50,17 @@ import org.apache.beam.sdk.options.PipelineOptions;
 import org.apache.beam.sdk.testing.NeedsRunner;
 import org.apache.beam.sdk.testing.PAssert;
 import org.apache.beam.sdk.testing.TestPipeline;
+import org.apache.beam.sdk.transforms.Count;
 import org.apache.beam.sdk.transforms.DoFn;
 import org.apache.beam.sdk.transforms.display.DisplayData;
 import org.apache.beam.sdk.transforms.reflect.DoFnInvokers;
+import org.apache.beam.sdk.transforms.splittabledofn.WatermarkEstimators;
+import org.apache.beam.sdk.transforms.windowing.AfterWatermark;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
+import org.apache.beam.sdk.transforms.windowing.GlobalWindows;
+import org.apache.beam.sdk.transforms.windowing.Window;
 import org.apache.beam.sdk.values.PCollection;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.MoreObjects;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.joda.time.Duration;
@@ -61,6 +79,10 @@ import org.junit.runners.JUnit4;
   "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
 })
 public class ReadTest implements Serializable {
+
+  private static final Map<String, List<Instant>> STATIC_INSTANT_LIST_MAP =
+      new ConcurrentHashMap<>();
+
   @Rule public transient ExpectedException thrown = ExpectedException.none();
   @Rule public final transient TestPipeline pipeline = TestPipeline.create();
 
@@ -127,7 +149,7 @@ public class ReadTest implements Serializable {
 
   @Test
   @Category(NeedsRunner.class)
-  public void testUnboundedSdfWrapperCacheStartedReaders() throws Exception {
+  public void testUnboundedSdfWrapperCacheStartedReaders() {
     long numElements = 1000L;
     PCollection<Long> input =
         pipeline.apply(Read.from(new ExpectCacheUnboundedSource(numElements)));
@@ -142,6 +164,67 @@ public class ReadTest implements Serializable {
         .waitUntilFinish();
   }
 
+  @Test
+  @Category(NeedsRunner.class)
+  public void testWatermarkAdvanceOnClaimFail() {
+    // NOTE: this test is supposed to run only against DirectRunner
+    // as for other runners it might not be working the interception of watermark
+    // through the STATIC_INSTANT_LIST_MAP
+    int numElements = 1000;
+    final String uuid = UUID.randomUUID().toString();
+    List<Instant> interceptedWatermark =
+        STATIC_INSTANT_LIST_MAP.computeIfAbsent(uuid, tmp -> new ArrayList<>());
+    PCollection<Long> counted =
+        pipeline
+            .apply(
+                newUnboundedReadInterceptingWatermark(
+                    numElements,
+                    (Serializable & Consumer<Instant>)
+                        (instant -> STATIC_INSTANT_LIST_MAP.get(uuid).add(instant))))
+            .apply(
+                Window.<Long>into(new GlobalWindows())
+                    .discardingFiredPanes()
+                    .triggering(AfterWatermark.pastEndOfWindow()))
+            .apply(Count.globally());
+    PAssert.that(counted).containsInAnyOrder((long) numElements);
+    pipeline.run().waitUntilFinish();
+    // verify that the observed watermark gradually moves
+    assertThat(interceptedWatermark.size(), greaterThanOrEqualTo(numElements));
+    Instant watermark = interceptedWatermark.get(0);
+    for (int i = 1; i < interceptedWatermark.size(); i++) {
+      assertThat(
+          "Watermarks should be non-decreasing sequence, got " + interceptedWatermark,
+          !watermark.isAfter(interceptedWatermark.get(i)));
+      watermark = interceptedWatermark.get(i);
+    }
+  }
+
+  private <T extends Serializable & Consumer<Instant>>
+      Read.Unbounded<Long> newUnboundedReadInterceptingWatermark(
+          long numElements, T interceptedWatermarkReceiver) {
+
+    UnboundedLongSource source = new UnboundedLongSource(numElements);
+    return new Read.Unbounded<Long>(null, source) {
+      @Override
+      @SuppressWarnings("unchecked")
+      Read.UnboundedSourceAsSDFWrapperFn<Long, CheckpointMark> createUnboundedSdfWrapper() {
+        return new Read.UnboundedSourceAsSDFWrapperFn<Long, CheckpointMark>(
+            (Coder) source.getCheckpointMarkCoder()) {
+          @Override
+          public WatermarkEstimators.Manual newWatermarkEstimator(Instant watermarkEstimatorState) {
+            return new WatermarkEstimators.Manual(watermarkEstimatorState) {
+              @Override
+              public void setWatermark(Instant watermark) {
+                super.setWatermark(watermark);
+                interceptedWatermarkReceiver.accept(watermark);
+              }
+            };
+          }
+        };
+      }
+    };
+  }
+
   private abstract static class CustomBoundedSource extends BoundedSource<String> {
     @Override
     public List<? extends BoundedSource<String>> split(
@@ -312,4 +395,114 @@ public class ReadTest implements Serializable {
   private static class SerializableUnboundedSource extends CustomUnboundedSource {}
 
   private static class NotSerializableClass {}
+
+  private static class OffsetCheckpointMark implements CheckpointMark {
+
+    private static final Coder<OffsetCheckpointMark> CODER =
+        new CustomCoder<OffsetCheckpointMark>() {
+          private final VarLongCoder longCoder = VarLongCoder.of();
+
+          @Override
+          public void encode(OffsetCheckpointMark value, OutputStream outStream)
+              throws CoderException, IOException {
+            longCoder.encode(value.offset, outStream);
+          }
+
+          @Override
+          public OffsetCheckpointMark decode(InputStream inStream)
+              throws CoderException, IOException {
+            return new OffsetCheckpointMark(longCoder.decode(inStream));
+          }
+        };
+
+    private final long offset;
+
+    OffsetCheckpointMark(Long offset) {
+      this.offset = MoreObjects.firstNonNull(offset, -1L);
+    }
+
+    @Override
+    public void finalizeCheckpoint() {}
+  }
+
+  private class UnboundedLongSource extends UnboundedSource<Long, OffsetCheckpointMark> {
+
+    private final long numElements;
+
+    public UnboundedLongSource(long numElements) {
+      this.numElements = numElements;
+    }
+
+    @Override
+    public List<? extends UnboundedSource<Long, OffsetCheckpointMark>> split(
+        int desiredNumSplits, PipelineOptions options) {
+
+      return Collections.singletonList(this);
+    }
+
+    @Override
+    public UnboundedReader<Long> createReader(
+        PipelineOptions options, @Nullable OffsetCheckpointMark checkpointMark) {
+
+      return new UnboundedLongSourceReader(
+          Optional.ofNullable(checkpointMark).map(m -> m.offset).orElse(-1L));
+    }
+
+    @Override
+    public Coder<Long> getOutputCoder() {
+      return VarLongCoder.of();
+    }
+
+    @Override
+    public Coder<OffsetCheckpointMark> getCheckpointMarkCoder() {
+      return OffsetCheckpointMark.CODER;
+    }
+
+    private class UnboundedLongSourceReader extends UnboundedReader<Long> {
+      private final Instant now = Instant.now();
+      private long current;
+
+      UnboundedLongSourceReader(long current) {
+        this.current = current;
+      }
+
+      @Override
+      public Long getCurrent() throws NoSuchElementException {
+        return current;
+      }
+
+      @Override
+      public Instant getCurrentTimestamp() throws NoSuchElementException {
+        return current < 0 ? now : now.plus(current);
+      }
+
+      @Override
+      public void close() throws IOException {}
+
+      @Override
+      public boolean start() throws IOException {
+        return advance();
+      }
+
+      @Override
+      public boolean advance() throws IOException {
+        return ++current < numElements;
+      }
+
+      @Override
+      public Instant getWatermark() {
+        return current < numElements ? getCurrentTimestamp() : BoundedWindow.TIMESTAMP_MAX_VALUE;
+      }
+
+      @Override
+      public CheckpointMark getCheckpointMark() {
+        return new OffsetCheckpointMark(current);
+      }
+
+      @Override
+      public UnboundedSource<Long, ?> getCurrentSource() {
+        return UnboundedLongSource.this;
+      }
+    }
+  }
 }
