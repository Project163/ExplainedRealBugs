diff --git a/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/stream/DirectStreamObserver.java b/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/stream/DirectStreamObserver.java
index eb7183f7cea..d098f593e39 100644
--- a/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/stream/DirectStreamObserver.java
+++ b/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/stream/DirectStreamObserver.java
@@ -21,7 +21,11 @@ package org.apache.beam.sdk.fn.stream;
 import io.grpc.stub.CallStreamObserver;
 import io.grpc.stub.StreamObserver;
 import java.util.concurrent.Phaser;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import javax.annotation.concurrent.ThreadSafe;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A {@link StreamObserver} which uses synchronization on the underlying
@@ -34,21 +38,66 @@ import javax.annotation.concurrent.ThreadSafe;
  */
 @ThreadSafe
 public final class DirectStreamObserver<T> implements StreamObserver<T> {
+  private static final Logger LOGGER = LoggerFactory.getLogger(DirectStreamObserver.class);
+  private static final int DEFAULT_MAX_MESSAGES_BEFORE_CHECK = 100;
+
   private final Phaser phaser;
   private final CallStreamObserver<T> outboundObserver;
+  private final int maxMessagesBeforeCheck;
+
+  private int numberOfMessagesBeforeReadyCheck;
 
   public DirectStreamObserver(
       Phaser phaser,
       CallStreamObserver<T> outboundObserver) {
+    this(phaser, outboundObserver, DEFAULT_MAX_MESSAGES_BEFORE_CHECK);
+  }
+
+  DirectStreamObserver(
+      Phaser phaser,
+      CallStreamObserver<T> outboundObserver,
+      int maxMessagesBeforeCheck) {
     this.phaser = phaser;
     this.outboundObserver = outboundObserver;
+    this.maxMessagesBeforeCheck = maxMessagesBeforeCheck;
   }
 
   @Override
   public void onNext(T value) {
-    int phase = phaser.getPhase();
-    if (!outboundObserver.isReady()) {
-      phaser.awaitAdvance(phase);
+    numberOfMessagesBeforeReadyCheck += 1;
+    if (numberOfMessagesBeforeReadyCheck >= maxMessagesBeforeCheck) {
+      numberOfMessagesBeforeReadyCheck = 0;
+      int waitTime = 1;
+      int totalTimeWaited = 0;
+      int phase = phaser.getPhase();
+      while (!outboundObserver.isReady()) {
+        try {
+          phaser.awaitAdvanceInterruptibly(phase, waitTime, TimeUnit.SECONDS);
+        } catch (TimeoutException e) {
+          totalTimeWaited += waitTime;
+          waitTime = waitTime * 2;
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+          throw new RuntimeException(e);
+        }
+      }
+      if (totalTimeWaited > 0) {
+        // If the phase didn't change, this means that the installed onReady callback had not
+        // been invoked.
+        if (phase == phaser.getPhase()) {
+          LOGGER.info(
+              "Output channel stalled for {}s, outbound thread {}. See: "
+              + "https://issues.apache.org/jira/browse/BEAM-4280 for the history for "
+              + "this issue.",
+              totalTimeWaited,
+              Thread.currentThread().getName());
+        } else {
+          LOGGER.debug(
+              "Output channel stalled for {}s, outbound thread {}.",
+              totalTimeWaited,
+              Thread.currentThread().getName());
+        }
+      }
     }
     synchronized (outboundObserver) {
       outboundObserver.onNext(value);
diff --git a/sdks/java/fn-execution/src/test/java/org/apache/beam/sdk/fn/stream/DirectStreamObserverTest.java b/sdks/java/fn-execution/src/test/java/org/apache/beam/sdk/fn/stream/DirectStreamObserverTest.java
index bd6c318e7c9..d0a5ed9b97c 100644
--- a/sdks/java/fn-execution/src/test/java/org/apache/beam/sdk/fn/stream/DirectStreamObserverTest.java
+++ b/sdks/java/fn-execution/src/test/java/org/apache/beam/sdk/fn/stream/DirectStreamObserverTest.java
@@ -98,7 +98,8 @@ public class DirectStreamObserverTest {
             phaser,
             TestStreams.withOnNext((String t) -> assertTrue(elementsAllowed.get()))
                 .withIsReady(elementsAllowed::get)
-                .build());
+                .build(),
+            0);
 
     // Start all the tasks
     List<Future<String>> results = new ArrayList<>();
@@ -114,7 +115,7 @@ public class DirectStreamObserverTest {
     }
 
     // Have them wait and then flip that we do allow elements and wake up those awaiting
-    Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);
+    Uninterruptibles.sleepUninterruptibly(500, TimeUnit.MILLISECONDS);
     elementsAllowed.set(true);
     phaser.arrive();
 
@@ -123,4 +124,50 @@ public class DirectStreamObserverTest {
     }
     streamObserver.onCompleted();
   }
+
+  /**
+   * This test specifically covers the case if the outbound observer is being invoked on the same
+   * thread that the inbound observer is. gRPC documentation states:
+   *
+   * <p><i>Note: the onReadyHandler's invocation is serialized on the same thread pool as the
+   * incoming StreamObserver's onNext(), onError(), and onComplete() handlers. Blocking the
+   * onReadyHandler will prevent additional messages from being processed by the incoming
+   * StreamObserver. The onReadyHandler must return in a timely manor or else message processing
+   * throughput will suffer.
+   * </i>
+   */
+  @Test
+  public void testIsReadyCheckDoesntBlockIfPhaserCallbackNeverHappens() throws Exception {
+    // Note that we never advance the phaser in this test.
+    final AtomicBoolean elementsAllowed = new AtomicBoolean();
+    final DirectStreamObserver<String> streamObserver =
+        new DirectStreamObserver<>(
+            new AdvancingPhaser(1),
+            TestStreams.withOnNext((String t) -> assertTrue(elementsAllowed.get()))
+                .withIsReady(elementsAllowed::get)
+                .build(),
+            0);
+
+    // Start all the tasks
+    List<Future<String>> results = new ArrayList<>();
+    for (final String prefix : ImmutableList.of("0", "1", "2", "3", "4")) {
+      results.add(
+          executor.submit(
+              () -> {
+                for (int i = 0; i < 10; i++) {
+                  streamObserver.onNext(prefix + i);
+                }
+                return prefix;
+              }));
+    }
+
+    // Have them wait and then flip that we do allow elements and wake up those awaiting
+    Uninterruptibles.sleepUninterruptibly(500, TimeUnit.MILLISECONDS);
+    elementsAllowed.set(true);
+
+    for (Future<String> result : results) {
+      result.get();
+    }
+    streamObserver.onCompleted();
+  }
 }
