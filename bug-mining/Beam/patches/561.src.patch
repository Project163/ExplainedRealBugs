diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ControlClientPool.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ControlClientPool.java
new file mode 100644
index 00000000000..fc9e6348fc3
--- /dev/null
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ControlClientPool.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.fnexecution.control;
+
+/** Control client pool that exposes a source and sink of control clients. */
+public interface ControlClientPool<T extends InstructionRequestHandler> {
+
+  /** Source of control clients. */
+  ClientSource<T> getSource();
+
+  /** Sink for control clients. */
+  ClientSink<T> getSink();
+
+  /** A source of control clients. */
+  @FunctionalInterface
+  interface ClientSource<T> {
+      T take() throws Exception;
+  }
+
+  /** A sink for control clients. */
+  @FunctionalInterface
+  interface ClientSink<T> {
+      void put(T controlClient) throws Exception;
+  }
+}
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/FnApiControlClientPoolService.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/FnApiControlClientPoolService.java
index aa4fe5c058b..7ed43414b88 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/FnApiControlClientPoolService.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/FnApiControlClientPoolService.java
@@ -19,7 +19,6 @@ package org.apache.beam.runners.fnexecution.control;
 
 import io.grpc.stub.StreamObserver;
 import java.util.Collection;
-import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.atomic.AtomicBoolean;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi;
@@ -34,13 +33,14 @@ public class FnApiControlClientPoolService extends BeamFnControlGrpc.BeamFnContr
     implements FnService {
   private static final Logger LOGGER = LoggerFactory.getLogger(FnApiControlClientPoolService.class);
 
-  private final BlockingQueue<FnApiControlClient> clientPool;
+  private final ControlClientPool.ClientSink<? super FnApiControlClient> clientPool;
   private final Collection<FnApiControlClient> vendedClients = new CopyOnWriteArrayList<>();
   private final HeaderAccessor headerAccessor;
   private AtomicBoolean closed = new AtomicBoolean();
 
   private FnApiControlClientPoolService(
-      BlockingQueue<FnApiControlClient> clientPool, HeaderAccessor headerAccessor) {
+      ControlClientPool.ClientSink<? super FnApiControlClient> clientPool,
+      HeaderAccessor headerAccessor) {
     this.clientPool = clientPool;
     this.headerAccessor = headerAccessor;
   }
@@ -53,7 +53,8 @@ public class FnApiControlClientPoolService extends BeamFnControlGrpc.BeamFnContr
    * That consumer is responsible for closing the clients when they are no longer needed.
    */
   public static FnApiControlClientPoolService offeringClientsToPool(
-      BlockingQueue<FnApiControlClient> clientPool, HeaderAccessor headerAccessor) {
+      ControlClientPool.ClientSink<? super FnApiControlClient> clientPool,
+      HeaderAccessor headerAccessor) {
     return new FnApiControlClientPoolService(clientPool, headerAccessor);
   }
 
@@ -81,6 +82,8 @@ public class FnApiControlClientPoolService extends BeamFnControlGrpc.BeamFnContr
     } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
       throw new RuntimeException(e);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
     }
     return newClient.asResponseObserver();
   }
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/QueueControlClientPool.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/QueueControlClientPool.java
new file mode 100644
index 00000000000..818c2ef8e77
--- /dev/null
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/QueueControlClientPool.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.fnexecution.control;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+
+/** Control client pool backed by a blocking queue. */
+public class QueueControlClientPool<T extends InstructionRequestHandler>
+    implements ControlClientPool {
+
+  private final BlockingQueue<T> queue;
+
+  /** Creates a client pool backed by a {@link SynchronousQueue}. */
+  public static QueueControlClientPool createSynchronous() {
+      return new QueueControlClientPool<>(new SynchronousQueue<>(true));
+  }
+
+  /** Creates a client pool backed by an unbounded {@link LinkedBlockingQueue}. */
+  public static QueueControlClientPool createLinked() {
+      return new QueueControlClientPool<>(new LinkedBlockingQueue<>());
+  }
+
+  private QueueControlClientPool(BlockingQueue<T> queue) {
+      this.queue = queue;
+  }
+
+  @Override
+  public ClientSource<T> getSource() {
+    return queue::take;
+  }
+
+  @Override
+  public ClientSink<T> getSink() {
+      return queue::put;
+  }
+
+}
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/SdkHarnessClientControlService.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/SdkHarnessClientControlService.java
index dd7023651c5..94dfd856b62 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/SdkHarnessClientControlService.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/SdkHarnessClientControlService.java
@@ -20,9 +20,7 @@ package org.apache.beam.runners.fnexecution.control;
 
 import io.grpc.ServerServiceDefinition;
 import java.util.Collection;
-import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.SynchronousQueue;
 import java.util.function.Supplier;
 import org.apache.beam.runners.fnexecution.FnService;
 import org.apache.beam.runners.fnexecution.HeaderAccessor;
@@ -34,7 +32,7 @@ import org.apache.beam.runners.fnexecution.data.FnDataService;
  */
 public class SdkHarnessClientControlService implements FnService {
   private final FnApiControlClientPoolService clientPoolService;
-  private final BlockingQueue<FnApiControlClient> pendingClients;
+  private final ControlClientPool<FnApiControlClient> pendingClients;
 
   private final Supplier<FnDataService> dataService;
 
@@ -49,19 +47,22 @@ public class SdkHarnessClientControlService implements FnService {
       Supplier<FnDataService> dataService, HeaderAccessor headerAccessor) {
     this.dataService = dataService;
     activeClients = new ConcurrentLinkedQueue<>();
-    pendingClients = new SynchronousQueue<>();
+    pendingClients = QueueControlClientPool.createSynchronous();
     clientPoolService =
-        FnApiControlClientPoolService.offeringClientsToPool(pendingClients, headerAccessor);
+        FnApiControlClientPoolService.offeringClientsToPool(pendingClients.getSink(),
+            headerAccessor);
   }
 
   public SdkHarnessClient getClient() {
     try {
       // Block until a client is available.
-      FnApiControlClient getClient = pendingClients.take();
+      FnApiControlClient getClient = pendingClients.getSource().take();
       return SdkHarnessClient.usingFnApiClient(getClient, dataService.get());
     } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
       throw new RuntimeException("Interrupted while waiting for client", e);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
     }
   }
 
diff --git a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/InProcessSdkHarness.java b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/InProcessSdkHarness.java
index 137a0283c89..a3a08feec1a 100644
--- a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/InProcessSdkHarness.java
+++ b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/InProcessSdkHarness.java
@@ -21,14 +21,14 @@ package org.apache.beam.runners.fnexecution;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import io.grpc.ManagedChannel;
 import io.grpc.inprocess.InProcessChannelBuilder;
-import java.io.IOException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.SynchronousQueue;
 import org.apache.beam.fn.harness.FnHarness;
 import org.apache.beam.model.pipeline.v1.Endpoints.ApiServiceDescriptor;
+import org.apache.beam.runners.fnexecution.control.ControlClientPool;
 import org.apache.beam.runners.fnexecution.control.FnApiControlClient;
 import org.apache.beam.runners.fnexecution.control.FnApiControlClientPoolService;
+import org.apache.beam.runners.fnexecution.control.QueueControlClientPool;
 import org.apache.beam.runners.fnexecution.control.SdkHarnessClient;
 import org.apache.beam.runners.fnexecution.data.GrpcDataService;
 import org.apache.beam.runners.fnexecution.logging.GrpcLoggingService;
@@ -67,13 +67,13 @@ public class InProcessSdkHarness extends ExternalResource implements TestRule {
     return dataServer.getApiServiceDescriptor();
   }
 
-  protected void before() throws IOException, InterruptedException {
+  protected void before() throws Exception {
     InProcessServerFactory serverFactory = InProcessServerFactory.create();
     executor = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setDaemon(true).build());
-    SynchronousQueue<FnApiControlClient> clientPool = new SynchronousQueue<>();
+    ControlClientPool<FnApiControlClient> clientPool = QueueControlClientPool.createSynchronous();
     FnApiControlClientPoolService clientPoolService =
         FnApiControlClientPoolService.offeringClientsToPool(
-            clientPool, GrpcContextHeaderAccessorProvider.getHeaderAccessor());
+            clientPool.getSink(), GrpcContextHeaderAccessorProvider.getHeaderAccessor());
 
     loggingServer =
         GrpcFnServer.allocatePortAndCreateFor(
@@ -98,7 +98,8 @@ public class InProcessSdkHarness extends ExternalResource implements TestRule {
           return null;
         });
 
-    client = SdkHarnessClient.usingFnApiClient(clientPool.take(), dataServer.getService());
+    client = SdkHarnessClient.usingFnApiClient(clientPool.getSource().take(),
+        dataServer.getService());
   }
 
   protected void after() {
diff --git a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/FnApiControlClientPoolServiceTest.java b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/FnApiControlClientPoolServiceTest.java
index d08bcfc1edf..f2b45ed7293 100644
--- a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/FnApiControlClientPoolServiceTest.java
+++ b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/FnApiControlClientPoolServiceTest.java
@@ -26,10 +26,8 @@ import static org.mockito.Mockito.verify;
 import io.grpc.inprocess.InProcessChannelBuilder;
 import io.grpc.stub.StreamObserver;
 import java.io.IOException;
-import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.InstructionRequest;
@@ -51,10 +49,10 @@ public class FnApiControlClientPoolServiceTest {
 
   // For ease of straight-line testing, we use a LinkedBlockingQueue; in practice a SynchronousQueue
   // for matching incoming connections and server threads is likely.
-  private final BlockingQueue<FnApiControlClient> pool = new LinkedBlockingQueue<>();
+  private final ControlClientPool<FnApiControlClient> pool = QueueControlClientPool.createLinked();
   private final FnApiControlClientPoolService controlService =
       FnApiControlClientPoolService.offeringClientsToPool(
-          pool, GrpcContextHeaderAccessorProvider.getHeaderAccessor());
+          pool.getSink(), GrpcContextHeaderAccessorProvider.getHeaderAccessor());
   private GrpcFnServer<FnApiControlClientPoolService> server;
   private BeamFnControlGrpc.BeamFnControlStub stub;
 
@@ -77,7 +75,7 @@ public class FnApiControlClientPoolServiceTest {
     StreamObserver<BeamFnApi.InstructionResponse> responseObserver =
         controlService.control(requestObserver);
 
-    FnApiControlClient client = pool.take();
+    FnApiControlClient client = pool.getSource().take();
 
     // Check that the client is wired up to the request channel
     String id = "fakeInstruction";
@@ -115,7 +113,7 @@ public class FnApiControlClientPoolServiceTest {
           }
         });
 
-    pool.take();
+    pool.getSource().take();
     server.close();
 
     latch.await();
diff --git a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java
index c9ec7a4f050..b52141c0ab3 100644
--- a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java
+++ b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java
@@ -33,10 +33,8 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import org.apache.beam.fn.harness.FnHarness;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.Target;
@@ -108,11 +106,11 @@ public class RemoteExecutionTest implements Serializable {
         GrpcFnServer.allocatePortAndCreateFor(
             GrpcLoggingService.forWriter(Slf4jLogWriter.getDefault()), serverFactory);
 
-    BlockingQueue<FnApiControlClient> clientPool = new SynchronousQueue<>();
+    ControlClientPool<FnApiControlClient> clientPool = QueueControlClientPool.createSynchronous();
     controlServer =
         GrpcFnServer.allocatePortAndCreateFor(
             FnApiControlClientPoolService.offeringClientsToPool(
-                clientPool, GrpcContextHeaderAccessorProvider.getHeaderAccessor()),
+                clientPool.getSink(), GrpcContextHeaderAccessorProvider.getHeaderAccessor()),
             serverFactory);
 
     // Create the SDK harness, and wait until it connects
@@ -130,7 +128,7 @@ public class RemoteExecutionTest implements Serializable {
                   }
                 },
                 StreamObserverFactory.direct()));
-    FnApiControlClient controlClient = clientPool.take();
+    FnApiControlClient controlClient = clientPool.getSource().take();
     this.controlClient = SdkHarnessClient.usingFnApiClient(controlClient, dataServer.getService());
   }
 
