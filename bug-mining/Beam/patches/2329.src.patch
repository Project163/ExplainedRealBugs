diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/fn/data/BeamFnDataGrpcService.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/fn/data/BeamFnDataGrpcService.java
index 9abc49378a1..8ada47694a7 100644
--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/fn/data/BeamFnDataGrpcService.java
+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/fn/data/BeamFnDataGrpcService.java
@@ -120,6 +120,12 @@ public class BeamFnDataGrpcService extends BeamFnDataGrpc.BeamFnDataImplBase
       future.get().awaitCompletion();
     }
 
+    @Override
+    @SuppressWarnings("FutureReturnValueIgnored")
+    public void runWhenComplete(Runnable completeRunnable) {
+      future.whenComplete((result, throwable) -> completeRunnable.run());
+    }
+
     @Override
     public boolean isDone() {
       if (!future.isDone()) {
diff --git a/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/BeamFnDataInboundObserver.java b/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/BeamFnDataInboundObserver.java
index ed1f178d37b..6f37b08966f 100644
--- a/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/BeamFnDataInboundObserver.java
+++ b/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/BeamFnDataInboundObserver.java
@@ -73,6 +73,11 @@ public class BeamFnDataInboundObserver
     readFuture.awaitCompletion();
   }
 
+  @Override
+  public void runWhenComplete(Runnable completeRunnable) {
+    readFuture.runWhenComplete(completeRunnable);
+  }
+
   @Override
   public boolean isDone() {
     return readFuture.isDone();
diff --git a/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/CompletableFutureInboundDataClient.java b/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/CompletableFutureInboundDataClient.java
index 5f02e6e14f5..73b68222cfa 100644
--- a/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/CompletableFutureInboundDataClient.java
+++ b/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/CompletableFutureInboundDataClient.java
@@ -48,6 +48,12 @@ public class CompletableFutureInboundDataClient implements InboundDataClient {
     future.get();
   }
 
+  @Override
+  @SuppressWarnings("FutureReturnValueIgnored")
+  public void runWhenComplete(Runnable completeRunnable) {
+    future.whenComplete((result, throwable) -> completeRunnable.run());
+  }
+
   @Override
   public boolean isDone() {
     return future.isDone();
diff --git a/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/InboundDataClient.java b/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/InboundDataClient.java
index db46290256d..a8b2c673545 100644
--- a/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/InboundDataClient.java
+++ b/sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/data/InboundDataClient.java
@@ -33,6 +33,9 @@ public interface InboundDataClient {
    */
   void awaitCompletion() throws InterruptedException, Exception;
 
+  /** Runs the runnable once the client has completed reading from the inbound stream. */
+  void runWhenComplete(Runnable completeRunnable);
+
   /**
    * Returns true if the client is done, either via completing successfully or by being cancelled.
    */
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/ProcessBundleHandler.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/ProcessBundleHandler.java
index e550d2c6789..defdc69e157 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/ProcessBundleHandler.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/ProcessBundleHandler.java
@@ -119,6 +119,8 @@ public class ProcessBundleHandler {
   private static final String DATA_OUTPUT_URN = "beam:runner:sink:v1";
   public static final String JAVA_SOURCE_URN = "beam:source:java:0.1";
 
+  private static final int DATA_QUEUE_SIZE = 1000;
+
   private static final Logger LOG = LoggerFactory.getLogger(ProcessBundleHandler.class);
   @VisibleForTesting static final Map<String, PTransformRunnerFactory> REGISTERED_RUNNER_FACTORIES;
 
@@ -444,7 +446,8 @@ public class ProcessBundleHandler {
     // Note: We must create one instance of the QueueingBeamFnDataClient as it is designed to
     // handle the life of a bundle. It will insert elements onto a queue and drain them off so all
     // process() calls will execute on this thread when queueingClient.drainAndBlock() is called.
-    QueueingBeamFnDataClient queueingClient = new QueueingBeamFnDataClient(this.beamFnDataClient);
+    QueueingBeamFnDataClient queueingClient =
+        new QueueingBeamFnDataClient(this.beamFnDataClient, DATA_QUEUE_SIZE);
 
     BeamFnApi.ProcessBundleDescriptor bundleDescriptor =
         (BeamFnApi.ProcessBundleDescriptor) fnApiRegistry.apply(bundleId);
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/BeamFnDataGrpcClient.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/BeamFnDataGrpcClient.java
index f9242613c68..cf72497db84 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/BeamFnDataGrpcClient.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/BeamFnDataGrpcClient.java
@@ -67,7 +67,8 @@ public class BeamFnDataGrpcClient implements BeamFnDataClient {
    * <p>The provided coder is used to decode elements on the inbound stream. The decoded elements
    * are passed to the provided consumer. Any failure during decoding or processing of the element
    * will complete the returned future exceptionally. On successful termination of the stream
-   * (signaled by an empty data block), the returned future is completed successfully.
+   * (signaled by an empty data block with isLast set to true), the returned future is completed
+   * successfully.
    */
   @Override
   public InboundDataClient receive(
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/BeamFnTimerGrpcClient.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/BeamFnTimerGrpcClient.java
index 0b1777b7289..6bfaa6e5d92 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/BeamFnTimerGrpcClient.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/BeamFnTimerGrpcClient.java
@@ -75,6 +75,11 @@ public class BeamFnTimerGrpcClient implements BeamFnTimerClient {
         inbound.awaitCompletion();
       }
 
+      @Override
+      public void runWhenComplete(Runnable completeRunnable) {
+        inbound.runWhenComplete(completeRunnable);
+      }
+
       @Override
       public boolean isDone() {
         return inbound.isDone();
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/QueueingBeamFnDataClient.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/QueueingBeamFnDataClient.java
index 093b7bc0adf..a1180f95333 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/QueueingBeamFnDataClient.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/data/QueueingBeamFnDataClient.java
@@ -17,9 +17,12 @@
  */
 package org.apache.beam.fn.harness.data;
 
-import java.util.concurrent.ConcurrentHashMap;
+import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.concurrent.GuardedBy;
 import org.apache.beam.model.pipeline.v1.Endpoints;
 import org.apache.beam.model.pipeline.v1.Endpoints.ApiServiceDescriptor;
 import org.apache.beam.sdk.coders.Coder;
@@ -28,6 +31,7 @@ import org.apache.beam.sdk.fn.data.FnDataReceiver;
 import org.apache.beam.sdk.fn.data.InboundDataClient;
 import org.apache.beam.sdk.fn.data.LogicalEndpoint;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.slf4j.Logger;
@@ -42,20 +46,83 @@ import org.slf4j.LoggerFactory;
  * clients have been registered a single thread should call {@link #drainAndBlock}.
  */
 public class QueueingBeamFnDataClient implements BeamFnDataClient {
+  private static class ClosableQueue {
+    // Used to indicate that the queue is closed.
+    private static final ConsumerAndData<Object> POISON =
+        new ConsumerAndData<>(
+            input -> {
+              throw new RuntimeException("Unable to accept poison.");
+            },
+            new Object());
 
-  private static final int QUEUE_SIZE = 1000;
+    private final LinkedBlockingQueue<ConsumerAndData<?>> queue;
+    private final AtomicBoolean closed = new AtomicBoolean();
+
+    ClosableQueue(int queueSize) {
+      this.queue = new LinkedBlockingQueue<ConsumerAndData<?>>(queueSize);
+    }
+
+    // Closes the queue indicating that no additional elements will be added. May be called
+    // at most once. Non-blocking.
+    void close() {
+      Preconditions.checkArgument(!closed.getAndSet(true));
+      if (!queue.offer(POISON)) {
+        // If this returns false, the queue was full. Since there were elements in
+        // the queue, the poison is unnecessary since we check closed when taking from
+        // the queue.
+        LOG.debug("Queue was full, not adding poison");
+      }
+    }
+
+    // See BlockingQueue.offer. Must not be called after close().
+    boolean offer(ConsumerAndData<?> e, long l, TimeUnit t) throws InterruptedException {
+      return queue.offer(e, l, t);
+    }
+
+    // Blocks until there is either an element available or the queue has been closed and is
+    // empty in which case it returns null.
+    @Nullable
+    ConsumerAndData<?> take() throws InterruptedException {
+      @Nullable ConsumerAndData<?> result = queue.poll();
+      if (result == null) {
+        if (closed.get()) {
+          return null;
+        }
+        result = queue.take();
+      }
+      if (result == POISON) {
+        return null;
+      }
+      return result;
+    }
+
+    boolean isEmpty() {
+      return queue.isEmpty();
+    }
+  }
 
   private static final Logger LOG = LoggerFactory.getLogger(QueueingBeamFnDataClient.class);
 
   private final BeamFnDataClient mainClient;
-  private final ConcurrentHashMap<InboundDataClient, Object> inboundDataClients;
 
-  private LinkedBlockingQueue<ConsumerAndData<?>> queue;
+  @GuardedBy("inboundDataClients")
+  private final HashSet<InboundDataClient> inboundDataClients;
 
-  public QueueingBeamFnDataClient(BeamFnDataClient mainClient) {
+  @GuardedBy("inboundDataClients")
+  private final ArrayList<InboundDataClient> finishedClients;
+
+  @GuardedBy("inboundDataClients")
+  private boolean isDraining = false;
+
+  private final int queueSize;
+  private ClosableQueue queue;
+
+  public QueueingBeamFnDataClient(BeamFnDataClient mainClient, int queueSize) {
     this.mainClient = mainClient;
-    this.inboundDataClients = new ConcurrentHashMap<>();
-    this.queue = new LinkedBlockingQueue<>(QUEUE_SIZE);
+    this.inboundDataClients = new HashSet<>();
+    this.finishedClients = new ArrayList<>();
+    this.queueSize = queueSize;
+    this.queue = new ClosableQueue(queueSize);
   }
 
   @Override
@@ -73,23 +140,36 @@ public class QueueingBeamFnDataClient implements BeamFnDataClient {
     InboundDataClient inboundDataClient =
         this.mainClient.receive(apiServiceDescriptor, inputLocation, queueingConsumer);
     queueingConsumer.inboundDataClient = inboundDataClient;
-    this.inboundDataClients.computeIfAbsent(
-        inboundDataClient, (InboundDataClient idcToStore) -> idcToStore);
+    synchronized (inboundDataClients) {
+      Preconditions.checkState(!isDraining);
+      if (this.inboundDataClients.add(inboundDataClient)) {
+        inboundDataClient.runWhenComplete(() -> completeInbound(inboundDataClient));
+      }
+    }
     return inboundDataClient;
   }
 
-  // Returns true if all the InboundDataClients have finished or cancelled and no values
-  // remain on the queue.
-  private boolean allDone() {
-    for (InboundDataClient inboundDataClient : inboundDataClients.keySet()) {
-      if (!inboundDataClient.isDone()) {
-        return false;
+  private void completeInbound(InboundDataClient client) {
+    Preconditions.checkState(client.isDone());
+    // This client will no longer be adding elements to the queue.
+    //
+    // There are several cases we consider here:
+    // - this is not the last active client -> do nothing since the last client will handle things
+    // - last client and we are draining -> we know that no additional elements will be added to the
+    //   queue because there will be no more clients. We close the queue to trigger exiting
+    //   drainAndBlock.
+    // - last client and we are not draining -> it is possible that additional clients will be added
+    //   with receive. drainAndBlock itself detects this case and close the queue.
+    synchronized (inboundDataClients) {
+      if (!inboundDataClients.remove(client)) {
+        // Possible if this client was leftover from before reset() was called.
+        return;
+      }
+      finishedClients.add(client);
+      if (inboundDataClients.isEmpty() && isDraining) {
+        queue.close();
       }
     }
-    if (!this.queue.isEmpty()) {
-      return false;
-    }
-    return true;
   }
 
   /**
@@ -104,30 +184,46 @@ public class QueueingBeamFnDataClient implements BeamFnDataClient {
    * class comment.
    */
   public void drainAndBlock() throws Exception {
+    // There are several ways drainAndBlock completes:
+    // - processing elements fails -> all inbound clients are failed and exception thrown
+    // - draining starts while inbound clients are active -> the last client will poision the queue
+    //   to notify that no more elements will arrive
+    // - draining starts without any remaining clients -> we just need to drain the queue and then
+    //   are done as no further elements will arrive.
+    synchronized (inboundDataClients) {
+      Preconditions.checkState(!isDraining);
+      isDraining = true;
+      if (inboundDataClients.isEmpty()) {
+        queue.close();
+      }
+    }
     while (true) {
       try {
-        ConsumerAndData<?> tuple = queue.poll(200, TimeUnit.MILLISECONDS);
-        if (tuple != null) {
-          // Forward to the consumers who cares about this data.
-          tuple.accept();
-        } else {
-          // Note: We do not expect to ever hit this point without receiving all values
-          // as (1) The InboundObserver will not be set to Done until the
-          // QueuingFnDataReceiver.accept() call returns and will not be invoked again.
-          // (2) The QueueingFnDataReceiver will not return until the value is received in
-          // drainAndBlock, because of the use of the SynchronousQueue.
-          if (allDone()) {
-            break;
-          }
+        @Nullable ConsumerAndData<?> tuple = queue.take();
+        if (tuple == null) {
+          break; // queue has been drained and is closed.
         }
+
+        // Forward to the consumers who cares about this data.
+        tuple.accept();
       } catch (Exception e) {
-        LOG.error("Client failed to dequeue and process the value", e);
-        for (InboundDataClient inboundDataClient : inboundDataClients.keySet()) {
+        LOG.error("Client failed to deque and process the value", e);
+        HashSet<InboundDataClient> clients = new HashSet<>();
+        synchronized (inboundDataClients) {
+          clients.addAll(inboundDataClients);
+          clients.addAll(finishedClients);
+        }
+        for (InboundDataClient inboundDataClient : clients) {
           inboundDataClient.fail(e);
         }
         throw e;
       }
     }
+    synchronized (inboundDataClients) {
+      Preconditions.checkState(inboundDataClients.isEmpty());
+      Preconditions.checkState(isDraining);
+    }
+    Preconditions.checkState(queue.isEmpty());
   }
 
   @Override
@@ -144,10 +240,14 @@ public class QueueingBeamFnDataClient implements BeamFnDataClient {
 
   /** Resets this object so that it may be reused. */
   public void reset() {
-    inboundDataClients.clear();
+    synchronized (inboundDataClients) {
+      inboundDataClients.clear();
+      isDraining = false;
+      finishedClients.clear();
+    }
     // It is possible that previous inboundClients were failed but could still be adding
     // additional elements to their bound queue. For this reason we create a new queue.
-    this.queue = new LinkedBlockingQueue<>(QUEUE_SIZE);
+    this.queue = new ClosableQueue(queueSize);
   }
 
   /**
@@ -158,13 +258,12 @@ public class QueueingBeamFnDataClient implements BeamFnDataClient {
    * the inboundClient is failed. {@link QueueingBeamFnDataClient#drainAndBlock} is responsible for
    * processing values from the queue.
    */
-  public static class QueueingFnDataReceiver<T> implements FnDataReceiver<T> {
+  private static class QueueingFnDataReceiver<T> implements FnDataReceiver<T> {
     private final FnDataReceiver<T> consumer;
-    private final LinkedBlockingQueue<ConsumerAndData<?>> queue;
+    private final ClosableQueue queue;
     public @Nullable InboundDataClient inboundDataClient; // Null only during initialization.
 
-    public QueueingFnDataReceiver(
-        FnDataReceiver<T> consumer, LinkedBlockingQueue<ConsumerAndData<?>> queue) {
+    public QueueingFnDataReceiver(FnDataReceiver<T> consumer, ClosableQueue queue) {
       this.queue = queue;
       this.consumer = consumer;
     }
@@ -193,7 +292,7 @@ public class QueueingBeamFnDataClient implements BeamFnDataClient {
     }
   }
 
-  static class ConsumerAndData<T> {
+  private static class ConsumerAndData<T> {
     private final FnDataReceiver<T> consumer;
     private final T data;
 
diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/data/FakeBeamFnTimerClient.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/data/FakeBeamFnTimerClient.java
index 8119cd38ff4..80165a944f6 100644
--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/data/FakeBeamFnTimerClient.java
+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/data/FakeBeamFnTimerClient.java
@@ -64,6 +64,12 @@ public class FakeBeamFnTimerClient implements BeamFnTimerClient {
                   timerInputFutures.get(endpoint).get();
                 }
 
+                @Override
+                @SuppressWarnings("FutureReturnValueIgnored")
+                public void runWhenComplete(Runnable completeRunnable) {
+                  timerInputFutures.get(endpoint).whenComplete((f, t) -> completeRunnable.run());
+                }
+
                 @Override
                 public boolean isDone() {
                   return timerInputFutures.get(endpoint).isDone();
diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/data/QueueingBeamFnDataClientTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/data/QueueingBeamFnDataClientTest.java
index 535b4258e26..1b2b0fa9cc0 100644
--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/data/QueueingBeamFnDataClientTest.java
+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/data/QueueingBeamFnDataClientTest.java
@@ -21,6 +21,8 @@ import static org.apache.beam.sdk.util.CoderUtils.encodeToByteArray;
 import static org.apache.beam.sdk.util.WindowedValue.valueInGlobalWindow;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.equalTo;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -31,6 +33,7 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi;
 import org.apache.beam.model.fnexecution.v1.BeamFnDataGrpc;
@@ -171,7 +174,7 @@ public class QueueingBeamFnDataClientTest {
               PipelineOptionsFactory.create(),
               (Endpoints.ApiServiceDescriptor descriptor) -> channel,
               OutboundObserverFactory.trivial());
-      QueueingBeamFnDataClient queueingClient = new QueueingBeamFnDataClient(clientFactory);
+      QueueingBeamFnDataClient queueingClient = new QueueingBeamFnDataClient(clientFactory, 1000);
 
       InboundDataClient readFutureA =
           queueingClient.receive(
@@ -235,6 +238,118 @@ public class QueueingBeamFnDataClientTest {
     }
   }
 
+  @Test(timeout = 10000)
+  public void testClosingWithFullInboundQueue() throws Exception {
+    CountDownLatch waitForClientToConnect = new CountDownLatch(1);
+    CountDownLatch allowValueProcessing = new CountDownLatch(1);
+    final int numValues = 100;
+    CountDownLatch receiveAllValues = new CountDownLatch(numValues);
+    Collection<WindowedValue<String>> inboundValues = new ConcurrentLinkedQueue<>();
+    Collection<BeamFnApi.Elements> inboundServerValues = new ConcurrentLinkedQueue<>();
+    AtomicReference<StreamObserver<BeamFnApi.Elements>> outboundServerObserver =
+        new AtomicReference<>();
+    CallStreamObserver<BeamFnApi.Elements> inboundServerObserver =
+        TestStreams.withOnNext(inboundServerValues::add).build();
+
+    Endpoints.ApiServiceDescriptor apiServiceDescriptor =
+        Endpoints.ApiServiceDescriptor.newBuilder()
+            .setUrl(this.getClass().getName() + "-" + UUID.randomUUID().toString())
+            .build();
+    Server server =
+        InProcessServerBuilder.forName(apiServiceDescriptor.getUrl())
+            .addService(
+                new BeamFnDataGrpc.BeamFnDataImplBase() {
+                  @Override
+                  public StreamObserver<BeamFnApi.Elements> data(
+                      StreamObserver<BeamFnApi.Elements> outboundObserver) {
+                    outboundServerObserver.set(outboundObserver);
+                    waitForClientToConnect.countDown();
+                    return inboundServerObserver;
+                  }
+                })
+            .build();
+    server.start();
+    try {
+      ManagedChannel channel =
+          InProcessChannelBuilder.forName(apiServiceDescriptor.getUrl()).build();
+
+      BeamFnDataGrpcClient clientFactory =
+          new BeamFnDataGrpcClient(
+              PipelineOptionsFactory.create(),
+              (Endpoints.ApiServiceDescriptor descriptor) -> channel,
+              OutboundObserverFactory.trivial());
+      // We want the queue to have no room when we try to close. The queue size
+      // is therefore set to numValues -1 since one of the values has been removed
+      // from the queue to accept it.
+      QueueingBeamFnDataClient queueingClient =
+          new QueueingBeamFnDataClient(clientFactory, numValues - 1);
+
+      final AtomicInteger currentCount = new AtomicInteger();
+      InboundDataClient inboundDataClient =
+          queueingClient.receive(
+              apiServiceDescriptor,
+              ENDPOINT_A,
+              CODER,
+              (WindowedValue<String> wv) -> {
+                if (allowValueProcessing.getCount() != 0) {
+                  LOG.info("Inbound processing blocking");
+                }
+                allowValueProcessing.await();
+                LOG.info("Received " + wv.getValue());
+                assertEquals("ABC" + currentCount.getAndIncrement(), wv.getValue());
+              });
+
+      waitForClientToConnect.await();
+
+      // Start draining elements, the drain will be blocked by allowValueProcessing.
+      Future<?> drainElementsFuture =
+          executor.submit(
+              () -> {
+                try {
+                  queueingClient.drainAndBlock();
+                } catch (Exception e) {
+                  LOG.error("Failed ", e);
+                  fail();
+                }
+              });
+
+      // We should be able to send all the elements and complete without blocking.
+      for (int i = 0; i < numValues; ++i) {
+        BeamFnApi.Elements element =
+            BeamFnApi.Elements.newBuilder()
+                .addData(
+                    BeamFnApi.Elements.Data.newBuilder()
+                        .setInstructionId(ENDPOINT_A.getInstructionId())
+                        .setTransformId(ENDPOINT_A.getTransformId())
+                        .setData(
+                            ByteString.copyFrom(
+                                encodeToByteArray(CODER, valueInGlobalWindow("ABC" + i)))))
+                .build();
+        outboundServerObserver.get().onNext(element);
+      }
+      outboundServerObserver
+          .get()
+          .onNext(
+              BeamFnApi.Elements.newBuilder()
+                  .addData(
+                      BeamFnApi.Elements.Data.newBuilder()
+                          .setInstructionId(ENDPOINT_A.getInstructionId())
+                          .setTransformId(ENDPOINT_A.getTransformId())
+                          .setIsLast(true))
+                  .build());
+      inboundDataClient.awaitCompletion();
+
+      // Allow processing to complete and verify that draining finishes.
+      LOG.info("Completed client, allowing inbound processing.");
+      allowValueProcessing.countDown();
+      drainElementsFuture.get();
+
+      assertThat(currentCount.get(), equalTo(numValues));
+    } finally {
+      server.shutdownNow();
+    }
+  }
+
   @Test(timeout = 100000)
   public void testBundleProcessorThrowsExecutionExceptionWhenUserCodeThrows() throws Exception {
     CountDownLatch waitForClientToConnect = new CountDownLatch(1);
@@ -273,7 +388,7 @@ public class QueueingBeamFnDataClientTest {
               PipelineOptionsFactory.create(),
               (Endpoints.ApiServiceDescriptor descriptor) -> channel,
               OutboundObserverFactory.trivial());
-      QueueingBeamFnDataClient queueingClient = new QueueingBeamFnDataClient(clientFactory);
+      QueueingBeamFnDataClient queueingClient = new QueueingBeamFnDataClient(clientFactory, 1000);
 
       InboundDataClient readFutureA =
           queueingClient.receive(
@@ -342,6 +457,8 @@ public class QueueingBeamFnDataClientTest {
       } catch (ExecutionException e) {
         if (e.getCause() instanceof RuntimeException) {
           intentionallyFailedB = true;
+        } else {
+          LOG.error("Unintentional failure ", e);
         }
       }
       assertTrue(intentionallyFailedB);
