diff --git a/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexGroupByKeyOperator.java b/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexGroupByKeyOperator.java
index f8b665311e9..3c9f5ab770f 100644
--- a/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexGroupByKeyOperator.java
+++ b/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexGroupByKeyOperator.java
@@ -25,11 +25,9 @@ import com.datatorrent.api.DefaultOutputPort;
 import com.datatorrent.api.Operator;
 import com.datatorrent.api.StreamCodec;
 import com.datatorrent.api.annotation.OutputPortFieldAnnotation;
-import com.datatorrent.netlet.util.Slice;
 import com.esotericsoftware.kryo.serializers.FieldSerializer.Bind;
 import com.esotericsoftware.kryo.serializers.JavaSerializer;
 import com.google.common.base.Throwables;
-import com.google.common.collect.Multimap;
 import java.util.Collection;
 import java.util.Collections;
 import org.apache.beam.runners.apex.ApexPipelineOptions;
@@ -41,6 +39,7 @@ import org.apache.beam.runners.core.ReduceFnRunner;
 import org.apache.beam.runners.core.StateInternalsFactory;
 import org.apache.beam.runners.core.SystemReduceFn;
 import org.apache.beam.runners.core.TimerInternals;
+import org.apache.beam.runners.core.TimerInternals.TimerData;
 import org.apache.beam.runners.core.construction.Triggers;
 import org.apache.beam.runners.core.triggers.ExecutableTriggerStateMachine;
 import org.apache.beam.runners.core.triggers.TriggerStateMachines;
@@ -49,8 +48,8 @@ import org.apache.beam.sdk.coders.KvCoder;
 import org.apache.beam.sdk.transforms.GroupByKey;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.sdk.transforms.windowing.PaneInfo;
-import org.apache.beam.sdk.util.CoderUtils;
 import org.apache.beam.sdk.util.NullSideInputReader;
+import org.apache.beam.sdk.util.TimeDomain;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.util.WindowingStrategy;
 import org.apache.beam.sdk.values.KV;
@@ -68,7 +67,8 @@ import org.slf4j.LoggerFactory;
  * @param <K> key type
  * @param <V> value type
  */
-public class ApexGroupByKeyOperator<K, V> implements Operator {
+public class ApexGroupByKeyOperator<K, V> implements Operator,
+    ApexTimerInternals.TimerProcessor<K> {
   private static final Logger LOG = LoggerFactory.getLogger(ApexGroupByKeyOperator.class);
   private boolean traceTuples = true;
 
@@ -106,7 +106,7 @@ public class ApexGroupByKeyOperator<K, V> implements Operator {
         }
         processElement(t.getValue());
       } catch (Exception e) {
-        Throwables.propagateIfPossible(e);
+        Throwables.throwIfUnchecked(e);
         throw new RuntimeException(e);
       }
     }
@@ -143,6 +143,8 @@ public class ApexGroupByKeyOperator<K, V> implements Operator {
 
   @Override
   public void endWindow() {
+    timerInternals.fireReadyTimers(timerInternals.currentProcessingTime().getMillis(),
+        this, TimeDomain.PROCESSING_TIME);
   }
 
   @Override
@@ -195,7 +197,6 @@ public class ApexGroupByKeyOperator<K, V> implements Operator {
         serializedOptions.get());
   }
 
-
   private void processElement(WindowedValue<KV<K, V>> windowedValue) throws Exception {
     final KV<K, V> kv = windowedValue.getValue();
     final WindowedValue<V> updatedWindowedValue = WindowedValue.of(kv.getValue(),
@@ -209,19 +210,23 @@ public class ApexGroupByKeyOperator<K, V> implements Operator {
     reduceFnRunner.persist();
   }
 
-  private void processWatermark(ApexStreamTuple.WatermarkTuple<?> mark) throws Exception {
-    this.inputWatermark = new Instant(mark.getTimestamp());
-    Multimap<Slice, TimerInternals.TimerData> timers = timerInternals.getTimersReadyToProcess(
-        mark.getTimestamp());
-    if (!timers.isEmpty()) {
-      for (Slice keyBytes : timers.keySet()) {
-        K key = CoderUtils.decodeFromByteArray(keyCoder, keyBytes.buffer);
-        timerInternals.setContext(key, keyCoder, inputWatermark);
-        ReduceFnRunner<K, V, Iterable<V>, BoundedWindow> reduceFnRunner = newReduceFnRunner(key);
-        reduceFnRunner.onTimers(timers.get(keyBytes));
-        reduceFnRunner.persist();
-      }
+  @Override
+  public void fireTimer(K key, Collection<TimerData> timerData) {
+    timerInternals.setContext(key, keyCoder, inputWatermark);
+    ReduceFnRunner<K, V, Iterable<V>, BoundedWindow> reduceFnRunner = newReduceFnRunner(key);
+    try {
+      reduceFnRunner.onTimers(timerData);
+    } catch (Exception e) {
+      Throwables.throwIfUnchecked(e);
+      throw new RuntimeException(e);
     }
+    reduceFnRunner.persist();
+  }
+
+  private void processWatermark(ApexStreamTuple.WatermarkTuple<?> mark) {
+    this.inputWatermark = new Instant(mark.getTimestamp());
+    timerInternals.fireReadyTimers(this.inputWatermark.getMillis(),
+        this, TimeDomain.EVENT_TIME);
   }
 
 }
diff --git a/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexTimerInternals.java b/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexTimerInternals.java
index b142095946a..15ccbee1d73 100644
--- a/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexTimerInternals.java
+++ b/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexTimerInternals.java
@@ -20,9 +20,12 @@ package org.apache.beam.runners.apex.translation.operators;
 import com.datatorrent.netlet.util.Slice;
 import com.esotericsoftware.kryo.DefaultSerializer;
 import com.esotericsoftware.kryo.serializers.JavaSerializer;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.Multimap;
 import java.io.Serializable;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -47,14 +50,16 @@ import org.joda.time.Instant;
 @DefaultSerializer(JavaSerializer.class)
 class ApexTimerInternals<K> implements TimerInternals, Serializable {
 
-  private Map<Slice, Set<Slice>> activeTimers = new HashMap<>();
-  private TimerDataCoder timerDataCoder;
+  private final TimerSet eventTimeTimeTimers;
+  private final TimerSet processingTimeTimers;
+
   private transient K currentKey;
   private transient Instant currentInputWatermark;
   private transient Coder<K> keyCoder;
 
   public ApexTimerInternals(TimerDataCoder timerDataCoder) {
-    this.timerDataCoder = timerDataCoder;
+    this.eventTimeTimeTimers = new TimerSet(timerDataCoder);
+    this.processingTimeTimers = new TimerSet(timerDataCoder);
   }
 
   public void setContext(K key, Coder<K> keyCoder, Instant inputWatermark) {
@@ -63,31 +68,37 @@ class ApexTimerInternals<K> implements TimerInternals, Serializable {
     this.currentInputWatermark = inputWatermark;
   }
 
+  @VisibleForTesting
+  protected TimerSet getTimerSet(TimeDomain domain) {
+    return (domain == TimeDomain.EVENT_TIME) ? eventTimeTimeTimers : processingTimeTimers;
+  }
+
   @Override
   public void setTimer(StateNamespace namespace, String timerId, Instant target,
       TimeDomain timeDomain) {
     TimerData timerData = TimerData.of(timerId, namespace, target, timeDomain);
-    registerActiveTimer(currentKey, timerData);
+    setTimer(timerData);
   }
 
   @Override
   public void setTimer(TimerData timerData) {
-    registerActiveTimer(currentKey, timerData);
+    getTimerSet(timerData.getDomain()).addTimer(getKeyBytes(this.currentKey), timerData);
   }
 
   @Override
   public void deleteTimer(StateNamespace namespace, String timerId, TimeDomain timeDomain) {
-    throw new UnsupportedOperationException();
+    getTimerSet(timeDomain).deleteTimer(getKeyBytes(this.currentKey), namespace, timerId);
   }
 
   @Override
   public void deleteTimer(StateNamespace namespace, String timerId) {
-    throw new UnsupportedOperationException();
+    this.eventTimeTimeTimers.deleteTimer(getKeyBytes(this.currentKey), namespace, timerId);
+    this.processingTimeTimers.deleteTimer(getKeyBytes(this.currentKey), namespace, timerId);
   }
 
   @Override
   public void deleteTimer(TimerData timerKey) {
-    unregisterActiveTimer(currentKey, timerKey);
+    getTimerSet(timerKey.getDomain()).deleteTimer(getKeyBytes(this.currentKey), timerKey);
   }
 
   @Override
@@ -102,7 +113,7 @@ class ApexTimerInternals<K> implements TimerInternals, Serializable {
 
   @Override
   public Instant currentInputWatermarkTime() {
-    return new Instant(currentInputWatermark);
+    return currentInputWatermark;
   }
 
   @Override
@@ -110,14 +121,17 @@ class ApexTimerInternals<K> implements TimerInternals, Serializable {
     return null;
   }
 
+  public interface TimerProcessor<K> {
+    void fireTimer(K key, Collection<TimerData> timerData);
+  }
+
   /**
-   * Returns the list of timers that are ready to fire. These are the timers
-   * that are registered to be triggered at a time before the current watermark.
-   * We keep these timers in a Set, so that they are deduplicated, as the same
-   * timer can be registered multiple times.
+   * Fire the timers that are ready. These are the timers
+   * that are registered to be triggered at a time before the current time.
    */
-  public Multimap<Slice, TimerInternals.TimerData> getTimersReadyToProcess(
-      long currentWatermark) {
+  public void fireReadyTimers(long currentTime,
+      TimerProcessor<K> timerProcessor, TimeDomain timeDomain) {
+    TimerSet timers = getTimerSet(timeDomain);
 
     // we keep the timers to return in a different list and launch them later
     // because we cannot prevent a trigger from registering another timer,
@@ -125,16 +139,16 @@ class ApexTimerInternals<K> implements TimerInternals, Serializable {
     Multimap<Slice, TimerInternals.TimerData> toFire = HashMultimap.create();
 
     Iterator<Map.Entry<Slice, Set<Slice>>> it =
-        activeTimers.entrySet().iterator();
+        timers.activeTimers.entrySet().iterator();
     while (it.hasNext()) {
       Map.Entry<Slice, Set<Slice>> keyWithTimers = it.next();
 
       Iterator<Slice> timerIt = keyWithTimers.getValue().iterator();
       while (timerIt.hasNext()) {
         try {
-          TimerData timerData = CoderUtils.decodeFromByteArray(timerDataCoder,
+          TimerData timerData = CoderUtils.decodeFromByteArray(timers.timerDataCoder,
               timerIt.next().buffer);
-          if (timerData.getTimestamp().isBefore(currentWatermark)) {
+          if (timerData.getTimestamp().isBefore(currentTime)) {
             toFire.put(keyWithTimers.getKey(), timerData);
             timerIt.remove();
           }
@@ -147,55 +161,106 @@ class ApexTimerInternals<K> implements TimerInternals, Serializable {
         it.remove();
       }
     }
-    return toFire;
-  }
 
-  private void registerActiveTimer(K key, TimerData timer) {
-    final Slice keyBytes;
-    try {
-      keyBytes = new Slice(CoderUtils.encodeToByteArray(keyCoder, key));
-    } catch (CoderException e) {
-      throw new RuntimeException(e);
-    }
-    Set<Slice> timersForKey = activeTimers.get(keyBytes);
-    if (timersForKey == null) {
-      timersForKey = new HashSet<>();
+    // fire ready timers
+    if (!toFire.isEmpty()) {
+      for (Slice keyBytes : toFire.keySet()) {
+        try {
+          K key = CoderUtils.decodeFromByteArray(keyCoder, keyBytes.buffer);
+          timerProcessor.fireTimer(key, toFire.get(keyBytes));
+        } catch (CoderException e) {
+          throw new RuntimeException(e);
+        }
+      }
     }
+  }
 
+  private Slice getKeyBytes(K key) {
     try {
-      Slice timerBytes = new Slice(CoderUtils.encodeToByteArray(timerDataCoder, timer));
-      timersForKey.add(timerBytes);
+      return new Slice(CoderUtils.encodeToByteArray(keyCoder, key));
     } catch (CoderException e) {
       throw new RuntimeException(e);
     }
-
-    activeTimers.put(keyBytes, timersForKey);
   }
 
-  private void unregisterActiveTimer(K key, TimerData timer) {
-    final Slice keyBytes;
-    try {
-      keyBytes = new Slice(CoderUtils.encodeToByteArray(keyCoder, key));
-    } catch (CoderException e) {
-      throw new RuntimeException(e);
+  protected static class TimerSet implements Serializable {
+    private final Map<Slice, Set<Slice>> activeTimers = new HashMap<>();
+    private final TimerDataCoder timerDataCoder;
+
+    protected TimerSet(TimerDataCoder timerDataCoder) {
+      this.timerDataCoder = timerDataCoder;
     }
 
-    Set<Slice> timersForKey = activeTimers.get(keyBytes);
-    if (timersForKey != null) {
+    public void addTimer(Slice keyBytes, TimerData timer) {
+      Set<Slice> timersForKey = activeTimers.get(keyBytes);
+      if (timersForKey == null) {
+        timersForKey = new HashSet<>();
+      }
+
       try {
         Slice timerBytes = new Slice(CoderUtils.encodeToByteArray(timerDataCoder, timer));
         timersForKey.add(timerBytes);
-        timersForKey.remove(timerBytes);
       } catch (CoderException e) {
         throw new RuntimeException(e);
       }
 
+      activeTimers.put(keyBytes, timersForKey);
+    }
+
+    public void deleteTimer(Slice keyBytes, StateNamespace namespace, String timerId) {
+      Set<Slice> timersForKey = activeTimers.get(keyBytes);
+      if (timersForKey == null) {
+        return;
+      }
+
+      Iterator<Slice> timerIt = timersForKey.iterator();
+      while (timerIt.hasNext()) {
+        try {
+          TimerData timerData = CoderUtils.decodeFromByteArray(timerDataCoder,
+              timerIt.next().buffer);
+          ComparisonChain chain =
+              ComparisonChain.start().compare(timerData.getTimerId(), timerId);
+          if (chain.result() == 0 && !timerData.getNamespace().equals(namespace)) {
+            // Obtaining the stringKey may be expensive; only do so if required
+            chain = chain.compare(timerData.getNamespace().stringKey(), namespace.stringKey());
+          }
+          if (chain.result() == 0) {
+            timerIt.remove();
+          }
+        } catch (CoderException e) {
+          throw new RuntimeException(e);
+        }
+      }
+
       if (timersForKey.isEmpty()) {
         activeTimers.remove(keyBytes);
-      } else {
-        activeTimers.put(keyBytes, timersForKey);
       }
     }
+
+    public void deleteTimer(Slice keyBytes, TimerData timerKey) {
+      Set<Slice> timersForKey = activeTimers.get(keyBytes);
+      if (timersForKey != null) {
+        try {
+          Slice timerBytes = new Slice(CoderUtils.encodeToByteArray(timerDataCoder, timerKey));
+          timersForKey.add(timerBytes);
+          timersForKey.remove(timerBytes);
+        } catch (CoderException e) {
+          throw new RuntimeException(e);
+        }
+
+        if (timersForKey.isEmpty()) {
+          activeTimers.remove(keyBytes);
+        } else {
+          activeTimers.put(keyBytes, timersForKey);
+        }
+      }
+    }
+
+    @VisibleForTesting
+    protected Map<Slice, Set<Slice>> getMap() {
+      return activeTimers;
+    }
+
   }
 
 }
diff --git a/runners/apex/src/test/java/org/apache/beam/runners/apex/translation/operators/ApexTimerInternalsTest.java b/runners/apex/src/test/java/org/apache/beam/runners/apex/translation/operators/ApexTimerInternalsTest.java
index 1d7e586281b..ee142e2942e 100644
--- a/runners/apex/src/test/java/org/apache/beam/runners/apex/translation/operators/ApexTimerInternalsTest.java
+++ b/runners/apex/src/test/java/org/apache/beam/runners/apex/translation/operators/ApexTimerInternalsTest.java
@@ -22,8 +22,12 @@ import static org.junit.Assert.assertNotNull;
 
 import com.datatorrent.lib.util.KryoCloneUtils;
 import com.datatorrent.netlet.util.Slice;
-import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import org.apache.beam.runners.apex.translation.operators.ApexTimerInternals.TimerProcessor;
 import org.apache.beam.runners.core.StateNamespaces;
 import org.apache.beam.runners.core.TimerInternals.TimerData;
 import org.apache.beam.runners.core.TimerInternals.TimerDataCoder;
@@ -40,6 +44,15 @@ public class ApexTimerInternalsTest {
 
   @Test
   public void testEventTimeTimers() {
+
+    final Map<String, Collection<TimerData>> firedTimers = new HashMap<>();
+    TimerProcessor<String> timerProcessor = new TimerProcessor<String>() {
+      @Override
+      public void fireTimer(String key, Collection<TimerData> timerData) {
+        firedTimers.put(key, timerData);
+      }
+    };
+
     TimerDataCoder timerDataCoder = TimerDataCoder.of(GlobalWindow.Coder.INSTANCE);
     String key1 = "key1";
     Instant instant0 = new Instant(0);
@@ -57,17 +70,60 @@ public class ApexTimerInternalsTest {
         instant1, TimeDomain.EVENT_TIME);
     timerInternals.setTimer(timerData1);
 
-    Multimap<Slice, TimerData> timers = timerInternals.getTimersReadyToProcess(
-        instant0.getMillis());
-    assertEquals(0, timers.size());
+    timerInternals.fireReadyTimers(instant0.getMillis(), timerProcessor, TimeDomain.EVENT_TIME);
+    assertEquals(0, firedTimers.size());
+    firedTimers.clear();
 
-    timers = timerInternals.getTimersReadyToProcess(instant1.getMillis());
-    assertEquals(1, timers.size());
-    assertEquals(Sets.newHashSet(timerData0), Sets.newHashSet(timers.values()));
+    timerInternals.fireReadyTimers(instant1.getMillis(), timerProcessor,
+        TimeDomain.PROCESSING_TIME);
+    assertEquals(0, firedTimers.size());
+    timerInternals.fireReadyTimers(instant1.getMillis(), timerProcessor, TimeDomain.EVENT_TIME);
+    assertEquals(1, firedTimers.size());
+    assertEquals(Sets.newHashSet(timerData0),
+        Sets.newHashSet(firedTimers.values().iterator().next()));
+    firedTimers.clear();
 
-    timers = timerInternals.getTimersReadyToProcess(instant2.getMillis());
-    assertEquals(1, timers.size());
-    assertEquals(Sets.newHashSet(timerData1), Sets.newHashSet(timers.values()));
+    timerInternals.fireReadyTimers(instant2.getMillis(), timerProcessor, TimeDomain.EVENT_TIME);
+    assertEquals(1, firedTimers.size());
+    assertEquals(Sets.newHashSet(timerData1),
+        Sets.newHashSet(firedTimers.values().iterator().next()));
+    firedTimers.clear();
+  }
+
+  @Test
+  public void testDeleteTimer() {
+    TimerDataCoder timerDataCoder = TimerDataCoder.of(GlobalWindow.Coder.INSTANCE);
+    String key1 = "key1";
+    Instant instant0 = new Instant(0);
+    Instant instant1 = new Instant(1);
+
+    ApexTimerInternals<String> timerInternals = new ApexTimerInternals<>(timerDataCoder);
+    timerInternals.setContext(key1, StringUtf8Coder.of(), Instant.now());
+
+    TimerData timerData0 = TimerData.of("timerData0", StateNamespaces.global(),
+        instant0, TimeDomain.EVENT_TIME);
+    timerInternals.setTimer(timerData0);
+
+    TimerData timerData1 = TimerData.of("timerData1", StateNamespaces.global(),
+        instant1, TimeDomain.EVENT_TIME);
+    timerInternals.setTimer(timerData1);
+
+    Map<?, Set<Slice>> timerMap = timerInternals.getTimerSet(TimeDomain.EVENT_TIME).getMap();
+    assertEquals(1, timerMap.size());
+    assertEquals(2, timerMap.values().iterator().next().size());
+
+    timerInternals.deleteTimer(timerData0.getNamespace(), timerData0.getTimerId());
+    assertEquals(1, timerMap.size());
+    assertEquals(1, timerMap.values().iterator().next().size());
+
+    timerInternals.deleteTimer(timerData1.getNamespace(), timerData1.getTimerId(),
+        TimeDomain.PROCESSING_TIME);
+    assertEquals(1, timerMap.size());
+    assertEquals(1, timerMap.values().iterator().next().size());
+
+    timerInternals.deleteTimer(timerData1.getNamespace(), timerData1.getTimerId(),
+        TimeDomain.EVENT_TIME);
+    assertEquals(0, timerMap.size());
   }
 
   @Test
@@ -82,7 +138,7 @@ public class ApexTimerInternalsTest {
     ApexTimerInternals<String> cloned;
     assertNotNull("Serialization", cloned = KryoCloneUtils.cloneObject(timerInternals));
     cloned.setContext(key, StringUtf8Coder.of(), Instant.now());
-    Multimap<Slice, TimerData> timers = cloned.getTimersReadyToProcess(new Instant(1).getMillis());
+    Map<?, Set<Slice>> timers = cloned.getTimerSet(TimeDomain.EVENT_TIME).getMap();
     assertEquals(1, timers.size());
   }
 
diff --git a/runners/apex/src/test/java/org/apache/beam/runners/apex/translation/ApexStateInternalsTest.java b/runners/apex/src/test/java/org/apache/beam/runners/apex/translation/utils/ApexStateInternalsTest.java
similarity index 99%
rename from runners/apex/src/test/java/org/apache/beam/runners/apex/translation/ApexStateInternalsTest.java
rename to runners/apex/src/test/java/org/apache/beam/runners/apex/translation/utils/ApexStateInternalsTest.java
index 091fe3b94cc..225b65439d1 100644
--- a/runners/apex/src/test/java/org/apache/beam/runners/apex/translation/ApexStateInternalsTest.java
+++ b/runners/apex/src/test/java/org/apache/beam/runners/apex/translation/utils/ApexStateInternalsTest.java
@@ -15,7 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.beam.runners.apex.translation;
+package org.apache.beam.runners.apex.translation.utils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -24,7 +24,6 @@ import static org.junit.Assert.assertThat;
 
 import com.datatorrent.lib.util.KryoCloneUtils;
 import java.util.Arrays;
-import org.apache.beam.runners.apex.translation.utils.ApexStateInternals;
 import org.apache.beam.runners.apex.translation.utils.ApexStateInternals.ApexStateBackend;
 import org.apache.beam.runners.apex.translation.utils.ApexStateInternals.ApexStateInternalsFactory;
 import org.apache.beam.runners.core.StateMerging;
