diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java
index fc6eb5efdea..2ca53bd4954 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/Schema.java
@@ -815,9 +815,6 @@ public class Schema implements Serializable {
       if (!getTypeName().equals(other.getTypeName())) {
         return false;
       }
-      if (!Objects.equals(getMetadata(), other.getMetadata())) {
-        return false;
-      }
 
       switch (getTypeName()) {
         case ROW:
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTest.java
index 1369f5912e5..cc476787d2b 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTest.java
@@ -236,6 +236,22 @@ public class SchemaTest {
     assertFalse(schema1.equivalent(schema2));
   }
 
+  @Test
+  public void testFieldsWithDifferentMetadataAreEquivalent() {
+    Field foo = Field.of("foo", FieldType.STRING);
+    Field fooWithMetadata = Field.of("foo", FieldType.STRING.withMetadata("key", "value"));
+
+    Schema schema1 = Schema.builder().addField(foo).build();
+    Schema schema2 = Schema.builder().addField(foo).build();
+    assertEquals(schema1, schema2);
+    assertTrue(schema1.equivalent(schema2));
+
+    schema1 = Schema.builder().addField(foo).build();
+    schema2 = Schema.builder().addField(fooWithMetadata).build();
+    assertNotEquals(schema1, schema2);
+    assertTrue(schema1.equivalent(schema2));
+  }
+
   @Test
   public void testNestedNotEquivalent() {
     Schema nestedSchema1 = Schema.builder().addInt64Field("foo").build();
