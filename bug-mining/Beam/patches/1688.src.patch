diff --git a/sdks/go/pkg/beam/transforms/top/top.go b/sdks/go/pkg/beam/transforms/top/top.go
index 9ca2797a77e..7f950c00020 100644
--- a/sdks/go/pkg/beam/transforms/top/top.go
+++ b/sdks/go/pkg/beam/transforms/top/top.go
@@ -212,6 +212,10 @@ func (f *combineFn) MergeAccumulators(a, b accum) accum {
 
 func (f *combineFn) ExtractOutput(a accum) []beam.T {
 	var ret []beam.T
+	a.enc, a.dec = f.enc, f.dec
+	if err := a.unmarshal(); err != nil {
+		panic(err)
+	}
 	for _, elm := range a.list {
 		ret = append(ret, elm) // implicitly wrap T
 	}
diff --git a/sdks/go/pkg/beam/transforms/top/top_test.go b/sdks/go/pkg/beam/transforms/top/top_test.go
index a6a38b9922c..964e2930cdb 100644
--- a/sdks/go/pkg/beam/transforms/top/top_test.go
+++ b/sdks/go/pkg/beam/transforms/top/top_test.go
@@ -79,7 +79,9 @@ func TestCombineFn3RevString(t *testing.T) {
 	}
 }
 
-// TestCombineFnMerge verifies that accumulators merge correctly.
+// TestCombineFnMerge verifies that accumulators merge correctly and
+// extractOutput still works on the marshalled accumulators it receives after
+// merging.
 func TestCombineFnMerge(t *testing.T) {
 	less := func(a, b string) bool {
 		return len(a) < len(b)
@@ -103,7 +105,7 @@ func TestCombineFnMerge(t *testing.T) {
 				list = append(list, load(fn, a...))
 			}
 			a := merge(t, fn, list...)
-			actual := output(fn, a)
+			actual := outputUnmarshal(t, fn, a)
 			if !reflect.DeepEqual(actual, test.Expected) {
 				t.Errorf("CombineFn(3; %v) = %v, want %v", test.Elms, actual, test.Expected)
 			}
@@ -136,6 +138,18 @@ func merge(t *testing.T, fn *combineFn, as ...accum) accum {
 	return a
 }
 
+func outputUnmarshal(t *testing.T, fn *combineFn, a accum) []string {
+	buf, err := a.MarshalJSON()
+	if err != nil {
+		t.Fatalf("failure marshalling accum: %v, %+v", err, a)
+	}
+	var b accum
+	if err := b.UnmarshalJSON(buf); err != nil {
+		t.Fatalf("failure unmarshalling accum: %v, %+v", err, b)
+	}
+	return output(fn, b)
+}
+
 func output(fn *combineFn, a accum) []string {
 	var ret []string
 	for _, actual := range fn.ExtractOutput(a) {
