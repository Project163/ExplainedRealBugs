diff --git a/sdks/python/apache_beam/runners/interactive/pipeline_analyzer.py b/sdks/python/apache_beam/runners/interactive/pipeline_analyzer.py
index a1c273a9dae..860bbe263fa 100644
--- a/sdks/python/apache_beam/runners/interactive/pipeline_analyzer.py
+++ b/sdks/python/apache_beam/runners/interactive/pipeline_analyzer.py
@@ -375,9 +375,18 @@ class PipelineInfo(object):
     for transform_id, transform_proto in self._proto.transforms.items():
       if transform_proto.subtransforms:
         continue
+      # Identify producers of each PCollection. A PTransform is a producer of
+      # a PCollection if it outputs the PCollection but does not consume the
+      # same PCollection as input. The latter part of the definition is to avoid
+      # infinite recursions when constructing the PCollection's derivation.
+      transform_inputs = set(transform_proto.inputs.values())
       for tag, pcoll_id in transform_proto.outputs.items():
+        if pcoll_id in transform_inputs:
+          # A transform is not the producer of a PCollection if it consumes the
+          # PCollection as an input.
+          continue
         self._producers[pcoll_id] = transform_id, tag
-      for pcoll_id in transform_proto.inputs.values():
+      for pcoll_id in transform_inputs:
         self._consumers[pcoll_id].append(transform_id)
     self._derivations = {}
 
diff --git a/sdks/python/apache_beam/runners/interactive/pipeline_analyzer_test.py b/sdks/python/apache_beam/runners/interactive/pipeline_analyzer_test.py
index 92b5af1097a..e8602269154 100644
--- a/sdks/python/apache_beam/runners/interactive/pipeline_analyzer_test.py
+++ b/sdks/python/apache_beam/runners/interactive/pipeline_analyzer_test.py
@@ -271,5 +271,31 @@ class PipelineAnalyzerTest(unittest.TestCase):
                              to_stable_runner_api(expected_pipeline))
 
 
+class PipelineInfoTest(unittest.TestCase):
+  def setUp(self):
+    self.runner = direct_runner.DirectRunner()
+
+  def test_passthrough(self):
+    """
+    Test that PTransforms which pass through their input PCollection can be
+    used with PipelineInfo.
+    """
+    class Passthrough(beam.PTransform):
+      def expand(self, pcoll):
+        return pcoll
+
+    p = beam.Pipeline(runner=self.runner)
+    p | beam.Impulse() | Passthrough()  # pylint: disable=expression-not-assigned
+    proto = to_stable_runner_api(p).components
+    info = pipeline_analyzer.PipelineInfo(proto)
+    for pcoll_id in info.all_pcollections():
+      # FIXME: If PipelineInfo does not support passthrough PTransforms, this
+      #        will only fail some of the time, depending on the ordering of
+      #        transforms in the Pipeline proto.
+
+      # Should not throw exception
+      info.cache_label(pcoll_id)
+
+
 if __name__ == '__main__':
   unittest.main()
