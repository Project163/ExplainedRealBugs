diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
index dce41382124..1ad57fdfe18 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
@@ -32,6 +32,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
+import java.util.PriorityQueue;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.locks.Lock;
 import java.util.stream.Collectors;
@@ -520,15 +521,8 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
       processWatermark(new Watermark(Long.MAX_VALUE));
       invokeFinishBundle();
       if (currentOutputWatermark < Long.MAX_VALUE) {
-        if (keyedStateInternals == null) {
-          throw new RuntimeException("Current watermark is still " + currentOutputWatermark + ".");
-
-        } else {
-          throw new RuntimeException(
-              "There are still watermark holds. Watermark held at "
-                  + keyedStateInternals.watermarkHold().getMillis()
-                  + ".");
-        }
+        throw new RuntimeException(
+            "There are still watermark holds. Watermark held at " + currentOutputWatermark);
       }
     } finally {
       super.close();
@@ -824,13 +818,13 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
   }
 
   @Override
-  public void onEventTime(InternalTimer<ByteBuffer, TimerData> timer) throws Exception {
+  public void onEventTime(InternalTimer<ByteBuffer, TimerData> timer) {
     checkInvokeStartBundle();
     fireTimer(timer);
   }
 
   @Override
-  public void onProcessingTime(InternalTimer<ByteBuffer, TimerData> timer) throws Exception {
+  public void onProcessingTime(InternalTimer<ByteBuffer, TimerData> timer) {
     checkInvokeStartBundle();
     fireTimer(timer);
   }
@@ -1125,8 +1119,12 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
      */
     @VisibleForTesting final MapState<String, TimerData> pendingTimersById;
 
-    /** Current minimum output timestamp across all registered timers. */
-    private long minOutputTimestampMs;
+    /**
+     * Sorted cache of the output timestamps for timers which have an earlier output time than the
+     * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching
+     * timer data from the state backend which is expensive if done for each timer.
+     */
+    private final PriorityQueue<Long> outputTimestampQueue;
 
     private FlinkTimerInternals() {
       MapStateDescriptor<String, TimerData> pendingTimersByIdStateDescriptor =
@@ -1135,44 +1133,46 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
               new StringSerializer(),
               new CoderTypeSerializer<>(timerCoder));
       this.pendingTimersById = getKeyedStateStore().getMapState(pendingTimersByIdStateDescriptor);
-      computeAndSetMinOutputTimestamp();
+      this.outputTimestampQueue = new PriorityQueue<>();
+      populateOutputTimestampQueue();
     }
 
     /** Gets the current minimum output timestamp across all registered timers. */
     long getMinOutputTimestampMs() {
-      return minOutputTimestampMs;
+      if (outputTimestampQueue.isEmpty()) {
+        return Long.MAX_VALUE;
+      } else {
+        return outputTimestampQueue.peek();
+      }
     }
 
     /** Keeps a minimum output timestamp across all event timers. */
-    private void updateMinTimestampOnNewTimer(TimerData newTimer) {
+    private void onNewEventTimer(TimerData newTimer) {
       Preconditions.checkState(
           newTimer.getDomain() == TimeDomain.EVENT_TIME,
           "Timer with id %s is not an event time timer!",
           newTimer.getTimerId());
-      // A new timer means a potential new minimum; this is cheap to compute.
-      minOutputTimestampMs =
-          Math.min(minOutputTimestampMs, newTimer.getOutputTimestamp().getMillis());
+      if (timerUsesOutputTimestamp(newTimer)) {
+        outputTimestampQueue.add(newTimer.getOutputTimestamp().getMillis());
+      }
     }
 
-    private void updateMinTimestampOnRemovedTimer(TimerData removedTimer) {
-      if (removedTimer.getDomain() != TimeDomain.EVENT_TIME) {
-        return;
-      }
-      long outputTimestampMs = removedTimer.getOutputTimestamp().getMillis();
+    private void onRemovedEventTimer(TimerData removedTimer) {
       Preconditions.checkState(
-          outputTimestampMs >= minOutputTimestampMs || minOutputTimestampMs == Long.MAX_VALUE,
-          "Removed timer's output timestamp (%s) was smaller than the current minimum output timestamp (%s).",
-          outputTimestampMs,
-          minOutputTimestampMs);
-      // If the removed timer had an output timestamp which matched the current minimum,
-      // we have to recompute the output timestamp
-      if (outputTimestampMs == minOutputTimestampMs) {
-        computeAndSetMinOutputTimestamp();
+          removedTimer.getDomain() == TimeDomain.EVENT_TIME,
+          "Timer with id %s is not an event time timer!",
+          removedTimer.getTimerId());
+      // Remove the first occurrence of the output timestamp, if cached
+      // Note: There may be duplicate timestamps from other timers, that's ok.
+      if (timerUsesOutputTimestamp(removedTimer)) {
+        outputTimestampQueue.remove(removedTimer.getOutputTimestamp().getMillis());
       }
     }
 
-    private void computeAndSetMinOutputTimestamp() {
-      minOutputTimestampMs = Long.MAX_VALUE;
+    private void populateOutputTimestampQueue() {
+      Preconditions.checkState(
+          outputTimestampQueue.isEmpty(),
+          "Output timestamp queue should be empty when recomputing the minimum output timestamp across all timers.");
       final KeyedStateBackend<Object> keyedStateBackend = getKeyedStateBackend();
       final Object currentKey = keyedStateBackend.getCurrentKey();
       try (Stream<Object> keys =
@@ -1183,8 +1183,10 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
               try {
                 for (TimerData timerData : pendingTimersById.values()) {
                   if (timerData.getDomain() == TimeDomain.EVENT_TIME) {
-                    minOutputTimestampMs =
-                        Math.min(minOutputTimestampMs, timerData.getOutputTimestamp().getMillis());
+                    long outputTimeStampMs = timerData.getOutputTimestamp().getMillis();
+                    if (timerUsesOutputTimestamp(timerData)) {
+                      outputTimestampQueue.add(outputTimeStampMs);
+                    }
                   }
                 }
               } catch (Exception e) {
@@ -1199,6 +1201,12 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
       }
     }
 
+    private boolean timerUsesOutputTimestamp(TimerData timer) {
+      // If a timer's output timestamp is earlier than the timer timestamp,
+      // we have to hold back the output watermark.
+      return timer.getOutputTimestamp().isBefore(timer.getTimestamp());
+    }
+
     @Override
     public void setTimer(
         StateNamespace namespace,
@@ -1232,11 +1240,12 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
     }
 
     private void registerTimer(TimerData timer, String contextTimerId) throws Exception {
+      pendingTimersById.put(contextTimerId, timer);
       long time = timer.getTimestamp().getMillis();
       switch (timer.getDomain()) {
         case EVENT_TIME:
           timerService.registerEventTimeTimer(timer, adjustTimestampForFlink(time));
-          updateMinTimestampOnNewTimer(timer);
+          onNewEventTimer(timer);
           break;
         case PROCESSING_TIME:
         case SYNCHRONIZED_PROCESSING_TIME:
@@ -1245,7 +1254,6 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
         default:
           throw new UnsupportedOperationException("Unsupported time domain: " + timer.getDomain());
       }
-      pendingTimersById.put(contextTimerId, timer);
     }
 
     /**
@@ -1259,21 +1267,22 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
       }
     }
 
-    /** Hook which must be called when a timer is fired or deleted to perform cleanup. */
+    /**
+     * Hook which must be called when a timer is fired or deleted to perform cleanup. Note: Make
+     * sure that the state backend key is set correctly. It is best to run this in the fireTimer()
+     * method.
+     */
     void onFiredOrDeletedTimer(TimerData timer) {
       try {
         pendingTimersById.remove(getContextTimerId(timer.getTimerId(), timer.getNamespace()));
-        updateMinTimestampOnRemovedTimer(timer);
+        if (timer.getDomain() == TimeDomain.EVENT_TIME) {
+          onRemovedEventTimer(timer);
+        }
       } catch (Exception e) {
         throw new RuntimeException("Failed to cleanup pending timers state.", e);
       }
     }
 
-    /** Unique contextual id of a timer. Used to look up any existing timers in a context. */
-    private String getContextTimerId(String timerId, StateNamespace namespace) {
-      return timerId + namespace.stringKey();
-    }
-
     /** @deprecated use {@link #deleteTimer(StateNamespace, String, TimeDomain)}. */
     @Deprecated
     @Override
@@ -1335,6 +1344,11 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
       return new Instant(currentOutputWatermark);
     }
 
+    /** Unique contextual id of a timer. Used to look up any existing timers in a context. */
+    private String getContextTimerId(String timerId, StateNamespace namespace) {
+      return timerId + namespace.stringKey();
+    }
+
     /**
      * In Beam, a timer with timestamp {@code T} is only illegible for firing when the time has
      * moved past this time stamp, i.e. {@code T < current_time}. In the case of event time,
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java
index e4ca6b08283..fe777e8fb36 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java
@@ -250,40 +250,57 @@ public class DoFnOperatorTest {
   public void testWatermarkContract() throws Exception {
 
     final Instant timerTimestamp = new Instant(1000);
-    final String eventTimeMessage = "Event timer fired";
+    final String eventTimeMessage = "Event timer fired: ";
     final String processingTimeMessage = "Processing timer fired";
 
     WindowingStrategy<Object, IntervalWindow> windowingStrategy =
         WindowingStrategy.of(FixedWindows.of(new Duration(10_000)));
 
+    final String eventTimerId = "eventTimer";
+    final String eventTimerId2 = "eventTimer2";
+    final String processingTimerId = "processingTimer";
     DoFn<Integer, String> fn =
         new DoFn<Integer, String>() {
-          private static final String EVENT_TIMER_ID = "eventTimer";
-          private static final String PROCESSING_TIMER_ID = "processingTimer";
 
-          @TimerId(EVENT_TIMER_ID)
+          @TimerId(eventTimerId)
           private final TimerSpec eventTimer = TimerSpecs.timer(TimeDomain.EVENT_TIME);
 
-          @TimerId(PROCESSING_TIMER_ID)
+          @TimerId(eventTimerId2)
+          private final TimerSpec eventTimer2 = TimerSpecs.timer(TimeDomain.EVENT_TIME);
+
+          @TimerId(processingTimerId)
           private final TimerSpec processingTimer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);
 
           @ProcessElement
           public void processElement(
               ProcessContext context,
-              @TimerId(EVENT_TIMER_ID) Timer eventTimer,
-              @TimerId(PROCESSING_TIMER_ID) Timer processingTimer) {
+              @TimerId(eventTimerId) Timer eventTimer,
+              @TimerId(eventTimerId2) Timer eventTimerWithOutputTimestamp,
+              @TimerId(processingTimerId) Timer processingTimer) {
             eventTimer.set(timerTimestamp);
+            eventTimerWithOutputTimestamp
+                .withOutputTimestamp(timerTimestamp.minus(1))
+                .set(timerTimestamp);
             processingTimer.offset(Duration.millis(timerTimestamp.getMillis())).setRelative();
           }
 
-          @OnTimer(EVENT_TIMER_ID)
+          @OnTimer(eventTimerId)
           public void onEventTime(OnTimerContext context) {
             assertEquals(
                 "Timer timestamp must match set timestamp.", timerTimestamp, context.timestamp());
-            context.outputWithTimestamp(eventTimeMessage, context.timestamp());
+            context.outputWithTimestamp(eventTimeMessage + eventTimerId, context.timestamp());
+          }
+
+          @OnTimer(eventTimerId2)
+          public void onEventTime2(OnTimerContext context) {
+            assertEquals(
+                "Timer timestamp must match set timestamp.",
+                timerTimestamp,
+                context.fireTimestamp());
+            context.output(eventTimeMessage + eventTimerId2);
           }
 
-          @OnTimer(PROCESSING_TIMER_ID)
+          @OnTimer(processingTimerId)
           public void onProcessingTime(OnTimerContext context) {
             assertEquals(
                 // Timestamps in processing timer context are defined to be the input watermark
@@ -346,13 +363,23 @@ public class DoFnOperatorTest {
     testHarness.setProcessingTime(timerTimestamp.getMillis());
 
     assertThat(stripStreamRecordFromWindowedValue(testHarness.getOutput()), emptyIterable());
+    assertThat(
+        doFnOperator.timerInternals.getMinOutputTimestampMs(),
+        is(timerTimestamp.minus(1).getMillis()));
 
-    // this must fire the event timer
+    // this must fire the event timers
     testHarness.processWatermark(timerTimestamp.getMillis() + 1);
 
     assertThat(
         stripStreamRecordFromWindowedValue(testHarness.getOutput()),
-        contains(WindowedValue.of(eventTimeMessage, timerTimestamp, window1, PaneInfo.NO_FIRING)));
+        containsInAnyOrder(
+            WindowedValue.of(
+                eventTimeMessage + eventTimerId, timerTimestamp, window1, PaneInfo.NO_FIRING),
+            WindowedValue.of(
+                eventTimeMessage + eventTimerId2,
+                timerTimestamp.minus(1),
+                window1,
+                PaneInfo.NO_FIRING)));
 
     testHarness.getOutput().clear();
 
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/WindowDoFnOperatorTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/WindowDoFnOperatorTest.java
index 783ed95840e..fdb84c4afdc 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/WindowDoFnOperatorTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/WindowDoFnOperatorTest.java
@@ -153,7 +153,7 @@ public class WindowDoFnOperatorTest {
 
     assertThat(testHarness.numKeyedStateEntries(), is(6));
     assertThat(windowDoFnOperator.currentOutputWatermark, is(1L));
-    assertThat(timerInternals.getMinOutputTimestampMs(), is(99L));
+    assertThat(timerInternals.getMinOutputTimestampMs(), is(Long.MAX_VALUE));
 
     // close window
     testHarness.processWatermark(100L);
@@ -163,7 +163,7 @@ public class WindowDoFnOperatorTest {
 
     assertThat(testHarness.numKeyedStateEntries(), is(3));
     assertThat(windowDoFnOperator.currentOutputWatermark, is(100L));
-    assertThat(timerInternals.getMinOutputTimestampMs(), is(199L));
+    assertThat(timerInternals.getMinOutputTimestampMs(), is(Long.MAX_VALUE));
 
     testHarness.processWatermark(200L);
 
