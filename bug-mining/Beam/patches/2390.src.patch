diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubClient.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubClient.java
index deca0173942..936092a3ba0 100644
--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubClient.java
+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubClient.java
@@ -31,8 +31,8 @@ import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ThreadLocalRandom;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Objects;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Splitter;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Strings;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An (abstract) helper class for talking to Pubsub via an underlying transport. */
@@ -58,13 +58,12 @@ public abstract class PubsubClient implements Closeable {
   }
 
   /**
-   * Return timestamp as ms-since-unix-epoch corresponding to {@code timestamp}. Return {@literal
-   * null} if no timestamp could be found. Throw {@link IllegalArgumentException} if timestamp
-   * cannot be recognized.
+   * Return timestamp as ms-since-unix-epoch corresponding to {@code timestamp}. Throw {@link
+   * IllegalArgumentException} if timestamp cannot be recognized.
    */
-  private static @Nullable Long asMsSinceEpoch(@Nullable String timestamp) {
-    if (Strings.isNullOrEmpty(timestamp)) {
-      return null;
+  protected static Long parseTimestampAsMsSinceEpoch(String timestamp) {
+    if (timestamp.isEmpty()) {
+      throw new IllegalArgumentException("Empty timestamp.");
     }
     try {
       // Try parsing as milliseconds since epoch. Note there is no way to parse a
@@ -81,40 +80,28 @@ public abstract class PubsubClient implements Closeable {
 
   /**
    * Return the timestamp (in ms since unix epoch) to use for a Pubsub message with {@code
-   * attributes} and {@code pubsubTimestamp}.
+   * timestampAttribute} and {@code attriutes}.
    *
-   * <p>If {@code timestampAttribute} is non-{@literal null} then the message attributes must
-   * contain that attribute, and the value of that attribute will be taken as the timestamp.
-   * Otherwise the timestamp will be taken from the Pubsub publish timestamp {@code
-   * pubsubTimestamp}.
+   * <p>The message attributes must contain {@code timestampAttribute}, and the value of that
+   * attribute will be taken as the timestamp.
    *
    * @throws IllegalArgumentException if the timestamp cannot be recognized as a ms-since-unix-epoch
    *     or RFC3339 time.
    */
-  protected static long extractTimestamp(
-      @Nullable String timestampAttribute,
-      @Nullable String pubsubTimestamp,
-      @Nullable Map<String, String> attributes) {
-    Long timestampMsSinceEpoch;
-    if (Strings.isNullOrEmpty(timestampAttribute)) {
-      timestampMsSinceEpoch = asMsSinceEpoch(pubsubTimestamp);
-      checkArgument(
-          timestampMsSinceEpoch != null,
-          "Cannot interpret PubSub publish timestamp: %s",
-          pubsubTimestamp);
-    } else {
-      String value = attributes == null ? null : attributes.get(timestampAttribute);
-      checkArgument(
-          value != null,
-          "PubSub message is missing a value for timestamp attribute %s",
-          timestampAttribute);
-      timestampMsSinceEpoch = asMsSinceEpoch(value);
-      checkArgument(
-          timestampMsSinceEpoch != null,
-          "Cannot interpret value of attribute %s as timestamp: %s",
-          timestampAttribute,
-          value);
-    }
+  protected static long extractTimestampAttribute(
+      String timestampAttribute, @Nullable Map<String, String> attributes) {
+    Preconditions.checkState(!timestampAttribute.isEmpty());
+    String value = attributes == null ? null : attributes.get(timestampAttribute);
+    checkArgument(
+        value != null,
+        "PubSub message is missing a value for timestamp attribute %s",
+        timestampAttribute);
+    Long timestampMsSinceEpoch = parseTimestampAsMsSinceEpoch(value);
+    checkArgument(
+        timestampMsSinceEpoch != null,
+        "Cannot interpret value of attribute %s as timestamp: %s",
+        timestampAttribute,
+        value);
     return timestampMsSinceEpoch;
   }
 
diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubGrpcClient.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubGrpcClient.java
index 06187419218..43b932e80e3 100644
--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubGrpcClient.java
+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubGrpcClient.java
@@ -17,6 +17,7 @@
  */
 package org.apache.beam.sdk.io.gcp.pubsub;
 
+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;
 
 import com.google.auth.Credentials;
@@ -230,14 +231,15 @@ public class PubsubGrpcClient extends PubsubClient {
       @Nullable Map<String, String> attributes = pubsubMessage.getAttributes();
 
       // Timestamp.
-      String pubsubTimestampString = null;
-      Timestamp timestampProto = pubsubMessage.getPublishTime();
-      if (timestampProto != null) {
-        pubsubTimestampString =
-            String.valueOf(timestampProto.getSeconds() + timestampProto.getNanos() / 1000L);
+      long timestampMsSinceEpoch;
+      if (Strings.isNullOrEmpty(timestampAttribute)) {
+        Timestamp timestampProto = pubsubMessage.getPublishTime();
+        checkArgument(timestampProto != null, "Pubsub message is missing timestamp proto");
+        timestampMsSinceEpoch =
+            timestampProto.getSeconds() * 1000 + timestampProto.getNanos() / 1000L / 1000L;
+      } else {
+        timestampMsSinceEpoch = extractTimestampAttribute(timestampAttribute, attributes);
       }
-      long timestampMsSinceEpoch =
-          extractTimestamp(timestampAttribute, pubsubTimestampString, attributes);
 
       // Ack id.
       String ackId = message.getAckId();
diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubJsonClient.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubJsonClient.java
index 198c5389c83..145fe95ce41 100644
--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubJsonClient.java
+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubJsonClient.java
@@ -190,8 +190,12 @@ public class PubsubJsonClient extends PubsubClient {
       }
 
       // Timestamp.
-      long timestampMsSinceEpoch =
-          extractTimestamp(timestampAttribute, message.getMessage().getPublishTime(), attributes);
+      long timestampMsSinceEpoch;
+      if (Strings.isNullOrEmpty(timestampAttribute)) {
+        timestampMsSinceEpoch = parseTimestampAsMsSinceEpoch(message.getMessage().getPublishTime());
+      } else {
+        timestampMsSinceEpoch = extractTimestampAttribute(timestampAttribute, attributes);
+      }
 
       // Ack id.
       String ackId = message.getAckId();
diff --git a/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubClientTest.java b/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubClientTest.java
index 846f593f851..ab62c1e907a 100644
--- a/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubClientTest.java
+++ b/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubClientTest.java
@@ -42,7 +42,7 @@ public class PubsubClientTest {
 
   private long parse(String timestamp) {
     Map<String, String> map = ImmutableMap.of("myAttribute", timestamp);
-    return PubsubClient.extractTimestamp("myAttribute", null, map);
+    return PubsubClient.extractTimestampAttribute("myAttribute", map);
   }
 
   private void roundTripRfc339(String timestamp) {
@@ -53,24 +53,17 @@ public class PubsubClientTest {
     assertEquals(Instant.parse(truncatedTimestmap).getMillis(), parse(timestamp));
   }
 
-  @Test
-  public void noTimestampAttributeReturnsPubsubPublish() {
-    final long time = 987654321L;
-    long timestamp = PubsubClient.extractTimestamp(null, String.valueOf(time), null);
-    assertEquals(time, timestamp);
-  }
-
   @Test
   public void noTimestampAttributeAndInvalidPubsubPublishThrowsError() {
     thrown.expect(NumberFormatException.class);
-    PubsubClient.extractTimestamp(null, "not-a-date", null);
+    PubsubClient.parseTimestampAsMsSinceEpoch("not-a-date");
   }
 
   @Test
   public void timestampAttributeWithNullAttributesThrowsError() {
     thrown.expect(RuntimeException.class);
     thrown.expectMessage("PubSub message is missing a value for timestamp attribute myAttribute");
-    PubsubClient.extractTimestamp("myAttribute", null, null);
+    PubsubClient.extractTimestampAttribute("myAttribute", null);
   }
 
   @Test
@@ -78,14 +71,14 @@ public class PubsubClientTest {
     thrown.expect(RuntimeException.class);
     thrown.expectMessage("PubSub message is missing a value for timestamp attribute myAttribute");
     Map<String, String> map = ImmutableMap.of("otherLabel", "whatever");
-    PubsubClient.extractTimestamp("myAttribute", null, map);
+    PubsubClient.extractTimestampAttribute("myAttribute", map);
   }
 
   @Test
   public void timestampAttributeParsesMillisecondsSinceEpoch() {
     long time = 1446162101123L;
     Map<String, String> map = ImmutableMap.of("myAttribute", String.valueOf(time));
-    long timestamp = PubsubClient.extractTimestamp("myAttribute", null, map);
+    long timestamp = PubsubClient.extractTimestampAttribute("myAttribute", map);
     assertEquals(time, timestamp);
   }
 
diff --git a/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubGrpcClientTest.java b/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubGrpcClientTest.java
index 4dd719b5de1..8eeacc47e67 100644
--- a/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubGrpcClientTest.java
+++ b/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubGrpcClientTest.java
@@ -48,6 +48,7 @@ import org.apache.beam.sdk.io.gcp.pubsub.PubsubClient.TopicPath;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -65,9 +66,9 @@ public class PubsubGrpcClientTest {
   private static final TopicPath TOPIC = PubsubClient.topicPathFromName("testProject", "testTopic");
   private static final SubscriptionPath SUBSCRIPTION =
       PubsubClient.subscriptionPathFromName("testProject", "testSubscription");
-  private static final long REQ_TIME = 1234L;
-  private static final long PUB_TIME = 3456L;
-  private static final long MESSAGE_TIME = 6789L;
+  private static final long REQ_TIME_MS = 1234L;
+  private static final long PUB_TIME_MS = 3456L;
+  private static final long MESSAGE_TIME_MS = 6789L;
   private static final String TIMESTAMP_ATTRIBUTE = "timestamp";
   private static final String ID_ATTRIBUTE = "id";
   private static final String MESSAGE_ID = "testMessageId";
@@ -83,10 +84,14 @@ public class PubsubGrpcClientTest {
         String.format(
             "%s-%s", PubsubGrpcClientTest.class.getName(), ThreadLocalRandom.current().nextInt());
     inProcessChannel = InProcessChannelBuilder.forName(channelName).directExecutor().build();
+  }
+
+  protected void initializeClient(
+      @Nullable String timestampAttribute, @Nullable String idAttribute) {
     Credentials testCredentials = new TestCredential();
     client =
         new PubsubGrpcClient(
-            TIMESTAMP_ATTRIBUTE, ID_ATTRIBUTE, 10, inProcessChannel, testCredentials);
+            timestampAttribute, idAttribute, 10, inProcessChannel, testCredentials);
   }
 
   @After
@@ -97,6 +102,62 @@ public class PubsubGrpcClientTest {
 
   @Test
   public void pullOneMessage() throws IOException {
+    initializeClient(null, null);
+    String expectedSubscription = SUBSCRIPTION.getPath();
+    final PullRequest expectedRequest =
+        PullRequest.newBuilder()
+            .setSubscription(expectedSubscription)
+            .setReturnImmediately(true)
+            .setMaxMessages(10)
+            .build();
+    Timestamp timestamp =
+        Timestamp.newBuilder()
+            .setSeconds(PUB_TIME_MS / 1000)
+            .setNanos((int) (PUB_TIME_MS % 1000) * 1000 * 1000)
+            .build();
+    PubsubMessage expectedPubsubMessage =
+        PubsubMessage.newBuilder()
+            .setMessageId(MESSAGE_ID)
+            .setData(ByteString.copyFrom(DATA.getBytes(StandardCharsets.UTF_8)))
+            .setPublishTime(timestamp)
+            .build();
+    ReceivedMessage expectedReceivedMessage =
+        ReceivedMessage.newBuilder().setMessage(expectedPubsubMessage).setAckId(ACK_ID).build();
+    final PullResponse response =
+        PullResponse.newBuilder()
+            .addAllReceivedMessages(ImmutableList.of(expectedReceivedMessage))
+            .build();
+
+    final List<PullRequest> requestsReceived = new ArrayList<>();
+    SubscriberImplBase subscriberImplBase =
+        new SubscriberImplBase() {
+          @Override
+          public void pull(PullRequest request, StreamObserver<PullResponse> responseObserver) {
+            requestsReceived.add(request);
+            responseObserver.onNext(response);
+            responseObserver.onCompleted();
+          }
+        };
+    Server server =
+        InProcessServerBuilder.forName(channelName).addService(subscriberImplBase).build().start();
+    try {
+      List<IncomingMessage> actualMessages = client.pull(REQ_TIME_MS, SUBSCRIPTION, 10, true);
+      assertEquals(1, actualMessages.size());
+      IncomingMessage actualMessage = actualMessages.get(0);
+      assertEquals(ACK_ID, actualMessage.ackId());
+      assertEquals(DATA, actualMessage.message().getData().toStringUtf8());
+      assertEquals(MESSAGE_ID, actualMessage.recordId());
+      assertEquals(REQ_TIME_MS, actualMessage.requestTimeMsSinceEpoch());
+      assertEquals(PUB_TIME_MS, actualMessage.timestampMsSinceEpoch());
+      assertEquals(expectedRequest, Iterables.getOnlyElement(requestsReceived));
+    } finally {
+      server.shutdownNow();
+    }
+  }
+
+  @Test
+  public void pullOneMessageUsingAttributes() throws IOException {
+    initializeClient(TIMESTAMP_ATTRIBUTE, ID_ATTRIBUTE);
     String expectedSubscription = SUBSCRIPTION.getPath();
     final PullRequest expectedRequest =
         PullRequest.newBuilder()
@@ -106,8 +167,8 @@ public class PubsubGrpcClientTest {
             .build();
     Timestamp timestamp =
         Timestamp.newBuilder()
-            .setSeconds(PUB_TIME / 1000)
-            .setNanos((int) (PUB_TIME % 1000) * 1000)
+            .setSeconds(PUB_TIME_MS / 1000)
+            .setNanos((int) (PUB_TIME_MS % 1000) * 1000 * 1000)
             .build();
     PubsubMessage expectedPubsubMessage =
         PubsubMessage.newBuilder()
@@ -117,7 +178,7 @@ public class PubsubGrpcClientTest {
             .putAllAttributes(ATTRIBUTES)
             .putAllAttributes(
                 ImmutableMap.of(
-                    TIMESTAMP_ATTRIBUTE, String.valueOf(MESSAGE_TIME), ID_ATTRIBUTE, RECORD_ID))
+                    TIMESTAMP_ATTRIBUTE, String.valueOf(MESSAGE_TIME_MS), ID_ATTRIBUTE, RECORD_ID))
             .build();
     ReceivedMessage expectedReceivedMessage =
         ReceivedMessage.newBuilder().setMessage(expectedPubsubMessage).setAckId(ACK_ID).build();
@@ -139,14 +200,14 @@ public class PubsubGrpcClientTest {
     Server server =
         InProcessServerBuilder.forName(channelName).addService(subscriberImplBase).build().start();
     try {
-      List<IncomingMessage> acutalMessages = client.pull(REQ_TIME, SUBSCRIPTION, 10, true);
-      assertEquals(1, acutalMessages.size());
-      IncomingMessage actualMessage = acutalMessages.get(0);
+      List<IncomingMessage> actualMessages = client.pull(REQ_TIME_MS, SUBSCRIPTION, 10, true);
+      assertEquals(1, actualMessages.size());
+      IncomingMessage actualMessage = actualMessages.get(0);
       assertEquals(ACK_ID, actualMessage.ackId());
       assertEquals(DATA, actualMessage.message().getData().toStringUtf8());
       assertEquals(RECORD_ID, actualMessage.recordId());
-      assertEquals(REQ_TIME, actualMessage.requestTimeMsSinceEpoch());
-      assertEquals(MESSAGE_TIME, actualMessage.timestampMsSinceEpoch());
+      assertEquals(REQ_TIME_MS, actualMessage.requestTimeMsSinceEpoch());
+      assertEquals(MESSAGE_TIME_MS, actualMessage.timestampMsSinceEpoch());
       assertEquals(expectedRequest, Iterables.getOnlyElement(requestsReceived));
     } finally {
       server.shutdownNow();
@@ -155,6 +216,7 @@ public class PubsubGrpcClientTest {
 
   @Test
   public void publishOneMessage() throws IOException {
+    initializeClient(TIMESTAMP_ATTRIBUTE, ID_ATTRIBUTE);
     String expectedTopic = TOPIC.getPath();
     PubsubMessage expectedPubsubMessage =
         PubsubMessage.newBuilder()
@@ -162,7 +224,7 @@ public class PubsubGrpcClientTest {
             .putAllAttributes(ATTRIBUTES)
             .putAllAttributes(
                 ImmutableMap.of(
-                    TIMESTAMP_ATTRIBUTE, String.valueOf(MESSAGE_TIME), ID_ATTRIBUTE, RECORD_ID))
+                    TIMESTAMP_ATTRIBUTE, String.valueOf(MESSAGE_TIME_MS), ID_ATTRIBUTE, RECORD_ID))
             .build();
     final PublishRequest expectedRequest =
         PublishRequest.newBuilder()
@@ -192,7 +254,7 @@ public class PubsubGrpcClientTest {
                   .setData(ByteString.copyFromUtf8(DATA))
                   .putAllAttributes(ATTRIBUTES)
                   .build(),
-              MESSAGE_TIME,
+              MESSAGE_TIME_MS,
               RECORD_ID);
       int n = client.publish(TOPIC, ImmutableList.of(actualMessage));
       assertEquals(1, n);
