diff --git a/CHANGES.md b/CHANGES.md
index f3106211dce..1aa7b5ca432 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -61,6 +61,7 @@
 
 ## New Features / Improvements
 
+* Support for repeatable fields in JSON decoder for `ReadFromBigQuery` added. (Python) ([BEAM-10524](https://issues.apache.org/jira/browse/BEAM-10524))
 * X feature added (Java/Python) ([BEAM-X](https://issues.apache.org/jira/browse/BEAM-X)).
 
 ## Breaking Changes
diff --git a/sdks/python/apache_beam/io/gcp/bigquery.py b/sdks/python/apache_beam/io/gcp/bigquery.py
index b003a54d387..4a77eb86970 100644
--- a/sdks/python/apache_beam/io/gcp/bigquery.py
+++ b/sdks/python/apache_beam/io/gcp/bigquery.py
@@ -545,31 +545,32 @@ class BigQuerySource(dataflow_io.NativeSource):
         kms_key=self.kms_key)
 
 
-FieldSchema = collections.namedtuple('FieldSchema', 'fields mode name type')
-
-
-def _to_decimal(value):
-  return decimal.Decimal(value)
-
-
-def _to_bytes(value):
-  """Converts value from str to bytes on Python 3.x. Does nothing on
-  Python 2.7."""
-  return value.encode('utf-8')
-
-
 class _JsonToDictCoder(coders.Coder):
   """A coder for a JSON string to a Python dict."""
+
+  FieldSchema = collections.namedtuple('FieldSchema', 'fields mode name type')
+
   def __init__(self, table_schema):
     self.fields = self._convert_to_tuple(table_schema.fields)
     self._converters = {
         'INTEGER': int,
         'INT64': int,
         'FLOAT': float,
-        'NUMERIC': _to_decimal,
-        'BYTES': _to_bytes,
+        'FLOAT64': float,
+        'NUMERIC': self._to_decimal,
+        'BYTES': self._to_bytes,
     }
 
+  @staticmethod
+  def _to_decimal(value):
+    return decimal.Decimal(value)
+
+  @staticmethod
+  def _to_bytes(value):
+    """Converts value from str to bytes on Python 3.x. Does nothing on
+    Python 2.7."""
+    return value.encode('utf-8')
+
   @classmethod
   def _convert_to_tuple(cls, table_field_schemas):
     """Recursively converts the list of TableFieldSchema instances to the
@@ -580,7 +581,8 @@ class _JsonToDictCoder(coders.Coder):
       return []
 
     return [
-        FieldSchema(cls._convert_to_tuple(x.fields), x.mode, x.name, x.type)
+        cls.FieldSchema(
+            cls._convert_to_tuple(x.fields), x.mode, x.name, x.type)
         for x in table_field_schemas
     ]
 
@@ -598,8 +600,14 @@ class _JsonToDictCoder(coders.Coder):
         continue
 
       if field.type == 'RECORD':
-        value[field.name] = self._decode_with_schema(
-            value[field.name], field.fields)
+        nested_values = value[field.name]
+        if field.mode == 'REPEATED':
+          for i, nested_value in enumerate(nested_values):
+            nested_values[i] = self._decode_with_schema(
+                nested_value, field.fields)
+        else:
+          value[field.name] = self._decode_with_schema(
+              nested_values, field.fields)
       else:
         try:
           converter = self._converters[field.type]
diff --git a/sdks/python/apache_beam/io/gcp/bigquery_test.py b/sdks/python/apache_beam/io/gcp/bigquery_test.py
index 1cec29ad5ba..a57f0a37dcc 100644
--- a/sdks/python/apache_beam/io/gcp/bigquery_test.py
+++ b/sdks/python/apache_beam/io/gcp/bigquery_test.py
@@ -266,7 +266,8 @@ class TestJsonToDictCoder(unittest.TestCase):
     def _fill_schema(fields):
       for field in fields:
         table_field = bigquery.TableFieldSchema()
-        table_field.name, table_field.type, nested_fields = field
+        table_field.name, table_field.type, table_field.mode, nested_fields, \
+          = field
         if nested_fields:
           table_field.fields = list(_fill_schema(nested_fields))
         yield table_field
@@ -278,10 +279,13 @@ class TestJsonToDictCoder(unittest.TestCase):
   def test_coder_is_pickable(self):
     try:
       schema = self._make_schema([
-          ('record', 'RECORD', [
-              ('float', 'FLOAT', []),
-          ]),
-          ('integer', 'INTEGER', []),
+          (
+              'record',
+              'RECORD',
+              'NULLABLE', [
+                  ('float', 'FLOAT', 'NULLABLE', []),
+              ]),
+          ('integer', 'INTEGER', 'NULLABLE', []),
       ])
       coder = _JsonToDictCoder(schema)
       pickler.loads(pickler.dumps(coder))
@@ -291,8 +295,8 @@ class TestJsonToDictCoder(unittest.TestCase):
   def test_values_are_converted(self):
     input_row = b'{"float": "10.5", "string": "abc"}'
     expected_row = {'float': 10.5, 'string': 'abc'}
-    schema = self._make_schema([('float', 'FLOAT', []),
-                                ('string', 'STRING', [])])
+    schema = self._make_schema([('float', 'FLOAT', 'NULLABLE', []),
+                                ('string', 'STRING', 'NULLABLE', [])])
     coder = _JsonToDictCoder(schema)
 
     actual = coder.decode(input_row)
@@ -301,8 +305,8 @@ class TestJsonToDictCoder(unittest.TestCase):
   def test_null_fields_are_preserved(self):
     input_row = b'{"float": "10.5"}'
     expected_row = {'float': 10.5, 'string': None}
-    schema = self._make_schema([('float', 'FLOAT', []),
-                                ('string', 'STRING', [])])
+    schema = self._make_schema([('float', 'FLOAT', 'NULLABLE', []),
+                                ('string', 'STRING', 'NULLABLE', [])])
     coder = _JsonToDictCoder(schema)
 
     actual = coder.decode(input_row)
@@ -312,10 +316,31 @@ class TestJsonToDictCoder(unittest.TestCase):
     input_row = b'{"record": {"float": "55.5"}, "integer": 10}'
     expected_row = {'record': {'float': 55.5}, 'integer': 10}
     schema = self._make_schema([
-        ('record', 'RECORD', [
-            ('float', 'FLOAT', []),
-        ]),
-        ('integer', 'INTEGER', []),
+        (
+            'record',
+            'RECORD',
+            'NULLABLE', [
+                ('float', 'FLOAT', 'NULLABLE', []),
+            ]),
+        ('integer', 'INTEGER', 'NULLABLE', []),
+    ])
+    coder = _JsonToDictCoder(schema)
+
+    actual = coder.decode(input_row)
+    self.assertEqual(expected_row, actual)
+
+  def test_record_and_repeatable_field_is_properly_converted(self):
+    input_row = b'{"record": [{"float": "55.5"}, {"float": "65.5"}], ' \
+                b'"integer": 10}'
+    expected_row = {'record': [{'float': 55.5}, {'float': 65.5}], 'integer': 10}
+    schema = self._make_schema([
+        (
+            'record',
+            'RECORD',
+            'REPEATED', [
+                ('float', 'FLOAT', 'NULLABLE', []),
+            ]),
+        ('integer', 'INTEGER', 'NULLABLE', []),
     ])
     coder = _JsonToDictCoder(schema)
 
