diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnHarness.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnHarness.java
index 4b9ec82d96c..08e90313bdb 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnHarness.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnHarness.java
@@ -62,6 +62,7 @@ import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.CacheLoade
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.LoadingCache;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.util.concurrent.MoreExecutors;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -314,15 +315,22 @@ public class FnHarness {
                                       Collectors.toMap(
                                           Function.identity(), metricsShortIds::get)))));
 
-      BeamFnControlClient control =
-          new BeamFnControlClient(id, controlStub, outboundObserverFactory, handlers);
-
       JvmInitializers.runBeforeProcessing(options);
 
       ExecutionStateSampler.instance().start();
 
       LOG.info("Entering instruction processing loop");
-      control.processInstructionRequests(executorService);
+
+      // The control client immediately dispatches requests to an executor so we execute on the
+      // direct executor. If we created separate channels for different stubs we could use
+      // directExecutor() when building the channel.
+      BeamFnControlClient control =
+          new BeamFnControlClient(
+              controlStub.withExecutor(MoreExecutors.directExecutor()),
+              outboundObserverFactory,
+              executorService,
+              handlers);
+      control.waitForTermination();
       processBundleHandler.shutdown();
     } finally {
       System.out.println("Shutting SDK harness down.");
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/BeamFnControlClient.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/BeamFnControlClient.java
index bb5eeee9458..020a2e2e3a3 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/BeamFnControlClient.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/BeamFnControlClient.java
@@ -20,12 +20,9 @@ package org.apache.beam.fn.harness.control;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables.getStackTraceAsString;
 
 import java.util.EnumMap;
-import java.util.Objects;
-import java.util.concurrent.BlockingDeque;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
-import java.util.concurrent.LinkedBlockingDeque;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi;
 import org.apache.beam.model.fnexecution.v1.BeamFnControlGrpc;
 import org.apache.beam.model.pipeline.v1.Endpoints.ApiServiceDescriptor;
@@ -34,7 +31,6 @@ import org.apache.beam.sdk.fn.stream.OutboundObserverFactory;
 import org.apache.beam.sdk.function.ThrowingFunction;
 import org.apache.beam.vendor.grpc.v1p26p0.io.grpc.Status;
 import org.apache.beam.vendor.grpc.v1p26p0.io.grpc.stub.StreamObserver;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.util.concurrent.Uninterruptibles;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -52,13 +48,9 @@ import org.slf4j.LoggerFactory;
  * client will not produce any more {@link BeamFnApi.InstructionRequest}s.
  */
 public class BeamFnControlClient {
-  private static final String FAKE_INSTRUCTION_ID = "FAKE_INSTRUCTION_ID";
   private static final Logger LOG = LoggerFactory.getLogger(BeamFnControlClient.class);
-  private static final BeamFnApi.InstructionRequest POISON_PILL =
-      BeamFnApi.InstructionRequest.newBuilder().setInstructionId(FAKE_INSTRUCTION_ID).build();
 
   private final StreamObserver<BeamFnApi.InstructionResponse> outboundObserver;
-  private final BlockingDeque<BeamFnApi.InstructionRequest> bufferedInstructions;
   private final EnumMap<
           BeamFnApi.InstructionRequest.RequestCase,
           ThrowingFunction<BeamFnApi.InstructionRequest, BeamFnApi.InstructionResponse.Builder>>
@@ -66,32 +58,32 @@ public class BeamFnControlClient {
   private final CompletableFuture<Object> onFinish;
 
   public BeamFnControlClient(
-      String id,
       ApiServiceDescriptor apiServiceDescriptor,
       ManagedChannelFactory channelFactory,
       OutboundObserverFactory outboundObserverFactory,
+      Executor executor,
       EnumMap<
               BeamFnApi.InstructionRequest.RequestCase,
               ThrowingFunction<BeamFnApi.InstructionRequest, BeamFnApi.InstructionResponse.Builder>>
           handlers) {
     this(
-        id,
         BeamFnControlGrpc.newStub(channelFactory.forDescriptor(apiServiceDescriptor)),
         outboundObserverFactory,
+        executor,
         handlers);
   }
 
   public BeamFnControlClient(
-      String id,
       BeamFnControlGrpc.BeamFnControlStub controlStub,
       OutboundObserverFactory outboundObserverFactory,
+      Executor executor,
       EnumMap<
               BeamFnApi.InstructionRequest.RequestCase,
               ThrowingFunction<BeamFnApi.InstructionRequest, BeamFnApi.InstructionResponse.Builder>>
           handlers) {
-    this.bufferedInstructions = new LinkedBlockingDeque<>();
     this.outboundObserver =
-        outboundObserverFactory.outboundObserverFor(controlStub::control, new InboundObserver());
+        outboundObserverFactory.outboundObserverFor(
+            controlStub::control, new InboundObserver(executor));
     this.handlers = handlers;
     this.onFinish = new CompletableFuture<>();
   }
@@ -103,65 +95,40 @@ public class BeamFnControlClient {
    * termination.
    */
   private class InboundObserver implements StreamObserver<BeamFnApi.InstructionRequest> {
+    private final Executor executor;
+
+    InboundObserver(Executor executorService) {
+      this.executor = executorService;
+    }
 
     @Override
     public void onNext(BeamFnApi.InstructionRequest value) {
       LOG.debug("Received InstructionRequest {}", value);
-      Uninterruptibles.putUninterruptibly(bufferedInstructions, value);
+      executor.execute(
+          () -> {
+            try {
+              BeamFnApi.InstructionResponse response = delegateOnInstructionRequestType(value);
+              sendInstructionResponse(response);
+            } catch (Error e) {
+              sendErrorResponse(e);
+              throw e;
+            }
+          });
     }
 
     @Override
     public void onError(Throwable t) {
-      placePoisonPillIntoQueue();
       onFinish.completeExceptionally(t);
     }
 
     @Override
     public void onCompleted() {
-      placePoisonPillIntoQueue();
       onFinish.complete(COMPLETED);
     }
-
-    /**
-     * This method emulates {@link Uninterruptibles#putUninterruptibly} but placing the element at
-     * the front of the queue.
-     *
-     * <p>We place the poison pill at the front of the queue because if the server shutdown, any
-     * remaining instructions can be discarded.
-     */
-    private void placePoisonPillIntoQueue() {
-      while (true) {
-        try {
-          bufferedInstructions.putFirst(POISON_PILL);
-          return;
-        } catch (InterruptedException e) {
-          // Ignored until we place the poison pill into the queue
-        }
-      }
-    }
   }
 
-  /**
-   * Note that this method continuously submits work to the supplied executor until the Beam Fn
-   * Control server hangs up or fails exceptionally.
-   */
-  public void processInstructionRequests(Executor executor)
-      throws InterruptedException, ExecutionException {
-    BeamFnApi.InstructionRequest request;
-    while (!Objects.equals((request = bufferedInstructions.take()), POISON_PILL)) {
-      BeamFnApi.InstructionRequest currentRequest = request;
-      executor.execute(
-          () -> {
-            try {
-              BeamFnApi.InstructionResponse response =
-                  delegateOnInstructionRequestType(currentRequest);
-              sendInstructionResponse(response);
-            } catch (Error e) {
-              sendErrorResponse(e);
-              throw e;
-            }
-          });
-    }
+  /** This method blocks until the control stream has completed. */
+  public void waitForTermination() throws InterruptedException, ExecutionException {
     onFinish.get();
   }
 
@@ -204,7 +171,6 @@ public class BeamFnControlClient {
         Status.INTERNAL
             .withDescription(String.format("%s: %s", e.getClass().getName(), e.getMessage()))
             .asException());
-    // TODO: Should this clear out the instruction request queue?
   }
 
   private BeamFnApi.InstructionResponse.Builder missingHandler(
diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/control/BeamFnControlClientTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/control/BeamFnControlClientTest.java
index fddb6b2c3e3..168e396eacf 100644
--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/control/BeamFnControlClientTest.java
+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/control/BeamFnControlClientTest.java
@@ -31,7 +31,6 @@ import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi;
@@ -130,26 +129,19 @@ public class BeamFnControlClientTest {
             throw FAILURE;
           });
 
+      ExecutorService executor = Executors.newCachedThreadPool();
       BeamFnControlClient client =
           new BeamFnControlClient(
-              "",
               apiServiceDescriptor,
               InProcessManagedChannelFactory.create(),
               OutboundObserverFactory.trivial(),
+              executor,
               handlers);
 
       // Get the connected client and attempt to send and receive an instruction
       StreamObserver<BeamFnApi.InstructionRequest> outboundServerObserver =
           outboundServerObservers.take();
 
-      ExecutorService executor = Executors.newCachedThreadPool();
-      Future<Void> future =
-          executor.submit(
-              () -> {
-                client.processInstructionRequests(executor);
-                return null;
-              });
-
       outboundServerObserver.onNext(SUCCESSFUL_REQUEST);
       assertEquals(SUCCESSFUL_RESPONSE, values.take());
 
@@ -165,7 +157,7 @@ public class BeamFnControlClientTest {
       // Ensure that the server completing the stream translates to the completable future
       // being completed allowing for a successful shutdown of the client.
       outboundServerObserver.onCompleted();
-      future.get();
+      client.waitForTermination();
     } finally {
       server.shutdownNow();
     }
@@ -210,26 +202,19 @@ public class BeamFnControlClientTest {
             throw new Error("Test Error");
           });
 
+      ExecutorService executor = Executors.newCachedThreadPool();
       BeamFnControlClient client =
           new BeamFnControlClient(
-              "",
               apiServiceDescriptor,
               InProcessManagedChannelFactory.create(),
               OutboundObserverFactory.trivial(),
+              executor,
               handlers);
 
       // Get the connected client and attempt to send and receive an instruction
       StreamObserver<BeamFnApi.InstructionRequest> outboundServerObserver =
           outboundServerObservers.take();
 
-      ExecutorService executor = Executors.newCachedThreadPool();
-      Future<Void> future =
-          executor.submit(
-              () -> {
-                client.processInstructionRequests(executor);
-                return null;
-              });
-
       // Ensure that all exceptions are caught and translated to failures
       outboundServerObserver.onNext(
           InstructionRequest.newBuilder()
@@ -241,7 +226,7 @@ public class BeamFnControlClientTest {
 
       // Ensure that the client shuts down when an Error is thrown from the harness
       try {
-        future.get();
+        client.waitForTermination();
         throw new IllegalStateException("The future should have terminated with an error");
       } catch (ExecutionException errorWrapper) {
         assertThat(errorWrapper.getCause().getMessage(), containsString("Test Error"));
