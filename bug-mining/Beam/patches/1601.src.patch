diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
index 3af14ca5371..3adf8cf65f8 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
@@ -88,6 +88,7 @@ import org.apache.beam.sdk.values.PCollectionView;
 import org.apache.beam.sdk.values.TupleTag;
 import org.apache.beam.sdk.values.WindowingStrategy;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
+import org.apache.beam.vendor.grpc.v1p26p0.io.grpc.StatusRuntimeException;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Charsets;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
 import org.apache.beam.vendor.sdk.v2.sdk.extensions.protobuf.ByteStringCoder;
@@ -698,6 +699,9 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
         remoteBundle.close();
         emitResults();
       } catch (Exception e) {
+        if (e.getCause() instanceof StatusRuntimeException) {
+          throw new RuntimeException("SDK Harness connection lost.", e);
+        }
         throw new RuntimeException("Failed to finish remote bundle", e);
       } finally {
         remoteBundle = null;
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactory.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactory.java
index 006790f213a..84dc918fed1 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactory.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactory.java
@@ -19,7 +19,7 @@ package org.apache.beam.runners.fnexecution.control;
 
 import com.google.auto.value.AutoValue;
 import java.io.IOException;
-import java.util.HashMap;
+import java.util.IdentityHashMap;
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -321,8 +321,9 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
 
     private final ExecutableStage executableStage;
     private final int environmentIndex;
-    private final HashMap<WrappedSdkHarnessClient, PreparedClient> preparedClients = new HashMap();
-    private PreparedClient currentClient;
+    private final Map<WrappedSdkHarnessClient, PreparedClient> preparedClients =
+        new IdentityHashMap<>();
+    private volatile PreparedClient currentClient;
 
     private SimpleStageBundleFactory(ExecutableStage executableStage) {
       this.executableStage = executableStage;
@@ -342,22 +343,14 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
       // TODO: Consider having BundleProcessor#newBundle take in an OutputReceiverFactory rather
       // than constructing the receiver map here. Every bundle factory will need this.
 
-      if (environmentExpirationMillis == 0 && !loadBalanceBundles) {
-        return currentClient.processor.newBundle(
-            getOutputReceivers(currentClient.processBundleDescriptor, outputReceiverFactory)
-                .build(),
-            stateRequestHandler,
-            progressHandler);
-      }
-
       final LoadingCache<Environment, WrappedSdkHarnessClient> currentCache;
+      final WrappedSdkHarnessClient client;
       if (loadBalanceBundles) {
         // The semaphore is used to ensure fairness, i.e. first stop first go.
         availableCachesSemaphore.acquire();
         // The blocking queue of caches for serving multiple bundles concurrently.
         currentCache = availableCaches.take();
-        WrappedSdkHarnessClient client =
-            currentCache.getUnchecked(executableStage.getEnvironment());
+        client = currentCache.getUnchecked(executableStage.getEnvironment());
         client.ref();
 
         currentClient = preparedClients.get(client);
@@ -370,8 +363,7 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
 
       } else {
         currentCache = environmentCaches.get(environmentIndex);
-        WrappedSdkHarnessClient client =
-            currentCache.getUnchecked(executableStage.getEnvironment());
+        client = currentCache.getUnchecked(executableStage.getEnvironment());
         client.ref();
 
         if (currentClient.wrappedClient != client) {
@@ -406,11 +398,14 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
 
         @Override
         public void close() throws Exception {
-          bundle.close();
-          currentClient.wrappedClient.unref();
-          if (loadBalanceBundles) {
-            availableCaches.offer(currentCache);
-            availableCachesSemaphore.release();
+          try {
+            bundle.close();
+          } finally {
+            client.unref();
+            if (loadBalanceBundles) {
+              availableCaches.offer(currentCache);
+              availableCachesSemaphore.release();
+            }
           }
         }
       };
@@ -467,13 +462,15 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
       // DO NOT ADD ANYTHING HERE WHICH MIGHT CAUSE THE BLOCK BELOW TO NOT BE EXECUTED.
       // If we exit prematurely (e.g. due to an exception), resources won't be cleaned up properly.
       // Please make an AutoCloseable and add it to the try statement below.
+      // These will be closed in the reverse creation order:
       try (AutoCloseable envCloser = environment;
+          AutoCloseable provisioningServer = serverInfo.getProvisioningServer();
+          AutoCloseable retrievalServer = serverInfo.getRetrievalServer();
           AutoCloseable stateServer = serverInfo.getStateServer();
-          AutoCloseable dateServer = serverInfo.getDataServer();
+          AutoCloseable dataServer = serverInfo.getDataServer();
           AutoCloseable controlServer = serverInfo.getControlServer();
-          AutoCloseable loggingServer = serverInfo.getLoggingServer();
-          AutoCloseable retrievalServer = serverInfo.getRetrievalServer();
-          AutoCloseable provisioningServer = serverInfo.getProvisioningServer()) {
+          // Close the logging server first to prevent spaming the logs with error messages
+          AutoCloseable loggingServer = serverInfo.getLoggingServer()) {
         // Wrap resources in try-with-resources to ensure all are cleaned up.
         // This will close _all_ of these even in the presence of exceptions.
         // The first exception encountered will be the base exception,
diff --git a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactoryTest.java b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactoryTest.java
index 1d53d35272c..23aebf8e075 100644
--- a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactoryTest.java
+++ b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactoryTest.java
@@ -72,6 +72,7 @@ import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
 import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
@@ -360,6 +361,33 @@ public class DefaultJobBundleFactoryTest {
     verify(remoteEnvironment).close();
   }
 
+  @Test
+  public void closesFnServices() throws Exception {
+    InOrder inOrder =
+        Mockito.inOrder(
+            loggingServer,
+            controlServer,
+            dataServer,
+            stateServer,
+            retrievalServer,
+            provisioningServer,
+            remoteEnvironment);
+
+    try (DefaultJobBundleFactory bundleFactory =
+        createDefaultJobBundleFactory(envFactoryProviderMap)) {
+      bundleFactory.forStage(getExecutableStage(environment));
+    }
+
+    // Close logging service first to avoid spaming the logs
+    inOrder.verify(loggingServer).close();
+    inOrder.verify(controlServer).close();
+    inOrder.verify(dataServer).close();
+    inOrder.verify(stateServer).close();
+    inOrder.verify(retrievalServer).close();
+    inOrder.verify(provisioningServer).close();
+    inOrder.verify(remoteEnvironment).close();
+  }
+
   @Test
   public void cachesEnvironment() throws Exception {
     try (DefaultJobBundleFactory bundleFactory =
