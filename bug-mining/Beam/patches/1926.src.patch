diff --git a/sdks/python/apache_beam/pipeline.py b/sdks/python/apache_beam/pipeline.py
index 51f00a42e95..dff583d0de1 100644
--- a/sdks/python/apache_beam/pipeline.py
+++ b/sdks/python/apache_beam/pipeline.py
@@ -58,6 +58,7 @@ import sys
 import tempfile
 from builtins import object
 from builtins import zip
+from collections import defaultdict
 from typing import TYPE_CHECKING
 from typing import Dict
 from typing import FrozenSet
@@ -221,6 +222,13 @@ class Pipeline(object):
     # then the transform will have to be cloned with a new label.
     self.applied_labels = set()  # type: Set[str]
 
+    # Create a ComponentIdMap for assigning IDs to components. Ensures that any
+    # components that receive an ID during pipeline construction (for example in
+    # ExternalTransform), will receive the same component ID when generating the
+    # full pipeline proto.
+    self.component_id_map = ComponentIdMap()
+
+
   @property  # type: ignore[misc]  # decorated property not supported
   @deprecated(
       since='First stable release',
@@ -795,6 +803,7 @@ class Pipeline(object):
     if context is None:
       context = pipeline_context.PipelineContext(
           use_fake_coders=use_fake_coders,
+          component_id_map=self.component_id_map,
           default_environment=default_environment)
     elif default_environment is not None:
       raise ValueError(
@@ -1324,6 +1333,32 @@ class PTransformOverride(with_metaclass(abc.ABCMeta,
     raise NotImplementedError
 
 
+class ComponentIdMap(object):
+  """A utility for assigning unique component ids to Beam components.
+
+  Component ID assignments are only guaranteed to be unique and consistent
+  within the scope of a ComponentIdMap instance.
+  """
+  def __init__(self, namespace="ref"):
+    self.namespace = namespace
+    self._counters = defaultdict(lambda: 0)  # type: Dict[type, int]
+    self._obj_to_id = {}  # type: Dict[Any, str]
+
+  def get_or_assign(self, obj=None, obj_type=None, label=None):
+    if obj not in self._obj_to_id:
+      self._obj_to_id[obj] = self._unique_ref(obj, obj_type, label)
+
+    return self._obj_to_id[obj]
+
+  def _unique_ref(self, obj=None, obj_type=None, label=None):
+    self._counters[obj_type] += 1
+    return "%s_%s_%s_%d" % (
+        self.namespace,
+        obj_type.__name__,
+        label or type(obj).__name__,
+        self._counters[obj_type])
+
+
 if sys.version_info >= (3, ):
   try_unicode = str
 
diff --git a/sdks/python/apache_beam/runners/pipeline_context.py b/sdks/python/apache_beam/runners/pipeline_context.py
index 1434f54290b..a32e57c7db8 100644
--- a/sdks/python/apache_beam/runners/pipeline_context.py
+++ b/sdks/python/apache_beam/runners/pipeline_context.py
@@ -37,6 +37,7 @@ from apache_beam import coders
 from apache_beam import pipeline
 from apache_beam import pvalue
 from apache_beam.internal import pickler
+from apache_beam.pipeline import ComponentIdMap
 from apache_beam.portability.api import beam_fn_api_pb2
 from apache_beam.portability.api import beam_runner_api_pb2
 from apache_beam.transforms import core
@@ -67,16 +68,6 @@ class _PipelineContextMap(object):
     self._obj_to_id = {}  # type: Dict[Any, str]
     self._id_to_obj = {}  # type: Dict[str, Any]
     self._id_to_proto = dict(proto_map) if proto_map else {}
-    self._counter = 0
-
-  def _unique_ref(self, obj=None, label=None):
-    # type: (Optional[Any], Optional[str]) -> str
-    self._counter += 1
-    return "%s_%s_%s_%d" % (
-        self._namespace,
-        self._obj_type.__name__,
-        label or type(obj).__name__,
-        self._counter)
 
   def populate_map(self, proto_map):
     # type: (Mapping[str, message.Message]) -> None
@@ -86,7 +77,8 @@ class _PipelineContextMap(object):
   def get_id(self, obj, label=None):
     # type: (Any, Optional[str]) -> str
     if obj not in self._obj_to_id:
-      id = self._unique_ref(obj, label)
+      id = self._pipeline_context.component_id_map.get_or_assign(
+          obj, self._obj_type, label)
       self._id_to_obj[id] = obj
       self._obj_to_id[obj] = id
       self._id_to_proto[id] = obj.to_runner_api(self._pipeline_context)
@@ -109,7 +101,10 @@ class _PipelineContextMap(object):
       for id, proto in self._id_to_proto.items():
         if proto == maybe_new_proto:
           return id
-    return self.put_proto(self._unique_ref(label), maybe_new_proto)
+    return self.put_proto(
+        self._pipeline_context.component_id_map.get_or_assign(
+            label, obj_type=self._obj_type),
+        maybe_new_proto)
 
   def get_id_to_proto_map(self):
     # type: () -> Dict[str, message.Message]
@@ -149,6 +144,7 @@ class PipelineContext(object):
 
   def __init__(self,
                proto=None,  # type: Optional[Union[beam_runner_api_pb2.Components, beam_fn_api_pb2.ProcessBundleDescriptor]]
+               component_id_map=None,  # type: Optional[pipeline.ComponentIdMap]
                default_environment=None,  # type: Optional[environments.Environment]
                use_fake_coders=False,
                iterable_state_read=None,  # type: Optional[IterableStateReader]
@@ -163,6 +159,9 @@ class PipelineContext(object):
           windowing_strategies=dict(proto.windowing_strategies.items()),
           environments=dict(proto.environments.items()))
 
+    self.component_id_map = component_id_map or ComponentIdMap(namespace)
+    assert self.component_id_map.namespace == namespace
+
     self.transforms = _PipelineContextMap(
         self,
         pipeline.AppliedPTransform,
diff --git a/sdks/python/apache_beam/runners/pipeline_context_test.py b/sdks/python/apache_beam/runners/pipeline_context_test.py
index 45a9df78db9..119c25695e0 100644
--- a/sdks/python/apache_beam/runners/pipeline_context_test.py
+++ b/sdks/python/apache_beam/runners/pipeline_context_test.py
@@ -53,6 +53,19 @@ class PipelineContextTest(unittest.TestCase):
     self.assertEqual(
         coders.BytesCoder(), context2.coders.get_by_id(bytes_coder_ref))
 
+  def test_common_id_assignment(self):
+    context = pipeline_context.PipelineContext()
+    float_coder_ref = context.coders.get_id(coders.FloatCoder())
+    bytes_coder_ref = context.coders.get_id(coders.BytesCoder())
+    context2 = pipeline_context.PipelineContext(
+        component_id_map=context.component_id_map)
+
+    bytes_coder_ref2 = context2.coders.get_id(coders.BytesCoder())
+    float_coder_ref2 = context2.coders.get_id(coders.FloatCoder())
+
+    self.assertEqual(bytes_coder_ref, bytes_coder_ref2)
+    self.assertEqual(float_coder_ref, float_coder_ref2)
+
 
 if __name__ == '__main__':
   unittest.main()
diff --git a/sdks/python/apache_beam/transforms/external.py b/sdks/python/apache_beam/transforms/external.py
index c5c0d69f3ad..0bcb9f4b63c 100644
--- a/sdks/python/apache_beam/transforms/external.py
+++ b/sdks/python/apache_beam/transforms/external.py
@@ -287,7 +287,8 @@ class ExternalTransform(ptransform.PTransform):
     pipeline = (
         next(iter(self._inputs.values())).pipeline
         if self._inputs else pvalueish.pipeline)
-    context = pipeline_context.PipelineContext()
+    context = pipeline_context.PipelineContext(
+        component_id_map=pipeline.component_id_map)
     transform_proto = beam_runner_api_pb2.PTransform(
         unique_name=pipeline._current_transform().full_label,
         spec=beam_runner_api_pb2.FunctionSpec(
diff --git a/sdks/python/apache_beam/transforms/sql_test.py b/sdks/python/apache_beam/transforms/sql_test.py
index 8c2dae32a31..ea255f3cbbd 100644
--- a/sdks/python/apache_beam/transforms/sql_test.py
+++ b/sdks/python/apache_beam/transforms/sql_test.py
@@ -157,6 +157,21 @@ class SqlTransformTest(unittest.TestCase):
           dialect="zetasql")
       assert_that(out, equal_to([(1, "foo", 3.14)]))
 
+  def test_windowing_before_sql(self):
+    with TestPipeline() as p:
+      out = (
+          p | beam.Create([
+              SimpleRow(5, "foo", 1.),
+              SimpleRow(15, "bar", 2.),
+              SimpleRow(25, "baz", 3.)
+          ])
+          | beam.Map(lambda v: beam.window.TimestampedValue(v, v.id)).
+          with_output_types(SimpleRow)
+          | beam.WindowInto(
+              beam.window.FixedWindows(10)).with_output_types(SimpleRow)
+          | SqlTransform("SELECT COUNT(*) as `count` FROM PCOLLECTION"))
+      assert_that(out, equal_to([(1, ), (1, ), (1, )]))
+
 
 if __name__ == "__main__":
   logging.getLogger().setLevel(logging.INFO)
