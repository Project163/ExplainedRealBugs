diff --git a/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/GroupCombineFunctions.java b/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/GroupCombineFunctions.java
index f79dac2e9c1..77fc77fdb76 100644
--- a/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/GroupCombineFunctions.java
+++ b/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/GroupCombineFunctions.java
@@ -18,6 +18,7 @@
 package org.apache.beam.runners.spark.translation;
 
 import com.google.common.base.Optional;
+import com.google.common.collect.Iterables;
 import javax.annotation.Nullable;
 import org.apache.beam.runners.spark.coders.CoderHelpers;
 import org.apache.beam.runners.spark.util.ByteArray;
@@ -97,10 +98,6 @@ public class GroupCombineFunctions {
     // ---- InputT: I
     JavaRDD<byte[]> inputRDDBytes = rdd.map(CoderHelpers.toByteFunction(wviCoder));
 
-    if (inputRDDBytes.isEmpty()) {
-      return Optional.absent();
-    }
-
     /*Itr<WV<A>>*/
     /*Itr<WV<A>>>*/
     /*Itr<WV<A>>>*/
@@ -129,7 +126,10 @@ public class GroupCombineFunctions {
               return CoderHelpers.toByteArray(merged, iterAccumCoder);
             });
 
-    return Optional.of(CoderHelpers.fromByteArray(accumulatedBytes, iterAccumCoder));
+    final Iterable<WindowedValue<AccumT>> result =
+        CoderHelpers.fromByteArray(accumulatedBytes, iterAccumCoder);
+
+    return Iterables.isEmpty(result) ? Optional.absent() : Optional.of(result);
   }
 
   /**
