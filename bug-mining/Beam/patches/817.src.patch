diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/ListCoder.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/ListCoder.java
index e6311381909..da90d1088bc 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/ListCoder.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/ListCoder.java
@@ -17,6 +17,7 @@
  */
 package org.apache.beam.sdk.coders;
 
+import java.util.ArrayList;
 import java.util.List;
 import org.apache.beam.sdk.values.TypeDescriptor;
 import org.apache.beam.sdk.values.TypeParameter;
@@ -44,6 +45,24 @@ public class ListCoder<T> extends IterableLikeCoder<T, List<T>> {
     super(elemCoder, "List");
   }
 
+  @Override
+  public boolean consistentWithEquals() {
+    return getElemCoder().consistentWithEquals();
+  }
+
+  @Override
+  public Object structuralValue(List<T> values) {
+    if (consistentWithEquals()) {
+      return values;
+    } else {
+      List<Object> ret = new ArrayList<>(values.size());
+      for (T value : values) {
+        ret.add(getElemCoder().structuralValue(value));
+      }
+      return ret;
+    }
+  }
+
   /**
    * List sizes are always known, so ListIterable may be deterministic while the general
    * IterableLikeCoder is not.
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/coders/ListCoderTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/coders/ListCoderTest.java
index 334ff6bac7d..e793e40935e 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/coders/ListCoderTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/coders/ListCoderTest.java
@@ -17,7 +17,9 @@
  */
 package org.apache.beam.sdk.coders;
 
+import static junit.framework.TestCase.assertTrue;
 import static org.hamcrest.Matchers.equalTo;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
 
 import java.util.ArrayList;
@@ -110,6 +112,25 @@ public class ListCoderTest {
     CoderProperties.coderDecodeEncodeEqual(coder, list);
   }
 
+  @Test
+  public void testStructuralValueDecodeEncodeEqual() throws Exception {
+    ListCoder<byte[]> coder = ListCoder.of(ByteArrayCoder.of());
+    List<byte[]> value = Collections.singletonList(new byte[] {1, 2, 3, 4});
+    CoderProperties.structuralValueDecodeEncodeEqual(coder, value);
+  }
+
+  @Test
+  public void testNotConsistentWithEquals() {
+    ListCoder<byte[]> coder = ListCoder.of(ByteArrayCoder.of());
+    assertFalse(coder.consistentWithEquals());
+  }
+
+  @Test
+  public void testConsistentWithEquals() {
+    ListCoder<Integer> coder = ListCoder.of(VarIntCoder.of());
+    assertTrue(coder.consistentWithEquals());
+  }
+
   @Test
   public void testEncodedTypeDescriptor() throws Exception {
     TypeDescriptor<List<Integer>> typeDescriptor = new TypeDescriptor<List<Integer>>() {};
