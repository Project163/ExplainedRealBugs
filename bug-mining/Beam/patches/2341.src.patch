diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/BagUserState.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/BagUserState.java
index 3c96e42a517..172557125d5 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/BagUserState.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/BagUserState.java
@@ -26,7 +26,6 @@ import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateAppendRequest;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateClearRequest;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateRequest;
 import org.apache.beam.sdk.coders.Coder;
-import org.apache.beam.sdk.fn.stream.DataStreams;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
 
@@ -77,11 +76,7 @@ public class BagUserState<T> {
     request = requestBuilder.build();
 
     this.oldValues =
-        new LazyCachingIteratorToIterable<>(
-            new DataStreams.DataStreamDecoder(
-                valueCoder,
-                DataStreams.inbound(
-                    StateFetchingIterators.readAllStartingFrom(beamFnStateClient, request))));
+        StateFetchingIterators.readAllAndDecodeStartingFrom(beamFnStateClient, request, valueCoder);
     this.newValues = new ArrayList<>();
   }
 
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/IterableSideInput.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/IterableSideInput.java
index c4ee0b47973..3f17ef1240f 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/IterableSideInput.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/IterableSideInput.java
@@ -19,7 +19,6 @@ package org.apache.beam.fn.harness.state;
 
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateRequest;
 import org.apache.beam.sdk.coders.Coder;
-import org.apache.beam.sdk.fn.stream.DataStreams;
 import org.apache.beam.sdk.transforms.Materializations.IterableView;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
 
@@ -66,11 +65,7 @@ public class IterableSideInput<T> implements IterableView<T> {
         .setSideInputId(sideInputId)
         .setWindow(encodedWindow);
 
-    return new LazyCachingIteratorToIterable<>(
-        new DataStreams.DataStreamDecoder(
-            valueCoder,
-            DataStreams.inbound(
-                StateFetchingIterators.readAllStartingFrom(
-                    beamFnStateClient, requestBuilder.build()))));
+    return StateFetchingIterators.readAllAndDecodeStartingFrom(
+        beamFnStateClient, requestBuilder.build(), valueCoder);
   }
 }
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/MultimapSideInput.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/MultimapSideInput.java
index 0f5bd4f584a..2ed68248ece 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/MultimapSideInput.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/MultimapSideInput.java
@@ -20,7 +20,6 @@ package org.apache.beam.fn.harness.state;
 import java.io.IOException;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateRequest;
 import org.apache.beam.sdk.coders.Coder;
-import org.apache.beam.sdk.fn.stream.DataStreams;
 import org.apache.beam.sdk.transforms.Materializations.MultimapView;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
 
@@ -71,12 +70,8 @@ public class MultimapSideInput<K, V> implements MultimapView<K, V> {
         .setSideInputId(sideInputId)
         .setWindow(encodedWindow);
 
-    return new LazyCachingIteratorToIterable<>(
-        new DataStreams.DataStreamDecoder(
-            keyCoder,
-            DataStreams.inbound(
-                StateFetchingIterators.readAllStartingFrom(
-                    beamFnStateClient, requestBuilder.build()))));
+    return StateFetchingIterators.readAllAndDecodeStartingFrom(
+        beamFnStateClient, requestBuilder.build(), keyCoder);
   }
 
   @Override
@@ -98,11 +93,7 @@ public class MultimapSideInput<K, V> implements MultimapView<K, V> {
         .setWindow(encodedWindow)
         .setKey(output.toByteString());
 
-    return new LazyCachingIteratorToIterable<>(
-        new DataStreams.DataStreamDecoder(
-            valueCoder,
-            DataStreams.inbound(
-                StateFetchingIterators.readAllStartingFrom(
-                    beamFnStateClient, requestBuilder.build()))));
+    return StateFetchingIterators.readAllAndDecodeStartingFrom(
+        beamFnStateClient, requestBuilder.build(), valueCoder);
   }
 }
diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/StateFetchingIterators.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/StateFetchingIterators.java
index dda5cd6b249..2afaf6c2fb3 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/StateFetchingIterators.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/state/StateFetchingIterators.java
@@ -17,15 +17,20 @@
  */
 package org.apache.beam.fn.harness.state;
 
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
+import java.util.function.Supplier;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateGetRequest;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateRequest;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateResponse;
+import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.fn.stream.DataStreams;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
 
 /**
  * Adapters which convert a a logical series of chunks using continuation tokens over the Beam Fn
@@ -54,6 +59,117 @@ public class StateFetchingIterators {
     return new LazyBlockingStateFetchingIterator(beamFnStateClient, stateRequestForFirstChunk);
   }
 
+  /**
+   * This adapter handles using the continuation token to provide iteration over all the elements
+   * returned by the Beam Fn State API using the supplied state client, state request for the first
+   * chunk of the state stream, and a value decoder.
+   *
+   * <p>The first page, and only the first page, of the state request results is cached for
+   * efficient re-iteration for small state requests while still allowing unboundedly large state
+   * requests without unboundedly large memory consumption.
+   *
+   * @param beamFnStateClient A client for handling state requests.
+   * @param stateRequestForFirstChunk A fully populated state request for the first (and possibly
+   *     only) chunk of a state stream. This state request will be populated with a continuation
+   *     token to request further chunks of the stream if required.
+   * @param valueCoder A coder for decoding the state stream.
+   */
+  public static <T> Iterable<T> readAllAndDecodeStartingFrom(
+      BeamFnStateClient beamFnStateClient,
+      StateRequest stateRequestForFirstChunk,
+      Coder<T> valueCoder) {
+    FirstPageAndRemainder firstPageAndRemainder =
+        new FirstPageAndRemainder(beamFnStateClient, stateRequestForFirstChunk);
+    return Iterables.concat(
+        new LazyCachingIteratorToIterable<T>(
+            new DataStreams.DataStreamDecoder<>(
+                valueCoder,
+                DataStreams.inbound(
+                    new LazySingletonIterator<>(firstPageAndRemainder::firstPage)))),
+        () ->
+            new DataStreams.DataStreamDecoder<>(
+                valueCoder, DataStreams.inbound(firstPageAndRemainder.remainder())));
+  }
+
+  /** A iterable that contains a single element, provided by a Supplier which is invoked lazily. */
+  static class LazySingletonIterator<T> implements Iterator<T> {
+
+    private final Supplier<T> supplier;
+    private boolean hasNext;
+
+    private LazySingletonIterator(Supplier<T> supplier) {
+      this.supplier = supplier;
+      hasNext = true;
+    }
+
+    @Override
+    public boolean hasNext() {
+      return hasNext;
+    }
+
+    @Override
+    public T next() {
+      hasNext = false;
+      return supplier.get();
+    }
+  }
+
+  /**
+   * An helper class that (lazily) gives the first page of a paginated state request separately from
+   * all the remaining pages.
+   */
+  static class FirstPageAndRemainder {
+    private final BeamFnStateClient beamFnStateClient;
+    private final StateRequest stateRequestForFirstChunk;
+    private ByteString firstPage = null;
+    private ByteString continuationToken;
+
+    private FirstPageAndRemainder(
+        BeamFnStateClient beamFnStateClient, StateRequest stateRequestForFirstChunk) {
+      this.beamFnStateClient = beamFnStateClient;
+      this.stateRequestForFirstChunk = stateRequestForFirstChunk;
+    }
+
+    public ByteString firstPage() {
+      if (firstPage == null) {
+        CompletableFuture<StateResponse> stateResponseFuture = new CompletableFuture<>();
+        beamFnStateClient.handle(
+            stateRequestForFirstChunk.toBuilder().setGet(stateRequestForFirstChunk.getGet()),
+            stateResponseFuture);
+        StateResponse stateResponse;
+        try {
+          stateResponse = stateResponseFuture.get();
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+          throw new IllegalStateException(e);
+        } catch (ExecutionException e) {
+          if (e.getCause() == null) {
+            throw new IllegalStateException(e);
+          }
+          Throwables.throwIfUnchecked(e.getCause());
+          throw new IllegalStateException(e.getCause());
+        }
+        continuationToken = stateResponse.getGet().getContinuationToken();
+        firstPage = stateResponse.getGet().getData();
+      }
+      return firstPage;
+    }
+
+    public Iterator<ByteString> remainder() {
+      firstPage();
+      if (ByteString.EMPTY.equals(continuationToken)) {
+        return Collections.emptyIterator();
+      } else {
+        return new LazyBlockingStateFetchingIterator(
+            beamFnStateClient,
+            stateRequestForFirstChunk
+                .toBuilder()
+                .setGet(StateGetRequest.newBuilder().setContinuationToken(continuationToken))
+                .build());
+      }
+    }
+  }
+
   /**
    * An {@link Iterator} which fetches {@link ByteString} chunks using the State API.
    *
@@ -79,7 +195,7 @@ public class StateFetchingIterators {
       this.currentState = State.READ_REQUIRED;
       this.beamFnStateClient = beamFnStateClient;
       this.stateRequestForFirstChunk = stateRequestForFirstChunk;
-      this.continuationToken = ByteString.EMPTY;
+      this.continuationToken = stateRequestForFirstChunk.getGet().getContinuationToken();
     }
 
     @Override
diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java
index c698d6b1541..c4803bb288d 100644
--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java
+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java
@@ -436,7 +436,7 @@ public class FnApiDoFnRunnerTest implements Serializable {
               iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),
               encode("iterableValue1", "iterableValue2", "iterableValue3"));
 
-      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);
+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData, 1000);
 
       List<WindowedValue<String>> mainOutputValues = new ArrayList<>();
       List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();
@@ -728,7 +728,7 @@ public class FnApiDoFnRunnerTest implements Serializable {
               iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),
               encode("iterableValue1B", "iterableValue2B", "iterableValue3B"));
 
-      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);
+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData, 1000);
 
       List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();
       MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();
diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/state/FakeBeamFnStateClient.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/state/FakeBeamFnStateClient.java
index e6346523ea9..898ed8d0680 100644
--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/state/FakeBeamFnStateClient.java
+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/state/FakeBeamFnStateClient.java
@@ -20,7 +20,9 @@ package org.apache.beam.fn.harness.state;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
 
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
@@ -33,18 +35,41 @@ import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateRequest;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateRequest.RequestCase;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateResponse;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Maps;
 
 /** A fake implementation of a {@link BeamFnStateClient} to aid with testing. */
 public class FakeBeamFnStateClient implements BeamFnStateClient {
-  private final Map<StateKey, ByteString> data;
+  private final Map<StateKey, List<ByteString>> data;
   private int currentId;
 
   public FakeBeamFnStateClient(Map<StateKey, ByteString> initialData) {
-    this.data = new ConcurrentHashMap<>(initialData);
+    this(initialData, 6);
+  }
+
+  public FakeBeamFnStateClient(Map<StateKey, ByteString> initialData, int chunkSize) {
+    this.data =
+        new ConcurrentHashMap<>(
+            Maps.transformValues(
+                initialData,
+                (ByteString all) -> {
+                  List<ByteString> chunks = new ArrayList<>();
+                  for (int i = 0; i < Math.max(1, all.size()); i += chunkSize) {
+                    chunks.add(all.substring(i, Math.min(all.size(), i + chunkSize)));
+                  }
+                  return chunks;
+                }));
   }
 
   public Map<StateKey, ByteString> getData() {
-    return Collections.unmodifiableMap(data);
+    return Maps.transformValues(
+        data,
+        bs -> {
+          ByteString all = ByteString.EMPTY;
+          for (ByteString b : bs) {
+            all = all.concat(b);
+          }
+          return all;
+        });
   }
 
   @Override
@@ -67,16 +92,16 @@ public class FakeBeamFnStateClient implements BeamFnStateClient {
 
     switch (request.getRequestCase()) {
       case GET:
-        // Chunk gets into 5 byte return blocks
-        ByteString byteString = data.getOrDefault(request.getStateKey(), ByteString.EMPTY);
+        // Chunk gets into 6 byte return blocks
+        List<ByteString> byteStrings =
+            data.getOrDefault(request.getStateKey(), Collections.singletonList(ByteString.EMPTY));
         int block = 0;
         if (request.getGet().getContinuationToken().size() > 0) {
           block = Integer.parseInt(request.getGet().getContinuationToken().toStringUtf8());
         }
-        ByteString returnBlock =
-            byteString.substring(block * 5, Math.min(byteString.size(), (block + 1) * 5));
+        ByteString returnBlock = byteStrings.get(block);
         ByteString continuationToken = ByteString.EMPTY;
-        if (byteString.size() > (block + 1) * 5) {
+        if (byteStrings.size() > block + 1) {
           continuationToken = ByteString.copyFromUtf8(Integer.toString(block + 1));
         }
         response =
@@ -93,8 +118,18 @@ public class FakeBeamFnStateClient implements BeamFnStateClient {
         break;
 
       case APPEND:
-        ByteString previousValue = data.getOrDefault(request.getStateKey(), ByteString.EMPTY);
-        data.put(request.getStateKey(), previousValue.concat(request.getAppend().getData()));
+        List<ByteString> previousValue =
+            data.getOrDefault(request.getStateKey(), Collections.singletonList(ByteString.EMPTY));
+        List<ByteString> newValue = new ArrayList<>();
+        newValue.addAll(previousValue);
+        ByteString newData = request.getAppend().getData();
+        if (newData.size() % 2 == 0) {
+          newValue.remove(newValue.size() - 1);
+          newValue.add(previousValue.get(previousValue.size() - 1).concat(newData));
+        } else {
+          newValue.add(newData);
+        }
+        data.put(request.getStateKey(), newValue);
         response = StateResponse.newBuilder().setAppend(StateAppendResponse.getDefaultInstance());
         break;
 
diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/state/StateFetchingIteratorsTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/state/StateFetchingIteratorsTest.java
index d184ca2c4da..d2561c2fac3 100644
--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/state/StateFetchingIteratorsTest.java
+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/state/StateFetchingIteratorsTest.java
@@ -18,13 +18,23 @@
 package org.apache.beam.fn.harness.state;
 
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
 
+import java.util.Arrays;
 import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Collectors;
 import org.apache.beam.fn.harness.state.StateFetchingIterators.LazyBlockingStateFetchingIterator;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateGetResponse;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateRequest;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateResponse;
+import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.CoderException;
+import org.apache.beam.sdk.coders.VarIntCoder;
+import org.apache.beam.sdk.util.CoderUtils;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterators;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -67,34 +77,107 @@ public class StateFetchingIteratorsTest {
           ByteString.EMPTY);
     }
 
+    private BeamFnStateClient fakeStateClient(AtomicInteger callCount, ByteString... expected) {
+      return (requestBuilder, response) -> {
+        callCount.incrementAndGet();
+        if (expected.length == 0) {
+          response.complete(
+              StateResponse.newBuilder()
+                  .setId(requestBuilder.getId())
+                  .setGet(StateGetResponse.newBuilder())
+                  .build());
+          return;
+        }
+
+        ByteString continuationToken = requestBuilder.getGet().getContinuationToken();
+
+        int requestedPosition = 0; // Default position is 0
+        if (!ByteString.EMPTY.equals(continuationToken)) {
+          requestedPosition = Integer.parseInt(continuationToken.toStringUtf8());
+        }
+
+        // Compute the new continuation token
+        ByteString newContinuationToken = ByteString.EMPTY;
+        if (requestedPosition != expected.length - 1) {
+          newContinuationToken = ByteString.copyFromUtf8(Integer.toString(requestedPosition + 1));
+        }
+        response.complete(
+            StateResponse.newBuilder()
+                .setId(requestBuilder.getId())
+                .setGet(
+                    StateGetResponse.newBuilder()
+                        .setData(expected[requestedPosition])
+                        .setContinuationToken(newContinuationToken))
+                .build());
+      };
+    }
+
     private void testFetch(ByteString... expected) {
-      BeamFnStateClient fakeStateClient =
-          (requestBuilder, response) -> {
-            ByteString continuationToken = requestBuilder.getGet().getContinuationToken();
-
-            int requestedPosition = 0; // Default position is 0
-            if (!ByteString.EMPTY.equals(continuationToken)) {
-              requestedPosition = Integer.parseInt(continuationToken.toStringUtf8());
-            }
-
-            // Compute the new continuation token
-            ByteString newContinuationToken = ByteString.EMPTY;
-            if (requestedPosition != expected.length - 1) {
-              newContinuationToken =
-                  ByteString.copyFromUtf8(Integer.toString(requestedPosition + 1));
-            }
-            response.complete(
-                StateResponse.newBuilder()
-                    .setId(requestBuilder.getId())
-                    .setGet(
-                        StateGetResponse.newBuilder()
-                            .setData(expected[requestedPosition])
-                            .setContinuationToken(newContinuationToken))
-                    .build());
-          };
+      AtomicInteger callCount = new AtomicInteger();
+      BeamFnStateClient fakeStateClient = fakeStateClient(callCount, expected);
       Iterator<ByteString> byteStrings =
           new LazyBlockingStateFetchingIterator(fakeStateClient, StateRequest.getDefaultInstance());
+      assertEquals(0, callCount.get()); // Ensure it's fully lazy.
       assertArrayEquals(expected, Iterators.toArray(byteStrings, Object.class));
     }
+
+    @Test
+    public void testEmptyValues() throws Exception {
+      testFetchValues(VarIntCoder.of());
+    }
+
+    @Test
+    public void testOneValue() throws Exception {
+      testFetchValues(VarIntCoder.of(), 4);
+    }
+
+    @Test
+    public void testManyValues() throws Exception {
+      testFetchValues(VarIntCoder.of(), 11, 37, 389, 5077);
+    }
+
+    private <T> void testFetchValues(Coder<T> coder, T... expected) {
+      List<ByteString> byteStrings =
+          Arrays.stream(expected)
+              .map(
+                  value -> {
+                    try {
+                      return CoderUtils.encodeToByteArray(coder, value);
+                    } catch (CoderException exn) {
+                      throw new RuntimeException(exn);
+                    }
+                  })
+              .map(ByteString::copyFrom)
+              .collect(Collectors.toList());
+
+      AtomicInteger callCount = new AtomicInteger();
+      BeamFnStateClient fakeStateClient =
+          fakeStateClient(callCount, Iterables.toArray(byteStrings, ByteString.class));
+      Iterable<T> values =
+          StateFetchingIterators.readAllAndDecodeStartingFrom(
+              fakeStateClient, StateRequest.getDefaultInstance(), coder);
+
+      // Ensure it's fully lazy.
+      assertEquals(0, callCount.get());
+      Iterator<T> valuesIter = values.iterator();
+      assertEquals(0, callCount.get());
+
+      // No more is read than necissary.
+      if (valuesIter.hasNext()) {
+        valuesIter.next();
+      }
+      assertEquals(1, callCount.get());
+
+      // The first page is cached.
+      Iterator<T> valuesIter2 = values.iterator();
+      assertEquals(1, callCount.get());
+      if (valuesIter2.hasNext()) {
+        valuesIter2.next();
+      }
+      assertEquals(1, callCount.get());
+
+      // The contents agree.
+      assertArrayEquals(expected, Iterables.toArray(values, Object.class));
+    }
   }
 }
