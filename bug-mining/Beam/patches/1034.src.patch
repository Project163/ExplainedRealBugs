diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
index 32d0ad4b686..b1073f41e8c 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
@@ -22,6 +22,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.stream.Stream;
 import javax.annotation.Nonnull;
 import org.apache.beam.runners.core.StateInternals;
 import org.apache.beam.runners.core.StateNamespace;
@@ -58,8 +59,11 @@ import org.apache.flink.api.common.state.ListStateDescriptor;
 import org.apache.flink.api.common.state.MapStateDescriptor;
 import org.apache.flink.api.common.state.ValueStateDescriptor;
 import org.apache.flink.api.common.typeutils.base.BooleanSerializer;
+import org.apache.flink.api.common.typeutils.base.LongSerializer;
 import org.apache.flink.api.common.typeutils.base.StringSerializer;
 import org.apache.flink.runtime.state.KeyedStateBackend;
+import org.apache.flink.runtime.state.VoidNamespace;
+import org.apache.flink.runtime.state.VoidNamespaceSerializer;
 import org.joda.time.Instant;
 
 /**
@@ -73,20 +77,25 @@ public class FlinkStateInternals<K> implements StateInternals {
   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;
   private Coder<K> keyCoder;
 
-  // on recovery, these will no be properly set because we don't
-  // know which watermark hold states there are in the Flink State Backend
-  private final Map<String, Instant> watermarkHolds = new HashMap<>();
+  // Combined watermark holds for all keys of this partition
+  private final Map<String, Long> watermarkHolds = new HashMap<>();
+  // State to persist combined watermark holds for all keys of this partition
+  private final MapStateDescriptor<String, Long> watermarkHoldState =
+      new MapStateDescriptor<>(
+          "watermark-holds", StringSerializer.INSTANCE, LongSerializer.INSTANCE);
 
-  public FlinkStateInternals(KeyedStateBackend<ByteBuffer> flinkStateBackend, Coder<K> keyCoder) {
+  public FlinkStateInternals(KeyedStateBackend<ByteBuffer> flinkStateBackend, Coder<K> keyCoder)
+      throws Exception {
     this.flinkStateBackend = flinkStateBackend;
     this.keyCoder = keyCoder;
+    restoreWatermarkHoldsView();
   }
 
   /** Returns the minimum over all watermark holds. */
   public Instant watermarkHold() {
     long min = Long.MAX_VALUE;
-    for (Instant hold : watermarkHolds.values()) {
-      min = Math.min(min, hold.getMillis());
+    for (Long hold : watermarkHolds.values()) {
+      min = Math.min(min, hold);
     }
     return new Instant(min);
   }
@@ -111,7 +120,8 @@ public class FlinkStateInternals<K> implements StateInternals {
         .getSpec()
         .bind(
             address.getId(),
-            new FlinkStateBinder(namespace, context, flinkStateBackend, watermarkHolds));
+            new FlinkStateBinder(
+                namespace, context, flinkStateBackend, watermarkHolds, watermarkHoldState));
   }
 
   private static class FlinkStateBinder implements StateBinder {
@@ -119,17 +129,20 @@ public class FlinkStateInternals<K> implements StateInternals {
     private final StateNamespace namespace;
     private final StateContext<?> stateContext;
     private final KeyedStateBackend<ByteBuffer> flinkStateBackend;
-    private final Map<String, Instant> watermarkHolds;
+    private final Map<String, Long> watermarkHolds;
+    private final MapStateDescriptor<String, Long> watermarkHoldState;
 
     private FlinkStateBinder(
         StateNamespace namespace,
         StateContext<?> stateContext,
         KeyedStateBackend<ByteBuffer> flinkStateBackend,
-        Map<String, Instant> watermarkHolds) {
+        Map<String, Long> watermarkHolds,
+        MapStateDescriptor<String, Long> watermarkHoldState) {
       this.namespace = namespace;
       this.stateContext = stateContext;
       this.flinkStateBackend = flinkStateBackend;
       this.watermarkHolds = watermarkHolds;
+      this.watermarkHoldState = watermarkHoldState;
     }
 
     @Override
@@ -186,7 +199,7 @@ public class FlinkStateInternals<K> implements StateInternals {
     public WatermarkHoldState bindWatermark(
         String id, StateSpec<WatermarkHoldState> spec, TimestampCombiner timestampCombiner) {
       return new FlinkWatermarkHoldState<>(
-          flinkStateBackend, watermarkHolds, id, namespace, timestampCombiner);
+          flinkStateBackend, watermarkHolds, watermarkHoldState, id, namespace, timestampCombiner);
     }
   }
 
@@ -738,12 +751,14 @@ public class FlinkStateInternals<K> implements StateInternals {
     private final TimestampCombiner timestampCombiner;
     private final StateNamespace namespace;
     private final KeyedStateBackend<ByteBuffer> flinkStateBackend;
-    private final Map<String, Instant> watermarkHolds;
+    private final Map<String, Long> watermarkHolds;
+    private org.apache.flink.api.common.state.MapState<String, Long> watermarkHoldsPartitionState;
     private final ValueStateDescriptor<Instant> flinkStateDescriptor;
 
     public FlinkWatermarkHoldState(
         KeyedStateBackend<ByteBuffer> flinkStateBackend,
-        Map<String, Instant> watermarkHolds,
+        Map<String, Long> watermarkHolds,
+        MapStateDescriptor<String, Long> watermarkHoldState,
         String stateId,
         StateNamespace namespace,
         TimestampCombiner timestampCombiner) {
@@ -752,8 +767,13 @@ public class FlinkStateInternals<K> implements StateInternals {
       this.namespace = namespace;
       this.flinkStateBackend = flinkStateBackend;
       this.watermarkHolds = watermarkHolds;
-
-      flinkStateDescriptor =
+      try {
+        this.watermarkHoldsPartitionState = flinkStateBackend.getPartitionedState(
+            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, watermarkHoldState);
+      } catch (Exception e) {
+        throw new RuntimeException("Could not access state for watermark partition view");
+      }
+      this.flinkStateDescriptor =
           new ValueStateDescriptor<>(stateId, new CoderTypeSerializer<>(InstantCoder.of()));
     }
 
@@ -800,11 +820,13 @@ public class FlinkStateInternals<K> implements StateInternals {
         Instant current = state.value();
         if (current == null) {
           state.update(value);
-          watermarkHolds.put(namespace.stringKey(), value);
+          watermarkHolds.put(namespace.stringKey(), value.getMillis());
+          watermarkHoldsPartitionState.put(namespace.stringKey(), value.getMillis());
         } else {
           Instant combined = timestampCombiner.combine(current, value);
           state.update(combined);
-          watermarkHolds.put(namespace.stringKey(), combined);
+          watermarkHolds.put(namespace.stringKey(), combined.getMillis());
+          watermarkHoldsPartitionState.put(namespace.stringKey(), combined.getMillis());
         }
       } catch (Exception e) {
         throw new RuntimeException("Error updating state.", e);
@@ -814,6 +836,7 @@ public class FlinkStateInternals<K> implements StateInternals {
     @Override
     public Instant read() {
       try {
+        watermarkHoldsPartitionState.get(namespace.stringKey());
         org.apache.flink.api.common.state.ValueState<Instant> state =
             flinkStateBackend.getPartitionedState(
                 namespace.stringKey(), StringSerializer.INSTANCE, flinkStateDescriptor);
@@ -827,6 +850,7 @@ public class FlinkStateInternals<K> implements StateInternals {
     public void clear() {
       watermarkHolds.remove(namespace.stringKey());
       try {
+        watermarkHoldsPartitionState.remove(namespace.stringKey());
         org.apache.flink.api.common.state.ValueState<Instant> state =
             flinkStateBackend.getPartitionedState(
                 namespace.stringKey(), StringSerializer.INSTANCE, flinkStateDescriptor);
@@ -1202,4 +1226,19 @@ public class FlinkStateInternals<K> implements StateInternals {
       return result;
     }
   }
+
+  /** Restores a view of the watermark holds of all keys of this partiton. */
+  private void restoreWatermarkHoldsView() throws Exception {
+    org.apache.flink.api.common.state.MapState<String, Long> mapState =
+        flinkStateBackend.getPartitionedState(
+            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, watermarkHoldState);
+    try (Stream<ByteBuffer> keys =
+        flinkStateBackend.getKeys(watermarkHoldState.getName(), VoidNamespace.INSTANCE)) {
+      Iterator<ByteBuffer> iterator = keys.iterator();
+      while (iterator.hasNext()) {
+        flinkStateBackend.setCurrentKey(iterator.next());
+        mapState.entries().forEach(entry -> watermarkHolds.put(entry.getKey(), entry.getValue()));
+      }
+    }
+  }
 }
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/streaming/FlinkStateInternalsTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/streaming/FlinkStateInternalsTest.java
index 6bbf81d398d..edc44f6543d 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/streaming/FlinkStateInternalsTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/streaming/FlinkStateInternalsTest.java
@@ -17,11 +17,22 @@
  */
 package org.apache.beam.runners.flink.streaming;
 
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
 import java.nio.ByteBuffer;
+import java.util.UUID;
 import org.apache.beam.runners.core.StateInternals;
 import org.apache.beam.runners.core.StateInternalsTest;
+import org.apache.beam.runners.core.StateNamespaces;
+import org.apache.beam.runners.core.StateTag;
+import org.apache.beam.runners.core.StateTags;
 import org.apache.beam.runners.flink.translation.wrappers.streaming.state.FlinkStateInternals;
+import org.apache.beam.sdk.coders.CoderException;
 import org.apache.beam.sdk.coders.StringUtf8Coder;
+import org.apache.beam.sdk.state.WatermarkHoldState;
+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;
+import org.apache.beam.sdk.transforms.windowing.TimestampCombiner;
 import org.apache.beam.sdk.util.CoderUtils;
 import org.apache.flink.api.common.ExecutionConfig;
 import org.apache.flink.api.common.JobID;
@@ -31,7 +42,10 @@ import org.apache.flink.runtime.operators.testutils.DummyEnvironment;
 import org.apache.flink.runtime.query.KvStateRegistry;
 import org.apache.flink.runtime.state.AbstractKeyedStateBackend;
 import org.apache.flink.runtime.state.KeyGroupRange;
+import org.apache.flink.runtime.state.KeyedStateBackend;
 import org.apache.flink.runtime.state.memory.MemoryStateBackend;
+import org.joda.time.Instant;
+import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
@@ -41,24 +55,90 @@ public class FlinkStateInternalsTest extends StateInternalsTest {
 
   @Override
   protected StateInternals createStateInternals() {
-    MemoryStateBackend backend = new MemoryStateBackend();
     try {
-      AbstractKeyedStateBackend<ByteBuffer> keyedStateBackend =
-          backend.createKeyedStateBackend(
-              new DummyEnvironment("test", 1, 0),
-              new JobID(),
-              "test_op",
-              new GenericTypeInfo<>(ByteBuffer.class).createSerializer(new ExecutionConfig()),
-              1,
-              new KeyGroupRange(0, 0),
-              new KvStateRegistry().createTaskRegistry(new JobID(), new JobVertexID()));
-
-      keyedStateBackend.setCurrentKey(
-          ByteBuffer.wrap(CoderUtils.encodeToByteArray(StringUtf8Coder.of(), "Hello")));
-
+      KeyedStateBackend<ByteBuffer> keyedStateBackend = createStateBackend();
       return new FlinkStateInternals<>(keyedStateBackend, StringUtf8Coder.of());
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
   }
+
+  @Test
+  public void testWatermarkHoldsPersistence() throws Exception {
+    KeyedStateBackend<ByteBuffer> keyedStateBackend = createStateBackend();
+    FlinkStateInternals stateInternals =
+        new FlinkStateInternals<>(keyedStateBackend, StringUtf8Coder.of());
+
+    StateTag<WatermarkHoldState> stateTag =
+        StateTags.watermarkStateInternal("hold", TimestampCombiner.EARLIEST);
+    WatermarkHoldState globalWindow = stateInternals.state(StateNamespaces.global(), stateTag);
+    WatermarkHoldState fixedWindow =
+        stateInternals.state(
+            StateNamespaces.window(
+                IntervalWindow.getCoder(), new IntervalWindow(new Instant(0), new Instant(10))),
+            stateTag);
+
+    Instant noHold = new Instant(Long.MAX_VALUE);
+    assertThat(stateInternals.watermarkHold(), is(noHold));
+
+    Instant high = new Instant(10);
+    globalWindow.add(high);
+    assertThat(stateInternals.watermarkHold(), is(high));
+
+    Instant middle = new Instant(5);
+    fixedWindow.add(middle);
+    assertThat(stateInternals.watermarkHold(), is(middle));
+
+    Instant low = new Instant(1);
+    globalWindow.add(low);
+    assertThat(stateInternals.watermarkHold(), is(low));
+
+    // Try to overwrite with later hold (should not succeed)
+    globalWindow.add(high);
+    assertThat(stateInternals.watermarkHold(), is(low));
+    fixedWindow.add(high);
+    assertThat(stateInternals.watermarkHold(), is(low));
+
+    changeKey(keyedStateBackend);
+    // Discard watermark view and recover it
+    stateInternals = new FlinkStateInternals<>(keyedStateBackend, StringUtf8Coder.of());
+    globalWindow = stateInternals.state(StateNamespaces.global(), stateTag);
+    fixedWindow =
+        stateInternals.state(
+            StateNamespaces.window(
+                IntervalWindow.getCoder(), new IntervalWindow(new Instant(0), new Instant(10))),
+            stateTag);
+
+    assertThat(stateInternals.watermarkHold(), is(low));
+
+    fixedWindow.clear();
+    assertThat(stateInternals.watermarkHold(), is(low));
+
+    globalWindow.clear();
+    assertThat(stateInternals.watermarkHold(), is(noHold));
+  }
+
+  private KeyedStateBackend<ByteBuffer> createStateBackend() throws Exception {
+    MemoryStateBackend backend = new MemoryStateBackend();
+
+    AbstractKeyedStateBackend<ByteBuffer> keyedStateBackend =
+        backend.createKeyedStateBackend(
+            new DummyEnvironment("test", 1, 0),
+            new JobID(),
+            "test_op",
+            new GenericTypeInfo<>(ByteBuffer.class).createSerializer(new ExecutionConfig()),
+            2,
+            new KeyGroupRange(0, 1),
+            new KvStateRegistry().createTaskRegistry(new JobID(), new JobVertexID()));
+
+    changeKey(keyedStateBackend);
+
+    return keyedStateBackend;
+  }
+
+  private void changeKey(KeyedStateBackend<ByteBuffer> keyedStateBackend) throws CoderException {
+    keyedStateBackend.setCurrentKey(
+        ByteBuffer.wrap(
+            CoderUtils.encodeToByteArray(StringUtf8Coder.of(), UUID.randomUUID().toString())));
+  }
 }
