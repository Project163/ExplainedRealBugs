diff --git a/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsCheckpointMark.java b/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsCheckpointMark.java
index 8d28b59b735..a7746a158b4 100644
--- a/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsCheckpointMark.java
+++ b/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsCheckpointMark.java
@@ -17,34 +17,69 @@
  */
 package org.apache.beam.sdk.io.aws.sqs;
 
-import com.amazonaws.services.sqs.model.Message;
+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;
+
+import java.io.IOException;
 import java.io.Serializable;
-import java.util.Collection;
 import java.util.List;
-import java.util.Optional;
 import org.apache.beam.sdk.io.UnboundedSource;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Objects;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+@SuppressWarnings({
+  "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
+})
 class SqsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {
 
-  private final List<Message> messagesToDelete;
-  private final transient Optional<SqsUnboundedReader> reader;
+  /**
+   * If the checkpoint is for persisting: the reader who's snapshotted state we are persisting. If
+   * the checkpoint is for restoring: {@literal null}. Not persisted in durable checkpoint. CAUTION:
+   * Between a checkpoint being taken and {@link #finalizeCheckpoint()} being called the 'true'
+   * active reader may have changed.
+   */
+  private transient @Nullable SqsUnboundedReader reader;
 
-  public SqsCheckpointMark(SqsUnboundedReader reader, Collection<Message> messagesToDelete) {
-    this.reader = Optional.of(reader);
-    this.messagesToDelete = ImmutableList.copyOf(messagesToDelete);
-    ;
-  }
+  /**
+   * If the checkpoint is for persisting: The ids of messages which have been passed downstream
+   * since the last checkpoint. If the checkpoint is for restoring: {@literal null}. Not persisted
+   * in durable checkpoint.
+   */
+  private @Nullable List<String> safeToDeleteIds;
 
-  @Override
-  public void finalizeCheckpoint() {
-    reader.ifPresent(r -> r.delete(messagesToDelete));
+  /**
+   * If the checkpoint is for persisting: The receipt handles of messages which have been received
+   * from SQS but not yet passed downstream at the time of the snapshot. If the checkpoint is for
+   * restoring: Same, but recovered from durable storage.
+   */
+  @VisibleForTesting final List<String> notYetReadReceipts;
+
+  public SqsCheckpointMark(
+      SqsUnboundedReader reader, List<String> messagesToDelete, List<String> notYetReadReceipts) {
+    this.reader = reader;
+    this.safeToDeleteIds = ImmutableList.copyOf(messagesToDelete);
+    this.notYetReadReceipts = ImmutableList.copyOf(notYetReadReceipts);
   }
 
-  List<Message> getMessagesToDelete() {
-    return messagesToDelete;
+  @Override
+  public void finalizeCheckpoint() throws IOException {
+    checkState(reader != null && safeToDeleteIds != null, "Cannot finalize a restored checkpoint");
+    // Even if the 'true' active reader has changed since the checkpoint was taken we are
+    // fine:
+    // - The underlying SQS topic will not have changed, so the following deletes will still
+    // go to the right place.
+    // - We'll delete the ACK ids from the readers in-flight state, but that only affect
+    // flow control and stats, neither of which are relevant anymore.
+    try {
+      reader.delete(safeToDeleteIds);
+    } finally {
+      int remainingInFlight = reader.numInFlightCheckpoints.decrementAndGet();
+      checkState(remainingInFlight >= 0, "Miscounted in-flight checkpoints");
+      reader.maybeCloseClient();
+      reader = null;
+      safeToDeleteIds = null;
+    }
   }
 
   @Override
@@ -56,11 +91,11 @@ class SqsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable
       return false;
     }
     SqsCheckpointMark that = (SqsCheckpointMark) o;
-    return Objects.equal(messagesToDelete, that.messagesToDelete);
+    return Objects.equal(safeToDeleteIds, that.safeToDeleteIds);
   }
 
   @Override
   public int hashCode() {
-    return Objects.hashCode(messagesToDelete);
+    return Objects.hashCode(safeToDeleteIds);
   }
 }
diff --git a/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsUnboundedReader.java b/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsUnboundedReader.java
index b066e25d92d..393d7a0e434 100644
--- a/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsUnboundedReader.java
+++ b/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsUnboundedReader.java
@@ -17,51 +17,385 @@
  */
 package org.apache.beam.sdk.io.aws.sqs;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.toMap;
+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;
+
+import com.amazonaws.services.sqs.AmazonSQS;
+import com.amazonaws.services.sqs.model.BatchResultErrorEntry;
+import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchRequestEntry;
+import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchResult;
+import com.amazonaws.services.sqs.model.DeleteMessageBatchRequestEntry;
+import com.amazonaws.services.sqs.model.DeleteMessageBatchResult;
+import com.amazonaws.services.sqs.model.GetQueueAttributesRequest;
 import com.amazonaws.services.sqs.model.Message;
+import com.amazonaws.services.sqs.model.MessageAttributeValue;
 import com.amazonaws.services.sqs.model.MessageSystemAttributeName;
+import com.amazonaws.services.sqs.model.QueueAttributeName;
 import com.amazonaws.services.sqs.model.ReceiveMessageRequest;
 import com.amazonaws.services.sqs.model.ReceiveMessageResult;
-import java.io.Serializable;
-import java.nio.charset.StandardCharsets;
+import java.io.IOException;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.NoSuchElementException;
+import java.util.Objects;
 import java.util.Queue;
+import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 import org.apache.beam.sdk.io.UnboundedSource;
 import org.apache.beam.sdk.io.UnboundedSource.CheckpointMark;
+import org.apache.beam.sdk.transforms.Combine;
+import org.apache.beam.sdk.transforms.Sum;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
+import org.apache.beam.sdk.util.BucketingFunction;
+import org.apache.beam.sdk.util.MovingFunction;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.EvictingQueue;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;
+import org.joda.time.Duration;
 import org.joda.time.Instant;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 @SuppressWarnings({
   "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
 })
-class SqsUnboundedReader extends UnboundedSource.UnboundedReader<Message> implements Serializable {
+class SqsUnboundedReader extends UnboundedSource.UnboundedReader<Message> {
+  private static final Logger LOG = LoggerFactory.getLogger(SqsUnboundedReader.class);
 
+  /** Maximum number of messages to pull from SQS per request. */
   public static final int MAX_NUMBER_OF_MESSAGES = 10;
+
+  /** Maximum times to retry batch SQS operations upon partial success. */
+  private static final int BATCH_OPERATION_MAX_RETIRES = 5;
+
+  /** Timeout for round trip from receiving a message to finally deleting it from SQS. */
+  private static final Duration PROCESSING_TIMEOUT = Duration.standardMinutes(2);
+
+  /**
+   * Percentage of visibility timeout by which to extend visibility timeout when they are near
+   * timeout.
+   */
+  private static final int VISIBILITY_EXTENSION_PCT = 50;
+
+  /**
+   * Percentage of ack timeout we should use as a safety margin. We'll try to extend visibility
+   * timeout by this margin before the visibility timeout actually expires.
+   */
+  private static final int VISIBILITY_SAFETY_PCT = 20;
+
+  /**
+   * For stats only: How close we can get to an visibility deadline before we risk it being already
+   * considered passed by SQS.
+   */
+  private static final Duration VISIBILITY_TOO_LATE = Duration.standardSeconds(2);
+
+  /** Maximum number of message ids per delete or visibility extension call. */
+  private static final int DELETE_BATCH_SIZE = 10;
+
+  /** Maximum number of messages in flight. */
+  private static final int MAX_IN_FLIGHT = 20000;
+
+  /** Maximum number of recent messages for calculating average message size. */
+  private static final int MAX_AVG_BYTE_MESSAGES = 20;
+
+  /** Period of samples to determine watermark and other stats. */
+  private static final Duration SAMPLE_PERIOD = Duration.standardMinutes(1);
+
+  /** Period of updates to determine watermark and other stats. */
+  private static final Duration SAMPLE_UPDATE = Duration.standardSeconds(5);
+
+  /** Period for logging stats. */
+  private static final Duration LOG_PERIOD = Duration.standardSeconds(30);
+
+  /** Minimum number of unread messages required before considering updating watermark. */
+  private static final int MIN_WATERMARK_MESSAGES = 10;
+
+  /**
+   * Minimum number of SAMPLE_UPDATE periods over which unread messages should be spread before
+   * considering updating watermark.
+   */
+  private static final int MIN_WATERMARK_SPREAD = 2;
+
+  // TODO: Would prefer to use MinLongFn but it is a BinaryCombineFn<Long> rather
+  // than a BinaryCombineLongFn. [BEAM-285]
+  private static final Combine.BinaryCombineLongFn MIN =
+      new Combine.BinaryCombineLongFn() {
+        @Override
+        public long apply(long left, long right) {
+          return Math.min(left, right);
+        }
+
+        @Override
+        public long identity() {
+          return Long.MAX_VALUE;
+        }
+      };
+
+  private static final Combine.BinaryCombineLongFn MAX =
+      new Combine.BinaryCombineLongFn() {
+        @Override
+        public long apply(long left, long right) {
+          return Math.max(left, right);
+        }
+
+        @Override
+        public long identity() {
+          return Long.MIN_VALUE;
+        }
+      };
+
+  private static final Combine.BinaryCombineLongFn SUM = Sum.ofLongs();
+
+  /** For access to topic and SQS client. */
   private final SqsUnboundedSource source;
+
+  /**
+   * The closed state of this {@link SqsUnboundedReader}. If true, the reader has not yet been
+   * closed, and it will have a non-null value within {@link #SqsUnboundedReader}.
+   */
+  private AtomicBoolean active = new AtomicBoolean(true);
+
+  /** The current message, or {@literal null} if none. */
   private Message current;
-  private final Queue<Message> messagesNotYetRead;
-  private List<Message> messagesToDelete;
-  private Instant oldestPendingTimestamp = BoundedWindow.TIMESTAMP_MIN_VALUE;
 
-  public SqsUnboundedReader(SqsUnboundedSource source, SqsCheckpointMark sqsCheckpointMark) {
+  /**
+   * Messages we have received from SQS and not yet delivered downstream. We preserve their order.
+   */
+  final Queue<Message> messagesNotYetRead;
+
+  /** Message ids of messages we have delivered downstream but not yet deleted. */
+  private Set<String> safeToDeleteIds;
+
+  /**
+   * Visibility timeout, in ms, as set on subscription when we first start reading. Not updated
+   * thereafter. -1 if not yet determined.
+   */
+  private long visibilityTimeoutMs;
+
+  /** Byte size of undecoded elements in {@link #messagesNotYetRead}. */
+  private long notYetReadBytes;
+
+  /** Byte size of recent messages. */
+  private EvictingQueue<Integer> recentMessageBytes;
+
+  /**
+   * Bucketed map from received time (as system time, ms since epoch) to message timestamps (mssince
+   * epoch) of all received but not-yet read messages. Used to estimate watermark.
+   */
+  private BucketingFunction minUnreadTimestampMsSinceEpoch;
+
+  /**
+   * Minimum of timestamps (ms since epoch) of all recently read messages. Used to estimate
+   * watermark.
+   */
+  private MovingFunction minReadTimestampMsSinceEpoch;
+
+  /** Number of recent empty receives. */
+  private MovingFunction numEmptyReceives;
+
+  private static class InFlightState {
+    /** Receipt handle of message. */
+    String receiptHandle;
+
+    /** When request which yielded message was issued. */
+    long requestTimeMsSinceEpoch;
+
+    /**
+     * When SQS will consider this message's visibility timeout to timeout and thus it needs to be
+     * extended.
+     */
+    long visibilityDeadlineMsSinceEpoch;
+
+    public InFlightState(
+        String receiptHandle, long requestTimeMsSinceEpoch, long visibilityDeadlineMsSinceEpoch) {
+      this.receiptHandle = receiptHandle;
+      this.requestTimeMsSinceEpoch = requestTimeMsSinceEpoch;
+      this.visibilityDeadlineMsSinceEpoch = visibilityDeadlineMsSinceEpoch;
+    }
+  }
+
+  /**
+   * Map from message ids of messages we have received from SQS but not yet deleted to their in
+   * flight state. Ordered from earliest to latest visibility deadline.
+   */
+  private final LinkedHashMap<String, InFlightState> inFlight;
+
+  /**
+   * Batches of successfully deleted message ids which need to be pruned from the above. CAUTION:
+   * Accessed by both reader and checkpointing threads.
+   */
+  private final Queue<List<String>> deletedIds;
+
+  /**
+   * System time (ms since epoch) we last received a message from SQS, or -1 if not yet received any
+   * messages.
+   */
+  private long lastReceivedMsSinceEpoch;
+
+  /** The last reported watermark (ms since epoch), or beginning of time if none yet reported. */
+  private long lastWatermarkMsSinceEpoch;
+
+  /** Stats only: System time (ms since epoch) we last logs stats, or -1 if never. */
+  private long lastLogTimestampMsSinceEpoch;
+
+  /** Stats only: Total number of messages received. */
+  private long numReceived;
+
+  /** Stats only: Number of messages which have recently been received. */
+  private MovingFunction numReceivedRecently;
+
+  /** Stats only: Number of messages which have recently had their deadline extended. */
+  private MovingFunction numExtendedDeadlines;
+
+  /**
+   * Stats only: Number of messages which have recently had their deadline extended even though it
+   * may be too late to do so.
+   */
+  private MovingFunction numLateDeadlines;
+
+  /** Stats only: Number of messages which have recently been deleted. */
+  private MovingFunction numDeleted;
+
+  /**
+   * Stats only: Number of messages which have recently expired (visibility timeout were extended
+   * for too long).
+   */
+  private MovingFunction numExpired;
+
+  /** Stats only: Number of messages which have recently been returned to visible on SQS. */
+  private MovingFunction numReleased;
+
+  /** Stats only: Number of message bytes which have recently been read by downstream consumer. */
+  private MovingFunction numReadBytes;
+
+  /**
+   * Stats only: Minimum of timestamp (ms since epoch) of all recently received messages. Used to
+   * estimate timestamp skew. Does not contribute to watermark estimator.
+   */
+  private MovingFunction minReceivedTimestampMsSinceEpoch;
+
+  /**
+   * Stats only: Maximum of timestamp (ms since epoch) of all recently received messages. Used to
+   * estimate timestamp skew.
+   */
+  private MovingFunction maxReceivedTimestampMsSinceEpoch;
+
+  /** Stats only: Minimum of recent estimated watermarks (ms since epoch). */
+  private MovingFunction minWatermarkMsSinceEpoch;
+
+  /** Stats ony: Maximum of recent estimated watermarks (ms since epoch). */
+  private MovingFunction maxWatermarkMsSinceEpoch;
+
+  /**
+   * Stats only: Number of messages with timestamps strictly behind the estimated watermark at the
+   * time they are received. These may be considered 'late' by downstream computations.
+   */
+  private MovingFunction numLateMessages;
+
+  /**
+   * Stats only: Current number of checkpoints in flight. CAUTION: Accessed by both checkpointing
+   * and reader threads.
+   */
+  AtomicInteger numInFlightCheckpoints;
+
+  /** Stats only: Maximum number of checkpoints in flight at any time. */
+  private int maxInFlightCheckpoints;
+
+  private static MovingFunction newFun(Combine.BinaryCombineLongFn function) {
+    return new MovingFunction(
+        SAMPLE_PERIOD.getMillis(),
+        SAMPLE_UPDATE.getMillis(),
+        MIN_WATERMARK_SPREAD,
+        MIN_WATERMARK_MESSAGES,
+        function);
+  }
+
+  public SqsUnboundedReader(SqsUnboundedSource source, SqsCheckpointMark sqsCheckpointMark)
+      throws IOException {
     this.source = source;
-    this.current = null;
 
-    this.messagesNotYetRead = new ArrayDeque<>();
-    this.messagesToDelete = new ArrayList<>();
+    messagesNotYetRead = new ArrayDeque<>();
+    safeToDeleteIds = new HashSet<>();
+    inFlight = new LinkedHashMap<>();
+    deletedIds = new ConcurrentLinkedQueue<>();
+    visibilityTimeoutMs = -1;
+    notYetReadBytes = 0;
+    recentMessageBytes = EvictingQueue.create(MAX_AVG_BYTE_MESSAGES);
+    minUnreadTimestampMsSinceEpoch =
+        new BucketingFunction(
+            SAMPLE_UPDATE.getMillis(), MIN_WATERMARK_SPREAD, MIN_WATERMARK_MESSAGES, MIN);
+    minReadTimestampMsSinceEpoch = newFun(MIN);
+    numEmptyReceives = newFun(SUM);
+    lastReceivedMsSinceEpoch = -1;
+    lastWatermarkMsSinceEpoch = BoundedWindow.TIMESTAMP_MIN_VALUE.getMillis();
+    current = null;
+    lastLogTimestampMsSinceEpoch = -1;
+    numReceived = 0L;
+    numReceivedRecently = newFun(SUM);
+    numExtendedDeadlines = newFun(SUM);
+    numLateDeadlines = newFun(SUM);
+    numDeleted = newFun(SUM);
+    numExpired = newFun(SUM);
+    numReleased = newFun(SUM);
+    numReadBytes = newFun(SUM);
+    minReceivedTimestampMsSinceEpoch = newFun(MIN);
+    maxReceivedTimestampMsSinceEpoch = newFun(MAX);
+    minWatermarkMsSinceEpoch = newFun(MIN);
+    maxWatermarkMsSinceEpoch = newFun(MAX);
+    numLateMessages = newFun(SUM);
+    numInFlightCheckpoints = new AtomicInteger();
+    maxInFlightCheckpoints = 0;
 
     if (sqsCheckpointMark != null) {
-      this.messagesToDelete.addAll(sqsCheckpointMark.getMessagesToDelete());
+      long nowMsSinceEpoch = now();
+      extendBatch(nowMsSinceEpoch, sqsCheckpointMark.notYetReadReceipts, 0);
+      numReleased.add(nowMsSinceEpoch, sqsCheckpointMark.notYetReadReceipts.size());
     }
   }
 
   @Override
   public Instant getWatermark() {
-    return oldestPendingTimestamp;
+
+    // NOTE: We'll allow the watermark to go backwards. The underlying runner is responsible
+    // for aggregating all reported watermarks and ensuring the aggregate is latched.
+    // If we attempt to latch locally then it is possible a temporary starvation of one reader
+    // could cause its estimated watermark to fast forward to current system time. Then when
+    // the reader resumes its watermark would be unable to resume tracking.
+    // By letting the underlying runner latch we avoid any problems due to localized starvation.
+    long nowMsSinceEpoch = now();
+    long readMin = minReadTimestampMsSinceEpoch.get(nowMsSinceEpoch);
+    long unreadMin = minUnreadTimestampMsSinceEpoch.get();
+    if (readMin == Long.MAX_VALUE
+        && unreadMin == Long.MAX_VALUE
+        && numEmptyReceives.get(nowMsSinceEpoch) > 0
+        && nowMsSinceEpoch > lastReceivedMsSinceEpoch + SAMPLE_PERIOD.getMillis()) {
+      // We don't currently have any unread messages pending, we have not had any messages
+      // read for a while, and we have not received any new messages from SQS for a while.
+      // Advance watermark to current time.
+      // TODO: Estimate a timestamp lag.
+      lastWatermarkMsSinceEpoch = nowMsSinceEpoch;
+    } else if (minReadTimestampMsSinceEpoch.isSignificant()
+        || minUnreadTimestampMsSinceEpoch.isSignificant()) {
+      // Take minimum of the timestamps in all unread messages and recently read messages.
+      lastWatermarkMsSinceEpoch = Math.min(readMin, unreadMin);
+    }
+    // else: We're not confident enough to estimate a new watermark. Stick with the old one.
+    minWatermarkMsSinceEpoch.add(nowMsSinceEpoch, lastWatermarkMsSinceEpoch);
+    maxWatermarkMsSinceEpoch.add(nowMsSinceEpoch, lastWatermarkMsSinceEpoch);
+    return new Instant(lastWatermarkMsSinceEpoch);
   }
 
   @Override
@@ -86,12 +420,19 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<Message> implem
     if (current == null) {
       throw new NoSuchElementException();
     }
-    return current.getMessageId().getBytes(StandardCharsets.UTF_8);
+    return current.getMessageId().getBytes(UTF_8);
   }
 
   @Override
   public CheckpointMark getCheckpointMark() {
-    return new SqsCheckpointMark(this, messagesToDelete);
+    int cur = numInFlightCheckpoints.incrementAndGet();
+    maxInFlightCheckpoints = Math.max(maxInFlightCheckpoints, cur);
+    List<String> snapshotSafeToDeleteIds = Lists.newArrayList(safeToDeleteIds);
+    List<String> snapshotNotYetReadReceipts = new ArrayList<>(messagesNotYetRead.size());
+    for (Message message : messagesNotYetRead) {
+      snapshotNotYetReadReceipts.add(message.getReceiptHandle());
+    }
+    return new SqsCheckpointMark(this, snapshotSafeToDeleteIds, snapshotNotYetReadReceipts);
   }
 
   @Override
@@ -100,47 +441,220 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<Message> implem
   }
 
   @Override
-  public boolean start() {
+  public long getTotalBacklogBytes() {
+    long avgBytes = avgMessageBytes();
+    List<String> requestAttributes =
+        Collections.singletonList(QueueAttributeName.ApproximateNumberOfMessages.toString());
+    Map<String, String> queueAttributes =
+        source
+            .getSqs()
+            .getQueueAttributes(source.getRead().queueUrl(), requestAttributes)
+            .getAttributes();
+    long numMessages =
+        Long.parseLong(
+            queueAttributes.get(QueueAttributeName.ApproximateNumberOfMessages.toString()));
+
+    // No messages consumed for estimating average message size
+    if (avgBytes == -1 && numMessages > 0) {
+      return BACKLOG_UNKNOWN;
+    } else {
+      return numMessages * avgBytes;
+    }
+  }
+
+  @Override
+  public boolean start() throws IOException {
+    visibilityTimeoutMs =
+        Integer.parseInt(
+                source
+                    .getSqs()
+                    .getQueueAttributes(
+                        new GetQueueAttributesRequest(source.getRead().queueUrl())
+                            .withAttributeNames("VisibilityTimeout"))
+                    .getAttributes()
+                    .get("VisibilityTimeout"))
+            * 1000L;
     return advance();
   }
 
   @Override
-  public boolean advance() {
+  public boolean advance() throws IOException {
+    // Emit stats.
+    stats();
+
+    if (current != null) {
+      // Current is consumed. It can no longer contribute to holding back the watermark.
+      minUnreadTimestampMsSinceEpoch.remove(getRequestTimeMsSinceEpoch(current));
+      current = null;
+    }
+
+    // Retire state associated with deleted messages.
+    retire();
+
+    // Extend all pressing deadlines.
+    // Will BLOCK until done.
+    // If the system is pulling messages only to let them sit in a downstream queue then
+    // this will have the effect of slowing down the pull rate.
+    // However, if the system is genuinely taking longer to process each message then
+    // the work to extend visibility timeout would be better done in the background.
+    extend();
+
     if (messagesNotYetRead.isEmpty()) {
+      // Pull another batch.
+      // Will BLOCK until fetch returns, but will not block until a message is available.
       pull();
     }
 
+    // Take one message from queue.
     current = messagesNotYetRead.poll();
     if (current == null) {
+      // Try again later.
       return false;
     }
-
-    messagesToDelete.add(current);
-
-    Instant currentMessageTimestamp = getCurrentTimestamp();
-    if (getCurrentTimestamp().isBefore(oldestPendingTimestamp)) {
-      oldestPendingTimestamp = currentMessageTimestamp;
+    notYetReadBytes -= current.getBody().getBytes(UTF_8).length;
+    checkState(notYetReadBytes >= 0);
+    long nowMsSinceEpoch = now();
+    numReadBytes.add(nowMsSinceEpoch, current.getBody().getBytes(UTF_8).length);
+    recentMessageBytes.add(current.getBody().getBytes(UTF_8).length);
+    minReadTimestampMsSinceEpoch.add(nowMsSinceEpoch, getCurrentTimestamp().getMillis());
+    if (getCurrentTimestamp().getMillis() < lastWatermarkMsSinceEpoch) {
+      numLateMessages.add(nowMsSinceEpoch, 1L);
     }
 
+    // Current message can be considered 'read' and will be persisted by the next
+    // checkpoint. So it is now safe to delete from SQS.
+    safeToDeleteIds.add(current.getMessageId());
+
     return true;
   }
 
+  /**
+   * {@inheritDoc}.
+   *
+   * <p>Marks this {@link SqsUnboundedReader} as no longer active. The {@link AmazonSQS} continue to
+   * exist and be active beyond the life of this call if there are any in-flight checkpoints. When
+   * no in-flight checkpoints remain, the reader will be closed.
+   */
   @Override
-  public void close() {}
+  public void close() throws IOException {
+    active.set(false);
+    maybeCloseClient();
+  }
 
-  void delete(final Collection<Message> messages) {
-    for (Message message : messages) {
-      if (messagesToDelete.contains(message)) {
-        source.getSqs().deleteMessage(source.getRead().queueUrl(), message.getReceiptHandle());
-        Instant currentMessageTimestamp = getTimestamp(message);
-        if (currentMessageTimestamp.isAfter(oldestPendingTimestamp)) {
-          oldestPendingTimestamp = currentMessageTimestamp;
-        }
+  /**
+   * Close this reader's underlying {@link AmazonSQS} if the reader has been closed and there are no
+   * outstanding checkpoints.
+   */
+  void maybeCloseClient() throws IOException {
+    if (!active.get() && numInFlightCheckpoints.get() == 0) {
+      // The reader has been closed and it has no more outstanding checkpoints. The client
+      // must be closed so it doesn't leak
+      AmazonSQS client = source.getSqs();
+      if (client != null) {
+        client.shutdown();
       }
     }
   }
 
+  /** delete the provided {@code messageIds} from SQS. */
+  void delete(List<String> messageIds) throws IOException {
+    AtomicInteger counter = new AtomicInteger();
+    for (List<String> messageList :
+        messageIds.stream()
+            .collect(groupingBy(x -> counter.getAndIncrement() / DELETE_BATCH_SIZE))
+            .values()) {
+      deleteBatch(messageList);
+    }
+  }
+
+  /**
+   * delete the provided {@code messageIds} from SQS, blocking until all of the messages are
+   * deleted.
+   *
+   * <p>CAUTION: May be invoked from a separate thread.
+   *
+   * <p>CAUTION: Retains {@code messageIds}.
+   */
+  private void deleteBatch(List<String> messageIds) throws IOException {
+    int retries = 0;
+    List<String> errorMessages = new ArrayList<>();
+    Map<String, String> pendingReceipts =
+        IntStream.range(0, messageIds.size())
+            .boxed()
+            .filter(i -> inFlight.containsKey(messageIds.get(i)))
+            .collect(toMap(Object::toString, i -> inFlight.get(messageIds.get(i)).receiptHandle));
+
+    while (!pendingReceipts.isEmpty()) {
+
+      if (retries >= BATCH_OPERATION_MAX_RETIRES) {
+        throw new IOException(
+            "Failed to delete "
+                + pendingReceipts.size()
+                + " messages after "
+                + retries
+                + " retries: "
+                + String.join(", ", errorMessages));
+      }
+
+      List<DeleteMessageBatchRequestEntry> entries =
+          pendingReceipts.entrySet().stream()
+              .map(r -> new DeleteMessageBatchRequestEntry(r.getKey(), r.getValue()))
+              .collect(Collectors.toList());
+
+      DeleteMessageBatchResult result =
+          source.getSqs().deleteMessageBatch(source.getRead().queueUrl(), entries);
+
+      // Retry errors except invalid handles
+      Set<BatchResultErrorEntry> retryErrors =
+          result.getFailed().stream()
+              .filter(e -> !e.getCode().equals("ReceiptHandleIsInvalid"))
+              .collect(Collectors.toSet());
+
+      pendingReceipts
+          .keySet()
+          .retainAll(
+              retryErrors.stream().map(BatchResultErrorEntry::getId).collect(Collectors.toSet()));
+
+      errorMessages =
+          retryErrors.stream().map(BatchResultErrorEntry::getMessage).collect(Collectors.toList());
+
+      retries += 1;
+    }
+    deletedIds.add(messageIds);
+  }
+
+  /**
+   * Messages which have been deleted (via the checkpoint finalize) are no longer in flight. This is
+   * only used for flow control and stats.
+   */
+  private void retire() {
+    long nowMsSinceEpoch = now();
+    while (true) {
+      List<String> ackIds = deletedIds.poll();
+      if (ackIds == null) {
+        return;
+      }
+      numDeleted.add(nowMsSinceEpoch, ackIds.size());
+      for (String ackId : ackIds) {
+        inFlight.remove(ackId);
+        safeToDeleteIds.remove(ackId);
+      }
+    }
+  }
+
+  /** BLOCKING Fetch another batch of messages from SQS. */
   private void pull() {
+    if (inFlight.size() >= MAX_IN_FLIGHT) {
+      // Wait for checkpoint to be finalized before pulling anymore.
+      // There may be lag while checkpoints are persisted and the finalizeCheckpoint method
+      // is invoked. By limiting the in-flight messages we can ensure we don't end up consuming
+      // messages faster than we can checkpoint them.
+      return;
+    }
+
+    long requestTimeMsSinceEpoch = now();
+    long deadlineMsSinceEpoch = requestTimeMsSinceEpoch + visibilityTimeoutMs;
+
     final ReceiveMessageRequest receiveMessageRequest =
         new ReceiveMessageRequest(source.getRead().queueUrl());
 
@@ -153,17 +667,296 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<Message> implem
     final List<Message> messages = receiveMessageResult.getMessages();
 
     if (messages == null || messages.isEmpty()) {
+      numEmptyReceives.add(requestTimeMsSinceEpoch, 1L);
       return;
     }
 
+    lastReceivedMsSinceEpoch = requestTimeMsSinceEpoch;
+
+    // Capture the received messages.
     for (Message message : messages) {
+      // The Message class does not contain request time.
+      setRequestTimeMsSinceEpoch(message, requestTimeMsSinceEpoch);
       messagesNotYetRead.add(message);
+      notYetReadBytes += message.getBody().getBytes(UTF_8).length;
+      inFlight.put(
+          message.getMessageId(),
+          new InFlightState(
+              message.getReceiptHandle(), requestTimeMsSinceEpoch, deadlineMsSinceEpoch));
+      numReceived++;
+      numReceivedRecently.add(requestTimeMsSinceEpoch, 1L);
+      minReceivedTimestampMsSinceEpoch.add(
+          requestTimeMsSinceEpoch, getTimestamp(message).getMillis());
+      maxReceivedTimestampMsSinceEpoch.add(
+          requestTimeMsSinceEpoch, getTimestamp(message).getMillis());
+      minUnreadTimestampMsSinceEpoch.add(
+          requestTimeMsSinceEpoch, getTimestamp(message).getMillis());
+    }
+  }
+
+  /** Return the current time, in ms since epoch. */
+  long now() {
+    return System.currentTimeMillis();
+  }
+
+  /**
+   * BLOCKING Extend deadline for all messages which need it. CAUTION: If extensions can't keep up
+   * with wallclock then we'll never return.
+   */
+  private void extend() throws IOException {
+    while (true) {
+      long nowMsSinceEpoch = now();
+      List<String> assumeExpired = new ArrayList<>();
+      List<String> toBeExtended = new ArrayList<>();
+      List<String> toBeExpired = new ArrayList<>();
+      // Messages will be in increasing deadline order.
+      for (Map.Entry<String, InFlightState> entry : inFlight.entrySet()) {
+        if (entry.getValue().visibilityDeadlineMsSinceEpoch
+                - (visibilityTimeoutMs * VISIBILITY_SAFETY_PCT) / 100
+            > nowMsSinceEpoch) {
+          // All remaining messages don't need their visibility timeouts to be extended.
+          break;
+        }
+
+        if (entry.getValue().visibilityDeadlineMsSinceEpoch - VISIBILITY_TOO_LATE.getMillis()
+            < nowMsSinceEpoch) {
+          // SQS may have already considered this message to have expired.
+          // If so it will (eventually) be made available on a future pull request.
+          // If this message ends up being committed then it will be considered a duplicate
+          // when re-pulled.
+          assumeExpired.add(entry.getKey());
+          continue;
+        }
+
+        if (entry.getValue().requestTimeMsSinceEpoch + PROCESSING_TIMEOUT.getMillis()
+            < nowMsSinceEpoch) {
+          // This message has been in-flight for too long.
+          // Give up on it, otherwise we risk extending its visibility timeout indefinitely.
+          toBeExpired.add(entry.getKey());
+          continue;
+        }
+
+        // Extend the visibility timeout for this message.
+        toBeExtended.add(entry.getKey());
+        if (toBeExtended.size() >= DELETE_BATCH_SIZE) {
+          // Enough for one batch.
+          break;
+        }
+      }
+
+      if (assumeExpired.isEmpty() && toBeExtended.isEmpty() && toBeExpired.isEmpty()) {
+        // Nothing to be done.
+        return;
+      }
+
+      if (!assumeExpired.isEmpty()) {
+        // If we didn't make the visibility deadline assume expired and no longer in flight.
+        numLateDeadlines.add(nowMsSinceEpoch, assumeExpired.size());
+        for (String messageId : assumeExpired) {
+          inFlight.remove(messageId);
+        }
+      }
+
+      if (!toBeExpired.isEmpty()) {
+        // Expired messages are no longer considered in flight.
+        numExpired.add(nowMsSinceEpoch, toBeExpired.size());
+        for (String messageId : toBeExpired) {
+          inFlight.remove(messageId);
+        }
+      }
+
+      if (!toBeExtended.isEmpty()) {
+        // SQS extends visibility timeout from it's notion of current time.
+        // We'll try to track that on our side, but note the deadlines won't necessarily agree.
+        long extensionMs = (int) ((visibilityTimeoutMs * VISIBILITY_EXTENSION_PCT) / 100L);
+        long newDeadlineMsSinceEpoch = nowMsSinceEpoch + extensionMs;
+        for (String messageId : toBeExtended) {
+          // Maintain increasing ack deadline order.
+          String receiptHandle = inFlight.get(messageId).receiptHandle;
+          InFlightState state = inFlight.remove(messageId);
+
+          inFlight.put(
+              messageId,
+              new InFlightState(
+                  receiptHandle, state.requestTimeMsSinceEpoch, newDeadlineMsSinceEpoch));
+        }
+        List<String> receiptHandles =
+            toBeExtended.stream()
+                .map(inFlight::get)
+                .filter(Objects::nonNull) // get rid of null values
+                .map(m -> m.receiptHandle)
+                .collect(Collectors.toList());
+        // BLOCKs until extended.
+        extendBatch(nowMsSinceEpoch, receiptHandles, (int) (extensionMs / 1000));
+      }
     }
   }
 
+  /**
+   * BLOCKING Extend the visibility timeout for messages from SQS with the given {@code
+   * receiptHandles}.
+   */
+  void extendBatch(long nowMsSinceEpoch, List<String> receiptHandles, int extensionSec)
+      throws IOException {
+    int retries = 0;
+    int numMessages = receiptHandles.size();
+    Map<String, String> pendingReceipts =
+        IntStream.range(0, receiptHandles.size())
+            .boxed()
+            .collect(toMap(Object::toString, receiptHandles::get));
+    List<String> errorMessages = new ArrayList<>();
+
+    while (!pendingReceipts.isEmpty()) {
+
+      if (retries >= BATCH_OPERATION_MAX_RETIRES) {
+        throw new IOException(
+            "Failed to extend visibility timeout for "
+                + pendingReceipts.size()
+                + " messages after "
+                + retries
+                + " retries: "
+                + String.join(", ", errorMessages));
+      }
+
+      List<ChangeMessageVisibilityBatchRequestEntry> entries =
+          pendingReceipts.entrySet().stream()
+              .map(
+                  r ->
+                      new ChangeMessageVisibilityBatchRequestEntry(r.getKey(), r.getValue())
+                          .withVisibilityTimeout(extensionSec))
+              .collect(Collectors.toList());
+
+      ChangeMessageVisibilityBatchResult result =
+          source.getSqs().changeMessageVisibilityBatch(source.getRead().queueUrl(), entries);
+
+      // Retry errors except invalid handles
+      Set<BatchResultErrorEntry> retryErrors =
+          result.getFailed().stream()
+              .filter(e -> !e.getCode().equals("ReceiptHandleIsInvalid"))
+              .collect(Collectors.toSet());
+
+      pendingReceipts
+          .keySet()
+          .retainAll(
+              retryErrors.stream().map(BatchResultErrorEntry::getId).collect(Collectors.toSet()));
+
+      errorMessages =
+          retryErrors.stream().map(BatchResultErrorEntry::getMessage).collect(Collectors.toList());
+
+      retries += 1;
+    }
+    numExtendedDeadlines.add(nowMsSinceEpoch, numMessages);
+  }
+
+  /** Log stats if time to do so. */
+  private void stats() {
+    long nowMsSinceEpoch = now();
+    if (lastLogTimestampMsSinceEpoch < 0) {
+      lastLogTimestampMsSinceEpoch = nowMsSinceEpoch;
+      return;
+    }
+    long deltaMs = nowMsSinceEpoch - lastLogTimestampMsSinceEpoch;
+    if (deltaMs < LOG_PERIOD.getMillis()) {
+      return;
+    }
+
+    String messageSkew = "unknown";
+    long minTimestamp = minReceivedTimestampMsSinceEpoch.get(nowMsSinceEpoch);
+    long maxTimestamp = maxReceivedTimestampMsSinceEpoch.get(nowMsSinceEpoch);
+    if (minTimestamp < Long.MAX_VALUE && maxTimestamp > Long.MIN_VALUE) {
+      messageSkew = (maxTimestamp - minTimestamp) + "ms";
+    }
+
+    String watermarkSkew = "unknown";
+    long minWatermark = minWatermarkMsSinceEpoch.get(nowMsSinceEpoch);
+    long maxWatermark = maxWatermarkMsSinceEpoch.get(nowMsSinceEpoch);
+    if (minWatermark < Long.MAX_VALUE && maxWatermark > Long.MIN_VALUE) {
+      watermarkSkew = (maxWatermark - minWatermark) + "ms";
+    }
+
+    String oldestInFlight = "no";
+    String oldestAckId = Iterables.getFirst(inFlight.keySet(), null);
+    if (oldestAckId != null) {
+      oldestInFlight = (nowMsSinceEpoch - inFlight.get(oldestAckId).requestTimeMsSinceEpoch) + "ms";
+    }
+
+    LOG.debug(
+        "SQS {} has "
+            + "{} received messages, "
+            + "{} current unread messages, "
+            + "{} current unread bytes, "
+            + "{} current in-flight msgs, "
+            + "{} oldest in-flight, "
+            + "{} current in-flight checkpoints, "
+            + "{} max in-flight checkpoints, "
+            + "{} bytes in backlog, "
+            + "{}B/s recent read, "
+            + "{} recent received, "
+            + "{} recent extended, "
+            + "{} recent late extended, "
+            + "{} recent deleted, "
+            + "{} recent released, "
+            + "{} recent expired, "
+            + "{} recent message timestamp skew, "
+            + "{} recent watermark skew, "
+            + "{} recent late messages, "
+            + "{} last reported watermark",
+        source.getRead().queueUrl(),
+        numReceived,
+        messagesNotYetRead.size(),
+        notYetReadBytes,
+        inFlight.size(),
+        oldestInFlight,
+        numInFlightCheckpoints.get(),
+        maxInFlightCheckpoints,
+        getTotalBacklogBytes(),
+        numReadBytes.get(nowMsSinceEpoch) / (SAMPLE_PERIOD.getMillis() / 1000L),
+        numReceivedRecently.get(nowMsSinceEpoch),
+        numExtendedDeadlines.get(nowMsSinceEpoch),
+        numLateDeadlines.get(nowMsSinceEpoch),
+        numDeleted.get(nowMsSinceEpoch),
+        numReleased.get(nowMsSinceEpoch),
+        numExpired.get(nowMsSinceEpoch),
+        messageSkew,
+        watermarkSkew,
+        numLateMessages.get(nowMsSinceEpoch),
+        new Instant(lastWatermarkMsSinceEpoch));
+
+    lastLogTimestampMsSinceEpoch = nowMsSinceEpoch;
+  }
+
+  /** Return the average byte size of all message read. -1 if no message read yet */
+  private long avgMessageBytes() {
+    if (!recentMessageBytes.isEmpty()) {
+      return (long) recentMessageBytes.stream().mapToDouble(s -> s).average().getAsDouble();
+    } else {
+      return -1L;
+    }
+  }
+
+  /** Extract the timestamp from the given {@code message}. */
   private Instant getTimestamp(final Message message) {
     return new Instant(
         Long.parseLong(
             message.getAttributes().get(MessageSystemAttributeName.SentTimestamp.toString())));
   }
+
+  /**
+   * Since SQS Message instances does not hold the request timestamp, store a new message attribute
+   * as the given {@code requestTimeMsSinceEpoch}.
+   */
+  private void setRequestTimeMsSinceEpoch(
+      final Message message, final long requestTimeMsSinceEpoch) {
+    Map<String, MessageAttributeValue> attributes = new HashMap<>();
+    attributes.put(
+        "requestTimeMsSinceEpoch",
+        new MessageAttributeValue().withStringValue(Long.toString(requestTimeMsSinceEpoch)));
+    message.setMessageAttributes(attributes);
+  }
+
+  /** Extract the request timestamp from the given {@code message}. */
+  private Long getRequestTimeMsSinceEpoch(final Message message) {
+    return Long.parseLong(
+        message.getMessageAttributes().get("requestTimeMsSinceEpoch").getStringValue());
+  }
 }
diff --git a/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsUnboundedSource.java b/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsUnboundedSource.java
index 5dcfce05826..1161bff61b1 100644
--- a/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsUnboundedSource.java
+++ b/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/sqs/SqsUnboundedSource.java
@@ -20,6 +20,7 @@ package org.apache.beam.sdk.io.aws.sqs;
 import com.amazonaws.services.sqs.AmazonSQS;
 import com.amazonaws.services.sqs.AmazonSQSClientBuilder;
 import com.amazonaws.services.sqs.model.Message;
+import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
@@ -68,7 +69,11 @@ class SqsUnboundedSource extends UnboundedSource<Message, SqsCheckpointMark> {
   @Override
   public UnboundedReader<Message> createReader(
       PipelineOptions options, @Nullable SqsCheckpointMark checkpointMark) {
-    return new SqsUnboundedReader(this, checkpointMark);
+    try {
+      return new SqsUnboundedReader(this, checkpointMark);
+    } catch (IOException e) {
+      throw new RuntimeException("Unable to subscribe to " + read.queueUrl() + ": ", e);
+    }
   }
 
   @Override
diff --git a/sdks/java/io/amazon-web-services/src/test/java/org/apache/beam/sdk/io/aws/sqs/SqsIOTest.java b/sdks/java/io/amazon-web-services/src/test/java/org/apache/beam/sdk/io/aws/sqs/SqsIOTest.java
index 5ce832d78e9..f3e7be092af 100644
--- a/sdks/java/io/amazon-web-services/src/test/java/org/apache/beam/sdk/io/aws/sqs/SqsIOTest.java
+++ b/sdks/java/io/amazon-web-services/src/test/java/org/apache/beam/sdk/io/aws/sqs/SqsIOTest.java
@@ -17,7 +17,9 @@
  */
 package org.apache.beam.sdk.io.aws.sqs;
 
+import static junit.framework.TestCase.assertFalse;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 import com.amazonaws.auth.AWSStaticCredentialsProvider;
 import com.amazonaws.auth.BasicAWSCredentials;
@@ -28,13 +30,17 @@ import com.amazonaws.services.sqs.model.CreateQueueResult;
 import com.amazonaws.services.sqs.model.Message;
 import com.amazonaws.services.sqs.model.ReceiveMessageResult;
 import com.amazonaws.services.sqs.model.SendMessageRequest;
+import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
-import org.apache.beam.sdk.testing.PAssert;
+import org.apache.beam.sdk.io.UnboundedSource.CheckpointMark;
+import org.apache.beam.sdk.io.UnboundedSource.UnboundedReader;
+import org.apache.beam.sdk.io.aws.options.AwsOptions;
+import org.apache.beam.sdk.testing.CoderProperties;
 import org.apache.beam.sdk.testing.TestPipeline;
-import org.apache.beam.sdk.transforms.Count;
 import org.apache.beam.sdk.transforms.Create;
-import org.apache.beam.sdk.values.PCollection;
+import org.apache.beam.sdk.util.CoderUtils;
 import org.elasticmq.rest.sqs.SQSRestServer;
 import org.elasticmq.rest.sqs.SQSRestServerBuilder;
 import org.junit.Rule;
@@ -46,25 +52,151 @@ import org.junit.runners.JUnit4;
 /** Tests on {@link SqsIO}. */
 @RunWith(JUnit4.class)
 public class SqsIOTest {
+  private static final String DATA = "testData";
 
   @Rule public TestPipeline pipeline = TestPipeline.create();
 
   @Rule public EmbeddedSqsServer embeddedSqsRestServer = new EmbeddedSqsServer();
 
-  @Test
-  public void testRead() {
+  private SqsUnboundedSource source;
+
+  private void setupOneMessage() {
     final AmazonSQS client = embeddedSqsRestServer.getClient();
     final String queueUrl = embeddedSqsRestServer.getQueueUrl();
+    client.sendMessage(queueUrl, DATA);
+    source =
+        new SqsUnboundedSource(
+            SqsIO.read().withQueueUrl(queueUrl).withMaxNumRecords(1),
+            new SqsConfiguration(pipeline.getOptions().as(AwsOptions.class)));
+  }
+
+  private void setupMessages(List<String> messages) {
+    final AmazonSQS client = embeddedSqsRestServer.getClient();
+    final String queueUrl = embeddedSqsRestServer.getQueueUrl();
+    for (String message : messages) {
+      client.sendMessage(queueUrl, message);
+    }
+    source =
+        new SqsUnboundedSource(
+            SqsIO.read().withQueueUrl(queueUrl).withMaxNumRecords(1),
+            new SqsConfiguration(pipeline.getOptions().as(AwsOptions.class)));
+  }
+
+  @Test
+  public void checkpointCoderIsSane() {
+    setupOneMessage();
+    CoderProperties.coderSerializable(source.getCheckpointMarkCoder());
+    // Since we only serialize/deserialize the 'notYetReadIds', and we don't want to make
+    // equals on checkpoints ignore those fields, we'll test serialization and deserialization
+    // of checkpoints in multipleReaders below.
+  }
 
-    final PCollection<Message> output =
-        pipeline.apply(SqsIO.read().withQueueUrl(queueUrl).withMaxNumRecords(100));
+  @Test
+  public void readOneMessage() throws IOException {
+    setupOneMessage();
+    UnboundedReader<Message> reader = source.createReader(pipeline.getOptions(), null);
+    // Read one message.
+    assertTrue(reader.start());
+    assertEquals(DATA, reader.getCurrent().getBody());
+    assertFalse(reader.advance());
+    // ACK the message.
+    CheckpointMark checkpoint = reader.getCheckpointMark();
+    checkpoint.finalizeCheckpoint();
+    reader.close();
+  }
 
-    PAssert.thatSingleton(output.apply(Count.globally())).isEqualTo(100L);
+  @Test
+  public void timeoutAckAndRereadOneMessage() throws IOException {
+    setupOneMessage();
+    UnboundedReader<Message> reader = source.createReader(pipeline.getOptions(), null);
+    AmazonSQS sqsClient = source.getSqs();
+    assertTrue(reader.start());
+    assertEquals(DATA, reader.getCurrent().getBody());
+    String receiptHandle = reader.getCurrent().getReceiptHandle();
+    // Set the message to timeout.
+    sqsClient.changeMessageVisibility(source.getRead().queueUrl(), receiptHandle, 0);
+    // We'll now receive the same message again.
+    assertTrue(reader.advance());
+    assertEquals(DATA, reader.getCurrent().getBody());
+    assertFalse(reader.advance());
+    // Now ACK the message.
+    CheckpointMark checkpoint = reader.getCheckpointMark();
+    checkpoint.finalizeCheckpoint();
+    reader.close();
+  }
+
+  @Test
+  public void multipleReaders() throws IOException {
+    List<String> incoming = new ArrayList<>();
+    for (int i = 0; i < 2; i++) {
+      incoming.add(String.format("data_%d", i));
+    }
+    setupMessages(incoming);
+    UnboundedReader<Message> reader = source.createReader(pipeline.getOptions(), null);
+    // Consume two messages, only read one.
+    assertTrue(reader.start());
+    assertEquals("data_0", reader.getCurrent().getBody());
 
+    // Grab checkpoint.
+    SqsCheckpointMark checkpoint = (SqsCheckpointMark) reader.getCheckpointMark();
+    checkpoint.finalizeCheckpoint();
+    assertEquals(1, checkpoint.notYetReadReceipts.size());
+
+    // Read second message.
+    assertTrue(reader.advance());
+    assertEquals("data_1", reader.getCurrent().getBody());
+
+    // Restore from checkpoint.
+    byte[] checkpointBytes =
+        CoderUtils.encodeToByteArray(source.getCheckpointMarkCoder(), checkpoint);
+    checkpoint = CoderUtils.decodeFromByteArray(source.getCheckpointMarkCoder(), checkpointBytes);
+    assertEquals(1, checkpoint.notYetReadReceipts.size());
+
+    // Re-read second message.
+    reader = source.createReader(pipeline.getOptions(), checkpoint);
+    assertTrue(reader.start());
+    assertEquals("data_1", reader.getCurrent().getBody());
+
+    // We are done.
+    assertFalse(reader.advance());
+
+    // ACK final message.
+    checkpoint = (SqsCheckpointMark) reader.getCheckpointMark();
+    checkpoint.finalizeCheckpoint();
+    reader.close();
+  }
+
+  @Test
+  public void testReadMany() throws IOException {
+
+    HashSet<String> messages = new HashSet<>();
+    List<String> incoming = new ArrayList<>();
     for (int i = 0; i < 100; i++) {
-      client.sendMessage(queueUrl, "This is a test");
+      String content = String.format("data_%d", i);
+      messages.add(content);
+      incoming.add(String.format("data_%d", i));
     }
-    pipeline.run();
+    setupMessages(incoming);
+
+    SqsUnboundedReader reader =
+        (SqsUnboundedReader) source.createReader(pipeline.getOptions(), null);
+
+    for (int i = 0; i < 100; i++) {
+      if (i == 0) {
+        assertTrue(reader.start());
+      } else {
+        assertTrue(reader.advance());
+      }
+      String data = reader.getCurrent().getBody();
+      boolean messageNum = messages.remove(data);
+      // No duplicate messages.
+      assertTrue(messageNum);
+    }
+    // We are done.
+    assertFalse(reader.advance());
+    // We saw each message exactly once.
+    assertTrue(messages.isEmpty());
+    reader.close();
   }
 
   @Test
@@ -96,6 +228,17 @@ public class SqsIOTest {
     }
   }
 
+  /** Tests that checkpoints finalized after the reader is closed succeed. */
+  @Test
+  public void closeWithActiveCheckpoints() throws Exception {
+    setupOneMessage();
+    UnboundedReader<Message> reader = source.createReader(pipeline.getOptions(), null);
+    reader.start();
+    CheckpointMark checkpoint = reader.getCheckpointMark();
+    reader.close();
+    checkpoint.finalizeCheckpoint();
+  }
+
   private static class EmbeddedSqsServer extends ExternalResource {
 
     private SQSRestServer sqsRestServer;
diff --git a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsCheckpointMark.java b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsCheckpointMark.java
index 92ed2354de5..2a9a630c457 100644
--- a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsCheckpointMark.java
+++ b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsCheckpointMark.java
@@ -17,33 +17,70 @@
  */
 package org.apache.beam.sdk.io.aws2.sqs;
 
+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;
+
+import java.io.IOException;
 import java.io.Serializable;
-import java.util.Collection;
 import java.util.List;
 import java.util.Optional;
 import org.apache.beam.sdk.io.UnboundedSource;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Objects;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.checkerframework.checker.nullness.qual.Nullable;
-import software.amazon.awssdk.services.sqs.model.Message;
 
+@SuppressWarnings({
+  "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
+})
 class SqsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {
 
-  private final List<Message> messagesToDelete;
-  private final transient Optional<SqsUnboundedReader> reader;
+  /**
+   * If the checkpoint is for persisting: the reader who's snapshotted state we are persisting. If
+   * the checkpoint is for restoring: {@literal null}. Not persisted in durable checkpoint. CAUTION:
+   * Between a checkpoint being taken and {@link #finalizeCheckpoint()} being called the 'true'
+   * active reader may have changed.
+   */
+  private transient Optional<SqsUnboundedReader> reader;
+  /**
+   * If the checkpoint is for persisting: The ids of messages which have been passed downstream
+   * since the last checkpoint. If the checkpoint is for restoring: {@literal null}. Not persisted
+   * in durable checkpoint.
+   */
+  private @Nullable List<String> safeToDeleteIds;
+
+  /**
+   * If the checkpoint is for persisting: The receipt handles of messages which have been received
+   * from SQS but not yet passed downstream at the time of the snapshot. If the checkpoint is for
+   * restoring: Same, but recovered from durable storage.
+   */
+  @VisibleForTesting final List<String> notYetReadReceipts;
 
-  SqsCheckpointMark(SqsUnboundedReader reader, Collection<Message> messagesToDelete) {
+  SqsCheckpointMark(
+      SqsUnboundedReader reader, List<String> messagesToDelete, List<String> notYetReadReceipts) {
     this.reader = Optional.of(reader);
-    this.messagesToDelete = ImmutableList.copyOf(messagesToDelete);
+    this.safeToDeleteIds = ImmutableList.copyOf(messagesToDelete);
+    this.notYetReadReceipts = ImmutableList.copyOf(notYetReadReceipts);
   }
 
   @Override
-  public void finalizeCheckpoint() {
-    reader.ifPresent(r -> r.delete(messagesToDelete));
-  }
-
-  List<Message> getMessagesToDelete() {
-    return messagesToDelete;
+  public void finalizeCheckpoint() throws IOException {
+    checkState(
+        reader.isPresent() && safeToDeleteIds != null, "Cannot finalize a restored checkpoint");
+    // Even if the 'true' active reader has changed since the checkpoint was taken we are
+    // fine:
+    // - The underlying SQS topic will not have changed, so the following deletes will still
+    // go to the right place.
+    // - We'll delete the ACK ids from the readers in-flight state, but that only affect
+    // flow control and stats, neither of which are relevant anymore.
+    try {
+      reader.get().delete(safeToDeleteIds);
+    } finally {
+      int remainingInFlight = reader.get().numInFlightCheckpoints.decrementAndGet();
+      checkState(remainingInFlight >= 0, "Miscounted in-flight checkpoints");
+      reader.get().maybeCloseClient();
+      reader = Optional.empty();
+      safeToDeleteIds = null;
+    }
   }
 
   @Override
@@ -55,11 +92,11 @@ class SqsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable
       return false;
     }
     SqsCheckpointMark that = (SqsCheckpointMark) o;
-    return Objects.equal(messagesToDelete, that.messagesToDelete);
+    return Objects.equal(safeToDeleteIds, that.safeToDeleteIds);
   }
 
   @Override
   public int hashCode() {
-    return Objects.hashCode(messagesToDelete);
+    return Objects.hashCode(safeToDeleteIds);
   }
 }
diff --git a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsMessage.java b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsMessage.java
index e0e8daaa086..ba895d466a9 100644
--- a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsMessage.java
+++ b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsMessage.java
@@ -30,8 +30,12 @@ public abstract class SqsMessage implements Serializable {
 
   abstract @Nullable String getMessageId();
 
+  abstract @Nullable String getReceiptHandle();
+
   abstract @Nullable String getTimeStamp();
 
+  abstract @Nullable String getRequestTimeStamp();
+
   abstract Builder toBuilder();
 
   @AutoValue.Builder
@@ -40,20 +44,33 @@ public abstract class SqsMessage implements Serializable {
 
     abstract Builder setMessageId(String messageId);
 
+    abstract Builder setReceiptHandle(String receiptHandle);
+
     abstract Builder setTimeStamp(String timeStamp);
 
+    abstract Builder setRequestTimeStamp(String timeStamp);
+
     abstract SqsMessage build();
   }
 
-  static SqsMessage create(String body, String messageId, String timeStamp) {
+  static SqsMessage create(
+      String body,
+      String messageId,
+      String receiptHandle,
+      String timeStamp,
+      String requestTimeStamp) {
     checkArgument(body != null, "body can not be null");
     checkArgument(messageId != null, "messageId can not be null");
+    checkArgument(receiptHandle != null, "receiptHandle can not be null");
     checkArgument(timeStamp != null, "timeStamp can not be null");
+    checkArgument(requestTimeStamp != null, "requestTimeStamp can not be null");
 
     return new AutoValue_SqsMessage.Builder()
         .setBody(body)
         .setMessageId(messageId)
+        .setReceiptHandle(receiptHandle)
         .setTimeStamp(timeStamp)
+        .setRequestTimeStamp(requestTimeStamp)
         .build();
   }
 }
diff --git a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReader.java b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReader.java
index 3d65a430786..a6c7755ec64 100644
--- a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReader.java
+++ b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReader.java
@@ -17,19 +17,50 @@
  */
 package org.apache.beam.sdk.io.aws2.sqs;
 
-import java.io.Serializable;
-import java.nio.charset.StandardCharsets;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.toMap;
+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;
+import static software.amazon.awssdk.services.sqs.model.QueueAttributeName.VISIBILITY_TIMEOUT;
+
+import java.io.IOException;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collection;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.NoSuchElementException;
+import java.util.Objects;
 import java.util.Queue;
+import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 import org.apache.beam.sdk.io.UnboundedSource;
 import org.apache.beam.sdk.io.UnboundedSource.CheckpointMark;
+import org.apache.beam.sdk.transforms.Combine;
+import org.apache.beam.sdk.transforms.Sum;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
+import org.apache.beam.sdk.util.BucketingFunction;
+import org.apache.beam.sdk.util.MovingFunction;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;
+import org.joda.time.Duration;
 import org.joda.time.Instant;
-import software.amazon.awssdk.services.sqs.model.DeleteMessageRequest;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import software.amazon.awssdk.services.sqs.SqsClient;
+import software.amazon.awssdk.services.sqs.model.BatchResultErrorEntry;
+import software.amazon.awssdk.services.sqs.model.ChangeMessageVisibilityBatchRequest;
+import software.amazon.awssdk.services.sqs.model.ChangeMessageVisibilityBatchRequestEntry;
+import software.amazon.awssdk.services.sqs.model.ChangeMessageVisibilityBatchResponse;
+import software.amazon.awssdk.services.sqs.model.DeleteMessageBatchRequest;
+import software.amazon.awssdk.services.sqs.model.DeleteMessageBatchRequestEntry;
+import software.amazon.awssdk.services.sqs.model.DeleteMessageBatchResponse;
+import software.amazon.awssdk.services.sqs.model.GetQueueAttributesRequest;
 import software.amazon.awssdk.services.sqs.model.Message;
 import software.amazon.awssdk.services.sqs.model.MessageSystemAttributeName;
 import software.amazon.awssdk.services.sqs.model.ReceiveMessageRequest;
@@ -38,31 +69,319 @@ import software.amazon.awssdk.services.sqs.model.ReceiveMessageResponse;
 @SuppressWarnings({
   "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
 })
-class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage>
-    implements Serializable {
+class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
+  private static final Logger LOG = LoggerFactory.getLogger(SqsUnboundedReader.class);
 
+  /** Maximum number of messages to pull from SQS per request. */
   public static final int MAX_NUMBER_OF_MESSAGES = 10;
+
+  /** Maximum times to retry batch SQS operations upon partial success. */
+  private static final int BATCH_OPERATION_MAX_RETIRES = 5;
+
+  /** Timeout for round trip from receiving a message to finally deleting it from SQS. */
+  private static final Duration PROCESSING_TIMEOUT = Duration.standardMinutes(2);
+
+  /**
+   * Percentage of visibility timeout by which to extend visibility timeout when they are near
+   * timeout.
+   */
+  private static final int VISIBILITY_EXTENSION_PCT = 50;
+
+  /**
+   * Percentage of ack timeout we should use as a safety margin. We'll try to extend visibility
+   * timeout by this margin before the visibility timeout actually expires.
+   */
+  private static final int VISIBILITY_SAFETY_PCT = 20;
+
+  /**
+   * For stats only: How close we can get to an visibility deadline before we risk it being already
+   * considered passed by SQS.
+   */
+  private static final Duration VISIBILITY_TOO_LATE = Duration.standardSeconds(2);
+
+  /** Maximum number of message ids per delete or visibility extension call. */
+  private static final int DELETE_BATCH_SIZE = 10;
+
+  /** Maximum number of messages in flight. */
+  private static final int MAX_IN_FLIGHT = 20000;
+
+  /** Period of samples to determine watermark and other stats. */
+  private static final Duration SAMPLE_PERIOD = Duration.standardMinutes(1);
+
+  /** Period of updates to determine watermark and other stats. */
+  private static final Duration SAMPLE_UPDATE = Duration.standardSeconds(5);
+
+  /** Period for logging stats. */
+  private static final Duration LOG_PERIOD = Duration.standardSeconds(30);
+
+  /** Minimum number of unread messages required before considering updating watermark. */
+  private static final int MIN_WATERMARK_MESSAGES = 10;
+
+  /**
+   * Minimum number of SAMPLE_UPDATE periods over which unread messages should be spread before
+   * considering updating watermark.
+   */
+  private static final int MIN_WATERMARK_SPREAD = 2;
+
+  // TODO: Would prefer to use MinLongFn but it is a BinaryCombineFn<Long> rather
+  // than a BinaryCombineLongFn. [BEAM-285]
+  private static final Combine.BinaryCombineLongFn MIN =
+      new Combine.BinaryCombineLongFn() {
+        @Override
+        public long apply(long left, long right) {
+          return Math.min(left, right);
+        }
+
+        @Override
+        public long identity() {
+          return Long.MAX_VALUE;
+        }
+      };
+
+  private static final Combine.BinaryCombineLongFn MAX =
+      new Combine.BinaryCombineLongFn() {
+        @Override
+        public long apply(long left, long right) {
+          return Math.max(left, right);
+        }
+
+        @Override
+        public long identity() {
+          return Long.MIN_VALUE;
+        }
+      };
+
+  private static final Combine.BinaryCombineLongFn SUM = Sum.ofLongs();
+
+  /** For access to topic and SQS client. */
   private final SqsUnboundedSource source;
+
+  /**
+   * The closed state of this {@link SqsUnboundedReader}. If true, the reader has not yet been
+   * closed, and it will have a non-null value within {@link #SqsUnboundedReader}.
+   */
+  private AtomicBoolean active = new AtomicBoolean(true);
+
+  /** The current message, or {@literal null} if none. */
   private SqsMessage current;
-  private final Queue<Message> messagesNotYetRead;
-  private List<Message> messagesToDelete;
-  private Instant oldestPendingTimestamp = BoundedWindow.TIMESTAMP_MIN_VALUE;
 
-  public SqsUnboundedReader(SqsUnboundedSource source, SqsCheckpointMark sqsCheckpointMark) {
+  /**
+   * Messages we have received from SQS and not yet delivered downstream. We preserve their order.
+   */
+  private final Queue<SqsMessage> messagesNotYetRead;
+
+  /** Message ids of messages we have delivered downstream but not yet deleted. */
+  private Set<String> safeToDeleteIds;
+
+  /**
+   * Visibility timeout, in ms, as set on subscription when we first start reading. Not updated
+   * thereafter. -1 if not yet determined.
+   */
+  private long visibilityTimeoutMs;
+
+  /** Byte size of undecoded elements in {@link #messagesNotYetRead}. */
+  private long notYetReadBytes;
+
+  /**
+   * Bucketed map from received time (as system time, ms since epoch) to message timestamps (mssince
+   * epoch) of all received but not-yet read messages. Used to estimate watermark.
+   */
+  private BucketingFunction minUnreadTimestampMsSinceEpoch;
+
+  /**
+   * Minimum of timestamps (ms since epoch) of all recently read messages. Used to estimate
+   * watermark.
+   */
+  private MovingFunction minReadTimestampMsSinceEpoch;
+
+  private static class InFlightState {
+    /** Receipt handle of message. */
+    String receiptHandle;
+
+    /** When request which yielded message was issued. */
+    long requestTimeMsSinceEpoch;
+
+    /**
+     * When SQS will consider this message's visibility timeout to timeout and thus it needs to be
+     * extended.
+     */
+    long visibilityDeadlineMsSinceEpoch;
+
+    public InFlightState(
+        String receiptHandle, long requestTimeMsSinceEpoch, long visibilityDeadlineMsSinceEpoch) {
+      this.receiptHandle = receiptHandle;
+      this.requestTimeMsSinceEpoch = requestTimeMsSinceEpoch;
+      this.visibilityDeadlineMsSinceEpoch = visibilityDeadlineMsSinceEpoch;
+    }
+  }
+
+  /**
+   * Map from message ids of messages we have received from SQS but not yet deleted to their in
+   * flight state. Ordered from earliest to latest visibility deadline.
+   */
+  private final LinkedHashMap<String, InFlightState> inFlight;
+
+  /**
+   * Batches of successfully deleted message ids which need to be pruned from the above. CAUTION:
+   * Accessed by both reader and checkpointing threads.
+   */
+  private final Queue<List<String>> deletedIds;
+
+  /**
+   * System time (ms since epoch) we last received a message from SQS, or -1 if not yet received any
+   * messages.
+   */
+  private long lastReceivedMsSinceEpoch;
+
+  /** The last reported watermark (ms since epoch), or beginning of time if none yet reported. */
+  private long lastWatermarkMsSinceEpoch;
+
+  /** Stats only: System time (ms since epoch) we last logs stats, or -1 if never. */
+  private long lastLogTimestampMsSinceEpoch;
+
+  /** Stats only: Total number of messages received. */
+  private long numReceived;
+
+  /** Stats only: Number of messages which have recently been received. */
+  private MovingFunction numReceivedRecently;
+
+  /** Stats only: Number of messages which have recently had their deadline extended. */
+  private MovingFunction numExtendedDeadlines;
+
+  /**
+   * Stats only: Number of messages which have recently had their deadline extended even though it
+   * may be too late to do so.
+   */
+  private MovingFunction numLateDeadlines;
+
+  /** Stats only: Number of messages which have recently been deleted. */
+  private MovingFunction numDeleted;
+
+  /**
+   * Stats only: Number of messages which have recently expired (visibility timeout were extended
+   * for too long).
+   */
+  private MovingFunction numExpired;
+
+  /** Stats only: Number of messages which have recently been returned to visible on SQS. */
+  private MovingFunction numReleased;
+
+  /** Stats only: Number of message bytes which have recently been read by downstream consumer. */
+  private MovingFunction numReadBytes;
+
+  /**
+   * Stats only: Minimum of timestamp (ms since epoch) of all recently received messages. Used to
+   * estimate timestamp skew. Does not contribute to watermark estimator.
+   */
+  private MovingFunction minReceivedTimestampMsSinceEpoch;
+
+  /**
+   * Stats only: Maximum of timestamp (ms since epoch) of all recently received messages. Used to
+   * estimate timestamp skew.
+   */
+  private MovingFunction maxReceivedTimestampMsSinceEpoch;
+
+  /** Stats only: Minimum of recent estimated watermarks (ms since epoch). */
+  private MovingFunction minWatermarkMsSinceEpoch;
+
+  /** Stats ony: Maximum of recent estimated watermarks (ms since epoch). */
+  private MovingFunction maxWatermarkMsSinceEpoch;
+
+  /**
+   * Stats only: Number of messages with timestamps strictly behind the estimated watermark at the
+   * time they are received. These may be considered 'late' by downstream computations.
+   */
+  private MovingFunction numLateMessages;
+
+  /**
+   * Stats only: Current number of checkpoints in flight. CAUTION: Accessed by both checkpointing
+   * and reader threads.
+   */
+  AtomicInteger numInFlightCheckpoints;
+
+  /** Stats only: Maximum number of checkpoints in flight at any time. */
+  private int maxInFlightCheckpoints;
+
+  private static MovingFunction newFun(Combine.BinaryCombineLongFn function) {
+    return new MovingFunction(
+        SAMPLE_PERIOD.getMillis(),
+        SAMPLE_UPDATE.getMillis(),
+        MIN_WATERMARK_SPREAD,
+        MIN_WATERMARK_MESSAGES,
+        function);
+  }
+
+  public SqsUnboundedReader(SqsUnboundedSource source, SqsCheckpointMark sqsCheckpointMark)
+      throws IOException {
     this.source = source;
-    this.current = null;
 
-    this.messagesNotYetRead = new ArrayDeque<>();
-    this.messagesToDelete = new ArrayList<>();
+    messagesNotYetRead = new ArrayDeque<>();
+    safeToDeleteIds = new HashSet<>();
+    inFlight = new LinkedHashMap<>();
+    deletedIds = new ConcurrentLinkedQueue<>();
+    visibilityTimeoutMs = -1;
+    notYetReadBytes = 0;
+    minUnreadTimestampMsSinceEpoch =
+        new BucketingFunction(
+            SAMPLE_UPDATE.getMillis(), MIN_WATERMARK_SPREAD, MIN_WATERMARK_MESSAGES, MIN);
+    minReadTimestampMsSinceEpoch = newFun(MIN);
+    lastReceivedMsSinceEpoch = -1;
+    lastWatermarkMsSinceEpoch = BoundedWindow.TIMESTAMP_MIN_VALUE.getMillis();
+    current = null;
+    lastLogTimestampMsSinceEpoch = -1;
+    numReceived = 0L;
+    numReceivedRecently = newFun(SUM);
+    numExtendedDeadlines = newFun(SUM);
+    numLateDeadlines = newFun(SUM);
+    numDeleted = newFun(SUM);
+    numExpired = newFun(SUM);
+    numReleased = newFun(SUM);
+    numReadBytes = newFun(SUM);
+    minReceivedTimestampMsSinceEpoch = newFun(MIN);
+    maxReceivedTimestampMsSinceEpoch = newFun(MAX);
+    minWatermarkMsSinceEpoch = newFun(MIN);
+    maxWatermarkMsSinceEpoch = newFun(MAX);
+    numLateMessages = newFun(SUM);
+    numInFlightCheckpoints = new AtomicInteger();
+    maxInFlightCheckpoints = 0;
 
     if (sqsCheckpointMark != null) {
-      this.messagesToDelete.addAll(sqsCheckpointMark.getMessagesToDelete());
+      long nowMsSinceEpoch = now();
+      extendBatch(nowMsSinceEpoch, sqsCheckpointMark.notYetReadReceipts, 0);
+      numReleased.add(nowMsSinceEpoch, sqsCheckpointMark.notYetReadReceipts.size());
     }
   }
 
   @Override
   public Instant getWatermark() {
-    return oldestPendingTimestamp;
+
+    // NOTE: We'll allow the watermark to go backwards. The underlying runner is responsible
+    // for aggregating all reported watermarks and ensuring the aggregate is latched.
+    // If we attempt to latch locally then it is possible a temporary starvation of one reader
+    // could cause its estimated watermark to fast forward to current system time. Then when
+    // the reader resumes its watermark would be unable to resume tracking.
+    // By letting the underlying runner latch we avoid any problems due to localized starvation.
+    long nowMsSinceEpoch = now();
+    long readMin = minReadTimestampMsSinceEpoch.get(nowMsSinceEpoch);
+    long unreadMin = minUnreadTimestampMsSinceEpoch.get();
+    if (readMin == Long.MAX_VALUE
+        && unreadMin == Long.MAX_VALUE
+        && lastReceivedMsSinceEpoch >= 0
+        && nowMsSinceEpoch > lastReceivedMsSinceEpoch + SAMPLE_PERIOD.getMillis()) {
+      // We don't currently have any unread messages pending, we have not had any messages
+      // read for a while, and we have not received any new messages from SQS for a while.
+      // Advance watermark to current time.
+      // TODO: Estimate a timestamp lag.
+      lastWatermarkMsSinceEpoch = nowMsSinceEpoch;
+    } else if (minReadTimestampMsSinceEpoch.isSignificant()
+        || minUnreadTimestampMsSinceEpoch.isSignificant()) {
+      // Take minimum of the timestamps in all unread messages and recently read messages.
+      lastWatermarkMsSinceEpoch = Math.min(readMin, unreadMin);
+    }
+    // else: We're not confident enough to estimate a new watermark. Stick with the old one.
+    minWatermarkMsSinceEpoch.add(nowMsSinceEpoch, lastWatermarkMsSinceEpoch);
+    maxWatermarkMsSinceEpoch.add(nowMsSinceEpoch, lastWatermarkMsSinceEpoch);
+    return new Instant(lastWatermarkMsSinceEpoch);
   }
 
   @Override
@@ -87,12 +406,19 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage>
     if (current == null) {
       throw new NoSuchElementException();
     }
-    return current.getMessageId().getBytes(StandardCharsets.UTF_8);
+    return current.getMessageId().getBytes(UTF_8);
   }
 
   @Override
   public CheckpointMark getCheckpointMark() {
-    return new SqsCheckpointMark(this, messagesToDelete);
+    int cur = numInFlightCheckpoints.incrementAndGet();
+    maxInFlightCheckpoints = Math.max(maxInFlightCheckpoints, cur);
+    List<String> snapshotSafeToDeleteIds = Lists.newArrayList(safeToDeleteIds);
+    List<String> snapshotNotYetReadReceipts = new ArrayList<>(messagesNotYetRead.size());
+    for (SqsMessage message : messagesNotYetRead) {
+      snapshotNotYetReadReceipts.add(message.getReceiptHandle());
+    }
+    return new SqsCheckpointMark(this, snapshotSafeToDeleteIds, snapshotNotYetReadReceipts);
   }
 
   @Override
@@ -101,66 +427,205 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage>
   }
 
   @Override
-  public boolean start() {
+  public boolean start() throws IOException {
+    visibilityTimeoutMs =
+        Integer.parseInt(
+                source
+                    .getSqs()
+                    .getQueueAttributes(
+                        GetQueueAttributesRequest.builder()
+                            .queueUrl(source.getRead().queueUrl())
+                            .attributeNames(VISIBILITY_TIMEOUT)
+                            .build())
+                    .attributes()
+                    .get(VISIBILITY_TIMEOUT))
+            * 1000L;
     return advance();
   }
 
   @Override
-  public boolean advance() {
+  public boolean advance() throws IOException {
+    // Emit stats.
+    stats();
+
+    if (current != null) {
+      // Current is consumed. It can no longer contribute to holding back the watermark.
+      minUnreadTimestampMsSinceEpoch.remove(Long.parseLong(current.getRequestTimeStamp()));
+      current = null;
+    }
+
+    // Retire state associated with deleted messages.
+    retire();
+
+    // Extend all pressing deadlines.
+    // Will BLOCK until done.
+    // If the system is pulling messages only to let them sit in a downstream queue then
+    // this will have the effect of slowing down the pull rate.
+    // However, if the system is genuinely taking longer to process each message then
+    // the work to extend visibility timeout would be better done in the background.
+    extend();
+
     if (messagesNotYetRead.isEmpty()) {
+      // Pull another batch.
+      // Will BLOCK until fetch returns, but will not block until a message is available.
       pull();
     }
 
-    Message orgMsg = messagesNotYetRead.poll();
-    if (orgMsg != null) {
-      String timeStamp =
-          orgMsg.attributes().get(MessageSystemAttributeName.APPROXIMATE_FIRST_RECEIVE_TIMESTAMP);
-      current = SqsMessage.create(orgMsg.body(), orgMsg.messageId(), timeStamp);
-    } else {
+    // Take one message from queue.
+    current = messagesNotYetRead.poll();
+    if (current == null) {
+      // Try again later.
       return false;
     }
-
-    messagesToDelete.add(orgMsg);
-
-    Instant currentMessageTimestamp = getCurrentTimestamp();
-    if (getCurrentTimestamp().isBefore(oldestPendingTimestamp)) {
-      oldestPendingTimestamp = currentMessageTimestamp;
+    notYetReadBytes -= current.getBody().getBytes(UTF_8).length;
+    checkState(notYetReadBytes >= 0);
+    long nowMsSinceEpoch = now();
+    numReadBytes.add(nowMsSinceEpoch, current.getBody().getBytes(UTF_8).length);
+    minReadTimestampMsSinceEpoch.add(nowMsSinceEpoch, getCurrentTimestamp().getMillis());
+    ;
+    if (getCurrentTimestamp().getMillis() < lastWatermarkMsSinceEpoch) {
+      numLateMessages.add(nowMsSinceEpoch, 1L);
     }
 
+    // Current message can be considered 'read' and will be persisted by the next
+    // checkpoint. So it is now safe to delete from SQS.
+    safeToDeleteIds.add(current.getMessageId());
+
     return true;
   }
 
+  /**
+   * {@inheritDoc}.
+   *
+   * <p>Marks this {@link SqsUnboundedReader} as no longer active. The {@link SqsClient} continue to
+   * exist and be active beyond the life of this call if there are any in-flight checkpoints. When
+   * no in-flight checkpoints remain, the reader will be closed.
+   */
   @Override
-  public void close() {}
-
-  void delete(final Collection<Message> messages) {
-    for (Message message : messages) {
-      if (messagesToDelete.contains(message)) {
-        DeleteMessageRequest deleteMessageRequest =
-            DeleteMessageRequest.builder()
-                .queueUrl(source.getRead().queueUrl())
-                .receiptHandle(message.receiptHandle())
-                .build();
-
-        source.getSqs().deleteMessage(deleteMessageRequest);
-        Instant currentMessageTimestamp =
-            getTimestamp(
-                message
-                    .attributes()
-                    .get(MessageSystemAttributeName.APPROXIMATE_FIRST_RECEIVE_TIMESTAMP));
-        if (currentMessageTimestamp.isAfter(oldestPendingTimestamp)) {
-          oldestPendingTimestamp = currentMessageTimestamp;
-        }
+  public void close() throws IOException {
+    active.set(false);
+    maybeCloseClient();
+  }
+
+  /**
+   * Close this reader's underlying {@link SqsClient} if the reader has been closed and there are no
+   * outstanding checkpoints.
+   */
+  void maybeCloseClient() throws IOException {
+    if (!active.get() && numInFlightCheckpoints.get() == 0) {
+      // The reader has been closed and it has no more outstanding checkpoints. The client
+      // must be closed so it doesn't leak
+      SqsClient client = source.getSqs();
+      if (client != null) {
+        client.close();
       }
     }
   }
 
+  /** delete the provided {@code messageIds} from SQS. */
+  void delete(List<String> messageIds) throws IOException {
+    AtomicInteger counter = new AtomicInteger();
+    for (List<String> messageList :
+        messageIds.stream()
+            .collect(groupingBy(x -> counter.getAndIncrement() / DELETE_BATCH_SIZE))
+            .values()) {
+      deleteBatch(messageList);
+    }
+  }
+
+  /**
+   * delete the provided {@code messageIds} from SQS, blocking until all of the messages are
+   * deleted.
+   *
+   * <p>CAUTION: May be invoked from a separate thread.
+   *
+   * <p>CAUTION: Retains {@code messageIds}.
+   */
+  private void deleteBatch(List<String> messageIds) throws IOException {
+    int retries = 0;
+    Map<String, String> pendingReceipts =
+        IntStream.range(0, messageIds.size())
+            .boxed()
+            .filter(i -> inFlight.containsKey(messageIds.get(i)))
+            .collect(toMap(Object::toString, i -> inFlight.get(messageIds.get(i)).receiptHandle));
+
+    while (!pendingReceipts.isEmpty()) {
+
+      if (retries >= BATCH_OPERATION_MAX_RETIRES) {
+        throw new IOException(
+            "Failed to extend visibility timeout for "
+                + pendingReceipts.size()
+                + " messages after "
+                + retries
+                + " retries");
+      }
+
+      List<DeleteMessageBatchRequestEntry> entries =
+          pendingReceipts.entrySet().stream()
+              .map(
+                  r ->
+                      DeleteMessageBatchRequestEntry.builder()
+                          .id(r.getKey())
+                          .receiptHandle(r.getValue())
+                          .build())
+              .collect(Collectors.toList());
+
+      DeleteMessageBatchResponse result =
+          source
+              .getSqs()
+              .deleteMessageBatch(
+                  DeleteMessageBatchRequest.builder()
+                      .queueUrl(source.getRead().queueUrl())
+                      .entries(entries)
+                      .build());
+
+      // Reflect failed message IDs to map
+      pendingReceipts
+          .keySet()
+          .retainAll(
+              result.failed().stream().map(BatchResultErrorEntry::id).collect(Collectors.toSet()));
+
+      retries += 1;
+    }
+    deletedIds.add(messageIds);
+  }
+
+  /**
+   * Messages which have been deleted (via the checkpoint finalize) are no longer in flight. This is
+   * only used for flow control and stats.
+   */
+  private void retire() {
+    long nowMsSinceEpoch = now();
+    while (true) {
+      List<String> ackIds = deletedIds.poll();
+      if (ackIds == null) {
+        return;
+      }
+      numDeleted.add(nowMsSinceEpoch, ackIds.size());
+      for (String ackId : ackIds) {
+        inFlight.remove(ackId);
+        safeToDeleteIds.remove(ackId);
+      }
+    }
+  }
+
+  /** BLOCKING Fetch another batch of messages from SQS. */
   private void pull() {
+    if (inFlight.size() >= MAX_IN_FLIGHT) {
+      // Wait for checkpoint to be finalized before pulling anymore.
+      // There may be lag while checkpoints are persisted and the finalizeCheckpoint method
+      // is invoked. By limiting the in-flight messages we can ensure we don't end up consuming
+      // messages faster than we can checkpoint them.
+      return;
+    }
+
+    long requestTimeMsSinceEpoch = now();
+    long deadlineMsSinceEpoch = requestTimeMsSinceEpoch + visibilityTimeoutMs;
+
     final ReceiveMessageRequest receiveMessageRequest =
         ReceiveMessageRequest.builder()
             .maxNumberOfMessages(MAX_NUMBER_OF_MESSAGES)
-            .attributeNamesWithStrings(
-                MessageSystemAttributeName.APPROXIMATE_FIRST_RECEIVE_TIMESTAMP.toString())
+            .attributeNamesWithStrings(MessageSystemAttributeName.SENT_TIMESTAMP.toString())
             .queueUrl(source.getRead().queueUrl())
             .build();
 
@@ -173,7 +638,270 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage>
       return;
     }
 
-    messagesNotYetRead.addAll(messages);
+    lastReceivedMsSinceEpoch = requestTimeMsSinceEpoch;
+
+    // Capture the received messages.
+    for (Message orgMsg : messages) {
+      String timeStamp = orgMsg.attributes().get(MessageSystemAttributeName.SENT_TIMESTAMP);
+      String requestTimeStamp = Long.toString(requestTimeMsSinceEpoch);
+      SqsMessage message =
+          SqsMessage.create(
+              orgMsg.body(),
+              orgMsg.messageId(),
+              orgMsg.receiptHandle(),
+              timeStamp,
+              requestTimeStamp);
+      messagesNotYetRead.add(message);
+      notYetReadBytes += message.getBody().getBytes(UTF_8).length;
+      inFlight.put(
+          message.getMessageId(),
+          new InFlightState(
+              message.getReceiptHandle(), requestTimeMsSinceEpoch, deadlineMsSinceEpoch));
+      numReceived++;
+      numReceivedRecently.add(requestTimeMsSinceEpoch, 1L);
+      minReceivedTimestampMsSinceEpoch.add(
+          requestTimeMsSinceEpoch, getTimestamp(message.getTimeStamp()).getMillis());
+      maxReceivedTimestampMsSinceEpoch.add(
+          requestTimeMsSinceEpoch, getTimestamp(message.getTimeStamp()).getMillis());
+      minUnreadTimestampMsSinceEpoch.add(
+          requestTimeMsSinceEpoch, getTimestamp(message.getTimeStamp()).getMillis());
+    }
+  }
+
+  /** Return the current time, in ms since epoch. */
+  long now() {
+    return System.currentTimeMillis();
+  }
+
+  /**
+   * BLOCKING Extend deadline for all messages which need it. CAUTION: If extensions can't keep up
+   * with wallclock then we'll never return.
+   */
+  private void extend() throws IOException {
+    while (true) {
+      long nowMsSinceEpoch = now();
+      List<String> assumeExpired = new ArrayList<>();
+      List<String> toBeExtended = new ArrayList<>();
+      List<String> toBeExpired = new ArrayList<>();
+      // Messages will be in increasing deadline order.
+      for (Map.Entry<String, InFlightState> entry : inFlight.entrySet()) {
+        if (entry.getValue().visibilityDeadlineMsSinceEpoch
+                - (visibilityTimeoutMs * VISIBILITY_SAFETY_PCT) / 100
+            > nowMsSinceEpoch) {
+          // All remaining messages don't need their visibility timeouts to be extended.
+          break;
+        }
+
+        if (entry.getValue().visibilityDeadlineMsSinceEpoch - VISIBILITY_TOO_LATE.getMillis()
+            < nowMsSinceEpoch) {
+          // SQS may have already considered this message to have expired.
+          // If so it will (eventually) be made available on a future pull request.
+          // If this message ends up being committed then it will be considered a duplicate
+          // when re-pulled.
+          assumeExpired.add(entry.getKey());
+          continue;
+        }
+
+        if (entry.getValue().requestTimeMsSinceEpoch + PROCESSING_TIMEOUT.getMillis()
+            < nowMsSinceEpoch) {
+          // This message has been in-flight for too long.
+          // Give up on it, otherwise we risk extending its visibility timeout indefinitely.
+          toBeExpired.add(entry.getKey());
+          continue;
+        }
+
+        // Extend the visibility timeout for this message.
+        toBeExtended.add(entry.getKey());
+        if (toBeExtended.size() >= DELETE_BATCH_SIZE) {
+          // Enough for one batch.
+          break;
+        }
+      }
+
+      if (assumeExpired.isEmpty() && toBeExtended.isEmpty() && toBeExpired.isEmpty()) {
+        // Nothing to be done.
+        return;
+      }
+
+      if (!assumeExpired.isEmpty()) {
+        // If we didn't make the visibility deadline assume expired and no longer in flight.
+        numLateDeadlines.add(nowMsSinceEpoch, assumeExpired.size());
+        for (String messageId : assumeExpired) {
+          inFlight.remove(messageId);
+        }
+      }
+
+      if (!toBeExpired.isEmpty()) {
+        // Expired messages are no longer considered in flight.
+        numExpired.add(nowMsSinceEpoch, toBeExpired.size());
+        for (String messageId : toBeExpired) {
+          inFlight.remove(messageId);
+        }
+      }
+
+      if (!toBeExtended.isEmpty()) {
+        // SQS extends visibility timeout from it's notion of current time.
+        // We'll try to track that on our side, but note the deadlines won't necessarily agree.
+        long extensionMs = (int) ((visibilityTimeoutMs * VISIBILITY_EXTENSION_PCT) / 100L);
+        long newDeadlineMsSinceEpoch = nowMsSinceEpoch + extensionMs;
+        for (String messageId : toBeExtended) {
+          // Maintain increasing ack deadline order.
+          String receiptHandle = inFlight.get(messageId).receiptHandle;
+          InFlightState state = inFlight.remove(messageId);
+          inFlight.put(
+              messageId,
+              new InFlightState(
+                  receiptHandle, state.requestTimeMsSinceEpoch, newDeadlineMsSinceEpoch));
+        }
+        List<String> receiptHandles =
+            toBeExtended.stream()
+                .map(inFlight::get)
+                .filter(Objects::nonNull) // get rid of null values
+                .map(m -> m.receiptHandle)
+                .collect(Collectors.toList());
+        // BLOCKs until extended.
+        extendBatch(nowMsSinceEpoch, receiptHandles, (int) (extensionMs / 1000));
+      }
+    }
+  }
+
+  /**
+   * BLOCKING Extend the visibility timeout for messages from SQS with the given {@code
+   * receiptHandles}.
+   */
+  void extendBatch(long nowMsSinceEpoch, List<String> receiptHandles, int extensionSec)
+      throws IOException {
+    int retries = 0;
+    int numMessages = receiptHandles.size();
+    Map<String, String> pendingReceipts =
+        IntStream.range(0, receiptHandles.size())
+            .boxed()
+            .collect(toMap(Object::toString, receiptHandles::get));
+
+    while (!pendingReceipts.isEmpty()) {
+
+      if (retries >= BATCH_OPERATION_MAX_RETIRES) {
+        throw new IOException(
+            "Failed to extend visibility timeout for "
+                + receiptHandles.size()
+                + " messages after "
+                + retries
+                + " retries");
+      }
+
+      List<ChangeMessageVisibilityBatchRequestEntry> entries =
+          pendingReceipts.entrySet().stream()
+              .map(
+                  r ->
+                      ChangeMessageVisibilityBatchRequestEntry.builder()
+                          .id(r.getKey())
+                          .receiptHandle(r.getValue())
+                          .visibilityTimeout(extensionSec)
+                          .build())
+              .collect(Collectors.toList());
+
+      ChangeMessageVisibilityBatchResponse response =
+          source
+              .getSqs()
+              .changeMessageVisibilityBatch(
+                  ChangeMessageVisibilityBatchRequest.builder()
+                      .queueUrl(source.getRead().queueUrl())
+                      .entries(entries)
+                      .build());
+
+      pendingReceipts
+          .keySet()
+          .retainAll(
+              response.failed().stream()
+                  .map(BatchResultErrorEntry::id)
+                  .collect(Collectors.toSet()));
+
+      retries += 1;
+    }
+    numExtendedDeadlines.add(nowMsSinceEpoch, numMessages);
+  }
+
+  /** Log stats if time to do so. */
+  private void stats() {
+    long nowMsSinceEpoch = now();
+    if (lastLogTimestampMsSinceEpoch < 0) {
+      lastLogTimestampMsSinceEpoch = nowMsSinceEpoch;
+      return;
+    }
+    long deltaMs = nowMsSinceEpoch - lastLogTimestampMsSinceEpoch;
+    if (deltaMs < LOG_PERIOD.getMillis()) {
+      return;
+    }
+
+    String messageSkew = "unknown";
+    long minTimestamp = minReceivedTimestampMsSinceEpoch.get(nowMsSinceEpoch);
+    long maxTimestamp = maxReceivedTimestampMsSinceEpoch.get(nowMsSinceEpoch);
+    if (minTimestamp < Long.MAX_VALUE && maxTimestamp > Long.MIN_VALUE) {
+      messageSkew = (maxTimestamp - minTimestamp) + "ms";
+    }
+
+    String watermarkSkew = "unknown";
+    long minWatermark = minWatermarkMsSinceEpoch.get(nowMsSinceEpoch);
+    long maxWatermark = maxWatermarkMsSinceEpoch.get(nowMsSinceEpoch);
+    if (minWatermark < Long.MAX_VALUE && maxWatermark > Long.MIN_VALUE) {
+      watermarkSkew = (maxWatermark - minWatermark) + "ms";
+    }
+
+    String oldestInFlight = "no";
+    String oldestAckId = Iterables.getFirst(inFlight.keySet(), null);
+    if (oldestAckId != null) {
+      oldestInFlight = (nowMsSinceEpoch - inFlight.get(oldestAckId).requestTimeMsSinceEpoch) + "ms";
+    }
+
+    LOG.info(
+        "SQS {} has "
+            + "{} received messages, "
+            + "{} current unread messages, "
+            + "{} current unread bytes, "
+            + "{} current in-flight msgs, "
+            + "{} oldest in-flight, "
+            + "{} current in-flight checkpoints, "
+            + "{} max in-flight checkpoints, "
+            + "{}B/s recent read, "
+            + "{} recent received, "
+            + "{} recent extended, "
+            + "{} recent late extended, "
+            + "{} recent deleted, "
+            + "{} recent released, "
+            + "{} recent expired, "
+            + "{} recent message timestamp skew, "
+            + "{} recent watermark skew, "
+            + "{} recent late messages, "
+            + "{} last reported watermark, "
+            + "{} min recent read timestamp (significance = {}), "
+            + "{} min recent unread timestamp (significance = {}), "
+            + "{} last receive timestamp",
+        source.getRead().queueUrl(),
+        numReceived,
+        messagesNotYetRead.size(),
+        notYetReadBytes,
+        inFlight.size(),
+        oldestInFlight,
+        numInFlightCheckpoints.get(),
+        maxInFlightCheckpoints,
+        numReadBytes.get(nowMsSinceEpoch) / (SAMPLE_PERIOD.getMillis() / 1000L),
+        numReceivedRecently.get(nowMsSinceEpoch),
+        numExtendedDeadlines.get(nowMsSinceEpoch),
+        numLateDeadlines.get(nowMsSinceEpoch),
+        numDeleted.get(nowMsSinceEpoch),
+        numReleased.get(nowMsSinceEpoch),
+        numExpired.get(nowMsSinceEpoch),
+        messageSkew,
+        watermarkSkew,
+        numLateMessages.get(nowMsSinceEpoch),
+        new Instant(lastWatermarkMsSinceEpoch),
+        new Instant(minReadTimestampMsSinceEpoch.get(nowMsSinceEpoch)),
+        minReadTimestampMsSinceEpoch.isSignificant(),
+        new Instant(minUnreadTimestampMsSinceEpoch.get()),
+        minUnreadTimestampMsSinceEpoch.isSignificant(),
+        new Instant(lastReceivedMsSinceEpoch));
+
+    lastLogTimestampMsSinceEpoch = nowMsSinceEpoch;
   }
 
   private Instant getTimestamp(String timeStamp) {
diff --git a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedSource.java b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedSource.java
index b794b33b838..96a616504ce 100644
--- a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedSource.java
+++ b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedSource.java
@@ -17,6 +17,7 @@
  */
 package org.apache.beam.sdk.io.aws2.sqs;
 
+import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
@@ -56,7 +57,11 @@ class SqsUnboundedSource extends UnboundedSource<SqsMessage, SqsCheckpointMark>
   @Override
   public UnboundedReader<SqsMessage> createReader(
       PipelineOptions options, @Nullable SqsCheckpointMark checkpointMark) {
-    return new SqsUnboundedReader(this, checkpointMark);
+    try {
+      return new SqsUnboundedReader(this, checkpointMark);
+    } catch (IOException e) {
+      throw new RuntimeException("Unable to subscribe to " + read.queueUrl() + ": ", e);
+    }
   }
 
   @Override
diff --git a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/EmbeddedSqsServer.java b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/EmbeddedSqsServer.java
index 2b826931297..8f532e5a955 100644
--- a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/EmbeddedSqsServer.java
+++ b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/EmbeddedSqsServer.java
@@ -20,6 +20,7 @@ package org.apache.beam.sdk.io.aws2.sqs;
 import java.net.URI;
 import org.elasticmq.rest.sqs.SQSRestServer;
 import org.elasticmq.rest.sqs.SQSRestServerBuilder;
+import org.junit.rules.ExternalResource;
 import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
 import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
 import software.amazon.awssdk.regions.Region;
@@ -27,7 +28,7 @@ import software.amazon.awssdk.services.sqs.SqsClient;
 import software.amazon.awssdk.services.sqs.model.CreateQueueRequest;
 import software.amazon.awssdk.services.sqs.model.CreateQueueResponse;
 
-class EmbeddedSqsServer {
+class EmbeddedSqsServer extends ExternalResource {
   private static SQSRestServer sqsRestServer;
   private static SqsClient client;
   private static String queueUrl;
@@ -35,7 +36,8 @@ class EmbeddedSqsServer {
   private static String endPoint = String.format("http://localhost:%d", port);
   private static String queueName = "test";
 
-  static void start() {
+  @Override
+  protected void before() {
     sqsRestServer = SQSRestServerBuilder.withPort(port).start();
 
     client =
@@ -52,15 +54,16 @@ class EmbeddedSqsServer {
     queueUrl = queue.queueUrl();
   }
 
-  static SqsClient getClient() {
+  public SqsClient getClient() {
     return client;
   }
 
-  static String getQueueUrl() {
+  public String getQueueUrl() {
     return queueUrl;
   }
 
-  static void stop() {
+  @Override
+  protected void after() {
     sqsRestServer.stopAndWait();
   }
 }
diff --git a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsIOTest.java b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsIOTest.java
index a3416dc2810..249f13f8038 100644
--- a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsIOTest.java
+++ b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsIOTest.java
@@ -17,22 +17,25 @@
  */
 package org.apache.beam.sdk.io.aws2.sqs;
 
+import static junit.framework.TestCase.assertFalse;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
+import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
-import org.apache.beam.sdk.testing.PAssert;
+import org.apache.beam.sdk.io.UnboundedSource;
+import org.apache.beam.sdk.testing.CoderProperties;
 import org.apache.beam.sdk.testing.TestPipeline;
-import org.apache.beam.sdk.transforms.Count;
 import org.apache.beam.sdk.transforms.Create;
-import org.apache.beam.sdk.values.PCollection;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
+import org.apache.beam.sdk.util.CoderUtils;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import software.amazon.awssdk.services.sqs.SqsClient;
+import software.amazon.awssdk.services.sqs.model.ChangeMessageVisibilityRequest;
 import software.amazon.awssdk.services.sqs.model.Message;
 import software.amazon.awssdk.services.sqs.model.ReceiveMessageRequest;
 import software.amazon.awssdk.services.sqs.model.ReceiveMessageResponse;
@@ -40,36 +43,174 @@ import software.amazon.awssdk.services.sqs.model.SendMessageRequest;
 
 /** Tests on {@link SqsIO}. */
 @RunWith(JUnit4.class)
+@SuppressWarnings({
+  "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
+})
 public class SqsIOTest {
+  private static final String DATA = "testData";
 
   @Rule public TestPipeline pipeline = TestPipeline.create();
 
-  @Test
-  public void testRead() {
-    final SqsClient client = EmbeddedSqsServer.getClient();
-    final String queueUrl = EmbeddedSqsServer.getQueueUrl();
+  @Rule public EmbeddedSqsServer embeddedSqsRestServer = new EmbeddedSqsServer();
+
+  private SqsUnboundedSource source;
 
-    final PCollection<SqsMessage> output =
-        pipeline.apply(
+  private void setupOneMessage() {
+    final SqsClient client = embeddedSqsRestServer.getClient();
+    final String queueUrl = embeddedSqsRestServer.getQueueUrl();
+    client.sendMessage(SendMessageRequest.builder().queueUrl(queueUrl).messageBody(DATA).build());
+    source =
+        new SqsUnboundedSource(
             SqsIO.read()
+                .withQueueUrl(queueUrl)
                 .withSqsClientProvider(SqsClientProviderMock.of(client))
+                .withMaxNumRecords(1));
+  }
+
+  private void setupMessages(List<String> messages) {
+    final SqsClient client = embeddedSqsRestServer.getClient();
+    final String queueUrl = embeddedSqsRestServer.getQueueUrl();
+    for (String message : messages) {
+      client.sendMessage(
+          SendMessageRequest.builder().queueUrl(queueUrl).messageBody(message).build());
+    }
+    source =
+        new SqsUnboundedSource(
+            SqsIO.read()
                 .withQueueUrl(queueUrl)
-                .withMaxNumRecords(100));
+                .withSqsClientProvider(SqsClientProviderMock.of(client))
+                .withMaxNumRecords(messages.size()));
+  }
 
-    PAssert.thatSingleton(output.apply(Count.globally())).isEqualTo(100L);
+  @Test
+  public void checkpointCoderIsSane() {
+    setupOneMessage();
+    CoderProperties.coderSerializable(source.getCheckpointMarkCoder());
+    // Since we only serialize/deserialize the 'notYetReadIds', and we don't want to make
+    // equals on checkpoints ignore those fields, we'll test serialization and deserialization
+    // of checkpoints in multipleReaders below.
+  }
 
+  @Test
+  public void readOneMessage() throws IOException {
+    setupOneMessage();
+    UnboundedSource.UnboundedReader<SqsMessage> reader =
+        source.createReader(pipeline.getOptions(), null);
+    // Read one message.
+    assertTrue(reader.start());
+    assertEquals(DATA, reader.getCurrent().getBody());
+    assertFalse(reader.advance());
+    // ACK the message.
+    UnboundedSource.CheckpointMark checkpoint = reader.getCheckpointMark();
+    checkpoint.finalizeCheckpoint();
+    reader.close();
+  }
+
+  @Test
+  public void timeoutAckAndRereadOneMessage() throws IOException {
+    setupOneMessage();
+    UnboundedSource.UnboundedReader<SqsMessage> reader =
+        source.createReader(pipeline.getOptions(), null);
+    SqsClient sqsClient = source.getSqs();
+    assertTrue(reader.start());
+    assertEquals(DATA, reader.getCurrent().getBody());
+    String receiptHandle = reader.getCurrent().getReceiptHandle();
+    // Set the message to timeout.
+    sqsClient.changeMessageVisibility(
+        ChangeMessageVisibilityRequest.builder()
+            .queueUrl(source.getRead().queueUrl())
+            .receiptHandle(receiptHandle)
+            .visibilityTimeout(0)
+            .build());
+    // We'll now receive the same message again.
+    assertTrue(reader.advance());
+    assertEquals(DATA, reader.getCurrent().getBody());
+    assertFalse(reader.advance());
+    // Now ACK the message.
+    UnboundedSource.CheckpointMark checkpoint = reader.getCheckpointMark();
+    checkpoint.finalizeCheckpoint();
+    reader.close();
+  }
+
+  @Test
+  public void multipleReaders() throws IOException {
+    List<String> incoming = new ArrayList<>();
+    for (int i = 0; i < 2; i++) {
+      incoming.add(String.format("data_%d", i));
+    }
+    setupMessages(incoming);
+    UnboundedSource.UnboundedReader<SqsMessage> reader =
+        source.createReader(pipeline.getOptions(), null);
+    // Consume two messages, only read one.
+    assertTrue(reader.start());
+    assertEquals("data_0", reader.getCurrent().getBody());
+
+    // Grab checkpoint.
+    SqsCheckpointMark checkpoint = (SqsCheckpointMark) reader.getCheckpointMark();
+    checkpoint.finalizeCheckpoint();
+    assertEquals(1, checkpoint.notYetReadReceipts.size());
+
+    // Read second message.
+    assertTrue(reader.advance());
+    assertEquals("data_1", reader.getCurrent().getBody());
+
+    // Restore from checkpoint.
+    byte[] checkpointBytes =
+        CoderUtils.encodeToByteArray(source.getCheckpointMarkCoder(), checkpoint);
+    checkpoint = CoderUtils.decodeFromByteArray(source.getCheckpointMarkCoder(), checkpointBytes);
+    assertEquals(1, checkpoint.notYetReadReceipts.size());
+
+    // Re-read second message.
+    reader = source.createReader(pipeline.getOptions(), checkpoint);
+    assertTrue(reader.start());
+    assertEquals("data_1", reader.getCurrent().getBody());
+
+    // We are done.
+    assertFalse(reader.advance());
+
+    // ACK final message.
+    checkpoint = (SqsCheckpointMark) reader.getCheckpointMark();
+    checkpoint.finalizeCheckpoint();
+    reader.close();
+  }
+
+  @Test
+  public void testReadMany() throws IOException {
+
+    HashSet<String> messages = new HashSet<>();
+    List<String> incoming = new ArrayList<>();
     for (int i = 0; i < 100; i++) {
-      SendMessageRequest sendMessageRequest =
-          SendMessageRequest.builder().queueUrl(queueUrl).messageBody("This is a test").build();
-      client.sendMessage(sendMessageRequest);
+      String content = String.format("data_%d", i);
+      messages.add(content);
+      incoming.add(String.format("data_%d", i));
     }
-    pipeline.run();
+    setupMessages(incoming);
+
+    SqsUnboundedReader reader =
+        (SqsUnboundedReader) source.createReader(pipeline.getOptions(), null);
+
+    for (int i = 0; i < 100; i++) {
+      if (i == 0) {
+        assertTrue(reader.start());
+      } else {
+        assertTrue(reader.advance());
+      }
+      String data = reader.getCurrent().getBody();
+      boolean messageNum = messages.remove(data);
+      // No duplicate messages.
+      assertTrue(messageNum);
+    }
+    // We are done.
+    assertFalse(reader.advance());
+    // We saw each message exactly once.
+    assertTrue(messages.isEmpty());
+    reader.close();
   }
 
   @Test
   public void testWrite() {
-    final SqsClient client = EmbeddedSqsServer.getClient();
-    final String queueUrl = EmbeddedSqsServer.getQueueUrl();
+    final SqsClient client = embeddedSqsRestServer.getClient();
+    final String queueUrl = embeddedSqsRestServer.getQueueUrl();
 
     List<SendMessageRequest> messages = new ArrayList<>();
     for (int i = 0; i < 100; i++) {
@@ -106,13 +247,15 @@ public class SqsIOTest {
     }
   }
 
-  @BeforeClass
-  public static void before() {
-    EmbeddedSqsServer.start();
-  }
-
-  @AfterClass
-  public static void after() {
-    EmbeddedSqsServer.stop();
+  /** Tests that checkpoints finalized after the reader is closed succeed. */
+  @Test
+  public void closeWithActiveCheckpoints() throws Exception {
+    setupOneMessage();
+    UnboundedSource.UnboundedReader<SqsMessage> reader =
+        source.createReader(pipeline.getOptions(), null);
+    reader.start();
+    UnboundedSource.CheckpointMark checkpoint = reader.getCheckpointMark();
+    reader.close();
+    checkpoint.finalizeCheckpoint();
   }
 }
