diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java
index bd1cc854678..2984e214aa7 100644
--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java
+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java
@@ -511,7 +511,8 @@ public class StreamingModeExecutionContext extends DataflowExecutionContext<Step
               stateFamily,
               stateReader,
               work.getIsNewKey(),
-              stateCache.forKey(getSerializedKey(), stateFamily, getWork().getCacheToken()),
+              stateCache.forKey(
+                  getSerializedKey(), stateFamily, getWork().getCacheToken(), getWorkToken()),
               scopedReadStateSupplier);
 
       this.systemTimerInternals =
diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateCache.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateCache.java
index 90d442d05e3..0527a92fad4 100644
--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateCache.java
+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateCache.java
@@ -56,9 +56,9 @@ public class WindmillStateCache implements StatusDataProvider {
   private static final int INITIAL_HASH_MAP_CAPACITY = 4;
   // Overhead of each hash map entry.
   private static final int HASH_MAP_ENTRY_OVERHEAD = 16;
-  // Overhead of each cache entry.  Two longs, plus a hash table.
+  // Overhead of each cache entry.  Three longs, plus a hash table.
   private static final int PER_CACHE_ENTRY_OVERHEAD =
-      16 + HASH_MAP_ENTRY_OVERHEAD * INITIAL_HASH_MAP_CAPACITY;
+      24 + HASH_MAP_ENTRY_OVERHEAD * INITIAL_HASH_MAP_CAPACITY;
 
   private Cache<StateId, StateCacheEntry> stateCache;
   private HashMultimap<ComputationKey, StateId> keyIndex =
@@ -114,8 +114,8 @@ public class WindmillStateCache implements StatusDataProvider {
     }
 
     /** Returns a per-computation, per-key view of the state cache. */
-    public ForKey forKey(ByteString key, String stateFamily, long cacheToken) {
-      return new ForKey(computation, key, stateFamily, cacheToken);
+    public ForKey forKey(ByteString key, String stateFamily, long cacheToken, long workToken) {
+      return new ForKey(computation, key, stateFamily, cacheToken, workToken);
     }
   }
 
@@ -124,24 +124,36 @@ public class WindmillStateCache implements StatusDataProvider {
     private final String computation;
     private final ByteString key;
     private final String stateFamily;
+    // Cache token must be consistent for the key for the cache to be valid.
     private final long cacheToken;
 
-    private ForKey(String computation, ByteString key, String stateFamily, long cacheToken) {
+    // The work token for processing must be greater than the last work token.  As work items are
+    // increasing for a key, a less-than or equal to work token indicates that the current token is
+    // for stale processing. We don't use the cache so that fetches performed will fail with a no
+    // longer valid work token.
+    private final long workToken;
+
+    private ForKey(
+        String computation, ByteString key, String stateFamily, long cacheToken, long workToken) {
       this.computation = computation;
       this.key = key;
       this.stateFamily = stateFamily;
       this.cacheToken = cacheToken;
+      this.workToken = workToken;
     }
 
     public <T extends State> T get(StateNamespace namespace, StateTag<T> address) {
       return WindmillStateCache.this.get(
-          computation, key, stateFamily, cacheToken, namespace, address);
+          computation, key, stateFamily, cacheToken, workToken, namespace, address);
     }
 
+    // Note that once a value has been put for a given workToken, get calls with that same workToken
+    // will fail. This is ok as we only put entries when we are building the commit and will no
+    // longer be performing gets for the same work token.
     public <T extends State> void put(
         StateNamespace namespace, StateTag<T> address, T value, long weight) {
       WindmillStateCache.this.put(
-          computation, key, stateFamily, cacheToken, namespace, address, value, weight);
+          computation, key, stateFamily, cacheToken, workToken, namespace, address, value, weight);
     }
   }
 
@@ -154,7 +166,8 @@ public class WindmillStateCache implements StatusDataProvider {
       String computation,
       ByteString processingKey,
       String stateFamily,
-      long token,
+      long cacheToken,
+      long workToken,
       StateNamespace namespace,
       StateTag<T> address) {
     StateId id = new StateId(computation, processingKey, stateFamily, namespace);
@@ -162,10 +175,14 @@ public class WindmillStateCache implements StatusDataProvider {
     if (entry == null) {
       return null;
     }
-    if (entry.getToken() != token) {
+    if (entry.getCacheToken() != cacheToken) {
       stateCache.invalidate(id);
       return null;
     }
+    if (workToken <= entry.getLastWorkToken()) {
+      // We don't used the cached item but we don't invalidate it.
+      return null;
+    }
     return entry.get(namespace, address);
   }
 
@@ -173,7 +190,8 @@ public class WindmillStateCache implements StatusDataProvider {
       String computation,
       ByteString processingKey,
       String stateFamily,
-      long token,
+      long cacheToken,
+      long workToken,
       StateNamespace namespace,
       StateTag<T> address,
       T value,
@@ -185,11 +203,12 @@ public class WindmillStateCache implements StatusDataProvider {
         keyIndex.put(id.getComputationKey(), id);
       }
     }
-    if (entry == null || entry.getToken() != token) {
-      entry = new StateCacheEntry(token);
+    if (entry == null || entry.getCacheToken() != cacheToken) {
+      entry = new StateCacheEntry(cacheToken);
       this.displayedWeight += (int) id.getWeight();
       this.displayedWeight += (int) entry.getWeight();
     }
+    entry.setLastWorkToken(workToken);
     this.displayedWeight += (int) entry.put(namespace, address, value, weight);
     // Always add back to the cache to update the weight.
     stateCache.put(id, entry);
@@ -266,20 +285,26 @@ public class WindmillStateCache implements StatusDataProvider {
   }
 
   /**
-   * Entry in the state cache that stores a map of values and a token representing the validity of
-   * the values.
+   * Entry in the state cache that stores a map of values, a cache token representing the validity
+   * of the values, and a work token that is increasing to ensure sequential processing.
    */
   private static class StateCacheEntry implements Weighted {
-    private final long token;
+    private final long cacheToken;
+    private long lastWorkToken;
     private final Map<NamespacedTag<?>, WeightedValue<?>> values;
     private long weight;
 
-    public StateCacheEntry(long token) {
+    public StateCacheEntry(long cacheToken) {
       this.values = new HashMap<>(INITIAL_HASH_MAP_CAPACITY);
-      this.token = token;
+      this.cacheToken = cacheToken;
+      this.lastWorkToken = Long.MIN_VALUE;
       this.weight = 0;
     }
 
+    public void setLastWorkToken(long workToken) {
+      this.lastWorkToken = workToken;
+    }
+
     @SuppressWarnings("unchecked")
     public <T extends State> T get(StateNamespace namespace, StateTag<T> tag) {
       WeightedValue<T> weightedValue =
@@ -312,8 +337,12 @@ public class WindmillStateCache implements StatusDataProvider {
       return weight + PER_CACHE_ENTRY_OVERHEAD;
     }
 
-    public long getToken() {
-      return token;
+    public long getCacheToken() {
+      return cacheToken;
+    }
+
+    public long getLastWorkToken() {
+      return lastWorkToken;
     }
 
     private static class NamespacedTag<T extends State> {
diff --git a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateCacheTest.java b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateCacheTest.java
index e480f4817ef..07e6c1c4e79 100644
--- a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateCacheTest.java
+++ b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateCacheTest.java
@@ -131,26 +131,27 @@ public class WindmillStateCacheTest {
   @Before
   public void setUp() {
     cache = new WindmillStateCache();
-    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L);
     assertEquals(0, cache.getWeight());
   }
 
   @Test
   public void testBasic() throws Exception {
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 1L);
     assertNull(keyCache.get(StateNamespaces.global(), new TestStateTag("tag1")));
     assertNull(keyCache.get(windowNamespace(0), new TestStateTag("tag2")));
     assertNull(keyCache.get(triggerNamespace(0, 0), new TestStateTag("tag3")));
     assertNull(keyCache.get(triggerNamespace(0, 0), new TestStateTag("tag2")));
 
     keyCache.put(StateNamespaces.global(), new TestStateTag("tag1"), new TestState("g1"), 2);
-    assertEquals(121, cache.getWeight());
+    assertEquals(129, cache.getWeight());
     keyCache.put(windowNamespace(0), new TestStateTag("tag2"), new TestState("w2"), 2);
-    assertEquals(242, cache.getWeight());
+    assertEquals(258, cache.getWeight());
     keyCache.put(triggerNamespace(0, 0), new TestStateTag("tag3"), new TestState("t3"), 2);
-    assertEquals(260, cache.getWeight());
+    assertEquals(276, cache.getWeight());
     keyCache.put(triggerNamespace(0, 0), new TestStateTag("tag2"), new TestState("t2"), 2);
-    assertEquals(278, cache.getWeight());
+    assertEquals(294, cache.getWeight());
 
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 2L);
     assertEquals(
         new TestState("g1"), keyCache.get(StateNamespaces.global(), new TestStateTag("tag1")));
     assertEquals(new TestState("w2"), keyCache.get(windowNamespace(0), new TestStateTag("tag2")));
@@ -163,14 +164,17 @@ public class WindmillStateCacheTest {
   /** Verifies that values are cached in the appropriate namespaces. */
   @Test
   public void testInvalidation() throws Exception {
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 1L);
     assertNull(keyCache.get(StateNamespaces.global(), new TestStateTag("tag1")));
     keyCache.put(StateNamespaces.global(), new TestStateTag("tag1"), new TestState("g1"), 2);
-    assertEquals(121, cache.getWeight());
+
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 2L);
+    assertEquals(129, cache.getWeight());
     assertEquals(
         new TestState("g1"), keyCache.get(StateNamespaces.global(), new TestStateTag("tag1")));
 
-    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 1L);
-    assertEquals(121, cache.getWeight());
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 1L, 3L);
+    assertEquals(129, cache.getWeight());
     assertNull(keyCache.get(StateNamespaces.global(), new TestStateTag("tag1")));
     assertEquals(0, cache.getWeight());
   }
@@ -178,45 +182,102 @@ public class WindmillStateCacheTest {
   /** Verifies that the cache is invalidated when the cache token changes. */
   @Test
   public void testEviction() throws Exception {
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 1L);
     keyCache.put(windowNamespace(0), new TestStateTag("tag2"), new TestState("w2"), 2);
-    assertEquals(121, cache.getWeight());
+    assertEquals(129, cache.getWeight());
     keyCache.put(triggerNamespace(0, 0), new TestStateTag("tag3"), new TestState("t3"), 2000000000);
     assertEquals(0, cache.getWeight());
     // Eviction is atomic across the whole window.
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 2L);
     assertNull(keyCache.get(windowNamespace(0), new TestStateTag("tag2")));
     assertNull(keyCache.get(triggerNamespace(0, 0), new TestStateTag("tag3")));
   }
 
+  /** Verifies that the cache does not vend for stale work tokens. */
+  @Test
+  public void testStaleWorkItem() throws Exception {
+    TestStateTag tag = new TestStateTag("tag2");
+
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 2L);
+    keyCache.put(windowNamespace(0), tag, new TestState("w2"), 2);
+    assertEquals(129, cache.getWeight());
+    // Same cache.
+    assertNull(keyCache.get(windowNamespace(0), tag));
+
+    // Previous work token.
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 1L);
+    assertNull(keyCache.get(windowNamespace(0), tag));
+
+    // Retry of work token that inserted.
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 2L);
+    assertNull(keyCache.get(windowNamespace(0), tag));
+
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 10L);
+    assertEquals(new TestState("w2"), keyCache.get(windowNamespace(0), tag));
+    keyCache.put(windowNamespace(0), tag, new TestState("w3"), 2);
+
+    // Ensure that second put updated work token.
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 5L);
+    assertNull(keyCache.get(windowNamespace(0), tag));
+
+    keyCache = cache.forComputation(COMPUTATION).forKey(KEY, STATE_FAMILY, 0L, 15L);
+    assertEquals(new TestState("w3"), keyCache.get(windowNamespace(0), tag));
+  }
+
   /** Verifies that caches are kept independently per-key. */
   @Test
   public void testMultipleKeys() throws Exception {
+    TestStateTag tag = new TestStateTag("tag1");
+
     WindmillStateCache.ForKey keyCache1 =
-        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L);
+        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L, 0L);
     WindmillStateCache.ForKey keyCache2 =
-        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key2"), STATE_FAMILY, 0L);
+        cache
+            .forComputation("comp1")
+            .forKey(ByteString.copyFromUtf8("key2"), STATE_FAMILY, 0L, 10L);
     WindmillStateCache.ForKey keyCache3 =
-        cache.forComputation("comp2").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L);
-
-    keyCache1.put(StateNamespaces.global(), new TestStateTag("tag1"), new TestState("g1"), 2);
-    assertEquals(
-        new TestState("g1"), keyCache1.get(StateNamespaces.global(), new TestStateTag("tag1")));
-    assertNull(keyCache2.get(StateNamespaces.global(), new TestStateTag("tag1")));
-    assertNull(keyCache3.get(StateNamespaces.global(), new TestStateTag("tag1")));
+        cache.forComputation("comp2").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L, 0L);
+
+    TestState state1 = new TestState("g1");
+    keyCache1.put(StateNamespaces.global(), tag, state1, 2);
+    assertNull(keyCache1.get(StateNamespaces.global(), tag));
+    keyCache1 =
+        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L, 1L);
+    assertEquals(state1, keyCache1.get(StateNamespaces.global(), tag));
+    assertNull(keyCache2.get(StateNamespaces.global(), tag));
+    assertNull(keyCache3.get(StateNamespaces.global(), tag));
+
+    TestState state2 = new TestState("g2");
+    keyCache2.put(StateNamespaces.global(), tag, state2, 2);
+    assertNull(keyCache2.get(StateNamespaces.global(), tag));
+    keyCache2 =
+        cache
+            .forComputation("comp1")
+            .forKey(ByteString.copyFromUtf8("key2"), STATE_FAMILY, 0L, 20L);
+    assertEquals(state2, keyCache2.get(StateNamespaces.global(), tag));
+    assertEquals(state1, keyCache1.get(StateNamespaces.global(), tag));
+    assertNull(keyCache3.get(StateNamespaces.global(), tag));
   }
 
   /** Verifies explicit invalidation does indeed invalidate the correct entries. */
   @Test
   public void testExplicitInvalidation() throws Exception {
     WindmillStateCache.ForKey keyCache1 =
-        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L);
+        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L, 0L);
     WindmillStateCache.ForKey keyCache2 =
-        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key2"), STATE_FAMILY, 0L);
+        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key2"), STATE_FAMILY, 0L, 0L);
     WindmillStateCache.ForKey keyCache3 =
-        cache.forComputation("comp2").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L);
+        cache.forComputation("comp2").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L, 0L);
 
     keyCache1.put(StateNamespaces.global(), new TestStateTag("tag1"), new TestState("g1"), 1);
     keyCache2.put(StateNamespaces.global(), new TestStateTag("tag2"), new TestState("g2"), 2);
     keyCache3.put(StateNamespaces.global(), new TestStateTag("tag3"), new TestState("g3"), 3);
+    keyCache1 =
+        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L, 1L);
+    keyCache2 =
+        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key2"), STATE_FAMILY, 0L, 1L);
+    keyCache3 =
+        cache.forComputation("comp2").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L, 1L);
     assertEquals(
         new TestState("g1"), keyCache1.get(StateNamespaces.global(), new TestStateTag("tag1")));
     assertEquals(
@@ -256,10 +317,13 @@ public class WindmillStateCacheTest {
   @Test
   public void testBadCoderEquality() throws Exception {
     WindmillStateCache.ForKey keyCache1 =
-        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L);
+        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L, 0L);
 
     StateTag<TestState> tag = new TestStateTagWithBadEquality("tag1");
     keyCache1.put(StateNamespaces.global(), tag, new TestState("g1"), 1);
+
+    keyCache1 =
+        cache.forComputation("comp1").forKey(ByteString.copyFromUtf8("key1"), STATE_FAMILY, 0L, 1L);
     assertEquals(new TestState("g1"), keyCache1.get(StateNamespaces.global(), tag));
     assertEquals(
         new TestState("g1"),
diff --git a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternalsTest.java b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternalsTest.java
index 30777b15225..bbd9a18b8c1 100644
--- a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternalsTest.java
+++ b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternalsTest.java
@@ -78,6 +78,7 @@ public class WindmillStateInternalsTest {
   private static final ByteString COMBINING_KEY = key(NAMESPACE, "combining");
   private final Coder<int[]> accumCoder =
       Sum.ofIntegers().getAccumulatorCoder(null, VarIntCoder.of());
+  private long workToken = 0;
 
   @Mock private WindmillStateReader mockReader;
 
@@ -99,21 +100,26 @@ public class WindmillStateInternalsTest {
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     cache = new WindmillStateCache();
+    resetUnderTest();
+  }
+
+  public void resetUnderTest() {
+    workToken++;
     underTest =
         new WindmillStateInternals<>(
             "dummyKey",
             STATE_FAMILY,
             mockReader,
             false,
-            cache.forComputation("comp").forKey(ByteString.EMPTY, STATE_FAMILY, 17L),
+            cache.forComputation("comp").forKey(ByteString.EMPTY, STATE_FAMILY, 17L, workToken),
             readStateSupplier);
     underTestNewKey =
         new WindmillStateInternals<String>(
-            "dummyKey",
+            "dummyNewKey",
             STATE_FAMILY,
             mockReader,
             true,
-            cache.forComputation("comp").forKey(ByteString.EMPTY, STATE_FAMILY, 17L),
+            cache.forComputation("comp").forKey(ByteString.EMPTY, STATE_FAMILY, 17L, workToken),
             readStateSupplier);
   }
 
@@ -848,15 +854,17 @@ public class WindmillStateInternalsTest {
     value.write("Hi");
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(118, cache.getWeight());
+    assertEquals(126, cache.getWeight());
 
+    resetUnderTest();
     value = underTest.state(NAMESPACE, addr);
     assertEquals("Hi", value.read());
     value.clear();
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(116, cache.getWeight());
+    assertEquals(124, cache.getWeight());
 
+    resetUnderTest();
     value = underTest.state(NAMESPACE, addr);
     assertEquals(null, value.read());
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
@@ -886,8 +894,9 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(126, cache.getWeight());
+    assertEquals(134, cache.getWeight());
 
+    resetUnderTest();
     bag = underTest.state(NAMESPACE, addr);
     bag.add("goodbye");
 
@@ -905,8 +914,9 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(119, cache.getWeight());
+    assertEquals(127, cache.getWeight());
 
+    resetUnderTest();
     bag = underTest.state(NAMESPACE, addr);
     bag.add("new2");
     assertThat(bag.read(), Matchers.containsInAnyOrder("new", "new2"));
@@ -915,8 +925,9 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(120, cache.getWeight());
+    assertEquals(128, cache.getWeight());
 
+    resetUnderTest();
     bag = underTest.state(NAMESPACE, addr);
     assertThat(bag.read(), Matchers.containsInAnyOrder("new3"));
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
@@ -945,16 +956,18 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(124, cache.getWeight());
+    assertEquals(132, cache.getWeight());
 
+    resetUnderTest();
     hold = underTest.state(NAMESPACE, addr);
     assertThat(hold.read(), Matchers.equalTo(new Instant(2000)));
     hold.clear();
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(124, cache.getWeight());
+    assertEquals(132, cache.getWeight());
 
+    resetUnderTest();
     hold = underTest.state(NAMESPACE, addr);
     assertEquals(null, hold.read());
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
@@ -983,8 +996,9 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(117, cache.getWeight());
+    assertEquals(125, cache.getWeight());
 
+    resetUnderTest();
     value = underTest.state(NAMESPACE, COMBINING_ADDR);
     assertThat(value.read(), Matchers.equalTo(3));
     value.add(3);
@@ -993,8 +1007,9 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(116, cache.getWeight());
+    assertEquals(124, cache.getWeight());
 
+    resetUnderTest();
     value = underTest.state(NAMESPACE, COMBINING_ADDR);
     assertThat(value.read(), Matchers.equalTo(0));
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
