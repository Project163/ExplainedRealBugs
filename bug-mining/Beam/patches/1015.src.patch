diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamAggregationRule.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamAggregationRule.java
index 70ece2fc63a..5e5fe6975f5 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamAggregationRule.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamAggregationRule.java
@@ -181,12 +181,12 @@ public class BeamAggregationRule extends RelOptRule {
   }
 
   private static Duration durationParameter(List<RexNode> parameters, int parameterIndex) {
-    return Duration.millis(intValue(parameters.get(parameterIndex)));
+    return Duration.millis(longValue(parameters.get(parameterIndex)));
   }
 
-  private static long intValue(RexNode operand) {
+  private static long longValue(RexNode operand) {
     if (operand instanceof RexLiteral) {
-      return RexLiteral.intValue(operand);
+      return ((Number) RexLiteral.value(operand)).longValue();
     } else {
       throw new IllegalArgumentException(String.format("[%s] is not valid.", operand));
     }
diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java
index 4dc010ff24d..429d8630ea9 100644
--- a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java
+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java
@@ -323,6 +323,52 @@ public class BeamSqlDslAggregationTest extends BeamSqlDslBase {
     runTumbleWindow(unboundedInput1);
   }
 
+  @Test
+  public void testTumbleWindowWith31DaysBounded() throws Exception {
+    runTumbleWindowFor31Days(boundedInputMonthly);
+  }
+
+  private void runTumbleWindowFor31Days(PCollection<Row> input) throws Exception {
+    String sql =
+        "SELECT f_int2, COUNT(*) AS `getFieldCount`,"
+            + " TUMBLE_START(f_timestamp, INTERVAL '31' DAY) AS `window_start`, "
+            + " TUMBLE_END(f_timestamp, INTERVAL '31' DAY) AS `window_end` "
+            + " FROM TABLE_A"
+            + " GROUP BY f_int2, TUMBLE(f_timestamp, INTERVAL '31' DAY)";
+    PCollection<Row> result =
+        PCollectionTuple.of(new TupleTag<>("TABLE_A"), input)
+            .apply("testTumbleWindow", SqlTransform.query(sql));
+
+    Schema resultType =
+        Schema.builder()
+            .addInt32Field("f_int2")
+            .addInt64Field("size")
+            .addDateTimeField("window_start")
+            .addDateTimeField("window_end")
+            .build();
+
+    List<Row> expectedRows =
+        TestUtils.RowsBuilder.of(resultType)
+            .addRows(
+                0,
+                1L,
+                parseTimestampWithoutTimeZone("2016-12-08 01:00:00"),
+                parseTimestampWithoutTimeZone("2017-01-08 01:00:00"),
+                0,
+                1L,
+                parseTimestampWithoutTimeZone("2017-01-08 01:00:00"),
+                parseTimestampWithoutTimeZone("2017-02-08 01:00:00"),
+                0,
+                1L,
+                parseTimestampWithoutTimeZone("2017-02-08 01:00:00"),
+                parseTimestampWithoutTimeZone("2017-03-11 01:00:00"))
+            .getRows();
+
+    PAssert.that(result).containsInAnyOrder(expectedRows);
+
+    pipeline.run().waitUntilFinish();
+  }
+
   private void runTumbleWindow(PCollection<Row> input) throws Exception {
     String sql =
         "SELECT f_int2, COUNT(*) AS `getFieldCount`,"
diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslBase.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslBase.java
index 28f3f752443..2ff46737d3b 100644
--- a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslBase.java
+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslBase.java
@@ -56,6 +56,7 @@ public class BeamSqlDslBase {
   static Schema schemaBytesPaddingTest;
 
   static List<Row> rowsInTableA;
+  static List<Row> monthlyRowsInTableA;
   static List<Row> rowsOfFloatDouble;
   static List<Row> rowsOfBytes;
   static List<Row> rowsOfBytesPaddingTest;
@@ -66,6 +67,7 @@ public class BeamSqlDslBase {
   protected PCollection<Row> boundedInputFloatDouble;
   protected PCollection<Row> boundedInputBytes;
   protected PCollection<Row> boundedInputBytesPaddingTest;
+  protected PCollection<Row> boundedInputMonthly;
 
   // unbounded PCollections
   protected PCollection<Row> unboundedInput1;
@@ -135,6 +137,43 @@ public class BeamSqlDslBase {
                 new BigDecimal(4))
             .getRows();
 
+    monthlyRowsInTableA =
+        TestUtils.RowsBuilder.of(schemaInTableA)
+            .addRows(
+                1,
+                1000L,
+                (short) 1,
+                (byte) 1,
+                1.0f,
+                1.0d,
+                "string_row1",
+                parseTimestampWithoutTimeZone("2017-01-01 01:01:03"),
+                0,
+                new BigDecimal(1))
+            .addRows(
+                2,
+                2000L,
+                (short) 2,
+                (byte) 2,
+                2.0f,
+                2.0d,
+                "string_row2",
+                parseTimestampWithoutTimeZone("2017-02-01 01:02:03"),
+                0,
+                new BigDecimal(2))
+            .addRows(
+                3,
+                3000L,
+                (short) 3,
+                (byte) 3,
+                3.0f,
+                3.0d,
+                "string_row3",
+                parseTimestampWithoutTimeZone("2017-03-01 01:06:03"),
+                0,
+                new BigDecimal(3))
+            .getRows();
+
     schemaFloatDouble =
         Schema.builder()
             .addFloatField("f_float_1")
@@ -259,6 +298,14 @@ public class BeamSqlDslBase {
                     schemaBytesPaddingTest,
                     SerializableFunctions.identity(),
                     SerializableFunctions.identity()));
+    boundedInputMonthly =
+        pipeline.apply(
+            "boundedInputMonthly",
+            Create.of(monthlyRowsInTableA)
+                .withSchema(
+                    schemaInTableA,
+                    SerializableFunctions.identity(),
+                    SerializableFunctions.identity()));
 
     unboundedInput1 = prepareUnboundedPCollection1();
     unboundedInput2 = prepareUnboundedPCollection2();
