diff --git a/sdks/python/apache_beam/runners/interactive/user_pipeline_tracker.py b/sdks/python/apache_beam/runners/interactive/user_pipeline_tracker.py
new file mode 100644
index 00000000000..72a878f1136
--- /dev/null
+++ b/sdks/python/apache_beam/runners/interactive/user_pipeline_tracker.py
@@ -0,0 +1,135 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+"""Class that tracks derived/pipeline fragments from user pipelines.
+
+For internal use only; no backwards-compatibility guarantees.
+In the InteractiveRunner the design is to keep the user pipeline unchanged,
+create a copy of the user pipeline, and modify the copy. When the derived
+pipeline runs, there should only be per-user pipeline state. This makes sure
+that derived pipelines can link back to the parent user pipeline.
+"""
+
+from typing import Iterator
+from typing import Optional
+
+import apache_beam as beam  # type: ignore
+
+
+class UserPipelineTracker:
+  """Tracks user pipelines from derived pipelines.
+
+  This data structure is similar to a disjoint set data structure. A derived
+  pipeline can only have one parent user pipeline. A user pipeline can have many
+  derived pipelines.
+  """
+  def __init__(self):
+    self._user_pipelines: set[beam.Pipeline] = set()
+    self._derived_pipelines: dict[beam.Pipeline] = {}
+    self._pid_to_pipelines: dict[beam.Pipeline] = {}
+
+  def __iter__(self) -> Iterator[beam.Pipeline]:
+    """Iterates through all the user pipelines."""
+    for p in self._user_pipelines:
+      yield p
+
+  def _key(self, pipeline: beam.Pipeline) -> str:
+    return str(id(pipeline))
+
+  def clear(self) -> None:
+    """Clears the tracker of all user and derived pipelines."""
+    self._user_pipelines.clear()
+    self._derived_pipelines.clear()
+    self._pid_to_pipelines.clear()
+
+  def get_pipeline(self, pid: str) -> Optional[beam.Pipeline]:
+    """Returns the pipeline corresponding to the given pipeline id."""
+    return self._pid_to_pipelines.get(pid, None)
+
+  def add_user_pipeline(self, p: beam.Pipeline) -> beam.Pipeline:
+    """Adds a user pipeline with an empty set of derived pipelines."""
+    self._memoize_pipieline(p)
+
+    # Create a new node for the user pipeline if it doesn't exist already.
+    user_pipeline = self.get_user_pipeline(p)
+    if not user_pipeline:
+      user_pipeline = p
+      self._user_pipelines.add(p)
+
+    return user_pipeline
+
+  def _memoize_pipieline(self, p: beam.Pipeline) -> None:
+    """Memoizes the pid of the pipeline to the pipeline object."""
+    pid = self._key(p)
+    if pid not in self._pid_to_pipelines:
+      self._pid_to_pipelines[pid] = p
+
+  def add_derived_pipeline(
+      self, maybe_user_pipeline: beam.Pipeline,
+      derived_pipeline: beam.Pipeline) -> None:
+    """Adds a derived pipeline with the user pipeline.
+
+    If the `maybe_user_pipeline` is a user pipeline, then the derived pipeline
+    will be added to its set. Otherwise, the derived pipeline will be added to
+    the user pipeline of the `maybe_user_pipeline`.
+
+    By doing the above one can do:
+    p = beam.Pipeline()
+
+    derived1 = beam.Pipeline()
+    derived2 = beam.Pipeline()
+
+    ut = UserPipelineTracker()
+    ut.add_derived_pipeline(p, derived1)
+    ut.add_derived_pipeline(derived1, derived2)
+
+    # Returns p.
+    ut.get_user_pipeline(derived2)
+    """
+    self._memoize_pipieline(maybe_user_pipeline)
+    self._memoize_pipieline(derived_pipeline)
+
+    # Cannot add a derived pipeline twice.
+    assert derived_pipeline not in self._derived_pipelines
+
+    # Get the "true" user pipeline. This allows for the user to derive a
+    # pipeline from another derived pipeline, use both as arguments, and this
+    # method will still get the correct user pipeline.
+    user = self.add_user_pipeline(maybe_user_pipeline)
+
+    # Map the derived pipeline to the user pipeline.
+    self._derived_pipelines[derived_pipeline] = user
+
+  def get_user_pipeline(self, p: beam.Pipeline) -> Optional[beam.Pipeline]:
+    """Returns the user pipeline of the given pipeline.
+
+    If the given pipeline has no user pipeline, i.e. not added to this tracker,
+    then this returns None. If the given pipeline is a user pipeline then this
+    returns the same pipeline. If the given pipeline is a derived pipeline then
+    this returns the user pipeline.
+    """
+
+    # If `p` is a user pipeline then return it.
+    if p in self._user_pipelines:
+      return p
+
+    # If `p` exists then return its user pipeline.
+    if p in self._derived_pipelines:
+      return self._derived_pipelines[p]
+
+    # Otherwise, `p` is not in this tracker.
+    return None
diff --git a/sdks/python/apache_beam/runners/interactive/user_pipeline_tracker_test.py b/sdks/python/apache_beam/runners/interactive/user_pipeline_tracker_test.py
new file mode 100644
index 00000000000..1894d029914
--- /dev/null
+++ b/sdks/python/apache_beam/runners/interactive/user_pipeline_tracker_test.py
@@ -0,0 +1,183 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+from __future__ import absolute_import
+
+import unittest
+
+import apache_beam as beam
+from apache_beam.runners.interactive.user_pipeline_tracker import UserPipelineTracker
+
+
+class UserPipelineTrackerTest(unittest.TestCase):
+  def test_getting_unknown_pid_returns_none(self):
+    ut = UserPipelineTracker()
+
+    p = beam.Pipeline()
+
+    self.assertIsNone(ut.get_pipeline(str(id(p))))
+
+  def test_getting_unknown_pipeline_returns_none(self):
+    ut = UserPipelineTracker()
+
+    p = beam.Pipeline()
+
+    self.assertIsNone(ut.get_user_pipeline(p))
+
+  def test_no_parent_returns_none(self):
+    ut = UserPipelineTracker()
+
+    user = beam.Pipeline()
+    derived = beam.Pipeline()
+    orphan = beam.Pipeline()
+
+    ut.add_derived_pipeline(user, derived)
+
+    self.assertIsNone(ut.get_user_pipeline(orphan))
+
+  def test_get_user_pipeline_is_same(self):
+    ut = UserPipelineTracker()
+
+    p = beam.Pipeline()
+    ut.add_user_pipeline(p)
+
+    self.assertIs(ut.get_user_pipeline(p), p)
+
+  def test_can_add_derived(self):
+    ut = UserPipelineTracker()
+
+    user = beam.Pipeline()
+    derived = beam.Pipeline()
+
+    ut.add_derived_pipeline(user, derived)
+
+    self.assertIs(ut.get_user_pipeline(derived), user)
+
+  def test_can_add_multiple_derived(self):
+    """Tests that there can be many user pipelines with many derived
+    pipelines.
+    """
+    ut = UserPipelineTracker()
+
+    # Add the first set of user and derived pipelines.
+    user1 = beam.Pipeline()
+    derived11 = beam.Pipeline()
+    derived12 = beam.Pipeline()
+
+    ut.add_derived_pipeline(user1, derived11)
+    ut.add_derived_pipeline(user1, derived12)
+
+    # Add the second set of user and derived pipelines.
+    user2 = beam.Pipeline()
+    derived21 = beam.Pipeline()
+    derived22 = beam.Pipeline()
+
+    ut.add_derived_pipeline(user2, derived21)
+    ut.add_derived_pipeline(user2, derived22)
+
+    # Assert that the user pipelines are correct.
+    self.assertIs(ut.get_user_pipeline(derived11), user1)
+    self.assertIs(ut.get_user_pipeline(derived12), user1)
+    self.assertIs(ut.get_user_pipeline(derived21), user2)
+    self.assertIs(ut.get_user_pipeline(derived22), user2)
+
+  def test_cannot_have_multiple_parents(self):
+    ut = UserPipelineTracker()
+
+    user1 = beam.Pipeline()
+    user2 = beam.Pipeline()
+    derived = beam.Pipeline()
+
+    ut.add_derived_pipeline(user1, derived)
+
+    with self.assertRaises(AssertionError):
+      ut.add_derived_pipeline(user2, derived)
+
+    self.assertIs(ut.get_user_pipeline(derived), user1)
+
+  def test_adding_derived_with_derived_gets_user_pipeline(self):
+    """Tests that one can correctly add a derived pipeline from a derived
+    pipeline and still get the correct user pipeline.
+    """
+    ut = UserPipelineTracker()
+
+    user = beam.Pipeline()
+    derived1 = beam.Pipeline()
+    derived2 = beam.Pipeline()
+
+    # Add the first derived pipeline to the user pipelne.
+    ut.add_derived_pipeline(user, derived1)
+
+    # Add the second derived pipeline to the first derived pipeline. This should
+    # get the user pipeline of the first and add the second to it.
+    ut.add_derived_pipeline(derived1, derived2)
+
+    # Asserts that both derived pipelines are under the same user pipeline.
+    self.assertIs(ut.get_user_pipeline(derived1), user)
+    self.assertIs(ut.get_user_pipeline(derived2), user)
+
+  def test_can_get_pipeline_from_id(self):
+    """Tests the pid -> pipeline memoization."""
+    ut = UserPipelineTracker()
+
+    user = beam.Pipeline()
+    derived = beam.Pipeline()
+
+    ut.add_user_pipeline(user)
+    ut.add_derived_pipeline(user, derived)
+
+    self.assertIs(ut.get_pipeline(str(id(user))), user)
+    self.assertIs(ut.get_pipeline(str(id(derived))), derived)
+
+  def test_clear(self):
+    ut = UserPipelineTracker()
+
+    user = beam.Pipeline()
+    derived = beam.Pipeline()
+
+    ut.add_derived_pipeline(user, derived)
+
+    self.assertIs(ut.get_user_pipeline(derived), user)
+
+    ut.clear()
+
+    self.assertIsNone(ut.get_user_pipeline(user))
+    self.assertIsNone(ut.get_user_pipeline(derived))
+
+  def test_can_iterate(self):
+    ut = UserPipelineTracker()
+
+    user1 = beam.Pipeline()
+    derived11 = beam.Pipeline()
+    derived12 = beam.Pipeline()
+
+    ut.add_derived_pipeline(user1, derived11)
+    ut.add_derived_pipeline(user1, derived12)
+
+    user2 = beam.Pipeline()
+    derived21 = beam.Pipeline()
+    derived22 = beam.Pipeline()
+
+    ut.add_derived_pipeline(user2, derived21)
+    ut.add_derived_pipeline(user2, derived22)
+
+    user_pipelines = set(p for p in ut)
+    self.assertSetEqual(set([user1, user2]), user_pipelines)
+
+
+if __name__ == '__main__':
+  unittest.main()
