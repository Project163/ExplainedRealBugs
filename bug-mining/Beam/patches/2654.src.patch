diff --git a/playground/backend/internal/code_processing/code_processing.go b/playground/backend/internal/code_processing/code_processing.go
index 281ec44bc46..917eae66dd3 100644
--- a/playground/backend/internal/code_processing/code_processing.go
+++ b/playground/backend/internal/code_processing/code_processing.go
@@ -161,9 +161,9 @@ func Process(ctx context.Context, cacheService cache.Cache, lc *fs_tool.LifeCycl
 
 // getExecuteCmd return cmd instance based on the code type: unit test or example code
 func getExecuteCmd(valRes *sync.Map, executor *executors.Executor, ctxWithTimeout context.Context) *exec.Cmd {
-	isUnitTest, _ := valRes.Load(validators.UnitTestValidatorName)
+	isUnitTest, ok := valRes.Load(validators.UnitTestValidatorName)
 	runType := executors.Run
-	if isUnitTest.(bool) {
+	if ok && isUnitTest.(bool) {
 		runType = executors.Test
 	}
 	cmdReflect := reflect.ValueOf(executor).MethodByName(string(runType)).Call([]reflect.Value{reflect.ValueOf(ctxWithTimeout)})
@@ -426,6 +426,9 @@ func processCompileSuccess(ctx context.Context, output []byte, pipelineId uuid.U
 	if err := utils.SetToCache(ctx, cacheService, pipelineId, cache.RunOutput, ""); err != nil {
 		return err
 	}
+	if err := utils.SetToCache(ctx, cacheService, pipelineId, cache.Logs, ""); err != nil {
+		return err
+	}
 	return utils.SetToCache(ctx, cacheService, pipelineId, cache.Status, pb.Status_STATUS_EXECUTING)
 }
 
diff --git a/playground/backend/internal/setup_tools/builder/setup_builder.go b/playground/backend/internal/setup_tools/builder/setup_builder.go
index 1184cd9557e..fb65aa312a4 100644
--- a/playground/backend/internal/setup_tools/builder/setup_builder.go
+++ b/playground/backend/internal/setup_tools/builder/setup_builder.go
@@ -78,6 +78,10 @@ func SetupExecutorBuilder(srcFilePath, baseFolderPath, execFilePath string, sdkE
 			WithExecutableFileName("").
 			WithRunner().
 			WithCommand(execFilePath).ExecutorBuilder
+	case pb.Sdk_SDK_PYTHON:
+		// Nothing is needed for Python
+	case pb.Sdk_SDK_SCIO:
+		return nil, fmt.Errorf("SCIO is not supported yet")
 	default:
 		return nil, fmt.Errorf("incorrect sdk: %s", sdkEnv.ApacheBeamSdk)
 	}
diff --git a/playground/frontend/lib/modules/editor/repository/code_repository/code_client/grpc_code_client.dart b/playground/frontend/lib/modules/editor/repository/code_repository/code_client/grpc_code_client.dart
index ed63ec85bc5..8d5bca79d90 100644
--- a/playground/frontend/lib/modules/editor/repository/code_repository/code_client/grpc_code_client.dart
+++ b/playground/frontend/lib/modules/editor/repository/code_repository/code_client/grpc_code_client.dart
@@ -91,7 +91,8 @@ class GrpcCodeClient implements CodeClient {
   ) {
     return _runSafely(() => createClient(request.sdk)
         .getLogs(grpc.GetLogsRequest(pipelineUuid: pipelineUuid))
-        .then((response) => OutputResponse(response.output)));
+        .then((response) => OutputResponse(response.output))
+        .catchError((err) => OutputResponse('')));
   }
 
   @override
diff --git a/playground/frontend/lib/modules/editor/repository/code_repository/code_repository.dart b/playground/frontend/lib/modules/editor/repository/code_repository/code_repository.dart
index 4afa927c351..6f8a2354dc6 100644
--- a/playground/frontend/lib/modules/editor/repository/code_repository/code_repository.dart
+++ b/playground/frontend/lib/modules/editor/repository/code_repository/code_repository.dart
@@ -52,17 +52,25 @@ class CodeRepository {
     RunCodeRequestWrapper request, {
     RunCodeResult? prevResult,
   }) async* {
-    final statusResponse = await _client.checkStatus(pipelineUuid, request);
-    final result = await _getPipelineResult(
-      pipelineUuid,
-      statusResponse.status,
-      prevResult,
-      request,
-    );
-    yield result;
-    if (!result.isFinished) {
-      await Future.delayed(kPipelineCheckDelay);
-      yield* _checkPipelineExecution(pipelineUuid, request, prevResult: result);
+    try {
+      final statusResponse = await _client.checkStatus(pipelineUuid, request);
+      final result = await _getPipelineResult(
+        pipelineUuid,
+        statusResponse.status,
+        prevResult,
+        request,
+      );
+      yield result;
+      if (!result.isFinished) {
+        await Future.delayed(kPipelineCheckDelay);
+        yield* _checkPipelineExecution(
+            pipelineUuid, request, prevResult: result);
+      }
+    } on RunCodeError catch (error) {
+      yield RunCodeResult(
+        status: RunCodeStatus.unknownError,
+        errorMessage: error.message ?? kUnknownErrorText,
+      );
     }
   }
 
