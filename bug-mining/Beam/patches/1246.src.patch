diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/CombineTranslation.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/CombineTranslation.java
index fb52bf0f1d0..a360984af96 100644
--- a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/CombineTranslation.java
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/CombineTranslation.java
@@ -37,7 +37,6 @@ import org.apache.beam.sdk.runners.AppliedPTransform;
 import org.apache.beam.sdk.transforms.Combine;
 import org.apache.beam.sdk.transforms.CombineFnBase.GlobalCombineFn;
 import org.apache.beam.sdk.transforms.PTransform;
-import org.apache.beam.sdk.util.AppliedCombineFn;
 import org.apache.beam.sdk.util.SerializableUtils;
 import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.PCollection;
@@ -105,7 +104,7 @@ public class CombineTranslation {
         return RunnerApi.CombinePayload.newBuilder()
             .setAccumulatorCoderId(
                 components.registerCoder(
-                    extractAccumulatorCoder(combineFn, (AppliedPTransform) combine)))
+                    extractCombinePerKeyAccumulatorCoder(combineFn, (AppliedPTransform) combine)))
             .setCombineFn(
                 SdkFunctionSpec.newBuilder()
                     .setEnvironmentId(components.getOnlyEnvironmentId())
@@ -176,7 +175,7 @@ public class CombineTranslation {
         return RunnerApi.CombinePayload.newBuilder()
             .setAccumulatorCoderId(
                 components.registerCoder(
-                    extractAccumulatorCoder(combineFn, (AppliedPTransform) combine)))
+                    extractCombineGloballyAccumulatorCoder(combineFn, (AppliedPTransform) combine)))
             .setCombineFn(
                 SdkFunctionSpec.newBuilder()
                     .setEnvironmentId(components.getOnlyEnvironmentId())
@@ -198,14 +197,15 @@ public class CombineTranslation {
 
   @VisibleForTesting
   static CombinePayload toProto(
-      AppliedPTransform<?, ?, Combine.PerKey<?, ?, ?>> combine, SdkComponents sdkComponents)
+      AppliedPTransform<?, ?, Combine.Globally<?, ?>> combine, SdkComponents sdkComponents)
       throws IOException {
     checkArgument(
         combine.getTransform().getSideInputs().isEmpty(),
         "CombineTranslation.toProto cannot translate Combines with side inputs.");
     GlobalCombineFn<?, ?, ?> combineFn = combine.getTransform().getFn();
     try {
-      Coder<?> accumulatorCoder = extractAccumulatorCoder(combineFn, (AppliedPTransform) combine);
+      Coder<?> accumulatorCoder =
+          extractCombineGloballyAccumulatorCoder(combineFn, (AppliedPTransform) combine);
       return RunnerApi.CombinePayload.newBuilder()
           .setAccumulatorCoderId(sdkComponents.registerCoder(accumulatorCoder))
           .setCombineFn(toProto(combineFn, sdkComponents))
@@ -215,7 +215,7 @@ public class CombineTranslation {
     }
   }
 
-  private static <K, InputT, AccumT> Coder<AccumT> extractAccumulatorCoder(
+  private static <K, InputT, AccumT> Coder<AccumT> extractCombinePerKeyAccumulatorCoder(
       GlobalCombineFn<InputT, AccumT, ?> combineFn,
       AppliedPTransform<PCollection<KV<K, InputT>>, ?, Combine.PerKey<K, InputT, ?>> transform)
       throws CannotProvideCoderException {
@@ -223,15 +223,21 @@ public class CombineTranslation {
     PCollection<KV<K, InputT>> mainInput =
         (PCollection<KV<K, InputT>>)
             Iterables.getOnlyElement(TransformInputs.nonAdditionalInputs(transform));
-    KvCoder<K, InputT> inputCoder = (KvCoder<K, InputT>) mainInput.getCoder();
-    return AppliedCombineFn.withInputCoder(
-            combineFn,
-            transform.getPipeline().getCoderRegistry(),
-            inputCoder,
-            transform.getTransform().getSideInputs(),
-            ((PCollection<?>) Iterables.getOnlyElement(transform.getOutputs().values()))
-                .getWindowingStrategy())
-        .getAccumulatorCoder();
+    return combineFn.getAccumulatorCoder(
+        transform.getPipeline().getCoderRegistry(),
+        ((KvCoder<K, InputT>) mainInput.getCoder()).getValueCoder());
+  }
+
+  private static <InputT, AccumT> Coder<AccumT> extractCombineGloballyAccumulatorCoder(
+      GlobalCombineFn<InputT, AccumT, ?> combineFn,
+      AppliedPTransform<PCollection<InputT>, ?, Combine.Globally<InputT, ?>> transform)
+      throws CannotProvideCoderException {
+    @SuppressWarnings("unchecked")
+    PCollection<InputT> mainInput =
+        (PCollection<InputT>)
+            Iterables.getOnlyElement(TransformInputs.nonAdditionalInputs(transform));
+    return combineFn.getAccumulatorCoder(
+        transform.getPipeline().getCoderRegistry(), mainInput.getCoder());
   }
 
   public static SdkFunctionSpec toProto(
diff --git a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/CombineTranslationTest.java b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/CombineTranslationTest.java
index ef93515e0e2..a9b7e104541 100644
--- a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/CombineTranslationTest.java
+++ b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/CombineTranslationTest.java
@@ -80,13 +80,13 @@ public class CombineTranslationTest {
     public void testToProto() throws Exception {
       PCollection<Integer> input = pipeline.apply(Create.of(1, 2, 3));
       input.apply(Combine.globally(combineFn));
-      final AtomicReference<AppliedPTransform<?, ?, Combine.PerKey<?, ?, ?>>> combine =
+      final AtomicReference<AppliedPTransform<?, ?, Combine.Globally<?, ?>>> combine =
           new AtomicReference<>();
       pipeline.traverseTopologically(
           new PipelineVisitor.Defaults() {
             @Override
             public void leaveCompositeTransform(Node node) {
-              if (node.getTransform() instanceof Combine.PerKey) {
+              if (node.getTransform() instanceof Combine.Globally) {
                 checkState(combine.get() == null);
                 combine.set((AppliedPTransform) node.toAppliedPTransform(getPipeline()));
               }
@@ -121,13 +121,13 @@ public class CombineTranslationTest {
       PCollection<Integer> input = pipeline.apply(Create.of(1, 2, 3));
       CombineFnWithContext<Integer, int[], Integer> combineFn = new TestCombineFnWithContext();
       input.apply(Combine.globally(combineFn).withoutDefaults());
-      final AtomicReference<AppliedPTransform<?, ?, Combine.PerKey<?, ?, ?>>> combine =
+      final AtomicReference<AppliedPTransform<?, ?, Combine.Globally<?, ?>>> combine =
           new AtomicReference<>();
       pipeline.traverseTopologically(
           new PipelineVisitor.Defaults() {
             @Override
             public void leaveCompositeTransform(Node node) {
-              if (node.getTransform() instanceof Combine.PerKey) {
+              if (node.getTransform() instanceof Combine.Globally) {
                 checkState(combine.get() == null);
                 combine.set((AppliedPTransform) node.toAppliedPTransform(getPipeline()));
               }
@@ -168,13 +168,13 @@ public class CombineTranslationTest {
           };
 
       input.apply(Combine.globally(combineFn).withSideInputs(sideInputs).withoutDefaults());
-      final AtomicReference<AppliedPTransform<?, ?, Combine.PerKey<?, ?, ?>>> combine =
+      final AtomicReference<AppliedPTransform<?, ?, Combine.Globally<?, ?>>> combine =
           new AtomicReference<>();
       pipeline.traverseTopologically(
           new PipelineVisitor.Defaults() {
             @Override
             public void leaveCompositeTransform(Node node) {
-              if (node.getTransform() instanceof Combine.PerKey) {
+              if (node.getTransform() instanceof Combine.Globally) {
                 checkState(combine.get() == null);
                 combine.set((AppliedPTransform) node.toAppliedPTransform(getPipeline()));
               }
