diff --git a/sdks/python/apache_beam/transforms/core.py b/sdks/python/apache_beam/transforms/core.py
index 6c48b23bd79..54fb369b1a7 100644
--- a/sdks/python/apache_beam/transforms/core.py
+++ b/sdks/python/apache_beam/transforms/core.py
@@ -596,7 +596,7 @@ class DoFn(WithTypeHints, HasDisplayData, urns.RunnerApiFn):
       **kwargs: other keyword arguments.
 
     Returns:
-      An Iterable of output elements.
+      An Iterable of output elements or None.
     """
     raise NotImplementedError
 
diff --git a/sdks/python/apache_beam/typehints/decorators.py b/sdks/python/apache_beam/typehints/decorators.py
index aab45d947ea..aec6568df1f 100644
--- a/sdks/python/apache_beam/typehints/decorators.py
+++ b/sdks/python/apache_beam/typehints/decorators.py
@@ -95,6 +95,7 @@ from builtins import zip
 
 from apache_beam.typehints import native_type_compatibility
 from apache_beam.typehints import typehints
+from apache_beam.typehints.native_type_compatibility import convert_to_beam_type
 from apache_beam.typehints.typehints import CompositeTypeHintError
 from apache_beam.typehints.typehints import SimpleTypeHintError
 from apache_beam.typehints.typehints import check_constraint
@@ -254,16 +255,16 @@ class IOTypeHints(object):
           input_args.append(typehints.Any)
       else:
         if param.kind in [param.KEYWORD_ONLY, param.VAR_KEYWORD]:
-          input_kwargs[param.name] = param.annotation
+          input_kwargs[param.name] = convert_to_beam_type(param.annotation)
         else:
           assert param.kind in [param.POSITIONAL_ONLY,
                                 param.POSITIONAL_OR_KEYWORD,
                                 param.VAR_POSITIONAL], \
               'Unsupported Parameter kind: %s' % param.kind
-          input_args.append(param.annotation)
+          input_args.append(convert_to_beam_type(param.annotation))
     output_args = []
     if signature.return_annotation != signature.empty:
-      output_args.append(signature.return_annotation)
+      output_args.append(convert_to_beam_type(signature.return_annotation))
     else:
       output_args.append(typehints.Any)
 
diff --git a/sdks/python/apache_beam/typehints/decorators_test.py b/sdks/python/apache_beam/typehints/decorators_test.py
index 645fae6cd8c..4096e220310 100644
--- a/sdks/python/apache_beam/typehints/decorators_test.py
+++ b/sdks/python/apache_beam/typehints/decorators_test.py
@@ -26,6 +26,7 @@ from apache_beam.typehints import Any
 from apache_beam.typehints import List
 from apache_beam.typehints import WithTypeHints
 from apache_beam.typehints import decorators
+from apache_beam.typehints import typehints
 
 decorators._enable_from_callable = True
 
@@ -72,6 +73,41 @@ class IOTypeHintsTest(unittest.TestCase):
                         {'__unknown__keywords': decorators._ANY_VAR_KEYWORD}))
     self.assertEqual(th.output_types, ((Any,), {}))
 
+  def test_strip_iterable_not_simple_output_noop(self):
+    th = decorators.IOTypeHints(output_types=((int, str), {}))
+    th.strip_iterable()
+    self.assertEqual(((int, str), {}), th.output_types)
+
+  def _test_strip_iterable(self, before, expected_after):
+    after = decorators.IOTypeHints(
+        output_types=((before,), {})).strip_iterable()
+    self.assertEqual(((expected_after, ), {}), after.output_types)
+
+  def _test_strip_iterable_fail(self, before):
+    with self.assertRaisesRegex(ValueError, r'not iterable'):
+      self._test_strip_iterable(before, None)
+
+  def test_strip_iterable(self):
+    # TODO(BEAM-8492): Uncomment once #9895 is merged.
+    # self._test_strip_iterable(None, None)
+    self._test_strip_iterable(typehints.Any, typehints.Any)
+    self._test_strip_iterable(typehints.Iterable[str], str)
+    self._test_strip_iterable(typehints.List[str], str)
+    self._test_strip_iterable(typehints.Iterator[str], str)
+    self._test_strip_iterable(typehints.Generator[str], str)
+    self._test_strip_iterable(typehints.Tuple[str], str)
+    self._test_strip_iterable(typehints.Tuple[str, int],
+                              typehints.Union[str, int])
+    self._test_strip_iterable(typehints.Tuple[str, ...], str)
+    self._test_strip_iterable(typehints.KV[str, int],
+                              typehints.Union[str, int])
+    self._test_strip_iterable(typehints.Dict[str, int], str)
+    self._test_strip_iterable(typehints.Set[str], str)
+
+    self._test_strip_iterable_fail(typehints.Union[str, int])
+    self._test_strip_iterable_fail(typehints.Optional[str])
+    self._test_strip_iterable_fail(typehints.WindowedValue[str])
+
 
 class WithTypeHintsTest(unittest.TestCase):
   def test_get_type_hints_no_settings(self):
diff --git a/sdks/python/apache_beam/typehints/decorators_test_py3.py b/sdks/python/apache_beam/typehints/decorators_test_py3.py
index d48f84575f8..e66b140aea3 100644
--- a/sdks/python/apache_beam/typehints/decorators_test_py3.py
+++ b/sdks/python/apache_beam/typehints/decorators_test_py3.py
@@ -19,6 +19,7 @@
 
 from __future__ import absolute_import
 
+import typing
 import unittest
 
 # patches unittest.TestCase to be python3 compatible
@@ -33,18 +34,20 @@ from apache_beam.typehints import decorators
 
 decorators._enable_from_callable = True
 T = TypeVariable('T')
+# Name is 'T' so it converts to a beam type with the same name.
+T_typing = typing.TypeVar('T')
 
 
 class IOTypeHintsTest(unittest.TestCase):
 
   def test_from_callable(self):
     def fn(a: int, b: str = None, *args: Tuple[T], foo: List[int],
-           **kwargs: Dict[str, str]) -> Tuple:
+           **kwargs: Dict[str, str]) -> Tuple[Any, ...]:
       return a, b, args, foo, kwargs
     th = decorators.IOTypeHints.from_callable(fn)
     self.assertEqual(th.input_types, (
         (int, str, Tuple[T]), {'foo': List[int], 'kwargs': Dict[str, str]}))
-    self.assertEqual(th.output_types, ((Tuple,), {}))
+    self.assertEqual(th.output_types, ((Tuple[Any, ...],), {}))
 
   def test_from_callable_partial_annotations(self):
     def fn(a: int, b=None, *args, foo: List[int], **kwargs):
@@ -77,9 +80,22 @@ class IOTypeHintsTest(unittest.TestCase):
     self.assertEqual(th.input_types, ((T,), {}))
     self.assertEqual(th.output_types, ((None,), {}))
 
+  def test_from_callable_convert_to_beam_types(self):
+    def fn(a: typing.List[int],
+           b: str = None,
+           *args: typing.Tuple[T_typing],
+           foo: typing.List[int],
+           **kwargs: typing.Dict[str, str]) -> typing.Tuple[typing.Any, ...]:
+      return a, b, args, foo, kwargs
+    th = decorators.IOTypeHints.from_callable(fn)
+    self.assertEqual(th.input_types, (
+        (List[int], str, Tuple[T]),
+        {'foo': List[int], 'kwargs': Dict[str, str]}))
+    self.assertEqual(th.output_types, ((Tuple[Any, ...],), {}))
+
   def test_getcallargs_forhints(self):
     def fn(a: int, b: str = None, *args: Tuple[T], foo: List[int],
-           **kwargs: Dict[str, str]) -> Tuple:
+           **kwargs: Dict[str, str]) -> Tuple[Any, ...]:
       return a, b, args, foo, kwargs
     callargs = decorators.getcallargs_forhints(fn, float, foo=List[str])
     self.assertDictEqual(callargs,
@@ -91,7 +107,7 @@ class IOTypeHintsTest(unittest.TestCase):
 
   def test_getcallargs_forhints_default_arg(self):
     # Default args are not necessarily types, so they should be ignored.
-    def fn(a=List[int], b=None, *args, foo=(), **kwargs) -> Tuple:
+    def fn(a=List[int], b=None, *args, foo=(), **kwargs) -> Tuple[Any, ...]:
       return a, b, args, foo, kwargs
     callargs = decorators.getcallargs_forhints(fn)
     self.assertDictEqual(callargs,
diff --git a/sdks/python/apache_beam/typehints/native_type_compatibility.py b/sdks/python/apache_beam/typehints/native_type_compatibility.py
index d73a1cf96e7..7cadc0138a4 100644
--- a/sdks/python/apache_beam/typehints/native_type_compatibility.py
+++ b/sdks/python/apache_beam/typehints/native_type_compatibility.py
@@ -20,6 +20,7 @@
 from __future__ import absolute_import
 
 import collections
+import logging
 import sys
 import typing
 from builtins import next
@@ -27,6 +28,8 @@ from builtins import range
 
 from apache_beam.typehints import typehints
 
+_LOGGER = logging.getLogger(__name__)
+
 # Describes an entry in the type map in convert_to_beam_type.
 # match is a function that takes a user type and returns whether the conversion
 # should trigger.
@@ -251,8 +254,9 @@ def convert_to_beam_type(typ):
   # Find the first matching entry.
   matched_entry = next((entry for entry in type_map if entry.match(typ)), None)
   if not matched_entry:
-    # No match: return original type.
-    return typ
+    # Please add missing type support if you see this message.
+    _LOGGER.info('Using Any for unsupported type: %s', typ)
+    return typehints.Any
 
   if matched_entry.arity == -1:
     arity = _len_arg(typ)
diff --git a/sdks/python/apache_beam/typehints/typehints.py b/sdks/python/apache_beam/typehints/typehints.py
index b64e020b2ef..9c018aec003 100644
--- a/sdks/python/apache_beam/typehints/typehints.py
+++ b/sdks/python/apache_beam/typehints/typehints.py
@@ -1190,9 +1190,14 @@ def get_yielded_type(type_hint):
   if is_consistent_with(type_hint, Iterator[Any]):
     return type_hint.yielded_type
   if is_consistent_with(type_hint, Tuple[Any, ...]):
-    return Union[type_hint.tuple_types]
+    if isinstance(type_hint, TupleConstraint):
+      return Union[type_hint.tuple_types]
+    else:  # TupleSequenceConstraint
+      return type_hint.inner_type
   if is_consistent_with(type_hint, Iterable[Any]):
     return type_hint.inner_type
+  if is_consistent_with(type_hint, Dict[Any, Any]):
+    return type_hint.key_type
   raise ValueError('%s is not iterable' % type_hint)
 
 
