diff --git a/model/pipeline/src/main/proto/schema.proto b/model/pipeline/src/main/proto/schema.proto
index 23c32a0db96..b26fc8fef8d 100644
--- a/model/pipeline/src/main/proto/schema.proto
+++ b/model/pipeline/src/main/proto/schema.proto
@@ -113,7 +113,7 @@ message LogicalType {
 message Option {
   // REQUIRED. Identifier for the option.
   string name = 1;
-  // REQUIRED. Type specifer for the structure of value.
+  // REQUIRED. Type specifier for the structure of value.
   // Conventionally, options that don't require additional configuration should
   // use a boolean type, with the value set to true.
   FieldType type = 2;
@@ -125,6 +125,7 @@ message Row {
 }
 
 message FieldValue {
+  // If none of these are set, value is considered null.
   oneof field_value {
     AtomicTypeValue atomic_value = 1;
     ArrayTypeValue array_value = 2;
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaTranslation.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaTranslation.java
index 4e6921b5226..25983caf2b1 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaTranslation.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaTranslation.java
@@ -17,6 +17,11 @@
  */
 package org.apache.beam.sdk.schemas;
 
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.PipedInputStream;
+import java.io.PipedOutputStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -28,6 +33,7 @@ import org.apache.beam.model.pipeline.v1.SchemaApi.ArrayTypeValue;
 import org.apache.beam.model.pipeline.v1.SchemaApi.AtomicTypeValue;
 import org.apache.beam.model.pipeline.v1.SchemaApi.FieldValue;
 import org.apache.beam.model.pipeline.v1.SchemaApi.IterableTypeValue;
+import org.apache.beam.model.pipeline.v1.SchemaApi.LogicalTypeValue;
 import org.apache.beam.model.pipeline.v1.SchemaApi.MapTypeEntry;
 import org.apache.beam.model.pipeline.v1.SchemaApi.MapTypeValue;
 import org.apache.beam.sdk.annotations.Experimental;
@@ -45,6 +51,7 @@ import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditio
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Maps;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.io.ByteStreams;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Utility methods for translating schemas. */
@@ -319,6 +326,7 @@ public class SchemaTranslation {
             fieldTypeFromProto(protoFieldType.getMapType().getValueType()));
       case LOGICAL_TYPE:
         String urn = protoFieldType.getLogicalType().getUrn();
+        SchemaApi.LogicalType logicalType = protoFieldType.getLogicalType();
         Class<? extends LogicalType<?, ?>> logicalTypeClass = STANDARD_LOGICAL_TYPES.get(urn);
         if (logicalTypeClass != null) {
           try {
@@ -351,22 +359,21 @@ public class SchemaTranslation {
           return FieldType.logicalType(
               (LogicalType)
                   SerializableUtils.deserializeFromByteArray(
-                      protoFieldType.getLogicalType().getPayload().toByteArray(), "logicalType"));
+                      logicalType.getPayload().toByteArray(), "logicalType"));
         } else {
           @Nullable FieldType argumentType = null;
           @Nullable Object argumentValue = null;
-          if (protoFieldType.getLogicalType().hasArgumentType()) {
-            argumentType = fieldTypeFromProto(protoFieldType.getLogicalType().getArgumentType());
-            argumentValue =
-                fieldValueFromProto(argumentType, protoFieldType.getLogicalType().getArgument());
+          if (logicalType.hasArgumentType()) {
+            argumentType = fieldTypeFromProto(logicalType.getArgumentType());
+            argumentValue = fieldValueFromProto(argumentType, logicalType.getArgument());
           }
           return FieldType.logicalType(
               new UnknownLogicalType(
                   urn,
-                  protoFieldType.getLogicalType().getPayload().toByteArray(),
+                  logicalType.getPayload().toByteArray(),
                   argumentType,
                   argumentValue,
-                  fieldTypeFromProto(protoFieldType.getLogicalType().getRepresentation())));
+                  fieldTypeFromProto(logicalType.getRepresentation())));
         }
       default:
         throw new IllegalArgumentException(
@@ -393,6 +400,14 @@ public class SchemaTranslation {
 
   static SchemaApi.FieldValue fieldValueToProto(FieldType fieldType, Object value) {
     FieldValue.Builder builder = FieldValue.newBuilder();
+    if (value == null) {
+      if (fieldType.getNullable()) {
+        return builder.build();
+      } else {
+        throw new RuntimeException("Null value found for field that doesn't support nulls.");
+      }
+    }
+
     switch (fieldType.getTypeName()) {
       case ARRAY:
         return builder
@@ -411,26 +426,74 @@ public class SchemaTranslation {
             .build();
       case ROW:
         return builder.setRowValue(rowToProto((Row) value)).build();
+      case DATETIME:
+        return builder
+            .setLogicalTypeValue(logicalTypeToProto(FieldType.INT64, fieldType, value))
+            .build();
+      case DECIMAL:
+        return builder
+            .setLogicalTypeValue(logicalTypeToProto(FieldType.BYTES, fieldType, value))
+            .build();
       case LOGICAL_TYPE:
+        return builder
+            .setLogicalTypeValue(logicalTypeToProto(fieldType.getLogicalType(), value))
+            .build();
       default:
         return builder.setAtomicValue(primitiveRowFieldToProto(fieldType, value)).build();
     }
   }
 
+  /** Returns if the given field is null and throws exception if it is and can't be. */
+  static boolean isNullFieldValueFromProto(FieldType fieldType, boolean hasNonNullValue) {
+    if (!hasNonNullValue && !fieldType.getNullable()) {
+      throw new RuntimeException("FieldTypeValue has no value but the field cannot be null.");
+    }
+    return !hasNonNullValue;
+  }
+
   static Object fieldValueFromProto(FieldType fieldType, SchemaApi.FieldValue value) {
     switch (fieldType.getTypeName()) {
       case ARRAY:
+        if (isNullFieldValueFromProto(fieldType, value.hasArrayValue())) {
+          return null;
+        }
         return arrayValueFromProto(fieldType.getCollectionElementType(), value.getArrayValue());
       case ITERABLE:
+        if (isNullFieldValueFromProto(fieldType, value.hasIterableValue())) {
+          return null;
+        }
         return iterableValueFromProto(
             fieldType.getCollectionElementType(), value.getIterableValue());
       case MAP:
+        if (isNullFieldValueFromProto(fieldType, value.hasMapValue())) {
+          return null;
+        }
         return mapFromProto(
             fieldType.getMapKeyType(), fieldType.getMapValueType(), value.getMapValue());
       case ROW:
+        if (isNullFieldValueFromProto(fieldType, value.hasRowValue())) {
+          return null;
+        }
         return rowFromProto(value.getRowValue(), fieldType);
       case LOGICAL_TYPE:
+        if (isNullFieldValueFromProto(fieldType, value.hasLogicalTypeValue())) {
+          return null;
+        }
+        return logicalTypeFromProto(fieldType.getLogicalType(), value);
+      case DATETIME:
+        if (isNullFieldValueFromProto(fieldType, value.hasLogicalTypeValue())) {
+          return null;
+        }
+        return logicalTypeFromProto(FieldType.INT64, fieldType, value.getLogicalTypeValue());
+      case DECIMAL:
+        if (isNullFieldValueFromProto(fieldType, value.hasLogicalTypeValue())) {
+          return null;
+        }
+        return logicalTypeFromProto(FieldType.BYTES, fieldType, value.getLogicalTypeValue());
       default:
+        if (isNullFieldValueFromProto(fieldType, value.hasAtomicValue())) {
+          return null;
+        }
         return primitiveFromProto(fieldType, value.getAtomicValue());
     }
   }
@@ -485,6 +548,74 @@ public class SchemaTranslation {
                 entry -> fieldValueFromProto(mapValueType, entry.getValue())));
   }
 
+  /** Converts logical type value from proto using a default type coder. */
+  private static Object logicalTypeFromProto(
+      FieldType baseType, FieldType inputType, LogicalTypeValue value) {
+    try {
+      PipedInputStream in = new PipedInputStream();
+      DataOutputStream stream = new DataOutputStream(new PipedOutputStream(in));
+      switch (baseType.getTypeName()) {
+        case INT64:
+          stream.writeLong(value.getValue().getAtomicValue().getInt64());
+          break;
+        case BYTES:
+          stream.write(value.getValue().getAtomicValue().getBytes().toByteArray());
+          break;
+        default:
+          throw new UnsupportedOperationException(
+              "Unsupported underlying type for parsing logical type via coder.");
+      }
+      stream.close();
+      return SchemaCoderHelpers.coderForFieldType(inputType).decode(in);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /** Converts logical type value to a proto using a default type coder. */
+  private static LogicalTypeValue logicalTypeToProto(
+      FieldType baseType, FieldType inputType, Object value) {
+    try {
+      PipedInputStream in = new PipedInputStream();
+      PipedOutputStream out = new PipedOutputStream(in);
+      SchemaCoderHelpers.coderForFieldType(inputType).encode(value, out);
+      out.close(); // Close required for toByteArray.
+      Object baseObject;
+      switch (baseType.getTypeName()) {
+        case INT64:
+          baseObject = new DataInputStream(in).readLong();
+          break;
+        case BYTES:
+          baseObject = ByteStreams.toByteArray(in);
+          break;
+        default:
+          throw new UnsupportedOperationException(
+              "Unsupported underlying type for producing LogicalType via coder.");
+      }
+      return LogicalTypeValue.newBuilder()
+          .setValue(fieldValueToProto(baseType, baseObject))
+          .build();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private static LogicalTypeValue logicalTypeToProto(LogicalType logicalType, Object value) {
+    return LogicalTypeValue.newBuilder()
+        .setValue(
+            fieldValueToProto(
+                logicalType.getBaseType(), SchemaUtils.toLogicalBaseType(logicalType, value)))
+        .build();
+  }
+
+  private static Object logicalTypeFromProto(
+      LogicalType logicalType, SchemaApi.FieldValue logicalValue) {
+    return SchemaUtils.toLogicalInputType(
+        logicalType,
+        fieldValueFromProto(
+            logicalType.getBaseType(), logicalValue.getLogicalTypeValue().getValue()));
+  }
+
   private static AtomicTypeValue primitiveRowFieldToProto(FieldType fieldType, Object value) {
     switch (fieldType.getTypeName()) {
       case BYTE:
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaUtils.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaUtils.java
index ebddfb38afa..da08269fd4b 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaUtils.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaUtils.java
@@ -18,6 +18,7 @@
 package org.apache.beam.sdk.schemas;
 
 import org.apache.beam.sdk.schemas.Schema.FieldType;
+import org.apache.beam.sdk.schemas.Schema.LogicalType;
 
 /** A set of utility functions for schemas. */
 @SuppressWarnings({
@@ -101,4 +102,24 @@ public class SchemaUtils {
     }
     return result.withNullable(fieldType1.getNullable() || fieldType2.getNullable());
   }
+
+  /**
+   * Returns the base type given a logical type and the input type.
+   *
+   * <p>This function can be used to handle logical types without knowing InputT or BaseT.
+   */
+  public static <InputT, BaseT> BaseT toLogicalBaseType(
+      LogicalType<InputT, BaseT> logicalType, InputT inputType) {
+    return logicalType.toBaseType(inputType);
+  }
+
+  /**
+   * Returns the input type given a logical type and the base type.
+   *
+   * <p>This function can be used to handle logical types without knowing InputT or BaseT.
+   */
+  public static <BaseT, InputT> InputT toLogicalInputType(
+      LogicalType<InputT, BaseT> logicalType, BaseT baseType) {
+    return logicalType.toInputType(baseType);
+  }
 }
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java
index 9dd02d32c2f..f7f434d02c4 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java
@@ -43,6 +43,7 @@ import org.apache.beam.sdk.schemas.FieldValueGetter;
 import org.apache.beam.sdk.schemas.Schema;
 import org.apache.beam.sdk.schemas.Schema.FieldType;
 import org.apache.beam.sdk.schemas.Schema.TypeName;
+import org.apache.beam.sdk.schemas.SchemaUtils;
 import org.apache.beam.sdk.values.RowUtils.CapturingRowCases;
 import org.apache.beam.sdk.values.RowUtils.FieldOverride;
 import org.apache.beam.sdk.values.RowUtils.FieldOverrides;
@@ -460,7 +461,10 @@ public abstract class Row implements Serializable {
       if (a == null || b == null) {
         return a == b;
       } else if (fieldType.getTypeName() == TypeName.LOGICAL_TYPE) {
-        return deepEquals(a, b, fieldType.getLogicalType().getBaseType());
+        return deepEquals(
+            SchemaUtils.toLogicalBaseType(fieldType.getLogicalType(), a),
+            SchemaUtils.toLogicalBaseType(fieldType.getLogicalType(), b),
+            fieldType.getLogicalType().getBaseType());
       } else if (fieldType.getTypeName() == Schema.TypeName.BYTES) {
         return Arrays.equals((byte[]) a, (byte[]) b);
       } else if (fieldType.getTypeName() == TypeName.ARRAY) {
@@ -598,6 +602,9 @@ public abstract class Row implements Serializable {
   }
 
   private String toString(Schema.FieldType fieldType, Object value, boolean includeFieldNames) {
+    if (value == null) {
+      return "<null>";
+    }
     StringBuilder builder = new StringBuilder();
     switch (fieldType.getTypeName()) {
       case ARRAY:
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTranslationTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTranslationTest.java
index 9f1f7d47efa..2c0cadb45ea 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTranslationTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/SchemaTranslationTest.java
@@ -22,6 +22,8 @@ import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.equalTo;
 import static org.junit.Assert.assertThrows;
 
+import java.math.BigDecimal;
+import java.time.LocalDateTime;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -36,12 +38,14 @@ import org.apache.beam.model.pipeline.v1.SchemaApi.FieldValue;
 import org.apache.beam.model.pipeline.v1.SchemaApi.LogicalType;
 import org.apache.beam.sdk.schemas.Schema.Field;
 import org.apache.beam.sdk.schemas.Schema.FieldType;
+import org.apache.beam.sdk.schemas.logicaltypes.DateTime;
 import org.apache.beam.sdk.schemas.logicaltypes.FixedBytes;
 import org.apache.beam.sdk.schemas.logicaltypes.MicrosInstant;
 import org.apache.beam.sdk.values.Row;
 import org.apache.beam.vendor.grpc.v1p43p2.com.google.protobuf.ByteString;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Charsets;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
+import org.joda.time.Instant;
 import org.junit.Test;
 import org.junit.experimental.runners.Enclosed;
 import org.junit.runner.RunWith;
@@ -173,6 +177,9 @@ public class SchemaTranslationTest {
           .add(
               Schema.of(
                   Field.of("null_argument", FieldType.logicalType(new NullArgumentLogicalType()))))
+          .add(Schema.of(Field.of("logical_argument", FieldType.logicalType(new DateTime()))))
+          .add(
+              Schema.of(Field.of("single_arg_argument", FieldType.logicalType(FixedBytes.of(100)))))
           .build();
     }
 
@@ -290,6 +297,72 @@ public class SchemaTranslationTest {
     }
   }
 
+  /** Tests round-trip proto encodings for {@link Row}. */
+  @RunWith(Parameterized.class)
+  public static class RowToFromProtoTest {
+
+    public static Row simpleRow(FieldType type, Object value) {
+      return Row.withSchema(Schema.of(Field.of("s", type))).addValue(value).build();
+    }
+
+    public static Row simpleNullRow(FieldType type) {
+      return Row.withSchema(Schema.of(Field.nullable("s", type))).addValue(null).build();
+    }
+
+    @Parameters(name = "{index}: {0}")
+    public static Iterable<Row> data() {
+      Map<String, Integer> map = new HashMap<>();
+      map.put("string", 42);
+      List<String> list = new ArrayList<>();
+      list.add("string");
+      Schema schema =
+          Schema.builder()
+              .addField("field_one", FieldType.STRING)
+              .addField("field_two", FieldType.INT32)
+              .build();
+      Row row = Row.withSchema(schema).addValue("value").addValue(42).build();
+
+      return ImmutableList.<Row>builder()
+          .add(simpleRow(FieldType.STRING, "string"))
+          .add(simpleRow(FieldType.BOOLEAN, true))
+          .add(simpleRow(FieldType.BYTE, (byte) 12))
+          .add(simpleRow(FieldType.INT16, (short) 12))
+          .add(simpleRow(FieldType.INT32, 12))
+          .add(simpleRow(FieldType.INT64, 12L))
+          .add(simpleRow(FieldType.BYTES, new byte[] {0x42, 0x69, 0x00}))
+          .add(simpleRow(FieldType.FLOAT, (float) 12))
+          .add(simpleRow(FieldType.DOUBLE, 12.0))
+          .add(simpleRow(FieldType.map(FieldType.STRING, FieldType.INT32), map))
+          .add(simpleRow(FieldType.array(FieldType.STRING), list))
+          .add(simpleRow(FieldType.row(row.getSchema()), row))
+          .add(simpleRow(FieldType.DATETIME, new Instant(23L)))
+          .add(simpleRow(FieldType.DECIMAL, BigDecimal.valueOf(100000)))
+          .add(simpleRow(FieldType.logicalType(new NullArgumentLogicalType()), "str"))
+          .add(simpleRow(FieldType.logicalType(new DateTime()), LocalDateTime.of(2000, 1, 3, 3, 1)))
+          .add(simpleNullRow(FieldType.STRING))
+          .add(simpleNullRow(FieldType.INT32))
+          .add(simpleNullRow(FieldType.map(FieldType.STRING, FieldType.INT32)))
+          .add(simpleNullRow(FieldType.array(FieldType.STRING)))
+          .add(simpleNullRow(FieldType.row(row.getSchema())))
+          .add(simpleNullRow(FieldType.logicalType(new NullArgumentLogicalType())))
+          .add(simpleNullRow(FieldType.logicalType(new DateTime())))
+          .add(simpleNullRow(FieldType.DECIMAL))
+          .add(simpleNullRow(FieldType.DATETIME))
+          .build();
+    }
+
+    @Parameter(0)
+    public Row row;
+
+    @Test
+    public void toAndFromProto() throws Exception {
+      SchemaApi.Row rowProto = SchemaTranslation.rowToProto(row);
+      Row decodedRow =
+          (Row) SchemaTranslation.rowFromProto(rowProto, FieldType.row(row.getSchema()));
+      assertThat(decodedRow, equalTo(row));
+    }
+  }
+
   /** Tests that we raise helpful errors when decoding bad {@link Schema} protos. */
   @RunWith(JUnit4.class)
   public static class DecodeErrorTest {
