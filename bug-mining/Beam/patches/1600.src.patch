diff --git a/sdks/python/apache_beam/typehints/native_type_compatibility.py b/sdks/python/apache_beam/typehints/native_type_compatibility.py
index 240db005748..0b38315083c 100644
--- a/sdks/python/apache_beam/typehints/native_type_compatibility.py
+++ b/sdks/python/apache_beam/typehints/native_type_compatibility.py
@@ -26,7 +26,6 @@ import logging
 import sys
 import typing
 from builtins import next
-from builtins import range
 
 from apache_beam.typehints import typehints
 
@@ -41,54 +40,34 @@ _TypeMapEntry = collections.namedtuple(
     '_TypeMapEntry', ['match', 'arity', 'beam_type'])
 
 
-def _get_compatible_args(typ):
-  if isinstance(typ, typing.TypeVar):
-    return (typ.__name__,)
-  # On Python versions < 3.5.3, the Tuple and Union type from typing do
-  # not have an __args__ attribute, but a __tuple_params__, and a
-  # __union_params__ argument respectively.
-  if (3, 0, 0) <= sys.version_info[0:3] < (3, 5, 3):
-    if getattr(typ, '__tuple_params__', None) is not None:
-      if typ.__tuple_use_ellipsis__:
-        return typ.__tuple_params__ + (Ellipsis,)
-      else:
-        return typ.__tuple_params__
-    elif getattr(typ, '__union_params__', None) is not None:
-      return typ.__union_params__
-  return None
-
-
 def _get_args(typ):
-  """Returns the index-th argument to the given type."""
-  try:
-    return typ.__args__
-  except AttributeError:
-    compatible_args = _get_compatible_args(typ)
-    if compatible_args is None:
-      raise
-    return compatible_args
-
-
-def _get_arg(typ, index):
-  """Returns the index-th argument to the given type."""
-  try:
-    return typ.__args__[index]
-  except AttributeError:
-    compatible_args = _get_compatible_args(typ)
-    if compatible_args is None:
-      raise
-    return compatible_args[index]
+  """Returns a list of arguments to the given type.
 
+  Args:
+    typ: A typing module typing type.
 
-def _len_arg(typ):
-  """Returns the length of the arguments to the given type."""
+  Returns:
+    A tuple of args.
+  """
   try:
-    return len(typ.__args__)
+    if typ.__args__ is None:
+      return ()
+    return typ.__args__
   except AttributeError:
-    compatible_args = _get_compatible_args(typ)
-    if compatible_args is None:
-      return 0
-    return len(compatible_args)
+    if isinstance(typ, typing.TypeVar):
+      return (typ.__name__,)
+    # On Python versions < 3.5.3, the Tuple and Union type from typing do
+    # not have an __args__ attribute, but a __tuple_params__, and a
+    # __union_params__ argument respectively.
+    if (3, 0, 0) <= sys.version_info[0:3] < (3, 5, 3):
+      if getattr(typ, '__tuple_params__', None) is not None:
+        if typ.__tuple_use_ellipsis__:
+          return typ.__tuple_params__ + (Ellipsis,)
+        else:
+          return typ.__tuple_params__
+      elif getattr(typ, '__union_params__', None) is not None:
+        return typ.__union_params__
+    return ()
 
 
 def _safe_issubclass(derived, parent):
@@ -119,11 +98,6 @@ def _match_issubclass(match_against):
   return lambda user_type: _safe_issubclass(user_type, match_against)
 
 
-def _match_same_type(match_against):
-  # For types that can't be compared with isinstance or _safe_issubclass.
-  return lambda user_type: type(user_type) == type(match_against)
-
-
 def _match_is_exactly_mapping(user_type):
   # Avoid unintentionally catching all subtypes (e.g. strings and mappings).
   if sys.version_info < (3, 7):
@@ -134,6 +108,8 @@ def _match_is_exactly_mapping(user_type):
 
 
 def _match_is_exactly_iterable(user_type):
+  if user_type is typing.Iterable:
+    return True
   # Avoid unintentionally catching all subtypes (e.g. strings and mappings).
   if sys.version_info < (3, 7):
     expected_origin = typing.Iterable
@@ -182,6 +158,10 @@ def _match_is_union(user_type):
   return False
 
 
+def is_Any(typ):
+  return typ is typing.Any
+
+
 # Mapping from typing.TypeVar/typehints.TypeVariable ids to an object of the
 # other type. Bidirectional mapping preserves typing.TypeVar instances.
 _type_var_cache = {}  # type: typing.Dict[int, typehints.TypeVariable]
@@ -223,9 +203,7 @@ def convert_to_beam_type(typ):
 
   type_map = [
       _TypeMapEntry(
-          match=_match_same_type(typing.Any),
-          arity=0,
-          beam_type=typehints.Any),
+          match=is_Any, arity=0, beam_type=typehints.Any),
       _TypeMapEntry(
           match=_match_issubclass(typing.Dict),
           arity=2,
@@ -269,14 +247,33 @@ def convert_to_beam_type(typ):
     _LOGGER.info('Using Any for unsupported type: %s', typ)
     return typehints.Any
 
-  if matched_entry.arity == -1:
-    arity = _len_arg(typ)
+  args = _get_args(typ)
+  len_args = len(args)
+  if len_args == 0 and len_args != matched_entry.arity:
+    arity = matched_entry.arity
+    # Handle unsubscripted types.
+    if _match_issubclass(typing.Tuple)(typ):
+      args = (typehints.TypeVariable('T'), Ellipsis)
+    elif _match_is_union(typ):
+      raise ValueError('Unsupported Union with no arguments.')
+    elif _match_issubclass(typing.Generator)(typ):
+      raise ValueError('Unsupported Generator with no arguments.')
+    elif _match_issubclass(typing.Dict)(typ):
+      args = (typehints.TypeVariable('KT'), typehints.TypeVariable('VT'))
+    elif (_match_issubclass(typing.Iterator)(typ) or
+          _match_issubclass(typing.Generator)(typ) or
+          _match_is_exactly_iterable(typ)):
+      args = (typehints.TypeVariable('T_co'),)
+    else:
+      args = (typehints.TypeVariable('T'),) * arity
+  elif matched_entry.arity == -1:
+    arity = len_args
   else:
     arity = matched_entry.arity
-    if _len_arg(typ) != arity:
+    if len_args != arity:
       raise ValueError('expecting type %s to have arity %d, had arity %d '
-                       'instead' % (str(typ), arity, _len_arg(typ)))
-  typs = [convert_to_beam_type(_get_arg(typ, i)) for i in range(arity)]
+                       'instead' % (str(typ), arity, len_args))
+  typs = convert_to_beam_types(args)
   if arity == 0:
     # Nullary types (e.g. Any) don't accept empty tuples as arguments.
     return matched_entry.beam_type
diff --git a/sdks/python/apache_beam/typehints/native_type_compatibility_test.py b/sdks/python/apache_beam/typehints/native_type_compatibility_test.py
index 969f9c704a9..e70fe875057 100644
--- a/sdks/python/apache_beam/typehints/native_type_compatibility_test.py
+++ b/sdks/python/apache_beam/typehints/native_type_compatibility_test.py
@@ -30,6 +30,7 @@ from apache_beam.typehints.native_type_compatibility import convert_to_beam_type
 from apache_beam.typehints.native_type_compatibility import convert_to_beam_types
 from apache_beam.typehints.native_type_compatibility import convert_to_typing_type
 from apache_beam.typehints.native_type_compatibility import convert_to_typing_types
+from apache_beam.typehints.native_type_compatibility import is_Any
 
 _TestNamedTuple = typing.NamedTuple('_TestNamedTuple',
                                     [('age', int), ('name', bytes)])
@@ -117,6 +118,51 @@ class NativeTypeCompatibilityTest(unittest.TestCase):
         typehints.List[typing.Dict[int, str]],
         typehints.List[typehints.Dict[int, str]])
 
+  def test_convert_bare_types(self):
+    # Conversions for unsubscripted types that have implicit subscripts.
+    test_cases = [
+        ('bare list', typing.List,
+         typehints.List[typehints.TypeVariable('T')]),
+        ('bare dict', typing.Dict,
+         typehints.Dict[typehints.TypeVariable('KT'),
+                        typehints.TypeVariable('VT')]),
+        ('bare tuple', typing.Tuple,
+         typehints.Tuple[typehints.TypeVariable('T'), ...]),
+        ('bare set', typing.Set, typehints.Set[typehints.TypeVariable('T')]),
+        ('bare iterator', typing.Iterator,
+         typehints.Iterator[typehints.TypeVariable('T_co')]),
+        ('bare iterable', typing.Iterable,
+         typehints.Iterable[typehints.TypeVariable('T_co')]),
+        ('nested bare', typing.Tuple[typing.Iterator],
+         typehints.Tuple[typehints.Iterator[typehints.TypeVariable('T_co')]]),
+    ]
+    if sys.version_info >= (3, 7):
+      test_cases += [
+          ('bare generator', typing.Generator,
+           typehints.Generator[typehints.TypeVariable('T_co')]),
+      ]
+    for test_case in test_cases:
+      description = test_case[0]
+      typing_type = test_case[1]
+      expected_beam_type = test_case[2]
+      converted_beam_type = convert_to_beam_type(typing_type)
+      self.assertEqual(expected_beam_type, converted_beam_type, description)
+
+  def test_convert_bare_types_fail(self):
+    # These conversions should fail.
+    test_cases = [
+        ('bare union', typing.Union),
+    ]
+    if sys.version_info < (3, 7):
+      test_cases += [
+          ('bare generator', typing.Generator),
+      ]
+    for test_case in test_cases:
+      description = test_case[0]
+      typing_type = test_case[1]
+      with self.assertRaises(ValueError, msg=description):
+        convert_to_beam_type(typing_type)
+
   def test_convert_to_beam_types(self):
     typing_types = [bytes, typing.List[bytes],
                     typing.List[typing.Tuple[bytes, int]],
@@ -129,6 +175,17 @@ class NativeTypeCompatibilityTest(unittest.TestCase):
     converted_typing_types = convert_to_typing_types(converted_beam_types)
     self.assertEqual(converted_typing_types, typing_types)
 
+  def test_is_any(self):
+    test_cases = [
+        (True, typing.Any),
+        (False, typing.List[int]),
+        (False, typing.Union),
+        (False, 1),
+        (False, 'a'),
+    ]
+    for expected, typ in test_cases:
+      self.assertEqual(expected, is_Any(typ), msg='%s' % typ)
+
 
 if __name__ == '__main__':
   unittest.main()
