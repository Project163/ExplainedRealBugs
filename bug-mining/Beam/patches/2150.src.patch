diff --git a/sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java b/sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java
index a7bd320b5fe..04bb74a37cd 100644
--- a/sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java
+++ b/sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java
@@ -233,6 +233,8 @@ public class XmlSource<T> extends FileBasedSource<T> {
       int charBytesFound = 0;
 
       ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);
+      boolean bufSizeChanged = false;
+
       byte[] recordStartBytes =
           ("<" + getCurrentSource().configuration.getRecordElement())
               .getBytes(StandardCharsets.UTF_8);
@@ -281,7 +283,16 @@ public class XmlSource<T> extends FileBasedSource<T> {
               break outer;
             } else {
               // Matching was unsuccessful. Reset the buffer to include bytes read for the char.
-              ByteBuffer newbuf = ByteBuffer.allocate(BUF_SIZE);
+              int bytesToWrite = buf.remaining() + charBytes.length;
+              ByteBuffer newbuf;
+              if (bytesToWrite > BUF_SIZE) {
+                // Avoiding buffer overflow. The number of bytes to push to the buffer might be
+                // larger than BUF_SIZE due to additional 'charBytes'.
+                newbuf = ByteBuffer.allocate(bytesToWrite);
+                bufSizeChanged = true;
+              } else {
+                newbuf = ByteBuffer.allocate(BUF_SIZE);
+              }
               newbuf.put(charBytes);
               offsetInFileOfCurrentByte -= charBytes.length;
               while (buf.hasRemaining()) {
@@ -320,7 +331,14 @@ public class XmlSource<T> extends FileBasedSource<T> {
             recordStartBytesMatched = true;
           }
         }
-        buf.clear();
+        if (bufSizeChanged) {
+          // We have to reset the size of the buffer to 'BUF_SIZE'
+          // to prevent it from infinitely increasing.
+          buf = ByteBuffer.allocate(BUF_SIZE);
+          bufSizeChanged = false;
+        } else {
+          buf.clear();
+        }
       }
 
       if (!fullyMatched) {
diff --git a/sdks/java/io/xml/src/test/java/org/apache/beam/sdk/io/xml/XmlSourceTest.java b/sdks/java/io/xml/src/test/java/org/apache/beam/sdk/io/xml/XmlSourceTest.java
index f84f8f404a1..0be34cb483a 100644
--- a/sdks/java/io/xml/src/test/java/org/apache/beam/sdk/io/xml/XmlSourceTest.java
+++ b/sdks/java/io/xml/src/test/java/org/apache/beam/sdk/io/xml/XmlSourceTest.java
@@ -158,6 +158,12 @@ public class XmlSourceTest {
           + "<train size=\"small\"><name>CÃ©dric</name><number>7</number><color>blue</color></train>"
           + "</trains>";
 
+  private String trainXMLWithTrainTagsTemplate =
+      "<trains>"
+          + "<train><trainTags>%trainTags%</trainTags><name>Thomas</name><number>1</number><color>blue</color></train>"
+          + "<train><trainTags>%trainTags%</trainTags><name>Henry</name><number>3</number><color>green</color></train>"
+          + "</trains>";
+
   @XmlRootElement
   static class TinyTrain {
     TinyTrain(String name) {
@@ -873,6 +879,42 @@ public class XmlSourceTest {
     assertSplitAtFractionExhaustive(source, options);
   }
 
+  @Test
+  public void testNoBufferOverflowThrown() throws IOException {
+    // The magicNumber was found imperatively and will be different for different xml content.
+    // Test with the current setup causes BufferOverflow in
+    // XMLReader#getFirstOccurenceOfRecordElement method,
+    // if the specific corner case is not handled
+    final int magicNumber = 51;
+    StringBuilder tagsSb = new StringBuilder();
+    for (int j = 0; j < magicNumber; j++) {
+      // tags which start the same way as the record element, trigger
+      // a special flow, which could end up with BufferOverflow
+      // exception
+      tagsSb.append("<trainTag>").append(j).append("</trainTag>");
+    }
+    File file = tempFolder.newFile("trainXMLWithTags");
+
+    String xmlWithNoise = trainXMLWithTrainTagsTemplate.replace("%trainTags%", tagsSb.toString());
+    Files.write(file.toPath(), xmlWithNoise.getBytes(StandardCharsets.UTF_8));
+
+    PCollection<Train> output =
+        p.apply(
+            "ReadFileData",
+            XmlIO.<Train>read()
+                .from(file.toPath().toString())
+                .withRootElement("trains")
+                .withRecordElement("train")
+                .withRecordClass(Train.class)
+                .withMinBundleSize(1024));
+
+    List<Train> expectedResults =
+        ImmutableList.of(
+            new Train("Thomas", 1, "blue", null), new Train("Henry", 3, "green", null));
+    PAssert.that(output).containsInAnyOrder(expectedResults);
+    p.run();
+  }
+
   @Test
   @Ignore(
       "Multi-byte characters in XML are not supported because the parser "
