diff --git a/CHANGES.md b/CHANGES.md
index 7a3238b2613..9d7ac3fdc6b 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -36,6 +36,8 @@
 ## Breaking Changes
 
 * X behavior was changed ([BEAM-X](https://issues.apache.org/jira/browse/BEAM-X)).
+* Python Row objects are now sensitive to field order. So `Row(x=3, y=4)` is no
+  longer considered equal to `Row(y=4, x=3)` (BEAM-11929).
 
 ## Deprecations
 
diff --git a/sdks/python/apache_beam/dataframe/schemas_test.py b/sdks/python/apache_beam/dataframe/schemas_test.py
index 6011475adb4..8b1159cdaa3 100644
--- a/sdks/python/apache_beam/dataframe/schemas_test.py
+++ b/sdks/python/apache_beam/dataframe/schemas_test.py
@@ -122,6 +122,25 @@ class SchemasTest(unittest.TestCase):
           | schemas.BatchRowsAsDataFrame(min_batch_size=10, max_batch_size=10))
       assert_that(res, matches_df(expected))
 
+  def test_simple_df_with_beam_row(self):
+    expected = pd.DataFrame({
+        'name': list(unicode(i) for i in range(5)),
+        'id': list(range(5)),
+        'height': list(float(i) for i in range(5))
+    },
+                            columns=['name', 'id', 'height'])
+
+    with TestPipeline() as p:
+      res = (
+          p
+          | beam.Create([(str(i), i, float(i)) for i in range(5)])
+          | beam.Select(
+              name=lambda r: str(r[0]),
+              id=lambda r: int(r[1]),
+              height=lambda r: float(r[2]))
+          | schemas.BatchRowsAsDataFrame(min_batch_size=10, max_batch_size=10))
+      assert_that(res, matches_df(expected))
+
   def test_generate_proxy(self):
     expected = pd.DataFrame({
         'animal': pd.Series(dtype=pd.StringDtype()),
diff --git a/sdks/python/apache_beam/pvalue.py b/sdks/python/apache_beam/pvalue.py
index eb5ae54517e..28e527adb2f 100644
--- a/sdks/python/apache_beam/pvalue.py
+++ b/sdks/python/apache_beam/pvalue.py
@@ -654,6 +654,9 @@ class Row(object):
 
   when applied to a PCollection of ints will produce a PCollection with schema
   `(x=int, y=float)`.
+
+  Note that in Beam 2.30.0 and later, Row objects are sensitive to field order.
+  So `Row(x=3, y=4)` is not considered equal to `Row(y=4, x=3)`.
   """
   def __init__(self, **kwargs):
     self.__dict__.update(kwargs)
@@ -662,21 +665,21 @@ class Row(object):
     return dict(self.__dict__)
 
   def __iter__(self):
-    for _, value in sorted(self.__dict__.items()):
+    for _, value in self.__dict__.items():
       yield value
 
   def __repr__(self):
-    return 'Row(%s)' % ', '.join(
-        '%s=%r' % kv for kv in sorted(self.__dict__.items()))
+    return 'Row(%s)' % ', '.join('%s=%r' % kv for kv in self.__dict__.items())
 
   def __hash__(self):
-    return hash(type(sorted(self.__dict__.items())))
+    return hash(self.__dict__.items())
 
   def __eq__(self, other):
-    return type(self) == type(other) and self.__dict__ == other.__dict__
+    return type(self) == type(other) and all(
+        s == o for s, o in zip(self.__dict__.items(), other.__dict__.items()))
 
   def __reduce__(self):
-    return _make_Row, tuple(sorted(self.__dict__.items()))
+    return _make_Row, tuple(self.__dict__.items())
 
 
 def _make_Row(*items):
