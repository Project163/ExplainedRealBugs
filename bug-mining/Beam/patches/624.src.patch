diff --git a/sdks/go/pkg/beam/runners/dataflow/dataflow.go b/sdks/go/pkg/beam/runners/dataflow/dataflow.go
index 9bdc2acb141..35fba1aae22 100644
--- a/sdks/go/pkg/beam/runners/dataflow/dataflow.go
+++ b/sdks/go/pkg/beam/runners/dataflow/dataflow.go
@@ -31,6 +31,7 @@ import (
 
 	"github.com/apache/beam/sdks/go/pkg/beam"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/graph"
 	// Importing to get the side effect of the remote execution hook. See init().
 	_ "github.com/apache/beam/sdks/go/pkg/beam/core/runtime/harness/init"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/util/hooks"
@@ -45,7 +46,6 @@ import (
 	"golang.org/x/oauth2/google"
 	df "google.golang.org/api/dataflow/v1b3"
 	"google.golang.org/api/storage/v1"
-	"github.com/apache/beam/sdks/go/pkg/beam/core/graph"
 )
 
 // TODO(herohde) 5/16/2017: the Dataflow flags should match the other SDKs.
@@ -129,13 +129,20 @@ func Execute(ctx context.Context, p *beam.Pipeline) error {
 
 	bin := *jobopts.WorkerBinary
 	if bin == "" {
-		worker, err := runnerlib.BuildTempWorkerBinary(ctx)
-		if err != nil {
-			return err
+		if self, ok := runnerlib.IsWorkerCompatibleBinary(); ok {
+			bin = self
+			log.Infof(ctx, "Using running binary as worker binary: '%v'", bin)
+		} else {
+			// Cross-compile as last resort.
+
+			worker, err := runnerlib.BuildTempWorkerBinary(ctx)
+			if err != nil {
+				return err
+			}
+			defer os.Remove(worker)
+
+			bin = worker
 		}
-		defer os.Remove(worker)
-
-		bin = worker
 	} else {
 		log.Infof(ctx, "Using specified worker binary: '%v'", bin)
 	}
diff --git a/sdks/go/pkg/beam/runners/universal/runnerlib/compile.go b/sdks/go/pkg/beam/runners/universal/runnerlib/compile.go
index 52cf4682d21..efb82ba40a7 100644
--- a/sdks/go/pkg/beam/runners/universal/runnerlib/compile.go
+++ b/sdks/go/pkg/beam/runners/universal/runnerlib/compile.go
@@ -30,6 +30,15 @@ import (
 	"github.com/apache/beam/sdks/go/pkg/beam/log"
 )
 
+// IsWorkerCompatibleBinary returns the path to itself and true if running
+// a linux-amd64 binary that can directly be used as a worker binary.
+func IsWorkerCompatibleBinary() (string, bool) {
+	if runtime.GOOS == "linux" && runtime.GOARCH == "amd64" {
+		return os.Args[0], true
+	}
+	return "", false
+}
+
 // BuildTempWorkerBinary creates a local worker binary in the tmp directory
 // for linux/amd64. Caller responsible for deleting the binary.
 func BuildTempWorkerBinary(ctx context.Context) (string, error) {
diff --git a/sdks/go/pkg/beam/runners/universal/runnerlib/execute.go b/sdks/go/pkg/beam/runners/universal/runnerlib/execute.go
index 558c68e3be6..08bb3d510a3 100644
--- a/sdks/go/pkg/beam/runners/universal/runnerlib/execute.go
+++ b/sdks/go/pkg/beam/runners/universal/runnerlib/execute.go
@@ -50,13 +50,20 @@ func Execute(ctx context.Context, p *pb.Pipeline, endpoint string, opt *JobOptio
 
 	bin := opt.Worker
 	if bin == "" {
-		worker, err := BuildTempWorkerBinary(ctx)
-		if err != nil {
-			return "", err
+		if self, ok := IsWorkerCompatibleBinary(); ok {
+			bin = self
+			log.Infof(ctx, "Using running binary as worker binary: '%v'", bin)
+		} else {
+			// Cross-compile as last resort.
+
+			worker, err := BuildTempWorkerBinary(ctx)
+			if err != nil {
+				return "", err
+			}
+			defer os.Remove(worker)
+
+			bin = worker
 		}
-		defer os.Remove(worker)
-
-		bin = worker
 	} else {
 		log.Infof(ctx, "Using specified worker binary: '%v'", bin)
 	}
