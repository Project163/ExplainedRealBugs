diff --git a/sdks/go/pkg/beam/core/metrics/metrics.go b/sdks/go/pkg/beam/core/metrics/metrics.go
index 841bcdf6ad4..ec0aeccbc25 100644
--- a/sdks/go/pkg/beam/core/metrics/metrics.go
+++ b/sdks/go/pkg/beam/core/metrics/metrics.go
@@ -533,10 +533,22 @@ func MergeCounters(
 	attempted map[StepKey]int64,
 	committed map[StepKey]int64) []CounterResult {
 	res := make([]CounterResult, 0)
+	merged := map[StepKey]CounterResult{}
 
-	for k := range attempted {
-		v := committed[k]
-		res = append(res, CounterResult{Attempted: attempted[k], Committed: v, Key: k})
+	for k, v := range attempted {
+		merged[k] = CounterResult{Attempted: v, Key: k}
+	}
+	for k, v := range committed {
+		m, ok := merged[k]
+		if ok {
+			merged[k] = CounterResult{Attempted: m.Attempted, Committed: v, Key: k}
+		} else {
+			merged[k] = CounterResult{Committed: v, Key: k}
+		}
+	}
+
+	for _, v := range merged {
+		res = append(res, v)
 	}
 	return res
 }
@@ -563,10 +575,22 @@ func MergeDistributions(
 	attempted map[StepKey]DistributionValue,
 	committed map[StepKey]DistributionValue) []DistributionResult {
 	res := make([]DistributionResult, 0)
+	merged := map[StepKey]DistributionResult{}
+
+	for k, v := range attempted {
+		merged[k] = DistributionResult{Attempted: v, Key: k}
+	}
+	for k, v := range committed {
+		m, ok := merged[k]
+		if ok {
+			merged[k] = DistributionResult{Attempted: m.Attempted, Committed: v, Key: k}
+		} else {
+			merged[k] = DistributionResult{Committed: v, Key: k}
+		}
+	}
 
-	for k := range attempted {
-		v := committed[k]
-		res = append(res, DistributionResult{Attempted: attempted[k], Committed: v, Key: k})
+	for _, v := range merged {
+		res = append(res, v)
 	}
 	return res
 }
@@ -598,10 +622,22 @@ func MergeGauges(
 	attempted map[StepKey]GaugeValue,
 	committed map[StepKey]GaugeValue) []GaugeResult {
 	res := make([]GaugeResult, 0)
+	merged := map[StepKey]GaugeResult{}
+
+	for k, v := range attempted {
+		merged[k] = GaugeResult{Attempted: v, Key: k}
+	}
+	for k, v := range committed {
+		m, ok := merged[k]
+		if ok {
+			merged[k] = GaugeResult{Attempted: m.Attempted, Committed: v, Key: k}
+		} else {
+			merged[k] = GaugeResult{Committed: v, Key: k}
+		}
+	}
 
-	for k := range attempted {
-		v := committed[k]
-		res = append(res, GaugeResult{Attempted: attempted[k], Committed: v, Key: k})
+	for _, v := range merged {
+		res = append(res, v)
 	}
 	return res
 }
diff --git a/sdks/go/pkg/beam/core/metrics/metrics_test.go b/sdks/go/pkg/beam/core/metrics/metrics_test.go
index a0127d99b22..db247291abb 100644
--- a/sdks/go/pkg/beam/core/metrics/metrics_test.go
+++ b/sdks/go/pkg/beam/core/metrics/metrics_test.go
@@ -20,6 +20,9 @@ import (
 	"fmt"
 	"testing"
 	"time"
+
+	"github.com/google/go-cmp/cmp"
+	"github.com/google/go-cmp/cmp/cmpopts"
 )
 
 // bID is a bundleId to use in the tests, if nothing more specific is needed.
@@ -304,6 +307,147 @@ func TestNameCollisions(t *testing.T) {
 	}
 }
 
+func TestMergeCounters(t *testing.T) {
+	realKey := StepKey{Name: "real"}
+	tests := []struct {
+		name                 string
+		attempted, committed map[StepKey]int64
+		want                 []CounterResult
+	}{
+		{
+			name: "merge",
+			attempted: map[StepKey]int64{
+				realKey: 5,
+			},
+			committed: map[StepKey]int64{
+				realKey: 7,
+			},
+			want: []CounterResult{{Attempted: 5, Committed: 7, Key: realKey}},
+		}, {
+			name: "attempted only",
+			attempted: map[StepKey]int64{
+				realKey: 5,
+			},
+			committed: map[StepKey]int64{},
+			want:      []CounterResult{{Attempted: 5, Key: realKey}},
+		}, {
+			name:      "committed only",
+			attempted: map[StepKey]int64{},
+			committed: map[StepKey]int64{
+				realKey: 7,
+			},
+			want: []CounterResult{{Committed: 7, Key: realKey}},
+		},
+	}
+	less := func(a, b CounterResult) bool {
+		return a.Key.Name < b.Key.Name
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			got := MergeCounters(test.attempted, test.committed)
+			if d := cmp.Diff(test.want, got, cmpopts.SortSlices(less)); d != "" {
+				t.Errorf("MergeCounters(%+v, %+v) = %+v, want %+v\ndiff:\n%v", test.attempted, test.committed, got, test.want, d)
+			}
+		})
+	}
+}
+
+func TestMergeDistributions(t *testing.T) {
+	realKey := StepKey{Name: "real"}
+	distA := DistributionValue{Count: 2, Sum: 5, Min: 1, Max: 4}
+	distB := DistributionValue{Count: 3, Sum: 5, Min: 1, Max: 2}
+	tests := []struct {
+		name                 string
+		attempted, committed map[StepKey]DistributionValue
+		want                 []DistributionResult
+	}{
+		{
+			name: "merge",
+			attempted: map[StepKey]DistributionValue{
+				realKey: distA,
+			},
+			committed: map[StepKey]DistributionValue{
+				realKey: distB,
+			},
+			want: []DistributionResult{{Attempted: distA, Committed: distB, Key: realKey}},
+		}, {
+			name: "attempted only",
+			attempted: map[StepKey]DistributionValue{
+				realKey: distA,
+			},
+			committed: map[StepKey]DistributionValue{},
+			want:      []DistributionResult{{Attempted: distA, Key: realKey}},
+		}, {
+			name:      "committed only",
+			attempted: map[StepKey]DistributionValue{},
+			committed: map[StepKey]DistributionValue{
+				realKey: distB,
+			},
+			want: []DistributionResult{{Committed: distB, Key: realKey}},
+		},
+	}
+	less := func(a, b DistributionResult) bool {
+		return a.Key.Name < b.Key.Name
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			got := MergeDistributions(test.attempted, test.committed)
+			if d := cmp.Diff(test.want, got, cmpopts.SortSlices(less)); d != "" {
+				t.Errorf("MergeDistributions(%+v, %+v) = %+v, want %+v\ndiff:\n%v", test.attempted, test.committed, got, test.want, d)
+			}
+		})
+	}
+}
+
+func TestMergeGauges(t *testing.T) {
+	realKey := StepKey{Name: "real"}
+	now := time.Now()
+	later := now.Add(time.Hour)
+	gaugeA := GaugeValue{Value: 2, Timestamp: now}
+	gaugeB := GaugeValue{Value: 3, Timestamp: later}
+	tests := []struct {
+		name                 string
+		attempted, committed map[StepKey]GaugeValue
+		want                 []GaugeResult
+	}{
+		{
+			name: "merge",
+			attempted: map[StepKey]GaugeValue{
+				realKey: gaugeA,
+			},
+			committed: map[StepKey]GaugeValue{
+				realKey: gaugeB,
+			},
+			want: []GaugeResult{{Attempted: gaugeA, Committed: gaugeB, Key: realKey}},
+		}, {
+			name: "attempted only",
+			attempted: map[StepKey]GaugeValue{
+				realKey: gaugeA,
+			},
+			committed: map[StepKey]GaugeValue{},
+			want:      []GaugeResult{{Attempted: gaugeA, Key: realKey}},
+		}, {
+			name:      "committed only",
+			attempted: map[StepKey]GaugeValue{},
+			committed: map[StepKey]GaugeValue{
+				realKey: gaugeB,
+			},
+			want: []GaugeResult{{Committed: gaugeB, Key: realKey}},
+		},
+	}
+	less := func(a, b DistributionResult) bool {
+		return a.Key.Name < b.Key.Name
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			got := MergeGauges(test.attempted, test.committed)
+			if d := cmp.Diff(test.want, got, cmpopts.SortSlices(less)); d != "" {
+				t.Errorf("MergeGauges(%+v, %+v) = %+v, want %+v\ndiff:\n%v", test.attempted, test.committed, got, test.want, d)
+			}
+		})
+	}
+}
+
 // Run on @lostluck's desktop (2020/01/21) go1.13.4
 //
 // Allocs & bytes should be consistent within go versions, but ns/op is relative to the running machine.
