diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkPipelineRunner.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkPipelineRunner.java
index f3dc60fd937..e61cb1243dc 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkPipelineRunner.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkPipelineRunner.java
@@ -20,17 +20,22 @@ package org.apache.beam.runners.flink;
 import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.hasUnboundedPCollections;
 
 import java.util.List;
+import java.util.Map;
 import javax.annotation.Nullable;
 import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.model.pipeline.v1.RunnerApi.Pipeline;
 import org.apache.beam.runners.core.construction.graph.ExecutableStage;
 import org.apache.beam.runners.core.construction.graph.GreedyPipelineFuser;
 import org.apache.beam.runners.core.construction.graph.PipelineTrimmer;
+import org.apache.beam.runners.core.metrics.MetricsPusher;
+import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineResult;
 import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineRunner;
 import org.apache.beam.runners.fnexecution.provisioning.JobInfo;
-import org.apache.beam.sdk.PipelineResult;
 import org.apache.beam.sdk.metrics.MetricsEnvironment;
+import org.apache.beam.sdk.metrics.MetricsOptions;
+import org.apache.beam.sdk.options.PipelineOptions;
 import org.apache.flink.api.common.JobExecutionResult;
+import org.apache.flink.client.program.DetachedEnvironment;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -50,7 +55,7 @@ public class FlinkPipelineRunner implements PortablePipelineRunner {
   }
 
   @Override
-  public PipelineResult run(final Pipeline pipeline, JobInfo jobInfo) throws Exception {
+  public PortablePipelineResult run(final Pipeline pipeline, JobInfo jobInfo) throws Exception {
     MetricsEnvironment.setMetricsSupported(false);
 
     FlinkPortablePipelineTranslator<?> translator;
@@ -64,7 +69,7 @@ public class FlinkPipelineRunner implements PortablePipelineRunner {
   }
 
   private <T extends FlinkPortablePipelineTranslator.TranslationContext>
-      PipelineResult runPipelineWithTranslator(
+      PortablePipelineResult runPipelineWithTranslator(
           final Pipeline pipeline, JobInfo jobInfo, FlinkPortablePipelineTranslator<T> translator)
           throws Exception {
     LOG.info("Translating pipeline to Flink program.");
@@ -86,6 +91,33 @@ public class FlinkPipelineRunner implements PortablePipelineRunner {
             fusedPipeline);
     final JobExecutionResult result = executor.execute(pipelineOptions.getJobName());
 
-    return FlinkRunner.createPipelineResult(result, pipelineOptions);
+    return createPortablePipelineResult(result, pipelineOptions);
+  }
+
+  private PortablePipelineResult createPortablePipelineResult(
+      JobExecutionResult result, PipelineOptions options) {
+    if (result instanceof DetachedEnvironment.DetachedJobExecutionResult) {
+      LOG.info("Pipeline submitted in Detached mode");
+      // no metricsPusher because metrics are not supported in detached mode
+      return new FlinkPortableRunnerResult.Detached();
+    } else {
+      LOG.info("Execution finished in {} msecs", result.getNetRuntime());
+      Map<String, Object> accumulators = result.getAllAccumulatorResults();
+      if (accumulators != null && !accumulators.isEmpty()) {
+        LOG.info("Final accumulator values:");
+        for (Map.Entry<String, Object> entry : result.getAllAccumulatorResults().entrySet()) {
+          LOG.info("{} : {}", entry.getKey(), entry.getValue());
+        }
+      }
+      FlinkPortableRunnerResult flinkRunnerResult =
+          new FlinkPortableRunnerResult(accumulators, result.getNetRuntime());
+      MetricsPusher metricsPusher =
+          new MetricsPusher(
+              flinkRunnerResult.getMetricsContainerStepMap(),
+              options.as(MetricsOptions.class),
+              flinkRunnerResult);
+      metricsPusher.start();
+      return flinkRunnerResult;
+    }
   }
 }
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkPortableRunnerResult.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkPortableRunnerResult.java
new file mode 100644
index 00000000000..b23c4fc71a7
--- /dev/null
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkPortableRunnerResult.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.flink;
+
+import java.util.Map;
+import org.apache.beam.model.jobmanagement.v1.JobApi;
+import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineResult;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/** Result of executing a portable {@link org.apache.beam.sdk.Pipeline} with Flink. */
+public class FlinkPortableRunnerResult extends FlinkRunnerResult implements PortablePipelineResult {
+
+  private static final Logger LOG = LoggerFactory.getLogger(FlinkPortableRunnerResult.class);
+
+  FlinkPortableRunnerResult(Map<String, Object> accumulators, long runtime) {
+    super(accumulators, runtime);
+  }
+
+  @Override
+  public JobApi.MetricResults portableMetrics() throws UnsupportedOperationException {
+    LOG.warn("Collecting monitoring infos is not implemented yet in Flink portable runner.");
+    return JobApi.MetricResults.newBuilder().build();
+  }
+
+  static class Detached extends FlinkDetachedRunnerResult implements PortablePipelineResult {
+
+    @Override
+    public JobApi.MetricResults portableMetrics() throws UnsupportedOperationException {
+      LOG.warn(
+          "Collecting monitoring infos is not implemented yet in Flink portable runner (detached mode).");
+      return JobApi.MetricResults.newBuilder().build();
+    }
+  }
+}
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/JobInvocation.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/JobInvocation.java
index 0538d290c16..bf4cc63b383 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/JobInvocation.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/JobInvocation.java
@@ -53,7 +53,7 @@ public class JobInvocation {
   private List<Consumer<Enum>> stateObservers;
   private List<Consumer<JobMessage>> messageObservers;
   private JobState.Enum jobState;
-  @Nullable private ListenableFuture<PipelineResult> invocationFuture;
+  @Nullable private ListenableFuture<PortablePipelineResult> invocationFuture;
 
   public JobInvocation(
       JobInfo jobInfo,
@@ -70,7 +70,7 @@ public class JobInvocation {
     this.jobState = JobState.Enum.STOPPED;
   }
 
-  private PipelineResult runPipeline() throws Exception {
+  private PortablePipelineResult runPipeline() throws Exception {
     return pipelineRunner.run(pipeline, jobInfo);
   }
 
@@ -86,9 +86,9 @@ public class JobInvocation {
     setState(JobState.Enum.RUNNING);
     Futures.addCallback(
         invocationFuture,
-        new FutureCallback<PipelineResult>() {
+        new FutureCallback<PortablePipelineResult>() {
           @Override
-          public void onSuccess(PipelineResult pipelineResult) {
+          public void onSuccess(PortablePipelineResult pipelineResult) {
             if (pipelineResult != null) {
               switch (pipelineResult.getState()) {
                 case DONE:
@@ -148,9 +148,9 @@ public class JobInvocation {
       this.invocationFuture.cancel(true /* mayInterruptIfRunning */);
       Futures.addCallback(
           invocationFuture,
-          new FutureCallback<PipelineResult>() {
+          new FutureCallback<PortablePipelineResult>() {
             @Override
-            public void onSuccess(PipelineResult pipelineResult) {
+            public void onSuccess(PortablePipelineResult pipelineResult) {
               // Do not cancel when we are already done.
               if (pipelineResult != null
                   && pipelineResult.getState() != PipelineResult.State.DONE) {
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/PortablePipelineRunner.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/PortablePipelineRunner.java
index 08adee6cbc1..01a58f6eb99 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/PortablePipelineRunner.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/PortablePipelineRunner.java
@@ -19,9 +19,8 @@ package org.apache.beam.runners.fnexecution.jobsubmission;
 
 import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.runners.fnexecution.provisioning.JobInfo;
-import org.apache.beam.sdk.PipelineResult;
 
 /** Runs a portable Beam pipeline on some execution engine. */
 public interface PortablePipelineRunner {
-  PipelineResult run(RunnerApi.Pipeline pipeline, JobInfo jobInfo) throws Exception;
+  PortablePipelineResult run(RunnerApi.Pipeline pipeline, JobInfo jobInfo) throws Exception;
 }
diff --git a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/JobInvocationTest.java b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/JobInvocationTest.java
index bbd8c1f85e7..5012e52bade 100644
--- a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/JobInvocationTest.java
+++ b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/JobInvocationTest.java
@@ -135,21 +135,22 @@ public class JobInvocationTest {
   private static class ControllablePipelineRunner implements PortablePipelineRunner {
 
     private final CountDownLatch latch = new CountDownLatch(1);
-    private volatile PipelineResult result;
+    private volatile PortablePipelineResult result;
 
     @Override
-    public PipelineResult run(RunnerApi.Pipeline pipeline, JobInfo jobInfo) throws Exception {
+    public PortablePipelineResult run(RunnerApi.Pipeline pipeline, JobInfo jobInfo)
+        throws Exception {
       latch.await();
       return result;
     }
 
-    void setResult(PipelineResult pipelineResult) {
+    void setResult(PortablePipelineResult pipelineResult) {
       result = pipelineResult;
       latch.countDown();
     }
   }
 
-  private static class TestPipelineResult implements PipelineResult {
+  private static class TestPipelineResult implements PortablePipelineResult {
 
     private final State state;
     private final CountDownLatch cancelLatch = new CountDownLatch(1);
@@ -183,5 +184,10 @@ public class JobInvocationTest {
     public MetricResults metrics() {
       return null;
     }
+
+    @Override
+    public JobApi.MetricResults portableMetrics() {
+      return null;
+    }
   }
 }
diff --git a/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaPipelineRunner.java b/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaPipelineRunner.java
index 175b3eb00b6..85bd576b902 100644
--- a/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaPipelineRunner.java
+++ b/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaPipelineRunner.java
@@ -21,9 +21,9 @@ import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.model.pipeline.v1.RunnerApi.Pipeline;
 import org.apache.beam.runners.core.construction.graph.GreedyPipelineFuser;
 import org.apache.beam.runners.core.construction.renderer.PipelineDotRenderer;
+import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineResult;
 import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineRunner;
 import org.apache.beam.runners.fnexecution.provisioning.JobInfo;
-import org.apache.beam.sdk.PipelineResult;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -35,7 +35,7 @@ public class SamzaPipelineRunner implements PortablePipelineRunner {
   private final SamzaPipelineOptions options;
 
   @Override
-  public PipelineResult run(final Pipeline pipeline, JobInfo jobInfo) {
+  public PortablePipelineResult run(final Pipeline pipeline, JobInfo jobInfo) {
     // Fused pipeline proto.
     final RunnerApi.Pipeline fusedPipeline = GreedyPipelineFuser.fuse(pipeline).toPipeline();
     LOG.info("Portable pipeline to run:");
diff --git a/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaPortablePipelineResult.java b/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaPortablePipelineResult.java
new file mode 100644
index 00000000000..11c8b556e38
--- /dev/null
+++ b/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaPortablePipelineResult.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.samza;
+
+import org.apache.beam.model.jobmanagement.v1.JobApi;
+import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineResult;
+import org.apache.samza.application.StreamApplication;
+import org.apache.samza.config.Config;
+import org.apache.samza.runtime.ApplicationRunner;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/** The result from executing a Samza Portable Pipeline. */
+public class SamzaPortablePipelineResult extends SamzaPipelineResult
+    implements PortablePipelineResult {
+
+  private static final Logger LOG = LoggerFactory.getLogger(SamzaPortablePipelineResult.class);
+
+  SamzaPortablePipelineResult(
+      StreamApplication app,
+      ApplicationRunner runner,
+      SamzaExecutionContext executionContext,
+      SamzaPipelineLifeCycleListener listener,
+      Config config) {
+    super(app, runner, executionContext, listener, config);
+  }
+
+  @Override
+  public JobApi.MetricResults portableMetrics() throws UnsupportedOperationException {
+    LOG.warn("Collecting monitoring infos is not implemented yet in Samza portable runner.");
+    return JobApi.MetricResults.newBuilder().build();
+  }
+}
diff --git a/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaRunner.java b/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaRunner.java
index aa9c10b00d3..0eb50c4b6e9 100644
--- a/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaRunner.java
+++ b/runners/samza/src/main/java/org/apache/beam/runners/samza/SamzaRunner.java
@@ -24,6 +24,7 @@ import java.util.Map;
 import java.util.ServiceLoader;
 import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.runners.core.construction.renderer.PipelineDotRenderer;
+import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineResult;
 import org.apache.beam.runners.samza.translation.ConfigBuilder;
 import org.apache.beam.runners.samza.translation.PViewToIdMapper;
 import org.apache.beam.runners.samza.translation.PortableTranslationContext;
@@ -70,7 +71,7 @@ public class SamzaRunner extends PipelineRunner<SamzaPipelineResult> {
         listenerReg.hasNext() ? Iterators.getOnlyElement(listenerReg).getLifeCycleListener() : null;
   }
 
-  public SamzaPipelineResult runPortablePipeline(RunnerApi.Pipeline pipeline) {
+  public PortablePipelineResult runPortablePipeline(RunnerApi.Pipeline pipeline) {
     final ConfigBuilder configBuilder = new ConfigBuilder(options);
     SamzaPortablePipelineTranslator.createConfig(pipeline, configBuilder, options);
 
@@ -93,7 +94,7 @@ public class SamzaRunner extends PipelineRunner<SamzaPipelineResult> {
         };
 
     ApplicationRunner runner = runSamzaApp(app, config);
-    return new SamzaPipelineResult(app, runner, executionContext, listener, config);
+    return new SamzaPortablePipelineResult(app, runner, executionContext, listener, config);
   }
 
   @Override
diff --git a/runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineResult.java b/runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineResult.java
index afada94509d..fd3fbcff6a1 100644
--- a/runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineResult.java
+++ b/runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineResult.java
@@ -25,6 +25,8 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import org.apache.beam.model.jobmanagement.v1.JobApi;
+import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineResult;
 import org.apache.beam.runners.spark.metrics.MetricsAccumulator;
 import org.apache.beam.runners.spark.translation.SparkContextFactory;
 import org.apache.beam.sdk.Pipeline;
@@ -35,6 +37,8 @@ import org.apache.spark.SparkException;
 import org.apache.spark.api.java.JavaSparkContext;
 import org.apache.spark.streaming.api.java.JavaStreamingContext;
 import org.joda.time.Duration;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /** Represents a Spark pipeline execution result. */
 public abstract class SparkPipelineResult implements PipelineResult {
@@ -142,6 +146,21 @@ public abstract class SparkPipelineResult implements PipelineResult {
     }
   }
 
+  static class PortableBatchMode extends BatchMode implements PortablePipelineResult {
+
+    private static final Logger LOG = LoggerFactory.getLogger(BatchMode.class);
+
+    PortableBatchMode(Future<?> pipelineExecution, JavaSparkContext javaSparkContext) {
+      super(pipelineExecution, javaSparkContext);
+    }
+
+    @Override
+    public JobApi.MetricResults portableMetrics() throws UnsupportedOperationException {
+      LOG.warn("Collecting monitoring infos is not implemented yet in Spark portable runner.");
+      return JobApi.MetricResults.newBuilder().build();
+    }
+  }
+
   /** Represents a streaming Spark pipeline result. */
   static class StreamingMode extends SparkPipelineResult {
 
diff --git a/runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineRunner.java b/runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineRunner.java
index 53716390612..725df7513f6 100644
--- a/runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineRunner.java
+++ b/runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineRunner.java
@@ -29,6 +29,7 @@ import org.apache.beam.runners.core.construction.graph.ExecutableStage;
 import org.apache.beam.runners.core.construction.graph.GreedyPipelineFuser;
 import org.apache.beam.runners.core.construction.graph.PipelineTrimmer;
 import org.apache.beam.runners.core.metrics.MetricsPusher;
+import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineResult;
 import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineRunner;
 import org.apache.beam.runners.fnexecution.provisioning.JobInfo;
 import org.apache.beam.runners.spark.aggregators.AggregatorsAccumulator;
@@ -54,7 +55,7 @@ public class SparkPipelineRunner implements PortablePipelineRunner {
   }
 
   @Override
-  public SparkPipelineResult run(RunnerApi.Pipeline pipeline, JobInfo jobInfo) {
+  public PortablePipelineResult run(RunnerApi.Pipeline pipeline, JobInfo jobInfo) {
     SparkBatchPortablePipelineTranslator translator = new SparkBatchPortablePipelineTranslator();
 
     // Don't let the fuser fuse any subcomponents of native transforms.
@@ -102,7 +103,8 @@ public class SparkPipelineRunner implements PortablePipelineRunner {
               LOG.info(String.format("Job %s finished.", jobInfo.jobId()));
             });
 
-    SparkPipelineResult result = new SparkPipelineResult.BatchMode(submissionFuture, jsc);
+    PortablePipelineResult result =
+        new SparkPipelineResult.PortableBatchMode(submissionFuture, jsc);
     MetricsPusher metricsPusher =
         new MetricsPusher(
             MetricsAccumulator.getInstance().value(),
