diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/PTransformTranslation.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/PTransformTranslation.java
index 9916d135c8d..53fe744491b 100644
--- a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/PTransformTranslation.java
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/PTransformTranslation.java
@@ -84,6 +84,11 @@ public class PTransformTranslation {
   public static final String SPLITTABLE_PROCESS_ELEMENTS_URN =
       getUrn(SplittableParDoComponents.PROCESS_ELEMENTS);
 
+  public static final String ITERABLE_SIDE_INPUT =
+      getUrn(RunnerApi.StandardSideInputTypes.Enum.ITERABLE);
+  public static final String MULTIMAP_SIDE_INPUT =
+      getUrn(RunnerApi.StandardSideInputTypes.Enum.MULTIMAP);
+
   private static final Map<Class<? extends PTransform>, TransformPayloadTranslator>
       KNOWN_PAYLOAD_TRANSLATORS = loadTransformPayloadTranslators();
 
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkBatchSideInputHandlerFactory.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkBatchSideInputHandlerFactory.java
index ef46d598ce1..78a5acad2e7 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkBatchSideInputHandlerFactory.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkBatchSideInputHandlerFactory.java
@@ -23,10 +23,14 @@ import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
+import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.model.pipeline.v1.RunnerApi.ExecutableStagePayload.SideInputId;
+import org.apache.beam.runners.core.construction.PTransformTranslation;
 import org.apache.beam.runners.core.construction.graph.ExecutableStage;
 import org.apache.beam.runners.core.construction.graph.PipelineNode.PCollectionNode;
 import org.apache.beam.runners.core.construction.graph.SideInputReference;
@@ -34,6 +38,7 @@ import org.apache.beam.runners.fnexecution.state.StateRequestHandler;
 import org.apache.beam.runners.fnexecution.state.StateRequestHandlers.MultimapSideInputHandler;
 import org.apache.beam.runners.fnexecution.state.StateRequestHandlers.MultimapSideInputHandlerFactory;
 import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.KvCoder;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.values.KV;
@@ -74,19 +79,67 @@ class FlinkBatchSideInputHandlerFactory implements MultimapSideInputHandlerFacto
   }
 
   @Override
-  public <K, V, W extends BoundedWindow> MultimapSideInputHandler<K, V, W> forSideInput(
+  public <T, V, W extends BoundedWindow> MultimapSideInputHandler<V, W> forSideInput(
       String transformId,
       String sideInputId,
-      Coder<K> keyCoder,
-      Coder<V> valueCoder,
+      RunnerApi.FunctionSpec accessPattern,
+      Coder<T> elementCoder,
       Coder<W> windowCoder) {
+
     PCollectionNode collectionNode =
         sideInputToCollection.get(
             SideInputId.newBuilder().setTransformId(transformId).setLocalName(sideInputId).build());
     checkArgument(collectionNode != null, "No side input for %s/%s", transformId, sideInputId);
-    List<WindowedValue<KV<K, V>>> broadcastVariable =
-        runtimeContext.getBroadcastVariable(collectionNode.getId());
 
+    if (PTransformTranslation.ITERABLE_SIDE_INPUT.equals(accessPattern.getUrn())) {
+      @SuppressWarnings("unchecked") // T == V
+      Coder<V> outputCoder = (Coder<V>) elementCoder;
+      return forIterableSideInput(
+          runtimeContext.getBroadcastVariable(collectionNode.getId()), outputCoder, windowCoder);
+    } else if (PTransformTranslation.MULTIMAP_SIDE_INPUT.equals(accessPattern.getUrn())) {
+      @SuppressWarnings("unchecked") // T == KV<?, V>
+      KvCoder<?, V> kvCoder = (KvCoder<?, V>) elementCoder;
+      return forMultimapSideInput(
+          runtimeContext.getBroadcastVariable(collectionNode.getId()),
+          kvCoder.getKeyCoder(),
+          kvCoder.getValueCoder(),
+          windowCoder);
+    } else {
+      throw new IllegalArgumentException(
+          String.format("Unknown side input access pattern: %s", accessPattern));
+    }
+  }
+
+  private <T, W extends BoundedWindow> MultimapSideInputHandler<T, W> forIterableSideInput(
+      List<WindowedValue<T>> broadcastVariable, Coder<T> elementCoder, Coder<W> windowCoder) {
+    ImmutableMultimap.Builder<Object, T> multimapBuilder = ImmutableMultimap.builder();
+    for (WindowedValue<T> windowedValue : broadcastVariable) {
+      for (BoundedWindow boundedWindow : windowedValue.getWindows()) {
+        @SuppressWarnings("unchecked")
+        W window = (W) boundedWindow;
+        multimapBuilder.put(windowCoder.structuralValue(window), windowedValue.getValue());
+      }
+    }
+    ImmutableMultimap<Object, T> multimap = multimapBuilder.build();
+
+    return new MultimapSideInputHandler<T, W>() {
+      @Override
+      public Iterable<T> get(byte[] key, W window) {
+        return multimap.get(windowCoder.structuralValue(window));
+      }
+
+      @Override
+      public Coder<T> resultCoder() {
+        return elementCoder;
+      }
+    };
+  }
+
+  private <K, V, W extends BoundedWindow> MultimapSideInputHandler<V, W> forMultimapSideInput(
+      List<WindowedValue<KV<K, V>>> broadcastVariable,
+      Coder<K> keyCoder,
+      Coder<V> valueCoder,
+      Coder<W> windowCoder) {
     ImmutableMultimap.Builder<SideInputKey, V> multimap = ImmutableMultimap.builder();
     for (WindowedValue<KV<K, V>> windowedValue : broadcastVariable) {
       K key = windowedValue.getValue().getKey();
@@ -101,28 +154,53 @@ class FlinkBatchSideInputHandlerFactory implements MultimapSideInputHandlerFacto
       }
     }
 
-    return new SideInputHandler<>(multimap.build(), keyCoder, windowCoder);
+    return new SideInputHandler<>(multimap.build(), keyCoder, valueCoder, windowCoder);
+  }
+
+  private <T> List<WindowedValue<T>> getBroadcastVariable(String transformId, String sideInputId) {
+    PCollectionNode collectionNode =
+        sideInputToCollection.get(
+            SideInputId.newBuilder().setTransformId(transformId).setLocalName(sideInputId).build());
+    checkArgument(collectionNode != null, "No side input for %s/%s", transformId, sideInputId);
+    return runtimeContext.getBroadcastVariable(collectionNode.getId());
   }
 
   private static class SideInputHandler<K, V, W extends BoundedWindow>
-      implements MultimapSideInputHandler<K, V, W> {
+      implements MultimapSideInputHandler<V, W> {
 
     private final Multimap<SideInputKey, V> collection;
     private final Coder<K> keyCoder;
+    private final Coder<V> valueCoder;
     private final Coder<W> windowCoder;
 
     private SideInputHandler(
-        Multimap<SideInputKey, V> collection, Coder<K> keyCoder, Coder<W> windowCoder) {
+        Multimap<SideInputKey, V> collection,
+        Coder<K> keyCoder,
+        Coder<V> valueCoder,
+        Coder<W> windowCoder) {
       this.collection = collection;
       this.keyCoder = keyCoder;
+      this.valueCoder = valueCoder;
       this.windowCoder = windowCoder;
     }
 
     @Override
-    public Iterable<V> get(K key, W window) {
+    public Iterable<V> get(byte[] keyBytes, W window) {
+      K key;
+      try {
+        // TODO: We could skip decoding and just compare encoded values for deterministic keyCoders.
+        key = keyCoder.decode(new ByteArrayInputStream(keyBytes));
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
       return collection.get(
           SideInputKey.of(keyCoder.structuralValue(key), windowCoder.structuralValue(window)));
     }
+
+    @Override
+    public Coder<V> resultCoder() {
+      return valueCoder;
+    }
   }
 
   @AutoValue
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/functions/FlinkBatchSideInputHandlerFactoryTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/functions/FlinkBatchSideInputHandlerFactoryTest.java
index f3afd0b5d7d..0219b58b198 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/functions/FlinkBatchSideInputHandlerFactoryTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/functions/FlinkBatchSideInputHandlerFactoryTest.java
@@ -24,18 +24,23 @@ import static org.hamcrest.Matchers.emptyIterable;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.mockito.Mockito.when;
 
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.model.pipeline.v1.RunnerApi.Components;
 import org.apache.beam.model.pipeline.v1.RunnerApi.Environment;
+import org.apache.beam.runners.core.construction.PTransformTranslation;
 import org.apache.beam.runners.core.construction.graph.ExecutableStage;
 import org.apache.beam.runners.core.construction.graph.ImmutableExecutableStage;
 import org.apache.beam.runners.core.construction.graph.PipelineNode;
 import org.apache.beam.runners.core.construction.graph.PipelineNode.PCollectionNode;
 import org.apache.beam.runners.core.construction.graph.SideInputReference;
 import org.apache.beam.runners.fnexecution.state.StateRequestHandlers.MultimapSideInputHandler;
+import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.KvCoder;
 import org.apache.beam.sdk.coders.StringUtf8Coder;
 import org.apache.beam.sdk.coders.VarIntCoder;
 import org.apache.beam.sdk.coders.VoidCoder;
@@ -65,6 +70,10 @@ public class FlinkBatchSideInputHandlerFactoryTest {
   private static final String TRANSFORM_ID = "transform-id";
   private static final String SIDE_INPUT_NAME = "side-input";
   private static final String COLLECTION_ID = "collection";
+  private static final RunnerApi.FunctionSpec MULTIMAP_ACCESS =
+      RunnerApi.FunctionSpec.newBuilder().setUrn(PTransformTranslation.MULTIMAP_SIDE_INPUT).build();
+  private static final RunnerApi.FunctionSpec ITERABLE_ACCESS =
+      RunnerApi.FunctionSpec.newBuilder().setUrn(PTransformTranslation.ITERABLE_SIDE_INPUT).build();
   private static final ExecutableStage EXECUTABLE_STAGE =
       createExecutableStage(
           Arrays.asList(
@@ -73,6 +82,8 @@ public class FlinkBatchSideInputHandlerFactoryTest {
                   SIDE_INPUT_NAME,
                   PipelineNode.pCollection(
                       COLLECTION_ID, RunnerApi.PCollection.getDefaultInstance()))));
+  private static final byte[] ENCODED_NULL = encode(null, VoidCoder.of());
+  private static final byte[] ENCODED_FOO = encode("foo", StringUtf8Coder.of());
 
   @Rule public ExpectedException thrown = ExpectedException.none();
 
@@ -90,23 +101,27 @@ public class FlinkBatchSideInputHandlerFactoryTest {
         FlinkBatchSideInputHandlerFactory.forStage(stage, context);
     thrown.expect(instanceOf(IllegalArgumentException.class));
     factory.forSideInput(
-        "transform-id", "side-input", VoidCoder.of(), VoidCoder.of(), GlobalWindow.Coder.INSTANCE);
+        "transform-id",
+        "side-input",
+        MULTIMAP_ACCESS,
+        KvCoder.of(VoidCoder.of(), VoidCoder.of()),
+        GlobalWindow.Coder.INSTANCE);
   }
 
   @Test
   public void emptyResultForEmptyCollection() {
     FlinkBatchSideInputHandlerFactory factory =
         FlinkBatchSideInputHandlerFactory.forStage(EXECUTABLE_STAGE, context);
-    MultimapSideInputHandler<Void, Integer, GlobalWindow> handler =
+    MultimapSideInputHandler<Integer, GlobalWindow> handler =
         factory.forSideInput(
             TRANSFORM_ID,
             SIDE_INPUT_NAME,
-            VoidCoder.of(),
-            VarIntCoder.of(),
+            MULTIMAP_ACCESS,
+            KvCoder.of(VoidCoder.of(), VarIntCoder.of()),
             GlobalWindow.Coder.INSTANCE);
     // We never populated the broadcast variable for "side-input", so the mock will return an empty
     // list.
-    Iterable<Integer> result = handler.get(null, GlobalWindow.INSTANCE);
+    Iterable<Integer> result = handler.get(ENCODED_NULL, GlobalWindow.INSTANCE);
     assertThat(result, emptyIterable());
   }
 
@@ -118,14 +133,14 @@ public class FlinkBatchSideInputHandlerFactoryTest {
 
     FlinkBatchSideInputHandlerFactory factory =
         FlinkBatchSideInputHandlerFactory.forStage(EXECUTABLE_STAGE, context);
-    MultimapSideInputHandler<Void, Integer, GlobalWindow> handler =
+    MultimapSideInputHandler<Integer, GlobalWindow> handler =
         factory.forSideInput(
             TRANSFORM_ID,
             SIDE_INPUT_NAME,
-            VoidCoder.of(),
-            VarIntCoder.of(),
+            MULTIMAP_ACCESS,
+            KvCoder.of(VoidCoder.of(), VarIntCoder.of()),
             GlobalWindow.Coder.INSTANCE);
-    Iterable<Integer> result = handler.get(null, GlobalWindow.INSTANCE);
+    Iterable<Integer> result = handler.get(ENCODED_NULL, GlobalWindow.INSTANCE);
     assertThat(result, contains(3));
   }
 
@@ -140,14 +155,14 @@ public class FlinkBatchSideInputHandlerFactoryTest {
 
     FlinkBatchSideInputHandlerFactory factory =
         FlinkBatchSideInputHandlerFactory.forStage(EXECUTABLE_STAGE, context);
-    MultimapSideInputHandler<String, Integer, GlobalWindow> handler =
+    MultimapSideInputHandler<Integer, GlobalWindow> handler =
         factory.forSideInput(
             TRANSFORM_ID,
             SIDE_INPUT_NAME,
-            StringUtf8Coder.of(),
-            VarIntCoder.of(),
+            MULTIMAP_ACCESS,
+            KvCoder.of(StringUtf8Coder.of(), VarIntCoder.of()),
             GlobalWindow.Coder.INSTANCE);
-    Iterable<Integer> result = handler.get("foo", GlobalWindow.INSTANCE);
+    Iterable<Integer> result = handler.get(ENCODED_FOO, GlobalWindow.INSTANCE);
     assertThat(result, containsInAnyOrder(2, 5));
   }
 
@@ -170,19 +185,49 @@ public class FlinkBatchSideInputHandlerFactoryTest {
 
     FlinkBatchSideInputHandlerFactory factory =
         FlinkBatchSideInputHandlerFactory.forStage(EXECUTABLE_STAGE, context);
-    MultimapSideInputHandler<String, Integer, IntervalWindow> handler =
+    MultimapSideInputHandler<Integer, IntervalWindow> handler =
         factory.forSideInput(
             TRANSFORM_ID,
             SIDE_INPUT_NAME,
-            StringUtf8Coder.of(),
-            VarIntCoder.of(),
+            MULTIMAP_ACCESS,
+            KvCoder.of(StringUtf8Coder.of(), VarIntCoder.of()),
             IntervalWindowCoder.of());
-    Iterable<Integer> resultA = handler.get("foo", windowA);
-    Iterable<Integer> resultB = handler.get("foo", windowB);
+    Iterable<Integer> resultA = handler.get(ENCODED_FOO, windowA);
+    Iterable<Integer> resultB = handler.get(ENCODED_FOO, windowB);
     assertThat(resultA, containsInAnyOrder(1, 3));
     assertThat(resultB, containsInAnyOrder(4, 6));
   }
 
+  @Test
+  public void iterableAccessPattern() {
+    Instant instantA = new DateTime(2018, 1, 1, 1, 1, DateTimeZone.UTC).toInstant();
+    Instant instantB = new DateTime(2018, 1, 1, 1, 2, DateTimeZone.UTC).toInstant();
+    Instant instantC = new DateTime(2018, 1, 1, 1, 3, DateTimeZone.UTC).toInstant();
+    IntervalWindow windowA = new IntervalWindow(instantA, instantB);
+    IntervalWindow windowB = new IntervalWindow(instantB, instantC);
+    when(context.getBroadcastVariable(COLLECTION_ID))
+        .thenReturn(
+            Arrays.asList(
+                WindowedValue.of(1, instantA, windowA, PaneInfo.NO_FIRING),
+                WindowedValue.of(2, instantA, windowA, PaneInfo.NO_FIRING),
+                WindowedValue.of(3, instantB, windowB, PaneInfo.NO_FIRING),
+                WindowedValue.of(4, instantB, windowB, PaneInfo.NO_FIRING)));
+
+    FlinkBatchSideInputHandlerFactory factory =
+        FlinkBatchSideInputHandlerFactory.forStage(EXECUTABLE_STAGE, context);
+    SideInputHandler<Integer, IntervalWindow> handler =
+        factory.forSideInput(
+            TRANSFORM_ID,
+            SIDE_INPUT_NAME,
+            ITERABLE_ACCESS,
+            VarIntCoder.of(),
+            IntervalWindowCoder.of());
+    Iterable<Integer> resultA = handler.get(null, windowA);
+    Iterable<Integer> resultB = handler.get(null, windowB);
+    assertThat(resultA, containsInAnyOrder(1, 2));
+    assertThat(resultB, containsInAnyOrder(3, 4));
+  }
+
   private static ExecutableStage createExecutableStage(Collection<SideInputReference> sideInputs) {
     Components components = Components.getDefaultInstance();
     Environment environment = Environment.getDefaultInstance();
@@ -196,4 +241,14 @@ public class FlinkBatchSideInputHandlerFactoryTest {
         Collections.emptyList(),
         Collections.emptyList());
   }
+
+  private static <T> byte[] encode(T value, Coder<T> coder) {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    try {
+      coder.encode(value, out);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+    return out.toByteArray();
+  }
 }
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java
index 2c049687faf..59ad949815a 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java
@@ -24,6 +24,7 @@ import static org.apache.beam.runners.core.construction.SyntheticComponents.uniq
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableTable;
 import com.google.common.collect.Iterables;
+import com.google.protobuf.InvalidProtocolBufferException;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Collections;
@@ -36,6 +37,7 @@ import org.apache.beam.model.fnexecution.v1.BeamFnApi.ProcessBundleDescriptor;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.RemoteGrpcPort;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.Target;
 import org.apache.beam.model.pipeline.v1.Endpoints.ApiServiceDescriptor;
+import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.model.pipeline.v1.RunnerApi.Components;
 import org.apache.beam.model.pipeline.v1.RunnerApi.PCollection;
 import org.apache.beam.model.pipeline.v1.RunnerApi.PTransform;
@@ -47,7 +49,6 @@ import org.apache.beam.runners.fnexecution.data.RemoteInputDestination;
 import org.apache.beam.runners.fnexecution.wire.LengthPrefixUnknownCoders;
 import org.apache.beam.runners.fnexecution.wire.WireCoders;
 import org.apache.beam.sdk.coders.Coder;
-import org.apache.beam.sdk.coders.KvCoder;
 import org.apache.beam.sdk.fn.data.RemoteGrpcPortRead;
 import org.apache.beam.sdk.fn.data.RemoteGrpcPortWrite;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
@@ -239,13 +240,25 @@ public class ProcessBundleDescriptors {
           MultimapSideInputSpec.of(
               sideInputReference.transform().getId(),
               sideInputReference.localName(),
-              ((KvCoder) coder.getValueCoder()).getKeyCoder(),
-              ((KvCoder) coder.getValueCoder()).getValueCoder(),
+              getAccessPattern(sideInputReference),
+              coder.getValueCoder(),
               coder.getWindowCoder()));
     }
     return idsToSpec.build().rowMap();
   }
 
+  private static RunnerApi.FunctionSpec getAccessPattern(SideInputReference sideInputReference) {
+    try {
+      return RunnerApi.ParDoPayload.parseFrom(
+              sideInputReference.transform().getTransform().getSpec().getPayload())
+          .getSideInputsMap()
+          .get(sideInputReference.localName())
+          .getAccessPattern();
+    } catch (InvalidProtocolBufferException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
   @AutoValue
   abstract static class TargetEncoding {
     abstract BeamFnApi.Target getTarget();
@@ -258,24 +271,24 @@ public class ProcessBundleDescriptors {
    * handling multimap side input state requests.
    */
   @AutoValue
-  public abstract static class MultimapSideInputSpec<K, V, W extends BoundedWindow> {
-    static <K, V, W extends BoundedWindow> MultimapSideInputSpec<K, V, W> of(
+  public abstract static class MultimapSideInputSpec<K, T, W extends BoundedWindow> {
+    public static <T, W extends BoundedWindow> MultimapSideInputSpec of(
         String transformId,
         String sideInputId,
-        Coder<K> keyCoder,
-        Coder<V> valueCoder,
+        RunnerApi.FunctionSpec accessPattern,
+        Coder<T> elementCoder,
         Coder<W> windowCoder) {
       return new AutoValue_ProcessBundleDescriptors_MultimapSideInputSpec(
-          transformId, sideInputId, keyCoder, valueCoder, windowCoder);
+          transformId, sideInputId, accessPattern, elementCoder, windowCoder);
     }
 
     public abstract String transformId();
 
     public abstract String sideInputId();
 
-    public abstract Coder<K> keyCoder();
+    public abstract RunnerApi.FunctionSpec accessPattern();
 
-    public abstract Coder<V> valueCoder();
+    public abstract Coder<T> elementCoder();
 
     public abstract Coder<W> windowCoder();
   }
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java
index 57dc744673c..b6b95a78863 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java
@@ -34,6 +34,7 @@ import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateKey;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateKey.TypeCase;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateRequest;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateResponse;
+import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.runners.fnexecution.control.ProcessBundleDescriptors.ExecutableProcessBundleDescriptor;
 import org.apache.beam.runners.fnexecution.control.ProcessBundleDescriptors.MultimapSideInputSpec;
 import org.apache.beam.sdk.coders.Coder;
@@ -55,14 +56,19 @@ public class StateRequestHandlers {
    * <p>Note that this handler is expected to be thread safe as it will be invoked concurrently.
    */
   @ThreadSafe
-  public interface MultimapSideInputHandler<K, V, W extends BoundedWindow> {
+  public interface MultimapSideInputHandler<V, W extends BoundedWindow> {
     /**
      * Returns an {@link Iterable} of values representing the side input for the given key and
      * window.
      *
+     * <p>The key is interpreted according to the access pattern of side input.
+     *
      * <p>TODO: Add support for side input chunking and caching if a {@link Reiterable} is returned.
      */
-    Iterable<V> get(K key, W window);
+    Iterable<V> get(byte[] key, W window);
+
+    /** Returns the {@link Coder} to use for the elements of the resulting values iterable. */
+    Coder<V> resultCoder();
   }
 
   /**
@@ -74,26 +80,26 @@ public class StateRequestHandlers {
   public interface MultimapSideInputHandlerFactory {
 
     /**
-     * Returns a {@link MultimapSideInputHandler} for the given {@code pTransformId} and {@code
-     * sideInputId}. The supplied {@code keyCoder}, {@code valueCoder}, and {@code windowCoder}
-     * should be used to encode/decode their respective values.
+     * Returns a {@link MultimapSideInputHandler} for the given {@code pTransformId}, {@code
+     * sideInputId}, and {@code accessPattern}. The supplied {@code elementCoder} and {@code
+     * windowCoder} should be used to encode/decode their respective values.
      */
-    <K, V, W extends BoundedWindow> MultimapSideInputHandler<K, V, W> forSideInput(
+    <T, V, W extends BoundedWindow> MultimapSideInputHandler<V, W> forSideInput(
         String pTransformId,
         String sideInputId,
-        Coder<K> keyCoder,
-        Coder<V> valueCoder,
+        RunnerApi.FunctionSpec accessPattern,
+        Coder<T> elementCoder,
         Coder<W> windowCoder);
 
     /** Throws a {@link UnsupportedOperationException} on the first access. */
     static MultimapSideInputHandlerFactory unsupported() {
       return new MultimapSideInputHandlerFactory() {
         @Override
-        public <K, V, W extends BoundedWindow> MultimapSideInputHandler<K, V, W> forSideInput(
+        public <T, V, W extends BoundedWindow> MultimapSideInputHandler<V, W> forSideInput(
             String pTransformId,
             String sideInputId,
-            Coder<K> keyCoder,
-            Coder<V> valueCoder,
+            RunnerApi.FunctionSpec accessPattern,
+            Coder<T> elementCoder,
             Coder<W> windowCoder) {
           throw new UnsupportedOperationException(
               String.format(
@@ -213,7 +219,7 @@ public class StateRequestHandlers {
         StateKey.MultimapSideInput stateKey = request.getStateKey().getMultimapSideInput();
         MultimapSideInputSpec<?, ?, ?> sideInputReferenceSpec =
             sideInputSpecs.get(stateKey.getPtransformId()).get(stateKey.getSideInputId());
-        MultimapSideInputHandler<?, ?, ?> handler =
+        MultimapSideInputHandler<?, ?> handler =
             cache.computeIfAbsent(sideInputReferenceSpec, this::createHandler);
 
         switch (request.getRequestCase()) {
@@ -234,7 +240,7 @@ public class StateRequestHandlers {
     }
 
     private <K, V, W extends BoundedWindow> CompletionStage<StateResponse.Builder> handleGetRequest(
-        StateRequest request, MultimapSideInputHandler<K, V, W> handler) throws Exception {
+        StateRequest request, MultimapSideInputHandler<V, W> handler) throws Exception {
       // TODO: Add support for continuation tokens when handling state if the handler
       // returned a {@link Reiterable}.
       checkState(
@@ -246,14 +252,13 @@ public class StateRequestHandlers {
       MultimapSideInputSpec<K, V, W> sideInputReferenceSpec =
           sideInputSpecs.get(stateKey.getPtransformId()).get(stateKey.getSideInputId());
 
-      K key = sideInputReferenceSpec.keyCoder().decode(stateKey.getKey().newInput());
       W window = sideInputReferenceSpec.windowCoder().decode(stateKey.getWindow().newInput());
 
-      Iterable<V> values = handler.get(key, window);
+      Iterable<V> values = handler.get(stateKey.getKey().toByteArray(), window);
       List<ByteString> encodedValues = new ArrayList<>();
       ElementDelimitedOutputStream outputStream = DataStreams.outbound(encodedValues::add);
       for (V value : values) {
-        sideInputReferenceSpec.valueCoder().encode(value, outputStream);
+        handler.resultCoder().encode(value, outputStream);
         outputStream.delimitElement();
       }
       outputStream.close();
@@ -265,13 +270,13 @@ public class StateRequestHandlers {
       return CompletableFuture.completedFuture(response);
     }
 
-    private <K, V, W extends BoundedWindow> MultimapSideInputHandler<K, V, W> createHandler(
+    private <K, V, W extends BoundedWindow> MultimapSideInputHandler<V, W> createHandler(
         MultimapSideInputSpec cacheKey) {
       return multimapSideInputHandlerFactory.forSideInput(
           cacheKey.transformId(),
           cacheKey.sideInputId(),
-          cacheKey.keyCoder(),
-          cacheKey.valueCoder(),
+          cacheKey.accessPattern(),
+          cacheKey.elementCoder(),
           cacheKey.windowCoder());
     }
   }
diff --git a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java
index b3c0b1649ed..926d3bd3e70 100644
--- a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java
+++ b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java
@@ -328,17 +328,22 @@ public class RemoteExecutionTest implements Serializable {
             descriptor.getMultimapSideInputSpecs(),
             new MultimapSideInputHandlerFactory() {
               @Override
-              public <K, V, W extends BoundedWindow> MultimapSideInputHandler<K, V, W> forSideInput(
+              public <T, V, W extends BoundedWindow> MultimapSideInputHandler<V, W> forSideInput(
                   String pTransformId,
                   String sideInputId,
-                  Coder<K> keyCoder,
-                  Coder<V> valueCoder,
+                  RunnerApi.FunctionSpec accessPattern,
+                  Coder<T> elementCoder,
                   Coder<W> windowCoder) {
-                return new MultimapSideInputHandler<K, V, W>() {
+                return new MultimapSideInputHandler<V, W>() {
                   @Override
-                  public Iterable<V> get(K key, W window) {
+                  public Iterable<V> get(byte[] key, W window) {
                     return (Iterable) sideInputData;
                   }
+
+                  @Override
+                  public Coder<V> resultCoder() {
+                    return ((KvCoder) elementCoder).getValueCoder();
+                  }
                 };
               }
             });
