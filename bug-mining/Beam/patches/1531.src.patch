diff --git a/buildSrc/src/main/groovy/org/apache/beam/gradle/BeamModulePlugin.groovy b/buildSrc/src/main/groovy/org/apache/beam/gradle/BeamModulePlugin.groovy
index dc5fe53f47a..6156647cfa0 100644
--- a/buildSrc/src/main/groovy/org/apache/beam/gradle/BeamModulePlugin.groovy
+++ b/buildSrc/src/main/groovy/org/apache/beam/gradle/BeamModulePlugin.groovy
@@ -363,6 +363,7 @@ class BeamModulePlugin implements Plugin<Project> {
     def aws_java_sdk_version = "1.11.519"
     def aws_java_sdk2_version = "2.5.71"
     def cassandra_driver_version = "3.6.0"
+    def classgraph_version = "4.8.56"
     def generated_grpc_beta_version = "0.44.0"
     def generated_grpc_ga_version = "1.43.0"
     def generated_grpc_dc_beta_version = "0.27.0-alpha"
@@ -426,6 +427,7 @@ class BeamModulePlugin implements Plugin<Project> {
         bigdataoss_util                             : "com.google.cloud.bigdataoss:util:$google_cloud_bigdataoss_version",
         cassandra_driver_core                       : "com.datastax.cassandra:cassandra-driver-core:$cassandra_driver_version",
         cassandra_driver_mapping                    : "com.datastax.cassandra:cassandra-driver-mapping:$cassandra_driver_version",
+        classgraph                                  : "io.github.classgraph:classgraph:$classgraph_version",
         commons_codec                               : "commons-codec:commons-codec:1.10",
         commons_compress                            : "org.apache.commons:commons-compress:1.19",
         commons_csv                                 : "org.apache.commons:commons-csv:1.4",
diff --git a/runners/core-construction-java/build.gradle b/runners/core-construction-java/build.gradle
index 1b9759793eb..b9c842fa86f 100644
--- a/runners/core-construction-java/build.gradle
+++ b/runners/core-construction-java/build.gradle
@@ -38,11 +38,11 @@ dependencies {
   compile project(path: ":sdks:java:core", configuration: "shadow")
   compile library.java.vendored_grpc_1_21_0
   compile library.java.vendored_guava_26_0_jre
+  compile library.java.classgraph
   compile library.java.jackson_core
   compile library.java.jackson_databind
   compile library.java.joda_time
   compile library.java.slf4j_api
-  testCompile project(path: ":sdks:java:core", configuration: "testRuntime")
   testCompile library.java.hamcrest_core
   testCompile library.java.hamcrest_library
   testCompile library.java.junit
@@ -50,6 +50,7 @@ dependencies {
   testCompile library.java.jackson_annotations
   testCompile library.java.jackson_dataformat_yaml
   testCompile project(path: ":model:fn-execution", configuration: "shadow")
+  testCompile project(path: ":sdks:java:core", configuration: "testRuntime")
   testRuntimeOnly library.java.slf4j_jdk14
 }
 
diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/ClasspathScanningResourcesDetector.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/ClasspathScanningResourcesDetector.java
index 19657179742..4cdf60b0c6b 100644
--- a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/ClasspathScanningResourcesDetector.java
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/ClasspathScanningResourcesDetector.java
@@ -17,69 +17,35 @@
  */
 package org.apache.beam.runners.core.construction.resources;
 
+import io.github.classgraph.ClassGraph;
 import java.io.File;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.StreamSupport;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Splitter;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import java.util.stream.Stream;
 
 /**
- * Attempts to detect all the resources to be staged using either URLClassLoader (if it is
- * available) or via the "java.class.path" system property. URLClassLoader is not available for Java
- * 9 and above, hence the alternative approach was introduced.
+ * Attempts to detect all the resources to be staged using classgraph library.
+ *
+ * <p>See <a
+ * href="https://github.com/classgraph/classgraph">https://github.com/classgraph/classgraph</a>
  */
 public class ClasspathScanningResourcesDetector implements PipelineResourcesDetector {
 
-  private static final Logger LOG =
-      LoggerFactory.getLogger(ClasspathScanningResourcesDetector.class);
+  private transient ClassGraph classGraph;
+
+  public ClasspathScanningResourcesDetector(ClassGraph classGraph) {
+    this.classGraph = classGraph;
+  }
 
   /**
-   * Detects classpath resources by either using URLClassLoader or java.class.path env variable.
+   * Detects classpath resources and returns a list of absolute paths to them.
    *
    * @param classLoader The classloader to use to detect resources to stage (optional).
-   * @throws IllegalArgumentException If one of the resources the class loader exposes is not a file
-   *     resource.
    * @return A list of absolute paths to the resources the class loader uses.
    */
   @Override
-  public List<String> detect(ClassLoader classLoader) {
-    if (classLoader instanceof URLClassLoader) {
-      return scanClasspathForResourcesToStage((URLClassLoader) classLoader);
-    } else {
-      return scanClasspathForResourcesToStage();
-    }
-  }
-
-  private static List<String> scanClasspathForResourcesToStage() {
-    LOG.info("Scanning classpath for resources to stage via the java.class.path system property.");
-
-    Iterable<String> classpathEntries =
-        Splitter.on(File.pathSeparator).split(System.getProperty("java.class.path"));
-
-    return StreamSupport.stream(classpathEntries.spliterator(), false)
-        .map(File::new)
-        .map(File::getAbsolutePath)
-        .collect(Collectors.toList());
-  }
-
-  private static List<String> scanClasspathForResourcesToStage(URLClassLoader classLoader) {
-    LOG.info("Scanning classpath for resources to stage via the URLClassLoader.");
+  public Stream<String> detect(ClassLoader classLoader) {
+    List<File> classpathContents = classGraph.addClassLoader(classLoader).getClasspathFiles();
 
-    List<String> files = new ArrayList<>();
-    for (URL url : classLoader.getURLs()) {
-      try {
-        files.add(new File(url.toURI()).getAbsolutePath());
-      } catch (IllegalArgumentException | URISyntaxException e) {
-        String message = String.format("Unable to convert url (%s) to file.", url);
-        throw new IllegalArgumentException(message, e);
-      }
-    }
-    return files;
+    return classpathContents.stream().map(File::getAbsolutePath);
   }
 }
diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResources.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResources.java
index 5439bd8b05d..c3ecde4fef1 100644
--- a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResources.java
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResources.java
@@ -24,6 +24,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.List;
+import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import org.apache.beam.sdk.options.PipelineOptions;
 import org.apache.beam.sdk.util.ZipFiles;
@@ -49,7 +50,19 @@ public class PipelineResources {
       ClassLoader classLoader, PipelineOptions options) {
 
     PipelineResourcesOptions artifactsRelatedOptions = options.as(PipelineResourcesOptions.class);
-    return artifactsRelatedOptions.getPipelineResourcesDetector().detect(classLoader);
+    return artifactsRelatedOptions
+        .getPipelineResourcesDetector()
+        .detect(classLoader)
+        .filter(isStageable())
+        .collect(Collectors.toList());
+  }
+
+  /**
+   * Returns a predicate for filtering all resources that are impossible to stage (like gradle
+   * wrapper jars).
+   */
+  private static Predicate<String> isStageable() {
+    return resourcePath -> !resourcePath.contains("gradle/wrapper");
   }
 
   /**
diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesDetector.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesDetector.java
index ba1b9ea6c43..46b9459002c 100644
--- a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesDetector.java
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesDetector.java
@@ -18,10 +18,10 @@
 package org.apache.beam.runners.core.construction.resources;
 
 import java.io.Serializable;
-import java.util.List;
+import java.util.stream.Stream;
 
 /** Interface for an algorithm detecting classpath resources for pipelines. */
 public interface PipelineResourcesDetector extends Serializable {
 
-  List<String> detect(ClassLoader classLoader);
+  Stream<String> detect(ClassLoader classLoader);
 }
diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesOptions.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesOptions.java
index cc27cb1a262..21f0c2476d4 100644
--- a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesOptions.java
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesOptions.java
@@ -18,6 +18,7 @@
 package org.apache.beam.runners.core.construction.resources;
 
 import com.fasterxml.jackson.annotation.JsonIgnore;
+import io.github.classgraph.ClassGraph;
 import org.apache.beam.sdk.options.Default;
 import org.apache.beam.sdk.options.DefaultValueFactory;
 import org.apache.beam.sdk.options.Description;
@@ -70,7 +71,7 @@ public interface PipelineResourcesOptions extends PipelineOptions {
 
     @Override
     public PipelineResourcesDetector getPipelineResourcesDetector() {
-      return new ClasspathScanningResourcesDetector();
+      return new ClasspathScanningResourcesDetector(new ClassGraph());
     }
   }
 }
diff --git a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/resources/ClasspathScanningResourcesDetectorTest.java b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/resources/ClasspathScanningResourcesDetectorTest.java
index 7c8923cce55..63cea677687 100644
--- a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/resources/ClasspathScanningResourcesDetectorTest.java
+++ b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/resources/ClasspathScanningResourcesDetectorTest.java
@@ -17,23 +17,29 @@
  */
 package org.apache.beam.runners.core.construction.resources;
 
+import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.CoreMatchers.hasItem;
 import static org.hamcrest.CoreMatchers.hasItems;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.collection.IsCollectionWithSize.hasSize;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThrows;
+import static org.hamcrest.Matchers.not;
+import static org.junit.Assert.assertFalse;
 
+import io.github.classgraph.ClassGraph;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.util.List;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+import java.util.stream.Collectors;
 import org.apache.beam.sdk.testing.RestoreSystemProperties;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
+import org.mockito.Mockito;
 
 public class ClasspathScanningResourcesDetectorTest {
 
@@ -43,44 +49,81 @@ public class ClasspathScanningResourcesDetectorTest {
 
   private ClasspathScanningResourcesDetector detector;
 
+  private ClassLoader classLoader;
+
   @Before
-  public void setUp() throws Exception {
-    detector = new ClasspathScanningResourcesDetector();
+  public void setUp() {
+    detector = new ClasspathScanningResourcesDetector(new ClassGraph());
+  }
+
+  @Test
+  public void shouldDetectDirectories() throws Exception {
+    File folder = tmpFolder.newFolder("folder1");
+    classLoader = new URLClassLoader(new URL[] {folder.toURI().toURL()});
+
+    List<String> result = detector.detect(classLoader).collect(Collectors.toList());
+
+    assertThat(result, hasItem(containsString(folder.getAbsolutePath())));
+  }
+
+  @Test
+  public void shouldDetectJarFiles() throws Exception {
+    File jarFile = createTestTmpJarFile("test");
+    classLoader = new URLClassLoader(new URL[] {jarFile.toURI().toURL()});
+
+    List<String> result = detector.detect(classLoader).collect(Collectors.toList());
+
+    assertThat(result, hasItem(containsString(jarFile.getAbsolutePath())));
+  }
+
+  private File createTestTmpJarFile(String name) throws IOException {
+    File jarFile = tmpFolder.newFile(name);
+    try (JarOutputStream os = new JarOutputStream(new FileOutputStream(jarFile), new Manifest())) {}
+    return jarFile;
   }
 
   @Test
-  public void detectClassPathResourceWithFileResources() throws Exception {
-    File file = tmpFolder.newFile("file");
-    File file2 = tmpFolder.newFile("file2");
-    URLClassLoader classLoader =
-        new URLClassLoader(new URL[] {file.toURI().toURL(), file2.toURI().toURL()});
-
-    assertEquals(
-        ImmutableList.of(file.getAbsolutePath(), file2.getAbsolutePath()),
-        detector.detect(classLoader));
+  public void shouldNotDetectOrdinaryFiles() throws Exception {
+    File textFile = tmpFolder.newFile("ordinaryTextFile.txt");
+    classLoader = new URLClassLoader(new URL[] {textFile.toURI().toURL()});
+
+    List<String> result = detector.detect(classLoader).collect(Collectors.toList());
+
+    assertThat(result, not(hasItem(containsString(textFile.getAbsolutePath()))));
   }
 
   @Test
-  public void detectClassPathResourceFromJavaClassPathWhenTheresNoClassLoader() throws IOException {
-    String path = tmpFolder.newFile("file").getAbsolutePath();
-    String path2 = tmpFolder.newFile("file2").getAbsolutePath();
-    String classpath = String.join(File.pathSeparator, path, path2);
-    System.setProperty("java.class.path", classpath);
+  public void shouldDetectClassPathResourceFromJavaClassPathEnvVariable() throws IOException {
+    String path = tmpFolder.newFolder("folder").getAbsolutePath();
+    System.setProperty("java.class.path", path);
 
-    List<String> resources = detector.detect(null);
+    List<String> resources = detector.detect(null).collect(Collectors.toList());
 
-    assertThat(resources, hasItems(path, path2));
-    assertThat(resources, hasSize(2));
+    assertThat(resources, hasItems(containsString(path)));
   }
 
   @Test
-  public void throwWhenDetectingClassPathResourceWithNonFileResources() throws Exception {
+  public void shouldNotDetectClassPathResourceThatIsNotAFile() throws Exception {
     String url = "http://www.google.com/all-the-secrets.jar";
-    URLClassLoader classLoader = new URLClassLoader(new URL[] {new URL(url)});
+    classLoader = new URLClassLoader(new URL[] {new URL(url)});
+
+    List<String> result = detector.detect(classLoader).collect(Collectors.toList());
+
+    assertThat(result, not(hasItem(containsString(url))));
+  }
+
+  /*
+   * ClassGraph library that is used in the tested algorithm can still detect resources from
+   * "java.class.path" env variable. Even in case the classloader that is passed is of no use we
+   * will still be able to detect and load resource paths from the env variable.
+   */
+  @Test
+  public void shouldStillDetectResourcesEvenIfClassloaderIsUseless() {
+    ClassLoader uselessClassLoader = Mockito.mock(ClassLoader.class);
 
-    IllegalArgumentException exeption =
-        assertThrows(IllegalArgumentException.class, () -> detector.detect(classLoader));
+    List<String> detectedResources =
+        detector.detect(uselessClassLoader).collect(Collectors.toList());
 
-    assertEquals("Unable to convert url (" + url + ") to file.", exeption.getMessage());
+    assertFalse(detectedResources.isEmpty());
   }
 }
diff --git a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesTest.java b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesTest.java
index 0165035cd4d..b84d3e7425e 100644
--- a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesTest.java
+++ b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/resources/PipelineResourcesTest.java
@@ -19,7 +19,9 @@ package org.apache.beam.runners.core.construction.resources;
 
 import static junit.framework.TestCase.assertTrue;
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.empty;
+import static org.hamcrest.Matchers.not;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
 
@@ -53,7 +55,21 @@ public class PipelineResourcesTest {
     List<String> detectedResources =
         PipelineResources.detectClassPathResourcesToStage(classLoader, options);
 
-    assertThat(detectedResources, hasSize(1));
+    assertThat(detectedResources, not(empty()));
+  }
+
+  @Test
+  public void testDetectedResourcesListDoNotContainNotStageableResources() throws IOException {
+    File unstageableResource = tmpFolder.newFolder(".gradle/wrapper/unstageableResource");
+    URLClassLoader classLoader =
+        new URLClassLoader(new URL[] {unstageableResource.toURI().toURL()});
+    PipelineResourcesOptions options =
+        PipelineOptionsFactory.create().as(PipelineResourcesOptions.class);
+
+    List<String> detectedResources =
+        PipelineResources.detectClassPathResourcesToStage(classLoader, options);
+
+    assertThat(detectedResources, not(contains(unstageableResource.getAbsolutePath())));
   }
 
   @Test
