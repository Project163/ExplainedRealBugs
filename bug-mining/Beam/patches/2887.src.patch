diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/IsmReaderImpl.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/IsmReaderImpl.java
index 379e69a1512..bcf7a18b0ec 100644
--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/IsmReaderImpl.java
+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/IsmReaderImpl.java
@@ -32,7 +32,6 @@ import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.SeekableByteChannel;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -42,7 +41,8 @@ import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.SortedMap;
 import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
 import org.apache.beam.runners.dataflow.internal.IsmFormat;
 import org.apache.beam.runners.dataflow.internal.IsmFormat.Footer;
 import org.apache.beam.runners.dataflow.internal.IsmFormat.FooterCoder;
@@ -66,7 +66,6 @@ import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.Visi
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.MoreObjects;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Optional;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.Cache;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSortedMap;
@@ -113,7 +112,8 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
   private NavigableMap<Long, IsmShard> shardOffsetToShardMap;
 
   /** Values lazily initialized per shard on first keyed read of each shard. */
-  private Map<Integer, ImmutableSortedMap<RandomAccessData, IsmShardKey>> indexPerShard;
+  private ConcurrentHashMap<Integer, ImmutableSortedMap<RandomAccessData, IsmShardKey>>
+      indexPerShard;
 
   ScalableBloomFilter bloomFilter;
 
@@ -299,6 +299,14 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
         FooterCoder.of()
             .decode(data.asInputStream(data.size() - Footer.FIXED_LENGTH, Footer.FIXED_LENGTH));
 
+    checkState(
+        0 <= footer.getBloomFilterPosition()
+            && footer.getBloomFilterPosition() <= footer.getIndexPosition()
+            && footer.getIndexPosition() < this.length - Footer.FIXED_LENGTH,
+        "Invalid footer '%s' for resourceId '%s' with length %s",
+        footer,
+        resourceId,
+        length);
     checkState(
         startPosition < footer.getIndexPosition(),
         "Malformed file, expected to have been able to read entire shard index.");
@@ -370,7 +378,7 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
     position(rawChannel, footer.getBloomFilterPosition());
     bloomFilter = ScalableBloomFilterCoder.of().decode(Channels.newInputStream(rawChannel));
 
-    indexPerShard = new HashMap<>();
+    indexPerShard = new ConcurrentHashMap<>();
     // If a shard is small, it may not contain an index and we can detect this and
     // prepopulate the shard index map with an empty entry if the start of the index
     // and start of the next block are equal
@@ -387,6 +395,13 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
     IsmShard currentShard = shardIterator.next();
     while (shardIterator.hasNext()) {
       IsmShard nextShard = shardIterator.next();
+      checkState(
+          currentShard.getIndexOffset() <= nextShard.getBlockOffset(),
+          "Expected currentShard.indexOffset to be less than or equal to nextShard.blockOffset. "
+              + "But, currentShard is '%s' and nextShard is '%s' for resourceId '%s'",
+          currentShard,
+          nextShard,
+          resourceId);
       if (currentShard.getIndexOffset() == nextShard.getBlockOffset()) {
         indexPerShard.put(
             currentShard.getId(),
@@ -406,6 +421,13 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
 
     // Add an entry for the last shard if its index offset is equivalent to the
     // start of the Bloom filter, then we know that the index is empty.
+    checkState(
+        currentShard.getIndexOffset() <= footer.getBloomFilterPosition(),
+        "Expected indexOffset of the last shard to be less than or equal to bloomfilter "
+            + "position. But, the last shard is '%s' and bloomfilter position is '%s' for resourceId '%s'",
+        currentShard,
+        footer.getBloomFilterPosition(),
+        resourceId);
     if (currentShard.getIndexOffset() == footer.getBloomFilterPosition()) {
       indexPerShard.put(
           currentShard.getId(),
@@ -491,27 +513,65 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
 
     inChannel = initializeBloomFilterAndIndexPerShard(inChannel);
 
-    // If the index has been populated and contains the shard id, we can return.
-    if (indexPerShard != null && indexPerShard.containsKey(shardId)) {
-      checkState(bloomFilter != null, "Bloom filter expected to have been initialized.");
+    checkState(
+        indexPerShard != null,
+        "indexPerShard must not be null after initializeBloomFilterAndIndexPerShard.");
+
+    if (indexPerShard.containsKey(shardId)) {
+      // ConcurrentHashMap.containsKey doesn't lock a bin, so it's faster than `computeIfAbsent` for
+      // a present key.
       return inChannel;
     }
 
-    checkState(
-        indexPerShard.get(shardId) == null,
-        "Expected to not have initialized index for shard %s",
-        shardId);
+    // Using AtomicReference for an object holder. Actually, atomicity is not required.
+    AtomicReference<SeekableByteChannel> rawChannelReference =
+        new AtomicReference<>(inChannel.orNull());
+
+    // JDK-8161372 (ConcurrentHashMap.computeIfAbsent locks bin when k present) alleviated the
+    // performance loss by not acquiring lock for the first node. But, the fix was applied to Java9,
+    // and it still has chance to lock the bin containing the key at the second or next nodes. As we
+    // expect `indexPerShard` already has the shardId in most cases, it would have a better
+    // performance to check `containsKey` above before invoking `computeIfAbsent` here.
+    indexPerShard.computeIfAbsent(
+        shardId,
+        ignored -> {
+          Long startOfNextBlock = shardOffsetToShardMap.higherKey(shardWithIndex.getBlockOffset());
+          // If this is the last block, then we need to grab the position of the Bloom filter
+          // as the upper bound.
+          if (startOfNextBlock == null) {
+            startOfNextBlock = footer.getBloomFilterPosition();
+          }
 
-    Long startOfNextBlock = shardOffsetToShardMap.higherKey(shardWithIndex.getBlockOffset());
-    // If this is the last block, then we need to grab the position of the Bloom filter
-    // as the upper bound.
-    if (startOfNextBlock == null) {
-      startOfNextBlock = footer.getBloomFilterPosition();
-    }
+          checkState(
+              shardWithIndex.getIndexOffset() < startOfNextBlock,
+              "Expected the index start offset is less than the next block start offset. "
+                  + "But, IsmShard is '%s' and the next block offset is %s for resourceId '%s'",
+              shardWithIndex,
+              startOfNextBlock,
+              resourceId);
+
+          try {
+            SeekableByteChannel rawChannel = openIfNeeded(Optional.of(rawChannelReference.get()));
+            rawChannelReference.set(rawChannel);
+            return readIndexBlockForShard(resourceId, shardWithIndex, startOfNextBlock, rawChannel);
+          } catch (IOException e) {
+            // Wrapping with RuntimeException
+            throw new RuntimeException(
+                "Failed to read shard index for resourceId: " + resourceId + " shardId: " + shardId,
+                e);
+          }
+        });
+
+    return Optional.of(rawChannelReference.get());
+  }
+
+  /** Read index block for a shard. */
+  private static ImmutableSortedMap<RandomAccessData, IsmShardKey> readIndexBlockForShard(
+      ResourceId resourceId, IsmShard shard, long startOfNextBlock, SeekableByteChannel rawChannel)
+      throws IOException {
 
     // Open the channel if needed and seek to the start of the index.
-    SeekableByteChannel rawChannel = openIfNeeded(inChannel);
-    rawChannel.position(shardWithIndex.getIndexOffset());
+    rawChannel.position(shard.getIndexOffset());
     InputStream inStream = Channels.newInputStream(rawChannel);
 
     ImmutableSortedMap.Builder<RandomAccessData, IsmShardKey> builder =
@@ -522,30 +582,50 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
     readKey(inStream, currentKeyBytes);
     long currentOffset = VarInt.decodeLong(inStream);
 
+    checkState(
+        shard.getBlockOffset() < currentOffset && currentOffset < shard.getIndexOffset(),
+        "Expected the first index offset in the range of IsmShard. "
+            + "But, the first index offset is %s and IsmShard is '%s' for resourceId '%s'",
+        currentOffset,
+        shard,
+        resourceId);
     // Insert the entry that happens at the beginning limiting the shard block by the
     // first keys block offset.
     builder.put(
         new RandomAccessData(0),
         new IsmShardKey(
-            IsmReaderImpl.this.resourceId.toString(),
-            new RandomAccessData(0),
-            shardWithIndex.getBlockOffset(),
-            currentOffset));
+            resourceId.toString(), new RandomAccessData(0), shard.getBlockOffset(), currentOffset));
 
     // While another index entry exists, insert an index entry with the key, and offsets
     // that limit the range of the shard block.
-    while (rawChannel.position() < startOfNextBlock) {
+    long currentPosition;
+    while ((currentPosition = rawChannel.position()) < startOfNextBlock) {
       RandomAccessData nextKeyBytes = currentKeyBytes.copy();
       readKey(inStream, nextKeyBytes);
       long nextOffset = VarInt.decodeLong(inStream);
 
+      checkState(
+          RandomAccessData.UNSIGNED_LEXICOGRAPHICAL_COMPARATOR.compare(
+                  currentKeyBytes, nextKeyBytes)
+              < 0,
+          "Expected keys in index to be sorted. But, the key of the index at position %s is "
+              + "not larger than the previous key for IsmShard '%s' in resourceId '%s'",
+          currentPosition,
+          shard,
+          resourceId);
+      checkState(
+          currentOffset < nextOffset && nextOffset < shard.getIndexOffset(),
+          "Expected an index offset to be between the previous index offset and the index start "
+              + "offset. But, the index offset of the key at position %s is %s and the previous "
+              + "offset is %s for IsmShard '%s' in resourceId '%s'",
+          currentPosition,
+          nextOffset,
+          currentOffset,
+          shard,
+          resourceId);
       builder.put(
           currentKeyBytes,
-          new IsmShardKey(
-              IsmReaderImpl.this.resourceId.toString(),
-              currentKeyBytes,
-              currentOffset,
-              nextOffset));
+          new IsmShardKey(resourceId.toString(), currentKeyBytes, currentOffset, nextOffset));
 
       currentKeyBytes = nextKeyBytes;
       currentOffset = nextOffset;
@@ -555,13 +635,9 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
     builder.put(
         currentKeyBytes,
         new IsmShardKey(
-            IsmReaderImpl.this.resourceId.toString(),
-            currentKeyBytes,
-            currentOffset,
-            shardWithIndex.getIndexOffset()));
-    indexPerShard.put(shardId, builder.build());
+            resourceId.toString(), currentKeyBytes, currentOffset, shard.getIndexOffset()));
 
-    return Optional.of(rawChannel);
+    return builder.build();
   }
 
   /** A function which takes an IsmShardKey fully describing a data block to read and return. */
@@ -621,10 +697,16 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
       } else {
         return cache.get(key, new IsmCacheLoader(key)).getValue();
       }
-    } catch (ExecutionException e) {
-      // Try and re-throw the root cause if its an IOException
-      Throwables.propagateIfPossible(e.getCause(), IOException.class);
-      throw new IOException(e.getCause());
+    } catch (Exception e) {
+      // Throw with resource and key in error message for better debugging.
+      throw new IOException(
+          "Failed to fetch data block for resourceId: "
+              + this.resourceId
+              + ", startOffset: "
+              + key.startOffset
+              + ", endOffset: "
+              + key.endOffset,
+          e);
     }
   }
 
@@ -958,8 +1040,8 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
     private final SeekableByteChannel rawChannel;
     private final InputStream inStream;
     private final SideInputReadCounter readCounter;
-    private long readLimit;
-    private RandomAccessData keyBytes;
+    private final long readLimit;
+    private final RandomAccessData keyBytes;
     private long position;
     private Optional<WindowedValue<IsmRecord<V>>> current;
 
@@ -972,8 +1054,13 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
         throws IOException {
       checkNotNull(rawChannel);
       checkNotNull(currentKeyBytes);
-      checkArgument(newLimit >= 0L);
-      checkArgument(newPosition <= newLimit);
+      checkArgument(newPosition >= 0L, "newPosition (%s) is negative.", newPosition);
+      checkArgument(newLimit >= 0L, "newLimit (%s) is negative.", newLimit);
+      checkArgument(
+          newPosition <= newLimit,
+          "newPosition (%s) is greater than newLimit (%s).",
+          newPosition,
+          newLimit);
       this.rawChannel = rawChannel;
       this.inStream = Channels.newInputStream(rawChannel);
       this.keyBytes = currentKeyBytes.copy();
@@ -990,7 +1077,11 @@ public class IsmReaderImpl<V> extends IsmReader<V> {
 
     @Override
     public boolean advance() throws IOException, NoSuchElementException {
-      checkState(position <= readLimit, "Read past end of stream");
+      checkState(
+          position <= readLimit,
+          "Read past end of stream. position: %s, readLimit:%s",
+          position,
+          readLimit);
       if (position == readLimit) {
         current = Optional.absent();
         return false;
