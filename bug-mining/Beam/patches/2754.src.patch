diff --git a/sdks/java/io/amazon-web-services2/build.gradle b/sdks/java/io/amazon-web-services2/build.gradle
index 2fe845db101..b8aa0ec9b8d 100644
--- a/sdks/java/io/amazon-web-services2/build.gradle
+++ b/sdks/java/io/amazon-web-services2/build.gradle
@@ -62,7 +62,7 @@ dependencies {
   testImplementation library.java.mockito_core
   testImplementation library.java.guava_testlib
   testImplementation library.java.junit
-  testImplementation 'org.elasticmq:elasticmq-rest-sqs_2.12:0.15.6'
+  testImplementation 'org.elasticmq:elasticmq-rest-sqs_2.12:0.15.6' // later versions conflict with s3mock
   testImplementation library.java.hamcrest
   testImplementation library.java.powermock
   testImplementation library.java.powermock_mockito
diff --git a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsCheckpointMark.java b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsCheckpointMark.java
index 2a9a630c457..823f96ca5f6 100644
--- a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsCheckpointMark.java
+++ b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsCheckpointMark.java
@@ -21,6 +21,7 @@ import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Prec
 
 import java.io.IOException;
 import java.io.Serializable;
+import java.util.Collection;
 import java.util.List;
 import java.util.Optional;
 import org.apache.beam.sdk.io.UnboundedSource;
@@ -35,28 +36,38 @@ import org.checkerframework.checker.nullness.qual.Nullable;
 class SqsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {
 
   /**
-   * If the checkpoint is for persisting: the reader who's snapshotted state we are persisting. If
-   * the checkpoint is for restoring: {@literal null}. Not persisted in durable checkpoint. CAUTION:
-   * Between a checkpoint being taken and {@link #finalizeCheckpoint()} being called the 'true'
-   * active reader may have changed.
+   * The reader this checkpoint was created from.
+   *
+   * <p><b>Not persisted</b> in durable checkpoint, {@code null} after restoring the checkpoint.
+   *
+   * <p><b>CAUTION:</b>Between a checkpoint being taken and {@link #finalizeCheckpoint()} being
+   * called the 'true' active reader may have changed.
    */
   private transient Optional<SqsUnboundedReader> reader;
+
   /**
-   * If the checkpoint is for persisting: The ids of messages which have been passed downstream
-   * since the last checkpoint. If the checkpoint is for restoring: {@literal null}. Not persisted
-   * in durable checkpoint.
+   * Contains message ids that have been passed downstream since the last checkpoint.
+   *
+   * <p>Corresponding messages have to be purged from SQS when finalizing the checkpoint to prevent
+   * re-delivery.
+   *
+   * <p><b>Not persisted</b> in durable checkpoint, {@code null} after restoring the checkpoint.
    */
   private @Nullable List<String> safeToDeleteIds;
 
   /**
-   * If the checkpoint is for persisting: The receipt handles of messages which have been received
-   * from SQS but not yet passed downstream at the time of the snapshot. If the checkpoint is for
-   * restoring: Same, but recovered from durable storage.
+   * Contains receipt handles of messages which have been received from SQS, but not yet passed
+   * downstream at the time of the snapshot.
+   *
+   * <p>When restoring from a checkpoint, the visibility timeout of corresponding messages is set to
+   * {@code 0} to trigger immediate re-delivery.
    */
   @VisibleForTesting final List<String> notYetReadReceipts;
 
   SqsCheckpointMark(
-      SqsUnboundedReader reader, List<String> messagesToDelete, List<String> notYetReadReceipts) {
+      SqsUnboundedReader reader,
+      Collection<String> messagesToDelete,
+      Collection<String> notYetReadReceipts) {
     this.reader = Optional.of(reader);
     this.safeToDeleteIds = ImmutableList.copyOf(messagesToDelete);
     this.notYetReadReceipts = ImmutableList.copyOf(notYetReadReceipts);
diff --git a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReader.java b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReader.java
index 0fdaf2ca774..46a04380443 100644
--- a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReader.java
+++ b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReader.java
@@ -17,14 +17,23 @@
  */
 package org.apache.beam.sdk.io.aws2.sqs;
 
+import static java.lang.Boolean.FALSE;
+import static java.lang.Boolean.TRUE;
 import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.stream.Collectors.groupingBy;
+import static java.util.function.Function.identity;
+import static java.util.stream.Collectors.mapping;
+import static java.util.stream.Collectors.partitioningBy;
+import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toMap;
+import static java.util.stream.Collectors.toSet;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;
+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Collections2.transform;
+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Streams.mapWithIndex;
 import static software.amazon.awssdk.services.sqs.model.MessageSystemAttributeName.SENT_TIMESTAMP;
 import static software.amazon.awssdk.services.sqs.model.QueueAttributeName.VISIBILITY_TIMEOUT;
 
 import java.io.IOException;
+import java.time.Clock;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -32,14 +41,12 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
-import java.util.Objects;
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
+import java.util.function.Function;
 import org.apache.beam.sdk.io.UnboundedSource;
 import org.apache.beam.sdk.io.UnboundedSource.CheckpointMark;
 import org.apache.beam.sdk.transforms.Combine;
@@ -49,8 +56,11 @@ import org.apache.beam.sdk.transforms.Sum;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.sdk.util.BucketingFunction;
 import org.apache.beam.sdk.util.MovingFunction;
+import org.apache.beam.sdk.values.KV;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Streams.FunctionWithIndex;
 import org.joda.time.Duration;
 import org.joda.time.Instant;
 import org.slf4j.Logger;
@@ -63,7 +73,6 @@ import software.amazon.awssdk.services.sqs.model.ChangeMessageVisibilityBatchRes
 import software.amazon.awssdk.services.sqs.model.DeleteMessageBatchRequest;
 import software.amazon.awssdk.services.sqs.model.DeleteMessageBatchRequestEntry;
 import software.amazon.awssdk.services.sqs.model.DeleteMessageBatchResponse;
-import software.amazon.awssdk.services.sqs.model.GetQueueAttributesRequest;
 import software.amazon.awssdk.services.sqs.model.Message;
 import software.amazon.awssdk.services.sqs.model.ReceiveMessageRequest;
 import software.amazon.awssdk.services.sqs.model.ReceiveMessageResponse;
@@ -72,6 +81,8 @@ import software.amazon.awssdk.services.sqs.model.ReceiveMessageResponse;
   "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
 })
 class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
+  private static final String RECEIPT_HANDLE_IS_INVALID = "ReceiptHandleIsInvalid";
+
   private static final Logger LOG = LoggerFactory.getLogger(SqsUnboundedReader.class);
 
   /** Maximum number of messages to pull from SQS per request. */
@@ -134,6 +145,9 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
   /** For access to topic and SQS client. */
   private final SqsUnboundedSource source;
 
+  /** Clock for internal time. */
+  private final Clock clock;
+
   /**
    * The closed state of this {@link SqsUnboundedReader}. If true, the reader has not yet been
    * closed, and it will have a non-null value within {@link #SqsUnboundedReader}.
@@ -294,9 +308,16 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
 
   public SqsUnboundedReader(SqsUnboundedSource source, SqsCheckpointMark sqsCheckpointMark)
       throws IOException {
+    this(source, sqsCheckpointMark, Clock.systemUTC());
+  }
+
+  @VisibleForTesting
+  SqsUnboundedReader(SqsUnboundedSource source, SqsCheckpointMark sqsCheckpointMark, Clock clock)
+      throws IOException {
     this.source = source;
+    this.clock = clock;
 
-    messagesNotYetRead = new ArrayDeque<>();
+    messagesNotYetRead = new ArrayDeque<>(MAX_NUMBER_OF_MESSAGES);
     safeToDeleteIds = new HashSet<>();
     inFlight = new LinkedHashMap<>();
     deletedIds = new ConcurrentLinkedQueue<>();
@@ -327,10 +348,8 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
     maxInFlightCheckpoints = 0;
 
     if (sqsCheckpointMark != null) {
-      long nowMsSinceEpoch = now();
       initClient();
-      extendBatch(nowMsSinceEpoch, sqsCheckpointMark.notYetReadReceipts, 0);
-      numReleased.add(nowMsSinceEpoch, sqsCheckpointMark.notYetReadReceipts.size());
+      expireBatchForRedelivery(sqsCheckpointMark.notYetReadReceipts);
     }
   }
 
@@ -395,12 +414,8 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
   public CheckpointMark getCheckpointMark() {
     int cur = numInFlightCheckpoints.incrementAndGet();
     maxInFlightCheckpoints = Math.max(maxInFlightCheckpoints, cur);
-    List<String> snapshotSafeToDeleteIds = Lists.newArrayList(safeToDeleteIds);
-    List<String> snapshotNotYetReadReceipts = new ArrayList<>(messagesNotYetRead.size());
-    for (SqsMessage message : messagesNotYetRead) {
-      snapshotNotYetReadReceipts.add(message.getReceiptHandle());
-    }
-    return new SqsCheckpointMark(this, snapshotSafeToDeleteIds, snapshotNotYetReadReceipts);
+    return new SqsCheckpointMark(
+        this, safeToDeleteIds, transform(messagesNotYetRead, SqsMessage::getReceiptHandle));
   }
 
   @Override
@@ -411,20 +426,19 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
   @Override
   public boolean start() throws IOException {
     initClient();
-    visibilityTimeoutMs =
-        Integer.parseInt(
-                sqsClient
-                    .getQueueAttributes(
-                        GetQueueAttributesRequest.builder()
-                            .queueUrl(source.getRead().queueUrl())
-                            .attributeNames(VISIBILITY_TIMEOUT)
-                            .build())
-                    .attributes()
-                    .get(VISIBILITY_TIMEOUT))
-            * 1000L;
+    String timeout =
+        sqsClient
+            .getQueueAttributes(b -> b.queueUrl(queueUrl()).attributeNames(VISIBILITY_TIMEOUT))
+            .attributes()
+            .get(VISIBILITY_TIMEOUT);
+    visibilityTimeoutMs = Integer.parseInt(timeout) * 1000L;
     return advance();
   }
 
+  private String queueUrl() {
+    return source.getRead().queueUrl();
+  }
+
   private void initClient() {
     if (sqsClient == null) {
       sqsClient = source.getRead().sqsClientProvider().getSqsClient();
@@ -465,12 +479,13 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
       // Try again later.
       return false;
     }
-    notYetReadBytes -= current.getBody().getBytes(UTF_8).length;
+    int currentBytes = current.getBody().getBytes(UTF_8).length;
+    notYetReadBytes -= currentBytes;
     checkState(notYetReadBytes >= 0);
     long nowMsSinceEpoch = now();
-    numReadBytes.add(nowMsSinceEpoch, current.getBody().getBytes(UTF_8).length);
+    numReadBytes.add(nowMsSinceEpoch, currentBytes);
     minReadTimestampMsSinceEpoch.add(nowMsSinceEpoch, getCurrentTimestamp().getMillis());
-    ;
+
     if (getCurrentTimestamp().getMillis() < lastWatermarkMsSinceEpoch) {
       numLateMessages.add(nowMsSinceEpoch, 1L);
     }
@@ -509,70 +524,87 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
     }
   }
 
-  /** delete the provided {@code messageIds} from SQS. */
+  /**
+   * Delete the provided {@code messageIds} from SQS in multiple batches. Each batch except the last
+   * one is of size {@code DELETE_BATCH_SIZE}. Message ids that already got removed from {@code
+   * inFlight} messages are ignored.
+   *
+   * <p>CAUTION: May be invoked from a separate thread.
+   */
   void delete(List<String> messageIds) throws IOException {
-    AtomicInteger counter = new AtomicInteger();
-    for (List<String> messageList :
-        messageIds.stream()
-            .collect(groupingBy(x -> counter.getAndIncrement() / DELETE_BATCH_SIZE))
-            .values()) {
-      deleteBatch(messageList);
+    ArrayList<String> receiptHandles = new ArrayList<>(DELETE_BATCH_SIZE);
+    for (String msgId : messageIds) {
+      InFlightState state = inFlight.get(msgId);
+      if (state == null) {
+        continue;
+      }
+      receiptHandles.add(state.receiptHandle);
+      if (receiptHandles.size() == DELETE_BATCH_SIZE) {
+        deleteBatch(receiptHandles);
+        receiptHandles.clear();
+      }
+    }
+    if (!receiptHandles.isEmpty()) {
+      deleteBatch(receiptHandles);
     }
+    deletedIds.add(messageIds);
   }
 
   /**
-   * delete the provided {@code messageIds} from SQS, blocking until all of the messages are
-   * deleted.
+   * Delete the provided {@code receiptHandles} from SQS. Blocking until all messages are deleted.
    *
    * <p>CAUTION: May be invoked from a separate thread.
-   *
-   * <p>CAUTION: Retains {@code messageIds}.
    */
-  private void deleteBatch(List<String> messageIds) throws IOException {
+  private void deleteBatch(List<String> receiptHandles) throws IOException {
     int retries = 0;
-    Map<String, String> pendingReceipts =
-        IntStream.range(0, messageIds.size())
-            .boxed()
-            .filter(i -> inFlight.containsKey(messageIds.get(i)))
-            .collect(toMap(Object::toString, i -> inFlight.get(messageIds.get(i)).receiptHandle));
 
-    while (!pendingReceipts.isEmpty()) {
+    FunctionWithIndex<String, DeleteMessageBatchRequestEntry> buildEntry =
+        (handle, id) ->
+            DeleteMessageBatchRequestEntry.builder()
+                .id(Long.toString(id))
+                .receiptHandle(handle)
+                .build();
+
+    Map<String, DeleteMessageBatchRequestEntry> pendingDeletes =
+        mapWithIndex(receiptHandles.stream(), buildEntry).collect(toMap(e -> e.id(), identity()));
+
+    while (!pendingDeletes.isEmpty()) {
 
       if (retries >= BATCH_OPERATION_MAX_RETIRES) {
         throw new IOException(
-            "Failed to extend visibility timeout for "
-                + pendingReceipts.size()
+            "Failed to delete "
+                + pendingDeletes.size()
                 + " messages after "
                 + retries
                 + " retries");
       }
 
-      List<DeleteMessageBatchRequestEntry> entries =
-          pendingReceipts.entrySet().stream()
-              .map(
-                  r ->
-                      DeleteMessageBatchRequestEntry.builder()
-                          .id(r.getKey())
-                          .receiptHandle(r.getValue())
-                          .build())
-              .collect(Collectors.toList());
-
       DeleteMessageBatchResponse result =
           sqsClient.deleteMessageBatch(
               DeleteMessageBatchRequest.builder()
-                  .queueUrl(source.getRead().queueUrl())
-                  .entries(entries)
+                  .queueUrl(queueUrl())
+                  .entries(pendingDeletes.values())
                   .build());
 
-      // Reflect failed message IDs to map
-      pendingReceipts
-          .keySet()
-          .retainAll(
-              result.failed().stream().map(BatchResultErrorEntry::id).collect(Collectors.toSet()));
+      Map<Boolean, Set<String>> failures =
+          result.failed().stream()
+              .collect(partitioningBy(this::isHandleInvalid, mapping(e -> e.id(), toSet())));
+
+      // Keep failed IDs only, but discard invalid receipt handles
+      pendingDeletes.keySet().retainAll(failures.getOrDefault(FALSE, ImmutableSet.of()));
+
+      int invalidHandles = failures.getOrDefault(TRUE, ImmutableSet.of()).size();
+      if (invalidHandles > 0) {
+        LOG.warn("Failed to delete {} messages due to expired receipt handles.", invalidHandles);
+      }
 
       retries += 1;
     }
-    deletedIds.add(messageIds);
+  }
+
+  /** Check {@link BatchResultErrorEntry#code()} for invalid expired receipt handles. */
+  private boolean isHandleInvalid(BatchResultErrorEntry error) {
+    return RECEIPT_HANDLE_IS_INVALID.equals(error.code());
   }
 
   /**
@@ -594,7 +626,7 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
     }
   }
 
-  /** BLOCKING Fetch another batch of messages from SQS. */
+  /** BLOCKING. Fetch another batch of messages from SQS. */
   private void pull() {
     if (inFlight.size() >= MAX_IN_FLIGHT) {
       // Wait for checkpoint to be finalized before pulling anymore.
@@ -611,7 +643,7 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
         ReceiveMessageRequest.builder()
             .maxNumberOfMessages(MAX_NUMBER_OF_MESSAGES)
             .attributeNamesWithStrings(SENT_TIMESTAMP.toString())
-            .queueUrl(source.getRead().queueUrl())
+            .queueUrl(queueUrl())
             .build();
 
     final ReceiveMessageResponse receiveMessageResponse =
@@ -651,11 +683,11 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
 
   /** Return the current time, in ms since epoch. */
   long now() {
-    return System.currentTimeMillis();
+    return clock.millis();
   }
 
   /**
-   * BLOCKING Extend deadline for all messages which need it. CAUTION: If extensions can't keep up
+   * BLOCKING. Extend deadline for all messages which need it. CAUTION: If extensions can't keep up
    * with wallclock then we'll never return.
    */
   private void extend() throws IOException {
@@ -725,79 +757,105 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
         // We'll try to track that on our side, but note the deadlines won't necessarily agree.
         long extensionMs = (int) ((visibilityTimeoutMs * VISIBILITY_EXTENSION_PCT) / 100L);
         long newDeadlineMsSinceEpoch = nowMsSinceEpoch + extensionMs;
+        List<KV<String, String>> messages = new ArrayList<>(toBeExtended.size());
+
         for (String messageId : toBeExtended) {
           // Maintain increasing ack deadline order.
-          String receiptHandle = inFlight.get(messageId).receiptHandle;
           InFlightState state = inFlight.remove(messageId);
-          inFlight.put(
-              messageId,
-              new InFlightState(
-                  receiptHandle, state.requestTimeMsSinceEpoch, newDeadlineMsSinceEpoch));
+          state.visibilityDeadlineMsSinceEpoch = newDeadlineMsSinceEpoch;
+          inFlight.put(messageId, state);
+          messages.add(KV.of(messageId, state.receiptHandle));
         }
-        List<String> receiptHandles =
-            toBeExtended.stream()
-                .map(inFlight::get)
-                .filter(Objects::nonNull) // get rid of null values
-                .map(m -> m.receiptHandle)
-                .collect(Collectors.toList());
+
         // BLOCKs until extended.
-        extendBatch(nowMsSinceEpoch, receiptHandles, (int) (extensionMs / 1000));
+        extendBatch(nowMsSinceEpoch, messages, (int) (extensionMs / 1000));
       }
     }
   }
 
   /**
-   * BLOCKING Extend the visibility timeout for messages from SQS with the given {@code
-   * receiptHandles}.
+   * BLOCKING. Set the SQS visibility timeout for messages in {@code receiptHandles} to zero for
+   * immediate redelivery.
+   */
+  void expireBatchForRedelivery(List<String> receiptHandles) throws IOException {
+    List<KV<String, String>> messages =
+        mapWithIndex(receiptHandles.stream(), (handle, idx) -> KV.of(Long.toString(idx), handle))
+            .collect(toList());
+
+    long nowMsSinceEpoch = now();
+    extendBatch(nowMsSinceEpoch, messages, 0);
+    numReleased.add(nowMsSinceEpoch, receiptHandles.size());
+  }
+
+  /**
+   * BLOCKING. Extend the SQS visibility timeout for messages in {@code messages} as {@link KV} of
+   * message id, receipt handle.
    */
-  void extendBatch(long nowMsSinceEpoch, List<String> receiptHandles, int extensionSec)
+  void extendBatch(long nowMsSinceEpoch, List<KV<String, String>> messages, int extensionSec)
       throws IOException {
     int retries = 0;
-    int numMessages = receiptHandles.size();
-    Map<String, String> pendingReceipts =
-        IntStream.range(0, receiptHandles.size())
-            .boxed()
-            .collect(toMap(Object::toString, receiptHandles::get));
 
-    while (!pendingReceipts.isEmpty()) {
+    Function<KV<String, String>, ChangeMessageVisibilityBatchRequestEntry> buildEntry =
+        kv ->
+            ChangeMessageVisibilityBatchRequestEntry.builder()
+                .visibilityTimeout(extensionSec)
+                .id(kv.getKey())
+                .receiptHandle(kv.getValue())
+                .build();
+
+    Map<String, ChangeMessageVisibilityBatchRequestEntry> pendingExtends =
+        messages.stream().collect(toMap(KV::getKey, buildEntry));
+
+    while (!pendingExtends.isEmpty()) {
 
       if (retries >= BATCH_OPERATION_MAX_RETIRES) {
         throw new IOException(
             "Failed to extend visibility timeout for "
-                + receiptHandles.size()
+                + messages.size()
                 + " messages after "
                 + retries
                 + " retries");
       }
 
-      List<ChangeMessageVisibilityBatchRequestEntry> entries =
-          pendingReceipts.entrySet().stream()
-              .map(
-                  r ->
-                      ChangeMessageVisibilityBatchRequestEntry.builder()
-                          .id(r.getKey())
-                          .receiptHandle(r.getValue())
-                          .visibilityTimeout(extensionSec)
-                          .build())
-              .collect(Collectors.toList());
-
       ChangeMessageVisibilityBatchResponse response =
           sqsClient.changeMessageVisibilityBatch(
               ChangeMessageVisibilityBatchRequest.builder()
-                  .queueUrl(source.getRead().queueUrl())
-                  .entries(entries)
+                  .queueUrl(queueUrl())
+                  .entries(pendingExtends.values())
                   .build());
 
-      pendingReceipts
-          .keySet()
-          .retainAll(
-              response.failed().stream()
-                  .map(BatchResultErrorEntry::id)
-                  .collect(Collectors.toSet()));
+      Map<Boolean, Set<String>> failures =
+          response.failed().stream()
+              .collect(partitioningBy(this::isHandleInvalid, mapping(e -> e.id(), toSet())));
+
+      // Keep failed IDs only, but discard invalid (expired) receipt handles
+      pendingExtends.keySet().retainAll(failures.getOrDefault(FALSE, ImmutableSet.of()));
+
+      // Skip stats update and inFlight management if explicitly expiring messages for immediate
+      // redelivery
+      if (extensionSec > 0) {
+        numExtendedDeadlines.add(nowMsSinceEpoch, response.successful().size());
+
+        Set<String> invalidMsgIds = failures.getOrDefault(TRUE, ImmutableSet.of());
+        if (invalidMsgIds.size() > 0) {
+          // consider invalid (expired) messages no longer in flight
+          numLateDeadlines.add(nowMsSinceEpoch, invalidMsgIds.size());
+          for (String msgId : invalidMsgIds) {
+            inFlight.remove(msgId);
+          }
+          LOG.warn(
+              "Failed to extend visibility timeout for {} messages with expired receipt handles.",
+              invalidMsgIds.size());
+        }
+      }
 
       retries += 1;
     }
-    numExtendedDeadlines.add(nowMsSinceEpoch, numMessages);
+  }
+
+  @VisibleForTesting
+  long getVisibilityTimeoutMs() {
+    return visibilityTimeoutMs;
   }
 
   /** Log stats if time to do so. */
@@ -855,7 +913,7 @@ class SqsUnboundedReader extends UnboundedSource.UnboundedReader<SqsMessage> {
             + "{} min recent read timestamp (significance = {}), "
             + "{} min recent unread timestamp (significance = {}), "
             + "{} last receive timestamp",
-        source.getRead().queueUrl(),
+        queueUrl(),
         numReceived,
         messagesNotYetRead.size(),
         notYetReadBytes,
diff --git a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/EmbeddedSqsServer.java b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/EmbeddedSqsServer.java
index 1c4679d2d80..5d37ea082c0 100644
--- a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/EmbeddedSqsServer.java
+++ b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/EmbeddedSqsServer.java
@@ -17,6 +17,8 @@
  */
 package org.apache.beam.sdk.io.aws2.sqs;
 
+import static org.apache.commons.lang3.RandomStringUtils.randomAlphanumeric;
+
 import java.net.URI;
 import org.elasticmq.rest.sqs.SQSRestServer;
 import org.elasticmq.rest.sqs.SQSRestServerBuilder;
@@ -25,44 +27,57 @@ import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
 import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
 import software.amazon.awssdk.regions.Region;
 import software.amazon.awssdk.services.sqs.SqsClient;
-import software.amazon.awssdk.services.sqs.model.CreateQueueRequest;
-import software.amazon.awssdk.services.sqs.model.CreateQueueResponse;
 
 class EmbeddedSqsServer extends ExternalResource {
-  private static SQSRestServer sqsRestServer;
-  private static SqsClient client;
-  private static String queueUrl;
-  private static String queueName = "test";
+  private SQSRestServer sqsRestServer;
+  private URI endpoint;
 
   @Override
   protected void before() {
     sqsRestServer = SQSRestServerBuilder.withDynamicPort().start();
     int port = sqsRestServer.waitUntilStarted().localAddress().getPort();
-    client =
-        SqsClient.builder()
-            .credentialsProvider(
-                StaticCredentialsProvider.create(AwsBasicCredentials.create("x", "x")))
-            .endpointOverride(URI.create(String.format("http://localhost:%d", port)))
-            .region(Region.US_WEST_2)
-            .build();
-
-    CreateQueueRequest createQueueRequest =
-        CreateQueueRequest.builder().queueName(queueName).build();
-    final CreateQueueResponse queue = client.createQueue(createQueueRequest);
-    queueUrl = queue.queueUrl();
-  }
-
-  public SqsClient getClient() {
-    return client;
-  }
-
-  public String getQueueUrl() {
-    return queueUrl;
+    endpoint = URI.create(String.format("http://localhost:%d", port));
   }
 
   @Override
   protected void after() {
     sqsRestServer.stopAndWait();
-    client.close();
+  }
+
+  /** Isolated environment (queue, client) per test case. */
+  public static class TestCaseEnv extends ExternalResource {
+    private final EmbeddedSqsServer sqsServer;
+    private SqsClient client;
+    private String queueUrl;
+
+    public TestCaseEnv(EmbeddedSqsServer sqsServer) {
+      this.sqsServer = sqsServer;
+    }
+
+    @Override
+    protected void before() throws Throwable {
+      client =
+          SqsClient.builder()
+              .credentialsProvider(
+                  StaticCredentialsProvider.create(AwsBasicCredentials.create("x", "x")))
+              .endpointOverride(sqsServer.endpoint)
+              .region(Region.US_WEST_2)
+              .build();
+
+      queueUrl = client.createQueue(b -> b.queueName(randomAlphanumeric(5))).queueUrl();
+    }
+
+    @Override
+    protected void after() {
+      client.close();
+    }
+
+    public SqsClient getClient() {
+      return client;
+    }
+
+    public String getQueueUrl() {
+      return queueUrl;
+    }
   }
 }
diff --git a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsIOTest.java b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsIOTest.java
index 542333a664b..af436c15e69 100644
--- a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsIOTest.java
+++ b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsIOTest.java
@@ -21,8 +21,10 @@ import static org.junit.Assert.assertEquals;
 
 import java.util.ArrayList;
 import java.util.List;
+import org.apache.beam.sdk.io.aws2.sqs.EmbeddedSqsServer.TestCaseEnv;
 import org.apache.beam.sdk.testing.TestPipeline;
 import org.apache.beam.sdk.transforms.Create;
+import org.junit.ClassRule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,19 +37,18 @@ import software.amazon.awssdk.services.sqs.model.SendMessageRequest;
 
 /** Tests on {@link SqsIO}. */
 @RunWith(JUnit4.class)
-@SuppressWarnings({
-  "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
-})
 public class SqsIOTest {
 
-  @Rule public TestPipeline pipeline = TestPipeline.create();
+  @ClassRule public static EmbeddedSqsServer sqsServer = new EmbeddedSqsServer();
+
+  @Rule public TestCaseEnv testCase = new TestCaseEnv(sqsServer);
 
-  @Rule public EmbeddedSqsServer embeddedSqsRestServer = new EmbeddedSqsServer();
+  @Rule public TestPipeline pipeline = TestPipeline.create();
 
   @Test
   public void testWrite() {
-    final SqsClient client = embeddedSqsRestServer.getClient();
-    final String queueUrl = embeddedSqsRestServer.getQueueUrl();
+    final SqsClient client = testCase.getClient();
+    final String queueUrl = testCase.getQueueUrl();
 
     List<SendMessageRequest> messages = new ArrayList<>();
     for (int i = 0; i < 100; i++) {
diff --git a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReaderTest.java b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReaderTest.java
index e16b6fd4b2f..e007c08d86d 100644
--- a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReaderTest.java
+++ b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedReaderTest.java
@@ -17,72 +17,66 @@
  */
 package org.apache.beam.sdk.io.aws2.sqs;
 
+import static java.lang.System.currentTimeMillis;
+import static java.util.stream.IntStream.range;
 import static junit.framework.TestCase.assertFalse;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.Answers.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import java.io.IOException;
+import java.time.Clock;
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
+import org.apache.beam.sdk.coders.SerializableCoder;
 import org.apache.beam.sdk.io.UnboundedSource;
-import org.apache.beam.sdk.testing.TestPipeline;
+import org.apache.beam.sdk.io.aws2.sqs.EmbeddedSqsServer.TestCaseEnv;
 import org.apache.beam.sdk.util.CoderUtils;
+import org.junit.ClassRule;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
 import software.amazon.awssdk.services.sqs.SqsClient;
-import software.amazon.awssdk.services.sqs.model.ChangeMessageVisibilityRequest;
-import software.amazon.awssdk.services.sqs.model.SendMessageRequest;
 
 /** Tests on {@link SqsUnboundedReader}. */
-@RunWith(JUnit4.class)
+@RunWith(MockitoJUnitRunner.StrictStubs.class)
 public class SqsUnboundedReaderTest {
   private static final String DATA = "testData";
 
-  @Rule public TestPipeline pipeline = TestPipeline.create();
+  @ClassRule public static EmbeddedSqsServer sqsServer = new EmbeddedSqsServer();
 
-  @Rule public EmbeddedSqsServer embeddedSqsRestServer = new EmbeddedSqsServer();
+  @Rule public TestCaseEnv testCase = new TestCaseEnv(sqsServer);
 
-  private SqsUnboundedSource source;
+  @Mock(answer = RETURNS_DEEP_STUBS)
+  public SqsUnboundedSource mockSource;
 
-  private void setupOneMessage() {
-    final SqsClient client = embeddedSqsRestServer.getClient();
-    final String queueUrl = embeddedSqsRestServer.getQueueUrl();
-    client.sendMessage(SendMessageRequest.builder().queueUrl(queueUrl).messageBody(DATA).build());
-    source =
-        new SqsUnboundedSource(
-            SqsIO.read()
-                .withQueueUrl(queueUrl)
-                .withSqsClientProvider(StaticSqsClientProvider.of(client))
-                .withMaxNumRecords(1));
-  }
-
-  private void setupMessages(List<String> messages) {
-    final SqsClient client = embeddedSqsRestServer.getClient();
-    final String queueUrl = embeddedSqsRestServer.getQueueUrl();
+  private void setupMessages(String... messages) {
+    final SqsClient client = testCase.getClient();
+    final String queueUrl = testCase.getQueueUrl();
     for (String message : messages) {
-      client.sendMessage(
-          SendMessageRequest.builder().queueUrl(queueUrl).messageBody(message).build());
+      client.sendMessage(b -> b.queueUrl(queueUrl).messageBody(message));
     }
-    source =
-        new SqsUnboundedSource(
-            SqsIO.read()
-                .withQueueUrl(queueUrl)
-                .withSqsClientProvider(StaticSqsClientProvider.of(client))
-                .withMaxNumRecords(messages.size()));
+
+    when(mockSource.getRead().sqsClientProvider()).thenReturn(StaticSqsClientProvider.of(client));
+    when(mockSource.getRead().queueUrl()).thenReturn(queueUrl);
   }
 
   @Test
   public void testReadOneMessage() throws IOException {
-    setupOneMessage();
-    UnboundedSource.UnboundedReader<SqsMessage> reader =
-        source.createReader(pipeline.getOptions(), null);
+    setupMessages(DATA);
+    SqsUnboundedReader reader = new SqsUnboundedReader(mockSource, null);
+
     // Read one message.
     assertTrue(reader.start());
     assertEquals(DATA, reader.getCurrent().getBody());
     assertFalse(reader.advance());
+
     // ACK the message.
     UnboundedSource.CheckpointMark checkpoint = reader.getCheckpointMark();
     checkpoint.finalizeCheckpoint();
@@ -90,25 +84,80 @@ public class SqsUnboundedReaderTest {
   }
 
   @Test
-  public void testTimeoutAckAndRereadOneMessage() throws IOException {
-    setupOneMessage();
-    UnboundedSource.UnboundedReader<SqsMessage> reader =
-        source.createReader(pipeline.getOptions(), null);
-    SqsClient sqsClient = embeddedSqsRestServer.getClient();
+  public void testAckDeletedMessage() throws IOException {
+    setupMessages(DATA);
+    SqsUnboundedReader reader = new SqsUnboundedReader(mockSource, null);
+
+    // Read one message
+    assertTrue(reader.start());
+    assertEquals(DATA, reader.getCurrent().getBody());
+    String receiptHandle = reader.getCurrent().getReceiptHandle();
+    assertFalse(reader.advance());
+
+    // Simulate already ACKed message after re-delivery to different reader
+    testCase
+        .getClient()
+        .deleteMessage(b -> b.queueUrl(testCase.getQueueUrl()).receiptHandle(receiptHandle));
+
+    // Now ACK the message.
+    UnboundedSource.CheckpointMark checkpoint = reader.getCheckpointMark();
+    // Checkpoint can be finalized without failing due to invalid receipt handle
+    checkpoint.finalizeCheckpoint();
+    reader.close();
+  }
+
+  @Test
+  @Ignore("Behavior of SQSRestServer is broken: https://issues.apache.org/jira/browse/BEAM-13738")
+  public void testExtendDeletedMessage() throws IOException {
+    setupMessages(DATA);
+    Clock clock = mock(Clock.class);
+    when(clock.millis()).thenReturn(currentTimeMillis());
+
+    SqsUnboundedReader reader = new SqsUnboundedReader(mockSource, null, clock);
+
+    // Read one message
+    assertTrue(reader.start());
+    assertEquals(DATA, reader.getCurrent().getBody());
+
+    // Simulate already ACKed message after re-delivery to different reader
+    String receiptHandle = reader.getCurrent().getReceiptHandle();
+    testCase
+        .getClient()
+        .deleteMessage(b -> b.queueUrl(testCase.getQueueUrl()).receiptHandle(receiptHandle));
+
+    // Forward time to force extension of visibility
+    when(clock.millis()).thenReturn(currentTimeMillis() + reader.getVisibilityTimeoutMs() * 8 / 10);
+
+    // Advancing the reader will attempt extending the visibility of the only message received and
+    // succeeds despite the invalid receipt handle, but there's no further message.
+    assertFalse(reader.advance());
+    reader.close();
+  }
+
+  @Test
+  public void testRereadExpiredMessage() throws IOException {
+    setupMessages(DATA);
+    SqsUnboundedReader reader = new SqsUnboundedReader(mockSource, null);
+
+    // Read one message
     assertTrue(reader.start());
     assertEquals(DATA, reader.getCurrent().getBody());
     String receiptHandle = reader.getCurrent().getReceiptHandle();
-    // Set the message to timeout.
-    sqsClient.changeMessageVisibility(
-        ChangeMessageVisibilityRequest.builder()
-            .queueUrl(source.getRead().queueUrl())
-            .receiptHandle(receiptHandle)
-            .visibilityTimeout(0)
-            .build());
+
+    // Expire the message to simulate some delay in processing
+    testCase
+        .getClient()
+        .changeMessageVisibility(
+            b ->
+                b.queueUrl(testCase.getQueueUrl())
+                    .receiptHandle(receiptHandle)
+                    .visibilityTimeout(0));
+
     // We'll now receive the same message again.
     assertTrue(reader.advance());
     assertEquals(DATA, reader.getCurrent().getBody());
     assertFalse(reader.advance());
+
     // Now ACK the message.
     UnboundedSource.CheckpointMark checkpoint = reader.getCheckpointMark();
     checkpoint.finalizeCheckpoint();
@@ -116,14 +165,9 @@ public class SqsUnboundedReaderTest {
   }
 
   @Test
-  public void testMultipleReaders() throws IOException {
-    List<String> incoming = new ArrayList<>();
-    for (int i = 0; i < 2; i++) {
-      incoming.add(String.format("data_%d", i));
-    }
-    setupMessages(incoming);
-    UnboundedSource.UnboundedReader<SqsMessage> reader =
-        source.createReader(pipeline.getOptions(), null);
+  public void testRestoreReaderFromCheckpoint() throws IOException {
+    setupMessages("data_0", "data_1");
+    SqsUnboundedReader reader = new SqsUnboundedReader(mockSource, null);
     // Consume two messages, only read one.
     assertTrue(reader.start());
     assertEquals("data_0", reader.getCurrent().getBody());
@@ -138,13 +182,13 @@ public class SqsUnboundedReaderTest {
     assertEquals("data_1", reader.getCurrent().getBody());
 
     // Restore from checkpoint.
-    byte[] checkpointBytes =
-        CoderUtils.encodeToByteArray(source.getCheckpointMarkCoder(), checkpoint);
-    checkpoint = CoderUtils.decodeFromByteArray(source.getCheckpointMarkCoder(), checkpointBytes);
+    SerializableCoder<SqsCheckpointMark> coder = SerializableCoder.of(SqsCheckpointMark.class);
+    byte[] checkpointBytes = CoderUtils.encodeToByteArray(coder, checkpoint);
+    checkpoint = CoderUtils.decodeFromByteArray(coder, checkpointBytes);
     assertEquals(1, checkpoint.notYetReadReceipts.size());
 
     // Re-read second message.
-    reader = source.createReader(pipeline.getOptions(), checkpoint);
+    reader = new SqsUnboundedReader(mockSource, checkpoint);
     assertTrue(reader.start());
     assertEquals("data_1", reader.getCurrent().getBody());
 
@@ -158,44 +202,31 @@ public class SqsUnboundedReaderTest {
   }
 
   @Test
-  public void testReadMany() throws IOException {
-
-    HashSet<String> messages = new HashSet<>();
-    List<String> incoming = new ArrayList<>();
-    for (int i = 0; i < 100; i++) {
-      String content = String.format("data_%d", i);
-      messages.add(content);
-      incoming.add(String.format("data_%d", i));
-    }
-    setupMessages(incoming);
-
-    SqsUnboundedReader reader =
-        (SqsUnboundedReader) source.createReader(pipeline.getOptions(), null);
-
-    for (int i = 0; i < 100; i++) {
-      if (i == 0) {
-        assertTrue(reader.start());
-      } else {
-        assertTrue(reader.advance());
-      }
-      String data = reader.getCurrent().getBody();
-      boolean messageNum = messages.remove(data);
-      // No duplicate messages.
-      assertTrue(messageNum);
-    }
-    // We are done.
-    assertFalse(reader.advance());
-    // We saw each message exactly once.
-    assertTrue(messages.isEmpty());
+  public void testReadManyMessages() throws IOException {
+    List<String> receivedMessages = new ArrayList<>();
+    setupMessages(range(0, 100).mapToObj(Integer::toString).toArray(String[]::new));
+
+    SqsUnboundedReader reader = new SqsUnboundedReader(mockSource, null);
+
+    assertTrue(reader.start());
+    do {
+      receivedMessages.add(reader.getCurrent().getBody());
+    } while (reader.advance());
+
+    assertThat(receivedMessages).hasSize(100);
+    assertThat(receivedMessages).doesNotHaveDuplicates();
+
+    // ACK all messages
+    UnboundedSource.CheckpointMark checkpoint = reader.getCheckpointMark();
+    checkpoint.finalizeCheckpoint();
     reader.close();
   }
 
   /** Tests that checkpoints finalized after the reader is closed succeed. */
   @Test
   public void testCloseWithActiveCheckpoints() throws Exception {
-    setupOneMessage();
-    UnboundedSource.UnboundedReader<SqsMessage> reader =
-        source.createReader(pipeline.getOptions(), null);
+    setupMessages(DATA);
+    SqsUnboundedReader reader = new SqsUnboundedReader(mockSource, null);
     reader.start();
     UnboundedSource.CheckpointMark checkpoint = reader.getCheckpointMark();
     reader.close();
diff --git a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedSourceTest.java b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedSourceTest.java
index 8ee9a918d79..b8acf61e056 100644
--- a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedSourceTest.java
+++ b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/sqs/SqsUnboundedSourceTest.java
@@ -17,36 +17,20 @@
  */
 package org.apache.beam.sdk.io.aws2.sqs;
 
+import static org.mockito.Mockito.mock;
+
 import org.apache.beam.sdk.testing.CoderProperties;
-import org.apache.beam.sdk.testing.TestPipeline;
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-import software.amazon.awssdk.services.sqs.SqsClient;
-import software.amazon.awssdk.services.sqs.model.SendMessageRequest;
 
 /** Tests on {@link SqsUnboundedSource}. */
 @RunWith(JUnit4.class)
 public class SqsUnboundedSourceTest {
 
-  private static final String DATA = "testData";
-
-  @Rule public TestPipeline pipeline = TestPipeline.create();
-
-  @Rule public EmbeddedSqsServer embeddedSqsRestServer = new EmbeddedSqsServer();
-
   @Test
   public void testCheckpointCoderIsSane() {
-    final SqsClient client = embeddedSqsRestServer.getClient();
-    final String queueUrl = embeddedSqsRestServer.getQueueUrl();
-    client.sendMessage(SendMessageRequest.builder().queueUrl(queueUrl).messageBody(DATA).build());
-    SqsUnboundedSource source =
-        new SqsUnboundedSource(
-            SqsIO.read()
-                .withQueueUrl(queueUrl)
-                .withSqsClientProvider(StaticSqsClientProvider.of(client))
-                .withMaxNumRecords(1));
+    SqsUnboundedSource source = new SqsUnboundedSource(mock(SqsIO.Read.class));
     CoderProperties.coderSerializable(source.getCheckpointMarkCoder());
   }
 }
