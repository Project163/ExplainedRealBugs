diff --git a/sdks/python/apache_beam/typehints/decorators.py b/sdks/python/apache_beam/typehints/decorators.py
index 81ca4b28ae8..4f53eb530eb 100644
--- a/sdks/python/apache_beam/typehints/decorators.py
+++ b/sdks/python/apache_beam/typehints/decorators.py
@@ -311,6 +311,11 @@ class IOTypeHints(object):
     Only affects instances with simple output types, otherwise is a no-op.
     Does not modify self.
 
+    Designed to be used with type hints from callables of ParDo, FlatMap, DoFn.
+    Output type may be Optional[T], in which case the result of stripping T is
+    used as the output type.
+    Output type may be None/NoneType, in which case nothing is done.
+
     Example: Generator[Tuple(int, int)] becomes Tuple(int, int)
 
     Returns:
@@ -321,7 +326,20 @@ class IOTypeHints(object):
     """
     if not self.has_simple_output_type():
       return self
-    yielded_type = typehints.get_yielded_type(self.output_types[0][0])
+    output_type = self.output_types[0][0]
+    if output_type is None or isinstance(output_type, type(None)):
+      return self
+    # If output_type == Optional[T]: output_type = T.
+    if isinstance(output_type, typehints.UnionConstraint):
+      types = list(output_type.union_types)
+      if len(types) == 2:
+        try:
+          types.remove(type(None))
+          output_type = types[0]
+        except ValueError:
+          pass
+
+    yielded_type = typehints.get_yielded_type(output_type)
     res = self.copy()
     res.output_types = ((yielded_type,), {})
     return res
diff --git a/sdks/python/apache_beam/typehints/decorators_test.py b/sdks/python/apache_beam/typehints/decorators_test.py
index 1edbae3edc5..f477f923dc0 100644
--- a/sdks/python/apache_beam/typehints/decorators_test.py
+++ b/sdks/python/apache_beam/typehints/decorators_test.py
@@ -90,8 +90,7 @@ class IOTypeHintsTest(unittest.TestCase):
       self._test_strip_iterable(before, None)
 
   def test_strip_iterable(self):
-    # TODO(BEAM-8492): Uncomment once #9895 is merged.
-    # self._test_strip_iterable(None, None)
+    self._test_strip_iterable(None, None)
     self._test_strip_iterable(typehints.Any, typehints.Any)
     self._test_strip_iterable(typehints.Iterable[str], str)
     self._test_strip_iterable(typehints.List[str], str)
diff --git a/sdks/python/apache_beam/typehints/typed_pipeline_test_py3.py b/sdks/python/apache_beam/typehints/typed_pipeline_test_py3.py
index 81fa5c1226b..7f853844403 100644
--- a/sdks/python/apache_beam/typehints/typed_pipeline_test_py3.py
+++ b/sdks/python/apache_beam/typehints/typed_pipeline_test_py3.py
@@ -126,6 +126,31 @@ class MainInputTest(unittest.TestCase):
     with self.assertRaisesRegex(ValueError, r'str.*is not iterable'):
       _ = [1, 2, 3] | beam.ParDo(MyDoFn())
 
+  def test_typed_dofn_method_return_none(self):
+    class MyDoFn(beam.DoFn):
+      def process(self, unused_element: int) -> None:
+        pass
+
+    result = [1, 2, 3] | beam.ParDo(MyDoFn())
+    self.assertListEqual([], result)
+
+  def test_typed_dofn_method_return_optional(self):
+    class MyDoFn(beam.DoFn):
+      def process(self, unused_element: int) -> typehints.Optional[
+          typehints.Iterable[int]]:
+        pass
+
+    result = [1, 2, 3] | beam.ParDo(MyDoFn())
+    self.assertListEqual([], result)
+
+  def test_typed_dofn_method_return_optional_not_iterable(self):
+    class MyDoFn(beam.DoFn):
+      def process(self, unused_element: int) -> typehints.Optional[int]:
+        pass
+
+    with self.assertRaisesRegex(ValueError, r'int.*is not iterable'):
+      _ = [1, 2, 3] | beam.ParDo(MyDoFn())
+
   def test_typed_callable_not_iterable(self):
     def do_fn(element: int) -> int:
       return [element]  # Return a list to not fail the pipeline.
@@ -178,6 +203,57 @@ class MainInputTest(unittest.TestCase):
     result = [1, 2] | beam.ParDo(MyDoFn())
     self.assertEqual([['1', '1'], ['2', '2']], sorted(result))
 
+  def test_typed_map(self):
+    def fn(element: int) -> int:
+      return element * 2
+
+    result = [1, 2, 3] | beam.Map(fn)
+    self.assertEqual([2, 4, 6], sorted(result))
+
+  def test_typed_map_return_optional(self):
+    # None is a valid element value for Map.
+    def fn(element: int) -> typehints.Optional[int]:
+      if element > 1:
+        return element
+
+    result = [1, 2, 3] | beam.Map(fn)
+    self.assertCountEqual([None, 2, 3], result)
+
+  def test_typed_flatmap(self):
+    def fn(element: int) -> typehints.Iterable[int]:
+      yield element * 2
+
+    result = [1, 2, 3] | beam.FlatMap(fn)
+    self.assertCountEqual([2, 4, 6], result)
+
+  def test_typed_flatmap_output_hint_not_iterable(self):
+    def fn(element: int) -> int:
+      return element * 2
+
+    # TODO(BEAM-8466): This case currently only generates a warning instead of a
+    #   typehints.TypeCheckError.
+    with self.assertRaisesRegex(TypeError, r'int.*is not iterable'):
+      _ = [1, 2, 3] | beam.FlatMap(fn)
+
+  def test_typed_flatmap_output_value_not_iterable(self):
+    def fn(element: int) -> typehints.Iterable[int]:
+      return element * 2
+
+    with self.assertRaisesRegex(TypeError, r'int.*is not iterable'):
+      _ = [1, 2, 3] | beam.FlatMap(fn)
+
+  def test_typed_flatmap_optional(self):
+    def fn(element: int) -> typehints.Optional[typehints.Iterable[int]]:
+      if element > 1:
+        yield element * 2
+
+    # Verify that the output type of fn is int and not Optional[int].
+    def fn2(element: int) -> int:
+      return element
+
+    result = [1, 2, 3] | beam.FlatMap(fn) | beam.Map(fn2)
+    self.assertCountEqual([4, 6], result)
+
 
 class AnnotationsTest(unittest.TestCase):
 
@@ -232,6 +308,15 @@ class AnnotationsTest(unittest.TestCase):
     self.assertEqual(th.input_types, ((int,), {}))
     self.assertEqual(th.output_types, ((int,), {}))
 
+  def test_flat_map_wrapper_optional_output(self):
+    # Optional should not affect output type (Nones are ignored).
+    def map_fn(element: int) -> typehints.Optional[typehints.Iterable[int]]:
+      return [element, element + 1]
+
+    th = beam.FlatMap(map_fn).get_type_hints()
+    self.assertEqual(th.input_types, ((int,), {}))
+    self.assertEqual(th.output_types, ((int,), {}))
+
   @unittest.skip('BEAM-8662: Py3 annotations not yet supported for MapTuple')
   def test_flat_map_tuple_wrapper(self):
     # TODO(BEAM-8662): Also test with a fn that accepts default arguments.
@@ -250,6 +335,15 @@ class AnnotationsTest(unittest.TestCase):
     self.assertEqual(th.input_types, ((int,), {}))
     self.assertEqual(th.output_types, ((int,), {}))
 
+  def test_map_wrapper_optional_output(self):
+    # Optional does affect output type (Nones are NOT ignored).
+    def map_fn(unused_element: int) -> typehints.Optional[int]:
+      return 1
+
+    th = beam.Map(map_fn).get_type_hints()
+    self.assertEqual(th.input_types, ((int,), {}))
+    self.assertEqual(th.output_types, ((typehints.Optional[int],), {}))
+
   @unittest.skip('BEAM-8662: Py3 annotations not yet supported for MapTuple')
   def test_map_tuple(self):
     # TODO(BEAM-8662): Also test with a fn that accepts default arguments.
