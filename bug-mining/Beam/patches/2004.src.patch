diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java
index fe5287754c9..aebcdb6212d 100644
--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java
+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java
@@ -127,6 +127,7 @@ public class BeamFnDataReadRunner<OutputT> {
               consumer);
       startFunctionRegistry.register(pTransformId, runner::registerInputLocation);
       finishFunctionRegistry.register(pTransformId, runner::blockTillReadFinishes);
+      addResetFunction.accept(runner::reset);
       return runner;
     }
   }
@@ -139,8 +140,8 @@ public class BeamFnDataReadRunner<OutputT> {
   private final Coder<WindowedValue<OutputT>> coder;
 
   private final Object splittingLock = new Object();
-  private boolean started = false;
-  // 0-based index of the current element being processed
+  // 0-based index of the current element being processed. -1 if we have yet to process an element.
+  // stopIndex if we are done processing.
   private long index;
   // 0-based index of the first element to not process, aka the first element of the residual
   private long stopIndex;
@@ -184,8 +185,6 @@ public class BeamFnDataReadRunner<OutputT> {
 
     addProgressRequestCallback.accept(
         () -> {
-          // TODO(BEAM-9979): Fix race condition where reused BeamFnDataReadRunner reports
-          // read index from last bundle since registerInputLocation may have not yet been called.
           synchronized (splittingLock) {
             return ImmutableList.of(
                 new SimpleMonitoringInfoBuilder()
@@ -195,14 +194,10 @@ public class BeamFnDataReadRunner<OutputT> {
                     .build());
           }
         });
+    reset();
   }
 
   public void registerInputLocation() {
-    synchronized (splittingLock) {
-      started = true;
-      index = -1;
-      stopIndex = Long.MAX_VALUE;
-    }
     this.readFuture =
         beamFnDataClient.receive(
             apiServiceDescriptor,
@@ -237,8 +232,9 @@ public class BeamFnDataReadRunner<OutputT> {
     }
 
     synchronized (splittingLock) {
-      // Don't attempt to split if we haven't started.
-      if (!started) {
+      // Don't attempt to split if we are already done since there isn't a meaningful split we can
+      // provide.
+      if (index == stopIndex) {
         return;
       }
       // Since we hold the splittingLock, we guarantee that we will not pass the next element
@@ -342,11 +338,16 @@ public class BeamFnDataReadRunner<OutputT> {
         pTransformId);
     readFuture.awaitCompletion();
     synchronized (splittingLock) {
-      started = false;
       index += 1;
+      stopIndex = index;
     }
   }
 
+  public void reset() {
+    index = -1;
+    stopIndex = Long.MAX_VALUE;
+  }
+
   private boolean isValidSplitPoint(List<Long> allowedSplitPoints, long index) {
     return allowedSplitPoints.isEmpty() || allowedSplitPoints.contains(index);
   }
diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java
index 779fd0e1b27..ed46188e1d1 100644
--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java
+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java
@@ -288,16 +288,18 @@ public class BeamFnDataReadRunnerTest {
               Iterables.getOnlyElement(progressCallbacks).getMonitoringInfos()));
       assertThat(values, contains(valueInGlobalWindow("ABC"), valueInGlobalWindow("DEF")));
 
-      // Process for bundle id 1
-      bundleId.set("1");
+      readRunner.reset();
       values.clear();
-      readRunner.registerInputLocation();
       // Ensure that when we reuse the BeamFnDataReadRunner the read index is reset to -1
+      // before registerInputLocation.
       assertEquals(
           createReadIndexMonitoringInfoAt(-1),
           Iterables.getOnlyElement(
               Iterables.getOnlyElement(progressCallbacks).getMonitoringInfos()));
 
+      // Process for bundle id 1
+      bundleId.set("1");
+      readRunner.registerInputLocation();
       verify(mockBeamFnDataClient)
           .receive(
               eq(PORT_SPEC.getApiServiceDescriptor()),
@@ -352,6 +354,35 @@ public class BeamFnDataReadRunnerTest {
       fail("Expected registrar not found.");
     }
 
+    @Test
+    public void testSplittingBeforeStartBundle() throws Exception {
+      List<WindowedValue<String>> outputValues = new ArrayList<>();
+      BeamFnDataReadRunner<String> readRunner =
+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);
+      // The split should happen at 5 since the allowedSplitPoints is empty.
+      assertEquals(
+          channelSplitResult(5),
+          executeSplit(readRunner, PTRANSFORM_ID, -1L, 0.5, 10, Collections.EMPTY_LIST));
+
+      readRunner.registerInputLocation();
+      // Ensure that we process the correct number of elements after splitting.
+      readRunner.forwardElementToConsumer(valueInGlobalWindow("A"));
+      readRunner.forwardElementToConsumer(valueInGlobalWindow("B"));
+      readRunner.forwardElementToConsumer(valueInGlobalWindow("C"));
+      readRunner.forwardElementToConsumer(valueInGlobalWindow("D"));
+      readRunner.forwardElementToConsumer(valueInGlobalWindow("E"));
+      readRunner.forwardElementToConsumer(valueInGlobalWindow("F"));
+      readRunner.forwardElementToConsumer(valueInGlobalWindow("G"));
+      assertThat(
+          outputValues,
+          contains(
+              valueInGlobalWindow("A"),
+              valueInGlobalWindow("B"),
+              valueInGlobalWindow("C"),
+              valueInGlobalWindow("D"),
+              valueInGlobalWindow("E")));
+    }
+
     @Test
     public void testSplittingWhenNoElementsProcessed() throws Exception {
       List<WindowedValue<String>> outputValues = new ArrayList<>();
