diff --git a/sdks/java/io/jdbc/src/main/java/org/apache/beam/sdk/io/jdbc/LogicalTypes.java b/sdks/java/io/jdbc/src/main/java/org/apache/beam/sdk/io/jdbc/LogicalTypes.java
index 2e587288380..2831fcada87 100644
--- a/sdks/java/io/jdbc/src/main/java/org/apache/beam/sdk/io/jdbc/LogicalTypes.java
+++ b/sdks/java/io/jdbc/src/main/java/org/apache/beam/sdk/io/jdbc/LogicalTypes.java
@@ -20,6 +20,7 @@ package org.apache.beam.sdk.io.jdbc;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;
 
 import java.math.BigDecimal;
+import java.math.MathContext;
 import java.sql.JDBCType;
 import java.time.Instant;
 import java.util.Arrays;
@@ -266,8 +267,11 @@ class LogicalTypes {
     @Override
     public BigDecimal toInputType(BigDecimal base) {
       checkArgument(
-          base == null || (base.precision() == precision && base.scale() == scale),
-          "Expected BigDecimal base to be null or have precision = %s (was %s), scale = %s (was %s)",
+          base == null
+              || (base.precision() <= precision && base.scale() <= scale)
+              // for cases when received values can be safely coerced to the schema
+              || base.round(new MathContext(precision)).compareTo(base) == 0,
+          "Expected BigDecimal base to be null or have precision <= %s (was %s), scale <= %s (was %s)",
           precision,
           base.precision(),
           scale,
diff --git a/sdks/java/io/jdbc/src/test/java/org/apache/beam/sdk/io/jdbc/JdbcIOTest.java b/sdks/java/io/jdbc/src/test/java/org/apache/beam/sdk/io/jdbc/JdbcIOTest.java
index 695ad036ef0..9d1d75b8f64 100644
--- a/sdks/java/io/jdbc/src/test/java/org/apache/beam/sdk/io/jdbc/JdbcIOTest.java
+++ b/sdks/java/io/jdbc/src/test/java/org/apache/beam/sdk/io/jdbc/JdbcIOTest.java
@@ -37,6 +37,7 @@ import static org.mockito.Mockito.when;
 
 import java.io.Serializable;
 import java.math.BigDecimal;
+import java.math.RoundingMode;
 import java.nio.charset.Charset;
 import java.sql.Array;
 import java.sql.Connection;
@@ -328,6 +329,40 @@ public class JdbcIOTest implements Serializable {
     pipeline.run();
   }
 
+  @Test
+  public void testReadRowsWithNumericFieldsWithExcessPrecision() {
+    PCollection<Row> rows =
+        pipeline.apply(
+            JdbcIO.readRows()
+                .withDataSourceConfiguration(DATA_SOURCE_CONFIGURATION)
+                .withQuery(
+                    String.format(
+                        "SELECT CAST(1 AS NUMERIC(10, 2)) AS T1 FROM %s WHERE name = ?",
+                        READ_TABLE_NAME))
+                .withStatementPreparator(
+                    preparedStatement ->
+                        preparedStatement.setString(1, TestRow.getNameForSeed(1))));
+
+    Schema expectedSchema =
+        Schema.of(
+            Schema.Field.of(
+                "T1",
+                FieldType.logicalType(FixedPrecisionNumeric.of(NUMERIC.getName(), 10, 2))
+                    .withNullable(false)));
+
+    assertEquals(expectedSchema, rows.getSchema());
+
+    PCollection<Row> output = rows.apply(Select.fieldNames("T1"));
+    PAssert.that(output)
+        .containsInAnyOrder(
+            ImmutableList.of(
+                Row.withSchema(expectedSchema)
+                    .addValues(BigDecimal.valueOf(1).setScale(2, RoundingMode.HALF_UP))
+                    .build()));
+
+    pipeline.run();
+  }
+
   @Test
   public void testReadRowsWithoutStatementPreparator() {
     SerializableFunction<Void, DataSource> dataSourceProvider = ignored -> DATA_SOURCE;
