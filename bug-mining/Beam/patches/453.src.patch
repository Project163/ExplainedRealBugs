diff --git a/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkProcessContext.java b/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkProcessContext.java
index 8b85155fd53..4376c386f4e 100644
--- a/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkProcessContext.java
+++ b/runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkProcessContext.java
@@ -21,7 +21,7 @@ package org.apache.beam.runners.spark.translation;
 import static com.google.common.base.Preconditions.checkArgument;
 
 import com.google.common.collect.AbstractIterator;
-import com.google.common.collect.Lists;
+import java.util.ArrayList;
 import java.util.Iterator;
 import org.apache.beam.runners.core.DoFnRunner;
 import org.apache.beam.runners.core.DoFnRunners.OutputManager;
@@ -61,17 +61,13 @@ class SparkProcessContext<FnInputT, FnOutputT, OutputT> {
   Iterable<OutputT> processPartition(
       Iterator<WindowedValue<FnInputT>> partition) throws Exception {
 
-    // setup DoFn.
-    DoFnInvokers.invokerFor(doFn).invokeSetup();
-
     // skip if partition is empty.
     if (!partition.hasNext()) {
-      DoFnInvokers.invokerFor(doFn).invokeTeardown();
-      return Lists.newArrayList();
+      return new ArrayList<>();
     }
 
-    // call startBundle() before beginning to process the partition.
-    doFnRunner.startBundle();
+    // setup DoFn.
+    DoFnInvokers.invokerFor(doFn).invokeSetup();
     // process the partition; finishBundle() is called from within the output iterator.
     return this.getOutputIterable(partition, doFnRunner);
   }
@@ -87,7 +83,6 @@ class SparkProcessContext<FnInputT, FnOutputT, OutputT> {
   private Iterable<OutputT> getOutputIterable(
       final Iterator<WindowedValue<FnInputT>> iter,
       final DoFnRunner<FnInputT, FnOutputT> doFnRunner) {
-
     return new Iterable<OutputT>() {
       @Override
       public Iterator<OutputT> iterator() {
@@ -120,7 +115,8 @@ class SparkProcessContext<FnInputT, FnOutputT, OutputT> {
     private final Iterator<WindowedValue<FnInputT>> inputIterator;
     private final DoFnRunner<FnInputT, FnOutputT> doFnRunner;
     private Iterator<OutputT> outputIterator;
-    private boolean calledFinish;
+    private boolean isBundleStarted;
+    private boolean isBundleFinished;
 
     ProcCtxtIterator(
         Iterator<WindowedValue<FnInputT>> iterator,
@@ -137,31 +133,41 @@ class SparkProcessContext<FnInputT, FnOutputT, OutputT> {
       // collection (and iterator) is reset between each call to processElement, so the
       // collection only holds the output values for each call to processElement, rather
       // than for the whole partition (which would use too much memory).
-      while (true) {
-        if (outputIterator.hasNext()) {
-          return outputIterator.next();
-        } else if (inputIterator.hasNext()) {
-          clearOutput();
-          // grab the next element and process it.
-          doFnRunner.processElement(inputIterator.next());
-          outputIterator = getOutputIterator();
-        } else if (timerDataIterator.hasNext()) {
+      if (!isBundleStarted) {
+        isBundleStarted = true;
+        // call startBundle() before beginning to process the partition.
+        doFnRunner.startBundle();
+      }
+
+      try {
+        while (true) {
+          if (outputIterator.hasNext()) {
+            return outputIterator.next();
+          }
+
           clearOutput();
-          fireTimer(timerDataIterator.next());
-          outputIterator = getOutputIterator();
-        } else {
-          // no more input to consume, but finishBundle can produce more output
-          if (!calledFinish) {
-            clearOutput();
-            calledFinish = true;
-            doFnRunner.finishBundle();
-            // teardown DoFn.
-            DoFnInvokers.invokerFor(doFn).invokeTeardown();
+          if (inputIterator.hasNext()) {
+            // grab the next element and process it.
+            doFnRunner.processElement(inputIterator.next());
+            outputIterator = getOutputIterator();
+          } else if (timerDataIterator.hasNext()) {
+            fireTimer(timerDataIterator.next());
             outputIterator = getOutputIterator();
-            continue; // try to consume outputIterator from start of loop
+          } else {
+            // no more input to consume, but finishBundle can produce more output
+            if (!isBundleFinished) {
+              isBundleFinished = true;
+              doFnRunner.finishBundle();
+              outputIterator = getOutputIterator();
+              continue; // try to consume outputIterator from start of loop
+            }
+            DoFnInvokers.invokerFor(doFn).invokeTeardown();
+            return endOfData();
           }
-          return endOfData();
         }
+      } catch (final RuntimeException re) {
+        DoFnInvokers.invokerFor(doFn).invokeTeardown();
+        throw re;
       }
     }
 
