diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileSystems.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileSystems.java
index cacd4770525..46573c68070 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileSystems.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileSystems.java
@@ -272,10 +272,14 @@ public class FileSystems {
   public static void copy(
       List<ResourceId> srcResourceIds, List<ResourceId> destResourceIds, MoveOptions... moveOptions)
       throws IOException {
-    FilterResult filtered = filterFiles(srcResourceIds, destResourceIds, moveOptions);
+    validateSrcDestLists(srcResourceIds, destResourceIds);
+    if (srcResourceIds.isEmpty()) {
+      return;
+    }
+    FileSystem fileSystem = getFileSystemInternal(srcResourceIds.iterator().next().getScheme());
+    FilterResult filtered = filterFiles(fileSystem, srcResourceIds, destResourceIds, moveOptions);
     if (!filtered.resultSources.isEmpty()) {
-      getFileSystemInternal(filtered.resultSources.iterator().next().getScheme())
-          .copy(filtered.resultSources, filtered.resultDestinations);
+      fileSystem.copy(filtered.resultSources, filtered.resultDestinations);
     }
   }
 
@@ -297,22 +301,36 @@ public class FileSystems {
   public static void rename(
       List<ResourceId> srcResourceIds, List<ResourceId> destResourceIds, MoveOptions... moveOptions)
       throws IOException {
-    FilterResult filtered = filterFiles(srcResourceIds, destResourceIds, moveOptions);
-    if (!filtered.resultSources.isEmpty()) {
-      try {
-        getFileSystemInternal(filtered.resultSources.iterator().next().getScheme())
-            .rename(filtered.resultSources, filtered.resultDestinations, moveOptions);
-      } catch (UnsupportedOperationException e) {
-        // Some file systems do not yet support specifying the move options.  We handle the move
-        // options above with filtering so specifying them is just an optimization for error
-        // handling and it is safe to rename without specifying them.
-        getFileSystemInternal(filtered.resultSources.iterator().next().getScheme())
-            .rename(filtered.resultSources, filtered.resultDestinations);
-      }
+    validateSrcDestLists(srcResourceIds, destResourceIds);
+    if (srcResourceIds.isEmpty()) {
+      return;
     }
-    if (!filtered.filteredExistingSrcs.isEmpty()) {
-      getFileSystemInternal(filtered.filteredExistingSrcs.iterator().next().getScheme())
-          .delete(filtered.filteredExistingSrcs);
+    renameInternal(
+        getFileSystemInternal(srcResourceIds.iterator().next().getScheme()),
+        srcResourceIds,
+        destResourceIds,
+        moveOptions);
+  }
+
+  @VisibleForTesting
+  static void renameInternal(
+      FileSystem fileSystem,
+      List<ResourceId> srcResourceIds,
+      List<ResourceId> destResourceIds,
+      MoveOptions... moveOptions)
+      throws IOException {
+    try {
+      fileSystem.rename(srcResourceIds, destResourceIds, moveOptions);
+    } catch (UnsupportedOperationException e) {
+      // Some file systems do not yet support specifying the move options. Instead we
+      // perform filtering using match calls before renaming.
+      FilterResult filtered = filterFiles(fileSystem, srcResourceIds, destResourceIds, moveOptions);
+      if (!filtered.resultSources.isEmpty()) {
+        fileSystem.rename(filtered.resultSources, filtered.resultDestinations);
+      }
+      if (!filtered.filteredExistingSrcs.isEmpty()) {
+        fileSystem.delete(filtered.filteredExistingSrcs);
+      }
     }
   }
 
@@ -382,9 +400,11 @@ public class FileSystems {
   };
 
   private static FilterResult filterFiles(
-      List<ResourceId> srcResourceIds, List<ResourceId> destResourceIds, MoveOptions... moveOptions)
+      FileSystem fileSystem,
+      List<ResourceId> srcResourceIds,
+      List<ResourceId> destResourceIds,
+      MoveOptions... moveOptions)
       throws IOException {
-    validateSrcDestLists(srcResourceIds, destResourceIds);
     FilterResult result = new FilterResult();
     if (moveOptions.length == 0 || srcResourceIds.isEmpty()) {
       // Nothing will be filtered.
@@ -407,7 +427,9 @@ public class FileSystems {
     if (skipExistingDest) {
       matchResources.addAll(destResourceIds);
     }
-    List<MatchResult> matchResults = matchResources(matchResources);
+    List<MatchResult> matchResults =
+        fileSystem.match(
+            FluentIterable.from(matchResources).transform(ResourceId::toString).toList());
     List<MatchResult> matchSrcResults = ignoreMissingSrc ? matchResults.subList(0, size) : null;
     List<MatchResult> matchDestResults =
         skipExistingDest
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/fs/MatchResult.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/fs/MatchResult.java
index 839c581a869..ceb8ae8bf9e 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/fs/MatchResult.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/fs/MatchResult.java
@@ -117,6 +117,7 @@ public abstract class MatchResult {
 
     public static Builder builder() {
       return new AutoValue_MatchResult_Metadata.Builder()
+          .setIsReadSeekEfficient(false)
           .setLastModifiedMillis(UNKNOWN_LAST_MODIFIED_MILLIS);
     }
 
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/FileSystemsTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/FileSystemsTest.java
index d1e9397e56b..023aaeccdf4 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/FileSystemsTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/FileSystemsTest.java
@@ -23,7 +23,12 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeFalse;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
+import java.io.FileNotFoundException;
 import java.io.Writer;
 import java.nio.channels.Channels;
 import java.nio.charset.StandardCharsets;
@@ -32,6 +37,7 @@ import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.List;
 import org.apache.beam.sdk.io.fs.CreateOptions;
+import org.apache.beam.sdk.io.fs.MatchResult;
 import org.apache.beam.sdk.io.fs.MoveOptions;
 import org.apache.beam.sdk.io.fs.ResourceId;
 import org.apache.beam.sdk.options.PipelineOptionsFactory;
@@ -189,6 +195,86 @@ public class FileSystemsTest {
         containsInAnyOrder("content3"));
   }
 
+  @Test
+  public void testRenameWithFilteringAfterUnsupportedOptions() throws Exception {
+    FileSystem mockFileSystem = mock(FileSystem.class);
+
+    Path srcPath1 = temporaryFolder.newFile().toPath();
+    Path nonExistentPath = srcPath1.resolveSibling("non-existent");
+    Path srcPath3 = temporaryFolder.newFile().toPath();
+
+    Path destPath1 = srcPath1.resolveSibling("dest1");
+    Path destPath2 = nonExistentPath.resolveSibling("dest2");
+    Path destPath3 = srcPath1.resolveSibling("dest3");
+
+    doThrow(new UnsupportedOperationException("move options not supported."))
+        .when(mockFileSystem)
+        .rename(
+            toResourceIds(ImmutableList.of(srcPath1, nonExistentPath, srcPath3), false),
+            toResourceIds(ImmutableList.of(destPath1, destPath2, destPath3), false),
+            MoveOptions.StandardMoveOptions.SKIP_IF_DESTINATION_EXISTS,
+            MoveOptions.StandardMoveOptions.IGNORE_MISSING_FILES);
+    when(mockFileSystem.match(
+            ImmutableList.of(
+                srcPath1.toString(),
+                nonExistentPath.toString(),
+                srcPath3.toString(),
+                destPath1.toString(),
+                destPath2.toString(),
+                destPath3.toString())))
+        .thenReturn(
+            ImmutableList.of(
+                MatchResult.create(
+                    MatchResult.Status.OK,
+                    ImmutableList.of(
+                        MatchResult.Metadata.builder()
+                            .setChecksum("1")
+                            .setResourceId(LocalResourceId.fromPath(srcPath1, false))
+                            .setSizeBytes(1)
+                            .build())),
+                MatchResult.create(MatchResult.Status.NOT_FOUND, new FileNotFoundException("")),
+                MatchResult.create(
+                    MatchResult.Status.OK,
+                    ImmutableList.of(
+                        MatchResult.Metadata.builder()
+                            .setChecksum("3")
+                            .setResourceId(LocalResourceId.fromPath(srcPath3, false))
+                            .setSizeBytes(1)
+                            .build())),
+                MatchResult.create(MatchResult.Status.NOT_FOUND, new FileNotFoundException("")),
+                MatchResult.create(
+                    MatchResult.Status.OK,
+                    ImmutableList.of(
+                        MatchResult.Metadata.builder()
+                            .setChecksum("2")
+                            .setResourceId(LocalResourceId.fromPath(destPath2, false))
+                            .setSizeBytes(1)
+                            .build())),
+                MatchResult.create(
+                    MatchResult.Status.OK,
+                    ImmutableList.of(
+                        MatchResult.Metadata.builder()
+                            .setChecksum("3")
+                            .setResourceId(LocalResourceId.fromPath(destPath3, false))
+                            .setSizeBytes(1)
+                            .build()))));
+
+    FileSystems.renameInternal(
+        mockFileSystem,
+        toResourceIds(
+            ImmutableList.of(srcPath1, nonExistentPath, srcPath3), false /* isDirectory */),
+        toResourceIds(ImmutableList.of(destPath1, destPath2, destPath3), false /* isDirectory */),
+        MoveOptions.StandardMoveOptions.SKIP_IF_DESTINATION_EXISTS,
+        MoveOptions.StandardMoveOptions.IGNORE_MISSING_FILES);
+
+    verify(mockFileSystem)
+        .rename(
+            toResourceIds(ImmutableList.of(srcPath1), false /* isDirectory */),
+            toResourceIds(ImmutableList.of(destPath1), false /* isDirectory */));
+    verify(mockFileSystem)
+        .delete(toResourceIds(ImmutableList.of(srcPath3), false /* isDirectory */));
+  }
+
   @Test
   public void testValidMatchNewResourceForLocalFileSystem() {
     assertEquals("file", FileSystems.matchNewResource("/tmp/f1", false).getScheme());
@@ -202,7 +288,7 @@ public class FileSystemsTest {
     assertEquals("file", FileSystems.matchNewResource("c:/tmp/f1", false));
   }
 
-  private List<ResourceId> toResourceIds(List<Path> paths, final boolean isDirectory) {
+  private static List<ResourceId> toResourceIds(List<Path> paths, final boolean isDirectory) {
     return FluentIterable.from(paths)
         .transform(path -> (ResourceId) LocalResourceId.fromPath(path, isDirectory))
         .toList();
diff --git a/sdks/java/extensions/google-cloud-platform-core/src/main/java/org/apache/beam/sdk/extensions/gcp/util/GcsUtil.java b/sdks/java/extensions/google-cloud-platform-core/src/main/java/org/apache/beam/sdk/extensions/gcp/util/GcsUtil.java
index f6a67034636..538ddaa3a8c 100644
--- a/sdks/java/extensions/google-cloud-platform-core/src/main/java/org/apache/beam/sdk/extensions/gcp/util/GcsUtil.java
+++ b/sdks/java/extensions/google-cloud-platform-core/src/main/java/org/apache/beam/sdk/extensions/gcp/util/GcsUtil.java
@@ -793,7 +793,12 @@ public class GcsUtil {
 
   public void copy(Iterable<String> srcFilenames, Iterable<String> destFilenames)
       throws IOException {
-    rewriteHelper(srcFilenames, destFilenames, false, false);
+    rewriteHelper(
+        srcFilenames,
+        destFilenames,
+        /*deleteSource=*/ false,
+        /*ignoreMissingSource=*/ false,
+        /*ignoreExistingDest=*/ false);
   }
 
   public void rename(
@@ -804,17 +809,22 @@ public class GcsUtil {
     Set<MoveOptions> moveOptionSet = Sets.newHashSet(moveOptions);
     final boolean ignoreMissingSrc =
         moveOptionSet.contains(StandardMoveOptions.IGNORE_MISSING_FILES);
-    rewriteHelper(srcFilenames, destFilenames, true, ignoreMissingSrc);
+    final boolean ignoreExistingDest =
+        moveOptionSet.contains(StandardMoveOptions.SKIP_IF_DESTINATION_EXISTS);
+    rewriteHelper(
+        srcFilenames, destFilenames, /*deleteSource=*/ true, ignoreMissingSrc, ignoreExistingDest);
   }
 
   private void rewriteHelper(
       Iterable<String> srcFilenames,
       Iterable<String> destFilenames,
       boolean deleteSource,
-      boolean ignoreMissingSource)
+      boolean ignoreMissingSource,
+      boolean ignoreExistingDest)
       throws IOException {
     LinkedList<RewriteOp> rewrites =
-        makeRewriteOps(srcFilenames, destFilenames, deleteSource, ignoreMissingSource);
+        makeRewriteOps(
+            srcFilenames, destFilenames, deleteSource, ignoreMissingSource, ignoreExistingDest);
     org.apache.beam.sdk.util.BackOff backoff = BACKOFF_FACTORY.backoff();
     while (true) {
       List<BatchInterface> batches = makeRewriteBatches(rewrites); // Removes completed rewrite ops.
@@ -858,7 +868,8 @@ public class GcsUtil {
       Iterable<String> srcFilenames,
       Iterable<String> destFilenames,
       boolean deleteSource,
-      boolean ignoreMissingSource)
+      boolean ignoreMissingSource,
+      boolean ignoreExistingDest)
       throws IOException {
     List<String> srcList = Lists.newArrayList(srcFilenames);
     List<String> destList = Lists.newArrayList(destFilenames);
@@ -871,6 +882,10 @@ public class GcsUtil {
     for (int i = 0; i < srcList.size(); i++) {
       final GcsPath sourcePath = GcsPath.fromUri(srcList.get(i));
       final GcsPath destPath = GcsPath.fromUri(destList.get(i));
+      if (ignoreExistingDest && !sourcePath.getBucket().equals(destPath.getBucket())) {
+        throw new UnsupportedOperationException(
+            "Skipping dest existence is only supported within a bucket.");
+      }
       rewrites.addLast(new RewriteOp(sourcePath, destPath, deleteSource, ignoreMissingSource));
     }
     return rewrites;
diff --git a/sdks/java/extensions/google-cloud-platform-core/src/test/java/org/apache/beam/sdk/extensions/gcp/util/GcsUtilTest.java b/sdks/java/extensions/google-cloud-platform-core/src/test/java/org/apache/beam/sdk/extensions/gcp/util/GcsUtilTest.java
index 2890e72da26..0c4df7a2519 100644
--- a/sdks/java/extensions/google-cloud-platform-core/src/test/java/org/apache/beam/sdk/extensions/gcp/util/GcsUtilTest.java
+++ b/sdks/java/extensions/google-cloud-platform-core/src/test/java/org/apache/beam/sdk/extensions/gcp/util/GcsUtilTest.java
@@ -850,7 +850,7 @@ public class GcsUtilTest {
     GcsUtil gcsUtil = gcsOptions.getGcsUtil();
 
     LinkedList<RewriteOp> rewrites =
-        gcsUtil.makeRewriteOps(makeStrings("s", 1), makeStrings("d", 1), false, false);
+        gcsUtil.makeRewriteOps(makeStrings("s", 1), makeStrings("d", 1), false, false, false);
     assertEquals(1, rewrites.size());
 
     RewriteOp rewrite = rewrites.pop();
@@ -870,7 +870,7 @@ public class GcsUtilTest {
     gcsUtil.maxBytesRewrittenPerCall = 1337L;
 
     LinkedList<RewriteOp> rewrites =
-        gcsUtil.makeRewriteOps(makeStrings("s", 1), makeStrings("d", 1), false, false);
+        gcsUtil.makeRewriteOps(makeStrings("s", 1), makeStrings("d", 1), false, false, false);
     assertEquals(1, rewrites.size());
 
     RewriteOp rewrite = rewrites.pop();
@@ -886,21 +886,23 @@ public class GcsUtilTest {
     // Small number of files fits in 1 batch
     List<BatchInterface> batches =
         gcsUtil.makeRewriteBatches(
-            gcsUtil.makeRewriteOps(makeStrings("s", 3), makeStrings("d", 3), false, false));
+            gcsUtil.makeRewriteOps(makeStrings("s", 3), makeStrings("d", 3), false, false, false));
     assertThat(batches.size(), equalTo(1));
     assertThat(sumBatchSizes(batches), equalTo(3));
 
     // 1 batch of files fits in 1 batch
     batches =
         gcsUtil.makeRewriteBatches(
-            gcsUtil.makeRewriteOps(makeStrings("s", 100), makeStrings("d", 100), false, false));
+            gcsUtil.makeRewriteOps(
+                makeStrings("s", 100), makeStrings("d", 100), false, false, false));
     assertThat(batches.size(), equalTo(1));
     assertThat(sumBatchSizes(batches), equalTo(100));
 
     // A little more than 5 batches of files fits in 6 batches
     batches =
         gcsUtil.makeRewriteBatches(
-            gcsUtil.makeRewriteOps(makeStrings("s", 501), makeStrings("d", 501), false, false));
+            gcsUtil.makeRewriteOps(
+                makeStrings("s", 501), makeStrings("d", 501), false, false, false));
     assertThat(batches.size(), equalTo(6));
     assertThat(sumBatchSizes(batches), equalTo(501));
   }
@@ -911,7 +913,7 @@ public class GcsUtilTest {
     thrown.expect(IllegalArgumentException.class);
     thrown.expectMessage("Number of source files 3");
 
-    gcsUtil.makeRewriteOps(makeStrings("s", 3), makeStrings("d", 1), false, false);
+    gcsUtil.makeRewriteOps(makeStrings("s", 3), makeStrings("d", 1), false, false, false);
   }
 
   private class FakeBatcher implements BatchInterface {
@@ -1049,6 +1051,48 @@ public class GcsUtilTest {
     verify(mockStorageRewrite, times(1)).execute();
   }
 
+  @Test
+  public void testRenameSkipDestinationExistsSameBucket() throws IOException {
+    GcsOptions pipelineOptions = gcsOptionsWithTestCredential();
+    GcsUtil gcsUtil = pipelineOptions.getGcsUtil();
+
+    Storage mockStorage = Mockito.mock(Storage.class);
+    gcsUtil.setStorageClient(mockStorage);
+    gcsUtil.setBatchRequestSupplier(() -> new FakeBatcher());
+
+    Storage.Objects mockStorageObjects = Mockito.mock(Storage.Objects.class);
+    Storage.Objects.Rewrite mockStorageRewrite = Mockito.mock(Storage.Objects.Rewrite.class);
+    Storage.Objects.Delete mockStorageDelete = Mockito.mock(Storage.Objects.Delete.class);
+
+    when(mockStorage.objects()).thenReturn(mockStorageObjects);
+    when(mockStorageObjects.rewrite("bucket", "s0", "bucket", "d0", null))
+        .thenReturn(mockStorageRewrite);
+    when(mockStorageRewrite.execute()).thenReturn(new RewriteResponse().setDone(true));
+    when(mockStorageObjects.delete("bucket", "s0")).thenReturn(mockStorageDelete);
+
+    gcsUtil.rename(
+        makeStrings("s", 1), makeStrings("d", 1), StandardMoveOptions.SKIP_IF_DESTINATION_EXISTS);
+    verify(mockStorageRewrite, times(1)).execute();
+    verify(mockStorageDelete, times(1)).execute();
+  }
+
+  @Test
+  public void testRenameSkipDestinationExistsDifferentBucket() throws IOException {
+    GcsOptions pipelineOptions = gcsOptionsWithTestCredential();
+    GcsUtil gcsUtil = pipelineOptions.getGcsUtil();
+
+    Storage mockStorage = Mockito.mock(Storage.class);
+    gcsUtil.setStorageClient(mockStorage);
+
+    assertThrows(
+        UnsupportedOperationException.class,
+        () ->
+            gcsUtil.rename(
+                Collections.singletonList("gs://bucket/source"),
+                Collections.singletonList("gs://different_bucket/dest"),
+                StandardMoveOptions.SKIP_IF_DESTINATION_EXISTS));
+  }
+
   @Test
   public void testMakeRemoveBatches() throws IOException {
     GcsUtil gcsUtil = gcsOptionsWithTestCredential().getGcsUtil();
