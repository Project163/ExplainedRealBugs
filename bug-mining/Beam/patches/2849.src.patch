diff --git a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/KinesisReader.java b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/KinesisReader.java
index 651601ca36c..da9c971ec12 100644
--- a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/KinesisReader.java
+++ b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/KinesisReader.java
@@ -117,7 +117,15 @@ class KinesisReader extends UnboundedSource.UnboundedReader<KinesisRecord> {
 
   @Override
   public void close() throws IOException {
-    shardReadersPool.stop();
+    try {
+      try (AutoCloseable c = kinesis) {
+        shardReadersPool.stop();
+      }
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new IOException(e);
+    }
   }
 
   @Override
diff --git a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/KinesisSource.java b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/KinesisSource.java
index 2efa98420d7..9a0fec6eab3 100644
--- a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/KinesisSource.java
+++ b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/KinesisSource.java
@@ -17,19 +17,19 @@
  */
 package org.apache.beam.sdk.io.aws2.kinesis;
 
+import static org.apache.beam.sdk.io.aws2.common.ClientBuilderFactory.buildClient;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists.newArrayList;
 
 import java.util.List;
+import java.util.function.Supplier;
 import org.apache.beam.sdk.coders.Coder;
 import org.apache.beam.sdk.coders.SerializableCoder;
 import org.apache.beam.sdk.io.UnboundedSource;
-import org.apache.beam.sdk.io.aws2.common.ClientBuilderFactory;
 import org.apache.beam.sdk.io.aws2.common.ClientConfiguration;
 import org.apache.beam.sdk.io.aws2.kinesis.KinesisIO.Read;
 import org.apache.beam.sdk.io.aws2.options.AwsOptions;
 import org.apache.beam.sdk.options.PipelineOptions;
-import org.joda.time.Instant;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import software.amazon.awssdk.services.cloudwatch.CloudWatchClient;
@@ -57,18 +57,18 @@ class KinesisSource extends UnboundedSource<KinesisRecord, KinesisReaderCheckpoi
 
   private SimplifiedKinesisClient createClient(PipelineOptions options) {
     AwsOptions awsOptions = options.as(AwsOptions.class);
-    KinesisClient kinesis;
-    CloudWatchClient cloudWatch;
+    Supplier<KinesisClient> kinesisSupplier;
+    Supplier<CloudWatchClient> cloudWatchSupplier;
     if (spec.getAWSClientsProvider() != null) {
-      kinesis = spec.getAWSClientsProvider().getKinesisClient();
-      cloudWatch = spec.getAWSClientsProvider().getCloudWatchClient();
+      kinesisSupplier = spec.getAWSClientsProvider()::getKinesisClient;
+      cloudWatchSupplier = spec.getAWSClientsProvider()::getCloudWatchClient;
     } else {
       ClientConfiguration config = spec.getClientConfiguration();
-      kinesis = ClientBuilderFactory.buildClient(awsOptions, KinesisClient.builder(), config);
-      cloudWatch = ClientBuilderFactory.buildClient(awsOptions, CloudWatchClient.builder(), config);
+      kinesisSupplier = () -> buildClient(awsOptions, KinesisClient.builder(), config);
+      cloudWatchSupplier = () -> buildClient(awsOptions, CloudWatchClient.builder(), config);
     }
     return new SimplifiedKinesisClient(
-        kinesis, cloudWatch, spec.getRequestRecordsLimit(), Instant::now);
+        kinesisSupplier, cloudWatchSupplier, spec.getRequestRecordsLimit());
   }
 
   /**
@@ -77,12 +77,14 @@ class KinesisSource extends UnboundedSource<KinesisRecord, KinesisReaderCheckpoi
    */
   @Override
   public List<KinesisSource> split(int desiredNumSplits, PipelineOptions options) throws Exception {
-    KinesisReaderCheckpoint checkpoint = checkpointGenerator.generate(createClient(options));
-    List<KinesisSource> sources = newArrayList();
-    for (KinesisReaderCheckpoint partition : checkpoint.splitInto(desiredNumSplits)) {
-      sources.add(new KinesisSource(spec, new StaticCheckpointGenerator(partition)));
+    try (SimplifiedKinesisClient client = createClient(options)) {
+      KinesisReaderCheckpoint checkpoint = checkpointGenerator.generate(client);
+      List<KinesisSource> sources = newArrayList();
+      for (KinesisReaderCheckpoint partition : checkpoint.splitInto(desiredNumSplits)) {
+        sources.add(new KinesisSource(spec, new StaticCheckpointGenerator(partition)));
+      }
+      return sources;
     }
-    return sources;
   }
 
   /**
diff --git a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/SimplifiedKinesisClient.java b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/SimplifiedKinesisClient.java
index 04f324ef3b0..1351796896d 100644
--- a/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/SimplifiedKinesisClient.java
+++ b/sdks/java/io/amazon-web-services2/src/main/java/org/apache/beam/sdk/io/aws2/kinesis/SimplifiedKinesisClient.java
@@ -64,7 +64,7 @@ import software.amazon.kinesis.retrieval.KinesisClientRecord;
 @SuppressWarnings({
   "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
 })
-class SimplifiedKinesisClient {
+class SimplifiedKinesisClient implements AutoCloseable {
 
   private static final String KINESIS_NAMESPACE = "AWS/Kinesis";
   private static final String INCOMING_RECORDS_METRIC = "IncomingBytes";
@@ -78,20 +78,17 @@ class SimplifiedKinesisClient {
   private static final Duration DESCRIBE_STREAM_SUMMARY_INITIAL_BACKOFF =
       Duration.standardSeconds(1);
 
-  private final KinesisClient kinesis;
-  private final CloudWatchClient cloudWatch;
+  private final LazyResource<KinesisClient> kinesis;
+  private final LazyResource<CloudWatchClient> cloudWatch;
   private final Integer limit;
-  private final Supplier<Instant> currentInstantSupplier;
 
   SimplifiedKinesisClient(
-      KinesisClient kinesis,
-      CloudWatchClient cloudWatch,
-      Integer limit,
-      Supplier<Instant> currentInstantSupplier) {
-    this.kinesis = checkNotNull(kinesis, "kinesis");
-    this.cloudWatch = checkNotNull(cloudWatch, "cloudWatch");
+      Supplier<KinesisClient> kinesisSupplier,
+      Supplier<CloudWatchClient> cloudWatchSupplier,
+      Integer limit) {
+    this.kinesis = new LazyResource<>(checkNotNull(kinesisSupplier, "kinesis"));
+    this.cloudWatch = new LazyResource<>(checkNotNull(cloudWatchSupplier, "cloudWatch"));
     this.limit = limit;
-    this.currentInstantSupplier = currentInstantSupplier;
   }
 
   public String getShardIterator(
@@ -104,6 +101,7 @@ class SimplifiedKinesisClient {
     return wrapExceptions(
         () ->
             kinesis
+                .get()
                 .getShardIterator(
                     GetShardIteratorRequest.builder()
                         .streamName(streamName)
@@ -150,8 +148,7 @@ class SimplifiedKinesisClient {
     Duration retentionPeriod = Duration.standardHours(streamDescription.retentionPeriodHours());
 
     Instant streamTrimHorizonTimestamp =
-        currentInstantSupplier
-            .get()
+        Instant.now()
             .minus(retentionPeriod)
             .plus(SPACING_FOR_TIMESTAMP_LIST_SHARDS_REQUEST_TO_NOT_EXCEED_TRIM_HORIZON);
     if (startingPointTimestamp.isAfter(streamTrimHorizonTimestamp)) {
@@ -183,7 +180,7 @@ class SimplifiedKinesisClient {
         DescribeStreamSummaryRequest.builder().streamName(streamName).build();
     while (true) {
       try {
-        return kinesis.describeStreamSummary(request).streamDescriptionSummary();
+        return kinesis.get().describeStreamSummary(request).streamDescriptionSummary();
       } catch (LimitExceededException exc) {
         if (!BackOffUtils.next(sleeper, backoff)) {
           throw exc;
@@ -221,7 +218,7 @@ class SimplifiedKinesisClient {
               reqBuilder.streamName(streamName);
             }
 
-            ListShardsResponse response = kinesis.listShards(reqBuilder.build());
+            ListShardsResponse response = kinesis.get().listShards(reqBuilder.build());
             shardsBuilder.addAll(response.shards());
             currentNextToken = response.nextToken();
           } while (currentNextToken != null);
@@ -255,9 +252,9 @@ class SimplifiedKinesisClient {
       throws TransientKinesisException {
     return wrapExceptions(
         () -> {
-          GetRecordsResponse response =
-              kinesis.getRecords(
-                  GetRecordsRequest.builder().shardIterator(shardIterator).limit(limit).build());
+          GetRecordsRequest request =
+              GetRecordsRequest.builder().shardIterator(shardIterator).limit(limit).build();
+          GetRecordsResponse response = kinesis.get().getRecords(request);
           List<Record> records = response.records();
           return new GetKinesisRecordsResult(
               deaggregate(records),
@@ -306,7 +303,7 @@ class SimplifiedKinesisClient {
               createMetricStatisticsRequest(streamName, countSince, countTo, period);
 
           long totalSizeInBytes = 0;
-          GetMetricStatisticsResponse response = cloudWatch.getMetricStatistics(request);
+          GetMetricStatisticsResponse response = cloudWatch.get().getMetricStatistics(request);
           for (Datapoint point : response.datapoints()) {
             totalSizeInBytes += point.sum().longValue();
           }
@@ -354,4 +351,44 @@ class SimplifiedKinesisClient {
       throw new RuntimeException("Unknown kinesis failure, when trying to reach kinesis", e);
     }
   }
+
+  @Override
+  public void close() throws Exception {
+    try (AutoCloseable c1 = kinesis;
+        AutoCloseable c2 = cloudWatch) {
+      // nothing to do
+    }
+  }
+
+  /** Memoizing supplier that closes resources appropriately. */
+  private static class LazyResource<T extends AutoCloseable> implements Supplier<T>, AutoCloseable {
+    private final Supplier<T> initializer;
+    private volatile T resource = null;
+
+    private LazyResource(Supplier<T> initializer) {
+      this.initializer = initializer;
+    }
+
+    @Override
+    public void close() throws Exception {
+      T res = resource;
+      if (res != null) {
+        res.close();
+      }
+    }
+
+    @Override
+    public T get() {
+      T res = resource;
+      if (res == null) {
+        synchronized (this) {
+          res = resource; // need to read again in synchronized
+          if (res == null) {
+            resource = res = initializer.get();
+          }
+        }
+      }
+      return res;
+    }
+  }
 }
diff --git a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/kinesis/SimplifiedKinesisClientTest.java b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/kinesis/SimplifiedKinesisClientTest.java
index e3a7b5b5bad..f4b8a6deea0 100644
--- a/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/kinesis/SimplifiedKinesisClientTest.java
+++ b/sdks/java/io/amazon-web-services2/src/test/java/org/apache/beam/sdk/io/aws2/kinesis/SimplifiedKinesisClientTest.java
@@ -22,20 +22,22 @@ import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
 import static org.mockito.Mockito.when;
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.function.Supplier;
+import org.joda.time.DateTimeUtils;
 import org.joda.time.Duration;
 import org.joda.time.Instant;
 import org.joda.time.Minutes;
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockito.stubbing.Answer;
@@ -80,8 +82,17 @@ public class SimplifiedKinesisClientTest {
 
   @Mock private KinesisClient kinesis;
   @Mock private CloudWatchClient cloudWatch;
-  @Mock private Supplier<Instant> currentInstantSupplier;
-  @InjectMocks private SimplifiedKinesisClient underTest;
+  private SimplifiedKinesisClient underTest;
+
+  @Before
+  public void init() {
+    underTest = new SimplifiedKinesisClient(() -> kinesis, () -> cloudWatch, null);
+  }
+
+  @After
+  public void afterEach() {
+    DateTimeUtils.setCurrentMillisSystem();
+  }
 
   @Test
   public void shouldReturnIteratorStartingWithSequenceNumber() throws Exception {
@@ -99,6 +110,9 @@ public class SimplifiedKinesisClientTest {
             STREAM, SHARD_1, ShardIteratorType.AT_SEQUENCE_NUMBER, SEQUENCE_NUMBER, null);
 
     assertThat(stream).isEqualTo(SHARD_ITERATOR);
+
+    underTest.close();
+    verify(kinesis).close(); // cloudWatch not initialized / used
   }
 
   @Test
@@ -118,6 +132,9 @@ public class SimplifiedKinesisClientTest {
             STREAM, SHARD_1, ShardIteratorType.AT_SEQUENCE_NUMBER, null, timestamp);
 
     assertThat(stream).isEqualTo(SHARD_ITERATOR);
+
+    underTest.close();
+    verify(kinesis).close(); // cloudWatch not initialized / used
   }
 
   @Test
@@ -197,6 +214,9 @@ public class SimplifiedKinesisClientTest {
             STREAM, new StartingPoint(InitialPositionInStream.TRIM_HORIZON));
 
     assertThat(shards).containsOnly(shard1, shard2, shard3);
+
+    underTest.close();
+    verify(kinesis).close(); // cloudWatch not initialized / used
   }
 
   @Test
@@ -248,8 +268,7 @@ public class SimplifiedKinesisClientTest {
         CURRENT_TIMESTAMP.minus(Duration.standardHours(retentionPeriodHours));
     Instant startingPointTimestamp =
         streamCreationTimestamp.plus(Duration.standardHours(hoursDifference));
-
-    when(currentInstantSupplier.get()).thenReturn(CURRENT_TIMESTAMP);
+    DateTimeUtils.setCurrentMillisFixed(CURRENT_TIMESTAMP.getMillis());
 
     when(kinesis.describeStreamSummary(
             DescribeStreamSummaryRequest.builder().streamName(STREAM).build()))
@@ -298,8 +317,7 @@ public class SimplifiedKinesisClientTest {
     Instant startingPointTimestamp =
         streamCreationTimestamp.plus(Duration.standardHours(hoursDifference));
 
-    when(currentInstantSupplier.get()).thenReturn(CURRENT_TIMESTAMP);
-
+    DateTimeUtils.setCurrentMillisFixed(CURRENT_TIMESTAMP.getMillis());
     when(kinesis.describeStreamSummary(
             DescribeStreamSummaryRequest.builder().streamName(STREAM).build()))
         .thenThrow(
@@ -349,8 +367,7 @@ public class SimplifiedKinesisClientTest {
         CURRENT_TIMESTAMP.minus(Duration.standardHours(hoursSinceStreamCreation));
     Instant startingPointTimestampAfterStreamRetentionTimestamp =
         CURRENT_TIMESTAMP.minus(Duration.standardHours(startingPointHours));
-
-    when(currentInstantSupplier.get()).thenReturn(CURRENT_TIMESTAMP);
+    DateTimeUtils.setCurrentMillisFixed(CURRENT_TIMESTAMP.getMillis());
 
     DescribeStreamSummaryRequest describeStreamRequest =
         DescribeStreamSummaryRequest.builder().streamName(STREAM).build();
@@ -531,6 +548,9 @@ public class SimplifiedKinesisClientTest {
     long backlogBytes = underTest.getBacklogBytes(STREAM, countSince, countTo);
 
     assertThat(backlogBytes).isEqualTo(1L);
+
+    underTest.close();
+    verify(cloudWatch).close(); // kinesis not initialized / used
   }
 
   @Test
@@ -563,7 +583,7 @@ public class SimplifiedKinesisClientTest {
     long backlogBytes = underTest.getBacklogBytes(STREAM, countSince, countTo);
 
     assertThat(backlogBytes).isEqualTo(0L);
-    verifyZeroInteractions(cloudWatch);
+    verifyNoInteractions(cloudWatch);
   }
 
   @Test
@@ -633,6 +653,9 @@ public class SimplifiedKinesisClientTest {
 
     GetKinesisRecordsResult result = underTest.getRecords(SHARD_ITERATOR, STREAM, SHARD_1, limit);
     assertThat(result.getRecords().size()).isEqualTo(limit);
+
+    underTest.close();
+    verify(kinesis).close(); // cloudWatch not initialized / used
   }
 
   private List<Record> generateRecords(int num) {
