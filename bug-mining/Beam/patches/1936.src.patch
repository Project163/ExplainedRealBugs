diff --git a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/EvaluationContext.java b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/EvaluationContext.java
index 22e0a8a4add..dd2657f883d 100644
--- a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/EvaluationContext.java
+++ b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/EvaluationContext.java
@@ -20,6 +20,7 @@ package org.apache.beam.runners.direct;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;
 
 import java.util.Collection;
+import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
@@ -140,7 +141,6 @@ class EvaluationContext {
    *     null} if the transform that produced the result is a root transform
    * @param completedTimers the timers that were delivered to produce the {@code completedBundle},
    *     or an empty iterable if no timers were delivered
-   * @param pushedBackTimers timers that have been pushed back during processing
    * @param result the result of evaluating the input bundle
    * @return the committed bundles contained within the handled {@code result}
    */
@@ -148,6 +148,7 @@ class EvaluationContext {
       CommittedBundle<?> completedBundle,
       Iterable<TimerData> completedTimers,
       TransformResult<?> result) {
+
     Iterable<? extends CommittedBundle<?>> committedBundles =
         commitBundles(result.getOutputBundles());
     metrics.commitLogical(completedBundle, result.getLogicalMetricUpdates());
@@ -368,15 +369,23 @@ class EvaluationContext {
     fireAllAvailableCallbacks();
   }
 
+  @VisibleForTesting
+  Collection<FiredTimers<AppliedPTransform<?, ?, ?>>> extractFiredTimers() {
+    return extractFiredTimers(Collections.emptyList());
+  }
+
   /**
-   * Extracts all timers that have been fired and have not already been extracted.
+   * Extracts all timers that have been fired and have not already been extracted. Do not extract
+   * timers for given ignored transforms.
    *
-   * <p>This is a destructive operation. Timers will only appear in the result of this method once
-   * for each time they are set.
+   * @param ignoredTransforms transforms that must be ignored and timers not extracted for them
+   *     <p>This is a destructive operation. Timers will only appear in the result of this method
+   *     once for each time they are set.
    */
-  Collection<FiredTimers<AppliedPTransform<?, ?, ?>>> extractFiredTimers() {
+  Collection<FiredTimers<AppliedPTransform<?, ?, ?>>> extractFiredTimers(
+      Collection<AppliedPTransform<?, ?, ?>> ignoredTransforms) {
     forceRefresh();
-    return watermarkManager.extractFiredTimers();
+    return watermarkManager.extractFiredTimers(ignoredTransforms);
   }
 
   /** Returns true if the step will not produce additional output. */
diff --git a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/QuiescenceDriver.java b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/QuiescenceDriver.java
index cbd2eeb1f9e..de13435b6b3 100644
--- a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/QuiescenceDriver.java
+++ b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/QuiescenceDriver.java
@@ -24,6 +24,7 @@ import java.util.Collections;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
@@ -70,6 +71,12 @@ class QuiescenceDriver implements ExecutionDriver {
   private final Map<AppliedPTransform<?, ?, ?>, ConcurrentLinkedQueue<CommittedBundle<?>>>
       pendingRootBundles;
   private final Queue<WorkUpdate> pendingWork = new ConcurrentLinkedQueue<>();
+  // We collect here bundles and AppliedPTransforms that have started to process bundle, but have
+  // not completed it yet. The reason for that is that the bundle processing might change output
+  // watermark of a PTransform before enqueuing the resulting bundle to pendingUpdates of downstream
+  // PTransform, which can lead to watermark being updated past the emitted elements.
+  private final Map<AppliedPTransform<?, ?, ?>, Collection<CommittedBundle<?>>> inflightBundles =
+      new ConcurrentHashMap<>();
 
   private final AtomicReference<ExecutorState> state =
       new AtomicReference<>(ExecutorState.QUIESCENT);
@@ -137,8 +144,7 @@ class QuiescenceDriver implements ExecutionDriver {
           || (ExecutorState.PROCESSING == startingState && noWorkOutstanding)) {
         CommittedBundle<?> bundle = update.getBundle().get();
         for (AppliedPTransform<?, ?, ?> consumer : update.getConsumers()) {
-          outstandingWork.incrementAndGet();
-          bundleProcessor.process(bundle, consumer, defaultCompletionCallback);
+          processBundle(bundle, consumer);
         }
       } else {
         pendingWork.offer(update);
@@ -149,11 +155,30 @@ class QuiescenceDriver implements ExecutionDriver {
     }
   }
 
+  private void processBundle(CommittedBundle<?> bundle, AppliedPTransform<?, ?, ?> consumer) {
+    processBundle(bundle, consumer, defaultCompletionCallback);
+  }
+
+  private void processBundle(
+      CommittedBundle<?> bundle, AppliedPTransform<?, ?, ?> consumer, CompletionCallback callback) {
+    inflightBundles.compute(
+        consumer,
+        (k, v) -> {
+          if (v == null) {
+            v = new ArrayList<>();
+          }
+          v.add(bundle);
+          return v;
+        });
+    outstandingWork.incrementAndGet();
+    bundleProcessor.process(bundle, consumer, callback);
+  }
+
   /** Fires any available timers. */
   private void fireTimers() {
     try {
       for (FiredTimers<AppliedPTransform<?, ?, ?>> transformTimers :
-          evaluationContext.extractFiredTimers()) {
+          evaluationContext.extractFiredTimers(inflightBundles.keySet())) {
         Collection<TimerData> delivery = transformTimers.getTimers();
         KeyedWorkItem<?, Object> work =
             KeyedWorkItems.timersWorkItem(transformTimers.getKey().getKey(), delivery);
@@ -167,8 +192,7 @@ class QuiescenceDriver implements ExecutionDriver {
                             transformTimers.getExecutable().getMainInputs().values()))
                 .add(WindowedValue.valueInGlobalWindow(work))
                 .commit(evaluationContext.now());
-        outstandingWork.incrementAndGet();
-        bundleProcessor.process(
+        processBundle(
             bundle, transformTimers.getExecutable(), new TimerIterableCompletionCallback(delivery));
         state.set(ExecutorState.ACTIVE);
       }
@@ -198,8 +222,7 @@ class QuiescenceDriver implements ExecutionDriver {
           bundles.add(bundle);
         }
         for (CommittedBundle<?> bundle : bundles) {
-          outstandingWork.incrementAndGet();
-          bundleProcessor.process(bundle, pendingRootEntry.getKey(), defaultCompletionCallback);
+          processBundle(bundle, pendingRootEntry.getKey());
           state.set(ExecutorState.ACTIVE);
         }
       }
@@ -283,6 +306,12 @@ class QuiescenceDriver implements ExecutionDriver {
         state.set(ExecutorState.ACTIVE);
       }
       outstandingWork.decrementAndGet();
+      inflightBundles.compute(
+          result.getTransform(),
+          (k, v) -> {
+            v.remove(inputBundle);
+            return v.isEmpty() ? null : v;
+          });
       return committedResult;
     }
 
diff --git a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactory.java b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactory.java
index 47082760ae8..da7a7142a2c 100644
--- a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactory.java
+++ b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactory.java
@@ -270,11 +270,13 @@ final class StatefulParDoEvaluatorFactory<K, InputT, OutputT> implements Transfo
         delegateEvaluator.processElement(windowedValue);
       }
 
-      Instant currentInputWatermark = timerInternals.currentInputWatermarkTime();
+      final Instant inputWatermarkTime = timerInternals.currentInputWatermarkTime();
       PriorityQueue<TimerData> toBeFiredTimers =
           new PriorityQueue<>(Comparator.comparing(TimerData::getTimestamp));
       gbkResult.getValue().timersIterable().forEach(toBeFiredTimers::add);
-      while (!toBeFiredTimers.isEmpty()) {
+
+      while (!timerInternals.containsUpdateForTimeBefore(inputWatermarkTime)
+          && !toBeFiredTimers.isEmpty()) {
         TimerData timer = toBeFiredTimers.poll();
         checkState(
             timer.getNamespace() instanceof WindowNamespace,
@@ -291,10 +293,6 @@ final class StatefulParDoEvaluatorFactory<K, InputT, OutputT> implements Transfo
 
         stepContext.stateInternals().state(timer.getNamespace(), timerWatermarkHoldTag).clear();
         stepContext.stateInternals().commit();
-
-        if (timerInternals.containsUpdateForTimeBefore(currentInputWatermark)) {
-          break;
-        }
       }
       pushedBackTimers.addAll(toBeFiredTimers);
     }
diff --git a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java
index 3cc5180fcb7..9e3e235ead2 100644
--- a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java
+++ b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java
@@ -895,7 +895,8 @@ public class WatermarkManager<ExecutableT, CollectionT> {
   private final Map<ExecutableT, TransformWatermarks> transformToWatermarks;
 
   /** A queue of pending updates to the state of this {@link WatermarkManager}. */
-  private final ConcurrentLinkedQueue<PendingWatermarkUpdate> pendingUpdates;
+  private final ConcurrentLinkedQueue<PendingWatermarkUpdate<ExecutableT, CollectionT>>
+      pendingUpdates;
 
   /** A lock used to control concurrency for updating pending values. */
   private final Lock refreshLock;
@@ -1191,9 +1192,7 @@ public class WatermarkManager<ExecutableT, CollectionT> {
     // do not share a Mutex within this call and thus can be interleaved with external calls to
     // refresh.
     for (Bundle<?, ? extends CollectionT> bundle : outputs) {
-      for (ExecutableT consumer :
-          // TODO: Remove this cast once CommittedBundle returns a CollectionT
-          graph.getPerElementConsumers((CollectionT) bundle.getPCollection())) {
+      for (ExecutableT consumer : graph.getPerElementConsumers(bundle.getPCollection())) {
         TransformWatermarks watermarks = transformToWatermarks.get(consumer);
         watermarks.addPending(bundle);
       }
@@ -1222,6 +1221,7 @@ public class WatermarkManager<ExecutableT, CollectionT> {
       while (!toRefresh.isEmpty()) {
         toRefresh = refreshAllOf(toRefresh);
       }
+      pendingRefreshes.clear();
     } finally {
       refreshLock.unlock();
     }
@@ -1248,17 +1248,27 @@ public class WatermarkManager<ExecutableT, CollectionT> {
     return Collections.emptySet();
   }
 
+  @VisibleForTesting
+  Collection<FiredTimers<ExecutableT>> extractFiredTimers() {
+    return extractFiredTimers(Collections.emptyList());
+  }
+
   /**
    * Returns a map of each {@link PTransform} that has pending timers to those timers. All of the
    * pending timers will be removed from this {@link WatermarkManager}.
    */
-  public Collection<FiredTimers<ExecutableT>> extractFiredTimers() {
+  public Collection<FiredTimers<ExecutableT>> extractFiredTimers(
+      Collection<ExecutableT> ignoredExecutables) {
+
     Collection<FiredTimers<ExecutableT>> allTimers = new ArrayList<>();
     refreshLock.lock();
     try {
       for (Map.Entry<ExecutableT, TransformWatermarks> watermarksEntry :
           transformToWatermarks.entrySet()) {
         ExecutableT transform = watermarksEntry.getKey();
+        if (ignoredExecutables.contains(transform)) {
+          continue;
+        }
         if (!transformsWithAlreadyExtractedTimers.containsKey(transform)) {
           TransformWatermarks watermarks = watermarksEntry.getValue();
           Collection<FiredTimers<ExecutableT>> firedTimers = watermarks.extractFiredTimers();
