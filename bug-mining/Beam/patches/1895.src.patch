diff --git a/sdks/python/apache_beam/runners/worker/bundle_processor.py b/sdks/python/apache_beam/runners/worker/bundle_processor.py
index 8358cc6d0de..5e005993b66 100644
--- a/sdks/python/apache_beam/runners/worker/bundle_processor.py
+++ b/sdks/python/apache_beam/runners/worker/bundle_processor.py
@@ -332,7 +332,6 @@ class _StateBackedIterable(object):
                state_handler,  # type: sdk_worker.CachingStateHandler
                state_key,  # type: beam_fn_api_pb2.StateKey
                coder_or_impl,  # type: Union[coders.Coder, coder_impl.CoderImpl]
-               is_cached=False
               ):
     # type: (...) -> None
     self._state_handler = state_handler
@@ -341,13 +340,11 @@ class _StateBackedIterable(object):
       self._coder_impl = coder_or_impl.get_impl()
     else:
       self._coder_impl = coder_or_impl
-    self._is_cached = is_cached
 
   def __iter__(self):
     # type: () -> Iterator[Any]
     return iter(
-        self._state_handler.blocking_get(
-            self._state_key, self._coder_impl, is_cached=self._is_cached))
+        self._state_handler.blocking_get(self._state_key, self._coder_impl))
 
   def __reduce__(self):
     return list, (list(self), )
@@ -514,10 +511,7 @@ class SynchronousBagRuntimeState(userstate.BagRuntimeState):
     return _ConcatIterable([] if self._cleared else cast(
         'Iterable[Any]',
         _StateBackedIterable(
-            self._state_handler,
-            self._state_key,
-            self._value_coder,
-            is_cached=True)),
+            self._state_handler, self._state_key, self._value_coder)),
                            self._added_elements)
 
   def add(self, value):
@@ -532,13 +526,10 @@ class SynchronousBagRuntimeState(userstate.BagRuntimeState):
   def commit(self):
     to_await = None
     if self._cleared:
-      to_await = self._state_handler.clear(self._state_key, is_cached=True)
+      to_await = self._state_handler.clear(self._state_key)
     if self._added_elements:
       to_await = self._state_handler.extend(
-          self._state_key,
-          self._value_coder.get_impl(),
-          self._added_elements,
-          is_cached=True)
+          self._state_key, self._value_coder.get_impl(), self._added_elements)
     if to_await:
       # To commit, we need to wait on the last state request future to complete.
       to_await.get()
@@ -562,19 +553,13 @@ class SynchronousSetRuntimeState(userstate.SetRuntimeState):
     accumulator = set(
         _ConcatIterable(
             set() if self._cleared else _StateBackedIterable(
-                self._state_handler,
-                self._state_key,
-                self._value_coder,
-                is_cached=True),
+                self._state_handler, self._state_key, self._value_coder),
             self._added_elements))
 
     if rewrite and accumulator:
-      self._state_handler.clear(self._state_key, is_cached=True)
+      self._state_handler.clear(self._state_key)
       self._state_handler.extend(
-          self._state_key,
-          self._value_coder.get_impl(),
-          accumulator,
-          is_cached=True)
+          self._state_key, self._value_coder.get_impl(), accumulator)
 
       # Since everthing is already committed so we can safely reinitialize
       # added_elements here.
@@ -590,7 +575,7 @@ class SynchronousSetRuntimeState(userstate.SetRuntimeState):
     # type: (Any) -> None
     if self._cleared:
       # This is a good time explicitly clear.
-      self._state_handler.clear(self._state_key, is_cached=True)
+      self._state_handler.clear(self._state_key)
       self._cleared = False
 
     self._added_elements.add(value)
@@ -606,13 +591,10 @@ class SynchronousSetRuntimeState(userstate.SetRuntimeState):
     # type: () -> None
     to_await = None
     if self._cleared:
-      to_await = self._state_handler.clear(self._state_key, is_cached=True)
+      to_await = self._state_handler.clear(self._state_key)
     if self._added_elements:
       to_await = self._state_handler.extend(
-          self._state_key,
-          self._value_coder.get_impl(),
-          self._added_elements,
-          is_cached=True)
+          self._state_key, self._value_coder.get_impl(), self._added_elements)
     if to_await:
       # To commit, we need to wait on the last state request future to complete.
       to_await.get()
@@ -770,7 +752,6 @@ class FnApiUserStateContext(userstate.UserStateContext):
 
   def reset(self):
     # type: () -> None
-    # TODO(BEAM-5428): Implement cross-bundle state caching.
     self._all_states = {}
     self._timer_output_streams = {}
     self._timer_coders_impl = {}
diff --git a/sdks/python/apache_beam/runners/worker/sdk_worker.py b/sdks/python/apache_beam/runners/worker/sdk_worker.py
index 0adcb30ccd1..b22cf34f7c6 100644
--- a/sdks/python/apache_beam/runners/worker/sdk_worker.py
+++ b/sdks/python/apache_beam/runners/worker/sdk_worker.py
@@ -914,10 +914,9 @@ class CachingStateHandler(object):
   def blocking_get(self,
                    state_key,  # type: beam_fn_api_pb2.StateKey
                    coder,  # type: coder_impl.CoderImpl
-                   is_cached=False
                   ):
     # type: (...) -> Iterable[Any]
-    cache_token = self._get_cache_token(state_key, is_cached)
+    cache_token = self._get_cache_token(state_key)
     if not cache_token:
       # Cache disabled / no cache token. Can't do a lookup/store in the cache.
       # Fall back to lazily materializing the state, one element at a time.
@@ -945,10 +944,9 @@ class CachingStateHandler(object):
              state_key,  # type: beam_fn_api_pb2.StateKey
              coder,  # type: coder_impl.CoderImpl
              elements,  # type: Iterable[Any]
-             is_cached=False
             ):
     # type: (...) -> _Future
-    cache_token = self._get_cache_token(state_key, is_cached)
+    cache_token = self._get_cache_token(state_key)
     if cache_token:
       # Update the cache
       cache_key = self._convert_to_cache_key(state_key)
@@ -979,9 +977,9 @@ class CachingStateHandler(object):
       coder.encode_to_stream(element, out, True)
     return self._underlying.append_raw(state_key, out.get())
 
-  def clear(self, state_key, is_cached=False):
-    # type: (beam_fn_api_pb2.StateKey, bool) -> _Future
-    cache_token = self._get_cache_token(state_key, is_cached)
+  def clear(self, state_key):
+    # type: (beam_fn_api_pb2.StateKey) -> _Future
+    cache_token = self._get_cache_token(state_key)
     if cache_token:
       cache_key = self._convert_to_cache_key(state_key)
       self._state_cache.clear(cache_key, cache_token)
@@ -1011,11 +1009,11 @@ class CachingStateHandler(object):
       if not continuation_token:
         break
 
-  def _get_cache_token(self, state_key, request_is_cached):
+  def _get_cache_token(self, state_key):
     if not self._state_cache.is_cache_enabled():
       return None
     elif state_key.HasField('bag_user_state'):
-      if request_is_cached and self._context.user_state_cache_token:
+      if self._context.user_state_cache_token:
         return self._context.user_state_cache_token
       else:
         return self._context.bundle_cache_token
diff --git a/sdks/python/apache_beam/runners/worker/sdk_worker_test.py b/sdks/python/apache_beam/runners/worker/sdk_worker_test.py
index 9b17b207544..59baf15372a 100644
--- a/sdks/python/apache_beam/runners/worker/sdk_worker_test.py
+++ b/sdks/python/apache_beam/runners/worker/sdk_worker_test.py
@@ -176,7 +176,7 @@ class CachingStateHandlerTest(unittest.TestCase):
             transform_id='transform', side_input_id='side1'))
 
     def get_as_list(key):
-      return list(caching_state_hander.blocking_get(key, coder_impl, True))
+      return list(caching_state_hander.blocking_get(key, coder_impl))
 
     underlying_state.set_counter(100)
     with caching_state_hander.process_instruction_id('bundle1', []):
@@ -284,13 +284,13 @@ class CachingStateHandlerTest(unittest.TestCase):
         state_cache, underlying_state_handler)
 
     def get():
-      return handler.blocking_get(state, coder.get_impl(), True)
+      return handler.blocking_get(state, coder.get_impl())
 
     def append(iterable):
-      handler.extend(state, coder.get_impl(), iterable, True)
+      handler.extend(state, coder.get_impl(), iterable)
 
     def clear():
-      handler.clear(state, True)
+      handler.clear(state)
 
     # Initialize state
     underlying_state_handler.set_value(42, coder)
@@ -325,17 +325,17 @@ class CachingStateHandlerTest(unittest.TestCase):
         user_state=beam_fn_api_pb2.ProcessBundleRequest.CacheToken.UserState())
 
     def get(materialize=True):
-      result = handler.blocking_get(state, coder.get_impl(), True)
+      result = handler.blocking_get(state, coder.get_impl())
       return list(result) if materialize else result
 
     def get_type():
       return type(get(materialize=False))
 
     def append(*values):
-      handler.extend(state, coder.get_impl(), values, True)
+      handler.extend(state, coder.get_impl(), values)
 
     def clear():
-      handler.clear(state, True)
+      handler.clear(state)
 
     underlying_state_handler.set_continuations(True)
     underlying_state_handler.set_values([45, 46, 47], coder)
