diff --git a/sdks/go/pkg/beam/core/runtime/harness/datamgr.go b/sdks/go/pkg/beam/core/runtime/harness/datamgr.go
index 81e813e4f93..3fb9401dd01 100644
--- a/sdks/go/pkg/beam/core/runtime/harness/datamgr.go
+++ b/sdks/go/pkg/beam/core/runtime/harness/datamgr.go
@@ -266,18 +266,14 @@ func (c *DataChannel) read(ctx context.Context) {
 				cache[id] = r
 			}
 
-			if r.completed {
-				// The local reader has closed but the remote is still sending data.
-				// Just ignore it. We keep the reader config in the cache so we don't
-				// treat it as a new reader. Eventually the stream will finish and go
-				// through normal teardown.
-				continue
-			}
 			// TODO(BEAM-9558): Cleanup once dataflow is updated.
 			if len(elm.GetData()) == 0 || elm.GetIsLast() {
-				// Sentinel EOF segment for stream. Close buffer to signal EOF.
-				r.completed = true
-				close(r.buf)
+				// If this reader hasn't closed yet, do so now.
+				if !r.completed {
+					// Sentinel EOF segment for stream. Close buffer to signal EOF.
+					r.completed = true
+					close(r.buf)
+				}
 
 				// Clean up local bookkeeping. We'll never see another message
 				// for it again. We have to be careful not to remove the real
@@ -287,6 +283,14 @@ func (c *DataChannel) read(ctx context.Context) {
 				continue
 			}
 
+			if r.completed {
+				// The local reader has closed but the remote is still sending data.
+				// Just ignore it. We keep the reader config in the cache so we don't
+				// treat it as a new reader. Eventually the stream will finish and go
+				// through normal teardown.
+				continue
+			}
+
 			// This send is deliberately blocking, if we exceed the buffering for
 			// a reader. We can't buffer the entire main input, if some user code
 			// is slow (or gets stuck). If the local side closes, the reader
