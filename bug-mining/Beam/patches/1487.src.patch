diff --git a/runners/core-java/src/test/java/org/apache/beam/runners/core/metrics/MetricsPusherTest.java b/runners/core-java/src/test/java/org/apache/beam/runners/core/metrics/MetricsPusherTest.java
index 36d71c29d00..107059a181d 100644
--- a/runners/core-java/src/test/java/org/apache/beam/runners/core/metrics/MetricsPusherTest.java
+++ b/runners/core-java/src/test/java/org/apache/beam/runners/core/metrics/MetricsPusherTest.java
@@ -48,18 +48,35 @@ public class MetricsPusherTest {
   private static final Logger LOG = LoggerFactory.getLogger(MetricsPusherTest.class);
 
   private static final long NUM_ELEMENTS = 1000L;
+  private static final String COUNTER_NAME = "counter";
   @Rule public final TestPipeline pipeline = TestPipeline.create();
 
   @Before
   public void init() {
-    TestMetricsSink.clear();
     MetricsOptions options = pipeline.getOptions().as(MetricsOptions.class);
     options.setMetricsSink(TestMetricsSink.class);
   }
 
   @Category({ValidatesRunner.class, UsesAttemptedMetrics.class, UsesCounterMetrics.class})
   @Test
-  public void test() throws Exception {
+  public void pushesUserMetrics() throws Exception {
+    TestMetricsSink.clear();
+    pipeline
+        .apply(
+            // Use maxReadTime to force unbounded mode.
+            GenerateSequence.from(0).to(NUM_ELEMENTS).withMaxReadTime(Duration.standardDays(1)))
+        .apply(ParDo.of(new CountingDoFn()));
+    pipeline.run();
+    // give metrics pusher time to push
+    Thread.sleep(
+        (pipeline.getOptions().as(MetricsOptions.class).getMetricsPushPeriod() + 1L) * 1000);
+    assertThat(TestMetricsSink.getCounterValue(COUNTER_NAME), is(NUM_ELEMENTS));
+  }
+
+  @Category({ValidatesRunner.class, UsesAttemptedMetrics.class, UsesCounterMetrics.class})
+  @Test
+  public void pushesSystemMetrics() throws InterruptedException {
+    TestMetricsSink.clear();
     pipeline
         .apply(
             // Use maxReadTime to force unbounded mode.
@@ -69,11 +86,11 @@ public class MetricsPusherTest {
     // give metrics pusher time to push
     Thread.sleep(
         (pipeline.getOptions().as(MetricsOptions.class).getMetricsPushPeriod() + 1L) * 1000);
-    assertThat(TestMetricsSink.getCounterValue(), is(NUM_ELEMENTS));
+    assertThat(TestMetricsSink.getSystemCounters().isEmpty(), is(false));
   }
 
   private static class CountingDoFn extends DoFn<Long, Long> {
-    private final Counter counter = Metrics.counter(MetricsPusherTest.class, "counter");
+    private final Counter counter = Metrics.counter(MetricsPusherTest.class, COUNTER_NAME);
 
     @ProcessElement
     public void processElement(ProcessContext context) {
diff --git a/runners/core-java/src/test/java/org/apache/beam/runners/core/metrics/TestMetricsSink.java b/runners/core-java/src/test/java/org/apache/beam/runners/core/metrics/TestMetricsSink.java
index 0d24866fffe..29daa848cc3 100644
--- a/runners/core-java/src/test/java/org/apache/beam/runners/core/metrics/TestMetricsSink.java
+++ b/runners/core-java/src/test/java/org/apache/beam/runners/core/metrics/TestMetricsSink.java
@@ -17,7 +17,11 @@
  */
 package org.apache.beam.runners.core.metrics;
 
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
 import org.apache.beam.sdk.metrics.MetricQueryResults;
+import org.apache.beam.sdk.metrics.MetricResult;
 import org.apache.beam.sdk.metrics.MetricsOptions;
 import org.apache.beam.sdk.metrics.MetricsSink;
 
@@ -27,23 +31,34 @@ import org.apache.beam.sdk.metrics.MetricsSink;
  */
 public class TestMetricsSink implements MetricsSink {
 
-  private static long counterValue;
+  private static MetricQueryResults metricQueryResults;
+  private static final String SYSTEM_METRIC_PREFIX = "metric:";
 
   public TestMetricsSink(MetricsOptions pipelineOptions) {}
 
-  public static long getCounterValue() {
-    return counterValue;
+  public static long getCounterValue(String counterName) {
+    for (MetricResult<Long> metricResult : metricQueryResults.getCounters()) {
+      if (metricResult.getName().getName().equals(counterName)) {
+        return metricResult.getAttempted();
+      }
+    }
+    return 0L;
+  }
+
+  public static List<MetricResult<Long>> getSystemCounters() {
+    List<MetricResult<Long>> counters =
+        StreamSupport.stream(metricQueryResults.getCounters().spliterator(), false)
+            .filter(result -> result.getKey().metricName().getName().contains(SYSTEM_METRIC_PREFIX))
+            .collect(Collectors.toList());
+    return counters;
   }
 
   public static void clear() {
-    counterValue = 0L;
+    metricQueryResults = null;
   }
 
   @Override
-  public void writeMetrics(MetricQueryResults metricQueryResults) throws Exception {
-    counterValue =
-        metricQueryResults.getCounters().iterator().hasNext()
-            ? metricQueryResults.getCounters().iterator().next().getAttempted()
-            : 0L;
+  public void writeMetrics(MetricQueryResults metricQueryResult) throws Exception {
+    metricQueryResults = metricQueryResult;
   }
 }
diff --git a/runners/flink/job-server/flink_job_server.gradle b/runners/flink/job-server/flink_job_server.gradle
index 4e5b13ec989..f0cae9dc47d 100644
--- a/runners/flink/job-server/flink_job_server.gradle
+++ b/runners/flink/job-server/flink_job_server.gradle
@@ -139,12 +139,9 @@ def portableValidatesRunnerTask(String name, Boolean streaming) {
       includeCategories 'org.apache.beam.sdk.testing.ValidatesRunner'
       excludeCategories 'org.apache.beam.sdk.testing.FlattenWithHeterogeneousCoders'
       excludeCategories 'org.apache.beam.sdk.testing.LargeKeys$Above100MB'
-      excludeCategories 'org.apache.beam.sdk.testing.UsesAttemptedMetrics'
       excludeCategories 'org.apache.beam.sdk.testing.UsesCommittedMetrics'
-      excludeCategories 'org.apache.beam.sdk.testing.UsesCounterMetrics'
       excludeCategories 'org.apache.beam.sdk.testing.UsesCrossLanguageTransforms'
       excludeCategories 'org.apache.beam.sdk.testing.UsesCustomWindowMerging'
-      excludeCategories 'org.apache.beam.sdk.testing.UsesDistributionMetrics'
       excludeCategories 'org.apache.beam.sdk.testing.UsesFailureMessage'
       excludeCategories 'org.apache.beam.sdk.testing.UsesGaugeMetrics'
       excludeCategories 'org.apache.beam.sdk.testing.UsesParDoLifecycle'
diff --git a/runners/portability/java/src/main/java/org/apache/beam/runners/portability/JobServicePipelineResult.java b/runners/portability/java/src/main/java/org/apache/beam/runners/portability/JobServicePipelineResult.java
index d6dcfeb4fd9..9097712ace3 100644
--- a/runners/portability/java/src/main/java/org/apache/beam/runners/portability/JobServicePipelineResult.java
+++ b/runners/portability/java/src/main/java/org/apache/beam/runners/portability/JobServicePipelineResult.java
@@ -45,6 +45,7 @@ class JobServicePipelineResult implements PipelineResult, AutoCloseable {
   private final CloseableResource<JobServiceBlockingStub> jobService;
   @Nullable private State terminationState;
   @Nullable private final Runnable cleanup;
+  private org.apache.beam.model.jobmanagement.v1.JobApi.MetricResults jobMetrics;
 
   JobServicePipelineResult(
       ByteString jobId, CloseableResource<JobServiceBlockingStub> jobService, Runnable cleanup) {
@@ -121,12 +122,15 @@ class JobServicePipelineResult implements PipelineResult, AutoCloseable {
 
   @Override
   public MetricResults metrics() {
-    throw new UnsupportedOperationException("Not yet implemented.");
+    return PortableMetrics.of(jobMetrics);
   }
 
   @Override
   public void close() {
     try (CloseableResource<JobServiceBlockingStub> jobService = this.jobService) {
+      JobApi.GetJobMetricsRequest metricsRequest =
+          JobApi.GetJobMetricsRequest.newBuilder().setJobIdBytes(jobId).build();
+      jobMetrics = jobService.get().getJobMetrics(metricsRequest).getMetrics();
       if (cleanup != null) {
         cleanup.run();
       }
diff --git a/runners/portability/java/src/main/java/org/apache/beam/runners/portability/PortableMetrics.java b/runners/portability/java/src/main/java/org/apache/beam/runners/portability/PortableMetrics.java
new file mode 100644
index 00000000000..a96248690be
--- /dev/null
+++ b/runners/portability/java/src/main/java/org/apache/beam/runners/portability/PortableMetrics.java
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.portability;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+import org.apache.beam.model.jobmanagement.v1.JobApi;
+import org.apache.beam.model.pipeline.v1.MetricsApi;
+import org.apache.beam.sdk.metrics.DistributionResult;
+import org.apache.beam.sdk.metrics.GaugeResult;
+import org.apache.beam.sdk.metrics.MetricFiltering;
+import org.apache.beam.sdk.metrics.MetricKey;
+import org.apache.beam.sdk.metrics.MetricName;
+import org.apache.beam.sdk.metrics.MetricQueryResults;
+import org.apache.beam.sdk.metrics.MetricResult;
+import org.apache.beam.sdk.metrics.MetricResults;
+import org.apache.beam.sdk.metrics.MetricsFilter;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
+import org.joda.time.Instant;
+
+public class PortableMetrics extends MetricResults {
+
+  private static final List<String> COUNTER_METRIC_TYPES =
+      ImmutableList.of("beam:metrics:sum_int_64");
+  private static final List<String> DISTRIBUTION_METRIC_TYPES =
+      ImmutableList.of("beam:metrics:distribution_int_64");
+  private static final List<String> GAUGE_METRIC_TYPES =
+      ImmutableList.of("beam:metrics:latest_int_64");
+
+  private static final String NAMESPACE_LABEL = "NAMESPACE";
+  private static final String METRIC_NAME_LABEL = "NAME";
+  private static final String STEP_NAME_LABEL = "PTRANSFORM";
+  private Iterable<MetricResult<Long>> counters;
+  private Iterable<MetricResult<DistributionResult>> distributions;
+  private Iterable<MetricResult<GaugeResult>> gauges;
+
+  private PortableMetrics(
+      Iterable<MetricResult<Long>> counters,
+      Iterable<MetricResult<DistributionResult>> distributions,
+      Iterable<MetricResult<GaugeResult>> gauges) {
+    this.counters = counters;
+    this.distributions = distributions;
+    this.gauges = gauges;
+  }
+
+  public static PortableMetrics of(JobApi.MetricResults jobMetrics) {
+    return convertMonitoringInfosToMetricResults(jobMetrics);
+  }
+
+  @Override
+  public MetricQueryResults queryMetrics(MetricsFilter filter) {
+    return MetricQueryResults.create(
+        Iterables.filter(
+            this.counters, (counter) -> MetricFiltering.matches(filter, counter.getKey())),
+        Iterables.filter(
+            this.distributions,
+            (distribution) -> MetricFiltering.matches(filter, distribution.getKey())),
+        Iterables.filter(this.gauges, (gauge) -> MetricFiltering.matches(filter, gauge.getKey())));
+  }
+
+  private static PortableMetrics convertMonitoringInfosToMetricResults(
+      JobApi.MetricResults jobMetrics) {
+    List<MetricsApi.MonitoringInfo> monitoringInfoList = new ArrayList<>();
+    monitoringInfoList.addAll(jobMetrics.getAttemptedList());
+    monitoringInfoList.addAll(jobMetrics.getCommittedList());
+    Iterable<MetricResult<Long>> countersFromJobMetrics =
+        extractCountersFromJobMetrics(monitoringInfoList);
+    Iterable<MetricResult<DistributionResult>> distributionsFromMetrics =
+        extractDistributionMetricsFromJobMetrics(monitoringInfoList);
+    Iterable<MetricResult<GaugeResult>> gaugesFromMetrics =
+        extractGaugeMetricsFromJobMetrics(monitoringInfoList);
+    return new PortableMetrics(countersFromJobMetrics, distributionsFromMetrics, gaugesFromMetrics);
+  }
+
+  private static Iterable<MetricResult<DistributionResult>>
+      extractDistributionMetricsFromJobMetrics(List<MetricsApi.MonitoringInfo> monitoringInfoList) {
+    return monitoringInfoList.stream()
+        .filter(item -> DISTRIBUTION_METRIC_TYPES.contains(item.getType()))
+        .filter(item -> item.getLabelsMap().get(NAMESPACE_LABEL) != null)
+        .map(PortableMetrics::convertDistributionMonitoringInfoToDistribution)
+        .collect(Collectors.toList());
+  }
+
+  private static Iterable<MetricResult<GaugeResult>> extractGaugeMetricsFromJobMetrics(
+      List<MetricsApi.MonitoringInfo> monitoringInfoList) {
+    return monitoringInfoList.stream()
+        .filter(item -> GAUGE_METRIC_TYPES.contains(item.getType()))
+        .filter(item -> item.getLabelsMap().get(NAMESPACE_LABEL) != null)
+        .map(PortableMetrics::convertGaugeMonitoringInfoToGauge)
+        .collect(Collectors.toList());
+  }
+
+  private static MetricResult<GaugeResult> convertGaugeMonitoringInfoToGauge(
+      MetricsApi.MonitoringInfo monitoringInfo) {
+    Map<String, String> labelsMap = monitoringInfo.getLabelsMap();
+    MetricKey key =
+        MetricKey.create(
+            labelsMap.get(STEP_NAME_LABEL),
+            MetricName.named(labelsMap.get(NAMESPACE_LABEL), labelsMap.get(METRIC_NAME_LABEL)));
+    MetricsApi.IntExtremaData extremaData =
+        monitoringInfo.getMetric().getExtremaData().getIntExtremaData();
+    // Get only last value of the extrema table
+    Instant timestamp = Instant.ofEpochSecond(monitoringInfo.getTimestamp().getSeconds());
+    if (extremaData.getIntValuesCount() > 0) {
+      GaugeResult result =
+          GaugeResult.create(
+              extremaData.getIntValues(extremaData.getIntValuesCount() - 1), timestamp);
+      return MetricResult.create(key, false, result);
+    }
+    return null;
+  }
+
+  private static MetricResult<DistributionResult> convertDistributionMonitoringInfoToDistribution(
+      MetricsApi.MonitoringInfo monitoringInfo) {
+    Map<String, String> labelsMap = monitoringInfo.getLabelsMap();
+    MetricKey key =
+        MetricKey.create(
+            labelsMap.get(STEP_NAME_LABEL),
+            MetricName.named(labelsMap.get(NAMESPACE_LABEL), labelsMap.get(METRIC_NAME_LABEL)));
+    MetricsApi.IntDistributionData intDistributionData =
+        monitoringInfo.getMetric().getDistributionData().getIntDistributionData();
+    DistributionResult result =
+        DistributionResult.create(
+            intDistributionData.getSum(),
+            intDistributionData.getCount(),
+            intDistributionData.getMin(),
+            intDistributionData.getMax());
+    return MetricResult.create(key, false, result);
+  }
+
+  private static Iterable<MetricResult<Long>> extractCountersFromJobMetrics(
+      List<MetricsApi.MonitoringInfo> monitoringInfoList) {
+    return monitoringInfoList.stream()
+        .filter(item -> COUNTER_METRIC_TYPES.contains(item.getType()))
+        .filter(
+            item ->
+                item.getLabelsMap().get(NAMESPACE_LABEL) != null) // filter out pcollection metrics
+        .map(PortableMetrics::convertCounterMonitoringInfoToCounter)
+        .collect(Collectors.toList());
+  }
+
+  private static MetricResult<Long> convertCounterMonitoringInfoToCounter(
+      MetricsApi.MonitoringInfo counterMonInfo) {
+    Map<String, String> labelsMap = counterMonInfo.getLabelsMap();
+    MetricKey key =
+        MetricKey.create(
+            labelsMap.get(STEP_NAME_LABEL),
+            MetricName.named(labelsMap.get(NAMESPACE_LABEL), labelsMap.get(METRIC_NAME_LABEL)));
+    return MetricResult.create(
+        key, false, counterMonInfo.getMetric().getCounterData().getInt64Value());
+  }
+}
diff --git a/runners/portability/java/src/main/java/org/apache/beam/runners/portability/testing/TestJobService.java b/runners/portability/java/src/main/java/org/apache/beam/runners/portability/testing/TestJobService.java
index f816b7cfae0..f8d68991a89 100644
--- a/runners/portability/java/src/main/java/org/apache/beam/runners/portability/testing/TestJobService.java
+++ b/runners/portability/java/src/main/java/org/apache/beam/runners/portability/testing/TestJobService.java
@@ -17,6 +17,7 @@
  */
 package org.apache.beam.runners.portability.testing;
 
+import org.apache.beam.model.jobmanagement.v1.JobApi;
 import org.apache.beam.model.jobmanagement.v1.JobApi.GetJobStateRequest;
 import org.apache.beam.model.jobmanagement.v1.JobApi.GetJobStateResponse;
 import org.apache.beam.model.jobmanagement.v1.JobApi.JobState;
@@ -40,16 +41,19 @@ public class TestJobService extends JobServiceImplBase {
   private final String preparationId;
   private final String jobId;
   private final JobState.Enum jobState;
+  private JobApi.MetricResults metrics;
 
   public TestJobService(
       ApiServiceDescriptor stagingEndpoint,
       String preparationId,
       String jobId,
-      JobState.Enum jobState) {
+      JobState.Enum jobState,
+      JobApi.MetricResults metrics) {
     this.stagingEndpoint = stagingEndpoint;
     this.preparationId = preparationId;
     this.jobId = jobId;
     this.jobState = jobState;
+    this.metrics = metrics;
   }
 
   @Override
@@ -76,4 +80,12 @@ public class TestJobService extends JobServiceImplBase {
     responseObserver.onNext(GetJobStateResponse.newBuilder().setState(jobState).build());
     responseObserver.onCompleted();
   }
+
+  @Override
+  public void getJobMetrics(
+      JobApi.GetJobMetricsRequest request,
+      StreamObserver<JobApi.GetJobMetricsResponse> responseObserver) {
+    responseObserver.onNext(JobApi.GetJobMetricsResponse.newBuilder().setMetrics(metrics).build());
+    responseObserver.onCompleted();
+  }
 }
diff --git a/runners/portability/java/src/test/java/org/apache/beam/runners/portability/PortableRunnerTest.java b/runners/portability/java/src/test/java/org/apache/beam/runners/portability/PortableRunnerTest.java
index 332bf75fe08..40f7900a334 100644
--- a/runners/portability/java/src/test/java/org/apache/beam/runners/portability/PortableRunnerTest.java
+++ b/runners/portability/java/src/test/java/org/apache/beam/runners/portability/PortableRunnerTest.java
@@ -22,16 +22,23 @@ import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
 import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.beam.model.jobmanagement.v1.JobApi;
 import org.apache.beam.model.jobmanagement.v1.JobApi.JobState;
 import org.apache.beam.model.pipeline.v1.Endpoints.ApiServiceDescriptor;
+import org.apache.beam.model.pipeline.v1.MetricsApi;
 import org.apache.beam.runners.core.construction.InMemoryArtifactStagerService;
 import org.apache.beam.runners.portability.testing.TestJobService;
+import org.apache.beam.sdk.PipelineResult;
 import org.apache.beam.sdk.PipelineResult.State;
 import org.apache.beam.sdk.fn.test.InProcessManagedChannelFactory;
+import org.apache.beam.sdk.metrics.MetricQueryResults;
 import org.apache.beam.sdk.options.PipelineOptions;
 import org.apache.beam.sdk.options.PipelineOptionsFactory;
 import org.apache.beam.sdk.options.PortablePipelineOptions;
 import org.apache.beam.sdk.testing.TestPipeline;
+import org.apache.beam.vendor.grpc.v1p21p0.com.google.protobuf.Timestamp;
 import org.apache.beam.vendor.grpc.v1p21p0.io.grpc.Server;
 import org.apache.beam.vendor.grpc.v1p21p0.io.grpc.inprocess.InProcessServerBuilder;
 import org.junit.Rule;
@@ -46,6 +53,21 @@ public class PortableRunnerTest implements Serializable {
   private static final String ENDPOINT_URL = "foo:3000";
   private static final ApiServiceDescriptor ENDPOINT_DESCRIPTOR =
       ApiServiceDescriptor.newBuilder().setUrl(ENDPOINT_URL).build();
+  private static final String COUNTER_TYPE = "beam:metrics:sum_int_64";
+  private static final String DIST_TYPE = "beam:metrics:distribution_int_64";
+  private static final String GAUGE_TYPE = "beam:metrics:latest_int_64";
+  private static final String NAMESPACE_LABEL = "NAMESPACE";
+  private static final String METRIC_NAME_LABEL = "NAME";
+  private static final String STEP_NAME_LABEL = "PTRANSFORM";
+  private static final String NAMESPACE = "test";
+  private static final String METRIC_NAME = "testMetric";
+  private static final String STEP_NAME = "testStep";
+  private static final Long COUNTER_VALUE = 42L;
+  private static final Long GAUGE_VALUE = 64L;
+  private static final Long DIST_SUM = 1000L;
+  private static final Long DIST_MIN = 0L;
+  private static final Long DIST_MAX = 1000L;
+  private static final Long DIST_COUNT = 2L;
 
   private final PipelineOptions options = createPipelineOptions();
 
@@ -53,7 +75,8 @@ public class PortableRunnerTest implements Serializable {
 
   @Test
   public void stagesAndRunsJob() throws Exception {
-    try (CloseableResource<Server> server = createJobServer(JobState.Enum.DONE)) {
+    try (CloseableResource<Server> server =
+        createJobServer(JobState.Enum.DONE, JobApi.MetricResults.getDefaultInstance())) {
       PortableRunner runner =
           PortableRunner.create(options, InProcessManagedChannelFactory.create());
       State state = runner.run(p).waitUntilFinish();
@@ -61,12 +84,100 @@ public class PortableRunnerTest implements Serializable {
     }
   }
 
-  private static CloseableResource<Server> createJobServer(JobState.Enum jobState)
-      throws IOException {
+  @Test
+  public void extractsMetrics() throws Exception {
+    JobApi.MetricResults metricResults = generateMetricResults();
+    try (CloseableResource<Server> server = createJobServer(JobState.Enum.DONE, metricResults)) {
+      PortableRunner runner =
+          PortableRunner.create(options, InProcessManagedChannelFactory.create());
+      PipelineResult result = runner.run(p);
+      result.waitUntilFinish();
+      MetricQueryResults metricQueryResults = result.metrics().allMetrics();
+      assertThat(
+          metricQueryResults.getCounters().iterator().next().getAttempted(), is(COUNTER_VALUE));
+      assertThat(
+          metricQueryResults.getDistributions().iterator().next().getAttempted().getCount(),
+          is(DIST_COUNT));
+      assertThat(
+          metricQueryResults.getDistributions().iterator().next().getAttempted().getMax(),
+          is(DIST_MAX));
+      assertThat(
+          metricQueryResults.getDistributions().iterator().next().getAttempted().getMin(),
+          is(DIST_MIN));
+      assertThat(
+          metricQueryResults.getDistributions().iterator().next().getAttempted().getSum(),
+          is(DIST_SUM));
+      assertThat(
+          metricQueryResults.getGauges().iterator().next().getAttempted().getValue(),
+          is(GAUGE_VALUE));
+    }
+  }
+
+  private JobApi.MetricResults generateMetricResults() {
+    Map<String, String> labelMap = new HashMap<>();
+    labelMap.put(NAMESPACE_LABEL, NAMESPACE);
+    labelMap.put(METRIC_NAME_LABEL, METRIC_NAME);
+    labelMap.put(STEP_NAME_LABEL, STEP_NAME);
+
+    MetricsApi.CounterData counter =
+        MetricsApi.CounterData.newBuilder().setInt64Value(COUNTER_VALUE).build();
+    MetricsApi.Metric counterValue = MetricsApi.Metric.newBuilder().setCounterData(counter).build();
+    MetricsApi.MonitoringInfo counterMonitoringInfo =
+        MetricsApi.MonitoringInfo.newBuilder()
+            .setType(COUNTER_TYPE)
+            .putAllLabels(labelMap)
+            .setMetric(counterValue)
+            .build();
+
+    MetricsApi.IntDistributionData intDistributionData =
+        MetricsApi.IntDistributionData.newBuilder()
+            .setMax(DIST_MAX)
+            .setMin(DIST_MIN)
+            .setSum(DIST_SUM)
+            .setCount(DIST_COUNT)
+            .build();
+    MetricsApi.DistributionData distributionData =
+        MetricsApi.DistributionData.newBuilder()
+            .setIntDistributionData(intDistributionData)
+            .build();
+    MetricsApi.Metric distributionValue =
+        MetricsApi.Metric.newBuilder().setDistributionData(distributionData).build();
+    MetricsApi.MonitoringInfo distMonitoringInfo =
+        MetricsApi.MonitoringInfo.newBuilder()
+            .setType(DIST_TYPE)
+            .putAllLabels(labelMap)
+            .setMetric(distributionValue)
+            .build();
+
+    MetricsApi.IntExtremaData intExtremaData =
+        MetricsApi.IntExtremaData.newBuilder().addIntValues(GAUGE_VALUE).build();
+    MetricsApi.ExtremaData extremaData =
+        MetricsApi.ExtremaData.newBuilder().setIntExtremaData(intExtremaData).build();
+    MetricsApi.Metric gaugeValue =
+        MetricsApi.Metric.newBuilder().setExtremaData(extremaData).build();
+    MetricsApi.MonitoringInfo gaugeMonitoringInfo =
+        MetricsApi.MonitoringInfo.newBuilder()
+            .setType(GAUGE_TYPE)
+            .setTimestamp(Timestamp.getDefaultInstance())
+            .putAllLabels(labelMap)
+            .setMetric(gaugeValue)
+            .build();
+
+    return JobApi.MetricResults.newBuilder()
+        .addAttempted(counterMonitoringInfo)
+        .addAttempted(distMonitoringInfo)
+        .addAttempted(gaugeMonitoringInfo)
+        .build();
+  }
+
+  private static CloseableResource<Server> createJobServer(
+      JobState.Enum jobState, JobApi.MetricResults metricResults) throws IOException {
     CloseableResource<Server> server =
         CloseableResource.of(
             InProcessServerBuilder.forName(ENDPOINT_URL)
-                .addService(new TestJobService(ENDPOINT_DESCRIPTOR, "prepId", "jobId", jobState))
+                .addService(
+                    new TestJobService(
+                        ENDPOINT_DESCRIPTOR, "prepId", "jobId", jobState, metricResults))
                 .addService(new InMemoryArtifactStagerService())
                 .build(),
             Server::shutdown);
diff --git a/runners/spark/src/test/java/org/apache/beam/runners/spark/metrics/SparkMetricsPusherTest.java b/runners/spark/src/test/java/org/apache/beam/runners/spark/metrics/SparkMetricsPusherTest.java
index d9fd72fba16..59de4bbd2f5 100644
--- a/runners/spark/src/test/java/org/apache/beam/runners/spark/metrics/SparkMetricsPusherTest.java
+++ b/runners/spark/src/test/java/org/apache/beam/runners/spark/metrics/SparkMetricsPusherTest.java
@@ -50,6 +50,7 @@ import org.slf4j.LoggerFactory;
 public class SparkMetricsPusherTest {
 
   private static final Logger LOG = LoggerFactory.getLogger(SparkMetricsPusherTest.class);
+  private static final String COUNTER_NAME = "counter";
 
   @Rule public final transient ReuseSparkContextRule noContextResue = ReuseSparkContextRule.no();
 
@@ -96,7 +97,7 @@ public class SparkMetricsPusherTest {
     // give metrics pusher time to push
     Thread.sleep(
         (pipeline.getOptions().as(MetricsOptions.class).getMetricsPushPeriod() + 1L) * 1000);
-    assertThat(TestMetricsSink.getCounterValue(), is(6L));
+    assertThat(TestMetricsSink.getCounterValue(COUNTER_NAME), is(6L));
   }
 
   private static class CountingDoFn extends DoFn<Integer, Integer> {
@@ -122,6 +123,6 @@ public class SparkMetricsPusherTest {
     // give metrics pusher time to push
     Thread.sleep(
         (pipeline.getOptions().as(MetricsOptions.class).getMetricsPushPeriod() + 1L) * 1000);
-    assertThat(TestMetricsSink.getCounterValue(), is(6L));
+    assertThat(TestMetricsSink.getCounterValue(COUNTER_NAME), is(6L));
   }
 }
diff --git a/runners/spark/src/test/java/org/apache/beam/runners/spark/structuredstreaming/metrics/MetricsPusherTest.java b/runners/spark/src/test/java/org/apache/beam/runners/spark/structuredstreaming/metrics/MetricsPusherTest.java
index b6e00f166e0..3ae2b5abcac 100644
--- a/runners/spark/src/test/java/org/apache/beam/runners/spark/structuredstreaming/metrics/MetricsPusherTest.java
+++ b/runners/spark/src/test/java/org/apache/beam/runners/spark/structuredstreaming/metrics/MetricsPusherTest.java
@@ -49,6 +49,7 @@ import org.slf4j.LoggerFactory;
 public class MetricsPusherTest {
 
   private static final Logger LOG = LoggerFactory.getLogger(MetricsPusherTest.class);
+  private static final String COUNTER_NAME = "counter";
 
   private static Pipeline pipeline;
 
@@ -64,7 +65,7 @@ public class MetricsPusherTest {
   }
 
   private static class CountingDoFn extends DoFn<Integer, Integer> {
-    private final Counter counter = Metrics.counter(MetricsPusherTest.class, "counter");
+    private final Counter counter = Metrics.counter(MetricsPusherTest.class, COUNTER_NAME);
 
     @ProcessElement
     public void processElement(ProcessContext context) {
@@ -86,6 +87,6 @@ public class MetricsPusherTest {
     // give metrics pusher time to push
     Thread.sleep(
         (pipeline.getOptions().as(MetricsOptions.class).getMetricsPushPeriod() + 1L) * 1000);
-    assertThat(TestMetricsSink.getCounterValue(), is(6L));
+    assertThat(TestMetricsSink.getCounterValue(COUNTER_NAME), is(6L));
   }
 }
