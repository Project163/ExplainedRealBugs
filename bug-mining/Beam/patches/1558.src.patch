diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkJobInvoker.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkJobInvoker.java
index 6e6563706dc..40257b928f8 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkJobInvoker.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkJobInvoker.java
@@ -19,11 +19,11 @@ package org.apache.beam.runners.flink;
 
 import static org.apache.beam.runners.core.construction.resources.PipelineResources.detectClassPathResourcesToStage;
 
-import java.io.IOException;
 import java.util.UUID;
 import javax.annotation.Nullable;
 import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.runners.core.construction.PipelineOptionsTranslation;
+import org.apache.beam.runners.flink.translation.utils.Workarounds;
 import org.apache.beam.runners.fnexecution.jobsubmission.JobInvocation;
 import org.apache.beam.runners.fnexecution.jobsubmission.JobInvoker;
 import org.apache.beam.runners.fnexecution.jobsubmission.PortablePipelineJarCreator;
@@ -56,8 +56,9 @@ public class FlinkJobInvoker extends JobInvoker {
       RunnerApi.Pipeline pipeline,
       Struct options,
       @Nullable String retrievalToken,
-      ListeningExecutorService executorService)
-      throws IOException {
+      ListeningExecutorService executorService) {
+    Workarounds.restoreOriginalStdOutAndStdErrIfApplicable();
+
     // TODO: How to make Java/Python agree on names of keys and their values?
     LOG.trace("Parsing pipeline options");
     FlinkPipelineOptions flinkOptions =
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkRunner.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkRunner.java
index 3c53a42ce32..9454ba2f9c9 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkRunner.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkRunner.java
@@ -26,6 +26,7 @@ import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
 import org.apache.beam.runners.core.metrics.MetricsPusher;
+import org.apache.beam.runners.flink.translation.utils.Workarounds;
 import org.apache.beam.sdk.Pipeline;
 import org.apache.beam.sdk.PipelineResult;
 import org.apache.beam.sdk.PipelineRunner;
@@ -89,9 +90,10 @@ public class FlinkRunner extends PipelineRunner<PipelineResult> {
     return new FlinkRunner(flinkOptions);
   }
 
-  private FlinkRunner(FlinkPipelineOptions options) {
+  protected FlinkRunner(FlinkPipelineOptions options) {
     this.options = options;
     this.ptransformViewsWithNonDeterministicKeyCoders = new HashSet<>();
+    Workarounds.restoreOriginalStdOutAndStdErrIfApplicable();
   }
 
   @Override
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/utils/Workarounds.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/utils/Workarounds.java
index 560ea11a46d..77baba3d1be 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/utils/Workarounds.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/utils/Workarounds.java
@@ -18,7 +18,11 @@
 package org.apache.beam.runners.flink.translation.utils;
 
 import com.fasterxml.jackson.databind.type.TypeFactory;
-
+import java.io.FileDescriptor;
+import java.io.FileOutputStream;
+import java.io.PrintStream;
+import org.apache.flink.api.java.ExecutionEnvironment;
+import org.apache.flink.client.program.OptimizerPlanEnvironment;
 
 /** Workarounds for dealing with limitations of Flink or its libraries. */
 public class Workarounds {
@@ -28,4 +32,17 @@ public class Workarounds {
     // See https://jira.apache.org/jira/browse/BEAM-6460
     TypeFactory.defaultInstance().clearCache();
   }
+
+  /**
+   * Flink uses the {@link org.apache.flink.client.program.OptimizerPlanEnvironment} which replaces
+   * stdout/stderr during job graph creation. This was intended only for previewing the plan, but
+   * other parts of Flink, e.g. the Rest API have started to use this code as well. To be able to
+   * inspect the output before execution, we use this method to restore the original stdout/stderr.
+   */
+  public static void restoreOriginalStdOutAndStdErrIfApplicable() {
+    if (ExecutionEnvironment.getExecutionEnvironment() instanceof OptimizerPlanEnvironment) {
+      System.setOut(new PrintStream(new FileOutputStream(FileDescriptor.out)));
+      System.setErr(new PrintStream(new FileOutputStream(FileDescriptor.err)));
+    }
+  }
 }
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/FlinkJobInvokerTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/FlinkJobInvokerTest.java
new file mode 100644
index 00000000000..28c2cdebd90
--- /dev/null
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/FlinkJobInvokerTest.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.flink;
+
+import org.apache.beam.model.pipeline.v1.RunnerApi;
+import org.apache.beam.runners.core.construction.PipelineOptionsTranslation;
+import org.apache.beam.runners.core.construction.PipelineTranslation;
+import org.apache.beam.sdk.Pipeline;
+import org.apache.beam.sdk.io.GenerateSequence;
+import org.apache.beam.sdk.options.PipelineOptionsFactory;
+import org.apache.beam.vendor.grpc.v1p21p0.com.google.protobuf.Struct;
+import org.apache.flink.client.program.OptimizerPlanEnvironment;
+import org.apache.flink.client.program.PackagedProgram;
+import org.apache.flink.client.program.ProgramInvocationException;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.optimizer.Optimizer;
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+import org.hamcrest.core.StringContains;
+import org.junit.Assert;
+import org.junit.Test;
+
+/** Tests for {@link FlinkJobInvoker}. */
+public class FlinkJobInvokerTest {
+
+  @Test
+  public void testEnsureStdoutStdErrIsRestored() throws Exception {
+    PackagedProgram packagedProgram = new PackagedProgram(getClass());
+    OptimizerPlanEnvironment env = new OptimizerPlanEnvironment(new Optimizer(new Configuration()));
+    try {
+      // Flink will throw an error because no job graph will be generated by the main method
+      env.getOptimizedPlan(packagedProgram);
+      Assert.fail("This should have failed to create the Flink Plan.");
+    } catch (ProgramInvocationException e) {
+      // Test that Flink wasn't able to intercept the stdout/stderr and we printed to the regular
+      // output instead
+      MatcherAssert.assertThat(
+          e.getMessage(),
+          CoreMatchers.allOf(
+              StringContains.containsString("System.out: (none)"),
+              StringContains.containsString("System.err: (none)")));
+    }
+  }
+
+  /** Main method for {@code testEnsureStdoutStdErrIsRestored()}. */
+  public static void main(String[] args) {
+    Pipeline p = Pipeline.create();
+    p.apply(GenerateSequence.from(0));
+
+    RunnerApi.Pipeline pipeline = PipelineTranslation.toProto(p);
+    Struct options = PipelineOptionsTranslation.toProto(PipelineOptionsFactory.create());
+
+    FlinkJobInvoker flinkJobInvoker =
+        FlinkJobInvoker.create(new FlinkJobServerDriver.FlinkServerConfiguration());
+    // This will call Workarounds.restoreOriginalStdOutAndStdErr() which we want to test
+    flinkJobInvoker.invokeWithExecutor(pipeline, options, "retrievalToken", null);
+  }
+}
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/FlinkRunnerTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/FlinkRunnerTest.java
new file mode 100644
index 00000000000..182f65e9e6d
--- /dev/null
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/FlinkRunnerTest.java
@@ -0,0 +1,89 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.flink;
+
+import static org.hamcrest.CoreMatchers.allOf;
+
+import org.apache.beam.sdk.Pipeline;
+import org.apache.beam.sdk.PipelineResult;
+import org.apache.beam.sdk.io.GenerateSequence;
+import org.apache.beam.sdk.options.PipelineOptions;
+import org.apache.beam.sdk.options.PipelineOptionsFactory;
+import org.apache.flink.client.program.OptimizerPlanEnvironment;
+import org.apache.flink.client.program.PackagedProgram;
+import org.apache.flink.client.program.ProgramInvocationException;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.optimizer.Optimizer;
+import org.hamcrest.MatcherAssert;
+import org.hamcrest.core.StringContains;
+import org.junit.Assert;
+import org.junit.Test;
+
+/** Test for {@link FlinkRunner}. */
+public class FlinkRunnerTest {
+
+  @Test
+  public void testEnsureStdoutStdErrIsRestored() throws Exception {
+    PackagedProgram packagedProgram = new PackagedProgram(getClass());
+    OptimizerPlanEnvironment env = new OptimizerPlanEnvironment(new Optimizer(new Configuration()));
+    try {
+      // Flink will throw an error because no job graph will be generated by the main method
+      env.getOptimizedPlan(packagedProgram);
+      Assert.fail("This should have failed to create the Flink Plan.");
+    } catch (ProgramInvocationException e) {
+      // Test that Flink wasn't able to intercept the stdout/stderr and we printed to the regular
+      // output instead
+      MatcherAssert.assertThat(
+          e.getMessage(),
+          allOf(
+              StringContains.containsString("System.out: (none)"),
+              StringContains.containsString("System.err: (none)")));
+    }
+  }
+
+  /** Main method for {@code testEnsureStdoutStdErrIsRestored()}. */
+  public static void main(String[] args) {
+    FlinkPipelineOptions options = PipelineOptionsFactory.as(FlinkPipelineOptions.class);
+    options.setRunner(NotExecutingFlinkRunner.class);
+    Pipeline p = Pipeline.create(options);
+    p.apply(GenerateSequence.from(0));
+
+    // This will call Workarounds.restoreOriginalStdOutAndStdErr() through the constructor of
+    // FlinkRunner
+    p.run();
+  }
+
+  private static class NotExecutingFlinkRunner extends FlinkRunner {
+
+    protected NotExecutingFlinkRunner(FlinkPipelineOptions options) {
+      // Stdout/Stderr is restored here
+      super(options);
+    }
+
+    @SuppressWarnings("unused")
+    public static NotExecutingFlinkRunner fromOptions(PipelineOptions options) {
+      return new NotExecutingFlinkRunner(options.as(FlinkPipelineOptions.class));
+    }
+
+    @Override
+    public PipelineResult run(Pipeline pipeline) {
+      // Do not execute to test the stdout printing
+      return null;
+    }
+  }
+}
