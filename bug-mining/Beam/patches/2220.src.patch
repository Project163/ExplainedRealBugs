diff --git a/sdks/python/apache_beam/runners/dataflow/dataflow_runner.py b/sdks/python/apache_beam/runners/dataflow/dataflow_runner.py
index 2c6666e8e8a..e837d833f8f 100644
--- a/sdks/python/apache_beam/runners/dataflow/dataflow_runner.py
+++ b/sdks/python/apache_beam/runners/dataflow/dataflow_runner.py
@@ -513,34 +513,36 @@ class DataflowRunner(PipelineRunner):
 
     # Optimize the pipeline if it not streaming and the pre_optimize
     # experiment is set.
-    pre_optimize = options.view_as(DebugOptions).lookup_experiment(
-        'pre_optimize', 'default').lower()
-    from apache_beam.runners.portability.fn_api_runner import translations
-    if (options.view_as(StandardOptions).streaming or pre_optimize == 'none' or
-        pre_optimize == 'default'):
-      phases = []
-    elif pre_optimize == 'all':
-      phases = [
-          # TODO(BEAM-11694): Enable translations.pack_combiners
-          # translations.pack_combiners,
-          translations.sort_stages
-      ]
-    else:
-      phases = []
-      for phase_name in pre_optimize.split(','):
-        # For now, these are all we allow.
-        if phase_name in ('pack_combiners', ):
-          phases.append(getattr(translations, phase_name))
-        else:
-          raise ValueError(
-              'Unknown or inapplicable phase for pre_optimize: %s' % phase_name)
-      phases.append(translations.sort_stages)
-
-    self.proto_pipeline = translations.optimize_pipeline(
-        self.proto_pipeline,
-        phases=phases,
-        known_runner_urns=frozenset(),
-        partial=True)
+    if not options.view_as(StandardOptions).streaming:
+      pre_optimize = options.view_as(DebugOptions).lookup_experiment(
+          'pre_optimize', 'default').lower()
+      from apache_beam.runners.portability.fn_api_runner import translations
+      if pre_optimize == 'none' or pre_optimize == 'default':
+        phases = []
+      elif pre_optimize == 'all':
+        phases = [
+            # TODO(BEAM-11694): Enable translations.pack_combiners
+            # translations.pack_combiners,
+            translations.sort_stages
+        ]
+      else:
+        phases = []
+        for phase_name in pre_optimize.split(','):
+          # For now, these are all we allow.
+          if phase_name in ('pack_combiners', ):
+            phases.append(getattr(translations, phase_name))
+          else:
+            raise ValueError(
+                'Unknown or inapplicable phase for pre_optimize: %s' %
+                phase_name)
+        phases.append(translations.sort_stages)
+
+      if phases:
+        self.proto_pipeline = translations.optimize_pipeline(
+            self.proto_pipeline,
+            phases=phases,
+            known_runner_urns=frozenset(),
+            partial=True)
 
     if use_fnapi:
       self._check_for_unsupported_fnapi_features(self.proto_pipeline)
