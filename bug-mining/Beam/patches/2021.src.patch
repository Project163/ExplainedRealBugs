diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
index be60d4f681f..df7e5f92a1b 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
@@ -81,6 +81,7 @@ import org.apache.beam.sdk.transforms.DoFn;
 import org.apache.beam.sdk.transforms.DoFnSchemaInformation;
 import org.apache.beam.sdk.transforms.join.RawUnionValue;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;
 import org.apache.beam.sdk.transforms.windowing.PaneInfo;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.values.KV;
@@ -592,12 +593,35 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
         return currentOutputWatermark;
       }
     } else {
+      // Check if the final watermark was triggered to perform state cleanup for global window
+      if (potentialOutputWatermark > BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()
+          && currentOutputWatermark <= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {
+        cleanupGlobalWindowState();
+      }
       // No bundle was started when we advanced the input watermark.
       // Thus, we can safely set a new output watermark.
       return potentialOutputWatermark;
     }
   }
 
+  private void cleanupGlobalWindowState() {
+    List<String> userStateNames =
+        executableStage.getUserStates().stream()
+            .map(UserStateReference::localName)
+            .collect(Collectors.toList());
+
+    StateNamespace namespace =
+        StateNamespaces.window(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE);
+    for (String userState : userStateNames) {
+      StateTag<BagState<Void>> bagStateStateTag = StateTags.bag(userState, VoidCoder.of());
+      try {
+        keyedStateInternals.clearBagStates(namespace, bagStateStateTag);
+      } catch (Exception e) {
+        throw new RuntimeException("Failed to clear user state in global window.", e);
+      }
+    }
+  }
+
   private void preBundleStartCallback() {
     inputWatermarkBeforeBundleStart = getEffectiveInputWatermark();
   }
@@ -902,6 +926,15 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
     @Override
     public void setForWindow(InputT input, BoundedWindow window) {
       Preconditions.checkNotNull(input, "Null input passed to CleanupTimer");
+
+      // Skip setting a cleanup timer for the global window as these timers
+      // lead to potentially unbounded state growth in the runner, depending on key cardinality.
+      // Cleanup for global window will be performed upon arrival of the final watermark
+      // in in cleanupGlobalWindowState.
+      if (window.equals(GlobalWindow.INSTANCE)) {
+        return;
+      }
+
       // needs to match the encoding in prepareStateBackend for state request handler
       final ByteBuffer key = FlinkKeyUtils.encodeKey(((KV) input).getKey(), keyCoder);
       // Ensure the state backend is not concurrently accessed by the state requests
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
index 21c06b110f9..da8173d1555 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
@@ -114,6 +114,18 @@ public class FlinkStateInternals<K> implements StateInternals {
     return address.getSpec().bind(address.getId(), new FlinkStateBinder(namespace, context));
   }
 
+  public void clearBagStates(StateNamespace namespace, StateTag<? extends BagState> address)
+      throws Exception {
+    CoderTypeSerializer typeSerializer = new CoderTypeSerializer<>(VoidCoder.of());
+    flinkStateBackend.applyToAllKeys(
+        namespace.stringKey(),
+        StringSerializer.INSTANCE,
+        new ListStateDescriptor<>(address.getId(), typeSerializer),
+        (key, state) -> {
+          state.clear();
+        });
+  }
+
   private class FlinkStateBinder implements StateBinder {
 
     private final StateNamespace namespace;
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
index 22a35a7fc1d..d73ba0e6bc3 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
@@ -23,6 +23,7 @@ import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.nullValue;
 import static org.hamcrest.collection.IsIterableContainingInOrder.contains;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
@@ -31,6 +32,7 @@ import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
@@ -606,17 +608,33 @@ public class ExecutableStageDoFnOperatorTest {
     KeyedStateBackend keyedStateBackend = Mockito.mock(KeyedStateBackend.class);
     Lock stateBackendLock = Mockito.mock(Lock.class);
     StringUtf8Coder keyCoder = StringUtf8Coder.of();
-    GlobalWindow window = GlobalWindow.INSTANCE;
-    GlobalWindow.Coder windowCoder = GlobalWindow.Coder.INSTANCE;
 
-    // Test that cleanup timer is set correctly
+    // Test that no cleanup timer is set for the global window
+    WindowingStrategy windowingStrategy = WindowingStrategy.globalDefault();
+    BoundedWindow window = GlobalWindow.INSTANCE;
     ExecutableStageDoFnOperator.CleanupTimer cleanupTimer =
         new ExecutableStageDoFnOperator.CleanupTimer<>(
             inMemoryTimerInternals,
             stateBackendLock,
-            WindowingStrategy.globalDefault(),
+            windowingStrategy,
             keyCoder,
-            windowCoder,
+            windowingStrategy.getWindowFn().windowCoder(),
+            keyedStateBackend);
+    cleanupTimer.setForWindow(KV.of("key", "string"), window);
+    Mockito.verify(stateBackendLock, never()).lock();
+    Mockito.verify(stateBackendLock, never()).unlock();
+    assertThat(inMemoryTimerInternals.getNextTimer(TimeDomain.EVENT_TIME), nullValue());
+
+    // Test that cleanup timer is set correctly for non-global window
+    windowingStrategy = WindowingStrategy.of(FixedWindows.of(Duration.millis(10)));
+    window = new IntervalWindow(new Instant(0), new Instant(9));
+    cleanupTimer =
+        new ExecutableStageDoFnOperator.CleanupTimer<>(
+            inMemoryTimerInternals,
+            stateBackendLock,
+            windowingStrategy,
+            keyCoder,
+            windowingStrategy.getWindowFn().windowCoder(),
             keyedStateBackend);
     cleanupTimer.setForWindow(KV.of("key", "string"), window);
 
@@ -842,6 +860,73 @@ public class ExecutableStageDoFnOperatorTest {
     verifyNoMoreInteractions(receiver);
   }
 
+  @Test
+  public void testEnsureStateCleanupOnFinalWatermark() throws Exception {
+    TupleTag<Integer> mainOutput = new TupleTag<>("main-output");
+    DoFnOperator.MultiOutputOutputManagerFactory<Integer> outputManagerFactory =
+        new DoFnOperator.MultiOutputOutputManagerFactory(mainOutput, VoidCoder.of());
+
+    StringUtf8Coder keyCoder = StringUtf8Coder.of();
+
+    WindowingStrategy windowingStrategy = WindowingStrategy.globalDefault();
+    Coder<BoundedWindow> windowCoder = windowingStrategy.getWindowFn().windowCoder();
+
+    KvCoder<String, Integer> kvCoder = KvCoder.of(keyCoder, VarIntCoder.of());
+    ExecutableStageDoFnOperator<Integer, Integer> operator =
+        getOperator(
+            mainOutput,
+            Collections.emptyList(),
+            outputManagerFactory,
+            windowingStrategy,
+            keyCoder,
+            WindowedValue.getFullCoder(kvCoder, windowCoder));
+
+    KeyedOneInputStreamOperatorTestHarness<
+            ByteBuffer, WindowedValue<KV<String, Integer>>, WindowedValue<Integer>>
+        testHarness =
+            new KeyedOneInputStreamOperatorTestHarness(
+                operator,
+                operator.keySelector,
+                new CoderTypeInformation<>(FlinkKeyUtils.ByteBufferCoder.of()));
+
+    RemoteBundle bundle = Mockito.mock(RemoteBundle.class);
+    when(bundle.getInputReceivers())
+        .thenReturn(
+            ImmutableMap.<String, FnDataReceiver<WindowedValue>>builder()
+                .put("input", Mockito.mock(FnDataReceiver.class))
+                .build());
+    when(stageBundleFactory.getBundle(any(), any(), any(), any())).thenReturn(bundle);
+
+    testHarness.open();
+
+    KeyedStateBackend<ByteBuffer> keyedStateBackend = operator.getKeyedStateBackend();
+    ByteBuffer key = FlinkKeyUtils.encodeKey("key1", keyCoder);
+    keyedStateBackend.setCurrentKey(key);
+
+    // create some state which can be cleaned up
+    assertThat(testHarness.numKeyedStateEntries(), is(0));
+    StateNamespace stateNamespace = StateNamespaces.window(windowCoder, GlobalWindow.INSTANCE);
+    BagState<ByteString> state = // State from the SDK Harness is stored as ByteStrings
+        operator.keyedStateInternals.state(
+            stateNamespace, StateTags.bag(stateId, ByteStringCoder.of()));
+    state.add(ByteString.copyFrom("userstate".getBytes(Charsets.UTF_8)));
+    assertThat(testHarness.numKeyedStateEntries(), is(1));
+
+    // Generate final watermark to trigger state cleanup
+    testHarness.processWatermark(
+        new Watermark(BoundedWindow.TIMESTAMP_MAX_VALUE.plus(1).getMillis()));
+
+    assertThat(testHarness.numKeyedStateEntries(), is(0));
+
+    // Close should not repeat state cleanup
+    state.add(ByteString.copyFrom("userstate".getBytes(Charsets.UTF_8)));
+    assertThat(testHarness.numKeyedStateEntries(), is(1));
+
+    testHarness.close();
+
+    assertThat(testHarness.numKeyedStateEntries(), is(1));
+  }
+
   @Test
   public void testCacheTokenHandling() throws Exception {
     InMemoryStateInternals test = InMemoryStateInternals.forKey("test");
