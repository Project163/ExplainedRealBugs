diff --git a/sdks/go/pkg/beam/core/runtime/exec/sdf.go b/sdks/go/pkg/beam/core/runtime/exec/sdf.go
index 78fdb99cfb9..742445be516 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/sdf.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/sdf.go
@@ -172,10 +172,6 @@ func (n *SplitAndSizeRestrictions) ProcessElement(ctx context.Context, elm *Full
 	mainElm := elm.Elm.(*FullValue)
 
 	splitRests := n.splitInv.Invoke(mainElm, rest)
-	if len(splitRests) == 0 {
-		err := errors.Errorf("initial splitting returned 0 restrictions.")
-		return errors.WithContextf(err, "%v", n)
-	}
 
 	for _, splitRest := range splitRests {
 		size := n.sizeInv.Invoke(mainElm, splitRest)
diff --git a/sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go b/sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go
index 7dbe3e8420d..2159455b6df 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go
@@ -382,3 +382,50 @@ func (fn *VetKvSdf) ProcessElement(rt *VetRTracker, i, j int, emit func(*VetRest
 	rest.ProcessElm = true
 	emit(rest)
 }
+
+// VetEmptyInitialSplitSdf runs an SDF in order to test that these methods get called properly,
+// each method will flip the corresponding flag in the passed in VetRestriction,
+// overwrite the restriction's Key and Val with the last seen input elements,
+// and retain the other fields in the VetRestriction.
+type VetEmptyInitialSplitSdf struct {
+}
+
+// CreateInitialRestriction creates a restriction with the given values and
+// with the appropriate flags to track that this was called.
+func (fn *VetEmptyInitialSplitSdf) CreateInitialRestriction(i int) *VetRestriction {
+	return &VetRestriction{ID: "EmptySdf", Val: i, CreateRest: true}
+}
+
+// SplitRestriction outputs zero restrictions.
+func (fn *VetEmptyInitialSplitSdf) SplitRestriction(i int, rest *VetRestriction) []*VetRestriction {
+	return []*VetRestriction{}
+}
+
+// RestrictionSize just returns i as the size, as well as flipping appropriate
+// flags on the restriction to track that this was called.
+func (fn *VetEmptyInitialSplitSdf) RestrictionSize(i int, rest *VetRestriction) float64 {
+	rest.Key = nil
+	rest.Val = i
+	rest.RestSize = true
+	return (float64)(i)
+}
+
+// CreateTracker creates an RTracker containing the given restriction and flips
+// the appropriate flags on the restriction to track that this was called.
+func (fn *VetEmptyInitialSplitSdf) CreateTracker(rest *VetRestriction) *VetRTracker {
+	rest.CreateTracker = true
+	return &VetRTracker{rest}
+}
+
+// ProcessElement emits the restriction from the restriction tracker it
+// received, with the appropriate flags flipped to track that this was called.
+// Note that emitting restrictions is discouraged in normal usage. It is only
+// done here to allow validating that ProcessElement is being executed
+// properly.
+func (fn *VetEmptyInitialSplitSdf) ProcessElement(rt *VetRTracker, i int, emit func(*VetRestriction)) {
+	rest := rt.Rest
+	rest.Key = nil
+	rest.Val = i
+	rest.ProcessElm = true
+	emit(rest)
+}
diff --git a/sdks/go/pkg/beam/core/runtime/exec/sdf_test.go b/sdks/go/pkg/beam/core/runtime/exec/sdf_test.go
index 86b29acdef1..796a76bf549 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/sdf_test.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/sdf_test.go
@@ -58,6 +58,10 @@ func TestSdfNodes(t *testing.T) {
 	if err != nil {
 		t.Fatalf("invalid function: %v", err)
 	}
+	emptydfn, err := graph.NewDoFn(&VetEmptyInitialSplitSdf{}, graph.NumMainInputs(graph.MainSingle))
+	if err != nil {
+		t.Fatalf("invalid function: %v", err)
+	}
 
 	// Validate PairWithRestriction matches its contract and properly invokes
 	// SDF method CreateInitialRestriction.
@@ -228,6 +232,22 @@ func TestSdfNodes(t *testing.T) {
 					},
 				},
 			},
+			{
+				name: "Empty",
+				fn:   emptydfn,
+				in: FullValue{
+					Elm: &FullValue{
+						Elm:       1,
+						Elm2:      nil,
+						Timestamp: testTimestamp,
+						Windows:   testWindows,
+					},
+					Elm2:      &VetRestriction{ID: "Sdf"},
+					Timestamp: testTimestamp,
+					Windows:   testWindows,
+				},
+				want: []FullValue{},
+			},
 		}
 		for _, test := range tests {
 			test := test
@@ -238,6 +258,10 @@ func TestSdfNodes(t *testing.T) {
 				units := []Unit{root, node, capt}
 				constructAndExecutePlan(t, units)
 
+				if len(capt.Elements) != len(test.want) {
+					t.Errorf("SplitAndSizeRestrictions(%v) has incorrect number of outputs got: %v, want: %v",
+						test.in, len(capt.Elements), len(test.want))
+				}
 				for i, got := range capt.Elements {
 					if !cmp.Equal(got, test.want[i]) {
 						t.Errorf("SplitAndSizeRestrictions(%v) has incorrect output %v: got: %v, want: %v",
