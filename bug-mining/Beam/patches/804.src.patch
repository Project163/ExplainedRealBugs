diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/planner/BeamRuleSets.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/planner/BeamRuleSets.java
index 24d72c1fd67..d7bd179d236 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/planner/BeamRuleSets.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/planner/BeamRuleSets.java
@@ -22,6 +22,7 @@ import java.util.List;
 import org.apache.beam.sdk.annotations.Internal;
 import org.apache.beam.sdk.extensions.sql.impl.rel.BeamRelNode;
 import org.apache.beam.sdk.extensions.sql.impl.rule.BeamAggregationRule;
+import org.apache.beam.sdk.extensions.sql.impl.rule.BeamBasicAggregationRule;
 import org.apache.beam.sdk.extensions.sql.impl.rule.BeamCalcRule;
 import org.apache.beam.sdk.extensions.sql.impl.rule.BeamEnumerableConverterRule;
 import org.apache.beam.sdk.extensions.sql.impl.rule.BeamIntersectRule;
@@ -135,6 +136,7 @@ public class BeamRuleSets {
       ImmutableList.of(
           BeamCalcRule.INSTANCE,
           BeamAggregationRule.INSTANCE,
+          BeamBasicAggregationRule.INSTANCE,
           BeamSortRule.INSTANCE,
           BeamValuesRule.INSTANCE,
           BeamIntersectRule.INSTANCE,
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamAggregationRel.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamAggregationRel.java
index 68a9f537b2e..7a7e81dc363 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamAggregationRel.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamAggregationRel.java
@@ -25,6 +25,7 @@ import static org.apache.beam.sdk.values.Row.toRow;
 
 import com.google.common.collect.Lists;
 import java.util.List;
+import javax.annotation.Nullable;
 import org.apache.beam.sdk.coders.KvCoder;
 import org.apache.beam.sdk.extensions.sql.impl.transform.MultipleAggregationsFn;
 import org.apache.beam.sdk.extensions.sql.impl.transform.agg.AggregationCombineFnAdapter;
@@ -63,7 +64,7 @@ import org.joda.time.Duration;
 
 /** {@link BeamRelNode} to replace a {@link Aggregate} node. */
 public class BeamAggregationRel extends Aggregate implements BeamRelNode {
-  private WindowFn<Row, IntervalWindow> windowFn;
+  private @Nullable WindowFn<Row, IntervalWindow> windowFn;
   private final int windowFieldIndex;
 
   public BeamAggregationRel(
@@ -74,7 +75,7 @@ public class BeamAggregationRel extends Aggregate implements BeamRelNode {
       ImmutableBitSet groupSet,
       List<ImmutableBitSet> groupSets,
       List<AggregateCall> aggCalls,
-      WindowFn<Row, IntervalWindow> windowFn,
+      @Nullable WindowFn<Row, IntervalWindow> windowFn,
       int windowFieldIndex) {
 
     super(cluster, traits, child, indicator, groupSet, groupSets, aggCalls);
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamBasicAggregationRule.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamBasicAggregationRule.java
new file mode 100644
index 00000000000..eb939112bc0
--- /dev/null
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamBasicAggregationRule.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.extensions.sql.impl.rule;
+
+import org.apache.beam.sdk.extensions.sql.impl.rel.BeamAggregationRel;
+import org.apache.beam.sdk.extensions.sql.impl.rel.BeamLogicalConvention;
+import org.apache.calcite.plan.RelOptRule;
+import org.apache.calcite.plan.RelOptRuleCall;
+import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.Aggregate;
+import org.apache.calcite.rel.core.RelFactories;
+import org.apache.calcite.rel.core.TableScan;
+import org.apache.calcite.tools.RelBuilderFactory;
+
+/**
+ * Aggregation rule that doesn't include projection.
+ *
+ * <p>Doesn't support windowing, as we extract window information from projection node.
+ *
+ * <p>{@link BeamAggregationRule} supports projection and windowing.
+ */
+public class BeamBasicAggregationRule extends RelOptRule {
+  public static final BeamBasicAggregationRule INSTANCE =
+      new BeamBasicAggregationRule(Aggregate.class, RelFactories.LOGICAL_BUILDER);
+
+  public BeamBasicAggregationRule(
+      Class<? extends Aggregate> aggregateClass, RelBuilderFactory relBuilderFactory) {
+    super(operand(aggregateClass, operand(TableScan.class, any())), relBuilderFactory, null);
+  }
+
+  @Override
+  public void onMatch(RelOptRuleCall call) {
+    Aggregate aggregate = call.rel(0);
+    TableScan tableScan = call.rel(1);
+
+    RelNode newTableScan = tableScan.copy(tableScan.getTraitSet(), tableScan.getInputs());
+
+    call.transformTo(
+        new BeamAggregationRel(
+            aggregate.getCluster(),
+            aggregate.getTraitSet().replace(BeamLogicalConvention.INSTANCE),
+            convert(
+                newTableScan, newTableScan.getTraitSet().replace(BeamLogicalConvention.INSTANCE)),
+            aggregate.indicator,
+            aggregate.getGroupSet(),
+            aggregate.getGroupSets(),
+            aggregate.getAggCallList(),
+            null,
+            -1));
+  }
+}
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/transform/agg/AggregationArgsAdapter.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/transform/agg/AggregationArgsAdapter.java
index 9f7fb91b697..775c16c8a63 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/transform/agg/AggregationArgsAdapter.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/transform/agg/AggregationArgsAdapter.java
@@ -44,7 +44,7 @@ class AggregationArgsAdapter {
    */
   static ArgsAdapter of(List<Integer> argList, Schema inputSchema) {
     if (argList.size() == 0) {
-      return new ZeroArgsAdapter(inputSchema);
+      return ZeroArgsAdapter.INSTANCE;
     } else if (argList.size() == 1) {
       return new SingleArgAdapter(inputSchema, argList);
     } else {
@@ -53,29 +53,32 @@ class AggregationArgsAdapter {
   }
 
   /**
-   * If SQL aggregation call doesn't have actual arguments, we still pass the value first field to
-   * the delegate {@link CombineFn}.
+   * If SQL aggregation call doesn't have actual arguments, we pass an empty row to it.
+   *
+   * <p>This is for cases like COUNT(1) which doesn't take any arguments, or COUNT(*) that is a
+   * special case that returns the same result. In both of these cases we should count all Rows no
+   * matter whether they have NULLs or not.
    *
-   * <p>Note: this is not necessarily the correct thing to do.
+   * <p>This is a special case of the MultiArgsAdapter below.
    */
   static class ZeroArgsAdapter implements ArgsAdapter {
-    Schema sourceSchema;
+    private static final Schema EMPTY_SCHEMA = Schema.builder().build();
+    private static final Row EMPTY_ROW = Row.withSchema(EMPTY_SCHEMA).build();
+    private static final Coder<Row> EMPTY_ROW_CODER = SchemaCoder.of(EMPTY_SCHEMA);
 
-    ZeroArgsAdapter(Schema sourceSchema) {
-      this.sourceSchema = sourceSchema;
-    }
+    static final ZeroArgsAdapter INSTANCE = new ZeroArgsAdapter();
 
     /** Extracts the value from the first field of a row. */
     @Nullable
     @Override
     public Object getArgsValues(Row input) {
-      return input.getValue(0);
+      return EMPTY_ROW;
     }
 
     /** Coder for the first field of a row. */
     @Override
     public Coder getArgsValuesCoder() {
-      return RowCoder.coderForFieldType(sourceSchema.getField(0).getType());
+      return EMPTY_ROW_CODER;
     }
   }
 
diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java
index 95ec4cc97aa..64eff9beaf3 100644
--- a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java
+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java
@@ -612,6 +612,37 @@ public class BeamSqlDslAggregationTest extends BeamSqlDslBase {
     pipeline.run();
   }
 
+  /** Query has all the input fields, so no projection is added. */
+  @Test
+  public void testSupportsAggregationWithoutProjection() throws Exception {
+    pipeline.enableAbandonedNodeEnforcement(false);
+
+    Schema schema =
+        Schema.builder().addInt32Field("f_intGroupingKey").addInt32Field("f_intValue").build();
+
+    PCollection<Row> inputRows =
+        pipeline
+            .apply(
+                Create.of(
+                    TestUtils.rowsBuilderOf(schema)
+                        .addRows(
+                            0, 1,
+                            0, 2,
+                            1, 3,
+                            2, 4,
+                            2, 5)
+                        .getRows()))
+            .setSchema(schema, SerializableFunctions.identity(), SerializableFunctions.identity());
+
+    String sql = "SELECT SUM(f_intValue) FROM PCOLLECTION GROUP BY f_intGroupingKey";
+
+    PCollection<Row> result = inputRows.apply("sql", SqlTransform.query(sql));
+
+    PAssert.that(result).containsInAnyOrder(rowsWithSingleIntField("sum", Arrays.asList(3, 3, 9)));
+
+    pipeline.run();
+  }
+
   @Test
   public void testSupportsNonGlobalWindowWithCustomTrigger() {
     DateTime startTime = new DateTime(2017, 1, 1, 0, 0, 0, 0);
