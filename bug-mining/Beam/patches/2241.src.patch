diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateCache.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateCache.java
index ed8232cb556..0706b221f8d 100644
--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateCache.java
+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateCache.java
@@ -17,12 +17,13 @@
  */
 package org.apache.beam.runners.dataflow.worker;
 
+import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.HashMap;
-import java.util.Map;
 import java.util.Objects;
-import javax.servlet.ServletException;
+import java.util.concurrent.ConcurrentMap;
+import java.util.function.BiConsumer;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import org.apache.beam.runners.core.StateNamespace;
@@ -36,9 +37,9 @@ import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Equivalence;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.Cache;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.CacheBuilder;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.RemovalCause;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.CacheStats;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.Weigher;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.HashMultimap;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.MapMaker;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -50,29 +51,28 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * StreamingDataflowWorker} ensures that a single computation * processing key is executing on one
  * thread at a time, so this is safe.
  */
-@SuppressWarnings({
-  "nullness" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)
-})
 public class WindmillStateCache implements StatusDataProvider {
   // Convert Megabytes to bytes
   private static final long MEGABYTES = 1024 * 1024;
   // Estimate of overhead per StateId.
-  private static final int PER_STATE_ID_OVERHEAD = 20;
+  private static final long PER_STATE_ID_OVERHEAD = 28;
   // Initial size of hash tables per entry.
   private static final int INITIAL_HASH_MAP_CAPACITY = 4;
   // Overhead of each hash map entry.
   private static final int HASH_MAP_ENTRY_OVERHEAD = 16;
-  // Overhead of each cache entry.  Three longs, plus a hash table.
+  // Overhead of each StateCacheEntry.  One long, plus a hash table.
   private static final int PER_CACHE_ENTRY_OVERHEAD =
-      24 + HASH_MAP_ENTRY_OVERHEAD * INITIAL_HASH_MAP_CAPACITY;
+      8 + HASH_MAP_ENTRY_OVERHEAD * INITIAL_HASH_MAP_CAPACITY;
 
   private Cache<StateId, StateCacheEntry> stateCache;
-  private HashMultimap<WindmillComputationKey, StateId> keyIndex =
-      HashMultimap.<WindmillComputationKey, StateId>create();
-  private long displayedWeight = 0; // Only used for status pages and unit tests.
+  // Contains the current valid ForKey object. Entries in the cache are keyed by ForKey with pointer
+  // equality so entries may be invalidated by creating a new key object, rendering the previous
+  // entries inaccessible. They will be evicted through normal cache operation.
+  private ConcurrentMap<WindmillComputationKey, ForKey> keyIndex =
+      new MapMaker().weakValues().concurrencyLevel(4).makeMap();
   private long workerCacheBytes; // Copy workerCacheMb and convert to bytes.
 
-  public WindmillStateCache(Integer workerCacheMb) {
+  public WindmillStateCache(long workerCacheMb) {
     final Weigher<Weighted, Weighted> weigher = Weighers.weightedKeysAndValues();
     workerCacheBytes = workerCacheMb * MEGABYTES;
     stateCache =
@@ -80,25 +80,35 @@ public class WindmillStateCache implements StatusDataProvider {
             .maximumWeight(workerCacheBytes)
             .recordStats()
             .weigher(weigher)
-            .removalListener(
-                removal -> {
-                  if (removal.getCause() != RemovalCause.REPLACED) {
-                    synchronized (this) {
-                      StateId id = (StateId) removal.getKey();
-                      if (removal.getCause() != RemovalCause.EXPLICIT) {
-                        // When we invalidate a key explicitly, we'll also update the keyIndex, so
-                        // no need to do it here.
-                        keyIndex.remove(id.getWindmillComputationKey(), id);
-                      }
-                      displayedWeight -= weigher.weigh(id, removal.getValue());
-                    }
-                  }
-                })
+            .concurrencyLevel(4)
             .build();
   }
 
+  private static class EntryStats {
+    long entries;
+    long idWeight;
+    long entryWeight;
+    long entryValues;
+    long maxEntryValues;
+  }
+
+  private EntryStats calculateEntryStats() {
+    EntryStats stats = new EntryStats();
+    BiConsumer<StateId, StateCacheEntry> consumer =
+        (stateId, stateCacheEntry) -> {
+          stats.entries++;
+          stats.idWeight += stateId.getWeight();
+          stats.entryWeight += stateCacheEntry.getWeight();
+          stats.entryValues += stateCacheEntry.values.size();
+          stats.maxEntryValues = Math.max(stats.maxEntryValues, stateCacheEntry.values.size());
+        };
+    stateCache.asMap().forEach(consumer);
+    return stats;
+  }
+
   public long getWeight() {
-    return displayedWeight;
+    EntryStats w = calculateEntryStats();
+    return w.idWeight + w.entryWeight;
   }
 
   public long getMaxWeight() {
@@ -116,207 +126,194 @@ public class WindmillStateCache implements StatusDataProvider {
 
     /** Invalidate all cache entries for this computation and {@code processingKey}. */
     public void invalidate(ByteString processingKey, long shardingKey) {
-      synchronized (this) {
-        WindmillComputationKey key =
-            WindmillComputationKey.create(computation, processingKey, shardingKey);
-        for (StateId id : keyIndex.removeAll(key)) {
-          stateCache.invalidate(id);
-        }
-      }
+      WindmillComputationKey key =
+          WindmillComputationKey.create(computation, processingKey, shardingKey);
+      // By removing the ForKey object, all state for the key is orphaned in the cache and will
+      // be removed by normal cache cleanup.
+      keyIndex.remove(key);
     }
 
-    /** Returns a per-computation, per-key view of the state cache. */
-    public ForKey forKey(
+    /**
+     * Returns a per-computation, per-key, per-state-family view of the state cache. Access to the
+     * cached data for this key is not thread-safe. Callers should ensure that there is only a
+     * single ForKeyAndFamily object in use at a time and that access to it is synchronized or
+     * single-threaded.
+     */
+    public ForKeyAndFamily forKey(
         WindmillComputationKey computationKey,
         String stateFamily,
         long cacheToken,
         long workToken) {
-      return new ForKey(computationKey, stateFamily, cacheToken, workToken);
+      ForKey forKey = keyIndex.get(computationKey);
+      if (forKey == null || !forKey.updateTokens(cacheToken, workToken)) {
+        forKey = new ForKey(computationKey, cacheToken, workToken);
+        // We prefer this implementation to using compute because that is implemented similarly for
+        // ConcurrentHashMap with the downside of it performing inserts for unchanged existing
+        // values as well.
+        keyIndex.put(computationKey, forKey);
+      }
+      return new ForKeyAndFamily(forKey, stateFamily);
     }
   }
 
   /** Per-computation, per-key view of the state cache. */
-  public class ForKey {
-
+  // Note that we utilize the default equality and hashCode for this class based upon the instance
+  // (instead of the fields) to optimize cache invalidation.
+  private static class ForKey {
     private final WindmillComputationKey computationKey;
-    private final String stateFamily;
     // Cache token must be consistent for the key for the cache to be valid.
     private final long cacheToken;
 
     // The work token for processing must be greater than the last work token.  As work items are
     // increasing for a key, a less-than or equal to work token indicates that the current token is
-    // for stale processing. We don't use the cache so that fetches performed will fail with a no
-    // longer valid work token.
-    private final long workToken;
+    // for stale processing.
+    private long workToken;
 
-    private ForKey(
-        WindmillComputationKey computationKey,
-        String stateFamily,
-        long cacheToken,
-        long workToken) {
+    private ForKey(WindmillComputationKey computationKey, long cacheToken, long workToken) {
       this.computationKey = computationKey;
-      this.stateFamily = stateFamily;
       this.cacheToken = cacheToken;
       this.workToken = workToken;
     }
 
-    public <T extends State> T get(StateNamespace namespace, StateTag<T> address) {
-      return WindmillStateCache.this.get(
-          computationKey, stateFamily, cacheToken, workToken, namespace, address);
-    }
-
-    // Note that once a value has been put for a given workToken, get calls with that same workToken
-    // will fail. This is ok as we only put entries when we are building the commit and will no
-    // longer be performing gets for the same work token.
-    public <T extends State> void put(
-        StateNamespace namespace, StateTag<T> address, T value, long weight) {
-      WindmillStateCache.this.put(
-          computationKey, stateFamily, cacheToken, workToken, namespace, address, value, weight);
+    private boolean updateTokens(long cacheToken, long workToken) {
+      if (this.cacheToken != cacheToken || workToken <= this.workToken) {
+        return false;
+      }
+      this.workToken = workToken;
+      return true;
     }
   }
 
-  /** Returns a per-computation view of the state cache. */
-  public ForComputation forComputation(String computation) {
-    return new ForComputation(computation);
-  }
+  /**
+   * Per-computation, per-key, per-family view of the state cache. Modifications are cached locally
+   * and must be flushed to the cache by calling persist. This class is not thread-safe.
+   */
+  public class ForKeyAndFamily {
+    final ForKey forKey;
+    final String stateFamily;
+    private HashMap<StateId, StateCacheEntry> localCache;
 
-  private <T extends State> T get(
-      WindmillComputationKey computationKey,
-      String stateFamily,
-      long cacheToken,
-      long workToken,
-      StateNamespace namespace,
-      StateTag<T> address) {
-    StateId id = new StateId(computationKey, stateFamily, namespace);
-    StateCacheEntry entry = stateCache.getIfPresent(id);
-    if (entry == null) {
-      return null;
+    private ForKeyAndFamily(ForKey forKey, String stateFamily) {
+      this.forKey = forKey;
+      this.stateFamily = stateFamily;
+      localCache = new HashMap<>();
     }
-    if (entry.getCacheToken() != cacheToken) {
-      stateCache.invalidate(id);
-      return null;
+
+    public String getStateFamily() {
+      return stateFamily;
     }
-    if (workToken <= entry.getLastWorkToken()) {
-      // We don't used the cached item but we don't invalidate it.
-      return null;
+
+    public <T extends State> @Nullable T get(StateNamespace namespace, StateTag<T> address) {
+      StateId id = new StateId(forKey, stateFamily, namespace);
+      @SuppressWarnings("nullness") // Unsure how to annotate lambda return allowing null.
+      @Nullable
+      StateCacheEntry entry = localCache.computeIfAbsent(id, key -> stateCache.getIfPresent(key));
+      return entry == null ? null : entry.get(namespace, address);
     }
-    return entry.get(namespace, address);
-  }
 
-  private <T extends State> void put(
-      WindmillComputationKey computationKey,
-      String stateFamily,
-      long cacheToken,
-      long workToken,
-      StateNamespace namespace,
-      StateTag<T> address,
-      T value,
-      long weight) {
-    StateId id = new StateId(computationKey, stateFamily, namespace);
-    StateCacheEntry entry = stateCache.getIfPresent(id);
-    if (entry == null) {
-      synchronized (this) {
-        keyIndex.put(id.getWindmillComputationKey(), id);
+    public <T extends State> void put(
+        StateNamespace namespace, StateTag<T> address, T value, long weight) {
+      StateId id = new StateId(forKey, stateFamily, namespace);
+      @Nullable StateCacheEntry entry = localCache.get(id);
+      if (entry == null) {
+        entry = stateCache.getIfPresent(id);
+        if (entry == null) {
+          entry = new StateCacheEntry();
+        }
+        boolean hadValue = localCache.putIfAbsent(id, entry) != null;
+        Preconditions.checkState(!hadValue);
       }
+      entry.put(namespace, address, value, weight);
     }
-    if (entry == null || entry.getCacheToken() != cacheToken) {
-      entry = new StateCacheEntry(cacheToken);
-      this.displayedWeight += id.getWeight();
-      this.displayedWeight += entry.getWeight();
+
+    public void persist() {
+      localCache.forEach((id, entry) -> stateCache.put(id, entry));
     }
-    entry.setLastWorkToken(workToken);
-    this.displayedWeight += entry.put(namespace, address, value, weight);
-    // Always add back to the cache to update the weight.
-    stateCache.put(id, entry);
   }
 
-  /** Struct identifying a cache entry that contains all data for a key and namespace. */
-  private static class StateId implements Weighted {
+  /** Returns a per-computation view of the state cache. */
+  public ForComputation forComputation(String computation) {
+    return new ForComputation(computation);
+  }
 
-    private final WindmillComputationKey computationKey;
+  /**
+   * Struct identifying a cache entry that contains all data for a ForKey instance and namespace.
+   */
+  private static class StateId implements Weighted {
+    private final ForKey forKey;
     private final String stateFamily;
     private final Object namespaceKey;
+    private final int hashCode;
 
-    public StateId(
-        WindmillComputationKey computationKey, String stateFamily, StateNamespace namespace) {
-      this.computationKey = computationKey;
+    public StateId(ForKey forKey, String stateFamily, StateNamespace namespace) {
+      this.forKey = forKey;
       this.stateFamily = stateFamily;
       this.namespaceKey = namespace.getCacheKey();
+      this.hashCode = Objects.hash(forKey, stateFamily, namespaceKey);
     }
 
     @Override
     public boolean equals(@Nullable Object other) {
-      if (other instanceof StateId) {
-        StateId otherId = (StateId) other;
-        return computationKey.equals(otherId.computationKey)
-            && stateFamily.equals(otherId.stateFamily)
-            && namespaceKey.equals(otherId.namespaceKey);
+      if (this == other) {
+        return true;
       }
-      return false;
-    }
-
-    public WindmillComputationKey getWindmillComputationKey() {
-      return computationKey;
+      if (!(other instanceof StateId)) {
+        return false;
+      }
+      StateId otherId = (StateId) other;
+      return hashCode == otherId.hashCode
+          && forKey == otherId.forKey
+          && stateFamily.equals(otherId.stateFamily)
+          && namespaceKey.equals(otherId.namespaceKey);
     }
 
     @Override
     public int hashCode() {
-      return Objects.hash(computationKey, namespaceKey);
+      return hashCode;
     }
 
     @Override
     public long getWeight() {
-      return (long) computationKey.key().size() + PER_STATE_ID_OVERHEAD;
+      return forKey.computationKey.key().size() + stateFamily.length() + PER_STATE_ID_OVERHEAD;
     }
   }
 
-  /**
-   * Entry in the state cache that stores a map of values, a cache token representing the validity
-   * of the values, and a work token that is increasing to ensure sequential processing.
-   */
+  /** Entry in the state cache that stores a map of values. */
   private static class StateCacheEntry implements Weighted {
-
-    private final long cacheToken;
-    private long lastWorkToken;
-    private final Map<NamespacedTag<?>, WeightedValue<?>> values;
+    private final HashMap<NamespacedTag<?>, WeightedValue<?>> values;
     private long weight;
 
-    public StateCacheEntry(long cacheToken) {
+    public StateCacheEntry() {
       this.values = new HashMap<>(INITIAL_HASH_MAP_CAPACITY);
-      this.cacheToken = cacheToken;
-      this.lastWorkToken = Long.MIN_VALUE;
       this.weight = 0;
     }
 
-    public void setLastWorkToken(long workToken) {
-      this.lastWorkToken = workToken;
-    }
-
-    @SuppressWarnings("unchecked")
-    public <T extends State> T get(StateNamespace namespace, StateTag<T> tag) {
+    public <T extends State> @Nullable T get(StateNamespace namespace, StateTag<T> tag) {
+      @SuppressWarnings("unchecked")
+      @Nullable
       WeightedValue<T> weightedValue =
           (WeightedValue<T>) values.get(new NamespacedTag<>(namespace, tag));
       return weightedValue == null ? null : weightedValue.value;
     }
 
-    public <T extends State> long put(
+    public <T extends State> void put(
         StateNamespace namespace, StateTag<T> tag, T value, long weight) {
-      @SuppressWarnings("unchecked")
-      WeightedValue<T> weightedValue =
-          (WeightedValue<T>) values.get(new NamespacedTag<>(namespace, tag));
-      long weightDelta = 0;
-      if (weightedValue == null) {
-        weightedValue = new WeightedValue<>();
-        weightDelta += HASH_MAP_ENTRY_OVERHEAD;
-      } else {
-        weightDelta -= weightedValue.weight;
-      }
-      weightedValue.value = value;
-      weightedValue.weight = weight;
-      weightDelta += weight;
-      this.weight += weightDelta;
-      values.put(new NamespacedTag<>(namespace, tag), weightedValue);
-      return weightDelta;
+      values.compute(
+          new NamespacedTag<>(namespace, tag),
+          (t, v) -> {
+            @SuppressWarnings("unchecked")
+            WeightedValue<T> weightedValue = (WeightedValue<T>) v;
+            if (weightedValue == null) {
+              weightedValue = new WeightedValue<>();
+              this.weight += HASH_MAP_ENTRY_OVERHEAD;
+            } else {
+              this.weight -= weightedValue.weight;
+            }
+            this.weight += weight;
+            weightedValue.value = value;
+            weightedValue.weight = weight;
+            return weightedValue;
+          });
     }
 
     @Override
@@ -324,14 +321,9 @@ public class WindmillStateCache implements StatusDataProvider {
       return weight + PER_CACHE_ENTRY_OVERHEAD;
     }
 
-    public long getCacheToken() {
-      return cacheToken;
-    }
-
-    public long getLastWorkToken() {
-      return lastWorkToken;
-    }
-
+    // Even though we use the namespace at the higher cache level, we are only using the cacheKey.
+    // That allows for grouped eviction of entries sharing a cacheKey but we require the full
+    // namespace here to distinguish between grouped entries.
     private static class NamespacedTag<T extends State> {
 
       private final StateNamespace namespace;
@@ -344,6 +336,9 @@ public class WindmillStateCache implements StatusDataProvider {
 
       @Override
       public boolean equals(@Nullable Object other) {
+        if (other == this) {
+          return true;
+        }
         if (!(other instanceof NamespacedTag)) {
           return false;
         }
@@ -358,22 +353,31 @@ public class WindmillStateCache implements StatusDataProvider {
     }
 
     private static class WeightedValue<T> {
-
-      public long weight = 0;
-      public T value = null;
+      public long weight;
+      public @Nullable T value;
     }
   }
 
   /** Print summary statistics of the cache to the given {@link PrintWriter}. */
   @Override
   public void appendSummaryHtml(PrintWriter response) {
-    response.println("Cache Stats: <br><table border=0>");
+    response.println("Cache Stats: <br><table>");
     response.println(
-        "<tr><th>Hit Ratio</th><th>Evictions</th><th>Size</th><th>Weight</th></tr><tr>");
-    response.println("<th>" + stateCache.stats().hitRate() + "</th>");
-    response.println("<th>" + stateCache.stats().evictionCount() + "</th>");
-    response.println("<th>" + stateCache.size() + "</th>");
-    response.println("<th>" + getWeight() + "</th>");
+        "<tr><th>Hit Ratio</th><th>Evictions</th><th>Entries</th>"
+            + "<th>Entry Values</th><th>Max Entry Values</th>"
+            + "<th>Id Weight</th><th>Entry Weight</th><th>Max Weight</th><th>Keys</th>"
+            + "</tr><tr>");
+    CacheStats cacheStats = stateCache.stats();
+    EntryStats entryStats = calculateEntryStats();
+    response.println("<td>" + cacheStats.hitRate() + "</td>");
+    response.println("<td>" + cacheStats.evictionCount() + "</td>");
+    response.println("<td>" + entryStats.entries + "(" + stateCache.size() + " inc. weak) </td>");
+    response.println("<td>" + entryStats.entryValues + "</td>");
+    response.println("<td>" + entryStats.maxEntryValues + "</td>");
+    response.println("<td>" + entryStats.idWeight / MEGABYTES + "MB</td>");
+    response.println("<td>" + entryStats.entryWeight / MEGABYTES + "MB</td>");
+    response.println("<td>" + getMaxWeight() / MEGABYTES + "MB</td>");
+    response.println("<td>" + keyIndex.size() + "</td>");
     response.println("</tr></table><br>");
   }
 
@@ -381,8 +385,7 @@ public class WindmillStateCache implements StatusDataProvider {
     return new BaseStatusServlet("/cachez") {
       @Override
       protected void doGet(HttpServletRequest request, HttpServletResponse response)
-          throws IOException, ServletException {
-
+          throws IOException {
         PrintWriter writer = response.getWriter();
         writer.println("<h1>Cache Information</h1>");
         appendSummaryHtml(writer);
diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java
index 95e190a8778..4439603d674 100644
--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java
+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java
@@ -43,7 +43,6 @@ import org.apache.beam.runners.core.StateTable;
 import org.apache.beam.runners.core.StateTag;
 import org.apache.beam.runners.core.StateTag.StateBinder;
 import org.apache.beam.runners.core.StateTags;
-import org.apache.beam.runners.dataflow.worker.WindmillStateCache.ForKey;
 import org.apache.beam.runners.dataflow.worker.windmill.Windmill;
 import org.apache.beam.runners.dataflow.worker.windmill.Windmill.SortedListEntry;
 import org.apache.beam.runners.dataflow.worker.windmill.Windmill.SortedListRange;
@@ -120,7 +119,7 @@ class WindmillStateInternals<K> implements StateInternals {
     private final @Nullable K key;
     private final String stateFamily;
     private final WindmillStateReader reader;
-    private final WindmillStateCache.ForKey cache;
+    private final WindmillStateCache.ForKeyAndFamily cache;
     private final boolean isSystemTable;
     boolean isNewKey;
     private final Supplier<Closeable> scopedReadStateSupplier;
@@ -130,7 +129,7 @@ class WindmillStateInternals<K> implements StateInternals {
         @Nullable K key,
         String stateFamily,
         WindmillStateReader reader,
-        WindmillStateCache.ForKey cache,
+        WindmillStateCache.ForKeyAndFamily cache,
         boolean isSystemTable,
         boolean isNewKey,
         Supplier<Closeable> scopedReadStateSupplier,
@@ -254,7 +253,7 @@ class WindmillStateInternals<K> implements StateInternals {
     }
   }
 
-  private WindmillStateCache.ForKey cache;
+  private WindmillStateCache.ForKeyAndFamily cache;
   Supplier<Closeable> scopedReadStateSupplier;
   private StateTable workItemState;
   private StateTable workItemDerivedState;
@@ -264,7 +263,7 @@ class WindmillStateInternals<K> implements StateInternals {
       String stateFamily,
       WindmillStateReader reader,
       boolean isNewKey,
-      WindmillStateCache.ForKey cache,
+      WindmillStateCache.ForKeyAndFamily cache,
       Supplier<Closeable> scopedReadStateSupplier) {
     this.key = key;
     this.cache = cache;
@@ -329,6 +328,8 @@ class WindmillStateInternals<K> implements StateInternals {
       }
       throw new RuntimeException("Failed to retrieve Windmill state during persist()", exc);
     }
+
+    cache.persist();
   }
 
   /** Encodes the given namespace and address as {@code &lt;namespace&gt;+&lt;address&gt;}. */
@@ -368,7 +369,7 @@ class WindmillStateInternals<K> implements StateInternals {
      * Return an asynchronously computed {@link WorkItemCommitRequest}. The request should be of a
      * form that can be merged with others (only add to repeated fields).
      */
-    abstract Future<WorkItemCommitRequest> persist(WindmillStateCache.ForKey cache)
+    abstract Future<WorkItemCommitRequest> persist(WindmillStateCache.ForKeyAndFamily cache)
         throws IOException;
 
     /**
@@ -401,7 +402,7 @@ class WindmillStateInternals<K> implements StateInternals {
    */
   private abstract static class SimpleWindmillState extends WindmillState {
     @Override
-    public final Future<WorkItemCommitRequest> persist(WindmillStateCache.ForKey cache)
+    public final Future<WorkItemCommitRequest> persist(WindmillStateCache.ForKeyAndFamily cache)
         throws IOException {
       return Futures.immediateFuture(persistDirectly(cache));
     }
@@ -409,8 +410,8 @@ class WindmillStateInternals<K> implements StateInternals {
     /**
      * Returns a {@link WorkItemCommitRequest} that can be used to persist this state to Windmill.
      */
-    protected abstract WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)
-        throws IOException;
+    protected abstract WorkItemCommitRequest persistDirectly(
+        WindmillStateCache.ForKeyAndFamily cache) throws IOException;
   }
 
   @Override
@@ -497,7 +498,7 @@ class WindmillStateInternals<K> implements StateInternals {
     }
 
     @Override
-    protected WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)
+    protected WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKeyAndFamily cache)
         throws IOException {
       if (!valueIsKnown) {
         // The value was never read, written or cleared.
@@ -764,8 +765,7 @@ class WindmillStateInternals<K> implements StateInternals {
       if (availableIdsForTsRange != null) {
         availableIdsForTsRange.removeAll(idsUsed);
       }
-      idsAvailableValue.write(idsAvailable);
-      subRangeDeletionsValue.write(subRangeDeletions);
+      writeValues(idsAvailable, subRangeDeletions);
     }
 
     // Remove a timestamp range. Returns ids freed up.
@@ -797,8 +797,22 @@ class WindmillStateInternals<K> implements StateInternals {
           subRangeDeletions.remove(current);
         }
       }
-      idsAvailableValue.write(idsAvailable);
-      subRangeDeletionsValue.write(subRangeDeletions);
+      writeValues(idsAvailable, subRangeDeletions);
+    }
+
+    private void writeValues(
+        Map<Range<Instant>, RangeSet<Long>> idsAvailable,
+        Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions) {
+      if (idsAvailable.isEmpty()) {
+        idsAvailable.clear();
+      } else {
+        idsAvailableValue.write(idsAvailable);
+      }
+      if (subRangeDeletions.isEmpty()) {
+        subRangeDeletionsValue.clear();
+      } else {
+        subRangeDeletionsValue.write(subRangeDeletions);
+      }
     }
   }
 
@@ -997,10 +1011,14 @@ class WindmillStateInternals<K> implements StateInternals {
     }
 
     @Override
-    public WorkItemCommitRequest persistDirectly(ForKey cache) throws IOException {
+    public WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKeyAndFamily cache)
+        throws IOException {
       WorkItemCommitRequest.Builder commitBuilder = WorkItemCommitRequest.newBuilder();
       TagSortedListUpdateRequest.Builder updatesBuilder =
-          commitBuilder.addSortedListUpdatesBuilder().setStateFamily(stateFamily).setTag(stateKey);
+          commitBuilder
+              .addSortedListUpdatesBuilder()
+              .setStateFamily(cache.getStateFamily())
+              .setTag(stateKey);
       try {
         if (cleared) {
           // Default range.
@@ -1186,7 +1204,7 @@ class WindmillStateInternals<K> implements StateInternals {
     }
 
     @Override
-    public WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)
+    public WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKeyAndFamily cache)
         throws IOException {
       WorkItemCommitRequest.Builder commitBuilder = WorkItemCommitRequest.newBuilder();
 
@@ -1369,7 +1387,7 @@ class WindmillStateInternals<K> implements StateInternals {
     }
 
     @Override
-    public Future<WorkItemCommitRequest> persist(final WindmillStateCache.ForKey cache) {
+    public Future<WorkItemCommitRequest> persist(final WindmillStateCache.ForKeyAndFamily cache) {
 
       Future<WorkItemCommitRequest> result;
 
@@ -1508,7 +1526,7 @@ class WindmillStateInternals<K> implements StateInternals {
         String stateFamily,
         Coder<AccumT> accumCoder,
         CombineFn<InputT, AccumT, OutputT> combineFn,
-        WindmillStateCache.ForKey cache,
+        WindmillStateCache.ForKeyAndFamily cache,
         boolean isNewKey) {
       StateTag<BagState<AccumT>> internalBagAddress = StateTags.convertToBagTagInternal(address);
       WindmillBag<AccumT> cachedBag =
@@ -1559,7 +1577,7 @@ class WindmillStateInternals<K> implements StateInternals {
     }
 
     @Override
-    public Future<WorkItemCommitRequest> persist(WindmillStateCache.ForKey cache)
+    public Future<WorkItemCommitRequest> persist(WindmillStateCache.ForKeyAndFamily cache)
         throws IOException {
       if (hasLocalAdditions) {
         if (COMPACT_NOW.get().get() || bag.valuesAreCached()) {
diff --git a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateCacheTest.java b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateCacheTest.java
index f95e7f84801..aed3b552f72 100644
--- a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateCacheTest.java
+++ b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateCacheTest.java
@@ -144,7 +144,7 @@ public class WindmillStateCacheTest {
   }
 
   WindmillStateCache cache;
-  WindmillStateCache.ForKey keyCache;
+  WindmillStateCache.ForKeyAndFamily keyCache;
 
   @Before
   public void setUp() {
@@ -160,15 +160,22 @@ public class WindmillStateCacheTest {
     assertNull(keyCache.get(windowNamespace(0), new TestStateTag("tag2")));
     assertNull(keyCache.get(triggerNamespace(0, 0), new TestStateTag("tag3")));
     assertNull(keyCache.get(triggerNamespace(0, 0), new TestStateTag("tag2")));
+    assertEquals(0, cache.getWeight());
 
     keyCache.put(StateNamespaces.global(), new TestStateTag("tag1"), new TestState("g1"), 2);
-    assertEquals(129, cache.getWeight());
     keyCache.put(windowNamespace(0), new TestStateTag("tag2"), new TestState("w2"), 2);
-    assertEquals(258, cache.getWeight());
+
+    assertEquals(0, cache.getWeight());
+    keyCache.persist();
+    assertEquals(254, cache.getWeight());
+
     keyCache.put(triggerNamespace(0, 0), new TestStateTag("tag3"), new TestState("t3"), 2);
-    assertEquals(276, cache.getWeight());
     keyCache.put(triggerNamespace(0, 0), new TestStateTag("tag2"), new TestState("t2"), 2);
-    assertEquals(294, cache.getWeight());
+
+    // Observes updated weight in entries, though cache will not know about it.
+    assertEquals(290, cache.getWeight());
+    keyCache.persist();
+    assertEquals(290, cache.getWeight());
 
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 2L);
     assertEquals(
@@ -192,16 +199,16 @@ public class WindmillStateCacheTest {
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 1L);
     assertNull(keyCache.get(StateNamespaces.global(), new TestStateTag("tag1")));
     keyCache.put(StateNamespaces.global(), new TestStateTag("tag1"), new TestState("g1"), 2);
+    keyCache.persist();
 
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 2L);
-    assertEquals(129, cache.getWeight());
+    assertEquals(127, cache.getWeight());
     assertEquals(
         new TestState("g1"), keyCache.get(StateNamespaces.global(), new TestStateTag("tag1")));
 
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 1L, 3L);
-    assertEquals(129, cache.getWeight());
     assertNull(keyCache.get(StateNamespaces.global(), new TestStateTag("tag1")));
-    assertEquals(0, cache.getWeight());
+    assertEquals(127, cache.getWeight());
   }
 
   /** Verifies that the cache is invalidated when the cache token changes. */
@@ -209,9 +216,10 @@ public class WindmillStateCacheTest {
   public void testEviction() throws Exception {
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 1L);
     keyCache.put(windowNamespace(0), new TestStateTag("tag2"), new TestState("w2"), 2);
-    assertEquals(129, cache.getWeight());
     keyCache.put(triggerNamespace(0, 0), new TestStateTag("tag3"), new TestState("t3"), 2000000000);
+    keyCache.persist();
     assertEquals(0, cache.getWeight());
+
     // Eviction is atomic across the whole window.
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 2L);
     assertNull(keyCache.get(windowNamespace(0), new TestStateTag("tag2")));
@@ -225,9 +233,13 @@ public class WindmillStateCacheTest {
 
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 2L);
     keyCache.put(windowNamespace(0), tag, new TestState("w2"), 2);
-    assertEquals(129, cache.getWeight());
+
     // Same cache.
-    assertNull(keyCache.get(windowNamespace(0), tag));
+    assertEquals(new TestState("w2"), keyCache.get(windowNamespace(0), tag));
+    assertEquals(0, cache.getWeight());
+    keyCache.persist();
+    assertEquals(127, cache.getWeight());
+    assertEquals(new TestState("w2"), keyCache.get(windowNamespace(0), tag));
 
     // Previous work token.
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 1L);
@@ -238,7 +250,7 @@ public class WindmillStateCacheTest {
     assertNull(keyCache.get(windowNamespace(0), tag));
 
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 10L);
-    assertEquals(new TestState("w2"), keyCache.get(windowNamespace(0), tag));
+    assertNull(keyCache.get(windowNamespace(0), tag));
     keyCache.put(windowNamespace(0), tag, new TestState("w3"), 2);
 
     // Ensure that second put updated work token.
@@ -246,7 +258,7 @@ public class WindmillStateCacheTest {
     assertNull(keyCache.get(windowNamespace(0), tag));
 
     keyCache = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 15L);
-    assertEquals(new TestState("w3"), keyCache.get(windowNamespace(0), tag));
+    assertNull(keyCache.get(windowNamespace(0), tag));
   }
 
   /** Verifies that caches are kept independently per-key. */
@@ -254,22 +266,24 @@ public class WindmillStateCacheTest {
   public void testMultipleKeys() throws Exception {
     TestStateTag tag = new TestStateTag("tag1");
 
-    WindmillStateCache.ForKey keyCache1 =
+    WindmillStateCache.ForKeyAndFamily keyCache1 =
         cache
             .forComputation("comp1")
             .forKey(computationKey("comp1", "key1", SHARDING_KEY), STATE_FAMILY, 0L, 0L);
-    WindmillStateCache.ForKey keyCache2 =
+    WindmillStateCache.ForKeyAndFamily keyCache2 =
         cache
             .forComputation("comp1")
             .forKey(computationKey("comp1", "key2", SHARDING_KEY), STATE_FAMILY, 0L, 10L);
-    WindmillStateCache.ForKey keyCache3 =
+    WindmillStateCache.ForKeyAndFamily keyCache3 =
         cache
             .forComputation("comp2")
             .forKey(computationKey("comp2", "key1", SHARDING_KEY), STATE_FAMILY, 0L, 0L);
 
     TestState state1 = new TestState("g1");
     keyCache1.put(StateNamespaces.global(), tag, state1, 2);
-    assertNull(keyCache1.get(StateNamespaces.global(), tag));
+    assertEquals(state1, keyCache1.get(StateNamespaces.global(), tag));
+    keyCache1.persist();
+
     keyCache1 =
         cache
             .forComputation("comp1")
@@ -280,7 +294,8 @@ public class WindmillStateCacheTest {
 
     TestState state2 = new TestState("g2");
     keyCache2.put(StateNamespaces.global(), tag, state2, 2);
-    assertNull(keyCache2.get(StateNamespaces.global(), tag));
+    keyCache2.persist();
+    assertEquals(state2, keyCache2.get(StateNamespaces.global(), tag));
     keyCache2 =
         cache
             .forComputation("comp1")
@@ -294,25 +309,24 @@ public class WindmillStateCacheTest {
   @Test
   public void testMultipleShardsOfKey() throws Exception {
     TestStateTag tag = new TestStateTag("tag1");
-    ByteString key1 = ByteString.copyFromUtf8("key1");
-    ByteString key2 = ByteString.copyFromUtf8("key2");
 
-    WindmillStateCache.ForKey key1CacheShard1 =
+    WindmillStateCache.ForKeyAndFamily key1CacheShard1 =
         cache
             .forComputation(COMPUTATION)
             .forKey(computationKey(COMPUTATION, "key1", 1), STATE_FAMILY, 0L, 0L);
-    WindmillStateCache.ForKey key1CacheShard2 =
+    WindmillStateCache.ForKeyAndFamily key1CacheShard2 =
         cache
             .forComputation(COMPUTATION)
             .forKey(computationKey(COMPUTATION, "key1", 2), STATE_FAMILY, 0L, 0L);
-    WindmillStateCache.ForKey key2CacheShard1 =
+    WindmillStateCache.ForKeyAndFamily key2CacheShard1 =
         cache
             .forComputation(COMPUTATION)
             .forKey(computationKey(COMPUTATION, "key2", 1), STATE_FAMILY, 0L, 0L);
 
     TestState state1 = new TestState("g1");
     key1CacheShard1.put(StateNamespaces.global(), tag, state1, 2);
-    assertNull(key1CacheShard1.get(StateNamespaces.global(), tag));
+    key1CacheShard1.persist();
+    assertEquals(state1, key1CacheShard1.get(StateNamespaces.global(), tag));
     key1CacheShard1 =
         cache
             .forComputation(COMPUTATION)
@@ -323,7 +337,8 @@ public class WindmillStateCacheTest {
 
     TestState state2 = new TestState("g2");
     key1CacheShard2.put(StateNamespaces.global(), tag, state2, 2);
-    assertNull(key1CacheShard2.get(StateNamespaces.global(), tag));
+    assertEquals(state2, key1CacheShard2.get(StateNamespaces.global(), tag));
+    key1CacheShard2.persist();
     key1CacheShard2 =
         cache
             .forComputation(COMPUTATION)
@@ -336,27 +351,31 @@ public class WindmillStateCacheTest {
   /** Verifies explicit invalidation does indeed invalidate the correct entries. */
   @Test
   public void testExplicitInvalidation() throws Exception {
-    WindmillStateCache.ForKey keyCache1 =
+    WindmillStateCache.ForKeyAndFamily keyCache1 =
         cache
             .forComputation("comp1")
             .forKey(computationKey("comp1", "key1", 1), STATE_FAMILY, 0L, 0L);
-    WindmillStateCache.ForKey keyCache2 =
+    WindmillStateCache.ForKeyAndFamily keyCache2 =
         cache
             .forComputation("comp1")
             .forKey(computationKey("comp1", "key2", SHARDING_KEY), STATE_FAMILY, 0L, 0L);
-    WindmillStateCache.ForKey keyCache3 =
+    WindmillStateCache.ForKeyAndFamily keyCache3 =
         cache
             .forComputation("comp2")
             .forKey(computationKey("comp2", "key1", SHARDING_KEY), STATE_FAMILY, 0L, 0L);
-    WindmillStateCache.ForKey keyCache4 =
+    WindmillStateCache.ForKeyAndFamily keyCache4 =
         cache
             .forComputation("comp1")
             .forKey(computationKey("comp1", "key1", 2), STATE_FAMILY, 0L, 0L);
 
     keyCache1.put(StateNamespaces.global(), new TestStateTag("tag1"), new TestState("g1"), 1);
+    keyCache1.persist();
     keyCache2.put(StateNamespaces.global(), new TestStateTag("tag2"), new TestState("g2"), 2);
+    keyCache2.persist();
     keyCache3.put(StateNamespaces.global(), new TestStateTag("tag3"), new TestState("g3"), 3);
+    keyCache3.persist();
     keyCache4.put(StateNamespaces.global(), new TestStateTag("tag4"), new TestState("g4"), 4);
+    keyCache4.persist();
     keyCache1 =
         cache
             .forComputation("comp1")
@@ -384,6 +403,10 @@ public class WindmillStateCacheTest {
 
     // Invalidation of key 1 shard 1 does not affect another shard of key 1 or other keys.
     cache.forComputation("comp1").invalidate(ByteString.copyFromUtf8("key1"), 1);
+    keyCache1 =
+        cache
+            .forComputation("comp1")
+            .forKey(computationKey("comp1", "key1", 1), STATE_FAMILY, 0L, 2L);
 
     assertNull(keyCache1.get(StateNamespaces.global(), new TestStateTag("tag1")));
     assertEquals(
@@ -427,11 +450,12 @@ public class WindmillStateCacheTest {
    */
   @Test
   public void testBadCoderEquality() throws Exception {
-    WindmillStateCache.ForKey keyCache1 =
+    WindmillStateCache.ForKeyAndFamily keyCache1 =
         cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 0L);
 
     StateTag<TestState> tag = new TestStateTagWithBadEquality("tag1");
     keyCache1.put(StateNamespaces.global(), tag, new TestState("g1"), 1);
+    keyCache1.persist();
 
     keyCache1 = cache.forComputation(COMPUTATION).forKey(COMPUTATION_KEY, STATE_FAMILY, 0L, 1L);
     assertEquals(new TestState("g1"), keyCache1.get(StateNamespaces.global(), tag));
diff --git a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternalsTest.java b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternalsTest.java
index 206cba9cd1a..a0b5af22aaf 100644
--- a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternalsTest.java
+++ b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternalsTest.java
@@ -28,6 +28,7 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.when;
 
+import com.google.common.base.Charsets;
 import com.google.common.collect.Iterables;
 import java.io.Closeable;
 import java.util.ArrayList;
@@ -135,7 +136,8 @@ public class WindmillStateInternalsTest {
             cache
                 .forComputation("comp")
                 .forKey(
-                    WindmillComputationKey.create("comp", ByteString.EMPTY, 123),
+                    WindmillComputationKey.create(
+                        "comp", ByteString.copyFrom("dummyKey", Charsets.UTF_8), 123),
                     STATE_FAMILY,
                     17L,
                     workToken),
@@ -149,7 +151,8 @@ public class WindmillStateInternalsTest {
             cache
                 .forComputation("comp")
                 .forKey(
-                    WindmillComputationKey.create("comp", ByteString.EMPTY, 123),
+                    WindmillComputationKey.create(
+                        "comp", ByteString.copyFrom("dummyNewKey", Charsets.UTF_8), 123),
                     STATE_FAMILY,
                     17L,
                     workToken),
@@ -1222,7 +1225,7 @@ public class WindmillStateInternalsTest {
     value.write("Hi");
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(126, cache.getWeight());
+    assertEquals(132, cache.getWeight());
 
     resetUnderTest();
     value = underTest.state(NAMESPACE, addr);
@@ -1230,7 +1233,7 @@ public class WindmillStateInternalsTest {
     value.clear();
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(124, cache.getWeight());
+    assertEquals(130, cache.getWeight());
 
     resetUnderTest();
     value = underTest.state(NAMESPACE, addr);
@@ -1262,7 +1265,7 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(134, cache.getWeight());
+    assertEquals(140, cache.getWeight());
 
     resetUnderTest();
     bag = underTest.state(NAMESPACE, addr);
@@ -1282,7 +1285,7 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(127, cache.getWeight());
+    assertEquals(133, cache.getWeight());
 
     resetUnderTest();
     bag = underTest.state(NAMESPACE, addr);
@@ -1293,7 +1296,7 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(128, cache.getWeight());
+    assertEquals(134, cache.getWeight());
 
     resetUnderTest();
     bag = underTest.state(NAMESPACE, addr);
@@ -1324,7 +1327,7 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(132, cache.getWeight());
+    assertEquals(138, cache.getWeight());
 
     resetUnderTest();
     hold = underTest.state(NAMESPACE, addr);
@@ -1333,7 +1336,7 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(132, cache.getWeight());
+    assertEquals(138, cache.getWeight());
 
     resetUnderTest();
     hold = underTest.state(NAMESPACE, addr);
@@ -1364,7 +1367,7 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(125, cache.getWeight());
+    assertEquals(131, cache.getWeight());
 
     resetUnderTest();
     value = underTest.state(NAMESPACE, COMBINING_ADDR);
@@ -1375,7 +1378,7 @@ public class WindmillStateInternalsTest {
 
     underTest.persist(Windmill.WorkItemCommitRequest.newBuilder());
 
-    assertEquals(124, cache.getWeight());
+    assertEquals(130, cache.getWeight());
 
     resetUnderTest();
     value = underTest.state(NAMESPACE, COMBINING_ADDR);
