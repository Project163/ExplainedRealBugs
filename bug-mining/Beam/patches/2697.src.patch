diff --git a/sdks/java/io/jdbc/src/main/java/org/apache/beam/sdk/io/jdbc/JdbcUtil.java b/sdks/java/io/jdbc/src/main/java/org/apache/beam/sdk/io/jdbc/JdbcUtil.java
index 1ca21d61f83..3e94c454dd0 100644
--- a/sdks/java/io/jdbc/src/main/java/org/apache/beam/sdk/io/jdbc/JdbcUtil.java
+++ b/sdks/java/io/jdbc/src/main/java/org/apache/beam/sdk/io/jdbc/JdbcUtil.java
@@ -24,6 +24,7 @@ import java.sql.SQLException;
 import java.sql.Time;
 import java.sql.Timestamp;
 import java.util.Calendar;
+import java.util.Collection;
 import java.util.EnumMap;
 import java.util.List;
 import java.util.Map;
@@ -36,6 +37,7 @@ import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.Row;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;
 import org.joda.time.DateTime;
+import org.joda.time.ReadableDateTime;
 
 /** Provides utility functions for working with {@link JdbcIO}. */
 @SuppressWarnings({
@@ -64,44 +66,85 @@ class JdbcUtil {
           ImmutableMap.<Schema.TypeName, JdbcIO.PreparedStatementSetCaller>builder()
               .put(
                   Schema.TypeName.BYTE,
-                  (element, ps, i, fieldWithIndex) ->
-                      ps.setByte(i + 1, element.getByte(fieldWithIndex.getIndex())))
+                  (element, ps, i, fieldWithIndex) -> {
+                    Byte value = element.getByte(fieldWithIndex.getIndex());
+                    if (value == null) {
+                      setNullToPreparedStatement(ps, i);
+                    } else {
+                      ps.setByte(i + 1, value);
+                    }
+                  })
               .put(
                   Schema.TypeName.INT16,
-                  (element, ps, i, fieldWithIndex) ->
-                      ps.setInt(i + 1, element.getInt16(fieldWithIndex.getIndex())))
+                  (element, ps, i, fieldWithIndex) -> {
+                    Short value = element.getInt16(fieldWithIndex.getIndex());
+                    if (value == null) {
+                      setNullToPreparedStatement(ps, i);
+                    } else {
+                      ps.setInt(i + 1, value);
+                    }
+                  })
               .put(
                   Schema.TypeName.INT64,
-                  (element, ps, i, fieldWithIndex) ->
-                      ps.setLong(i + 1, element.getInt64(fieldWithIndex.getIndex())))
+                  (element, ps, i, fieldWithIndex) -> {
+                    Long value = element.getInt64(fieldWithIndex.getIndex());
+                    if (value == null) {
+                      setNullToPreparedStatement(ps, i);
+                    } else {
+                      ps.setLong(i + 1, value);
+                    }
+                  })
               .put(
                   Schema.TypeName.DECIMAL,
                   (element, ps, i, fieldWithIndex) ->
                       ps.setBigDecimal(i + 1, element.getDecimal(fieldWithIndex.getIndex())))
               .put(
                   Schema.TypeName.FLOAT,
-                  (element, ps, i, fieldWithIndex) ->
-                      ps.setFloat(i + 1, element.getFloat(fieldWithIndex.getIndex())))
+                  (element, ps, i, fieldWithIndex) -> {
+                    Float value = element.getFloat(fieldWithIndex.getIndex());
+                    if (value == null) {
+                      setNullToPreparedStatement(ps, i);
+                    } else {
+                      ps.setFloat(i + 1, value);
+                    }
+                  })
               .put(
                   Schema.TypeName.DOUBLE,
-                  (element, ps, i, fieldWithIndex) ->
-                      ps.setDouble(i + 1, element.getDouble(fieldWithIndex.getIndex())))
+                  (element, ps, i, fieldWithIndex) -> {
+                    Double value = element.getDouble(fieldWithIndex.getIndex());
+                    if (value == null) {
+                      setNullToPreparedStatement(ps, i);
+                    } else {
+                      ps.setDouble(i + 1, value);
+                    }
+                  })
               .put(
                   Schema.TypeName.DATETIME,
-                  (element, ps, i, fieldWithIndex) ->
-                      ps.setTimestamp(
-                          i + 1,
-                          new Timestamp(
-                              element.getDateTime(fieldWithIndex.getIndex()).getMillis())))
+                  (element, ps, i, fieldWithIndex) -> {
+                    ReadableDateTime value = element.getDateTime(fieldWithIndex.getIndex());
+                    ps.setTimestamp(i + 1, value == null ? null : new Timestamp(value.getMillis()));
+                  })
               .put(
                   Schema.TypeName.BOOLEAN,
-                  (element, ps, i, fieldWithIndex) ->
-                      ps.setBoolean(i + 1, element.getBoolean(fieldWithIndex.getIndex())))
+                  (element, ps, i, fieldWithIndex) -> {
+                    Boolean value = element.getBoolean(fieldWithIndex.getIndex());
+                    if (value == null) {
+                      setNullToPreparedStatement(ps, i);
+                    } else {
+                      ps.setBoolean(i + 1, value);
+                    }
+                  })
               .put(Schema.TypeName.BYTES, createBytesCaller())
               .put(
                   Schema.TypeName.INT32,
-                  (element, ps, i, fieldWithIndex) ->
-                      ps.setInt(i + 1, element.getInt32(fieldWithIndex.getIndex())))
+                  (element, ps, i, fieldWithIndex) -> {
+                    Integer value = element.getInt32(fieldWithIndex.getIndex());
+                    if (value == null) {
+                      setNullToPreparedStatement(ps, i);
+                    } else {
+                      ps.setInt(i + 1, value);
+                    }
+                  })
               .put(Schema.TypeName.STRING, createStringCaller())
               .build());
 
@@ -111,43 +154,57 @@ class JdbcUtil {
     switch (fieldType.getTypeName()) {
       case ARRAY:
       case ITERABLE:
-        return (element, ps, i, fieldWithIndex) ->
+        return (element, ps, i, fieldWithIndex) -> {
+          Collection<Object> value = element.getArray(fieldWithIndex.getIndex());
+          if (value == null) {
+            ps.setArray(i + 1, null);
+          } else {
             ps.setArray(
                 i + 1,
                 ps.getConnection()
                     .createArrayOf(
                         fieldType.getCollectionElementType().getTypeName().name(),
-                        element.getArray(fieldWithIndex.getIndex()).toArray()));
+                        value.toArray()));
+          }
+        };
       case LOGICAL_TYPE:
         {
           String logicalTypeName = fieldType.getLogicalType().getIdentifier();
           JDBCType jdbcType = JDBCType.valueOf(logicalTypeName);
           switch (jdbcType) {
             case DATE:
-              return (element, ps, i, fieldWithIndex) ->
-                  ps.setDate(
-                      i + 1,
-                      new Date(
-                          getDateOrTimeOnly(
-                                  element.getDateTime(fieldWithIndex.getIndex()).toDateTime(), true)
-                              .getTime()
-                              .getTime()));
+              return (element, ps, i, fieldWithIndex) -> {
+                ReadableDateTime value = element.getDateTime(fieldWithIndex.getIndex());
+                ps.setDate(
+                    i + 1,
+                    value == null
+                        ? null
+                        : new Date(
+                            getDateOrTimeOnly(value.toDateTime(), true).getTime().getTime()));
+              };
             case TIME:
-              return (element, ps, i, fieldWithIndex) ->
-                  ps.setTime(
-                      i + 1,
-                      new Time(
-                          getDateOrTimeOnly(
-                                  element.getDateTime(fieldWithIndex.getIndex()).toDateTime(),
-                                  false)
-                              .getTime()
-                              .getTime()));
+              return (element, ps, i, fieldWithIndex) -> {
+                ReadableDateTime value = element.getDateTime(fieldWithIndex.getIndex());
+                ps.setTime(
+                    i + 1,
+                    value == null
+                        ? null
+                        : new Time(
+                            getDateOrTimeOnly(
+                                    element.getDateTime(fieldWithIndex.getIndex()).toDateTime(),
+                                    false)
+                                .getTime()
+                                .getTime()));
+              };
             case TIMESTAMP_WITH_TIMEZONE:
               return (element, ps, i, fieldWithIndex) -> {
-                Calendar calendar =
-                    withTimestampAndTimezone(
-                        element.getDateTime(fieldWithIndex.getIndex()).toDateTime());
-                ps.setTimestamp(i + 1, new Timestamp(calendar.getTime().getTime()), calendar);
+                ReadableDateTime value = element.getDateTime(fieldWithIndex.getIndex());
+                if (value == null) {
+                  ps.setTimestamp(i + 1, null);
+                } else {
+                  Calendar calendar = withTimestampAndTimezone(value.toDateTime());
+                  ps.setTimestamp(i + 1, new Timestamp(calendar.getTime().getTime()), calendar);
+                }
               };
             default:
               return getPreparedStatementSetCaller(fieldType.getLogicalType().getBaseType());
@@ -166,6 +223,10 @@ class JdbcUtil {
     }
   }
 
+  static void setNullToPreparedStatement(PreparedStatement ps, int i) throws SQLException {
+    ps.setNull(i + 1, JDBCType.NULL.getVendorTypeNumber());
+  }
+
   static class BeamRowPreparedStatementSetter implements JdbcIO.PreparedStatementSetter<Row> {
     @Override
     public void setParameters(Row row, PreparedStatement statement) {
diff --git a/sdks/java/io/jdbc/src/test/java/org/apache/beam/sdk/io/jdbc/JdbcIOTest.java b/sdks/java/io/jdbc/src/test/java/org/apache/beam/sdk/io/jdbc/JdbcIOTest.java
index 30901345f40..cdd63a9dfbd 100644
--- a/sdks/java/io/jdbc/src/test/java/org/apache/beam/sdk/io/jdbc/JdbcIOTest.java
+++ b/sdks/java/io/jdbc/src/test/java/org/apache/beam/sdk/io/jdbc/JdbcIOTest.java
@@ -17,6 +17,7 @@
  */
 package org.apache.beam.sdk.io.jdbc;
 
+import static java.sql.JDBCType.NULL;
 import static java.sql.JDBCType.NUMERIC;
 import static org.apache.beam.sdk.io.common.DatabaseTestHelper.assertRowCount;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -880,6 +881,72 @@ public class JdbcIOTest implements Serializable {
     verify(psMocked, times(1)).setByte(11, Byte.parseByte("1", 2));
   }
 
+  @Test
+  public void testGetPreparedStatementSetNullsCaller() throws Exception {
+
+    Schema schema =
+        Schema.builder()
+            // primitive
+            .addField("bigint_col", Schema.FieldType.INT64.withNullable(true))
+            .addField("bit_col", Schema.FieldType.BOOLEAN.withNullable(true))
+            .addField("double_col", Schema.FieldType.DOUBLE.withNullable(true))
+            .addField("float_col", Schema.FieldType.FLOAT.withNullable(true))
+            .addField("integer_col", Schema.FieldType.INT32.withNullable(true))
+            .addField("int16_col", Schema.FieldType.INT16.withNullable(true))
+            .addField("byte_col", Schema.FieldType.BYTE.withNullable(true))
+            // reference
+            .addField("binary_col", Schema.FieldType.BYTES.withNullable(true))
+            .addField("char_col", Schema.FieldType.STRING.withNullable(true))
+            .addField("decimal_col", Schema.FieldType.DECIMAL.withNullable(true))
+            .addField("datetime_col", Schema.FieldType.DATETIME.withNullable(true))
+            .build();
+    Row row =
+        Row.withSchema(schema)
+            .addValues(null, null, null, null, null, null, null, null, null, null, null)
+            .build();
+
+    PreparedStatement psMocked = mock(PreparedStatement.class);
+
+    // primitive
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.INT64)
+        .set(row, psMocked, 0, SchemaUtil.FieldWithIndex.of(schema.getField(0), 0));
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.BOOLEAN)
+        .set(row, psMocked, 1, SchemaUtil.FieldWithIndex.of(schema.getField(2), 2));
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.DOUBLE)
+        .set(row, psMocked, 2, SchemaUtil.FieldWithIndex.of(schema.getField(5), 5));
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.FLOAT)
+        .set(row, psMocked, 3, SchemaUtil.FieldWithIndex.of(schema.getField(6), 6));
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.INT32)
+        .set(row, psMocked, 4, SchemaUtil.FieldWithIndex.of(schema.getField(7), 7));
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.INT16)
+        .set(row, psMocked, 5, SchemaUtil.FieldWithIndex.of(schema.getField(9), 9));
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.BYTE)
+        .set(row, psMocked, 6, SchemaUtil.FieldWithIndex.of(schema.getField(10), 10));
+    // reference
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.BYTES)
+        .set(row, psMocked, 7, SchemaUtil.FieldWithIndex.of(schema.getField(1), 1));
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.STRING)
+        .set(row, psMocked, 8, SchemaUtil.FieldWithIndex.of(schema.getField(3), 3));
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.DECIMAL)
+        .set(row, psMocked, 9, SchemaUtil.FieldWithIndex.of(schema.getField(4), 4));
+    JdbcUtil.getPreparedStatementSetCaller(Schema.FieldType.DATETIME)
+        .set(row, psMocked, 10, SchemaUtil.FieldWithIndex.of(schema.getField(8), 8));
+
+    // primitive
+    verify(psMocked, times(1)).setNull(1, NULL.getVendorTypeNumber());
+    verify(psMocked, times(1)).setNull(2, NULL.getVendorTypeNumber());
+    verify(psMocked, times(1)).setNull(3, NULL.getVendorTypeNumber());
+    verify(psMocked, times(1)).setNull(4, NULL.getVendorTypeNumber());
+    verify(psMocked, times(1)).setNull(5, NULL.getVendorTypeNumber());
+    verify(psMocked, times(1)).setNull(6, NULL.getVendorTypeNumber());
+    verify(psMocked, times(1)).setNull(7, NULL.getVendorTypeNumber());
+    // reference
+    verify(psMocked, times(1)).setBytes(8, null);
+    verify(psMocked, times(1)).setString(9, null);
+    verify(psMocked, times(1)).setBigDecimal(10, null);
+    verify(psMocked, times(1)).setTimestamp(11, null);
+  }
+
   @Test
   public void testGetPreparedStatementSetCallerForLogicalTypes() throws Exception {
     FieldType fixedLengthStringType = LogicalTypes.fixedLengthString(JDBCType.VARCHAR, 4);
