diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java
index 4ee46ae73e8..f28d5265dc8 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java
@@ -173,7 +173,7 @@ public class FlinkExecutableStageFunction<InputT> extends AbstractRichFunction
 
     final StateRequestHandler userStateHandler;
     if (executableStage.getUserStates().size() > 0) {
-      bagUserStateHandlerFactory = new InMemoryBagUserStateFactory();
+      bagUserStateHandlerFactory = new InMemoryBagUserStateFactory<>();
       userStateHandler =
           StateRequestHandlers.forBagUserStateHandlerFactory(
               processBundleDescriptor, bagUserStateHandlerFactory);
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
index d68d76da0e2..4f307694ccc 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
@@ -33,8 +33,6 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Optional;
-import java.util.UUID;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
@@ -75,7 +73,6 @@ import org.apache.beam.runners.fnexecution.state.StateRequestHandler;
 import org.apache.beam.runners.fnexecution.state.StateRequestHandlers;
 import org.apache.beam.sdk.coders.Coder;
 import org.apache.beam.sdk.coders.VoidCoder;
-import org.apache.beam.sdk.fn.IdGenerator;
 import org.apache.beam.sdk.fn.data.FnDataReceiver;
 import org.apache.beam.sdk.function.ThrowingFunction;
 import org.apache.beam.sdk.options.PipelineOptions;
@@ -93,7 +90,6 @@ import org.apache.beam.sdk.values.TupleTag;
 import org.apache.beam.sdk.values.WindowingStrategy;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
 import org.apache.beam.vendor.grpc.v1p26p0.io.grpc.StatusRuntimeException;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Charsets;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
 import org.apache.beam.vendor.sdk.v2.sdk.extensions.protobuf.ByteStringCoder;
@@ -270,11 +266,7 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
           StateRequestHandlers.forBagUserStateHandlerFactory(
               stageBundleFactory.getProcessBundleDescriptor(),
               new BagUserStateFactory(
-                  () -> UUID.randomUUID().toString(),
-                  keyedStateInternals,
-                  getKeyedStateBackend(),
-                  stateBackendLock,
-                  keyCoder));
+                  keyedStateInternals, getKeyedStateBackend(), stateBackendLock, keyCoder));
     } else {
       userStateRequestHandler = StateRequestHandler.unsupported();
     }
@@ -299,11 +291,8 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
     @Nullable private final Coder runnerKeyCoder;
     /** For debugging: Same as keyedStateBackend but upcasted, to access key group meta info. */
     @Nullable private final AbstractKeyedStateBackend<ByteBuffer> keyStateBackendWithKeyGroupInfo;
-    /** Holds the valid cache token for user state for this operator. */
-    private final ByteString cacheToken;
 
     BagUserStateFactory(
-        IdGenerator cacheTokenGenerator,
         StateInternals stateInternals,
         KeyedStateBackend<ByteBuffer> keyedStateBackend,
         Lock stateBackendLock,
@@ -320,7 +309,6 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
         this.keyStateBackendWithKeyGroupInfo = null;
       }
       this.runnerKeyCoder = runnerKeyCoder;
-      this.cacheToken = ByteString.copyFrom(cacheTokenGenerator.getId().getBytes(Charsets.UTF_8));
     }
 
     @Override
@@ -394,12 +382,6 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
           }
         }
 
-        @Override
-        public Optional<ByteString> getCacheToken() {
-          // Cache tokens remains valid for the life time of the operator
-          return Optional.of(cacheToken);
-        }
-
         private void prepareStateBackend(ByteString key) {
           // Key for state request is shipped encoded with NESTED context.
           ByteBuffer encodedKey = FlinkKeyUtils.fromEncodedKey(key);
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
index efea47701e6..c32a713b6d5 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
@@ -23,7 +23,6 @@ import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.iterableWithSize;
 import static org.hamcrest.collection.IsIterableContainingInOrder.contains;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
@@ -83,7 +82,6 @@ import org.apache.beam.sdk.coders.KvCoder;
 import org.apache.beam.sdk.coders.StringUtf8Coder;
 import org.apache.beam.sdk.coders.VarIntCoder;
 import org.apache.beam.sdk.coders.VoidCoder;
-import org.apache.beam.sdk.fn.IdGenerator;
 import org.apache.beam.sdk.fn.data.FnDataReceiver;
 import org.apache.beam.sdk.options.PipelineOptionsFactory;
 import org.apache.beam.sdk.state.BagState;
@@ -845,72 +843,63 @@ public class ExecutableStageDoFnOperatorTest {
     InMemoryStateInternals test = InMemoryStateInternals.forKey("test");
     KeyedStateBackend<ByteBuffer> stateBackend = FlinkStateInternalsTest.createStateBackend();
 
+    ExecutableStageDoFnOperator.BagUserStateFactory<Integer, GlobalWindow> bagUserStateFactory =
+        new ExecutableStageDoFnOperator.BagUserStateFactory<>(
+            test, stateBackend, NoopLock.get(), null);
+
+    ByteString key1 = ByteString.copyFrom("key1", Charsets.UTF_8);
+    ByteString key2 = ByteString.copyFrom("key2", Charsets.UTF_8);
+
+    Map<String, Map<String, ProcessBundleDescriptors.BagUserStateSpec>> userStateMapMock =
+        Mockito.mock(Map.class);
+    Map<String, ProcessBundleDescriptors.BagUserStateSpec> transformMap = Mockito.mock(Map.class);
+
+    final String userState1 = "userstate1";
+    ProcessBundleDescriptors.BagUserStateSpec bagUserStateSpec1 = mockBagUserState(userState1);
+    when(transformMap.get(userState1)).thenReturn(bagUserStateSpec1);
+
+    final String userState2 = "userstate2";
+    ProcessBundleDescriptors.BagUserStateSpec bagUserStateSpec2 = mockBagUserState(userState2);
+    when(transformMap.get(userState2)).thenReturn(bagUserStateSpec2);
+
+    when(userStateMapMock.get(anyString())).thenReturn(transformMap);
+    when(processBundleDescriptor.getBagUserStateSpecs()).thenReturn(userStateMapMock);
+    StateRequestHandler stateRequestHandler =
+        StateRequestHandlers.forBagUserStateHandlerFactory(
+            processBundleDescriptor, bagUserStateFactory);
+
     // User state the cache token is valid for the lifetime of the operator
-    for (String expectedToken : new String[] {"first token", "second token"}) {
-      final IdGenerator cacheTokenGenerator = () -> expectedToken;
-      ExecutableStageDoFnOperator.BagUserStateFactory<Integer, GlobalWindow> bagUserStateFactory =
-          new ExecutableStageDoFnOperator.BagUserStateFactory<>(
-              cacheTokenGenerator, test, stateBackend, NoopLock.get(), null);
-
-      ByteString key1 = ByteString.copyFrom("key1", Charsets.UTF_8);
-      ByteString key2 = ByteString.copyFrom("key2", Charsets.UTF_8);
-
-      Map<String, Map<String, ProcessBundleDescriptors.BagUserStateSpec>> userStateMapMock =
-          Mockito.mock(Map.class);
-      Map<String, ProcessBundleDescriptors.BagUserStateSpec> transformMap = Mockito.mock(Map.class);
-
-      final String userState1 = "userstate1";
-      ProcessBundleDescriptors.BagUserStateSpec bagUserStateSpec1 = mockBagUserState(userState1);
-      when(transformMap.get(userState1)).thenReturn(bagUserStateSpec1);
-
-      final String userState2 = "userstate2";
-      ProcessBundleDescriptors.BagUserStateSpec bagUserStateSpec2 = mockBagUserState(userState2);
-      when(transformMap.get(userState2)).thenReturn(bagUserStateSpec2);
-
-      when(userStateMapMock.get(anyString())).thenReturn(transformMap);
-      when(processBundleDescriptor.getBagUserStateSpecs()).thenReturn(userStateMapMock);
-      StateRequestHandler stateRequestHandler =
-          StateRequestHandlers.forBagUserStateHandlerFactory(
-              processBundleDescriptor, bagUserStateFactory);
-
-      // There should be no cache token available before any requests have been made
-      assertThat(stateRequestHandler.getCacheTokens(), iterableWithSize(0));
-
-      // Make a request to generate initial cache token
-      stateRequestHandler.handle(getRequest(key1, userState1));
-      BeamFnApi.ProcessBundleRequest.CacheToken cacheTokenStruct =
-          Iterables.getOnlyElement(stateRequestHandler.getCacheTokens());
-      assertThat(cacheTokenStruct.hasUserState(), is(true));
-      ByteString cacheToken = cacheTokenStruct.getToken();
-      final ByteString expectedCacheToken =
-          ByteString.copyFrom(expectedToken.getBytes(Charsets.UTF_8));
-      assertThat(cacheToken, is(expectedCacheToken));
-
-      List<RequestGenerator> generators =
-          Arrays.asList(
-              ExecutableStageDoFnOperatorTest::getRequest,
-              ExecutableStageDoFnOperatorTest::getAppend,
-              ExecutableStageDoFnOperatorTest::getClear);
-
-      for (RequestGenerator req : generators) {
-        // For every state read the tokens remains unchanged
-        stateRequestHandler.handle(req.makeRequest(key1, userState1));
-        assertThat(
-            Iterables.getOnlyElement(stateRequestHandler.getCacheTokens()).getToken(),
-            is(expectedCacheToken));
-
-        // The token is still valid for another key in the same key range
-        stateRequestHandler.handle(req.makeRequest(key2, userState1));
-        assertThat(
-            Iterables.getOnlyElement(stateRequestHandler.getCacheTokens()).getToken(),
-            is(expectedCacheToken));
-
-        // The token is still valid for another state cell in the same key range
-        stateRequestHandler.handle(req.makeRequest(key2, userState2));
-        assertThat(
-            Iterables.getOnlyElement(stateRequestHandler.getCacheTokens()).getToken(),
-            is(expectedCacheToken));
-      }
+    final BeamFnApi.ProcessBundleRequest.CacheToken expectedCacheToken =
+        Iterables.getOnlyElement(stateRequestHandler.getCacheTokens());
+
+    // Make a request to generate initial cache token
+    stateRequestHandler.handle(getRequest(key1, userState1));
+    BeamFnApi.ProcessBundleRequest.CacheToken returnedCacheToken =
+        Iterables.getOnlyElement(stateRequestHandler.getCacheTokens());
+    assertThat(returnedCacheToken.hasUserState(), is(true));
+    assertThat(returnedCacheToken, is(expectedCacheToken));
+
+    List<RequestGenerator> generators =
+        Arrays.asList(
+            ExecutableStageDoFnOperatorTest::getRequest,
+            ExecutableStageDoFnOperatorTest::getAppend,
+            ExecutableStageDoFnOperatorTest::getClear);
+
+    for (RequestGenerator req : generators) {
+      // For every state read the tokens remains unchanged
+      stateRequestHandler.handle(req.makeRequest(key1, userState1));
+      assertThat(
+          Iterables.getOnlyElement(stateRequestHandler.getCacheTokens()), is(expectedCacheToken));
+
+      // The token is still valid for another key in the same key range
+      stateRequestHandler.handle(req.makeRequest(key2, userState1));
+      assertThat(
+          Iterables.getOnlyElement(stateRequestHandler.getCacheTokens()), is(expectedCacheToken));
+
+      // The token is still valid for another state cell in the same key range
+      stateRequestHandler.handle(req.makeRequest(key2, userState2));
+      assertThat(
+          Iterables.getOnlyElement(stateRequestHandler.getCacheTokens()), is(expectedCacheToken));
     }
   }
 
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java
index 988f63db18e..52d249a234e 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java
@@ -20,8 +20,6 @@ package org.apache.beam.runners.fnexecution.state;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Optional;
-import java.util.UUID;
 import org.apache.beam.runners.core.InMemoryStateInternals;
 import org.apache.beam.runners.core.StateInternals;
 import org.apache.beam.runners.core.StateNamespace;
@@ -31,8 +29,6 @@ import org.apache.beam.runners.core.StateTags;
 import org.apache.beam.sdk.coders.Coder;
 import org.apache.beam.sdk.state.BagState;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
-import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Charsets;
 
 /**
  * Holds user state in memory. Only one key is active at a time due to the GroupReduceFunction being
@@ -41,7 +37,7 @@ import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Charsets;
 public class InMemoryBagUserStateFactory<K, V, W extends BoundedWindow>
     implements StateRequestHandlers.BagUserStateHandlerFactory<K, V, W> {
 
-  private List<InMemorySingleKeyBagState> handlers;
+  final List<InMemorySingleKeyBagState> handlers;
 
   public InMemoryBagUserStateFactory() {
     handlers = new ArrayList<>();
@@ -74,7 +70,6 @@ public class InMemoryBagUserStateFactory<K, V, W extends BoundedWindow>
 
     private final StateTag<BagState<V>> stateTag;
     private final Coder<W> windowCoder;
-    private final ByteString cacheToken;
 
     /* Lazily initialized state internals upon first access */
     private volatile StateInternals stateInternals;
@@ -82,7 +77,6 @@ public class InMemoryBagUserStateFactory<K, V, W extends BoundedWindow>
     InMemorySingleKeyBagState(String userStateId, Coder<V> valueCoder, Coder<W> windowCoder) {
       this.windowCoder = windowCoder;
       this.stateTag = StateTags.bag(userStateId, valueCoder);
-      this.cacheToken = ByteString.copyFrom(UUID.randomUUID().toString().getBytes(Charsets.UTF_8));
     }
 
     @Override
@@ -111,11 +105,6 @@ public class InMemoryBagUserStateFactory<K, V, W extends BoundedWindow>
       bagState.clear();
     }
 
-    @Override
-    public Optional<ByteString> getCacheToken() {
-      return Optional.of(cacheToken);
-    }
-
     private void initStateInternals(K key) {
       if (stateInternals == null) {
         stateInternals = InMemoryStateInternals.forKey(key);
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java
index b05776efd4d..bfafa7d86a2 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlers.java
@@ -20,13 +20,14 @@ package org.apache.beam.runners.fnexecution.state;
 import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.EnumMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Optional;
 import java.util.Set;
+import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ConcurrentHashMap;
@@ -52,6 +53,7 @@ import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.sdk.util.common.Reiterable;
 import org.apache.beam.sdk.values.KV;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Charsets;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.sdk.v2.sdk.extensions.protobuf.ByteStringCoder;
 
@@ -198,11 +200,6 @@ public class StateRequestHandlers {
 
     /** Clears the bag user state for the given key and window. */
     void clear(K key, W window);
-
-    /** Returns the currently valid cache token. */
-    default Optional<ByteString> getCacheToken() {
-      return Optional.empty();
-    }
   }
 
   /**
@@ -503,6 +500,9 @@ public class StateRequestHandlers {
    *
    * <p>Instances of {@link MultimapSideInputHandler}s returned by the {@link
    * SideInputHandlerFactory} are cached.
+   *
+   * <p>In case of any failures, this handler must be discarded. Otherwise, the contained state
+   * cache token would be reused which would corrupt the state cache.
    */
   public static StateRequestHandler forBagUserStateHandlerFactory(
       ExecutableProcessBundleDescriptor processBundleDescriptor,
@@ -520,6 +520,7 @@ public class StateRequestHandlers {
     private final ExecutableProcessBundleDescriptor processBundleDescriptor;
     private final BagUserStateHandlerFactory handlerFactory;
     private final ConcurrentHashMap<BagUserStateSpec, BagUserStateHandler> handlerCache;
+    private final BeamFnApi.ProcessBundleRequest.CacheToken cacheToken;
 
     ByteStringStateRequestHandlerToBagUserStateHandlerFactoryAdapter(
         ExecutableProcessBundleDescriptor processBundleDescriptor,
@@ -527,6 +528,7 @@ public class StateRequestHandlers {
       this.processBundleDescriptor = processBundleDescriptor;
       this.handlerFactory = handlerFactory;
       this.handlerCache = new ConcurrentHashMap<>();
+      this.cacheToken = createCacheToken();
     }
 
     @Override
@@ -588,20 +590,7 @@ public class StateRequestHandlers {
 
     @Override
     public Iterable<BeamFnApi.ProcessBundleRequest.CacheToken> getCacheTokens() {
-      // Use a loop here due to the horrible performance of Java Streams:
-      // https://medium.com/@milan.mimica/slow-like-a-stream-fast-like-a-loop-524f70391182
-      Set<BeamFnApi.ProcessBundleRequest.CacheToken> cacheTokens = new HashSet<>();
-      for (BagUserStateHandler handler : handlerCache.values()) {
-        if (handler.getCacheToken().isPresent()) {
-          cacheTokens.add(
-              BeamFnApi.ProcessBundleRequest.CacheToken.newBuilder()
-                  .setUserState(
-                      BeamFnApi.ProcessBundleRequest.CacheToken.UserState.getDefaultInstance())
-                  .setToken((ByteString) handler.getCacheToken().get())
-                  .build());
-        }
-      }
-      return cacheTokens;
+      return Collections.singleton(cacheToken);
     }
 
     private static <W extends BoundedWindow>
@@ -660,5 +649,13 @@ public class StateRequestHandlers {
           cacheKey.valueCoder(),
           cacheKey.windowCoder());
     }
+
+    private static BeamFnApi.ProcessBundleRequest.CacheToken createCacheToken() {
+      ByteString token = ByteString.copyFrom(UUID.randomUUID().toString().getBytes(Charsets.UTF_8));
+      return BeamFnApi.ProcessBundleRequest.CacheToken.newBuilder()
+          .setUserState(BeamFnApi.ProcessBundleRequest.CacheToken.UserState.getDefaultInstance())
+          .setToken(token)
+          .build();
+    }
   }
 }
diff --git a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlersTest.java b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlersTest.java
index 3c9cc037ae1..46a3d874ce3 100644
--- a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlersTest.java
+++ b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlersTest.java
@@ -17,14 +17,28 @@
  */
 package org.apache.beam.runners.fnexecution.state;
 
+import static org.apache.beam.runners.core.construction.PTransformTranslation.PAR_DO_TRANSFORM_URN;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.notNullValue;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 import java.util.EnumMap;
+import org.apache.beam.model.fnexecution.v1.BeamFnApi;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateKey;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateKey.MultimapSideInput;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateKey.TypeCase;
 import org.apache.beam.model.fnexecution.v1.BeamFnApi.StateRequest;
+import org.apache.beam.model.pipeline.v1.Endpoints;
+import org.apache.beam.model.pipeline.v1.RunnerApi;
+import org.apache.beam.runners.core.construction.ModelCoders;
+import org.apache.beam.runners.core.construction.graph.ExecutableStage;
+import org.apache.beam.runners.fnexecution.control.ProcessBundleDescriptors;
+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;
+import org.apache.beam.sdk.util.CoderUtils;
+import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -59,4 +73,124 @@ public class StateRequestHandlersTest {
     StateRequestHandlers.delegateBasedUponType(new EnumMap<>(StateKey.TypeCase.class))
         .handle(StateRequest.getDefaultInstance());
   }
+
+  @Test
+  public void testUserStateCacheTokenGeneration() throws Exception {
+    ExecutableStage stage = buildExecutableStage("state1", "state2");
+    ProcessBundleDescriptors.ExecutableProcessBundleDescriptor descriptor =
+        ProcessBundleDescriptors.fromExecutableStage(
+            "id", stage, Endpoints.ApiServiceDescriptor.getDefaultInstance());
+
+    InMemoryBagUserStateFactory inMemoryBagUserStateFactory = new InMemoryBagUserStateFactory<>();
+    assertThat(inMemoryBagUserStateFactory.handlers.size(), is(0));
+
+    StateRequestHandler stateRequestHandler =
+        StateRequestHandlers.forBagUserStateHandlerFactory(descriptor, inMemoryBagUserStateFactory);
+    final BeamFnApi.ProcessBundleRequest.CacheToken cacheToken =
+        assertSingleCacheToken(stateRequestHandler);
+
+    sendGetRequest(stateRequestHandler, "state1");
+    assertThat(inMemoryBagUserStateFactory.handlers.size(), is(1));
+    assertThat(assertSingleCacheToken(stateRequestHandler), is(cacheToken));
+
+    sendGetRequest(stateRequestHandler, "state2");
+    assertThat(inMemoryBagUserStateFactory.handlers.size(), is(2));
+    assertThat(assertSingleCacheToken(stateRequestHandler), is(cacheToken));
+  }
+
+  private static BeamFnApi.ProcessBundleRequest.CacheToken assertSingleCacheToken(
+      StateRequestHandler stateRequestHandler) {
+    Iterable<BeamFnApi.ProcessBundleRequest.CacheToken> cacheTokens =
+        stateRequestHandler.getCacheTokens();
+    assertThat(Iterables.size(cacheTokens), is(1));
+
+    BeamFnApi.ProcessBundleRequest.CacheToken cacheToken = Iterables.getOnlyElement(cacheTokens);
+    assertThat(cacheToken.getToken(), is(notNullValue()));
+    assertThat(
+        cacheToken.getUserState(),
+        is(BeamFnApi.ProcessBundleRequest.CacheToken.UserState.getDefaultInstance()));
+    return cacheToken;
+  }
+
+  private static void sendGetRequest(StateRequestHandler stateRequestHandler, String userStateName)
+      throws Exception {
+    stateRequestHandler
+        .handle(
+            StateRequest.newBuilder()
+                .setGet(BeamFnApi.StateGetRequest.getDefaultInstance())
+                .setStateKey(
+                    StateKey.newBuilder()
+                        .setBagUserState(
+                            StateKey.BagUserState.newBuilder()
+                                .setKey(ByteString.copyFromUtf8("key"))
+                                .setWindow(
+                                    ByteString.copyFrom(
+                                        CoderUtils.encodeToByteArray(
+                                            GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)))
+                                .setTransformId("transform")
+                                .setUserStateId(userStateName))
+                        .build())
+                .build())
+        .toCompletableFuture()
+        .get();
+  }
+
+  private static ExecutableStage buildExecutableStage(String... userStateNames) {
+    RunnerApi.ExecutableStagePayload.Builder builder =
+        RunnerApi.ExecutableStagePayload.newBuilder()
+            .setInput("input")
+            .setComponents(
+                RunnerApi.Components.newBuilder()
+                    .putWindowingStrategies(
+                        "window",
+                        RunnerApi.WindowingStrategy.newBuilder()
+                            .setWindowCoderId("windowCoder")
+                            .build())
+                    .putPcollections(
+                        "input",
+                        RunnerApi.PCollection.newBuilder()
+                            .setWindowingStrategyId("window")
+                            .setCoderId("coder")
+                            .build())
+                    .putCoders(
+                        "windowCoder",
+                        RunnerApi.Coder.newBuilder()
+                            .setSpec(
+                                RunnerApi.FunctionSpec.newBuilder()
+                                    .setUrn(ModelCoders.GLOBAL_WINDOW_CODER_URN)
+                                    .build())
+                            .build())
+                    .putCoders(
+                        "coder",
+                        RunnerApi.Coder.newBuilder()
+                            .setSpec(
+                                RunnerApi.FunctionSpec.newBuilder()
+                                    .setUrn(ModelCoders.KV_CODER_URN)
+                                    .build())
+                            .addComponentCoderIds("keyCoder")
+                            .addComponentCoderIds("valueCoder")
+                            .build())
+                    .putCoders("keyCoder", RunnerApi.Coder.getDefaultInstance())
+                    .putCoders("valueCoder", RunnerApi.Coder.getDefaultInstance())
+                    .putTransforms(
+                        "transform",
+                        RunnerApi.PTransform.newBuilder()
+                            .setSpec(
+                                RunnerApi.FunctionSpec.newBuilder()
+                                    .setUrn(PAR_DO_TRANSFORM_URN)
+                                    .build())
+                            .putInputs("input", "input")
+                            .build())
+                    .build());
+
+    for (String userStateName : userStateNames) {
+      builder.addUserStates(
+          RunnerApi.ExecutableStagePayload.UserStateId.newBuilder()
+              .setTransformId("transform")
+              .setLocalName(userStateName)
+              .build());
+    }
+
+    return ExecutableStage.fromPayload(builder.build());
+  }
 }
diff --git a/sdks/python/apache_beam/runners/portability/flink_runner_test.py b/sdks/python/apache_beam/runners/portability/flink_runner_test.py
index f63c9d77397..e56c768ec07 100644
--- a/sdks/python/apache_beam/runners/portability/flink_runner_test.py
+++ b/sdks/python/apache_beam/runners/portability/flink_runner_test.py
@@ -295,27 +295,17 @@ if __name__ == '__main__':
         lines_expected.update([
             # Gauges for the last finished bundle
             'stateful.beam.metric:statecache:capacity: 123',
-            # These are off by 10 because the first bundle contains all the keys
-            # once. Caching is only initialized after the first bundle. Caching
-            # depends on the cache token which is lazily initialized by the
-            # Runner's StateRequestHandlers.
-            'stateful.beam.metric:statecache:size: 20',
+            'stateful.beam.metric:statecache:size: 10',
             'stateful.beam.metric:statecache:get: 20',
             'stateful.beam.metric:statecache:miss: 0',
             'stateful.beam.metric:statecache:hit: 20',
             'stateful.beam.metric:statecache:put: 0',
             'stateful.beam.metric:statecache:evict: 0',
             # Counters
-            # (total of get/hit will be off by 10 due to the cross-bundle
-            # caching only getting initialized after the first bundle.
-            # Cross-bundle caching depends on the cache token which is lazily
-            # initialized by the Runner's StateRequestHandlers).
-            # If cross-bundle caching is not requested, caching is done
-            # at the bundle level.
             'stateful.beam.metric:statecache:get_total: 220',
-            'stateful.beam.metric:statecache:miss_total: 20',
-            'stateful.beam.metric:statecache:hit_total: 200',
-            'stateful.beam.metric:statecache:put_total: 20',
+            'stateful.beam.metric:statecache:miss_total: 10',
+            'stateful.beam.metric:statecache:hit_total: 210',
+            'stateful.beam.metric:statecache:put_total: 10',
             'stateful.beam.metric:statecache:evict_total: 0',
         ])
       else:
diff --git a/sdks/python/apache_beam/runners/worker/sdk_worker.py b/sdks/python/apache_beam/runners/worker/sdk_worker.py
index 0cf28805461..612da23aaf9 100644
--- a/sdks/python/apache_beam/runners/worker/sdk_worker.py
+++ b/sdks/python/apache_beam/runners/worker/sdk_worker.py
@@ -870,7 +870,11 @@ class GrpcStateHandler(StateHandler):
 
 
 class CachingStateHandler(object):
-  """ A State handler which retrieves and caches state. """
+  """ A State handler which retrieves and caches state.
+   If caching is activated, caches across bundles using a supplied cache token.
+   If activated but no cache token is supplied, caching is done at the bundle
+   level.
+  """
 
   def __init__(self,
                global_state_cache,  # type: StateCache
