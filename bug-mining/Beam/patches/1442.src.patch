diff --git a/sdks/python/apache_beam/testing/data/trigger_transcripts.yaml b/sdks/python/apache_beam/testing/data/trigger_transcripts.yaml
index cd553eea56c..2ddc584ea4c 100644
--- a/sdks/python/apache_beam/testing/data/trigger_transcripts.yaml
+++ b/sdks/python/apache_beam/testing/data/trigger_transcripts.yaml
@@ -34,12 +34,12 @@ transcript:
   - input: [1, 2, 3, 10, 11, 25]
   - watermark: 100
   - expect:
-      - {window: [0, 9], values: [1, 2, 3], timestamp: 10, final: false}
-      - {window: [10, 19], values: [10, 11], timestamp: 20}
-      - {window: [20, 29], values: [25], timestamp: 30, late: false}
+      - {window: [0, 9], values: [1, 2, 3], timestamp: 9, final: false}
+      - {window: [10, 19], values: [10, 11], timestamp: 19}
+      - {window: [20, 29], values: [25], timestamp: 29, late: false}
   - input: [7]
   - expect:
-      - {window: [0, 9], values: [1, 2, 3, 7], timestamp: 10, late: true}
+      - {window: [0, 9], values: [1, 2, 3, 7], timestamp: 9, late: true}
 
 ---
 name: timestamp_combiner_earliest
@@ -77,9 +77,9 @@ transcript:
   - input: [1, 2, 3, 10, 11, 25]
   - watermark: 100
   - expect:
-      - {window: [0, 9], values: [1, 2, 3], timestamp: 10, final: false}
-      - {window: [10, 19], values: [10, 11], timestamp: 20}
-      - {window: [20, 29], values: [25], timestamp: 30, late: false}
+      - {window: [0, 9], values: [1, 2, 3], timestamp: 9, final: false}
+      - {window: [10, 19], values: [10, 11], timestamp: 19}
+      - {window: [20, 29], values: [25], timestamp: 29, late: false}
 
 ---
 # Test that custom timestamping is not invoked.
@@ -119,20 +119,20 @@ timestamp_combiner: OUTPUT_AT_EOW
 transcript:
     - input: [1, 2, 3]
     - expect:
-        - {window: [1, 12], values: [1, 2, 3], timestamp: 13, early: true}
+        - {window: [1, 12], values: [1, 2, 3], timestamp: 12, early: true}
     - input: [4]    # no output
     - input: [5]
     - expect:
-        - {window: [1, 14], values: [1, 2, 3, 4, 5], timestamp: 15, early: true}
+        - {window: [1, 14], values: [1, 2, 3, 4, 5], timestamp: 14, early: true}
     - input: [6]
     - watermark: 100
     - expect:
-        - {window: [1, 15], values:[1, 2, 3, 4, 5, 6], timestamp: 16,
+        - {window: [1, 15], values:[1, 2, 3, 4, 5, 6], timestamp: 15,
            final: true}
     - input: [1]
     - input: [3, 4]
     - expect:
-        - {window: [1, 15], values: [1, 1, 2, 3, 3, 4, 4, 5, 6], timestamp: 16}
+        - {window: [1, 15], values: [1, 1, 2, 3, 3, 4, 4, 5, 6], timestamp: 15}
 
 ---
 name: garbage_collection
@@ -146,8 +146,8 @@ accumulation_mode: discarding
 transcript:
   - input: [1, 2, 3, 10, 11, 25]
   - expect:
-      - {window: [0, 9], timestamp: 10}
-      - {window: [10, 19], timestamp: 20}
+      - {window: [0, 9], timestamp: 9}
+      - {window: [10, 19], timestamp: 19}
   - state:
       present: [[20, 29]]
       absent: [[0, 9]]
@@ -179,7 +179,7 @@ transcript:
   - input: [2, 3, 7]
   - watermark: 11
   - expect:
-      - {window: [0, 9], values: [2, 3, 7], timestamp: 10}
+      - {window: [0, 9], values: [2, 3, 7], timestamp: 9}
 
 # These next examples test that bad/incomplete transcripts are rejected.
 ---
diff --git a/sdks/python/apache_beam/transforms/timeutil.py b/sdks/python/apache_beam/transforms/timeutil.py
index 55c7921cbe8..a5f729c7562 100644
--- a/sdks/python/apache_beam/transforms/timeutil.py
+++ b/sdks/python/apache_beam/transforms/timeutil.py
@@ -136,4 +136,4 @@ class OutputAtEndOfWindowImpl(DependsOnlyOnWindow):
   """TimestampCombinerImpl outputting at end of window."""
 
   def assign_output_time(self, window, unused_input_timestamp):
-    return window.end
+    return window.max_timestamp()
diff --git a/sdks/python/apache_beam/transforms/trigger.py b/sdks/python/apache_beam/transforms/trigger.py
index e1db8561de9..5fe08249bc4 100644
--- a/sdks/python/apache_beam/transforms/trigger.py
+++ b/sdks/python/apache_beam/transforms/trigger.py
@@ -1180,7 +1180,7 @@ class GeneralTriggerDriver(TriggerDriver):
     timestamp = state.get_state(window, self.WATERMARK_HOLD)
     if timestamp is None:
       # If no watermark hold was set, output at end of window.
-      timestamp = window.end
+      timestamp = window.max_timestamp()
     else:
       state.clear_state(window, self.WATERMARK_HOLD)
 
diff --git a/sdks/python/apache_beam/transforms/trigger_test.py b/sdks/python/apache_beam/transforms/trigger_test.py
index a72c5969486..c5f53f35253 100644
--- a/sdks/python/apache_beam/transforms/trigger_test.py
+++ b/sdks/python/apache_beam/transforms/trigger_test.py
@@ -119,7 +119,7 @@ class TriggerTest(unittest.TestCase):
     for bundle in bundles:
       for wvalue in driver.process_elements(state, bundle, MIN_TIMESTAMP):
         window, = wvalue.windows
-        self.assertEqual(window.end, wvalue.timestamp)
+        self.assertEqual(window.max_timestamp(), wvalue.timestamp)
         actual_panes[window].append(set(wvalue.value))
 
     while state.timers:
@@ -128,13 +128,13 @@ class TriggerTest(unittest.TestCase):
         for wvalue in driver.process_timer(
             timer_window, name, time_domain, timestamp, state):
           window, = wvalue.windows
-          self.assertEqual(window.end, wvalue.timestamp)
+          self.assertEqual(window.max_timestamp(), wvalue.timestamp)
           actual_panes[window].append(set(wvalue.value))
 
     for bundle in late_bundles:
       for wvalue in driver.process_elements(state, bundle, MIN_TIMESTAMP):
         window, = wvalue.windows
-        self.assertEqual(window.end, wvalue.timestamp)
+        self.assertEqual(window.max_timestamp(), wvalue.timestamp)
         actual_panes[window].append(set(wvalue.value))
 
       while state.timers:
@@ -143,7 +143,7 @@ class TriggerTest(unittest.TestCase):
           for wvalue in driver.process_timer(
               timer_window, name, time_domain, timestamp, state):
             window, = wvalue.windows
-            self.assertEqual(window.end, wvalue.timestamp)
+            self.assertEqual(window.max_timestamp(), wvalue.timestamp)
             actual_panes[window].append(set(wvalue.value))
 
     self.assertEqual(expected_panes, actual_panes)
@@ -604,6 +604,20 @@ class TranscriptTest(unittest.TestCase):
         window_fn, trigger_fn, accumulation_mode, timestamp_combiner,
         transcript, spec)
 
+  def _windowed_value_info(self, windowed_value):
+    # Currently some runners operate at the millisecond level, and some at the
+    # microsecond level.  Trigger transcript timestamps are expressed as
+    # integral units of the finest granularity, whatever that may be.
+    # In these tests we interpret them as integral seconds and then truncate
+    # the results to integral seconds to allow for portability across
+    # different sub-second resolutions.
+    window, = windowed_value.windows
+    return {
+        'window': [int(window.start), int(window.max_timestamp())],
+        'values': sorted(windowed_value.value),
+        'timestamp': int(windowed_value.timestamp),
+    }
+
 
 class TriggerDriverTranscriptTest(TranscriptTest):
 
@@ -624,10 +638,7 @@ class TriggerDriverTranscriptTest(TranscriptTest):
         for timer_window, (name, time_domain, t_timestamp) in to_fire:
           for wvalue in driver.process_timer(
               timer_window, name, time_domain, t_timestamp, state):
-            window, = wvalue.windows
-            output.append({'window': [window.start, window.end - 1],
-                           'values': sorted(wvalue.value),
-                           'timestamp': wvalue.timestamp})
+            output.append(self._windowed_value_info(wvalue))
         to_fire = state.get_and_clear_timers(watermark)
 
     for action, params in transcript:
@@ -642,12 +653,9 @@ class TriggerDriverTranscriptTest(TranscriptTest):
         bundle = [
             WindowedValue(t, t, window_fn.assign(WindowFn.AssignContext(t, t)))
             for t in params]
-        output = [{'window': [wvalue.windows[0].start,
-                              wvalue.windows[0].end - 1],
-                   'values': sorted(wvalue.value),
-                   'timestamp': wvalue.timestamp}
-                  for wvalue
-                  in driver.process_elements(state, bundle, watermark)]
+        output = [
+            self._windowed_value_info(wv)
+            for wv in driver.process_elements(state, bundle, watermark)]
         fire_timers()
 
       elif action == 'watermark':
@@ -778,11 +786,8 @@ class TestStreamTranscriptTest(TranscriptTest):
                      window=beam.DoFn.WindowParam,
                      t=beam.DoFn.TimestampParam: (
                          k,
-                         {
-                             'values': sorted(vs),
-                             'window': [int(window.start), int(window.end - 1)],
-                             'timestamp': t
-                         }))
+                         self._windowed_value_info(
+                             WindowedValue(vs, windows=[window], timestamp=t))))
           # Place outputs back into the global window to allow flattening
           # and share a single state in Check.
           | 'Global' >> beam.WindowInto(beam.transforms.window.GlobalWindows()))
diff --git a/sdks/python/apache_beam/transforms/util_test.py b/sdks/python/apache_beam/transforms/util_test.py
index a78145b1644..4588c3214f8 100644
--- a/sdks/python/apache_beam/transforms/util_test.py
+++ b/sdks/python/apache_beam/transforms/util_test.py
@@ -323,7 +323,7 @@ class ReshuffleTest(unittest.TestCase):
   def test_reshuffle_windows_unchanged(self):
     pipeline = TestPipeline()
     data = [(1, 1), (2, 1), (3, 1), (1, 2), (2, 2), (1, 4)]
-    expected_data = [TestWindowedValue(v, t, [w]) for (v, t, w) in [
+    expected_data = [TestWindowedValue(v, t - .001, [w]) for (v, t, w) in [
         ((1, contains_in_any_order([2, 1])), 4.0, IntervalWindow(1.0, 4.0)),
         ((2, contains_in_any_order([2, 1])), 4.0, IntervalWindow(1.0, 4.0)),
         ((3, [1]), 3.0, IntervalWindow(1.0, 3.0)),
@@ -351,11 +351,12 @@ class ReshuffleTest(unittest.TestCase):
         ((1, 2), 2.0, IntervalWindow(2.0, 4.0)),
         ((2, 2), 2.0, IntervalWindow(2.0, 4.0)),
         ((1, 4), 4.0, IntervalWindow(4.0, 6.0))]]
-    expected_merged_windows = [TestWindowedValue(v, t, [w]) for (v, t, w) in [
-        ((1, contains_in_any_order([2, 1])), 4.0, IntervalWindow(1.0, 4.0)),
-        ((2, contains_in_any_order([2, 1])), 4.0, IntervalWindow(1.0, 4.0)),
-        ((3, [1]), 3.0, IntervalWindow(1.0, 3.0)),
-        ((1, [4]), 6.0, IntervalWindow(4.0, 6.0))]]
+    expected_merged_windows = [
+        TestWindowedValue(v, t - .001, [w]) for (v, t, w) in [
+            ((1, contains_in_any_order([2, 1])), 4.0, IntervalWindow(1.0, 4.0)),
+            ((2, contains_in_any_order([2, 1])), 4.0, IntervalWindow(1.0, 4.0)),
+            ((3, [1]), 3.0, IntervalWindow(1.0, 3.0)),
+            ((1, [4]), 6.0, IntervalWindow(4.0, 6.0))]]
     before_reshuffle = (pipeline
                         | 'start' >> beam.Create(data)
                         | 'add_timestamp' >> beam.Map(
diff --git a/sdks/python/apache_beam/transforms/window_test.py b/sdks/python/apache_beam/transforms/window_test.py
index aa575b15c64..622fabbb81b 100644
--- a/sdks/python/apache_beam/transforms/window_test.py
+++ b/sdks/python/apache_beam/transforms/window_test.py
@@ -22,14 +22,17 @@ from __future__ import division
 import unittest
 from builtins import range
 
+import apache_beam as beam
 from apache_beam.runners import pipeline_context
 from apache_beam.testing.test_pipeline import TestPipeline
 from apache_beam.testing.util import assert_that
 from apache_beam.testing.util import equal_to
 from apache_beam.transforms import CombinePerKey
 from apache_beam.transforms import Create
+from apache_beam.transforms import FlatMapTuple
 from apache_beam.transforms import GroupByKey
 from apache_beam.transforms import Map
+from apache_beam.transforms import MapTuple
 from apache_beam.transforms import WindowInto
 from apache_beam.transforms import combiners
 from apache_beam.transforms import core
@@ -221,6 +224,34 @@ class WindowTest(unittest.TestCase):
       assert_that(result, equal_to([('key', sorted([0, 1, 2, 3, 4] * 3)),
                                     ('key', sorted([5, 6, 7, 8, 9] * 3))]))
 
+  def test_rewindow_regroup(self):
+    with TestPipeline() as p:
+      grouped = (p
+                 | Create(range(5))
+                 | Map(lambda t: TimestampedValue(('key', t), t))
+                 | 'window' >> WindowInto(FixedWindows(5, offset=3))
+                 | GroupByKey()
+                 | MapTuple(lambda k, vs: (k, sorted(vs))))
+      # Both of these group-and-ungroup sequences should be idempotent.
+      regrouped1 = (grouped
+                    | 'w1' >> WindowInto(FixedWindows(5, offset=3))
+                    | 'g1' >> GroupByKey()
+                    | FlatMapTuple(lambda k, vs: [(k, v) for v in vs]))
+      regrouped2 = (grouped
+                    | FlatMapTuple(lambda k, vs: [(k, v) for v in vs])
+                    | 'w2' >> WindowInto(FixedWindows(5, offset=3))
+                    | 'g2' >> GroupByKey()
+                    | MapTuple(lambda k, vs: (k, sorted(vs))))
+      with_windows = Map(lambda e, w=beam.DoFn.WindowParam: (e, w))
+      expected = [(('key', [0, 1, 2]), IntervalWindow(-2, 3)),
+                  (('key', [3, 4]), IntervalWindow(3, 8))]
+
+      assert_that(grouped | 'ww' >> with_windows, equal_to(expected))
+      assert_that(
+          regrouped1 | 'ww1' >> with_windows, equal_to(expected), label='r1')
+      assert_that(
+          regrouped2 | 'ww2' >> with_windows, equal_to(expected), label='r2')
+
   def test_timestamped_with_combiners(self):
     with TestPipeline() as p:
       result = (p
