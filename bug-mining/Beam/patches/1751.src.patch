diff --git a/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/KinesisReader.java b/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/KinesisReader.java
index 2c4222a112b..887aad37465 100644
--- a/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/KinesisReader.java
+++ b/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/KinesisReader.java
@@ -152,35 +152,58 @@ class KinesisReader extends UnboundedSource.UnboundedReader<KinesisRecord> {
   }
 
   /**
-   * Returns total size of all records that remain in Kinesis stream after current watermark. If the
-   * watermark was not already set then it returns {@link
-   * UnboundedSource.UnboundedReader#BACKLOG_UNKNOWN}. When currently processed record is not
-   * further behind than {@link #upToDateThreshold} then this method returns 0.
+   * Returns total size of all records that remain in Kinesis stream. The size is estimated taking
+   * into account size of the records that were added to the stream after timestamp of the most
+   * recent record returned by the reader. If no records have yet been retrieved from the reader
+   * {@link UnboundedSource.UnboundedReader#BACKLOG_UNKNOWN} is returned. When currently processed
+   * record is not further behind than {@link #upToDateThreshold} then this method returns 0.
+   *
+   * <p>The method can over-estimate size of the records for the split as it reports the backlog
+   * across all shards. This can lead to unnecessary decisions to scale up the number of workers but
+   * will never fail to scale up when this is necessary due to backlog size.
+   *
+   * @see <a href="https://issues.apache.org/jira/browse/BEAM-9439">BEAM-9439</a>
    */
   @Override
-  public long getTotalBacklogBytes() {
-    Instant watermark = getWatermark();
+  public long getSplitBacklogBytes() {
+    Instant latestRecordTimestamp = shardReadersPool.getLatestRecordTimestamp();
 
-    if (watermark.equals(BoundedWindow.TIMESTAMP_MIN_VALUE)) {
+    if (latestRecordTimestamp.equals(BoundedWindow.TIMESTAMP_MIN_VALUE)) {
+      LOG.debug("Split backlog bytes for stream {} unknown", source.getStreamName());
       return UnboundedSource.UnboundedReader.BACKLOG_UNKNOWN;
     }
 
-    if (watermark.plus(upToDateThreshold).isAfterNow()) {
+    if (latestRecordTimestamp.plus(upToDateThreshold).isAfterNow()) {
+      LOG.debug(
+          "Split backlog bytes for stream {} with latest record timestamp {}: 0 (latest record timestamp is up-to-date with threshold of {})",
+          source.getStreamName(),
+          latestRecordTimestamp,
+          upToDateThreshold);
       return 0L;
     }
+
     if (backlogBytesLastCheckTime.plus(backlogBytesCheckThreshold).isAfterNow()) {
+      LOG.debug(
+          "Split backlog bytes for {} stream with latest record timestamp {}: {} (cached value)",
+          source.getStreamName(),
+          latestRecordTimestamp,
+          lastBacklogBytes);
       return lastBacklogBytes;
     }
+
     try {
-      lastBacklogBytes = kinesis.getBacklogBytes(source.getStreamName(), watermark);
+      lastBacklogBytes = kinesis.getBacklogBytes(source.getStreamName(), latestRecordTimestamp);
       backlogBytesLastCheckTime = Instant.now();
     } catch (TransientKinesisException e) {
-      LOG.warn("Transient exception occurred.", e);
+      LOG.warn(
+          "Transient exception occurred during backlog estimation for stream {}.",
+          source.getStreamName(),
+          e);
     }
     LOG.info(
-        "Total backlog bytes for {} stream with {} watermark: {}",
+        "Split backlog bytes for {} stream with {} latest record timestamp: {}",
         source.getStreamName(),
-        watermark,
+        latestRecordTimestamp,
         lastBacklogBytes);
     return lastBacklogBytes;
   }
diff --git a/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardReadersPool.java b/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardReadersPool.java
index 827ab46458b..07f078fa461 100644
--- a/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardReadersPool.java
+++ b/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardReadersPool.java
@@ -31,6 +31,7 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;
@@ -52,14 +53,14 @@ class ShardReadersPool {
 
   /**
    * Executor service for running the threads that read records from shards handled by this pool.
-   * Each thread runs the {@link ShardReadersPool#readLoop(ShardRecordsIterator)} method and handles
-   * exactly one shard.
+   * Each thread runs the {@link ShardReadersPool#readLoop(ShardRecordsIterator, RateLimitPolicy)}
+   * method and handles exactly one shard.
    */
   private final ExecutorService executorService;
 
   /**
    * A Bounded buffer for read records. Records are added to this buffer within {@link
-   * ShardReadersPool#readLoop(ShardRecordsIterator)} method and removed in {@link
+   * ShardReadersPool#readLoop(ShardRecordsIterator, RateLimitPolicy)} method and removed in {@link
    * ShardReadersPool#nextRecord()}.
    */
   private BlockingQueue<KinesisRecord> recordsQueue;
@@ -228,8 +229,16 @@ class ShardReadersPool {
   }
 
   Instant getWatermark() {
+    return getMinTimestamp(ShardRecordsIterator::getShardWatermark);
+  }
+
+  Instant getLatestRecordTimestamp() {
+    return getMinTimestamp(ShardRecordsIterator::getLatestRecordTimestamp);
+  }
+
+  private Instant getMinTimestamp(Function<ShardRecordsIterator, Instant> timestampExtractor) {
     return shardIteratorsMap.get().values().stream()
-        .map(ShardRecordsIterator::getShardWatermark)
+        .map(timestampExtractor)
         .min(Comparator.naturalOrder())
         .orElse(BoundedWindow.TIMESTAMP_MAX_VALUE);
   }
diff --git a/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardRecordsIterator.java b/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardRecordsIterator.java
index ef219dc1c70..7c08c0df32b 100644
--- a/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardRecordsIterator.java
+++ b/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardRecordsIterator.java
@@ -24,7 +24,6 @@ import com.amazonaws.services.kinesis.model.ExpiredIteratorException;
 import com.amazonaws.services.kinesis.model.Shard;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import org.joda.time.Instant;
 import org.slf4j.Logger;
@@ -43,14 +42,15 @@ class ShardRecordsIterator {
   private final RecordFilter filter;
   private final String streamName;
   private final String shardId;
-  private AtomicReference<ShardCheckpoint> checkpoint;
+  private final AtomicReference<ShardCheckpoint> checkpoint;
+  private final WatermarkPolicy watermarkPolicy;
+  private final WatermarkPolicyFactory watermarkPolicyFactory;
+  private final WatermarkPolicy latestRecordTimestampPolicy =
+      WatermarkPolicyFactory.withArrivalTimePolicy().createWatermarkPolicy();
   private String shardIterator;
-  private AtomicLong millisBehindLatest = new AtomicLong(Long.MAX_VALUE);
-  private AtomicReference<WatermarkPolicy> watermarkPolicy;
-  private WatermarkPolicyFactory watermarkPolicyFactory;
 
   ShardRecordsIterator(
-      final ShardCheckpoint initialCheckpoint,
+      ShardCheckpoint initialCheckpoint,
       SimplifiedKinesisClient simplifiedKinesisClient,
       WatermarkPolicyFactory watermarkPolicyFactory)
       throws TransientKinesisException {
@@ -58,7 +58,7 @@ class ShardRecordsIterator {
   }
 
   ShardRecordsIterator(
-      final ShardCheckpoint initialCheckpoint,
+      ShardCheckpoint initialCheckpoint,
       SimplifiedKinesisClient simplifiedKinesisClient,
       WatermarkPolicyFactory watermarkPolicyFactory,
       RecordFilter filter)
@@ -69,7 +69,7 @@ class ShardRecordsIterator {
     this.streamName = initialCheckpoint.getStreamName();
     this.shardId = initialCheckpoint.getShardId();
     this.shardIterator = initialCheckpoint.getShardIterator(kinesis);
-    this.watermarkPolicy = new AtomicReference<>(watermarkPolicyFactory.createWatermarkPolicy());
+    this.watermarkPolicy = watermarkPolicyFactory.createWatermarkPolicy();
     this.watermarkPolicyFactory = watermarkPolicyFactory;
   }
 
@@ -82,10 +82,13 @@ class ShardRecordsIterator {
               streamName, shardId));
     }
     GetKinesisRecordsResult response = fetchRecords();
-    LOG.debug("Fetched {} new records", response.getRecords().size());
+    LOG.debug(
+        "Fetched {} new records from shard: streamName={}, shardId={}",
+        response.getRecords().size(),
+        streamName,
+        shardId);
 
     List<KinesisRecord> filteredRecords = filter.apply(response.getRecords(), checkpoint.get());
-    millisBehindLatest.set(response.getMillisBehindLatest());
     return filteredRecords;
   }
 
@@ -95,7 +98,11 @@ class ShardRecordsIterator {
       shardIterator = response.getNextShardIterator();
       return response;
     } catch (ExpiredIteratorException e) {
-      LOG.info("Refreshing expired iterator", e);
+      LOG.info(
+          "Refreshing expired iterator for shard: streamName={}, shardId={}",
+          streamName,
+          shardId,
+          e);
       shardIterator = checkpoint.get().getShardIterator(kinesis);
       return fetchRecords();
     }
@@ -107,11 +114,16 @@ class ShardRecordsIterator {
 
   void ackRecord(KinesisRecord record) {
     checkpoint.set(checkpoint.get().moveAfter(record));
-    watermarkPolicy.get().update(record);
+    watermarkPolicy.update(record);
+    latestRecordTimestampPolicy.update(record);
   }
 
   Instant getShardWatermark() {
-    return watermarkPolicy.get().getWatermark();
+    return watermarkPolicy.getWatermark();
+  }
+
+  Instant getLatestRecordTimestamp() {
+    return latestRecordTimestampPolicy.getWatermark();
   }
 
   String getShardId() {
diff --git a/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/KinesisReaderTest.java b/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/KinesisReaderTest.java
index 812a598a154..64f0fe7c653 100644
--- a/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/KinesisReaderTest.java
+++ b/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/KinesisReaderTest.java
@@ -19,9 +19,8 @@ package org.apache.beam.sdk.io.kinesis;
 
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doReturn;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 
@@ -136,50 +135,50 @@ public class KinesisReaderTest {
   }
 
   @Test
-  public void getTotalBacklogBytesShouldReturnLastSeenValueWhenKinesisExceptionsOccur()
+  public void getSplitBacklogBytesShouldReturnLastSeenValueWhenKinesisExceptionsOccur()
       throws TransientKinesisException, IOException {
     reader.start();
     when(kinesisSource.getStreamName()).thenReturn("stream1");
-    doReturn(Instant.now().minus(Duration.standardMinutes(1))).when(reader).getWatermark();
+    when(shardReadersPool.getLatestRecordTimestamp())
+        .thenReturn(Instant.now().minus(Duration.standardMinutes(1)));
     when(kinesis.getBacklogBytes(eq("stream1"), any(Instant.class)))
         .thenReturn(10L)
         .thenThrow(TransientKinesisException.class)
         .thenReturn(20L);
 
-    assertThat(reader.getTotalBacklogBytes()).isEqualTo(10);
-    assertThat(reader.getTotalBacklogBytes()).isEqualTo(10);
-    assertThat(reader.getTotalBacklogBytes()).isEqualTo(20);
+    assertThat(reader.getSplitBacklogBytes()).isEqualTo(10);
+    assertThat(reader.getSplitBacklogBytes()).isEqualTo(10);
+    assertThat(reader.getSplitBacklogBytes()).isEqualTo(20);
   }
 
   @Test
-  public void getTotalBacklogBytesShouldReturnLastSeenValueWhenCalledFrequently()
+  public void getSplitBacklogBytesShouldReturnLastSeenValueWhenCalledFrequently()
       throws TransientKinesisException, IOException {
     KinesisReader backlogCachingReader = spy(createReader(Duration.standardSeconds(30)));
     backlogCachingReader.start();
-    doReturn(Instant.now().minus(Duration.standardMinutes(1)))
-        .when(backlogCachingReader)
-        .getWatermark();
+    when(shardReadersPool.getLatestRecordTimestamp())
+        .thenReturn(Instant.now().minus(Duration.standardMinutes(1)));
     when(kinesisSource.getStreamName()).thenReturn("stream1");
     when(kinesis.getBacklogBytes(eq("stream1"), any(Instant.class)))
         .thenReturn(10L)
         .thenReturn(20L);
 
-    assertThat(backlogCachingReader.getTotalBacklogBytes()).isEqualTo(10);
-    assertThat(backlogCachingReader.getTotalBacklogBytes()).isEqualTo(10);
+    assertThat(backlogCachingReader.getSplitBacklogBytes()).isEqualTo(10);
+    assertThat(backlogCachingReader.getSplitBacklogBytes()).isEqualTo(10);
   }
 
   @Test
-  public void getTotalBacklogBytesShouldReturnBacklogUnknown()
+  public void getSplitBacklogBytesShouldReturnBacklogUnknown()
       throws IOException, TransientKinesisException {
     reader.start();
     when(kinesisSource.getStreamName()).thenReturn("stream1");
-    when(reader.getWatermark())
+    when(shardReadersPool.getLatestRecordTimestamp())
         .thenReturn(BoundedWindow.TIMESTAMP_MIN_VALUE)
         .thenReturn(Instant.now().minus(Duration.standardMinutes(1)));
     when(kinesis.getBacklogBytes(eq("stream1"), any(Instant.class))).thenReturn(10L);
 
-    assertThat(reader.getTotalBacklogBytes())
+    assertThat(reader.getSplitBacklogBytes())
         .isEqualTo(UnboundedSource.UnboundedReader.BACKLOG_UNKNOWN);
-    assertThat(reader.getTotalBacklogBytes()).isEqualTo(10);
+    assertThat(reader.getSplitBacklogBytes()).isEqualTo(10);
   }
 }
diff --git a/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java b/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java
index ed99a2a39b8..3cd87bdfc39 100644
--- a/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java
+++ b/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java
@@ -19,9 +19,9 @@ package org.apache.beam.sdk.io.kinesis;
 
 import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.same;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.ArgumentMatchers.same;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.timeout;
 import static org.mockito.Mockito.times;
@@ -59,7 +59,6 @@ public class ShardReadersPoolTest {
   @Mock private RateLimitPolicyFactory rateLimitPolicyFactory;
   @Mock private RateLimitPolicy customRateLimitPolicy;
 
-  private KinesisReaderCheckpoint checkpoint;
   private ShardReadersPool shardReadersPool;
   private final Instant now = Instant.now();
 
@@ -82,7 +81,8 @@ public class ShardReadersPoolTest {
         WatermarkPolicyFactory.withArrivalTimePolicy().createWatermarkPolicy();
     RateLimitPolicy rateLimitPolicy = RateLimitPolicyFactory.withoutLimiter().getRateLimitPolicy();
 
-    checkpoint = new KinesisReaderCheckpoint(ImmutableList.of(firstCheckpoint, secondCheckpoint));
+    KinesisReaderCheckpoint checkpoint =
+        new KinesisReaderCheckpoint(ImmutableList.of(firstCheckpoint, secondCheckpoint));
     shardReadersPool =
         Mockito.spy(
             new ShardReadersPool(
@@ -300,6 +300,24 @@ public class ShardReadersPoolTest {
     verify(secondIterator, times(2)).getShardWatermark();
   }
 
+  @Test
+  public void shouldReturnTheOldestFromLatestRecordTimestampOfAllShards()
+      throws TransientKinesisException {
+    Instant threeMin = now.minus(Duration.standardMinutes(3));
+    Instant twoMin = now.minus(Duration.standardMinutes(2));
+
+    when(firstIterator.getLatestRecordTimestamp()).thenReturn(threeMin).thenReturn(now);
+    when(secondIterator.getLatestRecordTimestamp()).thenReturn(twoMin);
+
+    shardReadersPool.start();
+
+    assertThat(shardReadersPool.getLatestRecordTimestamp()).isEqualTo(threeMin);
+    assertThat(shardReadersPool.getLatestRecordTimestamp()).isEqualTo(twoMin);
+
+    verify(firstIterator, times(2)).getLatestRecordTimestamp();
+    verify(secondIterator, times(2)).getLatestRecordTimestamp();
+  }
+
   @Test
   public void shouldCallRateLimitPolicy()
       throws TransientKinesisException, KinesisShardClosedException, InterruptedException {
diff --git a/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardRecordsIteratorTest.java b/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardRecordsIteratorTest.java
index 38aedb83da6..397dc9831a9 100644
--- a/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardRecordsIteratorTest.java
+++ b/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardRecordsIteratorTest.java
@@ -20,8 +20,8 @@ package org.apache.beam.sdk.io.kinesis;
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyListOf;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyList;
 import static org.mockito.Mockito.when;
 
 import com.amazonaws.services.kinesis.model.ExpiredIteratorException;
@@ -88,7 +88,7 @@ public class ShardRecordsIteratorTest {
     when(secondResult.getRecords()).thenReturn(Collections.emptyList());
     when(thirdResult.getRecords()).thenReturn(Collections.emptyList());
 
-    when(recordFilter.apply(anyListOf(KinesisRecord.class), any(ShardCheckpoint.class)))
+    when(recordFilter.apply(anyList(), any(ShardCheckpoint.class)))
         .thenAnswer(new IdentityAnswer());
 
     WatermarkPolicyFactory watermarkPolicyFactory = WatermarkPolicyFactory.withArrivalTimePolicy();
@@ -152,6 +152,30 @@ public class ShardRecordsIteratorTest {
     assertThat(iterator.readNextBatch()).isEqualTo(Collections.emptyList());
   }
 
+  @Test
+  public void tracksLatestRecordTimestamp() {
+    when(firstResult.getRecords()).thenReturn(singletonList(a));
+    when(secondResult.getRecords()).thenReturn(asList(b, c));
+    when(thirdResult.getRecords()).thenReturn(singletonList(c));
+
+    when(a.getApproximateArrivalTimestamp()).thenReturn(NOW);
+    when(b.getApproximateArrivalTimestamp()).thenReturn(NOW.plus(Duration.standardSeconds(4)));
+    when(c.getApproximateArrivalTimestamp()).thenReturn(NOW.plus(Duration.standardSeconds(2)));
+    when(d.getApproximateArrivalTimestamp()).thenReturn(NOW.plus(Duration.standardSeconds(6)));
+
+    iterator.ackRecord(a);
+    assertThat(iterator.getLatestRecordTimestamp()).isEqualTo(NOW);
+    iterator.ackRecord(b);
+    assertThat(iterator.getLatestRecordTimestamp())
+        .isEqualTo(NOW.plus(Duration.standardSeconds(4)));
+    iterator.ackRecord(c);
+    assertThat(iterator.getLatestRecordTimestamp())
+        .isEqualTo(NOW.plus(Duration.standardSeconds(4)));
+    iterator.ackRecord(d);
+    assertThat(iterator.getLatestRecordTimestamp())
+        .isEqualTo(NOW.plus(Duration.standardSeconds(6)));
+  }
+
   private static class IdentityAnswer implements Answer<Object> {
 
     @Override
