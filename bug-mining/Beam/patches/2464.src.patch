diff --git a/sdks/go/pkg/beam/core/runtime/exec/sdf.go b/sdks/go/pkg/beam/core/runtime/exec/sdf.go
index a0c9b727582..78fdb99cfb9 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/sdf.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/sdf.go
@@ -179,6 +179,10 @@ func (n *SplitAndSizeRestrictions) ProcessElement(ctx context.Context, elm *Full
 
 	for _, splitRest := range splitRests {
 		size := n.sizeInv.Invoke(mainElm, splitRest)
+		if size < 0 {
+			err := errors.Errorf("size returned expected to be non-negative but received %v.", size)
+			return errors.WithContextf(err, "%v", n)
+		}
 		output := &FullValue{}
 
 		output.Timestamp = elm.Timestamp
@@ -475,8 +479,14 @@ func (n *ProcessSizedElementsAndRestrictions) singleWindowSplit(f float64) ([]*F
 		return []*FullValue{}, []*FullValue{}, nil
 	}
 
-	pfv := n.newSplitResult(p, n.elm.Windows)
-	rfv := n.newSplitResult(r, n.elm.Windows)
+	pfv, err := n.newSplitResult(p, n.elm.Windows)
+	if err != nil {
+		return nil, nil, err
+	}
+	rfv, err := n.newSplitResult(r, n.elm.Windows)
+	if err != nil {
+		return nil, nil, err
+	}
 	return []*FullValue{pfv}, []*FullValue{rfv}, nil
 }
 
@@ -548,16 +558,32 @@ func (n *ProcessSizedElementsAndRestrictions) currentWindowSplit(f float64) ([]*
 
 	// Split of currently processing restriction in a single window.
 	ps := make([]*FullValue, 1)
-	ps[0] = n.newSplitResult(p, n.elm.Windows[n.currW:n.currW+1])
+	newP, err := n.newSplitResult(p, n.elm.Windows[n.currW:n.currW+1])
+	if err != nil {
+		return nil, nil, err
+	}
+	ps[0] = newP
 	rs := make([]*FullValue, 1)
-	rs[0] = n.newSplitResult(r, n.elm.Windows[n.currW:n.currW+1])
+	newR, err := n.newSplitResult(r, n.elm.Windows[n.currW:n.currW+1])
+	if err != nil {
+		return nil, nil, err
+	}
+	rs[0] = newR
 	// Window boundary split surrounding the split restriction above.
 	full := n.elm.Elm.(*FullValue).Elm2
 	if 0 < n.currW {
-		ps = append(ps, n.newSplitResult(full, n.elm.Windows[0:n.currW]))
+		newP, err := n.newSplitResult(full, n.elm.Windows[0:n.currW])
+		if err != nil {
+			return nil, nil, err
+		}
+		ps = append(ps, newP)
 	}
 	if n.currW+1 < n.numW {
-		rs = append(rs, n.newSplitResult(full, n.elm.Windows[n.currW+1:n.numW]))
+		newR, err := n.newSplitResult(full, n.elm.Windows[n.currW+1:n.numW])
+		if err != nil {
+			return nil, nil, err
+		}
+		rs = append(rs, newR)
 	}
 	n.numW = n.currW + 1
 	return ps, rs, nil
@@ -572,8 +598,14 @@ func (n *ProcessSizedElementsAndRestrictions) windowBoundarySplit(splitPt int) (
 		return []*FullValue{}, []*FullValue{}, nil
 	}
 	full := n.elm.Elm.(*FullValue).Elm2
-	pFv := n.newSplitResult(full, n.elm.Windows[0:splitPt])
-	rFv := n.newSplitResult(full, n.elm.Windows[splitPt:n.numW])
+	pFv, err := n.newSplitResult(full, n.elm.Windows[0:splitPt])
+	if err != nil {
+		return nil, nil, err
+	}
+	rFv, err := n.newSplitResult(full, n.elm.Windows[splitPt:n.numW])
+	if err != nil {
+		return nil, nil, err
+	}
 	n.numW = splitPt
 	return []*FullValue{pFv}, []*FullValue{rFv}, nil
 }
@@ -582,14 +614,22 @@ func (n *ProcessSizedElementsAndRestrictions) windowBoundarySplit(splitPt int) (
 // element restriction pair based on the currently processing element, but with
 // a modified restriction and windows. Intended for creating primaries and
 // residuals to return as split results.
-func (n *ProcessSizedElementsAndRestrictions) newSplitResult(rest interface{}, w []typex.Window) *FullValue {
+func (n *ProcessSizedElementsAndRestrictions) newSplitResult(rest interface{}, w []typex.Window) (*FullValue, error) {
 	var size float64
 	elm := n.elm.Elm.(*FullValue).Elm
 	if fv, ok := elm.(*FullValue); ok {
 		size = n.sizeInv.Invoke(fv, rest)
+		if size < 0 {
+			err := errors.Errorf("size returned expected to be non-negative but received %v.", size)
+			return nil, errors.WithContextf(err, "%v", n)
+		}
 	} else {
 		fv := &FullValue{Elm: elm}
 		size = n.sizeInv.Invoke(fv, rest)
+		if size < 0 {
+			err := errors.Errorf("size returned expected to be non-negative but received %v.", size)
+			return nil, errors.WithContextf(err, "%v", n)
+		}
 	}
 	return &FullValue{
 		Elm: &FullValue{
@@ -599,7 +639,7 @@ func (n *ProcessSizedElementsAndRestrictions) newSplitResult(rest interface{}, w
 		Elm2:      size,
 		Timestamp: n.elm.Timestamp,
 		Windows:   w,
-	}
+	}, nil
 }
 
 // GetProgress returns the current restriction tracker's progress as a fraction.
diff --git a/sdks/go/pkg/beam/core/runtime/exec/sdf_test.go b/sdks/go/pkg/beam/core/runtime/exec/sdf_test.go
index 9bf3332319c..86b29acdef1 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/sdf_test.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/sdf_test.go
@@ -17,6 +17,7 @@ package exec
 
 import (
 	"context"
+	"strings"
 	"testing"
 
 	"github.com/apache/beam/sdks/go/pkg/beam/core/graph"
@@ -247,6 +248,56 @@ func TestSdfNodes(t *testing.T) {
 		}
 	})
 
+	// Validate SplitAndSizeRestrictions matches its contract and properly
+	// invokes SDF methods SplitRestriction and RestrictionSize.
+	t.Run("InvalidSplitAndSizeRestrictions", func(t *testing.T) {
+		idfn, err := graph.NewDoFn(&NegativeSizeSdf{rest: offsetrange.Restriction{Start: 0, End: 4}}, graph.NumMainInputs(graph.MainSingle))
+		if err != nil {
+			t.Fatalf("invalid function: %v", err)
+		}
+		tests := []struct {
+			name string
+			fn   *graph.DoFn
+			in   FullValue
+		}{
+			{
+				name: "InvalidSplit",
+				fn:   idfn,
+				in: FullValue{
+					Elm: &FullValue{
+						Elm:       1,
+						Elm2:      nil,
+						Timestamp: testTimestamp,
+						Windows:   testWindows,
+					},
+					Elm2:      offsetrange.Restriction{Start: 0, End: 4},
+					Timestamp: testTimestamp,
+					Windows:   testWindows,
+				},
+			},
+		}
+		for _, test := range tests {
+			test := test
+			t.Run(test.name, func(t *testing.T) {
+				capt := &CaptureNode{UID: 2}
+				node := &SplitAndSizeRestrictions{UID: 1, Fn: test.fn, Out: capt}
+				root := &FixedRoot{UID: 0, Elements: []MainInput{{Key: test.in}}, Out: node}
+				units := []Unit{root, node, capt}
+				p, err := NewPlan("a", units)
+				if err != nil {
+					t.Fatalf("failed to construct plan: %v", err)
+				}
+				err = p.Execute(context.Background(), "1", DataContext{})
+				if err == nil {
+					t.Errorf("execution was expected to fail.")
+				}
+				if !strings.Contains(err.Error(), "size returned expected to be non-negative but received") {
+					t.Errorf("SplitAndSizeRestrictions(%v) failed, got: %v, wanted: 'size returned expected to be non-negative but received'.", test.in, err)
+				}
+			})
+		}
+	})
+
 	// Validate ProcessSizedElementsAndRestrictions matches its contract and
 	// properly invokes SDF methods CreateTracker and ProcessElement.
 	t.Run("ProcessSizedElementsAndRestrictions", func(t *testing.T) {
@@ -410,6 +461,14 @@ func TestAsSplittableUnit(t *testing.T) {
 	if err != nil {
 		t.Fatalf("invalid function: %v", err)
 	}
+	pdfn, err := graph.NewDoFn(&NegativeSizeSdf{rest: offsetrange.Restriction{Start: 0, End: 2}}, graph.NumMainInputs(graph.MainSingle))
+	if err != nil {
+		t.Fatalf("invalid function: %v", err)
+	}
+	rdfn, err := graph.NewDoFn(&NegativeSizeSdf{rest: offsetrange.Restriction{Start: 2, End: 4}}, graph.NumMainInputs(graph.MainSingle))
+	if err != nil {
+		t.Fatalf("invalid function: %v", err)
+	}
 	multiWindows := []typex.Window{
 		window.IntervalWindow{Start: 10, End: 20},
 		window.IntervalWindow{Start: 11, End: 21},
@@ -752,6 +811,67 @@ func TestAsSplittableUnit(t *testing.T) {
 			})
 		}
 	})
+
+	// Test that Split properly validates the results and returns an error if invalid
+	t.Run("InvalidSplitSize", func(t *testing.T) {
+		tests := []struct {
+			name string
+			fn   *graph.DoFn
+			in   FullValue
+		}{
+			{
+				name: "Primary",
+				fn:   pdfn,
+				in: FullValue{
+					Elm: &FullValue{
+						Elm:  1,
+						Elm2: &offsetrange.Restriction{Start: 0, End: 4},
+					},
+					Elm2:      1.0,
+					Timestamp: testTimestamp,
+					Windows:   testWindows,
+				},
+			},
+			{
+				name: "Residual",
+				fn:   rdfn,
+				in: FullValue{
+					Elm: &FullValue{
+						Elm:  1,
+						Elm2: &offsetrange.Restriction{Start: 0, End: 4},
+					},
+					Elm2:      1.0,
+					Timestamp: testTimestamp,
+					Windows:   testWindows,
+				},
+			},
+		}
+		for _, test := range tests {
+			test := test
+			t.Run(test.name, func(t *testing.T) {
+				// Setup, create transforms, inputs, and desired outputs.
+				n := &ParDo{UID: 1, Fn: test.fn, Out: []Node{}}
+				node := &ProcessSizedElementsAndRestrictions{PDo: n}
+				node.rt = sdf.RTracker(offsetrange.NewTracker(*test.in.Elm.(*FullValue).Elm2.(*offsetrange.Restriction)))
+				node.elm = &test.in
+				node.numW = len(test.in.Windows)
+				node.currW = 0
+
+				// Call from SplittableUnit and check results.
+				su := SplittableUnit(node)
+				if err := node.Up(context.Background()); err != nil {
+					t.Fatalf("ProcessSizedElementsAndRestrictions.Up() failed: %v", err)
+				}
+				_, _, err := su.Split(0.5)
+				if err == nil {
+					t.Errorf("SplittableUnit.Split(%v) was expected to fail.", test.in)
+				}
+				if !strings.Contains(err.Error(), "size returned expected to be non-negative but received") {
+					t.Errorf("SplittableUnit.Split(%v) failed, got: %v, wanted: 'size returned expected to be non-negative but received'.", test.in, err)
+				}
+			})
+		}
+	})
 }
 
 // TestMultiWindowProcessing tests that ProcessSizedElementsAndRestrictions
@@ -856,6 +976,44 @@ func TestMultiWindowProcessing(t *testing.T) {
 	}
 }
 
+// NegativeSizeSdf is a very basic SDF that returns a negative restriction size
+// if the passed in restriction matches otherwise it uses offsetrange.Restriction's default size.
+type NegativeSizeSdf struct {
+	rest offsetrange.Restriction
+}
+
+// CreateInitialRestriction creates a four-element offset range.
+func (fn *NegativeSizeSdf) CreateInitialRestriction(_ int) offsetrange.Restriction {
+	return offsetrange.Restriction{Start: 0, End: 4}
+}
+
+// SplitRestriction is a no-op, and does not split.
+func (fn *NegativeSizeSdf) SplitRestriction(_ int, rest offsetrange.Restriction) []offsetrange.Restriction {
+	return []offsetrange.Restriction{rest}
+}
+
+// RestrictionSize returns the passed in size that should be used.
+func (fn *NegativeSizeSdf) RestrictionSize(_ int, rest offsetrange.Restriction) float64 {
+	if fn.rest == rest {
+		return -1
+	}
+	return rest.Size()
+}
+
+// CreateTracker creates a LockRTracker wrapping an offset range RTracker.
+func (fn *NegativeSizeSdf) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {
+	return offsetrange.NewTracker(rest)
+}
+
+// ProcessElement emits the element after consuming the entire restriction tracker.
+func (fn *NegativeSizeSdf) ProcessElement(rt *offsetrange.Tracker, elm int, emit func(int)) {
+	i := rt.GetRestriction().(offsetrange.Restriction).Start
+	for rt.TryClaim(i) {
+		i++
+	}
+	emit(elm)
+}
+
 // WindowBlockingSdf is a very basic SDF that blocks execution once, in one
 // window and at one position within the restriction.
 type WindowBlockingSdf struct {
diff --git a/sdks/go/pkg/beam/pardo.go b/sdks/go/pkg/beam/pardo.go
index ab2a8e8abf2..07130232e51 100644
--- a/sdks/go/pkg/beam/pardo.go
+++ b/sdks/go/pkg/beam/pardo.go
@@ -287,11 +287,11 @@ func ParDo0(s Scope, dofn interface{}, col PCollection, opts ...Option) {
 //     called on each newly created restriction before they are processed.
 // * `RestrictionSize(elem, restriction) float64`
 //     RestrictionSize returns a cheap size estimation for a restriction. This
-//     size is an abstract scalar value that represents how much work a
-//     restriction takes compared to other restrictions in the same DoFn. For
-//     example, a size of 200 represents twice as much work as a size of
+//     size is an abstract non-negative scalar value that represents how much
+//     work a restriction takes compared to other restrictions in the same DoFn.
+//     For example, a size of 200 represents twice as much work as a size of
 //     100, but the numbers do not represent anything on their own. Size is
-//     used by runners to estimate work for liquid sharding.
+//     used by runners to estimate work for dynamic work rebalancing.
 // * `CreateTracker(restriction) restrictionTracker`
 //     CreateTracker creates and returns a restriction tracker (a concrete type
 //     implementing the `sdf.RTracker` interface) given a restriction. The
