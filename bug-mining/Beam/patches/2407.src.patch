diff --git a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/SchemaTranslationTest.java b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/SchemaTranslationTest.java
index c325b6f451f..3b083f6bacf 100644
--- a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/SchemaTranslationTest.java
+++ b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/SchemaTranslationTest.java
@@ -25,6 +25,12 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import org.apache.beam.model.pipeline.v1.SchemaApi;
+import org.apache.beam.model.pipeline.v1.SchemaApi.ArrayType;
+import org.apache.beam.model.pipeline.v1.SchemaApi.ArrayTypeValue;
+import org.apache.beam.model.pipeline.v1.SchemaApi.AtomicType;
+import org.apache.beam.model.pipeline.v1.SchemaApi.AtomicTypeValue;
+import org.apache.beam.model.pipeline.v1.SchemaApi.FieldValue;
+import org.apache.beam.model.pipeline.v1.SchemaApi.LogicalType;
 import org.apache.beam.sdk.schemas.Schema;
 import org.apache.beam.sdk.schemas.Schema.Field;
 import org.apache.beam.sdk.schemas.Schema.FieldType;
@@ -32,6 +38,8 @@ import org.apache.beam.sdk.schemas.SchemaTranslation;
 import org.apache.beam.sdk.schemas.logicaltypes.FixedBytes;
 import org.apache.beam.sdk.schemas.logicaltypes.MicrosInstant;
 import org.apache.beam.sdk.values.Row;
+import org.apache.beam.vendor.grpc.v1p36p0.com.google.protobuf.ByteString;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Charsets;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.junit.Test;
 import org.junit.experimental.runners.Enclosed;
@@ -174,4 +182,106 @@ public class SchemaTranslationTest {
       assertThat(decodedSchema, equalTo(schema));
     }
   }
+
+  /** Tests round-trip proto encodings for {@link Schema}. */
+  @RunWith(Parameterized.class)
+  public static class FromProtoToProtoTest {
+    @Parameters(name = "{index}: {0}")
+    public static Iterable<SchemaApi.Schema> data() {
+      SchemaApi.Schema.Builder builder = SchemaApi.Schema.newBuilder();
+      // A go 'int'
+      builder.addFields(
+          SchemaApi.Field.newBuilder()
+              .setName("goInt")
+              .setDescription("An int from go")
+              .setType(
+                  SchemaApi.FieldType.newBuilder()
+                      .setLogicalType(
+                          SchemaApi.LogicalType.newBuilder()
+                              .setUrn("gosdk:int")
+                              .setRepresentation(
+                                  SchemaApi.FieldType.newBuilder()
+                                      .setAtomicType(SchemaApi.AtomicType.INT64))
+                              .build()))
+              .setId(0)
+              .setEncodingPosition(0)
+              .build());
+      // A pickled python object
+      builder.addFields(
+          SchemaApi.Field.newBuilder()
+              .setName("pythonObject")
+              .setType(
+                  SchemaApi.FieldType.newBuilder()
+                      .setLogicalType(
+                          SchemaApi.LogicalType.newBuilder()
+                              .setUrn("pythonsdk:value")
+                              .setPayload(
+                                  ByteString.copyFrom(
+                                      "some payload describing a python type", Charsets.UTF_8))
+                              .setRepresentation(
+                                  SchemaApi.FieldType.newBuilder()
+                                      .setAtomicType(SchemaApi.AtomicType.BYTES))
+                              .build()))
+              .setId(1)
+              .setEncodingPosition(1)
+              .build());
+      // An enum logical type that Java doesn't know about
+      builder.addFields(
+          SchemaApi.Field.newBuilder()
+              .setName("enum")
+              .setType(
+                  SchemaApi.FieldType.newBuilder()
+                      .setLogicalType(
+                          LogicalType.newBuilder()
+                              .setUrn("strange_enum")
+                              .setArgumentType(
+                                  SchemaApi.FieldType.newBuilder()
+                                      .setArrayType(
+                                          ArrayType.newBuilder()
+                                              .setElementType(
+                                                  SchemaApi.FieldType.newBuilder()
+                                                      .setAtomicType(AtomicType.STRING))))
+                              .setArgument(
+                                  FieldValue.newBuilder()
+                                      .setArrayValue(
+                                          ArrayTypeValue.newBuilder()
+                                              .addElement(
+                                                  FieldValue.newBuilder()
+                                                      .setAtomicValue(
+                                                          AtomicTypeValue.newBuilder()
+                                                              .setString("FOO")
+                                                              .build())
+                                                      .build())
+                                              .addElement(
+                                                  FieldValue.newBuilder()
+                                                      .setAtomicValue(
+                                                          AtomicTypeValue.newBuilder()
+                                                              .setString("BAR")
+                                                              .build())
+                                                      .build())
+                                              .build())
+                                      .build())
+                              .setRepresentation(
+                                  SchemaApi.FieldType.newBuilder().setAtomicType(AtomicType.BYTE))
+                              .build()))
+              .setId(2)
+              .setEncodingPosition(2)
+              .build());
+      SchemaApi.Schema unknownLogicalTypeSchema = builder.build();
+
+      return ImmutableList.<SchemaApi.Schema>builder().add(unknownLogicalTypeSchema).build();
+    }
+
+    @Parameter(0)
+    public SchemaApi.Schema schemaProto;
+
+    @Test
+    public void fromProtoAndToProto() throws Exception {
+      Schema decodedSchema = SchemaTranslation.schemaFromProto(schemaProto);
+
+      SchemaApi.Schema reencodedSchemaProto = SchemaTranslation.schemaToProto(decodedSchema, true);
+
+      assertThat(reencodedSchemaProto, equalTo(schemaProto));
+    }
+  }
 }
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaTranslation.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaTranslation.java
index 9e7051003d8..2215f3dc9f7 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaTranslation.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaTranslation.java
@@ -37,6 +37,7 @@ import org.apache.beam.sdk.schemas.Schema.FieldType;
 import org.apache.beam.sdk.schemas.Schema.LogicalType;
 import org.apache.beam.sdk.schemas.Schema.TypeName;
 import org.apache.beam.sdk.schemas.logicaltypes.MicrosInstant;
+import org.apache.beam.sdk.schemas.logicaltypes.UnknownLogicalType;
 import org.apache.beam.sdk.util.SerializableUtils;
 import org.apache.beam.sdk.values.Row;
 import org.apache.beam.vendor.grpc.v1p36p0.com.google.protobuf.ByteString;
@@ -44,6 +45,7 @@ import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditio
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Maps;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Utility methods for translating schemas. */
 @Experimental(Kind.SCHEMAS)
@@ -136,6 +138,21 @@ public class SchemaTranslation {
                   .setRepresentation(
                       fieldTypeToProto(logicalType.getBaseType(), serializeLogicalType))
                   .setUrn(logicalType.getIdentifier());
+        } else if (logicalType instanceof UnknownLogicalType) {
+          logicalTypeBuilder =
+              SchemaApi.LogicalType.newBuilder()
+                  .setUrn(logicalType.getIdentifier())
+                  .setPayload(ByteString.copyFrom(((UnknownLogicalType) logicalType).getPayload()))
+                  .setRepresentation(
+                      fieldTypeToProto(logicalType.getBaseType(), serializeLogicalType));
+
+          if (logicalType.getArgumentType() != null) {
+            logicalTypeBuilder
+                .setArgumentType(
+                    fieldTypeToProto(logicalType.getArgumentType(), serializeLogicalType))
+                .setArgument(
+                    fieldValueToProto(logicalType.getArgumentType(), logicalType.getArgument()));
+          }
         } else {
           logicalTypeBuilder =
               SchemaApi.LogicalType.newBuilder()
@@ -325,7 +342,20 @@ public class SchemaTranslation {
                   SerializableUtils.deserializeFromByteArray(
                       protoFieldType.getLogicalType().getPayload().toByteArray(), "logicalType"));
         } else {
-          throw new IllegalArgumentException("Encountered unsupported logical type URN: " + urn);
+          @Nullable FieldType argumentType = null;
+          @Nullable Object argumentValue = null;
+          if (protoFieldType.getLogicalType().hasArgumentType()) {
+            argumentType = fieldTypeFromProto(protoFieldType.getLogicalType().getArgumentType());
+            argumentValue =
+                fieldValueFromProto(argumentType, protoFieldType.getLogicalType().getArgument());
+          }
+          return FieldType.logicalType(
+              new UnknownLogicalType(
+                  urn,
+                  protoFieldType.getLogicalType().getPayload().toByteArray(),
+                  argumentType,
+                  argumentValue,
+                  fieldTypeFromProto(protoFieldType.getLogicalType().getRepresentation())));
         }
       default:
         throw new IllegalArgumentException(
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/logicaltypes/UnknownLogicalType.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/logicaltypes/UnknownLogicalType.java
new file mode 100644
index 00000000000..af19f8f33e5
--- /dev/null
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/logicaltypes/UnknownLogicalType.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.schemas.logicaltypes;
+
+import org.apache.beam.sdk.schemas.Schema.FieldType;
+
+/**
+ * A base class for logical types that are not understood by the Java SDK.
+ *
+ * <p>Unknown logical types are passed through and treated like their Base type in the Java SDK.
+ *
+ * <p>Java transforms and JVM runners should take care when processing these types as they may have
+ * a particular semantic meaning in the context that created them. For example, consider an
+ * enumerated type backed by a primitive {@class FieldType.INT8}. A Java transform can clearly pass
+ * through this value and pass it back to a context that understands it, but that transform should
+ * not blindly perform arithmetic on this type.
+ */
+public class UnknownLogicalType<T> extends PassThroughLogicalType<T> {
+  private byte[] payload;
+
+  public UnknownLogicalType(
+      String identifier,
+      byte[] payload,
+      FieldType argumentType,
+      Object argument,
+      FieldType fieldType) {
+    super(identifier, argumentType, argument, fieldType);
+    this.payload = payload;
+  }
+
+  public byte[] getPayload() {
+    return payload;
+  }
+}
