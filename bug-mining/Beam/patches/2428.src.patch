diff --git a/sdks/python/apache_beam/runners/interactive/background_caching_job.py b/sdks/python/apache_beam/runners/interactive/background_caching_job.py
index 88aae06cc82..c08c5d63730 100644
--- a/sdks/python/apache_beam/runners/interactive/background_caching_job.py
+++ b/sdks/python/apache_beam/runners/interactive/background_caching_job.py
@@ -230,11 +230,13 @@ def has_source_to_cache(user_pipeline):
                                                          create_if_absent=True),
                       streaming_cache.StreamingCache):
 
+      file_based_cm = ie.current_env().get_cache_manager(user_pipeline)
       ie.current_env().set_cache_manager(
           streaming_cache.StreamingCache(
-              ie.current_env().get_cache_manager(user_pipeline)._cache_dir,
+              file_based_cm._cache_dir,
               is_cache_complete=is_cache_complete,
-              sample_resolution_sec=1.0),
+              sample_resolution_sec=1.0,
+              saved_pcoders=file_based_cm._saved_pcoders),
           user_pipeline)
   return has_cache
 
diff --git a/sdks/python/apache_beam/runners/interactive/cache_manager.py b/sdks/python/apache_beam/runners/interactive/cache_manager.py
index 9287e3d0e65..932e45a32a1 100644
--- a/sdks/python/apache_beam/runners/interactive/cache_manager.py
+++ b/sdks/python/apache_beam/runners/interactive/cache_manager.py
@@ -207,9 +207,8 @@ class FileBasedCacheManager(CacheManager):
     self._saved_pcoders[self._path(*labels)] = pcoder
 
   def load_pcoder(self, *labels):
-    return (
-        self._default_pcoder if self._default_pcoder is not None else
-        self._saved_pcoders[self._path(*labels)])
+    saved_pcoder = self._saved_pcoders.get(self._path(*labels), None)
+    return (self._default_pcoder if saved_pcoder is None else saved_pcoder)
 
   def read(self, *labels, **args):
     # Return an iterator to an empty list if it doesn't exist.
diff --git a/sdks/python/apache_beam/runners/interactive/cache_manager_test.py b/sdks/python/apache_beam/runners/interactive/cache_manager_test.py
index bd2be765dd7..02a49746df4 100644
--- a/sdks/python/apache_beam/runners/interactive/cache_manager_test.py
+++ b/sdks/python/apache_beam/runners/interactive/cache_manager_test.py
@@ -23,6 +23,7 @@ import tempfile
 import time
 import unittest
 
+import apache_beam as beam
 from apache_beam import coders
 from apache_beam.io import filesystems
 from apache_beam.runners.interactive import cache_manager as cache
@@ -214,6 +215,14 @@ class FileBasedCacheManagerTest(object):
     self.assertTrue(
         self.cache_manager.is_latest_version(version, prefix, cache_label))
 
+  def test_load_saved_pcoder(self):
+    pipeline = beam.Pipeline()
+    pcoll = pipeline | beam.Create([1, 2, 3])
+    _ = pcoll | cache.WriteCache(self.cache_manager, 'a key')
+    self.assertIs(
+        type(self.cache_manager.load_pcoder('full', 'a key')),
+        type(coders.registry.get_coder(int)))
+
 
 class TextFileBasedCacheManagerTest(
     FileBasedCacheManagerTest,
diff --git a/sdks/python/apache_beam/runners/interactive/caching/streaming_cache.py b/sdks/python/apache_beam/runners/interactive/caching/streaming_cache.py
index 58cd0982612..f85464f6cc5 100644
--- a/sdks/python/apache_beam/runners/interactive/caching/streaming_cache.py
+++ b/sdks/python/apache_beam/runners/interactive/caching/streaming_cache.py
@@ -32,6 +32,7 @@ from pathlib import Path
 from google.protobuf.message import DecodeError
 
 import apache_beam as beam
+from apache_beam import coders
 from apache_beam.portability.api.beam_interactive_api_pb2 import TestStreamFileHeader
 from apache_beam.portability.api.beam_interactive_api_pb2 import TestStreamFileRecord
 from apache_beam.portability.api.beam_runner_api_pb2 import TestStreamPayload
@@ -238,7 +239,11 @@ class StreamingCache(CacheManager):
   """Abstraction that holds the logic for reading and writing to cache.
   """
   def __init__(
-      self, cache_dir, is_cache_complete=None, sample_resolution_sec=0.1):
+      self,
+      cache_dir,
+      is_cache_complete=None,
+      sample_resolution_sec=0.1,
+      saved_pcoders={}):
     self._sample_resolution_sec = sample_resolution_sec
     self._is_cache_complete = is_cache_complete
 
@@ -258,7 +263,7 @@ class StreamingCache(CacheManager):
     # However, if we are to implement better cache persistence, one needs
     # to take care of keeping consistency between the cached PCollection
     # and its PCoder type.
-    self._saved_pcoders = {}
+    self._saved_pcoders = saved_pcoders
     self._default_pcoder = SafeFastPrimitivesCoder()
 
     # The sinks to capture data from capturable sources.
@@ -298,7 +303,10 @@ class StreamingCache(CacheManager):
       return iter([]), -1
 
     reader = StreamingCacheSource(
-        self._cache_dir, labels, self._is_cache_complete).read(tail=tail)
+        self._cache_dir,
+        labels,
+        self._is_cache_complete,
+        self.load_pcoder(*labels)).read(tail=tail)
 
     # Return an empty iterator if there is nothing in the file yet. This can
     # only happen when tail is False.
@@ -316,9 +324,9 @@ class StreamingCache(CacheManager):
     pipeline runtime which needs to block.
     """
     readers = [
-        StreamingCacheSource(self._cache_dir, l,
-                             self._is_cache_complete).read(tail=tail)
-        for l in labels
+        StreamingCacheSource(
+            self._cache_dir, l, self._is_cache_complete,
+            self.load_pcoder(*l)).read(tail=tail) for l in labels
     ]
     headers = [next(r) for r in readers]
     return StreamingCache.Reader(headers, readers).read()
@@ -336,7 +344,8 @@ class StreamingCache(CacheManager):
           val = v.SerializeToString()
         else:
           val = v
-        f.write(self._default_pcoder.encode(val) + b'\n')
+          self.save_pcoder(coders.registry.get_coder(type(val)), *labels)
+        f.write(self.load_pcoder(*labels).encode(val) + b'\n')
 
   def clear(self, *labels):
     directory = os.path.join(self._cache_dir, *labels[:-1])
@@ -364,19 +373,23 @@ class StreamingCache(CacheManager):
     """
     filename = labels[-1]
     cache_dir = os.path.join(self._cache_dir, *labels[:-1])
-    sink = StreamingCacheSink(cache_dir, filename, self._sample_resolution_sec)
+    sink = StreamingCacheSink(
+        cache_dir,
+        filename,
+        self._sample_resolution_sec,
+        self.load_pcoder(*labels))
     if is_capture:
       self._capture_sinks[sink.path] = sink
       self._capture_keys.add(filename)
     return sink
 
   def save_pcoder(self, pcoder, *labels):
-    self._saved_pcoders[os.path.join(*labels)] = pcoder
+    self._saved_pcoders[os.path.join(self._cache_dir, *labels)] = pcoder
 
   def load_pcoder(self, *labels):
-    return (
-        self._default_pcoder if self._default_pcoder is not None else
-        self._saved_pcoders[os.path.join(*labels)])
+    saved_pcoder = self._saved_pcoders.get(
+        os.path.join(self._cache_dir, *labels), None)
+    return (self._default_pcoder if saved_pcoder is None else saved_pcoder)
 
   def cleanup(self):
 
diff --git a/sdks/python/apache_beam/runners/interactive/caching/streaming_cache_test.py b/sdks/python/apache_beam/runners/interactive/caching/streaming_cache_test.py
index 68e7fed24e7..522c2f6bcb8 100644
--- a/sdks/python/apache_beam/runners/interactive/caching/streaming_cache_test.py
+++ b/sdks/python/apache_beam/runners/interactive/caching/streaming_cache_test.py
@@ -17,14 +17,18 @@
 
 # pytype: skip-file
 
+import tempfile
 import unittest
 
+import apache_beam as beam
 from apache_beam import coders
 from apache_beam.options.pipeline_options import StandardOptions
 from apache_beam.portability.api.beam_interactive_api_pb2 import TestStreamFileHeader
 from apache_beam.portability.api.beam_interactive_api_pb2 import TestStreamFileRecord
 from apache_beam.portability.api.beam_runner_api_pb2 import TestStreamPayload
+from apache_beam.runners.interactive.cache_manager import FileBasedCacheManager
 from apache_beam.runners.interactive.cache_manager import SafeFastPrimitivesCoder
+from apache_beam.runners.interactive.cache_manager import WriteCache
 from apache_beam.runners.interactive.caching.cacheable import CacheKey
 from apache_beam.runners.interactive.caching.streaming_cache import StreamingCache
 from apache_beam.runners.interactive.testing.test_cache_manager import FileRecordsBuilder
@@ -427,6 +431,43 @@ class StreamingCacheTest(unittest.TestCase):
 
     self.assertListEqual(actual_events, expected_events)
 
+  def test_always_default_coder_for_test_stream_records(self):
+    CACHED_NUMBERS = repr(CacheKey('numbers', '', '', ''))
+    numbers = (FileRecordsBuilder(CACHED_NUMBERS)
+               .advance_processing_time(2)
+               .add_element(element=1, event_time_secs=0)
+               .advance_processing_time(1)
+               .add_element(element=2, event_time_secs=0)
+               .advance_processing_time(1)
+               .add_element(element=2, event_time_secs=0)
+               .build()) # yapf: disable
+    cache = StreamingCache(cache_dir=None)
+    cache.write(numbers, CACHED_NUMBERS)
+    self.assertIs(
+        type(cache.load_pcoder(CACHED_NUMBERS)), type(cache._default_pcoder))
+
+  def test_load_saved_coder_for_non_record_types(self):
+    cache = StreamingCache(cache_dir=None)
+    cache.write('some value', 'a key')
+    self.assertIs(
+        type(cache.load_pcoder('a key')), type(coders.registry.get_coder(str)))
+
+  def test_wrap_file_based_cache_respect_load_saved_coders(self):
+    file_based_cache = FileBasedCacheManager(tempfile.mkdtemp())
+    pipeline = beam.Pipeline()
+    pcoll = pipeline | beam.Create([1, 2, 3])
+    _ = pcoll | WriteCache(file_based_cache, 'a key')
+    self.assertIs(
+        type(file_based_cache.load_pcoder('full', 'a key')),
+        type(coders.registry.get_coder(int)))
+    streaming_cache = StreamingCache(
+        cache_dir=file_based_cache._cache_dir,
+        saved_pcoders=file_based_cache._saved_pcoders)
+    streaming_cache.write('some value', 'another key')
+    self.assertIs(
+        type(streaming_cache.load_pcoder('full', 'a key')),
+        type(coders.registry.get_coder(int)))
+
 
 if __name__ == '__main__':
   unittest.main()
