diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/types/CoderTypeSerializer.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/types/CoderTypeSerializer.java
index 65ebe580116..4705fbc3635 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/types/CoderTypeSerializer.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/types/CoderTypeSerializer.java
@@ -25,6 +25,7 @@ import org.apache.beam.runners.flink.translation.wrappers.DataOutputViewWrapper;
 import org.apache.beam.sdk.coders.Coder;
 import org.apache.beam.sdk.coders.CoderException;
 import org.apache.beam.sdk.util.CoderUtils;
+import org.apache.beam.vendor.guava.v20_0.com.google.common.base.Preconditions;
 import org.apache.flink.api.common.typeutils.CompatibilityResult;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;
@@ -40,6 +41,7 @@ public class CoderTypeSerializer<T> extends TypeSerializer<T> {
   private Coder<T> coder;
 
   public CoderTypeSerializer(Coder<T> coder) {
+    Preconditions.checkNotNull(coder);
     this.coder = coder;
   }
 
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
index 4166619cd66..2847cf77ce1 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
@@ -734,7 +734,10 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window
     // We can't output here anymore because the checkpoint barrier has already been
     // sent downstream. This is going to change with 1.6/1.7's prepareSnapshotBarrier.
     outputManager.openBuffer();
-    invokeFinishBundle();
+    // Ensure that no new bundle gets started as part of finishing a bundle
+    while (bundleStarted.get()) {
+      invokeFinishBundle();
+    }
     outputManager.closeBuffer();
 
     super.snapshotState(context);
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
index 48f9792e14a..0162333343a 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java
@@ -47,6 +47,7 @@ import org.apache.beam.runners.core.LateDataUtils;
 import org.apache.beam.runners.core.StateInternals;
 import org.apache.beam.runners.core.StateNamespace;
 import org.apache.beam.runners.core.StateNamespaces;
+import org.apache.beam.runners.core.StateTag;
 import org.apache.beam.runners.core.StateTags;
 import org.apache.beam.runners.core.StatefulDoFnRunner;
 import org.apache.beam.runners.core.TimerInternals;
@@ -66,6 +67,7 @@ import org.apache.beam.runners.fnexecution.provisioning.JobInfo;
 import org.apache.beam.runners.fnexecution.state.StateRequestHandler;
 import org.apache.beam.runners.fnexecution.state.StateRequestHandlers;
 import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.VoidCoder;
 import org.apache.beam.sdk.fn.data.FnDataReceiver;
 import org.apache.beam.sdk.options.PipelineOptions;
 import org.apache.beam.sdk.state.BagState;
@@ -822,7 +824,8 @@ public class ExecutableStageDoFnOperator<InputT, OutputT> extends DoFnOperator<I
         keyContextConsumer.accept(kv.getKey());
         for (String userState : userStateNames) {
           StateNamespace namespace = StateNamespaces.window(windowCoder, kv.getValue());
-          BagState<?> state = stateInternals.state(namespace, StateTags.bag(userState, null));
+          StateTag<BagState<Void>> bagStateStateTag = StateTags.bag(userState, VoidCoder.of());
+          BagState<?> state = stateInternals.state(namespace, bagStateStateTag);
           state.clear();
         }
       }
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
index dc01ca39abd..361c6967d1d 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
@@ -65,6 +65,7 @@ import org.apache.beam.runners.fnexecution.control.StageBundleFactory;
 import org.apache.beam.runners.fnexecution.provisioning.JobInfo;
 import org.apache.beam.runners.fnexecution.state.StateRequestHandler;
 import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.KvCoder;
 import org.apache.beam.sdk.coders.StringUtf8Coder;
 import org.apache.beam.sdk.coders.VarIntCoder;
 import org.apache.beam.sdk.coders.VoidCoder;
@@ -384,7 +385,8 @@ public class ExecutableStageDoFnOperatorTest {
             Collections.emptyList(),
             outputManagerFactory,
             WindowingStrategy.globalDefault(),
-            keyCoder);
+            keyCoder,
+            WindowedValue.getFullCoder(keyCoder, GlobalWindow.Coder.INSTANCE));
 
     KeyedOneInputStreamOperatorTestHarness<Integer, WindowedValue<Integer>, WindowedValue<Integer>>
         testHarness =
@@ -476,6 +478,12 @@ public class ExecutableStageDoFnOperatorTest {
 
   @Test
   public void testEnsureDeferredStateCleanupTimerFiring() throws Exception {
+    testEnsureDeferredStateCleanupTimerFiring(false);
+    testEnsureDeferredStateCleanupTimerFiring(true);
+  }
+
+  private void testEnsureDeferredStateCleanupTimerFiring(boolean withCheckpointing)
+      throws Exception {
     TupleTag<Integer> mainOutput = new TupleTag<>("main-output");
     DoFnOperator.MultiOutputOutputManagerFactory<Integer> outputManagerFactory =
         new DoFnOperator.MultiOutputOutputManagerFactory(mainOutput, VoidCoder.of());
@@ -484,9 +492,15 @@ public class ExecutableStageDoFnOperatorTest {
     WindowingStrategy windowingStrategy =
         WindowingStrategy.of(FixedWindows.of(Duration.millis(1000)));
 
+    KvCoder<String, Integer> kvCoder = KvCoder.of(keyCoder, VarIntCoder.of());
     ExecutableStageDoFnOperator<Integer, Integer> operator =
         getOperator(
-            mainOutput, Collections.emptyList(), outputManagerFactory, windowingStrategy, keyCoder);
+            mainOutput,
+            Collections.emptyList(),
+            outputManagerFactory,
+            windowingStrategy,
+            keyCoder,
+            WindowedValue.getFullCoder(kvCoder, windowingStrategy.getWindowFn().windowCoder()));
 
     @SuppressWarnings("unchecked")
     RemoteBundle bundle = Mockito.mock(RemoteBundle.class);
@@ -558,20 +572,32 @@ public class ExecutableStageDoFnOperatorTest {
     assertFalse("Watermark must be held back until bundle is complete.", timerInputReceived.get());
     assertThat(cleanupTimers, hasSize(0));
 
-    // upon finish bundle, watermark advances and timers can fire
-    // Note that this will finish the current bundle, but will also start a new one
-    // when timers fire as part of advancing the watermark
-    operator.invokeFinishBundle();
-
-    // the user timer was scheduled to fire after cleanup, but executes first
-    assertTrue("Timer should have been triggered.", timerInputReceived.get());
-    // cleanup will be executed after the bundle is complete
-    assertThat(cleanupTimers, hasSize(1));
-
-    verifyNoMoreInteractions(receiver);
-
-    operator.invokeFinishBundle();
-    assertThat(cleanupTimers, hasSize(0));
+    if (withCheckpointing) {
+      // Upon checkpointing, the bundle is finished and the watermark advances;
+      // timers can fire. Note: The bundle is ensured to be finished.
+      testHarness.snapshot(0, 0);
+
+      // The user timer was scheduled to fire after cleanup, but executes first
+      assertTrue("Timer should have been triggered.", timerInputReceived.get());
+      // Cleanup will be executed after the bundle is complete
+      assertThat(cleanupTimers, hasSize(0));
+      verifyNoMoreInteractions(receiver);
+    } else {
+      // Upon finishing a bundle, the watermark advances; timers can fire.
+      // Note that this will finish the current bundle, but will also start a new one
+      // when timers fire as part of advancing the watermark
+      operator.invokeFinishBundle();
+
+      // The user timer was scheduled to fire after cleanup, but executes first
+      assertTrue("Timer should have been triggered.", timerInputReceived.get());
+      // Cleanup will be executed after the bundle is complete
+      assertThat(cleanupTimers, hasSize(1));
+      verifyNoMoreInteractions(receiver);
+
+      // Finish bundle which has been started by finishing the bundle
+      operator.invokeFinishBundle();
+      assertThat(cleanupTimers, hasSize(0));
+    }
 
     testHarness.close();
   }
@@ -646,7 +672,8 @@ public class ExecutableStageDoFnOperatorTest {
         additionalOutputs,
         outputManagerFactory,
         WindowingStrategy.globalDefault(),
-        null);
+        null,
+        WindowedValue.getFullCoder(StringUtf8Coder.of(), GlobalWindow.Coder.INSTANCE));
   }
 
   private ExecutableStageDoFnOperator<Integer, Integer> getOperator(
@@ -654,7 +681,8 @@ public class ExecutableStageDoFnOperatorTest {
       List<TupleTag<?>> additionalOutputs,
       DoFnOperator.MultiOutputOutputManagerFactory<Integer> outputManagerFactory,
       WindowingStrategy windowingStrategy,
-      @Nullable Coder keyCoder) {
+      @Nullable Coder keyCoder,
+      @Nullable Coder windowedInputCoder) {
 
     FlinkExecutableStageContext.Factory contextFactory =
         Mockito.mock(FlinkExecutableStageContext.Factory.class);
@@ -663,7 +691,7 @@ public class ExecutableStageDoFnOperatorTest {
     ExecutableStageDoFnOperator<Integer, Integer> operator =
         new ExecutableStageDoFnOperator<>(
             "transform",
-            null,
+            windowedInputCoder,
             null,
             Collections.emptyMap(),
             mainOutput,
