diff --git a/runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java b/runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java
index cb7bf62c919..b21252e2436 100644
--- a/runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java
+++ b/runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java
@@ -1219,11 +1219,11 @@ public class SimpleDoFnRunner<InputT, OutputT> implements DoFnRunner<InputT, Out
       Instant windowExpiry = window.maxTimestamp().plus(allowedLateness);
       if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {
         checkArgument(
-            !outputTimestamp.isAfter(target),
+            !outputTimestamp.isAfter(windowExpiry),
             "Attempted to set an event-time timer with an output timestamp of %s that is"
-                + " after the timer firing timestamp %s",
+                + " after the expiration of window %s",
             outputTimestamp,
-            target);
+            windowExpiry);
         checkArgument(
             !target.isAfter(windowExpiry),
             "Attempted to set an event-time timer with a firing timestamp of %s that is"
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java
index c363fc763c4..e022b142aad 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java
@@ -4675,6 +4675,82 @@ public class ParDoTest implements Serializable {
       pipeline.run();
     }
 
+    @Test
+    @Category(NeedsRunner.class)
+    public void testRelativeTimerWithOutputTimestamp() {
+      DoFn<KV<Void, String>, String> buffferFn =
+          new DoFn<KV<Void, String>, String>() {
+
+            @TimerId("timer")
+            private final TimerSpec timerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);
+
+            @StateId("buffer")
+            private final StateSpec<BagState<TimestampedValue<String>>> bufferSpec =
+                StateSpecs.bag(TimestampedValue.TimestampedValueCoder.of(StringUtf8Coder.of()));
+
+            @StateId("minStamp")
+            private final StateSpec<ValueState<Instant>> minStamp = StateSpecs.value();
+
+            private Instant minInstant(Instant a, Instant b) {
+              return a.isBefore(b) ? a : b;
+            }
+
+            @ProcessElement
+            public void processElement(
+                @Element KV<Void, String> element,
+                @Timestamp Instant timestamp,
+                @StateId("buffer") BagState<TimestampedValue<String>> buffer,
+                @StateId("minStamp") ValueState<Instant> minStamp,
+                @TimerId("timer") Timer timer) {
+
+              minStamp.readLater();
+              buffer.add(TimestampedValue.of(element.getValue(), timestamp));
+              Instant currentMinStamp = minStamp.read();
+              if (currentMinStamp == null || currentMinStamp.isAfter(timestamp)) {
+                currentMinStamp = timestamp;
+                minStamp.write(currentMinStamp);
+                timer.withOutputTimestamp(currentMinStamp).offset(Duration.ZERO).setRelative();
+              }
+            }
+
+            @OnTimer("timer")
+            public void onTimer(
+                OnTimerContext context,
+                @StateId("buffer") BagState<TimestampedValue<String>> buffer,
+                @StateId("minStamp") ValueState<Instant> minStamp,
+                @TimerId("timer") Timer timer,
+                OutputReceiver<String> output) {
+
+              Instant fireTimestamp = context.fireTimestamp();
+              Iterable<TimestampedValue<String>> values = buffer.read();
+              Instant currentMinStamp = BoundedWindow.TIMESTAMP_MAX_VALUE;
+              for (TimestampedValue<String> val : values) {
+                if (fireTimestamp.isBefore(val.getTimestamp())) {
+                  output.outputWithTimestamp(val.getValue(), val.getTimestamp());
+                } else if (currentMinStamp.isAfter(val.getTimestamp())) {
+                  currentMinStamp = val.getTimestamp();
+                }
+              }
+              if (currentMinStamp.isBefore(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
+                minStamp.write(currentMinStamp);
+                timer.withOutputTimestamp(currentMinStamp).offset(Duration.ZERO).setRelative();
+              } else {
+                minStamp.clear();
+              }
+            }
+          };
+
+      PCollection<KV<Void, String>> input =
+          pipeline.apply(
+              TestStream.create(KvCoder.of(VoidCoder.of(), StringUtf8Coder.of()))
+                  .addElements(TimestampedValue.of(KV.of(null, "foo"), new Instant(1)))
+                  .addElements(TimestampedValue.of(KV.of(null, "bar"), new Instant(2)))
+                  .advanceWatermarkToInfinity());
+      PCollection<String> result = input.apply(ParDo.of(buffferFn));
+      PAssert.that(result).containsInAnyOrder("foo", "bar");
+      pipeline.run();
+    }
+
     private static class TwoTimerTest extends PTransform<PBegin, PDone> {
 
       private static PTransform<PBegin, PDone> of(
