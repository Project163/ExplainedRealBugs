diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/ScalarFunctionImpl.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/ScalarFunctionImpl.java
index 0c842433e59..27ea077dd0d 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/ScalarFunctionImpl.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/ScalarFunctionImpl.java
@@ -22,16 +22,26 @@ import static org.apache.calcite.util.Static.RESOURCE;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMultimap;
 import org.apache.calcite.adapter.enumerable.CallImplementor;
 import org.apache.calcite.adapter.enumerable.NullPolicy;
 import org.apache.calcite.adapter.enumerable.ReflectiveCallNotNullImplementor;
 import org.apache.calcite.adapter.enumerable.RexImpTable;
+import org.apache.calcite.adapter.enumerable.RexToLixTranslator;
+import org.apache.calcite.avatica.util.ByteString;
 import org.apache.calcite.linq4j.function.SemiStrict;
 import org.apache.calcite.linq4j.function.Strict;
+import org.apache.calcite.linq4j.tree.Expression;
+import org.apache.calcite.linq4j.tree.Expressions;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
+import org.apache.calcite.rex.RexCall;
 import org.apache.calcite.schema.Function;
 import org.apache.calcite.schema.ImplementableFunction;
 import org.apache.calcite.schema.ScalarFunction;
@@ -117,10 +127,61 @@ public class ScalarFunctionImpl extends UdfImplReflectiveFunctionBase
     return implementor;
   }
 
-  private static CallImplementor createImplementor(final Method method) {
+  /**
+   * Version of {@link ReflectiveCallNotNullImplementor} that does parameter conversion for Beam
+   * UDFs.
+   */
+  private static class ScalarReflectiveCallNotNullImplementor
+      extends ReflectiveCallNotNullImplementor {
+    ScalarReflectiveCallNotNullImplementor(Method method) {
+      super(method);
+    }
+
+    private static List<Expression> translate(List<Type> types, List<Expression> expressions) {
+      Preconditions.checkArgument(
+          types.size() == expressions.size(), "types.size() != expressions.size()");
+
+      final List<Expression> translated = new ArrayList<>();
+      for (int i = 0; i < expressions.size(); i++) {
+        translated.add(translate(types.get(i), expressions.get(i)));
+      }
+
+      return translated;
+    }
+
+    private static Expression translate(Type type, Expression expression) {
+      // NB: base class is called ReflectiveCallNotNullImplementor, but nulls are possible
+      //
+      // Calcite infers our UDF parameters as nullable, and WILL pass nullable expressions to this
+      // method. We could revisit this by explicitly asking users to add @Nullable annotation
+      // to UDF parameters, and not treating them as nullable by default, and then we can better
+      // determine if expression is possibly nullable by using reflection.
+
+      if (type == byte[].class && expression.type == ByteString.class) {
+        return Expressions.condition(
+            Expressions.equal(expression, Expressions.constant(null)),
+            Expressions.constant(null),
+            Expressions.call(expression, "getBytes"));
+      }
+
+      return expression;
+    }
+
+    @Override
+    public Expression implement(
+        RexToLixTranslator translator, RexCall call, List<Expression> translatedOperands) {
+      final List<Expression> translated =
+          translate(Arrays.asList(method.getParameterTypes()), translatedOperands);
+
+      // delegate to the underlying implementation to do the rest of translations
+      return super.implement(translator, call, translated);
+    }
+  }
+
+  private static CallImplementor createImplementor(Method method) {
     final NullPolicy nullPolicy = getNullPolicy(method);
     return RexImpTable.createImplementor(
-        new ReflectiveCallNotNullImplementor(method), nullPolicy, false);
+        new ScalarReflectiveCallNotNullImplementor(method), nullPolicy, false);
   }
 
   private static NullPolicy getNullPolicy(Method m) {
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java
index 3e8e30e4dfc..de546252c01 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java
@@ -51,6 +51,7 @@ import org.apache.calcite.adapter.enumerable.PhysType;
 import org.apache.calcite.adapter.enumerable.PhysTypeImpl;
 import org.apache.calcite.adapter.enumerable.RexToLixTranslator;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
+import org.apache.calcite.avatica.util.ByteString;
 import org.apache.calcite.linq4j.QueryProvider;
 import org.apache.calcite.linq4j.tree.BlockBuilder;
 import org.apache.calcite.linq4j.tree.Expression;
@@ -276,7 +277,13 @@ public class BeamCalcRel extends Calc implements BeamRelNode {
     } else if (toType.getTypeName() == TypeName.DECIMAL
         && !Types.isAssignableFrom(BigDecimal.class, (Class) value.getType())) {
       return Expressions.new_(BigDecimal.class, value);
+    } else if (toType.getTypeName() == TypeName.BYTES
+        && Types.isAssignableFrom(ByteString.class, (Class) value.getType())) {
 
+      return Expressions.condition(
+          Expressions.equal(value, Expressions.constant(null)),
+          Expressions.constant(null),
+          Expressions.call(value, "getBytes"));
     } else if (((Class) value.getType()).isPrimitive()
         || Types.isAssignableFrom(Number.class, (Class) value.getType())) {
       Type rawType = rawTypeMap.get(toType.getTypeName());
@@ -411,6 +418,12 @@ public class BeamCalcRel extends Calc implements BeamRelNode {
                 Expressions.equal(field, Expressions.constant(null)),
                 Expressions.constant(null),
                 Expressions.call(WrappedList.class, "of", field));
+      } else if (fromType.getTypeName() == TypeName.BYTES) {
+        field =
+            Expressions.condition(
+                Expressions.equal(field, Expressions.constant(null)),
+                Expressions.constant(null),
+                Expressions.new_(ByteString.class, field));
       }
       return field;
     }
diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslFilterTest.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslFilterTest.java
index 057140bdc16..c00f3c9b8fb 100644
--- a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslFilterTest.java
+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslFilterTest.java
@@ -21,7 +21,9 @@ import static org.hamcrest.Matchers.containsString;
 import static org.junit.internal.matchers.ThrowableMessageMatcher.hasMessage;
 
 import org.apache.beam.sdk.extensions.sql.impl.ParseException;
+import org.apache.beam.sdk.schemas.Schema;
 import org.apache.beam.sdk.testing.PAssert;
+import org.apache.beam.sdk.transforms.Create;
 import org.apache.beam.sdk.values.PCollection;
 import org.apache.beam.sdk.values.PCollectionTuple;
 import org.apache.beam.sdk.values.Row;
@@ -128,4 +130,24 @@ public class BeamSqlDslFilterTest extends BeamSqlDslBase {
 
     pipeline.run().waitUntilFinish();
   }
+
+  @Test
+  public void testFilterBytes() {
+    String sql = "SELECT c_bytes FROM PCOLLECTION WHERE c_bytes = x'ff'";
+
+    Schema schema = Schema.builder().addByteArrayField("c_bytes").build();
+    PCollection<Row> input =
+        pipeline.apply(
+            Create.of(
+                    Row.withSchema(schema).addValue(new byte[] {-1}).build(),
+                    Row.withSchema(schema).addValue(new byte[] {127}).build())
+                .withRowSchema(schema));
+
+    PCollection<Row> result = input.apply(SqlTransform.query(sql));
+
+    PAssert.that(result)
+        .containsInAnyOrder(Row.withSchema(schema).addValue(new byte[] {-1}).build());
+
+    pipeline.run().waitUntilFinish();
+  }
 }
diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslProjectTest.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslProjectTest.java
index 068aeee1edb..998013fe99a 100644
--- a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslProjectTest.java
+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslProjectTest.java
@@ -217,4 +217,18 @@ public class BeamSqlDslProjectTest extends BeamSqlDslBase {
 
     pipeline.run();
   }
+
+  @Test
+  public void testBytesLiteral() {
+    Schema outputSchema = Schema.of(Schema.Field.of("c_bytes", Schema.FieldType.BYTES));
+
+    PCollection<Row> result =
+        PCollectionTuple.empty(pipeline).apply(SqlTransform.query("SELECT x'baadcafe' as c_bytes"));
+
+    PAssert.that(result)
+        .containsInAnyOrder(
+            Row.withSchema(outputSchema).addValue(new byte[] {-70, -83, -54, -2}).build());
+
+    pipeline.run();
+  }
 }
