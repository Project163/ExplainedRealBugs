diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileBasedSink.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileBasedSink.java
index 6c3b1763c2c..2224f7dde30 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileBasedSink.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileBasedSink.java
@@ -447,7 +447,7 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
   }
 
   /**
-   * Returns the directory inside which temprary files will be written according to the configured
+   * Returns the directory inside which temporary files will be written according to the configured
    * {@link FilenamePolicy}.
    */
   @Experimental(Kind.FILESYSTEM)
@@ -506,8 +506,20 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
     /** The Sink that this WriteOperation will write to. */
     protected final FileBasedSink<?, DestinationT, OutputT> sink;
 
-    /** Directory for temporary output files. */
-    protected final ValueProvider<ResourceId> tempDirectory;
+    /**
+     * Base directory for temporary output files. A subdirectory of this may be used based upon
+     * tempSubdirType.
+     */
+    private final ValueProvider<ResourceId> baseTempDirectory;
+
+    private enum TempSubDirType {
+      NONE, // baseTempDirectory is used without a subdirectory.
+      UNIQUE, // a subdirectory based upon subdirUUID is used.
+      CONSISTENT, // a subdirectory common across all pipelines is used.
+    }
+
+    private TempSubDirType tempSubdirType;
+    private final UUID subdirUUID;
 
     /** Whether windowed writes are being used. */
     @Experimental(Kind.FILESYSTEM)
@@ -524,30 +536,23 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
      * Constructs a WriteOperation using the default strategy for generating a temporary directory
      * from the base output filename.
      *
-     * <p>Default is a uniquely named subdirectory of the provided tempDirectory, e.g. if
-     * tempDirectory is /path/to/foo/, the temporary directory will be
+     * <p>Without windowing, the default is a uniquely named subdirectory of the provided
+     * tempDirectory, e.g. if tempDirectory is /path/to/foo/, the temporary directory will be
      * /path/to/foo/.temp-beam-$uuid.
      *
+     * <p>With windowing, the default is a consistent named subdirectory of the provided
+     * tempDirectory, e.g. if tempDirectory is /path/to/foo/, the temporary directory will be
+     * /path/to/foo/.temp-beam. With windowing, unique subdirectories of the tempDirectory are not
+     * beneficial as they cannot be used for cleanup. By using a consistent directory, the created
+     * temp files are well-distributed beneath a common directory prefix, across both worker and
+     * pipeline executions. This is beneficial for filesystems such as GCS which can reuse
+     * autoscaling of the file metadata.
+     *
      * @param sink the FileBasedSink that will be used to configure this write operation.
      */
     public WriteOperation(FileBasedSink<?, DestinationT, OutputT> sink) {
-      this(
-          sink,
-          NestedValueProvider.of(sink.getTempDirectoryProvider(), new TemporaryDirectoryBuilder()));
-    }
-
-    private static class TemporaryDirectoryBuilder
-        implements SerializableFunction<ResourceId, ResourceId> {
-      private final UUID tempUUID = UUID.randomUUID();
-
-      @Override
-      public ResourceId apply(ResourceId tempDirectory) {
-        // Temp directory has a random UUID postfix (BEAM-7689)
-        String tempDirName = String.format(TEMP_DIRECTORY_PREFIX + "-%s", tempUUID);
-        return tempDirectory
-            .getCurrentDirectory()
-            .resolve(tempDirName, StandardResolveOptions.RESOLVE_DIRECTORY);
-      }
+      // The use of the unique subdir will be disabled if setWindowedWrites is called.
+      this(sink, sink.getTempDirectoryProvider(), TempSubDirType.UNIQUE);
     }
 
     /**
@@ -558,16 +563,37 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
      */
     @Experimental(Kind.FILESYSTEM)
     public WriteOperation(FileBasedSink<?, DestinationT, OutputT> sink, ResourceId tempDirectory) {
-      this(sink, StaticValueProvider.of(tempDirectory));
+      this(sink, StaticValueProvider.of(tempDirectory), TempSubDirType.NONE);
     }
 
     private WriteOperation(
-        FileBasedSink<?, DestinationT, OutputT> sink, ValueProvider<ResourceId> tempDirectory) {
+        FileBasedSink<?, DestinationT, OutputT> sink,
+        ValueProvider<ResourceId> tempDirectory,
+        TempSubDirType tempSubdirType) {
       this.sink = sink;
-      this.tempDirectory = tempDirectory;
+      this.baseTempDirectory = tempDirectory;
+      this.tempSubdirType = tempSubdirType;
+      this.subdirUUID = UUID.randomUUID();
       this.windowedWrites = false;
     }
 
+    public ResourceId getTempDirectory() {
+      if (tempSubdirType == TempSubDirType.NONE) {
+        return baseTempDirectory.get();
+      }
+      String tempDirName;
+      if (tempSubdirType == TempSubDirType.UNIQUE) {
+        tempDirName = String.format(TEMP_DIRECTORY_PREFIX + "-%s", subdirUUID);
+      } else {
+        assert (tempSubdirType == TempSubDirType.CONSISTENT);
+        tempDirName = TEMP_DIRECTORY_PREFIX;
+      }
+      return baseTempDirectory
+          .get()
+          .getCurrentDirectory()
+          .resolve(tempDirName, StandardResolveOptions.RESOLVE_DIRECTORY);
+    }
+
     /**
      * Clients must implement to return a subclass of {@link Writer}. This method must not mutate
      * the state of the object.
@@ -575,8 +601,9 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
     public abstract Writer<DestinationT, OutputT> createWriter() throws Exception;
 
     /** Indicates that the operation will be performing windowed writes. */
-    public void setWindowedWrites(boolean windowedWrites) {
-      this.windowedWrites = windowedWrites;
+    public void setWindowedWrites() {
+      this.windowedWrites = true;
+      this.tempSubdirType = TempSubDirType.CONSISTENT;
     }
 
     /*
@@ -795,9 +822,6 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
     final void removeTemporaryFiles(
         Collection<ResourceId> knownFiles, boolean shouldRemoveTemporaryDirectory)
         throws IOException {
-      ResourceId tempDir = tempDirectory.get();
-      LOG.debug("Removing temporary bundle output files in {}.", tempDir);
-
       // To partially mitigate the effects of filesystems with eventually-consistent
       // directory matching APIs, we remove not only files that the filesystem says exist
       // in the directory (which may be incomplete), but also files that are known to exist
@@ -811,7 +835,9 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
       }
       // TODO: Windows OS cannot resolves and matches '*' in the path,
       // ignore the exception for now to avoid failing the pipeline.
+      ResourceId tempDir = getTempDirectory();
       if (shouldRemoveTemporaryDirectory) {
+        LOG.debug("Removing temporary bundle output files in {}.", tempDir);
         try {
           MatchResult singleMatch =
               Iterables.getOnlyElement(
@@ -851,7 +877,7 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
       return getClass().getSimpleName()
           + "{"
           + "tempDirectory="
-          + tempDirectory
+          + getTempDirectory()
           + ", windowedWrites="
           + windowedWrites
           + '}';
@@ -932,6 +958,14 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
      */
     protected void finishWrite() throws Exception {}
 
+    @VisibleForTesting
+    static String spreadUid(String uId) {
+      // We prepend the hash of the uId to ensure that the temporary
+      // filenames used do not have common prefix. In some filesystems
+      // (for example GCS) such filenames can lead to hotspots.
+      return String.format("%08x%s", uId.hashCode(), uId);
+    }
+
     /**
      * Opens a uniquely named temporary file and initializes the writer using {@link #prepareWrite}.
      *
@@ -940,8 +974,8 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
      * fault tolerance.
      */
     public final void open(String uId) throws Exception {
-      this.id = uId;
-      ResourceId tempDirectory = getWriteOperation().tempDirectory.get();
+      this.id = spreadUid(uId);
+      ResourceId tempDirectory = getWriteOperation().getTempDirectory();
       outputFile = tempDirectory.resolve(id, StandardResolveOptions.RESOLVE_FILE);
       verifyNotNull(
           outputFile, "FileSystems are not allowed to return null from resolve: %s", tempDirectory);
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/WriteFiles.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/WriteFiles.java
index 7afac9a7ade..56830430b1d 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/WriteFiles.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/WriteFiles.java
@@ -341,9 +341,9 @@ public abstract class WriteFiles<UserT, DestinationT, OutputT>
       }
     }
     this.writeOperation = getSink().createWriteOperation();
-    this.writeOperation.setWindowedWrites(getWindowedWrites());
-
-    if (!getWindowedWrites()) {
+    if (getWindowedWrites()) {
+      this.writeOperation.setWindowedWrites();
+    } else {
       // Re-window the data into the global window and remove any existing triggers.
       input =
           input.apply(
@@ -972,10 +972,15 @@ public abstract class WriteFiles<UserT, DestinationT, OutputT>
 
     @FinishBundle
     public void finishBundle(FinishBundleContext c) throws Exception {
-      MoreFutures.get(MoreFutures.allAsList(closeFutures));
-      // If all writers were closed without exception, output the results to the next stage.
-      for (KV<Instant, FileResult<DestinationT>> result : deferredOutput) {
-        c.output(result.getValue(), result.getKey(), result.getValue().getWindow());
+      try {
+        MoreFutures.get(MoreFutures.allAsList(closeFutures));
+        // If all writers were closed without exception, output the results to the next stage.
+        for (KV<Instant, FileResult<DestinationT>> result : deferredOutput) {
+          c.output(result.getValue(), result.getKey(), result.getValue().getWindow());
+        }
+      } finally {
+        deferredOutput = null;
+        closeFutures = null;
       }
     }
   }
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/FileBasedSinkTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/FileBasedSinkTest.java
index deb0d6b4e09..c08f195190d 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/FileBasedSinkTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/FileBasedSinkTest.java
@@ -104,7 +104,8 @@ public class FileBasedSinkTest {
   public void testWriter() throws Exception {
     String testUid = "testId";
     ResourceId expectedTempFile =
-        getBaseTempDirectory().resolve(testUid, StandardResolveOptions.RESOLVE_FILE);
+        getBaseTempDirectory()
+            .resolve(Writer.spreadUid(testUid), StandardResolveOptions.RESOLVE_FILE);
     List<String> values = Arrays.asList("sympathetic vulture", "boresome hummingbird");
     List<String> expected = new ArrayList<>();
     expected.add(SimpleSink.SimpleWriter.HEADER);
@@ -252,9 +253,9 @@ public class FileBasedSinkTest {
       assertFalse(temporaryFiles.get(i).exists());
     }
 
-    assertFalse(new File(writeOp.tempDirectory.get().toString()).exists());
+    assertFalse(new File(writeOp.getTempDirectory().toString()).exists());
     // Test that repeated requests of the temp directory return a stable result.
-    assertEquals(writeOp.tempDirectory.get(), writeOp.tempDirectory.get());
+    assertEquals(writeOp.getTempDirectory(), writeOp.getTempDirectory());
   }
 
   /**
@@ -528,7 +529,9 @@ public class FileBasedSinkTest {
             .createWriteOperation();
     final Writer<Void, String> writer = writeOp.createWriter();
     final ResourceId expectedFile =
-        writeOp.tempDirectory.get().resolve(testUid, StandardResolveOptions.RESOLVE_FILE);
+        writeOp
+            .getTempDirectory()
+            .resolve(Writer.spreadUid(testUid), StandardResolveOptions.RESOLVE_FILE);
 
     final List<String> expected = new ArrayList<>();
     expected.add("header");
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/SimpleSink.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/SimpleSink.java
index 1501a8199ab..8ad5ace6c99 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/io/SimpleSink.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/io/SimpleSink.java
@@ -100,10 +100,6 @@ class SimpleSink<DestinationT> extends FileBasedSink<String, DestinationT, Strin
     public SimpleWriter<DestinationT> createWriter() {
       return new SimpleWriter<>(this);
     }
-
-    public ResourceId getTempDirectory() {
-      return tempDirectory.get();
-    }
   }
 
   static final class SimpleWriter<DestinationT> extends Writer<DestinationT, String> {
