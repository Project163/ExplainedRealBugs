diff --git a/sdks/go/pkg/beam/core/runtime/exec/data.go b/sdks/go/pkg/beam/core/runtime/exec/data.go
index f891c9c34d5..ed671ee1c0b 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/data.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/data.go
@@ -19,8 +19,6 @@ import (
 	"context"
 	"fmt"
 	"io"
-
-	"github.com/apache/beam/sdks/v2/go/pkg/beam/core/runtime/harness/statecache"
 )
 
 // Port represents the connection port of external operations.
@@ -46,6 +44,16 @@ type DataContext struct {
 	State StateReader
 }
 
+// SideCache manages cached ReStream values for side inputs that can be re-used across
+// bundles.
+type SideCache interface {
+	// QueryCache checks the cache for a ReStream corresponding to the transform and
+	// side input being used.
+	QueryCache(transformID, sideInputID string) ReStream
+	// SetCache places a ReStream into the cache for a transform and side input.
+	SetCache(transformID, sideInputID string, input ReStream)
+}
+
 // DataManager manages external data byte streams. Each data stream can be
 // opened by one consumer only.
 type DataManager interface {
@@ -62,7 +70,7 @@ type StateReader interface {
 	// OpenIterable opens a byte stream for reading unwindowed iterables from the runner.
 	OpenIterable(ctx context.Context, id StreamID, key []byte) (io.ReadCloser, error)
 	// GetSideInputCache returns the SideInputCache being used at the harness level.
-	GetSideInputCache() *statecache.SideInputCache
+	GetSideInputCache() SideCache
 }
 
 // TODO(herohde) 7/20/2018: user state management
diff --git a/sdks/go/pkg/beam/core/runtime/exec/pardo.go b/sdks/go/pkg/beam/core/runtime/exec/pardo.go
index fdf20b0862f..6a41e9d83fc 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/pardo.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/pardo.go
@@ -257,6 +257,7 @@ func (n *ParDo) initSideInput(ctx context.Context, w typex.Window) error {
 	if err != nil {
 		return err
 	}
+	n.cache.key = w
 	n.cache.sideinput = sideinput
 	for i := 0; i < len(n.Side); i++ {
 		n.cache.extra[i] = sideinput[i].Value()
diff --git a/sdks/go/pkg/beam/core/runtime/harness/harness.go b/sdks/go/pkg/beam/core/runtime/harness/harness.go
index 09c1847a0e7..c0b12953bb9 100644
--- a/sdks/go/pkg/beam/core/runtime/harness/harness.go
+++ b/sdks/go/pkg/beam/core/runtime/harness/harness.go
@@ -317,6 +317,7 @@ func (c *control) handleInstruction(ctx context.Context, req *fnpb.InstructionRe
 			return fail(ctx, instID, "Failed: %v", err)
 		}
 
+		// TODO(BEAM-11097): Get and set valid tokens in cache
 		data := NewScopedDataManager(c.data, instID)
 		state := NewScopedStateReaderWithCache(c.state, instID, c.cache)
 		err = plan.Execute(ctx, string(instID), exec.DataContext{Data: data, State: state})
diff --git a/sdks/go/pkg/beam/core/runtime/harness/statecache/statecache.go b/sdks/go/pkg/beam/core/runtime/harness/statecache/statecache.go
index 99a093d62bf..529c21e2741 100644
--- a/sdks/go/pkg/beam/core/runtime/harness/statecache/statecache.go
+++ b/sdks/go/pkg/beam/core/runtime/harness/statecache/statecache.go
@@ -23,25 +23,13 @@ package statecache
 import (
 	"sync"
 
+	"github.com/apache/beam/sdks/v2/go/pkg/beam/core/runtime/exec"
 	"github.com/apache/beam/sdks/v2/go/pkg/beam/internal/errors"
 	fnpb "github.com/apache/beam/sdks/v2/go/pkg/beam/model/fnexecution_v1"
 )
 
 type token string
 
-// ReusableInput is a resettable value, notably used to unwind iterators cheaply
-// and cache materialized side input across invocations.
-//
-// Redefined from exec's input.go to avoid a cyclical dependency.
-type ReusableInput interface {
-	// Init initializes the value before use.
-	Init() error
-	// Value returns the side input value.
-	Value() interface{}
-	// Reset resets the value after use.
-	Reset() error
-}
-
 // SideInputCache stores a cache of reusable inputs for the purposes of
 // eliminating redundant calls to the runner during execution of ParDos
 // using side inputs.
@@ -56,12 +44,13 @@ type ReusableInput interface {
 type SideInputCache struct {
 	capacity    int
 	mu          sync.Mutex
-	cache       map[token]ReusableInput
+	cache       map[token]exec.ReStream
 	idsToTokens map[string]token
 	validTokens map[token]int8 // Maps tokens to active bundle counts
 	metrics     CacheMetrics
 }
 
+// CacheMetrics stores metrics for the cache across a pipeline run.
 type CacheMetrics struct {
 	Hits           int64
 	Misses         int64
@@ -78,7 +67,7 @@ func (c *SideInputCache) Init(cap int) error {
 	}
 	c.mu.Lock()
 	defer c.mu.Unlock()
-	c.cache = make(map[token]ReusableInput, cap)
+	c.cache = make(map[token]exec.ReStream, cap)
 	c.idsToTokens = make(map[string]token)
 	c.validTokens = make(map[token]int8)
 	c.capacity = cap
@@ -89,7 +78,7 @@ func (c *SideInputCache) Init(cap int) error {
 // transform and side input IDs to cache tokens in the process. Should be called at the start of every
 // new ProcessBundleRequest. If the runner does not support caching, the passed cache token values
 // should be empty and all get/set requests will silently be no-ops.
-func (c *SideInputCache) SetValidTokens(cacheTokens ...fnpb.ProcessBundleRequest_CacheToken) {
+func (c *SideInputCache) SetValidTokens(cacheTokens ...*fnpb.ProcessBundleRequest_CacheToken) {
 	c.mu.Lock()
 	defer c.mu.Unlock()
 	for _, tok := range cacheTokens {
@@ -121,7 +110,7 @@ func (c *SideInputCache) setValidToken(transformID, sideInputID string, tok toke
 // CompleteBundle takes the cache tokens passed to set the valid tokens and decrements their
 // usage count for the purposes of maintaining a valid count of whether or not a value is
 // still in use. Should be called once ProcessBundle has completed.
-func (c *SideInputCache) CompleteBundle(cacheTokens ...fnpb.ProcessBundleRequest_CacheToken) {
+func (c *SideInputCache) CompleteBundle(cacheTokens ...*fnpb.ProcessBundleRequest_CacheToken) {
 	c.mu.Lock()
 	defer c.mu.Unlock()
 	for _, tok := range cacheTokens {
@@ -160,7 +149,7 @@ func (c *SideInputCache) makeAndValidateToken(transformID, sideInputID string) (
 // input has been cached. A query having a bad token (e.g. one that doesn't make a known
 // token or one that makes a known but currently invalid token) is treated the same as a
 // cache miss.
-func (c *SideInputCache) QueryCache(transformID, sideInputID string) ReusableInput {
+func (c *SideInputCache) QueryCache(transformID, sideInputID string) exec.ReStream {
 	c.mu.Lock()
 	defer c.mu.Unlock()
 	tok, ok := c.makeAndValidateToken(transformID, sideInputID)
@@ -182,7 +171,7 @@ func (c *SideInputCache) QueryCache(transformID, sideInputID string) ReusableInp
 // with its corresponding transform ID and side input ID. If the IDs do not pair with a known, valid token
 // then we silently do not cache the input, as this is an indication that the runner is treating that input
 // as uncacheable.
-func (c *SideInputCache) SetCache(transformID, sideInputID string, input ReusableInput) {
+func (c *SideInputCache) SetCache(transformID, sideInputID string, input exec.ReStream) {
 	c.mu.Lock()
 	defer c.mu.Unlock()
 	tok, ok := c.makeAndValidateToken(transformID, sideInputID)
diff --git a/sdks/go/pkg/beam/core/runtime/harness/statecache/statecache_test.go b/sdks/go/pkg/beam/core/runtime/harness/statecache/statecache_test.go
index 18f2f38ab49..83a47a53385 100644
--- a/sdks/go/pkg/beam/core/runtime/harness/statecache/statecache_test.go
+++ b/sdks/go/pkg/beam/core/runtime/harness/statecache/statecache_test.go
@@ -18,35 +18,38 @@ package statecache
 import (
 	"testing"
 
+	"github.com/apache/beam/sdks/v2/go/pkg/beam/core/runtime/exec"
 	fnpb "github.com/apache/beam/sdks/v2/go/pkg/beam/model/fnexecution_v1"
 )
 
-// TestReusableInput implements the ReusableInput interface for the purposes
-// of testing.
-type TestReusableInput struct {
-	transformID string
-	sideInputID string
-	value       interface{}
+type TestReStream struct {
+	value interface{}
 }
 
-func makeTestReusableInput(transformID, sideInputID string, value interface{}) ReusableInput {
-	return &TestReusableInput{transformID: transformID, sideInputID: sideInputID, value: value}
+func (r *TestReStream) Open() (exec.Stream, error) {
+	return &TestFixedStream{value: r.value}, nil
 }
 
-// Init is a ReusableInput interface method, this is a no-op.
-func (r *TestReusableInput) Init() error {
+type TestFixedStream struct {
+	value interface{}
+}
+
+func (s *TestFixedStream) Close() error {
 	return nil
 }
 
-// Value returns the stored value in the TestReusableInput.
-func (r *TestReusableInput) Value() interface{} {
-	return r.value
+func (s *TestFixedStream) Read() (*exec.FullValue, error) {
+	return &exec.FullValue{Elm: s.value}, nil
 }
 
-// Reset clears the value in the TestReusableInput.
-func (r *TestReusableInput) Reset() error {
-	r.value = nil
-	return nil
+func makeTestReStream(value interface{}) exec.ReStream {
+	return &TestReStream{value: value}
+}
+
+func getValue(rs exec.ReStream) interface{} {
+	stream, _ := rs.Open()
+	fullVal, _ := stream.Read()
+	return fullVal.Elm
 }
 
 func TestInit(t *testing.T) {
@@ -83,7 +86,7 @@ func TestSetCache_UncacheableCase(t *testing.T) {
 	if err != nil {
 		t.Fatalf("cache init failed, got %v", err)
 	}
-	input := makeTestReusableInput("t1", "s1", 10)
+	input := makeTestReStream(10)
 	s.SetCache("t1", "s1", input)
 	output := s.QueryCache("t1", "s1")
 	if output != nil {
@@ -101,31 +104,31 @@ func TestSetCache_CacheableCase(t *testing.T) {
 	sideID := "s1"
 	tok := token("tok1")
 	s.setValidToken(transID, sideID, tok)
-	input := makeTestReusableInput(transID, sideID, 10)
+	input := makeTestReStream(10)
 	s.SetCache(transID, sideID, input)
 	output := s.QueryCache(transID, sideID)
 	if output == nil {
 		t.Fatalf("call to query cache missed when should have hit")
 	}
-	val, ok := output.Value().(int)
+	val, ok := getValue(output).(int)
 	if !ok {
-		t.Errorf("failed to convert value to integer, got %v", output.Value())
+		t.Errorf("failed to convert value to integer, got %v", getValue(output))
 	}
 	if val != 10 {
 		t.Errorf("element mismatch, expected 10, got %v", val)
 	}
 }
 
-func makeRequest(transformID, sideInputID string, t token) fnpb.ProcessBundleRequest_CacheToken {
-	var tok fnpb.ProcessBundleRequest_CacheToken
-	var wrap fnpb.ProcessBundleRequest_CacheToken_SideInput_
-	var side fnpb.ProcessBundleRequest_CacheToken_SideInput
-	side.TransformId = transformID
-	side.SideInputId = sideInputID
-	wrap.SideInput = &side
-	tok.Type = &wrap
-	tok.Token = []byte(t)
-	return tok
+func makeRequest(transformID, sideInputID string, t token) *fnpb.ProcessBundleRequest_CacheToken {
+	return &fnpb.ProcessBundleRequest_CacheToken{
+		Token: []byte(t),
+		Type: &fnpb.ProcessBundleRequest_CacheToken_SideInput_{
+			SideInput: &fnpb.ProcessBundleRequest_CacheToken_SideInput{
+				TransformId: transformID,
+				SideInputId: sideInputID,
+			},
+		},
+	}
 }
 
 func TestSetValidTokens(t *testing.T) {
@@ -157,7 +160,7 @@ func TestSetValidTokens(t *testing.T) {
 		t.Fatalf("cache init failed, got %v", err)
 	}
 
-	var tokens []fnpb.ProcessBundleRequest_CacheToken
+	var tokens []*fnpb.ProcessBundleRequest_CacheToken
 	for _, input := range inputs {
 		t := makeRequest(input.transformID, input.sideInputID, input.tok)
 		tokens = append(tokens, t)
@@ -243,14 +246,14 @@ func TestSetCache_Eviction(t *testing.T) {
 	}
 
 	tokOne := makeRequest("t1", "s1", "tok1")
-	inOne := makeTestReusableInput("t1", "s1", 10)
+	inOne := makeTestReStream(10)
 	s.SetValidTokens(tokOne)
 	s.SetCache("t1", "s1", inOne)
 	// Mark bundle as complete, drop count for tokOne to 0
 	s.CompleteBundle(tokOne)
 
 	tokTwo := makeRequest("t2", "s2", "tok2")
-	inTwo := makeTestReusableInput("t2", "s2", 20)
+	inTwo := makeTestReStream(20)
 	s.SetValidTokens(tokTwo)
 	s.SetCache("t2", "s2", inTwo)
 
@@ -270,10 +273,10 @@ func TestSetCache_EvictionFailure(t *testing.T) {
 	}
 
 	tokOne := makeRequest("t1", "s1", "tok1")
-	inOne := makeTestReusableInput("t1", "s1", 10)
+	inOne := makeTestReStream(10)
 
 	tokTwo := makeRequest("t2", "s2", "tok2")
-	inTwo := makeTestReusableInput("t2", "s2", 20)
+	inTwo := makeTestReStream(20)
 
 	s.SetValidTokens(tokOne, tokTwo)
 	s.SetCache("t1", "s1", inOne)
diff --git a/sdks/go/pkg/beam/core/runtime/harness/statemgr.go b/sdks/go/pkg/beam/core/runtime/harness/statemgr.go
index 31d75b656f9..2b7ea73e546 100644
--- a/sdks/go/pkg/beam/core/runtime/harness/statemgr.go
+++ b/sdks/go/pkg/beam/core/runtime/harness/statemgr.go
@@ -69,7 +69,7 @@ func (s *ScopedStateReader) OpenIterable(ctx context.Context, id exec.StreamID,
 }
 
 // GetSideInputCache returns a pointer to the SideInputCache being used by the SDK harness.
-func (s *ScopedStateReader) GetSideInputCache() *statecache.SideInputCache {
+func (s *ScopedStateReader) GetSideInputCache() exec.SideCache {
 	return s.cache
 }
 
