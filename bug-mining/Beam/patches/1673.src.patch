diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
index 37ed3c318b0..af20c647464 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
@@ -58,7 +58,6 @@ import org.apache.beam.runners.flink.FlinkPipelineOptions;
 import org.apache.beam.runners.flink.metrics.DoFnRunnerWithMetricsUpdate;
 import org.apache.beam.runners.flink.metrics.FlinkMetricContainer;
 import org.apache.beam.runners.flink.translation.types.CoderTypeSerializer;
-import org.apache.beam.runners.flink.translation.utils.NoopLock;
 import org.apache.beam.runners.flink.translation.utils.Workarounds;
 import org.apache.beam.runners.flink.translation.wrappers.streaming.stableinput.BufferingDoFnRunner;
 import org.apache.beam.runners.flink.translation.wrappers.streaming.state.FlinkBroadcastStateInternals;
@@ -78,6 +77,7 @@ import org.apache.beam.sdk.transforms.reflect.DoFnInvokers;
 import org.apache.beam.sdk.transforms.reflect.DoFnSignature;
 import org.apache.beam.sdk.transforms.reflect.DoFnSignatures;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
+import org.apache.beam.sdk.util.NoopLock;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.PCollectionView;
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
index 29a59d54af3..5626e819712 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java
@@ -67,7 +67,6 @@ import org.apache.beam.runners.flink.metrics.DoFnRunnerWithMetricsUpdate;
 import org.apache.beam.runners.flink.streaming.FlinkStateInternalsTest;
 import org.apache.beam.runners.flink.translation.functions.FlinkExecutableStageContextFactory;
 import org.apache.beam.runners.flink.translation.types.CoderTypeInformation;
-import org.apache.beam.runners.flink.translation.utils.NoopLock;
 import org.apache.beam.runners.fnexecution.control.BundleProgressHandler;
 import org.apache.beam.runners.fnexecution.control.ExecutableStageContext;
 import org.apache.beam.runners.fnexecution.control.OutputReceiverFactory;
@@ -92,6 +91,7 @@ import org.apache.beam.sdk.transforms.windowing.GlobalWindow;
 import org.apache.beam.sdk.transforms.windowing.IntervalWindow;
 import org.apache.beam.sdk.transforms.windowing.PaneInfo;
 import org.apache.beam.sdk.util.CoderUtils;
+import org.apache.beam.sdk.util.NoopLock;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.TupleTag;
diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactory.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactory.java
index 7cb82a8b583..7238eaeb9b1 100644
--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactory.java
+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/DefaultJobBundleFactory.java
@@ -28,6 +28,8 @@ import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.concurrent.ThreadSafe;
 import org.apache.beam.model.fnexecution.v1.ProvisionApi;
 import org.apache.beam.model.pipeline.v1.RunnerApi.Environment;
@@ -67,13 +69,13 @@ import org.apache.beam.sdk.options.ExperimentalOptions;
 import org.apache.beam.sdk.options.PipelineOptions;
 import org.apache.beam.sdk.options.PortablePipelineOptions;
 import org.apache.beam.sdk.options.PortablePipelineOptions.RetrievalServiceType;
+import org.apache.beam.sdk.util.NoopLock;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.MoreObjects;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.CacheBuilder;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.CacheLoader;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.LoadingCache;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.RemovalNotification;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
@@ -95,6 +97,7 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
 
   private final String factoryId = factoryIdGenerator.getId();
   private final ImmutableList<LoadingCache<Environment, WrappedSdkHarnessClient>> environmentCaches;
+  private final ImmutableList<Lock> environmentCacheLocks;
   private final AtomicInteger stageBundleFactoryCount = new AtomicInteger();
   private final Map<String, EnvironmentFactory.Provider> environmentFactoryProviderMap;
   private final ExecutorService executor;
@@ -140,13 +143,14 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
     this.stageIdGenerator = () -> factoryId + "-" + stageIdSuffixGenerator.getId();
     this.environmentExpirationMillis = getEnvironmentExpirationMillis(jobInfo);
     this.loadBalanceBundles = shouldLoadBalanceBundles(jobInfo);
+    this.environmentCacheLocks = createEnvironmentCacheLocks(getMaxEnvironmentClients(jobInfo));
     this.environmentCaches =
         createEnvironmentCaches(
             serverFactory -> createServerInfo(jobInfo, serverFactory),
             getMaxEnvironmentClients(jobInfo));
     this.availableCachesSemaphore = new Semaphore(environmentCaches.size(), true);
     this.availableCaches = new LinkedBlockingDeque<>(environmentCaches);
-    this.evictedActiveClients = Sets.newIdentityHashSet();
+    this.evictedActiveClients = Sets.newConcurrentHashSet();
   }
 
   @VisibleForTesting
@@ -161,39 +165,68 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
     this.stageIdGenerator = stageIdGenerator;
     this.environmentExpirationMillis = getEnvironmentExpirationMillis(jobInfo);
     this.loadBalanceBundles = shouldLoadBalanceBundles(jobInfo);
+    this.environmentCacheLocks = createEnvironmentCacheLocks(getMaxEnvironmentClients(jobInfo));
     this.environmentCaches =
         createEnvironmentCaches(serverFactory -> serverInfo, getMaxEnvironmentClients(jobInfo));
     this.availableCachesSemaphore = new Semaphore(environmentCaches.size(), true);
     this.availableCaches = new LinkedBlockingDeque<>(environmentCaches);
-    this.evictedActiveClients = Sets.newIdentityHashSet();
+    this.evictedActiveClients = Sets.newConcurrentHashSet();
+  }
+
+  private ImmutableList<Lock> createEnvironmentCacheLocks(int count) {
+    ImmutableList.Builder<Lock> locksForCaches = ImmutableList.builder();
+    for (int i = 0; i < count; i++) {
+      final Lock refLock;
+      if (environmentExpirationMillis > 0) {
+        // The lock ensures there is no race condition between expiring an environment and a client
+        // still attempting to use it, hence referencing it.
+        refLock = new ReentrantLock(true);
+      } else {
+        refLock = NoopLock.get();
+      }
+      locksForCaches.add(refLock);
+    }
+    return locksForCaches.build();
   }
 
   private ImmutableList<LoadingCache<Environment, WrappedSdkHarnessClient>> createEnvironmentCaches(
       ThrowingFunction<ServerFactory, ServerInfo> serverInfoCreator, int count) {
-    CacheBuilder<Environment, WrappedSdkHarnessClient> builder =
-        CacheBuilder.newBuilder()
-            .removalListener(
-                (RemovalNotification<Environment, WrappedSdkHarnessClient> notification) -> {
-                  WrappedSdkHarnessClient client = notification.getValue();
-                  int refCount = client.unref();
-                  if (refCount > 0) {
-                    LOG.warn(
-                        "Expiring environment {} with {} remaining bundle references. Taking note to clean it up during shutdown if the references are not removed by then.",
-                        notification.getKey(),
-                        refCount);
-                    evictedActiveClients.add(client);
-                  }
-                });
-
-    if (environmentExpirationMillis > 0) {
-      builder.expireAfterWrite(environmentExpirationMillis, TimeUnit.MILLISECONDS);
-    }
 
     ImmutableList.Builder<LoadingCache<Environment, WrappedSdkHarnessClient>> caches =
         ImmutableList.builder();
     for (int i = 0; i < count; i++) {
-      LoadingCache<Environment, WrappedSdkHarnessClient> cache =
-          builder.build(
+
+      final Lock refLock = environmentCacheLocks.get(i);
+      CacheBuilder<Environment, WrappedSdkHarnessClient> cacheBuilder =
+          CacheBuilder.newBuilder()
+              .removalListener(
+                  notification -> {
+                    WrappedSdkHarnessClient client = notification.getValue();
+                    final int refCount;
+                    try {
+                      // We need to use a lock here to ensure we are not causing the environment to
+                      // be removed if beforehand a StageBundleFactory has retrieved it but not yet
+                      // issued ref() on it.
+                      refLock.lock();
+                      refCount = client.unref();
+                    } finally {
+                      refLock.unlock();
+                    }
+                    if (refCount > 0) {
+                      LOG.warn(
+                          "Expiring environment {} with {} remaining bundle references. Taking note to clean it up during shutdown if the references are not removed by then.",
+                          notification.getKey(),
+                          refCount);
+                      evictedActiveClients.add(client);
+                    }
+                  });
+
+      if (environmentExpirationMillis > 0) {
+        cacheBuilder.expireAfterWrite(environmentExpirationMillis, TimeUnit.MILLISECONDS);
+      }
+
+      caches.add(
+          cacheBuilder.build(
               new CacheLoader<Environment, WrappedSdkHarnessClient>() {
                 @Override
                 public WrappedSdkHarnessClient load(Environment environment) throws Exception {
@@ -212,8 +245,7 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
                   return WrappedSdkHarnessClient.wrapping(
                       environmentFactory.createEnvironment(environment), serverInfo);
                 }
-              });
-      caches.add(cache);
+              }));
     }
     return caches.build();
   }
@@ -406,8 +438,16 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
         availableCachesSemaphore.acquire();
         // The blocking queue of caches for serving multiple bundles concurrently.
         currentCache = availableCaches.take();
-        client = currentCache.getUnchecked(executableStage.getEnvironment());
-        client.ref();
+        // Lock because the environment expiration can remove the ref for the client
+        // which would close the underlying environment before we can ref it.
+        Lock refLock = environmentCacheLocks.get(environmentIndex);
+        try {
+          refLock.lock();
+          client = currentCache.getUnchecked(executableStage.getEnvironment());
+          client.ref();
+        } finally {
+          refLock.unlock();
+        }
 
         currentClient = preparedClients.get(client);
         if (currentClient == null) {
@@ -419,8 +459,16 @@ public class DefaultJobBundleFactory implements JobBundleFactory {
 
       } else {
         currentCache = environmentCaches.get(environmentIndex);
-        client = currentCache.getUnchecked(executableStage.getEnvironment());
-        client.ref();
+        Lock refLock = environmentCacheLocks.get(environmentIndex);
+        // Lock because the environment expiration can remove the ref for the client which would
+        // close the underlying environment before we can ref it.
+        try {
+          refLock.lock();
+          client = currentCache.getUnchecked(executableStage.getEnvironment());
+          client.ref();
+        } finally {
+          refLock.unlock();
+        }
 
         if (currentClient.wrappedClient != client) {
           // reset after environment expired
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/utils/NoopLock.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/util/NoopLock.java
similarity index 97%
rename from runners/flink/src/main/java/org/apache/beam/runners/flink/translation/utils/NoopLock.java
rename to sdks/java/core/src/main/java/org/apache/beam/sdk/util/NoopLock.java
index f6e4ad55f5f..12a74830e55 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/utils/NoopLock.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/util/NoopLock.java
@@ -15,7 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.beam.runners.flink.translation.utils;
+package org.apache.beam.sdk.util;
 
 import java.io.Serializable;
 import java.util.concurrent.TimeUnit;
