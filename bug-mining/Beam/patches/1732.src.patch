diff --git a/model/pipeline/src/main/proto/beam_runner_api.proto b/model/pipeline/src/main/proto/beam_runner_api.proto
index 3ceba91db85..d2ddd09de08 100644
--- a/model/pipeline/src/main/proto/beam_runner_api.proto
+++ b/model/pipeline/src/main/proto/beam_runner_api.proto
@@ -1150,23 +1150,27 @@ message StandardArtifacts {
   enum Types {
     // A URN for locally-accessible artifact files.
     // payload: ArtifactFilePayload
-    FILE     = 0 [(beam_urn) = "beam:artifact:type:file:v1"];
+    FILE      = 0 [(beam_urn) = "beam:artifact:type:file:v1"];
 
     // A URN for artifacts described by URLs.
     // payload: ArtifactUrlPayload
-    URL      = 1 [(beam_urn) = "beam:artifact:type:url:v1"];
+    URL       = 1 [(beam_urn) = "beam:artifact:type:url:v1"];
 
     // A URN for artifacts embedded in ArtifactInformation proto.
     // payload: EmbeddedFilePayload.
-    EMBEDDED = 2 [(beam_urn) = "beam:artifact:type:embedded:v1"];
+    EMBEDDED  = 2 [(beam_urn) = "beam:artifact:type:embedded:v1"];
 
     // A URN for Python artifacts hosted on PYPI.
     // payload: PypiPayload
-    PYPI     = 3 [(beam_urn) = "beam:artifact:type:pypi:v1"];
+    PYPI      = 3 [(beam_urn) = "beam:artifact:type:pypi:v1"];
 
     // A URN for Java artifacts hosted on a Maven repository.
     // payload: MavenPayload
-    MAVEN    = 4 [(beam_urn) = "beam:artifact:type:maven:v1"];
+    MAVEN     = 4 [(beam_urn) = "beam:artifact:type:maven:v1"];
+
+    // A URN for deferred artifacts.
+    // payload: DeferredArtifactPayload
+    DEFERRED = 5 [(beam_urn) = "beam:artifact:type:deferred:v1"];
   }
   enum Roles {
     // A URN for staging-to role.
@@ -1176,7 +1180,7 @@ message StandardArtifacts {
 }
 
 message ArtifactFilePayload {
-  // a string for an artifact path e.g. "/tmp/foo.jar"
+  // a string for an artifact file path e.g. "/tmp/foo.jar"
   string path = 1;
 
   // The hex-encoded sha256 checksum of the artifact.
@@ -1210,6 +1214,15 @@ message MavenPayload {
   string repository_url = 2;
 }
 
+message DeferredArtifactPayload {
+  // A unique string identifier assigned by the creator of this payload. The creator may use this key to confirm
+  // whether they can parse the data.
+  string key = 1;
+
+  // Data for deferred artifacts. Interpretation of bytes is delegated to the creator of this payload.
+  bytes data = 2;
+}
+
 message ArtifactStagingToRolePayload {
   // A generated staged name (relative path under staging directory).
   string staged_name = 1;
diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/ArtifactResolver.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/ArtifactResolver.java
new file mode 100644
index 00000000000..6cad644a2b4
--- /dev/null
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/ArtifactResolver.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.core.construction;
+
+import java.util.List;
+import java.util.Optional;
+import org.apache.beam.model.pipeline.v1.RunnerApi;
+
+/**
+ * An interface for artifact resolvers. Artifact resolvers transform {@link
+ * RunnerApi.ArtifactInformation} from one type to another typically from remote or deferred
+ * artifacts to locally accessible file artifacts.
+ */
+public interface ArtifactResolver {
+
+  /**
+   * Register {@link ResolutionFn}. When multiple {@link ResolutionFn}s are capable of resolving the
+   * same {@link RunnerApi.ArtifactInformation}, the application order is up to the implementing
+   * class of this interface.
+   *
+   * @param fn a resolution function to be registered
+   */
+  void register(ResolutionFn fn);
+
+  /** Updating pipeline proto by applying registered {@link ResolutionFn}s. */
+  RunnerApi.Pipeline resolveArtifacts(RunnerApi.Pipeline pipeline);
+
+  /**
+   * A lazy transformer for resolving {@link RunnerApi.ArtifactInformation}. Note that {@link
+   * ResolutionFn} postpones any side-effect until {@link
+   * ArtifactResolver#resolveArtifacts(RunnerApi.Pipeline)} is called.
+   */
+  interface ResolutionFn {
+    Optional<List<RunnerApi.ArtifactInformation>> resolve(RunnerApi.ArtifactInformation info);
+  }
+}
diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java
new file mode 100644
index 00000000000..f3447a99e04
--- /dev/null
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.core.construction;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import org.apache.beam.model.pipeline.v1.RunnerApi;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;
+
+/**
+ * A default artifact resolver. This resolver applies {@link ResolutionFn} in the reversed order
+ * they registered i.e. the function registered later overrides the earlier one if they resolve the
+ * same artifact.
+ */
+public class DefaultArtifactResolver implements ArtifactResolver {
+  public static final ArtifactResolver INSTANCE = new DefaultArtifactResolver();
+
+  private List<ResolutionFn> fns =
+      Lists.newArrayList(
+          (info) -> {
+            if (BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE).equals(info.getTypeUrn())) {
+              return Optional.of(ImmutableList.of(info));
+            } else {
+              return Optional.empty();
+            }
+          });
+
+  private Function<RunnerApi.ArtifactInformation, Stream<RunnerApi.ArtifactInformation>> resolver =
+      (info) -> {
+        for (ResolutionFn fn : Lists.reverse(fns)) {
+          Optional<List<RunnerApi.ArtifactInformation>> resolved = fn.resolve(info);
+          if (resolved.isPresent()) {
+            return resolved.get().stream();
+          }
+        }
+        throw new RuntimeException(String.format("Cannot resolve artifact information: %s", info));
+      };
+
+  @Override
+  public void register(ResolutionFn fn) {
+    fns.add(fn);
+  }
+
+  @Override
+  public RunnerApi.Pipeline resolveArtifacts(RunnerApi.Pipeline pipeline) {
+    ImmutableMap.Builder<String, RunnerApi.Environment> environmentMapBuilder =
+        ImmutableMap.builder();
+    for (Map.Entry<String, RunnerApi.Environment> entry :
+        pipeline.getComponents().getEnvironmentsMap().entrySet()) {
+      List<RunnerApi.ArtifactInformation> resolvedDependencies =
+          entry
+              .getValue()
+              .getDependenciesList()
+              .parallelStream()
+              .flatMap(resolver)
+              .collect(Collectors.toList());
+      environmentMapBuilder.put(
+          entry.getKey(),
+          entry
+              .getValue()
+              .toBuilder()
+              .clearDependencies()
+              .addAllDependencies(resolvedDependencies)
+              .build());
+    }
+    return pipeline
+        .toBuilder()
+        .setComponents(
+            pipeline.getComponents().toBuilder().putAllEnvironments(environmentMapBuilder.build()))
+        .build();
+  }
+}
diff --git a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java
index 8b49863c1be..b8a2112b0ac 100644
--- a/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java
+++ b/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java
@@ -21,7 +21,6 @@ import com.fasterxml.jackson.databind.ObjectMapper;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -46,11 +45,15 @@ import org.apache.beam.sdk.util.ReleaseInfo;
 import org.apache.beam.sdk.util.ZipFiles;
 import org.apache.beam.sdk.util.common.ReflectHelpers;
 import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;
+import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.InvalidProtocolBufferException;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.MoreObjects;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Strings;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Sets;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.hash.HashCode;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.hash.Hashing;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.io.Files;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -111,7 +114,7 @@ public class Environments {
     }
     return defaultEnvironment
         .toBuilder()
-        .addAllDependencies(getArtifacts(options))
+        .addAllDependencies(getDeferredArtifacts(options))
         .addAllCapabilities(getJavaCapabilities())
         .build();
   }
@@ -207,31 +210,94 @@ public class Environments {
     }
   }
 
-  public static Collection<ArtifactInformation> getArtifacts(PipelineOptions options) {
-    Set<String> pathsToStage = Sets.newHashSet();
-    List<String> stagingFiles = options.as(PortablePipelineOptions.class).getFilesToStage();
-    if (stagingFiles != null) {
-      pathsToStage.addAll(stagingFiles);
-    }
-
-    ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();
+  private static List<ArtifactInformation> getArtifacts(List<String> stagingFiles) {
+    Set<String> pathsToStage = Sets.newHashSet(stagingFiles);
+    ImmutableList.Builder<ArtifactInformation> artifactsBuilder = ImmutableList.builder();
     for (String path : pathsToStage) {
       File file = new File(path);
-      if (new File(path).exists()) {
-        // Spurious items get added to the classpath. Filter by just those that exist.
+      // Spurious items get added to the classpath. Filter by just those that exist.
+      if (file.exists()) {
+        ArtifactInformation.Builder artifactBuilder = ArtifactInformation.newBuilder();
+        artifactBuilder.setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.FILE));
+        artifactBuilder.setRoleUrn(BeamUrns.getUrn(StandardArtifacts.Roles.STAGING_TO));
+        artifactBuilder.setRolePayload(
+            RunnerApi.ArtifactStagingToRolePayload.newBuilder()
+                .setStagedName(createStagingFileName(file))
+                .build()
+                .toByteString());
         if (file.isDirectory()) {
-          // Zip up directories so we can upload them to the artifact service.
+          File zippedFile;
+          HashCode hashCode;
           try {
-            filesToStage.add(createArtifactInformation(zipDirectory(file)));
+            zippedFile = zipDirectory(file);
+            hashCode = Files.asByteSource(zippedFile).hash(Hashing.sha256());
           } catch (IOException e) {
             throw new RuntimeException(e);
           }
+          artifactsBuilder.add(
+              artifactBuilder
+                  .setTypePayload(
+                      RunnerApi.ArtifactFilePayload.newBuilder()
+                          .setPath(zippedFile.getPath())
+                          .setSha256(hashCode.toString())
+                          .build()
+                          .toByteString())
+                  .build());
         } else {
-          filesToStage.add(createArtifactInformation(file));
+          HashCode hashCode;
+          try {
+            hashCode = Files.asByteSource(file).hash(Hashing.sha256());
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+          artifactsBuilder.add(
+              artifactBuilder
+                  .setTypePayload(
+                      RunnerApi.ArtifactFilePayload.newBuilder()
+                          .setPath(file.getPath())
+                          .setSha256(hashCode.toString())
+                          .build()
+                          .toByteString())
+                  .build());
         }
       }
     }
-    return filesToStage.build();
+    return artifactsBuilder.build();
+  }
+
+  public static List<ArtifactInformation> getDeferredArtifacts(PipelineOptions options) {
+    List<String> stagingFiles = options.as(PortablePipelineOptions.class).getFilesToStage();
+    if (stagingFiles == null || stagingFiles.isEmpty()) {
+      return ImmutableList.of();
+    }
+
+    String key = UUID.randomUUID().toString();
+    DefaultArtifactResolver.INSTANCE.register(
+        (info) -> {
+          if (BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED).equals(info.getTypeUrn())) {
+            RunnerApi.DeferredArtifactPayload deferredArtifactPayload;
+            try {
+              deferredArtifactPayload =
+                  RunnerApi.DeferredArtifactPayload.parseFrom(info.getTypePayload());
+            } catch (InvalidProtocolBufferException e) {
+              throw new RuntimeException("Error parsing deferred artifact payload.", e);
+            }
+            if (key.equals(deferredArtifactPayload.getKey())) {
+              return Optional.of(getArtifacts(stagingFiles));
+            } else {
+              return Optional.empty();
+            }
+          } else {
+            return Optional.empty();
+          }
+        });
+
+    return ImmutableList.of(
+        ArtifactInformation.newBuilder()
+            .setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED))
+            .setTypePayload(
+                RunnerApi.DeferredArtifactPayload.newBuilder().setKey(key).build().toByteString())
+            .build());
   }
 
   public static Set<String> getJavaCapabilities() {
@@ -243,14 +309,6 @@ public class Environments {
     return capabilities.build();
   }
 
-  private static File zipDirectory(File directory) throws IOException {
-    File zipFile = File.createTempFile(directory.getName(), ".zip");
-    try (FileOutputStream fos = new FileOutputStream(zipFile)) {
-      ZipFiles.zipDirectory(directory, fos);
-    }
-    return zipFile;
-  }
-
   private static String createStagingFileName(File file) {
     // TODO: https://issues.apache.org/jira/browse/BEAM-4109 Support arbitrary names in the staging
     // service itself.
@@ -262,21 +320,12 @@ public class Environments {
     return UUID.randomUUID().toString();
   }
 
-  public static ArtifactInformation createArtifactInformation(File file) {
-    ArtifactInformation.Builder artifactBuilder = ArtifactInformation.newBuilder();
-    artifactBuilder.setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.FILE));
-    artifactBuilder.setTypePayload(
-        RunnerApi.ArtifactFilePayload.newBuilder()
-            .setPath(file.getAbsolutePath())
-            .build()
-            .toByteString());
-    artifactBuilder.setRoleUrn(BeamUrns.getUrn(StandardArtifacts.Roles.STAGING_TO));
-    artifactBuilder.setRolePayload(
-        RunnerApi.ArtifactStagingToRolePayload.newBuilder()
-            .setStagedName(createStagingFileName(file))
-            .build()
-            .toByteString());
-    return artifactBuilder.build();
+  private static File zipDirectory(File directory) throws IOException {
+    File zipFile = File.createTempFile(directory.getName(), ".zip");
+    try (FileOutputStream fos = new FileOutputStream(zipFile)) {
+      ZipFiles.zipDirectory(directory, fos);
+    }
+    return zipFile;
   }
 
   private static class ProcessPayloadReferenceJSON {
diff --git a/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/DefaultArtifactResolverTest.java b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/DefaultArtifactResolverTest.java
new file mode 100644
index 00000000000..3249430cd3f
--- /dev/null
+++ b/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/DefaultArtifactResolverTest.java
@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.runners.core.construction;
+
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.startsWith;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
+
+import java.util.Optional;
+import org.apache.beam.model.pipeline.v1.RunnerApi;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class DefaultArtifactResolverTest {
+  private RunnerApi.Pipeline createEmptyPipeline(
+      Iterable<RunnerApi.ArtifactInformation> dependencies) {
+    return RunnerApi.Pipeline.newBuilder()
+        .setComponents(
+            RunnerApi.Components.newBuilder()
+                .putEnvironments(
+                    "env",
+                    RunnerApi.Environment.newBuilder().addAllDependencies(dependencies).build()))
+        .build();
+  }
+
+  // Testing artifacts
+  private RunnerApi.ArtifactInformation fooMavenArtifact =
+      RunnerApi.ArtifactInformation.newBuilder()
+          .setTypeUrn(BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.MAVEN))
+          .setTypePayload(
+              RunnerApi.MavenPayload.newBuilder()
+                  .setArtifact("org.apache:foo:1.0")
+                  .build()
+                  .toByteString())
+          .build();
+
+  private RunnerApi.ArtifactInformation fooFileArtifact =
+      RunnerApi.ArtifactInformation.newBuilder()
+          .setTypeUrn(BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE))
+          .setTypePayload(
+              RunnerApi.ArtifactFilePayload.newBuilder().setPath("foo.jar").build().toByteString())
+          .build();
+
+  private RunnerApi.ArtifactInformation barFileArtifact =
+      RunnerApi.ArtifactInformation.newBuilder()
+          .setTypeUrn(BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE))
+          .setTypePayload(
+              RunnerApi.ArtifactFilePayload.newBuilder().setPath("bar.jar").build().toByteString())
+          .build();
+
+  private RunnerApi.ArtifactInformation ambientArtifact =
+      RunnerApi.ArtifactInformation.newBuilder()
+          .setTypeUrn(BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.DEFERRED))
+          .setTypePayload(
+              RunnerApi.DeferredArtifactPayload.newBuilder()
+                  .setKey("test-key")
+                  .build()
+                  .toByteString())
+          .build();
+
+  // Testing Resolvers
+  private ArtifactResolver.ResolutionFn dummyMavenFooResolver =
+      info -> {
+        if (info.equals(fooMavenArtifact)) {
+          return Optional.of(ImmutableList.of(fooFileArtifact));
+        } else {
+          return Optional.empty();
+        }
+      };
+
+  private ArtifactResolver.ResolutionFn dummyAmbientFooBarResolver =
+      info -> {
+        if (info.equals(ambientArtifact)) {
+          return Optional.of(ImmutableList.of(fooFileArtifact, barFileArtifact));
+        } else {
+          return Optional.empty();
+        }
+      };
+
+  private ArtifactResolver.ResolutionFn dummyAmbientBarFooResolver =
+      info -> {
+        if (info.equals(ambientArtifact)) {
+          return Optional.of(ImmutableList.of(fooFileArtifact, barFileArtifact));
+        } else {
+          return Optional.empty();
+        }
+      };
+
+  @Test
+  public void testOverridesResolver() {
+    ArtifactResolver resolver = new DefaultArtifactResolver();
+    resolver.register(dummyAmbientBarFooResolver);
+    resolver.register(dummyAmbientFooBarResolver);
+    RunnerApi.Pipeline pipeline =
+        resolver.resolveArtifacts(createEmptyPipeline(ImmutableList.of(ambientArtifact)));
+    assertThat(
+        createEmptyPipeline(ImmutableList.of(fooFileArtifact, barFileArtifact)), equalTo(pipeline));
+  }
+
+  @Test
+  public void testUnknownArtifactInformation() {
+    ArtifactResolver resolver = new DefaultArtifactResolver();
+    resolver.register(dummyMavenFooResolver);
+    try {
+      resolver.resolveArtifacts(
+          createEmptyPipeline(ImmutableList.of(fooMavenArtifact, ambientArtifact)));
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getMessage(), startsWith("Cannot resolve artifact information:"));
+    }
+  }
+}
diff --git a/runners/portability/java/src/main/java/org/apache/beam/runners/portability/PortableRunner.java b/runners/portability/java/src/main/java/org/apache/beam/runners/portability/PortableRunner.java
index f4382173612..78488da79ae 100644
--- a/runners/portability/java/src/main/java/org/apache/beam/runners/portability/PortableRunner.java
+++ b/runners/portability/java/src/main/java/org/apache/beam/runners/portability/PortableRunner.java
@@ -36,6 +36,7 @@ import org.apache.beam.model.pipeline.v1.RunnerApi;
 import org.apache.beam.runners.core.construction.ArtifactServiceStager;
 import org.apache.beam.runners.core.construction.ArtifactServiceStager.StagedFile;
 import org.apache.beam.runners.core.construction.BeamUrns;
+import org.apache.beam.runners.core.construction.DefaultArtifactResolver;
 import org.apache.beam.runners.core.construction.Environments;
 import org.apache.beam.runners.core.construction.PipelineOptionsTranslation;
 import org.apache.beam.runners.core.construction.PipelineTranslation;
@@ -157,6 +158,7 @@ public class PortableRunner extends PipelineRunner<PipelineResult> {
 
     RunnerApi.Pipeline pipelineProto =
         PipelineTranslation.toProto(pipeline, SdkComponents.create(options));
+    pipelineProto = DefaultArtifactResolver.INSTANCE.resolveArtifacts(pipelineProto);
 
     PrepareJobRequest prepareJobRequest =
         PrepareJobRequest.newBuilder()
