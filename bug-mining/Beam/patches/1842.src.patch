diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/FlattenTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/FlattenTest.java
index f70f98bf7f4..07c8a53aa04 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/FlattenTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/FlattenTest.java
@@ -64,6 +64,7 @@ import org.apache.beam.sdk.values.PCollectionView;
 import org.apache.beam.sdk.values.TupleTag;
 import org.apache.beam.sdk.values.TupleTagList;
 import org.apache.beam.sdk.values.TypeDescriptor;
+import org.apache.beam.sdk.values.TypeDescriptors;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;
 import org.joda.time.Duration;
 import org.junit.Assert;
@@ -354,27 +355,45 @@ public class FlattenTest implements Serializable {
   @Test
   @Category(ValidatesRunner.class)
   public void testFlattenWithDifferentInputAndOutputCoders() {
-    // This test exists to prevent a regression in Dataflow. It is important
-    // that Flatten is followed by a GroupByKey.
-    PCollection<KV<String, String>> output = p.apply(Create.of(LINES)).apply(WithKeys.of("a"));
-    output.setCoder(SerializableCoder.of(new TypeDescriptor<KV<String, String>>() {}));
-
-    PCollection<KV<String, String>> output2 =
-        PCollectionList.of(output).apply(Flatten.pCollections());
-    output2.setCoder(KvCoder.of(StringUtf8Coder.of(), StringUtf8Coder.of()));
-    PCollection<String> output3 =
-        output2
+    // This test exists to prevent a regression in Dataflow. It tests a
+    // GroupByKey preceded by a Flatten with an SDK-specific input coder.
+    PCollection<KV<String, String>> flattenInput =
+        p.apply(Create.of(LINES))
+            .apply(WithKeys.of("a"))
+            .setCoder(SerializableCoder.of(new TypeDescriptor<KV<String, String>>() {}));
+    PCollection<String> output =
+        PCollectionList.of(flattenInput)
+            .apply(Flatten.pCollections())
+            .setCoder(KvCoder.of(StringUtf8Coder.of(), StringUtf8Coder.of()))
             .apply(GroupByKey.create())
             .apply(Values.create())
             .apply(
-                FlatMapElements.via(
-                    new SimpleFunction<Iterable<String>, Iterable<String>>() {
-                      @Override
-                      public Iterable<String> apply(Iterable<String> input) {
-                        return input;
-                      }
-                    }));
-    PAssert.that(output3).containsInAnyOrder(LINES);
+                FlatMapElements.into(TypeDescriptors.strings())
+                    .via((Iterable<String> values) -> values));
+    PAssert.that(output).containsInAnyOrder(LINES);
+    p.run();
+  }
+
+  @Test
+  @Category(ValidatesRunner.class)
+  public void testFlattenWithDifferentInputAndOutputCoders2() {
+    // This test exists to prevent a regression in Dataflow. It tests a
+    // GroupByKey followed by a Flatten with an SDK-specific output coder.
+    PCollection<KV<String, Iterable<String>>> flattenInput =
+        p.apply(Create.of(LINES))
+            .apply(WithKeys.of("a"))
+            .setCoder(KvCoder.of(StringUtf8Coder.of(), StringUtf8Coder.of()))
+            .apply(GroupByKey.create());
+    PCollection<String> output =
+        PCollectionList.of(flattenInput)
+            .apply(Flatten.pCollections())
+            .setCoder(SerializableCoder.of(new TypeDescriptor<KV<String, Iterable<String>>>() {}))
+            .apply(Values.create())
+            .setCoder(IterableCoder.of(StringUtf8Coder.of()))
+            .apply(
+                FlatMapElements.into(TypeDescriptors.strings())
+                    .via((Iterable<String> values) -> values));
+    PAssert.that(output).containsInAnyOrder(LINES);
     p.run();
   }
 
