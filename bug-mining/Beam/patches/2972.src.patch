diff --git a/runners/core-java/src/main/java/org/apache/beam/runners/core/StatefulDoFnRunner.java b/runners/core-java/src/main/java/org/apache/beam/runners/core/StatefulDoFnRunner.java
index d375e262615..d4faaf1d3bd 100644
--- a/runners/core-java/src/main/java/org/apache/beam/runners/core/StatefulDoFnRunner.java
+++ b/runners/core-java/src/main/java/org/apache/beam/runners/core/StatefulDoFnRunner.java
@@ -31,13 +31,11 @@ import org.apache.beam.sdk.state.State;
 import org.apache.beam.sdk.state.StateSpec;
 import org.apache.beam.sdk.state.TimeDomain;
 import org.apache.beam.sdk.state.ValueState;
-import org.apache.beam.sdk.state.WatermarkHoldState;
 import org.apache.beam.sdk.transforms.DoFn;
 import org.apache.beam.sdk.transforms.reflect.DoFnSignature;
 import org.apache.beam.sdk.transforms.reflect.DoFnSignatures;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.sdk.transforms.windowing.NonMergingWindowFn;
-import org.apache.beam.sdk.transforms.windowing.TimestampCombiner;
 import org.apache.beam.sdk.transforms.windowing.WindowFn;
 import org.apache.beam.sdk.util.WindowTracing;
 import org.apache.beam.sdk.util.WindowedValue;
@@ -65,7 +63,6 @@ public class StatefulDoFnRunner<InputT, OutputT, W extends BoundedWindow>
   private static final String SORT_BUFFER_STATE = "sortBuffer";
   private static final String SORT_BUFFER_MIN_STAMP = "sortBufferMinStamp";
   private static final String SORT_FLUSH_TIMER = "__StatefulParDoSortFlushTimerId";
-  private static final String SORT_FLUSH_WATERMARK_HOLD = "flushWatermarkHold";
 
   private final DoFnRunner<InputT, OutputT> doFnRunner;
   private final StepContext stepContext;
@@ -79,8 +76,6 @@ public class StatefulDoFnRunner<InputT, OutputT, W extends BoundedWindow>
   private final StateTag<BagState<WindowedValue<InputT>>> sortBufferTag;
   private final StateTag<ValueState<Instant>> sortBufferMinStampTag =
       StateTags.makeSystemTagInternal(StateTags.value(SORT_BUFFER_MIN_STAMP, InstantCoder.of()));
-  private final StateTag<WatermarkHoldState> watermarkHold =
-      StateTags.watermarkStateInternal(SORT_FLUSH_WATERMARK_HOLD, TimestampCombiner.LATEST);
 
   public StatefulDoFnRunner(
       DoFnRunner<InputT, OutputT> doFnRunner,
@@ -116,7 +111,7 @@ public class StatefulDoFnRunner<InputT, OutputT, W extends BoundedWindow>
   }
 
   public List<StateTag<?>> getSystemStateTags() {
-    return Arrays.asList(sortBufferTag, sortBufferMinStampTag, watermarkHold);
+    return Arrays.asList(sortBufferTag, sortBufferMinStampTag);
   }
 
   @Override
@@ -213,6 +208,7 @@ public class StatefulDoFnRunner<InputT, OutputT, W extends BoundedWindow>
       Instant timestamp,
       Instant outputTimestamp,
       TimeDomain timeDomain) {
+
     if (timerId.equals(SORT_FLUSH_TIMER)) {
       onSortFlushTimer(window, stepContext.timerInternals().currentInputWatermarkTime());
     } else if (cleanupTimer.isForWindow(timerId, window, timestamp, timeDomain)) {
@@ -267,8 +263,6 @@ public class StatefulDoFnRunner<InputT, OutputT, W extends BoundedWindow>
     minStampState.write(newMinStamp);
     if (newMinStamp.isBefore(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
       setupFlushTimer(namespace, window, newMinStamp);
-    } else {
-      clearWatermarkHold(namespace);
     }
   }
 
@@ -286,7 +280,6 @@ public class StatefulDoFnRunner<InputT, OutputT, W extends BoundedWindow>
     if (flushWithLateness.isAfter(windowGcTime)) {
       flushWithLateness = windowGcTime;
     }
-    WatermarkHoldState watermark = stepContext.stateInternals().state(namespace, watermarkHold);
     stepContext
         .timerInternals()
         .setTimer(
@@ -296,16 +289,6 @@ public class StatefulDoFnRunner<InputT, OutputT, W extends BoundedWindow>
             flushWithLateness,
             flush,
             TimeDomain.EVENT_TIME);
-    // [BEAM-10533] check if the hold is set (pipelines before release of [BEAM-10533]
-    // this can be removed in soe future versions, when we can assume there is no
-    // running with this state (beam 2.23.0 and older)
-    if (!watermark.isEmpty().read()) {
-      watermark.clear();
-    }
-  }
-
-  private void clearWatermarkHold(StateNamespace namespace) {
-    stepContext.stateInternals().state(namespace, watermarkHold).clear();
   }
 
   /**
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
index f6a6a6e2af2..b0f6cf22e9b 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java
@@ -64,7 +64,6 @@ import org.apache.beam.runners.flink.translation.utils.Workarounds;
 import org.apache.beam.runners.flink.translation.wrappers.streaming.stableinput.BufferingDoFnRunner;
 import org.apache.beam.runners.flink.translation.wrappers.streaming.state.FlinkBroadcastStateInternals;
 import org.apache.beam.runners.flink.translation.wrappers.streaming.state.FlinkStateInternals;
-import org.apache.beam.runners.fnexecution.control.BundleCheckpointHandlers.StateAndTimerBundleCheckpointHandler;
 import org.apache.beam.sdk.coders.Coder;
 import org.apache.beam.sdk.coders.StructuredCoder;
 import org.apache.beam.sdk.coders.VarIntCoder;
@@ -105,7 +104,6 @@ import org.apache.flink.runtime.state.KeyedStateBackend;
 import org.apache.flink.runtime.state.OperatorStateBackend;
 import org.apache.flink.runtime.state.StateInitializationContext;
 import org.apache.flink.runtime.state.StateSnapshotContext;
-import org.apache.flink.runtime.state.VoidNamespace;
 import org.apache.flink.streaming.api.CheckpointingMode;
 import org.apache.flink.streaming.api.graph.StreamConfig;
 import org.apache.flink.streaming.api.operators.ChainingStrategy;
@@ -121,6 +119,7 @@ import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
 import org.apache.flink.streaming.runtime.tasks.StreamTask;
 import org.apache.flink.util.OutputTag;
+import org.apache.flink.util.function.BiConsumerWithException;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.joda.time.Instant;
 import org.slf4j.Logger;
@@ -360,7 +359,7 @@ public class DoFnOperator<InputT, OutputT>
       //      @SuppressWarnings({"unchecked", "rawtypes"})
       Coder windowCoder = windowingStrategy.getWindowFn().windowCoder();
 
-      @SuppressWarnings({"unchecked", "rawtypes"})
+      @SuppressWarnings({"unchecked"})
       StatefulDoFnRunner.StateCleaner<?> stateCleaner =
           new StatefulDoFnRunner.StateInternalsStateCleaner<>(
               doFn, keyedStateInternals, windowCoder);
@@ -448,7 +447,7 @@ public class DoFnOperator<InputT, OutputT>
                 "beam-timer", new CoderTypeSerializer<>(timerCoder, serializedOptions), this);
       }
 
-      timerInternals = new FlinkTimerInternals();
+      timerInternals = new FlinkTimerInternals(timerService);
       timeServiceManagerCompat = getTimeServiceManagerCompat();
     }
 
@@ -912,6 +911,7 @@ public class DoFnOperator<InputT, OutputT>
   }
 
   protected final void invokeFinishBundle() {
+    long previousBundleFinishTime = lastFinishBundleTime;
     if (bundleStarted) {
       LOG.debug("Finishing bundle.");
       pushbackDoFnRunner.finishBundle();
@@ -926,6 +926,14 @@ public class DoFnOperator<InputT, OutputT>
         bundleFinishedCallback.run();
       }
     }
+    try {
+      if (previousBundleFinishTime - getProcessingTimeService().getCurrentProcessingTime()
+          > maxBundleTimeMills) {
+        processInputWatermark(false);
+      }
+    } catch (Exception ex) {
+      LOG.warn("Failed to update downstream watermark", ex);
+    }
   }
 
   @Override
@@ -1056,18 +1064,6 @@ public class DoFnOperator<InputT, OutputT>
     checkArgument(namespace instanceof WindowNamespace);
     BoundedWindow window = ((WindowNamespace) namespace).getWindow();
     timerInternals.onFiredOrDeletedTimer(timerData);
-    Instant effectiveOutputTimestamp;
-
-    if (timerData.getDomain() == TimeDomain.EVENT_TIME) {
-      effectiveOutputTimestamp = timerData.getOutputTimestamp();
-    } else {
-      // Flink does not set a watermark hold for the timer's output timestamp, and previous to
-      // https://github.com/apache/beam/pull/17262 processing time timers did not correctly emit
-      // elements at their output timestamp.  In this case we need to continue doing the wrong thing
-      // and using the output watermark rather than the firing timestamp.  Once flink correctly sets
-      // a  watermark hold for the output timestamp, this should be changed back.
-      effectiveOutputTimestamp = timerInternals.currentOutputWatermarkTime();
-    }
 
     pushbackDoFnRunner.onTimer(
         timerData.getTimerId(),
@@ -1075,7 +1071,7 @@ public class DoFnOperator<InputT, OutputT>
         keyedStateInternals.getKey(),
         window,
         timerData.getTimestamp(),
-        effectiveOutputTimestamp,
+        timerData.getOutputTimestamp(),
         timerData.getDomain());
   }
 
@@ -1366,14 +1362,18 @@ public class DoFnOperator<InputT, OutputT>
      */
     @VisibleForTesting final MapState<String, TimerData> pendingTimersById;
 
-    private FlinkTimerInternals() {
+    private final InternalTimerService<TimerData> timerService;
+
+    private FlinkTimerInternals(InternalTimerService<TimerData> timerService) throws Exception {
       MapStateDescriptor<String, TimerData> pendingTimersByIdStateDescriptor =
           new MapStateDescriptor<>(
               PENDING_TIMERS_STATE_NAME,
               new StringSerializer(),
               new CoderTypeSerializer<>(timerCoder, serializedOptions));
+
       this.pendingTimersById = getKeyedStateStore().getMapState(pendingTimersByIdStateDescriptor);
-      populateOutputTimestampQueue();
+      this.timerService = timerService;
+      populateOutputTimestampQueue(timerService);
     }
 
     /**
@@ -1398,59 +1398,14 @@ public class DoFnOperator<InputT, OutputT>
       }
     }
 
-    /** Keeps a minimum output timestamp across all event timers. */
-    private void onNewEventTimer(TimerData newTimer) {
-      Preconditions.checkState(
-          newTimer.getDomain() == TimeDomain.EVENT_TIME,
-          "Timer with id %s is not an event time timer!",
-          newTimer.getTimerId());
-      if (timerUsesOutputTimestamp(newTimer)) {
-        keyedStateInternals.addWatermarkHoldUsage(newTimer.getOutputTimestamp());
-      }
-    }
-
-    /** Holds the watermark when there is an sdf timer. */
-    private void onNewSdfTimer(TimerData newTimer) {
-      Preconditions.checkState(
-          StateAndTimerBundleCheckpointHandler.isSdfTimer(newTimer.getTimerId()));
-      // An SDF timer should hold the watermark for further output.
-      Preconditions.checkState(timerUsesOutputTimestamp(newTimer));
-      keyedStateInternals.addWatermarkHoldUsage(newTimer.getOutputTimestamp());
-    }
-
-    private void populateOutputTimestampQueue() {
-      final KeyedStateBackend<Object> keyedStateBackend = getKeyedStateBackend();
-      final Object currentKey = keyedStateBackend.getCurrentKey();
-      try (Stream<Object> keys =
-          keyedStateBackend.getKeys(PENDING_TIMERS_STATE_NAME, VoidNamespace.INSTANCE)) {
-        keys.forEach(
-            key -> {
-              keyedStateBackend.setCurrentKey(key);
-              try {
-                for (TimerData timerData : pendingTimersById.values()) {
-                  if (timerData.getDomain() == TimeDomain.EVENT_TIME
-                      || StateAndTimerBundleCheckpointHandler.isSdfTimer(timerData.getTimerId())) {
-                    if (timerUsesOutputTimestamp(timerData)) {
-                      keyedStateInternals.addWatermarkHoldUsage(timerData.getOutputTimestamp());
-                    }
-                  }
-                }
-              } catch (Exception e) {
-                throw new RuntimeException(
-                    "Exception while reading set of timers for key: " + key, e);
-              }
-            });
-      } finally {
-        if (currentKey != null) {
-          keyedStateBackend.setCurrentKey(currentKey);
-        }
-      }
-    }
+    private void populateOutputTimestampQueue(InternalTimerService<TimerData> timerService)
+        throws Exception {
 
-    private boolean timerUsesOutputTimestamp(TimerData timer) {
-      // If a timer's output timestamp is earlier than the timer timestamp,
-      // we have to hold back the output watermark.
-      return timer.getOutputTimestamp().isBefore(timer.getTimestamp());
+      BiConsumerWithException<TimerData, Long, Exception> consumer =
+          (timerData, stamp) ->
+              keyedStateInternals.addWatermarkHoldUsage(timerData.getOutputTimestamp());
+      timerService.forEachEventTimeTimer(consumer);
+      timerService.forEachProcessingTimeTimer(consumer);
     }
 
     private String constructTimerId(String timerFamilyId, String timerId) {
@@ -1506,18 +1461,15 @@ public class DoFnOperator<InputT, OutputT>
       switch (timer.getDomain()) {
         case EVENT_TIME:
           timerService.registerEventTimeTimer(timer, adjustTimestampForFlink(time));
-          onNewEventTimer(timer);
           break;
         case PROCESSING_TIME:
         case SYNCHRONIZED_PROCESSING_TIME:
           timerService.registerProcessingTimeTimer(timer, adjustTimestampForFlink(time));
-          if (StateAndTimerBundleCheckpointHandler.isSdfTimer(timer.getTimerId())) {
-            onNewSdfTimer(timer);
-          }
           break;
         default:
           throw new UnsupportedOperationException("Unsupported time domain: " + timer.getDomain());
       }
+      keyedStateInternals.addWatermarkHoldUsage(timer.getOutputTimestamp());
     }
 
     /**
@@ -1552,12 +1504,7 @@ public class DoFnOperator<InputT, OutputT>
             getContextTimerId(
                 constructTimerId(timer.getTimerFamilyId(), timer.getTimerId()),
                 timer.getNamespace()));
-        if (timer.getDomain() == TimeDomain.EVENT_TIME
-            || StateAndTimerBundleCheckpointHandler.isSdfTimer(timer.getTimerId())) {
-          if (timerUsesOutputTimestamp(timer)) {
-            keyedStateInternals.removeWatermarkHoldUsage(timer.getOutputTimestamp());
-          }
-        }
+        keyedStateInternals.removeWatermarkHoldUsage(timer.getOutputTimestamp());
       } catch (Exception e) {
         throw new RuntimeException("Failed to cleanup pending timers state.", e);
       }
diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
index 0b71305e80f..6e054691c38 100644
--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java
@@ -61,6 +61,7 @@ import org.apache.beam.sdk.values.TimestampedValue;
 import org.apache.beam.sdk.values.TimestampedValue.TimestampedValueCoder;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.MoreObjects;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;
+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.HashMultimap;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;
@@ -152,6 +153,10 @@ public class FlinkStateInternals<K> implements StateInternals {
    */
   private final Set<StateAndNamespaceDescriptor<?>> globalWindowStateDescriptors = new HashSet<>();
 
+  /** Watermark holds descriptors created for a specific window. */
+  private final HashMultimap<String, FlinkWatermarkHoldState> watermarkHoldsMap =
+      HashMultimap.create();
+
   // Watermark holds for all keys/windows of this partition, allows efficient lookup of the minimum
   private final TreeMultiset<Long> watermarkHolds = TreeMultiset.create();
   // State to persist combined watermark holds for all keys of this partition
@@ -213,8 +218,10 @@ public class FlinkStateInternals<K> implements StateInternals {
             stateAndNamespace.stateDescriptor,
             (key, state) -> state.clear());
       }
+      watermarkHoldsMap.values().forEach(FlinkWatermarkHoldState::clear);
       // Clear set to avoid repeating the cleanup
       globalWindowStateDescriptors.clear();
+      watermarkHoldsMap.clear();
     } catch (Exception e) {
       throw new RuntimeException("Failed to cleanup global state.", e);
     }
@@ -330,8 +337,15 @@ public class FlinkStateInternals<K> implements StateInternals {
         String id, StateSpec<WatermarkHoldState> spec, TimestampCombiner timestampCombiner) {
       collectGlobalWindowStateDescriptor(
           watermarkHoldStateDescriptor, VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE);
-      return new FlinkWatermarkHoldState(
-          flinkStateBackend, watermarkHoldStateDescriptor, id, namespace, timestampCombiner);
+      FlinkWatermarkHoldState state =
+          new FlinkWatermarkHoldState(
+              flinkStateBackend, watermarkHoldStateDescriptor, id, namespace, timestampCombiner);
+      collectWatermarkHolds(state);
+      return state;
+    }
+
+    private void collectWatermarkHolds(FlinkWatermarkHoldState state) {
+      watermarkHoldsMap.put(namespace.stringKey(), state);
     }
 
     /** Take note of state bound to the global window for cleanup in clearGlobalState(). */
diff --git a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java
index 3ce0862b38c..fad521e9278 100644
--- a/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java
+++ b/runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperatorTest.java
@@ -27,7 +27,6 @@ import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.collection.IsIterableContainingInOrder.contains;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 
@@ -95,7 +94,6 @@ import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.FluentIt
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;
 import org.apache.flink.api.common.typeinfo.TypeInformation;
 import org.apache.flink.api.java.functions.KeySelector;
 import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;
@@ -308,7 +306,10 @@ public class DoFnOperatorTest {
             eventTimerWithOutputTimestamp
                 .withOutputTimestamp(timerOutputTimestamp)
                 .set(timerTimestamp);
-            processingTimer.offset(Duration.millis(timerTimestamp.getMillis())).setRelative();
+            processingTimer
+                .withOutputTimestamp(new Instant(10))
+                .offset(Duration.millis(timerTimestamp.getMillis()))
+                .setRelative();
           }
 
           @OnTimer(eventTimerId)
@@ -384,7 +385,7 @@ public class DoFnOperatorTest {
 
     testHarness.open();
 
-    testHarness.processWatermark(0);
+    testHarness.processWatermark(499);
     testHarness.setProcessingTime(0);
 
     IntervalWindow window1 = new IntervalWindow(new Instant(0), Duration.millis(10_000));
@@ -400,6 +401,11 @@ public class DoFnOperatorTest {
     testHarness.setProcessingTime(timerTimestamp.getMillis());
 
     assertThat(stripStreamRecordFromWindowedValue(testHarness.getOutput()), emptyIterable());
+    assertThat(doFnOperator.keyedStateInternals.minWatermarkHoldMs(), is(10L));
+
+    // this must fire the processing timer
+    testHarness.setProcessingTime(timerTimestamp.getMillis() + 1);
+
     assertThat(
         doFnOperator.keyedStateInternals.minWatermarkHoldMs(),
         is(timerOutputTimestamp.getMillis()));
@@ -416,19 +422,9 @@ public class DoFnOperatorTest {
                 eventTimeMessage + eventTimerId2,
                 timerTimestamp.minus(Duration.millis(1)),
                 window1,
-                PaneInfo.NO_FIRING)));
-
-    testHarness.getOutput().clear();
-
-    // this must fire the processing timer
-    testHarness.setProcessingTime(timerTimestamp.getMillis() + 1);
+                PaneInfo.NO_FIRING),
+            WindowedValue.of(processingTimeMessage, new Instant(10), window1, PaneInfo.NO_FIRING)));
 
-    ArrayList<WindowedValue<?>> outputs =
-        Lists.newArrayList(stripStreamRecordFromWindowedValue(testHarness.getOutput()));
-    assertEquals(1, outputs.size());
-    assertEquals(processingTimeMessage, outputs.get(0).getValue());
-    assertFalse(timerTimestamp.plus(Duration.millis(1)).isBefore(outputs.get(0).getTimestamp()));
-    assertEquals(Collections.singletonList(window1), outputs.get(0).getWindows());
     testHarness.close();
   }
 
