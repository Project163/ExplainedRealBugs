diff --git a/sdks/python/apache_beam/runners/direct/helper_transforms.py b/sdks/python/apache_beam/runners/direct/helper_transforms.py
index da16d94f010..e648fb48fce 100644
--- a/sdks/python/apache_beam/runners/direct/helper_transforms.py
+++ b/sdks/python/apache_beam/runners/direct/helper_transforms.py
@@ -77,15 +77,15 @@ class PartialGroupByKeyCombiningValues(beam.DoFn):
       yield WindowedValue((k, self._combine_fn.compact(va)), w.end, (w,))
 
   def default_type_hints(self):
-    hints = self._combine_fn.get_type_hints().copy()
+    hints = self._combine_fn.get_type_hints()
     K = typehints.TypeVariable('K')
     if hints.input_types:
       args, kwargs = hints.input_types
       args = (typehints.Tuple[K, args[0]],) + args[1:]
-      hints.set_input_types(*args, **kwargs)
+      hints = hints.with_input_types(*args, **kwargs)
     else:
-      hints.set_input_types(typehints.Tuple[K, typing.Any])
-    hints.set_output_types(typehints.Tuple[K, typing.Any])
+      hints = hints.with_input_types(typehints.Tuple[K, typing.Any])
+    hints = hints.with_output_types(typehints.Tuple[K, typing.Any])
     return hints
 
 
@@ -103,10 +103,10 @@ class FinishCombine(beam.DoFn):
             self._combine_fn.merge_accumulators(vs)))]
 
   def default_type_hints(self):
-    hints = self._combine_fn.get_type_hints().copy()
+    hints = self._combine_fn.get_type_hints()
     K = typehints.TypeVariable('K')
-    hints.set_input_types(typehints.Tuple[K, typing.Any])
+    hints = hints.with_input_types(typehints.Tuple[K, typing.Any])
     if hints.output_types:
       main_output_type = hints.simple_output_type('')
-      hints.set_output_types(typehints.Tuple[K, main_output_type])
+      hints = hints.with_output_types(typehints.Tuple[K, main_output_type])
     return hints
diff --git a/sdks/python/apache_beam/transforms/core.py b/sdks/python/apache_beam/transforms/core.py
index 379b4ea7f14..2c84623d9b1 100644
--- a/sdks/python/apache_beam/transforms/core.py
+++ b/sdks/python/apache_beam/transforms/core.py
@@ -62,6 +62,8 @@ from apache_beam.typehints.decorators import TypeCheckError
 from apache_beam.typehints.decorators import WithTypeHints
 from apache_beam.typehints.decorators import get_signature
 from apache_beam.typehints.decorators import get_type_hints
+from apache_beam.typehints.decorators import with_input_types
+from apache_beam.typehints.decorators import with_output_types
 from apache_beam.typehints.trivial_inference import element_type
 from apache_beam.typehints.typehints import is_consistent_with
 from apache_beam.utils import timestamp
@@ -1047,9 +1049,7 @@ class CallableWrapperCombineFn(CombineFn):
             % input_args[0])
       input_args = (element_type(input_args[0]),) + input_args[1:]
       # TODO(robertwb): Assert output type is consistent with input type?
-      hints = fn_hints.copy()
-      hints.set_input_types(*input_args, **input_kwargs)
-      return hints
+      return fn_hints.with_input_types(*input_args, **input_kwargs)
 
   def for_input_type(self, input_type):
     # Avoid circular imports.
@@ -1447,10 +1447,12 @@ def Map(fn, *args, **kwargs):  # pylint: disable=invalid-name
   # wrapped function.
   type_hints = get_type_hints(fn).with_defaults(
       typehints.decorators.IOTypeHints.from_callable(fn))
-  get_type_hints(wrapper).input_types = type_hints.input_types
+  if type_hints.input_types is not None:
+    wrapper = with_input_types(*type_hints.input_types[0],
+                               **type_hints.input_types[1])(wrapper)
   output_hint = type_hints.simple_output_type(label)
   if output_hint:
-    get_type_hints(wrapper).set_output_types(typehints.Iterable[output_hint])
+    wrapper = with_output_types(typehints.Iterable[output_hint])(wrapper)
   # pylint: disable=protected-access
   wrapper._argspec_fn = fn
   # pylint: enable=protected-access
@@ -1516,10 +1518,12 @@ def MapTuple(fn, *args, **kwargs):  # pylint: disable=invalid-name
   # Proxy the type-hint information from the original function to this new
   # wrapped function.
   type_hints = get_type_hints(fn)
-  get_type_hints(wrapper).input_types = type_hints.input_types
+  if type_hints.input_types is not None:
+    wrapper = with_input_types(*type_hints.input_types[0],
+                               **type_hints.input_types[1])(wrapper)
   output_hint = type_hints.simple_output_type(label)
   if output_hint:
-    get_type_hints(wrapper).set_output_types(typehints.Iterable[output_hint])
+    wrapper = with_output_types(typehints.Iterable[output_hint])(wrapper)
 
   # Replace the first (args) component.
   modified_arg_names = ['tuple_element'] + arg_names[-num_defaults:]
@@ -1586,10 +1590,12 @@ def FlatMapTuple(fn, *args, **kwargs):  # pylint: disable=invalid-name
   # Proxy the type-hint information from the original function to this new
   # wrapped function.
   type_hints = get_type_hints(fn)
-  get_type_hints(wrapper).input_types = type_hints.input_types
+  if type_hints.input_types is not None:
+    wrapper = with_input_types(*type_hints.input_types[0],
+                               **type_hints.input_types[1])(wrapper)
   output_hint = type_hints.simple_output_type(label)
   if output_hint:
-    get_type_hints(wrapper).set_output_types(output_hint)
+    wrapper = with_output_types(output_hint)(wrapper)
 
   # Replace the first (args) component.
   modified_arg_names = ['tuple_element'] + arg_names[-num_defaults:]
@@ -1636,19 +1642,21 @@ def Filter(fn, *args, **kwargs):  # pylint: disable=invalid-name
   # hints from the callable (which should be bool if set).
   fn_type_hints = typehints.decorators.IOTypeHints.from_callable(fn)
   if fn_type_hints is not None:
-    fn_type_hints.output_types = None
+    fn_type_hints = fn_type_hints.with_output_types()
   type_hints = get_type_hints(fn).with_defaults(fn_type_hints)
 
   # Proxy the type-hint information from the function being wrapped, setting the
   # output type to be the same as the input type.
-  get_type_hints(wrapper).input_types = type_hints.input_types
+  if type_hints.input_types is not None:
+    wrapper = with_input_types(*type_hints.input_types[0],
+                               **type_hints.input_types[1])(wrapper)
   output_hint = type_hints.simple_output_type(label)
   if (output_hint is None
       and get_type_hints(wrapper).input_types
       and get_type_hints(wrapper).input_types[0]):
     output_hint = get_type_hints(wrapper).input_types[0][0]
   if output_hint:
-    get_type_hints(wrapper).set_output_types(typehints.Iterable[output_hint])
+    wrapper = with_output_types(typehints.Iterable[output_hint])(wrapper)
   # pylint: disable=protected-access
   wrapper._argspec_fn = fn
   # pylint: enable=protected-access
@@ -1875,17 +1883,17 @@ class CombinePerKey(PTransformWithSideInputs):
         self.fn, *args, **kwargs)
 
   def default_type_hints(self):
-    hints = self.fn.get_type_hints().copy()
+    hints = self.fn.get_type_hints()
     if hints.input_types:
       K = typehints.TypeVariable('K')
       args, kwargs = hints.input_types
       args = (typehints.Tuple[K, args[0]],) + args[1:]
-      hints.set_input_types(*args, **kwargs)
+      hints = hints.with_input_types(*args, **kwargs)
     else:
       K = typehints.Any
     if hints.output_types:
       main_output_type = hints.simple_output_type('')
-      hints.set_output_types(typehints.Tuple[K, main_output_type])
+      hints = hints.with_output_types(typehints.Tuple[K, main_output_type])
     return hints
 
   def to_runner_api_parameter(self,
@@ -1996,17 +2004,17 @@ class CombineValuesDoFn(DoFn):
              self.combinefn.extract_output(accumulator, *args, **kwargs))]
 
   def default_type_hints(self):
-    hints = self.combinefn.get_type_hints().copy()
+    hints = self.combinefn.get_type_hints()
     if hints.input_types:
       K = typehints.TypeVariable('K')
       args, kwargs = hints.input_types
       args = (typehints.Tuple[K, typehints.Iterable[args[0]]],) + args[1:]
-      hints.set_input_types(*args, **kwargs)
+      hints = hints.with_input_types(*args, **kwargs)
     else:
       K = typehints.Any
     if hints.output_types:
       main_output_type = hints.simple_output_type('')
-      hints.set_output_types(typehints.Tuple[K, main_output_type])
+      hints = hints.with_output_types(typehints.Tuple[K, main_output_type])
     return hints
 
 
diff --git a/sdks/python/apache_beam/typehints/decorators.py b/sdks/python/apache_beam/typehints/decorators.py
index 0e675526c65..71b1eda15be 100644
--- a/sdks/python/apache_beam/typehints/decorators.py
+++ b/sdks/python/apache_beam/typehints/decorators.py
@@ -90,6 +90,7 @@ from __future__ import absolute_import
 import inspect
 import logging
 import sys
+import traceback
 import types
 from builtins import next
 from builtins import object
@@ -97,6 +98,8 @@ from builtins import zip
 from typing import Any
 from typing import Callable
 from typing import Dict
+from typing import List
+from typing import NamedTuple
 from typing import Optional
 from typing import Tuple
 from typing import TypeVar
@@ -217,7 +220,10 @@ def get_signature(func):
   return signature
 
 
-class IOTypeHints(object):
+class IOTypeHints(NamedTuple('IOTypeHints', [
+    ('input_types', Optional[Tuple[Tuple[Any, ...], Dict[str, Any]]]),
+    ('output_types', Optional[Tuple[Tuple[Any, ...], Dict[str, Any]]]),
+    ('origin', List[str])])):
   """Encapsulates all type hint information about a Dataflow construct.
 
   This should primarily be used via the WithTypeHints mixin class, though
@@ -228,18 +234,34 @@ class IOTypeHints(object):
       May be None. The list and dict correspond to args and kwargs.
     output_types: (tuple, dict) List of typing types, and an optional dictionary
       (unused). Only the first element of the list is used. May be None.
+    origin: (List[str]) Stack of tracebacks of method calls used to create this
+      instance.
   """
-  __slots__ = ('input_types', 'output_types')
 
-  def __init__(self,
-               input_types=None,  # type: Optional[Tuple[Tuple[Any, ...], Dict[str, Any]]]
-               output_types=None  # type: Optional[Tuple[Tuple[Any, ...], Dict[str, Any]]]
-              ):
-    self.input_types = input_types
-    self.output_types = output_types
+  traceback_limit = 5
 
-  @staticmethod
-  def from_callable(fn):
+  @classmethod
+  def _make_traceback(cls, base):
+    # type: (Optional[IOTypeHints]) -> List[str]
+    # Omit this method and the IOTypeHints method that called it.
+    num_frames_skip = 2
+    tb = traceback.format_stack(limit=cls.traceback_limit + num_frames_skip)
+    tb_lines = 'TH>' + ''.join(tb[:-num_frames_skip]).replace('\n', '\nTH>')
+
+    res = [tb_lines + '\nbased on: ' + str(base)]
+    if base is not None:
+      res += base.origin
+    return res
+
+  @classmethod
+  def empty(cls):
+    # type: () -> IOTypeHints
+    """Construct a base IOTypeHints object with no hints."""
+    return IOTypeHints(None, None, [])
+
+  @classmethod
+  def from_callable(cls, fn):
+    # type: (Callable) -> Optional[IOTypeHints]
     """Construct an IOTypeHints object from a callable's signature.
 
     Supports Python 3 annotations. For partial annotations, sets unknown types
@@ -283,16 +305,21 @@ class IOTypeHints(object):
       output_args.append(typehints.Any)
 
     return IOTypeHints(input_types=(tuple(input_args), input_kwargs),
-                       output_types=(tuple(output_args), {}))
+                       output_types=(tuple(output_args), {}),
+                       origin=cls._make_traceback(None))
 
-  def set_input_types(self, *args, **kwargs):
-    self.input_types = args, kwargs
+  def with_input_types(self, *args, **kwargs):
+    # type: (...) -> IOTypeHints
+    return self._replace(input_types=(args, kwargs),
+                         origin=self._make_traceback(self))
 
-  def set_output_types(self, *args, **kwargs):
-    self.output_types = args, kwargs
+  def with_output_types(self, *args, **kwargs):
+    # type: (...) -> IOTypeHints
+    return self._replace(output_types=(args, kwargs),
+                         origin=self._make_traceback(self))
 
   def simple_output_type(self, context):
-    if self.output_types:
+    if self._has_output_types():
       args, kwargs = self.output_types
       if len(args) != 1 or kwargs:
         raise TypeError(
@@ -306,6 +333,7 @@ class IOTypeHints(object):
             not self.output_types[1])
 
   def strip_iterable(self):
+    # type: () -> IOTypeHints
     """Removes outer Iterable (or equivalent) from output type.
 
     Only affects instances with simple output types, otherwise is a no-op.
@@ -319,12 +347,12 @@ class IOTypeHints(object):
     Example: Generator[Tuple(int, int)] becomes Tuple(int, int)
 
     Returns:
-      A possible copy of this instance with a possibly different output type.
+      A copy of this instance with a possibly different output type.
 
     Raises:
       ValueError if output type is simple and not iterable.
     """
-    if not self.has_simple_output_type():
+    if self.output_types is None or not self.has_simple_output_type():
       return self
     output_type = self.output_types[0][0]
     if output_type is None or isinstance(output_type, type(None)):
@@ -340,13 +368,9 @@ class IOTypeHints(object):
           pass
 
     yielded_type = typehints.get_yielded_type(output_type)
-    res = self.copy()
-    res.output_types = ((yielded_type,), {})
-    return res
-
-  def copy(self):
-    # type: () -> IOTypeHints
-    return IOTypeHints(self.input_types, self.output_types)
+    return self._replace(
+        output_types=((yielded_type,), {}),
+        origin=self._make_traceback(self))
 
   def with_defaults(self, hints):
     # type: (Optional[IOTypeHints]) -> IOTypeHints
@@ -360,7 +384,11 @@ class IOTypeHints(object):
       output_types = self.output_types
     else:
       output_types = hints.output_types
-    return IOTypeHints(input_types, output_types)
+    res = IOTypeHints(input_types, output_types, self._make_traceback(self))
+    if res == self:
+      return self  # Don't needlessly increase origin traceback length.
+    else:
+      return res
 
   def _has_input_types(self):
     return self.input_types is not None and any(self.input_types)
@@ -375,6 +403,9 @@ class IOTypeHints(object):
     return 'IOTypeHints[inputs=%s, outputs=%s]' % (
         self.input_types, self.output_types)
 
+  def debug_str(self):
+    return '\n'.join([self.__repr__()] + self.origin)
+
   def __eq__(self, other):
     def same(a, b):
       if a is None or not any(a):
@@ -391,13 +422,17 @@ class IOTypeHints(object):
   def __hash__(self):
     return hash(str(self))
 
+  def __reduce__(self):
+    # Don't include "origin" debug information in pickled form.
+    return (IOTypeHints, (self.input_types, self.output_types, []))
+
 
 class WithTypeHints(object):
   """A mixin class that provides the ability to set and retrieve type hints.
   """
 
   def __init__(self, *unused_args, **unused_kwargs):
-    self._type_hints = IOTypeHints()
+    self._type_hints = IOTypeHints.empty()
 
   def _get_or_create_type_hints(self):
     # type: () -> IOTypeHints
@@ -406,7 +441,7 @@ class WithTypeHints(object):
       # Only return an instance bound to self (see BEAM-8629).
       return self.__dict__['_type_hints']
     except KeyError:
-      self._type_hints = IOTypeHints()
+      self._type_hints = IOTypeHints.empty()
       return self._type_hints
 
   def get_type_hints(self):
@@ -428,14 +463,16 @@ class WithTypeHints(object):
     # type: (WithTypeHintsT, *Any, **Any) -> WithTypeHintsT
     arg_hints = native_type_compatibility.convert_to_beam_types(arg_hints)
     kwarg_hints = native_type_compatibility.convert_to_beam_types(kwarg_hints)
-    self._get_or_create_type_hints().set_input_types(*arg_hints, **kwarg_hints)
+    self._type_hints = self._get_or_create_type_hints().with_input_types(
+        *arg_hints, **kwarg_hints)
     return self
 
   def with_output_types(self, *arg_hints, **kwarg_hints):
     # type: (WithTypeHintsT, *Any, **Any) -> WithTypeHintsT
     arg_hints = native_type_compatibility.convert_to_beam_types(arg_hints)
     kwarg_hints = native_type_compatibility.convert_to_beam_types(kwarg_hints)
-    self._get_or_create_type_hints().set_output_types(*arg_hints, **kwarg_hints)
+    self._type_hints = self._get_or_create_type_hints().with_output_types(
+        *arg_hints, **kwarg_hints)
     return self
 
 
@@ -637,14 +674,14 @@ def get_type_hints(fn):
   # pylint: disable=protected-access
   if not hasattr(fn, '_type_hints'):
     try:
-      fn._type_hints = IOTypeHints()
+      fn._type_hints = IOTypeHints.empty()
     except (AttributeError, TypeError):
       # Can't add arbitrary attributes to this object,
       # but might have some restrictions anyways...
-      hints = IOTypeHints()
+      hints = IOTypeHints.empty()
       # Python 3.7 introduces annotations for _MethodDescriptorTypes.
       if isinstance(fn, _MethodDescriptorType) and sys.version_info < (3, 7):
-        hints.set_input_types(fn.__objclass__)  # type: ignore
+        hints = hints.with_input_types(fn.__objclass__)  # type: ignore
       return hints
   return fn._type_hints
   # pylint: enable=protected-access
@@ -727,8 +764,9 @@ def with_input_types(*positional_hints, **keyword_hints):
         validate_composite_type_param(
             t, error_msg_prefix='All type hint arguments')
 
-    get_type_hints(f).set_input_types(*converted_positional_hints,
-                                      **converted_keyword_hints)
+    th = getattr(f, '_type_hints', IOTypeHints.empty()).with_input_types(
+        *converted_positional_hints, **converted_keyword_hints)
+    f._type_hints = th  # pylint: disable=protected-access
     return f
   return annotate
 
@@ -811,7 +849,8 @@ def with_output_types(*return_type_hint, **kwargs):
   )
 
   def annotate(f):
-    get_type_hints(f).set_output_types(return_type_hint)
+    th = getattr(f, '_type_hints', IOTypeHints.empty())
+    f._type_hints = th.with_output_types(return_type_hint)  # pylint: disable=protected-access
     return f
 
   return annotate
diff --git a/sdks/python/apache_beam/typehints/decorators_test.py b/sdks/python/apache_beam/typehints/decorators_test.py
index f477f923dc0..3f1747a13d4 100644
--- a/sdks/python/apache_beam/typehints/decorators_test.py
+++ b/sdks/python/apache_beam/typehints/decorators_test.py
@@ -21,9 +21,12 @@
 
 from __future__ import absolute_import
 
+import re
 import sys
 import unittest
 
+import future.tests.base  # pylint: disable=unused-import
+
 from apache_beam.typehints import Any
 from apache_beam.typehints import List
 from apache_beam.typehints import WithTypeHints
@@ -76,13 +79,19 @@ class IOTypeHintsTest(unittest.TestCase):
     self.assertEqual(th.output_types, ((Any,), {}))
 
   def test_strip_iterable_not_simple_output_noop(self):
-    th = decorators.IOTypeHints(output_types=((int, str), {}))
-    th.strip_iterable()
+    th = decorators.IOTypeHints(
+        input_types=None,
+        output_types=((int, str), {}),
+        origin=[])
+    th = th.strip_iterable()
     self.assertEqual(((int, str), {}), th.output_types)
 
   def _test_strip_iterable(self, before, expected_after):
-    after = decorators.IOTypeHints(
-        output_types=((before,), {})).strip_iterable()
+    th = decorators.IOTypeHints(
+        input_types=None,
+        output_types=((before,), {}),
+        origin=[])
+    after = th.strip_iterable()
     self.assertEqual(((expected_after, ), {}), after.output_types)
 
   def _test_strip_iterable_fail(self, before):
@@ -109,6 +118,37 @@ class IOTypeHintsTest(unittest.TestCase):
     self._test_strip_iterable_fail(typehints.WindowedValue[str])
     self._test_strip_iterable_fail(typehints.Dict[str, int])
 
+  def test_make_traceback(self):
+    origin = ''.join(
+        decorators.IOTypeHints.empty().with_input_types(str).origin)
+    self.assertRegex(origin, __name__)
+    # TODO: use self.assertNotRegex once py2 support is removed.
+    self.assertIsNone(re.search(r'\b_make_traceback', origin), msg=origin)
+
+  def test_origin(self):
+    th = decorators.IOTypeHints.empty()
+    self.assertListEqual([], th.origin)
+    th = th.with_input_types(str)
+    self.assertRegex(th.debug_str(), r'with_input_types')
+    th = th.with_output_types(str)
+    self.assertRegex(th.debug_str(), r'(?s)with_output_types.*with_input_types')
+
+  def test_with_defaults_noop_does_not_grow_origin(self):
+    th = decorators.IOTypeHints.empty()
+    expected_id = id(th)
+    th = th.with_defaults(None)
+    self.assertEqual(expected_id, id(th))
+    th = th.with_defaults(decorators.IOTypeHints.empty())
+    self.assertEqual(expected_id, id(th))
+
+    th = th.with_input_types(str)
+    expected_id = id(th)
+    th = th.with_defaults(th)
+    self.assertEqual(expected_id, id(th))
+
+    th2 = th.with_output_types(int)
+    th = th.with_defaults(th2)
+    self.assertNotEqual(expected_id, id(th))
 
 class WithTypeHintsTest(unittest.TestCase):
   def test_get_type_hints_no_settings(self):
@@ -134,7 +174,8 @@ class WithTypeHintsTest(unittest.TestCase):
       def default_type_hints(self):
         return decorators.IOTypeHints(
             input_types=((int, str), {}),
-            output_types=((int, ), {}))
+            output_types=((int, ), {}),
+            origin=[])
 
     th = Base().get_type_hints()
     self.assertEqual(th.input_types, ((int, str), {}))
@@ -146,7 +187,7 @@ class WithTypeHintsTest(unittest.TestCase):
     class Base(WithTypeHints):
       def default_type_hints(self):
         return decorators.IOTypeHints(
-            input_types=((float, ), {}))
+            input_types=((float, ), {}), output_types=None, origin=[])
 
     th = Base().get_type_hints()
     self.assertEqual(th.input_types, ((float, ), {}))
@@ -156,7 +197,7 @@ class WithTypeHintsTest(unittest.TestCase):
     class Base(WithTypeHints):
       def default_type_hints(self):
         return decorators.IOTypeHints(
-            input_types=((float, ), {}), output_types=((str, ), {}))
+            input_types=((float, ), {}), output_types=((str, ), {}), origin=[])
 
     th = Base().with_input_types(int).get_type_hints()
     self.assertEqual(th.input_types, ((int, ), {}))
