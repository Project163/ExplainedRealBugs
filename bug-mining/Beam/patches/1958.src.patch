diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/CoGroup.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/CoGroup.java
index f34e2e0f484..de065dc2860 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/CoGroup.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/CoGroup.java
@@ -43,7 +43,6 @@ import org.apache.beam.sdk.transforms.DoFn;
 import org.apache.beam.sdk.transforms.DoFn.OutputReceiver;
 import org.apache.beam.sdk.transforms.PTransform;
 import org.apache.beam.sdk.transforms.ParDo;
-import org.apache.beam.sdk.transforms.SerializableFunction;
 import org.apache.beam.sdk.transforms.View;
 import org.apache.beam.sdk.transforms.join.CoGbkResult;
 import org.apache.beam.sdk.transforms.join.CoGroupByKey;
@@ -336,8 +335,6 @@ public class CoGroup {
     private final Map<String, PCollectionView<Map<Row, Iterable<Row>>>> sideInputs;
     private final Schema keySchema;
     private final Map<String, Schema> componentSchemas;
-    // Maps from index in sortedTags to the toRow function.
-    private final Map<Integer, SerializableFunction<Object, Row>> toRows;
     private final List<String> sortedTags;
     private final Map<Integer, String> tagToKeyedTag;
 
@@ -346,14 +343,12 @@ public class CoGroup {
         Map<String, PCollectionView<Map<Row, Iterable<Row>>>> sideInputs,
         Schema keySchema,
         Map<String, Schema> componentSchemas,
-        Map<Integer, SerializableFunction<Object, Row>> toRows,
         List<String> sortedTags,
         Map<Integer, String> tagToKeyedTag) {
       this.keyedPCollectionTuple = keyedPCollectionTuple;
       this.sideInputs = sideInputs;
       this.keySchema = keySchema;
       this.componentSchemas = componentSchemas;
-      this.toRows = toRows;
       this.sortedTags = sortedTags;
       this.tagToKeyedTag = tagToKeyedTag;
     }
@@ -374,7 +369,6 @@ public class CoGroup {
       // Keep this in a TreeMap so that it's sorted. This way we get a deterministic output
       // schema.
       TreeMap<String, Schema> componentSchemas = Maps.newTreeMap();
-      Map<Integer, SerializableFunction<Object, Row>> toRows = Maps.newHashMap();
 
       Map<String, PCollectionView<Map<Row, Iterable<Row>>>> sideInputs = Maps.newHashMap();
       Map<Integer, String> tagToKeyedTag = Maps.newHashMap();
@@ -385,7 +379,6 @@ public class CoGroup {
         PCollection<?> pc = entry.getValue();
         Schema schema = pc.getSchema();
         componentSchemas.put(tag, schema);
-        toRows.put(tagIndex, (SerializableFunction<Object, Row>) pc.getToRowFunction());
         FieldAccessDescriptor fieldAccessDescriptor = getFieldAccessDescriptor.apply(tag);
         if (fieldAccessDescriptor == null) {
           throw new IllegalStateException("No fields were set for input " + tag);
@@ -420,7 +413,6 @@ public class CoGroup {
           sideInputs,
           keySchema,
           componentSchemas,
-          toRows,
           sortedTags,
           tagToKeyedTag);
     }
@@ -517,7 +509,6 @@ public class CoGroup {
 
       for (int i = 0; i < joinInformation.sortedTags.size(); ++i) {
         String tupleTag = joinInformation.tagToKeyedTag.get(i);
-        SerializableFunction<Object, Row> toRow = joinInformation.toRows.get(i);
         PCollectionView<Map<Row, Iterable<Row>>> sideView =
             joinInformation.sideInputs.get(tupleTag);
         Iterable<Row> rows =
@@ -527,7 +518,7 @@ public class CoGroup {
         if (rows == null) {
           rows = Collections::emptyIterator;
         }
-        fields.add(Iterables.transform(rows, toRow::apply));
+        fields.add(rows);
         tags.add(joinInformation.sortedTags.get(i));
       }
       return new AutoValue_CoGroup_Result(key, fields, tags, joinArgs, outputSchema);
diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/CoGroupTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/CoGroupTest.java
index 0008605a021..5f2e28dc5c8 100644
--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/CoGroupTest.java
+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/CoGroupTest.java
@@ -23,9 +23,12 @@ import static org.hamcrest.collection.IsIterableContainingInAnyOrder.containsInA
 import static org.junit.Assert.assertThat;
 
 import java.util.List;
+import java.util.Objects;
+import org.apache.beam.sdk.schemas.JavaFieldSchema;
 import org.apache.beam.sdk.schemas.Schema;
 import org.apache.beam.sdk.schemas.Schema.FieldType;
 import org.apache.beam.sdk.schemas.Schema.TypeName;
+import org.apache.beam.sdk.schemas.annotations.DefaultSchema;
 import org.apache.beam.sdk.schemas.transforms.CoGroup.By;
 import org.apache.beam.sdk.schemas.utils.SchemaTestUtils.RowFieldMatcherIterableFieldAnyOrder;
 import org.apache.beam.sdk.testing.NeedsRunner;
@@ -60,6 +63,40 @@ public class CoGroupTest {
           .addStringField("country")
           .build();
 
+  @DefaultSchema(JavaFieldSchema.class)
+  public static class CgPojo {
+    public String user;
+    public int count;
+    public String country;
+
+    public CgPojo() {}
+
+    public CgPojo(String user, int count, String country) {
+      this.user = user;
+      this.count = count;
+      this.country = country;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+      CgPojo cgPojo = (CgPojo) o;
+      return count == cgPojo.count
+          && Objects.equals(user, cgPojo.user)
+          && Objects.equals(country, cgPojo.country);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(user, count, country);
+    }
+  }
+
   private static final Schema SIMPLE_CG_KEY_SCHEMA =
       Schema.builder().addStringField("user").addStringField("country").build();
 
@@ -766,6 +803,71 @@ public class CoGroupTest {
     pipeline.run();
   }
 
+  @Test
+  @Category(NeedsRunner.class)
+  public void testPojo() {
+    List<CgPojo> pc1Rows =
+        Lists.newArrayList(
+            new CgPojo("user1", 1, "us"),
+            new CgPojo("user1", 2, "us"),
+            new CgPojo("user1", 3, "il"),
+            new CgPojo("user1", 4, "il"));
+
+    List<CgPojo> pc2Rows =
+        Lists.newArrayList(
+            new CgPojo("user1", 3, "us"),
+            new CgPojo("user1", 4, "us"),
+            new CgPojo("user1", 5, "il"),
+            new CgPojo("user1", 6, "il"));
+
+    PCollection<CgPojo> pc1 = pipeline.apply("Create1", Create.of(pc1Rows));
+    PCollection<CgPojo> pc2 = pipeline.apply("Create2", Create.of(pc2Rows));
+
+    PCollection<Row> joined =
+        PCollectionTuple.of("pc1", pc1)
+            .and("pc2", pc2)
+            .apply(
+                CoGroup.join("pc1", By.fieldNames("user", "country"))
+                    .join("pc2", By.fieldNames("user", "country")));
+
+    Schema expectedSchema =
+        Schema.builder()
+            .addRowField("key", SIMPLE_CG_KEY_SCHEMA)
+            .addIterableField("pc1", FieldType.row(CG_SCHEMA_1))
+            .addIterableField("pc2", FieldType.row(CG_SCHEMA_1))
+            .build();
+
+    List<Row> expected =
+        Lists.newArrayList(
+            Row.withSchema(expectedSchema)
+                .addValue(Row.withSchema(SIMPLE_CG_KEY_SCHEMA).addValues("user1", "us").build())
+                .addIterable(
+                    Lists.newArrayList(
+                        Row.withSchema(CG_SCHEMA_1).addValues("user1", 1, "us").build(),
+                        Row.withSchema(CG_SCHEMA_1).addValues("user1", 2, "us").build()))
+                .addIterable(
+                    Lists.newArrayList(
+                        Row.withSchema(CG_SCHEMA_1).addValues("user1", 3, "us").build(),
+                        Row.withSchema(CG_SCHEMA_1).addValues("user1", 4, "us").build()))
+                .build(),
+            Row.withSchema(expectedSchema)
+                .addValue(Row.withSchema(SIMPLE_CG_KEY_SCHEMA).addValues("user1", "il").build())
+                .addIterable(
+                    Lists.newArrayList(
+                        Row.withSchema(CG_SCHEMA_1).addValues("user1", 3, "il").build(),
+                        Row.withSchema(CG_SCHEMA_1).addValues("user1", 4, "il").build()))
+                .addIterable(
+                    Lists.newArrayList(
+                        Row.withSchema(CG_SCHEMA_1).addValues("user1", 5, "il").build(),
+                        Row.withSchema(CG_SCHEMA_1).addValues("user1", 6, "il").build()))
+                .build());
+
+    assertEquals(expectedSchema, joined.getSchema());
+    PAssert.that(joined).satisfies(actual -> containsJoinedFields(expected, actual));
+
+    pipeline.run();
+  }
+
   private static Void containsJoinedFields(List<Row> expected, Iterable<Row> actual) {
     List<Matcher<? super Row>> matchers = Lists.newArrayList();
     for (Row row : expected) {
