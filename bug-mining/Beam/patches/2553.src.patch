diff --git a/sdks/python/apache_beam/transforms/ptransform_test.py b/sdks/python/apache_beam/transforms/ptransform_test.py
index ccf0a55d5ea..56965d1a543 100644
--- a/sdks/python/apache_beam/transforms/ptransform_test.py
+++ b/sdks/python/apache_beam/transforms/ptransform_test.py
@@ -505,12 +505,10 @@ class PTransformTest(unittest.TestCase):
           | beam.Create([(1, 1), (1, 2), (1, 3), (1, 4)])
           | WindowInto(
               window.GlobalWindows(),
-              trigger=trigger.AfterCount(5),
+              trigger=trigger.AfterCount(4),
               accumulation_mode=trigger.AccumulationMode.ACCUMULATING)
           | beam.GroupByKey())
-      # We need five, but it only has four - Displays how this option is
-      # dangerous.
-      assert_that(pcoll, is_empty())
+      assert_that(pcoll, equal_to([(1, [1, 2, 3, 4])]))
 
   def test_group_by_key_reiteration(self):
     class MyDoFn(beam.DoFn):
diff --git a/sdks/python/apache_beam/transforms/trigger.py b/sdks/python/apache_beam/transforms/trigger.py
index e16cc54f558..bee05574b29 100644
--- a/sdks/python/apache_beam/transforms/trigger.py
+++ b/sdks/python/apache_beam/transforms/trigger.py
@@ -173,11 +173,6 @@ class DataLossReason(Flag):
   # be lost. Example: AfterCount(1) will stop firing after the first element.
   MAY_FINISH = auto()
 
-  # Trigger has a condition that is not guaranteed to ever be met. In this
-  # case, data that comes in may be lost. Example: AfterCount(42) will lose
-  # 20 records if only 20 come in, since the condition to fire was never met.
-  CONDITION_NOT_GUARANTEED = auto()
-
 
 # Convenience functions for checking if a flag is included. Each is equivalent
 # to `reason & flag == flag`
@@ -188,13 +183,6 @@ def _IncludesMayFinish(reason):
   return reason & DataLossReason.MAY_FINISH == DataLossReason.MAY_FINISH
 
 
-def _IncludesConditionNotGuaranteed(reason):
-  # type: (DataLossReason) -> bool
-  return (
-      reason & DataLossReason.CONDITION_NOT_GUARANTEED ==
-      DataLossReason.CONDITION_NOT_GUARANTEED)
-
-
 # pylint: disable=unused-argument
 # TODO(robertwb): Provisional API, Java likely to change as well.
 class TriggerFn(metaclass=ABCMeta):
@@ -288,11 +276,6 @@ class TriggerFn(metaclass=ABCMeta):
           scenario is only accounted for if the windowing strategy allows
           late data. Otherwise, the trigger is not responsible for the data
           loss.
-        * The trigger condition may not be met. For instance, AfterCount(N)
-          may not fire due to N not being met. This is only accounted for if
-          the condition itself led to data loss. Repeatedly(AfterCount(1)) is
-          safe, since it would only not fire if there is no data to lose, but
-          AfterCount(2) can cause data loss if there is only one record.
 
     Note that this only returns the potential for loss. It does not mean that
     there will be data loss. It also only accounts for loss related to the
@@ -305,9 +288,7 @@ class TriggerFn(metaclass=ABCMeta):
     Returns:
       The DataLossReason. If there is no potential loss,
         DataLossReason.NO_POTENTIAL_LOSS is returned. Otherwise, all the
-        potential reasons are returned as a single value. For instance, if
-        data loss can result from finishing or not having the condition met,
-        the result will be DataLossReason.MAY_FINISH|CONDITION_NOT_GUARANTEED.
+        potential reasons are returned as a single value.
     """
     # For backwards compatibility's sake, we're assuming the trigger is safe.
     return DataLossReason.NO_POTENTIAL_LOSS
@@ -417,15 +398,8 @@ class AfterProcessingTime(TriggerFn):
     pass
 
   def may_lose_data(self, unused_windowing):
-    """AfterProcessingTime may finish.
-
-    It is also possible, if the delay is greater than zero, that data loss
-    could result from not enough seconds passing after processing time.
-    """
-    reason = DataLossReason.MAY_FINISH
-    if self.delay > 0:
-      reason |= DataLossReason.CONDITION_NOT_GUARANTEED
-    return reason
+    """AfterProcessingTime may finish."""
+    return DataLossReason.MAY_FINISH
 
   @staticmethod
   def from_runner_api(proto, context):
@@ -530,7 +504,7 @@ class _Never(TriggerFn):
     """No potential data loss.
 
     Though Never doesn't explicitly trigger, it still collects data on
-    windowing closing, so any data loss is due to windowing closing.
+    windowing closing.
     """
     return DataLossReason.NO_POTENTIAL_LOSS
 
@@ -704,10 +678,8 @@ class AfterCount(TriggerFn):
     context.clear_state(self.COUNT_TAG)
 
   def may_lose_data(self, unused_windowing):
-    reason = DataLossReason.MAY_FINISH
-    if self.count > 1:
-      reason |= DataLossReason.CONDITION_NOT_GUARANTEED
-    return reason
+    """AfterCount may finish."""
+    return DataLossReason.MAY_FINISH
 
   @staticmethod
   def from_runner_api(proto, unused_context):
@@ -863,22 +835,10 @@ class AfterAny(_ParallelTriggerFn):
   combine_op = any
 
   def may_lose_data(self, windowing):
-    """May be flagged as unsafe under certain conditions.
-
-    If any sub-trigger may finish, this one may finish. If all sub-triggers
-    have unguaranteed conditions, then this one has an unguaranteed condition.
-    """
-    reason = DataLossReason.NO_POTENTIAL_LOSS
-    unguaranteed_conditions = 0
-    for trigger in self.triggers:
-      t_reason = trigger.may_lose_data(windowing)
-      if _IncludesMayFinish(t_reason):
-        reason |= DataLossReason.MAY_FINISH
-      if _IncludesConditionNotGuaranteed(t_reason):
-        unguaranteed_conditions += 1
-    if unguaranteed_conditions == len(self.triggers):
-      reason |= DataLossReason.CONDITION_NOT_GUARANTEED
-    return reason
+    """If any sub-trigger may finish, this one may finish."""
+    may_finish = any(t.may_lose_data(windowing) for t in self.triggers)
+    return (DataLossReason.MAY_FINISH if may_finish
+            else DataLossReason.NO_POTENTIAL_LOSS)
 
 
 class AfterAll(_ParallelTriggerFn):
@@ -889,22 +849,10 @@ class AfterAll(_ParallelTriggerFn):
   combine_op = all
 
   def may_lose_data(self, windowing):
-    """May be flagged as unsafe under certain conditions.
-
-    If all sub-triggers may finish, then this may finish. If any sub-trigger
-    has an unguaranteed condition, this has an unguaranteed condition.
-    """
-    reason = DataLossReason.NO_POTENTIAL_LOSS
-    may_finish = 0
-    for trigger in self.triggers:
-      t_reason = trigger.may_lose_data(windowing)
-      if _IncludesMayFinish(t_reason):
-        may_finish += 1
-      if _IncludesConditionNotGuaranteed(t_reason):
-        reason |= DataLossReason.CONDITION_NOT_GUARANTEED
-    if may_finish == len(self.triggers):
-      reason |= DataLossReason.MAY_FINISH
-    return reason
+    """If all sub-triggers may finish, then this may finish."""
+    may_finish = all(t.may_lose_data(windowing) for t in self.triggers)
+    return (DataLossReason.MAY_FINISH if may_finish
+            else DataLossReason.NO_POTENTIAL_LOSS)
 
 
 class AfterEach(TriggerFn):
@@ -962,19 +910,10 @@ class AfterEach(TriggerFn):
       trigger.reset(window, self._sub_context(context, ix))
 
   def may_lose_data(self, windowing):
-    """May be flagged as unsafe under certain conditions.
-
-    If any sub-trigger has NO_POTENTIAL_LOSS or CONDITION_NOT_GUARANTEED, then
-    this will return the same based on the first encountered one. If none of
-    the sub-triggers have either of these, then it will return MAY_FINISH.
-    """
-    for t in self.triggers:
-      reason = t.may_lose_data(windowing)
-      if reason == DataLossReason.NO_POTENTIAL_LOSS:
-        return DataLossReason.NO_POTENTIAL_LOSS
-      if _IncludesConditionNotGuaranteed(reason):
-        return DataLossReason.CONDITION_NOT_GUARANTEED
-    return DataLossReason.MAY_FINISH
+    """If all sub-triggers may finish, this may finish."""
+    may_finish = all(t.may_lose_data(windowing) for t in self.triggers)
+    return (DataLossReason.MAY_FINISH if may_finish
+            else DataLossReason.NO_POTENTIAL_LOSS)
 
   @staticmethod
   def _sub_context(context, index):
diff --git a/sdks/python/apache_beam/transforms/trigger_test.py b/sdks/python/apache_beam/transforms/trigger_test.py
index f75711ca262..2af660afdf1 100644
--- a/sdks/python/apache_beam/transforms/trigger_test.py
+++ b/sdks/python/apache_beam/transforms/trigger_test.py
@@ -449,14 +449,8 @@ class MayLoseDataTest(unittest.TestCase):
   def test_default_trigger(self):
     self._test(DefaultTrigger(), 0, DataLossReason.NO_POTENTIAL_LOSS)
 
-  def test_after_processing_time_zero(self):
-    self._test(AfterProcessingTime(0), 0, DataLossReason.MAY_FINISH)
-
-  def test_after_processing_time_non_zero(self):
-    self._test(
-        AfterProcessingTime(10),
-        0,
-        DataLossReason.MAY_FINISH | DataLossReason.CONDITION_NOT_GUARANTEED)
+  def test_after_processing(self):
+    self._test(AfterProcessingTime(42), 0, DataLossReason.MAY_FINISH)
 
   def test_always(self):
     self._test(Always(), 0, DataLossReason.NO_POTENTIAL_LOSS)
@@ -482,62 +476,23 @@ class MayLoseDataTest(unittest.TestCase):
         60,
         DataLossReason.NO_POTENTIAL_LOSS)
 
-  def test_after_watermark_no_allowed_lateness_may_finish_late(self):
-    self._test(
-        AfterWatermark(late=AfterProcessingTime()),
-        0,
-        DataLossReason.NO_POTENTIAL_LOSS)
-
-  def test_after_watermark_may_finish_late(self):
-    self._test(
-        AfterWatermark(late=AfterProcessingTime(0)),
-        60,
-        #  No loss, since it is wrapped in Repeatedly
-        DataLossReason.NO_POTENTIAL_LOSS)
-
-  def test_after_watermark_no_allowed_lateness_condition_late(self):
-    self._test(
-        AfterWatermark(late=AfterCount(5)), 0, DataLossReason.NO_POTENTIAL_LOSS)
-
-  def test_after_watermark_condition_late(self):
-    self._test(
-        AfterWatermark(late=AfterCount(5)),
-        60,
-        # No loss, since it is wrapped in Repeatedly
-        DataLossReason.NO_POTENTIAL_LOSS)
-
-  def test_after_count_one(self):
-    self._test(AfterCount(1), 0, DataLossReason.MAY_FINISH)
-
-  def test_after_count_gt_one(self):
-    self._test(
-        AfterCount(2),
-        0,
-        DataLossReason.MAY_FINISH | DataLossReason.CONDITION_NOT_GUARANTEED)
+  def test_after_count(self):
+    self._test(AfterCount(42), 0, DataLossReason.MAY_FINISH)
 
   def test_repeatedly_safe_underlying(self):
     self._test(
         Repeatedly(DefaultTrigger()), 0, DataLossReason.NO_POTENTIAL_LOSS)
 
-  def test_repeatedly_may_finish_underlying(self):
-    self._test(Repeatedly(AfterCount(1)), 0, DataLossReason.NO_POTENTIAL_LOSS)
-
-  def test_repeatedly_condition_underlying(self):
-    self._test(Repeatedly(AfterCount(2)), 0, DataLossReason.NO_POTENTIAL_LOSS)
+  def test_repeatedly_unsafe_underlying(self):
+    self._test(Repeatedly(AfterCount(42)), 0, DataLossReason.NO_POTENTIAL_LOSS)
 
   def test_after_any_one_may_finish(self):
     self._test(
-        AfterAny(AfterCount(1), DefaultTrigger()), 0, DataLossReason.MAY_FINISH)
-
-  def test_after_any_one_condition_not_guaranteed(self):
-    self._test(
-        AfterAny(AfterCount(2), AfterWatermark()), 0, DataLossReason.MAY_FINISH)
+        AfterAny(AfterCount(42), DefaultTrigger()), 0, DataLossReason.MAY_FINISH)
 
-  def test_after_any_all_conditions_not_guaranteed(self):
+  def test_after_any_all_safe(self):
     self._test(
-        AfterAny(AfterCount(2), AfterProcessingTime(1)),
-        0,
-        DataLossReason.MAY_FINISH | DataLossReason.CONDITION_NOT_GUARANTEED)
+        AfterAny(Repeatedly(AfterCount(42)), DefaultTrigger()), 0, DataLossReason.NO_POTENTIAL_LOSS)
 
   def test_after_all_some_may_finish(self):
     self._test(
@@ -547,33 +502,19 @@ class MayLoseDataTest(unittest.TestCase):
 
   def test_afer_all_all_may_finish(self):
     self._test(
-        AfterAll(AfterCount(1), AfterProcessingTime(0)),
+        AfterAll(AfterCount(42), AfterProcessingTime(42)),
         0,
         DataLossReason.MAY_FINISH)
 
-  def test_after_all_any_condition_not_guaranteed(self):
-    self._test(
-        AfterAll(AfterCount(2), DefaultTrigger()),
-        0,
-        DataLossReason.CONDITION_NOT_GUARANTEED)
-
-  def test_after_each_safe_comes_first(self):
-    # Note: Safe comes first in relation to CONDITIOON_NOT_GUARANTEED
+  def test_after_each_at_least_one_safe(self):
     self._test(
         AfterEach(AfterCount(1), DefaultTrigger(), AfterCount(2)),
         0,
         DataLossReason.NO_POTENTIAL_LOSS)
 
-  def test_after_each_safe_comes_second(self):
-    # Note: Safe comes second in relation to CONDITIOON_NOT_GUARANTEED
-    self._test(
-        AfterEach(AfterCount(1), AfterCount(2), DefaultTrigger()),
-        0,
-        DataLossReason.CONDITION_NOT_GUARANTEED)
-
   def test_after_each_all_may_finish(self):
     self._test(
-        AfterEach(AfterCount(1), AfterCount(1), AfterCount(1)),
+        AfterEach(AfterCount(1), AfterCount(2), AfterCount(3)),
         0,
         DataLossReason.MAY_FINISH)
 
