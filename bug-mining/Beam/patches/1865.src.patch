diff --git a/sdks/go/pkg/beam/core/runtime/exec/datasource.go b/sdks/go/pkg/beam/core/runtime/exec/datasource.go
index ccc4a09acb5..f9e9a943cba 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/datasource.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/datasource.go
@@ -20,6 +20,7 @@ import (
 	"fmt"
 	"io"
 	"math"
+	"sort"
 	"sync"
 	"time"
 
@@ -266,33 +267,95 @@ func (n *DataSource) Progress() ProgressReportSnapshot {
 	return ProgressReportSnapshot{PID: n.outputPID, ID: n.SID.PtransformID, Name: n.Name, Count: c}
 }
 
-// Split takes a sorted set of potential split indices, selects and actuates
-// split on an appropriate split index, and returns the selected split index
-// if successful. Returns an error when unable to split.
-func (n *DataSource) Split(splits []int64, frac float64) (int64, error) {
-	if splits == nil {
-		return 0, fmt.Errorf("failed to split: requested splits were empty")
-	}
+// Split takes a sorted set of potential split indices and a fraction of the
+// remainder to split at, selects and actuates a split on an appropriate split
+// index, and returns the selected split index if successful or an error when
+// unsuccessful.
+//
+// The bufSize param specifies the estimated number of elements that will be
+// sent to this DataSource, and is used to be able to perform accurate splits
+// even if the DataSource has not yet received all its elements. A bufSize of
+// 0 or less indicates that its unknown, and so uses the current known size.
+func (n *DataSource) Split(splits []int64, frac float64, bufSize int64) (int64, error) {
 	if n == nil {
 		return 0, fmt.Errorf("failed to split at requested splits: {%v}, DataSource not initialized", splits)
 	}
+	if frac > 1.0 {
+		frac = 1.0
+	} else if frac < 0.0 {
+		frac = 0.0
+	}
+
 	n.mu.Lock()
-	c := n.index
-	// Find the smallest split index that we haven't yet processed, and set
-	// the promised split index to this value.
-	for _, s := range splits {
-		// // Never split on the first element, or the current element.
-		if s > 0 && s > c && s <= n.splitIdx {
-			n.splitIdx = s
-			fs := n.splitIdx
-			n.mu.Unlock()
-			return fs, nil
-		}
+	// Size to split within is the minimum of bufSize or splitIdx so we avoid
+	// including elements we already know won't be processed.
+	if bufSize <= 0 || n.splitIdx < bufSize {
+		bufSize = n.splitIdx
+	}
+	s, err := splitHelper(n.index, bufSize, splits, frac)
+	if err != nil {
+		n.mu.Unlock()
+		return 0, err
 	}
+	n.splitIdx = s
+	fs := n.splitIdx
 	n.mu.Unlock()
-	// If we can't find a suitable split index from the requested choices,
-	// return an error.
-	return 0, fmt.Errorf("failed to split at requested splits: {%v}, DataSource at index: %v", splits, c)
+	return fs, nil
+}
+
+// splitHelper is a helper function that finds a split point in a range.
+// currIdx and splitIdx should match the DataSource's index and splitIdx fields,
+// and represent the start and end of the splittable range respectively. splits
+// is an optional slice of valid split indices, and if nil then all indices are
+// considered valid split points. frac must be between [0, 1], and represents
+// a fraction of the remaining work that the split point aims to be as close
+// as possible to.
+func splitHelper(currIdx, splitIdx int64, splits []int64, frac float64) (int64, error) {
+	// Get split index from fraction. Find the closest index to the fraction of
+	// the remainder.
+	var start int64 = 0
+	if currIdx > start {
+		start = currIdx
+	}
+	// This is the first valid split index, since we should never split at 0 or
+	// at the current element.
+	safeStart := start + 1
+	// The remainder starts at our actual progress (i.e. start), but our final
+	// split index has to be >= our safeStart.
+	fracIdx := start + int64(math.Round(frac*float64(splitIdx-start)))
+	if fracIdx < safeStart {
+		fracIdx = safeStart
+	}
+	if splits == nil {
+		// All split points are valid so just split at fraction.
+		return fracIdx, nil
+	} else {
+		// Find the closest unprocessed split point to our fraction.
+		sort.Slice(splits, func(i, j int) bool { return splits[i] < splits[j] })
+		var prevDiff int64 = math.MaxInt64
+		var bestS int64 = -1
+		for _, s := range splits {
+			if s >= safeStart && s <= splitIdx {
+				diff := intAbs(fracIdx - s)
+				if diff <= prevDiff {
+					prevDiff = diff
+					bestS = s
+				} else {
+					break // Stop early if the difference starts increasing.
+				}
+			}
+		}
+		if bestS != -1 {
+			return bestS, nil
+		}
+	}
+	return 0, fmt.Errorf("failed to split DataSource (at index: %v) at requested splits: {%v}", currIdx, splits)
+}
+
+// intAbs implements absolute value for integers via Two's Complement.
+func intAbs(n int64) int64 {
+	y := n >> 63       // y ← x ⟫ 63
+	return (n ^ y) - y // (x ⨁ y) - y
 }
 
 type concatReStream struct {
diff --git a/sdks/go/pkg/beam/core/runtime/exec/datasource_test.go b/sdks/go/pkg/beam/core/runtime/exec/datasource_test.go
index 1ce493cd1d8..c0ff1a941ec 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/datasource_test.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/datasource_test.go
@@ -341,7 +341,7 @@ func TestDataSource_Split(t *testing.T) {
 					<-blockedCh
 					// Validate that we do not split on the element we're blocking on index.
 					// The first valid split is at test.splitIdx.
-					if splitIdx, err := source.Split([]int64{0, 1, 2, 3, 4, 5}, -1); err != nil {
+					if splitIdx, err := source.Split([]int64{0, 1, 2, 3, 4, 5}, -1, 0); err != nil {
 						t.Errorf("error in Split: %v", err)
 					} else if got, want := splitIdx, test.splitIdx; got != want {
 						t.Errorf("error in Split: got splitIdx = %v, want %v ", got, want)
@@ -371,6 +371,57 @@ func TestDataSource_Split(t *testing.T) {
 		}
 	})
 
+	// Test that the bufSize param can be used to affect the split range.
+	t.Run("bufSize", func(t *testing.T) {
+		test := struct {
+			splitPts []int64
+			frac     float64
+			bufSize  int64
+			splitIdx int64
+			expected []interface{}
+		}{
+			// splitIdx defaults to the max int64, so if bufSize is respected
+			// the closest splitPt is 3, otherwise it'll be 5000.
+			splitPts: []int64{3, 5000},
+			frac:     0.5,
+			bufSize:  10,
+			splitIdx: 3,
+			expected: elements[:3],
+		}
+
+		source, out, pr := initSourceTest("bufSize")
+		p, err := NewPlan("a", []Unit{out, source})
+		if err != nil {
+			t.Fatalf("failed to construct plan: %v", err)
+		}
+		dc := DataContext{Data: &TestDataManager{R: pr}}
+		ctx := context.Background()
+
+		// StartBundle resets the source, so no splits can be actuated before then,
+		// which means we need to actuate the plan manually, and insert the split request
+		// after StartBundle.
+		for i, root := range p.units {
+			if err := root.Up(ctx); err != nil {
+				t.Fatalf("error in root[%d].Up: %v", i, err)
+			}
+		}
+		p.status = Active
+
+		runOnRoots(ctx, t, p, "StartBundle", func(root Root, ctx context.Context) error { return root.StartBundle(ctx, "1", dc) })
+
+		// SDK never splits on 0, so check that every test.
+		sp := SplitPoints{Splits: test.splitPts, Frac: test.frac, BufSize: test.bufSize}
+		if splitIdx, err := p.Split(sp); err != nil {
+			t.Fatalf("error in Split: %v", err)
+		} else if got, want := splitIdx, test.splitIdx; got != want {
+			t.Fatalf("error in Split: got splitIdx = %v, want %v ", got, want)
+		}
+		runOnRoots(ctx, t, p, "Process", Root.Process)
+		runOnRoots(ctx, t, p, "FinishBundle", Root.FinishBundle)
+
+		validateSource(t, out, source, makeValues(test.expected...))
+	})
+
 	// Test expects splitting errors, but for processing to be successful.
 	t.Run("errors", func(t *testing.T) {
 		source, out, pr := initSourceTest("noSplitsUntilStarted")
@@ -410,15 +461,93 @@ func TestDataSource_Split(t *testing.T) {
 
 	t.Run("sanity_errors", func(t *testing.T) {
 		var source *DataSource
-		if _, err := source.Split([]int64{0}, -1); err == nil {
+		if _, err := source.Split([]int64{0}, -1, 0); err == nil {
 			t.Fatal("expected error splitting nil *DataSource")
 		}
-		if _, err := source.Split(nil, -1); err == nil {
+		if _, err := source.Split(nil, -1, 0); err == nil {
 			t.Fatal("expected error splitting nil desired splits")
 		}
 	})
 }
 
+// TestSplitHelper tests the underlying split logic to confirm that various
+// cases produce expected split points.
+func TestSplitHelper(t *testing.T) {
+	// Test splits at various fractions.
+	t.Run("SimpleSplits", func(t *testing.T) {
+		tests := []struct {
+			curr, size int64
+			frac       float64
+			want       int64
+		}{
+			// Split as close to the beginning as possible.
+			{curr: 0, size: 16, frac: 0, want: 1},
+			// The closest split is at 4, even when just above or below it.
+			{curr: 0, size: 16, frac: 0.24, want: 4},
+			{curr: 0, size: 16, frac: 0.25, want: 4},
+			{curr: 0, size: 16, frac: 0.26, want: 4},
+			// Split the *remainder* in half.
+			{curr: 0, size: 16, frac: 0.5, want: 8},
+			{curr: 2, size: 16, frac: 0.5, want: 9},
+			{curr: 6, size: 16, frac: 0.5, want: 11},
+		}
+		for _, test := range tests {
+			test := test
+			t.Run(fmt.Sprintf("(%v of [%v, %v])", test.frac, test.curr, test.size), func(t *testing.T) {
+				got, err := splitHelper(test.curr, test.size, nil, test.frac)
+				if err != nil {
+					t.Errorf("error in splitHelper: %v", err)
+				} else if got != test.want {
+					t.Errorf("incorrect split point: got: %v, want: %v", got, test.want)
+				}
+			})
+		}
+	})
+
+	// Test splits with allowed split points.
+	t.Run("WithAllowedSplits", func(t *testing.T) {
+		tests := []struct {
+			curr, size int64
+			splits     []int64
+			frac       float64
+			want       int64
+			err        bool // True if test should cause a failure.
+		}{
+			// The desired split point is at 4.
+			{curr: 0, size: 16, splits: []int64{2, 3, 4, 5}, frac: 0.25, want: 4},
+			// If we can't split at 4, choose the closest possible split point.
+			{curr: 0, size: 16, splits: []int64{2, 3, 5}, frac: 0.25, want: 5},
+			{curr: 0, size: 16, splits: []int64{2, 3, 6}, frac: 0.25, want: 3},
+			// Also test the case where all possible split points lie above or
+			// below the desired split point.
+			{curr: 0, size: 16, splits: []int64{5, 6, 7}, frac: 0.25, want: 5},
+			{curr: 0, size: 16, splits: []int64{1, 2, 3}, frac: 0.25, want: 3},
+			// We have progressed beyond all possible split points, so can't split.
+			{curr: 5, size: 16, splits: []int64{1, 2, 3}, frac: 0.25, err: true},
+		}
+		for _, test := range tests {
+			test := test
+			t.Run(fmt.Sprintf("(%v of [%v, %v], splits = %v)", test.frac, test.curr, test.size, test.splits), func(t *testing.T) {
+				got, err := splitHelper(test.curr, test.size, test.splits, test.frac)
+				if test.err {
+					if err == nil {
+						t.Errorf("splitHelper should have errored, instead got: %v", got)
+					}
+				} else {
+					if err != nil {
+						t.Errorf("error in splitHelper: %v", err)
+					} else if got != test.want {
+						t.Errorf("incorrect split point: got: %v, want: %v", got, test.want)
+					}
+				}
+			})
+		}
+	})
+
+	// TODO(BEAM-9935): Add SDF and element progress splitting tests from Java
+	// and Python once those features are added.
+}
+
 func runOnRoots(ctx context.Context, t *testing.T, p *Plan, name string, mthd func(Root, context.Context) error) {
 	t.Helper()
 	for i, root := range p.roots {
diff --git a/sdks/go/pkg/beam/core/runtime/exec/plan.go b/sdks/go/pkg/beam/core/runtime/exec/plan.go
index fde9e7c78fa..2f07f3c3dba 100644
--- a/sdks/go/pkg/beam/core/runtime/exec/plan.go
+++ b/sdks/go/pkg/beam/core/runtime/exec/plan.go
@@ -198,6 +198,10 @@ type SplitPoints struct {
 	// Splits is a list of desired split indices.
 	Splits []int64
 	Frac   float64
+
+	// Estimated total number of elements (including unsent) for the source.
+	// A zero value indicates unknown, instead use locally known size.
+	BufSize int64
 }
 
 // Split takes a set of potential split indexes, and if successful returns
@@ -206,7 +210,7 @@ type SplitPoints struct {
 // Returns an error when unable to split.
 func (p *Plan) Split(s SplitPoints) (int64, error) {
 	if p.source != nil {
-		return p.source.Split(s.Splits, s.Frac)
+		return p.source.Split(s.Splits, s.Frac, s.BufSize)
 	}
 	return 0, fmt.Errorf("failed to split at requested splits: {%v}, Source not initialized", s)
 }
diff --git a/sdks/go/pkg/beam/core/runtime/harness/harness.go b/sdks/go/pkg/beam/core/runtime/harness/harness.go
index 26cd02e7b03..44099210d04 100644
--- a/sdks/go/pkg/beam/core/runtime/harness/harness.go
+++ b/sdks/go/pkg/beam/core/runtime/harness/harness.go
@@ -310,7 +310,11 @@ func (c *control) handleInstruction(ctx context.Context, req *fnpb.InstructionRe
 		if ds == nil {
 			return fail(ctx, instID, "failed to split: desired splits for root of %v was empty.", ref)
 		}
-		split, err := plan.Split(exec.SplitPoints{Splits: ds.GetAllowedSplitPoints(), Frac: ds.GetFractionOfRemainder()})
+		split, err := plan.Split(exec.SplitPoints{
+			Splits:  ds.GetAllowedSplitPoints(),
+			Frac:    ds.GetFractionOfRemainder(),
+			BufSize: ds.GetEstimatedInputElements(),
+		})
 
 		if err != nil {
 			return fail(ctx, instID, "unable to split %v: %v", ref, err)
