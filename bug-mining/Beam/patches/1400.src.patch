diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamAggregationRule.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamAggregationRule.java
index 2d54ae64961..cbdcf6a920b 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamAggregationRule.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamAggregationRule.java
@@ -57,6 +57,10 @@ public class BeamAggregationRule extends RelOptRule {
     final Aggregate aggregate = call.rel(0);
     final Project project = call.rel(1);
     RelNode x = updateWindow(call, aggregate, project);
+    if (x == null) {
+      // Non-windowed case should be handled by the BeamBasicAggregationRule
+      return;
+    }
     call.transformTo(x);
   }
 
@@ -82,6 +86,10 @@ public class BeamAggregationRule extends RelOptRule {
       }
     }
 
+    if (windowFn == null) {
+      return null;
+    }
+
     final Project newProject =
         project.copy(project.getTraitSet(), project.getInput(), projects, project.getRowType());
 
diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamBasicAggregationRule.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamBasicAggregationRule.java
index 3522cefb37a..9e1def7d00b 100644
--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamBasicAggregationRule.java
+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamBasicAggregationRule.java
@@ -17,14 +17,23 @@
  */
 package org.apache.beam.sdk.extensions.sql.impl.rule;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
 import org.apache.beam.sdk.extensions.sql.impl.rel.BeamAggregationRel;
 import org.apache.beam.sdk.extensions.sql.impl.rel.BeamLogicalConvention;
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptRule;
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptRuleCall;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.volcano.RelSubset;
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.Aggregate;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.Calc;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.Filter;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.Project;
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.RelFactories;
-import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableScan;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;
+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlKind;
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.tools.RelBuilderFactory;
 
 /**
@@ -40,15 +49,22 @@ public class BeamBasicAggregationRule extends RelOptRule {
 
   public BeamBasicAggregationRule(
       Class<? extends Aggregate> aggregateClass, RelBuilderFactory relBuilderFactory) {
-    super(operand(aggregateClass, operand(TableScan.class, any())), relBuilderFactory, null);
+    super(operand(aggregateClass, operand(RelNode.class, any())), relBuilderFactory, null);
   }
 
   @Override
   public void onMatch(RelOptRuleCall call) {
     Aggregate aggregate = call.rel(0);
-    TableScan tableScan = call.rel(1);
+    RelNode relNode = call.rel(1);
 
-    RelNode newTableScan = tableScan.copy(tableScan.getTraitSet(), tableScan.getInputs());
+    if (relNode instanceof Project || relNode instanceof Calc || relNode instanceof Filter) {
+      if (isWindowed(relNode) || hasWindowedParents(relNode)) {
+        // This case is expected to get handled by the 'BeamAggregationRule'
+        return;
+      }
+    }
+
+    RelNode newTableScan = relNode.copy(relNode.getTraitSet(), relNode.getInputs());
 
     call.transformTo(
         new BeamAggregationRel(
@@ -63,4 +79,54 @@ public class BeamBasicAggregationRule extends RelOptRule {
             null,
             -1));
   }
+
+  private static boolean isWindowed(RelNode node) {
+    List<RexNode> projects = null;
+
+    if (node instanceof Project) {
+      projects = new ArrayList<>(((Project) node).getProjects());
+    } else if (node instanceof Calc) {
+      projects =
+          ((Calc) node)
+              .getProgram().getProjectList().stream()
+                  .map(
+                      rexLocalRef ->
+                          ((Calc) node).getProgram().getExprList().get(rexLocalRef.getIndex()))
+                  .collect(Collectors.toList());
+    }
+
+    if (projects != null) {
+      for (RexNode projNode : projects) {
+        if (!(projNode instanceof RexCall)) {
+          continue;
+        }
+
+        SqlKind sqlKind = ((RexCall) projNode).op.kind;
+        if (sqlKind == SqlKind.SESSION || sqlKind == SqlKind.HOP || sqlKind == SqlKind.TUMBLE) {
+          return true;
+        }
+      }
+    }
+
+    return false;
+  }
+
+  private static boolean hasWindowedParents(RelNode node) {
+    List<RelNode> parents = new ArrayList<>();
+
+    for (RelNode inputNode : node.getInputs()) {
+      if (inputNode instanceof RelSubset) {
+        parents.addAll(((RelSubset) inputNode).getParentRels());
+        parents.addAll(((RelSubset) inputNode).getRelList());
+      }
+    }
+
+    for (RelNode parent : parents) {
+      if (isWindowed(parent)) {
+        return true;
+      }
+    }
+
+    return false;
+  }
 }
diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java
index 7591b73e2e1..9b9723c6e3e 100644
--- a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java
+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamSqlDslAggregationTest.java
@@ -49,7 +49,6 @@ import org.apache.beam.sdk.values.TupleTag;
 import org.joda.time.DateTime;
 import org.joda.time.Duration;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
@@ -701,7 +700,6 @@ public class BeamSqlDslAggregationTest extends BeamSqlDslBase {
   }
 
   @Test
-  @Ignore("https://issues.apache.org/jira/browse/BEAM-8317")
   public void testSupportsAggregationWithFilterWithoutProjection() throws Exception {
     pipeline.enableAbandonedNodeEnforcement(false);
 
