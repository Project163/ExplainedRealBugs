diff --git a/sdks/go/pkg/beam/core/runtime/pipelinex/replace.go b/sdks/go/pkg/beam/core/runtime/pipelinex/replace.go
index 8a0a3b90770..76b2ad77170 100644
--- a/sdks/go/pkg/beam/core/runtime/pipelinex/replace.go
+++ b/sdks/go/pkg/beam/core/runtime/pipelinex/replace.go
@@ -19,11 +19,13 @@ package pipelinex
 
 import (
 	"fmt"
+	"regexp"
 	"sort"
 
 	"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx"
 	"github.com/apache/beam/sdks/go/pkg/beam/internal/errors"
 	pipepb "github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1"
+	"github.com/golang/protobuf/proto"
 )
 
 // Update merges a pipeline with the given components, which may add, replace
@@ -243,3 +245,45 @@ func findFreeName(seen map[string]bool, name string) string {
 		}
 	}
 }
+
+// ApplySdkImageOverrides takes a pipeline and a map of patterns to overrides,
+// and proceeds to replace matching ContainerImages in any Environments
+// present in the pipeline. Each environment is expected to match at most one
+// pattern. If an environment matches two or more it is arbitrary which
+// pattern will be applied.
+func ApplySdkImageOverrides(p *pipepb.Pipeline, patterns map[string]string) error {
+	if len(patterns) == 0 {
+		return nil
+	}
+
+	// Precompile all patterns as regexes.
+	regexes := make(map[*regexp.Regexp]string, len(patterns))
+	for p, r := range patterns {
+		re, err := regexp.Compile(p)
+		if err != nil {
+			return err
+		}
+		regexes[re] = r
+	}
+
+	for _, env := range p.GetComponents().GetEnvironments() {
+		var payload pipepb.DockerPayload
+		if err := proto.Unmarshal(env.GetPayload(), &payload); err != nil {
+			return err
+		}
+		oldImg := payload.GetContainerImage()
+		for re, replacement := range regexes {
+			newImg := re.ReplaceAllLiteralString(oldImg, replacement)
+			if newImg != oldImg {
+				payload.ContainerImage = newImg
+				pl, err := proto.Marshal(&payload)
+				if err != nil {
+					return err
+				}
+				env.Payload = pl
+				break // Apply at most one override to each environment.
+			}
+		}
+	}
+	return nil
+}
diff --git a/sdks/go/pkg/beam/core/runtime/pipelinex/replace_test.go b/sdks/go/pkg/beam/core/runtime/pipelinex/replace_test.go
index 7bb395a3386..334056fa20a 100644
--- a/sdks/go/pkg/beam/core/runtime/pipelinex/replace_test.go
+++ b/sdks/go/pkg/beam/core/runtime/pipelinex/replace_test.go
@@ -21,6 +21,7 @@ import (
 	pipepb "github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1"
 	"github.com/golang/protobuf/proto"
 	"github.com/google/go-cmp/cmp"
+	"google.golang.org/protobuf/testing/protocmp"
 )
 
 func TestEnsureUniqueName(t *testing.T) {
@@ -200,3 +201,95 @@ func TestComputeInputOutput(t *testing.T) {
 		})
 	}
 }
+
+func TestApplySdkImageOverrides(t *testing.T) {
+	tests := []struct {
+		name     string
+		patterns map[string]string
+		envs     map[string]string // Environment ID to container image name.
+		want     map[string]string // Environment ID to final container image names.
+	}{
+		{
+			name:     "Basic",
+			patterns: map[string]string{".*foo.*": "foo:override"},
+			envs: map[string]string{
+				"foobar": "foo:invalid",
+				"bar":    "bar:valid",
+			},
+			want: map[string]string{
+				"foobar": "foo:override",
+				"bar":    "bar:valid",
+			},
+		},
+		{
+			name: "MultiplePatterns",
+			patterns: map[string]string{
+				".*foo.*": "foo:override",
+				".*bar.*": "bar:override",
+			},
+			envs: map[string]string{
+				"foobaz": "foo:invalid",
+				"barbaz": "bar:invalid",
+			},
+			want: map[string]string{
+				"foobaz": "foo:override",
+				"barbaz": "bar:override",
+			},
+		},
+		{
+			name:     "MultipleMatches",
+			patterns: map[string]string{".*foo.*": "foo:override"},
+			envs: map[string]string{
+				"foo1": "foo1:invalid",
+				"foo2": "foo2:invalid",
+			},
+			want: map[string]string{
+				"foo1": "foo:override",
+				"foo2": "foo:override",
+			},
+		},
+	}
+
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			envs := make(map[string]*pipepb.Environment)
+			for id, ci := range test.envs {
+				env := buildEnvironment(t, ci)
+				envs[id] = env
+			}
+			wantEnvs := make(map[string]*pipepb.Environment)
+			for id, ci := range test.want {
+				env := buildEnvironment(t, ci)
+				wantEnvs[id] = env
+			}
+
+			p := &pipepb.Pipeline{
+				Components: &pipepb.Components{
+					Environments: envs,
+				},
+			}
+			if err := ApplySdkImageOverrides(p, test.patterns); err != nil {
+				t.Fatalf("ApplySdkImageOverrides failed: %v", err)
+			}
+			if diff := cmp.Diff(envs, wantEnvs, protocmp.Transform()); diff != "" {
+				t.Errorf("ApplySdkImageOverrides gave incorrect output: diff(-want,+got):\n %v", diff)
+			}
+		})
+	}
+}
+
+func buildEnvironment(t *testing.T, containerImg string) *pipepb.Environment {
+	t.Helper()
+	env := &pipepb.Environment{
+		Urn:          "alpha",
+		DisplayData:  []*pipepb.DisplayData{{Urn: "beta"}},
+		Capabilities: []string{"delta", "gamma"},
+	}
+	pl := pipepb.DockerPayload{ContainerImage: containerImg}
+	plb, err := proto.Marshal(&pl)
+	if err != nil {
+		t.Fatalf("Failed to marshal DockerPayload with container image %v: %v", containerImg, err)
+	}
+	env.Payload = plb
+	return env
+}
diff --git a/sdks/go/pkg/beam/core/runtime/xlangx/expand.go b/sdks/go/pkg/beam/core/runtime/xlangx/expand.go
index 3ecd82e5161..ff320f77ed0 100644
--- a/sdks/go/pkg/beam/core/runtime/xlangx/expand.go
+++ b/sdks/go/pkg/beam/core/runtime/xlangx/expand.go
@@ -60,8 +60,6 @@ func Expand(edge *graph.MultiEdge, ext *graph.ExternalTransform) error {
 	// Scoping the ExternalTransform with respect to it's unique namespace, thus
 	// avoiding future collisions
 	addNamespace(extTransform, p.GetComponents(), ext.Namespace)
-
-	graphx.AddFakeImpulses(p) // Inputs need to have sources
 	delete(transforms, extTransformID)
 
 	// Querying the expansion service
@@ -74,7 +72,6 @@ func Expand(edge *graph.MultiEdge, ext *graph.ExternalTransform) error {
 
 	// Previously added fake impulses need to be removed to avoid having
 	// multiple sources to the same pcollection in the graph
-	graphx.RemoveFakeImpulses(res.GetComponents(), res.GetTransform())
 
 	exp := &graph.ExpandedTransform{
 		Components:   res.GetComponents(),
diff --git a/sdks/go/pkg/beam/core/runtime/xlangx/namespace.go b/sdks/go/pkg/beam/core/runtime/xlangx/namespace.go
index 06956a61cf8..ae38d48e446 100644
--- a/sdks/go/pkg/beam/core/runtime/xlangx/namespace.go
+++ b/sdks/go/pkg/beam/core/runtime/xlangx/namespace.go
@@ -67,11 +67,6 @@ func addWindowingStrategyID(c *pipepb.Components, idMap map[string]string, wid s
 		windowingStrategy.WindowCoderId = addCoderID(c, idMap, windowingStrategy.WindowCoderId, newID)
 	}
 
-	// Updating EnvironmentId of WindowingStrategy
-	if windowingStrategy.EnvironmentId != "" {
-		windowingStrategy.EnvironmentId = addEnvironmentID(c, idMap, windowingStrategy.EnvironmentId, newID)
-	}
-
 	idMap[wid] = newID(wid)
 
 	// Updating WindowingStrategies map
@@ -81,25 +76,6 @@ func addWindowingStrategyID(c *pipepb.Components, idMap map[string]string, wid s
 	return idMap[wid]
 }
 
-func addEnvironmentID(c *pipepb.Components, idMap map[string]string, eid string, newID func(string) string) string {
-	if _, exists := idMap[eid]; exists {
-		return idMap[eid]
-	}
-
-	environment, exists := c.Environments[eid]
-	if !exists {
-		panic(errors.Errorf("attempted to add namespace to missing windowing strategy id: %v not in %v", eid, c.Environments))
-	}
-
-	idMap[eid] = newID(eid)
-
-	// Updating Environments map
-	c.Environments[idMap[eid]] = environment
-	delete(c.Environments, eid)
-
-	return idMap[eid]
-}
-
 func addNamespace(t *pipepb.PTransform, c *pipepb.Components, namespace string) {
 	newID := func(id string) string {
 		return fmt.Sprintf("%v@%v", id, namespace)
@@ -107,10 +83,11 @@ func addNamespace(t *pipepb.PTransform, c *pipepb.Components, namespace string)
 
 	idMap := make(map[string]string)
 
-	// Update Environment ID of PTransform
-	if t.EnvironmentId != "" {
-		t.EnvironmentId = addEnvironmentID(c, idMap, t.EnvironmentId, newID)
-	}
+	// Note: Currently environments are not namespaced. This works under the
+	// assumption that the unexpanded transform is using the default Go SDK
+	// environment. If multiple Go SDK environments become possible, then
+	// namespacing of non-default environments should happen here.
+
 	for _, pcolsMap := range []map[string]string{t.Inputs, t.Outputs} {
 		for _, pid := range pcolsMap {
 			if pcol, exists := c.Pcollections[pid]; exists {
diff --git a/sdks/go/pkg/beam/core/runtime/xlangx/namespace_test.go b/sdks/go/pkg/beam/core/runtime/xlangx/namespace_test.go
index 49b2e2032b8..e02b8c5f5ec 100644
--- a/sdks/go/pkg/beam/core/runtime/xlangx/namespace_test.go
+++ b/sdks/go/pkg/beam/core/runtime/xlangx/namespace_test.go
@@ -100,25 +100,25 @@ func TestAddNamespace(t *testing.T) {
 						UniqueName:    "t0",
 						Inputs:        map[string]string{"t0i0": "p0"},
 						Outputs:       map[string]string{"t0o0": "p1", "t0o1": "p2"},
-						EnvironmentId: "e0@daASxQwenJ",
+						EnvironmentId: "e0",
 					},
 					"t1": {
 						UniqueName:    "t1",
 						Inputs:        map[string]string{"t1i0": "p1"},
 						Outputs:       map[string]string{"t1o0": "p3"},
-						EnvironmentId: "e1@daASxQwenJ",
+						EnvironmentId: "e1",
 					},
 					"t2": {
 						UniqueName:    "t2",
 						Inputs:        map[string]string{"t2i0": "p2"},
 						Outputs:       map[string]string{"t2o0": "p4"},
-						EnvironmentId: "e0@daASxQwenJ",
+						EnvironmentId: "e0",
 					},
 					"t3": {
 						UniqueName:    "t3",
 						Inputs:        map[string]string{"t3i0": "p3", "t3i1": "p4"},
 						Outputs:       map[string]string{"t3o0": "p5"},
-						EnvironmentId: "e1@daASxQwenJ",
+						EnvironmentId: "e1",
 					},
 				},
 				Pcollections: map[string]*pipepb.PCollection{
@@ -131,7 +131,7 @@ func TestAddNamespace(t *testing.T) {
 				},
 				WindowingStrategies: map[string]*pipepb.WindowingStrategy{
 					"w0":            {WindowCoderId: "c3", EnvironmentId: "e0"},
-					"w1@daASxQwenJ": {WindowCoderId: "c4@daASxQwenJ", EnvironmentId: "e1@daASxQwenJ"},
+					"w1@daASxQwenJ": {WindowCoderId: "c4@daASxQwenJ", EnvironmentId: "e1"},
 				},
 				Coders: map[string]*pipepb.Coder{
 					"c0@daASxQwenJ": {Spec: &pipepb.FunctionSpec{Urn: "c0"}},
@@ -141,8 +141,8 @@ func TestAddNamespace(t *testing.T) {
 					"c4@daASxQwenJ": {Spec: &pipepb.FunctionSpec{Urn: "c4"}},
 				},
 				Environments: map[string]*pipepb.Environment{
-					"e0@daASxQwenJ": {Urn: "e0"},
-					"e1@daASxQwenJ": {Urn: "e1"},
+					"e0": {Urn: "e0"},
+					"e1": {Urn: "e1"},
 				},
 			},
 		},
@@ -213,7 +213,7 @@ func TestAddNamespace(t *testing.T) {
 						UniqueName:    "t1",
 						Inputs:        map[string]string{"t1i0": "p1"},
 						Outputs:       map[string]string{"t1o0": "p3"},
-						EnvironmentId: "e1@daASxQwenJ",
+						EnvironmentId: "e1",
 					},
 					"t2": {
 						UniqueName:    "t2",
@@ -225,7 +225,7 @@ func TestAddNamespace(t *testing.T) {
 						UniqueName:    "t3",
 						Inputs:        map[string]string{"t3i0": "p3", "t3i1": "p4"},
 						Outputs:       map[string]string{"t3o0": "p5"},
-						EnvironmentId: "e1@daASxQwenJ",
+						EnvironmentId: "e1",
 					},
 				},
 				Pcollections: map[string]*pipepb.PCollection{
@@ -238,7 +238,7 @@ func TestAddNamespace(t *testing.T) {
 				},
 				WindowingStrategies: map[string]*pipepb.WindowingStrategy{
 					"w0":            {WindowCoderId: "c3", EnvironmentId: "e0"},
-					"w1@daASxQwenJ": {WindowCoderId: "c4@daASxQwenJ", EnvironmentId: "e1@daASxQwenJ"},
+					"w1@daASxQwenJ": {WindowCoderId: "c4@daASxQwenJ", EnvironmentId: "e1"},
 				},
 				Coders: map[string]*pipepb.Coder{
 					"c0":            {Spec: &pipepb.FunctionSpec{Urn: "c0"}},
@@ -248,8 +248,8 @@ func TestAddNamespace(t *testing.T) {
 					"c4@daASxQwenJ": {Spec: &pipepb.FunctionSpec{Urn: "c4"}},
 				},
 				Environments: map[string]*pipepb.Environment{
-					"e0":            {Urn: "e0"},
-					"e1@daASxQwenJ": {Urn: "e1"},
+					"e0": {Urn: "e0"},
+					"e1": {Urn: "e1"},
 				},
 			},
 		},
@@ -314,25 +314,25 @@ func TestAddNamespace(t *testing.T) {
 						UniqueName:    "t0",
 						Inputs:        map[string]string{"t0i0": "p0"},
 						Outputs:       map[string]string{"t0o0": "p1", "t0o1": "p2"},
-						EnvironmentId: "e0@daASxQwenJ",
+						EnvironmentId: "e0",
 					},
 					"t1": {
 						UniqueName:    "t1",
 						Inputs:        map[string]string{"t1i0": "p1"},
 						Outputs:       map[string]string{"t1o0": "p3"},
-						EnvironmentId: "e1@daASxQwenJ",
+						EnvironmentId: "e1",
 					},
 					"t2": {
 						UniqueName:    "t2",
 						Inputs:        map[string]string{"t2i0": "p2"},
 						Outputs:       map[string]string{"t2o0": "p4"},
-						EnvironmentId: "e0@daASxQwenJ",
+						EnvironmentId: "e0",
 					},
 					"t3": {
 						UniqueName:    "t3",
 						Inputs:        map[string]string{"t3i0": "p3", "t3i1": "p4"},
 						Outputs:       map[string]string{"t3o0": "p5"},
-						EnvironmentId: "e1@daASxQwenJ",
+						EnvironmentId: "e1",
 					},
 				},
 				Pcollections: map[string]*pipepb.PCollection{
@@ -344,8 +344,8 @@ func TestAddNamespace(t *testing.T) {
 					"p5": {CoderId: "c2@daASxQwenJ", WindowingStrategyId: "w1@daASxQwenJ"},
 				},
 				WindowingStrategies: map[string]*pipepb.WindowingStrategy{
-					"w0@daASxQwenJ": {WindowCoderId: "c3@daASxQwenJ", EnvironmentId: "e0@daASxQwenJ"},
-					"w1@daASxQwenJ": {WindowCoderId: "c4@daASxQwenJ", EnvironmentId: "e1@daASxQwenJ"},
+					"w0@daASxQwenJ": {WindowCoderId: "c3@daASxQwenJ", EnvironmentId: "e0"},
+					"w1@daASxQwenJ": {WindowCoderId: "c4@daASxQwenJ", EnvironmentId: "e1"},
 				},
 				Coders: map[string]*pipepb.Coder{
 					"c0":            {Spec: &pipepb.FunctionSpec{Urn: "c0"}},
@@ -355,8 +355,8 @@ func TestAddNamespace(t *testing.T) {
 					"c4@daASxQwenJ": {Spec: &pipepb.FunctionSpec{Urn: "c4"}},
 				},
 				Environments: map[string]*pipepb.Environment{
-					"e0@daASxQwenJ": {Urn: "e0"},
-					"e1@daASxQwenJ": {Urn: "e1"},
+					"e0": {Urn: "e0"},
+					"e1": {Urn: "e1"},
 				},
 			},
 		},
@@ -406,13 +406,13 @@ func TestAddNamespace(t *testing.T) {
 						UniqueName:    "t0",
 						Inputs:        map[string]string{"t0i0": "p0"},
 						Outputs:       map[string]string{"t0o0": "p1"},
-						EnvironmentId: "e0@daASxQwenJ",
+						EnvironmentId: "e0",
 					},
 					"t1": {
 						UniqueName:    "t1",
 						Inputs:        map[string]string{"t1i0": "p1"},
 						Outputs:       map[string]string{"t1o0": "p2"},
-						EnvironmentId: "e1@daASxQwenJ",
+						EnvironmentId: "e1",
 					},
 				},
 				Pcollections: map[string]*pipepb.PCollection{
@@ -421,8 +421,8 @@ func TestAddNamespace(t *testing.T) {
 					"p2": {CoderId: "c0@daASxQwenJ", WindowingStrategyId: "w1@daASxQwenJ"},
 				},
 				WindowingStrategies: map[string]*pipepb.WindowingStrategy{
-					"w0@daASxQwenJ": {WindowCoderId: "c3@daASxQwenJ", EnvironmentId: "e0@daASxQwenJ"},
-					"w1@daASxQwenJ": {WindowCoderId: "c4@daASxQwenJ", EnvironmentId: "e1@daASxQwenJ"},
+					"w0@daASxQwenJ": {WindowCoderId: "c3@daASxQwenJ", EnvironmentId: "e0"},
+					"w1@daASxQwenJ": {WindowCoderId: "c4@daASxQwenJ", EnvironmentId: "e1"},
 				},
 				Coders: map[string]*pipepb.Coder{
 					"c0@daASxQwenJ": {Spec: &pipepb.FunctionSpec{Urn: "c0"}, ComponentCoderIds: []string{"c2@daASxQwenJ"}},
@@ -432,8 +432,8 @@ func TestAddNamespace(t *testing.T) {
 					"c4@daASxQwenJ": {Spec: &pipepb.FunctionSpec{Urn: "c4"}},
 				},
 				Environments: map[string]*pipepb.Environment{
-					"e0@daASxQwenJ": {Urn: "e0"},
-					"e1@daASxQwenJ": {Urn: "e1"},
+					"e0": {Urn: "e0"},
+					"e1": {Urn: "e1"},
 				},
 			},
 		},
diff --git a/sdks/go/pkg/beam/options/jobopts/options.go b/sdks/go/pkg/beam/options/jobopts/options.go
index f1a159d1980..6ed13de144d 100644
--- a/sdks/go/pkg/beam/options/jobopts/options.go
+++ b/sdks/go/pkg/beam/options/jobopts/options.go
@@ -31,6 +31,21 @@ import (
 	"github.com/apache/beam/sdks/go/pkg/beam/log"
 )
 
+func init() {
+	flag.Var(&SdkHarnessContainerImageOverrides,
+		"sdk_harness_container_image_override",
+		"Overrides for SDK harness container images. Could be for the "+
+			"local SDK or for a remote SDK that pipeline has to support due "+
+			"to a cross-language transform. Each entry consists of two values "+
+			"separated by a comma where first value gives a regex to "+
+			"identify the container image to override and the second value "+
+			"gives the replacement container image. Multiple entries can be "+
+			"specified by using this flag multiple times. A container will "+
+			"have no more than 1 override applied to it. If multiple "+
+			"overrides match a container image it is arbitrary which "+
+			"will be applied.")
+}
+
 var (
 	// Endpoint is the job service endpoint.
 	Endpoint = flag.String("endpoint", "", "Job service endpoint (required).")
@@ -52,6 +67,10 @@ var (
 			"\"env\":{\"<Environment variables 1>\": \"<ENV_VAL>\"} }. "+
 			"All fields in the json are optional except command.")
 
+	// SdkHarnessContainerImageOverrides contains patterns for overriding
+	// container image names in a pipeline.
+	SdkHarnessContainerImageOverrides stringSlice
+
 	// WorkerBinary is the location of the compiled worker binary. If not
 	// specified, the binary is produced via go build.
 	WorkerBinary = flag.String("worker_binary", "", "Worker binary (optional)")
@@ -128,6 +147,18 @@ func GetEnvironmentConfig(ctx context.Context) string {
 	return *EnvironmentConfig
 }
 
+// GetSdkImageOverrides gets the specified overrides as a map where each key is
+// a regular expression pattern to match, and each value is the string to
+// replace matching containers with.
+func GetSdkImageOverrides() map[string]string {
+	ret := make(map[string]string)
+	for _, pattern := range SdkHarnessContainerImageOverrides {
+		splits := strings.SplitN(pattern, ",", 2)
+		ret[splits[0]] = splits[1]
+	}
+	return ret
+}
+
 // GetExperiments returns the experiments.
 func GetExperiments() []string {
 	if *Experiments == "" {
diff --git a/sdks/go/pkg/beam/options/jobopts/stringSlice.go b/sdks/go/pkg/beam/options/jobopts/stringSlice.go
new file mode 100644
index 00000000000..d9111d21ba1
--- /dev/null
+++ b/sdks/go/pkg/beam/options/jobopts/stringSlice.go
@@ -0,0 +1,44 @@
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements.  See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package jobopts
+
+import (
+	"fmt"
+)
+
+// stringSlice is a flag.Value implementation for string slices, that allows
+// multiple strings to be assigned to one flag by specifying multiple instances
+// of the flag.
+//
+// Example:
+//    var myFlags stringSlice
+//    flag.Var(&myFlags, "my_flag", "A list of flags")
+// With the example above, the slice can be set to contain ["foo", "bar"]:
+//    cmd -my_flag foo -my_flag bar
+type stringSlice []string
+
+// String implements the String method of flag.Value. This outputs the value
+// of the flag as a string.
+func (s *stringSlice) String() string {
+	return fmt.Sprintf("%v", *s)
+}
+
+// Set implements the Set method of flag.Value. This stores a string input to
+// the flag into a stringSlice representation.
+func (s *stringSlice) Set(value string) error {
+	*s = append(*s, value)
+	return nil
+}
diff --git a/sdks/go/pkg/beam/runners/dataflow/dataflow.go b/sdks/go/pkg/beam/runners/dataflow/dataflow.go
index e56da342cba..c46ff4cbadd 100644
--- a/sdks/go/pkg/beam/runners/dataflow/dataflow.go
+++ b/sdks/go/pkg/beam/runners/dataflow/dataflow.go
@@ -31,6 +31,7 @@ import (
 	"cloud.google.com/go/storage"
 	"github.com/apache/beam/sdks/go/pkg/beam"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx"
+	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/pipelinex"
 	"github.com/apache/beam/sdks/go/pkg/beam/core/util/hooks"
 	"github.com/apache/beam/sdks/go/pkg/beam/internal/errors"
 	"github.com/apache/beam/sdks/go/pkg/beam/log"
@@ -170,6 +171,7 @@ func Execute(ctx context.Context, p *beam.Pipeline) (beam.PipelineResult, error)
 		WorkerRegion:        *workerRegion,
 		WorkerZone:          *workerZone,
 		TeardownPolicy:      *teardownPolicy,
+		ContainerImage:      getContainerImage(ctx),
 	}
 	if opts.TempLocation == "" {
 		opts.TempLocation = gcsx.Join(*stagingLocation, "tmp")
@@ -181,14 +183,18 @@ func Execute(ctx context.Context, p *beam.Pipeline) (beam.PipelineResult, error)
 	if err != nil {
 		return nil, err
 	}
-	enviroment, err := graphx.CreateEnvironment(ctx, jobopts.GetEnvironmentUrn(ctx), getContainerImage)
+	environment, err := graphx.CreateEnvironment(ctx, jobopts.GetEnvironmentUrn(ctx), getContainerImage)
 	if err != nil {
-		return nil, errors.WithContext(err, "generating model pipeline")
+		return nil, errors.WithContext(err, "creating environment for model pipeline")
 	}
-	model, err := graphx.Marshal(edges, &graphx.Options{Environment: enviroment})
+	model, err := graphx.Marshal(edges, &graphx.Options{Environment: environment})
 	if err != nil {
 		return nil, errors.WithContext(err, "generating model pipeline")
 	}
+	err = pipelinex.ApplySdkImageOverrides(model, jobopts.GetSdkImageOverrides())
+	if err != nil {
+		return nil, errors.WithContext(err, "applying container image overrides")
+	}
 
 	// NOTE(herohde) 10/8/2018: the last segment of the names must be "worker" and "dataflow-worker.jar".
 	id := fmt.Sprintf("go-%v-%v", atomic.AddInt32(&unique, 1), time.Now().UnixNano())
diff --git a/sdks/go/pkg/beam/runners/dataflow/dataflowlib/job.go b/sdks/go/pkg/beam/runners/dataflow/dataflowlib/job.go
index 3beddf0977a..511b962a1f0 100644
--- a/sdks/go/pkg/beam/runners/dataflow/dataflowlib/job.go
+++ b/sdks/go/pkg/beam/runners/dataflow/dataflowlib/job.go
@@ -55,6 +55,7 @@ type JobOptions struct {
 	ServiceAccountEmail string
 	WorkerRegion        string
 	WorkerZone          string
+	ContainerImage      string
 
 	// Autoscaling settings
 	Algorithm     string
@@ -76,9 +77,22 @@ type JobOptions struct {
 func Translate(ctx context.Context, p *pipepb.Pipeline, opts *JobOptions, workerURL, jarURL, modelURL string) (*df.Job, error) {
 	// (1) Translate pipeline to v1b3 speak.
 
-	steps, err := translate(p)
-	if err != nil {
-		return nil, err
+	isPortableJob := false
+	for _, exp := range opts.Experiments {
+		if exp == "use_portable_job_submission" {
+			isPortableJob = true
+		}
+	}
+
+	var steps []*df.Step
+	if isPortableJob { // Portable jobs do not need to provide dataflow steps.
+		steps = make([]*df.Step, 0)
+	} else {
+		var err error
+		steps, err = translate(p)
+		if err != nil {
+			return nil, err
+		}
 	}
 
 	jobType := "JOB_TYPE_BATCH"
@@ -91,8 +105,12 @@ func Translate(ctx context.Context, p *pipepb.Pipeline, opts *JobOptions, worker
 	}
 
 	images := pipelinex.ContainerImages(p)
-	if len(images) != 1 {
-		return nil, errors.Errorf("Dataflow supports one container image only: %v", images)
+	dfImages := make([]*df.SdkHarnessContainerImage, 0, len(images))
+	for _, img := range images {
+		dfImages = append(dfImages, &df.SdkHarnessContainerImage{
+			ContainerImage:            img,
+			UseSingleCorePerContainer: false,
+		})
 	}
 
 	packages := []*df.Package{{
@@ -150,7 +168,8 @@ func Translate(ctx context.Context, p *pipepb.Pipeline, opts *JobOptions, worker
 				IpConfiguration:             ipConfiguration,
 				Kind:                        "harness",
 				Packages:                    packages,
-				WorkerHarnessContainerImage: images[0],
+				WorkerHarnessContainerImage: opts.ContainerImage,
+				SdkHarnessContainerImages:   dfImages,
 				NumWorkers:                  1,
 				MachineType:                 opts.MachineType,
 				Network:                     opts.Network,
diff --git a/sdks/go/test/integration/integration.go b/sdks/go/test/integration/integration.go
index b211f3002e4..56a0cb1c4a1 100644
--- a/sdks/go/test/integration/integration.go
+++ b/sdks/go/test/integration/integration.go
@@ -18,10 +18,10 @@
 //
 // Integration tests are implemented through Go's test framework, as test
 // functions that create and execute pipelines using the ptest package. Tests
-// should be placed in appropriate sub-packages for organizational purposes, and
-// to allow greater parallelism, since tests are only run in parallel across
-// different packages. Integration tests should always begin with a call to
-// CheckFilters to allow the test to be filtered.
+// should be placed in smaller sub-packages for organizational purposes and
+// parallelism (tests are only run in parallel across different packages).
+// Integration tests should always begin with a call to CheckFilters to ensure
+// test filters can be applied.
 //
 // Running integration tests can be done with a go test call with any flags that
 // are required by the test pipelines, such as --runner or --endpoint.
@@ -81,8 +81,6 @@ var sparkFilters = []string{
 }
 
 var dataflowFilters = []string{
-	// TODO(BEAM-11574): XLang needs to be enabled for Dataflow.
-	"TestXLang.*",
 	// TODO(BEAM-11576): TestFlattenDup failing on this runner.
 	"TestFlattenDup",
 }
diff --git a/sdks/go/test/run_validatesrunner_tests.sh b/sdks/go/test/run_validatesrunner_tests.sh
index 4eed7807a28..2a2a48dd188 100755
--- a/sdks/go/test/run_validatesrunner_tests.sh
+++ b/sdks/go/test/run_validatesrunner_tests.sh
@@ -259,7 +259,21 @@ if [[ "$RUNNER" == "dataflow" ]]; then
   docker images | grep $TAG
 
   # Push the container
-  gcloud docker -- push $CONTAINER
+  gcloud docker -- push $CONTAINER:$TAG
+
+  if [[ -n "$EXPANSION_ADDR" ]]; then
+    # Build the java container for cross-language
+    JAVA_TAG=$(date +%Y%m%d-%H%M%S)
+    JAVA_CONTAINER=us.gcr.io/$PROJECT/$USER/beam_java11_sdk
+    echo "Using container $JAVA_CONTAINER for cross-language java transforms"
+    ./gradlew :sdks:java:container:java11:docker -Pdocker-repository-root=us.gcr.io/$PROJECT/$USER -Pdocker-tag=$JAVA_TAG
+
+    # Verify it exists
+    docker images | grep $JAVA_TAG
+
+    # Push the container
+    gcloud docker -- push $JAVA_CONTAINER:$JAVA_TAG
+  fi
 else
   TAG=dev
   ./gradlew :sdks:go:container:docker -Pdocker-tag=$TAG
@@ -276,8 +290,13 @@ ARGS="$ARGS --staging_location=$GCS_LOCATION/staging-validatesrunner-test"
 ARGS="$ARGS --temp_location=$GCS_LOCATION/temp-validatesrunner-test"
 ARGS="$ARGS --dataflow_worker_jar=$DATAFLOW_WORKER_JAR"
 ARGS="$ARGS --endpoint=$ENDPOINT"
+OVERRIDE=--sdk_harness_container_image_override=".*java.*,$JAVA_CONTAINER:$JAVA_TAG"
+ARGS="$ARGS $OVERRIDE"
 if [[ -n "$EXPANSION_ADDR" ]]; then
   ARGS="$ARGS --expansion_addr=$EXPANSION_ADDR"
+  if [[ "$RUNNER" == "dataflow" ]]; then
+    ARGS="$ARGS --experiments=use_portable_job_submission"
+  fi
 fi
 
 # Running "go test" requires some additional setup on Jenkins.
@@ -304,6 +323,12 @@ if [[ "$RUNNER" == "dataflow" ]]; then
   docker rmi $CONTAINER:$TAG || echo "Failed to remove container"
   gcloud --quiet container images delete $CONTAINER:$TAG || echo "Failed to delete container"
 
+  if [[ -n "$EXPANSION_ADDR" ]]; then
+    # Delete the java cross-language container locally and remotely
+    docker rmi $JAVA_CONTAINER:$JAVA_TAG || echo "Failed to remove container"
+    gcloud --quiet container images delete $JAVA_CONTAINER:$JAVA_TAG || echo "Failed to delete container"
+  fi
+
   # Clean up tempdir
   rm -rf $TMPDIR
 fi
