diff --git a/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexReadUnboundedInputOperator.java b/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexReadUnboundedInputOperator.java
index 6fc2f0c6766..ac28c2a8e33 100644
--- a/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexReadUnboundedInputOperator.java
+++ b/runners/apex/src/main/java/org/apache/beam/runners/apex/translation/operators/ApexReadUnboundedInputOperator.java
@@ -35,6 +35,7 @@ import org.apache.beam.runners.apex.translation.utils.ApexStreamTuple.DataTuple;
 import org.apache.beam.runners.apex.translation.utils.SerializablePipelineOptions;
 import org.apache.beam.runners.apex.translation.utils.ValuesSource;
 import org.apache.beam.sdk.io.UnboundedSource;
+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.sdk.transforms.windowing.GlobalWindow;
 import org.apache.beam.sdk.transforms.windowing.PaneInfo;
 import org.apache.beam.sdk.util.WindowedValue;
@@ -86,9 +87,7 @@ public class ApexReadUnboundedInputOperator<OutputT, CheckpointMarkT
   public void beginWindow(long windowId) {
     if (!available && (isBoundedSource || source instanceof ValuesSource)) {
       // if it's a Create and the input was consumed, emit final watermark
-      emitWatermarkIfNecessary(GlobalWindow.TIMESTAMP_MAX_VALUE.getMillis());
-      // terminate the stream (allows tests to finish faster)
-      BaseOperator.shutdown();
+      emitWatermarkIfNecessary(BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis());
     } else {
       emitWatermarkIfNecessary(reader.getWatermark().getMillis());
     }
@@ -106,6 +105,18 @@ public class ApexReadUnboundedInputOperator<OutputT, CheckpointMarkT
 
   @Override
   public void endWindow() {
+    if (outputWatermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {
+      // terminate the stream
+      if (traceTuples) {
+        LOG.debug("terminating input after final watermark");
+      }
+      try {
+        // see BEAM-1140 for why the delay after mark was emitted
+        Thread.sleep(100);
+      } catch (InterruptedException e) {
+      }
+      BaseOperator.shutdown();
+    }
   }
 
   @Override
