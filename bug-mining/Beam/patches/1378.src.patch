diff --git a/sdks/go/pkg/beam/core/util/symtab/symtab.go b/sdks/go/pkg/beam/core/util/symtab/symtab.go
index ded72a7bed4..68abfd8820b 100644
--- a/sdks/go/pkg/beam/core/util/symtab/symtab.go
+++ b/sdks/go/pkg/beam/core/util/symtab/symtab.go
@@ -21,19 +21,46 @@ import (
 	"debug/elf"
 	"debug/macho"
 	"debug/pe"
+	"fmt"
 	"os"
+	"reflect"
+	"runtime"
 
 	"github.com/apache/beam/sdks/go/pkg/beam/internal/errors"
 )
 
 // SymbolTable allows for mapping between symbols and their addresses.
 type SymbolTable struct {
-	data *dwarf.Data
+	data   *dwarf.Data
+	offset uintptr // offset between file addresses and runtime addresses
 }
 
 // New creates a new symbol table based on the debug info
 // read from the specified file.
 func New(filename string) (*SymbolTable, error) {
+	d, err := dwarfData(filename)
+	if err != nil {
+		return nil, err
+	}
+
+	sym := &SymbolTable{data: d}
+
+	// Work out the offset between the file addresses and the
+	// runtime addreses, in case this is a position independent
+	// executable.
+	runtimeAddr := reflect.ValueOf(New).Pointer()
+	name := fnname()
+	fileAddr, err := sym.Sym2Addr(name)
+	if err != nil {
+		return nil, fmt.Errorf("failed to reverse lookup known function %s: %v", name, err)
+	}
+	sym.offset = runtimeAddr - fileAddr
+
+	return sym, nil
+}
+
+// dwarfData returns the debug info for the specified file.
+func dwarfData(filename string) (*dwarf.Data, error) {
 	f, err := os.Open(filename)
 	if err != nil {
 		return nil, err
@@ -51,7 +78,7 @@ func New(filename string) (*SymbolTable, error) {
 			f.Close()
 			return nil, errors.Wrap(err, "No working DWARF")
 		}
-		return &SymbolTable{d}, nil
+		return d, nil
 	}
 
 	// then Mach-O
@@ -62,7 +89,7 @@ func New(filename string) (*SymbolTable, error) {
 			f.Close()
 			return nil, errors.Wrap(err, "No working DWARF")
 		}
-		return &SymbolTable{d}, nil
+		return d, nil
 	}
 
 	// finally try Windows PE format
@@ -73,7 +100,7 @@ func New(filename string) (*SymbolTable, error) {
 			f.Close()
 			return nil, errors.Wrap(err, "No working DWARF")
 		}
-		return &SymbolTable{d}, nil
+		return d, nil
 	}
 
 	// Give up, we don't recognize it
@@ -81,8 +108,18 @@ func New(filename string) (*SymbolTable, error) {
 	return nil, errors.New("Unknown file format")
 }
 
+// fnname returns the name of the function that called it.
+func fnname() string {
+	var pcs [2]uintptr
+	n := runtime.Callers(2, pcs[:])
+	frames := runtime.CallersFrames(pcs[:n])
+	frame, _ := frames.Next()
+	return frame.Func.Name()
+}
+
 // Addr2Sym returns the symbol name for the provided address.
 func (s *SymbolTable) Addr2Sym(addr uintptr) (string, error) {
+	addr -= s.offset
 	reader := s.data.Reader()
 	for {
 		e, err := reader.Next()
@@ -121,7 +158,7 @@ func (s *SymbolTable) Sym2Addr(symbol string) (uintptr, error) {
 			nf := e.Field[0]
 			if nf.Attr.String() == "Name" && nf.Val.(string) == symbol {
 				addr := e.Field[1].Val.(uint64)
-				return uintptr(addr), nil
+				return uintptr(addr) + s.offset, nil
 			}
 		}
 	}
diff --git a/sdks/go/pkg/beam/core/util/symtab/symtab_test.go b/sdks/go/pkg/beam/core/util/symtab/symtab_test.go
new file mode 100644
index 00000000000..d60f7f019e2
--- /dev/null
+++ b/sdks/go/pkg/beam/core/util/symtab/symtab_test.go
@@ -0,0 +1,113 @@
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements.  See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package symtab
+
+import (
+	"io/ioutil"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"runtime"
+	"strings"
+	"testing"
+)
+
+// TestSym2Addr builds and runs this test program.
+const testprog = `
+package main
+
+import (
+	"fmt"
+	"os"
+	"runtime"
+
+	"github.com/apache/beam/sdks/go/pkg/beam/core/util/symtab"
+)
+
+func die(format string, a ...interface{}) {
+	fmt.Fprintf(os.Stderr, format, a...)
+	os.Exit(1)
+}
+
+func main() {
+	syms, err := symtab.New(os.Args[0])
+	if err != nil {
+		die("%s: could not read symbols: %v", os.Args[0], err)
+	}
+
+	symPC, err := syms.Sym2Addr("main.main")
+	if err != nil {
+		die("Sym2Addr(%q) failed: %v", "main.main", err)
+	}
+
+	runtimePC := fnaddr()
+	if symPC != runtimePC {
+		die("PC from symbol table %x != runtime PC %x", symPC, runtimePC)
+	}
+}
+
+// fnaddr returns the entry address of its caller.
+func fnaddr() uintptr {
+	var pcs [2]uintptr
+	n := runtime.Callers(2, pcs[:])
+	frames := runtime.CallersFrames(pcs[:n])
+	frame, _ := frames.Next()
+	return frame.Func.Entry()
+}
+`
+
+func TestSym2Addr(t *testing.T) {
+	f, err := ioutil.TempFile("", "TestSym2Addr*.go")
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	fname := f.Name()
+	defer os.Remove(fname)
+
+	if _, err := f.WriteString(testprog); err != nil {
+		t.Fatal(err)
+	}
+	if err := f.Close(); err != nil {
+		t.Fatal(err)
+	}
+
+	bin := strings.TrimSuffix(fname, ".go")
+	defer os.Remove(bin)
+
+	gotool := filepath.Join(runtime.GOROOT(), "bin", "go")
+
+	for _, arg := range []string{"-buildmode=exe", "-buildmode=pie"} {
+		args := []string{
+			gotool,
+			"build",
+			"-o",
+			bin,
+			arg,
+			fname,
+		}
+		if out, err := exec.Command(args[0], args[1:]...).CombinedOutput(); err != nil {
+			t.Logf("%s", out)
+			t.Errorf("%v failed: %v", args, err)
+			continue
+		}
+
+		if out, err := exec.Command(bin).CombinedOutput(); err != nil {
+			t.Logf("%s", out)
+			t.Errorf("test program built with %v failed: %v", args, err)
+		}
+	}
+}
