diff --git a/sdks/python/apache_beam/io/gcp/gcsio.py b/sdks/python/apache_beam/io/gcp/gcsio.py
index 1b312842dc1..cc740c397e9 100644
--- a/sdks/python/apache_beam/io/gcp/gcsio.py
+++ b/sdks/python/apache_beam/io/gcp/gcsio.py
@@ -163,9 +163,11 @@ class GcsIO(object):
   def get_project_number(self, bucket):
     if bucket not in self.bucket_to_project_number:
       bucket_metadata = self.get_bucket(bucket_name=bucket)
-      self.bucket_to_project_number[bucket] = bucket_metadata.projectNumber
+      if bucket_metadata:
+        self.bucket_to_project_number[bucket] = bucket_metadata.projectNumber
+      #  else failed to load the bucket metadata due to HttpError
 
-    return self.bucket_to_project_number[bucket]
+    return self.bucket_to_project_number.get(bucket, None)
 
   def _set_rewrite_response_callback(self, callback):
     """For testing purposes only. No backward compatibility guarantees.
@@ -582,17 +584,25 @@ class GcsDownloader(Downloader):
     self._buffer_size = buffer_size
     self._get_project_number = get_project_number
 
-    project_number = self._get_project_number(self._bucket)
-
     # Create a request count metric
     resource = resource_identifiers.GoogleCloudStorageBucket(self._bucket)
     labels = {
         monitoring_infos.SERVICE_LABEL: 'Storage',
         monitoring_infos.METHOD_LABEL: 'Objects.get',
         monitoring_infos.RESOURCE_LABEL: resource,
-        monitoring_infos.GCS_BUCKET_LABEL: self._bucket,
-        monitoring_infos.GCS_PROJECT_ID_LABEL: str(project_number)
+        monitoring_infos.GCS_BUCKET_LABEL: self._bucket
     }
+    project_number = self._get_project_number(self._bucket)
+    if project_number:
+      labels[monitoring_infos.GCS_PROJECT_ID_LABEL] = str(project_number)
+    else:
+      _LOGGER.debug(
+          'Possibly missing storage.buckets.get permission to '
+          'bucket %s. Label %s is not added to the counter because it '
+          'cannot be identified.',
+          self._bucket,
+          monitoring_infos.GCS_PROJECT_ID_LABEL)
+
     service_call_metric = ServiceCallMetric(
         request_count_urn=monitoring_infos.API_REQUEST_COUNT_URN,
         base_labels=labels)
@@ -603,7 +613,6 @@ class GcsDownloader(Downloader):
             bucket=self._bucket, object=self._name))
     try:
       metadata = self._get_object_metadata(self._get_request)
-      service_call_metric.call('ok')
     except HttpError as http_error:
       service_call_metric.call(http_error)
       if http_error.status_code == 404:
@@ -612,6 +621,9 @@ class GcsDownloader(Downloader):
         _LOGGER.error(
             'HTTP error while requesting file %s: %s', self._path, http_error)
         raise
+    else:
+      service_call_metric.call('ok')
+
     self._size = metadata.size
 
     # Ensure read is from file of the correct generation.
diff --git a/sdks/python/apache_beam/io/gcp/gcsio_test.py b/sdks/python/apache_beam/io/gcp/gcsio_test.py
index 06a98b11b59..1d2836a5614 100644
--- a/sdks/python/apache_beam/io/gcp/gcsio_test.py
+++ b/sdks/python/apache_beam/io/gcp/gcsio_test.py
@@ -794,6 +794,53 @@ class TestGCSIO(unittest.TestCase):
 
     self.assertEqual(metric_value, 2)
 
+  @mock.patch.object(FakeGcsBuckets, 'Get')
+  def test_downloader_fail_to_get_project_number(self, mock_get):
+    # Raising an error when listing GCS Bucket so that project number fails to
+    # be retrieved.
+    mock_get.side_effect = HttpError({'status': 403}, None, None)
+    # Clear the process wide metric container.
+    MetricsEnvironment.process_wide_container().reset()
+
+    file_name = 'gs://gcsio-metrics-test/dummy_mode_file'
+    file_size = 5 * 1024 * 1024 + 100
+    random_file = self._insert_random_file(self.client, file_name, file_size)
+    self.gcs.open(file_name, 'r')
+
+    resource = resource_identifiers.GoogleCloudStorageBucket(random_file.bucket)
+    labels = {
+        monitoring_infos.SERVICE_LABEL: 'Storage',
+        monitoring_infos.METHOD_LABEL: 'Objects.get',
+        monitoring_infos.RESOURCE_LABEL: resource,
+        monitoring_infos.GCS_BUCKET_LABEL: random_file.bucket,
+        monitoring_infos.GCS_PROJECT_ID_LABEL: str(DEFAULT_PROJECT_NUMBER),
+        monitoring_infos.STATUS_LABEL: 'ok'
+    }
+
+    metric_name = MetricName(
+        None, None, urn=monitoring_infos.API_REQUEST_COUNT_URN, labels=labels)
+    metric_value = MetricsEnvironment.process_wide_container().get_counter(
+        metric_name).get_cumulative()
+
+    self.assertEqual(metric_value, 0)
+
+    labels_without_project_id = {
+        monitoring_infos.SERVICE_LABEL: 'Storage',
+        monitoring_infos.METHOD_LABEL: 'Objects.get',
+        monitoring_infos.RESOURCE_LABEL: resource,
+        monitoring_infos.GCS_BUCKET_LABEL: random_file.bucket,
+        monitoring_infos.STATUS_LABEL: 'ok'
+    }
+    metric_name = MetricName(
+        None,
+        None,
+        urn=monitoring_infos.API_REQUEST_COUNT_URN,
+        labels=labels_without_project_id)
+    metric_value = MetricsEnvironment.process_wide_container().get_counter(
+        metric_name).get_cumulative()
+
+    self.assertEqual(metric_value, 2)
+
   def test_uploader_monitoring_info(self):
     # Clear the process wide metric container.
     MetricsEnvironment.process_wide_container().reset()
