diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Contextful.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Contextful.java
index 35634b464c4..073999433c0 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Contextful.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Contextful.java
@@ -112,6 +112,12 @@ public final class Contextful<ClosureT> implements Serializable {
     return new Contextful<>((element, c) -> fn.apply(element), Requirements.empty());
   }
 
+  /** Binary compatibility adapter for {@link #fn(ProcessFunction)}. */
+  public static <InputT, OutputT> Contextful<Fn<InputT, OutputT>> fn(
+      final SerializableFunction<InputT, OutputT> fn) {
+    return fn((ProcessFunction<InputT, OutputT>) fn);
+  }
+
   /** Same with {@link #of} but with better type inference behavior for the case of {@link Fn}. */
   public static <InputT, OutputT> Contextful<Fn<InputT, OutputT>> fn(
       final Fn<InputT, OutputT> fn, Requirements requirements) {
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Filter.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Filter.java
index aa9d2cd3810..61eacba6778 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Filter.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Filter.java
@@ -51,6 +51,12 @@ public class Filter<T> extends PTransform<PCollection<T>, PCollection<T>> {
     return new Filter<>(predicate);
   }
 
+  /** Binary compatibility adapter for {@link #by(ProcessFunction)}. */
+  public static <T, PredicateT extends SerializableFunction<T, Boolean>> Filter<T> by(
+      PredicateT predicate) {
+    return by((ProcessFunction<T, Boolean>) predicate);
+  }
+
   /**
    * Returns a {@code PTransform} that takes an input {@link PCollection} and returns a {@link
    * PCollection} with elements that are less than a given value, based on the elements' natural
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/FlatMapElements.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/FlatMapElements.java
index 169f86684b6..77b17e4a033 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/FlatMapElements.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/FlatMapElements.java
@@ -85,6 +85,12 @@ public class FlatMapElements<InputT, OutputT>
     return new FlatMapElements<>(wrapped, fn, inputType, outputType);
   }
 
+  /** Binary compatibility adapter for {@link #via(ProcessFunction)}. */
+  public static <InputT, OutputT> FlatMapElements<InputT, OutputT> via(
+      SimpleFunction<? super InputT, ? extends Iterable<OutputT>> fn) {
+    return via((InferableFunction<? super InputT, ? extends Iterable<OutputT>>) fn);
+  }
+
   /**
    * Returns a new {@link FlatMapElements} transform with the given type descriptor for the output
    * type, but the mapping function yet to be specified using {@link #via(ProcessFunction)}.
@@ -113,6 +119,12 @@ public class FlatMapElements<InputT, OutputT>
         (Contextful) Contextful.fn(fn), fn, TypeDescriptors.inputOf(fn), outputType);
   }
 
+  /** Binary compatibility adapter for {@link #via(ProcessFunction)}. */
+  public <NewInputT> FlatMapElements<NewInputT, OutputT> via(
+      SerializableFunction<NewInputT, ? extends Iterable<OutputT>> fn) {
+    return via((ProcessFunction<NewInputT, ? extends Iterable<OutputT>>) fn);
+  }
+
   /** Like {@link #via(ProcessFunction)}, but allows access to additional context. */
   @Experimental(Experimental.Kind.CONTEXTFUL)
   public <NewInputT> FlatMapElements<NewInputT, OutputT> via(
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/MapElements.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/MapElements.java
index 2ebbc19a6b1..a9cd2b6cecf 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/MapElements.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/MapElements.java
@@ -76,6 +76,12 @@ public class MapElements<InputT, OutputT>
         Contextful.fn(fn), fn, fn.getInputTypeDescriptor(), fn.getOutputTypeDescriptor());
   }
 
+  /** Binary compatibility adapter for {@link #via(InferableFunction)}. */
+  public static <InputT, OutputT> MapElements<InputT, OutputT> via(
+      final SimpleFunction<InputT, OutputT> fn) {
+    return via((InferableFunction<InputT, OutputT>) fn);
+  }
+
   /**
    * Returns a new {@link MapElements} transform with the given type descriptor for the output type,
    * but the mapping function yet to be specified using {@link #via(ProcessFunction)}.
@@ -101,6 +107,12 @@ public class MapElements<InputT, OutputT>
     return new MapElements<>(Contextful.fn(fn), fn, TypeDescriptors.inputOf(fn), outputType);
   }
 
+  /** Binary compatibility adapter for {@link #via(ProcessFunction)}. */
+  public <NewInputT> MapElements<NewInputT, OutputT> via(
+      SerializableFunction<NewInputT, OutputT> fn) {
+    return via((ProcessFunction<NewInputT, OutputT>) fn);
+  }
+
   /** Like {@link #via(ProcessFunction)}, but supports access to context, such as side inputs. */
   @Experimental(Kind.CONTEXTFUL)
   public <NewInputT> MapElements<NewInputT, OutputT> via(Contextful<Fn<NewInputT, OutputT>> fn) {
diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/values/TypeDescriptors.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/values/TypeDescriptors.java
index f58296f5501..8c257481f52 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/values/TypeDescriptors.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/values/TypeDescriptors.java
@@ -26,6 +26,7 @@ import java.util.Map;
 import java.util.Set;
 import org.apache.beam.sdk.transforms.Contextful;
 import org.apache.beam.sdk.transforms.ProcessFunction;
+import org.apache.beam.sdk.transforms.SerializableFunction;
 
 /**
  * A utility class for creating {@link TypeDescriptor} objects for different types, such as Java
@@ -394,6 +395,12 @@ public class TypeDescriptors {
         new TypeVariableExtractor<ProcessFunction<InputT, OutputT>, InputT>() {});
   }
 
+  /** Binary compatibility adapter for {@link #inputOf(ProcessFunction)}. */
+  public static <InputT, OutputT> TypeDescriptor<InputT> inputOf(
+      SerializableFunction<InputT, OutputT> fn) {
+    return inputOf((ProcessFunction<InputT, OutputT>) fn);
+  }
+
   /**
    * Returns a type descriptor for the output of the given {@link ProcessFunction}, subject to Java
    * type erasure: may contain unresolved type variables if the type was erased.
@@ -406,6 +413,12 @@ public class TypeDescriptors {
         new TypeVariableExtractor<ProcessFunction<InputT, OutputT>, OutputT>() {});
   }
 
+  /** Binary compatibility adapter for {@link #outputOf(ProcessFunction)}. */
+  public static <InputT, OutputT> TypeDescriptor<OutputT> outputOf(
+      SerializableFunction<InputT, OutputT> fn) {
+    return outputOf((ProcessFunction<InputT, OutputT>) fn);
+  }
+
   /** Like {@link #inputOf(ProcessFunction)} but for {@link Contextful.Fn}. */
   public static <InputT, OutputT> TypeDescriptor<InputT> inputOf(
       Contextful.Fn<InputT, OutputT> fn) {
