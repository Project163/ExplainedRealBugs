diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileBasedSink.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileBasedSink.java
index 7c1954b99bb..8e7a08057eb 100644
--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileBasedSink.java
+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/FileBasedSink.java
@@ -741,20 +741,18 @@ public abstract class FileBasedSink<UserT, DestinationT, OutputT>
         List<KV<FileResult<DestinationT>, ResourceId>> resultsToFinalFilenames) throws IOException {
       int numFiles = resultsToFinalFilenames.size();
 
-        LOG.debug("Copying {} files.", numFiles);
-        List<ResourceId> srcFiles = new ArrayList<>();
-        List<ResourceId> dstFiles = new ArrayList<>();
-        for (KV<FileResult<DestinationT>, ResourceId> entry : resultsToFinalFilenames) {
-          srcFiles.add(entry.getKey().getTempFilename());
-          dstFiles.add(entry.getValue());
-          LOG.info(
-              "Will copy temporary file {} to final location {}",
-              entry.getKey(),
-              entry.getValue());
-        }
-        // During a failure case, files may have been deleted in an earlier step. Thus
-        // we ignore missing files here.
-        FileSystems.copy(srcFiles, dstFiles, StandardMoveOptions.IGNORE_MISSING_FILES);
+      LOG.debug("Copying {} files.", numFiles);
+      List<ResourceId> srcFiles = new ArrayList<>();
+      List<ResourceId> dstFiles = new ArrayList<>();
+      for (KV<FileResult<DestinationT>, ResourceId> entry : resultsToFinalFilenames) {
+        srcFiles.add(entry.getKey().getTempFilename());
+        dstFiles.add(entry.getValue());
+        LOG.info(
+            "Will copy temporary file {} to final location {}", entry.getKey(), entry.getValue());
+      }
+      // During a failure case, files may have been deleted in an earlier step. Thus
+      // we ignore missing files here.
+      FileSystems.copy(srcFiles, dstFiles, StandardMoveOptions.IGNORE_MISSING_FILES);
       removeTemporaryFiles(srcFiles);
     }
 
diff --git a/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/s3/S3FileSystem.java b/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/s3/S3FileSystem.java
index ac95a638af7..6f5b5efaa5a 100644
--- a/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/s3/S3FileSystem.java
+++ b/sdks/java/io/amazon-web-services/src/main/java/org/apache/beam/sdk/io/aws/s3/S3FileSystem.java
@@ -27,6 +27,7 @@ import com.amazonaws.services.s3.AmazonS3;
 import com.amazonaws.services.s3.AmazonS3ClientBuilder;
 import com.amazonaws.services.s3.model.AmazonS3Exception;
 import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest;
+import com.amazonaws.services.s3.model.CopyObjectRequest;
 import com.amazonaws.services.s3.model.CopyPartRequest;
 import com.amazonaws.services.s3.model.CopyPartResult;
 import com.amazonaws.services.s3.model.DeleteObjectsRequest;
@@ -86,6 +87,9 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
       Runtime.getRuntime().maxMemory() < 512 * 1024 * 1024
           ? MINIMUM_UPLOAD_BUFFER_SIZE_BYTES
           : 64 * 1024 * 1024;
+  // Amazon S3 API: You can create a copy of your object up to 5 GB in a single atomic operation
+  // Ref. https://docs.aws.amazon.com/AmazonS3/latest/dev/CopyingObjectsExamples.html
+  private static final int MAX_COPY_OBJECT_SIZE_BYTES = 5 * 1024 * 1024 * 1024;
 
   // S3 API, delete-objects: "You may specify up to 1000 keys."
   private static final int MAX_DELETE_OBJECTS_PER_REQUEST = 1000;
@@ -107,13 +111,14 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
               + "was not specified. If you don't plan to use S3, then ignore this message.");
     }
 
-    AmazonS3ClientBuilder builder = AmazonS3ClientBuilder.standard()
-        .withCredentials(options.getAwsCredentialsProvider());
+    AmazonS3ClientBuilder builder =
+        AmazonS3ClientBuilder.standard().withCredentials(options.getAwsCredentialsProvider());
     if (Strings.isNullOrEmpty(options.getAwsServiceEndpoint())) {
       builder = builder.withRegion(options.getAwsRegion());
     } else {
-      builder = builder.withEndpointConfiguration(new EndpointConfiguration(
-          options.getAwsServiceEndpoint(), options.getAwsRegion()));
+      builder =
+          builder.withEndpointConfiguration(
+              new EndpointConfiguration(options.getAwsServiceEndpoint(), options.getAwsRegion()));
     }
     amazonS3 = builder.build();
 
@@ -130,9 +135,9 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
 
     checkArgument(options.getS3ThreadPoolSize() > 0, "threadPoolSize");
     executorService =
-        MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(
-            options.getS3ThreadPoolSize(), new ThreadFactoryBuilder().setDaemon(true).build()));
-
+        MoreExecutors.listeningDecorator(
+            Executors.newFixedThreadPool(
+                options.getS3ThreadPoolSize(), new ThreadFactoryBuilder().setDaemon(true).build()));
   }
 
   @Override
@@ -145,6 +150,11 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
     this.amazonS3 = amazonS3;
   }
 
+  @VisibleForTesting
+  AmazonS3 getAmazonS3Client() {
+    return this.amazonS3;
+  }
+
   @VisibleForTesting
   int getS3UploadBufferSizeBytes() {
     return s3UploadBufferSizeBytes;
@@ -187,9 +197,7 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
     return matchResults.build();
   }
 
-  /**
-   * Gets {@link MatchResult} representing all objects that match wildcard-containing paths.
-   */
+  /** Gets {@link MatchResult} representing all objects that match wildcard-containing paths. */
   @VisibleForTesting
   List<MatchResult> matchGlobPaths(Collection<S3ResourceId> globPaths) throws IOException {
     List<Callable<ExpandedGlob>> expandTasks = new ArrayList<>(globPaths.size());
@@ -198,8 +206,7 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
     }
 
     Map<S3ResourceId, ExpandedGlob> expandedGlobByGlobPath = new HashMap<>();
-    List<Callable<PathWithEncoding>> contentTypeTasks =
-        new ArrayList<>(globPaths.size());
+    List<Callable<PathWithEncoding>> contentTypeTasks = new ArrayList<>(globPaths.size());
     for (ExpandedGlob expandedGlob : callTasks(expandTasks)) {
       expandedGlobByGlobPath.put(expandedGlob.getGlobPath(), expandedGlob);
       if (expandedGlob.getExpandedPaths() != null) {
@@ -475,8 +482,7 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
   }
 
   @Override
-  protected void copy(
-      List<S3ResourceId> sourcePaths, List<S3ResourceId> destinationPaths)
+  protected void copy(List<S3ResourceId> sourcePaths, List<S3ResourceId> destinationPaths)
       throws IOException {
     checkArgument(
         sourcePaths.size() == destinationPaths.size(),
@@ -502,32 +508,50 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
 
   @VisibleForTesting
   void copy(S3ResourceId sourcePath, S3ResourceId destinationPath) throws IOException {
-    String uploadId;
-    long objectSize;
     try {
       ObjectMetadata objectMetadata =
           amazonS3.getObjectMetadata(sourcePath.getBucket(), sourcePath.getKey());
-      objectSize = objectMetadata.getContentLength();
-
-      InitiateMultipartUploadRequest initiateUploadRequest =
-          new InitiateMultipartUploadRequest(destinationPath.getBucket(), destinationPath.getKey())
-              .withStorageClass(storageClass)
-              .withObjectMetadata(objectMetadata);
-
-      InitiateMultipartUploadResult initiateUploadResult =
-          amazonS3.initiateMultipartUpload(initiateUploadRequest);
-      uploadId = initiateUploadResult.getUploadId();
-
+      if (objectMetadata.getContentLength() < MAX_COPY_OBJECT_SIZE_BYTES) {
+        atomicCopy(sourcePath, destinationPath);
+      } else {
+        multipartCopy(sourcePath, destinationPath, objectMetadata);
+      }
     } catch (AmazonClientException e) {
       throw new IOException(e);
     }
+  }
 
-    List<PartETag> eTags = new ArrayList<>();
+  @VisibleForTesting
+  void atomicCopy(S3ResourceId sourcePath, S3ResourceId destinationPath)
+      throws AmazonClientException {
+    CopyObjectRequest copyObjectRequest =
+        new CopyObjectRequest(
+            sourcePath.getBucket(),
+            sourcePath.getKey(),
+            destinationPath.getBucket(),
+            destinationPath.getKey());
+    copyObjectRequest.setStorageClass(storageClass);
+
+    amazonS3.copyObject(copyObjectRequest);
+  }
 
-    long bytePosition = 0;
+  @VisibleForTesting
+  void multipartCopy(
+      S3ResourceId sourcePath, S3ResourceId destinationPath, ObjectMetadata objectMetadata)
+      throws AmazonClientException {
+    InitiateMultipartUploadRequest initiateUploadRequest =
+        new InitiateMultipartUploadRequest(destinationPath.getBucket(), destinationPath.getKey())
+            .withStorageClass(storageClass)
+            .withObjectMetadata(objectMetadata);
+
+    InitiateMultipartUploadResult initiateUploadResult =
+        amazonS3.initiateMultipartUpload(initiateUploadRequest);
+    final String uploadId = initiateUploadResult.getUploadId();
+
+    List<PartETag> eTags = new ArrayList<>();
 
-    // Amazon parts are 1-indexed, not zero-indexed.
-    for (int partNumber = 1; bytePosition < objectSize; partNumber++) {
+    final long objectSize = objectMetadata.getContentLength();
+    if (objectSize == 0) {
       final CopyPartRequest copyPartRequest =
           new CopyPartRequest()
               .withSourceBucketName(sourcePath.getBucket())
@@ -535,19 +559,30 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
               .withDestinationBucketName(destinationPath.getBucket())
               .withDestinationKey(destinationPath.getKey())
               .withUploadId(uploadId)
-              .withPartNumber(partNumber)
-              .withFirstByte(bytePosition)
-              .withLastByte(Math.min(objectSize - 1, bytePosition + s3UploadBufferSizeBytes - 1));
+              .withPartNumber(1);
 
-      CopyPartResult copyPartResult;
-      try {
-        copyPartResult = amazonS3.copyPart(copyPartRequest);
-      } catch (AmazonClientException e) {
-        throw new IOException(e);
-      }
+      CopyPartResult copyPartResult = amazonS3.copyPart(copyPartRequest);
       eTags.add(copyPartResult.getPartETag());
-
-      bytePosition += s3UploadBufferSizeBytes;
+    } else {
+      long bytePosition = 0;
+      // Amazon parts are 1-indexed, not zero-indexed.
+      for (int partNumber = 1; bytePosition < objectSize; partNumber++) {
+        final CopyPartRequest copyPartRequest =
+            new CopyPartRequest()
+                .withSourceBucketName(sourcePath.getBucket())
+                .withSourceKey(sourcePath.getKey())
+                .withDestinationBucketName(destinationPath.getBucket())
+                .withDestinationKey(destinationPath.getKey())
+                .withUploadId(uploadId)
+                .withPartNumber(partNumber)
+                .withFirstByte(bytePosition)
+                .withLastByte(Math.min(objectSize - 1, bytePosition + s3UploadBufferSizeBytes - 1));
+
+        CopyPartResult copyPartResult = amazonS3.copyPart(copyPartRequest);
+        eTags.add(copyPartResult.getPartETag());
+
+        bytePosition += s3UploadBufferSizeBytes;
+      }
     }
 
     CompleteMultipartUploadRequest completeUploadRequest =
@@ -556,12 +591,7 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
             .withKey(destinationPath.getKey())
             .withUploadId(uploadId)
             .withPartETags(eTags);
-
-    try {
-      amazonS3.completeMultipartUpload(completeUploadRequest);
-    } catch (AmazonClientException e) {
-      throw new IOException(e);
-    }
+    amazonS3.completeMultipartUpload(completeUploadRequest);
   }
 
   @Override
@@ -585,8 +615,8 @@ class S3FileSystem extends FileSystem<S3ResourceId> {
 
     List<Callable<Void>> tasks = new ArrayList<>();
     for (final String bucket : keysByBucket.keySet()) {
-      for (final List<String> keysPartition
-          : Iterables.partition(keysByBucket.get(bucket), MAX_DELETE_OBJECTS_PER_REQUEST)) {
+      for (final List<String> keysPartition :
+          Iterables.partition(keysByBucket.get(bucket), MAX_DELETE_OBJECTS_PER_REQUEST)) {
         tasks.add(
             () -> {
               delete(bucket, keysPartition);
diff --git a/sdks/java/io/amazon-web-services/src/test/java/org/apache/beam/sdk/io/aws/s3/S3FileSystemTest.java b/sdks/java/io/amazon-web-services/src/test/java/org/apache/beam/sdk/io/aws/s3/S3FileSystemTest.java
index 931e9d0a747..b16e9dc5840 100644
--- a/sdks/java/io/amazon-web-services/src/test/java/org/apache/beam/sdk/io/aws/s3/S3FileSystemTest.java
+++ b/sdks/java/io/amazon-web-services/src/test/java/org/apache/beam/sdk/io/aws/s3/S3FileSystemTest.java
@@ -21,11 +21,13 @@ package org.apache.beam.sdk.io.aws.s3;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static org.hamcrest.Matchers.contains;
 import static org.hamcrest.Matchers.notNullValue;
+import static org.hamcrest.Matchers.nullValue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.argThat;
 import static org.mockito.Matchers.notNull;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -33,6 +35,8 @@ import static org.mockito.Mockito.when;
 import com.amazonaws.services.s3.AmazonS3;
 import com.amazonaws.services.s3.model.AmazonS3Exception;
 import com.amazonaws.services.s3.model.CompleteMultipartUploadRequest;
+import com.amazonaws.services.s3.model.CopyObjectRequest;
+import com.amazonaws.services.s3.model.CopyObjectResult;
 import com.amazonaws.services.s3.model.CopyPartRequest;
 import com.amazonaws.services.s3.model.CopyPartResult;
 import com.amazonaws.services.s3.model.DeleteObjectsRequest;
@@ -56,9 +60,7 @@ import org.junit.runners.JUnit4;
 import org.mockito.ArgumentMatcher;
 import org.mockito.Mockito;
 
-/**
- * Test case for {@link S3FileSystem}.
- */
+/** Test case for {@link S3FileSystem}. */
 @RunWith(JUnit4.class)
 public class S3FileSystemTest {
 
@@ -84,6 +86,12 @@ public class S3FileSystemTest {
     return options;
   }
 
+  private S3FileSystem buildMockedS3FileSystem() {
+    S3FileSystem s3FileSystem = new S3FileSystem(s3Options());
+    s3FileSystem.setAmazonS3Client(Mockito.mock(AmazonS3.class));
+    return s3FileSystem;
+  }
+
   @Test
   public void testGetScheme() {
     S3Options pipelineOptions = s3Options();
@@ -93,12 +101,63 @@ public class S3FileSystemTest {
   }
 
   @Test
-  public void testCopyMultipleParts() throws IOException {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
+  public void testCopy() throws IOException {
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
+
+    S3ResourceId sourcePath = S3ResourceId.fromUri("s3://bucket/from");
+    S3ResourceId destinationPath = S3ResourceId.fromUri("s3://bucket/to");
+
+    ObjectMetadata objectMetadata = new ObjectMetadata();
+    objectMetadata.setContentLength(0);
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .getObjectMetadata(sourcePath.getBucket(), sourcePath.getKey()))
+        .thenReturn(objectMetadata);
+
+    s3FileSystem.copy(sourcePath, destinationPath);
+
+    verify(s3FileSystem.getAmazonS3Client(), times(1))
+        .copyObject(argThat(notNullValue(CopyObjectRequest.class)));
+
+    // we simulate a big object >= 5GB so it takes the multiPart path
+    objectMetadata.setContentLength((long) 5 * 1024 * 1024 * 1024);
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .getObjectMetadata(sourcePath.getBucket(), sourcePath.getKey()))
+        .thenReturn(objectMetadata);
+
+    try {
+      s3FileSystem.copy(sourcePath, destinationPath);
+    } catch (NullPointerException e) {
+      // ignore failing unmocked path, this is covered by testMultipartCopy test
+    }
 
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    verify(s3FileSystem.getAmazonS3Client(), never())
+        .copyObject(argThat(nullValue(CopyObjectRequest.class)));
+  }
+
+  @Test
+  public void testAtomicCopy() throws IOException {
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
+
+    S3ResourceId sourcePath = S3ResourceId.fromUri("s3://bucket/from");
+    S3ResourceId destinationPath = S3ResourceId.fromUri("s3://bucket/to");
+
+    CopyObjectResult copyObjectResult = new CopyObjectResult();
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .copyObject(argThat(notNullValue(CopyObjectRequest.class))))
+        .thenReturn(copyObjectResult);
+
+    s3FileSystem.atomicCopy(sourcePath, destinationPath);
+
+    verify(s3FileSystem.getAmazonS3Client(), times(1))
+        .copyObject(argThat(notNullValue(CopyObjectRequest.class)));
+  }
+
+  @Test
+  public void testMultipartCopy() throws IOException {
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     S3ResourceId sourcePath = S3ResourceId.fromUri("s3://bucket/from");
     S3ResourceId destinationPath = S3ResourceId.fromUri("s3://bucket/to");
@@ -106,38 +165,37 @@ public class S3FileSystemTest {
     InitiateMultipartUploadResult initiateMultipartUploadResult =
         new InitiateMultipartUploadResult();
     initiateMultipartUploadResult.setUploadId("upload-id");
-    when(mockAmazonS3.initiateMultipartUpload(
-        argThat(notNullValue(InitiateMultipartUploadRequest.class))))
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .initiateMultipartUpload(argThat(notNullValue(InitiateMultipartUploadRequest.class))))
         .thenReturn(initiateMultipartUploadResult);
 
     ObjectMetadata sourceS3ObjectMetadata = new ObjectMetadata();
-    sourceS3ObjectMetadata
-        .setContentLength((long) (s3FileSystem.getS3UploadBufferSizeBytes() * 1.5));
+    sourceS3ObjectMetadata.setContentLength(
+        (long) (s3FileSystem.getS3UploadBufferSizeBytes() * 1.5));
     sourceS3ObjectMetadata.setContentEncoding("read-seek-efficient");
-    when(mockAmazonS3.getObjectMetadata(sourcePath.getBucket(), sourcePath.getKey()))
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .getObjectMetadata(sourcePath.getBucket(), sourcePath.getKey()))
         .thenReturn(sourceS3ObjectMetadata);
 
     CopyPartResult copyPartResult1 = new CopyPartResult();
     copyPartResult1.setETag("etag-1");
     CopyPartResult copyPartResult2 = new CopyPartResult();
     copyPartResult1.setETag("etag-2");
-    when(mockAmazonS3.copyPart(argThat(notNullValue(CopyPartRequest.class))))
+    when(s3FileSystem.getAmazonS3Client().copyPart(argThat(notNullValue(CopyPartRequest.class))))
         .thenReturn(copyPartResult1)
         .thenReturn(copyPartResult2);
 
-    s3FileSystem.copy(sourcePath, destinationPath);
+    s3FileSystem.multipartCopy(sourcePath, destinationPath, sourceS3ObjectMetadata);
 
-    verify(mockAmazonS3, times(1))
+    verify(s3FileSystem.getAmazonS3Client(), times(1))
         .completeMultipartUpload(argThat(notNullValue(CompleteMultipartUploadRequest.class)));
   }
 
   @Test
   public void deleteThousandsOfObjectsInMultipleBuckets() throws IOException {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
-
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     List<String> buckets = ImmutableList.of("bucket1", "bucket2");
     List<String> keys = new ArrayList<>();
@@ -154,23 +212,19 @@ public class S3FileSystemTest {
     s3FileSystem.delete(paths);
 
     // Should require 6 calls to delete 2500 objects in each of 2 buckets.
-    verify(mockAmazonS3, times(6)).deleteObjects(argThat(notNullValue(DeleteObjectsRequest.class)));
+    verify(s3FileSystem.getAmazonS3Client(), times(6))
+        .deleteObjects(argThat(notNullValue(DeleteObjectsRequest.class)));
   }
 
-
   @Test
   public void matchNonGlob() {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
-
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     S3ResourceId path = S3ResourceId.fromUri("s3://testbucket/testdirectory/filethatexists");
     ObjectMetadata s3ObjectMetadata = new ObjectMetadata();
     s3ObjectMetadata.setContentLength(100);
     s3ObjectMetadata.setContentEncoding("read-seek-efficient");
-    when(mockAmazonS3.getObjectMetadata(path.getBucket(), path.getKey()))
+    when(s3FileSystem.getAmazonS3Client().getObjectMetadata(path.getBucket(), path.getKey()))
         .thenReturn(s3ObjectMetadata);
 
     MatchResult result = s3FileSystem.matchNonGlobPath(path);
@@ -187,17 +241,13 @@ public class S3FileSystemTest {
 
   @Test
   public void matchNonGlobNotReadSeekEfficient() {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
-
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     S3ResourceId path = S3ResourceId.fromUri("s3://testbucket/testdirectory/filethatexists");
     ObjectMetadata s3ObjectMetadata = new ObjectMetadata();
     s3ObjectMetadata.setContentLength(100);
     s3ObjectMetadata.setContentEncoding("gzip");
-    when(mockAmazonS3.getObjectMetadata(path.getBucket(), path.getKey()))
+    when(s3FileSystem.getAmazonS3Client().getObjectMetadata(path.getBucket(), path.getKey()))
         .thenReturn(s3ObjectMetadata);
 
     MatchResult result = s3FileSystem.matchNonGlobPath(path);
@@ -214,17 +264,13 @@ public class S3FileSystemTest {
 
   @Test
   public void matchNonGlobNullContentEncoding() {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
-
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     S3ResourceId path = S3ResourceId.fromUri("s3://testbucket/testdirectory/filethatexists");
     ObjectMetadata s3ObjectMetadata = new ObjectMetadata();
     s3ObjectMetadata.setContentLength(100);
     s3ObjectMetadata.setContentEncoding(null);
-    when(mockAmazonS3.getObjectMetadata(path.getBucket(), path.getKey()))
+    when(s3FileSystem.getAmazonS3Client().getObjectMetadata(path.getBucket(), path.getKey()))
         .thenReturn(s3ObjectMetadata);
 
     MatchResult result = s3FileSystem.matchNonGlobPath(path);
@@ -241,16 +287,13 @@ public class S3FileSystemTest {
 
   @Test
   public void matchNonGlobNotFound() throws IOException {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
-
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     S3ResourceId path = S3ResourceId.fromUri("s3://testbucket/testdirectory/nonexistentfile");
     AmazonS3Exception exception = new AmazonS3Exception("mock exception");
     exception.setStatusCode(404);
-    when(mockAmazonS3.getObjectMetadata(path.getBucket(), path.getKey())).thenThrow(exception);
+    when(s3FileSystem.getAmazonS3Client().getObjectMetadata(path.getBucket(), path.getKey()))
+        .thenThrow(exception);
 
     MatchResult result = s3FileSystem.matchNonGlobPath(path);
     assertThat(
@@ -260,16 +303,13 @@ public class S3FileSystemTest {
 
   @Test
   public void matchNonGlobForbidden() throws IOException {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
-
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     AmazonS3Exception exception = new AmazonS3Exception("mock exception");
     exception.setStatusCode(403);
     S3ResourceId path = S3ResourceId.fromUri("s3://testbucket/testdirectory/keyname");
-    when(mockAmazonS3.getObjectMetadata(path.getBucket(), path.getKey())).thenThrow(exception);
+    when(s3FileSystem.getAmazonS3Client().getObjectMetadata(path.getBucket(), path.getKey()))
+        .thenThrow(exception);
 
     assertThat(
         s3FileSystem.matchNonGlobPath(path),
@@ -291,8 +331,8 @@ public class S3FileSystemTest {
         return expected.getBucketName().equals(actual.getBucketName())
             && expected.getPrefix().equals(actual.getPrefix())
             && (expected.getContinuationToken() == null
-            ? actual.getContinuationToken() == null
-            : expected.getContinuationToken().equals(actual.getContinuationToken()));
+                ? actual.getContinuationToken() == null
+                : expected.getContinuationToken().equals(actual.getContinuationToken()));
       }
       return false;
     }
@@ -300,11 +340,7 @@ public class S3FileSystemTest {
 
   @Test
   public void matchGlob() throws IOException {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
-
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     S3ResourceId path = S3ResourceId.fromUri("s3://testbucket/foo/bar*baz");
 
@@ -331,7 +367,9 @@ public class S3FileSystemTest {
     firstResult.setNextContinuationToken("token");
     firstResult.getObjectSummaries().add(firstMatch);
     firstResult.getObjectSummaries().add(secondMatch);
-    when(mockAmazonS3.listObjectsV2(argThat(new ListObjectsV2RequestArgumentMatches(firstRequest))))
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .listObjectsV2(argThat(new ListObjectsV2RequestArgumentMatches(firstRequest))))
         .thenReturn(firstResult);
 
     // Expect second request with continuation token
@@ -351,14 +389,16 @@ public class S3FileSystemTest {
     ListObjectsV2Result secondResult = new ListObjectsV2Result();
     secondResult.setNextContinuationToken(null);
     secondResult.getObjectSummaries().add(thirdMatch);
-    when(mockAmazonS3.listObjectsV2(
-        argThat(new ListObjectsV2RequestArgumentMatches(secondRequest))))
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .listObjectsV2(argThat(new ListObjectsV2RequestArgumentMatches(secondRequest))))
         .thenReturn(secondResult);
 
     // Expect object metadata queries for content encoding
     ObjectMetadata metadata = new ObjectMetadata();
     metadata.setContentEncoding("");
-    when(mockAmazonS3.getObjectMetadata(anyString(), anyString())).thenReturn(metadata);
+    when(s3FileSystem.getAmazonS3Client().getObjectMetadata(anyString(), anyString()))
+        .thenReturn(metadata);
 
     assertThat(
         s3FileSystem.matchGlobPaths(ImmutableList.of(path)).get(0),
@@ -367,26 +407,22 @@ public class S3FileSystemTest {
                 MatchResult.Metadata.builder()
                     .setIsReadSeekEfficient(true)
                     .setResourceId(
-                        S3ResourceId
-                            .fromComponents(firstMatch.getBucketName(), firstMatch.getKey()))
+                        S3ResourceId.fromComponents(
+                            firstMatch.getBucketName(), firstMatch.getKey()))
                     .setSizeBytes(firstMatch.getSize())
                     .build(),
                 MatchResult.Metadata.builder()
                     .setIsReadSeekEfficient(true)
                     .setResourceId(
-                        S3ResourceId
-                            .fromComponents(thirdMatch.getBucketName(), thirdMatch.getKey()))
+                        S3ResourceId.fromComponents(
+                            thirdMatch.getBucketName(), thirdMatch.getKey()))
                     .setSizeBytes(thirdMatch.getSize())
                     .build())));
   }
 
   @Test
   public void matchGlobWithSlashes() throws IOException {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
-
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     S3ResourceId path = S3ResourceId.fromUri("s3://testbucket/foo/bar\\baz*");
 
@@ -412,13 +448,16 @@ public class S3FileSystemTest {
     ListObjectsV2Result result = new ListObjectsV2Result();
     result.getObjectSummaries().add(firstMatch);
     result.getObjectSummaries().add(secondMatch);
-    when(mockAmazonS3.listObjectsV2(argThat(new ListObjectsV2RequestArgumentMatches(request))))
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .listObjectsV2(argThat(new ListObjectsV2RequestArgumentMatches(request))))
         .thenReturn(result);
 
     // Expect object metadata queries for content encoding
     ObjectMetadata metadata = new ObjectMetadata();
     metadata.setContentEncoding("");
-    when(mockAmazonS3.getObjectMetadata(anyString(), anyString())).thenReturn(metadata);
+    when(s3FileSystem.getAmazonS3Client().getObjectMetadata(anyString(), anyString()))
+        .thenReturn(metadata);
 
     assertThat(
         s3FileSystem.matchGlobPaths(ImmutableList.of(path)).get(0),
@@ -427,39 +466,41 @@ public class S3FileSystemTest {
                 MatchResult.Metadata.builder()
                     .setIsReadSeekEfficient(true)
                     .setResourceId(
-                        S3ResourceId
-                            .fromComponents(firstMatch.getBucketName(), firstMatch.getKey()))
+                        S3ResourceId.fromComponents(
+                            firstMatch.getBucketName(), firstMatch.getKey()))
                     .setSizeBytes(firstMatch.getSize())
                     .build())));
   }
 
   @Test
   public void matchVariousInvokeThreadPool() throws IOException {
-    S3Options pipelineOptions = s3Options();
-    S3FileSystem s3FileSystem = new S3FileSystem(pipelineOptions);
-
-    AmazonS3 mockAmazonS3 = Mockito.mock(AmazonS3.class);
-    s3FileSystem.setAmazonS3Client(mockAmazonS3);
+    S3FileSystem s3FileSystem = buildMockedS3FileSystem();
 
     AmazonS3Exception notFoundException = new AmazonS3Exception("mock exception");
     notFoundException.setStatusCode(404);
-    S3ResourceId pathNotExist = S3ResourceId
-        .fromUri("s3://testbucket/testdirectory/nonexistentfile");
-    when(mockAmazonS3.getObjectMetadata(pathNotExist.getBucket(), pathNotExist.getKey()))
+    S3ResourceId pathNotExist =
+        S3ResourceId.fromUri("s3://testbucket/testdirectory/nonexistentfile");
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .getObjectMetadata(pathNotExist.getBucket(), pathNotExist.getKey()))
         .thenThrow(notFoundException);
 
     AmazonS3Exception forbiddenException = new AmazonS3Exception("mock exception");
     forbiddenException.setStatusCode(403);
-    S3ResourceId pathForbidden = S3ResourceId
-        .fromUri("s3://testbucket/testdirectory/forbiddenfile");
-    when(mockAmazonS3.getObjectMetadata(pathForbidden.getBucket(), pathForbidden.getKey()))
+    S3ResourceId pathForbidden =
+        S3ResourceId.fromUri("s3://testbucket/testdirectory/forbiddenfile");
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .getObjectMetadata(pathForbidden.getBucket(), pathForbidden.getKey()))
         .thenThrow(forbiddenException);
 
     S3ResourceId pathExist = S3ResourceId.fromUri("s3://testbucket/testdirectory/filethatexists");
     ObjectMetadata s3ObjectMetadata = new ObjectMetadata();
     s3ObjectMetadata.setContentLength(100);
     s3ObjectMetadata.setContentEncoding("not-gzip");
-    when(mockAmazonS3.getObjectMetadata(pathExist.getBucket(), pathExist.getKey()))
+    when(s3FileSystem
+            .getAmazonS3Client()
+            .getObjectMetadata(pathExist.getBucket(), pathExist.getKey()))
         .thenReturn(s3ObjectMetadata);
 
     S3ResourceId pathGlob = S3ResourceId.fromUri("s3://testbucket/path/part*");
@@ -472,17 +513,18 @@ public class S3FileSystemTest {
     ListObjectsV2Result listObjectsResult = new ListObjectsV2Result();
     listObjectsResult.setNextContinuationToken(null);
     listObjectsResult.getObjectSummaries().add(foundListObject);
-    when(mockAmazonS3.listObjectsV2(notNull(ListObjectsV2Request.class)))
+    when(s3FileSystem.getAmazonS3Client().listObjectsV2(notNull(ListObjectsV2Request.class)))
         .thenReturn(listObjectsResult);
 
     ObjectMetadata metadata = new ObjectMetadata();
     metadata.setContentEncoding("");
-    when(mockAmazonS3.getObjectMetadata(pathGlob.getBucket(), "path/part-0"))
+    when(s3FileSystem.getAmazonS3Client().getObjectMetadata(pathGlob.getBucket(), "path/part-0"))
         .thenReturn(metadata);
 
     assertThat(
-        s3FileSystem.match(ImmutableList
-            .of(pathNotExist.toString(),
+        s3FileSystem.match(
+            ImmutableList.of(
+                pathNotExist.toString(),
                 pathForbidden.toString(),
                 pathExist.toString(),
                 pathGlob.toString())),
