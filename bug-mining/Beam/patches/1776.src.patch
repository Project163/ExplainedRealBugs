diff --git a/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/AggregateScanConverter.java b/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/AggregateScanConverter.java
index dc674d1f1e3..14c989765f4 100644
--- a/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/AggregateScanConverter.java
+++ b/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/AggregateScanConverter.java
@@ -43,7 +43,6 @@ import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.logical.Log
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlAggFunction;
-import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.ImmutableBitSet;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;
 
@@ -63,7 +62,7 @@ class AggregateScanConverter extends RelConverter<ResolvedAggregateScan> {
 
   @Override
   public RelNode convert(ResolvedAggregateScan zetaNode, List<RelNode> inputs) {
-    RelNode input = convertAggregateScanInputScanToLogicalProject(zetaNode, inputs.get(0));
+    LogicalProject input = convertAggregateScanInputScanToLogicalProject(zetaNode, inputs.get(0));
 
     // Calcite LogicalAggregate's GroupSet is indexes of group fields starting from 0.
     int groupFieldsListSize = zetaNode.getGroupByList().size();
@@ -87,8 +86,12 @@ class AggregateScanConverter extends RelConverter<ResolvedAggregateScan> {
       aggregateCalls = new ArrayList<>();
       // For aggregate calls, their input ref follow after GROUP BY input ref.
       int columnRefoff = groupFieldsListSize;
+      boolean nullable = false;
+      if (input.getProjects().size() > columnRefoff) {
+        nullable = input.getProjects().get(columnRefoff).getType().isNullable();
+      }
       for (ResolvedComputedColumn computedColumn : zetaNode.getAggregateList()) {
-        AggregateCall aggCall = convertAggCall(computedColumn, columnRefoff);
+        AggregateCall aggCall = convertAggCall(computedColumn, columnRefoff, nullable);
         aggregateCalls.add(aggCall);
         if (!aggCall.getArgList().isEmpty()) {
           // Only increment column reference offset when aggregates use them (BEAM-8042).
@@ -110,7 +113,7 @@ class AggregateScanConverter extends RelConverter<ResolvedAggregateScan> {
     return logicalAggregate;
   }
 
-  private RelNode convertAggregateScanInputScanToLogicalProject(
+  private LogicalProject convertAggregateScanInputScanToLogicalProject(
       ResolvedAggregateScan node, RelNode input) {
     // AggregateScan's input is the source of data (e.g. TableScan), which is different from the
     // design of CalciteSQL, in which the LogicalAggregate's input is a LogicalProject, whose input
@@ -165,7 +168,8 @@ class AggregateScanConverter extends RelConverter<ResolvedAggregateScan> {
     return LogicalProject.create(input, projects, fieldNames);
   }
 
-  private AggregateCall convertAggCall(ResolvedComputedColumn computedColumn, int columnRefOff) {
+  private AggregateCall convertAggCall(
+      ResolvedComputedColumn computedColumn, int columnRefOff, boolean nullable) {
     ResolvedAggregateFunctionCall aggregateFunctionCall =
         (ResolvedAggregateFunctionCall) computedColumn.getExpr();
 
@@ -217,17 +221,9 @@ class AggregateScanConverter extends RelConverter<ResolvedAggregateScan> {
       }
     }
 
-    // TODO: there should be a general way to decide if a return type of a aggcall is nullable.
-    RelDataType returnType;
-    if (sqlAggFunction.equals(SqlStdOperatorTable.ANY_VALUE)) {
-      returnType =
-          toSimpleRelDataType(
-              computedColumn.getColumn().getType().getKind(), getCluster().getRexBuilder(), true);
-    } else {
-      returnType =
-          toSimpleRelDataType(
-              computedColumn.getColumn().getType().getKind(), getCluster().getRexBuilder(), false);
-    }
+    RelDataType returnType =
+        toSimpleRelDataType(
+            computedColumn.getColumn().getType().getKind(), getCluster().getRexBuilder(), nullable);
 
     String aggName = getTrait().resolveAlias(computedColumn.getColumn());
     return AggregateCall.create(
diff --git a/sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java b/sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java
index ae5ddbaf3e8..6d4eb3e2a0c 100644
--- a/sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java
+++ b/sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java
@@ -1980,6 +1980,21 @@ public class ZetaSQLDialectSpecTest {
     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));
   }
 
+  @Test
+  public void testZetaSQLHavingNull() {
+    String sql = "SELECT SUM(int64_val) FROM all_null_table GROUP BY primary_key HAVING false";
+
+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);
+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);
+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);
+
+    final Schema schema = Schema.builder().addInt64Field("field").build();
+
+    PAssert.that(stream).empty();
+
+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));
+  }
+
   @Test
   public void testZetaSQLBasicFixedWindowing() {
     String sql =
