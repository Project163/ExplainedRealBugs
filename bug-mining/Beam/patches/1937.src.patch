diff --git a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactory.java b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactory.java
index da7a7142a2c..b487367b478 100644
--- a/runners/direct-java/src/main/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactory.java
+++ b/runners/direct-java/src/main/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactory.java
@@ -23,15 +23,10 @@ import com.google.auto.value.AutoValue;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
 import java.util.PriorityQueue;
 import org.apache.beam.runners.core.KeyedWorkItem;
 import org.apache.beam.runners.core.KeyedWorkItems;
-import org.apache.beam.runners.core.StateNamespace;
-import org.apache.beam.runners.core.StateNamespaces;
 import org.apache.beam.runners.core.StateNamespaces.WindowNamespace;
 import org.apache.beam.runners.core.StateTag;
 import org.apache.beam.runners.core.StateTags;
@@ -40,37 +35,23 @@ import org.apache.beam.runners.direct.DirectExecutionContext.DirectStepContext;
 import org.apache.beam.runners.direct.ParDoMultiOverrideFactory.StatefulParDo;
 import org.apache.beam.runners.direct.WatermarkManager.TimerUpdate;
 import org.apache.beam.runners.local.StructuralKey;
-import org.apache.beam.sdk.coders.Coder;
 import org.apache.beam.sdk.options.PipelineOptions;
 import org.apache.beam.sdk.runners.AppliedPTransform;
-import org.apache.beam.sdk.state.StateSpec;
 import org.apache.beam.sdk.state.WatermarkHoldState;
-import org.apache.beam.sdk.transforms.DoFn;
 import org.apache.beam.sdk.transforms.ParDo;
-import org.apache.beam.sdk.transforms.reflect.DoFnSignature;
-import org.apache.beam.sdk.transforms.reflect.DoFnSignature.StateDeclaration;
-import org.apache.beam.sdk.transforms.reflect.DoFnSignatures;
 import org.apache.beam.sdk.transforms.windowing.BoundedWindow;
 import org.apache.beam.sdk.transforms.windowing.TimestampCombiner;
 import org.apache.beam.sdk.util.WindowedValue;
 import org.apache.beam.sdk.values.KV;
 import org.apache.beam.sdk.values.PCollection;
 import org.apache.beam.sdk.values.PCollectionTuple;
-import org.apache.beam.sdk.values.PValue;
-import org.apache.beam.sdk.values.TupleTag;
-import org.apache.beam.sdk.values.WindowingStrategy;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.CacheBuilder;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.CacheLoader;
-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.cache.LoadingCache;
 import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;
 import org.joda.time.Instant;
 
 /** A {@link TransformEvaluatorFactory} for stateful {@link ParDo}. */
 final class StatefulParDoEvaluatorFactory<K, InputT, OutputT> implements TransformEvaluatorFactory {
 
-  private final LoadingCache<AppliedPTransformOutputKeyAndWindow<K, InputT, OutputT>, Runnable>
-      cleanupRegistry;
-
   private final ParDoEvaluatorFactory<KV<K, InputT>, OutputT> delegateFactory;
 
   private final EvaluationContext evaluationContext;
@@ -92,11 +73,6 @@ final class StatefulParDoEvaluatorFactory<K, InputT, OutputT> implements Transfo
               }
             },
             options);
-    this.cleanupRegistry =
-        CacheBuilder.newBuilder()
-            .weakValues()
-            .build(new CleanupSchedulingLoader(evaluationContext));
-
     this.evaluationContext = evaluationContext;
   }
 
@@ -125,22 +101,6 @@ final class StatefulParDoEvaluatorFactory<K, InputT, OutputT> implements Transfo
       CommittedBundle<KeyedWorkItem<K, KV<K, InputT>>> inputBundle)
       throws Exception {
 
-    final DoFn<KV<K, InputT>, OutputT> doFn = application.getTransform().getDoFn();
-    final DoFnSignature signature = DoFnSignatures.getSignature(doFn.getClass());
-
-    // If the DoFn is stateful, schedule state clearing.
-    // It is semantically correct to schedule any number of redundant clear tasks; the
-    // cache is used to limit the number of tasks to avoid performance degradation.
-    if (signature.stateDeclarations().size() > 0) {
-      for (final WindowedValue<?> element : inputBundle.getElements()) {
-        for (final BoundedWindow window : element.getWindows()) {
-          cleanupRegistry.get(
-              AppliedPTransformOutputKeyAndWindow.create(
-                  application, (StructuralKey<K>) inputBundle.getKey(), window));
-        }
-      }
-    }
-
     DoFnLifecycleManagerRemovingTransformEvaluator<KV<K, InputT>> delegateEvaluator =
         delegateFactory.createEvaluator(
             (AppliedPTransform) application,
@@ -161,66 +121,6 @@ final class StatefulParDoEvaluatorFactory<K, InputT, OutputT> implements Transfo
     return new StatefulParDoEvaluator<>(delegateEvaluator, stepContext);
   }
 
-  private class CleanupSchedulingLoader
-      extends CacheLoader<AppliedPTransformOutputKeyAndWindow<K, InputT, OutputT>, Runnable> {
-
-    private final EvaluationContext evaluationContext;
-
-    public CleanupSchedulingLoader(EvaluationContext evaluationContext) {
-      this.evaluationContext = evaluationContext;
-    }
-
-    @Override
-    public Runnable load(
-        final AppliedPTransformOutputKeyAndWindow<K, InputT, OutputT> transformOutputWindow) {
-      String stepName = evaluationContext.getStepName(transformOutputWindow.getTransform());
-
-      Map<TupleTag<?>, PCollection<?>> taggedValues = new HashMap<>();
-      for (Entry<TupleTag<?>, PValue> pv :
-          transformOutputWindow.getTransform().getOutputs().entrySet()) {
-        taggedValues.put(pv.getKey(), (PCollection<?>) pv.getValue());
-      }
-      PCollection<?> pc =
-          taggedValues.get(transformOutputWindow.getTransform().getTransform().getMainOutputTag());
-      WindowingStrategy<?, ?> windowingStrategy = pc.getWindowingStrategy();
-      BoundedWindow window = transformOutputWindow.getWindow();
-      final DoFn<?, ?> doFn = transformOutputWindow.getTransform().getTransform().getDoFn();
-      final DoFnSignature signature = DoFnSignatures.getSignature(doFn.getClass());
-
-      final DirectStepContext stepContext =
-          evaluationContext
-              .getExecutionContext(
-                  transformOutputWindow.getTransform(), transformOutputWindow.getKey())
-              .getStepContext(stepName);
-
-      final StateNamespace namespace =
-          StateNamespaces.window(
-              (Coder<BoundedWindow>) windowingStrategy.getWindowFn().windowCoder(), window);
-
-      Runnable cleanup =
-          () -> {
-            for (StateDeclaration stateDecl : signature.stateDeclarations().values()) {
-              StateTag<?> tag;
-              try {
-                tag = StateTags.tagForSpec(stateDecl.id(), (StateSpec) stateDecl.field().get(doFn));
-              } catch (IllegalAccessException e) {
-                throw new RuntimeException(
-                    String.format(
-                        "Error accessing %s for %s",
-                        StateSpec.class.getName(), doFn.getClass().getName()),
-                    e);
-              }
-              stepContext.stateInternals().state(namespace, tag).clear();
-            }
-            cleanupRegistry.invalidate(transformOutputWindow);
-          };
-
-      evaluationContext.scheduleAfterWindowExpiration(
-          transformOutputWindow.getTransform(), window, windowingStrategy, cleanup);
-      return cleanup;
-    }
-  }
-
   @AutoValue
   abstract static class AppliedPTransformOutputKeyAndWindow<K, InputT, OutputT> {
     abstract AppliedPTransform<
diff --git a/runners/direct-java/src/test/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactoryTest.java b/runners/direct-java/src/test/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactoryTest.java
index fd808543d03..32b4549b359 100644
--- a/runners/direct-java/src/test/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactoryTest.java
+++ b/runners/direct-java/src/test/java/org/apache/beam/runners/direct/StatefulParDoEvaluatorFactoryTest.java
@@ -19,12 +19,10 @@ package org.apache.beam.runners.direct;
 
 import static org.hamcrest.Matchers.containsInAnyOrder;
 import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.nullValue;
 import static org.junit.Assert.assertThat;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Matchers.anyList;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import java.io.Serializable;
@@ -35,10 +33,6 @@ import org.apache.beam.runners.core.KeyedWorkItem;
 import org.apache.beam.runners.core.KeyedWorkItems;
 import org.apache.beam.runners.core.ReadyCheckingSideInputReader;
 import org.apache.beam.runners.core.StateInternals;
-import org.apache.beam.runners.core.StateNamespace;
-import org.apache.beam.runners.core.StateNamespaces;
-import org.apache.beam.runners.core.StateTag;
-import org.apache.beam.runners.core.StateTags;
 import org.apache.beam.runners.core.construction.TransformInputs;
 import org.apache.beam.runners.direct.ParDoMultiOverrideFactory.StatefulParDo;
 import org.apache.beam.runners.direct.WatermarkManager.TimerUpdate;
@@ -85,7 +79,6 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-import org.mockito.ArgumentCaptor;
 import org.mockito.Matchers;
 import org.mockito.Mock;
 import org.mockito.Mockito;
@@ -128,130 +121,6 @@ public class StatefulParDoEvaluatorFactoryTest implements Serializable {
                 .createReaderForViews(Collections.emptyList()));
   }
 
-  @Test
-  public void windowCleanupScheduled() throws Exception {
-    // To test the factory, first we set up a pipeline and then we use the constructed
-    // pipeline to create the right parameters to pass to the factory
-
-    final String stateId = "my-state-id";
-
-    // For consistency, window it into FixedWindows. Actually we will fabricate an input bundle.
-    PCollection<KV<String, Integer>> input =
-        pipeline
-            .apply(Create.of(KV.of("hello", 1), KV.of("hello", 2)))
-            .apply(Window.into(FixedWindows.of(Duration.millis(10))));
-
-    TupleTag<Integer> mainOutput = new TupleTag<>();
-    final ParDoMultiOverrideFactory.GbkThenStatefulParDo<String, Integer, Integer>
-        gbkThenStatefulParDo;
-    gbkThenStatefulParDo =
-        new ParDoMultiOverrideFactory.GbkThenStatefulParDo<>(
-            new DoFn<KV<String, Integer>, Integer>() {
-              @StateId(stateId)
-              private final StateSpec<ValueState<String>> spec =
-                  StateSpecs.value(StringUtf8Coder.of());
-
-              @ProcessElement
-              public void process(ProcessContext c) {}
-            },
-            mainOutput,
-            TupleTagList.empty(),
-            Collections.emptyList(),
-            DoFnSchemaInformation.create(),
-            Collections.emptyMap());
-
-    final PCollection<KeyedWorkItem<String, KV<String, Integer>>> grouped =
-        gbkThenStatefulParDo.groupToKeyedWorkItem(input);
-
-    PCollection<Integer> produced =
-        gbkThenStatefulParDo.applyStatefulParDo(grouped).get(mainOutput).setCoder(VarIntCoder.of());
-
-    StatefulParDoEvaluatorFactory<String, Integer, Integer> factory =
-        new StatefulParDoEvaluatorFactory<>(mockEvaluationContext, options);
-
-    AppliedPTransform<
-            PCollection<? extends KeyedWorkItem<String, KV<String, Integer>>>,
-            PCollectionTuple,
-            StatefulParDo<String, Integer, Integer>>
-        producingTransform = (AppliedPTransform) DirectGraphs.getProducer(produced);
-
-    // Then there will be a digging down to the step context to get the state internals
-    when(mockEvaluationContext.getExecutionContext(
-            eq(producingTransform), Mockito.<StructuralKey>any()))
-        .thenReturn(mockExecutionContext);
-    when(mockExecutionContext.getStepContext(any())).thenReturn(mockStepContext);
-
-    IntervalWindow firstWindow = new IntervalWindow(new Instant(0), new Instant(9));
-    IntervalWindow secondWindow = new IntervalWindow(new Instant(10), new Instant(19));
-
-    StateNamespace firstWindowNamespace =
-        StateNamespaces.window(IntervalWindow.getCoder(), firstWindow);
-    StateNamespace secondWindowNamespace =
-        StateNamespaces.window(IntervalWindow.getCoder(), secondWindow);
-    StateTag<ValueState<String>> tag =
-        StateTags.tagForSpec(stateId, StateSpecs.value(StringUtf8Coder.of()));
-
-    // Set up non-empty state. We don't mock + verify calls to clear() but instead
-    // check that state is actually empty. We musn't care how it is accomplished.
-    stateInternals.state(firstWindowNamespace, tag).write("first");
-    stateInternals.state(secondWindowNamespace, tag).write("second");
-
-    // A single bundle with some elements in the global window; it should register cleanup for the
-    // global window state merely by having the evaluator created. The cleanup logic does not
-    // depend on the window.
-    CommittedBundle<KeyedWorkItem<String, KV<String, Integer>>> inputBundle =
-        BUNDLE_FACTORY
-            .createBundle(grouped)
-            .add(
-                WindowedValue.of(
-                    KeyedWorkItems.<String, KV<String, Integer>>elementsWorkItem(
-                        "hello",
-                        Collections.singleton(
-                            WindowedValue.of(
-                                KV.of("hello", 1),
-                                new Instant(3),
-                                firstWindow,
-                                PaneInfo.NO_FIRING))),
-                    new Instant(3),
-                    firstWindow,
-                    PaneInfo.NO_FIRING))
-            .add(
-                WindowedValue.of(
-                    KeyedWorkItems.<String, KV<String, Integer>>elementsWorkItem(
-                        "hello",
-                        Collections.singleton(
-                            WindowedValue.of(
-                                KV.of("hello", 2),
-                                new Instant(11),
-                                secondWindow,
-                                PaneInfo.NO_FIRING))),
-                    new Instant(11),
-                    secondWindow,
-                    PaneInfo.NO_FIRING))
-            .commit(Instant.now());
-
-    // Merely creating the evaluator should suffice to register the cleanup callback
-    factory.forApplication(producingTransform, inputBundle);
-
-    ArgumentCaptor<Runnable> argumentCaptor = ArgumentCaptor.forClass(Runnable.class);
-    verify(mockEvaluationContext)
-        .scheduleAfterWindowExpiration(
-            eq(producingTransform), eq(firstWindow), Mockito.any(), argumentCaptor.capture());
-
-    // Should actually clear the state for the first window
-    argumentCaptor.getValue().run();
-    assertThat(stateInternals.state(firstWindowNamespace, tag).read(), nullValue());
-    assertThat(stateInternals.state(secondWindowNamespace, tag).read(), equalTo("second"));
-
-    verify(mockEvaluationContext)
-        .scheduleAfterWindowExpiration(
-            eq(producingTransform), eq(secondWindow), Mockito.any(), argumentCaptor.capture());
-
-    // Should actually clear the state for the second window
-    argumentCaptor.getValue().run();
-    assertThat(stateInternals.state(secondWindowNamespace, tag).read(), nullValue());
-  }
-
   /**
    * A test that explicitly delays a side input so that the main input will have to be reprocessed,
    * testing that {@code finishBundle()} re-assembles the GBK outputs correctly.
