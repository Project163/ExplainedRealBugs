[{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76149885","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/3627#issuecomment-76149885","issue_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/3627","id":76149885,"node_id":"MDEyOklzc3VlQ29tbWVudDc2MTQ5ODg1","user":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2015-02-26T09:50:34Z","updated_at":"2015-02-26T09:50:34Z","body":"Confirmed, although the Redis and Memcached drivers are built around the assumption that you need their speed, and therefore you should never have a request that takes more than 5 seconds to process.\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76149885/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76256049","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/3627#issuecomment-76256049","issue_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/3627","id":76256049,"node_id":"MDEyOklzc3VlQ29tbWVudDc2MjU2MDQ5","user":{"login":"Ignasimg","id":2076465,"node_id":"MDQ6VXNlcjIwNzY0NjU=","avatar_url":"https://avatars.githubusercontent.com/u/2076465?v=4","gravatar_id":"","url":"https://api.github.com/users/Ignasimg","html_url":"https://github.com/Ignasimg","followers_url":"https://api.github.com/users/Ignasimg/followers","following_url":"https://api.github.com/users/Ignasimg/following{/other_user}","gists_url":"https://api.github.com/users/Ignasimg/gists{/gist_id}","starred_url":"https://api.github.com/users/Ignasimg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ignasimg/subscriptions","organizations_url":"https://api.github.com/users/Ignasimg/orgs","repos_url":"https://api.github.com/users/Ignasimg/repos","events_url":"https://api.github.com/users/Ignasimg/events{/privacy}","received_events_url":"https://api.github.com/users/Ignasimg/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2015-02-26T19:54:49Z","updated_at":"2015-02-26T19:54:49Z","body":"No ofense but I think this assumption is at most... useless.\n\nWhat I mean is who doesn't want their website to be as fast as possible?\n\nBut this doesn't mean, we always can return requests before 5 (or just X) seconds...\nIt might be cause the request need to do something weird with data or because you need to request something from other servers, and you know from time to time the network and/or the server will be more busy and you'll take X+1 seconds. Shit happens...\n\nWell that being said, I have searched and documented myself to try to propose a working solution for both of them, and aparently in redis is not only easy, but already done (even with distributed back-end) [redlock](http://redis.io/topics/distlock#distributed-locks-with-redis), however in memcached not only there isn't anything similar to it, but also seems impossible in the terms redis does it (it's possible to make an atomic operation such as [Memcached::add](http://php.net/manual/en/memcached.add.php)) but it's not possible to delete a key with a condition of the value (atomically). Nevertheless I still think it's possible to do it on memcache (in other terms as I said, but possible...)\n\nNow I know what will you say \"those algorithms are too big\", and I agree with you, and I'll also add \"they only solve some edge cases, that are also relatively hard to happen\" (in my opinion, even without the locks it's hard to have an issue with it)\n\nBut if we don't change those algorithms AT THE VERY LEAST it should be noted in the documentation somehow that a requests should only access session within the first five seconds of the requests (trying to don't run into missunderstandings by people thinking they need to check the time before accessing session...) And after all... honestly I think it would be quite hilarious... so in my opinion we should change the _lock procedures, to achieve a real lock. What do you think about it?\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76256049/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"Ignasimg","id":2076465,"node_id":"MDQ6VXNlcjIwNzY0NjU=","avatar_url":"https://avatars.githubusercontent.com/u/2076465?v=4","gravatar_id":"","url":"https://api.github.com/users/Ignasimg","html_url":"https://github.com/Ignasimg","followers_url":"https://api.github.com/users/Ignasimg/followers","following_url":"https://api.github.com/users/Ignasimg/following{/other_user}","gists_url":"https://api.github.com/users/Ignasimg/gists{/gist_id}","starred_url":"https://api.github.com/users/Ignasimg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ignasimg/subscriptions","organizations_url":"https://api.github.com/users/Ignasimg/orgs","repos_url":"https://api.github.com/users/Ignasimg/repos","events_url":"https://api.github.com/users/Ignasimg/events{/privacy}","received_events_url":"https://api.github.com/users/Ignasimg/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76259643","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/3627#issuecomment-76259643","issue_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/3627","id":76259643,"node_id":"MDEyOklzc3VlQ29tbWVudDc2MjU5NjQz","user":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2015-02-26T20:08:58Z","updated_at":"2015-02-26T20:08:58Z","body":"A quote from the docs:\n\n> Since Redis doesn't have a locking mechanism exposed, locks for this driver are emulated by a separate value that is kept for up to 5 seconds. You may experience issues if your page loads take longer than that!\n\nSeriously though, me saying \"Confirmed\" meant that this is a bug that must be fixed. The 5 second timeout should only cause subsequent requests to fail, not the first to obtain the lock.\n\nI'm inclined to disagree with everything else you said/proposed, but it's not worth discussing it ... you shouldn't have either.\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76259643/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76264193","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/3627#issuecomment-76264193","issue_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/3627","id":76264193,"node_id":"MDEyOklzc3VlQ29tbWVudDc2MjY0MTkz","user":{"login":"Ignasimg","id":2076465,"node_id":"MDQ6VXNlcjIwNzY0NjU=","avatar_url":"https://avatars.githubusercontent.com/u/2076465?v=4","gravatar_id":"","url":"https://api.github.com/users/Ignasimg","html_url":"https://github.com/Ignasimg","followers_url":"https://api.github.com/users/Ignasimg/followers","following_url":"https://api.github.com/users/Ignasimg/following{/other_user}","gists_url":"https://api.github.com/users/Ignasimg/gists{/gist_id}","starred_url":"https://api.github.com/users/Ignasimg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ignasimg/subscriptions","organizations_url":"https://api.github.com/users/Ignasimg/orgs","repos_url":"https://api.github.com/users/Ignasimg/repos","events_url":"https://api.github.com/users/Ignasimg/events{/privacy}","received_events_url":"https://api.github.com/users/Ignasimg/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2015-02-26T20:30:17Z","updated_at":"2015-02-26T20:30:17Z","body":"Sorry, I checked the docs on the web, not the ones in the git.\n\nAnd I'd really like to know why you disagree on the proposals, not to start a flame war, but I'd like to help with some implementation that really works. (Am I right if I guess the good version shouldn't have anything to do with times? While hopefully being dead-lock free?)\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76264193/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"Ignasimg","id":2076465,"node_id":"MDQ6VXNlcjIwNzY0NjU=","avatar_url":"https://avatars.githubusercontent.com/u/2076465?v=4","gravatar_id":"","url":"https://api.github.com/users/Ignasimg","html_url":"https://github.com/Ignasimg","followers_url":"https://api.github.com/users/Ignasimg/followers","following_url":"https://api.github.com/users/Ignasimg/following{/other_user}","gists_url":"https://api.github.com/users/Ignasimg/gists{/gist_id}","starred_url":"https://api.github.com/users/Ignasimg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ignasimg/subscriptions","organizations_url":"https://api.github.com/users/Ignasimg/orgs","repos_url":"https://api.github.com/users/Ignasimg/repos","events_url":"https://api.github.com/users/Ignasimg/events{/privacy}","received_events_url":"https://api.github.com/users/Ignasimg/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76273383","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/3627#issuecomment-76273383","issue_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/3627","id":76273383,"node_id":"MDEyOklzc3VlQ29tbWVudDc2MjczMzgz","user":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2015-02-26T21:06:23Z","updated_at":"2015-02-26T21:06:23Z","body":"> No ofense but I think this assumption is at most... useless.\n> \n> What I mean is who doesn't want their website to be as fast as possible?\n- Use Redis/Memcached sessions for _speed_.\n- Have _concurrent_ page-loads taking _more than 5 seconds to complete_ and _without closing the session first_.\n\n... that's useless. I'm sure you understand why.\n\n> But this doesn't mean, we always can return requests before 5 (or just X) seconds...\n\nIf you can't, something's wrong with your application.\n\n> It might be cause the request need to do something weird with data or because you need to request something from other servers, and you know from time to time the network and/or the server will be more busy and you'll take X+1 seconds. Shit happens...\n\nAnytime you use an external resource, you'll lose any performance benefit that you've gained from using Redis or Memcached. Therefore, you're just as good using the 'files' driver, which isn't the default for no reason ...\n\n> Well that being said, I have searched and documented myself to try to propose a working solution for both of them, and aparently in redis is not only easy, but already done (even with distributed back-end) redlock, however in memcached not only there isn't anything similar to it, but also seems impossible in the terms redis does it (it's possible to make an atomic operation such as Memcached::add) but it's not possible to delete a key with a condition of the value (atomically). Nevertheless I still think it's possible to do it on memcache (in other terms as I said, but possible...)\n\nYou can't have a deadlock-free mechanism without time values. Even redlock uses them.\n\n> Now I know what will you say \"those algorithms are too big\", and I agree with you, and I'll also add \"they only solve some edge cases, that are also relatively hard to happen\" (in my opinion, even without the locks it's hard to have an issue with it)\n\nYep, not worth it ... even if I didn't have anything other against them.\n\n> But if we don't change those algorithms AT THE VERY LEAST it should be noted in the documentation somehow that a requests should only access session within the first five seconds of the requests (trying to don't run into missunderstandings by people thinking they need to check the time before accessing session...) And after all... honestly I think it would be quite hilarious... so in my opinion we should change the _lock procedures, to achieve a real lock. What do you think about it?\n\nI believe I already answered that with my previous comment. Except there's no such thing as a \"real lock\" on these platforms, you can only emulate a lock.\n\n---\n\n> Am I right if I guess the good version shouldn't have anything to do with times? While hopefully being dead-lock free?\n\nNo, read above.\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76273383/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76576192","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/3627#issuecomment-76576192","issue_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/3627","id":76576192,"node_id":"MDEyOklzc3VlQ29tbWVudDc2NTc2MTky","user":{"login":"Ignasimg","id":2076465,"node_id":"MDQ6VXNlcjIwNzY0NjU=","avatar_url":"https://avatars.githubusercontent.com/u/2076465?v=4","gravatar_id":"","url":"https://api.github.com/users/Ignasimg","html_url":"https://github.com/Ignasimg","followers_url":"https://api.github.com/users/Ignasimg/followers","following_url":"https://api.github.com/users/Ignasimg/following{/other_user}","gists_url":"https://api.github.com/users/Ignasimg/gists{/gist_id}","starred_url":"https://api.github.com/users/Ignasimg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ignasimg/subscriptions","organizations_url":"https://api.github.com/users/Ignasimg/orgs","repos_url":"https://api.github.com/users/Ignasimg/repos","events_url":"https://api.github.com/users/Ignasimg/events{/privacy}","received_events_url":"https://api.github.com/users/Ignasimg/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2015-03-01T05:45:27Z","updated_at":"2015-03-01T05:45:27Z","body":"Ok, I don't agree with you on the first points, and a quick example comes to my mind... (an airplane ticket search engine, that stores the results on session) but as you said and I agree that's a worthless discussion... now to the issue.\n\nIs there a way to avoid deadlocks without time values? Definely not when the process might ask for different locks, but I certainly think there is in our case, which a process might want at most 1 lock at a time... Altought it's far from simple to implement, one could store a server_id & process_id of the current process who has the lock. The next process getting stoped by the lock should send a request to the server asking if the process is still alive... if the process is still alive it's mean sooner or later it will release the lock (unless it's trapped on something else, but that's not the lock problem...), on the other side if the process is not alive, the process which wants the lock should create a new sessionid, somehow based in a deterministic way on the one that's \"locked\" and create a new lock with this new sessionid... and yet it'd produce some issues like having the database with zombie locks... which I guess could also be solved by some weird process also without time... but yes... I deffinely think even this is possible it's not the way to go...\n\nSo now my other proposal which is far more simple... what if we allow deadlocks? As said before, in our case deadlocks only occur when a process either dies without clearing the lock, or it's trapped on an infinite loop.\nNow... how much infinite is the infinite? yep that might sound funny, but in php if you want to have an infinite loop which last longer than 30 seconds, you deliverately need to do it... it's not a matter of having a bug...\nHaving said that, it wouldn't be hard to setup a [shutdown function](http://php.net/manual/en/function.register-shutdown-function.php) that releases the session lock on shutdown, so the case of incidental infinite loop I think is solved quite gracefully.\n\nSo what if the process dies? (without executing the shutdown function) or if the server lost the connection at the time to release the lock? We're in deadlock. And we'll fuck up the user experience by asking them to logout / login again. That's deffinely not good.\n\nBut what about a dead-lock free version with TTL? well at some point if you are \"lucky\" enough, you might find yourself with weird issues, hard to replicate, etc...\n\nSo the question is.... what is most likely to happen? \nThat two or more requests get lucky to fall in love with each other and end up making love with your session data.\nOr that a server / process misteriously dies or loses connection.\n\nThat's also something we could discuss about for a long time without getting nowhere, but my point is a non-deadlock free solution should at least be considered.\n\n---\n\nExtra note: \nWhile writting this I happened to think about another solution, similar to the deadlock free proposed above, but instead of keeping the server_id / process_id on the lock, you can keep [connection_id](http://redis.io/commands/client-getname) in redis. And not only that, but once a new process wants the lock, it doesn't need to check a remote server, redis itself could [check](http://redis.io/commands/client-list) if the connection died, and if so erase the lock. Still a little bit hardlifting but much more clean I think. The downside is it would only work on redis...\n\nAnyway just some thoughts\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/76576192/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"Ignasimg","id":2076465,"node_id":"MDQ6VXNlcjIwNzY0NjU=","avatar_url":"https://avatars.githubusercontent.com/u/2076465?v=4","gravatar_id":"","url":"https://api.github.com/users/Ignasimg","html_url":"https://github.com/Ignasimg","followers_url":"https://api.github.com/users/Ignasimg/followers","following_url":"https://api.github.com/users/Ignasimg/following{/other_user}","gists_url":"https://api.github.com/users/Ignasimg/gists{/gist_id}","starred_url":"https://api.github.com/users/Ignasimg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ignasimg/subscriptions","organizations_url":"https://api.github.com/users/Ignasimg/orgs","repos_url":"https://api.github.com/users/Ignasimg/repos","events_url":"https://api.github.com/users/Ignasimg/events{/privacy}","received_events_url":"https://api.github.com/users/Ignasimg/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/77123662","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/3627#issuecomment-77123662","issue_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/3627","id":77123662,"node_id":"MDEyOklzc3VlQ29tbWVudDc3MTIzNjYy","user":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2015-03-04T09:32:53Z","updated_at":"2015-03-04T09:32:53Z","body":"> Is there a way to avoid deadlocks without time values? Definely not when the process might ask for different locks, but I certainly think there is in our case, which a process might want at most 1 lock at a time... Altought it's far from simple to implement, one could store a server_id & process_id of the current process who has the lock. The next process getting stoped by the lock should send a request to the server asking if the process is still alive... if the process is still alive it's mean sooner or later it will release the lock (unless it's trapped on something else, but that's not the lock problem...), on the other side if the process is not alive, the process which wants the lock should create a new sessionid, somehow based in a deterministic way on the one that's \"locked\" and create a new lock with this new sessionid... and yet it'd produce some issues like having the database with zombie locks... which I guess could also be solved by some weird process also without time... but yes... I deffinely think even this is possible it's not the way to go...\n\nJust FYI, there are two flaws in that scheme, even ignoring the sheer complexity that makes it impractical:\n- Generating a new session ID is not an option.\n- Running this on any httpd with multi-thread execution model may result in two concurrent requests with the same process ID.\n\n> So now my other proposal which is far more simple... what if we allow deadlocks? As said before, in our case deadlocks only occur when a process either dies without clearing the lock, or it's trapped on an infinite loop.\n> Now... how much infinite is the infinite? yep that might sound funny, but in php if you want to have an infinite loop which last longer than 30 seconds, you deliverately need to do it... it's not a matter of having a bug...\n> Having said that, it wouldn't be hard to setup a shutdown function that releases the session lock on shutdown, so the case of incidental infinite loop I think is solved quite gracefully.\n\nYou lost me at \"allow deadlocks\", that's a debugging nightmare far worse than anything else that we're trying to solve, especially in a web application.\n\nAlso, `session_write_close()` is already registered as a shutdown function and it does free the lock, but again - if the request crashes for whatever reason, we're doomed.\n\n> So what if the process dies? (without executing the shutdown function) or if the server lost the connection at the time to release the lock? We're in deadlock. And we'll fuck up the user experience by asking them to logout / login again. That's deffinely not good.\n\nA deadlock condition means you can't acquire the lock, the request times out and you can't even offer the option to logout. The user will have to stop visiting the page until the whole session is expired.\n\n> But what about a dead-lock free version with TTL? well at some point if you are \"lucky\" enough, you might find yourself with weird issues, hard to replicate, etc...\n\nThe only problem with TTLs is having the right timings. You found a _timing_ flaw in the current scheme and that's what we need to fix ... I believe I've got the solution already and will try to commit it today.\n\n> So the question is.... what is most likely to happen?\n> That two or more requests get lucky to fall in love with each other and end up making love with your session data.\n> Or that a server / process misteriously dies or loses connection.\n> \n> That's also something we could discuss about for a long time without getting nowhere, but my point is a non-deadlock free solution should at least be considered.\n\nYeah ... no. :)\nRead above.\n\n> Extra note:\n> While writting this I happened to think about another solution, similar to the deadlock free proposed above, but instead of keeping the server_id / process_id on the lock, you can keep connection_id in redis. And not only that, but once a new process wants the lock, it doesn't need to check a remote server, redis itself could check if the connection died, and if so erase the lock. Still a little bit hardlifting but much more clean I think. The downside is it would only work on redis...\n\nNeat, but yes - too much hardlifting and downsides.\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/77123662/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false}},{"id":245924364,"node_id":"MDExOkNsb3NlZEV2ZW50MjQ1OTI0MzY0","url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/events/245924364","actor":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"closed","commit_id":"e1a5bb345b1b30ea777348efa9cade21c1f2e2fb","commit_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/commits/e1a5bb345b1b30ea777348efa9cade21c1f2e2fb","created_at":"2015-03-04T11:33:58Z","state_reason":null,"performed_via_github_app":null},{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/77348545","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/3627#issuecomment-77348545","issue_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/3627","id":77348545,"node_id":"MDEyOklzc3VlQ29tbWVudDc3MzQ4NTQ1","user":{"login":"Ignasimg","id":2076465,"node_id":"MDQ6VXNlcjIwNzY0NjU=","avatar_url":"https://avatars.githubusercontent.com/u/2076465?v=4","gravatar_id":"","url":"https://api.github.com/users/Ignasimg","html_url":"https://github.com/Ignasimg","followers_url":"https://api.github.com/users/Ignasimg/followers","following_url":"https://api.github.com/users/Ignasimg/following{/other_user}","gists_url":"https://api.github.com/users/Ignasimg/gists{/gist_id}","starred_url":"https://api.github.com/users/Ignasimg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ignasimg/subscriptions","organizations_url":"https://api.github.com/users/Ignasimg/orgs","repos_url":"https://api.github.com/users/Ignasimg/repos","events_url":"https://api.github.com/users/Ignasimg/events{/privacy}","received_events_url":"https://api.github.com/users/Ignasimg/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2015-03-05T11:28:09Z","updated_at":"2015-03-05T11:29:05Z","body":"Well even I don't fully understand your objections about the first solution I proposed, since (I think) we both think second one was the best solution (even though only working on redis), yet you don't seem to like it much, let's leave this discussion here.\n\nOn the other side... either you or me didn't understand anything...\nYou say I found a timing flaw? What do you exactly mean by that? You mean the problem was that the lock would only be held for 5 seconds while an http timeout usually happens at 300 seconds?\nMaybe that is part of the problem, but in my opinion, the real problem, (even though now with such a big TTL will probably never appear) is still there.\n\nAnd finally you say allowing deathlocks would be a debugging nightmare... And you got a point, about the logout thing (even though it can be solved by ... ugly dirty and nasty solutions).\nBut since the problems that could lead to a deathlock (if we allowed them) would also lead to a 5 minutes deathlock in the current version... I ask you, isn't 5 minutes a debugging nightmare?\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/77348545/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"Ignasimg","id":2076465,"node_id":"MDQ6VXNlcjIwNzY0NjU=","avatar_url":"https://avatars.githubusercontent.com/u/2076465?v=4","gravatar_id":"","url":"https://api.github.com/users/Ignasimg","html_url":"https://github.com/Ignasimg","followers_url":"https://api.github.com/users/Ignasimg/followers","following_url":"https://api.github.com/users/Ignasimg/following{/other_user}","gists_url":"https://api.github.com/users/Ignasimg/gists{/gist_id}","starred_url":"https://api.github.com/users/Ignasimg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ignasimg/subscriptions","organizations_url":"https://api.github.com/users/Ignasimg/orgs","repos_url":"https://api.github.com/users/Ignasimg/repos","events_url":"https://api.github.com/users/Ignasimg/events{/privacy}","received_events_url":"https://api.github.com/users/Ignasimg/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/77352650","html_url":"https://github.com/bcit-ci/CodeIgniter/issues/3627#issuecomment-77352650","issue_url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/3627","id":77352650,"node_id":"MDEyOklzc3VlQ29tbWVudDc3MzUyNjUw","user":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2015-03-05T12:02:42Z","updated_at":"2015-03-05T12:02:42Z","body":"> On the other side... either you or me didn't understand anything...\n> You say I found a timing flaw? What do you exactly mean by that? You mean the problem was that the lock would only be held for 5 seconds while an http timeout usually happens at 300 seconds?\n> Maybe that is part of the problem, but in my opinion, the real problem, (even though now with such a big TTL will probably never appear) is still there.\n\nWhat do you mean what do I mean? Request1's lock may timeout before the request is actually completed, allowing Request2 to \"take over\" - you explained this in your issue description. This is the _only_ problem and it no longer exists.\n\n> And finally you say allowing deathlocks would be a debugging nightmare... And you got a point, about the logout thing (even though it can be solved by ... ugly dirty and nasty solutions).\n> But since the problems that could lead to a deathlock (if we allowed them) would also lead to a 5 minutes deathlock in the current version... I ask you, isn't 5 minutes a debugging nightmare?\n\nA deadlock doesn't timeout after 5 minutes, it's unbreakable and therefore infinite - that's why it's called a deadlock. 5 minutes is a relatively long time to block a session, but still way better than holding it until the session expires.\n\n---\n\nAs much as I enjoy discussing in-depth technical problems, can we stop this now? No offense but you talk a little bit too much and I'm trying very hard to prevent the issue tracker from turning into a forum board. :)\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/bcit-ci/CodeIgniter/issues/comments/77352650/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"narfbg","id":1058011,"node_id":"MDQ6VXNlcjEwNTgwMTE=","avatar_url":"https://avatars.githubusercontent.com/u/1058011?v=4","gravatar_id":"","url":"https://api.github.com/users/narfbg","html_url":"https://github.com/narfbg","followers_url":"https://api.github.com/users/narfbg/followers","following_url":"https://api.github.com/users/narfbg/following{/other_user}","gists_url":"https://api.github.com/users/narfbg/gists{/gist_id}","starred_url":"https://api.github.com/users/narfbg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/narfbg/subscriptions","organizations_url":"https://api.github.com/users/narfbg/orgs","repos_url":"https://api.github.com/users/narfbg/repos","events_url":"https://api.github.com/users/narfbg/events{/privacy}","received_events_url":"https://api.github.com/users/narfbg/received_events","type":"User","user_view_type":"public","site_admin":false}}]