diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/PartsFactory.java b/src/main/java/smartrics/rest/fitnesse/fixture/PartsFactory.java
index e46f1bd..6ff3b49 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/PartsFactory.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/PartsFactory.java
@@ -46,8 +46,8 @@ public class PartsFactory {
 	
 	private final BodyTypeAdapterFactory bodyTypeAdapterFactory;
 	
-	public PartsFactory(final RunnerVariablesProvider variablesProvider) {
-		this.bodyTypeAdapterFactory = new BodyTypeAdapterFactory(variablesProvider);
+	public PartsFactory(final RunnerVariablesProvider variablesProvider, Config config) {
+		this.bodyTypeAdapterFactory = new BodyTypeAdapterFactory(variablesProvider, config);
 	}
 	
     /**
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/RestFixture.java b/src/main/java/smartrics/rest/fitnesse/fixture/RestFixture.java
index 923cb5f..ab93f36 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/RestFixture.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/RestFixture.java
@@ -156,7 +156,7 @@ import java.util.Vector;
  * </tr>
  * <tr>
  * <td>restfixture.content.handlers.map</td>
- * <td><i>a map of contenty type to type adapters, entries separated by \n, and
+ * <td><i>a map of content type to type adapters, entries separated by \n, and
  * kye-value separated by '='. Available type adapters are JS, TEXT, JSON, XML
  * (see {@link smartrics.rest.fitnesse.fixture.support.BodyTypeAdapterFactory}
  * ).</i></td>
@@ -171,6 +171,14 @@ import java.util.Vector;
  * set for this config key. This value can also be the empty string to replace
  * null with empty.</i></td>
  * </tr>
+ * <tr>
+ * <td>restfixture.javascript.imports.map</td>
+ * <td><i>a map of name to Url/File path. Each entry refers to a url/path to a javascript file that is imported in the
+ * JS context and available for evaluation. Files are checked for existence and access. If not available/not accessible,
+ * an exception is thrown. Urls are tried to be downloaded. A failure in accessing the content causes an error/exception.
+ * The map key is the name of the library - it can be a freeform string that appears in logs for debugging purposes.
+ * </i></td>
+ * </tr>
  *
  * </table>
  *
@@ -282,7 +290,7 @@ public class RestFixture implements StatementExecutorConsumer, RunnerVariablesPr
 	 */
 	public RestFixture() {
 		super();
-		this.partsFactory = new PartsFactory(this);
+		this.partsFactory = new PartsFactory(this, Config.getConfig(Config.DEFAULT_CONFIG_NAME));
 		this.displayActualOnRight = true;
 		this.minLenForCollapseToggle = -1;
 		this.resourceUrisAreEscaped = false;
@@ -313,19 +321,20 @@ public class RestFixture implements StatementExecutorConsumer, RunnerVariablesPr
 		this.minLenForCollapseToggle = -1;
 		this.resourceUrisAreEscaped = false;
 		this.displayAbsoluteURLInFull = true;
-		this.partsFactory = new PartsFactory(this);
 		this.config = Config.getConfig(configName);
+        this.partsFactory = new PartsFactory(this, config);
 		this.baseUrl = new Url(stripTag(hostName));
         this.requestHeaders = new LinkedHashMap<String,String>();
 	}
 
 	/**
+     * VisibleForTesting
 	 * @param partsFactory
 	 *            the factory of parts necessary to create the rest fixture
 	 * @param hostName
 	 * @param configName
 	 */
-	public RestFixture(PartsFactory partsFactory, String hostName, String configName) {
+    RestFixture(PartsFactory partsFactory, String hostName, String configName) {
 		this.displayActualOnRight = true;
 		this.minLenForCollapseToggle = -1;
 		this.resourceUrisAreEscaped = false;
@@ -809,7 +818,7 @@ public class RestFixture implements StatementExecutorConsumer, RunnerVariablesPr
 			if (letHandler != null) {
 				StringTypeAdapter adapter = new StringTypeAdapter();
 				try {
-					sValue = letHandler.handle(this, getLastResponse(), namespaceContext, expr);
+					sValue = letHandler.handle(this, config, getLastResponse(), namespaceContext, expr);
 					exprCell.body(getFormatter().gray(exprCell.body()));
 				} catch (RuntimeException e) {
 					getFormatter().exception(exprCell, e.getMessage());
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/BodyTypeAdapterFactory.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/BodyTypeAdapterFactory.java
index 4c2dea1..ada0b56 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/BodyTypeAdapterFactory.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/BodyTypeAdapterFactory.java
@@ -36,16 +36,17 @@ import smartrics.rest.fitnesse.fixture.RunnerVariablesProvider;
 public class BodyTypeAdapterFactory {
 
 	private final RunnerVariablesProvider variablesProvider;
-	
-	private Map<ContentType, BodyTypeAdapterCreator> contentTypeToBodyTypeAdapter =
-		new HashMap<ContentType, BodyTypeAdapterCreator>();
+    private final Config config;
+
+    private Map<ContentType, BodyTypeAdapterCreator> contentTypeToBodyTypeAdapter = new HashMap<ContentType, BodyTypeAdapterCreator>();
     {
     	BodyTypeAdapterCreator jsonBodyTypeAdapterCreator = new BodyTypeAdapterCreator() {
 			@Override
 			public BodyTypeAdapter createBodyTypeAdapter() {
-				return new JSONBodyTypeAdapter(variablesProvider);
+				return new JSONBodyTypeAdapter(variablesProvider, config);
 			}
 		};
+
         contentTypeToBodyTypeAdapter.put(ContentType.JS, jsonBodyTypeAdapterCreator);
         contentTypeToBodyTypeAdapter.put(ContentType.JSON, jsonBodyTypeAdapterCreator);
         contentTypeToBodyTypeAdapter.put(ContentType.XML, new BodyTypeAdapterCreator() {
@@ -62,8 +63,9 @@ public class BodyTypeAdapterFactory {
         });;
     }
 
-	public BodyTypeAdapterFactory(final RunnerVariablesProvider variablesProvider) {
+	public BodyTypeAdapterFactory(final RunnerVariablesProvider variablesProvider, Config config) {
 		this.variablesProvider = variablesProvider;
+        this.config = config;
 	}
 	
     /**
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/Config.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/Config.java
index 14bb5c4..20133b3 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/Config.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/Config.java
@@ -205,9 +205,12 @@ public final class Config {
 	 * @return a map representing the key value.
 	 */
 	public Map<String, String> getAsMap(String key, Map<String, String> def) {
+		Map<String, String> returnMap = new HashMap<String, String>(def);
 		String val = get(key);
 		try {
-			return Tools.convertStringToMap(val, "\n", "=", true);
+			Map<String, String> result = Tools.convertStringToMap(val, "=", "\n", true);
+			returnMap.putAll(result);
+			return returnMap;
 		} catch (RuntimeException e) {
 			return def;
 		}
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/FitVariables.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/FitVariables.java
index 99d12c4..782736a 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/FitVariables.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/FitVariables.java
@@ -31,7 +31,7 @@ public class FitVariables extends Variables {
 
 	/**
 	 * initialises variables with default config. See @link
-	 * {@link #Variables(Config)}
+	 * {@link #FitVariables(Config)}
 	 */
 	public FitVariables() {
 		super();
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/JSONBodyTypeAdapter.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/JSONBodyTypeAdapter.java
index 8ce3162..c5fc012 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/JSONBodyTypeAdapter.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/JSONBodyTypeAdapter.java
@@ -20,26 +20,30 @@
  */
 package smartrics.rest.fitnesse.fixture.support;
 
-import java.util.List;
-
 import smartrics.rest.fitnesse.fixture.RunnerVariablesProvider;
 
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
 /**
  * Type adapted for cells containing JSON content.
- * 
+ *
  * @author smartrics
- * 
  */
 public class JSONBodyTypeAdapter extends XPathBodyTypeAdapter {
-    private boolean forceJsEvaluation = false;
+    private final Map<String, String> imports;
     private final JavascriptWrapper wrapper;
+    private boolean forceJsEvaluation = false;
 
     /**
      * def ctor
-     * @param variablesProvider 
+     *
+     * @param variablesProvider
      */
-    public JSONBodyTypeAdapter(RunnerVariablesProvider variablesProvider) {
-    	 wrapper = new JavascriptWrapper(variablesProvider);
+    public JSONBodyTypeAdapter(RunnerVariablesProvider variablesProvider, Config config) {
+        wrapper = new JavascriptWrapper(variablesProvider);
+        imports = config.getAsMap("restfixture.javascript.imports.map", new HashMap<String, String>());
     }
 
     @Override
@@ -48,7 +52,7 @@ public class JSONBodyTypeAdapter extends XPathBodyTypeAdapter {
         if (!forceJsEvaluation && Tools.isValidXPath(getContext(), expr) && !wrapper.looksLikeAJsExpression(expr)) {
             throw new IllegalArgumentException("XPath expectations in JSON content are not supported anymore. Please use JavaScript expressions.");
         }
-        Object exprResult = wrapper.evaluateExpression(json, expr);
+        Object exprResult = wrapper.evaluateExpression(json, expr, imports);
         if (exprResult == null) {
             return false;
         }
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/JavascriptException.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/JavascriptException.java
index 1f105e3..52d610a 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/JavascriptException.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/JavascriptException.java
@@ -36,4 +36,8 @@ public class JavascriptException extends RuntimeException {
     public JavascriptException(String message) {
         super(message);
     }
+
+    public JavascriptException(String message, Throwable t) {
+        super(message, t);
+    }
 }
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/JavascriptWrapper.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/JavascriptWrapper.java
index 3eff0e1..2b5d1ad 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/JavascriptWrapper.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/JavascriptWrapper.java
@@ -20,300 +20,346 @@
  */
 package smartrics.rest.fitnesse.fixture.support;
 
+import org.mozilla.javascript.*;
+import smartrics.rest.client.RestData.Header;
+import smartrics.rest.client.RestResponse;
+import smartrics.rest.fitnesse.fixture.RunnerVariablesProvider;
+
+import java.io.*;
 import java.lang.reflect.InvocationTargetException;
+import java.net.URL;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.EcmaError;
-import org.mozilla.javascript.EvaluatorException;
-import org.mozilla.javascript.Scriptable;
-import org.mozilla.javascript.ScriptableObject;
-
-import smartrics.rest.client.RestData.Header;
-import smartrics.rest.client.RestResponse;
-import smartrics.rest.fitnesse.fixture.RunnerVariablesProvider;
-
 /**
  * Wrapper class to all that related to JavaScript.
- * 
+ *
  * @author smartrics
- * 
  */
 public class JavascriptWrapper {
-	private static final long _64K = 65534;
-
-	/**
-	 * the name of the JS object containig the http response: {@code response}.
-	 */
-	public static final String RESPONSE_OBJ_NAME = "response";
-	/**
-	 * the name of the JS object containing the symbol table: {@code symbols}.
-	 */
-	public static final String SYMBOLS_OBJ_NAME = "symbols";
-	/**
-	 * the name of the JS object containing the json body: {@code jsonbody}.
-	 */
-	public static final String JSON_OBJ_NAME = "jsonbody";
-	
-	private RunnerVariablesProvider variablesProvider;
-
-	public JavascriptWrapper(RunnerVariablesProvider variablesProvider) {
-		this.variablesProvider = variablesProvider;
-	}
-	
-	/**
-	 * evaluates a Javascript expression in the given {@link RestResponse}.
-	 * 
-	 * @param response
-	 *            the {@link RestResponse}
-	 * @param expression
-	 *            the javascript expression
-	 * @return the result of the expression evaluation.
-	 */
-	public Object evaluateExpression(RestResponse response, String expression) {
-		if (expression == null) {
-			return null;
-		}
-		Context context = Context.enter();
-		removeOptimisationForLargeExpressions(expression, context);
-		ScriptableObject scope = context.initStandardObjects();
-		injectFitNesseSymbolMap(scope);
-		injectResponse(context, scope, response);
-		Object result = evaluateExpression(context, scope, expression);
-		return result;
-	}
-
-	/**
-	 * evaluates an expression on a given json object represented as string.
-	 * 
-	 * @param json
-	 *            the json object.
-	 * @param expression
-	 *            the expression.
-	 * @return the result of the evaluation
-	 */
-	public Object evaluateExpression(String json, String expression) {
-		if (json == null || expression == null) {
-			return null;
-		}
-		Context context = Context.enter();
-		ScriptableObject scope = context.initStandardObjects();
-		injectFitNesseSymbolMap(scope);
-		injectJson(context, scope, json);
-		Object result = evaluateExpression(context, scope, expression);
-		return result;
-	}
-
-	/**
-	 * @param json the potential json string. loosely checks if the input string contains {@link JavascriptWrapper#JSON_OBJ_NAME}.
-	 * @return whether it's actually a json object.
-	 */
-	public boolean looksLikeAJsExpression(String json) {
-		return json != null && json.contains(JSON_OBJ_NAME + ".");
-	}
-
-	private void injectFitNesseSymbolMap(ScriptableObject scope) {
-		Variables v = variablesProvider.createRunnerVariables();
-		Object wrappedVariables = Context.javaToJS(v, scope);
-		ScriptableObject.putProperty(scope, SYMBOLS_OBJ_NAME, wrappedVariables);
-	}
-
-	private void injectJson(Context cx, ScriptableObject scope, String json) {
-		evaluateExpression(cx, scope, "var " + JSON_OBJ_NAME + "=" + json);
-	}
-
-	private Object evaluateExpression(Context context, ScriptableObject scope,
-			String expression) {
-		try {
-			Object result = context.evaluateString(scope, expression, null, 1,
-					null);
-			return result;
-		} catch (EvaluatorException e) {
-			throw new JavascriptException(e.getMessage());
-		} catch (EcmaError e) {
-			throw new JavascriptException(e.getMessage());
-		}
-	}
-
-	private void injectResponse(Context cx, ScriptableObject scope,
-			RestResponse r) {
-		try {
-			ScriptableObject.defineClass(scope, JsResponse.class);
-			Scriptable response = null;
-			if (r == null) {
-				scope.put(RESPONSE_OBJ_NAME, scope, response);
-				return;
-			}
-			Object[] arg = new Object[1];
-			arg[0] = r;
-			response = cx.newObject(scope, "JsResponse", arg);
-			scope.put(RESPONSE_OBJ_NAME, scope, response);
-			putPropertyOnJsObject(response, "body", r.getBody());
-			putPropertyOnJsObject(response, JSON_OBJ_NAME, null);
-			boolean isJson = isJsonResponse(r);
-			if (isJson) {
-				evaluateExpression(cx, scope, RESPONSE_OBJ_NAME + "."
-						+ JSON_OBJ_NAME + "=" + r.getBody());
-			}
-			putPropertyOnJsObject(response, "resource", r.getResource());
-			putPropertyOnJsObject(response, "statusText", r.getStatusText());
-			putPropertyOnJsObject(response, "statusCode", r.getStatusCode());
-			putPropertyOnJsObject(response, "transactionId",
-					r.getTransactionId());
-			for (Header h : r.getHeaders()) {
-				callMethodOnJsObject(response, "addHeader", h.getName(),
-						h.getValue());
-			}
-		} catch (IllegalAccessException e) {
-			throw new JavascriptException(e.getMessage());
-		} catch (InstantiationException e) {
-			throw new JavascriptException(e.getMessage());
-		} catch (InvocationTargetException e) {
-			throw new JavascriptException(e.getMessage());
-		}
-	}
-
-	private void callMethodOnJsObject(Scriptable o, String mName, Object... arg) {
-		ScriptableObject.callMethod(o, mName, arg);
-	}
-
-	private void putPropertyOnJsObject(Scriptable o, String mName, Object value) {
-		ScriptableObject.putProperty(o, mName, value);
-	}
-
-	private boolean isJsonResponse(RestResponse r) {
-		if (ContentType.JSON.equals(ContentType.parse(r.getContentType()))) {
-			return true;
-		}
-		if (r.getBody() != null && r.getBody().trim().matches("\\{.+\\}")) {
-			return Tools.isValidJson(r.getBody());
-		}
-		return false;
-	}
-
-	/**
-	 * Wrapper class for Response to be embedded in the Rhino Context.
-	 * 
-	 * @author smartrics
-	 * 
-	 */
-	public static class JsResponse extends ScriptableObject {
-		private static final long serialVersionUID = 5441026774653915695L;
-
-		private Map<String, List<String>> headers;
-
-		/**
-		 * def ctor.
-		 */
-		public JsResponse() {
-
-		}
-
-		/**
-		 * initialises internal headers map.
-		 */
-		public void jsConstructor() {
-			headers = new HashMap<String, List<String>>();
-		}
-
-		@Override
-		public String getClassName() {
-			return "JsResponse";
-		}
-
-		/**
-		 * 
-		 * @param name
-		 * @param value
-		 */
-		public void jsFunction_addHeader(String name, String value) {
-			List<String> vals = headers.get(name);
-			if (vals == null) {
-				vals = new ArrayList<String>();
-				headers.put(name, vals);
-			}
-			vals.add(value);
-		}
-
-		/**
-		 * 
-		 * @param name
-		 * @param value
-		 */
-		public void jsFunction_putHeader(String name, String value) {
-			List<String> vals = new ArrayList<String>();
-			vals.add(value);
-			headers.put(name, vals);
-		}
-
-		/**
-		 * 
-		 * @param name
-		 * @return the headers list size
-		 */
-		public int jsFunction_headerListSize(String name) {
-			List<String> vals = headers.get(name);
-			if (vals == null || vals.size() == 0) {
-				return 0;
-			}
-			return vals.size();
-		}
-
-		/**
-		 * 
-		 * @return the total number of headers in the response.
-		 */
-		public int jsFunction_headersSize() {
-			int sz = 0;
-			for (List<String> hList : headers.values()) {
-				sz += hList.size();
-			}
-			return sz;
-		}
-
-		/**
-		 * @param name
-		 * @return the value of the header name in position 0
-		 */
-		public String jsFunction_header0(String name) {
-			return jsFunction_header(name, 0);
-		}
-
-		/**
-		 * @param name
-		 * @return all headers with the given name
-		 */
-		public List<String> jsFunction_headers(String name) {
-			int sz = jsFunction_headerListSize(name);
-			if (sz > 0) {
-				return headers.get(name);
-			} else {
-				return new ArrayList<String>();
-			}
-		}
-
-		/**
-		 * @param name
-		 * @param pos
-		 * @return the value of the header with name at pos 0
-		 */
-		public String jsFunction_header(String name, int pos) {
-			if (jsFunction_headerListSize(name) > 0) {
-				return headers.get(name).get(pos);
-			} else {
-				return null;
-			}
-		}
-
-	}
-
-	private void removeOptimisationForLargeExpressions(String expression, Context context) {
-		if(expression.getBytes().length > _64K) {
-			context.setOptimizationLevel(-1);
-		}
-	}
+
+    /**
+     * the name of the JS object containig the http response: {@code response}.
+     */
+    public static final String RESPONSE_OBJ_NAME = "response";
+    /**
+     * the name of the JS object containing the symbol table: {@code symbols}.
+     */
+    public static final String SYMBOLS_OBJ_NAME = "symbols";
+    /**
+     * the name of the JS object containing the json body: {@code jsonbody}.
+     */
+    public static final String JSON_OBJ_NAME = "jsonbody";
+    private static final long _64K = 65534;
+    private RunnerVariablesProvider variablesProvider;
+
+    public JavascriptWrapper(RunnerVariablesProvider variablesProvider) {
+        this.variablesProvider = variablesProvider;
+    }
+
+    /**
+     * evaluates a Javascript expression in the given {@link RestResponse}.
+     *
+     * @param response   the {@link RestResponse}
+     * @param expression the javascript expression
+     * @return the result of the expression evaluation.
+     */
+    public Object evaluateExpression(RestResponse response, String expression) {
+        return evaluateExpression(response, expression, new HashMap<String, String>());
+    }
+
+    public Object evaluateExpression(RestResponse response, String expression, Map<String, String> imports) {
+        if (expression == null) {
+            return null;
+        }
+        Context context = Context.enter();
+        removeOptimisationForLargeExpressions(expression, context);
+        ScriptableObject scope = context.initStandardObjects();
+        injectImports(context, scope, imports);
+        injectFitNesseSymbolMap(scope);
+        injectResponse(context, scope, response);
+        Object result = evaluateExpression(context, scope, expression);
+        return result;
+    }
+
+    /**
+     * evaluates an expression on a given json object represented as string.
+     *
+     * @param json       the json object.
+     * @param expression the expression.
+     * @return the result of the evaluation
+     */
+    public Object evaluateExpression(String json, String expression) {
+        return evaluateExpression(json, expression, new HashMap<String, String>());
+    }
+
+    public Object evaluateExpression(String json, String expression, Map<String, String> imports) {
+        if (json == null || expression == null) {
+            return null;
+        }
+        Context context = Context.enter();
+        ScriptableObject scope = context.initStandardObjects();
+        injectImports(context, scope, imports);
+        injectFitNesseSymbolMap(scope);
+        injectJson(context, scope, json);
+        Object result = evaluateExpression(context, scope, expression);
+        return result;
+    }
+
+    /**
+     * @param json the potential json string. loosely checks if the input string contains {@link JavascriptWrapper#JSON_OBJ_NAME}.
+     * @return whether it's actually a json object.
+     */
+    public boolean looksLikeAJsExpression(String json) {
+        return json != null && json.contains(JSON_OBJ_NAME + ".");
+    }
+
+    private void injectFitNesseSymbolMap(ScriptableObject scope) {
+        Variables v = variablesProvider.createRunnerVariables();
+        Object wrappedVariables = Context.javaToJS(v, scope);
+        ScriptableObject.putProperty(scope, SYMBOLS_OBJ_NAME, wrappedVariables);
+    }
+
+    private void injectJson(Context cx, ScriptableObject scope, String json) {
+        evaluateExpression(cx, scope, "var " + JSON_OBJ_NAME + "=" + json);
+    }
+
+    private Object evaluateExpression(Context context, ScriptableObject scope,
+                                      String expression) {
+        try {
+            Object result = context.evaluateString(scope, expression, null, 1,
+                    null);
+            return result;
+        } catch (EvaluatorException e) {
+            throw new JavascriptException(e.getMessage());
+        } catch (EcmaError e) {
+            throw new JavascriptException(e.getMessage());
+        }
+    }
+
+    private void injectResponse(Context cx, ScriptableObject scope,
+                                RestResponse r) {
+        try {
+            ScriptableObject.defineClass(scope, JsResponse.class);
+            Scriptable response = null;
+            if (r == null) {
+                scope.put(RESPONSE_OBJ_NAME, scope, response);
+                return;
+            }
+            Object[] arg = new Object[1];
+            arg[0] = r;
+            response = cx.newObject(scope, "JsResponse", arg);
+            scope.put(RESPONSE_OBJ_NAME, scope, response);
+            putPropertyOnJsObject(response, "body", r.getBody());
+            putPropertyOnJsObject(response, JSON_OBJ_NAME, null);
+            boolean isJson = isJsonResponse(r);
+            if (isJson) {
+                evaluateExpression(cx, scope, RESPONSE_OBJ_NAME + "."
+                        + JSON_OBJ_NAME + "=" + r.getBody());
+            }
+            putPropertyOnJsObject(response, "resource", r.getResource());
+            putPropertyOnJsObject(response, "statusText", r.getStatusText());
+            putPropertyOnJsObject(response, "statusCode", r.getStatusCode());
+            putPropertyOnJsObject(response, "transactionId", r.getTransactionId());
+            for (Header h : r.getHeaders()) {
+                callMethodOnJsObject(response, "addHeader", h.getName(), h.getValue());
+            }
+        } catch (IllegalAccessException e) {
+            throw new JavascriptException(e.getMessage());
+        } catch (InstantiationException e) {
+            throw new JavascriptException(e.getMessage());
+        } catch (InvocationTargetException e) {
+            throw new JavascriptException(e.getMessage());
+        }
+    }
+
+    private void callMethodOnJsObject(Scriptable o, String mName, Object... arg) {
+        ScriptableObject.callMethod(o, mName, arg);
+    }
+
+    private void putPropertyOnJsObject(Scriptable o, String mName, Object value) {
+        ScriptableObject.putProperty(o, mName, value);
+    }
+
+    private boolean isJsonResponse(RestResponse r) {
+        if (ContentType.JSON.equals(ContentType.parse(r.getContentType()))) {
+            return true;
+        }
+        if (r.getBody() != null && r.getBody().trim().matches("\\{.+\\}")) {
+            return Tools.isValidJson(r.getBody());
+        }
+        return false;
+    }
+
+    private void removeOptimisationForLargeExpressions(String expression, Context context) {
+        if (expression.getBytes().length > _64K) {
+            context.setOptimizationLevel(-1);
+        }
+    }
+
+    private void injectImports(Context context, ScriptableObject scope, Map<String, String> imports) {
+        for (Map.Entry<String, String> e : imports.entrySet()) {
+            injectImports(context, scope, e.getKey(), e.getValue());
+        }
+
+    }
+
+    private void injectImports(Context context, ScriptableObject scope, String name, String importUrl) {
+        InputStream is = null;
+        try {
+            is = parseImport(importUrl);
+            BufferedReader in = new BufferedReader(new InputStreamReader(is));
+            context.evaluateReader(scope, in, name, 1, null);
+        } catch (Exception e) {
+            throw new JavascriptException("Invalid url: " + importUrl + " for '" + name + "'", e);
+        } finally {
+            if(is != null) {
+                try {
+                    is.close();
+                } catch (IOException e) {
+                    // ignore
+                }
+            }
+        }
+
+    }
+
+    /**
+     * Wrapper class for Response to be embedded in the Rhino Context.
+     *
+     * @author smartrics
+     */
+    public static class JsResponse extends ScriptableObject {
+        private static final long serialVersionUID = 5441026774653915695L;
+
+        private Map<String, List<String>> headers;
+
+        /**
+         * def ctor.
+         */
+        public JsResponse() {
+
+        }
+
+        /**
+         * initialises internal headers map.
+         */
+        public void jsConstructor() {
+            headers = new HashMap<String, List<String>>();
+        }
+
+        @Override
+        public String getClassName() {
+            return "JsResponse";
+        }
+
+        /**
+         * @param name
+         * @param value
+         */
+        public void jsFunction_addHeader(String name, String value) {
+            List<String> vals = headers.get(name);
+            if (vals == null) {
+                vals = new ArrayList<String>();
+                headers.put(name, vals);
+            }
+            vals.add(value);
+        }
+
+        /**
+         * @param name
+         * @param value
+         */
+        public void jsFunction_putHeader(String name, String value) {
+            List<String> vals = new ArrayList<String>();
+            vals.add(value);
+            headers.put(name, vals);
+        }
+
+        /**
+         * @param name
+         * @return the headers list size
+         */
+        public int jsFunction_headerListSize(String name) {
+            List<String> vals = headers.get(name);
+            if (vals == null || vals.size() == 0) {
+                return 0;
+            }
+            return vals.size();
+        }
+
+        /**
+         * @return the total number of headers in the response.
+         */
+        public int jsFunction_headersSize() {
+            int sz = 0;
+            for (List<String> hList : headers.values()) {
+                sz += hList.size();
+            }
+            return sz;
+        }
+
+        /**
+         * @param name
+         * @return the value of the header name in position 0
+         */
+        public String jsFunction_header0(String name) {
+            return jsFunction_header(name, 0);
+        }
+
+        /**
+         * @param name
+         * @return all headers with the given name
+         */
+        public List<String> jsFunction_headers(String name) {
+            int sz = jsFunction_headerListSize(name);
+            if (sz > 0) {
+                return headers.get(name);
+            } else {
+                return new ArrayList<String>();
+            }
+        }
+
+        /**
+         * @param name
+         * @param pos
+         * @return the value of the header with name at pos 0
+         */
+        public String jsFunction_header(String name, int pos) {
+            if (jsFunction_headerListSize(name) > 0) {
+                return headers.get(name).get(pos);
+            } else {
+                return null;
+            }
+        }
+
+    }
+
+    private InputStream parseImport(String name) {
+        try {
+            return new URL(name).openStream();
+        } catch (Exception e1) {
+            File f = new File(name);
+            if (f.exists()) {
+                if(f.isFile() && f.canRead()) {
+                    try {
+                        return new FileInputStream(f);
+                    } catch (Exception e2) {
+                        throw new IllegalArgumentException("Invalid import file: " + name + ", path: " + f.getAbsolutePath());
+                    }
+                } else {
+                    throw new IllegalArgumentException("Import file not accessible: " + name + ", path: " + f.getAbsolutePath());
+                }
+            } else {
+                try {
+                    return Thread.currentThread().getContextClassLoader().getResource(name).openStream();
+                } catch (Exception e3) {
+                    throw new IllegalArgumentException("Import resource not valid: " + name);
+                }
+            }
+        }
+    }
 
 }
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyConstHandler.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyConstHandler.java
index 22db7d6..5e0d2a6 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyConstHandler.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyConstHandler.java
@@ -33,8 +33,7 @@ public class LetBodyConstHandler implements LetHandler {
 
 	
 	@Override
-	public String handle(RunnerVariablesProvider variablesProvider,
-			RestResponse response, Object expressionContext, String expression) {
+	public String handle(RunnerVariablesProvider variablesProvider, Config cOnfig, RestResponse response, Object expressionContext, String expression) {
 		return expression;
 	}
 	
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyHandler.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyHandler.java
index 3a82ade..a999b0e 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyHandler.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyHandler.java
@@ -38,15 +38,17 @@ import smartrics.rest.fitnesse.fixture.RunnerVariablesProvider;
  */
 public class LetBodyHandler implements LetHandler {
 
+    public LetBodyHandler() {
+    }
+
     @Override
-    public String handle(RunnerVariablesProvider variablesProvider,
-    		RestResponse response, Object expressionContext, String expression) {
+    public String handle(RunnerVariablesProvider variablesProvider,  Config config, RestResponse response, Object expressionContext, String expression) {
         @SuppressWarnings("unchecked")
         Map<String, String> namespaceContext = (Map<String, String>) expressionContext;
         String contentTypeString = response.getContentType();
         String charset = response.getCharset();
         ContentType contentType = ContentType.parse(contentTypeString);
-        BodyTypeAdapter bodyTypeAdapter = new BodyTypeAdapterFactory(variablesProvider)
+        BodyTypeAdapter bodyTypeAdapter = new BodyTypeAdapterFactory(variablesProvider, config)
         .getBodyTypeAdapter(contentType, charset);
         String body = bodyTypeAdapter.toXmlString(response.getBody());
         if (body == null) {
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyJsHandler.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyJsHandler.java
index 677a938..850ef12 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyJsHandler.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyJsHandler.java
@@ -20,23 +20,30 @@
  */
 package smartrics.rest.fitnesse.fixture.support;
 
+import org.slf4j.Logger;
 import smartrics.rest.client.RestResponse;
 import smartrics.rest.fitnesse.fixture.RunnerVariablesProvider;
 
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.slf4j.LoggerFactory.getLogger;
+
 /**
  * Handles let expressions on XML content, returning XML string rather than the
  * string with the content within the tags.
- * 
+ *
  * @author smartrics
- * 
  */
 public class LetBodyJsHandler implements LetHandler {
 
+    private static final Logger LOG = getLogger(LetBodyJsHandler.class);
+
     @Override
-    public String handle(RunnerVariablesProvider variablesProvider,
-    		RestResponse response, Object expressionContext, String expression) {
+    public String handle(RunnerVariablesProvider variablesProvider, Config config, RestResponse response, Object expressionContext, String expression) {
         JavascriptWrapper js = new JavascriptWrapper(variablesProvider);
-        Object result = js.evaluateExpression(response, expression);
+        final Map<String, String> urlMap = config.getAsMap("restfixture.javascript.imports.map", new HashMap<String, String>());
+        Object result = js.evaluateExpression(response, expression, urlMap);
         if (result == null) {
             return null;
         }
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyXmlHandler.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyXmlHandler.java
index f07c13e..92bc8b1 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyXmlHandler.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetBodyXmlHandler.java
@@ -37,8 +37,7 @@ import smartrics.rest.fitnesse.fixture.RunnerVariablesProvider;
 public class LetBodyXmlHandler implements LetHandler {
 
 	@Override
-	public String handle(RunnerVariablesProvider variablesProvider,
-			RestResponse response, Object expressionContext, String expression) {
+	public String handle(RunnerVariablesProvider variablesProvider, Config config, RestResponse response, Object expressionContext, String expression) {
         @SuppressWarnings("unchecked")
         Map<String, String> namespaceContext = (Map<String, String>) expressionContext;
         NodeList list = Tools.extractXPath(namespaceContext, expression, response.getBody());
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetHandler.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetHandler.java
index 0c628f2..587c8a3 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetHandler.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetHandler.java
@@ -42,7 +42,6 @@ public interface LetHandler {
 	 *            the expression
 	 * @return applies the expression to response within the given context.
 	 */
-	String handle(RunnerVariablesProvider variablesProvider,
-			RestResponse response, Object expressionContext, String expression);
+	String handle(RunnerVariablesProvider variablesProvider, Config config, RestResponse response, Object expressionContext, String expression);
 
 }
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetHeaderHandler.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetHeaderHandler.java
index 830aa3a..875398f 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/LetHeaderHandler.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/LetHeaderHandler.java
@@ -38,8 +38,7 @@ import smartrics.rest.fitnesse.fixture.RunnerVariablesProvider;
 public class LetHeaderHandler implements LetHandler {
 
 	@Override
-	public String handle(RunnerVariablesProvider variablesProvider,
-			RestResponse response, Object expressionContext, String expression) {
+	public String handle(RunnerVariablesProvider variablesProvider, Config config, RestResponse response, Object expressionContext, String expression) {
         List<String> content = new ArrayList<String>();
         if (response != null) {
             for (Header e : response.getHeaders()) {
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/Tools.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/Tools.java
index 8c19d20..eeb58b2 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/Tools.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/Tools.java
@@ -53,650 +53,613 @@ import java.util.regex.PatternSyntaxException;
 
 /**
  * Misc tool methods for string/xml/xpath manipulation.
- * 
+ *
  * @author smartrics
- * 
  */
 public final class Tools {
 
-	private Tools() {
-
-	}
-
-	/**
-	 * @param ns
-	 *            the name space
-	 * @param xpathExpression
-	 *            the expression
-	 * @param content
-	 *            the content
-	 * @return the list of nodes matching the supplied XPath.
-	 */
-	public static NodeList extractXPath(Map<String, String> ns,
-			String xpathExpression, String content) {
-		return (NodeList) extractXPath(ns, xpathExpression, content,
-				XPathConstants.NODESET, null);
-	}
-
-	/**
-	 * 
-	 * @param ns
-	 * @param xpathExpression
-	 * @param content
-	 * @param encoding
-	 * @return the list of nodes matching the supplied XPath.
-	 */
-	public static NodeList extractXPath(Map<String, String> ns,
-			String xpathExpression, String content, String encoding) {
-		return (NodeList) extractXPath(ns, xpathExpression, content,
-				XPathConstants.NODESET, encoding);
-	}
-
-	/**
-	 * @param xpathExpression
-	 * @param content
-	 * @param returnType
-	 * @return the list of nodes matching the supplied XPath.
-	 */
-	public static Object extractXPath(String xpathExpression, String content,
-			QName returnType) {
-		return extractXPath(xpathExpression, content, returnType, null);
-	}
-
-	/**
-	 * 
-	 * @param xpathExpression
-	 * @param content
-	 * @param returnType
-	 * @param encoding
-	 * @return the list of nodes mathching the supplied XPath.
-	 */
-	public static Object extractXPath(String xpathExpression, String content,
-			QName returnType, String encoding) {
-		// Use the java Xpath API to return a NodeList to the caller so they can
-		// iterate through
-		return extractXPath(new HashMap<String, String>(), xpathExpression,
-				content, returnType, encoding);
-	}
-
-	/**
-	 * 
-	 * @param ns
-	 * @param xpathExpression
-	 * @param content
-	 * @param returnType
-	 * @return the list of nodes mathching the supplied XPath.
-	 */
-	public static Object extractXPath(Map<String, String> ns,
-			String xpathExpression, String content, QName returnType) {
-		return extractXPath(ns, xpathExpression, content, returnType, null);
-	}
-
-	/**
-	 * extract the XPath from the content. the return value type is passed in
-	 * input using one of the {@link XPathConstants}. See also
-	 * {@link XPathExpression#evaluate(Object item, QName returnType)} ;
-	 * 
-	 * @param ns
-	 * @param xpathExpression
-	 * @param content
-	 * @param returnType
-	 * @param charset
-	 * @return the result
-	 */
-	public static Object extractXPath(Map<String, String> ns,
-			String xpathExpression, String content, QName returnType,
-			String charset) {
-		if (null == ns) {
-			ns = new HashMap<String, String>();
-		}
-		String ch = charset;
-		if (ch == null) {
-			ch = Charset.defaultCharset().name();
-		}
-		Document doc = toDocument(content, ch);
-		XPathExpression expr = toExpression(ns, xpathExpression);
-		try {
-			Object o = expr.evaluate(doc, returnType);
-			return o;
-		} catch (XPathExpressionException e) {
-			throw new IllegalArgumentException(
-					"xPath expression cannot be executed: " + xpathExpression);
-		}
-	}
-
-	/**
-	 * @param result
-	 * @return the serialised as xml result of an xpath expression evaluation
-	 */
-	public static String xPathResultToXmlString(Object result) {
-		if (result == null) {
-			return null;
-		}
-		try {
-			StringWriter sw = new StringWriter();
-			Transformer serializer = TransformerFactory.newInstance()
-					.newTransformer();
-			serializer.setOutputProperty(OutputKeys.INDENT, "yes");
-			serializer.setOutputProperty(OutputKeys.MEDIA_TYPE, "text/xml");
-			if (result instanceof NodeList) {
-				serializer.transform(
-						new DOMSource(((NodeList) result).item(0)),
-						new StreamResult(sw));
-			} else if (result instanceof Node) {
-				serializer.transform(new DOMSource((Node) result),
-						new StreamResult(sw));
-			} else {
-				return result.toString();
-			}
-			return sw.toString();
-		} catch (Exception e) {
-			throw new RuntimeException("Transformation caused an exception", e);
-		}
-	}
-
-	/**
-	 * @param ns
-	 * @param xpathExpression
-	 * @return true if the expression is valid
-	 */
-	public static boolean isValidXPath(Map<String, String> ns,
-			String xpathExpression) {
-		try {
-			toExpression(ns, xpathExpression);
-			return true;
-		} catch (IllegalArgumentException e) {
-			return false;
-		}
-	}
-
-	/**
-	 * @param ns
-	 * @param xpathExpression
-	 * @return the parsed string as {@link XPathExpression}
-	 */
-	public static XPathExpression toExpression(Map<String, String> ns,
-			String xpathExpression) {
-		try {
-			XPathFactory xpathFactory = XPathFactory.newInstance();
-			XPath xpath = xpathFactory.newXPath();
-			if (ns.size() > 0) {
-				xpath.setNamespaceContext(toNsContext(ns));
-			}
-			XPathExpression expr = xpath.compile(xpathExpression);
-			return expr;
-		} catch (XPathExpressionException e) {
-			throw new IllegalArgumentException(
-					"xPath expression can not be compiled: " + xpathExpression,
-					e);
-		}
-	}
-
-	private static NamespaceContext toNsContext(final Map<String, String> ns) {
-		NamespaceContext ctx = new NamespaceContext() {
-
-			@Override
-			public String getNamespaceURI(String prefix) {
-				String u = ns.get(prefix);
-				if (null == u) {
-					return XMLConstants.NULL_NS_URI;
-				}
-				return u;
-			}
-
-			@Override
-			public String getPrefix(String namespaceURI) {
-				for (String k : ns.keySet()) {
-					if (ns.get(k).equals(namespaceURI)) {
-						return k;
-					}
-				}
-				return null;
-			}
-
-			@Override
-			public Iterator<?> getPrefixes(String namespaceURI) {
-				return null;
-			}
-
-		};
-		return ctx;
-	}
-
-	private static Document toDocument(String content, String charset) {
-		String ch = charset;
-		if (ch == null) {
-			ch = Charset.defaultCharset().name();
-		}
-		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-		factory.setNamespaceAware(true);
-		try {
-			DocumentBuilder builder = factory.newDocumentBuilder();
-			Document doc = builder.parse(getInputStreamFromString(content, ch));
-			return doc;
-		} catch (ParserConfigurationException e) {
-			throw new IllegalArgumentException(
-					"parser for last response body caused an error", e);
-		} catch (SAXException e) {
-			throw new IllegalArgumentException(
-					"last response body cannot be parsed", e);
-		} catch (IOException e) {
-			throw new IllegalArgumentException(
-					"IO Exception when reading the document", e);
-		}
-	}
-
-	/**
-	 * this method uses @link {@link JSONObject} to parse the string and return
-	 * true if parse succeeds.
-	 * 
-	 * @param presumeblyJson
-	 *            string with some json (possibly).
-	 * @return true if json is valid
-	 */
-	public static boolean isValidJson(String presumeblyJson) {
-		Object o = null;
-		try {
-			o = new JSONObject(presumeblyJson);
-		} catch (JSONException e) {
-			return false;
-		}
-		return o != null;
-	}
-
-	/**
-	 * @param json
-	 *            the json string
-	 * @return the string as xml.
-	 */
-	public static String fromJSONtoXML(String json) {
-		HierarchicalStreamDriver driver = new JettisonMappedXmlDriver();
-		StringReader reader = new StringReader(json);
-		HierarchicalStreamReader hsr = driver.createReader(reader);
-		StringWriter writer = new StringWriter();
-		try {
-			new HierarchicalStreamCopier().copy(hsr, new PrettyPrintWriter(
-					writer));
-			return writer.toString();
-		} finally {
-			if (writer != null) {
-				try {
-					writer.close();
-				} catch (IOException e) {
-					// ignore
-				}
-			}
-		}
-	}
-
-	/**
-	 * Yet another stream 2 string function.
-	 * 
-	 * @param is
-	 *            the stream
-	 * @return the string.
-	 */
-	public static String getStringFromInputStream(InputStream is) {
-		return getStringFromInputStream(is, Charset.defaultCharset().name());
-	}
-
-	/**
-	 * Yet another stream 2 string function.
-	 * 
-	 * @param is
-	 *            the stream
-	 * @param encoding
-	 *            the encoding of the bytes in the stream
-	 * @return the string.
-	 */
-	public static String getStringFromInputStream(InputStream is,
-			String encoding) {
-		String line = null;
-		if (is == null) {
-			return "";
-		}
-		BufferedReader in = null;
-		try {
-			in = new BufferedReader(new InputStreamReader(is, encoding));
-		} catch (UnsupportedEncodingException e) {
-			throw new IllegalArgumentException("Unsupported encoding: "
-					+ encoding, e);
-		}
-		StringBuilder sb = new StringBuilder();
-		try {
-			while ((line = in.readLine()) != null) {
-				sb.append(line);
-			}
-		} catch (IOException e) {
-			throw new IllegalArgumentException("Unable to read from stream", e);
-		}
-		return sb.toString();
-	}
-
-	/**
-	 * Yet another stream 2 string function.
-	 * 
-	 * @param string
-	 *            the string
-	 * @param encoding
-	 *            the encoding of the bytes in the stream
-	 * @return the input stream.
-	 */
-	public static InputStream getInputStreamFromString(String string,
-			String encoding) {
-		if (string == null) {
-			throw new IllegalArgumentException("null input");
-		}
-		try {
-			byte[] byteArray = string.getBytes(encoding);
-			return new ByteArrayInputStream(byteArray);
-		} catch (UnsupportedEncodingException e) {
-			throw new IllegalArgumentException("Unsupported encoding: "
-					+ encoding);
-		}
-	}
-
-	/**
-	 * converts a map to string
-	 * 
-	 * @param map
-	 *            the map to convert
-	 * @param nvSep
-	 *            the nvp separator
-	 * @param entrySep
-	 *            the separator of each entry
-	 * @return the serialised map.
-	 */
-	public static String convertMapToString(Map<String, String> map,
-			String nvSep, String entrySep) {
-		StringBuffer sb = new StringBuffer();
-		if (map != null) {
-			for (Entry<String, String> entry : map.entrySet()) {
-				String el = entry.getKey();
-				sb.append(convertEntryToString(el, map.get(el), nvSep)).append(
-						entrySep);
-			}
-		}
-		String repr = sb.toString();
-		int pos = repr.lastIndexOf(entrySep);
-		return repr.substring(0, pos);
-	}
-
-	/**
-	 * @param name
-	 *            the name
-	 * @param value
-	 *            the value
-	 * @param nvSep
-	 *            the separator
-	 * @return the kvp as a string <code>&lt;name>&lt;sep>&lt;value></code>.
-	 */
-	public static String convertEntryToString(String name, String value, String nvSep) {
-		return String.format("%s%s%s", name, nvSep, value);
-	}
-
-	/**
-	 * @param text the text
-	 * @param expr the regex
-	 * @return true if regex matches text.
-	 */
-	public static boolean regex(String text, String expr) {
-		try {
-			Pattern p = Pattern.compile(expr);
-			boolean find = p.matcher(text).find();
-			return find;
-		} catch (PatternSyntaxException e) {
-			throw new IllegalArgumentException("Invalid regex " + expr);
-		}
-	}
-
-	/**
-	 * parses a map from a string.
-	 * 
-	 * @param expStr
-	 *            the string with the serialised map.
-	 * @param nvSep
-	 *            the separator for keys and values.
-	 * @param entrySep
-	 *            the separator for entries in the map.
-	 * @param cleanTags
-	 *            if true the value is cleaned from any present html tag.
-	 * @return the parsed map.
-	 */
-	public static Map<String, String> convertStringToMap(final String expStr,
-			final String nvSep, final String entrySep, boolean cleanTags) {
-		String sanitisedExpStr = expStr.trim();
-		sanitisedExpStr = removeOpenEscape(sanitisedExpStr);
-		sanitisedExpStr = removeCloseEscape(sanitisedExpStr);
-		sanitisedExpStr = sanitisedExpStr.trim();
-		String[] nvpArray = sanitisedExpStr.split(entrySep);
-		Map<String, String> ret = new HashMap<String, String>();
-		for (String nvp : nvpArray) {
-			try {
-				nvp = nvp.trim();
-				if ("".equals(nvp)) {
-					continue;
-				}
-				nvp = removeOpenEscape(nvp).trim();
-				nvp = removeCloseEscape(nvp).trim();
-				String[] nvpArr = nvp.split(nvSep);
-				String k, v;
-				k = nvpArr[0].trim();
-				v = "";
-				if (nvpArr.length == 2) {
-					v = nvpArr[1].trim();
-				} else if (nvpArr.length > 2) {
-					int pos = nvp.indexOf(nvSep) + nvSep.length();
-					v = nvp.substring(pos).trim();
-				}
-				if (cleanTags) {
-					ret.put(k, fromSimpleTag(v));
-				} else {
-					ret.put(k, v);
-				}
-			} catch (RuntimeException e) {
-				throw new IllegalArgumentException(
-						"Each entry in the must be separated by '"
-								+ entrySep
-								+ "' and each entry must be expressed as a name"
-								+ nvSep + "value");
-			}
-		}
-		return ret;
-	}
-
-	/**
-	 * @param message
-	 *            the message to be included in the collapsable section header.
-	 * @param content
-	 *            the content collapsed.
-	 * @return a string with the html/js code to implement a collapsable section
-	 *         in fitnesse.
-	 */
-	public static String makeToggleCollapseable(String message, String content) {
-		Random random = new Random();
-		String id = Integer.toString(content.hashCode())
-				+ Long.toString(random.nextLong());
-		StringBuffer sb = new StringBuffer();
-		sb.append("<div class='collapsible closed'>");
-		sb.append("<ul><li><a href='#' class='expandall'>Expand</a></li><li><a href='#' class='collapseall'>Collapse</a></li></ul>");
-		sb.append("<p class='title'>").append(message).append("</p>");
-		sb.append("<div>").append(content).append("</div>");
-		sb.append("</div>");
-		return sb.toString();
-	}
-
-	/**
-	 * Substitutions:
-	 * <table border="1">
-	 * <tr><td><code>&lt;pre></code> and <code>&lt;/pre></code></td><td><code>""</code></td></tr>
-	 * <tr><td><code>&lt;</code></td><td><code>&amp;lt;</code></td></tr>
-	 * <tr><td><code>\n</code></td><td><code>&lt;br /></code></td></tr>
-	 * <tr><td><code>&nbsp;</code> <i>(space)</i></td><td><code>&amp;nbsp;</code></td></tr>
-	 * <tr><td><code>-----</code> <i>(5 hyphens)</i></td><td><code>&lt;hr /></code></td></tr>
-	 * </table>
-	 * 
-	 * @param text
-	 *            some text.
-	 * @return the html.
-	 */
-	public static String toHtml(String text) {
+    private Tools() {
+
+    }
+
+    /**
+     * @param ns              the name space
+     * @param xpathExpression the expression
+     * @param content         the content
+     * @return the list of nodes matching the supplied XPath.
+     */
+    public static NodeList extractXPath(Map<String, String> ns,
+                                        String xpathExpression, String content) {
+        return (NodeList) extractXPath(ns, xpathExpression, content,
+                XPathConstants.NODESET, null);
+    }
+
+    /**
+     * @param ns
+     * @param xpathExpression
+     * @param content
+     * @param encoding
+     * @return the list of nodes matching the supplied XPath.
+     */
+    public static NodeList extractXPath(Map<String, String> ns,
+                                        String xpathExpression, String content, String encoding) {
+        return (NodeList) extractXPath(ns, xpathExpression, content,
+                XPathConstants.NODESET, encoding);
+    }
+
+    /**
+     * @param xpathExpression
+     * @param content
+     * @param returnType
+     * @return the list of nodes matching the supplied XPath.
+     */
+    public static Object extractXPath(String xpathExpression, String content,
+                                      QName returnType) {
+        return extractXPath(xpathExpression, content, returnType, null);
+    }
+
+    /**
+     * @param xpathExpression
+     * @param content
+     * @param returnType
+     * @param encoding
+     * @return the list of nodes mathching the supplied XPath.
+     */
+    public static Object extractXPath(String xpathExpression, String content,
+                                      QName returnType, String encoding) {
+        // Use the java Xpath API to return a NodeList to the caller so they can
+        // iterate through
+        return extractXPath(new HashMap<String, String>(), xpathExpression,
+                content, returnType, encoding);
+    }
+
+    /**
+     * @param ns
+     * @param xpathExpression
+     * @param content
+     * @param returnType
+     * @return the list of nodes mathching the supplied XPath.
+     */
+    public static Object extractXPath(Map<String, String> ns,
+                                      String xpathExpression, String content, QName returnType) {
+        return extractXPath(ns, xpathExpression, content, returnType, null);
+    }
+
+    /**
+     * extract the XPath from the content. the return value type is passed in
+     * input using one of the {@link XPathConstants}. See also
+     * {@link XPathExpression#evaluate(Object item, QName returnType)} ;
+     *
+     * @param ns
+     * @param xpathExpression
+     * @param content
+     * @param returnType
+     * @param charset
+     * @return the result
+     */
+    public static Object extractXPath(Map<String, String> ns,
+                                      String xpathExpression, String content, QName returnType,
+                                      String charset) {
+        if (null == ns) {
+            ns = new HashMap<String, String>();
+        }
+        String ch = charset;
+        if (ch == null) {
+            ch = Charset.defaultCharset().name();
+        }
+        Document doc = toDocument(content, ch);
+        XPathExpression expr = toExpression(ns, xpathExpression);
+        try {
+            Object o = expr.evaluate(doc, returnType);
+            return o;
+        } catch (XPathExpressionException e) {
+            throw new IllegalArgumentException(
+                    "xPath expression cannot be executed: " + xpathExpression);
+        }
+    }
+
+    /**
+     * @param result
+     * @return the serialised as xml result of an xpath expression evaluation
+     */
+    public static String xPathResultToXmlString(Object result) {
+        if (result == null) {
+            return null;
+        }
+        try {
+            StringWriter sw = new StringWriter();
+            Transformer serializer = TransformerFactory.newInstance()
+                    .newTransformer();
+            serializer.setOutputProperty(OutputKeys.INDENT, "yes");
+            serializer.setOutputProperty(OutputKeys.MEDIA_TYPE, "text/xml");
+            if (result instanceof NodeList) {
+                serializer.transform(
+                        new DOMSource(((NodeList) result).item(0)),
+                        new StreamResult(sw));
+            } else if (result instanceof Node) {
+                serializer.transform(new DOMSource((Node) result),
+                        new StreamResult(sw));
+            } else {
+                return result.toString();
+            }
+            return sw.toString();
+        } catch (Exception e) {
+            throw new RuntimeException("Transformation caused an exception", e);
+        }
+    }
+
+    /**
+     * @param ns
+     * @param xpathExpression
+     * @return true if the expression is valid
+     */
+    public static boolean isValidXPath(Map<String, String> ns,
+                                       String xpathExpression) {
+        try {
+            toExpression(ns, xpathExpression);
+            return true;
+        } catch (IllegalArgumentException e) {
+            return false;
+        }
+    }
+
+    /**
+     * @param ns
+     * @param xpathExpression
+     * @return the parsed string as {@link XPathExpression}
+     */
+    public static XPathExpression toExpression(Map<String, String> ns,
+                                               String xpathExpression) {
+        try {
+            XPathFactory xpathFactory = XPathFactory.newInstance();
+            XPath xpath = xpathFactory.newXPath();
+            if (ns.size() > 0) {
+                xpath.setNamespaceContext(toNsContext(ns));
+            }
+            XPathExpression expr = xpath.compile(xpathExpression);
+            return expr;
+        } catch (XPathExpressionException e) {
+            throw new IllegalArgumentException(
+                    "xPath expression can not be compiled: " + xpathExpression,
+                    e);
+        }
+    }
+
+    private static NamespaceContext toNsContext(final Map<String, String> ns) {
+        NamespaceContext ctx = new NamespaceContext() {
+
+            @Override
+            public String getNamespaceURI(String prefix) {
+                String u = ns.get(prefix);
+                if (null == u) {
+                    return XMLConstants.NULL_NS_URI;
+                }
+                return u;
+            }
+
+            @Override
+            public String getPrefix(String namespaceURI) {
+                for (String k : ns.keySet()) {
+                    if (ns.get(k).equals(namespaceURI)) {
+                        return k;
+                    }
+                }
+                return null;
+            }
+
+            @Override
+            public Iterator<?> getPrefixes(String namespaceURI) {
+                return null;
+            }
+
+        };
+        return ctx;
+    }
+
+    private static Document toDocument(String content, String charset) {
+        String ch = charset;
+        if (ch == null) {
+            ch = Charset.defaultCharset().name();
+        }
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        factory.setNamespaceAware(true);
+        try {
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document doc = builder.parse(getInputStreamFromString(content, ch));
+            return doc;
+        } catch (ParserConfigurationException e) {
+            throw new IllegalArgumentException(
+                    "parser for last response body caused an error", e);
+        } catch (SAXException e) {
+            throw new IllegalArgumentException(
+                    "last response body cannot be parsed", e);
+        } catch (IOException e) {
+            throw new IllegalArgumentException(
+                    "IO Exception when reading the document", e);
+        }
+    }
+
+    /**
+     * this method uses @link {@link JSONObject} to parse the string and return
+     * true if parse succeeds.
+     *
+     * @param presumeblyJson string with some json (possibly).
+     * @return true if json is valid
+     */
+    public static boolean isValidJson(String presumeblyJson) {
+        Object o = null;
+        try {
+            o = new JSONObject(presumeblyJson);
+        } catch (JSONException e) {
+            return false;
+        }
+        return o != null;
+    }
+
+    /**
+     * @param json the json string
+     * @return the string as xml.
+     */
+    public static String fromJSONtoXML(String json) {
+        HierarchicalStreamDriver driver = new JettisonMappedXmlDriver();
+        StringReader reader = new StringReader(json);
+        HierarchicalStreamReader hsr = driver.createReader(reader);
+        StringWriter writer = new StringWriter();
+        try {
+            new HierarchicalStreamCopier().copy(hsr, new PrettyPrintWriter(
+                    writer));
+            return writer.toString();
+        } finally {
+            if (writer != null) {
+                try {
+                    writer.close();
+                } catch (IOException e) {
+                    // ignore
+                }
+            }
+        }
+    }
+
+    /**
+     * Yet another stream 2 string function.
+     *
+     * @param is the stream
+     * @return the string.
+     */
+    public static String getStringFromInputStream(InputStream is) {
+        return getStringFromInputStream(is, Charset.defaultCharset().name());
+    }
+
+    /**
+     * Yet another stream 2 string function.
+     *
+     * @param is       the stream
+     * @param encoding the encoding of the bytes in the stream
+     * @return the string.
+     */
+    public static String getStringFromInputStream(InputStream is,
+                                                  String encoding) {
+        String line = null;
+        if (is == null) {
+            return "";
+        }
+        BufferedReader in = null;
+        try {
+            in = new BufferedReader(new InputStreamReader(is, encoding));
+        } catch (UnsupportedEncodingException e) {
+            throw new IllegalArgumentException("Unsupported encoding: "
+                    + encoding, e);
+        }
+        StringBuilder sb = new StringBuilder();
+        try {
+            while ((line = in.readLine()) != null) {
+                sb.append(line);
+            }
+        } catch (IOException e) {
+            throw new IllegalArgumentException("Unable to read from stream", e);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Yet another stream 2 string function.
+     *
+     * @param string   the string
+     * @param encoding the encoding of the bytes in the stream
+     * @return the input stream.
+     */
+    public static InputStream getInputStreamFromString(String string,
+                                                       String encoding) {
+        if (string == null) {
+            throw new IllegalArgumentException("null input");
+        }
+        try {
+            byte[] byteArray = string.getBytes(encoding);
+            return new ByteArrayInputStream(byteArray);
+        } catch (UnsupportedEncodingException e) {
+            throw new IllegalArgumentException("Unsupported encoding: "
+                    + encoding);
+        }
+    }
+
+    /**
+     * converts a map to string
+     *
+     * @param map      the map to convert
+     * @param nvSep    the nvp separator
+     * @param entrySep the separator of each entry
+     * @return the serialised map.
+     */
+    public static String convertMapToString(Map<String, String> map,
+                                            String nvSep, String entrySep) {
+        StringBuffer sb = new StringBuffer();
+        if (map != null) {
+            for (Entry<String, String> entry : map.entrySet()) {
+                String el = entry.getKey();
+                sb.append(convertEntryToString(el, map.get(el), nvSep)).append(
+                        entrySep);
+            }
+        }
+        String repr = sb.toString();
+        int pos = repr.lastIndexOf(entrySep);
+        return repr.substring(0, pos);
+    }
+
+    /**
+     * @param name  the name
+     * @param value the value
+     * @param nvSep the separator
+     * @return the kvp as a string <code>&lt;name>&lt;sep>&lt;value></code>.
+     */
+    public static String convertEntryToString(String name, String value, String nvSep) {
+        return String.format("%s%s%s", name, nvSep, value);
+    }
+
+    /**
+     * @param text the text
+     * @param expr the regex
+     * @return true if regex matches text.
+     */
+    public static boolean regex(String text, String expr) {
+        try {
+            Pattern p = Pattern.compile(expr);
+            boolean find = p.matcher(text).find();
+            return find;
+        } catch (PatternSyntaxException e) {
+            throw new IllegalArgumentException("Invalid regex " + expr);
+        }
+    }
+
+    /**
+     * parses a map from a string.
+     *
+     * @param expStr    the string with the serialised map.
+     * @param nvSep     the separator for keys and values.
+     * @param entrySep  the separator for entries in the map.
+     * @param cleanTags if true the value is cleaned from any present html tag.
+     * @return the parsed map.
+     */
+    public static Map<String, String> convertStringToMap(final String expStr,
+                                                         final String nvSep, final String entrySep, boolean cleanTags) {
+        String sanitisedExpStr = expStr.trim();
+        sanitisedExpStr = removeOpenEscape(sanitisedExpStr);
+        sanitisedExpStr = removeCloseEscape(sanitisedExpStr);
+        sanitisedExpStr = sanitisedExpStr.trim();
+        String[] nvpArray = sanitisedExpStr.split(entrySep);
+        Map<String, String> ret = new HashMap<String, String>();
+        for (String nvp : nvpArray) {
+            try {
+                nvp = nvp.trim();
+                if ("".equals(nvp)) {
+                    continue;
+                }
+                nvp = removeOpenEscape(nvp).trim();
+                nvp = removeCloseEscape(nvp).trim();
+                String[] nvpArr = nvp.split(nvSep);
+                String k, v;
+                k = nvpArr[0].trim();
+                v = "";
+                if (nvpArr.length == 2) {
+                    v = nvpArr[1].trim();
+                } else if (nvpArr.length > 2) {
+                    int pos = nvp.indexOf(nvSep) + nvSep.length();
+                    v = nvp.substring(pos).trim();
+                }
+                if (cleanTags) {
+                    ret.put(k, fromSimpleTag(v));
+                } else {
+                    ret.put(k, v);
+                }
+            } catch (RuntimeException e) {
+                throw new IllegalArgumentException(
+                        "Each entry in the must be separated by '"
+                                + entrySep
+                                + "' and each entry must be expressed as a name"
+                                + nvSep + "value");
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * @param message the message to be included in the collapsable section header.
+     * @param content the content collapsed.
+     * @return a string with the html/js code to implement a collapsable section
+     * in fitnesse.
+     */
+    public static String makeToggleCollapseable(String message, String content) {
+        Random random = new Random();
+        String id = Integer.toString(content.hashCode())
+                + Long.toString(random.nextLong());
+        StringBuffer sb = new StringBuffer();
+        sb.append("<div class='collapsible closed'>");
+        sb.append("<ul><li><a href='#' class='expandall'>Expand</a></li><li><a href='#' class='collapseall'>Collapse</a></li></ul>");
+        sb.append("<p class='title'>").append(message).append("</p>");
+        sb.append("<div>").append(content).append("</div>");
+        sb.append("</div>");
+        return sb.toString();
+    }
+
+    /**
+     * Substitutions:
+     * <table border="1">
+     * <tr><td><code>&lt;pre></code> and <code>&lt;/pre></code></td><td><code>""</code></td></tr>
+     * <tr><td><code>&lt;</code></td><td><code>&amp;lt;</code></td></tr>
+     * <tr><td><code>\n</code></td><td><code>&lt;br /></code></td></tr>
+     * <tr><td><code>&nbsp;</code> <i>(space)</i></td><td><code>&amp;nbsp;</code></td></tr>
+     * <tr><td><code>-----</code> <i>(5 hyphens)</i></td><td><code>&lt;hr /></code></td></tr>
+     * </table>
+     *
+     * @param text some text.
+     * @return the html.
+     */
+    public static String toHtml(String text) {
         return text.replaceAll("<pre>", "").replaceAll("</pre>", "")
                 .replaceAll("<", "&lt;").replaceAll(">", "&gt;")
                 .replaceAll("\n", "<br/>").replaceAll("\t", "    ")
                 .replaceAll(" ", "&nbsp;").replaceAll("-----", "<hr/>");
-	}
-
-	/**
-	 * @param c
-	 *            some text
-	 * @return the text within <code>&lt;code></code> tags.
-	 */
-	public static String toCode(String c) {
-		return "<code>" + c + "</code>";
-	}
-
-	/**
-	 * @param somethingWithinATag
-	 *            some text enclosed in some html tag.
-	 * @return the text within the tag.
-	 */ 
-	public static String fromSimpleTag(String somethingWithinATag) {
-		return somethingWithinATag.replaceAll("<[^>]+>", "").replace(
-				"</[^>]+>", "");
-	}
-
-	/**
-	 * @param text some html
-	 * @return the text stripped out of all tags.
-	 * 
-	 */
-	public static String fromHtml(String text) {
-		String ls = "\n";
-		return text.replaceAll("<br[\\s]*/>", ls).replaceAll("<BR[\\s]*/>", ls)
-				.replaceAll("<span[^>]*>", "").replaceAll("</span>", "")
-				.replaceAll("<pre>", "").replaceAll("</pre>", "")
-				.replaceAll("&nbsp;", " ").replaceAll("&gt;", ">")
-				.replaceAll("&amp;", "&").replaceAll("&lt;", "<")
-				.replaceAll("&nbsp;", " ");
-	}
-
-	/**
-	 * @param string a string
-	 * @return the string htmlified as a fitnesse label.
-	 */
-	public static String toHtmlLabel(String string) {
+    }
+
+    /**
+     * @param c some text
+     * @return the text within <code>&lt;code></code> tags.
+     */
+    public static String toCode(String c) {
+        return "<code>" + c + "</code>";
+    }
+
+    /**
+     * @param somethingWithinATag some text enclosed in some html tag.
+     * @return the text within the tag.
+     */
+    public static String fromSimpleTag(String somethingWithinATag) {
+        return somethingWithinATag.replaceAll("<[^>]+>", "").replace(
+                "</[^>]+>", "");
+    }
+
+    /**
+     * @param text some html
+     * @return the text stripped out of all tags.
+     */
+    public static String fromHtml(String text) {
+        String ls = "\n";
+        return text.replaceAll("<br[\\s]*/>", ls).replaceAll("<BR[\\s]*/>", ls)
+                .replaceAll("<span[^>]*>", "").replaceAll("</span>", "")
+                .replaceAll("<pre>", "").replaceAll("</pre>", "")
+                .replaceAll("&nbsp;", " ").replaceAll("&gt;", ">")
+                .replaceAll("&amp;", "&").replaceAll("&lt;", "<")
+                .replaceAll("&nbsp;", " ");
+    }
+
+    /**
+     * @param string a string
+     * @return the string htmlified as a fitnesse label.
+     */
+    public static String toHtmlLabel(String string) {
         return "<i><span class='fit_label'>" + string + "</span></i>";
-	}
-
-	/**
-	 * @param href
-	 *            a string ending up in the anchor href.
-	 * @param text
-	 *            a string within anchors.
-	 * @return the string htmlified as a html link.
-	 */
-	public static String toHtmlLink(String href, String text) {
+    }
+
+    /**
+     * @param href a string ending up in the anchor href.
+     * @param text a string within anchors.
+     * @return the string htmlified as a html link.
+     */
+    public static String toHtmlLink(String href, String text) {
         return "<a href='" + href + "'>" + text + "</a>";
-	}
-
-	/**
-	 * @param expected
-	 *            the expected value
-	 * @param typeAdapter
-	 *            the body adapter for the cell
-	 * @param formatter
-	 *            the formatter
-	 * @param minLenForToggle
-	 *            the value determining whether the content should be rendered
-	 *            as a collapseable section.
-	 * @return the formatted content for a cell with a wrong expectation
-	 */
-	public static String makeContentForWrongCell(String expected,
-			RestDataTypeAdapter typeAdapter, CellFormatter<?> formatter,
-			int minLenForToggle) {
-		StringBuffer sb = new StringBuffer();
-		sb.append(Tools.toHtml(expected));
-		if (formatter.isDisplayActual()) {
-			sb.append(toHtml("\n"));
-			sb.append(formatter.label("expected"));
-			String actual = typeAdapter.toString();
-			sb.append(toHtml("-----"));
-			sb.append(toHtml("\n"));
-			if (minLenForToggle >= 0 && actual.length() > minLenForToggle) {
-				sb.append(makeToggleCollapseable("toggle actual", toHtml(actual)));
-			} else {
-				sb.append(toHtml(actual));
-			}
-			sb.append(toHtml("\n"));
-			sb.append(formatter.label("actual"));
-		}
-		List<String> errors = typeAdapter.getErrors();
-		if (errors.size() > 0) {
-			sb.append(toHtml("-----"));
-			sb.append(toHtml("\n"));
-			for (String e : errors) {
-				sb.append(toHtml(e + "\n"));
-			}
-			sb.append(toHtml("\n"));
-			sb.append(formatter.label("errors"));
-		}
-		return sb.toString();
-	}
-
-	/**
-	 * @param expected the expected value
-	 * @param typeAdapter the body type adaptor
-	 * @param formatter the formatter
-	 *            the value determining whether the content should be rendered
-	 *            as a collapseable section.
-	 * @param minLenForToggle 
-	 *            the value determining whether the content should be rendered
-	 *            as a collapseable section.
-	 * @return the formatted content for a cell with a right expectation
-	 */
-	public static String makeContentForRightCell(String expected,
-			RestDataTypeAdapter typeAdapter, CellFormatter<?> formatter,
-			int minLenForToggle) {
-		StringBuffer sb = new StringBuffer();
-		sb.append(toHtml(expected));
-		String actual = typeAdapter.toString();
+    }
+
+    /**
+     * @param expected        the expected value
+     * @param typeAdapter     the body adapter for the cell
+     * @param formatter       the formatter
+     * @param minLenForToggle the value determining whether the content should be rendered
+     *                        as a collapseable section.
+     * @return the formatted content for a cell with a wrong expectation
+     */
+    public static String makeContentForWrongCell(String expected,
+                                                 RestDataTypeAdapter typeAdapter, CellFormatter<?> formatter,
+                                                 int minLenForToggle) {
+        StringBuffer sb = new StringBuffer();
+        sb.append(Tools.toHtml(expected));
+        if (formatter.isDisplayActual()) {
+            sb.append(toHtml("\n"));
+            sb.append(formatter.label("expected"));
+            String actual = typeAdapter.toString();
+            sb.append(toHtml("-----"));
+            sb.append(toHtml("\n"));
+            if (minLenForToggle >= 0 && actual.length() > minLenForToggle) {
+                sb.append(makeToggleCollapseable("toggle actual", toHtml(actual)));
+            } else {
+                sb.append(toHtml(actual));
+            }
+            sb.append(toHtml("\n"));
+            sb.append(formatter.label("actual"));
+        }
+        List<String> errors = typeAdapter.getErrors();
+        if (errors.size() > 0) {
+            sb.append(toHtml("-----"));
+            sb.append(toHtml("\n"));
+            for (String e : errors) {
+                sb.append(toHtml(e + "\n"));
+            }
+            sb.append(toHtml("\n"));
+            sb.append(formatter.label("errors"));
+        }
+        return sb.toString();
+    }
+
+    /**
+     * @param expected        the expected value
+     * @param typeAdapter     the body type adaptor
+     * @param formatter       the formatter
+     *                        the value determining whether the content should be rendered
+     *                        as a collapseable section.
+     * @param minLenForToggle the value determining whether the content should be rendered
+     *                        as a collapseable section.
+     * @return the formatted content for a cell with a right expectation
+     */
+    public static String makeContentForRightCell(String expected,
+                                                 RestDataTypeAdapter typeAdapter, CellFormatter<?> formatter,
+                                                 int minLenForToggle) {
+        StringBuffer sb = new StringBuffer();
+        sb.append(toHtml(expected));
+        String actual = typeAdapter.toString();
         if (formatter.isDisplayActual() && !expected.equals(actual)) {
-			sb.append(toHtml("\n"));
-			sb.append(formatter.label("expected"));
-			sb.append(toHtml("-----"));
-			sb.append(toHtml("\n"));
-			if (minLenForToggle >= 0 && actual.length() > minLenForToggle) {
-				sb.append(makeToggleCollapseable("toggle actual", toHtml(actual)));
-			} else {
-				sb.append(toHtml(actual));
-			}
-			sb.append(toHtml("\n"));
-			sb.append(formatter.label("actual"));
-		}
-		return sb.toString();
-	}
-
-	private static String removeCloseEscape(String str) {
-		return trimStartEnd("-!", str);
-	}
-
-	private static String removeOpenEscape(String str) {
-		return trimStartEnd("!-", str);
-	}
-
-	private static String trimStartEnd(String pattern, String str) {
-		if (str.startsWith(pattern)) {
-			str = str.substring(2);
-		}
-		if (str.endsWith(pattern)) {
-			str = str.substring(0, str.length() - 2);
-		}
-		return str;
-	}
-
-  public static String wrapInDiv(String body) {
-    return String.format("<div>%s</div>", body);
-  }
+            sb.append(toHtml("\n"));
+            sb.append(formatter.label("expected"));
+            sb.append(toHtml("-----"));
+            sb.append(toHtml("\n"));
+            if (minLenForToggle >= 0 && actual.length() > minLenForToggle) {
+                sb.append(makeToggleCollapseable("toggle actual", toHtml(actual)));
+            } else {
+                sb.append(toHtml(actual));
+            }
+            sb.append(toHtml("\n"));
+            sb.append(formatter.label("actual"));
+        }
+        return sb.toString();
+    }
+
+    private static String removeCloseEscape(String str) {
+        return trimStartEnd("-!", str);
+    }
+
+    private static String removeOpenEscape(String str) {
+        return trimStartEnd("!-", str);
+    }
+
+    private static String trimStartEnd(String pattern, String str) {
+        if (str.startsWith(pattern)) {
+            str = str.substring(2);
+        }
+        if (str.endsWith(pattern)) {
+            str = str.substring(0, str.length() - 2);
+        }
+        return str;
+    }
+
+    public static String wrapInDiv(String body) {
+        return String.format("<div>%s</div>", body);
+    }
 
 }
diff --git a/src/main/java/smartrics/rest/fitnesse/fixture/support/Url.java b/src/main/java/smartrics/rest/fitnesse/fixture/support/Url.java
index d6b634c..2d98e95 100644
--- a/src/main/java/smartrics/rest/fitnesse/fixture/support/Url.java
+++ b/src/main/java/smartrics/rest/fitnesse/fixture/support/Url.java
@@ -40,8 +40,7 @@ public class Url {
 	public Url(String url) {
 		try {
 			if (url == null || "".equals(url.trim())) {
-				throw new IllegalArgumentException("Null or empty input: "
-						+ url);
+				throw new IllegalArgumentException("Null or empty input: " + url);
 			}
 			String u = url;
 			if (url.endsWith("/")) {
diff --git a/src/test/java/smartrics/rest/fitnesse/fixture/PartsFactoryTest.java b/src/test/java/smartrics/rest/fitnesse/fixture/PartsFactoryTest.java
index fbc5d08..6f3ca47 100644
--- a/src/test/java/smartrics/rest/fitnesse/fixture/PartsFactoryTest.java
+++ b/src/test/java/smartrics/rest/fitnesse/fixture/PartsFactoryTest.java
@@ -50,7 +50,7 @@ public class PartsFactoryTest {
 			public Variables createRunnerVariables() {
 				return null;
 			}
-		});
+		}, c);
     }
 
     @Test
diff --git a/src/test/java/smartrics/rest/fitnesse/fixture/support/BodyTypeAdapterFactoryTest.java b/src/test/java/smartrics/rest/fitnesse/fixture/support/BodyTypeAdapterFactoryTest.java
index 0df7306..b212bbf 100644
--- a/src/test/java/smartrics/rest/fitnesse/fixture/support/BodyTypeAdapterFactoryTest.java
+++ b/src/test/java/smartrics/rest/fitnesse/fixture/support/BodyTypeAdapterFactoryTest.java
@@ -34,7 +34,7 @@ public class BodyTypeAdapterFactoryTest {
 		public Variables createRunnerVariables() {
 			return null;
 		}
-	});
+	},  Config.getConfig());
     
     @Test
     public void jsonContentTypeReturnsJSONBodyTypeAdapter() {
diff --git a/src/test/java/smartrics/rest/fitnesse/fixture/support/ConfigTest.java b/src/test/java/smartrics/rest/fitnesse/fixture/support/ConfigTest.java
index dec09c5..918c1f6 100644
--- a/src/test/java/smartrics/rest/fitnesse/fixture/support/ConfigTest.java
+++ b/src/test/java/smartrics/rest/fitnesse/fixture/support/ConfigTest.java
@@ -31,6 +31,9 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import java.util.HashMap;
+import java.util.Map;
+
 
 public class ConfigTest {
     private Config namedConfig;
@@ -120,6 +123,17 @@ public class ConfigTest {
         assertEquals(Long.valueOf(10), defaultNamedConfig.getAsLong("long-x", Long.valueOf(10)));
     }
 
+    @Test
+    public void mustGetDataParsedAsMap() {
+        defaultNamedConfig.add("prop", "a=1\nb=2\n");
+        final HashMap<String, String> def = new HashMap<String, String>();
+        def.put("c", "3");
+        Map<String, String> res = defaultNamedConfig.getAsMap("prop", def);
+        assertThat(res.get("a"), is("1"));
+        assertThat(res.get("b"), is("2"));
+        assertThat(res.get("c"), is("3"));
+    }
+
     @Test
     public void mustGetDataParsedAsBoolean() {
         defaultNamedConfig.add("bool", "false");
diff --git a/src/test/java/smartrics/rest/fitnesse/fixture/support/JSONBodyTypeAdapterTest.java b/src/test/java/smartrics/rest/fitnesse/fixture/support/JSONBodyTypeAdapterTest.java
index d0b62f4..c91ea60 100644
--- a/src/test/java/smartrics/rest/fitnesse/fixture/support/JSONBodyTypeAdapterTest.java
+++ b/src/test/java/smartrics/rest/fitnesse/fixture/support/JSONBodyTypeAdapterTest.java
@@ -53,7 +53,7 @@ public class JSONBodyTypeAdapterTest {
 
     @Before
     public void setUp() {
-        adapter = new JSONBodyTypeAdapter(variablesProvider);
+        adapter = new JSONBodyTypeAdapter(variablesProvider, Config.getConfig());
         adapter.setContext(new HashMap<String, String>());
     }
 
diff --git a/src/test/java/smartrics/rest/fitnesse/fixture/support/LetBodyHandlerTest.java b/src/test/java/smartrics/rest/fitnesse/fixture/support/LetBodyHandlerTest.java
index ae85b71..2a55ad2 100644
--- a/src/test/java/smartrics/rest/fitnesse/fixture/support/LetBodyHandlerTest.java
+++ b/src/test/java/smartrics/rest/fitnesse/fixture/support/LetBodyHandlerTest.java
@@ -56,7 +56,7 @@ public class LetBodyHandlerTest {
     @Test
     public void shouldHandleExpressionsReturningNull() {
         LetBodyHandler h = new LetBodyHandler();
-        String r = h.handle(variablesProvider, new RestResponse(), null, "null");
+        String r = h.handle(variablesProvider, Config.getConfig(), new RestResponse(), null, "null");
         assertNull(r);
     }
 
@@ -66,7 +66,7 @@ public class LetBodyHandlerTest {
         RestResponse response = new RestResponse();
         response.addHeader("Content-Type", "application/json");
         response.setBody("{\"root\" : {\"accountRef\":\"http://something:8111\",\"label\":\"default\",\"websiteRef\":\"ws1\",\"dispersionRef\":\"http://localhost:8111\"} }");
-        String ret = h.handle(variablesProvider, response, null, "/root/dispersionRef/text()");
+        String ret = h.handle(variablesProvider, Config.getConfig(), response, null, "/root/dispersionRef/text()");
         assertThat(ret, is(equalTo("http://localhost:8111")));
     }
 }
diff --git a/src/test/java/smartrics/rest/fitnesse/fixture/support/LetBodyJsHandlerTest.java b/src/test/java/smartrics/rest/fitnesse/fixture/support/LetBodyJsHandlerTest.java
index 76726d0..25d50f7 100644
--- a/src/test/java/smartrics/rest/fitnesse/fixture/support/LetBodyJsHandlerTest.java
+++ b/src/test/java/smartrics/rest/fitnesse/fixture/support/LetBodyJsHandlerTest.java
@@ -53,7 +53,7 @@ public class LetBodyJsHandlerTest {
     @Test
     public void shouldHandleExpressionsReturningNull() {
         LetBodyJsHandler h = new LetBodyJsHandler();
-        String r = h.handle(variablesProvider, new RestResponse(), null, "null");
+        String r = h.handle(variablesProvider, Config.getConfig(), new RestResponse(), null, "null");
         assertNull(r);
     }
 }
