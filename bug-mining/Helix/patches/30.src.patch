diff --git a/helix-core/src/syntax.rs b/helix-core/src/syntax.rs
index 0e6696db..c34ea81a 100644
--- a/helix-core/src/syntax.rs
+++ b/helix-core/src/syntax.rs
@@ -555,7 +555,9 @@ fn load_query(&self, kind: &str) -> Option<Query> {
 #[serde(default, rename_all = "kebab-case", deny_unknown_fields)]
 pub struct SoftWrap {
     /// Soft wrap lines that exceed viewport width. Default to off
-    pub enable: bool,
+    // NOTE: Option on purpose because the struct is shared between language config and global config.
+    // By default the option is None so that the language config falls back to the global config unless explicitly set.
+    pub enable: Option<bool>,
     /// Maximum space left free at the end of the line.
     /// This space is used to wrap text at word boundaries. If that is not possible within this limit
     /// the word is simply split at the end of the line.
diff --git a/helix-view/src/document.rs b/helix-view/src/document.rs
index 65a5a6e2..eca60026 100644
--- a/helix-view/src/document.rs
+++ b/helix-view/src/document.rs
@@ -1444,8 +1444,9 @@ pub fn text_format(&self, mut viewport_width: u16, theme: Option<&Theme>) -> Tex
             .as_ref()
             .and_then(|config| config.soft_wrap.as_ref());
         let enable_soft_wrap = language_soft_wrap
-            .map(|soft_wrap| soft_wrap.enable)
-            .unwrap_or_else(|| editor_soft_wrap.enable);
+            .and_then(|soft_wrap| soft_wrap.enable)
+            .or(editor_soft_wrap.enable)
+            .unwrap_or(false);
         let max_wrap = language_soft_wrap
             .and_then(|soft_wrap| soft_wrap.max_wrap)
             .or(config.soft_wrap.max_wrap)
