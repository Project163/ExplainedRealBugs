diff --git a/helix-core/src/selection.rs b/helix-core/src/selection.rs
index 0db7634c..0eb2b755 100644
--- a/helix-core/src/selection.rs
+++ b/helix-core/src/selection.rs
@@ -625,11 +625,6 @@ pub fn len(&self) -> usize {
 
     // returns true if self âŠ‡ other
     pub fn contains(&self, other: &Selection) -> bool {
-        // can't contain other if it is larger
-        if other.len() > self.len() {
-            return false;
-        }
-
         let (mut iter_self, mut iter_other) = (self.iter(), other.iter());
         let (mut ele_self, mut ele_other) = (iter_self.next(), iter_other.next());
 
@@ -1240,5 +1235,11 @@ fn contains(a: Vec<(usize, usize)>, b: Vec<(usize, usize)>) -> bool {
             vec!((3, 4), (7, 9))
         ));
         assert!(!contains(vec!((1, 1), (5, 6)), vec!((1, 6))));
+
+        // multiple ranges of other are all contained in some ranges of self,
+        assert!(contains(
+            vec!((1, 4), (7, 10)),
+            vec!((1, 2), (3, 4), (7, 9))
+        ));
     }
 }
diff --git a/helix-term/src/commands.rs b/helix-term/src/commands.rs
index 6817bc5c..803f4051 100644
--- a/helix-term/src/commands.rs
+++ b/helix-term/src/commands.rs
@@ -4371,7 +4371,6 @@ fn shrink_selection(cx: &mut Context) {
         // try to restore previous selection
         if let Some(prev_selection) = view.object_selections.pop() {
             if current_selection.contains(&prev_selection) {
-                // allow shrinking the selection only if current selection contains the previous object selection
                 doc.set_selection(view.id, prev_selection);
                 return;
             } else {
