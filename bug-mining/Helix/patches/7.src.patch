diff --git a/helix-lsp/src/client.rs b/helix-lsp/src/client.rs
index 8b14b0b8..14918818 100644
--- a/helix-lsp/src/client.rs
+++ b/helix-lsp/src/client.rs
@@ -293,6 +293,13 @@ pub(crate) async fn initialize(&self) -> Result<lsp::InitializeResult> {
                     completion: Some(lsp::CompletionClientCapabilities {
                         completion_item: Some(lsp::CompletionItemCapability {
                             snippet_support: Some(false),
+                            resolve_support: Some(lsp::CompletionItemCapabilityResolveSupport {
+                                properties: vec![
+                                    String::from("documentation"),
+                                    String::from("detail"),
+                                    String::from("additionalTextEdits"),
+                                ],
+                            }),
                             ..Default::default()
                         }),
                         completion_item_kind: Some(lsp::CompletionItemKindCapability {
diff --git a/helix-term/src/ui/completion.rs b/helix-term/src/ui/completion.rs
index 1ee4a01a..556273bc 100644
--- a/helix-term/src/ui/completion.rs
+++ b/helix-term/src/ui/completion.rs
@@ -178,17 +178,21 @@ fn completion_changes(transaction: &Transaction, trigger_offset: usize) -> Vec<C
                     });
 
                     // apply additional edits, mostly used to auto import unqualified types
-                    let resolved_additional_text_edits = if item.additional_text_edits.is_some() {
+                    let resolved_item = if item
+                        .additional_text_edits
+                        .as_ref()
+                        .map(|edits| !edits.is_empty())
+                        .unwrap_or(false)
+                    {
                         None
                     } else {
                         Self::resolve_completion_item(doc, item.clone())
-                            .and_then(|item| item.additional_text_edits)
                     };
 
-                    if let Some(additional_edits) = item
-                        .additional_text_edits
+                    if let Some(additional_edits) = resolved_item
                         .as_ref()
-                        .or(resolved_additional_text_edits.as_ref())
+                        .and_then(|item| item.additional_text_edits.as_ref())
+                        .or(item.additional_text_edits.as_ref())
                     {
                         if !additional_edits.is_empty() {
                             let transaction = util::generate_transaction_from_edits(
