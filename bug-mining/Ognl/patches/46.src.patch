diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index c3357f0..dbde8d5 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -23,6 +23,7 @@
   </properties>
   <body>
     <release version="4.0-incubating" date="TBD" description="First ASF release under Incubation.">
+      <action issue="OGNL-33" type="update" dev="mcucchiara">OGNL-33 - Improvements to JJTOgnlParserState (contributed by Adrian Cumiskey).</action>
       <action issue="OGNL-32" type="update" dev="mcucchiara">OGNL-32 - CPD fix to ASTProperty (contributed by Adrian Cumiskey).</action>
       <action issue="OGNL-31" type="update" dev="mcucchiara">OGNL-31 - Some CPD fixes around ASTMethod and ASTStaticMethod (contributed by Adrian Cumiskey).</action>
       <action issue="OGNL-28" type="update" dev="mcucchiara">Visitor pattern needs way to propagate exceptions (contributed by Daniel Pitts).</action>
diff --git a/src/main/java/org/apache/commons/ognl/JJTOgnlParserState.java b/src/main/java/org/apache/commons/ognl/JJTOgnlParserState.java
index 1ac38d3..249f1dc 100644
--- a/src/main/java/org/apache/commons/ognl/JJTOgnlParserState.java
+++ b/src/main/java/org/apache/commons/ognl/JJTOgnlParserState.java
@@ -20,27 +20,30 @@
 /* Generated By:JavaCC: Do not edit this line. JJTOgnlParserState.java Version 4.1d1 */
 package org.apache.commons.ognl;
 
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * $Id$
  */
 public class JJTOgnlParserState
 {
-    private java.util.List nodes;
+    private List<Node> nodes;
 
-    private java.util.List marks;
+    private List<Integer> marks;
 
-    private int sp; // number of nodes on stack
+    private int numNodesOnStack;
 
-    private int mk; // current mark
+    private int currentMark;
 
-    private boolean node_created;
+    private boolean nodeCreated;
 
     public JJTOgnlParserState()
     {
-        nodes = new java.util.ArrayList();
-        marks = new java.util.ArrayList();
-        sp = 0;
-        mk = 0;
+        nodes = new ArrayList<Node>();
+        marks = new ArrayList<Integer>();
+        numNodesOnStack = 0;
+        currentMark = 0;
     }
 
     /*
@@ -49,7 +52,7 @@ public class JJTOgnlParserState
      */
     public boolean nodeCreated()
     {
-        return node_created;
+        return nodeCreated;
     }
 
     /*
@@ -59,8 +62,8 @@ public class JJTOgnlParserState
     {
         nodes.clear();
         marks.clear();
-        sp = 0;
-        mk = 0;
+        numNodesOnStack = 0;
+        currentMark = 0;
     }
 
     /*
@@ -68,14 +71,14 @@ public class JJTOgnlParserState
      */
     public Node rootNode()
     {
-        return (Node) nodes.get( 0 );
+        return nodes.get( 0 );
     }
 
     /* Pushes a node on to the stack. */
-    public void pushNode( Node n )
+    public void pushNode( Node node )
     {
-        nodes.add( n );
-        ++sp;
+        nodes.add( node );
+        ++numNodesOnStack;
     }
 
     /*
@@ -83,17 +86,17 @@ public class JJTOgnlParserState
      */
     public Node popNode()
     {
-        if ( --sp < mk )
+        if ( --numNodesOnStack < currentMark )
         {
-            mk = ( (Integer) marks.remove( marks.size() - 1 ) ).intValue();
+            currentMark = marks.remove( marks.size() - 1 );
         }
-        return (Node) nodes.remove( nodes.size() - 1 );
+        return nodes.remove( nodes.size() - 1 );
     }
 
     /* Returns the node currently on the top of the stack. */
     public Node peekNode()
     {
-        return (Node) nodes.get( nodes.size() - 1 );
+        return nodes.get( nodes.size() - 1 );
     }
 
     /*
@@ -101,41 +104,41 @@ public class JJTOgnlParserState
      */
     public int nodeArity()
     {
-        return sp - mk;
+        return numNodesOnStack - currentMark;
     }
 
-    public void clearNodeScope( Node n )
+    public void clearNodeScope( Node unused )
     {
-        while ( sp > mk )
+        while ( numNodesOnStack > currentMark )
         {
             popNode();
         }
-        mk = ( (Integer) marks.remove( marks.size() - 1 ) ).intValue();
+        currentMark = marks.remove( marks.size() - 1 );
     }
 
-    public void openNodeScope( Node n )
+    public void openNodeScope( Node node )
     {
-        marks.add( new Integer( mk ) );
-        mk = sp;
-        n.jjtOpen();
+        marks.add(currentMark);
+        currentMark = numNodesOnStack;
+        node.jjtOpen();
     }
 
     /*
      * A definite node is constructed from a specified number of children. That number of nodes are popped from the
      * stack and made the children of the definite node. Then the definite node is pushed on to the stack.
      */
-    public void closeNodeScope( Node n, int num )
+    public void closeNodeScope( Node node, int num )
     {
-        mk = ( (Integer) marks.remove( marks.size() - 1 ) ).intValue();
+        currentMark = marks.remove( marks.size() - 1 );
         while ( num-- > 0 )
         {
-            Node c = popNode();
-            c.jjtSetParent( n );
-            n.jjtAddChild( c, num );
+            Node poppedNode = popNode();
+            poppedNode.jjtSetParent( node );
+            node.jjtAddChild( poppedNode, num );
         }
-        n.jjtClose();
-        pushNode( n );
-        node_created = true;
+        node.jjtClose();
+        pushNode( node );
+        nodeCreated = true;
     }
 
     /*
@@ -143,26 +146,26 @@ public class JJTOgnlParserState
      * was opened are made children of the conditional node, which is then pushed on to the stack. If the condition is
      * false the node is not constructed and they are left on the stack.
      */
-    public void closeNodeScope( Node n, boolean condition )
+    public void closeNodeScope( Node node, boolean condition )
     {
         if ( condition )
         {
-            int a = nodeArity();
-            mk = ( (Integer) marks.remove( marks.size() - 1 ) ).intValue();
-            while ( a-- > 0 )
+            int arity = nodeArity();
+            currentMark = marks.remove( marks.size() - 1 );
+            while ( arity-- > 0 )
             {
-                Node c = popNode();
-                c.jjtSetParent( n );
-                n.jjtAddChild( c, a );
+                Node poppedNode = popNode();
+                poppedNode.jjtSetParent( node );
+                node.jjtAddChild( poppedNode, arity );
             }
-            n.jjtClose();
-            pushNode( n );
-            node_created = true;
+            node.jjtClose();
+            pushNode( node );
+            nodeCreated = true;
         }
         else
         {
-            mk = ( (Integer) marks.remove( marks.size() - 1 ) ).intValue();
-            node_created = false;
+            currentMark = marks.remove( marks.size() - 1 );
+            nodeCreated = false;
         }
     }
 }
