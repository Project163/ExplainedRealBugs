diff --git a/packages/babel-helper-member-expression-to-functions/README.md b/packages/babel-helper-member-expression-to-functions/README.md
index 70221cf2b4..31dd4c3ce2 100644
--- a/packages/babel-helper-member-expression-to-functions/README.md
+++ b/packages/babel-helper-member-expression-to-functions/README.md
@@ -26,6 +26,8 @@ const visitor = {
 
 // The helper requires three special methods on state: `get`, `set`, and
 // `call`.
+// Optionally, a special `memoize` method may be defined, which gets
+// called if the member is in a self-referential update expression.
 // Everything else will be passed through as normal.
 const state = {
   get(memberPath) {
@@ -36,7 +38,7 @@ const state = {
     );
   },
 
-  get(memberPath, value) {
+  set(memberPath, value) {
     // Return some AST that will set the member
     return t.callExpression(
       this.file.addHelper('superSet'),
@@ -53,6 +55,13 @@ const state = {
     );
   },
 
+  memoize(memberPath) {
+    const { node } = memberPath;
+    if (node.computed) {
+      MEMOIZED.set(node, ...);
+    }
+  },
+
   // The handle method is provided by memberExpressionToFunctions.
   // handle(memberPath) { ... }
 
diff --git a/packages/babel-helper-member-expression-to-functions/src/index.js b/packages/babel-helper-member-expression-to-functions/src/index.js
index 33e3685b20..2f6d980b6f 100644
--- a/packages/babel-helper-member-expression-to-functions/src/index.js
+++ b/packages/babel-helper-member-expression-to-functions/src/index.js
@@ -9,6 +9,12 @@ const handle = {
     if (parentPath.isUpdateExpression({ argument: node })) {
       const { operator, prefix } = parent;
 
+      // Give the state handler a chance to memoize the member,
+      // since we'll reference it twice.
+      if (this.memoize) {
+        this.memoize(member);
+      }
+
       const value = t.binaryExpression(
         operator[0],
         t.unaryExpression("+", this.get(member)),
@@ -38,6 +44,12 @@ const handle = {
       let value = right;
 
       if (operator !== "=") {
+        // Give the state handler a chance to memoize the member,
+        // since we'll reference it twice.
+        if (this.memoize) {
+          this.memoize(member);
+        }
+
         value = t.binaryExpression(
           operator.slice(0, -1),
           this.get(member),
@@ -67,6 +79,8 @@ const handle = {
 // it wishes to be transformed.
 // Additionally, the caller must pass in a state object with at least
 // get, set, and call methods.
+// Optionally, a memoize method may be defined on the state, which will be
+// called when the member is a self-referential update.
 export default function memberExpressionToFunctions(path, visitor, state) {
   path.traverse(visitor, Object.assign({}, state, handle));
 }
diff --git a/packages/babel-helper-replace-supers/src/index.js b/packages/babel-helper-replace-supers/src/index.js
index 8501ec9990..25d02e1fa1 100644
--- a/packages/babel-helper-replace-supers/src/index.js
+++ b/packages/babel-helper-replace-supers/src/index.js
@@ -80,7 +80,23 @@ const visitor = traverse.visitors.merge([
   },
 ]);
 
+const memoized = new WeakMap();
 const specHandlers = {
+  memoize(superMember) {
+    const { scope, node } = superMember;
+    const { computed, property } = node;
+    if (!computed) {
+      return;
+    }
+
+    const memo = scope.maybeGenerateMemoised(property);
+    if (!memo) {
+      return;
+    }
+
+    memoized.set(property, memo);
+  },
+
   get(superMember) {
     const { computed, property } = superMember.node;
     let thisExpr = t.thisExpression();
@@ -93,9 +109,16 @@ const specHandlers = {
       );
     }
 
+    let prop;
+    if (computed && memoized.has(property)) {
+      prop = t.cloneNode(memoized.get(property));
+    } else {
+      prop = computed ? property : t.stringLiteral(property.name);
+    }
+
     return t.callExpression(this.file.addHelper("get"), [
       getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file),
-      computed ? property : t.stringLiteral(property.name),
+      prop,
       thisExpr,
     ]);
   },
@@ -103,9 +126,20 @@ const specHandlers = {
   set(superMember, value) {
     const { computed, property } = superMember.node;
 
+    let prop;
+    if (computed && memoized.has(property)) {
+      prop = t.assignmentExpression(
+        "=",
+        t.cloneNode(memoized.get(property)),
+        property,
+      );
+    } else {
+      prop = computed ? property : t.stringLiteral(property.name);
+    }
+
     return t.callExpression(this.file.addHelper("set"), [
       getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file),
-      computed ? property : t.stringLiteral(property.name),
+      prop,
       value,
       t.thisExpression(),
       t.booleanLiteral(superMember.isInStrictMode()),
@@ -193,23 +227,26 @@ export default class ReplaceSupers {
   }
 
   replace() {
-    const { get, set, call } = this.isLoose ? looseHandlers : specHandlers;
-
-    memberExpressionToFunctions(this.methodPath, visitor, {
-      get,
-      set,
-      call,
-
-      // Necessary state
-      file: this.file,
-      isStatic: this.isStatic,
-      getObjectRef: this.getObjectRef.bind(this),
-      superRef: this.superRef,
-
-      // TODO Remove this shit.
-      inConstructor: this.inConstructor,
-      returns: this.returns,
-      bareSupers: this.bareSupers,
-    });
+    const handler = this.isLoose ? looseHandlers : specHandlers;
+
+    memberExpressionToFunctions(
+      this.methodPath,
+      visitor,
+      Object.assign(
+        {
+          // Necessary state
+          file: this.file,
+          isStatic: this.isStatic,
+          getObjectRef: this.getObjectRef.bind(this),
+          superRef: this.superRef,
+
+          // TODO Remove this shit.
+          inConstructor: this.inConstructor,
+          returns: this.returns,
+          bareSupers: this.bareSupers,
+        },
+        handler,
+      ),
+    );
   }
 }
diff --git a/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-assign/exec.js b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-assign/exec.js
new file mode 100644
index 0000000000..0c22e74295
--- /dev/null
+++ b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-assign/exec.js
@@ -0,0 +1,41 @@
+"use strict";
+class Base {}
+Object.defineProperty(Base.prototype, 0, {
+  value: 0,
+  writable: true,
+  configurable: true,
+});
+Object.defineProperty(Base.prototype, 1, {
+  value: 1,
+  writable: true,
+  configurable: true,
+});
+
+let i = 0;
+const proper = {
+  get prop() {
+    return i++;
+  },
+};
+
+class Obj extends Base {
+  assign() {
+    super[proper.prop] += 1;
+  }
+
+  assign2() {
+    super[i] += 1;
+  }
+}
+
+const obj = new Obj();
+
+obj.assign();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(1);
+
+obj.assign2();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(2);
diff --git a/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-assign/input.js b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-assign/input.js
new file mode 100644
index 0000000000..0c22e74295
--- /dev/null
+++ b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-assign/input.js
@@ -0,0 +1,41 @@
+"use strict";
+class Base {}
+Object.defineProperty(Base.prototype, 0, {
+  value: 0,
+  writable: true,
+  configurable: true,
+});
+Object.defineProperty(Base.prototype, 1, {
+  value: 1,
+  writable: true,
+  configurable: true,
+});
+
+let i = 0;
+const proper = {
+  get prop() {
+    return i++;
+  },
+};
+
+class Obj extends Base {
+  assign() {
+    super[proper.prop] += 1;
+  }
+
+  assign2() {
+    super[i] += 1;
+  }
+}
+
+const obj = new Obj();
+
+obj.assign();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(1);
+
+obj.assign2();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(2);
diff --git a/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-assign/output.js b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-assign/output.js
new file mode 100644
index 0000000000..90c8677d8d
--- /dev/null
+++ b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-assign/output.js
@@ -0,0 +1,89 @@
+"use strict";
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function set(target, property, value, receiver) { if (typeof Reflect !== "undefined" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }
+
+function _set(target, property, value, receiver, isStrict) { const s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }
+
+function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) { return o.__proto__; }; return _getPrototypeOf(o); }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+let Base = function Base() {
+  _classCallCheck(this, Base);
+};
+
+Object.defineProperty(Base.prototype, 0, {
+  value: 0,
+  writable: true,
+  configurable: true
+});
+Object.defineProperty(Base.prototype, 1, {
+  value: 1,
+  writable: true,
+  configurable: true
+});
+let i = 0;
+const proper = {
+  get prop() {
+    return i++;
+  }
+
+};
+
+let Obj =
+/*#__PURE__*/
+function (_Base) {
+  _inherits(Obj, _Base);
+
+  function Obj() {
+    _classCallCheck(this, Obj);
+
+    return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
+  }
+
+  _createClass(Obj, [{
+    key: "assign",
+    value: function assign() {
+      var _proper$prop;
+
+      _set(_getPrototypeOf(Obj.prototype), _proper$prop = proper.prop, _get(_getPrototypeOf(Obj.prototype), _proper$prop, this) + 1, this, true);
+    }
+  }, {
+    key: "assign2",
+    value: function assign2() {
+      var _i;
+
+      _set(_getPrototypeOf(Obj.prototype), _i = i, _get(_getPrototypeOf(Obj.prototype), _i, this) + 1, this, true);
+    }
+  }]);
+
+  return Obj;
+}(Base);
+
+const obj = new Obj();
+obj.assign();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(1);
+obj.assign2();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(2);
diff --git a/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-update/exec.js b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-update/exec.js
new file mode 100644
index 0000000000..c1761230f6
--- /dev/null
+++ b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-update/exec.js
@@ -0,0 +1,41 @@
+"use strict";
+class Base {}
+Object.defineProperty(Base.prototype, 0, {
+  value: 0,
+  writable: true,
+  configurable: true,
+});
+Object.defineProperty(Base.prototype, 1, {
+  value: 1,
+  writable: true,
+  configurable: true,
+});
+
+let i = 0;
+const proper = {
+  get prop() {
+    return i++;
+  },
+};
+
+class Obj extends Base {
+  update() {
+    super[proper.prop]++;
+  }
+
+  update2() {
+    super[i]++;
+  }
+}
+
+const obj = new Obj();
+
+obj.update();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(1);
+
+obj.update2();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(2);
diff --git a/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-update/input.js b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-update/input.js
new file mode 100644
index 0000000000..c1761230f6
--- /dev/null
+++ b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-update/input.js
@@ -0,0 +1,41 @@
+"use strict";
+class Base {}
+Object.defineProperty(Base.prototype, 0, {
+  value: 0,
+  writable: true,
+  configurable: true,
+});
+Object.defineProperty(Base.prototype, 1, {
+  value: 1,
+  writable: true,
+  configurable: true,
+});
+
+let i = 0;
+const proper = {
+  get prop() {
+    return i++;
+  },
+};
+
+class Obj extends Base {
+  update() {
+    super[proper.prop]++;
+  }
+
+  update2() {
+    super[i]++;
+  }
+}
+
+const obj = new Obj();
+
+obj.update();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(1);
+
+obj.update2();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(2);
diff --git a/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-update/output.js b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-update/output.js
new file mode 100644
index 0000000000..fbeb44aedc
--- /dev/null
+++ b/packages/babel-plugin-transform-classes/test/fixtures/get-set/memoized-update/output.js
@@ -0,0 +1,89 @@
+"use strict";
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function set(target, property, value, receiver) { if (typeof Reflect !== "undefined" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }
+
+function _set(target, property, value, receiver, isStrict) { const s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }
+
+function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) { return o.__proto__; }; return _getPrototypeOf(o); }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+let Base = function Base() {
+  _classCallCheck(this, Base);
+};
+
+Object.defineProperty(Base.prototype, 0, {
+  value: 0,
+  writable: true,
+  configurable: true
+});
+Object.defineProperty(Base.prototype, 1, {
+  value: 1,
+  writable: true,
+  configurable: true
+});
+let i = 0;
+const proper = {
+  get prop() {
+    return i++;
+  }
+
+};
+
+let Obj =
+/*#__PURE__*/
+function (_Base) {
+  _inherits(Obj, _Base);
+
+  function Obj() {
+    _classCallCheck(this, Obj);
+
+    return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
+  }
+
+  _createClass(Obj, [{
+    key: "update",
+    value: function update() {
+      var _proper$prop, _super$proper$prop;
+
+      _set(_getPrototypeOf(Obj.prototype), _proper$prop = proper.prop, (_super$proper$prop = +_get(_getPrototypeOf(Obj.prototype), _proper$prop, this)) + 1, this, true), _super$proper$prop;
+    }
+  }, {
+    key: "update2",
+    value: function update2() {
+      var _i, _super$i;
+
+      _set(_getPrototypeOf(Obj.prototype), _i = i, (_super$i = +_get(_getPrototypeOf(Obj.prototype), _i, this)) + 1, this, true), _super$i;
+    }
+  }]);
+
+  return Obj;
+}(Base);
+
+const obj = new Obj();
+obj.update();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(1);
+obj.update2();
+expect(i).toBe(1);
+expect(obj[0]).toBe(1);
+expect(obj[1]).toBe(2);
