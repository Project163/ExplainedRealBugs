diff --git a/packages/babel-traverse/scripts/generators/validators.js b/packages/babel-traverse/scripts/generators/validators.js
index eae98a33e2..a3ec31a3eb 100644
--- a/packages/babel-traverse/scripts/generators/validators.js
+++ b/packages/babel-traverse/scripts/generators/validators.js
@@ -9,6 +9,7 @@ export default function generateValidators() {
  */
 import * as t from "@babel/types";
 import NodePath from "../index";
+import type { VirtualTypeAliases } from "./virtual-types";
 
 export interface NodePathValidators {
 `;
@@ -18,10 +19,18 @@ export interface NodePathValidators {
   }
 
   for (const type of Object.keys(virtualTypes)) {
+    const { types } = virtualTypes[type];
     if (type[0] === "_") continue;
     if (definitions.NODE_FIELDS[type] || definitions.FLIPPED_ALIAS_KEYS[type]) {
       output += `is${type}(opts?: object): this is NodePath<t.${type}>;`;
+    } else if (types /* in VirtualTypeAliases */) {
+      output += `is${type}(opts?: object): this is NodePath<VirtualTypeAliases["${type}"]>;`;
     } else {
+      // if it don't have types, then VirtualTypeAliases[type] is t.Node
+      // which TS marked as always true
+      // eg. if (path.isBlockScope()) return;
+      //     path resolved to `never` here
+      // so we have to return boolean instead of this is NodePath<t.Node> here
       output += `is${type}(opts?: object): boolean;`;
     }
   }
diff --git a/packages/babel-traverse/src/path/evaluation.ts b/packages/babel-traverse/src/path/evaluation.ts
index 09b509f1b6..de673dd007 100644
--- a/packages/babel-traverse/src/path/evaluation.ts
+++ b/packages/babel-traverse/src/path/evaluation.ts
@@ -153,7 +153,6 @@ function _evaluate(path: NodePath, state) {
   }
 
   if (path.isReferencedIdentifier()) {
-    // @ts-expect-error todo(flow->ts): consider separating type refinement and check for reference
     const binding = path.scope.getBinding(path.node.name);
 
     if (binding && binding.constantViolations.length > 0) {
@@ -167,13 +166,10 @@ function _evaluate(path: NodePath, state) {
     if (binding?.hasValue) {
       return binding.value;
     } else {
-      // @ts-expect-error todo(flow->ts): consider separating type refinement and check for reference
       if (path.node.name === "undefined") {
         return binding ? deopt(binding.path, state) : undefined;
-        // @ts-expect-error todo(flow->ts): consider separating type refinement and check for reference
       } else if (path.node.name === "Infinity") {
         return binding ? deopt(binding.path, state) : Infinity;
-        // @ts-expect-error todo(flow->ts): consider separating type refinement and check for reference
       } else if (path.node.name === "NaN") {
         return binding ? deopt(binding.path, state) : NaN;
       }
diff --git a/packages/babel-traverse/src/path/generated/validators.ts b/packages/babel-traverse/src/path/generated/validators.ts
index 75c8badee0..7dbf7d828d 100755
--- a/packages/babel-traverse/src/path/generated/validators.ts
+++ b/packages/babel-traverse/src/path/generated/validators.ts
@@ -4,6 +4,7 @@
  */
 import * as t from "@babel/types";
 import NodePath from "../index";
+import type { VirtualTypeAliases } from "./virtual-types";
 
 export interface NodePathValidators {
   isAnyTypeAnnotation(opts?: object): this is NodePath<t.AnyTypeAnnotation>;
@@ -416,22 +417,38 @@ export interface NodePathValidators {
   isWhileStatement(opts?: object): this is NodePath<t.WhileStatement>;
   isWithStatement(opts?: object): this is NodePath<t.WithStatement>;
   isYieldExpression(opts?: object): this is NodePath<t.YieldExpression>;
-  isReferencedIdentifier(opts?: object): boolean;
-  isReferencedMemberExpression(opts?: object): boolean;
-  isBindingIdentifier(opts?: object): boolean;
+  isReferencedIdentifier(
+    opts?: object,
+  ): this is NodePath<VirtualTypeAliases["ReferencedIdentifier"]>;
+  isReferencedMemberExpression(
+    opts?: object,
+  ): this is NodePath<VirtualTypeAliases["ReferencedMemberExpression"]>;
+  isBindingIdentifier(
+    opts?: object,
+  ): this is NodePath<VirtualTypeAliases["BindingIdentifier"]>;
   isStatement(opts?: object): this is NodePath<t.Statement>;
   isExpression(opts?: object): this is NodePath<t.Expression>;
-  isScope(opts?: object): boolean;
+  isScope(opts?: object): this is NodePath<VirtualTypeAliases["Scope"]>;
   isReferenced(opts?: object): boolean;
   isBlockScoped(opts?: object): boolean;
-  isVar(opts?: object): boolean;
+  isVar(opts?: object): this is NodePath<VirtualTypeAliases["Var"]>;
   isUser(opts?: object): boolean;
   isGenerated(opts?: object): boolean;
   isPure(opts?: object): boolean;
   isFlow(opts?: object): this is NodePath<t.Flow>;
-  isRestProperty(opts?: object): boolean;
-  isSpreadProperty(opts?: object): boolean;
-  isExistentialTypeParam(opts?: object): boolean;
-  isNumericLiteralTypeAnnotation(opts?: object): boolean;
-  isForAwaitStatement(opts?: object): boolean;
+  isRestProperty(
+    opts?: object,
+  ): this is NodePath<VirtualTypeAliases["RestProperty"]>;
+  isSpreadProperty(
+    opts?: object,
+  ): this is NodePath<VirtualTypeAliases["SpreadProperty"]>;
+  isExistentialTypeParam(
+    opts?: object,
+  ): this is NodePath<VirtualTypeAliases["ExistentialTypeParam"]>;
+  isNumericLiteralTypeAnnotation(
+    opts?: object,
+  ): this is NodePath<VirtualTypeAliases["NumericLiteralTypeAnnotation"]>;
+  isForAwaitStatement(
+    opts?: object,
+  ): this is NodePath<VirtualTypeAliases["ForAwaitStatement"]>;
 }
diff --git a/packages/babel-traverse/src/path/introspection.ts b/packages/babel-traverse/src/path/introspection.ts
index bd569e77e3..38d50dbff9 100644
--- a/packages/babel-traverse/src/path/introspection.ts
+++ b/packages/babel-traverse/src/path/introspection.ts
@@ -480,7 +480,6 @@ export function _resolve(
       // otherwise it's a request for a pattern and that's a bit more tricky
     }
   } else if (this.isReferencedIdentifier()) {
-    // @ts-expect-error todo(flow->ts): think about options to improve type refinements
     const binding = this.scope.getBinding(this.node.name);
     if (!binding) return;
 
