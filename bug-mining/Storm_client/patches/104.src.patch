diff --git a/storm-client/test/jvm/org/apache/storm/utils/JCQueueTest.java b/storm-client/test/jvm/org/apache/storm/utils/JCQueueTest.java
index 09a5dd11c..637c82f12 100644
--- a/storm-client/test/jvm/org/apache/storm/utils/JCQueueTest.java
+++ b/storm-client/test/jvm/org/apache/storm/utils/JCQueueTest.java
@@ -9,17 +9,18 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
  * and limitations under the License.
  */
-
 package org.apache.storm.utils;
 
+import static org.junit.Assert.assertFalse;
+
+import java.time.Duration;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 import org.apache.storm.policy.IWaitStrategy;
 import org.apache.storm.policy.WaitStrategyPark;
 import org.junit.Assert;
-import org.junit.Test;
-
-import static org.junit.Assert.assertFalse;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
 
 public class JCQueueTest {
 
@@ -27,28 +28,61 @@ public class JCQueueTest {
     private final static int PRODUCER_NUM = 4;
     IWaitStrategy waitStrategy = new WaitStrategyPark(100);
 
-    @Test(timeout = 10000)
+    @Test
     public void testFirstMessageFirst() throws InterruptedException {
-        for (int i = 0; i < 100; i++) {
-            JCQueue queue = createQueue("firstMessageOrder", 16);
+        Assertions.assertTimeoutPreemptively(Duration.ofSeconds(10), () -> {
+            for (int i = 0; i < 100; i++) {
+                JCQueue queue = createQueue("firstMessageOrder", 16);
+
+                queue.publish("FIRST");
+
+                Runnable producer = new IncProducer(queue, i + 100, 1);
+
+                final AtomicReference<Object> result = new AtomicReference<>();
+                Runnable consumer = new ConsumerThd(queue, new JCQueue.Consumer() {
+                    private boolean head = true;
+
+                    @Override
+                    public void accept(Object event) {
+                        if (Thread.currentThread().isInterrupted()) {
+                            throw new RuntimeException(new InterruptedException("ConsumerThd interrupted"));
+                        }
+                        if (head) {
+                            head = false;
+                            result.set(event);
+                        }
+                    }
 
-            queue.publish("FIRST");
+                    @Override
+                    public void flush() {
+                        return;
+                    }
+                });
 
-            Runnable producer = new IncProducer(queue, i + 100);
+                run(producer, consumer, queue);
+                Assert.assertEquals("We expect to receive first published message first, but received " + result.get(),
+                    "FIRST", result.get());
+            }
+        });
+    }
 
-            final AtomicReference<Object> result = new AtomicReference<>();
+    @Test
+    public void testInOrder() throws InterruptedException {
+        Assertions.assertTimeoutPreemptively(Duration.ofSeconds(10), () -> {
+            final AtomicBoolean allInOrder = new AtomicBoolean(true);
+
+            JCQueue queue = createQueue("consumerHang", 1024);
+            Runnable producer = new IncProducer(queue, 1024 * 1024, 100);
             Runnable consumer = new ConsumerThd(queue, new JCQueue.Consumer() {
-                private boolean head = true;
+                long _expected = 0;
 
                 @Override
-                public void accept(Object event) {
-                    if (Thread.currentThread().isInterrupted()) {
-                        throw new RuntimeException(new InterruptedException("ConsumerThd interrupted"));
-                    }
-                    if (head) {
-                        head = false;
-                        result.set(event);
+                public void accept(Object obj) {
+                    if (_expected != ((Number) obj).longValue()) {
+                        allInOrder.set(false);
+                        System.out.println("Expected " + _expected + " but got " + obj);
                     }
+                    _expected++;
                 }
 
                 @Override
@@ -56,71 +90,43 @@ public class JCQueueTest {
                     return;
                 }
             });
-
-            run(producer, consumer, queue);
-            Assert.assertEquals("We expect to receive first published message first, but received " + result.get(),
-                                "FIRST", result.get());
-        }
-    }
-
-    @Test(timeout = 10000)
-    public void testInOrder() throws InterruptedException {
-        final AtomicBoolean allInOrder = new AtomicBoolean(true);
-
-        JCQueue queue = createQueue("consumerHang", 1024);
-        Runnable producer = new IncProducer(queue, 1024 * 1024);
-        Runnable consumer = new ConsumerThd(queue, new JCQueue.Consumer() {
-            long _expected = 0;
-
-            @Override
-            public void accept(Object obj) {
-                if (_expected != ((Number) obj).longValue()) {
-                    allInOrder.set(false);
-                    System.out.println("Expected " + _expected + " but got " + obj);
-                }
-                _expected++;
-            }
-
-            @Override
-            public void flush() {
-                return;
-            }
+            run(producer, consumer, queue, 1000, 1);
+            Assert.assertTrue("Messages delivered out of order",
+                allInOrder.get());
         });
-        run(producer, consumer, queue, 1000, 1);
-        Assert.assertTrue("Messages delivered out of order",
-                          allInOrder.get());
     }
 
-    @Test(timeout = 10000)
+    @Test
     public void testInOrderBatch() throws InterruptedException {
-        final AtomicBoolean allInOrder = new AtomicBoolean(true);
-
-        JCQueue queue = createQueue("consumerHang", 10, 1024);
-        Runnable producer = new IncProducer(queue, 1024 * 1024);
-        Runnable consumer = new ConsumerThd(queue, new JCQueue.Consumer() {
-            long _expected = 0;
-
-            @Override
-            public void accept(Object obj) {
-                if (_expected != ((Number) obj).longValue()) {
-                    allInOrder.set(false);
-                    System.out.println("Expected " + _expected + " but got " + obj);
+        Assertions.assertTimeoutPreemptively(Duration.ofSeconds(10), () -> {
+            final AtomicBoolean allInOrder = new AtomicBoolean(true);
+
+            JCQueue queue = createQueue("consumerHang", 10, 1024);
+            Runnable producer = new IncProducer(queue, 1024 * 1024, 100);
+            Runnable consumer = new ConsumerThd(queue, new JCQueue.Consumer() {
+                long _expected = 0;
+
+                @Override
+                public void accept(Object obj) {
+                    if (_expected != ((Number) obj).longValue()) {
+                        allInOrder.set(false);
+                        System.out.println("Expected " + _expected + " but got " + obj);
+                    }
+                    _expected++;
                 }
-                _expected++;
-            }
 
-            @Override
-            public void flush() {
-                return;
-            }
-        });
+                @Override
+                public void flush() {
+                    return;
+                }
+            });
 
-        run(producer, consumer, queue, 1000, 1);
-        Assert.assertTrue("Messages delivered out of order",
-                          allInOrder.get());
+            run(producer, consumer, queue, 1000, 1);
+            Assert.assertTrue("Messages delivered out of order",
+                allInOrder.get());
+        });
     }
 
-
     private void run(Runnable producer, Runnable consumer, JCQueue queue)
         throws InterruptedException {
         run(producer, consumer, queue, 20, PRODUCER_NUM);
@@ -161,18 +167,21 @@ public class JCQueueTest {
     }
 
     private static class IncProducer implements Runnable {
+
         private JCQueue queue;
         private long _max;
+        private long min;
 
-        IncProducer(JCQueue queue, long max) {
+        public IncProducer(JCQueue queue, long _max, long min) {
             this.queue = queue;
-            this._max = max;
+            this._max = _max;
+            this.min = min;
         }
 
         @Override
         public void run() {
             try {
-                for (long i = 0; i < _max && !(Thread.currentThread().isInterrupted()); i++) {
+                for (long i = 0; i < _max && (!Thread.currentThread().isInterrupted() || i < min); i++) {
                     queue.publish(i);
                 }
             } catch (InterruptedException e) {
@@ -182,6 +191,7 @@ public class JCQueueTest {
     }
 
     private static class ConsumerThd implements Runnable {
+
         private JCQueue.Consumer handler;
         private JCQueue queue;
 
@@ -192,7 +202,8 @@ public class JCQueueTest {
 
         @Override
         public void run() {
-            while (!Thread.currentThread().isInterrupted()) {
+            //The producers are shut down first, so keep going until the queue is empty.
+            while (!Thread.currentThread().isInterrupted() || queue.size() != 0) {
                 queue.consume(handler);
             }
         }
