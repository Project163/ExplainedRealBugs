diff --git a/storm-client/src/jvm/org/apache/storm/cluster/PaceMakerStateStorage.java b/storm-client/src/jvm/org/apache/storm/cluster/PaceMakerStateStorage.java
index 929534753..bc2cb7456 100644
--- a/storm-client/src/jvm/org/apache/storm/cluster/PaceMakerStateStorage.java
+++ b/storm-client/src/jvm/org/apache/storm/cluster/PaceMakerStateStorage.java
@@ -24,6 +24,7 @@ import org.apache.curator.framework.state.ConnectionStateListener;
 import org.apache.storm.callback.ZKStateChangedCallback;
 import org.apache.storm.generated.*;
 import org.apache.storm.pacemaker.PacemakerClientPool;
+import org.apache.storm.pacemaker.PacemakerConnectionException;
 import org.apache.storm.utils.Utils;
 import org.apache.zookeeper.data.ACL;
 import org.slf4j.Logger;
@@ -123,12 +124,15 @@ public class PaceMakerStateStorage implements IStateStorage {
                 }
                 LOG.debug("Successful set_worker_hb");
                 break;
-            } catch (Exception e) {
+            } catch (HBExecutionException e) {
                 if (retry <= 0) {
-                    throw Utils.wrapInRuntime(e);
+                    throw new RuntimeException(e);
                 }
                 retry--;
                 LOG.error("{} Failed to set_worker_hb. Will make {} more attempts.", e.getMessage(), retry);
+            } catch (InterruptedException e) {
+                LOG.debug("set_worker_hb got interrupted: {}", e);
+                throw new RuntimeException(e);
             }
         }
     }
@@ -165,12 +169,15 @@ public class PaceMakerStateStorage implements IStateStorage {
                     throw new HBExecutionException("Failed to get a response.");
                 }
                 return ret;
-            } catch (Exception e) {
+            } catch (HBExecutionException|PacemakerConnectionException e) {
                 if (retry <= 0) {
-                    throw Utils.wrapInRuntime(e);
+                    throw new RuntimeException(e);
                 }
                 retry--;
                 LOG.error("{} Failed to get_worker_hb. Will make {} more attempts.", e.getMessage(), retry);
+            } catch (InterruptedException e) {
+                LOG.debug("get_worker_hb got interrupted: {}", e);
+                throw new RuntimeException(e);
             }
         }
     }
@@ -194,14 +201,17 @@ public class PaceMakerStateStorage implements IStateStorage {
                     }
                 }
 
-                LOG.debug("Successful get_worker_hb");
+                LOG.debug("Successful get_worker_hb_children");
                 return new ArrayList<>(retSet);
-            } catch (Exception e) {
+            } catch (PacemakerConnectionException e) {
                 if (retry <= 0) {
-                    throw Utils.wrapInRuntime(e);
+                    throw new RuntimeException(e);
                 }
                 retry--;
                 LOG.error("{} Failed to get_worker_hb_children. Will make {} more attempts.", e.getMessage(), retry);
+            } catch (InterruptedException e) {
+                LOG.debug("get_worker_hb_children got interrupted: {}", e);
+                throw new RuntimeException(e);
             }
         }
     }
@@ -231,7 +241,7 @@ public class PaceMakerStateStorage implements IStateStorage {
                 else {
                     throw new HBExecutionException("Failed to delete from all pacemakers.");
                 }
-            } catch (Exception e) {
+            } catch (HBExecutionException|PacemakerConnectionException e) {
                 if (retry <= 0) {
                     if(someSucceeded) {
                         LOG.warn("Unable to delete_worker_hb from every pacemaker.");
@@ -239,11 +249,14 @@ public class PaceMakerStateStorage implements IStateStorage {
                     }
                     else {
                         LOG.error("Unable to delete_worker_hb from any pacemaker.");
-                        throw Utils.wrapInRuntime(e);
+                        throw new RuntimeException(e);
                     }
                 }
                 retry--;
                 LOG.debug("{} Failed to delete_worker_hb. Will make {} more attempts.", e.getMessage(), retry);
+            } catch (InterruptedException e) {
+                LOG.debug("delete_worker_hb got interrupted: {}", e);
+                throw new RuntimeException(e);
             }
         }
     }
diff --git a/storm-client/src/jvm/org/apache/storm/pacemaker/PacemakerClient.java b/storm-client/src/jvm/org/apache/storm/pacemaker/PacemakerClient.java
index bb42d21c8..9e3d20776 100644
--- a/storm-client/src/jvm/org/apache/storm/pacemaker/PacemakerClient.java
+++ b/storm-client/src/jvm/org/apache/storm/pacemaker/PacemakerClient.java
@@ -169,56 +169,48 @@ public class PacemakerClient implements ISaslClient {
         return secret;
     }
 
-    public HBMessage send(HBMessage m) throws PacemakerConnectionException {
+    public HBMessage send(HBMessage m) throws InterruptedException {
         LOG.debug("Sending message: {}", m.toString());
-        try {
-            int next = availableMessageSlots.take();
-            synchronized (m) {
-                m.set_message_id(next);
-                messages[next] = m;
-                LOG.debug("Put message in slot: {}", Integer.toString(next));
-                do {
-                    try {
-                        waitUntilReady();
-                        Channel channel = channelRef.get();
-                        if (channel != null) {
-                            channel.write(m);
-                            m.wait(1000);
-                        }
-                    } catch (Exception exp) {
-                        LOG.error("error attempting to write to a channel {}", exp);
-                    }
-                } while (messages[next] == m);
-            }
 
-            HBMessage ret = messages[next];
-            if(ret == null) {
-                // This can happen if we lost the connection and subsequently reconnected or timed out.
-                send(m);
-            }
-            messages[next] = null;
-            LOG.debug("Got Response: {}", ret);
-            return ret;
+        int next = availableMessageSlots.take();
+        synchronized (m) {
+            m.set_message_id(next);
+            messages[next] = m;
+            LOG.debug("Put message in slot: {}", Integer.toString(next));
+            do {
+                try {
+                    waitUntilReady();
+                    Channel channel = channelRef.get();
+                    if (channel != null) {
+                        channel.write(m);
+                        m.wait(1000);
+                    }
+                } catch (PacemakerConnectionException exp) {
+                    LOG.error("error attempting to write to a channel {}", exp);
+                }
+            } while (messages[next] == m);
         }
-        catch (InterruptedException e) {
-            LOG.error("PacemakerClient send interrupted: ", e);
-            throw new RuntimeException(e);
+
+        HBMessage ret = messages[next];
+        if(ret == null) {
+            // This can happen if we lost the connection and subsequently reconnected or timed out.
+            send(m);
         }
+        messages[next] = null;
+        LOG.debug("Got Response: {}", ret);
+        return ret;
+
     }
 
-    private void waitUntilReady() throws PacemakerConnectionException {
+    private void waitUntilReady() throws PacemakerConnectionException, InterruptedException {
         // Wait for 'ready' (channel connected and maybe authentication)
         if(!ready.get() || channelRef.get() == null) {
             synchronized(this) {
                 if(!ready.get()) {
                     LOG.debug("Waiting for netty channel to be ready.");
-                    try {
-                        this.wait(1000);
-                        if(!ready.get() || channelRef.get() == null) {
-                            throw new PacemakerConnectionException("Timed out waiting for channel ready.");
-                        }
-                    } catch (InterruptedException e) {
-                        throw new RuntimeException(e);
+                    this.wait(1000);
+                    if(!ready.get() || channelRef.get() == null) {
+                        throw new PacemakerConnectionException("Timed out waiting for channel ready.");
                     }
                 }
             }
diff --git a/storm-client/src/jvm/org/apache/storm/pacemaker/PacemakerClientPool.java b/storm-client/src/jvm/org/apache/storm/pacemaker/PacemakerClientPool.java
index 0069b590f..bd5b137d1 100644
--- a/storm-client/src/jvm/org/apache/storm/pacemaker/PacemakerClientPool.java
+++ b/storm-client/src/jvm/org/apache/storm/pacemaker/PacemakerClientPool.java
@@ -54,25 +54,17 @@ public class PacemakerClientPool {
         }
     }
     
-    public HBMessage send(HBMessage m) throws PacemakerConnectionException {
-        try {
+    public HBMessage send(HBMessage m) throws InterruptedException {
             return getWriteClient().send(m);
-        } catch (Exception e) {
-            rotateClients();
-            throw e;
-        }
     }
 
-    public List<HBMessage> sendAll(HBMessage m) throws PacemakerConnectionException {
+    public List<HBMessage> sendAll(HBMessage m) throws PacemakerConnectionException, InterruptedException {
         List<HBMessage> responses = new ArrayList<HBMessage>();
         LOG.debug("Using servers: {}", servers);
         for(String s : servers) {
-            try {
-                HBMessage response = getClientForServer(s).send(m);
-                responses.add(response);
-            } catch (PacemakerConnectionException e) {
-                LOG.error("Failed to send message to Pacemaker " + s + " " + e.getMessage());
-            }
+            HBMessage response = getClientForServer(s).send(m);
+            responses.add(response);
+
         }
         if(responses.size() == 0) {
             throw new PacemakerConnectionException("Failed to connect to any Pacemaker.");
@@ -87,17 +79,6 @@ public class PacemakerClientPool {
         }
     }
 
-    private void rotateClients() {
-        PacemakerClient c = getWriteClient();
-        String server = servers.peek();
-        // Servers should be rotated **BEFORE** the old client is removed from clientForServer
-        // or a race with getWriteClient() could cause it to be put back in the map.
-        servers.add(servers.remove());
-        clientForServer.remove(server);   
-        c.shutdown();
-        c.close();
-    }
-
     private PacemakerClient getWriteClient() {
         return getClientForServer(servers.peek());
     }
