diff --git a/storm-client/src/jvm/org/apache/storm/blobstore/BlobStoreAclHandler.java b/storm-client/src/jvm/org/apache/storm/blobstore/BlobStoreAclHandler.java
index 1c7c2da5e..85de6b0e6 100644
--- a/storm-client/src/jvm/org/apache/storm/blobstore/BlobStoreAclHandler.java
+++ b/storm-client/src/jvm/org/apache/storm/blobstore/BlobStoreAclHandler.java
@@ -31,6 +31,7 @@ import org.apache.storm.security.auth.AuthUtils;
 import org.apache.storm.security.auth.IGroupMappingServiceProvider;
 import org.apache.storm.security.auth.IPrincipalToLocal;
 import org.apache.storm.security.auth.NimbusPrincipal;
+import org.apache.storm.utils.WrappedAuthorizationException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -172,7 +173,7 @@ public class BlobStoreAclHandler {
         if (duplicateUsers.size() > 0) {
             String errorMessage = "user " + Arrays.toString(duplicateUsers.toArray())
                                   + " can't appear more than once in the ACLs for key [" + key + "].";
-            throw new AuthorizationException(errorMessage);
+            throw new WrappedAuthorizationException(errorMessage);
         }
     }
 
@@ -249,7 +250,7 @@ public class BlobStoreAclHandler {
     }
 
     /**
-     * The user should be able to see the metadata if and only if they have any of READ, WRITE, or ADMIN
+     * The user should be able to see the metadata if and only if they have any of READ, WRITE, or ADMIN.
      */
     public void validateUserCanReadMeta(List<AccessControl> acl, Subject who, String key) throws AuthorizationException {
         hasAnyPermissions(acl, (READ | WRITE | ADMIN), who, key);
@@ -281,7 +282,7 @@ public class BlobStoreAclHandler {
                 return;
             }
         }
-        throw new AuthorizationException(
+        throw new WrappedAuthorizationException(
             user + " does not have access to " + key);
     }
 
@@ -312,7 +313,7 @@ public class BlobStoreAclHandler {
         if (mask == 0) {
             return;
         }
-        throw new AuthorizationException(
+        throw new WrappedAuthorizationException(
             user + " does not have " + namedPerms(mask) + " access to " + key);
     }
 
@@ -354,8 +355,8 @@ public class BlobStoreAclHandler {
         List<AccessControl> resultAcl = new ArrayList<AccessControl>();
         for (AccessControl control : accessControls) {
             if (control.get_type().equals(AccessControlType.OTHER) && (control.get_access() == 0)) {
-                LOG.debug("Removing invalid blobstore world ACL " +
-                          BlobStoreAclHandler.accessControlToString(control));
+                LOG.debug("Removing invalid blobstore world ACL "
+                          + BlobStoreAclHandler.accessControlToString(control));
                 continue;
             }
             resultAcl.add(control);
diff --git a/storm-client/src/jvm/org/apache/storm/cluster/PaceMakerStateStorage.java b/storm-client/src/jvm/org/apache/storm/cluster/PaceMakerStateStorage.java
index 54d3f91d0..b7ab63928 100644
--- a/storm-client/src/jvm/org/apache/storm/cluster/PaceMakerStateStorage.java
+++ b/storm-client/src/jvm/org/apache/storm/cluster/PaceMakerStateStorage.java
@@ -32,6 +32,7 @@ import org.apache.storm.generated.HBServerMessageType;
 import org.apache.storm.pacemaker.PacemakerClientPool;
 import org.apache.storm.pacemaker.PacemakerConnectionException;
 import org.apache.storm.utils.Utils;
+import org.apache.storm.utils.WrappedHBExecutionException;
 import org.apache.zookeeper.data.ACL;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -125,7 +126,7 @@ public class PaceMakerStateStorage implements IStateStorage {
                 HBMessage message = new HBMessage(HBServerMessageType.SEND_PULSE, HBMessageData.pulse(hbPulse));
                 HBMessage response = pacemakerClientPool.send(message);
                 if (response.get_type() != HBServerMessageType.SEND_PULSE_RESPONSE) {
-                    throw new HBExecutionException("Invalid Response Type");
+                    throw new WrappedHBExecutionException("Invalid Response Type");
                 }
                 LOG.debug("Successful set_worker_hb");
                 break;
@@ -171,7 +172,7 @@ public class PaceMakerStateStorage implements IStateStorage {
                     }
                 }
                 if (!got_response) {
-                    throw new HBExecutionException("Failed to get a response.");
+                    throw new WrappedHBExecutionException("Failed to get a response.");
                 }
                 return ret;
             } catch (HBExecutionException | PacemakerConnectionException e) {
@@ -242,7 +243,7 @@ public class PaceMakerStateStorage implements IStateStorage {
                 if (allSucceeded) {
                     break;
                 } else {
-                    throw new HBExecutionException("Failed to delete from all pacemakers.");
+                    throw new WrappedHBExecutionException("Failed to delete from all pacemakers.");
                 }
             } catch (HBExecutionException | PacemakerConnectionException e) {
                 if (retry <= 0) {
diff --git a/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java b/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java
index 3b9373960..e3b60c2a0 100644
--- a/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java
+++ b/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java
@@ -48,6 +48,7 @@ import org.apache.storm.tuple.Fields;
 import org.apache.storm.utils.ConfigUtils;
 import org.apache.storm.utils.ObjectReader;
 import org.apache.storm.utils.Utils;
+import org.apache.storm.utils.WrappedInvalidTopologyException;
 import org.json.simple.JSONValue;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -99,7 +100,7 @@ public class StormCommon {
         Set<String> keys = componentMap.keySet();
         for (String id : keys) {
             if (Utils.isSystemId(id)) {
-                throw new InvalidTopologyException(id + " is not a valid component id.");
+                throw new WrappedInvalidTopologyException(id + " is not a valid component id.");
             }
         }
         for (Object componentObj : componentMap.values()) {
@@ -107,7 +108,7 @@ public class StormCommon {
             Set<String> streamIds = common.get_streams().keySet();
             for (String id : streamIds) {
                 if (Utils.isSystemId(id)) {
-                    throw new InvalidTopologyException(id + " is not a valid stream id.");
+                    throw new WrappedInvalidTopologyException(id + " is not a valid stream id.");
                 }
             }
         }
@@ -122,7 +123,7 @@ public class StormCommon {
 
         List<String> offending = Utils.getRepeat(componentIds);
         if (!offending.isEmpty()) {
-            throw new InvalidTopologyException("Duplicate component ids: " + offending);
+            throw new WrappedInvalidTopologyException("Duplicate component ids: " + offending);
         }
     }
 
@@ -166,7 +167,7 @@ public class StormCommon {
                 for (Object obj : spoutComponents.values()) {
                     ComponentCommon common = getComponentCommon(obj);
                     if (!isEmptyInputs(common)) {
-                        throw new InvalidTopologyException("May not declare inputs for a spout");
+                        throw new WrappedInvalidTopologyException("May not declare inputs for a spout");
                     }
                 }
             }
@@ -179,7 +180,8 @@ public class StormCommon {
             int parallelismHintNum = Thrift.getParallelismHint(common);
             Integer taskNum = ObjectReader.getInt(conf.get(Config.TOPOLOGY_TASKS), 0);
             if (taskNum > 0 && parallelismHintNum <= 0) {
-                throw new InvalidTopologyException("Number of executors must be greater than 0 when number of tasks is greater than 0");
+                throw new WrappedInvalidTopologyException(
+                        "Number of executors must be greater than 0 when number of tasks is greater than 0");
             }
         }
     }
@@ -202,15 +204,15 @@ public class StormCommon {
                 String sourceStreamId = input.getKey().get_streamId();
                 String sourceComponentId = input.getKey().get_componentId();
                 if (!componentMap.keySet().contains(sourceComponentId)) {
-                    throw new InvalidTopologyException("Component: [" + componentId +
-                                                       "] subscribes from non-existent component [" + sourceComponentId + "]");
+                    throw new WrappedInvalidTopologyException("Component: [" + componentId
+                                                       + "] subscribes from non-existent component [" + sourceComponentId + "]");
                 }
 
                 ComponentCommon sourceComponent = getComponentCommon(componentMap.get(sourceComponentId));
                 if (!sourceComponent.get_streams().containsKey(sourceStreamId)) {
-                    throw new InvalidTopologyException("Component: [" + componentId +
-                                                       "] subscribes from non-existent stream: " +
-                                                       "[" + sourceStreamId + "] of component [" + sourceComponentId + "]");
+                    throw new WrappedInvalidTopologyException("Component: [" + componentId
+                                                       + "] subscribes from non-existent stream: "
+                                                       + "[" + sourceStreamId + "] of component [" + sourceComponentId + "]");
                 }
 
                 Grouping grouping = input.getValue();
@@ -220,9 +222,9 @@ public class StormCommon {
                     Set<String> sourceOutputFields = getStreamOutputFields(streams);
                     fields.removeAll(sourceOutputFields);
                     if (fields.size() != 0) {
-                        throw new InvalidTopologyException("Component: [" + componentId +
-                                                           "] subscribes from stream: [" + sourceStreamId + "] of component " +
-                                                           "[" + sourceComponentId + "] + with non-existent fields: " + fields);
+                        throw new WrappedInvalidTopologyException("Component: [" + componentId
+                                                           + "] subscribes from stream: [" + sourceStreamId + "] of component "
+                                                           + "[" + sourceComponentId + "] + with non-existent fields: " + fields);
                     }
                 }
             }
diff --git a/storm-client/src/jvm/org/apache/storm/utils/Utils.java b/storm-client/src/jvm/org/apache/storm/utils/Utils.java
index 5cad54539..6b1e08be6 100644
--- a/storm-client/src/jvm/org/apache/storm/utils/Utils.java
+++ b/storm-client/src/jvm/org/apache/storm/utils/Utils.java
@@ -347,8 +347,7 @@ public class Utils {
                     final Callable<Long> fn = isFactory ? (Callable<Long>) afn.call() : afn;
                     while (true) {
                         final Long s = fn.call();
-                        if (s == null) // then stop running it
-                        {
+                        if (s == null) { // then stop running it
                             break;
                         }
                         if (s > 0) {
@@ -413,7 +412,7 @@ public class Utils {
     }
 
     /**
-     * Checks if a throwable is an instance of a particular class
+     * Checks if a throwable is an instance of a particular class.
      *
      * @param klass     The class you're expecting
      * @param throwable The throwable you expect to be an instance of klass
@@ -1145,7 +1144,7 @@ public class Utils {
                     client.getBlobMeta(key);
                 } catch (KeyNotFoundException keyNotFound) {
                     // wrap KeyNotFoundException in an InvalidTopologyException
-                    throw new InvalidTopologyException("Key not found: " + keyNotFound.get_msg());
+                    throw new WrappedInvalidTopologyException("Key not found: " + keyNotFound.get_msg());
                 }
             }
         }
@@ -1169,7 +1168,7 @@ public class Utils {
                     blobStore.getBlobMeta(key, subject);
                 } catch (KeyNotFoundException keyNotFound) {
                     // wrap KeyNotFoundException in an InvalidTopologyException
-                    throw new InvalidTopologyException("Key not found: " + keyNotFound.get_msg());
+                    throw new WrappedInvalidTopologyException("Key not found: " + keyNotFound.get_msg());
                 }
             }
         }
@@ -1255,7 +1254,7 @@ public class Utils {
     }
 
     /**
-     * a or b the first one that is not null
+     * a or b the first one that is not null.
      *
      * @param a something
      * @param b something else
@@ -1408,16 +1407,16 @@ public class Utils {
     }
 
     /**
-     * Add version information to the given topology
+     * Add version information to the given topology.
      *
      * @param topology the topology being submitted (MIGHT BE MODIFIED)
      * @return topology
      */
     public static StormTopology addVersions(StormTopology topology) {
         String stormVersion = VersionInfo.getVersion();
-        if (stormVersion != null &&
-            !"Unknown".equalsIgnoreCase(stormVersion) &&
-            !topology.is_set_storm_version()) {
+        if (stormVersion != null
+            && !"Unknown".equalsIgnoreCase(stormVersion)
+            && !topology.is_set_storm_version()) {
             topology.set_storm_version(stormVersion);
         }
 
diff --git a/storm-client/src/jvm/org/apache/storm/utils/WrappedAlreadyAliveException.java b/storm-client/src/jvm/org/apache/storm/utils/WrappedAlreadyAliveException.java
new file mode 100644
index 000000000..1b39a7bca
--- /dev/null
+++ b/storm-client/src/jvm/org/apache/storm/utils/WrappedAlreadyAliveException.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.storm.utils;
+
+import org.apache.storm.generated.AlreadyAliveException;
+
+/**
+ * Wraps the generated TException to allow getMessage() to return a valid string.
+ */
+public class WrappedAlreadyAliveException extends AlreadyAliveException {
+    public WrappedAlreadyAliveException(String msg) {
+        super(msg);
+    }
+
+    @Override
+    public String getMessage() {
+        return this.get_msg();
+    }
+}
diff --git a/storm-client/src/jvm/org/apache/storm/utils/WrappedAuthorizationException.java b/storm-client/src/jvm/org/apache/storm/utils/WrappedAuthorizationException.java
new file mode 100644
index 000000000..7711901af
--- /dev/null
+++ b/storm-client/src/jvm/org/apache/storm/utils/WrappedAuthorizationException.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.storm.utils;
+
+import org.apache.storm.generated.AuthorizationException;
+
+/**
+ * Wraps the generated TException to allow getMessage() to return a valid string.
+ */
+public class WrappedAuthorizationException extends AuthorizationException {
+    public WrappedAuthorizationException(String msg) {
+        super(msg);
+    }
+
+    @Override
+    public String getMessage() {
+        return this.get_msg();
+    }
+}
diff --git a/storm-client/src/jvm/org/apache/storm/utils/WrappedDRPCExecutionException.java b/storm-client/src/jvm/org/apache/storm/utils/WrappedDRPCExecutionException.java
new file mode 100644
index 000000000..afa01a0b8
--- /dev/null
+++ b/storm-client/src/jvm/org/apache/storm/utils/WrappedDRPCExecutionException.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.storm.utils;
+
+import org.apache.storm.generated.DRPCExecutionException;
+
+/**
+ * Wraps the generated TException to allow getMessage() to return a valid string.
+ */
+public class WrappedDRPCExecutionException extends DRPCExecutionException {
+    public WrappedDRPCExecutionException(String msg) {
+        super(msg);
+    }
+
+    @Override
+    public String getMessage() {
+        return this.get_msg();
+    }
+}
diff --git a/storm-client/src/jvm/org/apache/storm/utils/WrappedHBExecutionException.java b/storm-client/src/jvm/org/apache/storm/utils/WrappedHBExecutionException.java
new file mode 100644
index 000000000..ab976c008
--- /dev/null
+++ b/storm-client/src/jvm/org/apache/storm/utils/WrappedHBExecutionException.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.storm.utils;
+
+import org.apache.storm.generated.HBExecutionException;
+
+/**
+ * Wraps the generated TException to allow getMessage() to return a valid string.
+ */
+public class WrappedHBExecutionException extends HBExecutionException {
+    public WrappedHBExecutionException(String msg) {
+        super(msg);
+    }
+
+    @Override
+    public String getMessage() {
+        return this.get_msg();
+    }
+}
diff --git a/storm-client/src/jvm/org/apache/storm/utils/WrappedInvalidTopologyException.java b/storm-client/src/jvm/org/apache/storm/utils/WrappedInvalidTopologyException.java
new file mode 100644
index 000000000..367f449b3
--- /dev/null
+++ b/storm-client/src/jvm/org/apache/storm/utils/WrappedInvalidTopologyException.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.storm.utils;
+
+import org.apache.storm.generated.InvalidTopologyException;
+
+/**
+ * Wraps the generated TException to allow getMessage() to return a valid string.
+ */
+public class WrappedInvalidTopologyException extends InvalidTopologyException {
+    public WrappedInvalidTopologyException(String msg) {
+        super(msg);
+    }
+
+    @Override
+    public String getMessage() {
+        return this.get_msg();
+    }
+}
diff --git a/storm-client/src/jvm/org/apache/storm/utils/WrappedKeyAlreadyExistsException.java b/storm-client/src/jvm/org/apache/storm/utils/WrappedKeyAlreadyExistsException.java
new file mode 100644
index 000000000..fbe479f81
--- /dev/null
+++ b/storm-client/src/jvm/org/apache/storm/utils/WrappedKeyAlreadyExistsException.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.storm.utils;
+
+import org.apache.storm.generated.KeyAlreadyExistsException;
+
+/**
+ * Wraps the generated TException to allow getMessage() to return a valid string.
+ */
+public class WrappedKeyAlreadyExistsException extends KeyAlreadyExistsException {
+    public WrappedKeyAlreadyExistsException(String msg) {
+        super(msg);
+    }
+
+    @Override
+    public String getMessage() {
+        return this.get_msg();
+    }
+}
diff --git a/storm-client/src/jvm/org/apache/storm/utils/WrappedKeyNotFoundException.java b/storm-client/src/jvm/org/apache/storm/utils/WrappedKeyNotFoundException.java
new file mode 100644
index 000000000..067b63ea8
--- /dev/null
+++ b/storm-client/src/jvm/org/apache/storm/utils/WrappedKeyNotFoundException.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.storm.utils;
+
+import org.apache.storm.generated.KeyNotFoundException;
+
+/**
+ * Wraps the generated TException to allow getMessage() to return a valid string.
+ */
+public class WrappedKeyNotFoundException extends KeyNotFoundException {
+    public WrappedKeyNotFoundException(String msg) {
+        super(msg);
+    }
+
+    @Override
+    public String getMessage() {
+        return this.get_msg();
+    }
+}
+
+
diff --git a/storm-client/src/jvm/org/apache/storm/utils/WrappedNotAliveException.java b/storm-client/src/jvm/org/apache/storm/utils/WrappedNotAliveException.java
new file mode 100644
index 000000000..efcdb51f3
--- /dev/null
+++ b/storm-client/src/jvm/org/apache/storm/utils/WrappedNotAliveException.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.storm.utils;
+
+import org.apache.storm.generated.NotAliveException;
+
+/**
+ * Wraps the generated TException to allow getMessage() to return a valid string.
+ */
+public class WrappedNotAliveException extends NotAliveException {
+    public WrappedNotAliveException(String msg) {
+        super(msg);
+    }
+
+    @Override
+    public String getMessage() {
+        return this.get_msg();
+    }
+}
