diff --git a/storm-client/src/jvm/org/apache/storm/messaging/netty/StormServerHandler.java b/storm-client/src/jvm/org/apache/storm/messaging/netty/StormServerHandler.java
index 55e70588f..3c256bb35 100644
--- a/storm-client/src/jvm/org/apache/storm/messaging/netty/StormServerHandler.java
+++ b/storm-client/src/jvm/org/apache/storm/messaging/netty/StormServerHandler.java
@@ -26,7 +26,7 @@ import org.slf4j.LoggerFactory;
 
 public class StormServerHandler extends ChannelInboundHandlerAdapter {
     private static final Logger LOG = LoggerFactory.getLogger(StormServerHandler.class);
-    private static final Set<Class> ALLOWED_EXCEPTIONS = new HashSet<>(Arrays.asList(new Class[]{ IOException.class }));
+    private static final Set<Class<?>> ALLOWED_EXCEPTIONS = new HashSet<>(Arrays.asList(new Class<?>[]{ IOException.class }));
     private final IServer server;
     private final AtomicInteger failure_count;
 
diff --git a/storm-client/src/jvm/org/apache/storm/nimbus/ILeaderElector.java b/storm-client/src/jvm/org/apache/storm/nimbus/ILeaderElector.java
index 3fdb40722..f0d877f7b 100644
--- a/storm-client/src/jvm/org/apache/storm/nimbus/ILeaderElector.java
+++ b/storm-client/src/jvm/org/apache/storm/nimbus/ILeaderElector.java
@@ -12,7 +12,6 @@
 
 package org.apache.storm.nimbus;
 
-import java.io.Closeable;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
@@ -21,7 +20,7 @@ import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;
 /**
  * The interface for leader election.
  */
-public interface ILeaderElector extends Closeable {
+public interface ILeaderElector extends AutoCloseable {
 
     /**
      * Method guaranteed to be called as part of initialization of leader elector instance.
@@ -37,11 +36,11 @@ public interface ILeaderElector extends Closeable {
     void addToLeaderLockQueue() throws Exception;
 
     /**
-     * Removes the caller from the leader lock queue. If the caller is leader
-     * also releases the lock. This method can be called multiple times so it needs
-     * to be idempotent.
+     * Removes the caller from leadership election, relinquishing leadership if acquired, then requeues for leadership after the specified
+     * delay.
+     * @param delayMs The delay to wait before re-entering the election
      */
-    void removeFromLeaderLockQueue() throws Exception;
+    void quitElectionFor(int delayMs) throws Exception;
 
     /**
      * Decide if the caller currently has the leader lock.
@@ -51,7 +50,7 @@ public interface ILeaderElector extends Closeable {
 
     /**
      * Get the current leader's address.
-     * @return the current leader's address , may return null if no one has the lock.
+     * @return the current leader's address, may return null if no one has the lock.
      */
     NimbusInfo getLeader();
     
@@ -71,9 +70,9 @@ public interface ILeaderElector extends Closeable {
     List<NimbusInfo> getAllNimbuses() throws Exception;
 
     /**
-     * Method called to allow for cleanup. once close this object can not be reused.
+     * Method called to allow for cleanup. Relinquishes leadership if owned by the caller.
      */
     @Override
-    void close();
+    void close() throws Exception;
 }
 
diff --git a/storm-client/src/jvm/org/apache/storm/utils/Utils.java b/storm-client/src/jvm/org/apache/storm/utils/Utils.java
index 102720f41..8d15fc24e 100644
--- a/storm-client/src/jvm/org/apache/storm/utils/Utils.java
+++ b/storm-client/src/jvm/org/apache/storm/utils/Utils.java
@@ -33,6 +33,7 @@ import java.io.ObjectOutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Serializable;
 import java.io.UnsupportedEncodingException;
+import java.lang.Thread.UncaughtExceptionHandler;
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadInfo;
 import java.net.InetAddress;
@@ -110,7 +111,7 @@ import org.slf4j.LoggerFactory;
 public class Utils {
     public static final Logger LOG = LoggerFactory.getLogger(Utils.class);
     public static final String DEFAULT_STREAM_ID = "default";
-    private static final Set<Class> defaultAllowedExceptions = new HashSet<>();
+    private static final Set<Class<?>> defaultAllowedExceptions = Collections.emptySet();
     private static final List<String> LOCALHOST_ADDRESSES = Lists.newArrayList("localhost", "127.0.0.1", "0:0:0:0:0:0:0:1");
     static SerializationDelegate serializationDelegate;
     private static ThreadLocal<TSerializer> threadSer = new ThreadLocal<TSerializer>();
@@ -625,7 +626,7 @@ public class Utils {
         handleUncaughtException(t, defaultAllowedExceptions);
     }
 
-    public static void handleUncaughtException(Throwable t, Set<Class> allowedExceptions) {
+    public static void handleUncaughtException(Throwable t, Set<Class<?>> allowedExceptions) {
         if (t != null) {
             if (t instanceof OutOfMemoryError) {
                 try {
@@ -975,17 +976,19 @@ public class Utils {
         return m;
     }
 
-    public static void setupDefaultUncaughtExceptionHandler() {
-        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-            public void uncaughtException(Thread thread, Throwable thrown) {
-                try {
-                    handleUncaughtException(thrown);
-                } catch (Error err) {
-                    LOG.error("Received error in main thread.. terminating server...", err);
-                    Runtime.getRuntime().exit(-2);
-                }
+    public static UncaughtExceptionHandler createDefaultUncaughtExceptionHandler() {
+        return (thread, thrown) -> {
+            try {
+                handleUncaughtException(thrown);
+            } catch (Error err) {
+                LOG.error("Received error in thread {}.. terminating server...", thread.getName(), err);
+                Runtime.getRuntime().exit(-2);
             }
-        });
+        };
+    }
+    
+    public static void setupDefaultUncaughtExceptionHandler() {
+        Thread.setDefaultUncaughtExceptionHandler(createDefaultUncaughtExceptionHandler());
     }
 
     public static Map<String, Object> findAndReadConfigFile(String name) {
