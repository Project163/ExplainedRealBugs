diff --git a/storm-client/pom.xml b/storm-client/pom.xml
index 30d7685d6..538b7b910 100644
--- a/storm-client/pom.xml
+++ b/storm-client/pom.xml
@@ -187,7 +187,12 @@
         </dependency>
         <dependency>
             <groupId>org.mockito</groupId>
-            <artifactId>mockito-all</artifactId>
+            <artifactId>mockito-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.hamcrest</groupId>
+            <artifactId>hamcrest-library</artifactId>
             <scope>test</scope>
         </dependency>
     </dependencies>
diff --git a/storm-client/src/jvm/org/apache/storm/topology/WindowedBoltExecutor.java b/storm-client/src/jvm/org/apache/storm/topology/WindowedBoltExecutor.java
index 2ada9bf89..56c329ee3 100644
--- a/storm-client/src/jvm/org/apache/storm/topology/WindowedBoltExecutor.java
+++ b/storm-client/src/jvm/org/apache/storm/topology/WindowedBoltExecutor.java
@@ -199,8 +199,7 @@ public class WindowedBoltExecutor implements IRichBolt {
         // validate
         validate(topoConf, windowLengthCount, windowLengthDuration,
                  slidingIntervalCount, slidingIntervalDuration);
-        evictionPolicy = getEvictionPolicy(windowLengthCount, windowLengthDuration,
-                                                                 manager);
+        evictionPolicy = getEvictionPolicy(windowLengthCount, windowLengthDuration);
         triggerPolicy = getTriggerPolicy(slidingIntervalCount, slidingIntervalDuration,
                                                               manager, evictionPolicy);
         manager.setEvictionPolicy(evictionPolicy);
@@ -251,8 +250,7 @@ public class WindowedBoltExecutor implements IRichBolt {
         }
     }
 
-    private EvictionPolicy<Tuple> getEvictionPolicy(Count windowLengthCount, Duration windowLengthDuration,
-                                                    WindowManager<Tuple> manager) {
+    private EvictionPolicy<Tuple> getEvictionPolicy(Count windowLengthCount, Duration windowLengthDuration) {
         if (windowLengthCount != null) {
             if (isTupleTs()) {
                 return new WatermarkCountEvictionPolicy<>(windowLengthCount.value);
diff --git a/storm-client/src/jvm/org/apache/storm/windowing/EvictionContext.java b/storm-client/src/jvm/org/apache/storm/windowing/EvictionContext.java
index 37dcfd90c..ee5fdb90e 100644
--- a/storm-client/src/jvm/org/apache/storm/windowing/EvictionContext.java
+++ b/storm-client/src/jvm/org/apache/storm/windowing/EvictionContext.java
@@ -38,7 +38,7 @@ public interface EvictionContext {
     Long getSlidingCount();
 
     /**
-     * Returns the current count of events in the queue up to the reference tim
+     * Returns the current count of events in the queue up to the reference time
      * based on which count based evictions can be performed.
      *
      * @return the current count
diff --git a/storm-client/src/jvm/org/apache/storm/windowing/EvictionPolicy.java b/storm-client/src/jvm/org/apache/storm/windowing/EvictionPolicy.java
index 774d0a371..fa4444404 100644
--- a/storm-client/src/jvm/org/apache/storm/windowing/EvictionPolicy.java
+++ b/storm-client/src/jvm/org/apache/storm/windowing/EvictionPolicy.java
@@ -27,7 +27,7 @@ public interface EvictionPolicy<T> {
     /**
      * The action to be taken when {@link EvictionPolicy#evict(Event)} is invoked.
      */
-    enum Action {
+    public enum Action {
         /**
          * expire the event and remove it from the queue
          */
diff --git a/storm-client/src/jvm/org/apache/storm/windowing/TimeEvictionPolicy.java b/storm-client/src/jvm/org/apache/storm/windowing/TimeEvictionPolicy.java
index 802e6bb42..570b05779 100644
--- a/storm-client/src/jvm/org/apache/storm/windowing/TimeEvictionPolicy.java
+++ b/storm-client/src/jvm/org/apache/storm/windowing/TimeEvictionPolicy.java
@@ -38,7 +38,7 @@ public class TimeEvictionPolicy<T> implements EvictionPolicy<T> {
      * {@inheritDoc}
      */
     @Override
-    public Action evict(Event<T> event) {
+    public Action evict(Event<T> event) {      
         long now = evictionContext == null ? System.currentTimeMillis() : evictionContext.getReferenceTime();
         long diff = now - event.getTimestamp();
         if (diff >= windowLength) {
diff --git a/storm-client/src/jvm/org/apache/storm/windowing/TimeTriggerPolicy.java b/storm-client/src/jvm/org/apache/storm/windowing/TimeTriggerPolicy.java
index b057afb50..6b6d9fa58 100644
--- a/storm-client/src/jvm/org/apache/storm/windowing/TimeTriggerPolicy.java
+++ b/storm-client/src/jvm/org/apache/storm/windowing/TimeTriggerPolicy.java
@@ -114,9 +114,7 @@ public class TimeTriggerPolicy<T> implements TriggerPolicy<T> {
                      * set the current timestamp as the reference time for the eviction policy
                      * to evict the events
                      */
-                    if (evictionPolicy != null) {
-                        evictionPolicy.setContext(new DefaultEvictionContext(System.currentTimeMillis()));
-                    }
+                    evictionPolicy.setContext(new DefaultEvictionContext(System.currentTimeMillis()));
                     handler.onTrigger();
                 } catch (Throwable th) {
                     LOG.error("handler.onTrigger failed ", th);
diff --git a/storm-client/src/jvm/org/apache/storm/windowing/WaterMarkEventGenerator.java b/storm-client/src/jvm/org/apache/storm/windowing/WaterMarkEventGenerator.java
index e1df72c39..ef81d6ee3 100644
--- a/storm-client/src/jvm/org/apache/storm/windowing/WaterMarkEventGenerator.java
+++ b/storm-client/src/jvm/org/apache/storm/windowing/WaterMarkEventGenerator.java
@@ -77,7 +77,7 @@ public class WaterMarkEventGenerator<T> implements Runnable {
         try {
             long waterMarkTs = computeWaterMarkTs();
             if (waterMarkTs > lastWaterMarkTs) {
-                this.windowManager.add(new WaterMarkEvent<T>(waterMarkTs));
+                this.windowManager.add(new WaterMarkEvent<>(waterMarkTs));
                 lastWaterMarkTs = waterMarkTs;
             }
         } catch (Throwable th) {
diff --git a/storm-client/src/jvm/org/apache/storm/windowing/WatermarkCountEvictionPolicy.java b/storm-client/src/jvm/org/apache/storm/windowing/WatermarkCountEvictionPolicy.java
index c5d7b4963..0fe6f753b 100644
--- a/storm-client/src/jvm/org/apache/storm/windowing/WatermarkCountEvictionPolicy.java
+++ b/storm-client/src/jvm/org/apache/storm/windowing/WatermarkCountEvictionPolicy.java
@@ -19,7 +19,7 @@ package org.apache.storm.windowing;
 
 /**
  * An eviction policy that tracks count based on watermark ts and
- * evicts events upto the watermark based on a threshold count.
+ * evicts events up to the watermark based on a threshold count.
  *
  * @param <T> the type of event tracked by this policy.
  */
@@ -32,6 +32,13 @@ public class WatermarkCountEvictionPolicy<T> extends CountEvictionPolicy<T> {
 
     @Override
     public Action evict(Event<T> event) {
+        if(getContext() == null) {
+            //It is possible to get asked about eviction before we have a context, due to WindowManager.compactWindow.
+            //In this case we should hold on to all the events. When the first watermark is received, the context will be set,
+            //and the events will be reevaluated for eviction
+            return Action.STOP;
+        }
+        
         Action action;
         if (event.getTimestamp() <= getContext().getReferenceTime() && processed < currentCount.get()) {
             action = super.evict(event);
diff --git a/storm-client/src/jvm/org/apache/storm/windowing/WatermarkTimeEvictionPolicy.java b/storm-client/src/jvm/org/apache/storm/windowing/WatermarkTimeEvictionPolicy.java
index e5ecba471..fdb391758 100644
--- a/storm-client/src/jvm/org/apache/storm/windowing/WatermarkTimeEvictionPolicy.java
+++ b/storm-client/src/jvm/org/apache/storm/windowing/WatermarkTimeEvictionPolicy.java
@@ -57,7 +57,14 @@ public class WatermarkTimeEvictionPolicy<T> extends TimeEvictionPolicy<T> {
      */
     @Override
     public Action evict(Event<T> event) {
-        long referenceTime = evictionContext.getReferenceTime() != null ? evictionContext.getReferenceTime() : 0L;
+        if(evictionContext == null) {
+            //It is possible to get asked about eviction before we have a context, due to WindowManager.compactWindow.
+            //In this case we should hold on to all the events. When the first watermark is received, the context will be set,
+            //and the events will be reevaluated for eviction
+            return Action.STOP;
+        }
+        
+        long referenceTime = evictionContext.getReferenceTime();
         long diff =  referenceTime - event.getTimestamp();
         if (diff < -lag) {
             return Action.STOP;
diff --git a/storm-client/src/jvm/org/apache/storm/windowing/WindowManager.java b/storm-client/src/jvm/org/apache/storm/windowing/WindowManager.java
index 8021ba837..f6cc52159 100644
--- a/storm-client/src/jvm/org/apache/storm/windowing/WindowManager.java
+++ b/storm-client/src/jvm/org/apache/storm/windowing/WindowManager.java
@@ -46,6 +46,9 @@ public class WindowManager<T> implements TriggerHandler {
     /**
      * Expire old events every EXPIRE_EVENTS_THRESHOLD to
      * keep the window size in check.
+     * 
+     * Note that if the eviction policy is based on watermarks, events will not be evicted until a new
+     * watermark would cause them to be considered expired anyway, regardless of this limit
      */
     public static final int EXPIRE_EVENTS_THRESHOLD = 100;
 
diff --git a/storm-client/test/jvm/org/apache/storm/windowing/WindowManagerTest.java b/storm-client/test/jvm/org/apache/storm/windowing/WindowManagerTest.java
index 6c170c64b..178c1bb0e 100644
--- a/storm-client/test/jvm/org/apache/storm/windowing/WindowManagerTest.java
+++ b/storm-client/test/jvm/org/apache/storm/windowing/WindowManagerTest.java
@@ -29,9 +29,12 @@ import java.util.List;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
-import static org.apache.storm.topology.base.BaseWindowedBolt.Count;
 import static org.apache.storm.topology.base.BaseWindowedBolt.Duration;
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.empty;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
 /**
@@ -155,7 +158,48 @@ public class WindowManagerTest {
         // window should be compacted and events should be expired.
         assertEquals(seq(1, threshold - windowLength), listener.onExpiryEvents);
     }
-
+    
+    private void testEvictBeforeWatermarkForWatermarkEvictionPolicy(EvictionPolicy watermarkEvictionPolicy, int windowLength) throws Exception {
+        /**
+         * The watermark eviction policy must not evict tuples until the first watermark has been received.
+         * The policies can't make a meaningful decision prior to the first watermark, so the safe decision
+         * is to postpone eviction.
+         */ 
+        int threshold = WindowManager.EXPIRE_EVENTS_THRESHOLD;
+        windowManager.setEvictionPolicy(watermarkEvictionPolicy);
+        WatermarkCountTriggerPolicy triggerPolicy = new WatermarkCountTriggerPolicy(windowLength, windowManager,
+            watermarkEvictionPolicy, windowManager);
+        triggerPolicy.start();
+        windowManager.setTriggerPolicy(triggerPolicy);
+        for (int i : seq(1, threshold)) {
+            windowManager.add(i, i);
+        }
+        assertThat("The watermark eviction policies should never evict events before the first watermark is received",  listener.onExpiryEvents, is(empty()));
+        windowManager.add(new WaterMarkEvent<>(threshold));
+        // The events should be put in a window when the first watermark is received
+        assertEquals(seq(1, threshold), listener.onActivationEvents);
+        //Now add some more events and a new watermark, and check that the previous events are expired
+        for(int i : seq(threshold+1, threshold*2)) {
+            windowManager.add(i, i);
+        }
+        windowManager.add(new WaterMarkEvent<>(threshold + windowLength+1));
+        //All the events should be expired when the next watermark is received
+        assertThat("All the events should be expired after the second watermark", listener.onExpiryEvents, equalTo(seq(1, threshold)));
+    }
+    
+    @Test
+    public void testExpireThresholdWithWatermarkCountEvictionPolicy() throws Exception {
+        int windowLength = WindowManager.EXPIRE_EVENTS_THRESHOLD;
+        EvictionPolicy watermarkCountEvictionPolicy = new WatermarkCountEvictionPolicy(windowLength);
+        testEvictBeforeWatermarkForWatermarkEvictionPolicy(watermarkCountEvictionPolicy, windowLength);
+    }
+    
+    @Test
+    public void testExpireThresholdWithWatermarkTimeEvictionPolicy() throws Exception {
+        int windowLength = WindowManager.EXPIRE_EVENTS_THRESHOLD;
+        EvictionPolicy watermarkTimeEvictionPolicy = new WatermarkTimeEvictionPolicy(windowLength);
+        testEvictBeforeWatermarkForWatermarkEvictionPolicy(watermarkTimeEvictionPolicy, windowLength);
+    }
 
     @Test
     public void testTimeBasedWindow() throws Exception {
