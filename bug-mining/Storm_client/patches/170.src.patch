diff --git a/storm-client/src/jvm/org/apache/storm/Config.java b/storm-client/src/jvm/org/apache/storm/Config.java
index 7837cf5ef..2ce79b481 100644
--- a/storm-client/src/jvm/org/apache/storm/Config.java
+++ b/storm-client/src/jvm/org/apache/storm/Config.java
@@ -46,6 +46,7 @@ import org.apache.storm.validation.ConfigValidationAnnotations.IsImplementationO
 import org.apache.storm.validation.ConfigValidationAnnotations.IsInteger;
 import org.apache.storm.validation.ConfigValidationAnnotations.IsKryoReg;
 import org.apache.storm.validation.ConfigValidationAnnotations.IsListEntryCustom;
+import org.apache.storm.validation.ConfigValidationAnnotations.IsLong;
 import org.apache.storm.validation.ConfigValidationAnnotations.IsMapEntryCustom;
 import org.apache.storm.validation.ConfigValidationAnnotations.IsMapEntryType;
 import org.apache.storm.validation.ConfigValidationAnnotations.IsNumber;
@@ -1517,6 +1518,13 @@ public class Config extends HashMap<String, Object> {
      */
     @IsInteger
     public static final String STORM_MESSAGING_NETTY_CLIENT_WORKER_THREADS = "storm.messaging.netty.client_worker_threads";
+    /**
+     * Netty based messaging: The number of milliseconds that a Netty client will retry flushing messages that are already
+     * buffered to be sent.
+     */
+    @IsLong
+    @IsPositiveNumber
+    public static final String STORM_MESSAGING_NETTY_FLUSH_TIMEOUT_MS = "storm.messaging.netty.flush_timeout_ms";
     /**
      * Should the supervior try to run the worker as the lauching user or not.  Defaults to false.
      */
diff --git a/storm-client/src/jvm/org/apache/storm/messaging/netty/Client.java b/storm-client/src/jvm/org/apache/storm/messaging/netty/Client.java
index 31a189bd1..7e6440c85 100644
--- a/storm-client/src/jvm/org/apache/storm/messaging/netty/Client.java
+++ b/storm-client/src/jvm/org/apache/storm/messaging/netty/Client.java
@@ -69,8 +69,9 @@ import org.slf4j.LoggerFactory;
  * destination is currently unavailable.
  */
 public class Client extends ConnectionWithStatus implements ISaslClient {
-    private static final long PENDING_MESSAGES_FLUSH_TIMEOUT_MS = 600000L;
-    private static final long PENDING_MESSAGES_FLUSH_INTERVAL_MS = 1000L;
+    private final long pendingMessagesFlushTimeoutMs ;
+    private final long pendingMessagesFlushIntervalMs;
+    private final double pendingMessagesFlushFactor = 0.0016;
     /**
      * Periodically checks for connected channel in order to avoid loss of messages.
      */
@@ -162,6 +163,8 @@ public class Client extends ConnectionWithStatus implements ISaslClient {
         launchChannelAliveThread();
         scheduleConnect(NO_DELAY_MS);
         int messageBatchSize = ObjectReader.getInt(topoConf.get(Config.STORM_NETTY_MESSAGE_BATCH_SIZE), 262144);
+        pendingMessagesFlushTimeoutMs = ObjectReader.getLong(topoConf.get(Config.STORM_MESSAGING_NETTY_FLUSH_TIMEOUT_MS));
+        pendingMessagesFlushIntervalMs = (long) (pendingMessagesFlushFactor * pendingMessagesFlushTimeoutMs);
         batcher = new MessageBuffer(messageBatchSize);
         String clazz = (String) topoConf.get(Config.TOPOLOGY_BACKPRESSURE_WAIT_STRATEGY);
         if (clazz == null) {
@@ -479,18 +482,18 @@ public class Client extends ConnectionWithStatus implements ISaslClient {
 
     private void waitForPendingMessagesToBeSent() {
         LOG.info("waiting up to {} ms to send {} pending messages to {}",
-                 PENDING_MESSAGES_FLUSH_TIMEOUT_MS, pendingMessages.get(), dstAddressPrefixedName);
+                 pendingMessagesFlushTimeoutMs, pendingMessages.get(), dstAddressPrefixedName);
         long totalPendingMsgs = pendingMessages.get();
         long startMs = System.currentTimeMillis();
         while (pendingMessages.get() != 0) {
             try {
                 long deltaMs = System.currentTimeMillis() - startMs;
-                if (deltaMs > PENDING_MESSAGES_FLUSH_TIMEOUT_MS) {
+                if (deltaMs > pendingMessagesFlushTimeoutMs) {
                     LOG.error("failed to send all pending messages to {} within timeout, {} of {} messages were not "
                         + "sent", dstAddressPrefixedName, pendingMessages.get(), totalPendingMsgs);
                     break;
                 }
-                Thread.sleep(PENDING_MESSAGES_FLUSH_INTERVAL_MS);
+                Thread.sleep(pendingMessagesFlushIntervalMs);
             } catch (InterruptedException e) {
                 break;
             }
diff --git a/storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java b/storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java
index 9503aa665..4175ee9f4 100644
--- a/storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java
+++ b/storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java
@@ -416,6 +416,26 @@ public class ConfigValidation {
         }
     }
 
+    /**
+     * Validates a Long.
+     */
+    public static class LongValidator extends Validator {
+        @Override
+        public void validateField(String name, Object o) {
+            validateLong(name, o);
+        }
+
+        public void validateLong(String name, Object o) {
+            if (o == null) {
+                return;
+            }
+            if (o instanceof Number && ((Number) o).longValue() == ((Number) o).doubleValue()) {
+                return;
+            }
+            throw new IllegalArgumentException("Field " + name + " must be an Long within type range.");
+        }
+    }
+
     /**
      * Validates an entry for ImpersonationAclUser.
      */
diff --git a/storm-client/src/jvm/org/apache/storm/validation/ConfigValidationAnnotations.java b/storm-client/src/jvm/org/apache/storm/validation/ConfigValidationAnnotations.java
index ce22c3cfc..736746e76 100644
--- a/storm-client/src/jvm/org/apache/storm/validation/ConfigValidationAnnotations.java
+++ b/storm-client/src/jvm/org/apache/storm/validation/ConfigValidationAnnotations.java
@@ -121,6 +121,13 @@ public class ConfigValidationAnnotations {
         Class<?>[] entryValidatorClasses();
     }
 
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.FIELD)
+    public @interface IsLong {
+        Class<?> validatorClass() default ConfigValidation.LongValidator.class;
+    }
+
+
     /**
      * Validates the type of each key and value in a map Validator with fields: validatorClass, keyValidatorClass, valueValidatorClass.
      */
diff --git a/storm-client/test/jvm/org/apache/storm/TestConfigValidate.java b/storm-client/test/jvm/org/apache/storm/TestConfigValidate.java
index 5b9739536..3c335308d 100644
--- a/storm-client/test/jvm/org/apache/storm/TestConfigValidate.java
+++ b/storm-client/test/jvm/org/apache/storm/TestConfigValidate.java
@@ -18,6 +18,7 @@
 
 package org.apache.storm;
 
+import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -43,6 +44,7 @@ import org.apache.storm.validation.ConfigValidation;
 import org.apache.storm.validation.ConfigValidation.ImpersonationAclUserEntryValidator;
 import org.apache.storm.validation.ConfigValidation.IntegerValidator;
 import org.apache.storm.validation.ConfigValidation.KryoRegValidator;
+import org.apache.storm.validation.ConfigValidation.LongValidator;
 import org.apache.storm.validation.ConfigValidation.ListEntryTypeValidator;
 import org.apache.storm.validation.ConfigValidation.ListOfListOfStringValidator;
 import org.apache.storm.validation.ConfigValidation.NoDuplicateInListValidator;
@@ -352,6 +354,23 @@ public class TestConfigValidate {
         }
     }
 
+    @Test
+    public void testLongValidator() {
+        LongValidator validator = new LongValidator();
+
+        Object[] passCases = { null, 1000, Integer.MAX_VALUE, Long.MAX_VALUE };
+
+        for (Object value : passCases) {
+            validator.validateField("test", value);
+        }
+
+        Object[] failCases = { 1.34, BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.valueOf(1L))};
+
+        for (Object value : failCases) {
+            assertThrows(IllegalArgumentException.class, () -> validator.validateField("test", value));
+        }
+    }
+
     @Test
     public void NoDuplicateInListValidator() {
         NoDuplicateInListValidator validator = new NoDuplicateInListValidator();
