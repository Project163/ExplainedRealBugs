diff --git a/release-notes/VERSION b/release-notes/VERSION
index a59f22a..ecbecf6 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -6,6 +6,8 @@ Project: woodstox
 
 5.1.0 (not yet released)
 
+#23: Text content is not validated correctly when copying events to `XmlStreamWriter`
+ (reported by hxc9@github)
 #43: `CompactStartElement` appears to incorrectly classify attributes as default
  (reported by Jonathan T)
 
diff --git a/src/main/java/com/ctc/wstx/msv/GenericMsvValidator.java b/src/main/java/com/ctc/wstx/msv/GenericMsvValidator.java
index 41621d7..9a7f52a 100644
--- a/src/main/java/com/ctc/wstx/msv/GenericMsvValidator.java
+++ b/src/main/java/com/ctc/wstx/msv/GenericMsvValidator.java
@@ -17,7 +17,9 @@ package com.ctc.wstx.msv;
 
 import java.util.*;
 
+import javax.xml.namespace.QName;
 import javax.xml.stream.Location;
+import javax.xml.stream.XMLStreamConstants;
 import javax.xml.stream.XMLStreamException;
 
 import org.codehaus.stax2.validation.*;
@@ -47,7 +49,8 @@ import com.ctc.wstx.util.TextAccumulator;
  */
 public final class GenericMsvValidator
     extends XMLValidator
-    implements com.sun.msv.grammar.IDContextProvider2
+    implements com.sun.msv.grammar.IDContextProvider2,
+        XMLStreamConstants
 {
     /*
     ///////////////////////////////////////////////////////////
@@ -112,6 +115,11 @@ public final class GenericMsvValidator
      */
     final StartTagInfo mStartTag = new StartTagInfo("", "", "", null, (IDContextProvider2) null);
 
+    /**
+     * Since `StartTagInfo` has no place for prefix, hold reference to one here
+     */
+    protected String mStartTagPrefix = "";
+
     /**
      * This object provides limited access to attribute values of the
      * currently validated element.
@@ -233,7 +241,6 @@ public final class GenericMsvValidator
     public void validateElementStart(String localName, String uri, String prefix)
         throws XMLStreamException
     {
-
         /* [WSTX-200]: If sub-tree we were to validate has ended, we
          *   have no current acceptor, and must quite. Ideally we would
          *   really handle this more cleanly but...
@@ -261,6 +268,7 @@ public final class GenericMsvValidator
         //String qname = (prefix == null || prefix.length() == 0) ? localName : (prefix + ":" +localName);
         String qname = localName;
         mStartTag.reinit(uri, localName, qname, mAttributeProxy, this);
+        mStartTagPrefix = prefix;
 
         mCurrAcceptor = mCurrAcceptor.createChildAcceptor(mStartTag, mErrorRef);
         /* As per documentation, the side-effect of getting the error message
@@ -268,7 +276,7 @@ public final class GenericMsvValidator
          * never (?) see null acceptor being returned
          */
         if (mErrorRef.str != null) {
-            reportError(mErrorRef);
+            reportError(mErrorRef, START_ELEMENT, _qname(uri, localName, prefix));
         }
         if (mProblem != null) { // pending problems (to throw exception on)?
             XMLValidationProblem p = mProblem;
@@ -299,7 +307,7 @@ public final class GenericMsvValidator
 
             if (!mCurrAcceptor.onAttribute2(uri, localName, qname, value, this, mErrorRef, typeRef)
                 || mErrorRef.str != null) {
-                reportError(mErrorRef);
+                reportError(mErrorRef, ATTRIBUTE, _qname(uri, localName, prefix));
             }
             if (mProblem != null) { // pending problems (to throw exception on)?
                 XMLValidationProblem p = mProblem;
@@ -307,23 +315,18 @@ public final class GenericMsvValidator
                 mContext.reportProblem(p);
             }
         }
-        /* No normalization done by RelaxNG, is there? (at least nothing
-         * visible to callers that is)
-         */
+        // No normalization done by RelaxNG, is there? (at least nothing
+        // visible to callers that is)
         return null;
     }
 
     @Override
-    public String validateAttribute(String localName, String uri,
-            String prefix,
-            char[] valueChars, int valueStart,
-            int valueEnd)
+    public String validateAttribute(String localName, String uri, String prefix,
+            char[] valueChars, int valueStart, int valueEnd)
         throws XMLStreamException
     {
         int len = valueEnd - valueStart;
-        /* This is very sub-optimal... but MSV doesn't deal with char
-         * arrays.
-         */
+        // This is very sub-optimal... but MSV doesn't deal with char arrays.
         return validateAttribute(localName, uri, prefix,
                                  new String(valueChars, valueStart, len));
     }
@@ -340,7 +343,7 @@ public final class GenericMsvValidator
              */
             if (!mCurrAcceptor.onEndAttributes(mStartTag, mErrorRef)
                 || mErrorRef.str != null) {
-                reportError(mErrorRef);
+                reportError(mErrorRef, XMLStreamConstants.END_ELEMENT, _startTagAsQName());
             }
 
             int stringChecks = mCurrAcceptor.getStringCareLevel();
@@ -375,19 +378,16 @@ public final class GenericMsvValidator
          */
         doValidateText(mTextAccumulator);
 
-        /* [WSTX-200]: need to avoid problems when doing sub-tree
-         *   validation... not a proper solution, but has to do for
-         *   now
-         */
+        // [WSTX-200]: need to avoid problems when doing sub-tree
+        //   validation... not a proper solution, but has to do for now
         int lastIx = mAcceptors.size()-1;
         if (lastIx < 0) {
             return XMLValidator.CONTENT_ALLOW_WS;
         }
-
         Acceptor acc = (Acceptor)mAcceptors.remove(lastIx);
         if (acc != null) { // may be null during error recovery? or not?
             if (!acc.isAcceptState(mErrorRef) || mErrorRef.str != null) {
-                reportError(mErrorRef);
+                reportError(mErrorRef, XMLStreamConstants.END_ELEMENT, _qname(uri, localName, prefix));
             }
         }
         if (lastIx == 0) { // root closed
@@ -398,7 +398,7 @@ public final class GenericMsvValidator
         if (mCurrAcceptor != null && acc != null) {
             if (!mCurrAcceptor.stepForward(acc, mErrorRef)
                 || mErrorRef.str != null) {
-                reportError(mErrorRef);
+                reportError(mErrorRef, XMLStreamConstants.END_ELEMENT, _qname(uri, localName, prefix));
             }
             int stringChecks = mCurrAcceptor.getStringCareLevel();
             switch (stringChecks) {
@@ -431,7 +431,7 @@ public final class GenericMsvValidator
 
     @Override
     public void validateText(char[] cbuf, int textStart, int textEnd,
-                             boolean lastTextSegment)
+            boolean lastTextSegment)
         throws XMLStreamException
     {
         /* If we got here, then it's likely we do need to call onText().
@@ -519,18 +519,31 @@ public final class GenericMsvValidator
             DatatypeRef typeRef = null;
             if (!mCurrAcceptor.onText2(str, this, mErrorRef, typeRef)
                 || mErrorRef.str != null) {
-                reportError(mErrorRef);
+                reportError(mErrorRef, CDATA, _startTagAsQName());
             }
         }
     }
 
-    private void reportError(StringRef errorRef)
-        throws XMLStreamException
+    private void reportError(StringRef errorRef, int type, QName name) throws XMLStreamException
     {
         String msg = errorRef.str;
         errorRef.str = null;
-        if (msg == null) {
-            msg = "Unknown reason";
+        if (msg == null || msg.isEmpty()) {
+            switch (type) {
+            case START_ELEMENT:
+                msg = "Unknown reason (at start element "+_name(name, "<", ">")+")";
+                break;
+            case END_ELEMENT:
+                msg = "Unknown reason (at end element "+_name(name, "</", ">")+")";
+                break;
+            case ATTRIBUTE:
+                msg = "Unknown reason (at attribute "+_name(name, "'", "'")+")";
+                break;
+            case CDATA:
+            default:
+                msg = "Unknown reason (at CDATA section, inside element "+_name(name, "<", ">")+")";
+                break;
+            }
         }
         reportError(msg);
     }
@@ -548,4 +561,34 @@ public final class GenericMsvValidator
         prob.setReporter(this);
         mContext.reportProblem(prob);
     }
+
+    private String _name(QName qn, String prefix, String suffix) {
+        if (qn == null) {
+            return "UNKNOWN";
+        }
+        String name = qn.getLocalPart();
+        String p = qn.getPrefix();
+        if (p != null && !p.isEmpty()) {
+            name = p + ":" + name;
+        }
+        return prefix + name + suffix;
+    }
+
+    private QName _startTagAsQName() {
+        return _qname(mStartTag.namespaceURI, mStartTag.localName, mStartTagPrefix);
+    }
+    
+    private QName _qname(String ns, String local, String prefix) {
+        if (prefix == null) {
+            prefix = "";
+        }
+        if (ns == null) {
+            ns = "";
+        }
+        // should we even allow this?
+        if (local == null) {
+            local = "";
+        }
+        return new QName(ns, local, prefix);
+    }
 }
diff --git a/src/main/java/com/ctc/wstx/sw/BaseStreamWriter.java b/src/main/java/com/ctc/wstx/sw/BaseStreamWriter.java
index 81d568d..a066d5e 100644
--- a/src/main/java/com/ctc/wstx/sw/BaseStreamWriter.java
+++ b/src/main/java/com/ctc/wstx/sw/BaseStreamWriter.java
@@ -375,18 +375,16 @@ public abstract class BaseStreamWriter
             }
         } else if (mVldContent == XMLValidator.CONTENT_ALLOW_VALIDATABLE_TEXT) {
             if (mValidator != null) {
-                /* Last arg is false, since we do not know if more text
-                 * may be added with additional calls
-                 */
+                // Last arg is false, since we do not know if more text
+                // may be added with additional calls
                 mValidator.validateText(text, start, start + len, false);
             }
         }
 
         if (len > 0) { // minor optimization
             try {
-                /* 21-Jun-2006, TSa: Fixing [WSTX-59]: no quoting can be done
-                 *   outside of element tree.
-                 */
+                // 21-Jun-2006, TSa: Fixing [WSTX-59]: no quoting can be done
+                //   outside of element tree.
                 if (inPrologOrEpilog()) {
                     mWriter.writeRaw(text, start, len);
                 } else {
@@ -758,10 +756,8 @@ public abstract class BaseStreamWriter
             case START_DOCUMENT:
                 {
                     String version = sr.getVersion();
-                    /* No real declaration? If so, we don't want to output
-                     * anything, to replicate as closely as possible the
-                     * source document
-                     */
+                    // No real declaration? If so, we don't want to output anything, to replicate
+                    // as closely as possible the source document
                     if (version == null || version.length() == 0) {
                         ; // no output if no real input
                     } else {
@@ -802,17 +798,26 @@ public abstract class BaseStreamWriter
                     if (mStartElementOpen) {
                         closeStartElement(mEmptyElement);
                     }
-                    /* No need to write as chars, should be pure space
-                     * (caller should have verified); also, no escaping
-                     * necessary.
-                     */
-                    sr.getText(wrapAsRawWriter(), preserveEventData);
+                    // No need to write as chars, should be pure space (caller should
+                    // have verified); also, no escaping necessary.
+
+                    // 28-Mar-2017, tatu: Various optimization do not work well when validation so:
+                    if (mValidator != null) {
+                        writeCData(sr.getText());
+                    } else {
+                        sr.getText(wrapAsRawWriter(), preserveEventData);
+                    }
                 }
                 return;
 
             case CDATA:
 
                 // First; is this to be changed to 'normal' text output?
+                // 28-Mar-2017, tatu: Various optimization do not work well when validation so:
+                if (mValidator != null) {
+                    writeCData(sr.getText());
+                    return;
+                }
                 if (!mCfgCDataAsText) {
                     mAnyOutput = true;
                     // Need to finish an open start element?
@@ -826,9 +831,8 @@ public abstract class BaseStreamWriter
                             reportNwfStructure(ErrorConsts.WERR_PROLOG_CDATA);
                         }
                     }
-                    /* Note: no need to check content, since reader is assumed
-                     * to have verified it to be valid XML.
-                     */
+                    // Note: no need to check content, since reader is assumed
+                    // to have verified it to be valid XML.
                     mWriter.writeCDataStart();
                     sr.getText(wrapAsRawWriter(), preserveEventData);
                     mWriter.writeCDataEnd();
@@ -837,7 +841,11 @@ public abstract class BaseStreamWriter
                 // fall down if it is to be converted...
 
             case CHARACTERS:
-                {
+
+                // 28-Mar-2017, tatu: Various optimization do not work well when validation so:
+                if (mValidator != null) {
+                    writeCharacters(sr.getText());
+                } else  {
                     // Let's just assume content is fine... not 100% reliably
                     // true, but usually is (not true if input had a root
                     // element surrounding text, but omitted for output)
@@ -877,15 +885,13 @@ public abstract class BaseStreamWriter
                 {
                     DTDInfo info = sr.getDTDInfo();
                     if (info == null) {
-                        // Hmmmh. It is legal for this to happen, for
-                        // non-DTD-aware readers. But what is the right
-                        // thing to do here?
+                        // Hmmmh. It is legal for this to happen, for non-DTD-aware
+                        // readers. But what is the right thing to do here?
                         throwOutputError("Current state DOCTYPE, but not DTDInfo Object returned -- reader doesn't support DTDs?");
                     }
-                    // Could optimize this a bit (stream the int. subset
-                    // possible), but it's never going to occur more than
-                    // once per document, so it's probably not much of a
-                    // bottleneck, ever
+                    // Could optimize this a bit (stream the int. subset possible),
+                    // but it's never going to occur more than once per document,
+                    // so it's probably not much of a bottleneck, ever
                     writeDTD(info);
                 }
                 return;
@@ -903,9 +909,8 @@ public abstract class BaseStreamWriter
         } catch (IOException ioe) {
             throw new WstxIOException(ioe);
         }
-
         throw new XMLStreamException("Unrecognized event type ("
-                                     +sr.getEventType()+"); not sure how to copy");
+                +sr.getEventType()+"); not sure how to copy");
     }
 
     /*
diff --git a/src/test/java/stax2/vwstream/BaseOutputTest.java b/src/test/java/stax2/vwstream/BaseOutputTest.java
index 34599e0..d43cfb9 100644
--- a/src/test/java/stax2/vwstream/BaseOutputTest.java
+++ b/src/test/java/stax2/vwstream/BaseOutputTest.java
@@ -12,7 +12,7 @@ abstract class BaseOutputTest
     extends BaseStax2Test
 {
     public XMLStreamWriter2 getDTDValidatingWriter(Writer w, String dtdSrc,
-                                                   boolean nsAware, boolean repairing)
+            boolean nsAware, boolean repairing)
         throws XMLStreamException
     {
         XMLOutputFactory2 outf = getOutputFactory();
@@ -28,4 +28,22 @@ abstract class BaseOutputTest
         strw.writeStartDocument();
         return strw;
     }
+
+    public XMLStreamWriter2 getSchemaValidatingWriter(Writer w, String schemaSrc,
+            boolean repairing)
+        throws XMLStreamException
+    {
+        XMLOutputFactory2 outf = getOutputFactory();
+        outf.setProperty(XMLStreamProperties.XSP_NAMESPACE_AWARE, true);
+        outf.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, new Boolean(repairing));
+
+        XMLStreamWriter2 strw = (XMLStreamWriter2)outf.createXMLStreamWriter(w);
+        XMLValidationSchemaFactory vd = XMLValidationSchemaFactory.newInstance(XMLValidationSchema.SCHEMA_ID_W3C_SCHEMA);
+
+        XMLValidationSchema schema = vd.createSchema(new StringReader(schemaSrc));
+
+        strw.validateAgainst(schema);
+        strw.writeStartDocument();
+        return strw;
+    }
 }
diff --git a/src/test/java/stax2/vwstream/WriteValidate23Test.java b/src/test/java/stax2/vwstream/WriteValidate23Test.java
new file mode 100644
index 0000000..2f23244
--- /dev/null
+++ b/src/test/java/stax2/vwstream/WriteValidate23Test.java
@@ -0,0 +1,39 @@
+package stax2.vwstream;
+
+import java.io.*;
+
+import org.codehaus.stax2.XMLStreamReader2;
+import org.codehaus.stax2.XMLStreamWriter2;
+
+public class WriteValidate23Test
+    extends BaseOutputTest
+{
+    public void testSchemaValidatingCopy23() throws Exception
+    {
+        final String SCHEMA = "<?xml version='1.0' ?>\n"
++"<xs:schema elementFormDefault='unqualified'\n"
++"           xmlns:xs='http://www.w3.org/2001/XMLSchema'>\n"
++"    <xs:element name='Document' type='xs:int'/>\n"
++"</xs:schema>";
+        final String CONTENT = "<Document>124</Document>";
+        final String DOC = "<?xml version='1.0' encoding='UTF-8'?>\n"+CONTENT;
+                
+
+        StringWriter strw = new StringWriter();
+        XMLStreamWriter2 xmlWriter = getSchemaValidatingWriter(strw, SCHEMA, false);
+        XMLStreamReader2 xmlReader = constructNsStreamReader(DOC, false);
+
+        while (xmlReader.hasNext()) {
+            /*int type =*/ xmlReader.next();
+            xmlWriter.copyEventFromReader(xmlReader, true);
+        }
+ 
+        xmlWriter.close();
+        xmlReader.close();
+
+        String xml = strw.toString();
+        if (!xml.contains(CONTENT)) {
+            fail("Should contain ["+CONTENT+"], does not: ["+xml+"]");
+        }
+    }
+}
