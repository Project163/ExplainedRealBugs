diff --git a/pom.xml b/pom.xml
index f56a91e..288f3d2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -4,7 +4,7 @@
     <parent>
       <groupId>com.fasterxml</groupId>
       <artifactId>oss-parent</artifactId>
-      <version>19</version>
+      <version>24</version>
     </parent>
 
     <groupId>com.fasterxml.woodstox</groupId>
@@ -111,6 +111,8 @@
         <dependency>
           <groupId>org.codehaus.woodstox</groupId>
           <artifactId>stax2-api</artifactId>
+<!-- 10-Dec-2015, tatu: For Woodstox 5.1, upgrade to 4.0
+  -->
           <version>3.1.4</version>
         </dependency>
 
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 6970c16..935628f 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -4,6 +4,11 @@ Project: woodstox
 === Releases ===
 ------------------------------------------------------------------------
 
+5.0.2 (not yet released)
+
+#10: Stax 4.0.0 is not compatible with Woodstox 5.0.1
+ (reported by naveengopi@github)
+
 5.0.1 (02-Apr-2015)
 
 #3: Initial 5.0.0 release did not contain class files (d'oh!)
diff --git a/src/main/java/com/ctc/wstx/api/ReaderConfig.java b/src/main/java/com/ctc/wstx/api/ReaderConfig.java
index 3388089..eeed8be 100644
--- a/src/main/java/com/ctc/wstx/api/ReaderConfig.java
+++ b/src/main/java/com/ctc/wstx/api/ReaderConfig.java
@@ -1424,15 +1424,15 @@ public final class ReaderConfig
         case PROP_MAX_ELEMENT_DEPTH:
             return DataUtil.Integer(getMaxElementDepth());
         case PROP_MAX_ELEMENT_COUNT:
-            return DataUtil.Long(getMaxElementCount());
+            return Long.valueOf(getMaxElementCount());
         case PROP_MAX_CHARACTERS:
-            return DataUtil.Long(getMaxCharacters());
+            return Long.valueOf(getMaxCharacters());
         case PROP_MAX_TEXT_LENGTH:
-            return DataUtil.Long(getMaxTextLength());
+            return Long.valueOf(getMaxTextLength());
         case PROP_MAX_ENTITY_DEPTH:
             return DataUtil.Integer(getMaxEntityDepth());
         case PROP_MAX_ENTITY_COUNT:
-            return DataUtil.Long(getMaxEntityCount());
+            return Long.valueOf(getMaxEntityCount());
 
         case PROP_MIN_TEXT_SEGMENT:
             return DataUtil.Integer(getShortestReportedTextSegment());
diff --git a/src/main/java/com/ctc/wstx/util/DataUtil.java b/src/main/java/com/ctc/wstx/util/DataUtil.java
index a22548c..42f2d3f 100644
--- a/src/main/java/com/ctc/wstx/util/DataUtil.java
+++ b/src/main/java/com/ctc/wstx/util/DataUtil.java
@@ -3,27 +3,31 @@ package com.ctc.wstx.util;
 import java.lang.reflect.Array;
 import java.util.*;
 
-import org.codehaus.stax2.ri.EmptyIterator;
 import org.codehaus.stax2.ri.SingletonIterator;
 
 public final class DataUtil
 {
     final static char[] EMPTY_CHAR_ARRAY = new char[0];
 
+    final static Long MAX_LONG = new Long(Long.MAX_VALUE);
+
     /**
-     * If baseline requirement was JDK 1.5, we wouldn't need to
-     * cache Integer instances like this (since it has
-     * Integer.valueOf() which does it); but until then, we
-     * alas need our known canonicalization.
+     * Due to [woodstox#10], we will need to use a work-around which (for now)
+     * includes a local copy of this iterator class.
+     *<p>
+     * TODO: Once we get to Java 7 / JDK 1.7, replace with one from Collections
+     * 
+     * @since 5.0.1
      */
-    final static Integer[] INTS = new Integer[100];
-    static {
-        for (int i = 0; i < INTS.length; ++i) {
-            INTS[i] = new Integer(i);
-        }
-    }
-    final static Long MAX_LONG = new Long(Long.MAX_VALUE);
+    private final static class EmptyIterator implements Iterator<Object>
+    {
+        public final static Iterator<?> INSTANCE = new EmptyIterator();
 
+        public boolean hasNext() { return false; }
+        public Object next() { throw new java.util.NoSuchElementException(); }
+        public void remove() { throw new IllegalStateException(); }
+    }
+    
     private DataUtil() { }
 
     /*
@@ -36,25 +40,19 @@ public final class DataUtil
         return EMPTY_CHAR_ARRAY;
     }
 
-    public static Integer Integer(int i)
-    {
-        /* !!! 13-Sep-2008, TSa: JDK 1.5 can use Integer.valueOf(int)
-         *   which does the same. When upgrading baseline, can get rid
-         *   of this method.
-         */
-        if (i < 0 || i >= INTS.length) {
-            return new Integer(i);
-        }
-        return INTS[i];
+    // TODO: deprecate, not really needed post-JDK-1.4
+    public static Integer Integer(int i) {
+        return Integer.valueOf(i);
     }
-    
+
+    @Deprecated // since 5.0.1
     public static Long Long(long l)
     {
         if (l == Long.MAX_VALUE) {
             return MAX_LONG;
         }
-        return new Long(l);
-    }  
+        return Long.valueOf(l);
+    }
 
     /*
     ////////////////////////////////////////////////////////////
@@ -65,15 +63,16 @@ public final class DataUtil
     @SuppressWarnings("unchecked")
     public static <T> Iterator<T> singletonIterator(T item) {
         // TODO: with JDK 1.7, can use method from Collections
+        // TODO: alternatively, with Woodstox 5.1, can fix deprecation marker
         return (Iterator<T>) new SingletonIterator(item);
     }
 
     @SuppressWarnings("unchecked")
     public static <T> Iterator<T> emptyIterator() {
         // TODO: with JDK 1.7, can use method from Collections
-        return (Iterator<T>) EmptyIterator.getInstance();
+        return (Iterator<T>) EmptyIterator.INSTANCE;
     }
-    
+
     /*
     ////////////////////////////////////////////////////////////
     // Methods for common operations on std data structs
@@ -143,11 +142,7 @@ public final class DataUtil
         if (arr == null) {
             return new String[more];
         }
-        String[] old = arr;
-        int len = arr.length;
-        arr = new String[len + more];
-        System.arraycopy(old, 0, arr, 0, len);
-        return arr;
+        return Arrays.copyOf(arr, arr.length + more);
     }
 
     public static int[] growArrayBy(int[] arr, int more)
@@ -155,11 +150,6 @@ public final class DataUtil
         if (arr == null) {
             return new int[more];
         }
-        int[] old = arr;
-        int len = arr.length;
-        arr = new int[len + more];
-        System.arraycopy(old, 0, arr, 0, len);
-        return arr;
+        return Arrays.copyOf(arr, arr.length + more);
     }
 }
- 
