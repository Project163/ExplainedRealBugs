diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index f8736ea..05a25ba 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -19,3 +19,14 @@ Colm O hEigeartaigh (coheigea@github)
 
 * Reported #85: OSGi dependency on relaxng should be `optional`
  (6.0.2)
+
+Michael Siegel (michaelsiegel@github)
+
+* Reported, contributed fix for #88: Missing closing quote for attribute values during
+  Validating output mode
+ (6.0.3)
+
+Ivo Studensky (istudens@github)
+
+* Reported #93: Stax `maxAttributeSize` limit is only vaguely respected
+ (6.0.3)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index bf890c2..a32ef71 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -8,6 +8,8 @@ Project: woodstox
 
 #88: Missing closing quote for attribute values during in Validating output mode
  (reported, fixed by michaelsiegel@github)
+#93: Stax `maxAttributeSize` limit is only vaguely respected
+ (reported by Ivo S)
 
 6.0.2 (12-Oct-2019)
 
diff --git a/src/main/java/com/ctc/wstx/sr/BasicStreamReader.java b/src/main/java/com/ctc/wstx/sr/BasicStreamReader.java
index 844814f..3f5f2c9 100644
--- a/src/main/java/com/ctc/wstx/sr/BasicStreamReader.java
+++ b/src/main/java/com/ctc/wstx/sr/BasicStreamReader.java
@@ -46,6 +46,7 @@ import com.ctc.wstx.ent.EntityDecl;
 import com.ctc.wstx.exc.WstxException;
 import com.ctc.wstx.io.*;
 import com.ctc.wstx.util.DefaultXmlSymbolTable;
+import com.ctc.wstx.util.ExceptionUtil;
 import com.ctc.wstx.util.TextBuffer;
 import com.ctc.wstx.util.TextBuilder;
 
@@ -1964,8 +1965,11 @@ public abstract class BasicStreamReader
     {
         char[] outBuf = tb.getCharBuffer();
         int outPtr = tb.getCharSize();
-        int outLen = outBuf.length;
-        WstxInputSource currScope = mInput;
+        // important! Underlying buffer may be shared, does not necessarily start from 0
+        final int startingOffset = outPtr;
+        final int maxAttrSize = mConfig.getMaxAttributeSize();
+        int outLimit = Math.min(startingOffset+maxAttrSize, outBuf.length);
+        final WstxInputSource currScope = mInput;
 
         while (true) {
             char c = (mInputPtr < mInputEnd) ? mInputBuffer[mInputPtr++]
@@ -1976,14 +1980,11 @@ public abstract class BasicStreamReader
                     if (c == '\n') {
                         markLF();
                     } else if (c == '\r') {
-                        /* 04-Mar-2006, TSa: Linefeed normalization only
-                         *   done if enabled -- specifically, 2-char lfs
-                         *   from int. entities are not coalesced. Now...
-                         *   whether to try to count them as one or not...
-                         *   easier not to; esp. since we may not be able to
-                         *   distinguish char entity originated ones from
-                         *   real ones.
-                         */
+                        // 04-Mar-2006, TSa: Linefeed normalization only done if enabled -
+                        //   specifically, 2-char lfs from int. entities are not coalesced.
+                        //   Now... whether to try to count them as one or not... easier not to;
+                        //   esp. since we may not be able to distinguish char entity originated ones
+                        //   from real ones.
                         if (mNormalizeLFs) {
                             c = getNextChar(SUFFIX_IN_ATTR_VALUE);
                             if (c != '\n') { // nope, not 2-char lf (Mac?)
@@ -1997,11 +1998,9 @@ public abstract class BasicStreamReader
                     // Whatever it was, it'll be 'normal' space now.
                     c = CHAR_SPACE;
                 } else if (c == openingQuote) {
-                    /* 06-Aug-2004, TSa: Can get these via entities; only "real"
-                     *    end quotes in same scope count. Note, too, that since
-                     *    this will only be done at root level, there's no need
-                     *    to check for "runaway" values; they'll hit EOF
-                     */
+                    // 06-Aug-2004, TSa: Can get these via entities; only "real" end quotes in same
+                    //    scope count. Note, too, that since  this will only be done at root level,
+                    //    there's no need  to check for "runaway" values; they'll hit EOF
                     if (mInput == currScope) {
                         break;
                     }
@@ -2022,9 +2021,9 @@ public abstract class BasicStreamReader
                         c = (char) ch;
                     } else {
                         ch -= 0x10000;
-                        if (outPtr >= outLen) {
-                            outBuf = tb.bufferFull(1);
-                            outLen = outBuf.length;
+                        if (outPtr >= outLimit) {
+                            outBuf = _checkAttributeLimit(tb, outBuf, outPtr, outPtr - startingOffset, maxAttrSize);
+                            outLimit = Math.min(startingOffset+maxAttrSize, outBuf.length);
                         }
                         outBuf[outPtr++] = (char) ((ch >> 10)  + 0xD800);
                         c = (char) ((ch & 0x3FF)  + 0xDC00);
@@ -2035,10 +2034,9 @@ public abstract class BasicStreamReader
             }
 
             // Ok, let's just add char in, whatever it was
-            if (outPtr >= outLen) {
-                verifyLimit("Maximum attribute size", mConfig.getMaxAttributeSize(), tb.getCharSize());
-                outBuf = tb.bufferFull(1);
-                outLen = outBuf.length;
+            if (outPtr >= outLimit) {
+                outBuf = _checkAttributeLimit(tb, outBuf, outPtr, outPtr - startingOffset, maxAttrSize);
+                outLimit = Math.min(startingOffset+maxAttrSize, outBuf.length);
             }
             outBuf[outPtr++] = c;
         }
@@ -2046,7 +2044,21 @@ public abstract class BasicStreamReader
         // Fine; let's tell TextBuild we're done:
         tb.setBufferSize(outPtr);
     }
-    
+
+    private final char[] _checkAttributeLimit(TextBuilder tb,
+            char[] outBuf, int outPtr, int currAttrSize, int maxAttrSize)
+        throws XMLStreamException
+    {
+        // Add +1 since we are at point where we are to append (at least) one more character
+        verifyLimit("Maximum attribute size", maxAttrSize , currAttrSize+1);
+        // just sanity check
+        if (outPtr < outBuf.length) {
+            ExceptionUtil.throwInternal("Expected either attr limit ("+maxAttrSize
+                    +") >= currAttrSize ("+currAttrSize+") OR >= outBuf.length ("+outBuf.length+")");
+        }
+        return tb.bufferFull(1);
+    }
+
     /*
     ///////////////////////////////////////////////////////////////////////
     // Internal methods, parsing prolog (before root) and epilog
diff --git a/src/test/java/stax2/typed/WriterTestBase.java b/src/test/java/stax2/typed/WriterTestBase.java
index 41bc0c6..9cf2a4c 100644
--- a/src/test/java/stax2/typed/WriterTestBase.java
+++ b/src/test/java/stax2/typed/WriterTestBase.java
@@ -25,7 +25,9 @@ public abstract class WriterTestBase
     extends BaseStax2Test
 {
     final static int[] ARRAY_TEST_LENGTHS = new int[] {
-        3, 8, 25, 120, 16, 99, 253, 1099, 2866, 37242
+            // 15-Nov-2019, tatu: careful wrt [woodstox-core#93] so as not to exceed
+            //    maximum attribute value lengths!
+            3, 8, 25, 120, 16, 99, 253, 1099, 2866, 7777, 23242
     };
 
     /*
@@ -514,7 +516,8 @@ public abstract class WriterTestBase
             }
             String contents;
             if (testAttr) {
-                contents = getAttributeContent(writeDoubleArrayAttrDoc("root", "attr", data));
+                final byte[] xml = writeDoubleArrayAttrDoc("root", "attr", data);
+                contents = getAttributeContent(xml);
             } else {
                 contents = getElementContent(writeDoubleArrayElemDoc("root", data));
             }
diff --git a/src/test/java/wstxtest/stream/TestAttributeLimits.java b/src/test/java/wstxtest/stream/TestAttributeLimits.java
index 0ac4192..24c761f 100644
--- a/src/test/java/wstxtest/stream/TestAttributeLimits.java
+++ b/src/test/java/wstxtest/stream/TestAttributeLimits.java
@@ -48,6 +48,31 @@ public class TestAttributeLimits extends BaseStreamTest
         reader.close();
     }
 
+    // [woodstox-core#93]: should use stricter verification of max attr length
+    public void testShorterAttribute() throws Exception
+    {
+        XMLInputFactory factory = getNewInputFactory();
+        factory.setProperty(WstxInputProperties.P_MAX_ATTRIBUTE_SIZE, 4);
+
+        // First: ok document
+        XMLStreamReader r = factory.createXMLStreamReader(new StringReader(
+                "<root attr='1234' other='ab' x='yz&amp;0' />"));
+        assertTokenType(START_ELEMENT, r.next());
+        assertEquals(3, r.getAttributeCount());
+        assertTokenType(END_ELEMENT, r.next());
+        r.close();
+
+        // then not so much
+        r = factory.createXMLStreamReader(new StringReader(
+                "<root attr='1234' other='abcde'  />"));
+        try {
+            r.next();
+            fail("Should not pass");
+        } catch (XMLStreamException ex) {
+            verifyException(ex, "Maximum attribute size limit (4)");
+        }
+    }
+
     public void testLongAttribute() throws Exception {
         final int max = 500;
         Reader reader = new Reader() {
