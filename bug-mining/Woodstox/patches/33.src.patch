diff --git a/release-notes/VERSION b/release-notes/VERSION
index a72aa1c..d0d5a67 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -4,6 +4,10 @@ Project: woodstox
 === Releases ===
 ------------------------------------------------------------------------
 
+Not yet released:
+
+#121: Fix issues outlined by "lgtm.com"'s static analysis
+
 6.2.7 (20-Nov-2021)
 
 #132: `copyEventFromReader()` Processing Instruction event bug
diff --git a/src/main/java/com/ctc/wstx/dtd/DTDIdAttr.java b/src/main/java/com/ctc/wstx/dtd/DTDIdAttr.java
index c0ffc22..7d49305 100644
--- a/src/main/java/com/ctc/wstx/dtd/DTDIdAttr.java
+++ b/src/main/java/com/ctc/wstx/dtd/DTDIdAttr.java
@@ -18,9 +18,9 @@ public final class DTDIdAttr
     extends DTDAttribute
 {
     /*
-    ///////////////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     // Life-cycle
-    ///////////////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
      */
 
     /**
@@ -44,9 +44,9 @@ public final class DTDIdAttr
     }
 
     /*
-    ///////////////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     // Public API
-    ///////////////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
      */
 
     @Override
@@ -60,9 +60,9 @@ public final class DTDIdAttr
     }
 
     /*
-    ///////////////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     // Public API, validation
-    ///////////////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
      */
 
     /**
diff --git a/src/main/java/com/ctc/wstx/dtd/DTDTypingNonValidator.java b/src/main/java/com/ctc/wstx/dtd/DTDTypingNonValidator.java
index efccac0..5e40dcd 100644
--- a/src/main/java/com/ctc/wstx/dtd/DTDTypingNonValidator.java
+++ b/src/main/java/com/ctc/wstx/dtd/DTDTypingNonValidator.java
@@ -37,10 +37,10 @@ import com.ctc.wstx.util.PrefixedName;
 public class DTDTypingNonValidator
     extends DTDValidatorBase
 {
-	/*
-    ///////////////////////////////////////////
+    /*
+    ///////////////////////////////////////////////////////////////////////
     // Element def/spec/validator stack, state
-    ///////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     */
 
     /**
@@ -63,21 +63,21 @@ public class DTDTypingNonValidator
     protected boolean mHasNormalizableAttrs = false;
 
     /*
-    ///////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     // Temporary helper objects
-    ///////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     */
 
     /**
      * Reusable lazily instantiated BitSet; needed to keep track of
      * 'missing' attributes with default values (normal default, #FIXED).
      */
-    BitSet mTmpDefaultAttrs;
+    protected BitSet mTmpDefaultAttrs;
 
     /*
-    ///////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     // Life-cycle
-    ///////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     */
 
     public DTDTypingNonValidator(DTDSubset schema, ValidationContext ctxt, boolean hasNsDefaults,
@@ -93,9 +93,9 @@ public class DTDTypingNonValidator
     public final boolean reallyValidating() { return false; }
 
     /*
-    ///////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     // Configuration
-    ///////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     */
 
     /**
@@ -108,9 +108,9 @@ public class DTDTypingNonValidator
     }
 
     /*
-    ///////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     // XMLValidator implementation
-    ///////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     */
 
     //public XMLValidationSchema getSchema()
@@ -253,7 +253,11 @@ public class DTDTypingNonValidator
          * attribute default values, and return "anything goes"
          * as the allowable content:
          */
-        DTDElement elem = mCurrElem;
+        final DTDElement elem = mCurrElem;
+        if (elem == null) { // can this ever occur really?
+            return XMLValidator.CONTENT_ALLOW_ANY_TEXT;
+        }
+        
         if (mHasAttrDefaults) {
             BitSet specBits = mCurrDefaultAttrs;
             int specCount = elem.getSpecialCount();
@@ -271,11 +275,9 @@ public class DTDTypingNonValidator
          * to occur -- although it won't be considered an error, when not
          * validating, info is needed to determine type of SPACE instead
          * of CHARACTERS. Other validation types are not to be returned,
-         * however, since caller doesn't know how to deal with such
-         * cases.
+         * however, since caller doesn't know how to deal with such cases.
          */
-        return (elem == null) ? XMLValidator.CONTENT_ALLOW_ANY_TEXT :
-            elem.getAllowedContentIfSpace();
+        return elem.getAllowedContentIfSpace();
     }
 
     @Override
@@ -307,9 +309,9 @@ public class DTDTypingNonValidator
     }
 
     /*
-    ///////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     // Package methods, accessors
-    ///////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////
     */
 
     @Override
diff --git a/src/main/java/com/ctc/wstx/sr/AttributeCollector.java b/src/main/java/com/ctc/wstx/sr/AttributeCollector.java
index 7c7a858..a0b5e1f 100644
--- a/src/main/java/com/ctc/wstx/sr/AttributeCollector.java
+++ b/src/main/java/com/ctc/wstx/sr/AttributeCollector.java
@@ -46,7 +46,7 @@ import com.ctc.wstx.util.*;
  */
 public final class AttributeCollector
 {
-    final static int INT_SPACE = 0x0020;
+    protected final static int INT_SPACE = 0x0020;
 
     /**
      * Threshold value that indicates minimum length for lists instances
@@ -798,7 +798,7 @@ public final class AttributeCollector
             mAttributes[0] = new Attribute(attrPrefix, attrLocalName, 0);
         } else {
             int valueStart = mValueBuilder.getCharSize();
-            if (mAttrCount >= mAttributes.length) {
+            if (mAttrCount >= mAttributes.length) { // lgtm [java/dereferenced-value-may-be-null]
                 if ((mAttrCount + mNsCount) >= mMaxAttributesPerElement) {
                     throw new XMLStreamException("Attribute limit ("+mMaxAttributesPerElement+") exceeded");
                 }
@@ -920,18 +920,17 @@ public final class AttributeCollector
             mNamespaces[0] = new Attribute(null, prefix, 0);
         } else {
             int len = mNsCount;
-            /* Ok: must ensure that there are no duplicate namespace
-             * declarations (ie. decls with same prefix being bound)
-             */
+            // Ok: must ensure that there are no duplicate namespace
+            // declarations (ie. decls with same prefix being bound)
             if (prefix != null) { // null == default ns
                 for (int i = 0; i < len; ++i) {
                     // note: for ns decls, bound prefix is in 'local name'
-                    if (prefix == mNamespaces[i].mLocalName) {
+                    if (prefix == mNamespaces[i].mLocalName) { // lgtm [java/dereferenced-value-may-be-null]
                         return null;
                     }
                 }
             }
-            if (len >= mNamespaces.length) {
+            if (len >= mNamespaces.length) { // lgtm [java/dereferenced-value-may-be-null]
                 if ((mAttrCount + mNsCount) >= mMaxAttributesPerElement) {
                     throw new XMLStreamException("Attribute limit ("+mMaxAttributesPerElement+") exceeded");
                 }
@@ -1000,15 +999,13 @@ public final class AttributeCollector
          */
         int[] map = mAttrMap;
 
-        /* What's minimum size to contain at most 80% full hash area,
-         * plus 1/8 spill area (12.5% spilled entries, two ints each)?
-         */
+        // What's minimum size to contain at most 80% full hash area,
+        // plus 1/8 spill area (12.5% spilled entries, two ints each)?
         int hashCount = 4;
         {
             int min = attrCount + (attrCount >> 2); // == 80% fill rate
-            /* Need to get 2^N size that can contain all elements, with
-             * 80% fill rate
-             */
+            // Need to get 2^N size that can contain all elements, with
+            // 80% fill rate
             while (hashCount < min) {
                 hashCount += hashCount; // 2x
             }
@@ -1018,10 +1015,9 @@ public final class AttributeCollector
             if (map == null || map.length < min) {
                 map = new int[min];
             } else {
-                /* Need to clear old hash entries (if any). But note that
-                 * spilled entries we can leave alone -- they are just ints,
-                 * and get overwritten if and as needed
-                 */
+                // Need to clear old hash entries (if any). But note that
+                // spilled entries we can leave alone -- they are just ints,
+                // and get overwritten if and as needed
                 Arrays.fill(map, 0, hashCount, 0);
             }
         }
@@ -1041,14 +1037,13 @@ public final class AttributeCollector
                 }
                 int index = hash & mask;
                 // Hash slot available?
-                if (map[index] == 0) {
+                if (map[index] == 0) { // lgtm [java/dereferenced-value-may-be-null]
                     map[index] = i+1; // since 0 is marker
                 } else {
                     int currIndex = map[index]-1;
-                    /* nope, need to spill; let's extract most of that code to
-                     * a separate method for clarity (and maybe it'll be
-                     * easier to inline by JVM too)
-                     */
+                    // nope, need to spill; let's extract most of that code to
+                    // a separate method for clarity (and maybe it'll be
+                    // easier to inline by JVM too)
                     map = spillAttr(uri, name, map, currIndex, spillIndex,
                                     hash, hashCount);
                     if (map == null) {
