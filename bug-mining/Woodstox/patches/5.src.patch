diff --git a/release-notes/VERSION b/release-notes/VERSION
index 49bb10c..14b51b4 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -8,6 +8,8 @@ Project: woodstox
 
 #13: BasicStreamReader.getElementText() behavior doesn't match Java documentation
  (reported by Caleb-An@github)
+#21: 500 characters limit when calling XMLStreamReader#getText() after CDATA event
+ (reported by elrodro83@github)
 
 5.0.2 (10-Dec-2015)
 
diff --git a/src/main/java/com/ctc/wstx/sr/BasicStreamReader.java b/src/main/java/com/ctc/wstx/sr/BasicStreamReader.java
index 6fd92b1..545c830 100644
--- a/src/main/java/com/ctc/wstx/sr/BasicStreamReader.java
+++ b/src/main/java/com/ctc/wstx/sr/BasicStreamReader.java
@@ -55,7 +55,6 @@ import com.ctc.wstx.util.TextBuilder;
  * all functionality other than DTD-validation-specific parts, and
  * Typed Access API (Stax2 v3.0), which are implemented at
  * sub-classes.
- *<p>
  *
  * @author Tatu Saloranta
  */
@@ -91,12 +90,13 @@ public abstract class BasicStreamReader
     // token type figured out, but not long enough:
     final static int TOKEN_STARTED = 1;
 
-    /* minimum token length returnable achieved; only used for CDATA and
-     * CHARACTERS events which allow fragments to be returned
+    /* minimum token length returnable achieved; only used for
+     * CHARACTERS event which allow fragments to be returned (and for
+     * CDATA in some limited cases)
      */
     final static int TOKEN_PARTIAL_SINGLE = 2;
 
-    /* a single physical event has been succesfully tokenized; as with
+    /* a single physical event has been successfully tokenized; as with
      * partial, only used with CDATA and CHARACTERS (meaningless for others,
      * which should only use TOKEN_FULL_COALESCED, TOKEN_NOT_STARTED or
      * TOKEN_STARTED.
@@ -292,7 +292,7 @@ public abstract class BasicStreamReader
      * physical segment; or just even a fragment of such a segment)
      */
     protected final int mStTextThreshold;
-    
+
     /**
      * Sized of currentTextLength for CDATA, CHARACTERS, WHITESPACE.
      * When segmenting, this records to size of all the segments
@@ -437,10 +437,9 @@ public abstract class BasicStreamReader
         } else {
             mStTextThreshold =  TOKEN_PARTIAL_SINGLE;
             if (forER) {
-                /* 30-Sep-2005, TSa: No point in returning runt segments for
-                 *   event readers (due to event object overhead, less
-                 *   convenient); let's just force returning of full length
-                 *   segments.
+                /* 30-Sep-2005, TSa: No point in returning runt segments for event readers
+                 *   (due to event object overhead, less convenient); let's just force
+                 *   returning of full length segments.
                  */
                 mShortestTextSegment = Integer.MAX_VALUE;
             } else {
@@ -884,16 +883,17 @@ public abstract class BasicStreamReader
     @Override
     public String getText()
     {
-        if (((1 << mCurrToken) & MASK_GET_TEXT) == 0) {
-            throwNotTextual(mCurrToken);
+        final int currToken = mCurrToken;
+        if (((1 << currToken) & MASK_GET_TEXT) == 0) {
+            throwNotTextual(currToken);
         }
         if (mTokenState < mStTextThreshold) {
             safeFinishToken();
         }
-        if (mCurrToken == ENTITY_REFERENCE) {
+        if (currToken == ENTITY_REFERENCE) {
             return (mCurrEntity == null) ? null : mCurrEntity.getReplacementText();
         }
-        if (mCurrToken == DTD) {
+        if (currToken == DTD) {
             /* 16-Aug-2004, TSa: Hmmh. Specs are bit ambiguous on whether this
              *   should return just the internal subset, or the whole
              *   thing...
@@ -906,16 +906,17 @@ public abstract class BasicStreamReader
     @Override
     public char[] getTextCharacters()
     {
-        if (((1 << mCurrToken) & MASK_GET_TEXT_XXX) == 0) {
-            throwNotTextXxx(mCurrToken);
+        final int currToken = mCurrToken;
+        if (((1 << currToken) & MASK_GET_TEXT_XXX) == 0) {
+            throwNotTextXxx(currToken);
         }
         if (mTokenState < mStTextThreshold) {
             safeFinishToken();
         }
-        if (mCurrToken == ENTITY_REFERENCE) {
+        if (currToken == ENTITY_REFERENCE) {
             return mCurrEntity.getReplacementChars();
         }
-        if (mCurrToken == DTD) {
+        if (currToken == DTD) {
             return getDTDInternalSubsetArray();
         }
         return mTextBuffer.getTextBuffer();
@@ -924,8 +925,9 @@ public abstract class BasicStreamReader
     @Override
     public int getTextCharacters(int sourceStart, char[] target, int targetStart, int len)
     {
-        if (((1 << mCurrToken) & MASK_GET_TEXT_XXX) == 0) {
-            throwNotTextXxx(mCurrToken);
+        final int currToken = mCurrToken;
+        if (((1 << currToken) & MASK_GET_TEXT_XXX) == 0) {
+            throwNotTextXxx(currToken);
         }
         if (mTokenState < mStTextThreshold) {
             safeFinishToken();
@@ -936,8 +938,9 @@ public abstract class BasicStreamReader
     @Override
     public int getTextLength()
     {
-        if (((1 << mCurrToken) & MASK_GET_TEXT_XXX) == 0) {
-            throwNotTextXxx(mCurrToken);
+        final int currToken = mCurrToken;
+        if (((1 << currToken) & MASK_GET_TEXT_XXX) == 0) {
+            throwNotTextXxx(currToken);
         }
         if (mTokenState < mStTextThreshold) {
             safeFinishToken();
@@ -948,8 +951,9 @@ public abstract class BasicStreamReader
     @Override
     public int getTextStart()
     {
-        if (((1 << mCurrToken) & MASK_GET_TEXT_XXX) == 0) {
-            throwNotTextXxx(mCurrToken);
+        final int currToken = mCurrToken;
+        if (((1 << currToken) & MASK_GET_TEXT_XXX) == 0) {
+            throwNotTextXxx(currToken);
         }
         if (mTokenState < mStTextThreshold) {
             safeFinishToken();
@@ -1021,7 +1025,8 @@ public abstract class BasicStreamReader
     @Override
     public boolean isWhiteSpace()
     {
-        if (mCurrToken == CHARACTERS || mCurrToken == CDATA) {
+        final int currToken = mCurrToken;
+        if (currToken == CHARACTERS || currToken == CDATA) {
             if (mTokenState < mStTextThreshold) {
                 safeFinishToken();
             }
@@ -1031,7 +1036,7 @@ public abstract class BasicStreamReader
             }
             return mWsStatus == ALL_WS_YES;
         }
-        return (mCurrToken == SPACE);
+        return (currToken == SPACE);
     }
 
     @Override
@@ -1193,8 +1198,7 @@ public abstract class BasicStreamReader
     }
 
     @Override
-    public int nextTag()
-        throws XMLStreamException
+    public int nextTag() throws XMLStreamException
     {
         while (true) {
             int next = next();
@@ -1218,7 +1222,7 @@ public abstract class BasicStreamReader
                     continue;
                 }
                 throwParseError("Received non-all-whitespace CHARACTERS or CDATA event in nextTag().");
-		break; // never gets here, but jikes complains without
+                break; // never gets here, but jikes complains without
             case START_ELEMENT:
             case END_ELEMENT:
                 return next;
@@ -1236,8 +1240,7 @@ public abstract class BasicStreamReader
      * set to true.
      */
     @Override
-    public void close()
-        throws XMLStreamException
+    public void close() throws XMLStreamException
     {
         if (mParseState != STATE_CLOSED) {
             mParseState = STATE_CLOSED;
@@ -1408,8 +1411,9 @@ public abstract class BasicStreamReader
     public int getText(Writer w, boolean preserveContents)
         throws IOException, XMLStreamException
     {
-        if (((1 << mCurrToken) & MASK_GET_TEXT_WITH_WRITER) == 0) {
-            throwNotTextual(mCurrToken);
+        final int currToken = mCurrToken;
+        if (((1 << currToken) & MASK_GET_TEXT_WITH_WRITER) == 0) {
+            throwNotTextual(currToken);
         }
         /* May need to be able to do fully streaming... but only for
          * text events that have not yet been fully read; for other
@@ -1417,7 +1421,7 @@ public abstract class BasicStreamReader
          * already have everything ready.
          */
         if (!preserveContents) {
-            if (mCurrToken == CHARACTERS) {
+            if (currToken == CHARACTERS) {
                 int count = mTextBuffer.rawContentsTo(w);
                 /* Let's also clear whatever was collected (as allowed by
                  * method contract) previously, to both save memory, and
@@ -1435,7 +1439,7 @@ public abstract class BasicStreamReader
                     }
                 }
                 return count;
-            } else if (mCurrToken == CDATA) {
+            } else if (currToken == CDATA) {
                 int count = mTextBuffer.rawContentsTo(w);
                 mTextBuffer.resetWithEmpty(); // same as with CHARACTERS
                 if (mTokenState < TOKEN_FULL_SINGLE) {
@@ -1456,10 +1460,10 @@ public abstract class BasicStreamReader
              */
             finishToken(false); // false -> shouldn't defer errors
         }
-        if (mCurrToken == ENTITY_REFERENCE) {
+        if (currToken == ENTITY_REFERENCE) {
             return mCurrEntity.getReplacementText(w);
         }
-        if (mCurrToken == DTD) {
+        if (currToken == DTD) {
             char[] ch = getDTDInternalSubsetArray();
             if (ch != null) {
                 w.write(ch);
@@ -3773,9 +3777,9 @@ public abstract class BasicStreamReader
             if (mCfgCoalesceText) {
                 readCoalescedText(mCurrToken, deferErrors);
             } else {
-                if (readCDataSecondary(mShortestTextSegment)) {
+                if (readCDataSecondary(Integer.MAX_VALUE)) {
                     mTokenState = TOKEN_FULL_SINGLE;
-                } else {
+                } else { // can this ever happen?
                     mTokenState = TOKEN_PARTIAL_SINGLE;
                 }
             }
@@ -4485,6 +4489,8 @@ public abstract class BasicStreamReader
                 // If not, need more buffer space:
                 outBuf = tb.finishCurrentSegment();
                 outPtr = 0;
+                // 17-Aug-2016, tatu: need to make sure to enforce size limits here too
+                verifyLimit("Text size", mConfig.getMaxTextLength(), mTextBuffer.size());
             }
         }
         // never gets here
@@ -5580,21 +5586,19 @@ public abstract class BasicStreamReader
                         +input.getEntityId()+" contains closing tag for <"+top+">");
     }
 
-    private void throwNotTextual(int type)
-    {
+    private void throwNotTextual(int type) {
         throw new IllegalStateException("Not a textual event ("
-                                        +tokenTypeDesc(type)+")");
+                +tokenTypeDesc(type)+")");
     }
 
-    private void throwNotTextXxx(int type)
-    {
+    private void throwNotTextXxx(int type) {
         throw new IllegalStateException("getTextXxx() methods can not be called on "
-                                        +tokenTypeDesc(type));
+                +tokenTypeDesc(type));
     }
 
-    protected void throwNotTextualOrElem(int type)
-    {
-        throw new IllegalStateException(MessageFormat.format(ErrorConsts.ERR_STATE_NOT_ELEM_OR_TEXT, new Object[] { tokenTypeDesc(type) }));
+    protected void throwNotTextualOrElem(int type) {
+        throw new IllegalStateException(MessageFormat.format(ErrorConsts.ERR_STATE_NOT_ELEM_OR_TEXT,
+                new Object[] { tokenTypeDesc(type) }));
     }
 
     /**
diff --git a/src/main/java/com/ctc/wstx/sr/StreamScanner.java b/src/main/java/com/ctc/wstx/sr/StreamScanner.java
index 3d1c1dd..b58decc 100644
--- a/src/main/java/com/ctc/wstx/sr/StreamScanner.java
+++ b/src/main/java/com/ctc/wstx/sr/StreamScanner.java
@@ -248,7 +248,7 @@ public abstract class StreamScanner
      * Custom resolver used to handle external entities that are to be expanded
      * by this reader (external param/general entity expander)
      */
-    XMLResolver mEntityResolver = null;
+    protected XMLResolver mEntityResolver = null;
 
     /**
      * This is the current depth of the input stack (same as what input
@@ -335,13 +335,13 @@ public abstract class StreamScanner
      * Input stream encoding, if known (passed in, or determined by
      * auto-detection); null if not.
      */
-    String mDocInputEncoding = null;
+    protected String mDocInputEncoding = null;
 
     /**
      * Character encoding from xml declaration, if any; null if no
      * declaration, or it didn't specify encoding.
      */
-    String mDocXmlEncoding = null;
+    protected String mDocXmlEncoding = null;
 
     /**
      * XML version as declared by the document; one of constants
@@ -415,8 +415,7 @@ public abstract class StreamScanner
     protected WstxInputLocation getLastCharLocation()
     {
         return mInput.getLocation(mCurrInputProcessed + mInputPtr - 1,
-                                  mCurrInputRow,
-                                  mInputPtr - mCurrInputRowStart);
+                mCurrInputRow, mInputPtr - mCurrInputRowStart);
     }
 
     protected URL getSource() throws IOException {
@@ -444,15 +443,14 @@ public abstract class StreamScanner
     public XMLStreamLocation2 getStartLocation()
     {
         // note: +1 is used as columns are 1-based...
-        return mInput.getLocation(mTokenInputTotal, mTokenInputRow,
-                                  mTokenInputCol + 1);
+        return mInput.getLocation(mTokenInputTotal,
+                mTokenInputRow, mTokenInputCol + 1);
     }
 
     public XMLStreamLocation2 getCurrentLocation()
     {
         return mInput.getLocation(mCurrInputProcessed + mInputPtr,
-                                  mCurrInputRow,
-                                  mInputPtr - mCurrInputRowStart + 1);
+                mCurrInputRow, mInputPtr - mCurrInputRowStart + 1);
     }
 
     /*
@@ -590,9 +588,8 @@ public abstract class StreamScanner
     public void reportValidationProblem(String msg)
         throws XMLStreamException
     {
-        reportValidationProblem(new XMLValidationProblem(getLastCharLocation(),
-                                                         msg,
-                                                         XMLValidationProblem.SEVERITY_ERROR));
+        reportValidationProblem(new XMLValidationProblem(getLastCharLocation(), msg,
+                XMLValidationProblem.SEVERITY_ERROR));
     }
 
     public void reportValidationProblem(Location loc, String msg)
@@ -651,15 +648,11 @@ public abstract class StreamScanner
         throw new WstxUnexpectedCharException(excMsg, getLastCharLocation(), c);
     }
 
-    protected void throwNullChar()
-        throws WstxException
-    {
+    protected void throwNullChar() throws WstxException {
         throw constructNullCharException();
     }
 
-    protected void throwInvalidSpace(int i)
-        throws WstxException
-    {
+    protected void throwInvalidSpace(int i) throws WstxException {
         throwInvalidSpace(i, false);
     }
 
@@ -686,9 +679,8 @@ public abstract class StreamScanner
     protected void throwUnexpectedEOF(String msg)
         throws WstxException
     {
-        throw new WstxEOFException("Unexpected EOF"
-                                   +(msg == null ? "" : msg),
-                                   getLastCharLocation());
+        throw new WstxEOFException("Unexpected EOF"+(msg == null ? "" : msg),
+                getLastCharLocation());
     }
 
     /**
@@ -700,19 +692,16 @@ public abstract class StreamScanner
     protected void throwUnexpectedEOB(String msg)
         throws WstxException
     {
-        throw new WstxEOFException("Unexpected end of input block"
-                                   +(msg == null ? "" : msg),
-                                   getLastCharLocation());
+        throw new WstxEOFException("Unexpected end of input block"+(msg == null ? "" : msg),
+                getLastCharLocation());
     }
 
-    protected void throwFromIOE(IOException ioe)
-        throws WstxException
-    {
+    protected void throwFromIOE(IOException ioe) throws WstxException {
         throw new WstxIOException(ioe);
     }
 
     protected void throwFromStrE(XMLStreamException strex)
-        throws WstxException
+            throws WstxException
     {
         if (strex instanceof WstxException) {
             throw (WstxException) strex;
@@ -732,8 +721,7 @@ public abstract class StreamScanner
         ExceptionUtil.throwRuntimeException(e);
     }
 
-    protected String tokenTypeDesc(int type)
-    {
+    protected String tokenTypeDesc(int type) {
         return ErrorConsts.tokenTypeDesc(type);
     }
 
@@ -758,8 +746,7 @@ public abstract class StreamScanner
     }
 
     @SuppressWarnings("cast")
-    protected final int getNext()
-        throws XMLStreamException
+    protected final int getNext() throws XMLStreamException
     {
         if (mInputPtr >= mInputEnd) {
             if (!loadMore()) {
diff --git a/src/test/java/org/codehaus/stax/test/stream/TestCDataRead.java b/src/test/java/org/codehaus/stax/test/stream/TestCDataRead.java
index ae7cb7c..30c9f60 100644
--- a/src/test/java/org/codehaus/stax/test/stream/TestCDataRead.java
+++ b/src/test/java/org/codehaus/stax/test/stream/TestCDataRead.java
@@ -227,7 +227,40 @@ public class TestCDataRead
         sr.close();
         in.close();
     }
-    
+
+    // [woodstox-core#21]: CDATA contents truncated to buffer size (500 initially)
+    public void testLongerCData2() throws Exception
+    {
+        String SRC_TEXT =
+                "\r\n123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\r\n"
+                          + "<embededElement>Woodstox 4.0.5 does not like this embedded element.  However, if you take\r\n"
+                          + "out one or more characters from the really long line (so that less than 500 characters come between\r\n"
+                          + "'CDATA[' and the opening of the embeddedElement tag (including LF), then Woodstox will instead\r\n"
+                          + "complain that the CDATA section wasn't ended.";
+        String DST_TEXT = SRC_TEXT.replace("\r\n", "\n");
+        String XML = "<?xml version='1.0' encoding='utf-8'?>\r\n"
+                     + "<test><![CDATA[" + SRC_TEXT + "]]></test>";
+        XMLInputFactory f = getInputFactory();
+        // important: don't force coalescing, that'll convert CDATA to CHARACTERS
+        f.setProperty(XMLInputFactory.IS_COALESCING, Boolean.FALSE);
+
+        XMLStreamReader sr = f.createXMLStreamReader(new StringReader(XML));
+        assertTokenType(START_DOCUMENT, sr.getEventType());
+        assertTokenType(START_ELEMENT, sr.next());
+        assertEquals("test", sr.getLocalName());
+        assertTokenType(CDATA, sr.next());
+        // This should still work, although with linefeed replacements
+        final String text = sr.getText();
+        if (text.length() != DST_TEXT.length()) {
+            fail("Length expected as "+DST_TEXT.length()+", was "+text.length());
+        }
+        if (!text.equals(DST_TEXT)) {
+            fail("Length as expected ("+DST_TEXT.length()+"), contents differ:\n"+text);
+        }
+        assertTokenType(END_ELEMENT, sr.next());
+        sr.close();
+    }
+
     /*
     ////////////////////////////////////////
     // Private methods, other
diff --git a/src/test/java/wstxtest/stream/TestCharacterLimits.java b/src/test/java/wstxtest/stream/TestCharacterLimits.java
index 1a55550..eb1bca8 100644
--- a/src/test/java/wstxtest/stream/TestCharacterLimits.java
+++ b/src/test/java/wstxtest/stream/TestCharacterLimits.java
@@ -95,20 +95,24 @@ public class TestCharacterLimits
             _verifyTextLimitException(ex);
         }
     }
+
     public void testLongCDATANextTag() throws Exception {
+        Reader reader = createLongReader("<![CDATA[", "]]>", true);
+        XMLInputFactory factory = getNewInputFactory();
+        factory.setProperty(WstxInputProperties.P_MAX_TEXT_LENGTH, Integer.valueOf(1000));
+        XMLStreamReader xmlreader = factory.createXMLStreamReader(reader);
         try {
-            Reader reader = createLongReader("<![CDATA[", "]]>", true);
-            XMLInputFactory factory = getNewInputFactory();
-            factory.setProperty(WstxInputProperties.P_MAX_TEXT_LENGTH, Integer.valueOf(1000));
-            XMLStreamReader xmlreader = factory.createXMLStreamReader(reader);
+            int tokens = 0;
             while (xmlreader.next() != XMLStreamReader.START_ELEMENT) {
+                ++tokens;
             }
-            xmlreader.nextTag();
-            fail("Should have failed");
+            int code = xmlreader.nextTag();
+            fail("Should have failed: instead got "+tokens+" tokens; and one following START_ELEMENT: "+code);
         } catch (XMLStreamException ex) {
             _verifyTextLimitException(ex);
         }
     }
+
     public void testLongComment() throws Exception {
         try {
             Reader reader = createLongReader("<!--", "-->", true);
@@ -117,26 +121,14 @@ public class TestCharacterLimits
             XMLStreamReader xmlreader = factory.createXMLStreamReader(reader);
             while (xmlreader.next() != XMLStreamReader.COMMENT) {
             }
-            System.out.println(xmlreader.getText());
-            fail("Should have failed");
-        } catch (Exception ex) {
-            _verifyTextLimitException(ex);
-        }
-    }
-    public void testLongComment2() throws Exception {
-        try {
-            Reader reader = createLongReader("<!--", "-->", true);
-            XMLInputFactory factory = getNewInputFactory();
-            factory.setProperty(WstxInputProperties.P_MAX_TEXT_LENGTH, Integer.valueOf(1000));
-            XMLStreamReader xmlreader = factory.createXMLStreamReader(reader);
-            while (xmlreader.next() != XMLStreamReader.COMMENT) {
-            }
-            System.out.println(new String(xmlreader.getTextCharacters()));
-            fail("Should have failed");
+            // important, due to lazy handling only triggers problem here:
+            String str = xmlreader.getText();
+            fail("Should have failed; instead got: "+str);
         } catch (Exception ex) {
             _verifyTextLimitException(ex);
         }
     }
+
     public void testLongCommentNextTag() throws Exception {
         try {
             Reader reader = createLongReader("<!--", "-->", true);
@@ -184,9 +176,13 @@ public class TestCharacterLimits
         }
     }
     
-    private Reader createLongReader(final String pre, final String post, final boolean ws) {
-        final int max = Integer.MAX_VALUE;
+    private Reader createLongReader(final String pre, final String post, final boolean ws)
+    {
+        // 17-Aug-2016, tatu: used to be Integer.MAX_VALUE, but since we are testing with
+        //     way smaller limit, just do 1 meg
+        final int maxLength = 16 * 1024 * 1024;
         final StringBuffer start = new StringBuffer("<ns:element xmlns:ns=\"http://foo.com\">" + pre);
+
         return new Reader() {
             StringReader sreader = new StringReader(start.toString());
             int count;
@@ -194,23 +190,23 @@ public class TestCharacterLimits
             
             @Override
             public int read(char[] cbuf, int off, int len) throws IOException {
+                if (done) {
+                    return -1;
+                }
                 int i = sreader.read(cbuf, off, len);
-                if (i == -1) {
-                    if (count < max) {
-                        if (ws) {
-                            sreader = new StringReader("                              ");
-                        } else {
-                            sreader = new StringReader("1234567890123<?foo?>78901234567890");                            
-                        }
-                        count++;
-                    } else if (!done) {
-                        if (ws) {
-                            sreader = new StringReader(post + "</ns:element>");
-                        } else {
-                            sreader = new StringReader(post + "<ns:el2>foo</ns:el2></ns:element>");
-                        }
+                if (i < 0) {
+                    String text;
+                    if (count < maxLength) {
+                        text = ws ? "                              "
+                                : "1234567890123<?foo?>78901234567890";
+                    } else {
+                        text = post +
+                                (ws ? "</ns:element>"
+                                : "<ns:el2>foo</ns:el2></ns:element>");
                         done = true;
                     }
+                    sreader = new StringReader(text);
+                    count += text.length();
                     i = sreader.read(cbuf, off, len);
                 }
                 return i;
