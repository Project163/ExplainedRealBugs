diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index 0472e037c..f10d28d0b 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -1658,6 +1658,26 @@ report.write.dialog.message=File creation may have failed or is not complete.
 report.write.permission.dir.dialog.message=Directory not writable:\n{0}\nPlease select a different location.
 report.write.permission.file.dialog.message=File not writable:\n{0}\nPlease select a different location.
 
+ruleConfig.api.action.resetRuleConfigValue		= Reset the specified rule configuration, which must already exist
+ruleConfig.api.action.resetAllRuleConfigValues	= Reset all of the rule configurations
+ruleConfig.api.action.setRuleConfigValue		= Set the specified rule configuration, which must already exist
+ruleConfig.api.view.ruleConfigValue				= Show the specified rule configuration
+ruleConfig.api.view.allRuleConfigs				= Show all of the rule configurations
+ruleconfig.desc					= Active and passive rule configuration
+ruleconfig.dialog.button.reset	= Reset
+ruleconfig.dialog.label.key		= Key:
+ruleconfig.dialog.label.value	= Value:
+ruleconfig.dialog.label.default	= Default:
+ruleconfig.dialog.label.desc	= Description:
+ruleconfig.dialog.title			= Edit Rule Configuration
+ruleconfig.options.button.reset	= Reset All to Defaults
+ruleconfig.options.table.header.key		= Key
+ruleconfig.options.table.header.default	= Default
+ruleconfig.options.table.header.value	= Value
+ruleconfig.options.title 		= Rule Configuration
+
+rules.common.sleep = The length of time in seconds used for timing attacks
+
 scanner.category.browser = Client Browser
 scanner.category.info    = Information Gathering
 scanner.category.inject  = Injection
diff --git a/src/org/parosproxy/paros/core/scanner/HostProcess.java b/src/org/parosproxy/paros/core/scanner/HostProcess.java
index cb3248c3a..6805e9eab 100644
--- a/src/org/parosproxy/paros/core/scanner/HostProcess.java
+++ b/src/org/parosproxy/paros/core/scanner/HostProcess.java
@@ -58,6 +58,7 @@
 // ZAP: 2016/04/21 Allow scanners to notify of messages sent (and tweak the progress and request count of each plugin)
 // ZAP: 2016/06/29 Allow to specify and obtain the reason why a scanner was skipped
 // ZAP: 2016/07/12 Do not allow techSet to be null
+// ZAP: 2016/07/01 Issue 2647 Support a/pscan rule configuration 
 
 package org.parosproxy.paros.core.scanner;
 
@@ -79,6 +80,8 @@ import org.parosproxy.paros.network.ConnectionParam;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpSender;
 import org.zaproxy.zap.extension.ascan.ScanPolicy;
+import org.zaproxy.zap.extension.ruleconfig.RuleConfig;
+import org.zaproxy.zap.extension.ruleconfig.RuleConfigParam;
 import org.zaproxy.zap.model.SessionStructure;
 import org.zaproxy.zap.model.StructuralNode;
 import org.zaproxy.zap.model.TechSet;
@@ -101,6 +104,7 @@ public class HostProcess implements Runnable {
     private Kb kb = null;
     private User user = null;
     private TechSet techSet;
+    private RuleConfigParam ruleConfigParam;
 
     /**
      * A {@code Map} from plugin IDs to corresponding {@link PluginStats}.
@@ -125,13 +129,14 @@ public class HostProcess implements Runnable {
      */
     public HostProcess(String hostAndPort, Scanner parentScanner, 
     		ScannerParam scannerParam, ConnectionParam connectionParam, 
-    		ScanPolicy scanPolicy) {
+    		ScanPolicy scanPolicy, RuleConfigParam ruleConfigParam) {
         
         super();
         this.hostAndPort = hostAndPort;
         this.parentScanner = parentScanner;
         this.scannerParam = scannerParam;
 		this.pluginFactory = scanPolicy.getPluginFactory().clone();
+		this.ruleConfigParam = ruleConfigParam;
 		
         httpSender = new HttpSender(connectionParam, true, HttpSender.ACTIVE_SCANNER_INITIATOR);
         httpSender.setUser(this.user);
@@ -370,6 +375,12 @@ public class HostProcess implements Runnable {
 
             test = plugin.getClass().newInstance();
             test.setConfig(plugin.getConfig());
+            if (this.ruleConfigParam != null) {
+	            // Set the configuration rules
+	            for (RuleConfig rc : this.ruleConfigParam.getAllRuleConfigs()) {
+	                test.getConfig().setProperty(rc.getKey(), rc.getValue());
+	            }
+            }
             test.setDelayInMs(plugin.getDelayInMs());
             test.setDefaultAlertThreshold(plugin.getAlertThreshold());
             test.setDefaultAttackStrength(plugin.getAttackStrength());
diff --git a/src/org/parosproxy/paros/core/scanner/Scanner.java b/src/org/parosproxy/paros/core/scanner/Scanner.java
index d9c0decc1..9edea8ee9 100644
--- a/src/org/parosproxy/paros/core/scanner/Scanner.java
+++ b/src/org/parosproxy/paros/core/scanner/Scanner.java
@@ -39,6 +39,7 @@
 // ZAP: 2015/10/21 Issue 1576: Removed SiteNode cast no longer needed
 // ZAP: 2015/12/14 Prevent scans from becoming in undefined state
 // ZAP: 2016/07/12 Do not allow techSet to be null
+// ZAP: 2016/07/01 Issue 2647 Support a/pscan rule configuration 
 
 package org.parosproxy.paros.core.scanner;
 
@@ -64,6 +65,7 @@ import org.parosproxy.paros.model.SiteNode;
 import org.parosproxy.paros.network.ConnectionParam;
 import org.parosproxy.paros.network.HttpMessage;
 import org.zaproxy.zap.extension.ascan.ScanPolicy;
+import org.zaproxy.zap.extension.ruleconfig.RuleConfigParam;
 import org.zaproxy.zap.extension.script.ScriptCollection;
 import org.zaproxy.zap.model.StructuralNode;
 import org.zaproxy.zap.model.StructuralSiteNode;
@@ -85,6 +87,7 @@ public class Scanner implements Runnable {
 	private ScannerParam scannerParam = null;
 	private ConnectionParam connectionParam = null;
 	private ScanPolicy scanPolicy;
+	private RuleConfigParam ruleConfigParam;
 	private boolean isStop = false;
 	private ThreadPool pool = null;
 	private Target target = null;
@@ -102,10 +105,12 @@ public class Scanner implements Runnable {
 	
 	private List<HostProcess> hostProcesses = new ArrayList<>();
 
-    public Scanner(ScannerParam scannerParam, ConnectionParam param, ScanPolicy scanPolicy) {
+    public Scanner(ScannerParam scannerParam, ConnectionParam param, 
+    		ScanPolicy scanPolicy, RuleConfigParam ruleConfigParam) {
 	    this.connectionParam = param;
 	    this.scannerParam = scannerParam;
 	    this.scanPolicy = scanPolicy;
+	    this.ruleConfigParam = ruleConfigParam;
 	    pool = new ThreadPool(scannerParam.getHostPerScan());
 	    
 	  //ZAP: Load all scanner hooks from extensionloader. 
@@ -188,7 +193,8 @@ public class Scanner implements Runnable {
 	    		while (iter.hasNext()) {
 		        	StructuralNode child = iter.next();
 		            String hostAndPort = getHostAndPort(child);
-		            hostProcess = new HostProcess(hostAndPort, this, scannerParam, connectionParam, scanPolicy);
+		            hostProcess = new HostProcess(hostAndPort, this, scannerParam, 
+		            		connectionParam, scanPolicy, ruleConfigParam);
 		            hostProcess.setStartNode(child);
 		            hostProcess.setUser(this.user);
 		            hostProcess.setTechSet(this.techSet);
@@ -208,7 +214,8 @@ public class Scanner implements Runnable {
 		            String hostAndPort = getHostAndPort(node);
 		            hostProcess = processMap.get(hostAndPort);
 		            if (hostProcess == null) {
-			            hostProcess = new HostProcess(hostAndPort, this, scannerParam, connectionParam, scanPolicy);
+			            hostProcess = new HostProcess(hostAndPort, this, 
+			            		scannerParam, connectionParam, scanPolicy, ruleConfigParam);
 			            hostProcess.setStartNode(node);
 			            hostProcess.setUser(this.user);
 			            hostProcess.setTechSet(this.techSet);
@@ -235,7 +242,8 @@ public class Scanner implements Runnable {
 	    	for (SiteNode node : nodes) {
 			    HostProcess hostProcess = null;
 	            String hostAndPort = getHostAndPort(node);
-	            hostProcess = new HostProcess(hostAndPort, this, scannerParam, connectionParam, scanPolicy);
+	            hostProcess = new HostProcess(hostAndPort, this, scannerParam, 
+	            		connectionParam, scanPolicy, ruleConfigParam);
 	            hostProcess.setStartNode(new StructuralSiteNode(node));
 	            hostProcess.setUser(this.user);
 	            hostProcess.setTechSet(this.techSet);
@@ -258,7 +266,8 @@ public class Scanner implements Runnable {
 	    	for (SiteNode node : nodes) {
 			    HostProcess hostProcess = null;
 	            String hostAndPort = getHostAndPort(node);
-	            hostProcess = new HostProcess(hostAndPort, this, scannerParam, connectionParam, scanPolicy);
+	            hostProcess = new HostProcess(hostAndPort, this, scannerParam, 
+	            		connectionParam, scanPolicy, ruleConfigParam);
 	            hostProcess.setStartNode(new StructuralSiteNode(node));
 	            hostProcess.setUser(this.user);
 	            hostProcess.setTechSet(this.techSet);
diff --git a/src/org/zaproxy/zap/control/CoreFunctionality.java b/src/org/zaproxy/zap/control/CoreFunctionality.java
index 6107df200..3c5faf6d0 100644
--- a/src/org/zaproxy/zap/control/CoreFunctionality.java
+++ b/src/org/zaproxy/zap/control/CoreFunctionality.java
@@ -101,6 +101,7 @@ public final class CoreFunctionality {
 			extensions.add(new org.zaproxy.zap.extension.log4j.ExtensionLog4j());
 			extensions.add(new org.zaproxy.zap.extension.params.ExtensionParams());
 			extensions.add(new org.zaproxy.zap.extension.pscan.ExtensionPassiveScan());
+			extensions.add(new org.zaproxy.zap.extension.ruleconfig.ExtensionRuleConfig());
 			extensions.add(new org.zaproxy.zap.extension.script.ExtensionScript());
 			extensions.add(new org.zaproxy.zap.extension.search.ExtensionSearch());
 			extensions.add(new org.zaproxy.zap.extension.sessions.ExtensionSessionManagement());
diff --git a/src/org/zaproxy/zap/extension/ascan/ActiveScan.java b/src/org/zaproxy/zap/extension/ascan/ActiveScan.java
index 7294fceba..3fe00662d 100644
--- a/src/org/zaproxy/zap/extension/ascan/ActiveScan.java
+++ b/src/org/zaproxy/zap/extension/ascan/ActiveScan.java
@@ -45,6 +45,7 @@ import org.parosproxy.paros.network.ConnectionParam;
 import org.parosproxy.paros.network.HttpMalformedHeaderException;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.view.View;
+import org.zaproxy.zap.extension.ruleconfig.RuleConfigParam;
 import org.zaproxy.zap.model.GenericScanner2;
 import org.zaproxy.zap.model.Target;
 
@@ -82,9 +83,15 @@ public class ActiveScan extends org.parosproxy.paros.core.scanner.Scanner implem
 
 	private static final Logger log = Logger.getLogger(ActiveScan.class);
 
+	@Deprecated
 	public ActiveScan(String displayName, ScannerParam scannerParam, 
 			ConnectionParam param, ScanPolicy scanPolicy) {
-		super(scannerParam, param, scanPolicy);
+		this(displayName, scannerParam, param, scanPolicy, null);
+	}
+
+	public ActiveScan(String displayName, ScannerParam scannerParam, 
+			ConnectionParam param, ScanPolicy scanPolicy, RuleConfigParam ruleConfigParam) {
+		super(scannerParam, param, scanPolicy, ruleConfigParam);
 		this.displayName = displayName;
 		this.maxResultsToList = scannerParam.getMaxResultsToList();
 		// Easiest way to get the messages and alerts ;) 
diff --git a/src/org/zaproxy/zap/extension/ascan/ActiveScanController.java b/src/org/zaproxy/zap/extension/ascan/ActiveScanController.java
index d96171cf7..b3c918154 100644
--- a/src/org/zaproxy/zap/extension/ascan/ActiveScanController.java
+++ b/src/org/zaproxy/zap/extension/ascan/ActiveScanController.java
@@ -26,11 +26,14 @@ import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
 import org.apache.log4j.Logger;
+import org.parosproxy.paros.control.Control;
 import org.parosproxy.paros.core.scanner.Alert;
 import org.parosproxy.paros.core.scanner.ScannerParam;
 import org.parosproxy.paros.model.Model;
 import org.parosproxy.paros.model.Session;
 import org.zaproxy.zap.extension.alert.ExtensionAlert;
+import org.zaproxy.zap.extension.ruleconfig.ExtensionRuleConfig;
+import org.zaproxy.zap.extension.ruleconfig.RuleConfigParam;
 import org.zaproxy.zap.extension.script.ScriptCollection;
 import org.zaproxy.zap.model.ScanController;
 import org.zaproxy.zap.model.Target;
@@ -102,9 +105,17 @@ public class ActiveScanController implements ScanController<ActiveScan> {
 		activeScansLock.lock();
 		try {
 			int id = this.scanIdCounter++;
+			
+			RuleConfigParam ruleConfigParam = null;
+			ExtensionRuleConfig extRC = 
+				Control.getSingleton().getExtensionLoader().getExtension(ExtensionRuleConfig.class);
+			if (extRC != null) {
+				ruleConfigParam = extRC.getRuleConfigParam();
+			}
+			
 			ActiveScan ascan = new ActiveScan(name, extension.getScannerParam(), 
 					extension.getModel().getOptionsParam().getConnectionParam(), 
-					null) {
+					null, ruleConfigParam) {
 				@Override
 				public void alertFound(Alert alert) {
 					if (extAlert!= null) {
diff --git a/src/org/zaproxy/zap/extension/ascan/AttackModeScanner.java b/src/org/zaproxy/zap/extension/ascan/AttackModeScanner.java
index dcb3bd3cb..f916b8ba1 100644
--- a/src/org/zaproxy/zap/extension/ascan/AttackModeScanner.java
+++ b/src/org/zaproxy/zap/extension/ascan/AttackModeScanner.java
@@ -47,6 +47,8 @@ import org.zaproxy.zap.eventBus.Event;
 import org.zaproxy.zap.eventBus.EventConsumer;
 import org.zaproxy.zap.extension.alert.ExtensionAlert;
 import org.zaproxy.zap.extension.log4j.ExtensionLog4j;
+import org.zaproxy.zap.extension.ruleconfig.ExtensionRuleConfig;
+import org.zaproxy.zap.extension.ruleconfig.RuleConfigParam;
 import org.zaproxy.zap.view.ScanStatus;
 
 public class AttackModeScanner implements EventConsumer {
@@ -216,8 +218,17 @@ public class AttackModeScanner implements EventConsumer {
 		public void run() {
 			log.debug("Starting attack thread");
 			this.running = true;
+
+			RuleConfigParam ruleConfigParam = null;
+			ExtensionRuleConfig extRC = 
+				Control.getSingleton().getExtensionLoader().getExtension(ExtensionRuleConfig.class);
+			if (extRC != null) {
+				ruleConfigParam = extRC.getRuleConfigParam();
+			}
+
 			ascanWrapper = new AttackScan(Constant.messages.getString("ascan.attack.scan"), extension.getScannerParam(), 
-					extension.getModel().getOptionsParam().getConnectionParam(), extension.getPolicyManager().getAttackScanPolicy());
+					extension.getModel().getOptionsParam().getConnectionParam(), 
+					extension.getPolicyManager().getAttackScanPolicy(), ruleConfigParam);
 			extension.registerScan(ascanWrapper);
 			while (running) {
 				if (scanStatus.getScanCount() != nodeStack.size()) {
@@ -239,9 +250,11 @@ public class AttackModeScanner implements EventConsumer {
 				while (nodeStack.size() > 0 && scanners.size() < scannerCount) {
 					SiteNode node = nodeStack.remove(0);
 					log.debug("Attacking node " + node.getNodeName());
+					
 					Scanner scanner = new Scanner(extension.getScannerParam(), 
 							extension.getModel().getOptionsParam().getConnectionParam(), 
-							extension.getPolicyManager().getAttackScanPolicy());
+							extension.getPolicyManager().getAttackScanPolicy(),
+							ruleConfigParam);
 					scanner.setStartNode(node);
 					scanner.setScanChildren(false);
 					scanner.addScannerListener(this);
diff --git a/src/org/zaproxy/zap/extension/ascan/AttackScan.java b/src/org/zaproxy/zap/extension/ascan/AttackScan.java
index b615b6a8d..53ad0ac72 100644
--- a/src/org/zaproxy/zap/extension/ascan/AttackScan.java
+++ b/src/org/zaproxy/zap/extension/ascan/AttackScan.java
@@ -21,6 +21,7 @@ package org.zaproxy.zap.extension.ascan;
 
 import org.parosproxy.paros.core.scanner.ScannerParam;
 import org.parosproxy.paros.network.ConnectionParam;
+import org.zaproxy.zap.extension.ruleconfig.RuleConfigParam;
 import org.zaproxy.zap.model.Target;
 
 /**
@@ -30,8 +31,9 @@ import org.zaproxy.zap.model.Target;
  */
 public class AttackScan extends ActiveScan {
 
-	public AttackScan(String displayName, ScannerParam scannerParam, ConnectionParam param, ScanPolicy scanPolicy) {
-		super(displayName, scannerParam, param, scanPolicy);
+	public AttackScan(String displayName, ScannerParam scannerParam, 
+			ConnectionParam param, ScanPolicy scanPolicy, RuleConfigParam ruleConfigParam) {
+		super(displayName, scannerParam, param, scanPolicy, ruleConfigParam);
 	}
 	
 	@Override
diff --git a/src/org/zaproxy/zap/extension/ruleconfig/DialogEditRuleConfig.java b/src/org/zaproxy/zap/extension/ruleconfig/DialogEditRuleConfig.java
new file mode 100644
index 000000000..ec95e3a63
--- /dev/null
+++ b/src/org/zaproxy/zap/extension/ruleconfig/DialogEditRuleConfig.java
@@ -0,0 +1,99 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0 
+ *   
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.  
+ */
+package org.zaproxy.zap.extension.ruleconfig;
+
+import java.awt.Dimension;
+import java.awt.Window;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.JButton;
+
+import org.parosproxy.paros.Constant;
+import org.zaproxy.zap.utils.ZapTextArea;
+import org.zaproxy.zap.view.StandardFieldsDialog;
+
+public class DialogEditRuleConfig extends StandardFieldsDialog {
+
+    private static final String FIELD_KEY = "ruleconfig.dialog.label.key"; 
+    private static final String FIELD_VALUE = "ruleconfig.dialog.label.value"; 
+    private static final String FIELD_DEFAULT = "ruleconfig.dialog.label.default"; 
+    private static final String FIELD_DESC = "ruleconfig.dialog.label.desc"; 
+
+    private static final long serialVersionUID = 1L;
+
+    private JButton resetButton;
+    private RuleConfig rc;
+    private RuleConfigTableModel model;
+
+    public DialogEditRuleConfig(Window owner) {
+        super(owner, "ruleconfig.dialog.title", new Dimension(400, 300), true);
+    }
+
+    public void init (RuleConfig rc, RuleConfigTableModel model) {
+        this.rc = rc;
+        this.model = model;
+
+        this.removeAllFields();
+        
+        this.addReadOnlyField(FIELD_KEY, rc.getKey(), false);
+        this.addReadOnlyField(FIELD_DEFAULT, rc.getDefaultValue(), false);
+        this.addTextField(FIELD_VALUE, rc.getValue());
+        String desc = "";
+        if (Constant.messages.containsKey(rc.getKey())) {
+            desc = Constant.messages.getString(rc.getKey());
+        }
+        this.addMultilineField(FIELD_DESC, desc);
+        ((ZapTextArea)this.getField(FIELD_DESC)).setEditable(false);
+    }
+
+    private JButton getResetButton () {
+        if (resetButton == null) {
+            resetButton = new JButton(
+                    Constant.messages.getString("ruleconfig.dialog.button.reset"));
+            resetButton.addActionListener(new ActionListener() {
+
+                @Override
+                public void actionPerformed(ActionEvent arg0) {
+                    setFieldValue(FIELD_VALUE, rc.getDefaultValue());
+                }});
+        }
+        return resetButton;
+    }
+
+    @Override
+    public JButton[] getExtraButtons () {
+        return new JButton[] {getResetButton()};
+    }
+
+    @Override
+    public void save() {
+        if (! this.getStringValue(FIELD_VALUE).equals(this.rc.getValue())) {
+            this.model.setRuleConfigValue (rc.getKey(), this.getStringValue(FIELD_VALUE));
+        }
+    }
+
+    @Override
+    public String validateFields() {
+        // Nothing to do
+        return null;
+    }
+    
+}
diff --git a/src/org/zaproxy/zap/extension/ruleconfig/ExtensionRuleConfig.java b/src/org/zaproxy/zap/extension/ruleconfig/ExtensionRuleConfig.java
new file mode 100644
index 000000000..4baac8f87
--- /dev/null
+++ b/src/org/zaproxy/zap/extension/ruleconfig/ExtensionRuleConfig.java
@@ -0,0 +1,120 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2016 The ZAP Development team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.extension.ruleconfig;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.List;
+
+import org.parosproxy.paros.Constant;
+import org.parosproxy.paros.extension.ExtensionAdaptor;
+import org.parosproxy.paros.extension.ExtensionHook;
+import org.zaproxy.zap.extension.api.API;
+
+public class ExtensionRuleConfig extends ExtensionAdaptor {
+
+    public static final String NAME = "ExtensionRuleConfig";
+    
+    private OptionsRuleConfigPanel optionsRuleConfigPanel;
+    private RuleConfigParam ruleConfigParam;
+
+    public ExtensionRuleConfig() {
+        super(NAME);
+    }
+
+    public void addRuleconfig (RuleConfig rc) {
+        this.getRuleConfigParam().addRuleConfig(rc);
+    }
+
+    @Override
+    public void hook(ExtensionHook extensionHook) {
+        extensionHook.addOptionsParamSet(getRuleConfigParam());
+        if (extensionHook.getView() != null) {
+            extensionHook.getHookView().addOptionPanel(getOptionsRuleConfigPanel());
+        }
+        
+        API.getInstance().registerApiImplementor(new RuleConfigAPI(this));
+    }
+    
+    public RuleConfigParam getRuleConfigParam() {
+        if (ruleConfigParam == null) {
+            ruleConfigParam = new RuleConfigParam();
+        }
+        return ruleConfigParam;
+    }
+
+    public List<RuleConfig> getAllRuleConfigs() {
+        return this.getRuleConfigParam().getAllRuleConfigs();
+    }
+
+    public RuleConfig getRuleConfig (String key) {
+        RuleConfig rc = this.getRuleConfigParam().getRuleConfig(key);
+        if (rc != null) {
+            return rc.clone();
+        }
+        return null;
+    }
+
+    public void setRuleConfigValue(String key, String value) {
+        this.getRuleConfigParam().setRuleConfigValue(key, value);
+    }
+
+    public void resetRuleConfigValue(String key) {
+        this.getRuleConfigParam().resetRuleConfigValue(key);
+    }
+
+    public void resetAllRuleConfigValues() {
+        this.getRuleConfigParam().resetAllRuleConfigValues();
+    }
+
+    private OptionsRuleConfigPanel getOptionsRuleConfigPanel() {
+        if (optionsRuleConfigPanel == null) {
+            optionsRuleConfigPanel = new OptionsRuleConfigPanel(this);
+        }
+        return optionsRuleConfigPanel;
+    }
+    
+    @Override
+    public String getAuthor() {
+        return Constant.ZAP_TEAM;
+    }
+
+    @Override
+    public String getDescription() {
+        return Constant.messages.getString("ruleconfig.desc");
+    }
+
+    @Override
+    public URL getURL() {
+        try {
+            return new URL(Constant.ZAP_HOMEPAGE);
+        } catch (MalformedURLException e) {
+            return null;
+        }
+    }
+
+    /**
+     * No database tables used, so all supported
+     */
+    @Override
+    public boolean supportsDb(String type) {
+        return true;
+    }
+}
diff --git a/src/org/zaproxy/zap/extension/ruleconfig/OptionsRuleConfigPanel.java b/src/org/zaproxy/zap/extension/ruleconfig/OptionsRuleConfigPanel.java
new file mode 100644
index 000000000..249d44fe5
--- /dev/null
+++ b/src/org/zaproxy/zap/extension/ruleconfig/OptionsRuleConfigPanel.java
@@ -0,0 +1,175 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0 
+ *   
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.zaproxy.zap.extension.ruleconfig;
+
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.JButton;
+import javax.swing.JLabel;
+import javax.swing.SortOrder;
+import javax.swing.SwingUtilities;
+
+import org.apache.log4j.Logger;
+import org.parosproxy.paros.Constant;
+import org.parosproxy.paros.view.AbstractParamPanel;
+import org.parosproxy.paros.view.View;
+import org.zaproxy.zap.view.LayoutHelper;
+import org.zaproxy.zap.view.MultipleOptionsTablePanel;
+
+public class OptionsRuleConfigPanel extends AbstractParamPanel {
+
+    private static final long serialVersionUID = 1L;
+    private static final Logger logger = Logger.getLogger(OptionsRuleConfigPanel.class);
+
+    private ExtensionRuleConfig extension;
+    private RuleConfigOptionsPanel ruleConfigOptionsPanel;
+    private JButton resetButton;
+
+    private RuleConfigTableModel ruleConfigModel;
+    
+    public OptionsRuleConfigPanel(ExtensionRuleConfig extension) {
+        super();
+        this.extension = extension;
+         initialize();
+    }
+
+    private void initialize() {
+        this.setName(Constant.messages.getString("ruleconfig.options.title"));
+        this.setLayout(new GridBagLayout());
+
+        GridBagConstraints gbc = new GridBagConstraints();
+        gbc.gridx = 0;
+        gbc.weightx = 1.0;
+        gbc.anchor = GridBagConstraints.LINE_START;
+        gbc.fill = GridBagConstraints.BOTH;
+
+        ruleConfigOptionsPanel = new RuleConfigOptionsPanel(getRuleConfigModel());
+        
+        gbc.weighty = 1.0;
+        this.add(ruleConfigOptionsPanel, 
+                LayoutHelper.getGBC(0, 0, 5, 1.0D, 1.0D, GridBagConstraints.BOTH, 
+                        GridBagConstraints.LINE_START, null));
+        
+        this.add(new JLabel(), LayoutHelper.getGBC(0, 1, 1, 0.5D, 0));    // Spacer
+        this.add(getResetButton(), LayoutHelper.getGBC(3, 1, 1, 0, 0));
+        this.add(new JLabel(), LayoutHelper.getGBC(4, 1, 1, 0.5D, 0));    // Spacer
+        
+    }
+
+    @Override
+    public void initParam(Object obj) {
+        this.getRuleConfigModel().setRuleConfigs(extension.getAllRuleConfigs());
+        ruleConfigOptionsPanel.packAll();
+    }
+
+    @Override
+    public void validateParam(Object obj) throws Exception {
+        // Nothing to do
+    }
+
+    private JButton getResetButton() {
+        if (resetButton == null) {
+            resetButton = new JButton(Constant.messages.getString("ruleconfig.options.button.reset"));
+            resetButton.addActionListener(new ActionListener() {
+                @Override
+                public void actionPerformed(ActionEvent e) {
+                    for (RuleConfig rc : getRuleConfigModel().getElements()) {
+                        rc.reset();
+                    }
+                    getRuleConfigModel().fireTableDataChanged();
+                }});
+        }
+        return resetButton;
+    }
+
+    @Override
+    public void saveParam(Object obj) throws Exception {
+        for (RuleConfig rc : getRuleConfigModel().getElements()) {
+            if (rc.isChanged()) {
+                logger.debug("Setting rule config " + rc.getKey() + " to " + rc.getValue());
+                extension.setRuleConfigValue(rc.getKey(), rc.getValue());
+            }
+        }
+    }
+
+    private RuleConfigTableModel getRuleConfigModel() {
+        if (ruleConfigModel == null) {
+            ruleConfigModel = new RuleConfigTableModel();
+        }
+        return ruleConfigModel;
+    }
+
+    @Override
+    public String getHelpIndex() {
+        return "ui.dialogs.options.ruleconfig";
+    }
+
+    private static class RuleConfigOptionsPanel extends MultipleOptionsTablePanel {
+        
+        private static final long serialVersionUID = -115340627058929308L;
+        
+        private DialogEditRuleConfig modifyDialog = null;
+        
+        private RuleConfigTableModel model;
+        
+        public RuleConfigOptionsPanel(final RuleConfigTableModel model) {
+            super(model);
+            
+            this.model = model;
+
+            // Sort on the key names
+            getTable().setSortOrder(0, SortOrder.ASCENDING);
+            
+            getTable().addMouseListener(new java.awt.event.MouseAdapter() { 
+                @Override
+                public void mousePressed(java.awt.event.MouseEvent e) {
+
+                    if (SwingUtilities.isLeftMouseButton(e)) {
+                        int row = getTable().getSelectedRow();
+                        if (row >= 0) {
+                            // This is just a single click
+                            showModifyDialogue(model.getElements().get(getTable().convertRowIndexToModel(row)));
+                        }
+                    }
+
+                }
+            });
+        }
+        
+        protected void packAll() {
+            getTable().packAll();
+        }
+
+        public void showModifyDialogue(RuleConfig rc) {
+            if (modifyDialog == null) {
+                modifyDialog = new DialogEditRuleConfig(
+                        View.getSingleton().getOptionsDialog(null));
+                modifyDialog.pack();
+            }
+            modifyDialog.init(rc, model);
+            modifyDialog.setVisible(true);
+        }
+        
+    }
+
+}
diff --git a/src/org/zaproxy/zap/extension/ruleconfig/RuleConfig.java b/src/org/zaproxy/zap/extension/ruleconfig/RuleConfig.java
new file mode 100644
index 000000000..e8ecd3966
--- /dev/null
+++ b/src/org/zaproxy/zap/extension/ruleconfig/RuleConfig.java
@@ -0,0 +1,77 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0 
+ *   
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.zaproxy.zap.extension.ruleconfig;
+
+
+public class RuleConfig implements Cloneable {
+
+    private String key;
+    private String value;
+    private String defaultValue;
+    
+    private boolean changed;
+
+    public RuleConfig() {
+    }
+
+    public RuleConfig(String key, String defaultValue, String value) {
+        super();
+        this.key = key;
+        this.defaultValue = defaultValue;
+        this.value = value;
+    }
+
+    public RuleConfig(String key, String defaultValue) {
+        super();
+        this.key = key;
+        this.defaultValue = defaultValue;
+        this.value = defaultValue;
+    }
+    
+    @Override
+    protected RuleConfig clone() {
+        return new RuleConfig(key, defaultValue, value);
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    public void setValue(String value) {
+        this.value = value;
+        this.changed = true;
+    }
+
+    public String getKey() {
+        return key;
+    }
+
+    public String getDefaultValue() {
+        return defaultValue;
+    }
+
+    public boolean isChanged() {
+        return changed;
+    }
+    
+    public void reset() {
+        this.setValue(this.defaultValue);
+    }
+}
diff --git a/src/org/zaproxy/zap/extension/ruleconfig/RuleConfigAPI.java b/src/org/zaproxy/zap/extension/ruleconfig/RuleConfigAPI.java
new file mode 100644
index 000000000..f36a08266
--- /dev/null
+++ b/src/org/zaproxy/zap/extension/ruleconfig/RuleConfigAPI.java
@@ -0,0 +1,141 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0 
+ *   
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.  
+ */
+package org.zaproxy.zap.extension.ruleconfig;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import net.sf.json.JSONObject;
+
+import org.parosproxy.paros.Constant;
+import org.zaproxy.zap.extension.api.ApiAction;
+import org.zaproxy.zap.extension.api.ApiException;
+import org.zaproxy.zap.extension.api.ApiImplementor;
+import org.zaproxy.zap.extension.api.ApiResponse;
+import org.zaproxy.zap.extension.api.ApiResponseElement;
+import org.zaproxy.zap.extension.api.ApiResponseList;
+import org.zaproxy.zap.extension.api.ApiResponseSet;
+import org.zaproxy.zap.extension.api.ApiView;
+
+public class RuleConfigAPI extends ApiImplementor {
+
+    private static final String PREFIX = "ruleConfig";
+    
+    private static final String ACTION_RESET_RULE_CONFIG_VALUE = "resetRuleConfigValue";
+    private static final String ACTION_RESET_ALL_RULE_CONFIG_VALUES = "resetAllRuleConfigValues";
+    private static final String ACTION_SET_RULE_CONFIG_VALUE = "setRuleConfigValue";
+
+    private static final String VIEW_RULE_CONFIG_VALUE = "ruleConfigValue";
+    private static final String VIEW_ALL_RULE_CONFIGS = "allRuleConfigs";
+
+    private static final String PARAM_KEY = "key";
+    private static final String PARAM_VALUE = "value";
+
+    private ExtensionRuleConfig extension;
+    
+    public RuleConfigAPI(ExtensionRuleConfig extension) {
+        this.extension = extension;
+        this.addApiAction(new ApiAction(ACTION_RESET_RULE_CONFIG_VALUE, new String[] {PARAM_KEY}));
+        this.addApiAction(new ApiAction(ACTION_RESET_ALL_RULE_CONFIG_VALUES));
+        this.addApiAction(new ApiAction(ACTION_SET_RULE_CONFIG_VALUE, 
+                new String[] {PARAM_KEY}, new String[] {PARAM_VALUE}));
+        this.addApiView(new ApiView(VIEW_RULE_CONFIG_VALUE, new String[] {PARAM_KEY}));
+        this.addApiView(new ApiView(VIEW_ALL_RULE_CONFIGS));
+    }
+
+    @Override
+    public String getPrefix() {
+        return PREFIX;
+    }
+
+    @Override
+    public ApiResponse handleApiAction(String name, JSONObject params) throws ApiException {
+        RuleConfig rc;
+        switch (name) {
+        case ACTION_SET_RULE_CONFIG_VALUE:
+            rc = extension.getRuleConfig(params.getString(PARAM_KEY));
+            if (rc != null) {
+                if (params.containsKey(PARAM_VALUE)) {
+                    extension.setRuleConfigValue(rc.getKey(), params.getString(PARAM_VALUE));
+                } else {
+                    extension.setRuleConfigValue(rc.getKey(), "");
+                }
+            } else {
+                throw new ApiException(ApiException.Type.DOES_NOT_EXIST, PARAM_KEY);
+            }
+            break;
+        case ACTION_RESET_RULE_CONFIG_VALUE:
+            rc = extension.getRuleConfig(params.getString(PARAM_KEY));
+            if (rc != null) {
+                extension.resetRuleConfigValue(rc.getKey());
+            } else {
+                throw new ApiException(ApiException.Type.DOES_NOT_EXIST, PARAM_KEY);
+            }
+            break;
+        case ACTION_RESET_ALL_RULE_CONFIG_VALUES:
+            extension.resetAllRuleConfigValues();
+            break;
+        default:
+            throw new ApiException(ApiException.Type.BAD_ACTION);
+        }
+
+        return ApiResponseElement.OK;
+    }
+
+    @Override
+    public ApiResponse handleApiView(String name, JSONObject params)
+            throws ApiException {
+        ApiResponse result;
+
+        switch (name) {
+        case VIEW_RULE_CONFIG_VALUE:
+            RuleConfig rc = extension.getRuleConfig(params.getString(PARAM_KEY));
+            if (rc != null) {
+                result = new ApiResponseElement(name, rc.getValue());
+            } else {
+                throw new ApiException(ApiException.Type.DOES_NOT_EXIST, PARAM_KEY);
+            }
+            
+            break;
+        case VIEW_ALL_RULE_CONFIGS:
+            List<RuleConfig> allRules = extension.getAllRuleConfigs();
+            
+            ApiResponseList resultList = new ApiResponseList(name);
+            for (RuleConfig rc2 : allRules) {
+                Map<String, String> map = new HashMap<>();
+                map.put("key", String.valueOf(rc2.getKey()));
+                map.put("defaultValue", rc2.getDefaultValue());
+                map.put("value", String.valueOf(rc2.getValue()));
+                if (Constant.messages.containsKey(rc2.getKey())) {
+                    map.put("description", Constant.messages.getString(rc2.getKey()));
+                }
+                resultList.addItem(new ApiResponseSet("ruleConfig", map));
+            }
+            
+            result = resultList;
+            break;
+        default:
+            throw new ApiException(ApiException.Type.BAD_VIEW);
+        }
+        return result;
+    }
+
+}
diff --git a/src/org/zaproxy/zap/extension/ruleconfig/RuleConfigParam.java b/src/org/zaproxy/zap/extension/ruleconfig/RuleConfigParam.java
new file mode 100644
index 000000000..019fbe1d0
--- /dev/null
+++ b/src/org/zaproxy/zap/extension/ruleconfig/RuleConfigParam.java
@@ -0,0 +1,132 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0 
+ *   
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+package org.zaproxy.zap.extension.ruleconfig;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.parosproxy.paros.common.AbstractParam;
+
+public class RuleConfigParam extends AbstractParam {
+
+    private static final String RULES_BASE_KEY = "rules";
+    private static final String RULES_DEFAULT_KEY_EXT = ".default";
+    
+    private Map<String, RuleConfig> ruleConfigs = new HashMap<String, RuleConfig>();
+
+    public RuleConfigParam() {
+    }
+
+    @Override
+    protected void parse() {
+        // Add the built in rule configs
+        this.addRuleConfig(new RuleConfig("rules.common.sleep", "5"));
+        
+        Iterator<String> iter = this.getConfig().getKeys(RULES_BASE_KEY);
+        RuleConfig rc;
+        while (iter.hasNext()) {
+            String key = iter.next();
+            if (ruleConfigs.containsKey(key)) {
+                ruleConfigs.get(key).setValue(this.getConfig().getString(key));
+            } else {
+                // Rules can specify an optional default value in the config file
+                rc = new RuleConfig(
+                    key, 
+                    this.getConfig().getString(key + RULES_DEFAULT_KEY_EXT, ""),
+                    this.getConfig().getString(key));
+                this.ruleConfigs.put(rc.getKey(), rc);
+            }
+        }
+    }
+
+    public void addRuleConfig (RuleConfig rc) {
+        this.ruleConfigs.put(rc.getKey(), rc);
+        if (! this.getConfig().containsKey(rc.getKey())) {
+            // Dont overwrite an existing value
+            this.getConfig().setProperty(rc.getKey(), rc.getValue());
+        }
+    }
+
+    public void addRuleConfig (String key, String defaultValue, String value) {
+        this.ruleConfigs.put(key, new RuleConfig(key, defaultValue, value));
+        if (! this.getConfig().containsKey(key)) {
+            // Dont overwrite an existing value
+            this.getConfig().setProperty(key, value);
+        }
+    }
+    
+    public RuleConfig getRuleConfig (String key) {
+        if (ruleConfigs.containsKey(key)) {
+            return ruleConfigs.get(key).clone();
+        }
+        return null;
+    }
+    
+    public List<RuleConfig> getAllRuleConfigs () {
+        ArrayList<RuleConfig> list = new ArrayList<RuleConfig>();
+        for (RuleConfig rc : ruleConfigs.values()) {
+            list.add(rc.clone());
+        }
+        return list;
+    }
+    
+    public String getRuleConfigValue (String key) {
+        if (ruleConfigs.containsKey(key)) {
+            return ruleConfigs.get(key).getValue();
+        }
+        return null;
+    }
+    
+    public String getRuleConfigDefaultValue (String key) {
+        if (ruleConfigs.containsKey(key)) {
+            return ruleConfigs.get(key).getDefaultValue();
+        }
+        return null;
+    }
+    
+    public void setRuleConfigValue(String key, String value) {
+        if (ruleConfigs.containsKey(key)) {
+            ruleConfigs.get(key).setValue(value);
+            this.getConfig().setProperty(key, value);
+        } else {
+            throw new IllegalArgumentException("No such key");
+        }
+    }
+
+    public void resetRuleConfigValue(String key) {
+        if (ruleConfigs.containsKey(key)) {
+            String value = ruleConfigs.get(key).getDefaultValue();
+            ruleConfigs.get(key).setValue(value);
+            this.getConfig().setProperty(key, value);
+        } else {
+            throw new IllegalArgumentException("No such key");
+        }
+    }
+
+    public void resetAllRuleConfigValues() {
+        for (RuleConfig rc : ruleConfigs.values()) {
+            rc.reset();
+            this.getConfig().setProperty(rc.getKey(), rc.getValue());
+        }
+    }
+}
diff --git a/src/org/zaproxy/zap/extension/ruleconfig/RuleConfigTableModel.java b/src/org/zaproxy/zap/extension/ruleconfig/RuleConfigTableModel.java
new file mode 100644
index 000000000..7a26bc623
--- /dev/null
+++ b/src/org/zaproxy/zap/extension/ruleconfig/RuleConfigTableModel.java
@@ -0,0 +1,115 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0 
+ *   
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License. 
+ */
+
+package org.zaproxy.zap.extension.ruleconfig;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.swing.table.AbstractTableModel;
+
+import org.parosproxy.paros.Constant;
+
+public class RuleConfigTableModel extends AbstractTableModel {
+
+    private static final long serialVersionUID = 1L;
+
+    private static final String[] COLUMN_NAMES = {
+            Constant.messages.getString("ruleconfig.options.table.header.key"),
+            Constant.messages.getString("ruleconfig.options.table.header.default"),
+            Constant.messages.getString("ruleconfig.options.table.header.value")};
+    
+    private static final int COLUMN_COUNT = COLUMN_NAMES.length;
+    
+    private List<RuleConfig> rcs = new ArrayList<>(0);
+    
+    public RuleConfigTableModel() {
+        super();
+    }
+    
+    protected List<RuleConfig> getElements() {
+        return rcs;
+    }
+
+    /**
+     * @param rcs The ruleconfigs to set.
+     */
+    public void setRuleConfigs(List<RuleConfig> rcs) {
+        this.rcs = new ArrayList<>(rcs.size());
+        
+        for (RuleConfig token : rcs) {
+            this.rcs.add(token);
+        }
+        
+            fireTableDataChanged();
+    }
+
+    @Override
+    public String getColumnName(int col) {
+        return COLUMN_NAMES[col];
+    }
+
+    @Override
+    public int getColumnCount() {
+        return COLUMN_COUNT;
+    }
+    
+    @Override
+    public Class<?> getColumnClass(int c) {
+        return String.class;
+    }
+
+    @Override
+    public int getRowCount() {
+        return rcs.size();
+    }
+
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return false;
+    }
+    
+    @Override
+    public Object getValueAt(int rowIndex, int columnIndex) {
+        switch(columnIndex) {
+        case 0:
+            return rcs.get(rowIndex).getKey();
+        case 1:
+            return rcs.get(rowIndex).getDefaultValue();
+        case 2:
+            return rcs.get(rowIndex).getValue();
+        }
+        return null;
+    }
+
+    public void setRuleConfigValue(String key, String value) {
+    	int row = 0;
+        for (RuleConfig token : rcs) {
+            // Not super efficient, but we dont expect there to be too many of these
+            if (token.getKey().equals(key)) {
+                token.setValue(value);
+                this.fireTableCellUpdated(row, 2);
+                return;
+            }
+            row++;
+        }
+    }
+
+}
diff --git a/test/org/zaproxy/zap/extension/ruleconfig/RuleConfigParamUnitTest.java b/test/org/zaproxy/zap/extension/ruleconfig/RuleConfigParamUnitTest.java
new file mode 100644
index 000000000..620ef88ce
--- /dev/null
+++ b/test/org/zaproxy/zap/extension/ruleconfig/RuleConfigParamUnitTest.java
@@ -0,0 +1,106 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development Team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.extension.ruleconfig;
+
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertThat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.runners.MockitoJUnitRunner;
+import org.zaproxy.zap.utils.ZapXmlConfiguration;
+
+@RunWith(MockitoJUnitRunner.class)
+public class RuleConfigParamUnitTest {
+
+	ZapXmlConfiguration configuration;
+
+	RuleConfigParam rcp;
+
+	@Before
+	public void setUp() throws Exception {
+		rcp = new RuleConfigParam();
+		configuration = new ZapXmlConfiguration();
+		rcp.load(configuration);
+	}
+
+	@Test
+	public void shouldReturnNullIfNoKey() {
+		assertThat(rcp.getRuleConfig("key"), is(equalTo(null)));
+	}
+
+	@Test
+	public void shouldRecordAddedRuleCorrectly() {
+		rcp.addRuleConfig("key", "defaultValue", "value");
+		assertThat(rcp.getRuleConfig("key").getKey(), is(equalTo("key")));
+		assertThat(rcp.getRuleConfig("key").getDefaultValue(), is(equalTo("defaultValue")));
+		assertThat(rcp.getRuleConfig("key").getValue(), is(equalTo("value")));
+		assertThat(configuration.getString("key"), is(equalTo("value")));
+	}
+
+	@Test
+	public void shouldUpdateRuleCorrectly() {
+		rcp.addRuleConfig("key", "defaultValue", "value");
+		rcp.setRuleConfigValue("key", "new value");
+		assertThat(rcp.getRuleConfig("key").getKey(), is(equalTo("key")));
+		assertThat(rcp.getRuleConfig("key").getDefaultValue(), is(equalTo("defaultValue")));
+		assertThat(rcp.getRuleConfig("key").getValue(), is(equalTo("new value")));
+		assertThat(configuration.getString("key"), is(equalTo("new value")));
+	}
+
+	@Test(expected=IllegalArgumentException.class)
+	public void shouldFailToUpdateMissingKey() {
+		rcp.addRuleConfig("key", "defaultValue", "value");
+		rcp.setRuleConfigValue("key2", "new value");
+	}
+
+	@Test(expected=IllegalArgumentException.class)
+	public void shouldFailToResetMissingKey() {
+		rcp.addRuleConfig("key", "defaultValue", "value");
+		rcp.resetRuleConfigValue("key2");
+	}
+
+	@Test
+	public void shouldResetRuleCorrectly() {
+		rcp.addRuleConfig("key", "defaultValue", "value");
+		rcp.resetRuleConfigValue("key");
+		assertThat(rcp.getRuleConfig("key").getKey(), is(equalTo("key")));
+		assertThat(rcp.getRuleConfig("key").getDefaultValue(), is(equalTo("defaultValue")));
+		assertThat(rcp.getRuleConfig("key").getValue(), is(equalTo("defaultValue")));
+		assertThat(configuration.getString("key"), is(equalTo("defaultValue")));
+	}
+
+	@Test
+	public void shouldResetAllRulesCorrectly() {
+		rcp.addRuleConfig("key1", "defaultValue1", "value1");
+		rcp.addRuleConfig("key2", "defaultValue2", "value2");
+		rcp.resetAllRuleConfigValues();;
+		assertThat(rcp.getRuleConfig("key1").getKey(), is(equalTo("key1")));
+		assertThat(rcp.getRuleConfig("key1").getDefaultValue(), is(equalTo("defaultValue1")));
+		assertThat(rcp.getRuleConfig("key1").getValue(), is(equalTo("defaultValue1")));
+		assertThat(rcp.getRuleConfig("key2").getKey(), is(equalTo("key2")));
+		assertThat(rcp.getRuleConfig("key2").getDefaultValue(), is(equalTo("defaultValue2")));
+		assertThat(rcp.getRuleConfig("key2").getValue(), is(equalTo("defaultValue2")));
+		assertThat(configuration.getString("key1"), is(equalTo("defaultValue1")));
+		assertThat(configuration.getString("key2"), is(equalTo("defaultValue2")));
+	}
+}
