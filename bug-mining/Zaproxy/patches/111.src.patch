diff --git a/src/org/parosproxy/paros/core/scanner/Variant.java b/src/org/parosproxy/paros/core/scanner/Variant.java
index 0d07c00f9..a389291b9 100644
--- a/src/org/parosproxy/paros/core/scanner/Variant.java
+++ b/src/org/parosproxy/paros/core/scanner/Variant.java
@@ -20,6 +20,7 @@
  */
 // ZAP: 2013/07/02 Changed Vector to generic List
 // ZAP: 2013/07/02 Changed API to public for future extensible Variant model
+// ZAP: 2016/05/04 Add JavaDoc to getParamList()
 package org.parosproxy.paros.core.scanner;
 
 import java.util.List;
@@ -29,7 +30,14 @@ import org.parosproxy.paros.network.HttpMessage;
 public interface Variant {
 
     public void setMessage(HttpMessage msg);
+
+    /**
+     * Gets the list of parameters handled by this variant.
+     * 
+     * @return a {@code List} containing the parameters
+     */
     public List<NameValuePair> getParamList();
+
     public String setParameter(HttpMessage msg, NameValuePair originalPair, String param, String value);
     public String setEscapedParameter(HttpMessage msg, NameValuePair originalPair, String param, String value);
     
diff --git a/src/org/parosproxy/paros/core/scanner/VariantAbstractQuery.java b/src/org/parosproxy/paros/core/scanner/VariantAbstractQuery.java
index fe04641e7..8cd9f7d1d 100644
--- a/src/org/parosproxy/paros/core/scanner/VariantAbstractQuery.java
+++ b/src/org/parosproxy/paros/core/scanner/VariantAbstractQuery.java
@@ -27,9 +27,11 @@
 // ZAP: 2013/08/21 Added a new encoding/decoding model for a correct parameter value interpretation
 // ZAP: 2014/01/06 Issue 965: Support 'single page' apps and 'non standard' parameter separators
 // ZAP: 2014/02/08 Used the same constants used in ScanParam Target settings
-//
+// ZAP: 2016/05/04 Changes to address issues related to ParameterParser
+
 package org.parosproxy.paros.core.scanner;
 
+import java.net.URLEncoder;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -64,6 +66,21 @@ public abstract class VariantAbstractQuery implements Variant {
      */
     protected abstract String getEscapedValue(HttpMessage msg, String value);
 
+    /**
+     * Gets parameter's name in encoded/escaped form.
+     * <p>
+     * Default implementation is to URL encode the name.
+     *
+     * @param msg the message that contains the parameter
+     * @param name the name to escape
+     * @return the escaped name
+     * @since TODO Add version
+     * @see URLEncoder#encode(String, String)
+     */
+    protected String getEscapedName(HttpMessage msg, String name) {
+        return name != null ? AbstractPlugin.getURLEncode(name) : "";
+    }
+
     /**
      * Return unescaped mutate of the value. To be overridden by subclass.
      * 
@@ -73,9 +90,10 @@ public abstract class VariantAbstractQuery implements Variant {
     protected abstract String getUnescapedValue(String value);
 
     /**
-     * 
-     * @param params 
+     * @deprecated (TODO add version) use {@link #setParameters(int, List)} instead.
      */
+    @Deprecated
+    @SuppressWarnings("javadoc")
     protected void setParams(int type, Map<String, String> params) {
         int i = 0;
         for (Entry<String, String> param : params.entrySet()) {
@@ -85,9 +103,27 @@ public abstract class VariantAbstractQuery implements Variant {
     }
 
     /**
+     * Sets the given {@code parameters} of the given {@code type} as the list of parameters handled by this variant.
+     * <p>
+     * The names and values of the parameters are expected to be in decoded form.
      *
-     * @return
+     * @param type the type of parameters
+     * @param parameters the actual parameters to add
+     * @since TODO add version
+     * @see #getParamList()
+     * @see NameValuePair#TYPE_QUERY_STRING
+     * @see NameValuePair#TYPE_POST_DATA
      */
+    protected void setParameters(int type, List<org.zaproxy.zap.model.NameValuePair> parameters) {
+        listParam.clear();
+
+        int i = 0;
+        for (org.zaproxy.zap.model.NameValuePair parameter : parameters) {
+            listParam.add(new NameValuePair(type, parameter.getName(), parameter.getValue(), i));
+            i++;
+        }
+    }
+
     @Override
     public List<NameValuePair> getParamList() {
         return listParam;
@@ -124,10 +160,10 @@ public abstract class VariantAbstractQuery implements Variant {
         for (int i = 0; i < getParamList().size(); i++) {
             pair = getParamList().get(i);
             if (i == originalPair.getPosition()) {
-                isAppended = paramAppend(sb, name, encodedValue, parser);
+                isAppended = paramAppend(sb, getEscapedName(msg, name), encodedValue, parser);
 
             } else {
-                isAppended = paramAppend(sb, pair.getName(), getEscapedValue(msg, pair.getValue()), parser);
+                isAppended = paramAppend(sb, getEscapedName(msg, pair.getName()), getEscapedValue(msg, pair.getValue()), parser);
             }
 
             if (isAppended && i < getParamList().size() - 1) {
diff --git a/src/org/parosproxy/paros/core/scanner/VariantFormQuery.java b/src/org/parosproxy/paros/core/scanner/VariantFormQuery.java
index 6848adf86..dc3a9d663 100644
--- a/src/org/parosproxy/paros/core/scanner/VariantFormQuery.java
+++ b/src/org/parosproxy/paros/core/scanner/VariantFormQuery.java
@@ -26,7 +26,8 @@
 // ZAP: 2013/12/09 Solved NullPointerException when the request header doesn't contain "Content-Type" header field
 // ZAP: 2014/01/06 Issue 965: Support 'single page' apps and 'non standard' parameter separators
 // ZAP: 2014/02/08 Used the same constants used in ScanParam Target settings
-//
+// ZAP: 2016/05/04 Changed to use setParameters(int, List<NameValuePair>)
+
 package org.parosproxy.paros.core.scanner;
 
 import org.parosproxy.paros.model.Model;
@@ -48,7 +49,7 @@ public class VariantFormQuery extends VariantAbstractQuery {
         String contentType = msg.getRequestHeader().getHeader(HttpHeader.CONTENT_TYPE);
         // ZAP: added control for null contentType
         if (contentType != null && contentType.startsWith(WWW_APP_URL_ENCODED)) {
-        	this.setParams(NameValuePair.TYPE_POST_DATA, Model.getSingleton().getSession().getParams(msg, Type.form));
+        	this.setParameters(NameValuePair.TYPE_POST_DATA, Model.getSingleton().getSession().getParameters(msg, Type.form));
         }
     }
             
diff --git a/src/org/parosproxy/paros/core/scanner/VariantURLQuery.java b/src/org/parosproxy/paros/core/scanner/VariantURLQuery.java
index 0ec2a82bd..39fbda225 100644
--- a/src/org/parosproxy/paros/core/scanner/VariantURLQuery.java
+++ b/src/org/parosproxy/paros/core/scanner/VariantURLQuery.java
@@ -24,7 +24,8 @@
 // ZAP: 2013/08/21 Added a new encoding/decoding model for a correct parameter value interpretation
 // ZAP: 2014/01/06 Issue 965: Support 'single page' apps and 'non standard' parameter separators
 // ZAP: 2014/02/08 Used the same constants used in ScanParam Target settings
-//
+// ZAP: 2016/05/04 Changed to use setParameters(int, List<NameValuePair>)
+
 package org.parosproxy.paros.core.scanner;
 
 import org.apache.commons.httpclient.URIException;
@@ -65,7 +66,7 @@ public class VariantURLQuery extends VariantAbstractQuery {
 
     @Override
     public void setMessage(HttpMessage msg) {
-       	this.setParams(NameValuePair.TYPE_QUERY_STRING, Model.getSingleton().getSession().getParams(msg, Type.url));
+       	this.setParameters(NameValuePair.TYPE_QUERY_STRING, Model.getSingleton().getSession().getParameters(msg, Type.url));
     }
 
     @Override
diff --git a/src/org/parosproxy/paros/model/Session.java b/src/org/parosproxy/paros/model/Session.java
index 96ca58220..ad287ce18 100644
--- a/src/org/parosproxy/paros/model/Session.java
+++ b/src/org/parosproxy/paros/model/Session.java
@@ -56,6 +56,7 @@
 // ZAP: 2015/12/14 Issue 2119: Context's description not imported
 // ZAP: 2016/02/26 Issue 2273: Clear stats on session init
 // ZAP: 2016/05/02 Issue 2451: Only a single Data Driven Node can be saved in a context
+// ZAP: 2016/05/04 Changes to address issues related to ParameterParser
 
 package org.parosproxy.paros.model;
 
@@ -66,6 +67,7 @@ import java.lang.reflect.InvocationTargetException;
 import java.security.InvalidParameterException;
 import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
@@ -90,6 +92,7 @@ import org.zaproxy.zap.control.ExtensionFactory;
 import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;
 import org.zaproxy.zap.extension.spider.ExtensionSpider;
 import org.zaproxy.zap.model.Context;
+import org.zaproxy.zap.model.NameValuePair;
 import org.zaproxy.zap.model.ParameterParser;
 import org.zaproxy.zap.model.StandardParameterParser;
 import org.zaproxy.zap.model.StructuralNodeModifier;
@@ -1389,6 +1392,38 @@ public class Session {
 		}
 	}
 
+	/**
+	 * Gets the parameters of the given {@code type} from the given {@code message}.
+	 * <p>
+	 * Parameters' names and values are in decoded form.
+	 *
+	 * @param msg the message whose parameters will be extracted from
+	 * @param type the type of parameters to extract
+	 * @return a {@code List} containing the parameters
+	 * @throws IllegalArgumentException if any of the parameters is {@code null} or if the given {@code type} is not
+	 *			 {@link org.parosproxy.paros.network.HtmlParameter.Type#url url} or
+	 *			 {@link org.parosproxy.paros.network.HtmlParameter.Type#form form}.
+	 * @since TODO add version
+	 * @see StandardParameterParser#getParameters(HttpMessage, org.parosproxy.paros.network.HtmlParameter.Type)
+	 */
+	public List<NameValuePair> getParameters(HttpMessage msg, HtmlParameter.Type type) {
+		if (msg == null) {
+			throw new IllegalArgumentException("Parameter msg must not be null.");
+		}
+		if (type == null) {
+			throw new IllegalArgumentException("Parameter type must not be null.");
+		}
+
+		switch (type) {
+		case form:
+			return this.getFormParamParser(msg.getRequestHeader().getURI().toString()).getParameters(msg, type);
+		case url:
+			return this.getUrlParamParser(msg.getRequestHeader().getURI().toString()).getParameters(msg, type);
+		default:
+			throw new IllegalArgumentException("The provided type is not supported: " + type);
+		}
+	}
+
 	/**
 	 * Returns the URL parameters for the given URL based on the parser associated with the
 	 * first context found that includes the URL, or the default parser if it is not
@@ -1398,7 +1433,11 @@ public class Session {
 	 * @throws URIException
 	 */
 	public Map<String, String> getUrlParams(URI uri) throws URIException {
-		return this.getUrlParamParser(uri.toString()).parse(uri.getQuery());
+		Map<String, String> map = new HashMap<>();
+		for (NameValuePair parameter : getUrlParamParser(uri.toString()).parseParameters(uri.getEscapedQuery())) {
+			map.put(parameter.getName(), parameter.getValue());
+		}
+		return map;
 	}
 
 	/**
diff --git a/src/org/zaproxy/zap/model/DefaultNameValuePair.java b/src/org/zaproxy/zap/model/DefaultNameValuePair.java
new file mode 100644
index 000000000..744233999
--- /dev/null
+++ b/src/org/zaproxy/zap/model/DefaultNameValuePair.java
@@ -0,0 +1,176 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development Team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.model;
+
+/**
+ * Default implementation of {@code NameValuePair}, in which the name and value are optional, that is, can be {@code null}.
+ * <p>
+ * The implementation is immutable thus thread safe.
+ *
+ * @since TODO add version
+ */
+public final class DefaultNameValuePair implements NameValuePair, Comparable<DefaultNameValuePair> {
+
+    /**
+     * The name of the pair, might be {@code null}.
+     */
+    private final String name;
+
+    /**
+     * The value of the pair, might be {@code null}.
+     */
+    private final String value;
+
+    /**
+     * Constructs a {@code DefaultNameValuePair} with no name nor value.
+     */
+    public DefaultNameValuePair() {
+        this(null, null);
+    }
+
+    /**
+     * Constructs a {@code DefaultNameValuePair} with the given {@code name} and no value.
+     *
+     * @param name the name, might be {@code null}
+     */
+    public DefaultNameValuePair(String name) {
+        this(name, null);
+    }
+
+    /**
+     * Constructs a {@code DefaultNameValuePair} with the given {@code name} and {@code value}.
+     *
+     * @param name the name, might be {@code null}
+     * @param value the value, might be {@code null}
+     */
+    public DefaultNameValuePair(String name, String value) {
+        this.name = name;
+        this.value = value;
+    }
+
+    /**
+     * @return the name, might be {@code null}
+     */
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @return the value, might be {@code null}
+     */
+    @Override
+    public String getValue() {
+        return value;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder strBuilder = new StringBuilder(75);
+        strBuilder.append("[");
+        if (name != null) {
+            strBuilder.append("Name=").append(name);
+        }
+        if (value != null) {
+            if (name != null) {
+                strBuilder.append(", ");
+            }
+            strBuilder.append("Value=").append(value);
+        }
+        strBuilder.append(']');
+        return strBuilder.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((name == null) ? 0 : name.hashCode());
+        result = prime * result + ((value == null) ? 0 : value.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        }
+        if (object == null) {
+            return false;
+        }
+        if (getClass() != object.getClass()) {
+            return false;
+        }
+
+        DefaultNameValuePair other = (DefaultNameValuePair) object;
+        if (!equalStrings(name, other.name)) {
+            return false;
+        }
+
+        if (!equalStrings(value, other.value)) {
+            return false;
+        }
+
+        return true;
+    }
+
+    private static boolean equalStrings(String string, String otherString) {
+        if (string == null) {
+            if (otherString != null) {
+                return false;
+            }
+        } else if (!string.equals(otherString)) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public int compareTo(DefaultNameValuePair other) {
+        if (other == null) {
+            return 1;
+        }
+
+        int res = compareStrings(name, other.name);
+        if (res != 0) {
+            return res;
+        }
+
+        res = compareStrings(value, other.value);
+        if (res != 0) {
+            return res;
+        }
+
+        return 0;
+    }
+
+    private static int compareStrings(String string, String otherString) {
+        if (string == null) {
+            if (otherString != null) {
+                return -1;
+            }
+            return 0;
+        } else if (otherString == null) {
+            return 1;
+        }
+
+        return string.compareTo(otherString);
+    }
+}
diff --git a/src/org/zaproxy/zap/model/NameValuePair.java b/src/org/zaproxy/zap/model/NameValuePair.java
new file mode 100644
index 000000000..47890b402
--- /dev/null
+++ b/src/org/zaproxy/zap/model/NameValuePair.java
@@ -0,0 +1,45 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development Team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.model;
+
+/**
+ * A name/value pair.
+ * <p>
+ * How {@code null} name and/or value are handled is at the discretion of implementations, for example, some implementations
+ * might choose to require a name, but not a value (thus being {@code null}).
+ *
+ * @since TODO add version
+ */
+public interface NameValuePair {
+
+    /**
+     * Gets the name of the name/value pair.
+     *
+     * @return the name
+     */
+    String getName();
+
+    /**
+     * Gets the value of the name/value pair.
+     *
+     * @return the value
+     */
+    String getValue();
+}
diff --git a/src/org/zaproxy/zap/model/ParameterParser.java b/src/org/zaproxy/zap/model/ParameterParser.java
index f77623e53..d857f11c0 100644
--- a/src/org/zaproxy/zap/model/ParameterParser.java
+++ b/src/org/zaproxy/zap/model/ParameterParser.java
@@ -31,8 +31,42 @@ public interface ParameterParser {
 
 	Map<String, String> getParams(HttpMessage msg, HtmlParameter.Type type);
 
+	/**
+	 * Gets the parameters of the given {@code type} from the given {@code message}.
+	 * <p>
+	 * The parameters are split using the key value pair separator(s) and each resulting parameter is split into name/value
+	 * pairs using key value separator(s).
+	 * <p>
+	 * Parameters' names and values are in decoded form.
+	 *
+	 * @param msg the message whose parameters will be extracted from
+	 * @param type the type of parameters to extract
+	 * @return a {@code List} containing the parameters
+	 * @throws IllegalArgumentException if the {@code msg} or {@code type} is {@code null}.
+	 * @since TODO add version
+	 * @see #getDefaultKeyValuePairSeparator()
+	 * @see #getDefaultKeyValueSeparator()
+	 */
+	List<NameValuePair> getParameters(HttpMessage msg, HtmlParameter.Type type);
+
 	Map<String, String> parse(String paramStr);
 
+	/**
+	 * Parses the given {@code parameters} into a list of {@link NameValuePair}.
+	 * <p>
+	 * The parameters are split using the key value pair separator(s) and each resulting parameter is split into name/value
+	 * pairs using key value separator(s).
+	 * <p>
+	 * Parameters' names and values are in decoded form.
+	 *
+	 * @param parameters the String of parameters to parse, might be {@code null}
+	 * @return a {@code List} containing the parameters parsed
+	 * @since TODO add version
+	 * @see #getDefaultKeyValuePairSeparator()
+	 * @see #getDefaultKeyValueSeparator()
+	 */
+	List<NameValuePair> parseParameters(String parameters);
+
 	List<String> getTreePath(URI uri) throws URIException;
 	
 	List<String> getTreePath(HttpMessage msg) throws URIException;
diff --git a/src/org/zaproxy/zap/model/StandardParameterParser.java b/src/org/zaproxy/zap/model/StandardParameterParser.java
index 4e3e05b89..7d6700300 100644
--- a/src/org/zaproxy/zap/model/StandardParameterParser.java
+++ b/src/org/zaproxy/zap/model/StandardParameterParser.java
@@ -17,6 +17,8 @@
  */
 package org.zaproxy.zap.model;
 
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
 import java.security.InvalidParameterException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -36,6 +38,7 @@ import org.apache.commons.httpclient.URIException;
 import org.apache.log4j.Logger;
 import org.parosproxy.paros.network.HtmlParameter;
 import org.parosproxy.paros.network.HttpMessage;
+import org.parosproxy.paros.network.HtmlParameter.Type;
 
 public class StandardParameterParser implements ParameterParser {
 	
@@ -104,17 +107,44 @@ public class StandardParameterParser implements ParameterParser {
 	    if (msg == null) {
 	    	return map;
 	    }
-	    try {
-			switch (type) {
-			case form:	return this.parse(msg.getRequestBody().toString());
-			case url:	return this.parse(msg.getRequestHeader().getURI().getQuery());
-			default:
-						throw new InvalidParameterException("Type not supported: " + type);
+		switch (type) {
+		case form:	return this.parse(msg.getRequestBody().toString());
+		case url:
+			for (NameValuePair parameter : parseParameters(msg.getRequestHeader().getURI().getEscapedQuery())) {
+				map.put(parameter.getName(), parameter.getValue());
 			}
-		} catch (URIException e) {
-			log.error(e.getMessage(), e);
+			return map;
+		default:
+					throw new InvalidParameterException("Type not supported: " + type);
+		}
+	}
+
+	/**
+	 * @throws IllegalArgumentException if any of the parameters is {@code null} or if the given {@code type} is not
+	 *             {@link org.parosproxy.paros.network.HtmlParameter.Type#url url} or
+	 *             {@link org.parosproxy.paros.network.HtmlParameter.Type#form form}.
+	 */
+	@Override
+	public List<NameValuePair> getParameters(HttpMessage msg, Type type) {
+		if (msg == null) {
+			throw new IllegalArgumentException("Parameter msg must not be null.");
+		}
+		if (type == null) {
+			throw new IllegalArgumentException("Parameter type must not be null.");
+		}
+
+		switch (type) {
+		case form:
+			return parseParameters(msg.getRequestBody().toString());
+		case url:
+			String query = msg.getRequestHeader().getURI().getEscapedQuery();
+			if (query == null) {
+				return new ArrayList<>(0);
+			}
+			return parseParameters(query);
+		default:
+			throw new IllegalArgumentException("The provided type is not supported: " + type);
 		}
-		return map;
 	}
 
 	private void setKeyValueSeparatorPattern(Pattern keyValueSeparatorPattern) {
@@ -192,6 +222,34 @@ public class StandardParameterParser implements ParameterParser {
 		}
 		return map;
 	}
+
+	@Override
+	public List<NameValuePair> parseParameters(String parameters) {
+		if (parameters == null) {
+			return new ArrayList<>(0);
+		}
+
+		List<NameValuePair> parametersList = new ArrayList<>();
+		String[] pairs = getKeyValuePairSeparatorPattern().split(parameters);
+		for (int i = 0; i < pairs.length; i++) {
+			String[] nameValuePair = getKeyValueSeparatorPattern().split(pairs[i], 2);
+			if (nameValuePair.length == 1) {
+				parametersList.add(new DefaultNameValuePair(urlDecode(nameValuePair[0])));
+			} else {
+				parametersList.add(new DefaultNameValuePair(urlDecode(nameValuePair[0]), urlDecode(nameValuePair[1])));
+			}
+		}
+		return parametersList;
+	}
+
+	private static String urlDecode(String value) {
+		try {
+			return URLDecoder.decode(value, "UTF-8");
+		} catch (UnsupportedEncodingException ignore) {
+			// Shouldn't happen UTF-8 is a standard charset (see java.nio.charset.StandardCharsets)
+		}
+		return "";
+	}
 	
 	@Override
 	public StandardParameterParser clone() {
@@ -250,7 +308,10 @@ public class StandardParameterParser implements ParameterParser {
 		}
 		if (incStructParams) {
 			// Add any structural params (url param) in key order
-			Map<String, String> urlParams = this.parse(uri.getQuery());
+			Map<String, String> urlParams = new HashMap<>();
+			for (NameValuePair parameter : parseParameters(uri.getEscapedQuery())) {
+				urlParams.put(parameter.getName(), parameter.getValue());
+			}
 			List<String> keys = new ArrayList<String>(urlParams.keySet());
 			Collections.sort(keys);
 			for (String key: keys) {
@@ -311,7 +372,10 @@ public class StandardParameterParser implements ParameterParser {
 
 		// Add the 'structural params' path elements
 		boolean firstElement = true;
-		Map<String, String> urlParams = this.parse(uri.getQuery());
+		Map<String, String> urlParams = new HashMap<>();
+		for (NameValuePair parameter : parseParameters(uri.getEscapedQuery())) {
+			urlParams.put(parameter.getName(), parameter.getValue());
+		}
 		for (Entry<String, String> param : urlParams.entrySet()) {
 			if (this.structuralParameters.contains(param.getKey())) {
 				if (firstElement) {
