diff --git a/.classpath b/.classpath
index a4f17eff6..0d9acfa7e 100644
--- a/.classpath
+++ b/.classpath
@@ -17,6 +17,7 @@
 	<classpathentry kind="lib" path="lib/commons-lang3-3.7.jar"/>
 	<classpathentry kind="lib" path="lib/commons-logging-api-1.1.1.jar"/>
 	<classpathentry kind="lib" path="lib/commons-text-1.3.jar"/>
+    <classpathentry kind="lib" path="lib/commons-validator-1.6.jar"/>
 	<classpathentry kind="lib" path="lib/diffutils-1.2.1.jar"/>
 	<classpathentry kind="lib" path="lib/ezmorph-1.0.6.jar"/>
 	<classpathentry kind="lib" path="lib/harlib-jackson-1.1.2.jar"/>
diff --git a/LEGALNOTICE.md b/LEGALNOTICE.md
index ef93d0f2b..b0def97e7 100644
--- a/LEGALNOTICE.md
+++ b/LEGALNOTICE.md
@@ -47,6 +47,7 @@ and subject to their respective licenses.
 | commons-logging-1.2.jar       | Apache 2.0                |
 | commons-logging-api-1.1.1.jar | Apache 2.0                |
 | commons-text-1.3.jar          | Apache 2.0                |
+| commons-validator-1.6.jar     | Apache 2.0                |
 | diffutils-1.2.1.jar           | Apache 2.0                |
 | ezmorph-1.0.6.jar             | Apache 2.0                |
 | harlib-jackson-1.1.2.jar      | Apache 2.0                |
diff --git a/lib/commons-validator-1.6.jar b/lib/commons-validator-1.6.jar
new file mode 100644
index 000000000..c5526e939
Binary files /dev/null and b/lib/commons-validator-1.6.jar differ
diff --git a/src/org/parosproxy/paros/network/SSLConnector.java b/src/org/parosproxy/paros/network/SSLConnector.java
index ab9f6b75c..294550325 100644
--- a/src/org/parosproxy/paros/network/SSLConnector.java
+++ b/src/org/parosproxy/paros/network/SSLConnector.java
@@ -32,6 +32,7 @@
 // ZAP: 2015/10/13 Issue 1975: Allow use of default disabled cipher suites (such as RC4-SHA)
 // ZAP: 2017/04/14 Validate that SSLv2Hello is set in conjunction with at least one SSL/TLS version.
 // ZAP: 2017/09/22 Rely on SNI if the domain is no known when creating the SSL/TLS tunnel.
+// ZAP: 2017/11/07 Pass the listeningIpAddress when creating the SSL/TLS tunnel. Check if hostname is an ipAddress when creating the SSL/TLS tunnel.
 // ZAP: 2018/06/08 Don't enable client cert if none set (Issue 4745).
 
 package org.parosproxy.paros.network;
@@ -81,8 +82,10 @@ import org.apache.commons.collections.map.LRUMap;
 import org.apache.commons.httpclient.ConnectTimeoutException;
 import org.apache.commons.httpclient.params.HttpConnectionParams;
 import org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;
+import org.apache.commons.validator.routines.InetAddressValidator;
 import org.apache.log4j.Logger;
 import org.parosproxy.paros.security.CachedSslCertifificateServiceImpl;
+import org.parosproxy.paros.security.CertData;
 import org.parosproxy.paros.security.SslCertificateService;
 
 import ch.csnc.extension.httpclient.SSLContextManager;
@@ -536,8 +539,9 @@ public class SSLConnector implements SecureProtocolSocketFactory {
 	 * @throws IOException
 	 */
 	public Socket createTunnelServerSocket(String targethost, Socket socket) throws IOException {
+		InetAddress listeningAddress = socket.getLocalAddress();
 		// ZAP: added host name parameter
-		SSLSocket s = (SSLSocket) getTunnelSSLSocketFactory(targethost).createSocket(socket, socket
+		SSLSocket s = (SSLSocket) getTunnelSSLSocketFactory(targethost, listeningAddress).createSocket(socket, socket
 				.getInetAddress().getHostAddress(), socket.getPort(), true);
 		
 		s.setUseClientMode(false);
@@ -545,8 +549,17 @@ public class SSLConnector implements SecureProtocolSocketFactory {
 		return s;
 	}
 
-	// ZAP: added new ServerSocketFaktory with support of dynamic SSL certificates
+
+	/**
+	 * @deprecated (TODO add version) No longer used/needed.
+	 *
+	 */
+	@Deprecated
 	public SSLSocketFactory getTunnelSSLSocketFactory(String hostname) {
+		return getTunnelSSLSocketFactory(hostname, null);
+	}
+
+	public SSLSocketFactory getTunnelSSLSocketFactory(String hostname, InetAddress listeningAddress) {
 
 		//	SSLServerSocketFactory ssf = null;
 		// set up key manager to do server authentication
@@ -559,10 +572,10 @@ public class SSLConnector implements SecureProtocolSocketFactory {
 
 			KeyManager[] keyManagers;
 			if (hostname != null && !hostname.isEmpty()) {
-				initKeyManagerFactoryWithCertForHostname(kmf, hostname);
+				initKeyManagerFactoryWithCertForHostname(kmf, hostname, listeningAddress);
 				keyManagers = kmf.getKeyManagers();
 			} else {
-				keyManagers = new KeyManager[] { new SniX509KeyManager(kmf) };
+				keyManagers = new KeyManager[] { new SniX509KeyManager(kmf, listeningAddress) };
 			}
 
 			java.security.SecureRandom x = new java.security.SecureRandom();
@@ -583,13 +596,29 @@ public class SSLConnector implements SecureProtocolSocketFactory {
         }
 	}
 
-	static void initKeyManagerFactoryWithCertForHostname(KeyManagerFactory keyManagerFactory, String hostname)
+	static void initKeyManagerFactoryWithCertForHostname(KeyManagerFactory keyManagerFactory, String hostname, InetAddress listeningAddress)
 			throws InvalidKeyException, UnrecoverableKeyException, NoSuchAlgorithmException, CertificateException,
 			NoSuchProviderException, SignatureException, KeyStoreException, IOException {
-		KeyStore ks = CachedSslCertifificateServiceImpl.getService().createCertForHost(hostname);
+
+		boolean hostnameIsIpAddress = isIpAddress(hostname);
+
+		CertData certData = hostnameIsIpAddress ? new CertData() : new CertData(hostname);
+		if(hostname == null && listeningAddress != null){
+			certData.addSubjectAlternativeName(new CertData.Name(CertData.Name.IP_ADDRESS, listeningAddress.getHostAddress()));
+		}
+
+		if(hostnameIsIpAddress){
+			certData.addSubjectAlternativeName(new CertData.Name(CertData.Name.IP_ADDRESS, hostname));
+		}
+
+		KeyStore ks = CachedSslCertifificateServiceImpl.getService().createCertForHost(certData);
 		keyManagerFactory.init(ks, SslCertificateService.PASSPHRASE);
 	}
 
+	private static boolean isIpAddress(String value){
+		return value != null && !value.isEmpty() && InetAddressValidator.getInstance().isValid(value);
+	}
+
 	private static SSLSocketFactory createDecoratedServerSslSocketFactory(final SSLSocketFactory delegate) {
 		return new DecoratedSocketsSslSocketFactory(delegate, serverSslSocketsDecorator);
 	}
@@ -657,10 +686,12 @@ public class SSLConnector implements SecureProtocolSocketFactory {
 	private static class SniX509KeyManager implements X509KeyManager {
 
 		private final KeyManagerFactory keyManagerFactory;
+		private InetAddress listeningAddress;
 		private X509KeyManager x509KeyManager;
 
-		public SniX509KeyManager(KeyManagerFactory keyManagerFactory) {
+		public SniX509KeyManager(KeyManagerFactory keyManagerFactory, InetAddress listeningAddress) {
 			this.keyManagerFactory = keyManagerFactory;
+			this.listeningAddress = listeningAddress;
 		}
 
 		@Override
@@ -680,11 +711,11 @@ public class SSLConnector implements SecureProtocolSocketFactory {
 			String hostname = extractHostname(sslSocket.getHandshakeSession());
 
 			if (hostname == null) {
-				logAndThrow("No domain extracted from SSL/TLS handshake session.");
+				logger.debug("No domain extracted from SSL/TLS handshake session.");
 			}
 
 			try {
-				initKeyManagerFactoryWithCertForHostname(keyManagerFactory, hostname);
+				initKeyManagerFactoryWithCertForHostname(keyManagerFactory, hostname, listeningAddress);
 			} catch (InvalidKeyException
 					 | UnrecoverableKeyException
 					 | NoSuchAlgorithmException
diff --git a/src/org/parosproxy/paros/security/CachedSslCertifificateServiceImpl.java b/src/org/parosproxy/paros/security/CachedSslCertifificateServiceImpl.java
index 0d1caf947..89e6c2581 100644
--- a/src/org/parosproxy/paros/security/CachedSslCertifificateServiceImpl.java
+++ b/src/org/parosproxy/paros/security/CachedSslCertifificateServiceImpl.java
@@ -48,18 +48,24 @@ public final class CachedSslCertifificateServiceImpl implements SslCertificateSe
 		delegate = SslCertificateServiceImpl.getService();
 	}
 
-	private Map<String, KeyStore> cache = new HashMap<>();
+	private Map<CertData, KeyStore> cache = new HashMap<>();
 
 	@Override
-	public synchronized KeyStore createCertForHost(String hostname)
+	public KeyStore createCertForHost(String hostname) throws CertificateException, UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException, SignatureException, NoSuchProviderException, InvalidKeyException, IOException {
+		return createCertForHost(new CertData(hostname));
+	}
+
+	@Override
+	public synchronized KeyStore createCertForHost(CertData certData)
 			throws NoSuchAlgorithmException, InvalidKeyException,
 			CertificateException, NoSuchProviderException, SignatureException,
 			KeyStoreException, IOException, UnrecoverableKeyException {
-		if (this.cache.containsKey(hostname)) {
-			return this.cache.get(hostname);
+
+		if (this.cache.containsKey(certData)) {
+			return this.cache.get(certData);
 		}
-		final KeyStore ks = delegate.createCertForHost(hostname);
-		this.cache.put(hostname, ks);
+		final KeyStore ks = delegate.createCertForHost(certData);
+		this.cache.put(certData, ks);
 		return ks;
 	}
 
diff --git a/src/org/parosproxy/paros/security/CertData.java b/src/org/parosproxy/paros/security/CertData.java
new file mode 100644
index 000000000..25f4ca3ab
--- /dev/null
+++ b/src/org/parosproxy/paros/security/CertData.java
@@ -0,0 +1,112 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.parosproxy.paros.security;
+
+import java.util.ArrayList;
+import java.util.Objects;
+
+public class CertData {
+
+    private String commonName;
+    private ArrayList<Name> subjectAlternativeNames;
+
+    public CertData() {
+        subjectAlternativeNames = new ArrayList<>();
+    }
+
+    public CertData(String commonName) {
+        this();
+        this.commonName = commonName;
+        if(commonName != null){
+            addSubjectAlternativeName(new Name(Name.DNS, commonName));
+        }
+    }
+
+    public String getCommonName() {
+        return commonName;
+    }
+
+    public void addSubjectAlternativeName(Name subjectAlternativeName){
+        subjectAlternativeNames.add(subjectAlternativeName);
+    }
+
+    public boolean isSubjectAlternativeNameIsCritical() {
+        return commonName == null;
+    }
+
+    public Name[] getSubjectAlternativeNames() {
+        Name[] subjectAlternativeNamesArray = new Name[subjectAlternativeNames.size()];
+        return subjectAlternativeNames.toArray(subjectAlternativeNamesArray);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = commonName != null ? commonName.hashCode() : 0;
+        result = 31 * result + (subjectAlternativeNames != null ? subjectAlternativeNames.hashCode() : 0);
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) return true;
+        if (obj == null || getClass() != obj.getClass()) return false;
+        CertData certData = (CertData) obj;
+        return Objects.equals(commonName, certData.commonName) &&
+               Objects.equals(subjectAlternativeNames, certData.subjectAlternativeNames);
+    }
+
+    public static class Name {
+        public static final int DNS = 2;
+        public static final int IP_ADDRESS = 7;
+
+        private int type;
+        private String value;
+
+        public Name(int type, String value) {
+            this.type = type;
+            this.value = value;
+        }
+
+        public int getType() {
+            return type;
+        }
+
+        public String getValue() {
+            return value;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Name)) return false;
+
+            Name name = (Name) o;
+
+            if (getType() != name.getType()) return false;
+            return getValue() != null ? getValue().equals(name.getValue()) : name.getValue() == null;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = getType();
+            result = 31 * result + (getValue() != null ? getValue().hashCode() : 0);
+            return result;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/org/parosproxy/paros/security/SslCertificateService.java b/src/org/parosproxy/paros/security/SslCertificateService.java
index 70e3a8f7c..0f3a8d6fd 100644
--- a/src/org/parosproxy/paros/security/SslCertificateService.java
+++ b/src/org/parosproxy/paros/security/SslCertificateService.java
@@ -68,6 +68,31 @@ public interface SslCertificateService {
 			CertificateException, NoSuchProviderException, SignatureException,
 			KeyStoreException, IOException, UnrecoverableKeyException;
 
+	/**
+	 * Generate a certificate signed by our CA's intermediate certificate.
+	 * Thy certificate, private key and public key are returned in one
+	 * {@link KeyStore} available with alias {@link #ZAPROXY_JKS_ALIAS}.
+	 *
+	 * @param certData
+	 * @return a {@link KeyStore} which contains root certificate, signed
+	 *         certificate, private key and public key of signed certificate
+	 * @throws NoSuchAlgorithmException
+	 * @throws InvalidKeyException
+	 * @throws CertificateException
+	 * @throws NoSuchProviderException
+	 * @throws SignatureException
+	 * @throws KeyStoreException
+	 * @throws IOException
+	 * @throws UnrecoverableKeyException
+	 * @throws MissingRootCertificateException when it wasn't initialized.
+	 */
+	default KeyStore createCertForHost(CertData certData)
+			throws NoSuchAlgorithmException, InvalidKeyException,
+			CertificateException, NoSuchProviderException, SignatureException,
+			KeyStoreException, IOException, UnrecoverableKeyException{
+		return createCertForHost(certData.getCommonName());
+	}
+
 	/**
 	 * Loads CA's private key, public key and X.509 certificate into this bean.
 	 *
diff --git a/src/org/parosproxy/paros/security/SslCertificateServiceImpl.java b/src/org/parosproxy/paros/security/SslCertificateServiceImpl.java
index a00d5fad4..27c53d07e 100644
--- a/src/org/parosproxy/paros/security/SslCertificateServiceImpl.java
+++ b/src/org/parosproxy/paros/security/SslCertificateServiceImpl.java
@@ -62,7 +62,7 @@ import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
 /**
  * This is a singleton class. Use {@link #getService()} method to
  * obtain a service bean. This implementation is totally unbuffered and creates
- * every time you call {@link #createCertForHost(String)} a new certificate.
+ * every time you call {@link SslCertificateService#createCertForHost(CertData)} a new certificate.
  * If you want to have a cached solution, have a look at {@link CachedSslCertifificateServiceImpl}.
  * This class is designed to be thread safe.
  *
@@ -110,23 +110,37 @@ public final class SslCertificateServiceImpl implements SslCertificateService {
 		}
 	}
 
-    @Override
-	public KeyStore createCertForHost(String hostname) throws NoSuchAlgorithmException, InvalidKeyException, CertificateException, NoSuchProviderException, SignatureException, KeyStoreException, IOException, UnrecoverableKeyException {
+	@Override
+	public KeyStore createCertForHost(String hostname) throws CertificateException, UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException, SignatureException, NoSuchProviderException, InvalidKeyException, IOException {
+		return createCertForHost(new CertData(hostname));
+	}
 
-    	if (hostname == null) {
-    		throw new IllegalArgumentException("Error, 'hostname' is not allowed to be null!");
-    	}
+	@Override
+	public KeyStore createCertForHost(CertData certData) throws NoSuchAlgorithmException, InvalidKeyException, CertificateException, NoSuchProviderException, SignatureException, KeyStoreException, IOException, UnrecoverableKeyException {
 
     	if (this.caCert == null || this.caPrivKey == null || this.caPubKey == null) {
     		throw new MissingRootCertificateException(this.getClass() + " wasn't initialized! Got to options 'Dynamic SSL Certs' and create one.");
     	}
 
+		CertData.Name[] certDataNames = certData.getSubjectAlternativeNames();
+    	GeneralName[] subjectAlternativeNames = new GeneralName[certDataNames.length];
+		for (int i = 0; i < certDataNames.length; i++) {
+			CertData.Name certDataName = certDataNames[i];
+			subjectAlternativeNames[i] = new GeneralName(certDataName.getType(), certDataName.getValue());
+		}
+
+		if (certData.getCommonName() == null && subjectAlternativeNames.length == 0) {
+			throw new IllegalArgumentException("commonName is null and no subjectAlternativeNames are specified");
+		}
+
         final KeyPair mykp = this.createKeyPair();
         final PrivateKey privKey = mykp.getPrivate();
         final PublicKey pubKey = mykp.getPublic();
 
-		X500NameBuilder namebld = new X500NameBuilder(BCStyle.INSTANCE); 
-		namebld.addRDN(BCStyle.CN, hostname);
+		X500NameBuilder namebld = new X500NameBuilder(BCStyle.INSTANCE);
+		if (certData.getCommonName() != null) {
+			namebld.addRDN(BCStyle.CN, certData.getCommonName());
+		}
 		namebld.addRDN(BCStyle.OU, "Zed Attack Proxy Project");
 		namebld.addRDN(BCStyle.O, "OWASP");
 		namebld.addRDN(BCStyle.C, "xx");
@@ -143,7 +157,10 @@ public final class SslCertificateServiceImpl implements SslCertificateService {
 
 		certGen.addExtension(Extension.subjectKeyIdentifier, false, new SubjectKeyIdentifier(pubKey.getEncoded()));
 		certGen.addExtension(Extension.basicConstraints, false, new BasicConstraints(false));
-		certGen.addExtension(Extension.subjectAlternativeName, false, new GeneralNames(new GeneralName(GeneralName.dNSName, hostname)));
+
+		if(subjectAlternativeNames.length > 0){
+			certGen.addExtension(Extension.subjectAlternativeName, certData.isSubjectAlternativeNameIsCritical(), new GeneralNames(subjectAlternativeNames));
+		}
 
 		ContentSigner sigGen;
 		try {
