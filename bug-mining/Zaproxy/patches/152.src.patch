diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index babacb894..08ec0d2c5 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -134,6 +134,7 @@ api.options.autofillKey		= Autofill API key in the API UI
 api.options.label.testingWarning	= <html>* The following options should only be used for testing as they may make it easier to attack ZAP</html>
 api.options.nokey.error		= You must supply an API key or explicitly disable it.
 ascan.activeActionPrefix = Active scanning: {0}
+ascan.api.action.scan = Runs the active scanner against the given URL and/or Context. Optionally, the 'recurse' parameter can be used to scan URLs under the given URL, the parameter 'inScopeOnly' can be used to constrain the scan to URLs that are in scope (ignored if a Context is specified), the parameter 'scanPolicyName' allows to specify the scan policy (if none is given it uses the default scan policy), the parameters 'method' and 'postData' allow to select a given request in conjunction with the given URL.
 ascan.api.action.scanAsUser = Active Scans from the perspective of a User, obtained using the given Context ID and User ID. See 'scan' action for more details.
 ascan.api.view.optionScanHeadersAllRequests = Tells whether or not the HTTP Headers of all requests should be scanned. Not just requests that send parameters, through the query or request body.
 ascan.api.action.setOptionScanHeadersAllRequests = Sets whether or not the HTTP Headers of all requests should be scanned. Not just requests that send parameters, through the query or request body.
diff --git a/src/org/zaproxy/zap/extension/api/ApiImplementor.java b/src/org/zaproxy/zap/extension/api/ApiImplementor.java
index ed487d414..d32c66bab 100644
--- a/src/org/zaproxy/zap/extension/api/ApiImplementor.java
+++ b/src/org/zaproxy/zap/extension/api/ApiImplementor.java
@@ -362,6 +362,20 @@ public abstract class ApiImplementor {
 		}
 	}
 
+	/**
+	 * Validates that a parameter with the given {@code name} exists (and it has a value) in the given {@code parameters}.
+	 *
+	 * @param parameters the parameters
+	 * @param name the name of the parameter that must exist
+	 * @throws ApiException if the parameter with the given name does not exist or it has no value.
+	 * @since TODO add version
+	 */
+	protected void validateParamExists(JSONObject parameters, String name) throws ApiException {
+		if (!parameters.has(name) || parameters.getString(name).length() == 0) {
+			throw new ApiException(ApiException.Type.MISSING_PARAMETER, name);
+		}
+	}
+	
 	/**
 	 * Override to add custom headers for specific API operations
 	 * @param name	the name of the operation
diff --git a/src/org/zaproxy/zap/extension/ascan/ActiveScanAPI.java b/src/org/zaproxy/zap/extension/ascan/ActiveScanAPI.java
index 4445f9f28..b1543401d 100644
--- a/src/org/zaproxy/zap/extension/ascan/ActiveScanAPI.java
+++ b/src/org/zaproxy/zap/extension/ascan/ActiveScanAPI.java
@@ -127,13 +127,13 @@ public class ActiveScanAPI extends ApiImplementor {
 
 	public ActiveScanAPI (ExtensionActiveScan controller) {
 		this.controller = controller;
-        this.addApiAction(new ApiAction(ACTION_SCAN,
-        		new String[] {PARAM_URL}, 
-        		new String[] {PARAM_RECURSE, PARAM_JUST_IN_SCOPE, PARAM_SCAN_POLICY_NAME, PARAM_METHOD, PARAM_POST_DATA}));
+        this.addApiAction(new ApiAction(ACTION_SCAN, null,
+        	new String[] {PARAM_URL, PARAM_RECURSE, PARAM_JUST_IN_SCOPE, PARAM_SCAN_POLICY_NAME, 
+        					PARAM_METHOD, PARAM_POST_DATA, PARAM_CONTEXT_ID}));
 		this.addApiAction(new ApiAction(
-				ACTION_SCAN_AS_USER,
-				new String[] { PARAM_URL, PARAM_CONTEXT_ID, PARAM_USER_ID },
-				new String[] { PARAM_RECURSE, PARAM_SCAN_POLICY_NAME, PARAM_METHOD, PARAM_POST_DATA }));
+				ACTION_SCAN_AS_USER, null,
+				new String[] { PARAM_URL, PARAM_CONTEXT_ID, PARAM_USER_ID, PARAM_RECURSE, 
+								PARAM_SCAN_POLICY_NAME, PARAM_METHOD, PARAM_POST_DATA }));
 		this.addApiAction(new ApiAction(ACTION_PAUSE_SCAN, new String[] { PARAM_SCAN_ID }));
 		this.addApiAction(new ApiAction(ACTION_RESUME_SCAN, new String[] { PARAM_SCAN_ID }));
 		this.addApiAction(new ApiAction(ACTION_STOP_SCAN, new String[] { PARAM_SCAN_ID }));
@@ -186,9 +186,15 @@ public class ActiveScanAPI extends ApiImplementor {
 		int policyId;
 
 		User user = null;
+		Context context = null;
 		try {
 			switch(name) {
 			case ACTION_SCAN_AS_USER:
+				// These are not mandatory parameters on purpose, to keep the same order
+				// of the parameters while having PARAM_URL as (now) optional.
+				validateParamExists(params, PARAM_CONTEXT_ID);
+				validateParamExists(params, PARAM_USER_ID);
+
 				int userID = ApiUtils.getIntParam(params, PARAM_USER_ID);
 				ExtensionUserManagement usersExtension = Control.getSingleton()
 						.getExtensionLoader()
@@ -196,7 +202,7 @@ public class ActiveScanAPI extends ApiImplementor {
 				if (usersExtension == null) {
 					throw new ApiException(Type.NO_IMPLEMENTOR, ExtensionUserManagement.NAME);
 				}
-				Context context = ApiUtils.getContextByParamId(params, PARAM_CONTEXT_ID);
+				context = ApiUtils.getContextByParamId(params, PARAM_CONTEXT_ID);
 				if (!context.isIncluded(params.getString(PARAM_URL))) {
 					throw new ApiException(Type.URL_NOT_IN_CONTEXT, PARAM_CONTEXT_ID);
 				}
@@ -208,9 +214,13 @@ public class ActiveScanAPI extends ApiImplementor {
 				// Same behaviour but with addition of the user to scan
 				// $FALL-THROUGH$
 			case ACTION_SCAN:
-				URI url = getTargetUrl(params.getString(PARAM_URL));
+				String url = ApiUtils.getOptionalStringParam(params, PARAM_URL);
+
+				if (context == null && params.has(PARAM_CONTEXT_ID) && !params.getString(PARAM_CONTEXT_ID).isEmpty()) {
+					context = ApiUtils.getContextByParamId(params, PARAM_CONTEXT_ID);
+				}
 
-				boolean scanJustInScope = user == null ? this.getParam(params, PARAM_JUST_IN_SCOPE, false) : false;
+				boolean scanJustInScope = context != null ? false : this.getParam(params, PARAM_JUST_IN_SCOPE, false);
 
 				String policyName = null;
 				policy = null;
@@ -244,7 +254,8 @@ public class ActiveScanAPI extends ApiImplementor {
 						scanJustInScope,
 						method,
 						this.getParam(params, PARAM_POST_DATA, ""),
-						policy);
+						policy,
+						context);
 
 				return new ApiResponseElement(name, Integer.toString(scanId));
 
@@ -387,19 +398,6 @@ public class ActiveScanAPI extends ApiImplementor {
 		return ApiResponseElement.OK;
 	}
 
-	private static URI getTargetUrl(String url) throws ApiException {
-		try {
-			URI targetUrl = new URI(url, false);
-			String scheme = targetUrl.getScheme();
-			if (scheme == null || (!scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https"))) {
-				throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_URL);
-			}
-			return targetUrl;
-		} catch (URIException e) {
-			throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_URL);
-		}
-	}
-
 	private ScanPolicy getScanPolicyFromParams(JSONObject params) throws ApiException {
 		String policyName = null;
 		try {
@@ -525,52 +523,76 @@ public class ActiveScanAPI extends ApiImplementor {
 		return scanner;
 	}
 
-	private int scanURL(URI url, User user, boolean scanChildren, boolean scanJustInScope, String method, String postData, ScanPolicy policy) throws ApiException {
-		// Try to find node
-		StructuralNode node;
-		
-		try {
-			node = SessionStructure.find(Model.getSingleton().getSession().getSessionId(), url, method, postData);
-			if (node == null) {
-				throw new ApiException(ApiException.Type.URL_NOT_FOUND);
+	private int scanURL(String url, User user, boolean scanChildren, boolean scanJustInScope, String method,
+			String postData, ScanPolicy policy, Context context) throws ApiException {
+
+		boolean useUrl = true;
+		if (url == null || url.isEmpty()) {
+			if (context == null || !context.hasNodesInContextFromSiteTree()) {
+				throw new ApiException(Type.MISSING_PARAMETER, PARAM_URL);
 			}
-			
-			switch (Control.getSingleton().getMode()) {
-			case safe:
-				throw new ApiException(ApiException.Type.MODE_VIOLATION);
-			case protect:
-				if (!Model.getSingleton().getSession().isInScope(url.toString())) {
-					throw new ApiException(ApiException.Type.MODE_VIOLATION);
-				}
-				// No problem
-				break;
-			case standard:
-				// No problem
-				break;
-			case attack:
-				// No problem
-				break;
+			useUrl = false;
+		} else if (context != null && !context.isInContext(url)) {
+			throw new ApiException(Type.URL_NOT_IN_CONTEXT, PARAM_URL);
+		}
+
+		StructuralNode node = null;
+		if (useUrl) {
+			URI startURI;
+			try {
+				startURI = new URI(url, true);
+			} catch (URIException e) {
+				throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_URL);
 			}
-			
-			Target target = new Target(node);
-			target.setRecurse(scanChildren);
-			target.setInScopeOnly(scanJustInScope);
-			if (user != null) {
-				target.setContext(user.getContext());
+			String scheme = startURI.getScheme();
+			if (scheme == null || (!scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https"))) {
+				throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_URL);
 			}
 
-			Object [] objs = new Object[]{};
-			if (policy != null) {
-				objs = new Object[]{policy};
+			try {
+				node = SessionStructure
+						.find(Model.getSingleton().getSession().getSessionId(), new URI(url, false), method, postData);
+			} catch (Exception e) {
+				throw new ApiException(ApiException.Type.INTERNAL_ERROR, e);
+			}
+
+			if (node == null) {
+				throw new ApiException(ApiException.Type.URL_NOT_FOUND);
 			}
+		}
+		Target target;
+		if (useUrl) {
+			target = new Target(node);
+			target.setContext(context);
+		} else {
+			target = new Target(context);
+		}
+		target.setRecurse(scanChildren);
+		target.setInScopeOnly(scanJustInScope);
+
+		switch (Control.getSingleton().getMode()) {
+		case safe:
+			throw new ApiException(ApiException.Type.MODE_VIOLATION);
+		case protect:
+			if ((useUrl && !Model.getSingleton().getSession().isInScope(url)) || (context != null && !context.isInScope())) {
+				throw new ApiException(ApiException.Type.MODE_VIOLATION);
+			}
+			// No problem
+			break;
+		case standard:
+			// No problem
+			break;
+		case attack:
+			// No problem
+			break;
+		}
 
-			return controller.startScan(null, target, user, objs);
-		} catch(ApiException e) {
-			throw e;
-		} catch (Exception e) {
-			throw new ApiException(ApiException.Type.INTERNAL_ERROR, e);
+		Object[] objs = new Object[] {};
+		if (policy != null) {
+			objs = new Object[] { policy };
 		}
 
+		return controller.startScan(null, target, user, objs);
 	}
 
 	@Override
