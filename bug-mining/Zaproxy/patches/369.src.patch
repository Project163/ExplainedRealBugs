diff --git a/zap/src/main/java/org/parosproxy/paros/core/scanner/VariantURLPath.java b/zap/src/main/java/org/parosproxy/paros/core/scanner/VariantURLPath.java
index b6e8264b1..1cec83129 100644
--- a/zap/src/main/java/org/parosproxy/paros/core/scanner/VariantURLPath.java
+++ b/zap/src/main/java/org/parosproxy/paros/core/scanner/VariantURLPath.java
@@ -19,9 +19,10 @@
  */
 package org.parosproxy.paros.core.scanner;
 
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
+import java.io.ByteArrayOutputStream;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
+import java.util.BitSet;
 import java.util.List;
 import org.apache.commons.httpclient.URI;
 import org.apache.commons.httpclient.URIException;
@@ -40,7 +41,48 @@ public class VariantURLPath implements Variant {
 
     private final Logger LOGGER = LogManager.getLogger(this.getClass());
 
+    private static final char ESCAPE = '%';
+
+    /*
+     * The allowed characters in a path segment, from RFCs 3986 and 4234.
+     */
+    private static final BitSet PCHAR = new BitSet();
+
+    static {
+        PCHAR.set(':');
+        PCHAR.set('@');
+        for (int i = 'A'; i <= 'Z'; i++) {
+            PCHAR.set(i);
+        }
+        for (int i = 'a'; i <= 'z'; i++) {
+            PCHAR.set(i);
+        }
+        for (int i = '0'; i <= '9'; i++) {
+            PCHAR.set(i);
+        }
+
+        PCHAR.set('-');
+        PCHAR.set('.');
+        PCHAR.set('_');
+        PCHAR.set('~');
+
+        PCHAR.set('!');
+        PCHAR.set('$');
+        PCHAR.set('&');
+        PCHAR.set('\'');
+        PCHAR.set('(');
+        PCHAR.set(')');
+        PCHAR.set('*');
+        PCHAR.set('+');
+        PCHAR.set(',');
+        PCHAR.set(';');
+        PCHAR.set('=');
+        PCHAR.set('[');
+        PCHAR.set(']');
+    }
+
     private final List<NameValuePair> stringParam = new ArrayList<>();
+    private String[] segments;
 
     @Override
     public void setMessage(HttpMessage msg) {
@@ -52,24 +94,69 @@ public class VariantURLPath implements Variant {
          *      bbb     2
          *      ccc     3
          */
-        try {
-            if (msg.getRequestHeader().getURI().getPath() != null) {
-                String[] paths = msg.getRequestHeader().getURI().getPath().toString().split("/");
-                int i = 0;
-                for (String path : paths) {
-                    if (path.length() > 0) {
-                        stringParam.add(
-                                new NameValuePair(NameValuePair.TYPE_URL_PATH, path, path, i));
-                    }
-
-                    i++;
+        String encodedPath = msg.getRequestHeader().getURI().getEscapedPath();
+        if (encodedPath != null) {
+            segments = encodedPath.split("/");
+            int i = 0;
+            for (String segment : segments) {
+                if (segment.length() > 0) {
+                    String decodedSegment = decode(segment);
+                    stringParam.add(
+                            new NameValuePair(
+                                    NameValuePair.TYPE_URL_PATH,
+                                    decodedSegment,
+                                    decodedSegment,
+                                    i));
                 }
+
+                i++;
             }
-        } catch (URIException e) {
-            // Ignore
         }
     }
 
+    // Adapted from URLCodec#decodeUrl
+    private static String decode(String segment) {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        byte[] bytes = segment.getBytes(StandardCharsets.US_ASCII);
+        for (int i = 0; i < bytes.length; i++) {
+            byte b = bytes[i];
+            if (b == ESCAPE) {
+                int u = Character.digit(bytes[++i], 16);
+                int l = Character.digit(bytes[++i], 16);
+                baos.write((u << 4) + l);
+            } else {
+                baos.write(b);
+            }
+        }
+        return new String(baos.toByteArray(), StandardCharsets.UTF_8);
+    }
+
+    // Adapted from URLCodec#encodeUrl
+    private static String encode(String segment) {
+        if (segment == null || segment.isEmpty()) {
+            return segment;
+        }
+
+        StringBuilder strBuilder = new StringBuilder();
+        byte[] chars = segment.getBytes(StandardCharsets.UTF_8);
+        for (int i = 0; i < chars.length; i++) {
+            int b = chars[i];
+            if (b < 0) {
+                b = 256 + b;
+            }
+            if (PCHAR.get(b)) {
+                strBuilder.append((char) b);
+            } else {
+                strBuilder.append(ESCAPE).append(toHex(b >> 4)).append(toHex(b));
+            }
+        }
+        return strBuilder.toString();
+    }
+
+    private static char toHex(int b) {
+        return Character.toUpperCase(Character.forDigit(b & 0xF, 16));
+    }
+
     @Override
     public List<NameValuePair> getParamList() {
         return stringParam;
@@ -87,24 +174,6 @@ public class VariantURLPath implements Variant {
         return setParameter(msg, originalPair, name, value, true);
     }
 
-    /**
-     * Encode the parameter value for a correct URL introduction
-     *
-     * @param value the value that need to be encoded
-     * @return the Encoded value
-     */
-    private String getEscapedValue(String value) {
-        if (value != null) {
-            try {
-                return URLEncoder.encode(value, "UTF-8");
-
-            } catch (UnsupportedEncodingException ex) {
-            }
-        }
-
-        return "";
-    }
-
     private String setParameter(
             HttpMessage msg,
             NameValuePair originalPair,
@@ -113,14 +182,16 @@ public class VariantURLPath implements Variant {
             boolean escaped) {
         try {
             URI uri = msg.getRequestHeader().getURI();
-            String[] paths = msg.getRequestHeader().getURI().getPath().toString().split("/");
 
-            if (originalPair.getPosition() < paths.length) {
+            int position = originalPair.getPosition();
+            if (position < segments.length) {
 
-                String encodedValue = (escaped) ? value : getEscapedValue(value);
+                String encodedValue = escaped ? value : encode(value);
 
-                paths[originalPair.getPosition()] = encodedValue;
-                String path = StringUtils.join(paths, "/");
+                String originalValue = segments[position];
+                segments[position] = encodedValue;
+                String path = StringUtils.join(segments, "/");
+                segments[position] = originalValue;
 
                 try {
                     uri.setEscapedPath(path);
@@ -137,14 +208,4 @@ public class VariantURLPath implements Variant {
 
         return value;
     }
-
-    /*
-    public static void main(String[] args) {
-        VariantURLPath var = new VariantURLPath();
-        String value = var.getEscapedValue("prova +codifica+ strana");
-        System.out.println(value);
-        String res = var.getUnescapedValue(value);
-        System.out.println(res);
-    }
-    */
 }
diff --git a/zap/src/test/java/org/parosproxy/paros/core/scanner/VariantURLPathUnitTest.java b/zap/src/test/java/org/parosproxy/paros/core/scanner/VariantURLPathUnitTest.java
new file mode 100644
index 000000000..977ee89ad
--- /dev/null
+++ b/zap/src/test/java/org/parosproxy/paros/core/scanner/VariantURLPathUnitTest.java
@@ -0,0 +1,216 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.parosproxy.paros.core.scanner;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.empty;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.is;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.List;
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.NullAndEmptySource;
+import org.junit.jupiter.params.provider.ValueSource;
+import org.parosproxy.paros.network.HttpMalformedHeaderException;
+import org.parosproxy.paros.network.HttpMessage;
+
+/** Unit test for {@link VariantURLPath}. */
+class VariantURLPathUnitTest {
+
+    @Test
+    void shouldHaveParametersListEmptyByDefault() {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        // When
+        List<NameValuePair> parameters = variantUrlPath.getParamList();
+        // Then
+        assertThat(parameters, is(empty()));
+    }
+
+    @Test
+    void shouldFailToExtractParametersFromUndefinedMessage() {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        HttpMessage undefinedMessage = null;
+        // When / Then
+        assertThrows(NullPointerException.class, () -> variantUrlPath.setMessage(undefinedMessage));
+    }
+
+    @ParameterizedTest
+    @ValueSource(strings = {"", "/"})
+    void shouldNotExtractAnyParameterIfThereIsNoPathOrItIsEmpty(String path) {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        HttpMessage message = createMessageWithPath(path);
+        // When
+        variantUrlPath.setMessage(message);
+        // Then
+        assertThat(variantUrlPath.getParamList(), is(empty()));
+    }
+
+    @Test
+    void shouldExtractParametersFromPathSegments() {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        HttpMessage message = createMessageWithPath("/X/Y/Z/");
+        // When
+        variantUrlPath.setMessage(message);
+        // Then
+        assertThat(
+                variantUrlPath.getParamList(),
+                contains(parameter("X", 1), parameter("Y", 2), parameter("Z", 3)));
+    }
+
+    @Test
+    void shouldExtractParametersFromEncodedPathSegments() {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        HttpMessage message = createMessageWithPath("/X/+%2F%20/Z/%/%A/");
+        // When
+        variantUrlPath.setMessage(message);
+        // Then
+        assertThat(
+                variantUrlPath.getParamList(),
+                contains(
+                        parameter("X", 1),
+                        parameter("+/ ", 2),
+                        parameter("Z", 3),
+                        parameter("%", 4),
+                        parameter("%A", 5)));
+    }
+
+    @Test
+    void shouldInjectSegmentModification() {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        HttpMessage message = createMessageWithPath("/X/Y/Z/");
+        variantUrlPath.setMessage(message);
+        // When
+        String injectedValue =
+                variantUrlPath.setParameter(message, parameter("X", 1), "X", "Value");
+        // Then
+        assertThat(injectedValue, is(equalTo("Value")));
+        assertThat(message, containsPath("/Value/Y/Z"));
+    }
+
+    @Test
+    void shouldInjectAndEscapeSegmentModification() {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        HttpMessage message = createMessageWithPath("/X/Y/Z/");
+        variantUrlPath.setMessage(message);
+        // When
+        String injectedValue =
+                variantUrlPath.setParameter(message, parameter("X", 1), "X", "Value A");
+        // Then
+        assertThat(injectedValue, is(equalTo("Value A")));
+        assertThat(message, containsPath("/Value%20A/Y/Z"));
+    }
+
+    @Test
+    void shouldInjectEscapedSegmentModification() {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        HttpMessage message = createMessageWithPath("/X/Y/Z/");
+        variantUrlPath.setMessage(message);
+        // When
+        String injectedValue =
+                variantUrlPath.setEscapedParameter(message, parameter("X", 1), "X", "Value%20A");
+        // Then
+        assertThat(injectedValue, is(equalTo("Value%20A")));
+        assertThat(message, containsPath("/Value%20A/Y/Z"));
+    }
+
+    @ParameterizedTest
+    @NullAndEmptySource
+    void shouldKeepEmptySegmentIfInjectedValueIsNullOrEmpty(String injection) {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        HttpMessage message = createMessageWithPath("/X/Y/Z/");
+        variantUrlPath.setMessage(message);
+        // When
+        String injectedValue =
+                variantUrlPath.setParameter(message, parameter("X", 1), "X", injection);
+        // Then
+        assertThat(injectedValue, is(equalTo(injection)));
+        assertThat(message, containsPath("//Y/Z"));
+    }
+
+    @Test
+    void shouldIgnoreChangesToSegmentName() {
+        // Given
+        VariantURLPath variantUrlPath = new VariantURLPath();
+        HttpMessage message = createMessageWithPath("/X/Y/Z/");
+        variantUrlPath.setMessage(message);
+        // When
+        String injectedValue =
+                variantUrlPath.setParameter(message, parameter("X", 1), "X-Y-Z", "X");
+        // Then
+        assertThat(injectedValue, is(equalTo("X")));
+        assertThat(message, containsPath("/X/Y/Z"));
+    }
+
+    private static HttpMessage createMessageWithPath(String path) {
+        HttpMessage message = new HttpMessage();
+        try {
+            message.setRequestHeader("GET http://example.com" + path + " HTTP/1.1\r\n");
+        } catch (HttpMalformedHeaderException e) {
+            throw new RuntimeException(e);
+        }
+        return message;
+    }
+
+    private static NameValuePair parameter(String value, int position) {
+        return new NameValuePair(NameValuePair.TYPE_URL_PATH, value, value, position);
+    }
+
+    private static Matcher<HttpMessage> containsPath(String path) {
+        return new BaseMatcher<HttpMessage>() {
+
+            @Override
+            public boolean matches(Object actualValue) {
+                HttpMessage message = (HttpMessage) actualValue;
+                return path.equals(message.getRequestHeader().getURI().getEscapedPath());
+            }
+
+            @Override
+            public void describeTo(Description description) {
+                description.appendText("URL path ").appendValue(path);
+            }
+
+            @Override
+            public void describeMismatch(Object item, Description description) {
+                HttpMessage message = (HttpMessage) item;
+                String path = message.getRequestHeader().getURI().getEscapedPath();
+                if (path.isEmpty()) {
+                    description.appendText("has no path");
+                } else {
+                    description.appendText("was ").appendValue(path);
+                }
+            }
+        };
+    }
+}
