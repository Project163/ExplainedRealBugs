diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index 0dfa44033..b4739c847 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -2103,6 +2103,13 @@ spider.panel.mnemonic			= d
 spider.panel.title              = Spider
 spider.panel.tab.messages = Messages
 spider.panel.tab.urls = URLs
+spider.parsefilter.reason.empty = Empty Message
+spider.parsefilter.reason.maxsize = Max Size
+spider.parsefilter.reason.nottext = Not Text
+spider.parsefilter.reason.maxchildren = Max Children
+spider.task.message.skipped.stopped = Spider Stopped
+spider.task.message.skipped.maxdepth = Max Depth
+spider.task.message.skipped.ioerror = I/O Error
 spider.table.header.uri 		= URI
 spider.table.header.inScope    	= Processed
 spider.table.header.method    	= Method
@@ -2114,7 +2121,6 @@ spider.table.flags.illegalprotocol = Illegal Protocol
 spider.table.flags.userrules = User Rules
 spider.table.messages.header.processed = Processed
 spider.table.messages.column.processed.successfully = Successfully
-spider.table.messages.column.processed.ioerror = I/O Error
 spider.toolbar.button.showmessages.label = Show Messages
 spider.toolbar.button.showmessages.label.selected = Hide Messages
 spider.toolbar.button.showmessages.tooltip = Shows the HTTP messages sent while spidering
diff --git a/src/org/zaproxy/zap/control/ExtensionFactory.java b/src/org/zaproxy/zap/control/ExtensionFactory.java
index 209164c93..e1e1a9ce7 100644
--- a/src/org/zaproxy/zap/control/ExtensionFactory.java
+++ b/src/org/zaproxy/zap/control/ExtensionFactory.java
@@ -257,6 +257,8 @@ public class ExtensionFactory {
         if (msg != null) {
             ext.setMessages(msg);
             Constant.messages.addMessageBundle(ext.getI18nPrefix(), ext.getMessages());
+        } else {
+            ext.setMessages(Constant.messages.getCoreResourceBundle());
         }
     }
 
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderAPI.java b/src/org/zaproxy/zap/extension/spider/SpiderAPI.java
index fc47f5bb3..d1afa739e 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderAPI.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderAPI.java
@@ -514,7 +514,7 @@ public class SpiderAPI extends ApiImplementor {
     		maxChildrenFetchFilter.setMaxChildren(maxChildren);
     		maxChildrenFetchFilter.setModel(extension.getModel());
     		
-    		MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter();
+    		MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter(extension.getMessages());
     		maxChildrenParseFilter.setMaxChildren(maxChildren);
     		maxChildrenParseFilter.setModel(extension.getModel());
 			objs.add(maxChildrenFetchFilter);
@@ -554,7 +554,7 @@ public class SpiderAPI extends ApiImplementor {
 			ApiResponseList resultList = new ApiResponseList("urlsInScope");
 			synchronized (scan.getResourcesFound()) {
 				for (SpiderResource sr : scan.getResourcesFound()) {
-					resultList.addItem(createApiResponseSet(sr));
+					resultList.addItem(createApiResponseSet(sr, sr.isProcessed(), sr.getReasonNotProcessed()));
 				}
 			}
 			resultUrls.addItem(resultList);
@@ -570,7 +570,7 @@ public class SpiderAPI extends ApiImplementor {
 			resultList = new ApiResponseList("urlsIoError");
 			synchronized (scan.getResourcesIoErrors()) {
 				for (SpiderResource sr : scan.getResourcesIoErrors()) {
-					resultList.addItem(createApiResponseSet(sr));
+					resultList.addItem(createApiResponseSet(sr, sr.isProcessed(), sr.getReasonNotProcessed()));
 				}
 			}
 			resultUrls.addItem(resultList);
@@ -633,13 +633,15 @@ public class SpiderAPI extends ApiImplementor {
 		return result;
 	}
 
-	private static ApiResponseSet<String> createApiResponseSet(SpiderResource sr) {
+	private static ApiResponseSet<String> createApiResponseSet(SpiderResource sr, boolean processed, String reasonNotProcessed) {
 		Map<String, String> map = new HashMap<>();
 		map.put("messageId", Integer.toString(sr.getHistoryId()));
 		map.put("method", sr.getMethod());
 		map.put("url", sr.getUri());
 		map.put("statusCode", Integer.toString(sr.getStatusCode()));
 		map.put("statusReason", sr.getStatusReason());
+		map.put("processed", Boolean.toString(processed));
+		map.put("reasonNotProcessed", reasonNotProcessed);
 		return new ApiResponseSet<>("resource", map);
 	}
 	
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderMessagesTableModel.java b/src/org/zaproxy/zap/extension/spider/SpiderMessagesTableModel.java
index 4118f8dc2..7c0e40464 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderMessagesTableModel.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderMessagesTableModel.java
@@ -65,7 +65,6 @@ class SpiderMessagesTableModel
             Constant.messages.getString("spider.table.messages.header.processed") };
 
     private static final ProcessedCellItem SUCCESSFULLY_PROCESSED_CELL_ITEM;
-    private static final ProcessedCellItem IO_ERROR_CELL_ITEM;
 
     private final ExtensionHistory extensionHistory;
     private AlertEventConsumer alertEventConsumer;
@@ -73,13 +72,12 @@ class SpiderMessagesTableModel
     private List<SpiderTableEntry> resources;
     private Map<Integer, Integer> idsToRows;
 
+    private Map<String, ProcessedCellItem> cacheProcessedCellItems;
+
     static {
         SUCCESSFULLY_PROCESSED_CELL_ITEM = new ProcessedCellItem(
                 true,
                 Constant.messages.getString("spider.table.messages.column.processed.successfully"));
-        IO_ERROR_CELL_ITEM = new ProcessedCellItem(
-                false,
-                Constant.messages.getString("spider.table.messages.column.processed.ioerror"));
     }
 
     public SpiderMessagesTableModel() {
@@ -91,6 +89,7 @@ class SpiderMessagesTableModel
 
         resources = new ArrayList<>();
         idsToRows = new HashMap<>();
+        cacheProcessedCellItems = new HashMap<>();
 
         if (createAlertEventConsumer) {
             alertEventConsumer = new AlertEventConsumer();
@@ -107,12 +106,14 @@ class SpiderMessagesTableModel
         // Nothing to do, the entries are added with the following method.
     }
 
-    public void addHistoryReference(HistoryReference historyReference, boolean ioError) {
+    public void addHistoryReference(HistoryReference historyReference, boolean processed, String reasonNotProcessed) {
         HistoryReference latestHistoryReference = historyReference;
         if (extensionHistory != null) {
             latestHistoryReference = extensionHistory.getHistoryReference(historyReference.getHistoryId());
         }
-        final SpiderTableEntry entry = new SpiderTableEntry(latestHistoryReference, ioError);
+        final SpiderTableEntry entry = new SpiderTableEntry(
+                latestHistoryReference,
+                getProcessedCellItem(processed, reasonNotProcessed));
         EventQueue.invokeLater(new Runnable() {
 
             @Override
@@ -125,8 +126,21 @@ class SpiderMessagesTableModel
         });
     }
 
+    private ProcessedCellItem getProcessedCellItem(boolean processed, String reasonNotProcessed) {
+        if (processed) {
+            return SUCCESSFULLY_PROCESSED_CELL_ITEM;
+        }
+        ProcessedCellItem processedCellItem = cacheProcessedCellItems.get(reasonNotProcessed);
+        if (processedCellItem == null) {
+            processedCellItem = new ProcessedCellItem(processed, reasonNotProcessed);
+            cacheProcessedCellItems.put(reasonNotProcessed, processedCellItem);
+        }
+        return processedCellItem;
+    }
+
     @Override
     public void clear() {
+        cacheProcessedCellItems = new HashMap<>();
         resources = new ArrayList<>();
         idsToRows = new HashMap<>();
         fireTableDataChanged();
@@ -203,7 +217,7 @@ class SpiderMessagesTableModel
     @Override
     protected Object getCustomValueAt(SpiderTableEntry entry, int columnIndex) {
         if (getCustomColumnIndex(columnIndex) == 0) {
-            return entry.isIoError() ? IO_ERROR_CELL_ITEM : SUCCESSFULLY_PROCESSED_CELL_ITEM;
+            return entry.getProcessedCellItem();
         }
         return null;
     }
@@ -249,15 +263,15 @@ class SpiderMessagesTableModel
 
     static class SpiderTableEntry extends DefaultHistoryReferencesTableEntry {
 
-        private final boolean ioError;
+        private final ProcessedCellItem processedCellItem;
 
-        public SpiderTableEntry(HistoryReference historyReference, boolean ioError) {
+        public SpiderTableEntry(HistoryReference historyReference, ProcessedCellItem processedCellItem) {
             super(historyReference, COLUMNS);
-            this.ioError = ioError;
+            this.processedCellItem = processedCellItem;
         }
 
-        public boolean isIoError() {
-            return ioError;
+        public ProcessedCellItem getProcessedCellItem() {
+            return processedCellItem;
         }
     }
 
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderResource.java b/src/org/zaproxy/zap/extension/spider/SpiderResource.java
index bd3be0a07..b2c02fbf3 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderResource.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderResource.java
@@ -34,13 +34,24 @@ public class SpiderResource {
 	private final String uri;
 	private final int statusCode;
 	private final String statusReason;
+	private final boolean processed;
+	private final String reasonNotProcessed;
 
-	public SpiderResource(int historyId, String method, String uri, int statusCode, String statusReason) {
+	public SpiderResource(
+			int historyId,
+			String method,
+			String uri,
+			int statusCode,
+			String statusReason,
+			boolean processed,
+			String reasonNotProcessed) {
 		this.historyId = historyId;
 		this.method = method;
 		this.uri = uri;
 		this.statusCode = statusCode;
 		this.statusReason = statusReason;
+		this.processed = processed;
+		this.reasonNotProcessed = reasonNotProcessed == null ? "" : reasonNotProcessed;
 	}
 
 	public int getHistoryId() {
@@ -62,4 +73,13 @@ public class SpiderResource {
 	public String getStatusReason() {
 		return statusReason;
 	}
+
+	public boolean isProcessed() {
+		return processed;
+	}
+
+	public String getReasonNotProcessed() {
+		return reasonNotProcessed;
+	}
+
 }
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderScan.java b/src/org/zaproxy/zap/extension/spider/SpiderScan.java
index 1f6f9ba9c..75c0a69a5 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderScan.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderScan.java
@@ -45,6 +45,7 @@ import org.zaproxy.zap.model.ScanListenner2;
 import org.zaproxy.zap.model.Target;
 import org.zaproxy.zap.spider.SpiderListener;
 import org.zaproxy.zap.spider.SpiderParam;
+import org.zaproxy.zap.spider.SpiderTaskResult;
 import org.zaproxy.zap.spider.filters.FetchFilter;
 import org.zaproxy.zap.spider.filters.FetchFilter.FetchStatus;
 import org.zaproxy.zap.spider.filters.ParseFilter;
@@ -330,7 +331,8 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 	}
 
 	@Override
-	public void readURI(HttpMessage msg) {
+	public void notifySpiderTaskResult(SpiderTaskResult spiderTaskResult) {
+		HttpMessage msg = spiderTaskResult.getHttpMessage();
 		HttpRequestHeader requestHeader = msg.getRequestHeader();
 		HttpResponseHeader responseHeader = msg.getResponseHeader();
 		SpiderResource resource = new SpiderResource(
@@ -338,7 +340,9 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 				requestHeader.getMethod(),
 				requestHeader.getURI().toString(),
 				responseHeader.getStatusCode(),
-				responseHeader.getReasonPhrase());
+				responseHeader.getReasonPhrase(),
+				spiderTaskResult.isProcessed(),
+				spiderTaskResult.getReasonNotProcessed());
 
 		if (msg.isResponseFromTargetHost()) {
 			resourcesFound.add(resource);
@@ -347,11 +351,11 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 		}
 
 		if (View.isInitialised()) {
-			addMessageToMessagesTableModel(msg);
+			addMessageToMessagesTableModel(spiderTaskResult);
 		}
 	}
 
-	private void addMessageToMessagesTableModel(final HttpMessage msg) {
+	private void addMessageToMessagesTableModel(final SpiderTaskResult spiderTaskResult) {
 		if (EventQueue.isDispatchThread() || cleared) {
 			if (cleared) {
 				return;
@@ -360,7 +364,10 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 			if (messagesTableModel == null) {
 				messagesTableModel = new SpiderMessagesTableModel();
 			}
-			messagesTableModel.addHistoryReference(msg.getHistoryRef(), !msg.isResponseFromTargetHost());
+			messagesTableModel.addHistoryReference(
+					spiderTaskResult.getHttpMessage().getHistoryRef(),
+					spiderTaskResult.isProcessed(),
+					spiderTaskResult.getReasonNotProcessed());
 			return;
 		}
 
@@ -368,7 +375,7 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 
 			@Override
 			public void run() {
-				addMessageToMessagesTableModel(msg);
+				addMessageToMessagesTableModel(spiderTaskResult);
 			}
 		});
 	}
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderScanController.java b/src/org/zaproxy/zap/extension/spider/SpiderScanController.java
index 6bd394c7f..a5e9193d0 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderScanController.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderScanController.java
@@ -128,7 +128,7 @@ public class SpiderScanController implements ScanController<SpiderScan> {
 				maxChildrenFetchFilter.setMaxChildren(spiderParams.getMaxChildren());
 				maxChildrenFetchFilter.setModel(extension.getModel());
 
-				MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter();
+				MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter(extension.getMessages());
 				maxChildrenParseFilter.setMaxChildren(spiderParams.getMaxChildren());
 				maxChildrenParseFilter.setModel(extension.getModel());
 
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderThread.java b/src/org/zaproxy/zap/extension/spider/SpiderThread.java
index 238361682..e29d615ff 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderThread.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderThread.java
@@ -44,6 +44,7 @@ import org.zaproxy.zap.model.TechSet;
 import org.zaproxy.zap.spider.Spider;
 import org.zaproxy.zap.spider.SpiderListener;
 import org.zaproxy.zap.spider.SpiderParam;
+import org.zaproxy.zap.spider.SpiderTaskResult;
 import org.zaproxy.zap.spider.filters.FetchFilter;
 import org.zaproxy.zap.spider.filters.FetchFilter.FetchStatus;
 import org.zaproxy.zap.spider.filters.ParseFilter;
@@ -450,9 +451,10 @@ public class SpiderThread extends ScanThread implements SpiderListener {
 	}
 
 	@Override
-	public void readURI(final HttpMessage msg) {
+	public void notifySpiderTaskResult(SpiderTaskResult spiderTaskResult) {
 		// Add the read message to the Site Map (tree or db structure)
 		try {
+			HttpMessage msg = spiderTaskResult.getHttpMessage();
 			int type = msg.isResponseFromTargetHost() ? HistoryReference.TYPE_SPIDER : HistoryReference.TYPE_SPIDER_TEMPORARY;
 			HistoryReference historyRef = new HistoryReference(extension.getModel().getSession(), type, msg);
 
diff --git a/src/org/zaproxy/zap/spider/Spider.java b/src/org/zaproxy/zap/spider/Spider.java
index 3d5e134b7..580efc0a3 100644
--- a/src/org/zaproxy/zap/spider/Spider.java
+++ b/src/org/zaproxy/zap/spider/Spider.java
@@ -196,7 +196,7 @@ public class Spider {
 		}
 
 		// Add a default parse filter and any custom ones
-		this.addParseFilter(new DefaultParseFilter(spiderParam));
+		this.addParseFilter(new DefaultParseFilter(spiderParam, extension.getMessages()));
 		for (ParseFilter filter : extension.getCustomParseFilters())
 			this.addParseFilter(filter);
 		
@@ -800,13 +800,13 @@ public class Spider {
 	}
 
 	/**
-	 * Notifies the listeners regarding a read uri.
+	 * Notifies the listeners of a {@link SpiderTask}'s result.
 	 * 
-	 * @param msg the message
+	 * @param result the result of a spider task.
 	 */
-	protected synchronized void notifyListenersReadURI(HttpMessage msg) {
+	protected synchronized void notifyListenersSpiderTaskResult(SpiderTaskResult result) {
 		for (SpiderListener l : listeners) {
-			l.readURI(msg);
+			l.notifySpiderTaskResult(result);
 		}
 	}
 
diff --git a/src/org/zaproxy/zap/spider/SpiderListener.java b/src/org/zaproxy/zap/spider/SpiderListener.java
index 4ed0b4701..f644b7409 100644
--- a/src/org/zaproxy/zap/spider/SpiderListener.java
+++ b/src/org/zaproxy/zap/spider/SpiderListener.java
@@ -18,7 +18,6 @@
 
 package org.zaproxy.zap.spider;
 
-import org.parosproxy.paros.network.HttpMessage;
 import org.zaproxy.zap.spider.filters.FetchFilter.FetchStatus;
 
 /**
@@ -51,11 +50,11 @@ public interface SpiderListener {
 	void foundURI(String uri, String method, FetchStatus status);
 
 	/**
-	 * Event triggered when a new uri was read.
+	 * Notifies that a new {@link SpiderTask}'s result is available.
 	 * 
-	 * @param msg the message
+	 * @param spiderTaskResult the result of the spider task.
 	 */
-	void readURI(HttpMessage msg);
+	void notifySpiderTaskResult(SpiderTaskResult spiderTaskResult);
 
 	/**
 	 * Event triggered when the spider is finished. This event is triggered either when the spider
diff --git a/src/org/zaproxy/zap/spider/SpiderTask.java b/src/org/zaproxy/zap/spider/SpiderTask.java
index a821f2170..112cf513d 100644
--- a/src/org/zaproxy/zap/spider/SpiderTask.java
+++ b/src/org/zaproxy/zap/spider/SpiderTask.java
@@ -44,6 +44,7 @@ import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpRequestHeader;
 import org.parosproxy.paros.network.HttpResponseHeader;
 import org.zaproxy.zap.spider.filters.ParseFilter;
+import org.zaproxy.zap.spider.filters.ParseFilter.FilterResult;
 import org.zaproxy.zap.spider.parser.SpiderParser;
 
 /**
@@ -209,7 +210,7 @@ public class SpiderTask implements Runnable {
 			fetchResource(msg);
 		} catch (Exception e) {
 			setErrorResponse(msg, e);
-			parent.notifyListenersReadURI(msg);
+			parent.notifyListenersSpiderTaskResult(new SpiderTaskResult(msg, getSkippedMessage("ioerror")));
 
 			// The exception was already logged, in fetchResource, with the URL (which we dont have here)
 			parent.postTaskExecution();
@@ -218,6 +219,7 @@ public class SpiderTask implements Runnable {
 
 		// Check if the should stop
 		if (parent.isStopped()) {
+		    parent.notifyListenersSpiderTaskResult(new SpiderTaskResult(msg, getSkippedMessage("stopped")));
 			log.debug("Spider process is stopped. Skipping crawling task...");
 			parent.postTaskExecution();
 			return;
@@ -226,24 +228,25 @@ public class SpiderTask implements Runnable {
 		parent.checkPauseAndWait();
 
 		// Check the parse filters to see if the resource should be skipped from parsing
-		boolean isFiltered = false;
 		for (ParseFilter filter : parent.getController().getParseFilters()) {
-			if (filter.isFiltered(msg)) {
+			FilterResult filterResult = filter.filtered(msg);
+			if (filterResult.isFiltered()) {
 				if (log.isDebugEnabled()) {
-					log.debug("Resource fetched, but will not be parsed due to a ParseFilter rule: "
-							+ msg.getRequestHeader().getURI());
+					log.debug(
+							"Resource [" + msg.getRequestHeader().getURI()
+									+ "] fetched, but will not be parsed due to a ParseFilter rule: "
+									+ filterResult.getReason());
 				}
-				isFiltered = true;
-				break;
+
+				parent.notifyListenersSpiderTaskResult(new SpiderTaskResult(msg, filterResult.getReason()));
+				parent.postTaskExecution();
+				return;
 			}
 		}
-		if (! isFiltered) {
-			// Notify the SpiderListeners that a resource was read
-			parent.notifyListenersReadURI(msg);
-		}
 
 		// Check if the should stop
 		if (parent.isStopped()) {
+			parent.notifyListenersSpiderTaskResult(new SpiderTaskResult(msg, "stopped"));
 			log.debug("Spider process is stopped. Skipping crawling task...");
 			parent.postTaskExecution();
 			return;
@@ -251,9 +254,11 @@ public class SpiderTask implements Runnable {
 		// Check if the crawling process is paused
 		parent.checkPauseAndWait();
 		
-		// Process resource, if this is not the maximum depth
-		if (!isFiltered && depth < parent.getSpiderParam().getMaxDepth()) {
+		if (depth < parent.getSpiderParam().getMaxDepth()) {
+			parent.notifyListenersSpiderTaskResult(new SpiderTaskResult(msg));
 			processResource(msg);
+		} else {
+			parent.notifyListenersSpiderTaskResult(new SpiderTaskResult(msg, "maxdepth"));
 		}
 
 		// Update the progress and check if the spidering process should stop
@@ -261,6 +266,10 @@ public class SpiderTask implements Runnable {
 		log.debug("Spider Task finished.");
 	}
 
+	private String getSkippedMessage(String key) {
+		return parent.getExtensionSpider().getMessages().getString("spider.task.message.skipped." + key);
+	}
+
 	/**
 	 * Prepares the HTTP message to be sent to the target server.
 	 * <p>
diff --git a/src/org/zaproxy/zap/spider/SpiderTaskResult.java b/src/org/zaproxy/zap/spider/SpiderTaskResult.java
new file mode 100644
index 000000000..b29a8e18d
--- /dev/null
+++ b/src/org/zaproxy/zap/spider/SpiderTaskResult.java
@@ -0,0 +1,100 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2017 The ZAP Development Team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.spider;
+
+import org.parosproxy.paros.network.HttpMessage;
+
+/**
+ * A result from a {@link SpiderTask}.
+ * <p>
+ * Contains the message and processing details.
+ *
+ * @since TODO add version
+ */
+public class SpiderTaskResult {
+
+    private final HttpMessage httpMessage;
+    private final boolean processed;
+    private final String reasonNotProcessed;
+
+    /**
+     * Constructs a {@code SpiderTaskResult} with the given processed message.
+     *
+     * @param httpMessage the HTTP message that resulted from the spider task.
+     */
+    public SpiderTaskResult(HttpMessage httpMessage) {
+        this(httpMessage, true, "");
+    }
+
+    /**
+     * Constructs a {@code SpiderTaskResult} with the given non-processed message and the reason of why it as not processed.
+     *
+     * @param httpMessage the HTTP message that resulted from the spider task.
+     * @param reasonNotProcessed the reason of why the HTTP message was not processed.
+     * @throws IllegalArgumentException if the given reason is {@code null}.
+     */
+    public SpiderTaskResult(HttpMessage httpMessage, String reasonNotProcessed) {
+        this(httpMessage, false, reasonNotProcessed);
+    }
+
+    /**
+     * Constructs a {@code SpiderTaskResult} with the given message, processed state, and the reason of why it as not processed.
+     *
+     * @param httpMessage the HTTP message that resulted from the spider task.
+     * @param processed {@code true} if the message was processed, {@code false} otherwise.
+     * @param reasonNotProcessed the reason of why the HTTP message was not processed.
+     */
+    private SpiderTaskResult(HttpMessage httpMessage, boolean processed, String reasonNotProcessed) {
+        if (reasonNotProcessed == null) {
+            throw new IllegalArgumentException("Parameter reason must not be null.");
+        }
+        this.httpMessage = httpMessage;
+        this.processed = processed;
+        this.reasonNotProcessed = reasonNotProcessed;
+    }
+
+    /**
+     * Gets the HTTP message that resulted from a spider task.
+     *
+     * @return the HTTP message, never {@code null}.
+     */
+    public HttpMessage getHttpMessage() {
+        return httpMessage;
+    }
+
+    /**
+     * Tells whether or not the HTTP message was processed (obtained and parsed).
+     *
+     * @return {@code true} if the message was processed, {@code false} otherwise.
+     */
+    public boolean isProcessed() {
+        return processed;
+    }
+
+    /**
+     * Gets the reason of why the HTTP message was not processed.
+     *
+     * @return the reason of why the HTTP message was not processed, never {@code null}.
+     */
+    public String getReasonNotProcessed() {
+        return reasonNotProcessed;
+    }
+
+}
diff --git a/src/org/zaproxy/zap/spider/filters/DefaultParseFilter.java b/src/org/zaproxy/zap/spider/filters/DefaultParseFilter.java
index 9f232e7ab..48bc963ef 100644
--- a/src/org/zaproxy/zap/spider/filters/DefaultParseFilter.java
+++ b/src/org/zaproxy/zap/spider/filters/DefaultParseFilter.java
@@ -17,6 +17,9 @@
  */
 package org.zaproxy.zap.spider.filters;
 
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.ResourceBundle;
 import java.util.regex.Pattern;
 
 import org.parosproxy.paros.network.HttpMessage;
@@ -63,37 +66,62 @@ public class DefaultParseFilter extends ParseFilter {
 	 * The configurations of the spider, never {@code null}.
 	 */
 	private final SpiderParam params;
+
+	private final FilterResult filterResultEmpty;
+	private final FilterResult filterResultMaxSize;
+	private final FilterResult filterResultNotText;
 	
 	/**
 	 * Constructs a {@code DefaultParseFilter} with default configurations.
 	 *
-	 * @deprecated (TODO add version) Replaced by {@link #DefaultParseFilter(SpiderParam)}.
+	 * @deprecated (TODO add version) Replaced by {@link #DefaultParseFilter(SpiderParam, ResourceBundle)}.
 	 */
 	@Deprecated
 	public DefaultParseFilter() {
-		this(new SpiderParam());
+		this(new SpiderParam(), new ResourceBundle() {
+
+			@Override
+			public Enumeration<String> getKeys() {
+				return Collections.emptyEnumeration();
+			}
+
+			@Override
+			protected Object handleGetObject(String key) {
+				return "";
+			}
+		});
 	}
 
 	/**
-	 * Constructs a {@code DefaultParseFilter} with the given configurations.
+	 * Constructs a {@code DefaultParseFilter} with the given configurations and resource bundle.
+	 * <p>
+	 * The resource bundle is used to obtain the (internationalised) reasons of why the message was filtered.
 	 *
 	 * @param params the spider configurations
-	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @param resourceBundle the resource bundle to obtain the internationalised reasons.
+	 * @throws IllegalArgumentException if any of the given parameters is {@code null}.
 	 * @since TODO add version
 	 * @see SpiderParam#getMaxParseSizeBytes()
 	 */
-	public DefaultParseFilter(SpiderParam params) {
+	public DefaultParseFilter(SpiderParam params, ResourceBundle resourceBundle) {
 		if (params == null) {
 			throw new IllegalArgumentException("Parameter params must not be null.");
 		}
+		if (resourceBundle == null) {
+			throw new IllegalArgumentException("Parameter resourceBundle must not be null.");
+		}
 		this.params = params;
+
+		filterResultEmpty = new FilterResult(resourceBundle.getString("spider.parsefilter.reason.empty"));
+		filterResultMaxSize = new FilterResult(resourceBundle.getString("spider.parsefilter.reason.maxsize"));
+		filterResultNotText = new FilterResult(resourceBundle.getString("spider.parsefilter.reason.nottext"));
 	}
 	
 	@Override
-	public boolean isFiltered(HttpMessage responseMessage) {
+	public FilterResult filtered(HttpMessage responseMessage) {
 		if (responseMessage == null || responseMessage.getRequestHeader().isEmpty()
 				|| responseMessage.getResponseHeader().isEmpty()) {
-			return true;
+			return filterResultEmpty;
 		}
 
 		//if it's a file ending in "/.svn/entries", or "/.svn/wc.db", the SVN Entries or Git parsers will process it 
@@ -102,7 +130,7 @@ public class DefaultParseFilter extends ParseFilter {
 		if (fullfilename != null && (SVN_SQLITE_FILENAME_PATTERN.matcher(fullfilename).find()
 				|| SVN_XML_FILENAME_PATTERN.matcher(fullfilename).find()
 				|| GIT_FILENAME_PATTERN.matcher(fullfilename).find())) {
-			return false;
+			return FilterResult.NOT_FILTERED;
 		}
 
 		// Check response body size
@@ -110,12 +138,12 @@ public class DefaultParseFilter extends ParseFilter {
 			if (log.isDebugEnabled()) {
 				log.debug("Resource too large: " + responseMessage.getRequestHeader().getURI());
 			}
-			return true;
+			return filterResultMaxSize;
 		}
 
 		// If it's a redirection, accept it, as the SpiderRedirectParser will process it
 		if (HttpStatusCode.isRedirection(responseMessage.getResponseHeader().getStatusCode())) {
-			return false;
+			return FilterResult.NOT_FILTERED;
 		}
 		
 		// Check response type.
@@ -123,10 +151,10 @@ public class DefaultParseFilter extends ParseFilter {
 			if (log.isDebugEnabled()) {
 				log.debug("Resource is not text: " + responseMessage.getRequestHeader().getURI());
 			}
-			return true;
+			return filterResultNotText;
 		}
 
-		return false;
+		return FilterResult.NOT_FILTERED;
 	}
 
 }
diff --git a/src/org/zaproxy/zap/spider/filters/MaxChildrenParseFilter.java b/src/org/zaproxy/zap/spider/filters/MaxChildrenParseFilter.java
index f3f697d52..9092db2f5 100644
--- a/src/org/zaproxy/zap/spider/filters/MaxChildrenParseFilter.java
+++ b/src/org/zaproxy/zap/spider/filters/MaxChildrenParseFilter.java
@@ -17,6 +17,10 @@
  */
 package org.zaproxy.zap.spider.filters;
 
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.ResourceBundle;
+
 import org.parosproxy.paros.model.Model;
 import org.parosproxy.paros.model.SiteNode;
 import org.parosproxy.paros.network.HttpMessage;
@@ -30,17 +34,56 @@ public class MaxChildrenParseFilter extends ParseFilter {
 	
 	private Model model;
 
+	private final FilterResult filtered;
+
+	/**
+	 * Constructs a {@code MaxChildrenParseFilter}, with no reason of why the message was filtered.
+	 *
+	 * @deprecated (TODO add version) Use {@link #MaxChildrenParseFilter(ResourceBundle)} instead.
+	 */
+	@Deprecated
+	public MaxChildrenParseFilter() {
+		this(new ResourceBundle() {
+
+			@Override
+			public Enumeration<String> getKeys() {
+				return Collections.emptyEnumeration();
+			}
+
+			@Override
+			protected Object handleGetObject(String key) {
+				return "";
+			}
+		});
+	}
+
+	/**
+	 * Constructs a {@code MaxChildrenParseFilter} with the given resource bundle.
+	 * <p>
+	 * The resource bundle is used to obtain the (internationalised) reason of why the message was filtered.
+	 *
+	 * @param resourceBundle the resource bundle to obtain the internationalised reason.
+	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @since TODO add version
+	 */
+	public MaxChildrenParseFilter(ResourceBundle resourceBundle) {
+		if (resourceBundle == null) {
+			throw new IllegalArgumentException("Parameter resourceBundle must not be null.");
+		}
+		filtered = new FilterResult(resourceBundle.getString("spider.parsefilter.reason.maxchildren"));
+	}
+	
 	@Override
-	public boolean isFiltered(HttpMessage responseMessage) {
+	public FilterResult filtered(HttpMessage responseMessage) {
 
 		SiteNode parent = model.getSession().getSiteTree().findClosestParent(responseMessage);
 		if (parent != null) {
 			if (maxChildren > 0 && parent.getChildCount() > maxChildren) {
-				return true;
+				return filtered;
 			}
 		}
 
-		return false;
+		return FilterResult.NOT_FILTERED;
 	}
 
 	public void setMaxChildren(int maxChildren) {
diff --git a/src/org/zaproxy/zap/spider/filters/ParseFilter.java b/src/org/zaproxy/zap/spider/filters/ParseFilter.java
index c00a1337c..7f95b605d 100644
--- a/src/org/zaproxy/zap/spider/filters/ParseFilter.java
+++ b/src/org/zaproxy/zap/spider/filters/ParseFilter.java
@@ -34,6 +34,103 @@ public abstract class ParseFilter {
 	 * 
 	 * @param responseMessage the response message after the resource was fetched
 	 * @return true, if is filtered
+	 * @deprecated (TODO add version) Use {@link #filtered(HttpMessage)} instead, which allows to provide the reason why the
+	 *             message was filtered.
 	 */
-	public abstract boolean isFiltered(HttpMessage responseMessage);
+	@Deprecated
+	public boolean isFiltered(HttpMessage responseMessage) {
+		return filtered(responseMessage).isFiltered();
+	}
+
+	/**
+	 * Tells whether or not the given resource is filtered. Filtered resources are not parsed.
+	 * <p>
+	 * Default is not filtered.
+	 *
+	 * @param responseMessage the HTTP message containing the response to be or not parsed.
+	 * @return the filter result, must not be {@code null}.
+	 * @since TODO add version
+	 */
+	public FilterResult filtered(HttpMessage responseMessage) {
+		return FilterResult.NOT_FILTERED;
+	}
+
+	/**
+	 * The result of a {@link ParseFilter}'s check.
+	 * <p>
+	 * Used to indicate if a resource was filtered and why.
+	 *
+	 * @since TODO add version
+	 * @see #NOT_FILTERED
+	 * @see #ParseFilter(String)
+	 */
+	public static final class FilterResult {
+
+		/**
+		 * Indicates that the resource was not filtered.
+		 */
+		public static final FilterResult NOT_FILTERED = new FilterResult();
+
+		/**
+		 * Indicates that the resource was filtered, with no specific reason.
+		 */
+		public static final FilterResult FILTERED = new FilterResult("");
+
+		private final boolean filtered;
+		private final String reason;
+
+		/**
+		 * Constructs a {@code FilterResult}, not filtered and with empty reason.
+		 */
+		private FilterResult() {
+			this(false, "");
+		}
+
+		/**
+		 * Constructs a {@code FilterResult} with the reason why the resource will not be parsed.
+		 *
+		 * @param reason the reason why the resource was filtered.
+		 * @see #NOT_FILTERED
+		 */
+		public FilterResult(String reason) {
+			this(true, reason);
+		}
+
+		/**
+		 * Constructs a {@code FilterResult} with the given filtered state and reason.
+		 *
+		 * @param filtered {@code true} if the resource was filtered, {@code false} otherwise.
+		 * @param reason the reason why the resource was filtered.
+		 * @throws IllegalArgumentException if the given {@code reason} is {@code null}.
+		 */
+		private FilterResult(boolean filtered, String reason) {
+			if (reason == null) {
+				throw new IllegalArgumentException("Parameter reason must not be null.");
+			}
+			this.filtered = filtered;
+			this.reason = reason;
+		}
+
+		/**
+		 * Tells whether or not the resource was filtered.
+		 * <p>
+		 * Filtered resources are not parsed.
+		 *
+		 * @return {@code true} if the resource was filtered, {@code false} otherwise.
+		 * @see #getReason()
+		 */
+		public boolean isFiltered() {
+			return filtered;
+		}
+
+		/**
+		 * Gets the reason why the resource was filtered.
+		 *
+		 * @return the reason why the resource was filtered, never {@code null}.
+		 * @see #isFiltered()
+		 */
+		public String getReason() {
+			return reason;
+		}
+	}
 }
diff --git a/src/org/zaproxy/zap/utils/I18N.java b/src/org/zaproxy/zap/utils/I18N.java
index 2c0f56d0a..b9d231abc 100644
--- a/src/org/zaproxy/zap/utils/I18N.java
+++ b/src/org/zaproxy/zap/utils/I18N.java
@@ -26,6 +26,16 @@ public class I18N {
     public I18N (Locale locale) {
     	setLocale(locale);
     }
+
+    /**
+     * Gets the core resource bundle.
+     *
+     * @return the core resource bundle, never {@code null}.
+     * @since TODO add version
+     */
+    public ResourceBundle getCoreResourceBundle() {
+        return this.stdMessages;
+    }
     
     public void addMessageBundle(String prefix, ResourceBundle bundle) {
 		logger.debug("Adding message bundle with prefix: " + prefix);
diff --git a/test/org/zaproxy/zap/spider/filters/DefaultParseFilterUnitTest.java b/test/org/zaproxy/zap/spider/filters/DefaultParseFilterUnitTest.java
index 55ad640a3..bf0de8d41 100644
--- a/test/org/zaproxy/zap/spider/filters/DefaultParseFilterUnitTest.java
+++ b/test/org/zaproxy/zap/spider/filters/DefaultParseFilterUnitTest.java
@@ -21,27 +21,64 @@ import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertThat;
 
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.ResourceBundle;
+
 import org.apache.log4j.Logger;
 import org.apache.log4j.varia.NullAppender;
+import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpRequestHeader;
 import org.zaproxy.zap.spider.SpiderParam;
+import org.zaproxy.zap.spider.filters.ParseFilter.FilterResult;
 
 /**
  * Unit test for {@link DefaultParseFilter}.
  */
 public class DefaultParseFilterUnitTest {
 
+    private static final String FILTERED_REASON_EMPTY = "empty";
+    private static final String FILTERED_REASON_MAX_SIZE = "maxSize";
+    private static final String FILTERED_REASON_NOT_TEXT = "notText";
+    
+    private ResourceBundle resourceBundle;
+    
     @BeforeClass
     public static void suppressLogging() {
         Logger.getRootLogger().addAppender(new NullAppender());
     }
 
+    @Before
+    public void setUp() throws Exception {
+        resourceBundle = new ResourceBundle() {
+
+            @Override
+            protected Object handleGetObject(String key) {
+                switch (key) {
+                case "spider.parsefilter.reason.empty":
+                    return FILTERED_REASON_EMPTY;
+                case "spider.parsefilter.reason.maxsize":
+                    return FILTERED_REASON_MAX_SIZE;
+                case "spider.parsefilter.reason.nottext":
+                    return FILTERED_REASON_NOT_TEXT;
+                }
+                return null;
+            }
+
+            @Override
+            public Enumeration<String> getKeys() {
+                return Collections.emptyEnumeration();
+            }
+
+        };
+    }
+
     @Test
     @SuppressWarnings({ "deprecation", "unused" })
-    public void shouldCreateDefaultParseFilterWithDefaultConfigsIfNoneSet() {
+    public void shouldCreateDefaultParseFilterWithDefaultConfigsAndResourceBundleIfNoneSet() {
         // Given / When
         new DefaultParseFilter();
         // Then = No exception.
@@ -49,11 +86,11 @@ public class DefaultParseFilterUnitTest {
 
     @Test
     @SuppressWarnings("unused")
-    public void shouldCreateDefaultParseFilterWithConfigsSet() {
+    public void shouldCreateDefaultParseFilterWithConfigsAndResourceBundleSet() {
         // Given
         SpiderParam configs = new SpiderParam();
         // When
-        new DefaultParseFilter(configs);
+        new DefaultParseFilter(configs, resourceBundle);
         // Then = No exception.
     }
 
@@ -63,7 +100,18 @@ public class DefaultParseFilterUnitTest {
         // Given
         SpiderParam configs = null;
         // When
-        new DefaultParseFilter(configs);
+        new DefaultParseFilter(configs, resourceBundle);
+        // Then = IllegalArgumentException.
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    @SuppressWarnings("unused")
+    public void shouldFailToCreateDefaultParseFilterWithNullResourceBundle() {
+        // Given
+        ResourceBundle resourceBundle = null;
+        SpiderParam configs = new SpiderParam();
+        // When
+        new DefaultParseFilter(configs, resourceBundle);
         // Then = IllegalArgumentException.
     }
 
@@ -73,9 +121,10 @@ public class DefaultParseFilterUnitTest {
         DefaultParseFilter filter = createDefaultParseFilter();
         HttpMessage httpMessage = null;
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(true)));
+        assertThat(filterResult.isFiltered(), is(equalTo(true)));
+        assertThat(filterResult.getReason(), is(equalTo(FILTERED_REASON_EMPTY)));
     }
 
     @Test
@@ -84,9 +133,10 @@ public class DefaultParseFilterUnitTest {
         DefaultParseFilter filter = createDefaultParseFilter();
         HttpMessage httpMessage = new HttpMessage();
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(true)));
+        assertThat(filterResult.isFiltered(), is(equalTo(true)));
+        assertThat(filterResult.getReason(), is(equalTo(FILTERED_REASON_EMPTY)));
     }
 
     @Test
@@ -95,9 +145,10 @@ public class DefaultParseFilterUnitTest {
         DefaultParseFilter filter = createDefaultParseFilter();
         HttpMessage httpMessage = createDefaultRequest();
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(true)));
+        assertThat(filterResult.isFiltered(), is(equalTo(true)));
+        assertThat(filterResult.getReason(), is(equalTo(FILTERED_REASON_EMPTY)));
     }
 
     @Test
@@ -106,7 +157,7 @@ public class DefaultParseFilterUnitTest {
         DefaultParseFilter filter = createDefaultParseFilter();
         HttpMessage httpMessage = createHttpMessageWithRequestUri("http://example.com");
         // When
-        filter.isFiltered(httpMessage);
+        filter.filtered(httpMessage);
         // Then = No exception.
     }
 
@@ -116,9 +167,9 @@ public class DefaultParseFilterUnitTest {
         DefaultParseFilter filter = createDefaultParseFilter();
         HttpMessage httpMessage = createHttpMessageWithRequestUri("/.svn/wc.db");
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(false)));
+        assertThat(filterResult.isFiltered(), is(equalTo(false)));
     }
 
     @Test
@@ -127,9 +178,9 @@ public class DefaultParseFilterUnitTest {
         DefaultParseFilter filter = createDefaultParseFilter();
         HttpMessage httpMessage = createHttpMessageWithRequestUri("/.svn/entries");
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(false)));
+        assertThat(filterResult.isFiltered(), is(equalTo(false)));
     }
 
     @Test
@@ -138,9 +189,9 @@ public class DefaultParseFilterUnitTest {
         DefaultParseFilter filter = createDefaultParseFilter();
         HttpMessage httpMessage = createHttpMessageWithRequestUri("/.git/index");
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(false)));
+        assertThat(filterResult.isFiltered(), is(equalTo(false)));
     }
 
     @Test
@@ -150,9 +201,10 @@ public class DefaultParseFilterUnitTest {
         HttpMessage httpMessage = createDefaultRequest();
         httpMessage.setResponseHeader("HTTP/1.1 200 OK\r\nContent-Type: application/x-binary\r\n");
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(true)));
+        assertThat(filterResult.isFiltered(), is(equalTo(true)));
+        assertThat(filterResult.getReason(), is(equalTo(FILTERED_REASON_NOT_TEXT)));
     }
 
     @Test
@@ -162,9 +214,9 @@ public class DefaultParseFilterUnitTest {
         HttpMessage httpMessage = createDefaultRequest();
         httpMessage.setResponseHeader("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n");
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(false)));
+        assertThat(filterResult.isFiltered(), is(equalTo(false)));
     }
 
     @Test
@@ -174,49 +226,50 @@ public class DefaultParseFilterUnitTest {
         HttpMessage httpMessage = createDefaultRequest();
         httpMessage.setResponseHeader("HTTP/1.1 303 See Other\r\n");
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(false)));
+        assertThat(filterResult.isFiltered(), is(equalTo(false)));
     }
 
     @Test
     public void shouldFilterHttpMessageWithResponseAboveMaxParseSize() throws Exception {
         // Given
         int maxParseSizeBytes = 2;
-        DefaultParseFilter filter = new DefaultParseFilter(createSpiderParam(maxParseSizeBytes));
+        DefaultParseFilter filter = new DefaultParseFilter(createSpiderParam(maxParseSizeBytes), resourceBundle);
         HttpMessage httpMessage = createHttpMessageWithResponseBody("ABC");
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(true)));
+        assertThat(filterResult.isFiltered(), is(equalTo(true)));
+        assertThat(filterResult.getReason(), is(equalTo(FILTERED_REASON_MAX_SIZE)));
     }
 
     @Test
     public void shouldNotFilterHttpMessageWithResponseEqualToMaxParseSize() throws Exception {
         // Given
         int maxParseSizeBytes = 2;
-        DefaultParseFilter filter = new DefaultParseFilter(createSpiderParam(maxParseSizeBytes));
+        DefaultParseFilter filter = new DefaultParseFilter(createSpiderParam(maxParseSizeBytes), resourceBundle);
         HttpMessage httpMessage = createHttpMessageWithResponseBody("AB");
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(false)));
+        assertThat(filterResult.isFiltered(), is(equalTo(false)));
     }
 
     @Test
     public void shouldNotFilterHttpMessageWithResponseUnderMaxParseSize() throws Exception {
         // Given
         int maxParseSizeBytes = 2;
-        DefaultParseFilter filter = new DefaultParseFilter(createSpiderParam(maxParseSizeBytes));
+        DefaultParseFilter filter = new DefaultParseFilter(createSpiderParam(maxParseSizeBytes), resourceBundle);
         HttpMessage httpMessage = createHttpMessageWithResponseBody("A");
         // When
-        boolean filtered = filter.isFiltered(httpMessage);
+        FilterResult filterResult = filter.filtered(httpMessage);
         // Then
-        assertThat(filtered, is(equalTo(false)));
+        assertThat(filterResult.isFiltered(), is(equalTo(false)));
     }
 
-    private static DefaultParseFilter createDefaultParseFilter() {
-        return new DefaultParseFilter(createSpiderParam(Integer.MAX_VALUE));
+    private DefaultParseFilter createDefaultParseFilter() {
+        return new DefaultParseFilter(createSpiderParam(Integer.MAX_VALUE), resourceBundle);
     }
 
     private static SpiderParam createSpiderParam(final int maxParseSizeBytes) {
