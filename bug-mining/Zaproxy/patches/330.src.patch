diff --git a/zap/src/main/java/org/apache/commons/httpclient/HttpConnection.java b/zap/src/main/java/org/apache/commons/httpclient/HttpConnection.java
index 002340231..27042be38 100644
--- a/zap/src/main/java/org/apache/commons/httpclient/HttpConnection.java
+++ b/zap/src/main/java/org/apache/commons/httpclient/HttpConnection.java
@@ -61,7 +61,7 @@ import org.apache.commons.logging.LogFactory;
  *  - Remove use of reflection to call Socket.shutdownOutput() in shutdownOutput(), not needed by minimum Java version targeted.
  *  - Add @Deprecated annotations to deprecated methods (by JavaDoc deprecated tag).
  *  - Change method tunnelCreated() to also create the tunnel if requested by calling code.
- * 
+ *  - Pass the HttpConnectionParams when calling SecureProtocolSocketFactory.
  */
 /**
  * An abstraction of an HTTP {@link InputStream} and {@link OutputStream}
@@ -801,7 +801,7 @@ public class HttpConnection {
             SecureProtocolSocketFactory socketFactory =
                 (SecureProtocolSocketFactory) protocolInUse.getSocketFactory();
 
-            socket = socketFactory.createSocket(socket, hostName, portNumber, true);
+            socket = socketFactory.createSocket(socket, hostName, portNumber, true, params);
         }
         
         if (LOG.isDebugEnabled()) {
diff --git a/zap/src/main/java/org/apache/commons/httpclient/HttpMethodDirector.java b/zap/src/main/java/org/apache/commons/httpclient/HttpMethodDirector.java
index fc7742dec..bb14482da 100644
--- a/zap/src/main/java/org/apache/commons/httpclient/HttpMethodDirector.java
+++ b/zap/src/main/java/org/apache/commons/httpclient/HttpMethodDirector.java
@@ -72,6 +72,7 @@ import org.apache.commons.logging.LogFactory;
  *  - Added the public modifier to the class.
  *  - Establish a tunnel if the request has a connection upgrade.
  *  - Use neutral Locale when converting to lower case.
+ *  - Add and propagate the parameter PARAM_RESOLVE_HOSTNAME.
  */
 /**
  * Handles the process of executing a method including authentication, redirection and retries.
@@ -92,6 +93,11 @@ public class HttpMethodDirector {
      */
     public static final String PARAM_DEFAULT_USER_AGENT_CONNECT_REQUESTS = "method.connect.default.user.agent";
 
+    /**
+     * Parameter to configure whether or not the (remote) hostname should be resolved when the socket is created.
+     */
+    public static final String PARAM_RESOLVE_HOSTNAME = "socket.resolve.hostname";
+
     /** The www authenticate challange header. */
     public static final String WWW_AUTH_CHALLENGE = "WWW-Authenticate";
 
@@ -444,6 +450,8 @@ public class HttpMethodDirector {
                         this.conn.closeIfStale();
                     }
                     if (!this.conn.isOpen()) {
+                        this.conn.getParams().setBooleanParameter(PARAM_RESOLVE_HOSTNAME,
+                                method.getParams().getBooleanParameter(PARAM_RESOLVE_HOSTNAME, true));
                         // this connection must be opened before it can be used
                         // This has nothing to do with opening a secure tunnel
                         this.conn.open();
diff --git a/zap/src/main/java/org/apache/commons/httpclient/protocol/SecureProtocolSocketFactory.java b/zap/src/main/java/org/apache/commons/httpclient/protocol/SecureProtocolSocketFactory.java
new file mode 100644
index 000000000..9e268f5bb
--- /dev/null
+++ b/zap/src/main/java/org/apache/commons/httpclient/protocol/SecureProtocolSocketFactory.java
@@ -0,0 +1,94 @@
+/*
+ * HeadURL: https://svn.apache.org/repos/asf/httpcomponents/oac.hc3x/trunk/src/java/org/apache/commons/httpclient/protocol/SecureProtocolSocketFactory.jav
+ * Revision: 608014
+ * Date: 2008-01-02 05:48:53 +0000 (Wed, 02 Jan 2008)
+ *
+ * ====================================================================
+ *
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.apache.commons.httpclient.protocol;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.UnknownHostException;
+
+import org.apache.commons.httpclient.params.HttpConnectionParams;
+
+/*
+ * Forked class...
+ *
+ * It was forked because ZAP depends (and uses) Commons HttpClient which is not compatible with, the newer version,
+ * HttpComponents Client.
+ *
+ * Changes:
+ *  - Removed the characters "$" from the previous SVN keywords (HeadURL, Revision and Date).
+ *  - Add a (default) createSocket(...) that allows to provide the HttpConnectionParams.
+ */
+/**
+ * A ProtocolSocketFactory that is secure.
+ *
+ * @see org.apache.commons.httpclient.protocol.ProtocolSocketFactory
+ *
+ * @author Michael Becke
+ * @author <a href="mailto:mbowler@GargoyleSoftware.com">Mike Bowler</a>
+ * @since 2.0
+ */
+public interface SecureProtocolSocketFactory extends ProtocolSocketFactory {
+
+    /**
+     * Returns a socket connected to the given host that is layered over an
+     * existing socket.  Used primarily for creating secure sockets through
+     * proxies.
+     *
+     * @param socket the existing socket
+     * @param host the host name/IP
+     * @param port the port on the host
+     * @param autoClose a flag for closing the underling socket when the created
+     * socket is closed
+     *
+     * @return Socket a new socket
+     *
+     * @throws IOException if an I/O error occurs while creating the socket
+     * @throws UnknownHostException if the IP address of the host cannot be
+     * determined
+     */
+    Socket createSocket(
+        Socket socket,
+        String host,
+        int port,
+        boolean autoClose
+    ) throws IOException, UnknownHostException;
+
+    default Socket createSocket(
+        Socket socket,
+        String host,
+        int port,
+        boolean autoClose,
+        HttpConnectionParams params
+    ) throws IOException {
+        return createSocket(socket, host, port, autoClose);
+    }
+
+}
diff --git a/zap/src/main/java/org/parosproxy/paros/extension/option/OptionsConnectionPanel.java b/zap/src/main/java/org/parosproxy/paros/extension/option/OptionsConnectionPanel.java
index cf3bc28cf..c6786e3bf 100644
--- a/zap/src/main/java/org/parosproxy/paros/extension/option/OptionsConnectionPanel.java
+++ b/zap/src/main/java/org/parosproxy/paros/extension/option/OptionsConnectionPanel.java
@@ -41,6 +41,7 @@
 // ZAP: 2019/06/05 Normalise format/style.
 // ZAP: 2020/03/24 Remove hardcoded white background on some fields (part of Issue 5542).
 // ZAP: 2020/03/25 Remove hardcoded colour in titled borders (Issue 5542).
+// ZAP: 2020/04/20 Add SocksProxyPanel (Issue 29).
 package org.parosproxy.paros.extension.option;
 
 import java.awt.BorderLayout;
@@ -68,6 +69,7 @@ import org.parosproxy.paros.model.OptionsParam;
 import org.parosproxy.paros.network.ConnectionParam;
 import org.parosproxy.paros.view.AbstractParamPanel;
 import org.parosproxy.paros.view.View;
+import org.zaproxy.zap.extension.option.SocksProxyPanel;
 import org.zaproxy.zap.model.CommonUserAgents;
 import org.zaproxy.zap.network.DomainMatcher;
 import org.zaproxy.zap.utils.FontUtils;
@@ -111,8 +113,11 @@ public class OptionsConnectionPanel extends AbstractParamPanel {
     private ProxyExcludedDomainsMultipleOptionsPanel proxyExcludedDomainsPanel;
     private ProxyExcludedDomainsTableModel proxyExcludedDomainsTableModel;
 
+    private final SocksProxyPanel socksProxyPanel;
+
     public OptionsConnectionPanel() {
         super();
+        socksProxyPanel = new SocksProxyPanel();
         initialize();
     }
 
@@ -400,6 +405,7 @@ public class OptionsConnectionPanel extends AbstractParamPanel {
             innerPanel.add(getSecurityProtocolsPanel(), gbc);
             innerPanel.add(getJPanel(), gbc);
             innerPanel.add(getPanelProxyAuth(), gbc);
+            innerPanel.add(socksProxyPanel, gbc);
 
             JScrollPane scrollPane = new JScrollPane(innerPanel);
             scrollPane.setBorder(BorderFactory.createEmptyBorder());
@@ -597,6 +603,8 @@ public class OptionsConnectionPanel extends AbstractParamPanel {
 
         defaultUserAgent.setText(connectionParam.getDefaultUserAgent());
         setUaFromString();
+
+        socksProxyPanel.initParam(connectionParam);
     }
 
     private void setProxyChainEnabled(boolean isEnabled) {
@@ -648,6 +656,8 @@ public class OptionsConnectionPanel extends AbstractParamPanel {
         }
 
         securityProtocolsPanel.validateSecurityProtocols();
+
+        socksProxyPanel.validateParam();
     }
 
     @Override
@@ -694,6 +704,8 @@ public class OptionsConnectionPanel extends AbstractParamPanel {
         connectionParam.setSecurityProtocolsEnabled(securityProtocolsPanel.getSelectedProtocols());
 
         connectionParam.setDefaultUserAgent(defaultUserAgent.getText());
+
+        socksProxyPanel.saveParam(connectionParam);
     }
 
     /**
diff --git a/zap/src/main/java/org/parosproxy/paros/network/ConnectionParam.java b/zap/src/main/java/org/parosproxy/paros/network/ConnectionParam.java
index 610cb7886..054b1458f 100644
--- a/zap/src/main/java/org/parosproxy/paros/network/ConnectionParam.java
+++ b/zap/src/main/java/org/parosproxy/paros/network/ConnectionParam.java
@@ -47,13 +47,16 @@
 // ZAP: 2019/06/01 Normalise line endings.
 // ZAP: 2019/06/05 Normalise format/style.
 // ZAP: 2020/01/02 Updated default user agent
+// ZAP: 2020/04/20 Allow to configure the SOCKS proxy (Issue 29).
 package org.parosproxy.paros.network;
 
+import java.net.PasswordAuthentication;
 import java.security.Security;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 import java.util.regex.Pattern;
 import org.apache.commons.configuration.HierarchicalConfiguration;
 import org.apache.commons.httpclient.HttpState;
@@ -61,6 +64,7 @@ import org.apache.log4j.Logger;
 import org.parosproxy.paros.common.AbstractParam;
 import org.zaproxy.zap.extension.api.ZapApiIgnore;
 import org.zaproxy.zap.network.DomainMatcher;
+import org.zaproxy.zap.network.SocksProxy;
 
 public class ConnectionParam extends AbstractParam {
 
@@ -128,6 +132,33 @@ public class ConnectionParam extends AbstractParam {
      */
     public static final int DEFAULT_TIMEOUT = 20;
 
+    private static final String SOCKS_PROXY_BASE_KEY = CONNECTION_BASE_KEY + ".socksProxy.";
+    private static final String USE_SOCKS_PROXY_KEY = SOCKS_PROXY_BASE_KEY + "enabled";
+    private static final String SOCKS_PROXY_HOST_KEY = SOCKS_PROXY_BASE_KEY + "host";
+    private static final String SOCKS_PROXY_PORT_KEY = SOCKS_PROXY_BASE_KEY + "port";
+    private static final String SOCKS_PROXY_VERSION_KEY = SOCKS_PROXY_BASE_KEY + "version";
+    private static final String SOCKS_PROXY_DNS_KEY = SOCKS_PROXY_BASE_KEY + "dns";
+    private static final String SOCKS_PROXY_USERNAME_KEY = SOCKS_PROXY_BASE_KEY + "username";
+    private static final String SOCKS_PROXY_PASSWORD_KEY = SOCKS_PROXY_BASE_KEY + "password";
+
+    /**
+     * The default SOCKS proxy configuration.
+     *
+     * @since TODO add version
+     */
+    public static final SocksProxy DEFAULT_SOCKS_PROXY = new SocksProxy("localhost", 1080);
+
+    /**
+     * Pattern with loopback names and addresses that should be always resolved (when creating the
+     * {@link java.net.InetSocketAddress}).
+     *
+     * <p>Same pattern used by default proxy selector.
+     *
+     * @see #shouldResolveRemoteHostname(String)
+     */
+    private static final Pattern LOOPBACK_PATTERN =
+            Pattern.compile("\\Qlocalhost\\E|\\Q127.\\E.*|\\Q[::1]\\E|\\Q0.0.0.0\\E|\\Q[::0]\\E");
+
     private boolean useProxyChain;
     private String proxyChainName = "";
     private int proxyChainPort = 8080;
@@ -136,6 +167,12 @@ public class ConnectionParam extends AbstractParam {
     private String proxyChainRealm = "";
     private String proxyChainUserName = "";
     private String proxyChainPassword = "";
+
+    private boolean useSocksProxy;
+    private SocksProxy socksProxy = DEFAULT_SOCKS_PROXY;
+    private PasswordAuthentication socksProxyPasswordAuth =
+            new PasswordAuthentication("", new char[0]);
+
     private HttpState httpState = null;
     private boolean httpStateEnabled = false;
     private List<DomainMatcher> proxyExcludedDomains = new ArrayList<>(0);
@@ -223,6 +260,8 @@ public class ConnectionParam extends AbstractParam {
         HttpRequestHeader.setDefaultUserAgent(defaultUserAgent);
 
         loadSecurityProtocolsEnabled();
+
+        parseSocksProxyOptions();
     }
 
     private void updateOptions() {
@@ -818,4 +857,202 @@ public class ConnectionParam extends AbstractParam {
         dnsTtlSuccessfulQueries = ttl;
         getConfig().setProperty(DNS_TTL_SUCCESSFUL_QUERIES_KEY, ttl);
     }
+
+    private void parseSocksProxyOptions() {
+        String host = System.getProperty("socksProxyHost");
+        int port;
+        String version;
+        boolean useDns = getBoolean(SOCKS_PROXY_DNS_KEY, DEFAULT_SOCKS_PROXY.isUseDns());
+
+        if (host != null && !host.isEmpty()) {
+            port = parseSocksPort(System.getProperty("socksProxyPort"));
+            version = System.getProperty("socksProxyVersion");
+
+            useSocksProxy = true;
+        } else {
+            host = getString(SOCKS_PROXY_HOST_KEY, DEFAULT_SOCKS_PROXY.getHost());
+            port = parseSocksPort(getConfig().getString(SOCKS_PROXY_PORT_KEY));
+            version =
+                    getString(
+                            SOCKS_PROXY_VERSION_KEY,
+                            String.valueOf(DEFAULT_SOCKS_PROXY.getVersion().number()));
+
+            useSocksProxy = getBoolean(USE_SOCKS_PROXY_KEY, false);
+        }
+
+        socksProxy = new SocksProxy(host, port, SocksProxy.Version.from(version), useDns);
+        if (useSocksProxy) {
+            apply(socksProxy);
+        }
+
+        socksProxyPasswordAuth =
+                new PasswordAuthentication(
+                        getString(SOCKS_PROXY_USERNAME_KEY, ""),
+                        getString(SOCKS_PROXY_PASSWORD_KEY, "").toCharArray());
+    }
+
+    private static int parseSocksPort(String value) {
+        if (value == null || value.isEmpty()) {
+            return DEFAULT_SOCKS_PROXY.getPort();
+        }
+
+        int port;
+        try {
+            port = Integer.parseInt(value);
+        } catch (NumberFormatException e) {
+            log.warn("Failed to parse the SOCKS port: " + value, e);
+            return DEFAULT_SOCKS_PROXY.getPort();
+        }
+
+        if (port > 0 && port <= 65535) {
+            return port;
+        }
+
+        log.warn("Invalid SOCKS port: " + value);
+        return DEFAULT_SOCKS_PROXY.getPort();
+    }
+
+    /**
+     * Applies the given SOCKS proxy configuration to the SOCKS system properties.
+     *
+     * <p>If the SOCKS proxy is not in use (i.e. {@link #useSocksProxy} is {@code false}) the system
+     * properties are cleared.
+     *
+     * @param socksProxy the SOCKS proxy to apply.
+     */
+    private void apply(SocksProxy socksProxy) {
+        String host = "";
+        String port = "";
+        String version = "";
+        if (useSocksProxy) {
+            host = socksProxy.getHost();
+            port = Integer.toString(socksProxy.getPort());
+            version = Integer.toString(socksProxy.getVersion().number());
+        }
+        System.setProperty("socksProxyHost", host);
+        System.setProperty("socksProxyPort", port);
+        System.setProperty("socksProxyVersion", version);
+    }
+
+    /**
+     * Tells whether or not the given hostname should be resolved.
+     *
+     * <p>The names should not be resolved when ZAP is configured to use a SOCKSv5 proxy and rely on
+     * it for resolution.
+     *
+     * <p><strong>Note:</strong> Not part of the public API.
+     *
+     * @param hostname the name to check.
+     * @return {@code true} if the given {@code hostname} should be resolved, {@code false}
+     *     otherwise.
+     */
+    @ZapApiIgnore
+    public boolean shouldResolveRemoteHostname(String hostname) {
+        if (!useSocksProxy
+                || !socksProxy.isUseDns()
+                || socksProxy.getVersion() != SocksProxy.Version.SOCKS5) {
+            return true;
+        }
+        return LOOPBACK_PATTERN.matcher(hostname).matches();
+    }
+
+    /**
+     * Tells whether or not the outgoing connections should use the SOCKS proxy.
+     *
+     * @return {@code true} if outgoing connections should use the SOCKS proxy, {@code false}
+     *     otherwise.
+     * @since TODO add version
+     * @see #setUseSocksProxy(boolean)
+     */
+    public boolean isUseSocksProxy() {
+        return useSocksProxy;
+    }
+
+    /**
+     * Sets whether or not the outgoing connections should use the SOCKS proxy.
+     *
+     * @param useSocksProxy {@code true} if outgoing connections should use the SOCKS proxy, {@code
+     *     false} otherwise.
+     * @since TODO add version
+     * @see #isUseSocksProxy()
+     * @see #setSocksProxy(SocksProxy)
+     */
+    public void setUseSocksProxy(boolean useSocksProxy) {
+        if (this.useSocksProxy == useSocksProxy) {
+            return;
+        }
+
+        this.useSocksProxy = useSocksProxy;
+
+        getConfig().setProperty(USE_SOCKS_PROXY_KEY, useSocksProxy);
+
+        apply(socksProxy);
+    }
+
+    /**
+     * Gets the SOCKS proxy for outgoing connections.
+     *
+     * @return the SOCKS proxy, never {@code null}.
+     * @since TODO add version
+     * @see #isUseSocksProxy()
+     * @see #setSocksProxy(SocksProxy)
+     */
+    @ZapApiIgnore
+    public SocksProxy getSocksProxy() {
+        return socksProxy;
+    }
+
+    /**
+     * Sets the SOCKS proxy for outgoing connections.
+     *
+     * @param socksProxy the SOCKS proxy.
+     * @throws NullPointerException if the given {@code socksProxy} is {@code null}.
+     * @since TODO add version
+     * @see #getSocksProxy()
+     * @see #setUseSocksProxy(boolean)
+     */
+    public void setSocksProxy(SocksProxy socksProxy) {
+        if (this.socksProxy.equals(socksProxy)) {
+            return;
+        }
+
+        this.socksProxy = Objects.requireNonNull(socksProxy);
+
+        getConfig().setProperty(SOCKS_PROXY_HOST_KEY, socksProxy.getHost());
+        getConfig().setProperty(SOCKS_PROXY_PORT_KEY, socksProxy.getPort());
+        getConfig().setProperty(SOCKS_PROXY_VERSION_KEY, socksProxy.getVersion().number());
+        getConfig().setProperty(SOCKS_PROXY_DNS_KEY, socksProxy.isUseDns());
+
+        if (useSocksProxy) {
+            apply(socksProxy);
+        }
+    }
+
+    /**
+     * Gets the SOCKS proxy password authentication.
+     *
+     * @return the SOCKS proxy password authentication, never {@code null}.
+     * @since TODO add version
+     * @see #isUseSocksProxy()
+     * @see #setSocksProxyPasswordAuth(PasswordAuthentication)
+     */
+    @ZapApiIgnore
+    public PasswordAuthentication getSocksProxyPasswordAuth() {
+        return socksProxyPasswordAuth;
+    }
+
+    /**
+     * Sets the SOCKS proxy password authentication.
+     *
+     * @param passwordAuth the password authentication.
+     * @throws NullPointerException if the given {@code passwordAuth} is {@code null}.
+     * @since TODO add version
+     * @see #getSocksProxyPasswordAuth()
+     */
+    public void setSocksProxyPasswordAuth(PasswordAuthentication passwordAuth) {
+        this.socksProxyPasswordAuth = Objects.requireNonNull(passwordAuth);
+
+        getConfig().setProperty(SOCKS_PROXY_USERNAME_KEY, passwordAuth.getUserName());
+        getConfig().setProperty(SOCKS_PROXY_PASSWORD_KEY, new String(passwordAuth.getPassword()));
+    }
 }
diff --git a/zap/src/main/java/org/parosproxy/paros/network/HttpSender.java b/zap/src/main/java/org/parosproxy/paros/network/HttpSender.java
index ea492b1e2..707ca691e 100644
--- a/zap/src/main/java/org/parosproxy/paros/network/HttpSender.java
+++ b/zap/src/main/java/org/parosproxy/paros/network/HttpSender.java
@@ -82,6 +82,7 @@
 // ZAP: 2019/08/19 Reinstate proxy auth credentials when HTTP state is changed.
 // ZAP: 2019/09/17 Use remove() instead of set(null) on IN_LISTENER.
 // ZAP: 2019/09/25 Add option to disable cookies
+// ZAP: 2020/04/20 Configure if the names should be resolved or not (Issue 29).
 package org.parosproxy.paros.network;
 
 import java.io.IOException;
@@ -409,6 +410,11 @@ public class HttpSender {
             }
         }
 
+        method.getParams()
+                .setBooleanParameter(
+                        HttpMethodDirector.PARAM_RESOLVE_HOSTNAME,
+                        param.shouldResolveRemoteHostname(hostName));
+
         // ZAP: Check if a custom state is being used
         if (state != null) {
             // Make sure cookies are enabled
diff --git a/zap/src/main/java/org/parosproxy/paros/network/SSLConnector.java b/zap/src/main/java/org/parosproxy/paros/network/SSLConnector.java
index c8db266c1..4b8a69794 100644
--- a/zap/src/main/java/org/parosproxy/paros/network/SSLConnector.java
+++ b/zap/src/main/java/org/parosproxy/paros/network/SSLConnector.java
@@ -39,6 +39,7 @@
 // ZAP: 2019/02/26 Disable TLS 1.3 by default as it currently fails with Java 11
 // ZAP: 2019/06/01 Normalise line endings.
 // ZAP: 2019/06/05 Normalise format/style.
+// ZAP: 2020/04/20 Let SOCKS proxy resolve hosts if set (Issue 29).
 package org.parosproxy.paros.network;
 
 import ch.csnc.extension.httpclient.SSLContextManager;
@@ -83,6 +84,7 @@ import javax.net.ssl.X509KeyManager;
 import org.apache.commons.collections.MapIterator;
 import org.apache.commons.collections.map.LRUMap;
 import org.apache.commons.httpclient.ConnectTimeoutException;
+import org.apache.commons.httpclient.HttpMethodDirector;
 import org.apache.commons.httpclient.params.HttpConnectionParams;
 import org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;
 import org.apache.commons.validator.routines.InetAddressValidator;
@@ -433,7 +435,9 @@ public class SSLConnector implements SecureProtocolSocketFactory {
 
                 return sslSocket;
             } catch (SSLException e) {
-                if (!e.getMessage().contains(CONTENTS_UNRECOGNIZED_NAME_EXCEPTION)) {
+                if (!e.getMessage().contains(CONTENTS_UNRECOGNIZED_NAME_EXCEPTION)
+                        || !params.getBooleanParameter(
+                                HttpMethodDirector.PARAM_RESOLVE_HOSTNAME, true)) {
                     throw e;
                 }
 
@@ -446,12 +450,21 @@ public class SSLConnector implements SecureProtocolSocketFactory {
         Socket socket = clientSSLSockFactory.createSocket();
         SocketAddress localAddr = new InetSocketAddress(localAddress, localPort);
         socket.bind(localAddr);
-        SocketAddress remoteAddr = new InetSocketAddress(host, port);
+        SocketAddress remoteAddr = createRemoteAddr(params, host, port);
         socket.connect(remoteAddr, timeout);
 
         return socket;
     }
 
+    private static SocketAddress createRemoteAddr(
+            HttpConnectionParams params, String host, int port) {
+        if (params == null
+                || params.getBooleanParameter(HttpMethodDirector.PARAM_RESOLVE_HOSTNAME, true)) {
+            return new InetSocketAddress(host, port);
+        }
+        return InetSocketAddress.createUnresolved(host, port);
+    }
+
     private static void cacheMisconfiguredHost(String host, int port, InetAddress address) {
         synchronized (misconfiguredHosts) {
             if (!misconfiguredHosts.isEmpty()) {
@@ -537,6 +550,13 @@ public class SSLConnector implements SecureProtocolSocketFactory {
     @Override
     public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
             throws IOException, UnknownHostException {
+        return createSocket(socket, host, port, autoClose, null);
+    }
+
+    @Override
+    public Socket createSocket(
+            Socket socket, String host, int port, boolean autoClose, HttpConnectionParams params)
+            throws IOException {
         InetAddress inetAddress = getCachedMisconfiguredHost(host, port);
         if (inetAddress != null) {
             return clientSSLSockFactory.createSocket(
@@ -550,7 +570,9 @@ public class SSLConnector implements SecureProtocolSocketFactory {
 
             return socketSSL;
         } catch (SSLException e) {
-            if (e.getMessage().contains(CONTENTS_UNRECOGNIZED_NAME_EXCEPTION)) {
+            if (e.getMessage().contains(CONTENTS_UNRECOGNIZED_NAME_EXCEPTION)
+                    && params.getBooleanParameter(
+                            HttpMethodDirector.PARAM_RESOLVE_HOSTNAME, true)) {
                 cacheMisconfiguredHost(host, port, InetAddress.getByName(host));
             }
             // Throw the exception anyway because the socket might no longer be usable (e.g.
diff --git a/zap/src/main/java/org/zaproxy/zap/ZAP.java b/zap/src/main/java/org/zaproxy/zap/ZAP.java
index 1973c2839..d3b1b6560 100644
--- a/zap/src/main/java/org/zaproxy/zap/ZAP.java
+++ b/zap/src/main/java/org/zaproxy/zap/ZAP.java
@@ -21,12 +21,21 @@ package org.zaproxy.zap;
 
 import java.io.IOException;
 import java.io.PrintStream;
+import java.net.Authenticator;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ProxySelector;
+import java.net.Socket;
+import java.net.SocketAddress;
 import java.net.URLConnection;
 import java.util.Arrays;
 import java.util.Enumeration;
 import java.util.Locale;
+import javax.net.SocketFactory;
 import net.htmlparser.jericho.Config;
 import net.htmlparser.jericho.LoggerProvider;
+import org.apache.commons.httpclient.HttpMethodDirector;
+import org.apache.commons.httpclient.params.HttpConnectionParams;
 import org.apache.commons.httpclient.protocol.Protocol;
 import org.apache.commons.httpclient.protocol.ProtocolSocketFactory;
 import org.apache.commons.io.output.NullOutputStream;
@@ -38,6 +47,8 @@ import org.parosproxy.paros.CommandLine;
 import org.parosproxy.paros.network.SSLConnector;
 import org.zaproxy.zap.eventBus.EventBus;
 import org.zaproxy.zap.eventBus.SimpleEventBus;
+import org.zaproxy.zap.network.ZapAuthenticator;
+import org.zaproxy.zap.network.ZapProxySelector;
 
 public class ZAP {
 
@@ -64,6 +75,9 @@ public class ZAP {
     private static final Logger logger = Logger.getLogger(ZAP.class);
 
     static {
+        ProxySelector.setDefault(ZapProxySelector.getSingleton());
+        Authenticator.setDefault(ZapAuthenticator.getSingleton());
+
         try {
             // Disable JAR caching to avoid leaking add-on files and use of stale data.
             URLConnection.class
@@ -92,6 +106,9 @@ public class ZAP {
                     new Protocol("https", (ProtocolSocketFactory) new SSLConnector(), 443));
         }
 
+        Protocol.registerProtocol(
+                "http", new Protocol("http", new ProtocolSocketFactoryImpl(), 80));
+
         // Initialise this earlier as possible.
         Config.LoggerProvider = JERICHO_LOGGER_PROVIDER;
     }
@@ -469,4 +486,49 @@ public class ZAP {
             }
         }
     }
+
+    /**
+     * A {@link ProtocolSocketFactory} for plain sockets.
+     *
+     * <p>Remote hostnames are not resolved if {@link HttpMethodDirector#PARAM_RESOLVE_HOSTNAME} is
+     * {@code false}.
+     */
+    private static class ProtocolSocketFactoryImpl implements ProtocolSocketFactory {
+
+        @Override
+        public Socket createSocket(
+                String host,
+                int port,
+                InetAddress localAddress,
+                int localPort,
+                HttpConnectionParams params)
+                throws IOException {
+            if (params == null) {
+                throw new IllegalArgumentException("Parameters may not be null");
+            }
+            Socket socket = SocketFactory.getDefault().createSocket();
+            socket.bind(new InetSocketAddress(localAddress, localPort));
+            SocketAddress remoteAddress;
+            if (params.getBooleanParameter(HttpMethodDirector.PARAM_RESOLVE_HOSTNAME, true)) {
+                remoteAddress = new InetSocketAddress(host, port);
+            } else {
+                remoteAddress = InetSocketAddress.createUnresolved(host, port);
+            }
+            socket.connect(remoteAddress, params.getConnectionTimeout());
+            return socket;
+        }
+
+        @Override
+        public Socket createSocket(String host, int port, InetAddress localAddress, int localPort)
+                throws IOException {
+            throw new UnsupportedOperationException(
+                    "Method not supported, not required/called by Commons HttpClient library (version >= 3.0).");
+        }
+
+        @Override
+        public Socket createSocket(String host, int port) throws IOException {
+            throw new UnsupportedOperationException(
+                    "Method not supported, not required/called by Commons HttpClient library (version >= 3.0).");
+        }
+    }
 }
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/DownloadManager.java b/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/DownloadManager.java
index d9cdc1d7d..8c6d055c8 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/DownloadManager.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/DownloadManager.java
@@ -20,9 +20,7 @@
 package org.zaproxy.zap.extension.autoupdate;
 
 import java.io.File;
-import java.net.Authenticator;
 import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
 import java.net.Proxy;
 import java.net.URL;
 import java.util.ArrayList;
@@ -44,9 +42,6 @@ public class DownloadManager extends Thread {
         super("ZAP-DownloadManager");
         this.connectionParam = connectionParam;
         setDaemon(true);
-
-        // TODO Remove once the class Downloader uses HttpClient instead of URL to download the file
-        Authenticator.setDefault(new ZapProxyAuthenticator());
     }
 
     public Downloader downloadFile(URL url, File targetFile, long size, String hash) {
@@ -163,35 +158,4 @@ public class DownloadManager extends Thread {
         }
         return allDownloads;
     }
-
-    // TODO Remove once the class Downloader uses HttpClient instead of URL to download the file
-    private final class ZapProxyAuthenticator extends Authenticator {
-
-        @Override
-        protected PasswordAuthentication getPasswordAuthentication() {
-            if (getRequestorType() != RequestorType.PROXY) {
-                return null;
-            }
-
-            if (getRequestingURL() == null) {
-                return null;
-            }
-
-            if (!connectionParam.isUseProxy(getRequestingURL().getHost())) {
-                return null;
-            }
-
-            if (connectionParam.getProxyChainPort() != getRequestingPort()) {
-                return null;
-            }
-
-            if (!connectionParam.getProxyChainName().equals(getRequestingHost())) {
-                return null;
-            }
-
-            return new PasswordAuthentication(
-                    connectionParam.getProxyChainUserName(),
-                    connectionParam.getProxyChainPassword().toCharArray());
-        }
-    }
 }
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/Downloader.java b/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/Downloader.java
index 7c13d956e..83764a4e7 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/Downloader.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/Downloader.java
@@ -96,15 +96,7 @@ public class Downloader extends Thread {
              * fos.getChannel().transferFrom(rbc, 0, 1 << 24);
              */
 
-            // XXX Change to use HttpClient instead of URL to download the file. The
-            // java.net.Authenticator is shared by all
-            // the URLConnection, it may be changed by 3rd party add-ons/libraries and it can't be
-            // set on a single connection
-            // (see bug 4941958 [1]) in which case the authentication will not succeed (hence the
-            // file will not be downloaded).
-            //
-            // [1] http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4941958
-
+            // XXX Change to use HttpClient to respect all proxy settings (e.g. use of SOCKS).
             in = new BufferedInputStream(url.openConnection(proxy).getInputStream());
             out = new FileOutputStream(this.targetFile);
             byte[] data = new byte[1024];
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/option/SocksProxyPanel.java b/zap/src/main/java/org/zaproxy/zap/extension/option/SocksProxyPanel.java
new file mode 100644
index 000000000..ff9fd75b2
--- /dev/null
+++ b/zap/src/main/java/org/zaproxy/zap/extension/option/SocksProxyPanel.java
@@ -0,0 +1,244 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.extension.option;
+
+import java.awt.event.ItemEvent;
+import java.net.PasswordAuthentication;
+import java.util.Arrays;
+import javax.swing.BorderFactory;
+import javax.swing.ButtonGroup;
+import javax.swing.GroupLayout;
+import javax.swing.JCheckBox;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JPasswordField;
+import javax.swing.JRadioButton;
+import javax.swing.border.TitledBorder;
+import org.parosproxy.paros.Constant;
+import org.parosproxy.paros.network.ConnectionParam;
+import org.zaproxy.zap.network.SocksProxy;
+import org.zaproxy.zap.utils.FontUtils;
+import org.zaproxy.zap.utils.ZapPortNumberSpinner;
+import org.zaproxy.zap.utils.ZapTextField;
+
+/** A panel for SOCKS proxy configuration. */
+public class SocksProxyPanel extends JPanel {
+
+    private static final long serialVersionUID = 1L;
+
+    private final JCheckBox useSocksCheckBox;
+    private final ZapTextField hostTextField;
+    private final ZapPortNumberSpinner portNumberSpinner;
+    private final JRadioButton version4RadioButton;
+    private final JRadioButton version5RadioButton;
+    private final JCheckBox useSocksDnsCheckBox;
+    private final ZapTextField usernameTextField;
+    private final JPasswordField passwordField;
+
+    public SocksProxyPanel() {
+        setBorder(
+                BorderFactory.createTitledBorder(
+                        null,
+                        Constant.messages.getString("conn.options.socks.title"),
+                        TitledBorder.DEFAULT_JUSTIFICATION,
+                        TitledBorder.DEFAULT_POSITION,
+                        FontUtils.getFont(FontUtils.Size.standard)));
+
+        GroupLayout layout = new GroupLayout(this);
+        setLayout(layout);
+        layout.setAutoCreateGaps(true);
+
+        hostTextField = new ZapTextField();
+        hostTextField.setText(ConnectionParam.DEFAULT_SOCKS_PROXY.getHost());
+        JLabel hostLabel = new JLabel(Constant.messages.getString("conn.options.socks.host"));
+        hostLabel.setLabelFor(hostTextField);
+
+        portNumberSpinner = new ZapPortNumberSpinner(ConnectionParam.DEFAULT_SOCKS_PROXY.getPort());
+        JLabel portLabel = new JLabel(Constant.messages.getString("conn.options.socks.port"));
+        portLabel.setLabelFor(portNumberSpinner);
+
+        JLabel versionLabel = new JLabel(Constant.messages.getString("conn.options.socks.version"));
+        version4RadioButton = new JRadioButton("4a");
+        version5RadioButton = new JRadioButton("5");
+
+        ButtonGroup versionButtonGroup = new ButtonGroup();
+        versionButtonGroup.add(version4RadioButton);
+        versionButtonGroup.add(version5RadioButton);
+        version4RadioButton.setSelected(true);
+
+        useSocksDnsCheckBox = new JCheckBox(Constant.messages.getString("conn.options.socks.dns"));
+        useSocksDnsCheckBox.setToolTipText(
+                Constant.messages.getString("conn.options.socks.dns.tooltip"));
+        useSocksDnsCheckBox.setSelected(true);
+
+        usernameTextField = new ZapTextField();
+        JLabel usernameLabel =
+                new JLabel(Constant.messages.getString("conn.options.socks.username"));
+        usernameLabel.setLabelFor(usernameTextField);
+
+        passwordField = new JPasswordField();
+        JLabel passwordLabel =
+                new JLabel(Constant.messages.getString("conn.options.socks.password"));
+        passwordLabel.setLabelFor(passwordField);
+
+        useSocksCheckBox =
+                new JCheckBox(Constant.messages.getString("conn.options.socks.enabled"), true);
+        useSocksCheckBox.addItemListener(
+                e -> {
+                    boolean state = e.getStateChange() == ItemEvent.SELECTED;
+                    hostTextField.setEnabled(state);
+                    portNumberSpinner.setEnabled(state);
+                    version4RadioButton.setEnabled(state);
+                    version5RadioButton.setEnabled(state);
+                    useSocksDnsCheckBox.setEnabled(state && version5RadioButton.isSelected());
+                    usernameTextField.setEnabled(state);
+                    passwordField.setEnabled(state);
+                });
+        useSocksCheckBox.setSelected(false);
+
+        version5RadioButton.addItemListener(
+                e ->
+                        useSocksDnsCheckBox.setEnabled(
+                                e.getStateChange() == ItemEvent.SELECTED
+                                        && useSocksCheckBox.isSelected()));
+        setSelectedVersion(ConnectionParam.DEFAULT_SOCKS_PROXY.getVersion());
+
+        layout.setHorizontalGroup(
+                layout.createParallelGroup()
+                        .addComponent(useSocksCheckBox)
+                        .addGroup(
+                                layout.createSequentialGroup()
+                                        .addGroup(
+                                                layout.createParallelGroup()
+                                                        .addComponent(hostLabel)
+                                                        .addComponent(portLabel)
+                                                        .addComponent(versionLabel)
+                                                        .addComponent(usernameLabel)
+                                                        .addComponent(passwordLabel))
+                                        .addGroup(
+                                                layout.createParallelGroup()
+                                                        .addComponent(hostTextField)
+                                                        .addComponent(portNumberSpinner)
+                                                        .addGroup(
+                                                                layout.createParallelGroup()
+                                                                        .addGroup(
+                                                                                layout.createSequentialGroup()
+                                                                                        .addComponent(
+                                                                                                version4RadioButton)
+                                                                                        .addComponent(
+                                                                                                version5RadioButton))
+                                                                        .addComponent(
+                                                                                useSocksDnsCheckBox))
+                                                        .addComponent(usernameTextField)
+                                                        .addComponent(passwordField))));
+
+        layout.setVerticalGroup(
+                layout.createSequentialGroup()
+                        .addComponent(useSocksCheckBox)
+                        .addGroup(
+                                layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
+                                        .addComponent(hostLabel)
+                                        .addComponent(hostTextField))
+                        .addGroup(
+                                layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
+                                        .addComponent(portLabel)
+                                        .addComponent(portNumberSpinner))
+                        .addGroup(
+                                layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
+                                        .addComponent(versionLabel)
+                                        .addComponent(version4RadioButton)
+                                        .addComponent(version5RadioButton))
+                        .addComponent(useSocksDnsCheckBox)
+                        .addGroup(
+                                layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
+                                        .addComponent(usernameLabel)
+                                        .addComponent(usernameTextField))
+                        .addGroup(
+                                layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
+                                        .addComponent(passwordLabel)
+                                        .addComponent(passwordField)));
+    }
+
+    private void setSelectedVersion(SocksProxy.Version version) {
+        switch (version) {
+            case SOCKS4a:
+                version4RadioButton.setSelected(true);
+                break;
+            case SOCKS5:
+            default:
+                version5RadioButton.setSelected(true);
+        }
+    }
+
+    private SocksProxy.Version getSelectedVersion() {
+        if (version4RadioButton.isSelected()) {
+            return SocksProxy.Version.SOCKS4a;
+        }
+        return SocksProxy.Version.SOCKS5;
+    }
+
+    public void initParam(ConnectionParam options) {
+        useSocksCheckBox.setSelected(options.isUseSocksProxy());
+
+        SocksProxy socksProxy = options.getSocksProxy();
+        hostTextField.setText(socksProxy.getHost());
+        hostTextField.discardAllEdits();
+        portNumberSpinner.setValue(socksProxy.getPort());
+        setSelectedVersion(socksProxy.getVersion());
+        useSocksDnsCheckBox.setSelected(socksProxy.isUseDns());
+
+        PasswordAuthentication passwordAuthentication = options.getSocksProxyPasswordAuth();
+        usernameTextField.setText(passwordAuthentication.getUserName());
+        usernameTextField.discardAllEdits();
+        passwordField.setText(new String(passwordAuthentication.getPassword()));
+    }
+
+    public void validateParam() throws Exception {
+        if (hostTextField.getText().isEmpty()) {
+            hostTextField.requestFocus();
+            throw new Exception(Constant.messages.getString("conn.options.socks.host.empty"));
+        }
+    }
+
+    public void saveParam(ConnectionParam options) {
+        options.setUseSocksProxy(useSocksCheckBox.isSelected());
+
+        SocksProxy oldSocksProxy = options.getSocksProxy();
+        if (!oldSocksProxy.getHost().equals(hostTextField.getText())
+                || oldSocksProxy.getPort() != portNumberSpinner.getValue()
+                || oldSocksProxy.getVersion() != getSelectedVersion()
+                || oldSocksProxy.isUseDns() != useSocksDnsCheckBox.isSelected()) {
+            options.setSocksProxy(
+                    new SocksProxy(
+                            hostTextField.getText(),
+                            portNumberSpinner.getValue(),
+                            getSelectedVersion(),
+                            useSocksDnsCheckBox.isSelected()));
+        }
+
+        PasswordAuthentication passwordAuthentication = options.getSocksProxyPasswordAuth();
+        char[] password = passwordField.getPassword();
+        if (!passwordAuthentication.getUserName().equals(usernameTextField.getText())
+                || !Arrays.equals(passwordAuthentication.getPassword(), password)) {
+            options.setSocksProxyPasswordAuth(
+                    new PasswordAuthentication(usernameTextField.getText(), password));
+        }
+    }
+}
diff --git a/zap/src/main/java/org/zaproxy/zap/network/SocksProxy.java b/zap/src/main/java/org/zaproxy/zap/network/SocksProxy.java
new file mode 100644
index 000000000..d8f26e9c5
--- /dev/null
+++ b/zap/src/main/java/org/zaproxy/zap/network/SocksProxy.java
@@ -0,0 +1,220 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import java.util.Objects;
+import org.apache.log4j.Logger;
+
+/**
+ * A SOCKS proxy.
+ *
+ * <p>Contains the host, port, version, and if names should be resolved by the proxy.
+ *
+ * @since TODO add version
+ */
+public class SocksProxy {
+
+    private static final Logger logger = Logger.getLogger(SocksProxy.class);
+
+    /** The version of the SOCKS proxy. */
+    public enum Version {
+        /** Version 4. */
+        SOCKS4a(4),
+        /**
+         * Version 5.
+         *
+         * <p>Can resolve names and require authentication.
+         */
+        SOCKS5(5);
+
+        private final int number;
+
+        Version(int number) {
+            this.number = number;
+        }
+
+        /**
+         * Gets the number of the version.
+         *
+         * @return the number of the version.
+         */
+        public int number() {
+            return number;
+        }
+
+        /**
+         * Gets a {@code Version} from the given value (version number).
+         *
+         * <p>Defaults to {@link #SOCKS5} when the {@code value} is:
+         *
+         * <ul>
+         *   <li>null
+         *   <li>empty
+         *   <li>not a number
+         *   <li>unknown version
+         * </ul>
+         *
+         * @param value the value to convert
+         * @return the version.
+         */
+        public static Version from(String value) {
+            if (value == null || value.isEmpty()) {
+                return SOCKS5;
+            }
+            int number;
+            try {
+                number = Integer.parseInt(value);
+            } catch (NumberFormatException e) {
+                logger.warn("Failed to parse the version: " + value, e);
+                return SOCKS5;
+            }
+
+            if (number == SOCKS4a.number) {
+                return SOCKS4a;
+            }
+            if (number == SOCKS5.number) {
+                return SOCKS5;
+            }
+
+            logger.warn("Unknown version: " + value);
+            return SOCKS5;
+        }
+    }
+
+    private final String host;
+    private final int port;
+    private final Version version;
+    private final boolean useDns;
+
+    /**
+     * Constructs a {@code SocksProxy} with the given host and port.
+     *
+     * <p>Uses {@link Version#SOCKS5} and names are resolved by the proxy.
+     *
+     * @param host the host, must not be {@code null} or empty.
+     * @param port the port.
+     * @throws NullPointerException if the {@code host} is null.
+     * @throws IllegalArgumentException if the {@code host} is empty or the {@code port} is not a
+     *     valid port number.
+     */
+    public SocksProxy(String host, int port) {
+        this(host, port, Version.SOCKS5, true);
+    }
+
+    /**
+     * Constructs a {@code SocksProxy} with the given data.
+     *
+     * @param host the host, must not be {@code null} or empty.
+     * @param port the port.
+     * @param version the version, must not be {@code null}.
+     * @param useDns {@code true} if the names should be resolved by the proxy, {@code false}
+     *     otherwise.
+     * @throws NullPointerException if the {@code host} or {@code version} is {@code null}.
+     * @throws IllegalArgumentException if the {@code host} is empty or the {@code port} is not a
+     *     valid port number.
+     */
+    public SocksProxy(String host, int port, Version version, boolean useDns) {
+        Objects.requireNonNull(host, "The host must not be null.");
+        Objects.requireNonNull(version, "The version must not be null.");
+        if (host.isEmpty()) {
+            throw new IllegalArgumentException("The host must not be empty.");
+        }
+        if (port <= 0 || port > 65535) {
+            throw new IllegalArgumentException(
+                    "The port is not valid, must be between 0 and 65535.");
+        }
+        this.host = host;
+        this.port = port;
+        this.version = version;
+        this.useDns = useDns;
+    }
+
+    /**
+     * Gets the host (name or address).
+     *
+     * @return the host, never {@code null} or empty.
+     */
+    public String getHost() {
+        return host;
+    }
+
+    /**
+     * Gets the port.
+     *
+     * @return the port.
+     */
+    public int getPort() {
+        return port;
+    }
+
+    /**
+     * Gets the version.
+     *
+     * @return the version, never {@code null}.
+     */
+    public Version getVersion() {
+        return version;
+    }
+
+    /**
+     * Tells whether or not the names should be resolved by the proxy.
+     *
+     * <p>Only supported by {@link Version#SOCKS5}.
+     *
+     * @return {@code true} if the names should be resolved by the proxy, {@code false} otherwise.
+     */
+    public boolean isUseDns() {
+        return useDns;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(host, port, useDns, version.number);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        SocksProxy other = (SocksProxy) obj;
+        return Objects.equals(host, other.host)
+                && port == other.port
+                && useDns == other.useDns
+                && version == other.version;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder strBuilder = new StringBuilder(75);
+        strBuilder.append("[Host=").append(host);
+        strBuilder.append(", Port=").append(port);
+        strBuilder.append(", Version=").append(version.number);
+        strBuilder.append(", UseDns=").append(useDns);
+        strBuilder.append(']');
+        return strBuilder.toString();
+    }
+}
diff --git a/zap/src/main/java/org/zaproxy/zap/network/ZapAuthenticator.java b/zap/src/main/java/org/zaproxy/zap/network/ZapAuthenticator.java
new file mode 100644
index 000000000..4b9541661
--- /dev/null
+++ b/zap/src/main/java/org/zaproxy/zap/network/ZapAuthenticator.java
@@ -0,0 +1,132 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import java.net.Authenticator;
+import java.net.PasswordAuthentication;
+import org.apache.log4j.Logger;
+import org.parosproxy.paros.model.Model;
+import org.parosproxy.paros.network.ConnectionParam;
+
+/**
+ * ZAP's {@link Authenticator}.
+ *
+ * <p>Authenticates to HTTP and SOCKS proxies.
+ *
+ * @since TODO add version
+ */
+public class ZapAuthenticator extends Authenticator {
+
+    private static final ZapAuthenticator SINGLETON = new ZapAuthenticator();
+
+    private static final Logger logger = Logger.getLogger(ZapAuthenticator.class);
+
+    private static ConnectionParam connectionOptions;
+
+    private ZapAuthenticator() {}
+
+    /**
+     * Gets the singleton.
+     *
+     * @return the ZAP's {@code Authenticator}.
+     */
+    public static ZapAuthenticator getSingleton() {
+        return SINGLETON;
+    }
+
+    @Override
+    protected PasswordAuthentication getPasswordAuthentication() {
+        PasswordAuthentication passwordAuthentication = getPasswordAuthenticationImpl();
+        if (logger.isDebugEnabled()) {
+            StringBuilder strBuilder = new StringBuilder();
+            strBuilder.append("Getting password authentication for:").append('\n');
+            strBuilder.append("Host      = ").append(getRequestingHost()).append('\n');
+            strBuilder.append("Site      = ").append(getRequestingSite()).append('\n');
+            strBuilder.append("Port      = ").append(getRequestingPort()).append('\n');
+            strBuilder.append("Protocol  = ").append(getRequestingProtocol()).append('\n');
+            strBuilder.append("Prompt    = ").append(getRequestingPrompt()).append('\n');
+            strBuilder.append("Scheme    = ").append(getRequestingScheme()).append('\n');
+            strBuilder.append("URL       = ").append(getRequestingURL()).append('\n');
+            strBuilder.append("Auth Type = ").append(getRequestorType()).append('\n');
+            strBuilder.append("Result: ");
+            if (passwordAuthentication == null) {
+                strBuilder.append(passwordAuthentication);
+            } else {
+                strBuilder.append("[Username: ").append(passwordAuthentication.getUserName());
+                strBuilder.append(", Password: *****]");
+            }
+            logger.debug(strBuilder.toString());
+        }
+        return passwordAuthentication;
+    }
+
+    private PasswordAuthentication getPasswordAuthenticationImpl() {
+        if (isForSocksProxy()) {
+            return getConnectionOptions().getSocksProxyPasswordAuth();
+        }
+
+        if (isForHttpProxy()) {
+            return new PasswordAuthentication(
+                    getConnectionOptions().getProxyChainUserName(),
+                    getConnectionOptions().getProxyChainPassword().toCharArray());
+        }
+
+        return null;
+    }
+
+    /**
+     * Tells whether or not the password authentication is being requested for the SOCKS proxy.
+     *
+     * @return {@code true} if the request is for the SOCKS proxy, {@code false} otherwise.
+     */
+    private boolean isForSocksProxy() {
+        if (!getConnectionOptions().isUseSocksProxy()) {
+            return false;
+        }
+
+        SocksProxy socksProxy = getConnectionOptions().getSocksProxy();
+        return socksProxy.getVersion() == SocksProxy.Version.SOCKS5
+                && getRequestorType() == RequestorType.SERVER
+                && SocksProxy.Version.SOCKS5.name().equals(getRequestingProtocol())
+                && socksProxy.getPort() == getRequestingPort()
+                && socksProxy.getHost().equals(getRequestingHost());
+    }
+
+    /**
+     * Tells whether or not the password authentication is being requested for the outgoing HTTP
+     * proxy.
+     *
+     * @return {@code true} if the request is for the outgoing HTTP proxy, {@code false} otherwise.
+     */
+    private boolean isForHttpProxy() {
+        return getRequestorType() == RequestorType.PROXY
+                && getRequestingURL() != null
+                && getConnectionOptions().isUseProxy(getRequestingURL().getHost())
+                && getConnectionOptions().getProxyChainPort() == getRequestingPort()
+                && getConnectionOptions().getProxyChainName().equals(getRequestingHost());
+    }
+
+    private static ConnectionParam getConnectionOptions() {
+        if (connectionOptions == null) {
+            connectionOptions = Model.getSingleton().getOptionsParam().getConnectionParam();
+        }
+        return connectionOptions;
+    }
+}
diff --git a/zap/src/main/java/org/zaproxy/zap/network/ZapProxySelector.java b/zap/src/main/java/org/zaproxy/zap/network/ZapProxySelector.java
new file mode 100644
index 000000000..906807e51
--- /dev/null
+++ b/zap/src/main/java/org/zaproxy/zap/network/ZapProxySelector.java
@@ -0,0 +1,80 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.List;
+import org.apache.log4j.Logger;
+
+/**
+ * ZAP's {@link ProxySelector}.
+ *
+ * @since TODO add version
+ */
+public class ZapProxySelector extends ProxySelector {
+
+    private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
+
+    private static final ZapProxySelector SINGLETON = new ZapProxySelector();
+
+    private static final Logger logger = Logger.getLogger(ZapProxySelector.class);
+
+    private ZapProxySelector() {}
+
+    /**
+     * Gets the singleton.
+     *
+     * @return the ZAP's {@code ProxySelector}.
+     */
+    public static ZapProxySelector getSingleton() {
+        return SINGLETON;
+    }
+
+    /**
+     * The default {@link ProxySelector}, provided by the JRE.
+     *
+     * @return the default {@code ProxySelector}.
+     */
+    public static ProxySelector getDefaultProxySelector() {
+        return DEFAULT_PROXY_SELECTOR;
+    }
+
+    @Override
+    public List<Proxy> select(URI uri) {
+        List<Proxy> proxies = getDefaultProxySelector().select(uri);
+        if (logger.isDebugEnabled()) {
+            logger.debug("Selected proxies for " + uri + " " + proxies);
+        }
+        return proxies;
+    }
+
+    @Override
+    public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+        if (logger.isDebugEnabled()) {
+            logger.debug("Connect failed for " + uri + " " + sa, ioe);
+        }
+
+        getDefaultProxySelector().connectFailed(uri, sa, ioe);
+    }
+}
diff --git a/zap/src/main/resources/org/zaproxy/zap/resources/Messages.properties b/zap/src/main/resources/org/zaproxy/zap/resources/Messages.properties
index 5d9e2ffb2..9de981c8d 100644
--- a/zap/src/main/resources/org/zaproxy/zap/resources/Messages.properties
+++ b/zap/src/main/resources/org/zaproxy/zap/resources/Messages.properties
@@ -1209,6 +1209,16 @@ conn.options.proxy.excluded.domain.dialog.remove.button.cancel = Cancel
 conn.options.proxy.excluded.domain.dialog.remove.button.confirm = Remove
 conn.options.proxy.excluded.domain.dialog.remove.checkbox.label = Do not show this message again
 conn.options.proxy.useProxyChain = Use Proxy Chain
+conn.options.socks.title = SOCKS Proxy
+conn.options.socks.enabled = Enabled
+conn.options.socks.host = Host:
+conn.options.socks.host.empty = The SOCKS host is empty.
+conn.options.socks.port = Port:
+conn.options.socks.version = Version:
+conn.options.socks.dns = Use SOCKS' DNS
+conn.options.socks.dns.tooltip = Only supported with version 5.
+conn.options.socks.username = User Name:
+conn.options.socks.password = Password:
 conn.options.singleCookieRequestHeader = Single Cookie Request Header
 conn.options.httpStateEnabled = Enable (Global) HTTP State
 conn.options.timeout             = Timeout (in seconds):
@@ -1430,6 +1440,8 @@ core.api.action.setOptionUseProxyChain = Sets whether or not the outgoing proxy
 core.api.action.setOptionUseProxyChain.param.Boolean = 
 core.api.action.setOptionUseProxyChainAuth = 
 core.api.action.setOptionUseProxyChainAuth.param.Boolean = 
+core.api.action.setOptionUseSocksProxy = Sets whether or not the SOCKS proxy should be used.
+core.api.action.setOptionUseSocksProxy.param.Boolean = true if the SOCKS proxy should be used, false otherwise.
 core.api.desc = 
 core.api.other.messagesHar = Gets the HTTP messages sent through/by ZAP, in HAR format, optionally filtered by URL and paginated with 'start' position and 'count' of messages
 core.api.other.messagesHar.param.baseurl = 
@@ -1500,6 +1512,7 @@ core.api.view.optionSingleCookieRequestHeader =
 core.api.view.optionTimeoutInSecs = Gets the connection time out, in seconds.
 core.api.view.optionUseProxyChain = 
 core.api.view.optionUseProxyChainAuth = 
+core.api.view.optionUseSocksProxy = Gets whether or not the SOCKS proxy should be used.
 core.api.view.proxyChainExcludedDomains = Gets all the domains that are excluded from the outgoing proxy. For each domain the following are shown: the index, the value (domain), if enabled, and if specified as a regex.
 core.api.view.version = Gets ZAP version
 core.api.view.excludedFromProxy = Gets the regular expressions, applied to URLs, to exclude from the local proxies.
diff --git a/zap/src/test/java/org/zaproxy/zap/network/SocksProxyUnitTest.java b/zap/src/test/java/org/zaproxy/zap/network/SocksProxyUnitTest.java
new file mode 100644
index 000000000..6da226658
--- /dev/null
+++ b/zap/src/test/java/org/zaproxy/zap/network/SocksProxyUnitTest.java
@@ -0,0 +1,275 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.is;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.stream.Stream;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+import org.junit.jupiter.params.provider.NullAndEmptySource;
+import org.junit.jupiter.params.provider.ValueSource;
+import org.zaproxy.zap.network.SocksProxy.Version;
+
+/** Unit test for {@link SocksProxy}. */
+public class SocksProxyUnitTest {
+
+    private static final String HOST = "localhost";
+    private static final int PORT = 1080;
+
+    @Test
+    public void shouldNotCreateSocksProxyWithNullHost() {
+        // Given
+        String host = null;
+        // When / Then
+        assertThrows(NullPointerException.class, () -> new SocksProxy(host, PORT));
+        // When / Then
+        assertThrows(
+                NullPointerException.class, () -> new SocksProxy(host, PORT, Version.SOCKS5, true));
+    }
+
+    @Test
+    public void shouldNotCreateSocksProxyWithEmptyHost() {
+        // Given
+        String host = "";
+        // When / Then
+        assertThrows(IllegalArgumentException.class, () -> new SocksProxy(host, PORT));
+        // When / Then
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> new SocksProxy(host, PORT, Version.SOCKS5, true));
+    }
+
+    @ParameterizedTest
+    @ValueSource(ints = {0, -1, 65546})
+    public void shouldNotCreateSocksProxyWithInvalidPort(int port) {
+        // Given port
+        // When / Then
+        assertThrows(IllegalArgumentException.class, () -> new SocksProxy(HOST, port));
+        // When / Then
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> new SocksProxy(HOST, port, Version.SOCKS5, true));
+    }
+
+    @Test
+    public void shouldNotCreateSocksProxyWithNullVersion() {
+        // Given
+        Version version = null;
+        // When / Then
+        assertThrows(NullPointerException.class, () -> new SocksProxy(HOST, PORT, version, true));
+    }
+
+    @Test
+    public void shouldCreateSocksProxy() {
+        // Given
+        String host = "127.0.1.1";
+        int port = 1234;
+        // When
+        SocksProxy socksProxy = new SocksProxy(host, port);
+        // Then
+        assertThat(socksProxy.getHost(), is(equalTo(host)));
+        assertThat(socksProxy.getPort(), is(equalTo(port)));
+        assertThat(socksProxy.getVersion(), is(equalTo(Version.SOCKS5)));
+        assertThat(socksProxy.isUseDns(), is(equalTo(true)));
+
+        // Given
+        Version version = Version.SOCKS4a;
+        boolean useDns = false;
+        // When
+        socksProxy = new SocksProxy(host, port, version, useDns);
+        // Then
+        assertThat(socksProxy.getHost(), is(equalTo(host)));
+        assertThat(socksProxy.getPort(), is(equalTo(port)));
+        assertThat(socksProxy.getVersion(), is(equalTo(version)));
+        assertThat(socksProxy.isUseDns(), is(equalTo(useDns)));
+    }
+
+    @ParameterizedTest
+    @MethodSource
+    public void shouldProduceConsistentHashCodes(SocksProxy instance, int hashCode) {
+        // Given instance, hashCode
+        // When / Then
+        assertThat(instance.hashCode(), is(equalTo(hashCode)));
+    }
+
+    static Stream<Arguments> shouldProduceConsistentHashCodes() {
+        return Stream.of(
+                arguments(new SocksProxy(HOST, PORT), -1995911588),
+                arguments(new SocksProxy(HOST, PORT, Version.SOCKS4a, true), -1995911589),
+                arguments(new SocksProxy("127.0.0.1", 9150, Version.SOCKS5, false), -26093838));
+    }
+
+    @Test
+    public void shouldBeEqualToItself() {
+        // Given
+        SocksProxy socksProxy = new SocksProxy(HOST, PORT);
+        // When
+        boolean equals = socksProxy.equals(socksProxy);
+        // Then
+        assertThat(equals, is(equalTo(true)));
+    }
+
+    @Test
+    public void shouldBeEqualToDifferentSocksProxyWithSameContents() {
+        // Given
+        SocksProxy socksProxy = new SocksProxy(HOST, PORT, Version.SOCKS4a, false);
+        SocksProxy otherEqualSocksProxy = new SocksProxy(HOST, PORT, Version.SOCKS4a, false);
+        // When
+        boolean equals = socksProxy.equals(otherEqualSocksProxy);
+        // Then
+        assertThat(equals, is(equalTo(true)));
+    }
+
+    @Test
+    public void shouldNotBeEqualToNull() {
+        // Given
+        SocksProxy socksProxy = new SocksProxy(HOST, PORT, Version.SOCKS4a, false);
+        // When
+        boolean equals = socksProxy.equals(null);
+        // Then
+        assertThat(equals, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotBeEqualToSocksProxyWithJustDifferentHost() {
+        // Given
+        SocksProxy socksProxy = new SocksProxy(HOST, PORT);
+        SocksProxy otherSocksProxy = new SocksProxy("example.com", PORT);
+        // When
+        boolean equals = socksProxy.equals(otherSocksProxy);
+        // Then
+        assertThat(equals, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotBeEqualToSocksProxyWithJustDifferentPort() {
+        // Given
+        SocksProxy socksProxy = new SocksProxy(HOST, PORT);
+        SocksProxy otherSocksProxy = new SocksProxy(HOST, 1234);
+        // When
+        boolean equals = socksProxy.equals(otherSocksProxy);
+        // Then
+        assertThat(equals, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotBeEqualToSocksProxyWithJustDifferentVersion() {
+        // Given
+        SocksProxy socksProxy = new SocksProxy(HOST, PORT, Version.SOCKS4a, false);
+        SocksProxy otherSocksProxy = new SocksProxy(HOST, PORT, Version.SOCKS5, false);
+        // When
+        boolean equals = socksProxy.equals(otherSocksProxy);
+        // Then
+        assertThat(equals, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotBeEqualToSocksProxyWithJustDifferentUseDns() {
+        // Given
+        SocksProxy socksProxy = new SocksProxy(HOST, PORT, Version.SOCKS4a, false);
+        SocksProxy otherSocksProxy = new SocksProxy(HOST, PORT, Version.SOCKS4a, true);
+        // When
+        boolean equals = socksProxy.equals(otherSocksProxy);
+        // Then
+        assertThat(equals, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotBeEqualToExtendedSocksProxy() {
+        // Given
+        SocksProxy socksProxy = new SocksProxy(HOST, PORT);
+        SocksProxy otherSocksProxy = new SocksProxy(HOST, PORT) {
+                    // Anonymous SocksProxy
+                };
+        // When
+        boolean equals = socksProxy.equals(otherSocksProxy);
+        // Then
+        assertThat(equals, is(equalTo(false)));
+    }
+
+    @ParameterizedTest
+    @MethodSource
+    public void shouldProduceConsistentStringRepresentations(
+            SocksProxy socksProxy, String representation) {
+        // Given socksProxy, representation
+        // When / Then
+        assertThat(socksProxy.toString(), is(equalTo(representation)));
+    }
+
+    static Stream<Arguments> shouldProduceConsistentStringRepresentations() {
+        return Stream.of(
+                arguments(
+                        new SocksProxy("127.0.0.1", 1234),
+                        "[Host=127.0.0.1, Port=1234, Version=5, UseDns=true]"),
+                arguments(
+                        new SocksProxy("localhost", 1080, Version.SOCKS4a, false),
+                        "[Host=localhost, Port=1080, Version=4, UseDns=false]"));
+    }
+
+    @Test
+    public void shouldGetSocks4From4() {
+        // Given
+        String value = "4";
+        // When
+        Version version = Version.from(value);
+        // Then
+        assertThat(version, is(equalTo(Version.SOCKS4a)));
+    }
+
+    @Test
+    public void shouldGetSocks5From5() {
+        // Given
+        String value = "5";
+        // When
+        Version version = Version.from(value);
+        // Then
+        assertThat(version, is(equalTo(Version.SOCKS5)));
+    }
+
+    @ParameterizedTest
+    @NullAndEmptySource
+    @ValueSource(strings = {"3", "NotAVersion"})
+    public void shouldGetSocks5FromInvalidValues(String value) {
+        // Given value
+        // When
+        Version version = Version.from(value);
+        // Then
+        assertThat(version, is(equalTo(Version.SOCKS5)));
+    }
+
+    @ParameterizedTest
+    @MethodSource
+    public void shouldGetExpectedVersionNumberFromVersion(Version version, int number) {
+        // Given version, number
+        // When / Then
+        assertThat(version.number(), is(equalTo(number)));
+    }
+
+    static Stream<Arguments> shouldGetExpectedVersionNumberFromVersion() {
+        return Stream.of(arguments(Version.SOCKS4a, 4), arguments(Version.SOCKS5, 5));
+    }
+}
