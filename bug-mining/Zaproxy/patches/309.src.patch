diff --git a/zap/src/main/java/org/zaproxy/zap/extension/api/API.java b/zap/src/main/java/org/zaproxy/zap/extension/api/API.java
index e5efea2a6..15e8a7958 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/api/API.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/api/API.java
@@ -28,6 +28,7 @@ import java.security.SecureRandom;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -1016,9 +1017,9 @@ public class API {
             return true;
         } finally {
             synchronized (nonces) {
-                for (Entry<String, Nonce> entry : nonces.entrySet()) {
-                    if (!entry.getValue().isValid()) {
-                        nonces.remove(entry.getKey());
+                for (Iterator<Nonce> it = nonces.values().iterator(); it.hasNext(); ) {
+                    if (!it.next().isValid()) {
+                        it.remove();
                     }
                 }
             }
diff --git a/zap/src/test/java/org/zaproxy/zap/extension/api/APIUnitTest.java b/zap/src/test/java/org/zaproxy/zap/extension/api/APIUnitTest.java
index 8d40391f5..dc6eb3e71 100644
--- a/zap/src/test/java/org/zaproxy/zap/extension/api/APIUnitTest.java
+++ b/zap/src/test/java/org/zaproxy/zap/extension/api/APIUnitTest.java
@@ -25,13 +25,15 @@ import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.startsWith;
 import static org.junit.Assert.assertThat;
+import static org.mockito.Mockito.when;
 
 import java.net.Inet4Address;
-import java.net.URI;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 import net.sf.json.JSON;
 import net.sf.json.JSONObject;
+import org.apache.commons.httpclient.URI;
 import org.apache.log4j.Logger;
 import org.apache.log4j.varia.NullAppender;
 import org.junit.BeforeClass;
@@ -40,6 +42,7 @@ import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 import org.mockito.runners.MockitoJUnitRunner;
 import org.parosproxy.paros.core.proxy.ProxyParam;
+import org.parosproxy.paros.network.HttpHeader;
 import org.parosproxy.paros.network.HttpInputStream;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpOutputStream;
@@ -54,6 +57,8 @@ import org.zaproxy.zap.utils.ZapXmlConfiguration;
 @RunWith(MockitoJUnitRunner.class)
 public class APIUnitTest {
 
+    private static final String CUSTOM_API_PATH = "/custom/api/";
+
     @BeforeClass
     public static void setUp() throws Exception {
         Logger.getRootLogger().addAppender(new NullAppender());
@@ -353,6 +358,110 @@ public class APIUnitTest {
         assertThat(baseUrl, is(equalTo("https://127.0.0.1:8080/JSON/test/view/test/")));
     }
 
+    @Test
+    public void shouldGenerateOneTimeApiNonce() throws Exception {
+        // Given
+        API api = new API();
+        api.setOptionsParamApi(createOptionsParamApi());
+        // When
+        String nonce = api.getOneTimeNonce(CUSTOM_API_PATH);
+        // Then
+        assertThat(nonce, is(notNullValue()));
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH, nonce), is(equalTo(true)));
+        // Should not be valid more than once
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH, nonce), is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldConsumeButNotAcceptOneTimeApiNonceIfPathMismatch() throws Exception {
+        // Given
+        API api = new API();
+        api.setOptionsParamApi(createOptionsParamApi());
+        // When
+        String nonce = api.getOneTimeNonce(CUSTOM_API_PATH);
+        // Then
+        assertThat(nonce, is(notNullValue()));
+        assertThat(isApiNonceValid(api, "/not/same/path/", nonce), is(equalTo(false)));
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH, nonce), is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotAcceptOneTimeApiNonceIfExpired() throws Exception {
+        // Given
+        int ttlInSecs = 1;
+        OptionsParamApi optionsParamApi = Mockito.mock(OptionsParamApi.class);
+        when(optionsParamApi.getNonceTimeToLiveInSecs()).thenReturn(ttlInSecs);
+        API api = new API();
+        api.setOptionsParamApi(optionsParamApi);
+        String nonce = api.getOneTimeNonce(CUSTOM_API_PATH);
+        // When
+        Thread.sleep(TimeUnit.SECONDS.toMillis(ttlInSecs + 1));
+        // Then
+        assertThat(nonce, is(notNullValue()));
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH, nonce), is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldExpireExistingOneTimeApiNonces() throws Exception {
+        // Given
+        int ttlInSecs = 1;
+        OptionsParamApi optionsParamApi = Mockito.mock(OptionsParamApi.class);
+        when(optionsParamApi.getNonceTimeToLiveInSecs()).thenReturn(ttlInSecs);
+        API api = new API();
+        api.setOptionsParamApi(optionsParamApi);
+        String nonce1 = api.getOneTimeNonce(CUSTOM_API_PATH + "1");
+        String nonce2 = api.getOneTimeNonce(CUSTOM_API_PATH + "2");
+        String nonce3 = api.getOneTimeNonce(CUSTOM_API_PATH + "2");
+        // When
+        Thread.sleep(TimeUnit.SECONDS.toMillis(ttlInSecs + 1));
+        // Then
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH + "1", nonce1), is(equalTo(false)));
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH + "2", nonce2), is(equalTo(false)));
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH + "3", nonce3), is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldGenerateLongLivedApiNonce() {
+        // Given
+        API api = new API();
+        api.setOptionsParamApi(createOptionsParamApi());
+        // When
+        String nonce = api.getLongLivedNonce(CUSTOM_API_PATH);
+        // Then
+        assertThat(nonce, is(notNullValue()));
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH, nonce), is(equalTo(true)));
+        // Should be valid more than once
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH, nonce), is(equalTo(true)));
+    }
+
+    @Test
+    public void shouldNotExpireLongLivedApiNonce() throws Exception {
+        // Given
+        int ttlInSecs = 1;
+        OptionsParamApi optionsParamApi = Mockito.mock(OptionsParamApi.class);
+        when(optionsParamApi.getNonceTimeToLiveInSecs()).thenReturn(ttlInSecs);
+        API api = new API();
+        api.setOptionsParamApi(optionsParamApi);
+        String nonce = api.getLongLivedNonce(CUSTOM_API_PATH);
+        // When
+        Thread.sleep(TimeUnit.SECONDS.toMillis(ttlInSecs + 1));
+        // Then
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH, nonce), is(equalTo(true)));
+    }
+
+    @Test
+    public void shouldNotAcceptLongLivedApiNonceIfPathMismatch() throws Exception {
+        // Given
+        API api = new API();
+        api.setOptionsParamApi(createOptionsParamApi());
+        // When
+        String nonce = api.getLongLivedNonce(CUSTOM_API_PATH);
+        // Then
+        assertThat(nonce, is(notNullValue()));
+        assertThat(isApiNonceValid(api, "/not/same/path/", nonce), is(equalTo(false)));
+        assertThat(isApiNonceValid(api, CUSTOM_API_PATH, nonce), is(equalTo(true)));
+    }
+
     @Test(expected = ApiException.class)
     public void shouldFailToGetXmlFromResponseWithNullEndpointName() throws ApiException {
         // Given
@@ -450,7 +559,7 @@ public class APIUnitTest {
     private static void assertApiNonceMatch(API api, String baseUrl) {
         try {
             // Given
-            URI uri = new URI(baseUrl);
+            URI uri = new URI(baseUrl, true);
             String hostHeader = uri.getHost() + (uri.getPort() != -1 ? ":" + uri.getPort() : "");
             TestApiImplementor apiImplementor = new TestApiImplementor();
             api.registerApiImplementor(apiImplementor);
@@ -469,6 +578,21 @@ public class APIUnitTest {
         }
     }
 
+    private static boolean isApiNonceValid(API api, String requestPath, String nonce) {
+        try {
+            URI requestUri = Mockito.mock(URI.class);
+            when(requestUri.getPath()).thenReturn(requestPath);
+            HttpRequestHeader request = Mockito.mock(HttpRequestHeader.class);
+            when(request.getURI()).thenReturn(requestUri);
+            when(request.getHeader(HttpHeader.X_ZAP_API_NONCE)).thenReturn(nonce);
+            when(request.getSenderAddress())
+                    .thenReturn(Inet4Address.getByAddress(new byte[] {127, 0, 0, 1}));
+            return api.hasValidKey(request, new JSONObject());
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
     private static List<DomainMatcher> createPermittedAddresses(String... addresses) {
         if (addresses == null || addresses.length == 0) {
             return new ArrayList<>();
