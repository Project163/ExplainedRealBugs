diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index 87eb84f15..8e37d8c54 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -970,7 +970,14 @@ dynssl.button.later              = Later
 dynssl.desc                      = Creates a dynamic SSL certificate to allow SSL communications to be intercepted without warnings being generated by the browser
 dynssl.filter.file				 = config.xml or *.pem files 
 dynssl.label.rootca              = Root CA certificate
-dynssl.message1.filecouldnloaded = Failed to import ZAP Root CA certificate from the file.\nPlease see log file for details.
+dynssl.importpem.failedreadfile = Failed to read the selected .pem file:\n{0}
+dynssl.importpem.nocertsection = No certificate section found in the .pem file.\nIt should contain the certificate surrounded with the tokens:\n{0}\nand:\n{1}
+dynssl.importpem.certnobase64 = The certificate is not properly base64 encoded.
+dynssl.importpem.noprivkeysection = No private key section found in the .pem file.\nIt should contain the private key surrounded with the tokens:\n{0}\nand:\n{1}
+dynssl.importpem.privkeynobase64 = The private key is not properly base64 encoded.
+dynssl.importpem.failedkeystore = Failed to create the KeyStore from the .pem file:\n{0}
+dynssl.importpem.failed.title = Error Import Root CA Cert .pem File
+dynssl.message1.filecouldntloaded = Failed to import Root CA certificate from the config file.\nPlease see log file for details.
 dynssl.message1.title            = Import Error
 dynssl.message2.caalreadyexists  = A Root CA certificate already exists.
 dynssl.message2.title            = Overwrite Existing Certificate?
diff --git a/src/org/zaproxy/zap/extension/dynssl/DynamicSSLPanel.java b/src/org/zaproxy/zap/extension/dynssl/DynamicSSLPanel.java
index f346db505..b71c2c428 100644
--- a/src/org/zaproxy/zap/extension/dynssl/DynamicSSLPanel.java
+++ b/src/org/zaproxy/zap/extension/dynssl/DynamicSSLPanel.java
@@ -28,6 +28,8 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.StringWriter;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Path;
 import java.security.KeyStore;
 import java.security.cert.Certificate;
 
@@ -46,6 +48,7 @@ import javax.swing.event.DocumentEvent;
 import javax.swing.event.DocumentListener;
 import javax.swing.filechooser.FileFilter;
 
+import org.apache.commons.io.FileUtils;
 import org.apache.log4j.Logger;
 import org.bouncycastle.openssl.jcajce.JcaMiscPEMGenerator;
 import org.bouncycastle.util.io.pem.PemWriter;
@@ -299,21 +302,20 @@ public class DynamicSSLPanel extends AbstractParamPanel {
 				logger.info("Loading Root CA certificate from " + f);
 			}
 			KeyStore ks = null;
-			try {
-				if (f.getName().toLowerCase().endsWith("pem")) {
-					ks = SslCertificateUtils.pem2Keystore(f);
-				} else {
+			if (f.getName().toLowerCase().endsWith("pem")) {
+				ks = convertPemFileToKeyStore(f.toPath());
+			} else {
+				try {
 					final ZapXmlConfiguration conf = new ZapXmlConfiguration(f);
 					final String rootcastr = conf.getString(DynSSLParam.PARAM_ROOT_CA);
 					ks = SslCertificateUtils.string2Keystore(rootcastr);
+				} catch (final Exception e) {
+					logger.error("Error importing Root CA cert from config file:", e);
+					JOptionPane.showMessageDialog(this,
+							Constant.messages.getString("dynssl.message1.filecouldntloaded"),
+							Constant.messages.getString("dynssl.message1.title"),
+							JOptionPane.ERROR_MESSAGE);
 				}
-			} catch (final Exception e) {
-				logger.error("Error importing foreign Root CA!", e);
-				// Constant.messages.getString("dynssl.label.rootca")
-				JOptionPane.showMessageDialog(this,
-						Constant.messages.getString("dynssl.message1.filecouldnloaded"),
-						Constant.messages.getString("dynssl.message1.title"),
-						JOptionPane.ERROR_MESSAGE);
 			}
 			if (ks != null) {
 				setRootca(ks);
@@ -322,6 +324,87 @@ public class DynamicSSLPanel extends AbstractParamPanel {
 		}
 	}
 
+	/**
+	 * Converts the given {@code .pem} file into a {@link KeyStore}.
+	 *
+	 * @param pemFile the {@code .pem} file that contains the certificate and the private key.
+	 * @return the {@code KeyStore} with the certificate, or {@code null} if the conversion failed.
+	 */
+	private KeyStore convertPemFileToKeyStore(Path pemFile) {
+		String pem;
+		try {
+			pem = FileUtils.readFileToString(pemFile.toFile(), StandardCharsets.US_ASCII);
+		} catch (IOException e) {
+			logger.warn("Failed to read .pem file:", e);
+			JOptionPane.showMessageDialog(
+					this,
+					Constant.messages.getString("dynssl.importpem.failedreadfile", e.getLocalizedMessage()),
+					Constant.messages.getString("dynssl.importpem.failed.title"),
+					JOptionPane.ERROR_MESSAGE);
+			return null;
+		}
+
+		byte[] cert;
+		try {
+			cert = SslCertificateUtils.extractCertificate(pem);
+			if (cert.length == 0) {
+				JOptionPane.showMessageDialog(
+						this,
+						Constant.messages.getString(
+								"dynssl.importpem.nocertsection",
+								SslCertificateUtils.BEGIN_CERTIFICATE_TOKEN,
+								SslCertificateUtils.END_CERTIFICATE_TOKEN),
+						Constant.messages.getString("dynssl.importpem.failed.title"),
+						JOptionPane.ERROR_MESSAGE);
+				return null;
+			}
+		} catch (IllegalArgumentException e) {
+			logger.warn("Failed to base64 decode the certificate from .pem file:", e);
+			JOptionPane.showMessageDialog(
+					this,
+					Constant.messages.getString("dynssl.importpem.certnobase64"),
+					Constant.messages.getString("dynssl.importpem.failed.title"),
+					JOptionPane.ERROR_MESSAGE);
+			return null;
+		}
+
+		byte[] key;
+		try {
+			key = SslCertificateUtils.extractPrivateKey(pem);
+			if (key.length == 0) {
+				JOptionPane.showMessageDialog(
+						this,
+						Constant.messages.getString(
+								"dynssl.importpem.noprivkeysection",
+								SslCertificateUtils.BEGIN_PRIVATE_KEY_TOKEN,
+								SslCertificateUtils.END_PRIVATE_KEY_TOKEN),
+						Constant.messages.getString("dynssl.importpem.failed.title"),
+						JOptionPane.ERROR_MESSAGE);
+				return null;
+			}
+		} catch (IllegalArgumentException e) {
+			logger.warn("Failed to base64 decode the private key from .pem file:", e);
+			JOptionPane.showMessageDialog(
+					this,
+					Constant.messages.getString("dynssl.importpem.privkeynobase64"),
+					Constant.messages.getString("dynssl.importpem.failed.title"),
+					JOptionPane.ERROR_MESSAGE);
+			return null;
+		}
+
+		try {
+			return SslCertificateUtils.pem2KeyStore(cert, key);
+		} catch (Exception e) {
+			logger.error("Error creating KeyStore for Root CA cert from .pem file:", e);
+			JOptionPane.showMessageDialog(
+					this,
+					Constant.messages.getString("dynssl.importpem.failedkeystore", e.getLocalizedMessage()),
+					Constant.messages.getString("dynssl.importpem.failed.title"),
+					JOptionPane.ERROR_MESSAGE);
+			return null;
+		}
+	}
+
 	/**
 	 * Saving Root CA certificate to disk.
 	 */
diff --git a/src/org/zaproxy/zap/extension/dynssl/SslCertificateUtils.java b/src/org/zaproxy/zap/extension/dynssl/SslCertificateUtils.java
index bc1611405..0b4438547 100644
--- a/src/org/zaproxy/zap/extension/dynssl/SslCertificateUtils.java
+++ b/src/org/zaproxy/zap/extension/dynssl/SslCertificateUtils.java
@@ -24,6 +24,7 @@ import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.math.BigInteger;
+import java.nio.charset.StandardCharsets;
 import java.security.KeyFactory;
 import java.security.KeyPair;
 import java.security.KeyPairGenerator;
@@ -70,6 +71,34 @@ import org.parosproxy.paros.security.SslCertificateService;
  */
 public class SslCertificateUtils {
 
+	/**
+	 * The token that indicates the start of the section that contains the certificate, contained in a {@code .pem} file.
+	 * 
+	 * @since TODO add version
+	 */
+	public static final String BEGIN_CERTIFICATE_TOKEN = "-----BEGIN CERTIFICATE-----";
+
+	/**
+	 * The token that indicates the end of the section that contains the certificate, contained in a {@code .pem} file.
+	 * 
+	 * @since TODO add version
+	 */
+	public static final String END_CERTIFICATE_TOKEN = "-----END CERTIFICATE-----";
+
+	/**
+	 * The token that indicates the start of the section that contains the private key, contained in a {@code .pem} file.
+	 * 
+	 * @since TODO add version
+	 */
+	public static final String BEGIN_PRIVATE_KEY_TOKEN = "-----BEGIN PRIVATE KEY-----";
+
+	/**
+	 * The token that indicates the end of the section that contains the private key, contained in a {@code .pem} file.
+	 * 
+	 * @since TODO add version
+	 */
+	public static final String END_PRIVATE_KEY_TOKEN = "-----END PRIVATE KEY-----";
+
 	private static final long DEFAULT_VALID_DAYS = 365L;
 
 	/**
@@ -183,10 +212,55 @@ public class SslCertificateUtils {
 	 */
 	public static KeyStore pem2Keystore(File pemFile) throws IOException, CertificateException, 
 			InvalidKeySpecException, NoSuchAlgorithmException, KeyStoreException {
-		byte[] certAndKey = FileUtils.readFileToByteArray(pemFile);
-	    byte[] certBytes = parseDERFromPEM(certAndKey, "-----BEGIN CERTIFICATE-----", "-----END CERTIFICATE-----");
-	    byte[] keyBytes = parseDERFromPEM(certAndKey, "-----BEGIN PRIVATE KEY-----", "-----END PRIVATE KEY-----");
+		String certAndKey = FileUtils.readFileToString(pemFile, StandardCharsets.US_ASCII);
+	    byte[] certBytes = extractCertificate(certAndKey);
+	    byte[] keyBytes = extractPrivateKey(certAndKey);
+
+	    return pem2KeyStore(certBytes, keyBytes);
+	}
+
+	/**
+	 * Extracts the certificate from the given {@code .pem} file's contents.
+	 *
+	 * @param pem the contents of the {@code .pem} file.
+	 * @return the certificate, or empty array if the certificate was not found.
+	 * @since TODO add version
+	 * @throws IllegalArgumentException if the certificate data is not properly {@code base64} encoded.
+	 */
+	public static byte[] extractCertificate(String pem) {
+		return parseDERFromPEM(pem, BEGIN_CERTIFICATE_TOKEN, END_CERTIFICATE_TOKEN);
+	}
 
+	/**
+	 * Extracts the private key from the given {@code .pem} file's contents.
+	 *
+	 * @param pem the contents of the {@code .pem} file.
+	 * @return the private key, or empty array if the private key was not found.
+	 * @since TODO add version
+	 * @throws IllegalArgumentException if the private key data is not properly {@code base64} encoded.
+	 */
+	public static byte[] extractPrivateKey(String pem) {
+		return parseDERFromPEM(pem, BEGIN_PRIVATE_KEY_TOKEN, END_PRIVATE_KEY_TOKEN);
+	}
+
+	/**
+	 * Tells whether or not the given ({@code .pem} file) contents contain a section with the given begin and end tokens.
+	 *
+	 * @param contents the ({@code .pem} file) contents to check if contains the section.
+	 * @param beginToken the begin token of the section.
+	 * @param endToken the end token of the section.
+	 * @return {@code true} if the section was found, {@code false} otherwise.
+	 */
+	private static boolean containsSection(String contents, String beginToken, String endToken) {
+		int idxToken;
+		if ((idxToken = contents.indexOf(beginToken)) == -1 || contents.indexOf(endToken) < idxToken) {
+			return false;
+		}
+		return true;
+	}
+	
+	public static KeyStore pem2KeyStore(byte[] certBytes, byte[] keyBytes)
+	        throws IOException, CertificateException, InvalidKeySpecException, NoSuchAlgorithmException, KeyStoreException {
 	    X509Certificate cert = generateCertificateFromDER(certBytes);              
 	    RSAPrivateKey key  = generatePrivateKeyFromDER(keyBytes);
 	    
@@ -197,9 +271,11 @@ public class SslCertificateUtils {
 	    return keystore;
 	}
 
-	private static byte[] parseDERFromPEM(byte[] pem, String beginDelimiter, String endDelimiter) {
-	    String data = new String(pem);
-	    String[] tokens = data.split(beginDelimiter);
+	private static byte[] parseDERFromPEM(String pem, String beginDelimiter, String endDelimiter) {
+	    if (!containsSection(pem, beginDelimiter, endDelimiter)) {
+	        return new byte[0];
+	    }
+	    String[] tokens = pem.split(beginDelimiter);
 	    tokens = tokens[1].split(endDelimiter);
 	    return DatatypeConverter.parseBase64Binary(tokens[0]);        
 	}
diff --git a/test/org/zaproxy/zap/extension/dynssl/SslCertificateUtilsUnitTest.java b/test/org/zaproxy/zap/extension/dynssl/SslCertificateUtilsUnitTest.java
new file mode 100644
index 000000000..de099fb7f
--- /dev/null
+++ b/test/org/zaproxy/zap/extension/dynssl/SslCertificateUtilsUnitTest.java
@@ -0,0 +1,154 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development Team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.extension.dynssl;
+
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.notNullValue;
+import static org.junit.Assert.assertThat;
+
+import java.nio.charset.StandardCharsets;
+
+import org.junit.Test;
+import org.parosproxy.paros.extension.encoder.Base64;
+
+/**
+ * Unit test for {@link SslCertificateUtils}.
+ */
+public class SslCertificateUtilsUnitTest {
+
+    private static final String CERT_DATA = "Certificate data...";
+    private static final String CERT_DATA_BASE64 = Base64.encodeBytes(CERT_DATA.getBytes(StandardCharsets.US_ASCII));
+
+    private static final String PRIV_KEY_DATA = "Private key...";
+    private static final String PRIV_KEY_BASE64 = Base64.encodeBytes(PRIV_KEY_DATA.getBytes(StandardCharsets.US_ASCII));
+
+    @Test
+    public void shouldReturnEmptyByteArrayIfNotAbleToFindCertSectionInPemData() {
+        // Given
+        String pem = CERT_DATA_BASE64;
+        // When
+        byte[] cert = SslCertificateUtils.extractCertificate(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(0)));
+    }
+
+    @Test
+    public void shouldReturnEmptyByteArrayIfBeginCertTokenWasNotFoundInPemData() {
+        // Given
+        String pem = CERT_DATA_BASE64 + SslCertificateUtils.END_CERTIFICATE_TOKEN;
+        // When
+        byte[] cert = SslCertificateUtils.extractCertificate(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(0)));
+    }
+
+    @Test
+    public void shouldReturnEmptyByteArrayIfEndCertTokenWasNotFoundInPemData() {
+        // Given
+        String pem = SslCertificateUtils.BEGIN_CERTIFICATE_TOKEN + CERT_DATA_BASE64;
+        // When
+        byte[] cert = SslCertificateUtils.extractCertificate(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(0)));
+    }
+
+    @Test
+    public void shouldReturnEmptyByteArrayIfEndCertTokenIsBeforeBeginCertTokenInPemData() {
+        // Given
+        String pem = SslCertificateUtils.END_CERTIFICATE_TOKEN + CERT_DATA_BASE64 + SslCertificateUtils.BEGIN_CERTIFICATE_TOKEN;
+        // When
+        byte[] cert = SslCertificateUtils.extractCertificate(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(0)));
+    }
+
+    @Test
+    public void shouldReturnCertificateBetweenBeginAndEndCertTokensFromPemData() {
+        // Given
+        String pem = SslCertificateUtils.BEGIN_CERTIFICATE_TOKEN + CERT_DATA_BASE64 + SslCertificateUtils.END_CERTIFICATE_TOKEN;
+        // When
+        byte[] cert = SslCertificateUtils.extractCertificate(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(CERT_DATA.length())));
+        assertThat(cert, is(equalTo(CERT_DATA.getBytes(StandardCharsets.US_ASCII))));
+    }
+
+    @Test
+    public void shouldReturnEmptyByteArrayIfNotAbleToFindPrivKeySectionInPemData() {
+        // Given
+        String pem = PRIV_KEY_BASE64;
+        // When
+        byte[] cert = SslCertificateUtils.extractPrivateKey(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(0)));
+    }
+
+    @Test
+    public void shouldReturnEmptyByteArrayIfBeginPrivKeyTokenWasNotFoundInPemData() {
+        // Given
+        String pem = PRIV_KEY_BASE64 + SslCertificateUtils.END_PRIVATE_KEY_TOKEN;
+        // When
+        byte[] cert = SslCertificateUtils.extractPrivateKey(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(0)));
+    }
+
+    @Test
+    public void shouldReturnEmptyByteArrayIfEndPrivKeyTokenWasNotFoundInPemData() {
+        // Given
+        String pem = SslCertificateUtils.BEGIN_PRIVATE_KEY_TOKEN + PRIV_KEY_BASE64;
+        // When
+        byte[] cert = SslCertificateUtils.extractPrivateKey(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(0)));
+    }
+
+    @Test
+    public void shouldReturnEmptyByteArrayIfEndPrivKeyTokenIsBeforeBeginPrivKeyTokenInPemData() {
+        // Given
+        String pem = SslCertificateUtils.END_PRIVATE_KEY_TOKEN + PRIV_KEY_BASE64 + SslCertificateUtils.BEGIN_PRIVATE_KEY_TOKEN;
+        // When
+        byte[] cert = SslCertificateUtils.extractPrivateKey(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(0)));
+    }
+
+    @Test
+    public void shouldReturnPrivateKeyBetweenBeginAndEndPrivKeyTokensFromPemData() {
+        // Given
+        String pem = SslCertificateUtils.BEGIN_PRIVATE_KEY_TOKEN + PRIV_KEY_BASE64 + SslCertificateUtils.END_PRIVATE_KEY_TOKEN;
+        // When
+        byte[] cert = SslCertificateUtils.extractPrivateKey(pem);
+        // Then
+        assertThat(cert, is(notNullValue()));
+        assertThat(cert.length, is(equalTo(PRIV_KEY_DATA.length())));
+        assertThat(cert, is(equalTo(PRIV_KEY_DATA.getBytes(StandardCharsets.US_ASCII))));
+    }
+}
