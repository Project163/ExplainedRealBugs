diff --git a/.classpath b/.classpath
index 98e222dca..ecde6d292 100644
--- a/.classpath
+++ b/.classpath
@@ -15,7 +15,9 @@
 	<classpathentry kind="lib" path="lib/commons-io-2.4.jar"/>
 	<classpathentry kind="lib" path="lib/commons-jxpath-1.3.jar"/>
 	<classpathentry kind="lib" path="lib/commons-lang-2.6.jar"/>
+	<classpathentry kind="lib" path="lib/commons-lang3-3.7.jar"/>
 	<classpathentry kind="lib" path="lib/commons-logging-api-1.1.1.jar"/>
+	<classpathentry kind="lib" path="lib/commons-text-1.3.jar"/>
 	<classpathentry kind="lib" path="lib/diffutils-1.2.1.jar"/>
 	<classpathentry kind="lib" path="lib/ezmorph-1.0.6.jar"/>
 	<classpathentry kind="lib" path="lib/harlib-jackson-1.1.2.jar"/>
diff --git a/LEGALNOTICE.md b/LEGALNOTICE.md
index df91c3de3..687088661 100644
--- a/LEGALNOTICE.md
+++ b/LEGALNOTICE.md
@@ -5,7 +5,7 @@ OWASP Zed Attack Proxy (ZAP)
 
 The software package is:
 
-    Copyright © 2010-2016 ZAP Development Team
+    Copyright © 2010-2018 ZAP Development Team
 
 Individual contributions, components, and libraries are copyright of their
 respective authors.
@@ -46,8 +46,10 @@ and subject to their respective licenses.
 | commons-io-2.4.jar            | Apache 2.0                |
 | commons-jxpath-1.3.jar        | Apache 2.0                |
 | commons-lang-2.6.jar          | Apache 2.0                |
+| commons-lang3-3.7.jar         | Apache 2.0                |
 | commons-logging-1.2.jar       | Apache 2.0                |
 | commons-logging-api-1.1.1.jar | Apache 2.0                |
+| commons-text-1.3.jar          | Apache 2.0                |
 | diffutils-1.2.1.jar           | Apache 2.0                |
 | ezmorph-1.0.6.jar             | Apache 2.0                |
 | harlib-jackson-1.1.2.jar      | Apache 2.0                |
diff --git a/lib/commons-lang3-3.7.jar b/lib/commons-lang3-3.7.jar
new file mode 100644
index 000000000..f37ded60f
Binary files /dev/null and b/lib/commons-lang3-3.7.jar differ
diff --git a/lib/commons-text-1.3.jar b/lib/commons-text-1.3.jar
new file mode 100644
index 000000000..0ec9e4814
Binary files /dev/null and b/lib/commons-text-1.3.jar differ
diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index cf216540c..61e733cc3 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -466,18 +466,22 @@ authentication.method.manual.dialog.error.nosession.text 	= No HTTP Session has
 authentication.method.manual.dialog.error.title 			= Configuration Error
 authentication.method.manual.field.description				= <html><p><small>* If the HTTP sessions that you are interested in are not present in the selection box, <br/>make sure you have included the <i>Site</i> to which the HTTP sessions correspond<br/> in the proper <b>Context</b>.</small></p><html>
 authentication.method.fb.name								= Form-based Authentication
-authentication.method.fb.field.label.postData				= Login Request POST Data (if any):
-authentication.method.fb.field.label.loginUrl				= Login Form Target URL *:
-authentication.method.fb.field.label.usernameParam			= Username Parameter *:
-authentication.method.fb.field.label.passwordParam			= Password Parameter *:
-authentication.method.fb.field.label.description			= <html><small>The <i>username</i> and <i>password</i> fields will be replaced, during authentication, with the username and password corresponding to application's users.</small><html>
+authentication.method.fb.popup.login.request = {0} : Form-based Auth Login Request
+authentication.method.jb.name = JSON-based Authentication
+authentication.method.jb.popup.login.request = {0} : JSON-based Auth Login Request
+authentication.method.pb.field.label.postData				= Login Request POST Data (if any):
+authentication.method.pb.field.label.postDataRequired = Login Request POST Data *:
+authentication.method.pb.field.label.loginUrl				= Login Form Target URL *:
+authentication.method.pb.field.label.usernameParam			= Username Parameter *:
+authentication.method.pb.field.label.passwordParam			= Password Parameter *:
+authentication.method.pb.field.label.description			= <html><small>The <i>username</i> and <i>password</i> fields will be replaced, during authentication, with the username and password corresponding to application's users.</small><html>
+authentication.method.pb.dialog.error.url.text = The login url you have inserted is not a valid URL.
+authentication.method.pb.dialog.error.postData.text = The POST Data is required.
 authentication.method.fb.credentials.field.label.user		= Username:
 authentication.method.fb.credentials.field.label.pass		= Password:
 authentication.method.fb.dialog.error.nofields.text 		= The username and password form field names have to be configured for this authentication method.
-authentication.method.fb.dialog.error.url.text 				= The login url you have inserted is not a valid URL.
 authentication.method.fb.credentials.dialog.error.user.text	= The username for the current user has to be configured.
 authentication.method.fb.dialog.error.title 				= Configuration Error
-authentication.method.fb.popup.login.request 				= {0} : Form-based Auth Login Request
 authentication.method.http.name								= HTTP/NTLM Authentication
 authentication.method.http.field.label.hostname				= Hostname:
 authentication.method.http.field.label.port					= Port:
diff --git a/src/org/parosproxy/paros/network/HttpHeader.java b/src/org/parosproxy/paros/network/HttpHeader.java
index 6a74bdc7d..eacef13eb 100644
--- a/src/org/parosproxy/paros/network/HttpHeader.java
+++ b/src/org/parosproxy/paros/network/HttpHeader.java
@@ -37,6 +37,7 @@
 // ZAP: 2017/02/08 Change isEmpty to check start line instead of headers (if it has the status/request line it's not empty).
 // ZAP: 2017/03/02 Issue 3226: Added API Key and Nonce headers
 // ZAP: 2018/02/06 Make the lower/upper case changes locale independent (Issue 4327).
+// ZAP: 2018/04/24 Add JSON Content-Type.
 
 package org.parosproxy.paros.network;
 
@@ -88,6 +89,7 @@ public abstract class HttpHeader implements java.io.Serializable {
     public static final String _KEEP_ALIVE = "Keep-Alive";
     public static final String _CHUNKED = "Chunked";
     public static final String FORM_URLENCODED_CONTENT_TYPE = "application/x-www-form-urlencoded";
+    public static final String JSON_CONTENT_TYPE = "application/json";
     public static final String SCHEME_HTTP = "http://";
     public static final String SCHEME_HTTPS = "https://";
     public static final String HTTP = "http";
diff --git a/src/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodType.java b/src/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodType.java
index d2fd00212..fdf5f065d 100644
--- a/src/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodType.java
+++ b/src/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodType.java
@@ -19,83 +19,26 @@
  */
 package org.zaproxy.zap.authentication;
 
-import java.awt.Component;
-import java.awt.GridBagLayout;
-import java.awt.event.FocusEvent;
-import java.awt.event.FocusListener;
-import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
 import java.net.URLEncoder;
 import java.nio.charset.StandardCharsets;
-import java.util.HashMap;
+import java.util.ArrayList;
 import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
+import java.util.function.UnaryOperator;
 
-import javax.swing.DefaultComboBoxModel;
-import javax.swing.ImageIcon;
-import javax.swing.JButton;
-import javax.swing.JComboBox;
-import javax.swing.JLabel;
-import javax.swing.JList;
-import javax.swing.JOptionPane;
-import javax.swing.JPanel;
-import javax.swing.border.Border;
-import javax.swing.border.EmptyBorder;
-import javax.swing.plaf.basic.BasicComboBoxRenderer;
-
-import net.sf.json.JSONObject;
-
-import org.apache.commons.configuration.Configuration;
-import org.apache.commons.configuration.ConfigurationException;
-import org.apache.commons.httpclient.URI;
-import org.apache.commons.httpclient.URIException;
 import org.apache.log4j.Logger;
 import org.parosproxy.paros.Constant;
-import org.parosproxy.paros.control.Control;
-import org.parosproxy.paros.db.DatabaseException;
-import org.parosproxy.paros.db.RecordContext;
-import org.parosproxy.paros.extension.ExtensionHook;
-import org.parosproxy.paros.model.Model;
-import org.parosproxy.paros.model.Session;
-import org.parosproxy.paros.model.SiteNode;
-import org.parosproxy.paros.network.HtmlParameter;
-import org.parosproxy.paros.network.HtmlParameter.Type;
 import org.parosproxy.paros.network.HttpHeader;
-import org.parosproxy.paros.network.HttpMalformedHeaderException;
-import org.parosproxy.paros.network.HttpMessage;
-import org.parosproxy.paros.network.HttpRequestHeader;
-import org.parosproxy.paros.network.HttpSender;
-import org.parosproxy.paros.view.SessionDialog;
-import org.parosproxy.paros.view.View;
-import org.zaproxy.zap.authentication.UsernamePasswordAuthenticationCredentials.UsernamePasswordAuthenticationCredentialsOptionsPanel;
-import org.zaproxy.zap.extension.api.ApiDynamicActionImplementor;
-import org.zaproxy.zap.extension.api.ApiException;
-import org.zaproxy.zap.extension.api.ApiResponse;
-import org.zaproxy.zap.extension.authentication.AuthenticationAPI;
-import org.zaproxy.zap.extension.authentication.ContextAuthenticationPanel;
-import org.zaproxy.zap.extension.users.ExtensionUserManagement;
 import org.zaproxy.zap.model.Context;
-import org.zaproxy.zap.session.SessionManagementMethod;
-import org.zaproxy.zap.session.WebSession;
-import org.zaproxy.zap.users.User;
-import org.zaproxy.zap.utils.ApiUtils;
-import org.zaproxy.zap.utils.ZapTextField;
-import org.zaproxy.zap.view.LayoutHelper;
-import org.zaproxy.zap.view.NodeSelectDialog;
-import org.zaproxy.zap.view.popup.PopupMenuItemContext;
-import org.zaproxy.zap.view.popup.PopupMenuItemSiteNodeContextMenuFactory;
+import org.zaproxy.zap.model.DefaultNameValuePair;
+import org.zaproxy.zap.model.NameValuePair;
 
 /**
- * The implementation for an {@link AuthenticationMethodType} where the Users are authenticated by
- * posting a form with user and password.
+ * An {@link AuthenticationMethodType} where the Users are authenticated by posting a form
+ * ({@code application/x-www-form-urlencoded}) with its username and password.
  */
-public class FormBasedAuthenticationMethodType extends AuthenticationMethodType {
-
-	public static final String CONTEXT_CONFIG_AUTH_FORM = AuthenticationMethod.CONTEXT_CONFIG_AUTH + ".form";
-	public static final String CONTEXT_CONFIG_AUTH_FORM_LOGINURL = CONTEXT_CONFIG_AUTH_FORM + ".loginurl";
-	public static final String CONTEXT_CONFIG_AUTH_FORM_LOGINBODY = CONTEXT_CONFIG_AUTH_FORM + ".loginbody";
+public class FormBasedAuthenticationMethodType extends PostBasedAuthenticationMethodType {
 
 	private static final int METHOD_IDENTIFIER = 2;
 
@@ -104,628 +47,105 @@ public class FormBasedAuthenticationMethodType extends AuthenticationMethodType
 
 	private static final String API_METHOD_NAME = "formBasedAuthentication";
 
-	private static final Logger log = Logger.getLogger(FormBasedAuthenticationMethodType.class);
-
-	/**
-	 * The implementation for an {@link AuthenticationMethod} where the Users are authenticated by
-	 * posting a form with user and password.
-	 */
-	public static class FormBasedAuthenticationMethod extends AuthenticationMethod {
-
-		private static final String LOGIN_ICON_RESOURCE = "/resource/icon/fugue/door-open-green-arrow.png";
-		public static final String MSG_USER_PATTERN = "{%username%}";
-		public static final String MSG_PASS_PATTERN = "{%password%}";
-
-		private HttpSender httpSender;
-		private SiteNode markedLoginSiteNode;
-		private SiteNode loginSiteNode = null;
-		private String loginRequestURL;
-		private String loginRequestBody;
-
-		@Override
-		public boolean isConfigured() {
-			// check if the login url is valid
-			return loginRequestURL != null && !loginRequestURL.isEmpty();
-		}
-
-		@Override
-		public AuthenticationCredentials createAuthenticationCredentials() {
-			return new UsernamePasswordAuthenticationCredentials();
-		}
-
-		@Override
-		public AuthenticationMethodType getType() {
-			return new FormBasedAuthenticationMethodType();
-		}
-
-		protected HttpSender getHttpSender() {
-			if (this.httpSender == null) {
-				this.httpSender = new HttpSender(Model.getSingleton().getOptionsParam().getConnectionParam(),
-						true, HttpSender.AUTHENTICATION_INITIATOR);
-			}
-			return httpSender;
-		}
-
-		/**
-		 * Prepares a request message, by filling the appropriate 'username' and 'password' fields
-		 * in the request URI and the POST data, if any.
-		 * 
-		 * @param credentials the credentials
-		 * @return the HTTP message prepared for authentication
-		 * @throws URIException if failed to create the request URI
-		 * @throws HttpMalformedHeaderException if the constructed HTTP request is malformed
-		 * @throws DatabaseException if an error occurred while reading the request from database
-		 */
-		private HttpMessage prepareRequestMessage(UsernamePasswordAuthenticationCredentials credentials)
-				throws URIException, HttpMalformedHeaderException, DatabaseException {
-
-			URI requestURI = createLoginUrl(loginRequestURL, credentials.getUsername(), credentials.getPassword());
-
-			// Replace the username and password in the post data of the request, if needed
-			String requestBody = null;
-			if (loginRequestBody != null && !loginRequestBody.isEmpty()) {
-				requestBody = replaceUserData(loginRequestBody, credentials.getUsername(), credentials.getPassword());
-			}
-
-			// Prepare the actual message, either based on the existing one, or create a new one
-			HttpMessage requestMessage;
-			if (this.loginSiteNode != null) {
-				// TODO: What happens if the SiteNode was deleted?
-				requestMessage = loginSiteNode.getHistoryReference().getHttpMessage().cloneRequest();
-				requestMessage.getRequestHeader().setURI(requestURI);
-				if (requestBody != null) {
-					requestMessage.getRequestBody().setBody(requestBody);
-					requestMessage.getRequestHeader().setHeader(HttpHeader.CONTENT_LENGTH, null);
-				}
-			} else {
-				String method = (requestBody != null) ? HttpRequestHeader.POST : HttpRequestHeader.GET;
-				requestMessage = new HttpMessage();
-				requestMessage.setRequestHeader(
-						new HttpRequestHeader(method, requestURI, HttpHeader.HTTP10,
-								Model.getSingleton().getOptionsParam().getConnectionParam()));
-				if (requestBody != null) {
-					requestMessage.getRequestBody().setBody(requestBody);
-				}
-			}
-
-			return requestMessage;
-		}
-
-		@Override
-		public WebSession authenticate(SessionManagementMethod sessionManagementMethod,
-				AuthenticationCredentials credentials, User user)
-				throws AuthenticationMethod.UnsupportedAuthenticationCredentialsException {
-
-			// type check
-			if (!(credentials instanceof UsernamePasswordAuthenticationCredentials)) {
-				throw new UnsupportedAuthenticationCredentialsException(
-						"Form based authentication method only supports "
-								+ UsernamePasswordAuthenticationCredentials.class.getSimpleName()
-								+ ". Received: " + credentials.getClass());
-			}
-			UsernamePasswordAuthenticationCredentials cred = (UsernamePasswordAuthenticationCredentials) credentials;
-
-			if (!cred.isConfigured()) {
-				log.warn("No credentials to authenticate user: " + user.getName());
-				return null;
-			}
-			
-			// Prepare login message
-			HttpMessage msg;
-			try {
-				msg = prepareRequestMessage(cred);
-			} catch (Exception e) {
-				log.error("Unable to prepare authentication message: " + e.getMessage(), e);
-				return null;
-			}
-
-			// Make sure the message will be sent with a good WebSession that can record the changes
-			if (user.getAuthenticatedSession() == null)
-				user.setAuthenticatedSession(sessionManagementMethod.createEmptyWebSession());
-			msg.setRequestingUser(user);
-
-			// Clear any session identifiers
-			msg.getRequestHeader().setHeader(HttpRequestHeader.COOKIE, null);
-
-			if (log.isDebugEnabled()) {
-				log.debug("Authentication request header: \n" + msg.getRequestHeader());
-				if (!msg.getRequestHeader().getMethod().equals(HttpRequestHeader.GET))
-					log.debug("Authentication request body: \n" + msg.getRequestBody());
-			}
-
-			// Send the authentication message
-			try {
-				getHttpSender().sendAndReceive(msg);
-			} catch (IOException e) {
-				log.error("Unable to send authentication message: " + e.getMessage());
-				return null;
-			}
-			if (this.isAuthenticated(msg)) {
-				// Let the user know it worked
-				AuthenticationHelper.notifyOutputAuthSuccessful(msg);
-			} else {
-				// Let the user know it failed
-				AuthenticationHelper.notifyOutputAuthFailure(msg);
-			}
-
-			// Add message to history
-			AuthenticationHelper.addAuthMessageToHistory(msg);
+	private static final Logger LOGGER = Logger.getLogger(FormBasedAuthenticationMethodType.class);
 
-			// Return the web session as extracted by the session management method
-			return sessionManagementMethod.extractWebSession(msg);
+	private static final UnaryOperator<String> PARAM_ENCODER = value -> {
+		try {
+			return URLEncoder.encode(value, StandardCharsets.UTF_8.name());
+		} catch (UnsupportedEncodingException ignore) {
+			// Standard charset.
 		}
+		return "";
+	};
 
-		/**
-		 * Sets the login request as being an existing SiteNode.
-		 * 
-		 * @param loginSiteNode the new login request
-		 * @throws Exception if an error occurred while obtaining the message from the node
-		 */
-		public void setLoginRequest(SiteNode loginSiteNode) throws Exception {
-			this.loginSiteNode = loginSiteNode;
-
-			HttpMessage requestMessage = loginSiteNode.getHistoryReference().getHttpMessage();
-			this.loginRequestURL = requestMessage.getRequestHeader().getURI().toString();
-			if (!requestMessage.getRequestHeader().getMethod().equalsIgnoreCase(HttpRequestHeader.GET)) {
-				this.loginRequestBody = requestMessage.getRequestBody().toString();
-			} else {
-				this.loginRequestBody = null;
-			}
+	private static final UnaryOperator<String> PARAM_DECODER = value -> {
+		try {
+			return URLDecoder.decode(value, StandardCharsets.UTF_8.name());
+		} catch (UnsupportedEncodingException ignore) {
+			// Standard charset.
+		} catch (IllegalArgumentException e) {
+			LOGGER.debug("Failed to URL decode: " + value, e);
 		}
+		return "";
+	};
 
-		/**
-		 * Gets the login request url.
-		 * 
-		 * @return the login request url
-		 */
-		public String getLoginRequestURL() {
-			return loginRequestURL;
-		}
+	public FormBasedAuthenticationMethodType() {
+		super(METHOD_NAME, METHOD_IDENTIFIER, API_METHOD_NAME, "authentication.method.fb.popup.login.request", false);
+	}
+	
+	/**
+	 * An {@link AuthenticationMethod} where the Users are authenticated by posting a form
+	 * ({@code application/x-www-form-urlencoded}) with its username and password.
+	 */
+	public class FormBasedAuthenticationMethod extends PostBasedAuthenticationMethod {
 
 		/**
-		 * Marks the provided Site Login as being a Login request. If {@code null} is provided, no
-		 * site node will be marked as login request (for the {@link Context} corresponding to this
-		 * AuthenticationMethod).
-		 * 
-		 * @param sn the new login site node
+		 * Constructs a {@code FormBasedAuthenticationMethod}.
+		 *
 		 */
-		private void markLoginSiteNode(SiteNode sn) {
-			// No need for resetting everything up if it's already the right node
-			if (this.markedLoginSiteNode == sn) {
-				return;
-			}
-			if (this.markedLoginSiteNode != null) {
-				this.markedLoginSiteNode.removeCustomIcon(LOGIN_ICON_RESOURCE);
-			}
-
-			this.markedLoginSiteNode = sn;
-			if (sn == null) {
-				return;
-			}
-			sn.addCustomIcon(LOGIN_ICON_RESOURCE, false);
+		public FormBasedAuthenticationMethod() {
+			this(null);
 		}
 
 		/**
-		 * Sets the login request, based on a given url and, if needed, post data. If post data is
-		 * provided, the assumed HTTP method is POST.
-		 * <p>
-		 * If there is a SiteNode that matches the URL and post data (with the exception of the
-		 * 'username' and 'password' parameters), it is marked as the 'Login' site node.
-		 * </p>
-		 * 
-		 * @param url the url
-		 * @param postData the post data, or {@code null} if the request should be a GET one
-		 * @throws Exception the exception
+		 * Constructs a {@code FormBasedAuthenticationMethod} based on the given method.
+		 *
+		 * @param formBasedAuthenticationMethod the method to copy.
 		 */
-		protected void setLoginRequest(String url, String postData) throws Exception {
-			if (url == null || url.length() == 0) {
-				this.loginRequestURL = null;
-				this.loginRequestBody = null;
-				this.loginSiteNode = null;
-			} else {
-				String method = HttpRequestHeader.GET;
-				if (postData != null && postData.length() > 0) {
-					method = HttpRequestHeader.POST;
-				}
-
-				this.loginRequestURL = url;
-				this.loginRequestBody = postData;
-
-				URI uri = createLoginUrl(loginRequestURL, "", "");
-				// Note: The findNode just checks the parameter names, not their values
-				// Note: No need to make sure the other parameters (besides user/password) are the
-				// same, as POSTs with different values are not delimited in the SitesTree anyway
-				// Note: Set the login site node anyway (even if null), to make sure any previously
-				// marked SiteNode is unmarked
-				this.loginSiteNode = Model.getSingleton().getSession().getSiteTree()
-						.findNode(uri, method, postData);
-			}
-
-		}
-
-		@Override
-		public String toString() {
-			return "FormBasedAuthenticationMethod [loginURI=" + loginRequestURL + "]";
-		}
-
-		@Override
-		public FormBasedAuthenticationMethod duplicate() {
-			FormBasedAuthenticationMethod clonedMethod = new FormBasedAuthenticationMethod();
-			clonedMethod.loginRequestURL = this.loginRequestURL;
-			clonedMethod.loginRequestBody = this.loginRequestBody;
-			clonedMethod.loginSiteNode = this.loginSiteNode;
-			clonedMethod.markedLoginSiteNode = this.markedLoginSiteNode;
-			return clonedMethod;
-		}
-
-		@Override
-		public void onMethodPersisted() {
-			markLoginSiteNode(loginSiteNode);
-		}
-
-		@Override
-		public void onMethodDiscarded() {
-			markLoginSiteNode(null);
+		private FormBasedAuthenticationMethod(FormBasedAuthenticationMethod formBasedAuthenticationMethod) {
+			super(HttpHeader.FORM_URLENCODED_CONTENT_TYPE, PARAM_ENCODER, formBasedAuthenticationMethod);
 		}
 
 		@Override
-		public ApiResponse getApiResponseRepresentation() {
-			Map<String, String> values = new HashMap<>();
-			values.put("methodName", API_METHOD_NAME);
-			values.put("loginUrl", loginRequestURL);
-			values.put("loginRequestData", this.loginRequestBody);
-			return new AuthMethodApiResponseRepresentation<>(values);
-		}
-
-		@Override
-		public int hashCode() {
-			final int prime = 31;
-			int result = super.hashCode();
-			result = prime * result + ((loginRequestBody == null) ? 0 : loginRequestBody.hashCode());
-			result = prime * result + ((loginRequestURL == null) ? 0 : loginRequestURL.hashCode());
-			return result;
+		public AuthenticationMethodType getType() {
+			return new FormBasedAuthenticationMethodType();
 		}
 
 		@Override
-		public boolean equals(Object obj) {
-			if (this == obj)
-				return true;
-			if (!super.equals(obj))
-				return false;
-			if (getClass() != obj.getClass())
-				return false;
-			FormBasedAuthenticationMethod other = (FormBasedAuthenticationMethod) obj;
-			if (loginRequestBody == null) {
-				if (other.loginRequestBody != null)
-					return false;
-			} else if (!loginRequestBody.equals(other.loginRequestBody))
-				return false;
-			if (loginRequestURL == null) {
-				if (other.loginRequestURL != null)
-					return false;
-			} else if (!loginRequestURL.equals(other.loginRequestURL))
-				return false;
-			return true;
-		}
-	}
-
-	private static URI createLoginUrl(String loginData, String username, String password) throws URIException {
-		return new URI(replaceUserData(loginData, username, password), true);
-	}
-
-	private static String replaceUserData(String loginData, String username, String password) {
-		return loginData.replace(FormBasedAuthenticationMethod.MSG_USER_PATTERN, encodeParameter(username))
-				.replace(FormBasedAuthenticationMethod.MSG_PASS_PATTERN, encodeParameter(password));
-	}
-
-	private static String encodeParameter(String parameter) {
-		try {
-			return URLEncoder.encode(parameter, "UTF-8");
-		} catch (UnsupportedEncodingException ignore) {
-			// UTF-8 is one of the standard charsets (see StandardCharsets.UTF_8).
-		}
-		return "";
-	}
-
-	private static boolean isValidLoginUrl(String loginUrl) {
-		if (loginUrl.isEmpty()) {
-			return false;
-		}
-
-		try {
-			createLoginUrl(loginUrl, "", "");
-			return true;
-		} catch (Exception e) {
-			return false;
+		protected AuthenticationMethod duplicate() {
+			return new FormBasedAuthenticationMethod(this);
 		}
 	}
 
 	/**
-	 * The Options Panel used for configuring a {@link FormBasedAuthenticationMethod}.
+	 * The options panel to configure a {@link FormBasedAuthenticationMethod}.
 	 */
-	private static class FormBasedAuthenticationMethodOptionsPanel extends
-			AbstractAuthenticationMethodOptionsPanel {
-
-		private static final long serialVersionUID = -9010956260384814566L;
+	private class FormBasedAuthenticationMethodOptionsPanel extends PostBasedAuthenticationMethodOptionsPanel {
 
-		private static final String POST_DATA_LABEL = Constant.messages
-				.getString("authentication.method.fb.field.label.postData");
-		private static final String USERNAME_PARAM_LABEL = Constant.messages
-				.getString("authentication.method.fb.field.label.usernameParam");
-		private static final String PASSWORD_PARAM_LABEL = Constant.messages
-				.getString("authentication.method.fb.field.label.passwordParam");
-		private static final String LOGIN_URL_LABEL = Constant.messages
-				.getString("authentication.method.fb.field.label.loginUrl");
-		private static final String AUTH_DESCRIPTION = Constant.messages
-				.getString("authentication.method.fb.field.label.description");
-
-		private ZapTextField loginUrlField;
-		private ZapTextField postDataField;
-		private JComboBox<HtmlParameter> usernameParameterCombo;
-		private JComboBox<HtmlParameter> passwordParameterCombo;
-		private FormBasedAuthenticationMethod authenticationMethod;
-
-		private Context context;
-		private ExtensionUserManagement userExt = null;
+		private static final long serialVersionUID = 1L;
 
+		/**
+		 * Constructs a {@code FormBasedAuthenticationMethodOptionsPanel} for the given context.
+		 *
+		 * @param context the context to be configured.
+		 */
 		public FormBasedAuthenticationMethodOptionsPanel(Context context) {
-			super();
-			initialize();
-			this.context = context;
-		}
-
-		@SuppressWarnings("unchecked")
-		private void initialize() {
-			this.setLayout(new GridBagLayout());
-
-			this.add(new JLabel(LOGIN_URL_LABEL), LayoutHelper.getGBC(0, 0, 2, 1.0d, 0.0d));
-
-			JPanel urlSelectPanel = new JPanel(new GridBagLayout());
-
-			this.loginUrlField = new ZapTextField();
-			this.postDataField = new ZapTextField();
-
-			JButton selectButton = new JButton(Constant.messages.getString("all.button.select"));
-			selectButton.setIcon(new ImageIcon(View.class.getResource("/resource/icon/16/094.png"))); // Globe
-
-			// Add behaviour for Node Select dialog
-			selectButton.addActionListener(new java.awt.event.ActionListener() {
-				@Override
-				public void actionPerformed(java.awt.event.ActionEvent e) {
-					NodeSelectDialog nsd = new NodeSelectDialog(View.getSingleton().getMainFrame());
-					// Try to pre-select the node according to what has been inserted in the fields
-					SiteNode node = null;
-					if (loginUrlField.getText().trim().length() > 0)
-						try {
-							// If it's a POST query
-							if (postDataField.getText().trim().length() > 0)
-								node = Model
-										.getSingleton()
-										.getSession()
-										.getSiteTree()
-										.findNode(new URI(loginUrlField.getText(), false),
-												HttpRequestHeader.POST, postDataField.getText());
-							else
-								node = Model.getSingleton().getSession().getSiteTree()
-										.findNode(new URI(loginUrlField.getText(), false));
-						} catch (Exception e2) {
-							// Ignore. It means we could not properly get a node for the existing
-							// value and does not have any harmful effects
-						}
-
-					// Show the dialog and wait for input
-					node = nsd.showDialog(node);
-					if (node != null && node.getHistoryReference() != null) {
-						try {
-							if (log.isInfoEnabled()) {
-								log.info("Selected Form Based Auth Login URL via dialog: "
-										+ node.getHistoryReference().getURI().toString());
-							}
-
-							loginUrlField.setText(node.getHistoryReference().getURI().toString());
-							postDataField.setText(node.getHistoryReference().getHttpMessage()
-									.getRequestBody().toString());
-							updateParameters();
-						} catch (Exception e1) {
-							log.error(e1.getMessage(), e1);
-						}
-					}
-				}
-			});
-
-			urlSelectPanel.add(this.loginUrlField, LayoutHelper.getGBC(0, 0, 1, 1.0D));
-			urlSelectPanel.add(selectButton, LayoutHelper.getGBC(1, 0, 1, 0.0D));
-			this.add(urlSelectPanel, LayoutHelper.getGBC(0, 1, 2, 1.0d, 0.0d));
-
-			this.add(new JLabel(POST_DATA_LABEL), LayoutHelper.getGBC(0, 2, 2, 1.0d, 0.0d));
-			this.add(this.postDataField, LayoutHelper.getGBC(0, 3, 2, 1.0d, 0.0d));
-
-			this.add(new JLabel(USERNAME_PARAM_LABEL), LayoutHelper.getGBC(0, 4, 1, 1.0d, 0.0d));
-			this.usernameParameterCombo = new JComboBox<>();
-			this.usernameParameterCombo.setRenderer(new HtmlParameterRenderer());
-			this.add(usernameParameterCombo, LayoutHelper.getGBC(0, 5, 1, 1.0d, 0.0d));
-
-			this.add(new JLabel(PASSWORD_PARAM_LABEL), LayoutHelper.getGBC(1, 4, 1, 1.0d, 0.0d));
-			this.passwordParameterCombo = new JComboBox<>();
-			this.passwordParameterCombo.setRenderer(new HtmlParameterRenderer());
-			this.add(passwordParameterCombo, LayoutHelper.getGBC(1, 5, 1, 1.0d, 0.0d));
-
-			this.add(new JLabel(AUTH_DESCRIPTION), LayoutHelper.getGBC(0, 8, 2, 1.0d, 0.0d));
-
-			// Make sure we update the parameters when something has been changed in the
-			// postDataField
-			this.postDataField.addFocusListener(new FocusListener() {
-				@Override
-				public void focusLost(FocusEvent e) {
-					updateParameters();
-				}
-
-				@Override
-				public void focusGained(FocusEvent e) {
-				}
-			});
+			super(context, PARAM_DECODER);
 		}
 
 		@Override
-		public void validateFields() {
-			if (!isValidLoginUrl(loginUrlField.getText())) {
-				loginUrlField.requestFocusInWindow();
-				throw new IllegalStateException(
-						Constant.messages.getString("authentication.method.fb.dialog.error.url.text"));
-			}
+		protected List<NameValuePair> extractParameters(String postData) {
+			List<NameValuePair> parameters = new ArrayList<>();
+			getContext().getPostParamParser().parse(postData).forEach((k, v) -> parameters.add(new DefaultNameValuePair(k, v)));
+			return parameters;
 		}
 
-		private String replaceParameterValue(String originalString, HtmlParameter parameter,
-				String replaceString) {
-			String keyValueSeparator = context.getPostParamParser().getDefaultKeyValueSeparator();
+		@Override
+		protected String replaceParameterValue(String originalString, NameValuePair parameter, String replaceString) {
+			String keyValueSeparator = getContext().getPostParamParser().getDefaultKeyValueSeparator();
 			String nameAndSeparator = parameter.getName() + keyValueSeparator;
 			// Make sure we handle the case when there's only the parameter name in the POST data instead of
 			// parameter name + separator + value (e.g. just 'param1&...' instead of 'param1=...&...')
-			if (originalString.contains(nameAndSeparator))
-				return originalString.replace(nameAndSeparator + parameter.getValue(), nameAndSeparator
-						+ replaceString);
-			else
-				return originalString.replace(parameter.getName(), nameAndSeparator + replaceString);
-		}
-		
-		private ExtensionUserManagement getUserExt() {
-			if (userExt == null) {
-				userExt = Control.getSingleton().getExtensionLoader().getExtension(ExtensionUserManagement.class);
-				
-			}
-			return userExt;
-		}
-
-		@Override
-		public void saveMethod() {
-			try {
-				String postData = postDataField.getText();
-				if (!postData.isEmpty()) {
-					HtmlParameter userParam = (HtmlParameter) usernameParameterCombo.getSelectedItem();
-					HtmlParameter passwdParam = (HtmlParameter) passwordParameterCombo.getSelectedItem();
-					
-					ExtensionUserManagement userExt = getUserExt();
-					if (userExt != null && userExt.getUIConfiguredUsers(context.getIndex()).size() == 0) {
-						String username = userParam.getValue();
-						String password = passwdParam.getValue();
-						if (!username.isEmpty() && !username.contains(FormBasedAuthenticationMethod.MSG_USER_PATTERN)
-								&& !password.contains(FormBasedAuthenticationMethod.MSG_PASS_PATTERN)) {
-							// Add the user based on the details provided
-							// Note that right now application/x-www-form-urlencoded forms are supported 
-							String userStr = decodeValue(username);
-							String passwdStr = decodeValue(password);
-							if (!userStr.isEmpty() && !passwdStr.isEmpty()) {
-								User user = new User(context.getIndex(), userStr);
-								UsernamePasswordAuthenticationCredentials upac = 
-										new UsernamePasswordAuthenticationCredentials(userStr, passwdStr);
-								user.setAuthenticationCredentials(upac);
-								getUserExt().getContextUserAuthManager(context.getIndex()).addUser(user);
-							}
-						}
-					}
-					
-					postData = this.replaceParameterValue(postData, userParam,
-							FormBasedAuthenticationMethod.MSG_USER_PATTERN);
-					postData = this.replaceParameterValue(postData, passwdParam,
-							FormBasedAuthenticationMethod.MSG_PASS_PATTERN);
-				}
-				getMethod().setLoginRequest(loginUrlField.getText(), postData);
-			} catch (Exception e) {
-				log.error(e.getMessage(), e);
-			}
-		}
-
-		private static String decodeValue(String value) {
-			try {
-				return URLDecoder.decode(value, StandardCharsets.UTF_8.name());
-			} catch (UnsupportedEncodingException ignore) {
-				// Standard charset.
-			} catch (IllegalArgumentException e) {
-				log.debug("Failed to URL decode: " + value, e);
-			}
-			return "";
-		}
-
-		@Override
-		public void bindMethod(AuthenticationMethod method) {
-			this.authenticationMethod = (FormBasedAuthenticationMethod) method;
-			this.loginUrlField.setText(authenticationMethod.loginRequestURL);
-			this.postDataField.setText(authenticationMethod.loginRequestBody);
-
-			updateParameters();
-		}
-
-		/**
-		 * Gets the index of the parameter with a given value.
-		 * 
-		 * @param params the params
-		 * @param value the value
-		 * @return the index of param with value, or -1 if no match was found
-		 */
-		private int getIndexOfParamWithValue(HtmlParameter[] params, String value) {
-			for (int i = 0; i < params.length; i++)
-				if (params[i].getValue().equals(value))
-					return i;
-			return -1;
-		}
-
-		private void updateParameters() {
-			try {
-				Map<String, String> params = this.context.getPostParamParser().parse(
-						this.postDataField.getText());
-				HtmlParameter[] paramsArray = mapToParamArray(params);
-				this.usernameParameterCombo.setModel(new DefaultComboBoxModel<>(paramsArray));
-				this.passwordParameterCombo.setModel(new DefaultComboBoxModel<>(paramsArray));
-
-				int index = getIndexOfParamWithValue(paramsArray,
-						FormBasedAuthenticationMethod.MSG_USER_PATTERN);
-				if (index >= 0) {
-					this.usernameParameterCombo.setSelectedIndex(index);
-				}
-
-				index = getIndexOfParamWithValue(paramsArray, FormBasedAuthenticationMethod.MSG_PASS_PATTERN);
-				if (index >= 0) {
-					this.passwordParameterCombo.setSelectedIndex(index);
-				}
-			} catch (Exception e) {
-				log.error(e.getMessage(), e);
-			}
-		}
-
-		private HtmlParameter[] mapToParamArray(Map<String, String> map) {
-			HtmlParameter[] array = new HtmlParameter[map.size()];
-			int i = 0;
-			for (Entry<String, String> param : map.entrySet()) {
-				array[i++] = new HtmlParameter(Type.form, param.getKey(), param.getValue());
+			if (originalString.contains(nameAndSeparator)) {
+				return originalString.replace(nameAndSeparator + parameter.getValue(), nameAndSeparator + replaceString);
 			}
-			return array;
-		}
-
-		@Override
-		public FormBasedAuthenticationMethod getMethod() {
-			return this.authenticationMethod;
+			return originalString.replace(parameter.getName(), nameAndSeparator + replaceString);
 		}
 	}
 
-	/**
-	 * A renderer for properly displaying the name of an HtmlParameter in a ComboBox.
-	 */
-	private static class HtmlParameterRenderer extends BasicComboBoxRenderer {
-		private static final long serialVersionUID = 3654541772447187317L;
-		private static final Border BORDER = new EmptyBorder(2, 3, 3, 3);
-
-		@Override
-		@SuppressWarnings("rawtypes")
-		public Component getListCellRendererComponent(JList list, Object value, int index,
-				boolean isSelected, boolean cellHasFocus) {
-			super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
-			if (value != null) {
-				setBorder(BORDER);
-				HtmlParameter item = (HtmlParameter) value;
-				setText(item.getName());
-			}
-			return this;
-		}
+	@Override
+	public boolean isTypeForMethod(AuthenticationMethod method) {
+		return method instanceof FormBasedAuthenticationMethod;
 	}
 
 	@Override
@@ -733,276 +153,9 @@ public class FormBasedAuthenticationMethodType extends AuthenticationMethodType
 		return new FormBasedAuthenticationMethod();
 	}
 
-	@Override
-	public String getName() {
-		return METHOD_NAME;
-	}
-
 	@Override
 	public AbstractAuthenticationMethodOptionsPanel buildOptionsPanel(Context uiSharedContext) {
 		return new FormBasedAuthenticationMethodOptionsPanel(uiSharedContext);
 	}
 
-	@Override
-	public boolean hasOptionsPanel() {
-		return true;
-	}
-
-	@Override
-	public AbstractCredentialsOptionsPanel<? extends AuthenticationCredentials> buildCredentialsOptionsPanel(
-			AuthenticationCredentials credentials, Context uiSharedContext) {
-		return new UsernamePasswordAuthenticationCredentialsOptionsPanel(
-				(UsernamePasswordAuthenticationCredentials) credentials);
-	}
-
-	@Override
-	public boolean hasCredentialsOptionsPanel() {
-		return true;
-	}
-
-	@Override
-	public boolean isTypeForMethod(AuthenticationMethod method) {
-		return (method instanceof FormBasedAuthenticationMethod);
-	}
-
-	@Override
-	public void hook(ExtensionHook extensionHook) {
-		extensionHook.getHookMenu().addPopupMenuItem(getPopupFlagLoginRequestMenuFactory());
-	}
-
-	/**
-	 * Gets the popup menu factory for flagging login requests.
-	 * 
-	 * @return the popup flag login request menu factory
-	 */
-	private PopupMenuItemSiteNodeContextMenuFactory getPopupFlagLoginRequestMenuFactory() {
-	    PopupMenuItemSiteNodeContextMenuFactory popupFlagLoginRequestMenuFactory = new PopupMenuItemSiteNodeContextMenuFactory(
-				Constant.messages.getString("context.flag.popup")) {
-			private static final long serialVersionUID = 8927418764L;
-
-			@Override
-			public PopupMenuItemContext getContextMenu(Context context, String parentMenu) {
-				return new PopupMenuItemContext(context, parentMenu, 
-						Constant.messages.getString("authentication.method.fb.popup.login.request", context.getName())) {
-
-					private static final long serialVersionUID = 1967885623005183801L;
-					private ExtensionUserManagement usersExtension;
-					private Context uiSharedContext;
-
-					/**
-					 * Make sure the user acknowledges the Users corresponding to this context will
-					 * be deleted.
-					 * 
-					 * @return true, if successful
-					 */
-					private boolean confirmUsersDeletion(Context uiSharedContext) {
-						usersExtension = Control.getSingleton().getExtensionLoader().getExtension(ExtensionUserManagement.class);
-						if (usersExtension != null) {
-							if (usersExtension.getSharedContextUsers(uiSharedContext).size() > 0) {
-								int choice = JOptionPane.showConfirmDialog(this, Constant.messages
-										.getString("authentication.dialog.confirmChange.label"),
-										Constant.messages
-												.getString("authentication.dialog.confirmChange.title"),
-										JOptionPane.OK_CANCEL_OPTION);
-								if (choice == JOptionPane.CANCEL_OPTION) {
-									return false;
-								}
-							}
-						}
-						return true;
-					}
-
-					@Override
-					public void performAction(SiteNode sn) {
-						// Manually create the UI shared contexts so any modifications are done
-						// on an UI shared Context, so changes can be undone by pressing Cancel
-						SessionDialog sessionDialog = View.getSingleton().getSessionDialog();
-						sessionDialog.recreateUISharedContexts(Model.getSingleton().getSession());
-						uiSharedContext = sessionDialog.getUISharedContext(this.getContext().getIndex());
-
-						// Do the work/changes on the UI shared context
-						if (this.getContext().getAuthenticationMethod() instanceof FormBasedAuthenticationMethod) {
-							log.info("Selected new login request via PopupMenu. Changing existing Form-Based Authentication instance for Context "
-									+ getContext().getIndex());
-							FormBasedAuthenticationMethod method = (FormBasedAuthenticationMethod) uiSharedContext
-									.getAuthenticationMethod();
-
-							try {
-								method.setLoginRequest(sn);
-							} catch (Exception e) {
-								log.error("Failed to set login request: " + e.getMessage(), e);
-								return;
-							}
-
-							// Show the session dialog without recreating UI Shared contexts
-							View.getSingleton()
-									.showSessionDialog(
-											Model.getSingleton().getSession(),
-											ContextAuthenticationPanel
-													.buildName(this.getContext().getIndex()), false);
-						} else {
-							log.info("Selected new login request via PopupMenu. Creating new Form-Based Authentication instance for Context "
-									+ getContext().getIndex());
-							FormBasedAuthenticationMethod method = new FormBasedAuthenticationMethod();
-
-							try {
-								method.setLoginRequest(sn);
-							} catch (Exception e) {
-								log.error("Failed to set login request: " + e.getMessage(), e);
-								return;
-							}
-							if (!confirmUsersDeletion(uiSharedContext)) {
-								log.debug("Cancelled change of authentication type.");
-								return;
-							}
-							uiSharedContext.setAuthenticationMethod(method);
-
-							// Show the session dialog without recreating UI Shared contexts
-							// NOTE: First init the panels of the dialog so old users data gets
-							// loaded and just then delete the users
-							// from the UI data model, otherwise the 'real' users from the
-							// non-shared context would be loaded
-							// and would override any deletions made.
-							View.getSingleton().showSessionDialog(Model.getSingleton().getSession(),
-									ContextAuthenticationPanel.buildName(this.getContext().getIndex()),
-									false, new Runnable() {
-
-										@Override
-										public void run() {
-											// Removing the users from the 'shared context' (the UI)
-											// will cause their removal at
-											// save as well
-											if (usersExtension != null)
-												usersExtension.removeSharedContextUsers(uiSharedContext);
-										}
-									});
-						}
-					}
-				};
-			}
-
-			@Override
-			public int getParentMenuIndex() {
-				return 3;
-			}
-		};
-		return popupFlagLoginRequestMenuFactory;
-	}
-
-	@Override
-	public AuthenticationMethod loadMethodFromSession(Session session, int contextId) throws DatabaseException {
-		FormBasedAuthenticationMethod method = new FormBasedAuthenticationMethod();
-		List<String> urls = session.getContextDataStrings(contextId, RecordContext.TYPE_AUTH_METHOD_FIELD_1);
-		String url = "";
-		if (urls != null && urls.size() > 0) {
-			url = urls.get(0);
-		}
-
-		List<String> postDatas = session.getContextDataStrings(contextId,
-				RecordContext.TYPE_AUTH_METHOD_FIELD_2);
-		String postData = null;
-		if (postDatas != null && postDatas.size() > 0) {
-			postData = postDatas.get(0);
-		}
-
-		try {
-			method.setLoginRequest(url, postData);
-		} catch (Exception e) {
-			log.error("Unable to load FormBasedAuthenticationMethod. ", e);
-		}
-		return method;
-	}
-
-	@Override
-	public void persistMethodToSession(Session session, int contextId, AuthenticationMethod authMethod)
-			throws DatabaseException {
-		if (!(authMethod instanceof FormBasedAuthenticationMethod)) {
-			throw new UnsupportedAuthenticationMethodException(
-					"Form based authentication type only supports: " + FormBasedAuthenticationMethod.class);
-		}
-
-		FormBasedAuthenticationMethod method = (FormBasedAuthenticationMethod) authMethod;
-		session.setContextData(contextId, RecordContext.TYPE_AUTH_METHOD_FIELD_1, method.loginRequestURL);
-		session.setContextData(contextId, RecordContext.TYPE_AUTH_METHOD_FIELD_2, method.loginRequestBody);
-	}
-
-	@Override
-	public int getUniqueIdentifier() {
-		return METHOD_IDENTIFIER;
-	}
-
-	@Override
-	public UsernamePasswordAuthenticationCredentials createAuthenticationCredentials() {
-		return new UsernamePasswordAuthenticationCredentials();
-	}
-
-	/* API related constants and methods. */
-	private static final String PARAM_LOGIN_URL = "loginUrl";
-	private static final String PARAM_LOGIN_REQUEST_DATA = "loginRequestData";
-
-	@Override
-	public ApiDynamicActionImplementor getSetMethodForContextApiAction() {
-		return new ApiDynamicActionImplementor(API_METHOD_NAME, new String[] { PARAM_LOGIN_URL },
-				new String[] { PARAM_LOGIN_REQUEST_DATA }) {
-
-			@Override
-			public void handleAction(JSONObject params) throws ApiException {
-				Context context = ApiUtils.getContextByParamId(params, AuthenticationAPI.PARAM_CONTEXT_ID);
-				String loginUrl = ApiUtils.getNonEmptyStringParam(params, PARAM_LOGIN_URL);
-				if (!isValidLoginUrl(loginUrl)) {
-					throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_LOGIN_URL);
-				}
-				String postData = "";
-				if (params.containsKey(PARAM_LOGIN_REQUEST_DATA)) {
-					postData = params.getString(PARAM_LOGIN_REQUEST_DATA);
-				}
-
-				// Set the method
-				FormBasedAuthenticationMethod method = createAuthenticationMethod(context.getIndex());
-				try {
-					method.setLoginRequest(loginUrl, postData);
-				} catch (Exception e) {
-					throw new ApiException(ApiException.Type.INTERNAL_ERROR, e.getMessage());
-				}
-
-				if (!context.getAuthenticationMethod().isSameType(method))
-					apiChangedAuthenticationMethodForContext(context.getIndex());
-				context.setAuthenticationMethod(method);
-			}
-		};
-	}
-
-	@Override
-	public ApiDynamicActionImplementor getSetCredentialsForUserApiAction() {
-		return UsernamePasswordAuthenticationCredentials.getSetCredentialsForUserApiAction(this);
-	}
-
-	@Override
-	public void exportData(Configuration config, AuthenticationMethod authMethod) {
-		if (!(authMethod instanceof FormBasedAuthenticationMethod)) {
-			throw new UnsupportedAuthenticationMethodException(
-					"Form based authentication type only supports: " + FormBasedAuthenticationMethod.class.getName());
-		}
-		FormBasedAuthenticationMethod method = (FormBasedAuthenticationMethod) authMethod;
-
-		config.setProperty(CONTEXT_CONFIG_AUTH_FORM_LOGINURL, method.loginRequestURL);
-		config.setProperty(CONTEXT_CONFIG_AUTH_FORM_LOGINBODY, method.loginRequestBody);
-	}
-
-	@Override
-	public void importData(Configuration config, AuthenticationMethod authMethod) throws ConfigurationException {
-		if (!(authMethod instanceof FormBasedAuthenticationMethod)) {
-			throw new UnsupportedAuthenticationMethodException(
-					"Form based authentication type only supports: " + FormBasedAuthenticationMethod.class.getName());
-		}
-		FormBasedAuthenticationMethod method = (FormBasedAuthenticationMethod) authMethod;
-		
-		try {
-			method.setLoginRequest(config.getString(CONTEXT_CONFIG_AUTH_FORM_LOGINURL), 
-					config.getString(CONTEXT_CONFIG_AUTH_FORM_LOGINBODY));
-		} catch (Exception e) {
-			throw new ConfigurationException(e);
-		}
-	}
-
 }
diff --git a/src/org/zaproxy/zap/authentication/JsonBasedAuthenticationMethodType.java b/src/org/zaproxy/zap/authentication/JsonBasedAuthenticationMethodType.java
new file mode 100644
index 000000000..cccc5d014
--- /dev/null
+++ b/src/org/zaproxy/zap/authentication/JsonBasedAuthenticationMethodType.java
@@ -0,0 +1,178 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2018 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.authentication;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.commons.text.StringEscapeUtils;
+import org.apache.log4j.Logger;
+import org.parosproxy.paros.Constant;
+import org.parosproxy.paros.network.HttpHeader;
+import org.zaproxy.zap.model.Context;
+import org.zaproxy.zap.model.DefaultNameValuePair;
+import org.zaproxy.zap.model.NameValuePair;
+
+import net.sf.json.JSONException;
+import net.sf.json.JSONObject;
+
+/**
+ * An {@link AuthenticationMethodType} where the Users are authenticated by posting a JSON object with its username and
+ * password.
+ * 
+ * @since TODO add version
+ */
+public class JsonBasedAuthenticationMethodType extends PostBasedAuthenticationMethodType {
+
+	private static final Logger LOGGER = Logger.getLogger(JsonBasedAuthenticationMethodType.class);
+
+	private static final int METHOD_IDENTIFIER = 5;
+
+	private static final String METHOD_NAME = Constant.messages.getString("authentication.method.jb.name");
+
+	private static final String API_METHOD_NAME = "jsonBasedAuthentication";
+
+	public JsonBasedAuthenticationMethodType() {
+		super(METHOD_NAME, METHOD_IDENTIFIER, API_METHOD_NAME, "authentication.method.jb.popup.login.request", true);
+	}
+
+	/**
+	 * An {@link AuthenticationMethod} where the Users are authenticated by posting a JSON object ({@code application/json})
+	 * with its username and password.
+	 */
+	public class JsonBasedAuthenticationMethod extends PostBasedAuthenticationMethod {
+
+		/**
+		 * Constructs a {@code JsonBasedAuthenticationMethod}.
+		 */
+		public JsonBasedAuthenticationMethod() {
+			this(null);
+		}
+
+		/**
+		 * Constructs a {@code JsonBasedAuthenticationMethod} based on the given method.
+		 *
+		 * @param jsonBasedAuthenticationMethod the method to copy.
+		 */
+		private JsonBasedAuthenticationMethod(JsonBasedAuthenticationMethod jsonBasedAuthenticationMethod) {
+			super(HttpHeader.JSON_CONTENT_TYPE, StringEscapeUtils::escapeJson, jsonBasedAuthenticationMethod);
+		}
+
+		@Override
+		public AuthenticationMethodType getType() {
+			return new JsonBasedAuthenticationMethodType();
+		}
+
+		@Override
+		protected AuthenticationMethod duplicate() {
+			return new JsonBasedAuthenticationMethod(this);
+		}
+	}
+
+	/**
+	 * The options panel to configure a {@link JsonBasedAuthenticationMethod}.
+	 */
+	private class JsonBasedAuthenticationMethodOptionsPanel extends PostBasedAuthenticationMethodOptionsPanel {
+
+		private static final long serialVersionUID = 1L;
+		private JSONObject jsonObject;
+
+		/**
+		 * Constructs a {@code JsonBasedAuthenticationMethodOptionsPanel} for the given context.
+		 *
+		 * @param context the context to be configured.
+		 */
+		public JsonBasedAuthenticationMethodOptionsPanel(Context context) {
+			super(context, StringEscapeUtils::unescapeJson);
+		}
+
+		@Override
+		protected List<NameValuePair> extractParameters(String postData) {
+			if (postData.isEmpty()) {
+				jsonObject = null;
+				return Collections.emptyList();
+			}
+
+			List<NameValuePair> params = new ArrayList<>();
+			try {
+				jsonObject = JSONObject.fromObject(postData);
+				extractJsonStrings(jsonObject, "", params);
+			} catch (JSONException e) {
+				if (LOGGER.isDebugEnabled()) {
+					LOGGER.debug("Unable to parse as JSON: " + postData, e);
+				}
+				jsonObject = null;
+				return Collections.emptyList();
+			}
+			return params;
+		}
+
+		private void extractJsonStrings(JSONObject jsonObject, String parent, List<NameValuePair> params) {
+			for (Object key : jsonObject.keySet()) {
+				Object obj = jsonObject.get(key);
+				if (obj instanceof JSONObject) {
+					extractJsonStrings((JSONObject) obj, normalisedKey(parent, (String) key), params);
+				} else if (obj instanceof String) {
+					params.add(new DefaultNameValuePair(normalisedKey(parent, (String) key), (String) obj));
+				}
+			}
+		}
+
+		private String normalisedKey(String parent, String key) {
+			return parent.isEmpty() ? key : parent + "." + key;
+		}
+
+		@Override
+		protected String replaceParameterValue(String originalString, NameValuePair parameter, String replaceString) {
+			if (jsonObject == null) {
+				return originalString;
+			}
+
+			setValue(jsonObject, parameter.getName().split("\\."), 0, replaceString);
+			return jsonObject.toString();
+		}
+	}
+
+	private static void setValue(JSONObject jsonObject, String[] keys, int idx, String value) {
+		Object obj = jsonObject.get(keys[idx]);
+		if (obj instanceof JSONObject) {
+			setValue((JSONObject) obj, keys, idx + 1, value);
+		} else if (obj instanceof String) {
+			jsonObject.put(keys[idx], value);
+		}
+	}
+
+	@Override
+	public boolean isTypeForMethod(AuthenticationMethod method) {
+		return method instanceof JsonBasedAuthenticationMethod;
+	}
+
+	@Override
+	public JsonBasedAuthenticationMethod createAuthenticationMethod(int contextId) {
+		return new JsonBasedAuthenticationMethod();
+	}
+
+	@Override
+	public AbstractAuthenticationMethodOptionsPanel buildOptionsPanel(Context uiSharedContext) {
+		return new JsonBasedAuthenticationMethodOptionsPanel(uiSharedContext);
+	}
+
+}
diff --git a/src/org/zaproxy/zap/authentication/PostBasedAuthenticationMethodType.java b/src/org/zaproxy/zap/authentication/PostBasedAuthenticationMethodType.java
new file mode 100644
index 000000000..e5001fdf1
--- /dev/null
+++ b/src/org/zaproxy/zap/authentication/PostBasedAuthenticationMethodType.java
@@ -0,0 +1,1037 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2018 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.authentication;
+
+import java.awt.Component;
+import java.awt.GridBagLayout;
+import java.awt.event.FocusAdapter;
+import java.awt.event.FocusEvent;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.UnaryOperator;
+
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.ImageIcon;
+import javax.swing.JButton;
+import javax.swing.JComboBox;
+import javax.swing.JLabel;
+import javax.swing.JList;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.border.Border;
+import javax.swing.border.EmptyBorder;
+import javax.swing.plaf.basic.BasicComboBoxRenderer;
+
+import net.sf.json.JSONObject;
+
+import org.apache.commons.configuration.Configuration;
+import org.apache.commons.configuration.ConfigurationException;
+import org.apache.commons.httpclient.URI;
+import org.apache.commons.httpclient.URIException;
+import org.apache.log4j.Logger;
+import org.parosproxy.paros.Constant;
+import org.parosproxy.paros.control.Control;
+import org.parosproxy.paros.db.DatabaseException;
+import org.parosproxy.paros.db.RecordContext;
+import org.parosproxy.paros.extension.ExtensionHook;
+import org.parosproxy.paros.model.Model;
+import org.parosproxy.paros.model.Session;
+import org.parosproxy.paros.model.SiteNode;
+import org.parosproxy.paros.network.HttpHeader;
+import org.parosproxy.paros.network.HttpMalformedHeaderException;
+import org.parosproxy.paros.network.HttpMessage;
+import org.parosproxy.paros.network.HttpRequestHeader;
+import org.parosproxy.paros.network.HttpSender;
+import org.parosproxy.paros.view.SessionDialog;
+import org.parosproxy.paros.view.View;
+import org.zaproxy.zap.authentication.UsernamePasswordAuthenticationCredentials.UsernamePasswordAuthenticationCredentialsOptionsPanel;
+import org.zaproxy.zap.extension.api.ApiDynamicActionImplementor;
+import org.zaproxy.zap.extension.api.ApiException;
+import org.zaproxy.zap.extension.api.ApiResponse;
+import org.zaproxy.zap.extension.authentication.AuthenticationAPI;
+import org.zaproxy.zap.extension.authentication.ContextAuthenticationPanel;
+import org.zaproxy.zap.extension.users.ExtensionUserManagement;
+import org.zaproxy.zap.model.Context;
+import org.zaproxy.zap.model.NameValuePair;
+import org.zaproxy.zap.session.SessionManagementMethod;
+import org.zaproxy.zap.session.WebSession;
+import org.zaproxy.zap.users.User;
+import org.zaproxy.zap.utils.ApiUtils;
+import org.zaproxy.zap.utils.ZapTextField;
+import org.zaproxy.zap.view.LayoutHelper;
+import org.zaproxy.zap.view.NodeSelectDialog;
+import org.zaproxy.zap.view.popup.PopupMenuItemContext;
+import org.zaproxy.zap.view.popup.PopupMenuItemSiteNodeContextMenuFactory;
+
+/**
+ * An {@link AuthenticationMethodType} where the Users are authenticated by POSTing the username and password.
+ * <p>
+ * The actual format of the POST body is defined by extending classes.
+ * 
+ * @since TODO add version
+ */
+public abstract class PostBasedAuthenticationMethodType extends AuthenticationMethodType {
+
+	private static final String CONTEXT_CONFIG_AUTH_FORM = AuthenticationMethod.CONTEXT_CONFIG_AUTH + ".form";
+	private static final String CONTEXT_CONFIG_AUTH_FORM_LOGINURL = CONTEXT_CONFIG_AUTH_FORM + ".loginurl";
+	private static final String CONTEXT_CONFIG_AUTH_FORM_LOGINBODY = CONTEXT_CONFIG_AUTH_FORM + ".loginbody";
+
+	private static final String POST_DATA_LABEL = Constant.messages
+			.getString("authentication.method.pb.field.label.postData");
+	private static final String POST_DATA_REQUIRED_LABEL = Constant.messages
+			.getString("authentication.method.pb.field.label.postDataRequired");
+	private static final String USERNAME_PARAM_LABEL = Constant.messages
+			.getString("authentication.method.pb.field.label.usernameParam");
+	private static final String PASSWORD_PARAM_LABEL = Constant.messages
+			.getString("authentication.method.pb.field.label.passwordParam");
+	private static final String LOGIN_URL_LABEL = Constant.messages
+			.getString("authentication.method.pb.field.label.loginUrl");
+	private static final String AUTH_DESCRIPTION = Constant.messages
+			.getString("authentication.method.pb.field.label.description");
+
+	private static final Logger LOGGER = Logger.getLogger(PostBasedAuthenticationMethodType.class);
+
+	private final String methodName;
+	private final int methodIdentifier;
+	private final String apiMethodName;
+	private final String labelPopupMenuKey;
+	private final boolean postDataRequired;
+
+	/**
+	 * Constructs a {@code PostBasedAuthenticationMethodType} with the given data.
+	 *
+	 * @param methodName the name of the authentication method, should not be {@code null}.
+	 * @param methodIdentifier the ID of the authentication method.
+	 * @param apiMethodName the API name of the authentication method, should not be {@code null}.
+	 * @param labelPopupMenuKey the name of the menu item that flags the request as login.
+	 * @param postDataRequired {@code true} if the POST data is required by the authentication method, {@code false} otherwise.
+	 */
+	protected PostBasedAuthenticationMethodType(
+			String methodName,
+			int methodIdentifier,
+			String apiMethodName,
+			String labelPopupMenuKey,
+			boolean postDataRequired) {
+		this.methodName = methodName;
+		this.methodIdentifier = methodIdentifier;
+		this.apiMethodName = apiMethodName;
+		this.labelPopupMenuKey = labelPopupMenuKey;
+		this.postDataRequired = postDataRequired;
+	}
+
+	/**
+	 * An {@link AuthenticationMethod} where the Users are authenticated by POSTing the username and password.
+	 * <p>
+	 * The actual format of the POST body is defined by extending classes.
+	 */
+	public abstract class PostBasedAuthenticationMethod extends AuthenticationMethod {
+
+		private static final String LOGIN_ICON_RESOURCE = "/resource/icon/fugue/door-open-green-arrow.png";
+		public static final String MSG_USER_PATTERN = "{%username%}";
+		public static final String MSG_PASS_PATTERN = "{%password%}";
+
+		private final String contentType;
+		private final UnaryOperator<String> paramEncoder;
+
+		private HttpSender httpSender;
+		private SiteNode markedLoginSiteNode;
+		private SiteNode loginSiteNode = null;
+		private String loginRequestURL;
+		private String loginRequestBody;
+
+		/**
+		 * Constructs a {@code PostBasedAuthenticationMethod} with the given data.
+		 * 
+		 * @param contentType the value of the Content-Type, to be added to the authentication message.
+		 * @param paramEncoder the encoder to be used on the authentication credentials set in the POST body.
+		 * @param authenticationMethod the authentication method to copy from, might be {@code null}.
+		 */
+		protected PostBasedAuthenticationMethod(
+				String contentType,
+				UnaryOperator<String> paramEncoder,
+				PostBasedAuthenticationMethod authenticationMethod) {
+			this.contentType = contentType + "; charset=utf-8";
+			this.paramEncoder = paramEncoder;
+			if (authenticationMethod != null) {
+				this.loginRequestURL = authenticationMethod.loginRequestURL;
+				this.loginRequestBody = authenticationMethod.loginRequestBody;
+				this.loginSiteNode = authenticationMethod.loginSiteNode;
+				this.markedLoginSiteNode = authenticationMethod.markedLoginSiteNode;
+			}
+		}
+
+		@Override
+		public boolean isConfigured() {
+			if (postDataRequired) {
+				if (loginRequestBody == null || loginRequestBody.isEmpty()) {
+					return false;
+				}
+			}
+
+			// check if the login url is valid
+			return loginRequestURL != null && !loginRequestURL.isEmpty();
+		}
+
+		@Override
+		public AuthenticationCredentials createAuthenticationCredentials() {
+			return new UsernamePasswordAuthenticationCredentials();
+		}
+
+		protected HttpSender getHttpSender() {
+			if (this.httpSender == null) {
+				this.httpSender = new HttpSender(Model.getSingleton().getOptionsParam().getConnectionParam(),
+						true, HttpSender.AUTHENTICATION_INITIATOR);
+			}
+			return httpSender;
+		}
+
+		/**
+		 * Prepares a request message, by filling the appropriate 'username' and 'password' fields
+		 * in the request URI and the POST data, if any.
+		 * 
+		 * @param credentials the credentials
+		 * @return the HTTP message prepared for authentication
+		 * @throws URIException if failed to create the request URI
+		 * @throws HttpMalformedHeaderException if the constructed HTTP request is malformed
+		 * @throws DatabaseException if an error occurred while reading the request from database
+		 */
+		protected HttpMessage prepareRequestMessage(UsernamePasswordAuthenticationCredentials credentials)
+				throws URIException, HttpMalformedHeaderException, DatabaseException {
+
+			URI requestURI = createLoginUrl(loginRequestURL, credentials.getUsername(), credentials.getPassword());
+
+			// Replace the username and password in the post data of the request, if needed
+			String requestBody = null;
+			if (loginRequestBody != null && !loginRequestBody.isEmpty()) {
+				requestBody = replaceUserData(loginRequestBody, credentials.getUsername(), credentials.getPassword(), paramEncoder);
+			}
+
+			// Prepare the actual message, either based on the existing one, or create a new one
+			HttpMessage requestMessage;
+			if (this.loginSiteNode != null) {
+				// TODO: What happens if the SiteNode was deleted?
+				requestMessage = loginSiteNode.getHistoryReference().getHttpMessage().cloneRequest();
+				requestMessage.getRequestHeader().setURI(requestURI);
+				if (requestBody != null) {
+					requestMessage.getRequestBody().setBody(requestBody);
+					requestMessage.getRequestHeader().setHeader(HttpHeader.CONTENT_LENGTH, null);
+				}
+			} else {
+				String method = (requestBody != null) ? HttpRequestHeader.POST : HttpRequestHeader.GET;
+				requestMessage = new HttpMessage();
+				requestMessage.setRequestHeader(
+						new HttpRequestHeader(method, requestURI, HttpHeader.HTTP10,
+								Model.getSingleton().getOptionsParam().getConnectionParam()));
+				if (requestBody != null) {
+					requestMessage.getRequestHeader().setHeader(HttpHeader.CONTENT_TYPE, contentType);
+					requestMessage.getRequestBody().setBody(requestBody);
+				}
+			}
+
+			return requestMessage;
+		}
+
+		@Override
+		public WebSession authenticate(SessionManagementMethod sessionManagementMethod,
+				AuthenticationCredentials credentials, User user)
+				throws AuthenticationMethod.UnsupportedAuthenticationCredentialsException {
+
+			// type check
+			if (!(credentials instanceof UsernamePasswordAuthenticationCredentials)) {
+				throw new UnsupportedAuthenticationCredentialsException(
+						"Post based authentication method only supports "
+								+ UsernamePasswordAuthenticationCredentials.class.getSimpleName()
+								+ ". Received: " + credentials.getClass());
+			}
+			UsernamePasswordAuthenticationCredentials cred = (UsernamePasswordAuthenticationCredentials) credentials;
+
+			if (!cred.isConfigured()) {
+				LOGGER.warn("No credentials to authenticate user: " + user.getName());
+				return null;
+			}
+			
+			// Prepare login message
+			HttpMessage msg;
+			try {
+				msg = prepareRequestMessage(cred);
+			} catch (Exception e) {
+				LOGGER.error("Unable to prepare authentication message: " + e.getMessage(), e);
+				return null;
+			}
+
+			// Make sure the message will be sent with a good WebSession that can record the changes
+			if (user.getAuthenticatedSession() == null)
+				user.setAuthenticatedSession(sessionManagementMethod.createEmptyWebSession());
+			msg.setRequestingUser(user);
+
+			// Clear any session identifiers
+			msg.getRequestHeader().setHeader(HttpRequestHeader.COOKIE, null);
+
+			if (LOGGER.isDebugEnabled()) {
+				LOGGER.debug("Authentication request header: \n" + msg.getRequestHeader());
+				if (!msg.getRequestHeader().getMethod().equals(HttpRequestHeader.GET))
+					LOGGER.debug("Authentication request body: \n" + msg.getRequestBody());
+			}
+
+			// Send the authentication message
+			try {
+				getHttpSender().sendAndReceive(msg);
+			} catch (IOException e) {
+				LOGGER.error("Unable to send authentication message: " + e.getMessage());
+				return null;
+			}
+			if (this.isAuthenticated(msg)) {
+				// Let the user know it worked
+				AuthenticationHelper.notifyOutputAuthSuccessful(msg);
+			} else {
+				// Let the user know it failed
+				AuthenticationHelper.notifyOutputAuthFailure(msg);
+			}
+
+			// Add message to history
+			AuthenticationHelper.addAuthMessageToHistory(msg);
+
+			// Return the web session as extracted by the session management method
+			return sessionManagementMethod.extractWebSession(msg);
+		}
+
+		/**
+		 * Sets the login request as being an existing SiteNode.
+		 * 
+		 * @param loginSiteNode the new login request
+		 * @throws Exception if an error occurred while obtaining the message from the node
+		 */
+		public void setLoginRequest(SiteNode loginSiteNode) throws Exception {
+			this.loginSiteNode = loginSiteNode;
+
+			HttpMessage requestMessage = loginSiteNode.getHistoryReference().getHttpMessage();
+			this.loginRequestURL = requestMessage.getRequestHeader().getURI().toString();
+			if (!requestMessage.getRequestHeader().getMethod().equalsIgnoreCase(HttpRequestHeader.GET)) {
+				this.loginRequestBody = requestMessage.getRequestBody().toString();
+			} else {
+				this.loginRequestBody = null;
+			}
+		}
+
+		/**
+		 * Gets the login request url.
+		 * 
+		 * @return the login request url
+		 */
+		public String getLoginRequestURL() {
+			return loginRequestURL;
+		}
+
+		/**
+		 * Marks the provided Site Login as being a Login request. If {@code null} is provided, no
+		 * site node will be marked as login request (for the {@link Context} corresponding to this
+		 * AuthenticationMethod).
+		 * 
+		 * @param sn the new login site node
+		 */
+		private void markLoginSiteNode(SiteNode sn) {
+			// No need for resetting everything up if it's already the right node
+			if (this.markedLoginSiteNode == sn) {
+				return;
+			}
+			if (this.markedLoginSiteNode != null) {
+				this.markedLoginSiteNode.removeCustomIcon(LOGIN_ICON_RESOURCE);
+			}
+
+			this.markedLoginSiteNode = sn;
+			if (sn == null) {
+				return;
+			}
+			sn.addCustomIcon(LOGIN_ICON_RESOURCE, false);
+		}
+
+		/**
+		 * Sets the login request, based on a given url and, if needed, post data. If post data is
+		 * provided, the assumed HTTP method is POST.
+		 * <p>
+		 * If there is a SiteNode that matches the URL and post data (with the exception of the
+		 * 'username' and 'password' parameters), it is marked as the 'Login' site node.
+		 * </p>
+		 * 
+		 * @param url the url
+		 * @param postData the post data, or {@code null} if the request should be a GET one
+		 * @throws Exception the exception
+		 */
+		protected void setLoginRequest(String url, String postData) throws Exception {
+			if (url == null || url.length() == 0) {
+				this.loginRequestURL = null;
+				this.loginRequestBody = null;
+				this.loginSiteNode = null;
+			} else {
+				String method = HttpRequestHeader.GET;
+				if (postData != null && postData.length() > 0) {
+					method = HttpRequestHeader.POST;
+				}
+
+				this.loginRequestURL = url;
+				this.loginRequestBody = postData;
+
+				URI uri = createLoginUrl(loginRequestURL, "", "");
+				// Note: The findNode just checks the parameter names, not their values
+				// Note: No need to make sure the other parameters (besides user/password) are the
+				// same, as POSTs with different values are not delimited in the SitesTree anyway
+				// Note: Set the login site node anyway (even if null), to make sure any previously
+				// marked SiteNode is unmarked
+				this.loginSiteNode = Model.getSingleton().getSession().getSiteTree()
+						.findNode(uri, method, postData);
+			}
+
+		}
+
+		@Override
+		public String toString() {
+			return getClass().getSimpleName() + " [loginURI=" + loginRequestURL + "]";
+		}
+
+		@Override
+		public void onMethodPersisted() {
+			markLoginSiteNode(loginSiteNode);
+		}
+
+		@Override
+		public void onMethodDiscarded() {
+			markLoginSiteNode(null);
+		}
+
+		@Override
+		public ApiResponse getApiResponseRepresentation() {
+			Map<String, String> values = new HashMap<>();
+			values.put("methodName", apiMethodName);
+			values.put("loginUrl", loginRequestURL);
+			values.put("loginRequestData", this.loginRequestBody);
+			return new AuthMethodApiResponseRepresentation<>(values);
+		}
+
+		@Override
+		public int hashCode() {
+			final int prime = 31;
+			int result = super.hashCode();
+			result = prime * result + ((loginRequestBody == null) ? 0 : loginRequestBody.hashCode());
+			result = prime * result + ((loginRequestURL == null) ? 0 : loginRequestURL.hashCode());
+			return result;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (!super.equals(obj))
+				return false;
+			if (getClass() != obj.getClass())
+				return false;
+			PostBasedAuthenticationMethod other = (PostBasedAuthenticationMethod) obj;
+			if (loginRequestBody == null) {
+				if (other.loginRequestBody != null)
+					return false;
+			} else if (!loginRequestBody.equals(other.loginRequestBody))
+				return false;
+			if (loginRequestURL == null) {
+				if (other.loginRequestURL != null)
+					return false;
+			} else if (!loginRequestURL.equals(other.loginRequestURL))
+				return false;
+			return true;
+		}
+	}
+
+	private static URI createLoginUrl(String loginData, String username, String password) throws URIException {
+		return new URI(replaceUserData(loginData, username, password, PostBasedAuthenticationMethodType::encodeParameter), true);
+	}
+
+	private static String replaceUserData(String loginData, String username, String password, UnaryOperator<String> encoder) {
+		return loginData.replace(PostBasedAuthenticationMethod.MSG_USER_PATTERN, encoder.apply(username))
+				.replace(PostBasedAuthenticationMethod.MSG_PASS_PATTERN, encoder.apply(password));
+	}
+
+	private static String encodeParameter(String parameter) {
+		try {
+			return URLEncoder.encode(parameter, "UTF-8");
+		} catch (UnsupportedEncodingException ignore) {
+			// UTF-8 is one of the standard charsets (see StandardCharsets.UTF_8).
+		}
+		return "";
+	}
+
+	private static boolean isValidLoginUrl(String loginUrl) {
+		if (loginUrl.isEmpty()) {
+			return false;
+		}
+
+		try {
+			createLoginUrl(loginUrl, "", "");
+			return true;
+		} catch (Exception e) {
+			return false;
+		}
+	}
+
+	/**
+	 * The Options Panel used for configuring a {@link PostBasedAuthenticationMethod}.
+	 */
+	protected abstract class PostBasedAuthenticationMethodOptionsPanel extends
+			AbstractAuthenticationMethodOptionsPanel {
+
+		private static final long serialVersionUID = 1L;
+
+		private ZapTextField loginUrlField;
+		private ZapTextField postDataField;
+		private JComboBox<NameValuePair> usernameParameterCombo;
+		private JComboBox<NameValuePair> passwordParameterCombo;
+		private PostBasedAuthenticationMethod authenticationMethod;
+
+		private Context context;
+		private ExtensionUserManagement userExt = null;
+
+		private final UnaryOperator<String> paramDecoder;
+
+		public PostBasedAuthenticationMethodOptionsPanel(Context context, UnaryOperator<String> paramDecoder) {
+			super();
+			initialize();
+			this.context = context;
+			this.paramDecoder = paramDecoder;
+		}
+
+		@SuppressWarnings("unchecked")
+		private void initialize() {
+			this.setLayout(new GridBagLayout());
+
+			this.add(new JLabel(LOGIN_URL_LABEL), LayoutHelper.getGBC(0, 0, 2, 1.0d, 0.0d));
+
+			JPanel urlSelectPanel = new JPanel(new GridBagLayout());
+
+			this.loginUrlField = new ZapTextField();
+			this.postDataField = new ZapTextField();
+
+			JButton selectButton = new JButton(Constant.messages.getString("all.button.select"));
+			selectButton.setIcon(new ImageIcon(View.class.getResource("/resource/icon/16/094.png"))); // Globe
+
+			// Add behaviour for Node Select dialog
+			selectButton.addActionListener(new java.awt.event.ActionListener() {
+				@Override
+				public void actionPerformed(java.awt.event.ActionEvent e) {
+					NodeSelectDialog nsd = new NodeSelectDialog(View.getSingleton().getMainFrame());
+					// Try to pre-select the node according to what has been inserted in the fields
+					SiteNode node = null;
+					if (loginUrlField.getText().trim().length() > 0)
+						try {
+							// If it's a POST query
+							if (postDataField.getText().trim().length() > 0)
+								node = Model
+										.getSingleton()
+										.getSession()
+										.getSiteTree()
+										.findNode(new URI(loginUrlField.getText(), false),
+												HttpRequestHeader.POST, postDataField.getText());
+							else
+								node = Model.getSingleton().getSession().getSiteTree()
+										.findNode(new URI(loginUrlField.getText(), false));
+						} catch (Exception e2) {
+							// Ignore. It means we could not properly get a node for the existing
+							// value and does not have any harmful effects
+						}
+
+					// Show the dialog and wait for input
+					node = nsd.showDialog(node);
+					if (node != null && node.getHistoryReference() != null) {
+						try {
+							if (LOGGER.isInfoEnabled()) {
+								LOGGER.info("Selected Post Based Auth Login URL via dialog: "
+										+ node.getHistoryReference().getURI().toString());
+							}
+
+							loginUrlField.setText(node.getHistoryReference().getURI().toString());
+							postDataField.setText(node.getHistoryReference().getHttpMessage()
+									.getRequestBody().toString());
+							updateParameters();
+						} catch (Exception e1) {
+							LOGGER.error(e1.getMessage(), e1);
+						}
+					}
+				}
+			});
+
+			urlSelectPanel.add(this.loginUrlField, LayoutHelper.getGBC(0, 0, 1, 1.0D));
+			urlSelectPanel.add(selectButton, LayoutHelper.getGBC(1, 0, 1, 0.0D));
+			this.add(urlSelectPanel, LayoutHelper.getGBC(0, 1, 2, 1.0d, 0.0d));
+
+			this.add(new JLabel(postDataRequired ? POST_DATA_REQUIRED_LABEL : POST_DATA_LABEL), LayoutHelper.getGBC(0, 2, 2, 1.0d, 0.0d));
+			this.add(this.postDataField, LayoutHelper.getGBC(0, 3, 2, 1.0d, 0.0d));
+
+			this.add(new JLabel(USERNAME_PARAM_LABEL), LayoutHelper.getGBC(0, 4, 1, 1.0d, 0.0d));
+			this.usernameParameterCombo = new JComboBox<>();
+			this.usernameParameterCombo.setRenderer(NameValuePairRenderer.INSTANCE);
+			this.add(usernameParameterCombo, LayoutHelper.getGBC(0, 5, 1, 1.0d, 0.0d));
+
+			this.add(new JLabel(PASSWORD_PARAM_LABEL), LayoutHelper.getGBC(1, 4, 1, 1.0d, 0.0d));
+			this.passwordParameterCombo = new JComboBox<>();
+			this.passwordParameterCombo.setRenderer(NameValuePairRenderer.INSTANCE);
+			this.add(passwordParameterCombo, LayoutHelper.getGBC(1, 5, 1, 1.0d, 0.0d));
+
+			this.add(new JLabel(AUTH_DESCRIPTION), LayoutHelper.getGBC(0, 8, 2, 1.0d, 0.0d));
+
+			// Make sure we update the parameters when something has been changed in the
+			// postDataField
+			this.postDataField.addFocusListener(new FocusAdapter() {
+				@Override
+				public void focusLost(FocusEvent e) {
+					updateParameters();
+				}
+			});
+		}
+
+		/**
+		 * Gets the context being configured.
+		 *
+		 * @return the context, never {@code null}.
+		 */
+		protected Context getContext() {
+			return context;
+		}
+
+		@Override
+		public void validateFields() {
+			if (!isValidLoginUrl(loginUrlField.getText())) {
+				loginUrlField.requestFocusInWindow();
+				throw new IllegalStateException(
+						Constant.messages.getString("authentication.method.pb.dialog.error.url.text"));
+			}
+
+			if (postDataRequired && postDataField.getText().isEmpty()) {
+				postDataField.requestFocusInWindow();
+				throw new IllegalStateException(
+						Constant.messages.getString("authentication.method.pb.dialog.error.postData.text"));
+			}
+		}
+
+		protected abstract String replaceParameterValue(String originalString, NameValuePair parameter, String replaceString);
+		
+		private ExtensionUserManagement getUserExt() {
+			if (userExt == null) {
+				userExt = Control.getSingleton().getExtensionLoader().getExtension(ExtensionUserManagement.class);
+				
+			}
+			return userExt;
+		}
+
+		@Override
+		public void saveMethod() {
+			try {
+				String postData = postDataField.getText();
+				if (!postData.isEmpty()) {
+					NameValuePair userParam = (NameValuePair) usernameParameterCombo.getSelectedItem();
+					NameValuePair passwdParam = (NameValuePair) passwordParameterCombo.getSelectedItem();
+					
+					ExtensionUserManagement userExt = getUserExt();
+					if (userExt != null && userExt.getUIConfiguredUsers(context.getIndex()).size() == 0) {
+						String username = userParam.getValue();
+						String password = passwdParam.getValue();
+						if (!username.isEmpty() && !username.contains(PostBasedAuthenticationMethod.MSG_USER_PATTERN)
+								&& !password.contains(PostBasedAuthenticationMethod.MSG_PASS_PATTERN)) {
+							// Add the user based on the details provided
+							String userStr = paramDecoder.apply(username);
+							String passwdStr = paramDecoder.apply(password);
+							if (!userStr.isEmpty() && !passwdStr.isEmpty()) {
+								User user = new User(context.getIndex(), userStr);
+								UsernamePasswordAuthenticationCredentials upac = 
+										new UsernamePasswordAuthenticationCredentials(userStr, passwdStr);
+								user.setAuthenticationCredentials(upac);
+								getUserExt().getContextUserAuthManager(context.getIndex()).addUser(user);
+							}
+						}
+					}
+					
+					postData = this.replaceParameterValue(postData, userParam,
+							PostBasedAuthenticationMethod.MSG_USER_PATTERN);
+					postData = this.replaceParameterValue(postData, passwdParam,
+							PostBasedAuthenticationMethod.MSG_PASS_PATTERN);
+				}
+				getMethod().setLoginRequest(loginUrlField.getText(), postData);
+			} catch (Exception e) {
+				LOGGER.error(e.getMessage(), e);
+			}
+		}
+
+		@Override
+		public void bindMethod(AuthenticationMethod method) {
+			this.authenticationMethod = (PostBasedAuthenticationMethod) method;
+			this.loginUrlField.setText(authenticationMethod.loginRequestURL);
+			this.postDataField.setText(authenticationMethod.loginRequestBody);
+
+			updateParameters();
+		}
+
+		/**
+		 * Gets the index of the parameter with a given value.
+		 * 
+		 * @param params the params
+		 * @param value the value
+		 * @return the index of param with value, or -1 if no match was found
+		 */
+		private int getIndexOfParamWithValue(NameValuePair[] params, String value) {
+			for (int i = 0; i < params.length; i++)
+				if (value.equals(params[i].getValue()))
+					return i;
+			return -1;
+		}
+
+		private void updateParameters() {
+			try {
+				List<NameValuePair> params = extractParameters(this.postDataField.getText());
+				NameValuePair[] paramsArray = params.toArray(new NameValuePair[params.size()]);
+				this.usernameParameterCombo.setModel(new DefaultComboBoxModel<>(paramsArray));
+				this.passwordParameterCombo.setModel(new DefaultComboBoxModel<>(paramsArray));
+
+				int index = getIndexOfParamWithValue(paramsArray,
+						PostBasedAuthenticationMethod.MSG_USER_PATTERN);
+				if (index >= 0) {
+					this.usernameParameterCombo.setSelectedIndex(index);
+				}
+
+				index = getIndexOfParamWithValue(paramsArray, PostBasedAuthenticationMethod.MSG_PASS_PATTERN);
+				if (index >= 0) {
+					this.passwordParameterCombo.setSelectedIndex(index);
+				}
+			} catch (Exception e) {
+				LOGGER.error(e.getMessage(), e);
+			}
+		}
+
+		protected abstract List<NameValuePair> extractParameters(String postData);
+
+		@Override
+		public PostBasedAuthenticationMethod getMethod() {
+			return this.authenticationMethod;
+		}
+	}
+
+	/**
+	 * A renderer for properly displaying the name of a {@link NameValuePair} in a ComboBox.
+	 * 
+	 * @see #INSTANCE
+	 */
+	private static class NameValuePairRenderer extends BasicComboBoxRenderer {
+
+		public static final NameValuePairRenderer INSTANCE = new NameValuePairRenderer();
+
+		private static final long serialVersionUID = 3654541772447187317L;
+		private static final Border BORDER = new EmptyBorder(2, 3, 3, 3);
+
+		private NameValuePairRenderer() {
+		}
+
+		@Override
+		@SuppressWarnings("rawtypes")
+		public Component getListCellRendererComponent(JList list, Object value, int index,
+				boolean isSelected, boolean cellHasFocus) {
+			super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
+			if (value != null) {
+				setBorder(BORDER);
+				NameValuePair item = (NameValuePair) value;
+				setText(item.getName());
+			}
+			return this;
+		}
+	}
+
+	@Override
+	public abstract PostBasedAuthenticationMethod createAuthenticationMethod(int contextId);
+
+	@Override
+	public String getName() {
+		return methodName;
+	}
+
+	@Override
+	public boolean hasOptionsPanel() {
+		return true;
+	}
+
+	@Override
+	public AbstractCredentialsOptionsPanel<? extends AuthenticationCredentials> buildCredentialsOptionsPanel(
+			AuthenticationCredentials credentials, Context uiSharedContext) {
+		return new UsernamePasswordAuthenticationCredentialsOptionsPanel(
+				(UsernamePasswordAuthenticationCredentials) credentials);
+	}
+
+	@Override
+	public boolean hasCredentialsOptionsPanel() {
+		return true;
+	}
+
+	@Override
+	public void hook(ExtensionHook extensionHook) {
+		extensionHook.getHookMenu().addPopupMenuItem(getPopupFlagLoginRequestMenuFactory());
+	}
+
+	/**
+	 * Gets the popup menu factory for flagging login requests.
+	 * 
+	 * @return the popup flag login request menu factory
+	 */
+	private PopupMenuItemSiteNodeContextMenuFactory getPopupFlagLoginRequestMenuFactory() {
+		PopupMenuItemSiteNodeContextMenuFactory popupFlagLoginRequestMenuFactory = new PopupMenuItemSiteNodeContextMenuFactory(
+				Constant.messages.getString("context.flag.popup")) {
+			private static final long serialVersionUID = 8927418764L;
+
+			@Override
+			public PopupMenuItemContext getContextMenu(Context context, String parentMenu) {
+				return new PopupMenuItemContext(context, parentMenu, 
+						Constant.messages.getString(labelPopupMenuKey, context.getName())) {
+
+					private static final long serialVersionUID = 1967885623005183801L;
+					private ExtensionUserManagement usersExtension;
+					private Context uiSharedContext;
+
+					/**
+					 * Make sure the user acknowledges the Users corresponding to this context will
+					 * be deleted.
+					 * 
+					 * @return true, if successful
+					 */
+					private boolean confirmUsersDeletion(Context uiSharedContext) {
+						usersExtension = Control.getSingleton().getExtensionLoader().getExtension(ExtensionUserManagement.class);
+						if (usersExtension != null) {
+							if (usersExtension.getSharedContextUsers(uiSharedContext).size() > 0) {
+								int choice = JOptionPane.showConfirmDialog(this, Constant.messages
+										.getString("authentication.dialog.confirmChange.label"),
+										Constant.messages
+												.getString("authentication.dialog.confirmChange.title"),
+										JOptionPane.OK_CANCEL_OPTION);
+								if (choice == JOptionPane.CANCEL_OPTION) {
+									return false;
+								}
+							}
+						}
+						return true;
+					}
+
+					@Override
+					public void performAction(SiteNode sn) {
+						// Manually create the UI shared contexts so any modifications are done
+						// on an UI shared Context, so changes can be undone by pressing Cancel
+						SessionDialog sessionDialog = View.getSingleton().getSessionDialog();
+						sessionDialog.recreateUISharedContexts(Model.getSingleton().getSession());
+						uiSharedContext = sessionDialog.getUISharedContext(this.getContext().getIndex());
+
+						// Do the work/changes on the UI shared context
+						if (isTypeForMethod(this.getContext().getAuthenticationMethod())) {
+							LOGGER.info("Selected new login request via PopupMenu. Changing existing " + methodName + " instance for Context "
+									+ getContext().getIndex());
+							PostBasedAuthenticationMethod method = (PostBasedAuthenticationMethod) uiSharedContext
+									.getAuthenticationMethod();
+
+							try {
+								method.setLoginRequest(sn);
+							} catch (Exception e) {
+								LOGGER.error("Failed to set login request: " + e.getMessage(), e);
+								return;
+							}
+
+							// Show the session dialog without recreating UI Shared contexts
+							View.getSingleton()
+									.showSessionDialog(
+											Model.getSingleton().getSession(),
+											ContextAuthenticationPanel
+													.buildName(this.getContext().getIndex()), false);
+						} else {
+							LOGGER.info("Selected new login request via PopupMenu. Creating new " + methodName + " instance for Context "
+									+ getContext().getIndex());
+							PostBasedAuthenticationMethod method = createAuthenticationMethod(getContext().getIndex());
+
+							try {
+								method.setLoginRequest(sn);
+							} catch (Exception e) {
+								LOGGER.error("Failed to set login request: " + e.getMessage(), e);
+								return;
+							}
+							if (!confirmUsersDeletion(uiSharedContext)) {
+								LOGGER.debug("Cancelled change of authentication type.");
+								return;
+							}
+							uiSharedContext.setAuthenticationMethod(method);
+
+							// Show the session dialog without recreating UI Shared contexts
+							// NOTE: First init the panels of the dialog so old users data gets
+							// loaded and just then delete the users
+							// from the UI data model, otherwise the 'real' users from the
+							// non-shared context would be loaded
+							// and would override any deletions made.
+							View.getSingleton().showSessionDialog(Model.getSingleton().getSession(),
+									ContextAuthenticationPanel.buildName(this.getContext().getIndex()),
+									false, new Runnable() {
+
+										@Override
+										public void run() {
+											// Removing the users from the 'shared context' (the UI)
+											// will cause their removal at
+											// save as well
+											if (usersExtension != null)
+												usersExtension.removeSharedContextUsers(uiSharedContext);
+										}
+									});
+						}
+					}
+				};
+			}
+
+			@Override
+			public int getParentMenuIndex() {
+				return 3;
+			}
+		};
+		return popupFlagLoginRequestMenuFactory;
+	}
+
+	@Override
+	public AuthenticationMethod loadMethodFromSession(Session session, int contextId) throws DatabaseException {
+		PostBasedAuthenticationMethod method = createAuthenticationMethod(contextId);
+		List<String> urls = session.getContextDataStrings(contextId, RecordContext.TYPE_AUTH_METHOD_FIELD_1);
+		String url = "";
+		if (urls != null && urls.size() > 0) {
+			url = urls.get(0);
+		}
+
+		List<String> postDatas = session.getContextDataStrings(contextId,
+				RecordContext.TYPE_AUTH_METHOD_FIELD_2);
+		String postData = null;
+		if (postDatas != null && postDatas.size() > 0) {
+			postData = postDatas.get(0);
+		}
+
+		try {
+			method.setLoginRequest(url, postData);
+		} catch (Exception e) {
+			LOGGER.error("Unable to load Post based authentication method data:", e);
+		}
+		return method;
+	}
+
+	@Override
+	public void persistMethodToSession(Session session, int contextId, AuthenticationMethod authMethod)
+			throws DatabaseException {
+		if (!(authMethod instanceof PostBasedAuthenticationMethod)) {
+			throw new UnsupportedAuthenticationMethodException(
+					"Post based authentication type only supports: " + PostBasedAuthenticationMethod.class);
+		}
+
+		PostBasedAuthenticationMethod method = (PostBasedAuthenticationMethod) authMethod;
+		session.setContextData(contextId, RecordContext.TYPE_AUTH_METHOD_FIELD_1, method.loginRequestURL);
+		session.setContextData(contextId, RecordContext.TYPE_AUTH_METHOD_FIELD_2, method.loginRequestBody);
+	}
+
+	@Override
+	public int getUniqueIdentifier() {
+		return methodIdentifier;
+	}
+
+	@Override
+	public UsernamePasswordAuthenticationCredentials createAuthenticationCredentials() {
+		return new UsernamePasswordAuthenticationCredentials();
+	}
+
+	/* API related constants and methods. */
+	private static final String PARAM_LOGIN_URL = "loginUrl";
+	private static final String PARAM_LOGIN_REQUEST_DATA = "loginRequestData";
+
+	@Override
+	public ApiDynamicActionImplementor getSetMethodForContextApiAction() {
+		String[] mandatoryParamNames;
+		String[] optionalParamNames;
+		if (postDataRequired) {
+			mandatoryParamNames = new String[] { PARAM_LOGIN_URL, PARAM_LOGIN_REQUEST_DATA };
+			optionalParamNames = null;
+		} else {
+			mandatoryParamNames = new String[] { PARAM_LOGIN_URL };
+			optionalParamNames = new String[] { PARAM_LOGIN_REQUEST_DATA };
+		}
+		return new ApiDynamicActionImplementor(apiMethodName, mandatoryParamNames, optionalParamNames) {
+
+			@Override
+			public void handleAction(JSONObject params) throws ApiException {
+				Context context = ApiUtils.getContextByParamId(params, AuthenticationAPI.PARAM_CONTEXT_ID);
+				String loginUrl = ApiUtils.getNonEmptyStringParam(params, PARAM_LOGIN_URL);
+				if (!isValidLoginUrl(loginUrl)) {
+					throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_LOGIN_URL);
+				}
+				String postData = "";
+				if (postDataRequired) {
+					postData = ApiUtils.getNonEmptyStringParam(params, PARAM_LOGIN_REQUEST_DATA);
+				} else if (params.containsKey(PARAM_LOGIN_REQUEST_DATA)) {
+					postData = params.getString(PARAM_LOGIN_REQUEST_DATA);
+				}
+
+				// Set the method
+				PostBasedAuthenticationMethod method = createAuthenticationMethod(context.getIndex());
+				try {
+					method.setLoginRequest(loginUrl, postData);
+				} catch (Exception e) {
+					throw new ApiException(ApiException.Type.INTERNAL_ERROR, e.getMessage());
+				}
+
+				if (!context.getAuthenticationMethod().isSameType(method))
+					apiChangedAuthenticationMethodForContext(context.getIndex());
+				context.setAuthenticationMethod(method);
+			}
+		};
+	}
+
+	@Override
+	public ApiDynamicActionImplementor getSetCredentialsForUserApiAction() {
+		return UsernamePasswordAuthenticationCredentials.getSetCredentialsForUserApiAction(this);
+	}
+
+	@Override
+	public void exportData(Configuration config, AuthenticationMethod authMethod) {
+		if (!(authMethod instanceof PostBasedAuthenticationMethod)) {
+			throw new UnsupportedAuthenticationMethodException(
+					"Post based authentication type only supports: " + PostBasedAuthenticationMethod.class.getName());
+		}
+		PostBasedAuthenticationMethod method = (PostBasedAuthenticationMethod) authMethod;
+
+		config.setProperty(CONTEXT_CONFIG_AUTH_FORM_LOGINURL, method.loginRequestURL);
+		config.setProperty(CONTEXT_CONFIG_AUTH_FORM_LOGINBODY, method.loginRequestBody);
+	}
+
+	@Override
+	public void importData(Configuration config, AuthenticationMethod authMethod) throws ConfigurationException {
+		if (!(authMethod instanceof PostBasedAuthenticationMethod)) {
+			throw new UnsupportedAuthenticationMethodException(
+					"Post based authentication type only supports: " + PostBasedAuthenticationMethod.class.getName());
+		}
+		PostBasedAuthenticationMethod method = (PostBasedAuthenticationMethod) authMethod;
+		
+		try {
+			method.setLoginRequest(config.getString(CONTEXT_CONFIG_AUTH_FORM_LOGINURL), 
+					config.getString(CONTEXT_CONFIG_AUTH_FORM_LOGINBODY));
+		} catch (Exception e) {
+			throw new ConfigurationException(e);
+		}
+	}
+
+}
diff --git a/src/org/zaproxy/zap/extension/authentication/ExtensionAuthentication.java b/src/org/zaproxy/zap/extension/authentication/ExtensionAuthentication.java
index 4913fff26..3751cd065 100644
--- a/src/org/zaproxy/zap/extension/authentication/ExtensionAuthentication.java
+++ b/src/org/zaproxy/zap/extension/authentication/ExtensionAuthentication.java
@@ -44,6 +44,7 @@ import org.zaproxy.zap.authentication.AuthenticationMethodType;
 import org.zaproxy.zap.authentication.FormBasedAuthenticationMethodType;
 import org.zaproxy.zap.authentication.FormBasedAuthenticationMethodType.FormBasedAuthenticationMethod;
 import org.zaproxy.zap.authentication.HttpAuthenticationMethodType;
+import org.zaproxy.zap.authentication.JsonBasedAuthenticationMethodType;
 import org.zaproxy.zap.authentication.ManualAuthenticationMethodType;
 import org.zaproxy.zap.authentication.ScriptBasedAuthenticationMethodType;
 import org.zaproxy.zap.extension.stdmenus.PopupContextMenuItemFactory;
@@ -202,6 +203,7 @@ public class ExtensionAuthentication extends ExtensionAdaptor implements Context
 		this.authenticationMethodTypes.add(new HttpAuthenticationMethodType());
 		this.authenticationMethodTypes.add(new ManualAuthenticationMethodType());
 		this.authenticationMethodTypes.add(new ScriptBasedAuthenticationMethodType());
+		this.authenticationMethodTypes.add(new JsonBasedAuthenticationMethodType());
 
 		for (AuthenticationMethodType a : authenticationMethodTypes) {
 			a.hook(hook);
