diff --git a/zap/src/main/java/org/parosproxy/paros/core/proxy/ProxyThread.java b/zap/src/main/java/org/parosproxy/paros/core/proxy/ProxyThread.java
index d9dfebe3d..785a59e5d 100644
--- a/zap/src/main/java/org/parosproxy/paros/core/proxy/ProxyThread.java
+++ b/zap/src/main/java/org/parosproxy/paros/core/proxy/ProxyThread.java
@@ -85,12 +85,10 @@
 // ZAP: 2019/06/01 Normalise line endings.
 // ZAP: 2019/06/05 Normalise format/style.
 // ZAP: 2020/11/26 Use Log4j 2 classes for logging.
+// ZAP: 2020/12/09 Rely on the content encodings from the body to decode.
 package org.parosproxy.paros.core.proxy;
 
 import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FilterInputStream;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.NetworkInterface;
@@ -100,12 +98,9 @@ import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.Vector;
-import java.util.regex.Pattern;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.Inflater;
-import java.util.zip.InflaterInputStream;
 import javax.net.ssl.SSLException;
 import org.apache.commons.httpclient.HttpException;
 import org.apache.commons.lang.exception.ExceptionUtils;
@@ -117,6 +112,7 @@ import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.db.RecordHistory;
 import org.parosproxy.paros.model.Model;
 import org.parosproxy.paros.network.ConnectionParam;
+import org.parosproxy.paros.network.HttpBody;
 import org.parosproxy.paros.network.HttpHeader;
 import org.parosproxy.paros.network.HttpInputStream;
 import org.parosproxy.paros.network.HttpMalformedHeaderException;
@@ -566,7 +562,9 @@ public class ProxyThread implements Runnable {
                             getHttpSender().sendAndReceive(msg);
                         }
 
-                        decodeResponseIfNeeded(msg);
+                        if (proxyParam.isAlwaysDecodeGzip()) {
+                            decodeResponseIfNeeded(msg);
+                        }
 
                         if (!notifyOverrideListenersResponseReceived(msg)) {
                             if (!notifyListenerResponseReceive(msg)) {
@@ -624,49 +622,18 @@ public class ProxyThread implements Runnable {
         } while (!isConnectionClose(msg) && !inSocket.isClosed());
     }
 
-    private FilterInputStream buildStreamDecoder(String encoding, ByteArrayInputStream bais)
-            throws IOException {
-        if (encoding.equalsIgnoreCase(HttpHeader.DEFLATE)) {
-            return new InflaterInputStream(bais, new Inflater(true));
-        } else {
-            return new GZIPInputStream(bais);
+    static void decodeResponseIfNeeded(HttpMessage msg) {
+        HttpBody body = msg.getResponseBody();
+        if (body.getContentEncodings().isEmpty() || body.hasContentEncodingErrors()) {
+            return;
         }
-    }
 
-    private void decodeResponseIfNeeded(HttpMessage msg) {
-        String encoding = msg.getResponseHeader().getHeader(HttpHeader.CONTENT_ENCODING);
-        if (proxyParam.isAlwaysDecodeGzip()
-                && encoding != null
-                && !encoding.equalsIgnoreCase(HttpHeader.IDENTITY)) {
-            encoding =
-                    Pattern.compile("^x-", Pattern.CASE_INSENSITIVE)
-                            .matcher(encoding)
-                            .replaceAll("");
-            if (!encoding.equalsIgnoreCase(HttpHeader.DEFLATE)
-                    && !encoding.equalsIgnoreCase(HttpHeader.GZIP)) {
-                log.warn("Unsupported content encoding method: " + encoding);
-                return;
-            }
-            // Uncompress content
-            try (ByteArrayInputStream bais =
-                            new ByteArrayInputStream(msg.getResponseBody().getBytes());
-                    FilterInputStream fis = buildStreamDecoder(encoding, bais);
-                    BufferedInputStream bis = new BufferedInputStream(fis);
-                    ByteArrayOutputStream out = new ByteArrayOutputStream(); ) {
-                int readLength;
-                byte[] readBuffer = new byte[1024];
-                while ((readLength = bis.read(readBuffer, 0, 1024)) != -1) {
-                    out.write(readBuffer, 0, readLength);
-                }
-                msg.setResponseBody(out.toByteArray());
-                msg.getResponseHeader().setHeader(HttpHeader.CONTENT_ENCODING, null);
-                if (msg.getResponseHeader().getHeader(HttpHeader.CONTENT_LENGTH) != null) {
-                    msg.getResponseHeader()
-                            .setHeader(HttpHeader.CONTENT_LENGTH, Integer.toString(out.size()));
-                }
-            } catch (IOException e) {
-                log.error("Unable to uncompress gzip content: " + e.getMessage(), e);
-            }
+        body.setBody(body.getContent());
+        body.setContentEncodings(Collections.emptyList());
+        HttpHeader header = msg.getResponseHeader();
+        header.setHeader(HttpHeader.CONTENT_ENCODING, null);
+        if (header.getHeader(HttpHeader.CONTENT_LENGTH) != null) {
+            header.setContentLength(body.length());
         }
     }
 
diff --git a/zap/src/main/java/org/parosproxy/paros/network/HttpBody.java b/zap/src/main/java/org/parosproxy/paros/network/HttpBody.java
index 85dc9c2c6..3e04ccffe 100644
--- a/zap/src/main/java/org/parosproxy/paros/network/HttpBody.java
+++ b/zap/src/main/java/org/parosproxy/paros/network/HttpBody.java
@@ -27,16 +27,23 @@
 // ZAP: 2019/06/01 Normalise line endings.
 // ZAP: 2019/06/05 Normalise format/style.
 // ZAP: 2020/11/26 Use Log4j 2 classes for logging.
+// ZAP: 2020/12/09 Add content encoding.
 package org.parosproxy.paros.network;
 
+import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.IllegalCharsetNameException;
 import java.nio.charset.StandardCharsets;
 import java.nio.charset.UnsupportedCharsetException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
 import org.apache.commons.lang.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.zaproxy.zap.network.HttpEncoding;
 
 /**
  * Abstract a HTTP body in request or response messages.
@@ -64,9 +71,13 @@ public abstract class HttpBody {
 
     private byte[] body;
     private int pos;
+    private byte[] bodyDecoded;
     private String cachedString;
     private Charset charset;
     private boolean determineCharset = true;
+    private boolean contentEncodingErrors;
+
+    private List<HttpEncoding> encodings = Collections.emptyList();
 
     /** Constructs a {@code HttpBody} with no contents (that is, zero length). */
     public HttpBody() {
@@ -133,7 +144,7 @@ public abstract class HttpBody {
         if (contents == null) {
             return;
         }
-        cachedString = null;
+        resetCachedValues();
 
         body = new byte[contents.length];
         System.arraycopy(contents, 0, body, 0, contents.length);
@@ -144,6 +155,8 @@ public abstract class HttpBody {
     /**
      * Sets the given {@code contents} as the body, using the current charset.
      *
+     * <p>The given contents are encoded with the content encodings set, if any.
+     *
      * <p>If the {@code contents} are {@code null} the call to this method has no effect.
      *
      * <p><strong>Note:</strong> Setting the contents with incorrect charset might lead to data
@@ -151,6 +164,7 @@ public abstract class HttpBody {
      *
      * @param contents the new contents of the body, might be {@code null}
      * @see #setCharset(String)
+     * @see #getContentEncodings()
      */
     public void setBody(String contents) {
         if (contents == null) {
@@ -163,11 +177,32 @@ public abstract class HttpBody {
             charset = determineCharset(contents);
         }
 
-        body = contents.getBytes(getCharsetImpl());
+        bodyDecoded = contents.getBytes(getCharsetImpl());
+        body = encode(bodyDecoded);
 
         pos = body.length;
     }
 
+    protected byte[] encode(byte[] data) {
+        if (encodings.isEmpty()) {
+            return data;
+        }
+
+        byte[] value = data;
+        try {
+            byte[] decoded = value;
+            for (HttpEncoding encoding : encodings) {
+                decoded = encoding.encode(decoded);
+            }
+            contentEncodingErrors = false;
+            return decoded;
+        } catch (IOException e) {
+            log.warn("An error occurred while encoding the body: {}", e.getMessage());
+        }
+        contentEncodingErrors = true;
+        return value;
+    }
+
     /**
      * Determines the {@code Charset} of the given {@code contents}, that are being set to the body.
      *
@@ -261,7 +296,13 @@ public abstract class HttpBody {
         System.arraycopy(contents, 0, body, pos, len);
         pos += len;
 
+        resetCachedValues();
+    }
+
+    private void resetCachedValues() {
         cachedString = null;
+        bodyDecoded = null;
+        contentEncodingErrors = false;
     }
 
     /**
@@ -281,6 +322,8 @@ public abstract class HttpBody {
     /**
      * Appends the given {@code contents} to the body, using the current charset.
      *
+     * <p>The given contents are encoded with the content encodings set, if any.
+     *
      * <p>If the {@code contents} are {@code null} the call to this method has no effect.
      *
      * <p><strong>Note:</strong> Setting the contents with incorrect charset might lead to data
@@ -288,23 +331,34 @@ public abstract class HttpBody {
      *
      * @param contents the contents to append, might be {@code null}
      * @see #setCharset(String)
+     * @see #getContentEncodings()
      */
     public void append(String contents) {
         if (contents == null) {
             return;
         }
-        append(contents.getBytes(getCharsetImpl()));
+
+        byte[] decoded = decode();
+        byte[] contentsBytes = contents.getBytes(getCharsetImpl());
+        byte[] data = new byte[decoded.length + contentsBytes.length];
+        System.arraycopy(decoded, 0, data, 0, decoded.length);
+        System.arraycopy(contentsBytes, 0, data, decoded.length, contentsBytes.length);
+        bodyDecoded = data;
+        setBody(encode(bodyDecoded));
     }
 
     /**
      * Gets the {@code String} representation of the body, using the current charset.
      *
+     * <p>The representation is returned decoded, using the content encodings set, if any.
+     *
      * <p>The {@code String} representation contains only the contents set so far, that is,
      * increasing the length of the body manually (with {@link #HttpBody(int)} or {@link
      * #setLength(int)}) does not affect the string representation.
      *
      * @return the {@code String} representation of the body
      * @see #getCharset()
+     * @see #getContentEncodings()
      */
     @Override
     public String toString() {
@@ -327,7 +381,38 @@ public abstract class HttpBody {
      * @see #getBytes()
      */
     protected String createString(Charset charset) {
-        return new String(getBytes(), 0, getPos(), charset != null ? charset : getCharsetImpl());
+        return new String(decode(), charset != null ? charset : getCharsetImpl());
+    }
+
+    /**
+     * Gets the body decoded, if any content encodings are applied.
+     *
+     * @return the body decoded.
+     * @see #getContentEncodings()
+     */
+    protected byte[] decode() {
+        if (bodyDecoded != null) {
+            return bodyDecoded;
+        }
+
+        bodyDecoded = decodeImpl();
+        return bodyDecoded;
+    }
+
+    private byte[] decodeImpl() {
+        byte[] value = pos != body.length ? Arrays.copyOf(body, pos) : body;
+        try {
+            byte[] decoded = value;
+            for (HttpEncoding encoding : encodings) {
+                decoded = encoding.decode(decoded);
+            }
+            contentEncodingErrors = false;
+            return decoded;
+        } catch (IOException e) {
+            log.warn("An error occurred while decoding the body: {}", e.getMessage());
+        }
+        contentEncodingErrors = true;
+        return value;
     }
 
     /**
@@ -357,6 +442,54 @@ public abstract class HttpBody {
         return body;
     }
 
+    /**
+     * Gets the content of the body as bytes, without any encodings applied (if any).
+     *
+     * <p>The returned array of bytes mustn't be modified. Is returned a reference instead of a copy
+     * to avoid more memory allocations.
+     *
+     * @return the content of the body.
+     * @since TOOD add version
+     * @see #getContentEncodings()
+     * @see #hasContentEncodingErrors()
+     * @see #toString()
+     */
+    public byte[] getContent() {
+        if (encodings.isEmpty()) {
+            return body;
+        }
+        return decode();
+    }
+
+    /**
+     * Tells whether or not the content encodings set to the body have errors (e.g. content
+     * malformed).
+     *
+     * @return {@code true} if there are errors while using the content encodings, {@code false}
+     *     otherwise.
+     * @since TOOD add version
+     * @see #getContent()
+     */
+    public boolean hasContentEncodingErrors() {
+        return contentEncodingErrors;
+    }
+
+    /**
+     * Sets the content of the body as bytes, applying any content encodings of the body, if any.
+     *
+     * @since TOOD add version
+     * @see #getContentEncodings()
+     */
+    public void setContent(byte[] content) {
+        if (content == null) {
+            return;
+        }
+        bodyDecoded = content;
+        body = encode(bodyDecoded);
+        pos = body.length;
+        cachedString = null;
+    }
+
     /**
      * Gets the current length of the body.
      *
@@ -385,7 +518,7 @@ public abstract class HttpBody {
         body = newBody;
 
         if (oldPos > pos) {
-            cachedString = null;
+            resetCachedValues();
         }
     }
 
@@ -449,9 +582,41 @@ public abstract class HttpBody {
         this.cachedString = null;
     }
 
+    /**
+     * Sets the content encodings of the body.
+     *
+     * @param encodings the encodings
+     * @throws NullPointerException if the given list or any of the encodings contained in the list
+     *     are {@code null}.
+     * @since TODO add version
+     */
+    public void setContentEncodings(List<HttpEncoding> encodings) {
+        Objects.requireNonNull(encodings);
+        encodings.forEach(Objects::requireNonNull);
+
+        this.encodings =
+                encodings.isEmpty()
+                        ? Collections.emptyList()
+                        : Collections.unmodifiableList(new ArrayList<>(encodings));
+        resetCachedValues();
+    }
+
+    /**
+     * Gets the content encodings of the body.
+     *
+     * @return the encodings, never {@code null}.
+     * @since TODO add version
+     */
+    public List<HttpEncoding> getContentEncodings() {
+        return encodings;
+    }
+
     @Override
     public int hashCode() {
-        return 31 + Arrays.hashCode(body);
+        final int prime = 31;
+        int result = prime + Arrays.hashCode(body);
+        result = prime * result + Objects.hash(encodings);
+        return result;
     }
 
     @Override
@@ -469,6 +634,6 @@ public abstract class HttpBody {
         if (!Arrays.equals(body, otherBody.body)) {
             return false;
         }
-        return true;
+        return Objects.equals(encodings, otherBody.encodings);
     }
 }
diff --git a/zap/src/main/java/org/parosproxy/paros/network/HttpInputStream.java b/zap/src/main/java/org/parosproxy/paros/network/HttpInputStream.java
index 6732f3e7b..8f82c0595 100644
--- a/zap/src/main/java/org/parosproxy/paros/network/HttpInputStream.java
+++ b/zap/src/main/java/org/parosproxy/paros/network/HttpInputStream.java
@@ -26,6 +26,7 @@
 // ZAP: 2019/06/05 Normalise format/style.
 // ZAP: 2020/08/25 Correctly read chunks of the body.
 // ZAP: 2020/11/26 Use Log4j 2 classes for logging.
+// ZAP: 2020/12/09 Set content encoding to the request body.
 package org.parosproxy.paros.network;
 
 import java.io.BufferedInputStream;
@@ -137,6 +138,8 @@ public class HttpInputStream extends BufferedInputStream {
 
         readBody(contentLength, body);
 
+        HttpMessage.setContentEncodings(httpHeader, body);
+
         return body;
     }
 
diff --git a/zap/src/main/java/org/parosproxy/paros/network/HttpMessage.java b/zap/src/main/java/org/parosproxy/paros/network/HttpMessage.java
index c94ba5c0f..a7a57ba7d 100644
--- a/zap/src/main/java/org/parosproxy/paros/network/HttpMessage.java
+++ b/zap/src/main/java/org/parosproxy/paros/network/HttpMessage.java
@@ -56,10 +56,12 @@
 // ZAP: 2019/12/09 Address deprecation of getHeaders(String) Vector method.
 // ZAP: 2020/07/31 Tidy up parameter methods
 // ZAP: 2020/11/26 Use Log4j 2 classes for logging.
+// ZAP: 2020/12/09 Handle content encodings in request/response bodies.
 package org.parosproxy.paros.network;
 
 import java.net.HttpCookie;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -80,6 +82,9 @@ import org.zaproxy.zap.eventBus.Event;
 import org.zaproxy.zap.extension.httppanel.Message;
 import org.zaproxy.zap.extension.httpsessions.HttpSession;
 import org.zaproxy.zap.model.NameValuePair;
+import org.zaproxy.zap.network.HttpEncoding;
+import org.zaproxy.zap.network.HttpEncodingDeflate;
+import org.zaproxy.zap.network.HttpEncodingGzip;
 import org.zaproxy.zap.network.HttpRequestBody;
 import org.zaproxy.zap.network.HttpResponseBody;
 import org.zaproxy.zap.users.User;
@@ -345,6 +350,8 @@ public class HttpMessage implements Message {
     /**
      * Sets the request body of this message.
      *
+     * <p><strong>Note:</strong> No encodings are set to the request body to match the header.
+     *
      * @param reqBody the new request body
      * @throws IllegalArgumentException if parameter {@code reqBody} is {@code null}.
      */
@@ -367,6 +374,8 @@ public class HttpMessage implements Message {
     /**
      * Sets the response body of this message.
      *
+     * <p><strong>Note:</strong> No encodings are set to the response body to match the header.
+     *
      * @param resBody the new response body
      * @throws IllegalArgumentException if parameter {@code resBody} is {@code null}.
      */
@@ -378,35 +387,122 @@ public class HttpMessage implements Message {
         getResponseBody().setCharset(getResponseHeader().getCharset());
     }
 
+    /**
+     * Sets the given string as the request header.
+     *
+     * <p><strong>Note:</strong> No encodings are set to the request body to match the header.
+     *
+     * @param reqHeader the new request header.
+     * @throws HttpMalformedHeaderException if the given header is malformed.
+     * @see #setContentEncodings(HttpHeader, HttpBody)
+     */
     public void setRequestHeader(String reqHeader) throws HttpMalformedHeaderException {
         HttpRequestHeader newHeader = new HttpRequestHeader(reqHeader);
         setRequestHeader(newHeader);
     }
 
+    /**
+     * Sets the given string as the response header.
+     *
+     * <p><strong>Note:</strong> No encodings are set to the response body to match the header.
+     *
+     * @param resHeader the new response header.
+     * @throws HttpMalformedHeaderException if the given header is malformed.
+     * @see #setContentEncodings(HttpHeader, HttpBody)
+     */
     public void setResponseHeader(String resHeader) throws HttpMalformedHeaderException {
         HttpResponseHeader newHeader = new HttpResponseHeader(resHeader);
         setResponseHeader(newHeader);
     }
 
+    /**
+     * Sets the content encodings defined in the header into the body.
+     *
+     * <p><strong>Note:</strong> Supports only {@code gzip} and {@code deflate}.
+     *
+     * @param header the header.
+     * @param body the body.
+     */
+    public static void setContentEncodings(HttpHeader header, HttpBody body) {
+        String encoding = header.getHeader(HttpHeader.CONTENT_ENCODING);
+        if (encoding == null || encoding.isEmpty()) {
+            body.setContentEncodings(Collections.emptyList());
+            return;
+        }
+
+        List<HttpEncoding> encodings = new ArrayList<>(1);
+        if (encoding.contains(HttpHeader.DEFLATE)) {
+            encodings.add(HttpEncodingDeflate.getSingleton());
+        } else if (encoding.contains(HttpHeader.GZIP)) {
+            encodings.add(HttpEncodingGzip.getSingleton());
+        }
+
+        body.setContentEncodings(encodings);
+    }
+
+    /**
+     * Sets the given string body as the request body.
+     *
+     * <p>The defined request header content encodings are set to the body, the string body will be
+     * encoded accordingly.
+     *
+     * @param body the new body.
+     * @see HttpBody#setContentEncodings(List)
+     */
     public void setRequestBody(String body) {
+        setContentEncodings(getRequestHeader(), getRequestBody());
+
         getRequestBody().setCharset(getRequestHeader().getCharset());
         getRequestBody().setBody(body);
     }
 
+    /**
+     * Sets the given byte body as the request body.
+     *
+     * <p>The defined request header content encodings are set to the body, the byte body is assumed
+     * to be properly encoded.
+     *
+     * @param body the new body.
+     * @see HttpBody#setContentEncodings(List)
+     */
     public void setRequestBody(byte[] body) {
         getRequestBody().setBody(body);
         getRequestBody().setCharset(getRequestHeader().getCharset());
+
+        setContentEncodings(getRequestHeader(), getRequestBody());
     }
 
+    /**
+     * Sets the given string body as the response body.
+     *
+     * <p>The defined response header content encodings are set to the body, the string body will be
+     * encoded accordingly.
+     *
+     * @param body the new body.
+     * @see HttpBody#setContentEncodings(List)
+     */
     public void setResponseBody(String body) {
+        setContentEncodings(getResponseHeader(), getResponseBody());
+
         getResponseBody().setCharset(getResponseHeader().getCharset());
         getResponseBody().setDetermineCharset(getResponseHeader().isText());
         getResponseBody().setBody(body);
     }
 
+    /**
+     * Sets the given byte body as the response body.
+     *
+     * <p>The defined response header content encodings are set to the body, the byte body is
+     * assumed to be properly encoded.
+     *
+     * @param body the new body.
+     * @see HttpBody#setContentEncodings(List)
+     */
     public void setResponseBody(byte[] body) {
         getResponseBody().setBody(body);
         getResponseBody().setCharset(getResponseHeader().getCharset());
+
+        setContentEncodings(getResponseHeader(), getResponseBody());
     }
 
     /**
diff --git a/zap/src/main/java/org/parosproxy/paros/network/HttpSender.java b/zap/src/main/java/org/parosproxy/paros/network/HttpSender.java
index 2cad305c6..704579a6b 100644
--- a/zap/src/main/java/org/parosproxy/paros/network/HttpSender.java
+++ b/zap/src/main/java/org/parosproxy/paros/network/HttpSender.java
@@ -85,6 +85,7 @@
 // ZAP: 2020/04/20 Configure if the names should be resolved or not (Issue 29).
 // ZAP: 2020/09/04 Added AUTHENTICATION_POLL_INITIATOR
 // ZAP: 2020/11/26 Use Log4j 2 classes for logging.
+// ZAP: 2020/12/09 Set content encoding to the response body.
 package org.parosproxy.paros.network;
 
 import java.io.IOException;
@@ -630,13 +631,14 @@ public class HttpSender {
                     null); // replaceAll("Transfer-Encoding: chunked\r\n",
             // "");
             msg.setResponseHeader(resHeader);
-            msg.getResponseBody().setCharset(resHeader.getCharset());
-            msg.getResponseBody().setLength(0);
 
             // ZAP: Do not read response body for Server-Sent Events stream
             // ZAP: Moreover do not set content length to zero
             if (!msg.isEventStream()) {
-                msg.getResponseBody().append(method.getResponseBody());
+                msg.setResponseBody(method.getResponseBody());
+            } else {
+                msg.getResponseBody().setCharset(resHeader.getCharset());
+                msg.getResponseBody().setLength(0);
             }
             msg.setResponseFromTargetHost(true);
 
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/HttpPanelViewModelUtils.java b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/HttpPanelViewModelUtils.java
index 29f90eae0..38036a09e 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/HttpPanelViewModelUtils.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/HttpPanelViewModelUtils.java
@@ -19,27 +19,10 @@
  */
 package org.zaproxy.zap.extension.httppanel.view.impl.models.http;
 
-import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.util.regex.Pattern;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-import org.parosproxy.paros.network.HttpBody;
-import org.parosproxy.paros.network.HttpHeader;
 import org.parosproxy.paros.network.HttpMessage;
 
 public final class HttpPanelViewModelUtils {
 
-    private static final Pattern GZIP_PATTERN =
-            Pattern.compile("\\s*(?:x-)?gzip\\s*", Pattern.CASE_INSENSITIVE);
-
-    private static final Logger logger = LogManager.getLogger(HttpPanelViewModelUtils.class);
-
     private HttpPanelViewModelUtils() {}
 
     public static void updateRequestContentLength(HttpMessage message) {
@@ -84,88 +67,4 @@ public final class HttpPanelViewModelUtils {
 
         return -1;
     }
-
-    public static byte[] getBodyBytes(HttpHeader header, HttpBody body) {
-        if (!isEncoded(header)) {
-            return body.getBytes();
-        }
-
-        try {
-            return decode(body);
-        } catch (IOException e) {
-            logger.debug("Failed to decode the body:", e);
-            return body.getBytes();
-        }
-    }
-
-    private static boolean isEncoded(HttpHeader header) {
-        String encoding = header.getHeader(HttpHeader.CONTENT_ENCODING);
-        return encoding != null && GZIP_PATTERN.matcher(encoding).matches();
-    }
-
-    private static byte[] decode(HttpBody body) throws IOException {
-        try (ByteArrayInputStream bais = new ByteArrayInputStream(body.getBytes());
-                GZIPInputStream gis = new GZIPInputStream(bais);
-                BufferedInputStream bis = new BufferedInputStream(gis);
-                ByteArrayOutputStream out = new ByteArrayOutputStream()) {
-            byte[] buffer = new byte[4096];
-            int len;
-            while ((len = bis.read(buffer)) != -1) {
-                out.write(buffer, 0, len);
-            }
-            return out.toByteArray();
-        }
-    }
-
-    public static String getBodyString(HttpHeader header, HttpBody body) {
-        if (!isEncoded(header)) {
-            return body.toString();
-        }
-
-        try {
-            return new String(decode(body), body.getCharset());
-        } catch (UnsupportedEncodingException ignore) {
-            // Shouldn't happen, the body has a supported charset.
-        } catch (IOException e) {
-            logger.debug("Failed to decode the body:", e);
-        }
-        return body.toString();
-    }
-
-    public static void setBody(HttpHeader header, HttpBody body, String value) {
-        body.setCharset(header.getCharset());
-
-        if (!isEncoded(header)) {
-            body.setBody(value);
-            return;
-        }
-
-        try {
-            setBodyGzip(header, body, value.getBytes(body.getCharset()));
-        } catch (UnsupportedEncodingException ignore) {
-            // Shouldn't happen, the body has a supported charset.
-        }
-    }
-
-    private static void setBodyGzip(HttpHeader header, HttpBody body, byte[] value) {
-        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                GZIPOutputStream gis = new GZIPOutputStream(baos, true)) {
-            gis.write(value);
-            gis.finish();
-            body.setBody(baos.toByteArray());
-        } catch (IOException e) {
-            logger.error("Failed to encode and set the body:", e);
-        }
-    }
-
-    public static void setBody(HttpHeader header, HttpBody body, byte[] value) {
-        body.setCharset(header.getCharset());
-
-        if (!isEncoded(header)) {
-            body.setBody(value);
-            return;
-        }
-
-        setBodyGzip(header, body, value);
-    }
 }
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestBodyByteHttpPanelViewModel.java b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestBodyByteHttpPanelViewModel.java
index 596fa32bf..67e12eb38 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestBodyByteHttpPanelViewModel.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestBodyByteHttpPanelViewModel.java
@@ -20,7 +20,6 @@
 package org.zaproxy.zap.extension.httppanel.view.impl.models.http.request;
 
 import org.zaproxy.zap.extension.httppanel.view.impl.models.http.AbstractHttpByteHttpPanelViewModel;
-import org.zaproxy.zap.extension.httppanel.view.impl.models.http.HttpPanelViewModelUtils;
 
 public class RequestBodyByteHttpPanelViewModel extends AbstractHttpByteHttpPanelViewModel {
 
@@ -30,8 +29,7 @@ public class RequestBodyByteHttpPanelViewModel extends AbstractHttpByteHttpPanel
             return new byte[0];
         }
 
-        return HttpPanelViewModelUtils.getBodyBytes(
-                httpMessage.getRequestHeader(), httpMessage.getRequestBody());
+        return httpMessage.getRequestBody().getContent();
     }
 
     @Override
@@ -40,7 +38,6 @@ public class RequestBodyByteHttpPanelViewModel extends AbstractHttpByteHttpPanel
             return;
         }
 
-        HttpPanelViewModelUtils.setBody(
-                httpMessage.getRequestHeader(), httpMessage.getRequestBody(), data);
+        httpMessage.getRequestBody().setContent(data);
     }
 }
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestBodyStringHttpPanelViewModel.java b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestBodyStringHttpPanelViewModel.java
index 1091f0d57..e8e504aea 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestBodyStringHttpPanelViewModel.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestBodyStringHttpPanelViewModel.java
@@ -20,7 +20,6 @@
 package org.zaproxy.zap.extension.httppanel.view.impl.models.http.request;
 
 import org.zaproxy.zap.extension.httppanel.view.impl.models.http.AbstractHttpStringHttpPanelViewModel;
-import org.zaproxy.zap.extension.httppanel.view.impl.models.http.HttpPanelViewModelUtils;
 
 public class RequestBodyStringHttpPanelViewModel extends AbstractHttpStringHttpPanelViewModel {
 
@@ -30,8 +29,7 @@ public class RequestBodyStringHttpPanelViewModel extends AbstractHttpStringHttpP
             return "";
         }
 
-        return HttpPanelViewModelUtils.getBodyString(
-                httpMessage.getRequestHeader(), httpMessage.getRequestBody());
+        return httpMessage.getRequestBody().toString();
     }
 
     @Override
@@ -40,7 +38,6 @@ public class RequestBodyStringHttpPanelViewModel extends AbstractHttpStringHttpP
             return;
         }
 
-        HttpPanelViewModelUtils.setBody(
-                httpMessage.getRequestHeader(), httpMessage.getRequestBody(), data);
+        httpMessage.getRequestBody().setBody(data);
     }
 }
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestStringHttpPanelViewModel.java b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestStringHttpPanelViewModel.java
index 72f0adb12..7e58c7858 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestStringHttpPanelViewModel.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/request/RequestStringHttpPanelViewModel.java
@@ -26,7 +26,6 @@ import org.parosproxy.paros.network.HttpHeader;
 import org.parosproxy.paros.network.HttpMalformedHeaderException;
 import org.zaproxy.zap.extension.httppanel.InvalidMessageDataException;
 import org.zaproxy.zap.extension.httppanel.view.impl.models.http.AbstractHttpStringHttpPanelViewModel;
-import org.zaproxy.zap.extension.httppanel.view.impl.models.http.HttpPanelViewModelUtils;
 
 public class RequestStringHttpPanelViewModel extends AbstractHttpStringHttpPanelViewModel {
 
@@ -40,8 +39,7 @@ public class RequestStringHttpPanelViewModel extends AbstractHttpStringHttpPanel
         }
 
         return httpMessage.getRequestHeader().toString().replaceAll(HttpHeader.CRLF, HttpHeader.LF)
-                + HttpPanelViewModelUtils.getBodyString(
-                        httpMessage.getRequestHeader(), httpMessage.getRequestBody());
+                + httpMessage.getRequestBody().toString();
     }
 
     @Override
@@ -66,7 +64,6 @@ public class RequestStringHttpPanelViewModel extends AbstractHttpStringHttpPanel
         if (parts.length > 1) {
             body = data.substring(parts[0].length() + 2);
         }
-        HttpPanelViewModelUtils.setBody(
-                httpMessage.getRequestHeader(), httpMessage.getRequestBody(), body);
+        httpMessage.getRequestBody().setBody(body);
     }
 }
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseBodyByteHttpPanelViewModel.java b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseBodyByteHttpPanelViewModel.java
index 1a4470790..83f7a50ad 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseBodyByteHttpPanelViewModel.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseBodyByteHttpPanelViewModel.java
@@ -20,7 +20,6 @@
 package org.zaproxy.zap.extension.httppanel.view.impl.models.http.response;
 
 import org.zaproxy.zap.extension.httppanel.view.impl.models.http.AbstractHttpByteHttpPanelViewModel;
-import org.zaproxy.zap.extension.httppanel.view.impl.models.http.HttpPanelViewModelUtils;
 
 public class ResponseBodyByteHttpPanelViewModel extends AbstractHttpByteHttpPanelViewModel {
 
@@ -30,8 +29,7 @@ public class ResponseBodyByteHttpPanelViewModel extends AbstractHttpByteHttpPane
             return new byte[0];
         }
 
-        return HttpPanelViewModelUtils.getBodyBytes(
-                httpMessage.getResponseHeader(), httpMessage.getResponseBody());
+        return httpMessage.getResponseBody().getContent();
     }
 
     @Override
@@ -40,7 +38,6 @@ public class ResponseBodyByteHttpPanelViewModel extends AbstractHttpByteHttpPane
             return;
         }
 
-        HttpPanelViewModelUtils.setBody(
-                httpMessage.getResponseHeader(), httpMessage.getResponseBody(), data);
+        httpMessage.getResponseBody().setContent(data);
     }
 }
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseBodyStringHttpPanelViewModel.java b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseBodyStringHttpPanelViewModel.java
index 73891d3b4..26f1fe9ae 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseBodyStringHttpPanelViewModel.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseBodyStringHttpPanelViewModel.java
@@ -20,7 +20,6 @@
 package org.zaproxy.zap.extension.httppanel.view.impl.models.http.response;
 
 import org.zaproxy.zap.extension.httppanel.view.impl.models.http.AbstractHttpStringHttpPanelViewModel;
-import org.zaproxy.zap.extension.httppanel.view.impl.models.http.HttpPanelViewModelUtils;
 
 public class ResponseBodyStringHttpPanelViewModel extends AbstractHttpStringHttpPanelViewModel {
 
@@ -30,8 +29,7 @@ public class ResponseBodyStringHttpPanelViewModel extends AbstractHttpStringHttp
             return "";
         }
 
-        return HttpPanelViewModelUtils.getBodyString(
-                httpMessage.getResponseHeader(), httpMessage.getResponseBody());
+        return httpMessage.getResponseBody().toString();
     }
 
     @Override
@@ -40,7 +38,6 @@ public class ResponseBodyStringHttpPanelViewModel extends AbstractHttpStringHttp
             return;
         }
 
-        HttpPanelViewModelUtils.setBody(
-                httpMessage.getResponseHeader(), httpMessage.getResponseBody(), data);
+        httpMessage.getResponseBody().setBody(data);
     }
 }
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseStringHttpPanelViewModel.java b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseStringHttpPanelViewModel.java
index 9df11d78d..81246df6c 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseStringHttpPanelViewModel.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/response/ResponseStringHttpPanelViewModel.java
@@ -26,7 +26,6 @@ import org.parosproxy.paros.network.HttpHeader;
 import org.parosproxy.paros.network.HttpMalformedHeaderException;
 import org.zaproxy.zap.extension.httppanel.InvalidMessageDataException;
 import org.zaproxy.zap.extension.httppanel.view.impl.models.http.AbstractHttpStringHttpPanelViewModel;
-import org.zaproxy.zap.extension.httppanel.view.impl.models.http.HttpPanelViewModelUtils;
 
 public class ResponseStringHttpPanelViewModel extends AbstractHttpStringHttpPanelViewModel {
 
@@ -40,8 +39,7 @@ public class ResponseStringHttpPanelViewModel extends AbstractHttpStringHttpPane
         }
 
         return httpMessage.getResponseHeader().toString().replaceAll(HttpHeader.CRLF, HttpHeader.LF)
-                + HttpPanelViewModelUtils.getBodyString(
-                        httpMessage.getResponseHeader(), httpMessage.getResponseBody());
+                + httpMessage.getResponseBody().toString();
     }
 
     @Override
@@ -66,7 +64,6 @@ public class ResponseStringHttpPanelViewModel extends AbstractHttpStringHttpPane
         if (parts.length > 1) {
             body = data.substring(parts[0].length() + 2);
         }
-        HttpPanelViewModelUtils.setBody(
-                httpMessage.getResponseHeader(), httpMessage.getResponseBody(), body);
+        httpMessage.getResponseBody().setBody(body);
     }
 }
diff --git a/zap/src/main/java/org/zaproxy/zap/network/AbstractStreamHttpEncoding.java b/zap/src/main/java/org/zaproxy/zap/network/AbstractStreamHttpEncoding.java
new file mode 100644
index 000000000..25c69700d
--- /dev/null
+++ b/zap/src/main/java/org/zaproxy/zap/network/AbstractStreamHttpEncoding.java
@@ -0,0 +1,71 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+abstract class AbstractStreamHttpEncoding implements HttpEncoding {
+
+    private static final int BUFFER_SIZE = 2048;
+
+    private final OutputStreamSupplier outputStreamSupplier;
+    private final InputStreamSupplier inputStreamSupplier;
+
+    protected AbstractStreamHttpEncoding(
+            OutputStreamSupplier outputStreamSupplier, InputStreamSupplier inputStreamSupplier) {
+        this.outputStreamSupplier = outputStreamSupplier;
+        this.inputStreamSupplier = inputStreamSupplier;
+    }
+
+    @Override
+    public byte[] encode(byte[] content) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try (OutputStream os = outputStreamSupplier.get(baos)) {
+            os.write(content);
+        }
+        return baos.toByteArray();
+    }
+
+    @Override
+    public byte[] decode(byte[] content) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try (ByteArrayInputStream bais = new ByteArrayInputStream(content);
+                InputStream is = inputStreamSupplier.get(bais)) {
+            byte[] buffer = new byte[BUFFER_SIZE];
+            int len;
+            while ((len = is.read(buffer)) != -1) {
+                baos.write(buffer, 0, len);
+            }
+        }
+        return baos.toByteArray();
+    }
+
+    protected interface OutputStreamSupplier {
+        OutputStream get(ByteArrayOutputStream os) throws IOException;
+    }
+
+    protected interface InputStreamSupplier {
+        InputStream get(ByteArrayInputStream os) throws IOException;
+    }
+}
diff --git a/zap/src/main/java/org/zaproxy/zap/network/HttpEncoding.java b/zap/src/main/java/org/zaproxy/zap/network/HttpEncoding.java
new file mode 100644
index 000000000..baac24f44
--- /dev/null
+++ b/zap/src/main/java/org/zaproxy/zap/network/HttpEncoding.java
@@ -0,0 +1,48 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import java.io.IOException;
+
+/**
+ * A HTTP encoding, for a given content coding.
+ *
+ * @since TODO add version
+ */
+public interface HttpEncoding {
+
+    /**
+     * Encodes the given content.
+     *
+     * @param content the content to encode.
+     * @return the content encoded.
+     * @throws IOException if an error occurred while encoding the content.
+     */
+    byte[] encode(byte[] content) throws IOException;
+
+    /**
+     * Decodes the given content.
+     *
+     * @param content the content to decode.
+     * @return the decoded content.
+     * @throws IOException if an error occurred while decoding the content.
+     */
+    byte[] decode(byte[] content) throws IOException;
+}
diff --git a/zap/src/main/java/org/zaproxy/zap/network/HttpEncodingDeflate.java b/zap/src/main/java/org/zaproxy/zap/network/HttpEncodingDeflate.java
new file mode 100644
index 000000000..ce088a2f4
--- /dev/null
+++ b/zap/src/main/java/org/zaproxy/zap/network/HttpEncodingDeflate.java
@@ -0,0 +1,71 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import java.io.IOException;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.Inflater;
+import java.util.zip.InflaterInputStream;
+
+/**
+ * The {@link HttpEncoding} for the {@code deflate} coding.
+ *
+ * @since TODO add version
+ */
+public class HttpEncodingDeflate extends AbstractStreamHttpEncoding {
+
+    private static final HttpEncodingDeflate SINGLETON = new HttpEncodingDeflate();
+
+    private HttpEncodingDeflate() {
+        super(
+                DeflaterOutputStream::new,
+                is -> {
+                    if (is.available() < 2) {
+                        throw new IOException("Content malformed");
+                    }
+
+                    is.mark(0);
+                    Inflater inflater = new Inflater(isNoWrap(is.read(), is.read()));
+                    is.reset();
+                    return new InflaterInputStream(is, inflater);
+                });
+    }
+
+    // Logic from Apache HttpClient's DeflateInputStream.
+    private static boolean isNoWrap(int i1, int i2) {
+        int b1 = i1 & 0xFF;
+        int compressionMethod = b1 & 0xF;
+        int compressionInfo = b1 >> 4 & 0xF;
+        int b2 = i2 & 0xFF;
+        if (compressionMethod == 8 && compressionInfo <= 7 && ((b1 << 8) | b2) % 31 == 0) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Gets the singleton.
+     *
+     * @return the GZIP content encoding.
+     */
+    public static HttpEncodingDeflate getSingleton() {
+        return SINGLETON;
+    }
+}
diff --git a/zap/src/main/java/org/zaproxy/zap/network/HttpEncodingGzip.java b/zap/src/main/java/org/zaproxy/zap/network/HttpEncodingGzip.java
new file mode 100644
index 000000000..4be8572ee
--- /dev/null
+++ b/zap/src/main/java/org/zaproxy/zap/network/HttpEncodingGzip.java
@@ -0,0 +1,46 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+/**
+ * The {@link HttpEncoding} for the {@code gzip}/{@code x-gzip} coding.
+ *
+ * @since TODO add version
+ */
+public class HttpEncodingGzip extends AbstractStreamHttpEncoding {
+
+    private static final HttpEncodingGzip SINGLETON = new HttpEncodingGzip();
+
+    private HttpEncodingGzip() {
+        super(GZIPOutputStream::new, GZIPInputStream::new);
+    }
+
+    /**
+     * Gets the singleton.
+     *
+     * @return the GZIP content encoding.
+     */
+    public static HttpEncodingGzip getSingleton() {
+        return SINGLETON;
+    }
+}
diff --git a/zap/src/main/java/org/zaproxy/zap/network/HttpResponseBody.java b/zap/src/main/java/org/zaproxy/zap/network/HttpResponseBody.java
index 637e473c6..d8fd63bfb 100644
--- a/zap/src/main/java/org/zaproxy/zap/network/HttpResponseBody.java
+++ b/zap/src/main/java/org/zaproxy/zap/network/HttpResponseBody.java
@@ -122,14 +122,15 @@ public class HttpResponseBody extends HttpBody {
         String resultDefaultCharset = null;
 
         try {
-            resultDefaultCharset = new String(getBytes(), 0, getPos(), StandardCharsets.ISO_8859_1);
+            byte[] value = decode();
+            resultDefaultCharset = new String(value, StandardCharsets.ISO_8859_1);
             Matcher matcher = patternCharset.matcher(resultDefaultCharset);
             if (matcher.find()) {
                 final String charset = matcher.group(1);
-                result = new String(getBytes(), 0, getPos(), charset);
+                result = new String(value, charset);
                 setCharset(charset);
             } else {
-                String utf8 = toUTF8();
+                String utf8 = toUtf8(value);
                 if (utf8 != null) {
                     // assume to be UTF8
                     setCharset(StandardCharsets.UTF_8.name());
@@ -148,11 +149,11 @@ public class HttpResponseBody extends HttpBody {
         return result;
     }
 
-    private String toUTF8() {
-        String utf8 = new String(getBytes(), 0, getPos(), StandardCharsets.UTF_8);
+    private String toUtf8(byte[] value) {
+        String utf8 = new String(value, StandardCharsets.UTF_8);
         int length2 = utf8.getBytes(StandardCharsets.UTF_8).length;
 
-        if (getPos() != length2) {
+        if (value.length != length2) {
             return null;
         }
 
diff --git a/zap/src/test/java/org/parosproxy/paros/core/proxy/ProxyThreadUnitTest.java b/zap/src/test/java/org/parosproxy/paros/core/proxy/ProxyThreadUnitTest.java
new file mode 100644
index 000000000..662025818
--- /dev/null
+++ b/zap/src/test/java/org/parosproxy/paros/core/proxy/ProxyThreadUnitTest.java
@@ -0,0 +1,128 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.parosproxy.paros.core.proxy;
+
+import static java.util.Arrays.asList;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import org.junit.jupiter.api.Test;
+import org.parosproxy.paros.network.HttpHeader;
+import org.parosproxy.paros.network.HttpMessage;
+import org.parosproxy.paros.network.HttpResponseHeader;
+import org.zaproxy.zap.network.HttpEncoding;
+import org.zaproxy.zap.network.HttpResponseBody;
+
+/** Unit test for {@link ProxyThread}. */
+class ProxyThreadUnitTest {
+
+    @Test
+    void shouldDecodeResponseIfNeeded() {
+        // Given
+        HttpResponseHeader responseHeader = mock(HttpResponseHeader.class);
+        given(responseHeader.getHeader(HttpHeader.CONTENT_LENGTH)).willReturn("1");
+        HttpResponseBody responseBody = mock(HttpResponseBody.class);
+        given(responseBody.getContentEncodings()).willReturn(asList(mock(HttpEncoding.class)));
+        byte[] content = "ABC".getBytes(StandardCharsets.ISO_8859_1);
+        given(responseBody.getContent()).willReturn(content);
+        given(responseBody.length()).willReturn(content.length);
+        HttpMessage message = createMessage(responseHeader, responseBody);
+        // When
+        ProxyThread.decodeResponseIfNeeded(message);
+        // Then
+        verify(responseBody).setBody(content);
+        verify(responseBody).setContentEncodings(Collections.emptyList());
+        verify(responseHeader).setHeader(HttpHeader.CONTENT_ENCODING, null);
+        verify(responseHeader).setContentLength(content.length);
+    }
+
+    @Test
+    void shouldDecodeResponseIfNeededButNotSetContentLengthIfNotPresent() {
+        // Given
+        HttpResponseHeader responseHeader = mock(HttpResponseHeader.class);
+        given(responseHeader.getHeader(HttpHeader.CONTENT_LENGTH)).willReturn(null);
+        HttpResponseBody responseBody = mock(HttpResponseBody.class);
+        given(responseBody.getContentEncodings()).willReturn(asList(mock(HttpEncoding.class)));
+        byte[] content = "ABC".getBytes(StandardCharsets.ISO_8859_1);
+        given(responseBody.getContent()).willReturn(content);
+        given(responseBody.length()).willReturn(content.length);
+        HttpMessage message = createMessage(responseHeader, responseBody);
+        // When
+        ProxyThread.decodeResponseIfNeeded(message);
+        // Then
+        verify(responseBody).setBody(content);
+        verify(responseBody).setContentEncodings(Collections.emptyList());
+        verify(responseHeader).setHeader(HttpHeader.CONTENT_ENCODING, null);
+        verify(responseHeader, times(0)).setContentLength(anyInt());
+    }
+
+    @Test
+    void shouldNotDecodeResponseIfNoContentEncodings() {
+        // Given
+        HttpResponseHeader responseHeader = mock(HttpResponseHeader.class);
+        given(responseHeader.getHeader(HttpHeader.CONTENT_LENGTH)).willReturn("1");
+        HttpResponseBody responseBody = mock(HttpResponseBody.class);
+        given(responseBody.getContentEncodings()).willReturn(Collections.emptyList());
+        byte[] content = "ABC".getBytes(StandardCharsets.ISO_8859_1);
+        given(responseBody.getContent()).willReturn(content);
+        given(responseBody.length()).willReturn(content.length);
+        HttpMessage message = createMessage(responseHeader, responseBody);
+        // When
+        ProxyThread.decodeResponseIfNeeded(message);
+        // Then
+        verify(responseBody, times(0)).setBody(content);
+        verify(responseBody, times(0)).setContentEncodings(Collections.emptyList());
+        verify(responseHeader, times(0)).setHeader(HttpHeader.CONTENT_ENCODING, null);
+        verify(responseHeader, times(0)).setContentLength(content.length);
+    }
+
+    @Test
+    void shouldNotDecodeResponseWithContentEncodingErrors() {
+        // Given
+        HttpResponseHeader responseHeader = mock(HttpResponseHeader.class);
+        given(responseHeader.getHeader(HttpHeader.CONTENT_LENGTH)).willReturn("1");
+        HttpResponseBody responseBody = mock(HttpResponseBody.class);
+        given(responseBody.getContentEncodings()).willReturn(asList(mock(HttpEncoding.class)));
+        given(responseBody.hasContentEncodingErrors()).willReturn(true);
+        byte[] content = "ABC".getBytes(StandardCharsets.ISO_8859_1);
+        given(responseBody.getContent()).willReturn(content);
+        given(responseBody.length()).willReturn(content.length);
+        HttpMessage message = createMessage(responseHeader, responseBody);
+        // When
+        ProxyThread.decodeResponseIfNeeded(message);
+        // Then
+        verify(responseBody, times(0)).setBody(content);
+        verify(responseBody, times(0)).setContentEncodings(Collections.emptyList());
+        verify(responseHeader, times(0)).setHeader(HttpHeader.CONTENT_ENCODING, null);
+        verify(responseHeader, times(0)).setContentLength(content.length);
+    }
+
+    private static HttpMessage createMessage(HttpResponseHeader header, HttpResponseBody body) {
+        HttpMessage message = mock(HttpMessage.class);
+        given(message.getResponseHeader()).willReturn(header);
+        given(message.getResponseBody()).willReturn(body);
+        return message;
+    }
+}
diff --git a/zap/src/test/java/org/parosproxy/paros/network/HttpBodyUnitTest.java b/zap/src/test/java/org/parosproxy/paros/network/HttpBodyUnitTest.java
index fc93599eb..12677a13b 100644
--- a/zap/src/test/java/org/parosproxy/paros/network/HttpBodyUnitTest.java
+++ b/zap/src/test/java/org/parosproxy/paros/network/HttpBodyUnitTest.java
@@ -19,17 +19,31 @@
  */
 package org.parosproxy.paros.network;
 
+import static java.util.Arrays.asList;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
 import static org.hamcrest.Matchers.nullValue;
 import static org.hamcrest.Matchers.sameInstance;
-
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+import java.io.IOException;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import org.junit.jupiter.api.Test;
 import org.zaproxy.zap.network.HttpBodyTestUtils;
+import org.zaproxy.zap.network.HttpEncoding;
 
 /** Unit test for {@link HttpBody}. */
 public class HttpBodyUnitTest extends HttpBodyTestUtils {
@@ -283,6 +297,97 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.toString(), is(equalTo("\0")));
     }
 
+    @Test
+    void shouldSetContentEncodings() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        List<HttpEncoding> encodings = Arrays.asList(mock(HttpEncoding.class));
+        // When
+        httpBody.setContentEncodings(encodings);
+        // Then
+        assertThat(httpBody.getContentEncodings(), is(equalTo(encodings)));
+    }
+
+    @Test
+    void shouldSetContentEncodingsAndCopyList() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        List<HttpEncoding> encodings = new ArrayList<>();
+        encodings.add(mock(HttpEncoding.class));
+        // When
+        httpBody.setContentEncodings(encodings);
+        encodings.add(mock(HttpEncoding.class));
+        // Then
+        assertThat(httpBody.getContentEncodings(), is(not(equalTo(encodings))));
+        assertThat(httpBody.getContentEncodings(), hasSize(1));
+    }
+
+    @Test
+    void shouldSetContentEncodingsAndNotAllowModificationsToReturnedList() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        httpBody.setContentEncodings(Arrays.asList(mock(HttpEncoding.class)));
+        // When / Then
+        assertThrows(
+                UnsupportedOperationException.class,
+                () -> httpBody.getContentEncodings().add(mock(HttpEncoding.class)));
+    }
+
+    @Test
+    void shouldSetEmptyContentEncodings() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        List<HttpEncoding> encodings = Collections.emptyList();
+        // When
+        httpBody.setContentEncodings(encodings);
+        // Then
+        assertThat(httpBody.getContentEncodings(), is(equalTo(encodings)));
+    }
+
+    @Test
+    void shouldResetContentEncodingErrorsWhenSettingContentEncodings() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        List<HttpEncoding> encodings = Collections.emptyList();
+        // When
+        httpBody.setContentEncodings(encodings);
+        // Then
+        assertThat(httpBody.hasContentEncodingErrors(), is(equalTo(false)));
+    }
+
+    @Test
+    void shouldToStringWithContentEncodingsSet() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        HttpEncoding contentEncoding = mock(HttpEncoding.class);
+        String bodyData = "ABC";
+        byte[] encodedContent = bytes(bodyData);
+        given(contentEncoding.decode(any())).willReturn(encodedContent);
+        // When
+        httpBody.toString(); // force the creation of the "old" string representation
+        httpBody.setContentEncodings(asList(contentEncoding));
+        // Then
+        assertThat(httpBody.toString(), is(equalTo(bodyData)));
+    }
+
+    @Test
+    void shouldThrowExceptionWhenSettingNullContentEncodings() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        List<HttpEncoding> encodings = null;
+        // When / Then
+        assertThrows(NullPointerException.class, () -> httpBody.setContentEncodings(encodings));
+    }
+
+    @Test
+    void shouldThrowExceptionWhenSettingANullContentEncoding() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        List<HttpEncoding> encodings = Arrays.asList(mock(HttpEncoding.class), null);
+        // When / Then
+        assertThrows(NullPointerException.class, () -> httpBody.setContentEncodings(encodings));
+    }
+
     @Test
     public void shouldIgnoreNullStringBodySet() {
         // Given
@@ -311,6 +416,26 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.toString(), is(equalTo(BODY_1_STRING_DEFAULT_CHARSET)));
     }
 
+    @Test
+    public void shouldSetBytesBodyUsingDefaultCharsetAndNotContentEncode() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        HttpEncoding encoding = mock(HttpEncoding.class);
+        httpBody.setContentEncodings(Arrays.asList(encoding));
+        given(encoding.decode(BODY_1_BYTES_DEFAULT_CHARSET))
+                .willReturn(BODY_1_BYTES_DEFAULT_CHARSET);
+        // When
+        httpBody.setBody(BODY_1_BYTES_DEFAULT_CHARSET);
+        // Then
+        assertThat(httpBody.length(), is(equalTo(BODY_1_BYTES_DEFAULT_CHARSET.length)));
+        assertThat(httpBody.getBytes(), is(not(nullValue())));
+        assertThat(httpBody.getBytes(), is(equalTo(BODY_1_BYTES_DEFAULT_CHARSET)));
+        assertThat(httpBody.getBytes().length, is(equalTo(BODY_1_BYTES_DEFAULT_CHARSET.length)));
+        assertThat(httpBody.toString(), is(equalTo(BODY_1_STRING_DEFAULT_CHARSET)));
+        verify(encoding).decode(BODY_1_BYTES_DEFAULT_CHARSET);
+        verifyNoMoreInteractions(encoding);
+    }
+
     @Test
     public void shouldSetStringBodyUsingDefaultCharset() {
         // Given
@@ -325,6 +450,26 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.toString(), is(equalTo(BODY_1_STRING_DEFAULT_CHARSET)));
     }
 
+    @Test
+    public void shouldSetStringBodyUsingDefaultCharsetAndContentEncode() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        HttpEncoding encoding = mock(HttpEncoding.class);
+        httpBody.setContentEncodings(Arrays.asList(encoding));
+        given(encoding.encode(BODY_1_BYTES_DEFAULT_CHARSET))
+                .willReturn(BODY_1_BYTES_DEFAULT_CHARSET);
+        // When
+        httpBody.setBody(BODY_1_STRING);
+        // Then
+        assertThat(httpBody.length(), is(equalTo(BODY_1_BYTES_DEFAULT_CHARSET.length)));
+        assertThat(httpBody.getBytes(), is(not(nullValue())));
+        assertThat(httpBody.getBytes(), is(equalTo(BODY_1_BYTES_DEFAULT_CHARSET)));
+        assertThat(httpBody.getBytes().length, is(equalTo(BODY_1_BYTES_DEFAULT_CHARSET.length)));
+        assertThat(httpBody.toString(), is(equalTo(BODY_1_STRING_DEFAULT_CHARSET)));
+        verify(encoding).encode(BODY_1_BYTES_DEFAULT_CHARSET);
+        verifyNoMoreInteractions(encoding);
+    }
+
     @Test
     public void shouldSetBytesBodyUsingCharsetSet() {
         // Given
@@ -340,6 +485,26 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.toString(), is(equalTo(BODY_1_STRING_UTF_8)));
     }
 
+    @Test
+    public void shouldSetBytesBodyUsingCharsetSetAndNotContentEncode() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        httpBody.setCharset(UTF_8_NAME);
+        HttpEncoding encoding = mock(HttpEncoding.class);
+        httpBody.setContentEncodings(Arrays.asList(encoding));
+        given(encoding.decode(BODY_1_BYTES_UTF_8)).willReturn(BODY_1_BYTES_UTF_8);
+        // When
+        httpBody.setBody(BODY_1_BYTES_UTF_8);
+        // Then
+        assertThat(httpBody.length(), is(equalTo(BODY_1_BYTES_UTF_8.length)));
+        assertThat(httpBody.getBytes(), is(not(nullValue())));
+        assertThat(httpBody.getBytes(), is(equalTo(BODY_1_BYTES_UTF_8)));
+        assertThat(httpBody.getBytes().length, is(equalTo(BODY_1_BYTES_UTF_8.length)));
+        assertThat(httpBody.toString(), is(equalTo(BODY_1_STRING_UTF_8)));
+        verify(encoding).decode(BODY_1_BYTES_UTF_8);
+        verifyNoMoreInteractions(encoding);
+    }
+
     @Test
     public void shouldSetStringBodyUsingCharsetSet() {
         // Given
@@ -355,6 +520,26 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.toString(), is(equalTo(BODY_1_STRING_UTF_8)));
     }
 
+    @Test
+    public void shouldSetStringBodyUsingCharsetSetAndContentEncode() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        httpBody.setCharset(UTF_8_NAME);
+        HttpEncoding encoding = mock(HttpEncoding.class);
+        httpBody.setContentEncodings(Arrays.asList(encoding));
+        given(encoding.encode(BODY_1_BYTES_UTF_8)).willReturn(BODY_1_BYTES_UTF_8);
+        // When
+        httpBody.setBody(BODY_1_STRING_UTF_8);
+        // Then
+        assertThat(httpBody.length(), is(equalTo(BODY_1_BYTES_UTF_8.length)));
+        assertThat(httpBody.getBytes(), is(not(nullValue())));
+        assertThat(httpBody.getBytes(), is(equalTo(BODY_1_BYTES_UTF_8)));
+        assertThat(httpBody.getBytes().length, is(equalTo(BODY_1_BYTES_UTF_8.length)));
+        assertThat(httpBody.toString(), is(equalTo(BODY_1_STRING_UTF_8)));
+        verify(encoding).encode(BODY_1_BYTES_UTF_8);
+        verifyNoMoreInteractions(encoding);
+    }
+
     @Test
     public void shouldIgnoreNullBytesBodyAppended() {
         // Given
@@ -398,6 +583,27 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.toString(), is(equalTo(BODY_1_AND_2_STRING_DEFAULT_CHARSET)));
     }
 
+    @Test
+    public void shouldAppendBytesBodyUsingDefaultCharsetAndNotContentEncode() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl(BODY_1_STRING);
+        HttpEncoding encoding = mock(HttpEncoding.class);
+        httpBody.setContentEncodings(Arrays.asList(encoding));
+        given(encoding.decode(BODY_1_AND_2_BYTES_DEFAULT_CHARSET))
+                .willReturn(BODY_1_AND_2_BYTES_DEFAULT_CHARSET);
+        // When
+        httpBody.append(BODY_2_BYTES_DEFAULT_CHARSET);
+        // Then
+        assertThat(httpBody.length(), is(equalTo(BODY_1_AND_2_BYTES_DEFAULT_CHARSET.length)));
+        assertThat(httpBody.getBytes(), is(not(nullValue())));
+        assertThat(httpBody.getBytes(), is(equalTo(BODY_1_AND_2_BYTES_DEFAULT_CHARSET)));
+        assertThat(
+                httpBody.getBytes().length, is(equalTo(BODY_1_AND_2_BYTES_DEFAULT_CHARSET.length)));
+        assertThat(httpBody.toString(), is(equalTo(BODY_1_AND_2_STRING_DEFAULT_CHARSET)));
+        verify(encoding).decode(BODY_1_AND_2_BYTES_DEFAULT_CHARSET);
+        verifyNoMoreInteractions(encoding);
+    }
+
     @Test
     public void shouldAppendStringBodyUsingDefaultCharset() {
         // Given
@@ -413,6 +619,33 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.toString(), is(equalTo(BODY_1_AND_2_STRING_DEFAULT_CHARSET)));
     }
 
+    @Test
+    void shouldAppendStringBodyUsingDefaultCharsetAndContentEncode() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl(BODY_1_STRING);
+        HttpEncoding encoding = mock(HttpEncoding.class);
+        given(encoding.decode(BODY_1_BYTES_DEFAULT_CHARSET))
+                .willReturn(BODY_1_BYTES_DEFAULT_CHARSET);
+        given(encoding.encode(BODY_1_AND_2_BYTES_DEFAULT_CHARSET))
+                .willReturn(BODY_1_AND_2_BYTES_DEFAULT_CHARSET);
+        given(encoding.decode(BODY_1_AND_2_BYTES_DEFAULT_CHARSET))
+                .willReturn(BODY_1_AND_2_BYTES_DEFAULT_CHARSET);
+        httpBody.setContentEncodings(asList(encoding));
+        // When
+        httpBody.append(BODY_2_STRING);
+        // Then
+        assertThat(httpBody.length(), is(equalTo(BODY_1_AND_2_BYTES_DEFAULT_CHARSET.length)));
+        assertThat(httpBody.getBytes(), is(not(nullValue())));
+        assertThat(httpBody.getBytes(), is(equalTo(BODY_1_AND_2_BYTES_DEFAULT_CHARSET)));
+        assertThat(
+                httpBody.getBytes().length, is(equalTo(BODY_1_AND_2_BYTES_DEFAULT_CHARSET.length)));
+        assertThat(httpBody.toString(), is(equalTo(BODY_1_AND_2_STRING_DEFAULT_CHARSET)));
+        verify(encoding).decode(BODY_1_BYTES_DEFAULT_CHARSET);
+        verify(encoding).encode(BODY_1_AND_2_BYTES_DEFAULT_CHARSET);
+        verify(encoding).decode(BODY_1_AND_2_BYTES_DEFAULT_CHARSET);
+        verifyNoMoreInteractions(encoding);
+    }
+
     @Test
     public void shouldAppendBytesBodyUsingCharsetSet() {
         // Given
@@ -428,6 +661,26 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.toString(), is(equalTo(BODY_1_AND_2_STRING_UTF_8)));
     }
 
+    @Test
+    public void shouldAppendBytesBodyUsingCharsetSetAndNotContentEncode() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl(BODY_1_BYTES_UTF_8);
+        httpBody.setCharset(UTF_8_NAME);
+        HttpEncoding encoding = mock(HttpEncoding.class);
+        httpBody.setContentEncodings(asList(encoding));
+        given(encoding.decode(BODY_1_AND_2_BYTES_UTF_8)).willReturn(BODY_1_AND_2_BYTES_UTF_8);
+        // When
+        httpBody.append(BODY_2_BYTES_UTF_8);
+        // Then
+        assertThat(httpBody.length(), is(equalTo(BODY_1_AND_2_BYTES_UTF_8.length)));
+        assertThat(httpBody.getBytes(), is(not(nullValue())));
+        assertThat(httpBody.getBytes(), is(equalTo(BODY_1_AND_2_BYTES_UTF_8)));
+        assertThat(httpBody.getBytes().length, is(equalTo(BODY_1_AND_2_BYTES_UTF_8.length)));
+        assertThat(httpBody.toString(), is(equalTo(BODY_1_AND_2_STRING_UTF_8)));
+        verify(encoding).decode(BODY_1_AND_2_BYTES_UTF_8);
+        verifyNoMoreInteractions(encoding);
+    }
+
     @Test
     public void shouldAppendStringBodyUsingCharsetSet() {
         // Given
@@ -443,6 +696,30 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.toString(), is(equalTo(BODY_1_AND_2_STRING_UTF_8)));
     }
 
+    @Test
+    public void shouldAppendStringBodyUsingCharsetSetAndContentEncode() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl(BODY_1_BYTES_UTF_8);
+        httpBody.setCharset(UTF_8_NAME);
+        HttpEncoding encoding = mock(HttpEncoding.class);
+        given(encoding.decode(BODY_1_BYTES_UTF_8)).willReturn(BODY_1_BYTES_UTF_8);
+        given(encoding.encode(BODY_1_AND_2_BYTES_UTF_8)).willReturn(BODY_1_AND_2_BYTES_UTF_8);
+        given(encoding.decode(BODY_1_AND_2_BYTES_UTF_8)).willReturn(BODY_1_AND_2_BYTES_UTF_8);
+        httpBody.setContentEncodings(Arrays.asList(encoding));
+        // When
+        httpBody.append(BODY_2_STRING_UTF_8);
+        // Then
+        assertThat(httpBody.length(), is(equalTo(BODY_1_AND_2_BYTES_UTF_8.length)));
+        assertThat(httpBody.getBytes(), is(not(nullValue())));
+        assertThat(httpBody.getBytes(), is(equalTo(BODY_1_AND_2_BYTES_UTF_8)));
+        assertThat(httpBody.getBytes().length, is(equalTo(BODY_1_AND_2_BYTES_UTF_8.length)));
+        assertThat(httpBody.toString(), is(equalTo(BODY_1_AND_2_STRING_UTF_8)));
+        verify(encoding).decode(BODY_1_BYTES_UTF_8);
+        verify(encoding).encode(BODY_1_AND_2_BYTES_UTF_8);
+        verify(encoding).decode(BODY_1_AND_2_BYTES_UTF_8);
+        verifyNoMoreInteractions(encoding);
+    }
+
     @Test
     public void shouldAppendFullByteArray() {
         // Given
@@ -651,6 +928,140 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(string2, is(sameInstance(string2)));
     }
 
+    @Test
+    void shouldGetContentDecoded() throws IOException {
+        // Given
+        String bodyData = "ABC";
+        HttpBody httpBody = new HttpBodyImpl(bodyData);
+        HttpEncoding contentEncoding = mock(HttpEncoding.class);
+        byte[] decodedContent = bytes(bodyData);
+        given(contentEncoding.decode(any())).willReturn(decodedContent);
+        httpBody.setContentEncodings(asList(contentEncoding));
+        // When
+        byte[] content = httpBody.getContent();
+        // Then
+        assertThat(content, is(sameInstance(decodedContent)));
+        assertThat(httpBody.toString(), is(equalTo(bodyData)));
+    }
+
+    @Test
+    void shouldGetSameDecodedContent() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl("");
+        HttpEncoding contentEncoding = mock(HttpEncoding.class);
+        given(contentEncoding.decode(any())).willReturn(bytes("ABC"));
+        httpBody.setContentEncodings(asList(contentEncoding));
+        // When
+        byte[] content = httpBody.getContent();
+        byte[] otherContent = httpBody.getContent();
+        // Then
+        assertThat(content, is(sameInstance(otherContent)));
+    }
+
+    @Test
+    void shouldGetContentSameAsBytesIfNoContentEncoding() {
+        // Given
+        String body = " X Y Z ";
+        HttpBody httpBody = new HttpBodyImpl(body);
+        // When
+        byte[] content = httpBody.getContent();
+        // Then
+        assertThat(content, is(sameInstance(httpBody.getBytes())));
+    }
+
+    @Test
+    void shouldSetContentAndEncode() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        HttpEncoding contentEncoding = mock(HttpEncoding.class);
+        byte[] encodedContent = bytes("ABC");
+        given(contentEncoding.encode(any())).willReturn(encodedContent);
+        httpBody.setContentEncodings(asList(contentEncoding));
+        String bodyData = "CBA";
+        byte[] decodedContent = bytes(bodyData);
+        // When
+        httpBody.setContent(decodedContent);
+        // Then
+        assertThat(httpBody.getBytes(), is(equalTo(encodedContent)));
+        assertThat(httpBody.getContent(), is(sameInstance(decodedContent)));
+        assertThat(httpBody.toString(), is(equalTo(bodyData)));
+    }
+
+    @Test
+    void shouldReturnToStringForContentSet() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        String bodyData = "ABC";
+        byte[] content = bytes(bodyData);
+        // When
+        httpBody.toString(); // force the creation of the "old" string representation
+        httpBody.setContent(content);
+        // Then
+        assertThat(httpBody.getBytes(), is(equalTo(content)));
+        assertThat(httpBody.toString(), is(equalTo(bodyData)));
+    }
+
+    @Test
+    void shouldSetContentWithoutEncodingIfNoContentEncoding() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        String bodyData = "ABC";
+        byte[] content = bytes(bodyData);
+        // When
+        httpBody.setContent(content);
+        // Then
+        assertThat(httpBody.getBytes(), is(equalTo(content)));
+        assertThat(httpBody.toString(), is(equalTo(bodyData)));
+    }
+
+    @Test
+    void shouldNotSetContentIfNull() {
+        // Given
+        String bodyData = "ABC";
+        HttpBody httpBody = new HttpBodyImpl(bodyData);
+        // When
+        httpBody.setContent(null);
+        // Then
+        assertThat(httpBody.getBytes(), is(equalTo(bytes(bodyData))));
+        assertThat(httpBody.toString(), is(equalTo(bodyData)));
+    }
+
+    @Test
+    void shouldHandleContentEncodingErrorsWhenDecoding() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        HttpEncoding contentEncoding = mock(HttpEncoding.class);
+        given(contentEncoding.decode(any())).willThrow(IOException.class);
+        httpBody.setContentEncodings(asList(contentEncoding));
+        String bodyData = "CBA";
+        byte[] bodyBytes = bytes(bodyData);
+        // When
+        httpBody.setBody(bodyBytes);
+        // Then
+        assertThat(httpBody.getBytes(), is(equalTo(bodyBytes)));
+        assertThat(httpBody.getContent(), is(equalTo(bodyBytes)));
+        assertThat(httpBody.toString(), is(equalTo(bodyData)));
+        assertThat(httpBody.hasContentEncodingErrors(), is(equalTo(true)));
+    }
+
+    @Test
+    void shouldHandleContentEncodingErrorsWhenEncoding() throws IOException {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl();
+        HttpEncoding contentEncoding = mock(HttpEncoding.class);
+        given(contentEncoding.encode(any())).willThrow(IOException.class);
+        httpBody.setContentEncodings(asList(contentEncoding));
+        String bodyData = "CBA";
+        byte[] bodyBytes = bytes(bodyData);
+        // When
+        httpBody.setBody(bodyData);
+        // Then
+        assertThat(httpBody.getBytes(), is(equalTo(bodyBytes)));
+        assertThat(httpBody.getContent(), is(equalTo(bodyBytes)));
+        assertThat(httpBody.toString(), is(equalTo(bodyData)));
+        assertThat(httpBody.hasContentEncodingErrors(), is(equalTo(true)));
+    }
+
     @Test
     public void shouldNotBeEqualToNull() {
         // Given
@@ -670,6 +1081,30 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody, is(equalTo(otherHttpBody)));
     }
 
+    @Test
+    void shouldBeEqualToEqualEncodings() {
+        // Given
+        List<HttpEncoding> encodings = Arrays.asList(mock(HttpEncoding.class));
+        HttpBody httpBody = new HttpBodyImpl();
+        httpBody.setContentEncodings(encodings);
+        HttpBody otherHttpBody = new HttpBodyImpl();
+        otherHttpBody.setContentEncodings(encodings);
+        // When / Then
+        assertThat(httpBody, is(equalTo(otherHttpBody)));
+    }
+
+    @Test
+    void shouldBeEqualToEqualHttpBodyAndEncodings() {
+        // Given
+        List<HttpEncoding> encodings = Arrays.asList(mock(HttpEncoding.class));
+        HttpBody httpBody = new HttpBodyImpl("Body");
+        httpBody.setContentEncodings(encodings);
+        HttpBody otherHttpBody = new HttpBodyImpl("Body");
+        otherHttpBody.setContentEncodings(encodings);
+        // When / Then
+        assertThat(httpBody, is(equalTo(otherHttpBody)));
+    }
+
     @Test
     public void shouldBeEqualToSameInstance() {
         // Given
@@ -687,6 +1122,28 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody, is(not(equalTo(otherDifferentHttpBody))));
     }
 
+    @Test
+    void shouldNotBeEqualToDifferentEncodings() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl("Body");
+        httpBody.setContentEncodings(Arrays.asList(mock(HttpEncoding.class)));
+        HttpBody otherDifferentHttpBody = new HttpBodyImpl("Body");
+        otherDifferentHttpBody.setContentEncodings(Arrays.asList(mock(HttpEncoding.class)));
+        // When / Then
+        assertThat(httpBody, is(not(equalTo(otherDifferentHttpBody))));
+    }
+
+    @Test
+    void shouldNotBeEqualToDifferentHttpBodyAndEncodings() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl("Body");
+        httpBody.setContentEncodings(Arrays.asList(mock(HttpEncoding.class)));
+        HttpBody otherDifferentHttpBody = new HttpBodyImpl("Different Contents");
+        otherDifferentHttpBody.setContentEncodings(Arrays.asList(mock(HttpEncoding.class)));
+        // When / Then
+        assertThat(httpBody, is(not(equalTo(otherDifferentHttpBody))));
+    }
+
     @Test
     public void shouldNotBeEqualToDifferentHttpBodyImplementation() {
         // Given
@@ -705,6 +1162,18 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.hashCode(), is(equalTo(otherHttpBody.hashCode())));
     }
 
+    @Test
+    void shouldProduceSameHashCodeForEqualBodyAndEncodings() {
+        // Given
+        List<HttpEncoding> encodings = Arrays.asList(mock(HttpEncoding.class));
+        HttpBody httpBody = new HttpBodyImpl("X A");
+        httpBody.setContentEncodings(encodings);
+        HttpBody otherHttpBody = new HttpBodyImpl("X A");
+        otherHttpBody.setContentEncodings(encodings);
+        // When / Then
+        assertThat(httpBody.hashCode(), is(equalTo(otherHttpBody.hashCode())));
+    }
+
     @Test
     public void shouldProduceDifferentHashCodeFromDifferentBody() {
         // Given
@@ -714,6 +1183,32 @@ public class HttpBodyUnitTest extends HttpBodyTestUtils {
         assertThat(httpBody.hashCode(), is(not(equalTo(otherHttpBody.hashCode()))));
     }
 
+    @Test
+    void shouldProduceDifferentHashCodeFromDifferentEncodings() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl("X A");
+        httpBody.setContentEncodings(Arrays.asList(mock(HttpEncoding.class)));
+        HttpBody otherHttpBody = new HttpBodyImpl("X A");
+        otherHttpBody.setContentEncodings(Arrays.asList(mock(HttpEncoding.class)));
+        // When / Then
+        assertThat(httpBody.hashCode(), is(not(equalTo(otherHttpBody.hashCode()))));
+    }
+
+    @Test
+    void shouldProduceDifferentHashCodeFromDifferentBodyAndEncodings() {
+        // Given
+        HttpBody httpBody = new HttpBodyImpl("_ X A 1");
+        httpBody.setContentEncodings(Arrays.asList(mock(HttpEncoding.class)));
+        HttpBody otherHttpBody = new HttpBodyImpl("X A 2");
+        otherHttpBody.setContentEncodings(Arrays.asList(mock(HttpEncoding.class)));
+        // When / Then
+        assertThat(httpBody.hashCode(), is(not(equalTo(otherHttpBody.hashCode()))));
+    }
+
+    private static byte[] bytes(String data) {
+        return data.getBytes(StandardCharsets.US_ASCII);
+    }
+
     private static class HttpBodyImpl extends HttpBody {
 
         private boolean determineCharsetCalled;
diff --git a/zap/src/test/java/org/parosproxy/paros/network/HttpInputStreamUnitTest.java b/zap/src/test/java/org/parosproxy/paros/network/HttpInputStreamUnitTest.java
index 504dcb939..31f005704 100644
--- a/zap/src/test/java/org/parosproxy/paros/network/HttpInputStreamUnitTest.java
+++ b/zap/src/test/java/org/parosproxy/paros/network/HttpInputStreamUnitTest.java
@@ -19,7 +19,9 @@
  */
 package org.parosproxy.paros.network;
 
+import static java.util.Arrays.asList;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
@@ -33,14 +35,19 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.net.Socket;
 import java.util.Arrays;
+import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.NullAndEmptySource;
 import org.junit.jupiter.params.provider.ValueSource;
+import org.zaproxy.zap.network.HttpEncodingDeflate;
+import org.zaproxy.zap.network.HttpEncodingGzip;
 import org.zaproxy.zap.network.HttpRequestBody;
 
 /** Unit test for {@link HttpInputStream}. */
 class HttpInputStreamUnitTest {
 
     private static final int UNKOWN_LENGTH = -1;
+    private static final byte[] EMPTY_BODY = {};
 
     @ParameterizedTest
     @ValueSource(
@@ -74,6 +81,65 @@ class HttpInputStreamUnitTest {
         assertThat(httpBody.getBytes(), is(equalTo(data)));
     }
 
+    @Test
+    void shouldSetGzipEncodingToBody() throws Exception {
+        // Given
+        HttpHeader httpHeader = mock(HttpHeader.class);
+        given(httpHeader.getContentLength()).willReturn(0);
+        given(httpHeader.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(HttpHeader.GZIP);
+        HttpInputStream httpInputStream = new HttpInputStream(createSocket(EMPTY_BODY));
+        // When
+        HttpRequestBody httpBody = httpInputStream.readRequestBody(httpHeader);
+        // Then
+        assertThat(
+                httpBody.getContentEncodings(),
+                is(equalTo(asList(HttpEncodingGzip.getSingleton()))));
+    }
+
+    @Test
+    void shouldSetDeflateEncodingToBody() throws Exception {
+        // Given
+        HttpHeader httpHeader = mock(HttpHeader.class);
+        given(httpHeader.getContentLength()).willReturn(0);
+        given(httpHeader.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(HttpHeader.DEFLATE);
+        HttpInputStream httpInputStream = new HttpInputStream(createSocket(EMPTY_BODY));
+        // When
+        HttpRequestBody httpBody = httpInputStream.readRequestBody(httpHeader);
+        // Then
+        assertThat(
+                httpBody.getContentEncodings(),
+                is(equalTo(asList(HttpEncodingDeflate.getSingleton()))));
+    }
+
+    @ParameterizedTest
+    @NullAndEmptySource
+    void shouldNotSetContentEncodingToBodyIfContentEncodingIsNotPresentOrIsEmpty(
+            String contentEncoding) throws Exception {
+        // Given
+        HttpHeader httpHeader = mock(HttpHeader.class);
+        given(httpHeader.getContentLength()).willReturn(0);
+        given(httpHeader.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
+        HttpInputStream httpInputStream = new HttpInputStream(createSocket(EMPTY_BODY));
+        // When
+        HttpRequestBody httpBody = httpInputStream.readRequestBody(httpHeader);
+        // Then
+        assertThat(httpBody.getContentEncodings(), is(empty()));
+    }
+
+    @Test
+    void shouldNotSetContentEncodingToBodyIfContentEncodingNotSupported() throws Exception {
+        // Given
+        HttpHeader httpHeader = mock(HttpHeader.class);
+        given(httpHeader.getContentLength()).willReturn(0);
+        given(httpHeader.getHeader(HttpHeader.CONTENT_ENCODING))
+                .willReturn("Encoding Not Supported");
+        HttpInputStream httpInputStream = new HttpInputStream(createSocket(EMPTY_BODY));
+        // When
+        HttpRequestBody httpBody = httpInputStream.readRequestBody(httpHeader);
+        // Then
+        assertThat(httpBody.getContentEncodings(), is(empty()));
+    }
+
     private static Socket createSocket(byte[] data) throws IOException {
         InputStream inputStream = new ByteArrayInputStream(data);
         Socket socket = mock(Socket.class);
diff --git a/zap/src/test/java/org/parosproxy/paros/network/HttpMessageUnitTest.java b/zap/src/test/java/org/parosproxy/paros/network/HttpMessageUnitTest.java
index c73c0b233..56fd41f60 100644
--- a/zap/src/test/java/org/parosproxy/paros/network/HttpMessageUnitTest.java
+++ b/zap/src/test/java/org/parosproxy/paros/network/HttpMessageUnitTest.java
@@ -19,17 +19,32 @@
  */
 package org.parosproxy.paros.network;
 
+import static java.util.Arrays.asList;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
 import static org.hamcrest.Matchers.nullValue;
 import static org.hamcrest.Matchers.sameInstance;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 
+import java.util.Collections;
+import java.util.List;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.NullAndEmptySource;
+import org.junit.jupiter.params.provider.ValueSource;
+import org.mockito.ArgumentCaptor;
 import org.parosproxy.paros.model.HistoryReference;
 import org.zaproxy.zap.extension.httpsessions.HttpSession;
+import org.zaproxy.zap.network.HttpEncoding;
+import org.zaproxy.zap.network.HttpEncodingDeflate;
+import org.zaproxy.zap.network.HttpEncodingGzip;
 import org.zaproxy.zap.network.HttpRequestBody;
 import org.zaproxy.zap.network.HttpResponseBody;
 import org.zaproxy.zap.users.User;
@@ -185,6 +200,141 @@ public class HttpMessageUnitTest {
         assertThat(copy.isResponseFromTargetHost(), is(equalTo(false)));
     }
 
+    @Test
+    void shouldNotSetContentEncodingsWhenSettingHttpRequestBody() {
+        // Given
+        HttpRequestHeader header = mock(HttpRequestHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(HttpHeader.GZIP);
+        HttpRequestBody body = mock(HttpRequestBody.class);
+        HttpMessage message = new HttpMessage(header, body);
+        // When
+        message.setRequestBody(body);
+        // Then
+        verify(body, times(0)).setContentEncodings(any());
+    }
+
+    @Test
+    void shouldSetContentEncodingsWhenSettingRequestBodyByte() {
+        // Given
+        HttpRequestHeader header = mock(HttpRequestHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(HttpHeader.GZIP);
+        HttpRequestBody body = mock(HttpRequestBody.class);
+        HttpMessage message = new HttpMessage(header, body);
+        // When
+        message.setRequestBody(new byte[0]);
+        // Then
+        assertThat(encodings(body), is(not(empty())));
+    }
+
+    @Test
+    void shouldSetContentEncodingsWhenSettingRequestBodyString() {
+        // Given
+        HttpRequestHeader header = mock(HttpRequestHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(HttpHeader.GZIP);
+        HttpRequestBody body = mock(HttpRequestBody.class);
+        HttpMessage message = new HttpMessage(header, body);
+        // When
+        message.setRequestBody("Body");
+        // Then
+        assertThat(encodings(body), is(not(empty())));
+    }
+
+    @Test
+    void shouldNotSetContentEncodingsWhenSettingHttpResponseBody() {
+        // Given
+        HttpResponseHeader header = mock(HttpResponseHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(HttpHeader.GZIP);
+        HttpResponseBody body = mock(HttpResponseBody.class);
+        HttpMessage message =
+                new HttpMessage(
+                        mock(HttpRequestHeader.class), mock(HttpRequestBody.class), header, body);
+        // When
+        message.setResponseBody(body);
+        // Then
+        verify(body, times(0)).setContentEncodings(any());
+    }
+
+    @Test
+    void shouldSetContentEncodingsWhenSettingResponseBodyByte() {
+        // Given
+        HttpResponseHeader header = mock(HttpResponseHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(HttpHeader.GZIP);
+        HttpResponseBody body = mock(HttpResponseBody.class);
+        HttpMessage message =
+                new HttpMessage(
+                        mock(HttpRequestHeader.class), mock(HttpRequestBody.class), header, body);
+        // When
+        message.setResponseBody(new byte[0]);
+        // Then
+        assertThat(encodings(body), is(not(empty())));
+    }
+
+    @Test
+    void shouldSetContentEncodingsWhenSettingResponseBodyString() {
+        // Given
+        HttpResponseHeader header = mock(HttpResponseHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(HttpHeader.GZIP);
+        HttpResponseBody body = mock(HttpResponseBody.class);
+        HttpMessage message =
+                new HttpMessage(
+                        mock(HttpRequestHeader.class), mock(HttpRequestBody.class), header, body);
+        // When
+        message.setResponseBody("Body");
+        // Then
+        assertThat(encodings(body), is(not(empty())));
+    }
+
+    @ParameterizedTest
+    @ValueSource(strings = {HttpHeader.GZIP, "x-gzip"})
+    void shouldSetGzipEncodingToBody(String contentEncodingHeader) {
+        // Given
+        HttpHeader header = mock(HttpHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncodingHeader);
+        HttpBody body = mock(HttpBody.class);
+        // When
+        HttpMessage.setContentEncodings(header, body);
+        // Then
+        verify(body).setContentEncodings(asList(HttpEncodingGzip.getSingleton()));
+    }
+
+    @Test
+    void shouldSetDeflateEncodingToBody() {
+        // Given
+        HttpHeader header = mock(HttpHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(HttpHeader.DEFLATE);
+        HttpBody body = mock(HttpBody.class);
+        // When
+        HttpMessage.setContentEncodings(header, body);
+        // Then
+        verify(body).setContentEncodings(asList(HttpEncodingDeflate.getSingleton()));
+    }
+
+    @ParameterizedTest
+    @NullAndEmptySource
+    void shouldNotSetContentEncodingToBodyIfContentEncodingIsNotPresentOrIsEmpty(
+            String contentEncoding) {
+        // Given
+        HttpHeader header = mock(HttpHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
+        HttpBody body = mock(HttpBody.class);
+        // When
+        HttpMessage.setContentEncodings(header, body);
+        // Then
+        verify(body).setContentEncodings(Collections.emptyList());
+    }
+
+    @Test
+    void shouldNotSetContentEncodingToBodyIfContentEncodingNotSupported() {
+        // Given
+        HttpHeader header = mock(HttpHeader.class);
+        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn("Encoding Not Supported");
+        HttpBody body = mock(HttpBody.class);
+        // When
+        HttpMessage.setContentEncodings(header, body);
+        // Then
+        verify(body).setContentEncodings(Collections.emptyList());
+    }
+
     private static HttpMessage newHttpMessage() throws Exception {
         HttpMessage message =
                 new HttpMessage(
@@ -204,4 +354,11 @@ public class HttpMessageUnitTest {
         message.setResponseFromTargetHost(true);
         return message;
     }
+
+    private static List<HttpEncoding> encodings(HttpBody body) {
+        @SuppressWarnings("unchecked")
+        ArgumentCaptor<List<HttpEncoding>> arg = ArgumentCaptor.forClass(List.class);
+        verify(body).setContentEncodings(arg.capture());
+        return arg.getValue();
+    }
 }
diff --git a/zap/src/test/java/org/parosproxy/paros/network/HttpSenderUnitTest.java b/zap/src/test/java/org/parosproxy/paros/network/HttpSenderUnitTest.java
index f1a93a9b4..46b7aebed 100644
--- a/zap/src/test/java/org/parosproxy/paros/network/HttpSenderUnitTest.java
+++ b/zap/src/test/java/org/parosproxy/paros/network/HttpSenderUnitTest.java
@@ -28,8 +28,10 @@ import static com.github.tomakehurst.wiremock.client.WireMock.matching;
 import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;
 import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.not;
 
 import com.github.tomakehurst.wiremock.WireMockServer;
 import com.github.tomakehurst.wiremock.client.VerificationException;
@@ -206,6 +208,39 @@ public class HttpSenderUnitTest {
         assertThat(message.getResponseBody().toString(), is(equalTo(PROXY_RESPONSE)));
     }
 
+    @Test
+    void shouldSetContentEncodingsToResponse() throws Exception {
+        // Given
+        server.stubFor(
+                get(urlMatching("/"))
+                        .willReturn(
+                                aResponse()
+                                        .withHeader(HttpHeader.CONTENT_ENCODING, HttpHeader.GZIP)));
+        HttpMessage message = createMessage("GET", "/");
+        HttpSender httpSender = new HttpSender(createOptions(), false, -1);
+        // When
+        httpSender.sendAndReceive(message);
+        // Then
+        server.verifyExactly(
+                getRequestedFor(urlMatching("/"))
+                        .withHeader("Host", matching("localhost:" + server.port())));
+        assertThat(message.getResponseBody().getContentEncodings(), is(not(empty())));
+    }
+
+    @Test
+    void shouldNotSetContentEncodingsToResponseIfNoneInHeader() throws Exception {
+        // Given
+        HttpMessage message = createMessage("GET", "/");
+        HttpSender httpSender = new HttpSender(createOptions(), false, -1);
+        // When
+        httpSender.sendAndReceive(message);
+        // Then
+        server.verifyExactly(
+                getRequestedFor(urlMatching("/"))
+                        .withHeader("Host", matching("localhost:" + server.port())));
+        assertThat(message.getResponseBody().getContentEncodings(), is(empty()));
+    }
+
     private HttpMessage createMessage(String method, String path) throws Exception {
         URI uri = new URI("http://localhost:" + server.port() + path, true);
         HttpRequestHeader requestHeader = new HttpRequestHeader(method, uri, "HTTP/1.1");
diff --git a/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/BodyByteHttpPanelViewModelTest.java b/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/BodyByteHttpPanelViewModelTest.java
index 655c14bfb..4cd1a28b1 100644
--- a/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/BodyByteHttpPanelViewModelTest.java
+++ b/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/BodyByteHttpPanelViewModelTest.java
@@ -29,10 +29,7 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.nio.charset.Charset;
-import java.util.zip.GZIPOutputStream;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.parosproxy.paros.network.HttpBody;
@@ -84,21 +81,9 @@ public abstract class BodyByteHttpPanelViewModelTest<T1 extends HttpHeader, T2 e
     }
 
     @Test
-    void shouldGetDataFromBody() {
+    void shouldGetDataFromBodyAsContent() {
         // Given
-        model.setMessage(message);
-        // When
-        byte[] data = model.getData();
-        // Then
-        assertThat(data, is(equalTo(BODY)));
-    }
-
-    @Test
-    void shouldGetDataFromBodyGzipDecoded() {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn("gzip");
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        given(body.getBytes()).willReturn(gzip(BODY));
+        given(body.getContent()).willReturn(BODY);
         model.setMessage(message);
         // When
         byte[] data = model.getData();
@@ -115,41 +100,14 @@ public abstract class BodyByteHttpPanelViewModelTest<T1 extends HttpHeader, T2 e
     }
 
     @Test
-    void shouldSetDataIntoBody() {
+    void shouldSetDataIntoBodyAsContent() {
         // Given
         model.setMessage(message);
         byte[] otherBodyContent = "Other Body".getBytes(DEFAULT_CHARSET);
-        given(body.length()).willReturn(otherBodyContent.length);
         // When
         model.setData(otherBodyContent);
         // Then
-        verify(body).setBody(otherBodyContent);
+        verify(body).setContent(otherBodyContent);
         verify(header, times(0)).setContentLength(anyInt());
     }
-
-    @Test
-    void shouldSetDataIntoBodyGzipEncoded() {
-        // Given
-        model.setMessage(message);
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn("gzip");
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        byte[] otherBodyContent = "Other Body".getBytes(DEFAULT_CHARSET);
-        byte[] encodedBody = gzip(otherBodyContent);
-        given(body.length()).willReturn(encodedBody.length);
-        // When
-        model.setData(otherBodyContent);
-        // Then
-        verify(body).setBody(encodedBody);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    private static byte[] gzip(byte[] value) {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        try (GZIPOutputStream gis = new GZIPOutputStream(baos)) {
-            gis.write(value);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-        return baos.toByteArray();
-    }
 }
diff --git a/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/BodyStringHttpPanelViewModelTest.java b/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/BodyStringHttpPanelViewModelTest.java
index 0226fb730..59e3b7f66 100644
--- a/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/BodyStringHttpPanelViewModelTest.java
+++ b/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/BodyStringHttpPanelViewModelTest.java
@@ -30,10 +30,6 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.zip.GZIPOutputStream;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.parosproxy.paros.network.HttpBody;
@@ -42,10 +38,7 @@ import org.parosproxy.paros.network.HttpMessage;
 
 public abstract class BodyStringHttpPanelViewModelTest<T1 extends HttpHeader, T2 extends HttpBody> {
 
-    private static final Charset DEFAULT_CHARSET = Charset.forName(HttpBody.DEFAULT_CHARSET);
-
     private static final String BODY = "Body 123 ABC";
-    private static final byte[] BODY_BYTES_DEFAULT_CHARSET = BODY.getBytes(DEFAULT_CHARSET);
 
     private AbstractHttpStringHttpPanelViewModel model;
 
@@ -85,21 +78,9 @@ public abstract class BodyStringHttpPanelViewModelTest<T1 extends HttpHeader, T2
     }
 
     @Test
-    void shouldGetDataFromBody() {
-        // Given
-        model.setMessage(message);
-        // When
-        String data = model.getData();
-        // Then
-        assertThat(data, is(equalTo(BODY)));
-    }
-
-    @Test
-    void shouldGetDataFromBodyGzipDecoded() {
+    void shouldGetDataFromBodyAsString() {
         // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn("gzip");
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        given(body.getBytes()).willReturn(gzip(BODY_BYTES_DEFAULT_CHARSET));
+        given(body.toString()).willReturn(BODY);
         model.setMessage(message);
         // When
         String data = model.getData();
@@ -116,41 +97,14 @@ public abstract class BodyStringHttpPanelViewModelTest<T1 extends HttpHeader, T2
     }
 
     @Test
-    void shouldSetDataIntoBody() {
+    void shouldSetDataIntoBodyAsContent() {
         // Given
         model.setMessage(message);
         String otherBodyContent = "Other Body";
-        given(body.length()).willReturn(otherBodyContent.length());
         // When
         model.setData(otherBodyContent);
         // Then
         verify(body).setBody(otherBodyContent);
         verify(header, times(0)).setContentLength(anyInt());
     }
-
-    @Test
-    void shouldSetDataIntoBodyGzipEncoded() {
-        // Given
-        model.setMessage(message);
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn("gzip");
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        String otherBodyContent = "Other Body";
-        byte[] encodedBody = gzip(otherBodyContent.getBytes(DEFAULT_CHARSET));
-        given(body.length()).willReturn(encodedBody.length);
-        // When
-        model.setData(otherBodyContent);
-        // Then
-        verify(body).setBody(encodedBody);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    private static byte[] gzip(byte[] value) {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        try (GZIPOutputStream gis = new GZIPOutputStream(baos)) {
-            gis.write(value);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-        return baos.toByteArray();
-    }
 }
diff --git a/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/HttpPanelViewModelUtilsUnitTest.java b/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/HttpPanelViewModelUtilsUnitTest.java
index 131b424aa..0be284110 100644
--- a/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/HttpPanelViewModelUtilsUnitTest.java
+++ b/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/HttpPanelViewModelUtilsUnitTest.java
@@ -22,26 +22,15 @@ package org.zaproxy.zap.extension.httppanel.view.impl.models.http;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
-import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
-import java.util.stream.Stream;
-import java.util.zip.GZIPOutputStream;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.MethodSource;
 import org.junit.jupiter.params.provider.ValueSource;
-import org.parosproxy.paros.network.HttpBody;
-import org.parosproxy.paros.network.HttpHeader;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpRequestHeader;
 import org.parosproxy.paros.network.HttpResponseHeader;
@@ -51,22 +40,6 @@ import org.zaproxy.zap.network.HttpResponseBody;
 /** Unit test for {@link HttpPanelViewModelUtils}. */
 class HttpPanelViewModelUtilsUnitTest {
 
-    private static final String UNSUPPORTED_ENCODING = "UnsupportedEncoding";
-
-    private static final Charset DEFAULT_CHARSET = Charset.forName(HttpBody.DEFAULT_CHARSET);
-
-    private static final String BODY = "Body 123 ABC";
-    private static final byte[] BODY_BYTES_DEFAULT_CHARSET = BODY.getBytes(DEFAULT_CHARSET);
-
-    private HttpHeader header;
-    private HttpBody body;
-
-    @BeforeEach
-    void setup() {
-        header = mock(HttpHeader.class);
-        body = mock(HttpBody.class);
-    }
-
     @Test
     void shouldUpdateRequestContentLength() {
         // Given
@@ -120,250 +93,4 @@ class HttpPanelViewModelUtilsUnitTest {
         // Then
         assertThat(pos, is(equalTo(-1)));
     }
-
-    @Test
-    void shouldGetBodyString() {
-        // Given
-        given(body.toString()).willReturn(BODY);
-        // When
-        String bodyString = HttpPanelViewModelUtils.getBodyString(header, body);
-        // Then
-        assertThat(bodyString, is(equalTo(BODY)));
-    }
-
-    @Test
-    void shouldGetBodyStringIgnoringUnsupportedEncoding() {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(UNSUPPORTED_ENCODING);
-        given(body.toString()).willReturn(BODY);
-        // When
-        String bodyString = HttpPanelViewModelUtils.getBodyString(header, body);
-        // Then
-        assertThat(bodyString, is(equalTo(BODY)));
-    }
-
-    @ParameterizedTest
-    @MethodSource(value = "gzipEncodingProvider")
-    void shouldGetBodyStringGzipDecoded(String contentEncoding) {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        given(body.getBytes()).willReturn(gzip(BODY_BYTES_DEFAULT_CHARSET));
-        // When
-        String bodyString = HttpPanelViewModelUtils.getBodyString(header, body);
-        // Then
-        assertThat(bodyString, is(equalTo(BODY)));
-    }
-
-    @ParameterizedTest
-    @MethodSource(value = "gzipEncodingProvider")
-    void shouldGetBodyStringAsOriginalIfNotProperlyGzipEncoded(String contentEncoding) {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        given(body.getBytes()).willReturn(new byte[] {'N', 'o', 't', ' ', 'G', 'Z', 'I', 'P'});
-        given(body.toString()).willReturn(BODY);
-        // When
-        String bodyString = HttpPanelViewModelUtils.getBodyString(header, body);
-        // Then
-        assertThat(bodyString, is(equalTo(BODY)));
-    }
-
-    @ParameterizedTest
-    @MethodSource(value = "gzipEncodingProvider")
-    void shouldGetBodyStringGzipDecodedEvenWithDataLossDueStringToByteConversion(
-            String contentEncoding) {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        byte[] bytes = " a  z ".getBytes(StandardCharsets.UTF_8);
-        given(body.getBytes()).willReturn(gzip(bytes));
-        String expectedBodyString = new String(bytes, DEFAULT_CHARSET);
-        // When
-        String bodyString = HttpPanelViewModelUtils.getBodyString(header, body);
-        // Then
-        assertThat(bodyString, is(equalTo(expectedBodyString)));
-    }
-
-    @Test
-    void shouldGetBodyBytes() {
-        // Given
-        given(body.getBytes()).willReturn(BODY_BYTES_DEFAULT_CHARSET);
-        // When
-        byte[] bodyBytes = HttpPanelViewModelUtils.getBodyBytes(header, body);
-        // Then
-        assertThat(bodyBytes, is(equalTo(BODY_BYTES_DEFAULT_CHARSET)));
-    }
-
-    @Test
-    void shouldGetBodyBytesIgnoringUnsupportedEncoding() {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(UNSUPPORTED_ENCODING);
-        given(body.getBytes()).willReturn(BODY_BYTES_DEFAULT_CHARSET);
-        // When
-        byte[] bodyBytes = HttpPanelViewModelUtils.getBodyBytes(header, body);
-        // Then
-        assertThat(bodyBytes, is(equalTo(BODY_BYTES_DEFAULT_CHARSET)));
-    }
-
-    @ParameterizedTest
-    @MethodSource(value = "gzipEncodingProvider")
-    void shouldGetBodyBytesGzipDecoded(String contentEncoding) {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
-        given(body.getBytes()).willReturn(gzip(BODY_BYTES_DEFAULT_CHARSET));
-        // When
-        byte[] bodyBytes = HttpPanelViewModelUtils.getBodyBytes(header, body);
-        // Then
-        assertThat(bodyBytes, is(equalTo(BODY_BYTES_DEFAULT_CHARSET)));
-    }
-
-    @ParameterizedTest
-    @MethodSource(value = "gzipEncodingProvider")
-    void shouldGetBodyBytesAsOriginalIfNotProperlyGzipEncoded(String contentEncoding) {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
-        byte[] content = new byte[] {'N', 'o', 't', ' ', 'G', 'Z', 'I', 'P'};
-        given(body.getBytes()).willReturn(content);
-        // When
-        byte[] bodyBytes = HttpPanelViewModelUtils.getBodyBytes(header, body);
-        // Then
-        assertThat(bodyBytes, is(equalTo(content)));
-    }
-
-    @Test
-    void shouldSetBodyString() {
-        // Given
-        given(body.length()).willReturn(BODY.length());
-        // When
-        HttpPanelViewModelUtils.setBody(header, body, BODY);
-        // Then
-        verify(body).setBody(BODY);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    @Test
-    void shouldSetBodyStringIgnoringUnsupportedEncoding() {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(UNSUPPORTED_ENCODING);
-        given(body.length()).willReturn(BODY.length());
-        // When
-        HttpPanelViewModelUtils.setBody(header, body, BODY);
-        // Then
-        verify(body).setBody(BODY);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    @Test
-    void shouldSetBodyStringWithHeaderCharset() {
-        // Given
-        Charset charset = StandardCharsets.UTF_8;
-        given(header.getCharset()).willReturn(charset.name());
-        String bodyContent = " a  z ";
-        given(body.length()).willReturn(bodyContent.length());
-        // When
-        HttpPanelViewModelUtils.setBody(header, body, bodyContent);
-        // Then
-        verify(body).setCharset(charset.name());
-        verify(body).setBody(bodyContent);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    @ParameterizedTest
-    @MethodSource(value = "gzipEncodingProvider")
-    void shouldSetBodyStringAndGzipEncode(String contentEncoding) {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
-        byte[] gzip = gzip(BODY_BYTES_DEFAULT_CHARSET);
-        given(body.length()).willReturn(gzip.length);
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        // When
-        HttpPanelViewModelUtils.setBody(header, body, BODY);
-        // Then
-        verify(body).setBody(gzip);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    @ParameterizedTest
-    @MethodSource(value = "gzipEncodingProvider")
-    void shouldSetBodyStringAndGzipEncodeEvenWithDataLossDueStringToByteConversion(
-            String contentEncoding) {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
-        String bodyContent = " a  z ";
-        byte[] gzip = gzip(bodyContent.getBytes(DEFAULT_CHARSET));
-        given(body.length()).willReturn(gzip.length);
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        // When
-        HttpPanelViewModelUtils.setBody(header, body, bodyContent);
-        // Then
-        verify(body).setBody(gzip);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    @Test
-    void shouldSetBodyBytes() {
-        // Given
-        given(body.length()).willReturn(BODY_BYTES_DEFAULT_CHARSET.length);
-        // When
-        HttpPanelViewModelUtils.setBody(header, body, BODY_BYTES_DEFAULT_CHARSET);
-        // Then
-        verify(body).setBody(BODY_BYTES_DEFAULT_CHARSET);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    @Test
-    void shouldSetBodyBytesIgnoringUnsupportedEncoding() {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(UNSUPPORTED_ENCODING);
-        given(body.length()).willReturn(BODY_BYTES_DEFAULT_CHARSET.length);
-        // When
-        HttpPanelViewModelUtils.setBody(header, body, BODY_BYTES_DEFAULT_CHARSET);
-        // Then
-        verify(body).setBody(BODY_BYTES_DEFAULT_CHARSET);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    @Test
-    void shouldSetBodyBytesWithHeaderCharset() {
-        // Given
-        Charset charset = StandardCharsets.UTF_8;
-        given(header.getCharset()).willReturn(charset.name());
-        byte[] bodyContent = " a  z ".getBytes(charset);
-        given(body.length()).willReturn(bodyContent.length);
-        // When
-        HttpPanelViewModelUtils.setBody(header, body, bodyContent);
-        // Then
-        verify(body).setCharset(charset.name());
-        verify(body).setBody(bodyContent);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    @ParameterizedTest
-    @MethodSource(value = "gzipEncodingProvider")
-    void shouldSetBodyBytesAndGzipEncode(String contentEncoding) {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn(contentEncoding);
-        byte[] gzip = gzip(BODY_BYTES_DEFAULT_CHARSET);
-        given(body.length()).willReturn(gzip.length);
-        // When
-        HttpPanelViewModelUtils.setBody(header, body, BODY_BYTES_DEFAULT_CHARSET);
-        // Then
-        verify(body).setBody(gzip);
-        verify(header, times(0)).setContentLength(anyInt());
-    }
-
-    static Stream<String> gzipEncodingProvider() {
-        return Stream.of("gzip", "gZiP", " gzip  ", "x-gzip", "X-gZiP", "  x-gzip ");
-    }
-
-    private static byte[] gzip(byte[] value) {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        try (GZIPOutputStream gis = new GZIPOutputStream(baos)) {
-            gis.write(value);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-        return baos.toByteArray();
-    }
 }
diff --git a/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/StringHttpPanelViewModelTest.java b/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/StringHttpPanelViewModelTest.java
index 31e5b3ad5..ceece65b0 100644
--- a/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/StringHttpPanelViewModelTest.java
+++ b/zap/src/test/java/org/zaproxy/zap/extension/httppanel/view/impl/models/http/StringHttpPanelViewModelTest.java
@@ -20,7 +20,6 @@
 package org.zaproxy.zap.extension.httppanel.view.impl.models.http;
 
 import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.endsWith;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.isEmptyString;
@@ -33,10 +32,6 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.zip.GZIPOutputStream;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.parosproxy.paros.Constant;
@@ -49,14 +44,11 @@ import org.zaproxy.zap.utils.I18N;
 
 public abstract class StringHttpPanelViewModelTest<T1 extends HttpHeader, T2 extends HttpBody> {
 
-    private static final Charset DEFAULT_CHARSET = Charset.forName(HttpBody.DEFAULT_CHARSET);
-
     private static final String HEADER = "Start Line\r\nHeader1: A\r\nHeader2: B";
     private static final String HEADER_WITH_SEPARATOR = HEADER + "\r\n\r\n";
     private static final String HEADER_LINEFEEDS = HEADER.replace(HttpHeader.CRLF, HttpHeader.LF);
 
     private static final String BODY = "Body\r\n 123\n ABC";
-    private static final byte[] BODY_BYTES_DEFAULT_CHARSET = BODY.getBytes(DEFAULT_CHARSET);
 
     protected AbstractHttpStringHttpPanelViewModel model;
 
@@ -116,19 +108,6 @@ public abstract class StringHttpPanelViewModelTest<T1 extends HttpHeader, T2 ext
         assertThat(data, is(equalTo(HEADER_LINEFEEDS + "\n\n" + BODY)));
     }
 
-    @Test
-    void shouldGetDataFromBodyGzipDecoded() {
-        // Given
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn("gzip");
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        given(body.getBytes()).willReturn(gzip(BODY_BYTES_DEFAULT_CHARSET));
-        model.setMessage(message);
-        // When
-        String data = model.getData();
-        // Then
-        assertThat(data, endsWith(BODY));
-    }
-
     @Test
     void shouldNotSetDataWithNullMessage() {
         // Given
@@ -181,32 +160,4 @@ public abstract class StringHttpPanelViewModelTest<T1 extends HttpHeader, T2 ext
         verify(header, times(0)).setContentLength(anyInt());
         verify(body).setBody("");
     }
-
-    @Test
-    void shouldSetDataIntoBodyGzipEncoded() throws HttpMalformedHeaderException {
-        // Given
-        model.setMessage(message);
-        given(header.getHeader(HttpHeader.CONTENT_ENCODING)).willReturn("gzip");
-        given(body.getCharset()).willReturn(DEFAULT_CHARSET.name());
-        String otherBodyContent = "Other Body\r\n 123\n ABC";
-        String data = HEADER_LINEFEEDS + "\n\n" + otherBodyContent;
-        byte[] encodedBody = gzip(otherBodyContent.getBytes(DEFAULT_CHARSET));
-        given(body.length()).willReturn(encodedBody.length);
-        // When
-        model.setData(data);
-        // Then
-        verifyHeader(HEADER);
-        verify(header, times(0)).setContentLength(anyInt());
-        verify(body).setBody(encodedBody);
-    }
-
-    private static byte[] gzip(byte[] value) {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        try (GZIPOutputStream gis = new GZIPOutputStream(baos)) {
-            gis.write(value);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-        return baos.toByteArray();
-    }
 }
diff --git a/zap/src/test/java/org/zaproxy/zap/network/HttpEncodingDeflateUnitTest.java b/zap/src/test/java/org/zaproxy/zap/network/HttpEncodingDeflateUnitTest.java
new file mode 100644
index 000000000..39fb07448
--- /dev/null
+++ b/zap/src/test/java/org/zaproxy/zap/network/HttpEncodingDeflateUnitTest.java
@@ -0,0 +1,75 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.is;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.zip.DeflaterOutputStream;
+import org.junit.jupiter.api.Test;
+
+/** Unit test for {@link HttpEncodingDeflate}. */
+class HttpEncodingDeflateUnitTest {
+
+    private static final byte[] CONTENT = "Content 123 ABC".getBytes(StandardCharsets.UTF_8);
+    private static final byte[] CONTENT_ENCODED = deflate(CONTENT);
+
+    private HttpEncodingDeflate encoding = HttpEncodingDeflate.getSingleton();
+
+    @Test
+    void shouldEncodeContent() throws IOException {
+        // Given / When
+        byte[] encodedContent = encoding.encode(CONTENT);
+        // Then
+        assertThat(encodedContent, is(equalTo(CONTENT_ENCODED)));
+    }
+
+    @Test
+    void shouldDecodeContent() throws IOException {
+        // Given / When
+        byte[] decodedContent = encoding.decode(CONTENT_ENCODED);
+        // Then
+        assertThat(decodedContent, is(equalTo(CONTENT)));
+    }
+
+    @Test
+    void shouldThrowExceptionWhenDecodingIfNotProperlyEncoded() {
+        // Given
+        byte[] invalidContent = new byte[] {'I', 'n', 'v', 'a', 'l', 'i', 'd'};
+        // When / Then
+        assertThrows(IOException.class, () -> encoding.decode(invalidContent));
+    }
+
+    private static byte[] deflate(byte[] value) {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try (OutputStream os = new DeflaterOutputStream(baos)) {
+            os.write(value);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+        return baos.toByteArray();
+    }
+}
diff --git a/zap/src/test/java/org/zaproxy/zap/network/HttpEncodingGzipUnitTest.java b/zap/src/test/java/org/zaproxy/zap/network/HttpEncodingGzipUnitTest.java
new file mode 100644
index 000000000..43584c8a3
--- /dev/null
+++ b/zap/src/test/java/org/zaproxy/zap/network/HttpEncodingGzipUnitTest.java
@@ -0,0 +1,75 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ *
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ *
+ * Copyright 2020 The ZAP Development Team
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.network;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.is;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.zip.GZIPOutputStream;
+import org.junit.jupiter.api.Test;
+
+/** Unit test for {@link HttpEncodingGzip}. */
+class HttpEncodingGzipUnitTest {
+
+    private static final byte[] CONTENT = "Content 123 ABC".getBytes(StandardCharsets.UTF_8);
+    private static final byte[] CONTENT_ENCODED = gzip(CONTENT);
+
+    private HttpEncodingGzip encoding = HttpEncodingGzip.getSingleton();
+
+    @Test
+    void shouldEncodeContent() throws IOException {
+        // Given / When
+        byte[] encodedContent = encoding.encode(CONTENT);
+        // Then
+        assertThat(encodedContent, is(equalTo(CONTENT_ENCODED)));
+    }
+
+    @Test
+    void shouldDecodeContent() throws IOException {
+        // Given / When
+        byte[] decodedContent = encoding.decode(CONTENT_ENCODED);
+        // Then
+        assertThat(decodedContent, is(equalTo(CONTENT)));
+    }
+
+    @Test
+    void shouldThrowExceptionWhenDecodingIfNotProperlyEncoded() {
+        // Given
+        byte[] invalidContent = new byte[] {'I', 'n', 'v', 'a', 'l', 'i', 'd'};
+        // When / Then
+        assertThrows(IOException.class, () -> encoding.decode(invalidContent));
+    }
+
+    private static byte[] gzip(byte[] value) {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try (OutputStream os = new GZIPOutputStream(baos)) {
+            os.write(value);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+        return baos.toByteArray();
+    }
+}
