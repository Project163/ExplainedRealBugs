diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index e776cd452..0f6b33e76 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -2010,6 +2010,7 @@ spider.api.action.removeDomainAlwaysInScope = Removes a domain that's always in
 spider.api.action.enableAllDomainsAlwaysInScope = Enables all domains that are always in scope.
 spider.api.action.disableAllDomainsAlwaysInScope = Disables all domains that are always in scope.
 spider.api.action.setOptionMaxChildren = Sets the maximum number of child nodes (per node) that can be crawled, 0 means no limit.
+spider.api.action.setOptionMaxParseSizeBytes = Sets the maximum size, in bytes, that a response might have to be parsed. This allows the spider to skip big responses/files.
 spider.api.action.scan = Runs the spider against the given URL (or context). Optionally, the 'maxChildren' parameter can be set to limit the number of children scanned, the 'recurse' parameter can be used to prevent the spider from seeding recursively, the parameter 'contextName' can be used to constrain the scan to a Context and the parameter 'subtreeOnly' allows to restrict the spider under a site's subtree (using the specified 'url').
 spider.api.action.scanAsUser = Runs the spider from the perspective of a User, obtained using the given Context ID and User ID. See 'scan' action for more details.
 spider.api.action.setOptionScopeString = Use actions [add|modify|remove]DomainAlwaysInScope instead.
@@ -2017,6 +2018,7 @@ spider.api.view.allUrls = Returns a list of unique URLs from the history table b
 spider.api.view.domainsAlwaysInScope = Gets all the domains that are always in scope. For each domain the following are shown: the index, the value (domain), if enabled, and if specified as a regex.
 spider.api.view.optionAcceptCookies = Gets whether or not a spider process should accept cookies while spidering.
 spider.api.view.optionMaxChildren = Gets the maximum number of child nodes (per node) that can be crawled, 0 means no limit.
+spider.api.view.optionMaxParseSizeBytes = Gets the maximum size, in bytes, that a response might have to be parsed.
 spider.api.view.optionSendRefererHeader = Gets whether or not the 'Referer' header should be sent while spidering.
 spider.api.view.excludedFromScan = Gets the regexes of URLs excluded from the spider scans.
 spider.api.view.optionDomainsAlwaysInScope = Use view domainsAlwaysInScope instead.
@@ -2028,6 +2030,7 @@ spider.custom.label.context	= Context:
 spider.custom.label.maxChildren		= Maximum children to crawl (0 is unlimited):
 spider.custom.label.maxDepth		= Maximum depth to crawl:
 spider.custom.label.maxDuration		= Maximum duration (min, 0 is unlimited):
+spider.custom.label.maxParseSizeBytes = Maximum parse size (bytes):
 spider.custom.label.acceptcookies = Accept Cookies:
 spider.custom.label.sendReferer		= Send 'Referer' header:
 spider.custom.label.postForms		= POST forms:
@@ -2083,6 +2086,7 @@ spider.options.label.threads    = Number of threads used:
 spider.options.label.comments	= Parse HTML Comments  
 spider.options.label.duration	= Maximum duration (min, 0 is unlimited):
 spider.options.label.maxChildren = Maximum children to crawl (0 is unlimited):
+spider.options.label.maxParseSizeBytes = Maximum parse size (bytes):
 spider.options.label.robotstxt 	= Parse 'robots.txt' files for new URIs
 spider.options.label.sitemapxml = Parse 'sitemap.xml' files for new URIs
 spider.options.label.svnentries = Parse SVN metadata files for new URIs
diff --git a/src/org/zaproxy/zap/extension/spider/OptionsSpiderPanel.java b/src/org/zaproxy/zap/extension/spider/OptionsSpiderPanel.java
index 8647e38fc..ada09aa69 100644
--- a/src/org/zaproxy/zap/extension/spider/OptionsSpiderPanel.java
+++ b/src/org/zaproxy/zap/extension/spider/OptionsSpiderPanel.java
@@ -76,6 +76,7 @@ public class OptionsSpiderPanel extends AbstractParamPanel {
 	private JSlider sliderThreads = null;
 	private ZapNumberSpinner durationNumberSpinner = null;
 	private ZapNumberSpinner maxChildrenNumberSpinner;
+	private ZapNumberSpinner maxParseSizeBytesNumberSpinner;
 	private JCheckBox chkPostForm = null;
 	private JCheckBox chkProcessForm = null;
 	private JCheckBox parseComments = null;
@@ -163,6 +164,12 @@ public class OptionsSpiderPanel extends AbstractParamPanel {
 					new JLabel(Constant.messages.getString("spider.options.label.maxChildren")),
 					LayoutHelper.getGBC(0, 1, 1, 1.0D));
 			inlineOptionsPanel.add(getMaxChildrenNumberSpinner(), LayoutHelper.getGBC(1, 1, 1, 1.0D));
+
+			inlineOptionsPanel.add(
+					new JLabel(Constant.messages.getString("spider.options.label.maxParseSizeBytes")),
+					LayoutHelper.getGBC(0, 2, 1, 1.0D));
+			inlineOptionsPanel.add(getMaxParseSizeBytesNumberSpinner(), LayoutHelper.getGBC(1, 2, 1, 1.0D));
+
 			innerPanel.add(inlineOptionsPanel, gbc);
 			
 			innerPanel.add(domainsLabel, gbc);
@@ -203,6 +210,7 @@ public class OptionsSpiderPanel extends AbstractParamPanel {
 		getSliderThreads().setValue(param.getThreadCount());
 		getDurationNumberSpinner().setValue(param.getMaxDuration());
 		getMaxChildrenNumberSpinner().setValue(param.getMaxChildren());
+		getMaxParseSizeBytesNumberSpinner().setValue(param.getMaxParseSizeBytes());
 		getDomainsAlwaysInScopeTableModel().setDomainsAlwaysInScope(param.getDomainsAlwaysInScope());
 		getDomainsAlwaysInScopePanel().setRemoveWithoutConfirmation(param.isConfirmRemoveDomainAlwaysInScope());
 		getChkProcessForm().setSelected(param.isProcessForm());
@@ -227,6 +235,7 @@ public class OptionsSpiderPanel extends AbstractParamPanel {
 		param.setThreadCount(getSliderThreads().getValue());
 		param.setMaxDuration(getDurationNumberSpinner().getValue());
 		param.setMaxChildren(getMaxChildrenNumberSpinner().getValue());
+		param.setMaxParseSizeBytes(getMaxParseSizeBytesNumberSpinner().getValue());
 		param.setDomainsAlwaysInScope(getDomainsAlwaysInScopeTableModel().getDomainsAlwaysInScope());
 		param.setConfirmRemoveDomainAlwaysInScope(getDomainsAlwaysInScopePanel().isRemoveWithoutConfirmation());
 		param.setSendRefererHeader(getChkSendRefererHeader().isSelected());
@@ -289,6 +298,13 @@ public class OptionsSpiderPanel extends AbstractParamPanel {
 		return maxChildrenNumberSpinner;
 	}
 
+	private ZapNumberSpinner getMaxParseSizeBytesNumberSpinner() {
+		if (maxParseSizeBytesNumberSpinner == null) {
+			maxParseSizeBytesNumberSpinner = new ZapNumberSpinner(0, 0, Integer.MAX_VALUE);
+		}
+		return maxParseSizeBytesNumberSpinner;
+	}
+
 	private JCheckBox getChkSendRefererHeader() {
 		if (chkSendRefererHeader == null) {
 			chkSendRefererHeader = new JCheckBox(Constant.messages.getString("spider.options.label.sendRefererHeader"));
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderDialog.java b/src/org/zaproxy/zap/extension/spider/SpiderDialog.java
index 02f7ae165..88669ec94 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderDialog.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderDialog.java
@@ -56,6 +56,7 @@ public class SpiderDialog extends StandardFieldsDialog {
     private static final String FIELD_MAX_DEPTH = "spider.custom.label.maxDepth"; 
     private static final String FIELD_MAX_CHILDREN = "spider.custom.label.maxChildren"; 
     private static final String FIELD_MAX_DURATION = "spider.custom.label.maxDuration"; 
+    private static final String FIELD_MAX_PARSE_SIZE_BYTES = "spider.custom.label.maxParseSizeBytes";
     private static final String FIELD_SEND_REFERER = "spider.custom.label.sendReferer";
     private static final String FIELD_ACCEPT_COOKIES = "spider.custom.label.acceptcookies";
     private static final String FIELD_PROCESS_FORMS = "spider.custom.label.processForms"; 
@@ -123,6 +124,7 @@ public class SpiderDialog extends StandardFieldsDialog {
         this.addNumberField(1, FIELD_MAX_DEPTH, 1, 19, getSpiderParam().getMaxDepth());
         this.addNumberField(1, FIELD_MAX_CHILDREN, 0, Integer.MAX_VALUE, getSpiderParam().getMaxChildren());
         this.addNumberField(1, FIELD_MAX_DURATION, 0, Integer.MAX_VALUE, getSpiderParam().getMaxDuration());
+        this.addNumberField(1, FIELD_MAX_PARSE_SIZE_BYTES, 0, Integer.MAX_VALUE, getSpiderParam().getMaxParseSizeBytes());
         this.addCheckBoxField(1, FIELD_SEND_REFERER, getSpiderParam().isSendRefererHeader());
         this.addCheckBoxField(1, FIELD_ACCEPT_COOKIES, getSpiderParam().isAcceptCookies());
         this.addCheckBoxField(1, FIELD_PROCESS_FORMS, getSpiderParam().isProcessForm());
@@ -305,6 +307,7 @@ public class SpiderDialog extends StandardFieldsDialog {
         	spiderParam.setMaxDepth(this.getIntValue(FIELD_MAX_DEPTH));
         	spiderParam.setMaxDuration(this.getIntValue(FIELD_MAX_DURATION));
         	spiderParam.setMaxChildren(this.getIntValue(FIELD_MAX_CHILDREN));
+        	spiderParam.setMaxParseSizeBytes(this.getIntValue(FIELD_MAX_PARSE_SIZE_BYTES));
         	spiderParam.setSendRefererHeader(this.getBoolValue(FIELD_SEND_REFERER));
         	spiderParam.setAcceptCookies(this.getBoolValue(FIELD_ACCEPT_COOKIES));
         	spiderParam.setProcessForm(this.getBoolValue(FIELD_PROCESS_FORMS));
diff --git a/src/org/zaproxy/zap/spider/Spider.java b/src/org/zaproxy/zap/spider/Spider.java
index f703413a1..3d5e134b7 100644
--- a/src/org/zaproxy/zap/spider/Spider.java
+++ b/src/org/zaproxy/zap/spider/Spider.java
@@ -196,7 +196,7 @@ public class Spider {
 		}
 
 		// Add a default parse filter and any custom ones
-		this.addParseFilter(new DefaultParseFilter());
+		this.addParseFilter(new DefaultParseFilter(spiderParam));
 		for (ParseFilter filter : extension.getCustomParseFilters())
 			this.addParseFilter(filter);
 		
diff --git a/src/org/zaproxy/zap/spider/SpiderParam.java b/src/org/zaproxy/zap/spider/SpiderParam.java
index 417bc43c2..dc3c05c4d 100644
--- a/src/org/zaproxy/zap/spider/SpiderParam.java
+++ b/src/org/zaproxy/zap/spider/SpiderParam.java
@@ -101,6 +101,17 @@ public class SpiderParam extends AbstractParam {
 	 */
 	private static final String SPIDER_ACCEPT_COOKIES = "spider.acceptCookies";
 
+	/**
+     * Configuration key to write/read the {@link #maxParseSizeBytes} flag.
+     */
+    private static final String SPIDER_MAX_PARSE_SIZE_BYTES = "spider.maxParseSizeBytes";
+
+    /**
+     * Default maximum size, in bytes, that a response might have to be parsed.
+     * 
+     * @see #maxParseSizeBytes
+     */
+    private static final int DEFAULT_MAX_PARSE_SIZE_BYTES = 2621440; // 2.5 MiB
 
 	/**
 	 * This option is used to define how the parameters are used when checking if an URI was already visited.
@@ -200,6 +211,17 @@ public class SpiderParam extends AbstractParam {
 	 */
 	private boolean acceptCookies = true;
 
+	/**
+	 * The maximum size, in bytes, that a response might have to be parsed.
+	 * <p>
+	 * Default value is {@value #DEFAULT_MAX_PARSE_SIZE_BYTES} bytes.
+	 * 
+	 * @see #SPIDER_MAX_PARSE_SIZE_BYTES
+	 * @see #getMaxParseSizeBytes()
+	 * @see #setMaxParseSizeBytes(int)
+	 */
+	private int maxParseSizeBytes = DEFAULT_MAX_PARSE_SIZE_BYTES;
+
 	/**
 	 * Instantiates a new spider param.
 	 * 
@@ -341,6 +363,14 @@ public class SpiderParam extends AbstractParam {
 			log.error("Error while loading the option \"" + SPIDER_ACCEPT_COOKIES + "\": " + e.getMessage(), e);
 			acceptCookies = true;
 		}
+
+        try {
+            this.maxParseSizeBytes = getConfig().getInteger(SPIDER_MAX_PARSE_SIZE_BYTES, DEFAULT_MAX_PARSE_SIZE_BYTES);
+        } catch (ConversionException e) {
+            log.error("Error while loading the option \"" + SPIDER_MAX_PARSE_SIZE_BYTES + "\": " + e.getMessage(), e);
+            maxParseSizeBytes = DEFAULT_MAX_PARSE_SIZE_BYTES;
+        }
+		
 	}
 
     private void updateOptions() {
@@ -1004,4 +1034,29 @@ public class SpiderParam extends AbstractParam {
         return acceptCookies;
     }
 
+    /**
+     * Sets the maximum size, in bytes, that a response might have to be parsed.
+     * <p>
+     * This allows the spider to skip big responses/files.
+     * 
+     * @param maxParseSizeBytes the maximum size, in bytes, that a response might have to be parsed.
+     * @since TODO add version
+     * @see #getMaxParseSizeBytes()
+     */
+    public void setMaxParseSizeBytes(int maxParseSizeBytes) {
+        this.maxParseSizeBytes = maxParseSizeBytes;
+        getConfig().setProperty(SPIDER_MAX_PARSE_SIZE_BYTES, maxParseSizeBytes);
+    }
+
+    /**
+     * Gets the maximum size, in bytes, that a response might have to be parsed.
+     *
+     * @return the maximum size, in bytes, that a response might have to be parsed.
+     * @since TODO add version
+     * @see #setMaxParseSizeBytes(int)
+     */
+    public int getMaxParseSizeBytes() {
+        return maxParseSizeBytes;
+    }
+
 }
diff --git a/src/org/zaproxy/zap/spider/filters/DefaultParseFilter.java b/src/org/zaproxy/zap/spider/filters/DefaultParseFilter.java
index 3cb8c2167..9f232e7ab 100644
--- a/src/org/zaproxy/zap/spider/filters/DefaultParseFilter.java
+++ b/src/org/zaproxy/zap/spider/filters/DefaultParseFilter.java
@@ -17,19 +17,18 @@
  */
 package org.zaproxy.zap.spider.filters;
 
-import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import org.apache.commons.httpclient.URIException;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpStatusCode;
+import org.zaproxy.zap.spider.SpiderParam;
 
 /**
  * The DefaultParseFilter is an implementation of a {@link ParseFilter} that is default for
  * spidering process. Its filter rules are the following:
  * <ul>
- * <li>the resource body should be under MAX_RESPONSE_BODY_SIZE bytes, otherwise it's probably a
- * binary resource.</li>
+ * <li>the resource body should be under a {@link SpiderParam#getMaxParseSizeBytes() number of bytes}, otherwise it's considered
+ * a binary resource.</li>
  * <li>the resource must be of parsable type (text, html, xml, javascript). Actually, the content
  * type should be text/...</li>
  * </ul>
@@ -39,48 +38,75 @@ public class DefaultParseFilter extends ParseFilter {
 	/**
 	 * The Constant MAX_RESPONSE_BODY_SIZE defining the size of response body that is considered too
 	 * big for a parsable file.
+	 * 
+	 * @deprecated (TODO add version) No longer in use, replaced by {@link SpiderParam#getMaxParseSizeBytes()}.
 	 */
+	@Deprecated
 	public static final int MAX_RESPONSE_BODY_SIZE = 512000;
 
 	/**
 	 * a pattern to match the SQLite based ".svn/wc.db" file name.
 	 */
-	private static final Pattern svnSQLiteFilenamePattern = Pattern.compile (".*/\\.svn/wc.db$");
+	private static final Pattern SVN_SQLITE_FILENAME_PATTERN = Pattern.compile (".*/\\.svn/wc.db$");
 
 	/**
 	 * a pattern to match the XML based ".svn/entries" file name.
 	 */
-	private static final Pattern svnXMLFilenamePattern = Pattern.compile (".*/\\.svn/entries$");
+	private static final Pattern SVN_XML_FILENAME_PATTERN = Pattern.compile (".*/\\.svn/entries$");
 
 	/**
 	 * a pattern to match the Git index file.
 	 */
-	private static final Pattern gitFilenamePattern = Pattern.compile (".*/\\.git/index$");
+	private static final Pattern GIT_FILENAME_PATTERN = Pattern.compile (".*/\\.git/index$");
 
+	/**
+	 * The configurations of the spider, never {@code null}.
+	 */
+	private final SpiderParam params;
+	
+	/**
+	 * Constructs a {@code DefaultParseFilter} with default configurations.
+	 *
+	 * @deprecated (TODO add version) Replaced by {@link #DefaultParseFilter(SpiderParam)}.
+	 */
+	@Deprecated
+	public DefaultParseFilter() {
+		this(new SpiderParam());
+	}
+
+	/**
+	 * Constructs a {@code DefaultParseFilter} with the given configurations.
+	 *
+	 * @param params the spider configurations
+	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @since TODO add version
+	 * @see SpiderParam#getMaxParseSizeBytes()
+	 */
+	public DefaultParseFilter(SpiderParam params) {
+		if (params == null) {
+			throw new IllegalArgumentException("Parameter params must not be null.");
+		}
+		this.params = params;
+	}
+	
 	@Override
 	public boolean isFiltered(HttpMessage responseMessage) {
+		if (responseMessage == null || responseMessage.getRequestHeader().isEmpty()
+				|| responseMessage.getResponseHeader().isEmpty()) {
+			return true;
+		}
 
 		//if it's a file ending in "/.svn/entries", or "/.svn/wc.db", the SVN Entries or Git parsers will process it 
 		//regardless of type, and regardless of whether it exceeds the file size restriction below.
-		
-		Matcher svnXMLFilenameMatcher, svnSQLiteFilenameMatcher, gitFilenameMatcher;
-		try {
-			String fullfilename = responseMessage.getRequestHeader().getURI().getPath();
-			//handle null paths
-			if (fullfilename == null) fullfilename = "";
-			svnSQLiteFilenameMatcher = svnSQLiteFilenamePattern.matcher(fullfilename);
-			svnXMLFilenameMatcher = svnXMLFilenamePattern.matcher(fullfilename);
-			gitFilenameMatcher = gitFilenamePattern.matcher(fullfilename);
-			
-			if ( svnSQLiteFilenameMatcher.find() || svnXMLFilenameMatcher.find() || gitFilenameMatcher.find())
-				return false;
-		} catch (URIException e) {
-			//give other parsers a chance to parse it.
-			log.error(e);			
+		String fullfilename = responseMessage.getRequestHeader().getURI().getEscapedPath();
+		if (fullfilename != null && (SVN_SQLITE_FILENAME_PATTERN.matcher(fullfilename).find()
+				|| SVN_XML_FILENAME_PATTERN.matcher(fullfilename).find()
+				|| GIT_FILENAME_PATTERN.matcher(fullfilename).find())) {
+			return false;
 		}
 
 		// Check response body size
-		if (responseMessage.getResponseBody().length() > MAX_RESPONSE_BODY_SIZE) {
+		if (responseMessage.getResponseBody().length() > params.getMaxParseSizeBytes()) {
 			if (log.isDebugEnabled()) {
 				log.debug("Resource too large: " + responseMessage.getRequestHeader().getURI());
 			}
@@ -88,8 +114,9 @@ public class DefaultParseFilter extends ParseFilter {
 		}
 
 		// If it's a redirection, accept it, as the SpiderRedirectParser will process it
-		if (HttpStatusCode.isRedirection(responseMessage.getResponseHeader().getStatusCode()))
+		if (HttpStatusCode.isRedirection(responseMessage.getResponseHeader().getStatusCode())) {
 			return false;
+		}
 		
 		// Check response type.
 		if (!responseMessage.getResponseHeader().isText()) {
diff --git a/test/org/zaproxy/zap/spider/filters/DefaultParseFilterUnitTest.java b/test/org/zaproxy/zap/spider/filters/DefaultParseFilterUnitTest.java
new file mode 100644
index 000000000..55ad640a3
--- /dev/null
+++ b/test/org/zaproxy/zap/spider/filters/DefaultParseFilterUnitTest.java
@@ -0,0 +1,261 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2017 The ZAP Development Team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.zaproxy.zap.spider.filters;
+
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertThat;
+
+import org.apache.log4j.Logger;
+import org.apache.log4j.varia.NullAppender;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.parosproxy.paros.network.HttpMessage;
+import org.parosproxy.paros.network.HttpRequestHeader;
+import org.zaproxy.zap.spider.SpiderParam;
+
+/**
+ * Unit test for {@link DefaultParseFilter}.
+ */
+public class DefaultParseFilterUnitTest {
+
+    @BeforeClass
+    public static void suppressLogging() {
+        Logger.getRootLogger().addAppender(new NullAppender());
+    }
+
+    @Test
+    @SuppressWarnings({ "deprecation", "unused" })
+    public void shouldCreateDefaultParseFilterWithDefaultConfigsIfNoneSet() {
+        // Given / When
+        new DefaultParseFilter();
+        // Then = No exception.
+    }
+
+    @Test
+    @SuppressWarnings("unused")
+    public void shouldCreateDefaultParseFilterWithConfigsSet() {
+        // Given
+        SpiderParam configs = new SpiderParam();
+        // When
+        new DefaultParseFilter(configs);
+        // Then = No exception.
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    @SuppressWarnings("unused")
+    public void shouldFailToCreateDefaultParseFilterWithNullConfigs() {
+        // Given
+        SpiderParam configs = null;
+        // When
+        new DefaultParseFilter(configs);
+        // Then = IllegalArgumentException.
+    }
+
+    @Test
+    public void shouldFilterNullHttpMessage() {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = null;
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(true)));
+    }
+
+    @Test
+    public void shouldFilterHttpMessageWithEmptyRequestHeader() {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = new HttpMessage();
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(true)));
+    }
+
+    @Test
+    public void shouldFilterHttpMessageWithEmptyResponseHeader() {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = createDefaultRequest();
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(true)));
+    }
+
+    @Test
+    public void shouldHandleHttpMessageWithNoPathInRequestUri() throws Exception {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = createHttpMessageWithRequestUri("http://example.com");
+        // When
+        filter.isFiltered(httpMessage);
+        // Then = No exception.
+    }
+
+    @Test
+    public void shouldNotFilterHttpMessageWithSvnXmlRequest() throws Exception {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = createHttpMessageWithRequestUri("/.svn/wc.db");
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotFilterHttpMessageWithSvnDbRequest() throws Exception {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = createHttpMessageWithRequestUri("/.svn/entries");
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotFilterHttpMessageWithGitRequest() throws Exception {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = createHttpMessageWithRequestUri("/.git/index");
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldFilterHttpMessageWithNonTextResponse() throws Exception {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = createDefaultRequest();
+        httpMessage.setResponseHeader("HTTP/1.1 200 OK\r\nContent-Type: application/x-binary\r\n");
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(true)));
+    }
+
+    @Test
+    public void shouldNotFilterHttpMessageWithTextResponse() throws Exception {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = createDefaultRequest();
+        httpMessage.setResponseHeader("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n");
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotFilterHttpMessageWithRedirectResponse() throws Exception {
+        // Given
+        DefaultParseFilter filter = createDefaultParseFilter();
+        HttpMessage httpMessage = createDefaultRequest();
+        httpMessage.setResponseHeader("HTTP/1.1 303 See Other\r\n");
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldFilterHttpMessageWithResponseAboveMaxParseSize() throws Exception {
+        // Given
+        int maxParseSizeBytes = 2;
+        DefaultParseFilter filter = new DefaultParseFilter(createSpiderParam(maxParseSizeBytes));
+        HttpMessage httpMessage = createHttpMessageWithResponseBody("ABC");
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(true)));
+    }
+
+    @Test
+    public void shouldNotFilterHttpMessageWithResponseEqualToMaxParseSize() throws Exception {
+        // Given
+        int maxParseSizeBytes = 2;
+        DefaultParseFilter filter = new DefaultParseFilter(createSpiderParam(maxParseSizeBytes));
+        HttpMessage httpMessage = createHttpMessageWithResponseBody("AB");
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(false)));
+    }
+
+    @Test
+    public void shouldNotFilterHttpMessageWithResponseUnderMaxParseSize() throws Exception {
+        // Given
+        int maxParseSizeBytes = 2;
+        DefaultParseFilter filter = new DefaultParseFilter(createSpiderParam(maxParseSizeBytes));
+        HttpMessage httpMessage = createHttpMessageWithResponseBody("A");
+        // When
+        boolean filtered = filter.isFiltered(httpMessage);
+        // Then
+        assertThat(filtered, is(equalTo(false)));
+    }
+
+    private static DefaultParseFilter createDefaultParseFilter() {
+        return new DefaultParseFilter(createSpiderParam(Integer.MAX_VALUE));
+    }
+
+    private static SpiderParam createSpiderParam(final int maxParseSizeBytes) {
+        return new SpiderParam() {
+
+            @Override
+            public int getMaxParseSizeBytes() {
+                return maxParseSizeBytes;
+            }
+        };
+    }
+
+    private static HttpMessage createHttpMessageWithResponseBody(String responseBody) {
+        try {
+            HttpMessage message = createDefaultRequest();
+            message.setResponseHeader("HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n");
+            message.setResponseBody(responseBody);
+            return message;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static HttpMessage createDefaultRequest() {
+        try {
+            return new HttpMessage(new HttpRequestHeader("GET / HTTP/1.1\r\nHost: example.com\r\n"));
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static HttpMessage createHttpMessageWithRequestUri(String requestUri) {
+        try {
+            HttpMessage message = new HttpMessage(
+                    new HttpRequestHeader("GET " + requestUri + " HTTP/1.1\r\nHost: example.com\r\n"));
+            message.setResponseHeader("HTTP/1.1 200 OK\r\n");
+            return message;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
