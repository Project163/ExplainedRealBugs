diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index d4ae2af01..2f0b5a03a 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -2053,6 +2053,9 @@ spider.table.flags.outofcontext = Out of Context
 spider.table.flags.outofscope = Out of Scope
 spider.table.flags.illegalprotocol = Illegal Protocol
 spider.table.flags.userrules = User Rules
+spider.table.messages.header.processed = Processed
+spider.table.messages.column.processed.successfully = Successfully
+spider.table.messages.column.processed.ioerror = I/O Error
 spider.toolbar.button.showmessages.label = Show Messages
 spider.toolbar.button.showmessages.label.selected = Hide Messages
 spider.toolbar.button.showmessages.tooltip = Shows the HTTP messages sent while spidering
diff --git a/src/org/parosproxy/paros/model/HistoryReference.java b/src/org/parosproxy/paros/model/HistoryReference.java
index 2749445ab..a7ce5bde7 100644
--- a/src/org/parosproxy/paros/model/HistoryReference.java
+++ b/src/org/parosproxy/paros/model/HistoryReference.java
@@ -46,6 +46,7 @@
 // ZAP: 2016/06/20 Add TYPE_ZEST_SCRIPT and deprecate TYPE_RESERVED_11
 // ZAP: 2016/08/30 Use a Set instead of a List for the alerts
 // ZAP: 2017/02/07 Add TYPE_SPIDER_AJAX_TEMPORARY.
+// ZAP: 2017/03/19 Add TYPE_SPIDER_TEMPORARY.
 
 package org.parosproxy.paros.model;
 
@@ -112,7 +113,9 @@ public class HistoryReference {
      * The type is used to off-load the messages (of resources found but not yet fetched) from the memory.
      * 
      * @since 2.0.0
-     * @see #DEFAULT_TEMPORARY_HISTORY_TYPES
+     * @see #TYPE_SPIDER
+     * @see #TYPE_SPIDER_TEMPORARY
+     * @see #DEFAULT_TEMPORARY_HISTORY_TYPES 
      */
    public static final int TYPE_SPIDER_TASK = 9;
 
@@ -215,6 +218,18 @@ public class HistoryReference {
      */
    public static final int TYPE_SPIDER_AJAX_TEMPORARY = 18;
 
+    /**
+     * A (temporary) HTTP message of the spider.
+     * <p>
+     * Normally a message that was not processed (i.e. not successfully sent to the server).
+     * 
+     * @since TODO add version
+     * @see #TYPE_SPIDER
+     * @see #TYPE_SPIDER_TASK
+     * @see #DEFAULT_TEMPORARY_HISTORY_TYPES
+     */
+    public static final int TYPE_SPIDER_TEMPORARY = 19;
+
    private static java.text.DecimalFormat decimalFormat = new java.text.DecimalFormat("##0.###");
 	private static TableHistory staticTableHistory = null;
 	// ZAP: Support for multiple tags
@@ -230,6 +245,7 @@ public class HistoryReference {
 		defaultHistoryTypes.add(Integer.valueOf(HistoryReference.TYPE_SPIDER_TASK));
 		defaultHistoryTypes.add(Integer.valueOf(HistoryReference.TYPE_SEQUENCE_TEMPORARY));
 		defaultHistoryTypes.add(Integer.valueOf(HistoryReference.TYPE_SPIDER_AJAX_TEMPORARY));
+		defaultHistoryTypes.add(Integer.valueOf(HistoryReference.TYPE_SPIDER_TEMPORARY));
 		DEFAULT_TEMPORARY_HISTORY_TYPES = Collections.unmodifiableSet(defaultHistoryTypes);
 
 		TEMPORARY_HISTORY_TYPES.addAll(DEFAULT_TEMPORARY_HISTORY_TYPES);
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderAPI.java b/src/org/zaproxy/zap/extension/spider/SpiderAPI.java
index c56d9fb20..fc47f5bb3 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderAPI.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderAPI.java
@@ -554,13 +554,7 @@ public class SpiderAPI extends ApiImplementor {
 			ApiResponseList resultList = new ApiResponseList("urlsInScope");
 			synchronized (scan.getResourcesFound()) {
 				for (SpiderResource sr : scan.getResourcesFound()) {
-					Map<String, String> map = new HashMap<>();
-					map.put("messageId", Integer.toString(sr.getHistoryId()));
-					map.put("method", sr.getMethod());
-					map.put("url", sr.getUri());
-					map.put("statusCode", Integer.toString(sr.getStatusCode()));
-					map.put("statusReason", sr.getStatusReason());
-					resultList.addItem(new ApiResponseSet<String>("resource", map));
+					resultList.addItem(createApiResponseSet(sr));
 				}
 			}
 			resultUrls.addItem(resultList);
@@ -572,6 +566,14 @@ public class SpiderAPI extends ApiImplementor {
 				}
 			}
 			resultUrls.addItem(resultList);
+
+			resultList = new ApiResponseList("urlsIoError");
+			synchronized (scan.getResourcesIoErrors()) {
+				for (SpiderResource sr : scan.getResourcesIoErrors()) {
+					resultList.addItem(createApiResponseSet(sr));
+				}
+			}
+			resultUrls.addItem(resultList);
 			result = resultUrls;
 		} else if (VIEW_EXCLUDED_FROM_SCAN.equals(name)) {
 			result = new ApiResponseList(name);
@@ -631,6 +633,16 @@ public class SpiderAPI extends ApiImplementor {
 		return result;
 	}
 
+	private static ApiResponseSet<String> createApiResponseSet(SpiderResource sr) {
+		Map<String, String> map = new HashMap<>();
+		map.put("messageId", Integer.toString(sr.getHistoryId()));
+		map.put("method", sr.getMethod());
+		map.put("url", sr.getUri());
+		map.put("statusCode", Integer.toString(sr.getStatusCode()));
+		map.put("statusReason", sr.getStatusReason());
+		return new ApiResponseSet<>("resource", map);
+	}
+	
 	private ApiResponse domainMatchersToApiResponseList(
 			String name,
 			List<DomainAlwaysInScopeMatcher> domains,
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderMessagesTable.java b/src/org/zaproxy/zap/extension/spider/SpiderMessagesTable.java
index 8b4220197..d4e9f0a05 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderMessagesTable.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderMessagesTable.java
@@ -19,13 +19,26 @@
  */
 package org.zaproxy.zap.extension.spider;
 
+import java.awt.Component;
+
+import javax.swing.Icon;
+import javax.swing.ImageIcon;
+import javax.swing.JLabel;
 import javax.swing.SortOrder;
 import javax.swing.table.TableModel;
 
+import org.jdesktop.swingx.decorator.AbstractHighlighter;
+import org.jdesktop.swingx.decorator.ComponentAdapter;
+import org.jdesktop.swingx.renderer.DefaultTableRenderer;
+import org.jdesktop.swingx.renderer.IconAware;
+import org.jdesktop.swingx.renderer.IconValues;
+import org.jdesktop.swingx.renderer.MappedValue;
+import org.jdesktop.swingx.renderer.StringValues;
 import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.control.Control;
 import org.parosproxy.paros.extension.history.ExtensionHistory;
 import org.parosproxy.paros.model.HistoryReference;
+import org.zaproxy.zap.extension.spider.SpiderMessagesTableModel.ProcessedCellItem;
 import org.zaproxy.zap.view.table.HistoryReferencesTable;
 
 class SpiderMessagesTable extends HistoryReferencesTable {
@@ -41,12 +54,16 @@ class SpiderMessagesTable extends HistoryReferencesTable {
 
         setAutoCreateColumnsFromModel(false);
 
+        getColumnExt(0)
+                .setCellRenderer(new DefaultTableRenderer(new MappedValue(StringValues.EMPTY, IconValues.NONE), JLabel.CENTER));
+        getColumnExt(0).setHighlighters(new ProcessedCellItemIconHighlighter(0));
+
         getColumnExt(Constant.messages.getString("view.href.table.header.hrefid")).setVisible(false);
         getColumnExt(Constant.messages.getString("view.href.table.header.timestamp.response")).setVisible(false);
         getColumnExt(Constant.messages.getString("view.href.table.header.size.requestheader")).setVisible(false);
         getColumnExt(Constant.messages.getString("view.href.table.header.size.requestbody")).setVisible(false);
 
-        setSortOrder(0, SortOrder.ASCENDING);
+        setSortOrder(1, SortOrder.ASCENDING);
 
         extensionHistory = Control.getSingleton().getExtensionLoader().getExtension(ExtensionHistory.class);
     }
@@ -76,4 +93,64 @@ class SpiderMessagesTable extends HistoryReferencesTable {
 
         return historyReference;
     }
+
+    /**
+     * A {@link org.jdesktop.swingx.decorator.Highlighter Highlighter} for a column that indicates, using icons and text,
+     * whether or not an entry was processed, that is, is or not in scope.
+     * <p>
+     * The expected type/class of the cell values is {@code ProcessedCellItem}.
+     */
+    private static class ProcessedCellItemIconHighlighter extends AbstractHighlighter {
+
+        /** The icon that indicates the entry was processed. */
+        private static final ImageIcon PROCESSED_ICON = new ImageIcon(
+                SpiderMessagesTable.class.getResource("/resource/icon/16/152.png"));
+
+        /** The icon that indicates the entry was not processed. */
+        private static final ImageIcon NOT_PROCESSED_ICON = new ImageIcon(
+                SpiderMessagesTable.class.getResource("/resource/icon/16/149.png"));
+
+        private final int columnIndex;
+
+        public ProcessedCellItemIconHighlighter(final int columnIndex) {
+            this.columnIndex = columnIndex;
+        }
+
+        @Override
+        protected Component doHighlight(Component component, ComponentAdapter adapter) {
+            ProcessedCellItem cell = (ProcessedCellItem) adapter.getValue(columnIndex);
+
+            boolean processed = cell.isSuccessful();
+            Icon icon = getProcessedIcon(processed);
+            if (component instanceof IconAware) {
+                ((IconAware) component).setIcon(icon);
+            } else if (component instanceof JLabel) {
+                ((JLabel) component).setIcon(icon);
+            }
+
+            if (component instanceof JLabel) {
+                ((JLabel) component).setText(processed ? "" : cell.getLabel());
+            }
+
+            return component;
+        }
+
+        private static Icon getProcessedIcon(final boolean processed) {
+            return processed ? PROCESSED_ICON : NOT_PROCESSED_ICON;
+        }
+
+        /**
+         * {@inheritDoc}
+         * <p>
+         * Overridden to return true if the component is of type IconAware or of type JLabel, false otherwise.
+         * <p>
+         * Note: special casing JLabel is for backward compatibility - application highlighting code which doesn't use the
+         * Swingx renderers would stop working otherwise.
+         */
+        // Method/JavaDoc copied from org.jdesktop.swingx.decorator.IconHighlighter#canHighlight(Component, ComponentAdapter)
+        @Override
+        protected boolean canHighlight(final Component component, final ComponentAdapter adapter) {
+            return component instanceof IconAware || component instanceof JLabel;
+        }
+    }
 }
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderMessagesTableModel.java b/src/org/zaproxy/zap/extension/spider/SpiderMessagesTableModel.java
index 860d0eea8..4118f8dc2 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderMessagesTableModel.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderMessagesTableModel.java
@@ -20,7 +20,14 @@
 package org.zaproxy.zap.extension.spider;
 
 import java.awt.EventQueue;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
+import javax.swing.event.TableModelEvent;
+
+import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.control.Control;
 import org.parosproxy.paros.extension.history.ExtensionHistory;
 import org.parosproxy.paros.model.HistoryReference;
@@ -28,35 +35,62 @@ import org.zaproxy.zap.ZAP;
 import org.zaproxy.zap.eventBus.Event;
 import org.zaproxy.zap.eventBus.EventConsumer;
 import org.zaproxy.zap.extension.alert.AlertEventPublisher;
-import org.zaproxy.zap.view.table.DefaultHistoryReferencesTableModel;
+import org.zaproxy.zap.view.table.AbstractCustomColumnHistoryReferencesTableModel;
+import org.zaproxy.zap.view.table.AbstractHistoryReferencesTableEntry;
+import org.zaproxy.zap.view.table.DefaultHistoryReferencesTableEntry;
 
-class SpiderMessagesTableModel extends DefaultHistoryReferencesTableModel {
+class SpiderMessagesTableModel
+        extends AbstractCustomColumnHistoryReferencesTableModel<SpiderMessagesTableModel.SpiderTableEntry> {
 
     private static final long serialVersionUID = 1093393768186896931L;
 
+    private static final Column[] COLUMNS = new Column[] {
+            Column.CUSTOM,
+            Column.HREF_ID,
+            Column.REQUEST_TIMESTAMP,
+            Column.RESPONSE_TIMESTAMP,
+            Column.METHOD,
+            Column.URL,
+            Column.STATUS_CODE,
+            Column.STATUS_REASON,
+            Column.RTT,
+            Column.SIZE_REQUEST_HEADER,
+            Column.SIZE_REQUEST_BODY,
+            Column.SIZE_RESPONSE_HEADER,
+            Column.SIZE_RESPONSE_BODY,
+            Column.HIGHEST_ALERT,
+            Column.TAGS };
+
+    private static final String[] CUSTOM_COLUMN_NAMES = {
+            Constant.messages.getString("spider.table.messages.header.processed") };
+
+    private static final ProcessedCellItem SUCCESSFULLY_PROCESSED_CELL_ITEM;
+    private static final ProcessedCellItem IO_ERROR_CELL_ITEM;
+
     private final ExtensionHistory extensionHistory;
     private AlertEventConsumer alertEventConsumer;
 
+    private List<SpiderTableEntry> resources;
+    private Map<Integer, Integer> idsToRows;
+
+    static {
+        SUCCESSFULLY_PROCESSED_CELL_ITEM = new ProcessedCellItem(
+                true,
+                Constant.messages.getString("spider.table.messages.column.processed.successfully"));
+        IO_ERROR_CELL_ITEM = new ProcessedCellItem(
+                false,
+                Constant.messages.getString("spider.table.messages.column.processed.ioerror"));
+    }
+
     public SpiderMessagesTableModel() {
         this(true);
     }
 
     public SpiderMessagesTableModel(boolean createAlertEventConsumer) {
-        super(new Column[] {
-                Column.HREF_ID,
-                Column.REQUEST_TIMESTAMP,
-                Column.RESPONSE_TIMESTAMP,
-                Column.METHOD,
-                Column.URL,
-                Column.STATUS_CODE,
-                Column.STATUS_REASON,
-                Column.RTT,
-                Column.SIZE_REQUEST_HEADER,
-                Column.SIZE_REQUEST_BODY,
-                Column.SIZE_RESPONSE_HEADER,
-                Column.SIZE_RESPONSE_BODY,
-                Column.HIGHEST_ALERT,
-                Column.TAGS });
+        super(COLUMNS);
+
+        resources = new ArrayList<>();
+        idsToRows = new HashMap<>();
 
         if (createAlertEventConsumer) {
             alertEventConsumer = new AlertEventConsumer();
@@ -69,17 +103,33 @@ class SpiderMessagesTableModel extends DefaultHistoryReferencesTableModel {
     }
 
     @Override
-    public void addHistoryReference(HistoryReference historyReference) {
+    public void addEntry(SpiderTableEntry entry) {
+        // Nothing to do, the entries are added with the following method.
+    }
+
+    public void addHistoryReference(HistoryReference historyReference, boolean ioError) {
         HistoryReference latestHistoryReference = historyReference;
         if (extensionHistory != null) {
             latestHistoryReference = extensionHistory.getHistoryReference(historyReference.getHistoryId());
         }
-        super.addHistoryReference(latestHistoryReference);
+        final SpiderTableEntry entry = new SpiderTableEntry(latestHistoryReference, ioError);
+        EventQueue.invokeLater(new Runnable() {
+
+            @Override
+            public void run() {
+                final int row = resources.size();
+                idsToRows.put(Integer.valueOf(entry.getHistoryId()), Integer.valueOf(row));
+                resources.add(entry);
+                fireTableRowsInserted(row, row);
+            }
+        });
     }
 
     @Override
     public void clear() {
-        super.clear();
+        resources = new ArrayList<>();
+        idsToRows = new HashMap<>();
+        fireTableDataChanged();
 
         if (alertEventConsumer != null) {
             ZAP.getEventBus().unregisterConsumer(alertEventConsumer, AlertEventPublisher.getPublisher().getPublisherName());
@@ -87,6 +137,190 @@ class SpiderMessagesTableModel extends DefaultHistoryReferencesTableModel {
         }
     }
 
+    @Override
+    public void refreshEntryRow(int historyReferenceId) {
+        final DefaultHistoryReferencesTableEntry entry = getEntryWithHistoryId(historyReferenceId);
+
+        if (entry != null) {
+            int rowIndex = getEntryRowIndex(historyReferenceId);
+            getEntryWithHistoryId(historyReferenceId).refreshCachedValues();
+
+            fireTableRowsUpdated(rowIndex, rowIndex);
+        }
+    }
+
+    @Override
+    public void removeEntry(int historyReferenceId) {
+        // Nothing to do, the entries are not removed.
+    }
+
+    @Override
+    public SpiderTableEntry getEntry(int rowIndex) {
+        return resources.get(rowIndex);
+    }
+
+    @Override
+    public SpiderTableEntry getEntryWithHistoryId(int historyReferenceId) {
+        final int row = getEntryRowIndex(historyReferenceId);
+        if (row != -1) {
+            return resources.get(row);
+        }
+        return null;
+    }
+
+    @Override
+    public int getEntryRowIndex(int historyReferenceId) {
+        final Integer row = idsToRows.get(Integer.valueOf(historyReferenceId));
+        if (row != null) {
+            return row.intValue();
+        }
+        return -1;
+    }
+
+    @Override
+    public int getRowCount() {
+        return resources.size();
+    }
+
+    @Override
+    protected Class<?> getColumnClass(Column column) {
+        return AbstractHistoryReferencesTableEntry.getColumnClass(column);
+    }
+
+    @Override
+    protected Object getPrototypeValue(Column column) {
+        return AbstractHistoryReferencesTableEntry.getPrototypeValue(column);
+    }
+
+    @Override
+    public Object getValueAt(int rowIndex, int columnIndex) {
+        if (columnIndex == -1) {
+            return getEntry(rowIndex);
+        }
+        return super.getValueAt(rowIndex, columnIndex);
+    }
+
+    @Override
+    protected Object getCustomValueAt(SpiderTableEntry entry, int columnIndex) {
+        if (getCustomColumnIndex(columnIndex) == 0) {
+            return entry.isIoError() ? IO_ERROR_CELL_ITEM : SUCCESSFULLY_PROCESSED_CELL_ITEM;
+        }
+        return null;
+    }
+
+    @Override
+    protected String getCustomColumnName(int columnIndex) {
+        return CUSTOM_COLUMN_NAMES[getCustomColumnIndex(columnIndex)];
+    }
+
+    @Override
+    protected Class<?> getCustomColumnClass(int columnIndex) {
+        if (getCustomColumnIndex(columnIndex) == 0) {
+            return ProcessedCellItem.class;
+        }
+        return null;
+    }
+
+    @Override
+    protected Object getCustomPrototypeValue(int columnIndex) {
+        if (getCustomColumnIndex(columnIndex) == 0) {
+            return "Successful";
+        }
+        return null;
+    }
+
+    private void refreshEntryRows() {
+        if (resources.isEmpty()) {
+            return;
+        }
+
+        for (SpiderTableEntry entry : resources) {
+            entry.refreshCachedValues();
+        }
+
+        fireTableChanged(
+                new TableModelEvent(
+                        this,
+                        0,
+                        resources.size() - 1,
+                        getColumnIndex(Column.HIGHEST_ALERT),
+                        TableModelEvent.UPDATE));
+    }
+
+    static class SpiderTableEntry extends DefaultHistoryReferencesTableEntry {
+
+        private final boolean ioError;
+
+        public SpiderTableEntry(HistoryReference historyReference, boolean ioError) {
+            super(historyReference, COLUMNS);
+            this.ioError = ioError;
+        }
+
+        public boolean isIoError() {
+            return ioError;
+        }
+    }
+
+    static class ProcessedCellItem implements Comparable<ProcessedCellItem> {
+
+        private final boolean successful;
+        private final String label;
+
+        public ProcessedCellItem(boolean successful, String label) {
+            this.successful = successful;
+            this.label = label;
+        }
+
+        public boolean isSuccessful() {
+            return successful;
+        }
+
+        public String getLabel() {
+            return label;
+        }
+
+        @Override
+        public String toString() {
+            return label;
+        }
+
+        @Override
+        public int hashCode() {
+            return 31 * (successful ? 1231 : 1237);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null) {
+                return false;
+            }
+            if (getClass() != obj.getClass()) {
+                return false;
+            }
+            ProcessedCellItem other = (ProcessedCellItem) obj;
+            if (successful != other.successful) {
+                return false;
+            }
+            return true;
+        }
+
+        @Override
+        public int compareTo(ProcessedCellItem other) {
+            if (other == null) {
+                return 1;
+            }
+            if (successful && !other.successful) {
+                return 1;
+            } else if (!successful && other.successful) {
+                return -1;
+            }
+            return label.compareTo(other.label);
+        }
+    }
+
     private class AlertEventConsumer implements EventConsumer {
 
         @Override
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderScan.java b/src/org/zaproxy/zap/extension/spider/SpiderScan.java
index 9bdb64c74..90ada5ea5 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderScan.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderScan.java
@@ -87,6 +87,8 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 
 	private List<SpiderResource> resourcesFound;
 
+	private List<SpiderResource> resourcesIoErrors;
+
 	private Set<String> foundURIsOutOfScope;
 
 	private SpiderThread spiderThread = null;
@@ -146,6 +148,7 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 		numberOfURIsFound = new AtomicInteger();
 		foundURIs = Collections.synchronizedSet(new HashSet<String>());
 		resourcesFound = Collections.synchronizedList(new ArrayList<SpiderResource>());
+		resourcesIoErrors = Collections.synchronizedList(new ArrayList<SpiderResource>());
 		foundURIsOutOfScope = Collections.synchronizedSet(new HashSet<String>());
 
 		state = State.NOT_STARTED;
@@ -297,6 +300,20 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 	public List<SpiderResource> getResourcesFound() {
 		return resourcesFound;
 	}
+	
+	/**
+	 * Returns the resources found during the scan that were not successfully obtained because of I/O errors.
+	 * <p>
+	 * <strong>Note:</strong> Iterations must be {@code synchronized} on returned object. Failing to do so might result in
+	 * {@code ConcurrentModificationException}.
+	 * </p>
+	 *
+	 * @return the resources found during the scan that were not successfully obtained
+	 * @since TODO add version
+	 */
+	public List<SpiderResource> getResourcesIoErrors() {
+		return resourcesIoErrors;
+	}
 
 	/**
 	 * Returns the URLs, out of scope, found during the scan.
@@ -316,12 +333,18 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 	public void readURI(HttpMessage msg) {
 		HttpRequestHeader requestHeader = msg.getRequestHeader();
 		HttpResponseHeader responseHeader = msg.getResponseHeader();
-		resourcesFound.add(new SpiderResource(
+		SpiderResource resource = new SpiderResource(
 				msg.getHistoryRef().getHistoryId(),
 				requestHeader.getMethod(),
 				requestHeader.getURI().toString(),
 				responseHeader.getStatusCode(),
-				responseHeader.getReasonPhrase()));
+				responseHeader.getReasonPhrase());
+
+		if (msg.isResponseFromTargetHost()) {
+			resourcesFound.add(resource);
+		} else {
+			resourcesIoErrors.add(resource);
+		}
 
 		if (View.isInitialised()) {
 			addMessageToMessagesTableModel(msg);
@@ -337,7 +360,7 @@ public class SpiderScan implements ScanListenner, SpiderListener, GenericScanner
 			if (messagesTableModel == null) {
 				messagesTableModel = new SpiderMessagesTableModel();
 			}
-			messagesTableModel.addHistoryReference(msg.getHistoryRef());
+			messagesTableModel.addHistoryReference(msg.getHistoryRef(), !msg.isResponseFromTargetHost());
 			return;
 		}
 
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderThread.java b/src/org/zaproxy/zap/extension/spider/SpiderThread.java
index adc705a58..90dc27c37 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderThread.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderThread.java
@@ -453,10 +453,12 @@ public class SpiderThread extends ScanThread implements SpiderListener {
 	public void readURI(final HttpMessage msg) {
 		// Add the read message to the Site Map (tree or db structure)
 		try {
-			final HistoryReference historyRef = new HistoryReference(extension.getModel().getSession(),
-					HistoryReference.TYPE_SPIDER, msg);
+			int type = msg.isResponseFromTargetHost() ? HistoryReference.TYPE_SPIDER : HistoryReference.TYPE_SPIDER_TEMPORARY;
+			HistoryReference historyRef = new HistoryReference(extension.getModel().getSession(), type, msg);
 
-			addMessageToSitesTree(historyRef, msg);
+			if (msg.isResponseFromTargetHost()) {
+				addMessageToSitesTree(historyRef, msg);
+			}
 		} catch (Exception e) {
 			log.error(e.getMessage(), e);
 		}
diff --git a/src/org/zaproxy/zap/spider/SpiderTask.java b/src/org/zaproxy/zap/spider/SpiderTask.java
index e83d61c8c..a821f2170 100644
--- a/src/org/zaproxy/zap/spider/SpiderTask.java
+++ b/src/org/zaproxy/zap/spider/SpiderTask.java
@@ -22,14 +22,18 @@ import java.net.ConnectException;
 import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
+import java.nio.charset.StandardCharsets;
 import java.util.List;
 
+import javax.net.ssl.SSLException;
+
 import net.htmlparser.jericho.Source;
 
-import org.apache.commons.httpclient.HttpException;
 import org.apache.commons.httpclient.URI;
 import org.apache.commons.httpclient.URIException;
+import org.apache.commons.lang.exception.ExceptionUtils;
 import org.apache.log4j.Logger;
+import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.control.Control;
 import org.parosproxy.paros.db.DatabaseException;
 import org.parosproxy.paros.extension.history.ExtensionHistory;
@@ -38,6 +42,7 @@ import org.parosproxy.paros.network.HttpHeader;
 import org.parosproxy.paros.network.HttpMalformedHeaderException;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpRequestHeader;
+import org.parosproxy.paros.network.HttpResponseHeader;
 import org.zaproxy.zap.spider.filters.ParseFilter;
 import org.zaproxy.zap.spider.parser.SpiderParser;
 
@@ -57,7 +62,7 @@ public class SpiderTask implements Runnable {
 	 * 
 	 * @see #cleanup()
 	 * @see #deleteHistoryReference()
-	 * @see #fetchResource()
+	 * @see #prepareHttpMessage()
 	 */
 	private HistoryReference reference;
 
@@ -191,10 +196,21 @@ public class SpiderTask implements Runnable {
 		parent.preTaskExecution();
 
 		// Fetch the resource
-		HttpMessage msg = null;
+		HttpMessage msg;
 		try {
-			msg = fetchResource();
+			msg = prepareHttpMessage();
 		} catch (Exception e) {
+			log.error("Failed to prepare HTTP message: ", e);
+			parent.postTaskExecution();
+			return;
+		}
+
+		try {
+			fetchResource(msg);
+		} catch (Exception e) {
+			setErrorResponse(msg, e);
+			parent.notifyListenersReadURI(msg);
+
 			// The exception was already logged, in fetchResource, with the URL (which we dont have here)
 			parent.postTaskExecution();
 			return;
@@ -245,6 +261,39 @@ public class SpiderTask implements Runnable {
 		log.debug("Spider Task finished.");
 	}
 
+	/**
+	 * Prepares the HTTP message to be sent to the target server.
+	 * <p>
+	 * The HTTP message is read from the database and set up with common headers (e.g. User-Agent) and properties (e.g. user).
+	 *
+	 * @return the HTTP message
+	 * @throws HttpMalformedHeaderException if an error occurred while parsing the HTTP message read from the database
+	 * @throws DatabaseException if an error occurred while reading the HTTP message from the database
+	 */
+	private HttpMessage prepareHttpMessage() throws HttpMalformedHeaderException, DatabaseException {
+		// Build fetch the request message from the database
+		HttpMessage msg;
+		try {
+			msg = reference.getHttpMessage();
+		} finally {
+			deleteHistoryReference();
+		}
+
+		msg.getRequestHeader().setHeader(HttpHeader.IF_MODIFIED_SINCE, null);
+		msg.getRequestHeader().setHeader(HttpHeader.IF_NONE_MATCH, null);
+
+		// Check if there is a custom user agent
+		if (parent.getSpiderParam().getUserAgent() != null) {
+			msg.getRequestHeader().setHeader(HttpHeader.USER_AGENT, parent.getSpiderParam().getUserAgent());
+		}
+
+		// Check if there's a need to send the message from the point of view of a User
+		if (parent.getScanUser() != null) {
+			msg.setRequestingUser(parent.getScanUser());
+		}
+		return msg;
+	}
+	
 	/**
 	 * Deletes the history reference, should be called when no longer needed.
 	 * <p>
@@ -262,6 +311,50 @@ public class SpiderTask implements Runnable {
 			reference = null;
 		}
 	}
+	
+	private void setErrorResponse(HttpMessage msg, Exception cause) {
+		StringBuilder strBuilder = new StringBuilder(250);
+		if (cause instanceof SSLException) {
+			strBuilder.append(Constant.messages.getString("network.ssl.error.connect"));
+			strBuilder.append(msg.getRequestHeader().getURI().toString()).append('\n');
+			strBuilder.append(Constant.messages.getString("network.ssl.error.exception"))
+					.append(cause.getMessage())
+					.append('\n');
+			strBuilder.append(Constant.messages.getString("network.ssl.error.exception.rootcause"))
+					.append(ExceptionUtils.getRootCauseMessage(cause))
+					.append('\n');
+			strBuilder.append(
+					Constant.messages
+							.getString("network.ssl.error.help", Constant.messages.getString("network.ssl.error.help.url")));
+
+			strBuilder.append("\n\nStack Trace:\n");
+			for (String stackTraceFrame : ExceptionUtils.getRootCauseStackTrace(cause)) {
+				strBuilder.append(stackTraceFrame).append('\n');
+			}
+		} else {
+			strBuilder.append(cause.getClass().getName())
+					.append(": ")
+					.append(cause.getLocalizedMessage())
+					.append("\n\nStack Trace:\n");
+			for (String stackTraceFrame : ExceptionUtils.getRootCauseStackTrace(cause)) {
+				strBuilder.append(stackTraceFrame).append('\n');
+			}
+		}
+
+		String message = strBuilder.toString();
+
+		HttpResponseHeader responseHeader;
+		try {
+			responseHeader = new HttpResponseHeader("HTTP/1.1 400 ZAP IO Error");
+			responseHeader.setHeader(HttpHeader.CONTENT_TYPE, "text/plain; charset=UTF-8");
+			responseHeader
+					.setHeader(HttpHeader.CONTENT_LENGTH, Integer.toString(message.getBytes(StandardCharsets.UTF_8).length));
+			msg.setResponseHeader(responseHeader);
+			msg.setResponseBody(message);
+		} catch (HttpMalformedHeaderException e) {
+			log.error("Failed to create error response:", e);
+		}
+	}
 
 	/**
 	 * Process a resource, searching for links (uris) to other resources.
@@ -308,59 +401,33 @@ public class SpiderTask implements Runnable {
 	/**
 	 * Fetches a resource.
 	 * 
-	 * @return the response http message
-	 * @throws HttpException the http exception
+	 * @param msg the HTTP message that will be sent to the server
 	 * @throws IOException Signals that an I/O exception has occurred.
-	 * @throws DatabaseException if an error occurred while reading the HTTP message
 	 */
-	private HttpMessage fetchResource() throws IOException, DatabaseException {
-
-		// Build fetch the request message from the database
-		HttpMessage msg;
-		try {
-			msg = reference.getHttpMessage();
-		} finally {
-			deleteHistoryReference();
-		}
-
-		msg.getRequestHeader().setHeader(HttpHeader.IF_MODIFIED_SINCE, null);
-		msg.getRequestHeader().setHeader(HttpHeader.IF_NONE_MATCH, null);
-
-		// Check if there is a custom user agent
-		if (parent.getSpiderParam().getUserAgent() != null) {
-			msg.getRequestHeader().setHeader(HttpHeader.USER_AGENT, parent.getSpiderParam().getUserAgent());
-		}
-		
-		//Check if there's a need to send the message from the point of view of a User
-		if(parent.getScanUser()!=null){
-			msg.setRequestingUser(parent.getScanUser());
+	private void fetchResource(HttpMessage msg) throws IOException {
+		if (parent.getHttpSender() == null) {
+			return;
 		}
 		
-		// Fetch the page
-		if (parent.getHttpSender() != null) {
-			try {
-				parent.getHttpSender().sendAndReceive(msg);
-			} catch (ConnectException e) {
-				log.debug("Failed to connect to: " + msg.getRequestHeader().getURI(), e);
-				throw e;
-			} catch (SocketTimeoutException e) {
-				log.debug("Socket timeout: " + msg.getRequestHeader().getURI(), e);
-				throw e;
-			} catch (SocketException e) {
-				log.debug("Socket exception: " + msg.getRequestHeader().getURI(), e);
-				throw e;
-			} catch (UnknownHostException e) {
-				log.debug("Unknown host: " + msg.getRequestHeader().getURI(), e);
-				throw e;
-			} catch (Exception e) {
-				log.error("An error occurred while fetching the resource [" + msg.getRequestHeader().getURI() + "]: "
-							+ e.getMessage(), e);
-				throw e;
-			}
+		try {
+			parent.getHttpSender().sendAndReceive(msg);
+		} catch (ConnectException e) {
+			log.debug("Failed to connect to: " + msg.getRequestHeader().getURI(), e);
+			throw e;
+		} catch (SocketTimeoutException e) {
+			log.debug("Socket timeout: " + msg.getRequestHeader().getURI(), e);
+			throw e;
+		} catch (SocketException e) {
+			log.debug("Socket exception: " + msg.getRequestHeader().getURI(), e);
+			throw e;
+		} catch (UnknownHostException e) {
+			log.debug("Unknown host: " + msg.getRequestHeader().getURI(), e);
+			throw e;
+		} catch (Exception e) {
+			log.error("An error occurred while fetching the resource [" + msg.getRequestHeader().getURI() + "]: "
+						+ e.getMessage(), e);
+			throw e;
 		}
-
-		return msg;
-
 	}
 
 	/**
