diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index c8d4adcb2..6a2b8f39e 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -857,11 +857,11 @@ core.api.action.deleteSiteNode = Deletes the site node found in the Sites Tree o
 core.api.action.loadSession = Loads the session with the given name. If a relative path is specified it will be resolved against the "session" directory in ZAP "home" dir.
 core.api.action.newSession = Creates a new session, optionally overwriting existing files. If a relative path is specified it will be resolved against the "session" directory in ZAP "home" dir.
 core.api.action.saveSession = Saves the session with the name supplied, optionally overwriting existing files. If a relative path is specified it will be resolved against the "session" directory in ZAP "home" dir.
-core.api.action.sendRequest = Sends the HTTP request, optionally following redirections. Returns the request sent and response received and followed redirections, if any.
+core.api.action.sendRequest = Sends the HTTP request, optionally following redirections. Returns the request sent and response received and followed redirections, if any. The Mode is enforced when sending the request (and following redirections), custom manual requests are now allowed in 'Safe' mode nor in 'Protected' mode if out of scope.
 core.api.action.setMode = Sets the mode, which may be one of [safe, protect, standard, attack]
 core.api.action.shutdown = Shuts down ZAP
 core.api.other.messagesHar = Gets the HTTP messages sent through/by ZAP, in HAR format, optionally filtered by URL and paginated with 'start' position and 'count' of messages
-core.api.other.sendHarRequest = Sends the first HAR request entry, optionally following redirections. Returns, in HAR format, the request sent and response received and followed redirections, if any.
+core.api.other.sendHarRequest = Sends the first HAR request entry, optionally following redirections. Returns, in HAR format, the request sent and response received and followed redirections, if any. The Mode is enforced when sending the request (and following redirections), custom manual requests are now allowed in 'Safe' mode nor in 'Protected' mode if out of scope.
 core.api.other.htmlreport = Generates a report in HTML format
 core.api.other.messageHar = Gets the message with the given ID in HAR format
 core.api.other.xmlreport = Generates a report in XML format
@@ -1263,6 +1263,7 @@ manReq.label.contentLength     = Body Length:
 manReq.label.totalLength       = Total Length: 
 manReq.label.totalLengthBytes  = bytes
 manReq.outofscope.warning      = The target URL not in scope
+manReq.outofscope.redirection.warning = A redirection was not followed because it was out of scope:\n{0}
 manReq.safe.warning            = Manual requests not allowed in Safe mode
 
 menu.analyse                  = Analyse
diff --git a/src/org/parosproxy/paros/core/scanner/AbstractPlugin.java b/src/org/parosproxy/paros/core/scanner/AbstractPlugin.java
index 8351a732a..724c656ed 100644
--- a/src/org/parosproxy/paros/core/scanner/AbstractPlugin.java
+++ b/src/org/parosproxy/paros/core/scanner/AbstractPlugin.java
@@ -50,6 +50,7 @@
 // ZAP: 2016/03/22 Implement init() and getDependency() by default, most plugins do not use them
 // ZAP: 2016/04/21 Include Plugin itself when notifying of a new message sent
 // ZAP: 2016/05/03 Remove exceptions' stack trace prints
+// ZAP: 2016/06/10 Honour scan's scope when following redirections
 
 package org.parosproxy.paros.core.scanner;
 
@@ -65,11 +66,13 @@ import java.util.regex.Pattern;
 
 import org.apache.commons.configuration.Configuration;
 import org.apache.commons.httpclient.HttpException;
+import org.apache.commons.httpclient.URI;
 import org.apache.log4j.Logger;
 import org.parosproxy.paros.control.Control;
 import org.parosproxy.paros.extension.encoder.Encoder;
 import org.parosproxy.paros.network.HttpHeader;
 import org.parosproxy.paros.network.HttpMessage;
+import org.parosproxy.paros.network.HttpSender;
 import org.zaproxy.zap.control.AddOn;
 import org.zaproxy.zap.extension.anticsrf.AntiCsrfToken;
 import org.zaproxy.zap.extension.anticsrf.ExtensionAntiCSRF;
@@ -106,6 +109,15 @@ public abstract class AbstractPlugin implements Plugin, Comparable<Object> {
     private Date finished = null;
     private AddOn.Status status = AddOn.Status.unknown;
 
+    /**
+     * The redirection validator that ensures the followed redirections are in scan's scope.
+     * <p>
+     * Lazily initialised.
+     * 
+     * @see #getRedirectionValidator()
+     */
+    private HttpSender.RedirectionValidator redirectionValidator;
+
     /**
      * Default Constructor
      */
@@ -257,7 +269,11 @@ public abstract class AbstractPlugin implements Plugin, Comparable<Object> {
         //ZAP: Runs the "beforeScan" methods of any ScannerHooks
         parent.performScannerHookBeforeScan(msg, this);
 
-        parent.getHttpSender().sendAndReceive(msg, isFollowRedirect);
+        if (isFollowRedirect) {
+            parent.getHttpSender().sendAndReceive(msg, getRedirectionValidator());
+        } else {
+            parent.getHttpSender().sendAndReceive(msg, false);
+        }
         
         // ZAP: Notify parent
         parent.notifyNewMessage(this, msg);
@@ -266,6 +282,35 @@ public abstract class AbstractPlugin implements Plugin, Comparable<Object> {
         parent.performScannerHookAfterScan(msg, this);
     }
 
+    /**
+     * Gets the redirection validator, that ensures the followed redirections are in scan's scope.
+     *
+     * @return scan's scope redirection validator, never {@code null}
+     */
+    private HttpSender.RedirectionValidator getRedirectionValidator() {
+        if (redirectionValidator == null) {
+            redirectionValidator = new HttpSender.RedirectionValidator() {
+
+                @Override
+                public boolean isValid(URI redirection) {
+                    if (!getParent().nodeInScope(redirection.getEscapedURI())) {
+                        if (log.isDebugEnabled()) {
+                            log.debug("Skipping redirection out of scan's scope: " + redirection);
+                        }
+                        return false;
+                    }
+                    return true;
+                }
+
+                @Override
+                public void notifyMessageReceived(HttpMessage message) {
+                    // Nothing to do with the message.
+                }
+            };
+        }
+        return redirectionValidator;
+    }
+
     private void regenerateAntiCsrfToken(HttpMessage msg, AntiCsrfToken antiCsrfToken) {
         if (antiCsrfToken == null) {
             return;
diff --git a/src/org/parosproxy/paros/core/scanner/Analyser.java b/src/org/parosproxy/paros/core/scanner/Analyser.java
index d17de6dee..1c3c8941f 100644
--- a/src/org/parosproxy/paros/core/scanner/Analyser.java
+++ b/src/org/parosproxy/paros/core/scanner/Analyser.java
@@ -33,6 +33,7 @@
 // ZAP: 2015/04/02 Issue 321: Support multiple databases and Issue 1582: Low memory option
 // ZAP: 2016/01/26 Fixed findbugs warning
 // ZAP: 2016/04/21 Allow to obtain the number of requests sent during the analysis
+// ZAP: 2016/06/10 Honour scan's scope when following redirections
 
 package org.parosproxy.paros.core.scanner;
 
@@ -477,7 +478,24 @@ public class Analyser {
             }
         }
 
-        httpSender.sendAndReceive(msg, true);
+        httpSender.sendAndReceive(msg, new HttpSender.RedirectionValidator() {
+
+            @Override
+            public boolean isValid(URI redirection) {
+                if (!parent.nodeInScope(redirection.getEscapedURI())) {
+                    if (logger.isDebugEnabled()) {
+                        logger.debug("Skipping redirection out of scan's scope: " + redirection);
+                    }
+                    return false;
+                }
+                return true;
+            }
+
+            @Override
+            public void notifyMessageReceived(HttpMessage message) {
+                // Nothing to do with the message.
+            }
+        });
         requestCount++;
 
         // ZAP: Notify parent
diff --git a/src/org/parosproxy/paros/extension/manualrequest/http/impl/HttpPanelSender.java b/src/org/parosproxy/paros/extension/manualrequest/http/impl/HttpPanelSender.java
index dcf01a8bf..86357dc67 100644
--- a/src/org/parosproxy/paros/extension/manualrequest/http/impl/HttpPanelSender.java
+++ b/src/org/parosproxy/paros/extension/manualrequest/http/impl/HttpPanelSender.java
@@ -27,9 +27,11 @@ import java.util.List;
 import javax.swing.ImageIcon;
 import javax.swing.JToggleButton;
 
+import org.apache.commons.httpclient.URI;
 import org.apache.log4j.Logger;
 import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.control.Control;
+import org.parosproxy.paros.control.Control.Mode;
 import org.parosproxy.paros.extension.history.ExtensionHistory;
 import org.parosproxy.paros.extension.manualrequest.MessageSender;
 import org.parosproxy.paros.model.HistoryReference;
@@ -38,6 +40,7 @@ import org.parosproxy.paros.model.Session;
 import org.parosproxy.paros.network.HttpMalformedHeaderException;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpSender;
+import org.parosproxy.paros.view.View;
 import org.zaproxy.zap.PersistentConnectionListener;
 import org.zaproxy.zap.ZapGetMethod;
 import org.zaproxy.zap.extension.httppanel.HttpPanel;
@@ -82,7 +85,12 @@ public class HttpPanelSender implements MessageSender {
     public void handleSendMessage(Message aMessage) throws IllegalArgumentException, IOException {
         final HttpMessage httpMessage = (HttpMessage) aMessage;
         try {
-            getDelegate().sendAndReceive(httpMessage, getButtonFollowRedirects().isSelected());
+            final ModeRedirectionValidator redirectionValidator = new ModeRedirectionValidator();
+            if (getButtonFollowRedirects().isSelected()) {
+                getDelegate().sendAndReceive(httpMessage, redirectionValidator);
+            } else {
+                getDelegate().sendAndReceive(httpMessage, false);
+            }
 
             EventQueue.invokeAndWait(new Runnable() {
                 @Override
@@ -102,6 +110,13 @@ public class HttpPanelSender implements MessageSender {
                         } catch (final Exception e) {
                             logger.error(e.getMessage(), e);
                         }
+
+                        if (!redirectionValidator.isRequestValid()) {
+                            View.getSingleton().showWarningDialog(
+                                    Constant.messages.getString(
+                                            "manReq.outofscope.redirection.warning",
+                                            redirectionValidator.getInvalidRedirection()));
+                        }
                     }
                 }
             });
@@ -216,4 +231,64 @@ public class HttpPanelSender implements MessageSender {
     public void removePersistentConnectionListener(PersistentConnectionListener listener) {
         persistentConnectionListener.remove(listener);
     }
+
+    /**
+     * A {@code RedirectionValidator} that enforces the {@link Mode} when validating the {@code URI} of redirections.
+     *
+     * @see #isRequestValid()
+     */
+    private static class ModeRedirectionValidator implements HttpSender.RedirectionValidator {
+
+        private boolean isRequestValid;
+        private URI invalidRedirection;
+
+        public ModeRedirectionValidator() {
+            isRequestValid = true;
+        }
+
+        @Override
+        public void notifyMessageReceived(HttpMessage message) {
+        }
+
+        @Override
+        public boolean isValid(URI redirection) {
+            if (!isValidForCurrentMode(redirection)) {
+                isRequestValid = false;
+                invalidRedirection = redirection;
+                return false;
+            }
+            return true;
+        }
+
+        private boolean isValidForCurrentMode(URI uri) {
+            switch (Control.getSingleton().getMode()) {
+            case safe:
+                return false;
+            case protect:
+                return Model.getSingleton().getSession().isInScope(uri.toString());
+            default:
+                return true;
+            }
+        }
+
+        /**
+         * Tells whether or not the request is valid, that is, all redirections were valid for the current {@link Mode}.
+         *
+         * @return {@code true} is the request is valid, {@code false} otherwise.
+         * @see #getInvalidRedirection()
+         */
+        public boolean isRequestValid() {
+            return isRequestValid;
+        }
+
+        /**
+         * Gets the invalid redirection, if any.
+         *
+         * @return the invalid redirection, {@code null} if there was none.
+         * @see #isRequestValid()
+         */
+        public URI getInvalidRedirection() {
+            return invalidRedirection;
+        }
+    }
 }
diff --git a/src/org/parosproxy/paros/network/HttpSender.java b/src/org/parosproxy/paros/network/HttpSender.java
index b41ceab3b..19fe87c89 100644
--- a/src/org/parosproxy/paros/network/HttpSender.java
+++ b/src/org/parosproxy/paros/network/HttpSender.java
@@ -58,6 +58,7 @@
 // ZAP: 2016/05/24 Issue 2463: Websocket not proxied when outgoing proxy is set
 // ZAP: 2016/05/27 Issue 2484: Circular Redirects
 // ZAP: 2016/06/08 Set User-Agent header defined in options as default for (internal) CONNECT requests
+// ZAP: 2016/06/10 Allow to validate the URI of the redirections before being followed
 
 package org.parosproxy.paros.network;
 
@@ -77,6 +78,7 @@ import org.apache.commons.httpclient.HttpMethod;
 import org.apache.commons.httpclient.HttpMethodDirector;
 import org.apache.commons.httpclient.HttpMethodRetryHandler;
 import org.apache.commons.httpclient.HttpState;
+import org.apache.commons.httpclient.InvalidRedirectLocationException;
 import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
 import org.apache.commons.httpclient.NTCredentials;
 import org.apache.commons.httpclient.ProxyHost;
@@ -365,6 +367,7 @@ public class HttpSender {
 	 * @param isFollowRedirect
 	 * @throws HttpException
 	 * @throws IOException
+	 * @see #sendAndReceive(HttpMessage, RedirectionValidator)
 	 */
 	public void sendAndReceive(HttpMessage msg, boolean isFollowRedirect) throws IOException {
 
@@ -815,4 +818,160 @@ public class HttpSender {
         client.getParams().setBooleanParameter(HttpClientParams.ALLOW_CIRCULAR_REDIRECTS, allow);
         clientViaProxy.getParams().setBooleanParameter(HttpClientParams.ALLOW_CIRCULAR_REDIRECTS, allow);
     }
+
+    /**
+     * Sends the request of given HTTP {@code message}, following redirections per rules defined by the given {@code validator}.
+     * After the call to this method the given {@code message} will have the contents of the last response received (possibly
+     * the response of a redirection).
+     * <p>
+     * The validator is notified of each message sent and received (first message and redirections followed, if any).
+     *
+     * @param message the message that will be sent
+     * @param validator the validator responsible for validation of redirections
+     * @throws IllegalArgumentException if any of the parameters is {@code null}
+     * @throws IOException if an error occurred while sending the message or following the redirections
+     * @since TODO add version
+     * @see #sendAndReceive(HttpMessage, boolean)
+     */
+    public void sendAndReceive(HttpMessage message, RedirectionValidator validator) throws IOException {
+        if (message == null) {
+            throw new IllegalArgumentException("Parameter message must not be null.");
+        }
+        if (validator == null) {
+            throw new IllegalArgumentException("Parameter validator must not be null.");
+        }
+
+        sendAndReceive(message, false);
+        validator.notifyMessageReceived(message);
+
+        followRedirections(message, validator);
+    }
+
+    /**
+     * Follows redirections using the response of the given {@code message}. The given {@code validator} will be called for each
+     * redirection received. After the call to this method the given {@code message} will have the contents of the last response
+     * received (possibly the response of a redirection).
+     * <p>
+     * The validator is notified of each message sent and received (first message and redirections followed, if any).
+     *
+     * @param message the message that will be sent, must not be {@code null}
+     * @param validator the validator responsible for validation of redirections, must not be {@code null}
+     * @throws IOException if an error occurred while sending the message or following the redirections
+     * @see #isRedirectionNeeded(int)
+     */
+    private void followRedirections(HttpMessage message, RedirectionValidator validator) throws IOException {
+        HttpMessage redirectMessage = message;
+        int maxRedirections = client.getParams().getIntParameter(HttpClientParams.MAX_REDIRECTS, 100);
+        for (int i = 0; i < maxRedirections && isRedirectionNeeded(redirectMessage.getResponseHeader().getStatusCode()); i++) {
+            URI newLocation = extractRedirectLocation(redirectMessage);
+            if (newLocation == null || !validator.isValid(newLocation)) {
+                return;
+            }
+
+            redirectMessage = redirectMessage.cloneAll();
+            redirectMessage.getRequestHeader().setURI(newLocation);
+
+            if (isRequestRewriteNeeded(redirectMessage.getResponseHeader().getStatusCode())) {
+                redirectMessage.getRequestHeader().setMethod(HttpRequestHeader.GET);
+                redirectMessage.getRequestHeader().setHeader(HttpHeader.CONTENT_TYPE, null);
+                redirectMessage.getRequestHeader().setHeader(HttpHeader.CONTENT_LENGTH, null);
+                redirectMessage.setRequestBody("");
+            }
+
+            sendAndReceive(redirectMessage, false);
+            validator.notifyMessageReceived(redirectMessage);
+
+            // Update the response of the (original) message
+            message.setResponseHeader(redirectMessage.getResponseHeader());
+            message.setResponseBody(redirectMessage.getResponseBody());
+        }
+    }
+
+    /**
+     * Tells whether or not a redirection is needed based on the given status code.
+     * <p>
+     * A redirection is needed if the status code is 301, 302, 303, 307 or 308.
+     *
+     * @param statusCode the status code that will be checked
+     * @return {@code true} if a redirection is needed, {@code false} otherwise
+     * @see #isRequestRewriteNeeded(int)
+     */
+    private static boolean isRedirectionNeeded(int statusCode) {
+        switch (statusCode) {
+        case 301:
+        case 302:
+        case 303:
+        case 307:
+        case 308:
+            return true;
+        default:
+            return false;
+        }
+    }
+
+    /**
+     * Tells whether or not the (original) request of the redirection with the given status code, should be rewritten.
+     * <p>
+     * For status codes 301, 302 and 303 the request should be changed from POST to GET when following redirections (mimicking
+     * the behaviour of browsers, which per <a href="https://tools.ietf.org/html/rfc7231#section-6.4">RFC 7231, Section 6.4</a>
+     * is now OK).
+     *
+     * @param statusCode the status code that will be checked
+     * @return {@code true} if the request should be rewritten, {@code false} otherwise
+     * @see #isRedirectionNeeded(int)
+     */
+    private static boolean isRequestRewriteNeeded(int statusCode) {
+        return statusCode == 301 || statusCode == 302 || statusCode == 303;
+    }
+
+    /**
+     * Extracts a {@code URI} from the {@code Location} header of the given HTTP {@code message}.
+     * <p>
+     * If there's no {@code Location} header this method returns {@code null}.
+     * 
+     * @param message the HTTP message that will processed
+     * @return the {@code URI} created from the value of the {@code Location} header, might be {@code null}
+     * @throws InvalidRedirectLocationException if the value of {@code Location} header is not a valid {@code URI}
+     */
+    private static URI extractRedirectLocation(HttpMessage message) throws InvalidRedirectLocationException {
+        String location = message.getResponseHeader().getHeader(HttpHeader.LOCATION);
+        if (location == null) {
+            if (log.isDebugEnabled()) {
+                log.debug("No Location header found: " + message.getResponseHeader());
+            }
+            return null;
+        }
+
+        try {
+            return new URI(message.getRequestHeader().getURI(), location, true);
+        } catch (URIException ex) {
+            throw new InvalidRedirectLocationException("Invalid redirect location: " + location, location, ex);
+        }
+    }
+
+    /**
+     * A validator of redirections.
+     * <p>
+     * As convenience the validator will also be notified of the HTTP messages sent and received (first message and followed
+     * redirections, if any).
+     * 
+     * @since TODO add version
+     */
+    public interface RedirectionValidator {
+
+        /**
+         * Tells whether or not the given {@code redirection} is valid, to be followed.
+         *
+         * @param redirection the redirection being checked, never {@code null}
+         * @return {@code true} if the redirection is valid, {@code false} otherwise
+         */
+        boolean isValid(URI redirection);
+
+        /**
+         * Notifies that a new message was sent and received (called for the first message and followed redirections, if any).
+         *
+         * @param message the HTTP message that was received, never {@code null}
+         */
+        void notifyMessageReceived(HttpMessage message);
+    }
 }
diff --git a/src/org/zaproxy/zap/extension/api/CoreAPI.java b/src/org/zaproxy/zap/extension/api/CoreAPI.java
index b1492ca2a..7c88b39a9 100644
--- a/src/org/zaproxy/zap/extension/api/CoreAPI.java
+++ b/src/org/zaproxy/zap/extension/api/CoreAPI.java
@@ -70,7 +70,6 @@ import org.parosproxy.paros.network.HttpMalformedHeaderException;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpRequestHeader;
 import org.parosproxy.paros.network.HttpSender;
-import org.parosproxy.paros.network.HttpStatusCode;
 import org.parosproxy.paros.view.View;
 import org.zaproxy.zap.extension.alert.ExtensionAlert;
 import org.zaproxy.zap.extension.dynssl.ExtensionDynSSL;
@@ -421,6 +420,7 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 			} catch (HttpMalformedHeaderException e) {
 				throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_REQUEST, e);
 			}
+			validateForCurrentMode(request);
 			return sendHttpMessage(request, getParam(params, PARAM_FOLLOW_REDIRECTS, false), name);
 		} else if (ACTION_DELETE_ALL_ALERTS.equals(name)) {
             final ExtensionAlert extAlert = (ExtensionAlert) Control.getSingleton()
@@ -468,6 +468,38 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 		return ApiResponseElement.OK;
 	}
 
+	/**
+	 * Validates that the given request is valid for the current {@link Mode}.
+	 *
+	 * @param request the request that will be validated
+	 * @throws ApiException if the request is not valid for the current {@code Mode}.
+	 * @see #isValidForCurrentMode(URI)
+	 */
+	private static void validateForCurrentMode(HttpMessage request) throws ApiException {
+		if (!isValidForCurrentMode(request.getRequestHeader().getURI())) {
+			throw new ApiException(ApiException.Type.MODE_VIOLATION);
+		}
+	}
+
+	/**
+	 * Tells whether or not the given {@code uri} is valid for the current {@link Mode}.
+	 * <p>
+	 * The {@code uri} is not valid if the mode is {@code safe} or if in {@code protect} mode is not in scope.
+	 *
+	 * @param uri the {@code URI} that will be validated
+	 * @return {@code true} if the given {@code uri} is valid, {@code false} otherwise.
+	 */
+	private static boolean isValidForCurrentMode(URI uri) {
+		switch (Control.getSingleton().getMode()) {
+		case safe:
+			return false;
+		case protect:
+			return Model.getSingleton().getSession().isInScope(uri.toString());
+		default:
+			return true;
+		}
+	}
+
 	private ApiResponse sendHttpMessage(HttpMessage request, boolean followRedirects, String apiResponseName)
 			throws ApiException {
 		final ApiResponseList resultList = new ApiResponseList(apiResponseName);
@@ -482,6 +514,8 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 			});
 
 			return resultList;
+		} catch (ApiException e) {
+			throw e;
 		} catch (Exception e) {
 			throw new ApiException(ApiException.Type.INTERNAL_ERROR, e.getMessage());
 		}
@@ -510,31 +544,22 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 	}
 
 	private static void sendRequest(HttpMessage request, boolean followRedirects, Processor<HttpMessage> processor)
-			throws IOException {
+			throws IOException, ApiException {
 		HttpSender sender = null;
 		try {
 			sender = createHttpSender();
-			sender.sendAndReceive(request);
-			persistMessage(request);
-			processor.process(request);
 
 			if (followRedirects) {
-				HttpMessage tempReq = request;
-				for (int i = 0; i < 10 && HttpStatusCode.isRedirection(tempReq.getResponseHeader().getStatusCode()); i++) {
-					tempReq = tempReq.cloneAll();
+				ModeRedirectionValidator redirector = new ModeRedirectionValidator(processor);
+				sender.sendAndReceive(request, redirector);
 
-					String location = tempReq.getResponseHeader().getHeader(HttpHeader.LOCATION);
-					URI baseUri = tempReq.getRequestHeader().getURI();
-					URI newLocation = new URI(baseUri, location, false);
-					tempReq.getRequestHeader().setURI(newLocation);
-
-					tempReq.getRequestHeader().setMethod(HttpRequestHeader.GET);
-					tempReq.getRequestHeader().setHeader(HttpHeader.CONTENT_LENGTH, null);
-
-					sender.sendAndReceive(tempReq);
-					persistMessage(tempReq);
-					processor.process(tempReq);
+				if (!redirector.isRequestValid()) {
+					throw new ApiException(ApiException.Type.MODE_VIOLATION);
 				}
+			} else {
+				sender.sendAndReceive(request, false);
+				persistMessage(request);
+				processor.process(request);
 			}
 		} finally {
 			if (sender != null) {
@@ -897,31 +922,37 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 			} catch (IOException e) {
 				ApiException apiException = new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_REQUEST, e);
 				responseBody = apiException.toString(API.Format.JSON, incErrorDetails()).getBytes(StandardCharsets.UTF_8);
-				
-				msg.setResponseBody(responseBody);
 			}
 
 			if (request != null) {
-				boolean followRedirects = getParam(params, PARAM_FOLLOW_REDIRECTS, false);
-				try {
-					final HarEntries entries = new HarEntries();
-					sendRequest(request, followRedirects, new Processor<HttpMessage>() {
-	
-						@Override
-						public void process(HttpMessage msg) {
-							entries.addEntry(HarUtils.createHarEntry(msg));
-						}
-					});
-	
-					HarLog harLog = HarUtils.createZapHarLog();
-					harLog.setEntries(entries);
-	
-					responseBody = HarUtils.harLogToByteArray(harLog);
-				} catch (Exception e) {
-					logger.error(e.getMessage(), e);
-	
-					ApiException apiException = new ApiException(ApiException.Type.INTERNAL_ERROR, e.getMessage());
+				if (!isValidForCurrentMode(request.getRequestHeader().getURI())) {
+					ApiException apiException = new ApiException(ApiException.Type.MODE_VIOLATION);
 					responseBody = apiException.toString(API.Format.JSON, incErrorDetails()).getBytes(StandardCharsets.UTF_8);
+				} else {
+					boolean followRedirects = getParam(params, PARAM_FOLLOW_REDIRECTS, false);
+					try {
+						final HarEntries entries = new HarEntries();
+						sendRequest(request, followRedirects, new Processor<HttpMessage>() {
+
+							@Override
+							public void process(HttpMessage msg) {
+								entries.addEntry(HarUtils.createHarEntry(msg));
+							}
+						});
+
+						HarLog harLog = HarUtils.createZapHarLog();
+						harLog.setEntries(entries);
+
+						responseBody = HarUtils.harLogToByteArray(harLog);
+					} catch(ApiException e) {
+						responseBody = e.toString(API.Format.JSON, incErrorDetails()).getBytes(StandardCharsets.UTF_8);
+					} catch (Exception e) {
+						logger.error(e.getMessage(), e);
+
+						ApiException apiException = new ApiException(ApiException.Type.INTERNAL_ERROR, e.getMessage());
+						responseBody = apiException.toString(API.Format.JSON, incErrorDetails())
+								.getBytes(StandardCharsets.UTF_8);
+					}
 				}
 			}
 
@@ -1200,4 +1231,40 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 			return pageEnded;
 		}
 	}
+
+	/**
+	 * A {@code RedirectionValidator} that enforces the {@link Mode} when validating the {@code URI} of redirections.
+	 *
+	 * @see #isRequestValid()
+	 */
+	private static class ModeRedirectionValidator implements HttpSender.RedirectionValidator {
+
+		private final Processor<HttpMessage> processor;
+		private boolean isRequestValid;
+
+		public ModeRedirectionValidator(Processor<HttpMessage> processor) {
+			this.processor = processor;
+		}
+
+		@Override
+		public void notifyMessageReceived(HttpMessage message) {
+			persistMessage(message);
+			processor.process(message);
+		}
+
+		@Override
+		public boolean isValid(URI redirection) {
+			isRequestValid = isValidForCurrentMode(redirection);
+			return isRequestValid;
+		}
+
+		/**
+		 * Tells whether or not the request is valid, that is, all redirections were valid for the current {@link Mode}.
+		 *
+		 * @return {@code true} is the request is valid, {@code false} otherwise.
+		 */
+		public boolean isRequestValid() {
+			return isRequestValid;
+		}
+	}
 }
