diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index af667ce06..3fe3d0b80 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -1977,6 +1977,10 @@ view.options.label.fontSize					= Font Size:
 view.options.label.largeRequestSize			= Large request view min size:
 view.options.label.largeResponseSize		= Large response view min size:
 view.options.label.processImages            = Process images in HTTP requests/responses
+view.options.label.responsepanelpos         = Response Panel Position:
+view.options.label.responsepanelpos.above   = Request Shown Above Response
+view.options.label.responsepanelpos.sideBySide = Panels Side by Side
+view.options.label.responsepanelpos.tabs    = Tabs Side by Side
 view.options.label.showSplashScreen			= Show splash screen
 view.options.label.scaleImages				= Scale Images:
 view.options.label.showTabNames             = Show Tab Names
diff --git a/src/org/parosproxy/paros/control/MenuToolsControl.java b/src/org/parosproxy/paros/control/MenuToolsControl.java
index 17878b9f0..e373f18b8 100644
--- a/src/org/parosproxy/paros/control/MenuToolsControl.java
+++ b/src/org/parosproxy/paros/control/MenuToolsControl.java
@@ -23,6 +23,7 @@
 // ZAP: 2013/01/23 Clean up of exception handling/logging.
 // ZAP: 2013/03/03 Issue 546: Remove all template Javadoc comments
 // ZAP: 2016/04/04 Do not require a restart to show/hide the tool bar
+// ZAP: 2016/04/06 Fix layouts' issues
 package org.parosproxy.paros.control;
 
 import javax.swing.JOptionPane;
@@ -79,7 +80,7 @@ public class MenuToolsControl {
 		    // ZAP: Notify all OptionsChangedListener.
 		    control.getExtensionLoader().optionsChangedAllPlugin(model.getOptionsParam());
 		    
-		    view.setMainToolbarVisible(model.getOptionsParam().getViewParam().isShowMainToolbar());
+		    view.getMainFrame().applyViewOptions();
 
 		    control.getProxy().stopServer();
 		    control.getProxy().startServer();
diff --git a/src/org/parosproxy/paros/extension/ExtensionLoader.java b/src/org/parosproxy/paros/extension/ExtensionLoader.java
index b51bf270b..c0f47f38d 100644
--- a/src/org/parosproxy/paros/extension/ExtensionLoader.java
+++ b/src/org/parosproxy/paros/extension/ExtensionLoader.java
@@ -60,6 +60,7 @@
 // ZAP: 2015/02/10 Issue 1208: Search classes/resources in add-ons declared as dependencies
 // ZAP: 2015/04/09 Generify Extension.getExtension(Class) to avoid unnecessary casts
 // ZAP: 2015/09/07 Start GUI on EDT
+// ZAP: 2016/04/06 Fix layouts' issues
 // ZAP: 2016/04/08 Hook ContextDataFactory/ContextPanelFactory 
 
 package org.parosproxy.paros.extension;
@@ -96,12 +97,12 @@ import org.parosproxy.paros.view.AbstractParamPanel;
 import org.parosproxy.paros.view.MainMenuBar;
 import org.parosproxy.paros.view.SiteMapPanel;
 import org.parosproxy.paros.view.View;
+import org.parosproxy.paros.view.WorkbenchPanel;
 import org.zaproxy.zap.PersistentConnectionListener;
 import org.zaproxy.zap.extension.AddonFilesChangedListener;
 import org.zaproxy.zap.model.ContextDataFactory;
 import org.zaproxy.zap.view.ContextPanelFactory;
 import org.zaproxy.zap.view.SiteMapListener;
-import org.zaproxy.zap.view.TabbedPanel2;
 
 public class ExtensionLoader {
 
@@ -623,39 +624,6 @@ public class ExtensionLoader {
         dialog.revalidate();
     }
 
-    /**
-     * Add every panel from panelList to the TabbedPanel2 tab.
-     *
-     * @param panelList
-     * @param tab
-     */
-    private void addTabPanel(List<AbstractPanel> panelList, TabbedPanel2 tab) {
-        for (AbstractPanel panel : panelList) {
-            try {
-                tab.addTab(panel);
-                if (panel.getTabIndex() == 0 && tab.indexOfComponent(panel) != -1) {
-                    // Its now the first one, give it focus
-                    tab.setSelectedComponent(panel);
-                }
-                
-            } catch (Exception e) {
-                logger.error(e.getMessage(), e);
-            }
-        }
-    }
-
-    private void removeTabPanel(List<AbstractPanel> panelList, TabbedPanel2 tab) {
-        for (AbstractPanel panel : panelList) {
-            try {
-                tab.removeTab(panel);
-                
-            } catch (Exception e) {
-                logger.error(e.getMessage(), e);
-            }
-        }
-        tab.revalidate();
-    }
-
     private void hookAllExtension(double progressFactor) {
         final double factorPerc = progressFactor / getExtensionCount();
         
@@ -909,27 +877,9 @@ public class ExtensionLoader {
             }
         }
 
-        // Add the three panels to the current window/workbench: add extension tabs to the Full layout
-        // when chosen, otherwise they are as before.
-        int displayOption = Model.getSingleton().getOptionsParam().getViewParam().getDisplayOption();
-        addTabPanel(pv.getSelectPanel(), view.getWorkbench().getTabbedSelect());
-        addTabPanel(pv.getWorkPanel(), view.getWorkbench().getTabbedWork());
-        addTabPanel(pv.getStatusPanel(), view.getWorkbench().getTabbedStatus());
-
-        // remember the position of tabs in status position
-        if (displayOption == View.DISPLAY_OPTION_TOP_FULL) {
-            // save the current normal instances to old instance variables, so they are both
-            // referencing the same TabbedPanel2 instances. Used when going into 'Full Layout'
-            // so the state is preserved.
-            view.getWorkbench().setTabbedOldWork(view.getWorkbench().getTabbedWork());
-            view.getWorkbench().setTabbedOldSelect(view.getWorkbench().getTabbedSelect());
-            view.getWorkbench().setTabbedOldStatus(view.getWorkbench().getTabbedStatus());
-
-            // switch the layout to Full Layout
-            addTabPanel(pv.getSelectPanel(), view.getWorkbench().getTabbedStatus());
-            addTabPanel(pv.getWorkPanel(), view.getWorkbench().getTabbedStatus());
-            addTabPanel(pv.getStatusPanel(), view.getWorkbench().getTabbedStatus());
-        }
+        view.getWorkbench().addPanels(pv.getSelectPanel(), WorkbenchPanel.PanelType.SELECT);
+        view.getWorkbench().addPanels(pv.getWorkPanel(), WorkbenchPanel.PanelType.WORK);
+        view.getWorkbench().addPanels(pv.getStatusPanel(), WorkbenchPanel.PanelType.STATUS);
 
         addParamPanel(pv.getSessionPanel(), view.getSessionDialog());
         addParamPanel(pv.getOptionsPanel(), view.getOptionsDialog(""));
@@ -953,23 +903,9 @@ public class ExtensionLoader {
             }
         }
 
-        // Remote the three panels to the current window/workbench: remove extension tabs
-        // from the Full layout when chosen.
-        int displayOption = Model.getSingleton().getOptionsParam().getViewParam().getDisplayOption();
-        switch (displayOption) {
-            case View.DISPLAY_OPTION_TOP_FULL:
-                removeTabPanel(pv.getSelectPanel(), view.getWorkbench().getTabbedStatus());
-                removeTabPanel(pv.getWorkPanel(), view.getWorkbench().getTabbedStatus());
-                removeTabPanel(pv.getStatusPanel(), view.getWorkbench().getTabbedStatus());
-                break;
-                
-            case View.DISPLAY_OPTION_LEFT_FULL:
-            case View.DISPLAY_OPTION_BOTTOM_FULL:
-            default:
-                removeTabPanel(pv.getSelectPanel(), view.getWorkbench().getTabbedSelect());
-                removeTabPanel(pv.getWorkPanel(), view.getWorkbench().getTabbedWork());
-                removeTabPanel(pv.getStatusPanel(), view.getWorkbench().getTabbedStatus());
-        }
+        view.getWorkbench().removePanels(pv.getSelectPanel(), WorkbenchPanel.PanelType.SELECT);
+        view.getWorkbench().removePanels(pv.getWorkPanel(), WorkbenchPanel.PanelType.WORK);
+        view.getWorkbench().removePanels(pv.getStatusPanel(), WorkbenchPanel.PanelType.STATUS);
 
         removeParamPanel(pv.getSessionPanel(), view.getSessionDialog());
         removeParamPanel(pv.getOptionsPanel(), view.getOptionsDialog(""));
@@ -980,7 +916,7 @@ public class ExtensionLoader {
             return;
         }
         
-        View.getSingleton().getWorkbench().getTabbedStatus().remove(panel);
+        View.getSingleton().getWorkbench().removePanel(panel, WorkbenchPanel.PanelType.STATUS);
     }
 
     public void removeOptionsPanel(AbstractParamPanel panel) {
@@ -1000,7 +936,7 @@ public class ExtensionLoader {
             return;
         }
         
-        View.getSingleton().getWorkbench().getTabbedWork().remove(panel);
+        View.getSingleton().getWorkbench().removePanel(panel, WorkbenchPanel.PanelType.WORK);
     }
 
     public void removePopupMenuItem(ExtensionPopupMenuItem popupMenuItem) {
diff --git a/src/org/parosproxy/paros/extension/option/OptionsParamView.java b/src/org/parosproxy/paros/extension/option/OptionsParamView.java
index f58f970c4..b160458fd 100644
--- a/src/org/parosproxy/paros/extension/option/OptionsParamView.java
+++ b/src/org/parosproxy/paros/extension/option/OptionsParamView.java
@@ -31,6 +31,7 @@
 // ZAP: 2014/12/16 Issue 1466: Config option for 'large display' size
 // ZAP: 2015/03/04 Added dev build warning option
 // ZAP: 2016/04/04 Do not require a restart to show/hide the tool bar
+// ZAP: 2016/04/06 Fix layouts' issues
 
 package org.parosproxy.paros.extension.option;
 
@@ -39,7 +40,7 @@ import java.util.Locale;
 import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.common.AbstractParam;
 import org.parosproxy.paros.control.Control.Mode;
-import org.parosproxy.paros.view.View;
+import org.parosproxy.paros.view.WorkbenchPanel;
 import org.zaproxy.zap.extension.httppanel.view.largerequest.LargeRequestUtil;
 import org.zaproxy.zap.extension.httppanel.view.largeresponse.LargeResponseUtil;
 
@@ -56,6 +57,7 @@ public class OptionsParamView extends AbstractParam {
 	public static final String LOCALE = "view.locale";
 	public static final String LOCALES = "view.locales";
 	public static final String DISPLAY_OPTION = "view.displayOption";
+	private static final String RESPONSE_PANEL_POS_KEY = BASE_VIEW_KEY + ".messagePanelsPosition.lastSelectedPosition";
 	public static final String BRK_PANEL_VIEW_OPTION = "view.brkPanelView";
 	public static final String SHOW_MAIN_TOOLBAR_OPTION = "view.showMainToolbar";
 	public static final String DEFAULT_LOCALE = "en_GB";
@@ -81,6 +83,7 @@ public class OptionsParamView extends AbstractParam {
 	private String configLocale = "";
 	private String locale = "";
 	private int displayOption = 0;
+	private String responsePanelPosition;
 	private int brkPanelViewOption = 0;
 	private int askOnExitEnabled = 1;
 	private int wmUiHandlingEnabled = 0;
@@ -108,6 +111,8 @@ public class OptionsParamView extends AbstractParam {
 	    configLocale = getConfig().getString(LOCALE, null);	// No default
 	    locale = getConfig().getString(LOCALE, DEFAULT_LOCALE);
 	    displayOption = getConfig().getInt(DISPLAY_OPTION, 0);
+        responsePanelPosition = getConfig()
+                .getString(RESPONSE_PANEL_POS_KEY, WorkbenchPanel.ResponsePanelPosition.TABS_SIDE_BY_SIDE.name());
 	    brkPanelViewOption = getConfig().getInt(BRK_PANEL_VIEW_OPTION, 0);
 	    showMainToolbar = getConfig().getInt(SHOW_MAIN_TOOLBAR_OPTION, 1);
 	    advancedViewEnabled = getConfig().getInt(ADVANCEDUI_OPTION, 0);
@@ -232,10 +237,6 @@ public class OptionsParamView extends AbstractParam {
 	
 	public void setShowTabNames(boolean showTabNames) {
 		this.showTabNames = showTabNames;
-
-    	// toggle between shown/hidden tab names 
-    	View.getSingleton().getWorkbench().toggleTabNames(showTabNames);
-
 		getConfig().setProperty(SHOW_TEXT_ICONS, showTabNames);
 	}
 
@@ -256,6 +257,28 @@ public class OptionsParamView extends AbstractParam {
 		this.displayOption = displayOption;
 		getConfig().setProperty(DISPLAY_OPTION, Integer.toString(displayOption));
 	}
+
+	/**
+	 * Gets the name of the current response panel position.
+	 *
+	 * @return the name of the current position
+	 * @since TODO add version
+	 * @see org.parosproxy.paros.view.WorkbenchPanel.ResponsePanelPosition
+	 */
+	public String getResponsePanelPosition() {
+		return responsePanelPosition;
+	}
+
+	/**
+	 * Sets the name of the current response panel position.
+	 * 
+	 * @param position the name of the position
+	 * @since TODO add version
+	 */
+	public void setResponsePanelPosition(String position) {
+		this.responsePanelPosition = position;
+		getConfig().setProperty(RESPONSE_PANEL_POS_KEY, position);
+	}
 	
 	public int getAdvancedViewOption() {
 		return advancedViewEnabled;
diff --git a/src/org/parosproxy/paros/extension/option/OptionsViewPanel.java b/src/org/parosproxy/paros/extension/option/OptionsViewPanel.java
index c8535bb18..c3ff74912 100644
--- a/src/org/parosproxy/paros/extension/option/OptionsViewPanel.java
+++ b/src/org/parosproxy/paros/extension/option/OptionsViewPanel.java
@@ -26,6 +26,7 @@
 // ZAP: 2014/10/09 Issue 1359: Options for splash screen
 // ZAP: 2014/12/16 Issue 1466: Config option for 'large display' size
 // ZAP: 2016/04/04 Do not require a restart to show/hide the tool bar
+// ZAP: 2016/04/06 Fix layouts' issues
 
 package org.parosproxy.paros.extension.option;
 
@@ -54,6 +55,7 @@ import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.model.Model;
 import org.parosproxy.paros.model.OptionsParam;
 import org.parosproxy.paros.view.AbstractParamPanel;
+import org.parosproxy.paros.view.WorkbenchPanel;
 import org.zaproxy.zap.extension.httppanel.view.largerequest.LargeRequestUtil;
 import org.zaproxy.zap.extension.httppanel.view.largeresponse.LargeResponseUtil;
 import org.zaproxy.zap.utils.FontUtils;
@@ -86,6 +88,7 @@ public class OptionsViewPanel extends AbstractParamPanel {
 	
 	private JComboBox<String> brkPanelViewSelect = null;
 	private JComboBox<String> displaySelect = null;
+	private JComboBox<ResponsePanelPositionUI> responsePanelPositionComboBox;
 	private JComboBox<String> timeStampsFormatSelect = null; 
 	private JComboBox<String> fontName = null;
 	
@@ -153,120 +156,140 @@ public class OptionsViewPanel extends AbstractParamPanel {
 			outputTabTimeStampExampleLabel = new JLabel(TimeStampUtils.currentDefaultFormattedTimeStamp());
 			showSplashScreenLabel = new JLabel(Constant.messages.getString("view.options.label.showSplashScreen"));
 			
+			int row = 0;
 			displayLabel.setLabelFor(getDisplaySelect());
 			panelMisc.add(displayLabel, 
-					LayoutHelper.getGBC(0, 0, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getDisplaySelect(), 
-					LayoutHelper.getGBC(1, 0, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 
+			row++;
+			JLabel responsePanelPositionLabel = new JLabel(Constant.messages.getString("view.options.label.responsepanelpos"));
+			panelMisc.add(responsePanelPositionLabel, 
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+			panelMisc.add(getResponsePanelPositionComboBox(), 
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+
+			row++;
 			brkPanelViewLabel.setLabelFor(getBrkPanelViewSelect());
 			panelMisc.add(brkPanelViewLabel, 
-					LayoutHelper.getGBC(0, 1, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getBrkPanelViewSelect(), 
-					LayoutHelper.getGBC(1, 1, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 
-			
+			row++;
 			largeRequestLabel.setLabelFor(getLargeRequestSize());
 			panelMisc.add(largeRequestLabel, 
-					LayoutHelper.getGBC(0, 2, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getLargeRequestSize(), 
-					LayoutHelper.getGBC(1, 2, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 
+			row++;
 			largeResponseLabel.setLabelFor(getLargeResponseSize());
 			panelMisc.add(largeResponseLabel, 
-					LayoutHelper.getGBC(0, 3, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getLargeResponseSize(), 
-					LayoutHelper.getGBC(1, 3, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 
 			
-			
+			row++;
 			advancedViewLabel.setLabelFor(getChkAdvancedView());
 			panelMisc.add(advancedViewLabel, 
-					LayoutHelper.getGBC(0, 4, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getChkAdvancedView(), 
-					LayoutHelper.getGBC(1, 4, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			
+			row++;
 			wmUiHandlingLabel.setLabelFor(getChkWmUiHandling());
 			panelMisc.add(wmUiHandlingLabel,  
-					LayoutHelper.getGBC(0, 5, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getChkWmUiHandling(),  
-					LayoutHelper.getGBC(1, 5, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 
+			row++;
 			askOnExitLabel.setLabelFor(getChkAskOnExit());
 			panelMisc.add(askOnExitLabel,  
-					LayoutHelper.getGBC(0, 6, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getChkAskOnExit(),  
-					LayoutHelper.getGBC(1, 6, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			
+			row++;
 			showMainToolbarLabel.setLabelFor(getChkShowMainToolbar());
 			panelMisc.add(showMainToolbarLabel,  
-					LayoutHelper.getGBC(0, 7, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getChkShowMainToolbar(),  
-					LayoutHelper.getGBC(1, 7, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			
+			row++;
 			processImagesLabel.setLabelFor(getChkProcessImages());
 			panelMisc.add(processImagesLabel,  
-					LayoutHelper.getGBC(0, 8, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getChkProcessImages(),  
-					LayoutHelper.getGBC(1, 8, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 
+			row++;
 			showTabNamesLabel.setLabelFor(getShowTabNames());
 			panelMisc.add(showTabNamesLabel,  
-					LayoutHelper.getGBC(0, 9, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getShowTabNames(),  
-					LayoutHelper.getGBC(1, 9, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			
+			row++;
 			showSplashScreenLabel.setLabelFor(getShowSplashScreen());
 			panelMisc.add(showSplashScreenLabel,  
-					LayoutHelper.getGBC(0, 10, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getShowSplashScreen(),  
-					LayoutHelper.getGBC(1, 10, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			
+			row++;
 			outputTabTimeStampLabel.setLabelFor(getChkOutputTabTimeStamps());
 			panelMisc.add(outputTabTimeStampLabel,   
-					LayoutHelper.getGBC(0, 11, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getChkOutputTabTimeStamps(),   
-					LayoutHelper.getGBC(1, 11, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			
+			row++;
 			outputTabTimeStampExampleLabel.setLabelFor(getTimeStampsFormatSelect());
 			panelMisc.add(getTimeStampsFormatSelect(),   
-					LayoutHelper.getGBC(0, 12, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(outputTabTimeStampExampleLabel,   
-					LayoutHelper.getGBC(1, 12, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 
+			row++;
 			JLabel fontNameLabel = new JLabel(Constant.messages.getString("view.options.label.fontName")); 
 			fontNameLabel.setLabelFor(getFontName());
 			panelMisc.add(fontNameLabel,   
-					LayoutHelper.getGBC(0, 13, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getFontName(),   
-					LayoutHelper.getGBC(1, 13, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 
+			row++;
 			JLabel fontSizeLabel = new JLabel(Constant.messages.getString("view.options.label.fontSize")); 
 			fontSizeLabel.setLabelFor(getFontSize());
 			panelMisc.add(fontSizeLabel,   
-					LayoutHelper.getGBC(0, 14, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getFontSize(),   
-					LayoutHelper.getGBC(1, 14, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			
+			row++;
 			JLabel fontExampleLabel = new JLabel(Constant.messages.getString("view.options.label.fontExample")); 
 			fontExampleLabel.setLabelFor(getFontExampleLabel());
 			panelMisc.add(fontExampleLabel,   
-					LayoutHelper.getGBC(0, 15, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getFontExampleLabel(),   
-					LayoutHelper.getGBC(1, 15, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			
-			panelMisc.add(new JLabel(""),   
-					LayoutHelper.getGBC(0, 20, 1, 1.0D, 1.0D));
-
+			row++;
 			JLabel scaleImagesLabel = new JLabel(Constant.messages.getString("view.options.label.scaleImages")); 
 			fontExampleLabel.setLabelFor(getScaleImages());
 			panelMisc.add(scaleImagesLabel,   
-					LayoutHelper.getGBC(0, 16, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			panelMisc.add(getScaleImages(),   
-					LayoutHelper.getGBC(1, 16, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
+					LayoutHelper.getGBC(1, row, 1, 1.0D, new java.awt.Insets(2,2,2,2)));
 			
+			row++;
 			panelMisc.add(new JLabel(""),   
-					LayoutHelper.getGBC(0, 20, 1, 1.0D, 1.0D));
+					LayoutHelper.getGBC(0, row, 1, 1.0D, 1.0D));
 
 		}
 		return panelMisc;
@@ -335,6 +358,25 @@ public class OptionsViewPanel extends AbstractParamPanel {
 		}
 		return displaySelect;
 	}
+
+	private JComboBox<ResponsePanelPositionUI> getResponsePanelPositionComboBox() {
+		if (responsePanelPositionComboBox == null) {
+			responsePanelPositionComboBox = new JComboBox<>();
+			responsePanelPositionComboBox.addItem(
+					new ResponsePanelPositionUI(
+							Constant.messages.getString("view.options.label.responsepanelpos.tabs"),
+							WorkbenchPanel.ResponsePanelPosition.TABS_SIDE_BY_SIDE));
+			responsePanelPositionComboBox.addItem(
+					new ResponsePanelPositionUI(
+							Constant.messages.getString("view.options.label.responsepanelpos.sideBySide"),
+							WorkbenchPanel.ResponsePanelPosition.PANELS_SIDE_BY_SIDE));
+			responsePanelPositionComboBox.addItem(
+					new ResponsePanelPositionUI(
+							Constant.messages.getString("view.options.label.responsepanelpos.above"),
+							WorkbenchPanel.ResponsePanelPosition.PANEL_ABOVE));
+		}
+		return responsePanelPositionComboBox;
+	}
 	
 	private JComboBox<String> getBrkPanelViewSelect() {
 		if (brkPanelViewSelect == null) {
@@ -490,6 +532,7 @@ public class OptionsViewPanel extends AbstractParamPanel {
 	    getShowSplashScreen().setSelected(options.getViewParam().isShowSplashScreen());
 	    getChkProcessImages().setSelected(options.getViewParam().getProcessImages() > 0);
 	    displaySelect.setSelectedIndex(options.getViewParam().getDisplayOption());
+	    selectResponstPanelPosition(options.getViewParam().getResponsePanelPosition());
 	    brkPanelViewSelect.setSelectedIndex(options.getViewParam().getBrkPanelViewOption());
 	    getChkShowMainToolbar().setSelected(options.getViewParam().isShowMainToolbar());
 	    chkAdvancedView.setSelected(options.getViewParam().getAdvancedViewOption() > 0);
@@ -504,6 +547,20 @@ public class OptionsViewPanel extends AbstractParamPanel {
 	    getScaleImages().setSelected(options.getViewParam().isScaleImages());
 	}
 	
+	private void selectResponstPanelPosition(String positionName) {
+		for (int i = 0; i < getResponsePanelPositionComboBox().getItemCount(); i++) {
+			ResponsePanelPositionUI item = getResponsePanelPositionComboBox().getItemAt(i);
+			if (item.getPosition().name().equals(positionName)) {
+				getResponsePanelPositionComboBox().setSelectedIndex(i);
+				break;
+			}
+		}
+
+		if (getResponsePanelPositionComboBox().getSelectedIndex() == -1) {
+			getResponsePanelPositionComboBox().setSelectedIndex(0);
+		}
+	}
+
 	@Override
 	public void validateParam(Object obj) {
 	    // no validation needed
@@ -516,6 +573,8 @@ public class OptionsViewPanel extends AbstractParamPanel {
 	    options.getViewParam().setShowSplashScreen(getShowSplashScreen().isSelected());
 	    options.getViewParam().setProcessImages((getChkProcessImages().isSelected()) ? 1 : 0);
 	    options.getViewParam().setDisplayOption(displaySelect.getSelectedIndex());
+	    ResponsePanelPositionUI selectedItem = (ResponsePanelPositionUI) getResponsePanelPositionComboBox().getSelectedItem();
+	    options.getViewParam().setResponsePanelPosition(selectedItem.getPosition().name());
 	    options.getViewParam().setBrkPanelViewOption(brkPanelViewSelect.getSelectedIndex());
 	    options.getViewParam().setShowMainToolbar(getChkShowMainToolbar().isSelected());
 	    options.getViewParam().setAdvancedViewOption(getChkAdvancedView().isSelected() ? 1 : 0);
@@ -553,4 +612,24 @@ public class OptionsViewPanel extends AbstractParamPanel {
 	        return renderer;
 	    }
 	}
+
+	private static class ResponsePanelPositionUI {
+
+		private final String name;
+		private final WorkbenchPanel.ResponsePanelPosition position;
+
+		public ResponsePanelPositionUI(String name, WorkbenchPanel.ResponsePanelPosition position) {
+			this.name = name;
+			this.position = position;
+		}
+
+		public WorkbenchPanel.ResponsePanelPosition getPosition() {
+			return position;
+		}
+
+		@Override
+		public String toString() {
+			return name;
+		}
+	}
 }
diff --git a/src/org/parosproxy/paros/view/MainFrame.java b/src/org/parosproxy/paros/view/MainFrame.java
index 012e951fb..b0f1dfcfa 100644
--- a/src/org/parosproxy/paros/view/MainFrame.java
+++ b/src/org/parosproxy/paros/view/MainFrame.java
@@ -26,48 +26,201 @@
 // ZAP: 2013/07/23 Issue 738: Options to hide tabs
 // ZAP: 2015/01/29 Issue 1489: Version number in window title
 // ZAP: 2016/04/04 Do not require a restart to show/hide the tool bar
+// ZAP: 2016/04/06 Fix layouts' issues
 
 package org.parosproxy.paros.view;
 
 import java.awt.CardLayout;
 import java.awt.Dimension;
+import java.awt.event.ActionEvent;
 import java.awt.event.WindowAdapter;
 import java.awt.event.WindowEvent;
+import java.net.URL;
 
+import javax.swing.AbstractAction;
 import javax.swing.BoxLayout;
+import javax.swing.ButtonGroup;
+import javax.swing.ImageIcon;
+import javax.swing.JButton;
 import javax.swing.JPanel;
+import javax.swing.JToggleButton;
 import javax.swing.WindowConstants;
 
+import org.apache.commons.configuration.ConfigurationException;
+import org.apache.log4j.Logger;
 import org.parosproxy.paros.Constant;
+import org.parosproxy.paros.extension.AbstractPanel;
 import org.parosproxy.paros.model.Model;
+import org.parosproxy.paros.model.OptionsParam;
+import org.zaproxy.zap.utils.DisplayUtils;
 import org.zaproxy.zap.view.MainToolbarPanel;
-
+import org.zaproxy.zap.view.ZapToggleButton;
 
 public class MainFrame extends AbstractFrame {
+
+	private static final Logger LOGGER = Logger.getLogger(MainFrame.class);
+
+	private static final String TABS_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.tabs");
+	private static final String DISABLED_TABS_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.tabs.disabled");
+	private static final String ABOVE_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.above");
+	private static final String DISABLED_ABOVE_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.above.disabled");
+	private static final String SIDE_BY_SIDE_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.sideBySide");
+	private static final String DISABLED_SIDE_BY_SIDE_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.sideBySide.disabled");
+
 	private static final long serialVersionUID = -1430550461546083192L;
 
+	private final OptionsParam options;
 	private JPanel paneContent = null;
 	// ZAP: Removed instance variable (JLabel txtStatus). The status label that
 	// was in the footer panel is no longer used.
-	private org.parosproxy.paros.view.WorkbenchPanel paneStandard = null;
+	private final WorkbenchPanel paneStandard;
 	private org.parosproxy.paros.view.MainMenuBar mainMenuBar = null;
 	private JPanel paneDisplay = null;
 
 	private MainToolbarPanel mainToolbarPanel = null;
 	private MainFooterPanel mainFooterPanel = null;
 
-	private int displayOption;
+	/**
+	 * The {@code ZapToggleButton} that sets whether or not the tabs should show the panels' names.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getShowTabIconNamesButton()
+	 */
+	private ZapToggleButton showTabIconNamesButton;
 
 	/**
-	 * This method initializes
-	 *
+	 * The {@code JButton} that shows all tabs.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getShowAllTabsButton()
+	 */
+	private JButton showAllTabsButton;
+
+	/**
+	 * The {@code JButton} that hides all tabs (if hideable and not pinned).
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getHideAllTabsButton()
+	 */
+	private JButton hideAllTabsButton;
+
+	/**
+	 * The current workbench layout, never {@code null}.
+	 * 
+	 * @see #setWorkbenchLayout(WorkbenchPanel.Layout)
+	 */
+	private WorkbenchPanel.Layout workbenchLayout;
+
+	/**
+	 * The {@code JToggleButton} that sets the layout {@link WorkbenchPanel.Layout#EXPAND_SELECT}.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getExpandSelectLayoutButton()
 	 */
+	private JToggleButton expandSelectLayoutButton;
+
+	/**
+	 * The {@code JToggleButton} that sets the layout {@link WorkbenchPanel.Layout#EXPAND_STATUS}.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getExpandStatusLayoutButton()
+	 */
+	private JToggleButton expandStatusLayoutButton;
+
+	/**
+	 * The {@code JToggleButton} that sets the layout {@link WorkbenchPanel.Layout#FULL}.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getFullLayoutButton()
+	 */
+	private JToggleButton fullLayoutButton;
+
+	/**
+	 * The current position of the response panel, never {@code null}.
+	 * 
+	 * @see #setResponsePanelPosition(WorkbenchPanel.ResponsePanelPosition)
+	 */
+	private WorkbenchPanel.ResponsePanelPosition responsePanelPosition;
+
+	/**
+	 * The {@code ZapToggleButton} that sets the response panel position
+	 * {@link WorkbenchPanel.ResponsePanelPosition#TABS_SIDE_BY_SIDE}.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getTabsResponsePanelPositionButton()
+	 */
+	private ZapToggleButton tabsResponsePanelPositionButton;
+
+	/**
+	 * The {@code ZapToggleButton} that sets the response panel position
+	 * {@link WorkbenchPanel.ResponsePanelPosition#PANEL_ABOVE}.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getAboveResponsePanelPositionButton()
+	 */
+	private ZapToggleButton aboveResponsePanelPositionButton;
+
+	/**
+	 * The {@code ZapToggleButton} that sets the response panel position
+	 * {@link WorkbenchPanel.ResponsePanelPosition#PANELS_SIDE_BY_SIDE}.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getPanelsResponsePanelPositionButton()
+	 */
+	private ZapToggleButton panelsResponsePanelPositionButton;
+
+	/**
+	 * @deprecated (TODO add version) Use {@link #MainFrame(OptionsParam, HttpPanelRequest, HttpPanelResponse)} instead.
+	 */
+	@Deprecated
+	@SuppressWarnings("javadoc")
 	public MainFrame(int displayOption) {
+		this(Model.getSingleton().getOptionsParam(),
+			 View.getSingleton().getRequestPanel(),
+			 View.getSingleton().getResponsePanel());
+
+		changeDisplayOption(displayOption);
+	}
+
+	/**
+	 * Constructs a {@code MainFrame} with the given options and request and response panels.
+	 * 
+	 * @param options the options
+	 * @param requestPanel the main request panel
+	 * @param responsePanel the main response panel
+	 * @throws IllegalArgumentException if any of the parameters is {@code null}.
+	 * @since TODO add version
+	 */
+	public MainFrame(OptionsParam options, AbstractPanel requestPanel, AbstractPanel responsePanel) {
 		super();
-		this.displayOption = -1;
+
+		if (options == null) {
+			throw new IllegalArgumentException("Parameter options must not be null");
+		}
+		if (requestPanel == null) {
+			throw new IllegalArgumentException("Parameter requestPanel must not be null");
+		}
+		if (responsePanel == null) {
+			throw new IllegalArgumentException("Parameter responsePanel must not be null");
+		}
+
+		this.options = options;
+		paneStandard = new WorkbenchPanel(options.getViewParam(), requestPanel, responsePanel);
+		paneStandard.setLayout(new CardLayout());
+		paneStandard.setName("paneStandard");
+
 		initialize();
-		
-		changeDisplayOption(displayOption);
+
+		applyViewOptions();
 	}
 
 	/**
@@ -110,16 +263,12 @@ public class MainFrame extends AbstractFrame {
 	}
 
 	/**
-	 * This method initializes paneStandard
+	 * Gets the {@code WorkbenchPanel}.
 	 *
-	 * @return org.parosproxy.paros.view.StandardPanel
+	 * @return the workbench panel
+	 * @since 2.2.0
 	 */
-	public org.parosproxy.paros.view.WorkbenchPanel getWorkbench() {
-		if (paneStandard == null) {
-			paneStandard = new org.parosproxy.paros.view.WorkbenchPanel(displayOption);
-			paneStandard.setLayout(new CardLayout());
-			paneStandard.setName("paneStandard");
-		}
+	public WorkbenchPanel getWorkbench() {
 		return paneStandard;
 	}
 
@@ -159,10 +308,167 @@ public class MainFrame extends AbstractFrame {
 	public MainToolbarPanel getMainToolbarPanel() {
 		if (mainToolbarPanel == null) {
 			mainToolbarPanel = new MainToolbarPanel();
+
+			mainToolbarPanel.addButton(getShowAllTabsButton());
+			mainToolbarPanel.addButton(getHideAllTabsButton());
+			mainToolbarPanel.addButton(getShowTabIconNamesButton());
+			mainToolbarPanel.addSeparator();
+
+			ButtonGroup layoutsButtonGroup = new ButtonGroup();
+			mainToolbarPanel.addButton(getExpandSelectLayoutButton());
+			layoutsButtonGroup.add(getExpandSelectLayoutButton());
+			mainToolbarPanel.addButton(getExpandStatusLayoutButton());
+			layoutsButtonGroup.add(getExpandStatusLayoutButton());
+			mainToolbarPanel.addButton(getFullLayoutButton());
+			layoutsButtonGroup.add(getFullLayoutButton());
+			mainToolbarPanel.addSeparator();
+
+			ButtonGroup responsePanelPositionsButtonGroup = new ButtonGroup();
+			mainToolbarPanel.addButton(getTabsResponsePanelPositionButton());
+			responsePanelPositionsButtonGroup.add(getTabsResponsePanelPositionButton());
+			mainToolbarPanel.addButton(getPanelsResponsePanelPositionButton());
+			responsePanelPositionsButtonGroup.add(getPanelsResponsePanelPositionButton());
+			mainToolbarPanel.addButton(getAboveResponsePanelPositionButton());
+			responsePanelPositionsButtonGroup.add(getAboveResponsePanelPositionButton());
+			mainToolbarPanel.addSeparator();
 		}
 		return mainToolbarPanel;
 	}
 
+	private JButton getShowAllTabsButton() {
+		if (showAllTabsButton == null) {
+			showAllTabsButton = new JButton();
+			showAllTabsButton.setIcon(new ImageIcon(WorkbenchPanel.class.getResource("/resource/icon/fugue/ui-tab-show.png")));
+			showAllTabsButton.setToolTipText(Constant.messages.getString("menu.view.tabs.show"));
+			DisplayUtils.scaleIcon(showAllTabsButton);
+
+			showAllTabsButton.addActionListener(new java.awt.event.ActionListener() {
+
+				@Override
+				public void actionPerformed(ActionEvent e) {
+					View.getSingleton().showAllTabs();
+				}
+			});
+		}
+		return showAllTabsButton;
+	}
+
+	private JButton getHideAllTabsButton() {
+		if (hideAllTabsButton == null) {
+			hideAllTabsButton = new JButton();
+			hideAllTabsButton.setIcon(new ImageIcon(WorkbenchPanel.class.getResource("/resource/icon/fugue/ui-tab-hide.png")));
+			hideAllTabsButton.setToolTipText(Constant.messages.getString("menu.view.tabs.hide"));
+			DisplayUtils.scaleIcon(hideAllTabsButton);
+
+			hideAllTabsButton.addActionListener(new java.awt.event.ActionListener() {
+
+				@Override
+				public void actionPerformed(ActionEvent e) {
+					View.getSingleton().hideAllTabs();
+				}
+			});
+		}
+		return hideAllTabsButton;
+	}
+
+	private JToggleButton getShowTabIconNamesButton() {
+		if (showTabIconNamesButton == null) {
+			showTabIconNamesButton = new ZapToggleButton();
+			showTabIconNamesButton.setIcon(new ImageIcon(WorkbenchPanel.class.getResource("/resource/icon/ui_tab_icon.png")));
+			showTabIconNamesButton.setToolTipText(Constant.messages.getString("view.toolbar.showNames"));
+			showTabIconNamesButton
+					.setSelectedIcon(new ImageIcon(WorkbenchPanel.class.getResource("/resource/icon/ui_tab_text.png")));
+			showTabIconNamesButton.setSelectedToolTipText(Constant.messages.getString("view.toolbar.showIcons"));
+			showTabIconNamesButton.setSelected(Model.getSingleton().getOptionsParam().getViewParam().getShowTabNames());
+			DisplayUtils.scaleIcon(showTabIconNamesButton);
+
+			showTabIconNamesButton.addActionListener(new java.awt.event.ActionListener() {
+
+				@Override
+				public void actionPerformed(ActionEvent evt) {
+					boolean showTabNames = getShowTabIconNamesButton().isSelected();
+					setShowTabNames(showTabNames);
+					Model.getSingleton().getOptionsParam().getViewParam().setShowTabNames(showTabNames);
+					try {
+						Model.getSingleton().getOptionsParam().getViewParam().getConfig().save();
+					} catch (ConfigurationException e) {
+						LOGGER.error(e.getMessage(), e);
+					}
+				}
+			});
+		}
+		return showTabIconNamesButton;
+	}
+
+	private JToggleButton getExpandSelectLayoutButton() {
+		if (expandSelectLayoutButton == null) {
+			expandSelectLayoutButton = new JToggleButton(
+					new ChangeWorkbenchLayoutAction(
+							WorkbenchPanel.class.getResource("/resource/icon/expand_sites.png"),
+							WorkbenchPanel.Layout.EXPAND_SELECT));
+			expandSelectLayoutButton.setToolTipText(Constant.messages.getString("view.toolbar.expandSites"));
+		}
+		return expandSelectLayoutButton;
+	}
+
+	private JToggleButton getExpandStatusLayoutButton() {
+		if (expandStatusLayoutButton == null) {
+			expandStatusLayoutButton = new JToggleButton(
+					new ChangeWorkbenchLayoutAction(
+							WorkbenchPanel.class.getResource("/resource/icon/expand_info.png"),
+							WorkbenchPanel.Layout.EXPAND_STATUS));
+			expandStatusLayoutButton.setToolTipText(Constant.messages.getString("view.toolbar.expandInfo"));
+		}
+		return expandStatusLayoutButton;
+	}
+
+	private JToggleButton getFullLayoutButton() {
+		if (fullLayoutButton == null) {
+			fullLayoutButton = new JToggleButton(
+					new ChangeWorkbenchLayoutAction(
+							WorkbenchPanel.class.getResource("/resource/icon/expand_full.png"),
+							WorkbenchPanel.Layout.FULL));
+			fullLayoutButton.setToolTipText(Constant.messages.getString("view.toolbar.expandFull"));
+		}
+		return fullLayoutButton;
+	}
+
+	private ZapToggleButton getTabsResponsePanelPositionButton() {
+		if (tabsResponsePanelPositionButton == null) {
+			tabsResponsePanelPositionButton = new ZapToggleButton(
+					new SetResponsePanelPositionAction(
+							WorkbenchPanel.class.getResource("/resource/icon/layout_tabbed.png"),
+							WorkbenchPanel.ResponsePanelPosition.TABS_SIDE_BY_SIDE));
+			tabsResponsePanelPositionButton.setToolTipText(TABS_VIEW_TOOL_TIP);
+			tabsResponsePanelPositionButton.setDisabledToolTipText(DISABLED_TABS_VIEW_TOOL_TIP);
+		}
+		return tabsResponsePanelPositionButton;
+	}
+
+	private ZapToggleButton getPanelsResponsePanelPositionButton() {
+		if (panelsResponsePanelPositionButton == null) {
+			panelsResponsePanelPositionButton = new ZapToggleButton(
+					new SetResponsePanelPositionAction(
+							WorkbenchPanel.class.getResource("/resource/icon/layout_horizontal_split.png"),
+							WorkbenchPanel.ResponsePanelPosition.PANELS_SIDE_BY_SIDE));
+			panelsResponsePanelPositionButton.setToolTipText(SIDE_BY_SIDE_VIEW_TOOL_TIP);
+			panelsResponsePanelPositionButton.setDisabledToolTipText(DISABLED_SIDE_BY_SIDE_VIEW_TOOL_TIP);
+		}
+		return panelsResponsePanelPositionButton;
+	}
+
+	private ZapToggleButton getAboveResponsePanelPositionButton() {
+		if (aboveResponsePanelPositionButton == null) {
+			aboveResponsePanelPositionButton = new ZapToggleButton(
+					new SetResponsePanelPositionAction(
+							WorkbenchPanel.class.getResource("/resource/icon/layout_vertical_split.png"),
+							WorkbenchPanel.ResponsePanelPosition.PANEL_ABOVE));
+			aboveResponsePanelPositionButton.setToolTipText(ABOVE_VIEW_TOOL_TIP);
+			aboveResponsePanelPositionButton.setDisabledToolTipText(DISABLED_ABOVE_VIEW_TOOL_TIP);
+		}
+		return aboveResponsePanelPositionButton;
+	}
+
 	// ZAP: Added footer toolbar panel
 	public MainFooterPanel getMainFooterPanel() {
 		if (mainFooterPanel == null) {
@@ -171,13 +477,168 @@ public class MainFrame extends AbstractFrame {
 		return mainFooterPanel;
 	}
 
+	/**
+	 * @deprecated (TODO add version) Use {@link #setWorkbenchLayout(WorkbenchPanel.Layout)} instead.
+	 */
+	@Deprecated
+	@SuppressWarnings("javadoc")
 	public void changeDisplayOption(int displayOption) {
-		if (this.displayOption != displayOption) {
-			this.displayOption = displayOption;
-			this.getWorkbench().changeDisplayOption(displayOption);
-			this.getMainToolbarPanel().setDisplayOption(displayOption);
-			Model.getSingleton().getOptionsParam().getViewParam().setDisplayOption(displayOption);
+		setWorkbenchLayout(WorkbenchPanel.Layout.getLayout(displayOption));
+	}
+
+	/**
+	 * Applies the view options to the main frame components.
+	 * <p>
+	 * It controls the visibility of the main tool bar, the layout and response panel position of the workbench panel and if the
+	 * tabs should display the panels' names.
+	 * 
+	 * @since TODO add version
+	 * @see #setMainToolbarVisible(boolean)
+	 * @see #setWorkbenchLayout(WorkbenchPanel.Layout)
+	 * @see #setResponsePanelPosition(WorkbenchPanel.ResponsePanelPosition)
+	 * @see #setShowTabNames(boolean)
+	 * @see org.parosproxy.paros.extension.option.OptionsParamView
+	 */
+	public void applyViewOptions() {
+		setMainToolbarVisible(options.getViewParam().isShowMainToolbar());
+
+		setWorkbenchLayout(WorkbenchPanel.Layout.getLayout(options.getViewParam().getDisplayOption()));
+
+		WorkbenchPanel.ResponsePanelPosition position = WorkbenchPanel.ResponsePanelPosition.TABS_SIDE_BY_SIDE;
+		try {
+			position = WorkbenchPanel.ResponsePanelPosition.valueOf(options.getViewParam().getResponsePanelPosition());
+		} catch (IllegalArgumentException e) {
+			LOGGER.warn("Failed to restore the position of response panel: ", e);
+		}
+		setResponsePanelPosition(position);
+
+		setShowTabNames(options.getViewParam().getShowTabNames());
+	}
+
+	/**
+	 * Sets the layout of the workbench panel.
+	 * <p>
+	 * If the layout is already set no further action is taken, otherwise updates the main tool bar buttons, the workbench panel
+	 * and the configurations file.
+	 *
+	 * @param layout the new layout of the workbench panel
+	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @since TODO add version
+	 * @see #getWorkbenchLayout()
+	 * @see #setResponsePanelPosition(WorkbenchPanel.ResponsePanelPosition)
+	 */
+	public void setWorkbenchLayout(WorkbenchPanel.Layout layout) {
+		if (layout == null) {
+			throw new IllegalArgumentException("Parameter layout must not be null.");
 		}
+
+		if (workbenchLayout == layout) {
+			return;
+		}
+
+		workbenchLayout = layout;
+
+		switch (workbenchLayout) {
+		case EXPAND_STATUS:
+			getExpandStatusLayoutButton().setSelected(true);
+			setResponsePanelPositionButtonsEnabled(true);
+			break;
+		case FULL:
+			getFullLayoutButton().setSelected(true);
+			setResponsePanelPositionButtonsEnabled(false);
+			break;
+		case EXPAND_SELECT:
+		default:
+			getExpandSelectLayoutButton().setSelected(true);
+			setResponsePanelPositionButtonsEnabled(true);
+			break;
+		}
+
+		getWorkbench().setWorkbenchLayout(workbenchLayout);
+		options.getViewParam().setDisplayOption(workbenchLayout.getId());
+	}
+
+	/**
+	 * Sets whether or not the buttons that control the response panel position should be enabled.
+	 *
+	 * @param enabled {@code true} if the buttons should be enabled, {@code false} otherwise.
+	 */
+	private void setResponsePanelPositionButtonsEnabled(boolean enabled) {
+		tabsResponsePanelPositionButton.setEnabled(enabled);
+		panelsResponsePanelPositionButton.setEnabled(enabled);
+		aboveResponsePanelPositionButton.setEnabled(enabled);
+	}
+
+	/**
+	 * Gets the workbench layout.
+	 *
+	 * @return the workbench layout, never {@code null}.
+	 * @since TODO add version
+	 * @see #setWorkbenchLayout(WorkbenchPanel.Layout)
+	 */
+	public WorkbenchPanel.Layout getWorkbenchLayout() {
+		return workbenchLayout;
+	}
+
+	/**
+	 * Sets the position of the response panel. Should be considered a hint, not all workbench layouts might use this setting.
+	 * <p>
+	 * If the position is already set no further action is taken, otherwise updates the main tool bar buttons, the workbench
+	 * panel and the configurations file.
+	 *
+	 * @param position the new position of the response panel
+	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @since TODO add version
+	 * @see #getResponsePanelPosition()
+	 * @see #setWorkbenchLayout(org.parosproxy.paros.view.WorkbenchPanel.Layout)
+	 */
+	public void setResponsePanelPosition(WorkbenchPanel.ResponsePanelPosition position) {
+		if (position == null) {
+			throw new IllegalArgumentException("Parameter position must not be null.");
+		}
+
+		if (responsePanelPosition == position) {
+			return;
+		}
+
+		responsePanelPosition = position;
+
+		switch (position) {
+		case PANEL_ABOVE:
+			aboveResponsePanelPositionButton.setSelected(true);
+			break;
+		case PANELS_SIDE_BY_SIDE:
+			panelsResponsePanelPositionButton.setSelected(true);
+			break;
+		case TABS_SIDE_BY_SIDE:
+		default:
+			tabsResponsePanelPositionButton.setSelected(true);
+		}
+
+		getWorkbench().setResponsePanelPosition(responsePanelPosition);
+		options.getViewParam().setResponsePanelPosition(responsePanelPosition.toString());
+	}
+
+	/**
+	 * Gets the response panel position.
+	 *
+	 * @return the response panel position, never {@code null}.
+	 * @since TODO add version
+	 * @see #setResponsePanelPosition(WorkbenchPanel.ResponsePanelPosition)
+	 */
+	public WorkbenchPanel.ResponsePanelPosition getResponsePanelPosition() {
+		return responsePanelPosition;
+	}
+
+	/**
+	 * Sets whether or not the tabs should display the name of the panels.
+	 * 
+	 * @param showTabNames {@code true} if the names should be shown, {@code false} otherwise.
+	 * @since TODO add version
+	 */
+	public void setShowTabNames(boolean showTabNames) {
+		getWorkbench().toggleTabNames(showTabNames);
+		getShowTabIconNamesButton().setSelected(showTabNames);
 	}
 
 	/**
@@ -208,4 +669,51 @@ public class MainFrame extends AbstractFrame {
 	public void setMainToolbarVisible(boolean visible) {
 		getMainToolbarPanel().setVisible(visible);
 	}
+
+	/**
+	 * An {@code Action} that changes the layout of the workbench panels.
+	 * 
+	 * @see MainFrame#setWorkbenchLayout(WorkbenchPanel.Layout)
+	 */
+	private class ChangeWorkbenchLayoutAction extends AbstractAction {
+
+		private static final long serialVersionUID = 8323387638733162321L;
+
+		private final WorkbenchPanel.Layout layout;
+
+		public ChangeWorkbenchLayoutAction(URL iconURL, WorkbenchPanel.Layout layout) {
+			super("", DisplayUtils.getScaledIcon(new ImageIcon(iconURL)));
+
+			this.layout = layout;
+		}
+
+		@Override
+		public void actionPerformed(ActionEvent evt) {
+			setWorkbenchLayout(layout);
+		}
+	}
+
+	/**
+	 * An {@code Action} that changes the position of the response panel.
+	 * 
+	 * @see MainFrame#setResponsePanelPosition(org.parosproxy.paros.view.WorkbenchPanel.ResponsePanelPosition)
+	 */
+	private class SetResponsePanelPositionAction extends AbstractAction {
+
+		private static final long serialVersionUID = 756133292459364854L;
+
+		private final WorkbenchPanel.ResponsePanelPosition position;
+
+		public SetResponsePanelPositionAction(URL iconLocation, WorkbenchPanel.ResponsePanelPosition position) {
+			super("", new ImageIcon(iconLocation));
+
+			this.position = position;
+		}
+
+		@Override
+		public void actionPerformed(ActionEvent e) {
+			setResponsePanelPosition(position);
+		}
+	}
+
 }
diff --git a/src/org/parosproxy/paros/view/TabbedPanel.java b/src/org/parosproxy/paros/view/TabbedPanel.java
index 84d9b1ef2..2bf683a41 100644
--- a/src/org/parosproxy/paros/view/TabbedPanel.java
+++ b/src/org/parosproxy/paros/view/TabbedPanel.java
@@ -23,31 +23,28 @@
 // time in the main window
 // ZAP: 2013/02/26 Issue 540: Maximised work tabs hidden when response tab
 // position changed
+// ZAP: 2016/04/06 Fix layouts' issues
 
 package org.parosproxy.paros.view;
 
-import javax.swing.JOptionPane;
 import javax.swing.JTabbedPane;
 
-import org.apache.commons.configuration.ConfigurationException;
-import org.apache.log4j.Logger;
-import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.model.Model;
+import org.zaproxy.zap.view.ComponentMaximiser;
+import org.zaproxy.zap.view.ComponentMaximiserMouseListener;
 
 public class TabbedPanel extends JTabbedPane {
 
 	private static final long serialVersionUID = 8927990541854169615L;
 
-	private java.awt.Container originalParent = null;
-    private java.awt.Container alternativeParent = null;
-    private java.awt.Component backupChild = null;
-    private Logger log = Logger.getLogger(this.getClass());
+	private ComponentMaximiserMouseListener componentMaximiserML;
     
     /**
 	 * This is the default constructor
 	 */
 	public TabbedPanel() {
 		super();
+		componentMaximiserML = new ComponentMaximiserMouseListener(Model.getSingleton().getOptionsParam().getViewParam());
 		initialize();
 	}
 	/**
@@ -57,64 +54,25 @@ public class TabbedPanel extends JTabbedPane {
 		if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {
 			this.setSize(225, 145);
 		}
-		this.addMouseListener(new java.awt.event.MouseAdapter() { 
-
-			@Override
-			public void mouseClicked(java.awt.event.MouseEvent e) {    
-
-			    if (e.getClickCount() >= 2) {
-			        alternateParent();
-			    }
-
-			}
-		});
+		this.addMouseListener(componentMaximiserML);
 
 	}
 	
 	public void setAlternativeParent(java.awt.Container alternativeParent) {
-	    this.alternativeParent = alternativeParent;
+		ComponentMaximiser maximiser = alternativeParent != null ? new ComponentMaximiser(alternativeParent) : null;
+		componentMaximiserML.setComponentMaximiser(maximiser);
 	}
-	
-	private boolean isAlternative = true;
-	
+
 	public boolean isInAlternativeParent() {
-		return !isAlternative;
+		ComponentMaximiser maximiser= componentMaximiserML.getComponentMaximiser();
+		if (maximiser == null) {
+			return false;
+		}
+		return maximiser.isComponentMaximised();
 	}
 	
 	public void alternateParent() {
-	    if (alternativeParent == null) return;
-
-		if (Model.getSingleton().getOptionsParam().getViewParam().getWarnOnTabDoubleClick()) {
-			if (View.getSingleton().showConfirmDialog(Constant.messages.getString("tab.doubleClick.warning"))  
-					!= JOptionPane.OK_OPTION) {
-				// They cancelled the dialog
-				return;
-			}
-			// Only ever warn once
-			Model.getSingleton().getOptionsParam().getViewParam().setWarnOnTabDoubleClick(false);
-			try {
-				Model.getSingleton().getOptionsParam().getViewParam().getConfig().save();
-			} catch (ConfigurationException e) {
-				log.error(e.getMessage(), e);
-			}
-		}
-	    
-	    if (isAlternative) {
-	        
-	        originalParent = this.getParent();
-	        originalParent.remove(this);
-	        backupChild = alternativeParent.getComponent(0);
-	        alternativeParent.remove(backupChild);
-	        alternativeParent.add(this);
-	    } else {
-	        alternativeParent.remove(this);
-	        alternativeParent.add(backupChild);
-	        originalParent.add(this);
-	    }
-        originalParent.validate();
-        alternativeParent.validate();
-        this.validate();
-	    isAlternative = !isAlternative;
+		componentMaximiserML.triggerMaximisation(this);
 	}
 	
 
diff --git a/src/org/parosproxy/paros/view/View.java b/src/org/parosproxy/paros/view/View.java
index 78bde8013..682a3ab7b 100644
--- a/src/org/parosproxy/paros/view/View.java
+++ b/src/org/parosproxy/paros/view/View.java
@@ -67,6 +67,7 @@
 // ZAP: 2016/03/22 Allow to remove ContextPanelFactory
 // ZAP: 2016/03/23 Issue 2331: Custom Context Panels not show in existing contexts after installation of add-on
 // ZAP: 2016/04/04 Do not require a restart to show/hide the tool bar
+// ZAP: 2016/04/06 Fix layouts' issues
 
 package org.parosproxy.paros.view;
 
@@ -107,6 +108,7 @@ import org.parosproxy.paros.extension.ExtensionPopupMenuItem;
 import org.parosproxy.paros.extension.ViewDelegate;
 import org.parosproxy.paros.extension.option.OptionsParamView;
 import org.parosproxy.paros.model.Model;
+import org.parosproxy.paros.model.OptionsParam;
 import org.parosproxy.paros.model.Session;
 import org.zaproxy.zap.control.AddOn;
 import org.zaproxy.zap.control.AddOn.Status;
@@ -124,13 +126,11 @@ import org.zaproxy.zap.view.ContextListPanel;
 import org.zaproxy.zap.view.ContextPanelFactory;
 import org.zaproxy.zap.view.ContextStructurePanel;
 import org.zaproxy.zap.view.ContextTechnologyPanel;
-import org.zaproxy.zap.view.MessagePanelsPositionController;
 import org.zaproxy.zap.view.SessionExcludeFromProxyPanel;
 import org.zaproxy.zap.view.SessionExcludeFromScanPanel;
 import org.zaproxy.zap.view.SessionExcludeFromSpiderPanel;
 import org.zaproxy.zap.view.SplashScreen;
 import org.zaproxy.zap.view.StatusUI;
-import org.zaproxy.zap.view.TabbedPanel2;
 import org.zaproxy.zap.view.ZapMenuItem;
 import org.zaproxy.zap.view.messagelocation.MessageLocationHighlightRenderersEditors;
 import org.zaproxy.zap.view.messagelocation.TextMessageLocationHighlight;
@@ -139,8 +139,26 @@ import org.zaproxy.zap.view.messagelocation.TextMessageLocationHighlightRenderer
 
 public class View implements ViewDelegate {
 
+    /**
+     * @deprecated (TODO add version) Use {@link WorkbenchPanel.Layout#EXPAND_SELECT} instead.
+     * @see #getMainFrame()
+     * @see MainFrame#setWorkbenchLayout(org.parosproxy.paros.view.WorkbenchPanel.Layout)
+     */
+    @Deprecated
     public static final int DISPLAY_OPTION_LEFT_FULL = 0;
+    /**
+     * @deprecated (TODO add version) Use {@link WorkbenchPanel.Layout#EXPAND_STATUS} instead.
+     * @see #getMainFrame()
+     * @see MainFrame#setWorkbenchLayout(org.parosproxy.paros.view.WorkbenchPanel.Layout)
+     */
+    @Deprecated
     public static final int DISPLAY_OPTION_BOTTOM_FULL = 1;
+    /**
+     * @deprecated (TODO add version) Use {@link WorkbenchPanel.Layout#FULL} instead.
+     * @see #getMainFrame()
+     * @see MainFrame#setWorkbenchLayout(org.parosproxy.paros.view.WorkbenchPanel.Layout)
+     */
+    @Deprecated
     public static final int DISPLAY_OPTION_TOP_FULL = 2;
 
     public static final int DISPLAY_OPTION_ICONNAMES = 0;
@@ -176,12 +194,8 @@ public class View implements ViewDelegate {
      */
     private Map<ContextPanelFactory, List<AbstractContextPropertiesPanel>> contextPanelFactoriesPanels = new HashMap<>();
 
-    private static int displayOption = DISPLAY_OPTION_BOTTOM_FULL;
-
     private static final Logger logger = Logger.getLogger(View.class);
 
-    private MessagePanelsPositionController messagePanelsPositionController;
-
     // ZAP: splash screen
     private SplashScreen splashScreen = null;
 
@@ -209,23 +223,33 @@ public class View implements ViewDelegate {
     //	return responsePanel;
     //}
 
+
     /**
-     * Sets the displayOption.
+     * @deprecated (TODO add version) Use {@link MainFrame#setWorkbenchLayout(org.parosproxy.paros.view.WorkbenchPanel.Layout)}
+     *             instead.
+     * @see #getMainFrame()
      */
+    @Deprecated
+    @SuppressWarnings("javadoc")
     public static void setDisplayOption(int displayOption) {
-        View.displayOption = displayOption;
+        View.getSingleton().getMainFrame().setWorkbenchLayout(WorkbenchPanel.Layout.getLayout(displayOption));
     }
 
     /**
-     * Return the current displayOption.
+     * @deprecated (TODO add version) Use {@link MainFrame#getWorkbenchLayout()} instead.
+     * @see #getMainFrame()
      */
+    @Deprecated
+    @SuppressWarnings("javadoc")
     public static int getDisplayOption() {
-        return View.displayOption;
+        return View.getSingleton().getMainFrame().getWorkbenchLayout().getId();
     }
 
 //  ZAP: Removed method changeDisplayOption(int)
     public void init() {
-        mainFrame = new MainFrame(displayOption);
+        OptionsParam options = Model.getSingleton().getOptionsParam();
+        mainFrame = new MainFrame(options, getRequestPanel(), getResponsePanel());
+        mainFrame.getWorkbench().addPanel(View.getSingleton().getSiteTreePanel(), WorkbenchPanel.PanelType.SELECT);
 
         // Install default editor and renderer for TextMessageLocationHighlight
         MessageLocationHighlightRenderersEditors.getInstance().addEditor(
@@ -234,13 +258,6 @@ public class View implements ViewDelegate {
         MessageLocationHighlightRenderersEditors.getInstance().addRenderer(
                 TextMessageLocationHighlight.class,
                 new TextMessageLocationHighlightRenderer());
-
-        getWorkbench().getTabbedWork().setAlternativeParent(mainFrame.getPaneDisplay());
-        getWorkbench().getTabbedStatus().setAlternativeParent(mainFrame.getPaneDisplay());
-        getWorkbench().getTabbedSelect().setAlternativeParent(mainFrame.getPaneDisplay());
-
-        // adds the Request/Response representation buttons in ZAP toolbar
-        getMessagePanelsPositionController().restoreState();
         
         String statusString;
         for(Status status : AddOn.Status.values()) {     	
@@ -260,18 +277,10 @@ public class View implements ViewDelegate {
         	}
         	statusMap.put(status, new StatusUI(status, statusString));
         }
-
-        setMainToolbarVisible(Model.getSingleton().getOptionsParam().getViewParam().isShowMainToolbar());
     }
 
     public void postInit() {
-      // Note: addTab function calls have been moved to WorkbenchPanel.java because
-        // of the Full Layout support, but this line is still needed for the 'History'
-        // tab to be the currently selected tab; otherwise it's the 'Output' tab.
-        getWorkbench().getTabbedStatus().addTab(getOutputPanel().getName(), getOutputPanel().getIcon(), getOutputPanel());
-
-        // restore the state of Request/Response layout: side by side or above each other.
-        getMessagePanelsPositionController().restoreState();
+        mainFrame.getWorkbench().addPanel(getOutputPanel(), WorkbenchPanel.PanelType.STATUS);
 
         refreshTabViewMenus();
 
@@ -317,19 +326,16 @@ public class View implements ViewDelegate {
     }
 
     /**
-     * Return the MessagePanelsPositionController so other classes can also
-     * restore state of the Request/Response layout.
-     * @return the controller 
+     * @deprecated (TODO add version) No longer in use/working, use
+     *             {@link MainFrame#setResponsePanelPosition(org.parosproxy.paros.view.WorkbenchPanel.ResponsePanelPosition)}
+     *             instead.
+     * @since 2.1.0
+     * @see #getMainFrame()
      */
-    public MessagePanelsPositionController getMessagePanelsPositionController() {
-        if (messagePanelsPositionController == null) {
-            messagePanelsPositionController = new MessagePanelsPositionController(
-                    getRequestPanel(),
-                    getResponsePanel(),
-                    mainFrame,
-                    getWorkbench());
-        }
-        return messagePanelsPositionController;
+    @Deprecated
+    @SuppressWarnings("javadoc")
+    public org.zaproxy.zap.view.MessagePanelsPositionController getMessagePanelsPositionController() {
+        return new org.zaproxy.zap.view.MessagePanelsPositionController(null, null, null, null);
     }
 
     public void refreshTabViewMenus() {
@@ -342,88 +348,54 @@ public class View implements ViewDelegate {
 
         ExtensionKeyboard extKey = (ExtensionKeyboard) Control.getSingleton().getExtensionLoader().getExtension(ExtensionKeyboard.NAME);
 
-        for (Component tab : getWorkbench().getTabbedSelect().getSortedTabList()) {
-            registerMenu(extKey, getWorkbench().getTabbedSelect(), tab);
+        for (AbstractPanel panel : getWorkbench().getSortedPanels(WorkbenchPanel.PanelType.SELECT)) {
+            registerMenu(extKey, panel);
         }
         menuShowTabs.addSeparator();
-        for (Component tab : getWorkbench().getTabbedWork().getSortedTabList()) {
-            registerMenu(extKey, getWorkbench().getTabbedWork(), tab);
+        for (AbstractPanel panel : getWorkbench().getSortedPanels(WorkbenchPanel.PanelType.WORK)) {
+            registerMenu(extKey, panel);
         }
         menuShowTabs.addSeparator();
-        for (Component tab : getWorkbench().getTabbedStatus().getSortedTabList()) {
-            registerMenu(extKey, getWorkbench().getTabbedStatus(), tab);
+        for (AbstractPanel panel : getWorkbench().getSortedPanels(WorkbenchPanel.PanelType.STATUS)) {
+            registerMenu(extKey, panel);
         }
     }
 
-    private void registerMenu(ExtensionKeyboard extKey, final TabbedPanel2 parent, final Component tab) {
-        if (tab instanceof AbstractPanel) {
-            final AbstractPanel ap = (AbstractPanel) tab;
-            ZapMenuItem tabMenu = new ZapMenuItem(
-                    tab.getClass().getName(), MessageFormat.format(Constant.messages.getString("menu.view.tab"), tab.getName()),
-                    ap.getDefaultAccelerator());
-            tabMenu.setMnemonic(ap.getMnemonic());
-            if (ap.getIcon() != null) {
-                tabMenu.setIcon(ap.getIcon());
-            }
-            tabMenu.addActionListener(new ActionListener() {
-                @Override
-                public void actionPerformed(ActionEvent e) {
-                    parent.setVisible(tab, true);
-                    ap.setTabFocus();
-                }
-            });
-
-            menuShowTabs.add(tabMenu);
-            if (extKey != null) {
-                extKey.registerMenuItem(tabMenu);
+    private void registerMenu(ExtensionKeyboard extKey, final AbstractPanel ap) {
+        ZapMenuItem tabMenu = new ZapMenuItem(
+                ap.getClass().getName(), MessageFormat.format(Constant.messages.getString("menu.view.tab"), ap.getName()),
+                ap.getDefaultAccelerator());
+        tabMenu.setMnemonic(ap.getMnemonic());
+        if (ap.getIcon() != null) {
+            tabMenu.setIcon(ap.getIcon());
+        }
+        tabMenu.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                getWorkbench().showPanel(ap);
             }
+        });
 
+        menuShowTabs.add(tabMenu);
+        if (extKey != null) {
+            extKey.registerMenuItem(tabMenu);
         }
     }
 
     public void showAllTabs() {
-        for (Component tab : getWorkbench().getTabbedSelect().getTabList()) {
-            setTabVisible(getWorkbench().getTabbedSelect(), tab, true);
-        }
-        for (Component tab : getWorkbench().getTabbedWork().getTabList()) {
-            setTabVisible(getWorkbench().getTabbedWork(), tab, true);
-        }
-        for (Component tab : getWorkbench().getTabbedStatus().getTabList()) {
-            setTabVisible(getWorkbench().getTabbedStatus(), tab, true);
-        }
+        getWorkbench().setPanelsVisible(true);
     }
 
     public void hideAllTabs() {
-        for (Component tab : getWorkbench().getTabbedSelect().getTabList()) {
-            setTabVisible(getWorkbench().getTabbedSelect(), tab, false);
-        }
-        for (Component tab : getWorkbench().getTabbedWork().getTabList()) {
-            setTabVisible(getWorkbench().getTabbedWork(), tab, false);
-        }
-        for (Component tab : getWorkbench().getTabbedStatus().getTabList()) {
-            setTabVisible(getWorkbench().getTabbedStatus(), tab, false);
-        }
+        getWorkbench().setPanelsVisible(false);
     }
 
     public void pinAllTabs() {
-        getWorkbench().getTabbedSelect().pinVisibleTabs();
-        getWorkbench().getTabbedWork().pinVisibleTabs();
-        getWorkbench().getTabbedStatus().pinVisibleTabs();
+        getWorkbench().pinVisiblePanels();
     }
 
     public void unpinAllTabs() {
-        getWorkbench().getTabbedSelect().unpinTabs();
-        getWorkbench().getTabbedWork().unpinTabs();
-        getWorkbench().getTabbedStatus().unpinTabs();
-    }
-
-    private void setTabVisible(final TabbedPanel2 parent, Component tab, boolean tabVisible) {
-        if (tab instanceof AbstractPanel) {
-            AbstractPanel ap = (AbstractPanel) tab;
-            if (ap.isHideable() && !ap.isPinned()) {
-                parent.setVisible(tab, tabVisible);
-            }
-        }
+        getWorkbench().unpinVisiblePanels();
     }
 
     /**
diff --git a/src/org/parosproxy/paros/view/WorkbenchPanel.java b/src/org/parosproxy/paros/view/WorkbenchPanel.java
index 8e7c9d62c..ac475297d 100644
--- a/src/org/parosproxy/paros/view/WorkbenchPanel.java
+++ b/src/org/parosproxy/paros/view/WorkbenchPanel.java
@@ -31,6 +31,7 @@
 // ZAP: 2014/10/07 Issue 1357: Hide unused tabs
 // ZAP: 2015/02/11 Ensure that a tab is always selected when the layout is switched
 // ZAP: 2015/12/14 Disable request/response tab buttons location when in full layout
+// ZAP: 2016/04/06 Fix layouts' issues
 
 package org.parosproxy.paros.view;
 
@@ -38,10 +39,13 @@ import java.awt.BorderLayout;
 import java.awt.Component;
 import java.awt.Cursor;
 import java.awt.Dimension;
-import java.awt.GridBagConstraints;
-import java.awt.GridBagLayout;
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.SortedSet;
+import java.util.TreeSet;
 import java.util.prefs.BackingStoreException;
 import java.util.prefs.Preferences;
 
@@ -52,268 +56,483 @@ import javax.swing.JTabbedPane;
 
 import org.apache.log4j.Logger;
 import org.parosproxy.paros.extension.AbstractPanel;
+import org.parosproxy.paros.extension.option.OptionsParamView;
+import org.parosproxy.paros.model.Model;
+import org.parosproxy.paros.model.OptionsParam;
+import org.zaproxy.zap.utils.DisplayUtils;
+import org.zaproxy.zap.view.ComponentMaximiser;
+import org.zaproxy.zap.view.ComponentMaximiserMouseListener;
+import org.zaproxy.zap.view.MainToolbarPanel;
 import org.zaproxy.zap.view.TabbedPanel2;
 
+/**
+ * A workbench panel, responsible to show and manage the main panels.
+ *
+ * @since 1.0.0
+ */
 public class WorkbenchPanel extends JPanel {
 
+	/**
+	 * The layouts available to a {@code WorkbenchPanel}.
+	 * 
+	 * @since TODO add version
+	 * @see ResponsePanelPosition
+	 */
+	public enum Layout {
+		/**
+		 * Divides the panel in 3 areas, {@code select}, {@code status} and {@code work}, containing the
+		 * {@link WorkbenchPanel.PanelType#SELECT SELECT}, {@link WorkbenchPanel.PanelType#STATUS STATUS} and
+		 * {@link WorkbenchPanel.PanelType#WORK WORK} panels, respectively. The {@code select} area occupies the left portion of
+		 * the workbench panel while the areas {@code work} and {@code status} occupy the top-right and bottom-right portions of
+		 * the workbench panel, respectively.
+		 * <p>
+		 * All the areas can be resized (using {@code JSplitPane}s) and maximised (using {@link ComponentMaximiser}).
+		 */
+		EXPAND_SELECT(0),
+
+		/**
+		 * The default layout, divides the panel in 3 areas, {@code select}, {@code status} and {@code work}, containing the
+		 * {@link WorkbenchPanel.PanelType#SELECT SELECT}, {@link WorkbenchPanel.PanelType#STATUS STATUS} and
+		 * {@link WorkbenchPanel.PanelType#WORK WORK} panels, respectively. The {@code status} area is located at the bottom of
+		 * the workbench panel while the areas {@code select} and {@code work} are located in the top-left and top-right
+		 * portions of the workbench panel, respectively.
+		 * <p>
+		 * All the areas can be resized (using {@code JSplitPane}s) and maximised (using {@link ComponentMaximiser}).
+		 */
+		EXPAND_STATUS(1),
+
+		/**
+		 * A layout that has only one area that occupies the whole workbench panel and where all panels (
+		 * {@link WorkbenchPanel.PanelType#SELECT SELECT}, {@link WorkbenchPanel.PanelType#STATUS STATUS} and
+		 * {@link WorkbenchPanel.PanelType#WORK WORK}) are shown.
+		 * <p>
+		 * Since it already occupies the whole workbench panel the area can not be resized nor maximised.
+		 */
+		FULL(2);
+
+		/**
+		 * The ID of the layout.
+		 */
+		private final int id;
+
+		private Layout(int id) {
+			this.id = id;
+		}
+
+		/**
+		 * Gets the ID of the layout.
+		 * <p>
+		 * Unique among all layouts, thus suitable for persistence of options.
+		 *
+		 * @return the ID of the layout
+		 * @see #getLayout(int)
+		 */
+		public int getId() {
+			return id;
+		}
+
+		/**
+		 * Gets the {@code Layout} corresponding to the given ID.
+		 *
+		 * @param id the ID of the layout
+		 * @return the {@code Layout} corresponding to the given ID, or {@link #EXPAND_STATUS} if the ID is unknown.
+		 */
+		public static Layout getLayout(int id) {
+			if (id == Layout.EXPAND_SELECT.getId()) {
+				return Layout.EXPAND_SELECT;
+			}
+			if (id == Layout.EXPAND_STATUS.getId()) {
+				return Layout.EXPAND_STATUS;
+			}
+			if (id == Layout.FULL.getId()) {
+				return Layout.FULL;
+			}
+			return Layout.EXPAND_STATUS;
+		}
+	}
+
+	/**
+	 * The position of the response panel, with respect to the request panel.
+	 * <p>
+	 * The position of the response panel can be changed dynamically but might not be used by all layouts, for example, the Full
+	 * Layout.
+	 * 
+	 * @since TODO add version
+	 * @see Layout
+	 */
+	public enum ResponsePanelPosition {
+		/**
+		 * Request and response panels are shown, side-by-side, in the same tabbed panel.
+		 */
+		TABS_SIDE_BY_SIDE,
+
+		/**
+		 * Request panel is shown above the response panel, in different tabbed panels.
+		 */
+		PANEL_ABOVE,
+
+		/**
+		 * Request and response panels are shown, side-by-side, in different tabbed panels.
+		 */
+		PANELS_SIDE_BY_SIDE
+	}
+
+	/**
+	 * The type of panels added to the {@code WorkbenchPanel}, used as hint when doing the layout of the panels.
+	 * <p>
+	 * Panels of the same type might be shown in the same area of the workbench panel. Some layouts, like {@link Layout#FULL},
+	 * might choose to ignore the type of the panels.
+	 * 
+	 * @since TODO add version
+	 */
+	public enum PanelType {
+		/**
+		 * The panels that provide status/data about extensions/components, for example, History panel.
+		 */
+		STATUS,
+
+		/**
+		 * The panels that allow to select/display general data, for example, Sites or Scripts panels.
+		 */
+		SELECT,
+
+		/**
+		 * The panels that allow to display/manipulate common data, for example, Request and Response panels.
+		 */
+		WORK
+	}
+
 	private static final long serialVersionUID = -4610792807151921550L;
 
+	private static final Logger logger = Logger.getLogger(WorkbenchPanel.class);
+
 	private static final String PREF_DIVIDER_LOCATION = "divider.location";
 	private static final String DIVIDER_VERTICAL = "vertical";
 	private static final String DIVIDER_HORIZONTAL = "horizontal";
 
-	private JSplitPane splitVert = null;
-	private JSplitPane splitHoriz = null;
-
-  /* panels used when presenting views */
-	private JPanel paneStatus = null;
-	private JPanel paneSelect = null;
-	private JPanel paneWork = null;
-
-  /* panels for normal view */
-	private TabbedPanel2 tabbedStatus = null;
-	private TabbedPanel2 tabbedWork = null;
-	private TabbedPanel2 tabbedSelect = null;
-  
-  /* panels used when going into 'Full Layout' to remember the old tab positions */
-	private TabbedPanel2 tabbedOldStatus = null;
-	private TabbedPanel2 tabbedOldWork = null;
-	private TabbedPanel2 tabbedOldSelect = null;
-	
-	private int displayOption;
-  private int previousDisplayOption = -1;
-
 	private final Preferences preferences;
 	private final String prefnzPrefix = this.getClass().getSimpleName()+".";
 
-	private final Logger logger = Logger.getLogger(WorkbenchPanel.class);
+	/**
+	 * The request panel, used for positioning the response panel.
+	 * 
+	 * @see #setResponsePanelPosition(ResponsePanelPosition)
+	 */
+	private final AbstractPanel requestPanel;
 
 	/**
-	 * This is the default constructor
+	 * The response panel, moved around depending on the option {@code response panel position}.
+	 * 
+	 * @see #setResponsePanelPosition(ResponsePanelPosition)
 	 */
+	private final AbstractPanel responsePanel;
+
+	/**
+	 * A tabbed panel to show the response panel, when it is shown separately from other panels.
+	 * <p>
+	 * Main purpose is to show the request and response panels at the same time.
+	 * 
+	 * @see #setResponsePanelPosition(ResponsePanelPosition)
+	 */
+	private final TabbedPanel2 responseTabbedPanel;
+
+	/**
+	 * The object to maximise the components when in some layouts.
+	 * <p>
+	 * The components are not maximised in Full Layout, they already occupy the whole workbench panel.
+	 */
+	private final ComponentMaximiser componentMaximiser;
+
+	/**
+	 * The layout of the workbench panel.
+	 * 
+	 * @see #setWorkbenchLayout(Layout)
+	 */
+	private Layout layout;
+
+	/**
+	 * The position of the response panel.
+	 * 
+	 * @see #setResponsePanelPosition(ResponsePanelPosition)
+	 */
+	private ResponsePanelPosition responsePanelPosition;
+
+	/**
+	 * The tabbed panel for {@link PanelType#STATUS STATUS} panels.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getTabbedStatus()
+	 */
+	private TabbedPanel2 tabbedStatus;
+
+	/**
+	 * The {@code JPanel} that has the tabbed panel {@link #tabbedStatus}, represents the {@code status} area.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getPaneStatus()
+	 */
+	private JPanel paneStatus;
+
+	/**
+	 * The tabbed panel for {@link PanelType#SELECT SELECT} panels.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getTabbedSelect()
+	 */
+	private TabbedPanel2 tabbedSelect;
+
+	/**
+	 * The {@code JPanel} that has the tabbed panel {@link #tabbedSelect}, represents the {@code select} area.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getPaneSelect()
+	 */
+	private JPanel paneSelect;
+
+	/**
+	 * The tabbed panel for {@link PanelType#WORK WORK} panels.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getTabbedWork()
+	 */
+	private TabbedPanel2 tabbedWork;
+
+	/**
+	 * The {@code JPanel} that has the tabbed panel {@link #tabbedWork}, represents the {@code work} area.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getPaneWork()
+	 */
+	private JPanel paneWork;
+
+	/**
+	 * The tabbed panel for all {@link PanelType types} of panels, when in {@link Layout#FULL FULL} layout.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getTabbedFull()
+	 */
+	private TabbedPanel2 tabbedFull;
+
+	/**
+	 * The {@code JPanel} that has the tabbed panel {@link #tabbedFull}, that is, the {@link Layout#FULL FULL} layout.
+	 * <p>
+	 * Lazily initialised.
+	 * 
+	 * @see #getFullLayoutPanel()
+	 */
+	private JPanel fullLayoutPanel;
+
+	/**
+	 * Flag that indicates whether or not the tabs should show the panels' names.
+	 * <p>
+	 * When false only the icons are shown, otherwise it is shown the icons and the names.
+	 */
+	private boolean showTabNames;
+
+	/**
+	 * @deprecated (TODO add version) Use
+	 *			 {@link WorkbenchPanel#WorkbenchPanel(OptionsParam, AbstractPanel, AbstractPanel, MainToolbarPanel)} instead.
+	 */
+	@Deprecated
+	@SuppressWarnings("javadoc")
 	public WorkbenchPanel(int displayOption) {
-		super();
+		this(Model.getSingleton().getOptionsParam().getViewParam(),
+			 View.getSingleton().getRequestPanel(),
+			 View.getSingleton().getResponsePanel());
+		changeDisplayOption(displayOption);
+	}
+
+	/**
+	 * Constructs a {@code WorkbenchPanel} with the given options and request and response panels.
+	 * 
+	 * @param viewOptions the options
+	 * @param requestPanel the request panel
+	 * @param responsePanel the response panel
+	 * @throws IllegalArgumentException if any of the parameters is {@code null}.
+	 * @since TODO add version
+	 */
+	public WorkbenchPanel(OptionsParamView viewOptions, AbstractPanel requestPanel, AbstractPanel responsePanel) {
+		super(new BorderLayout());
+
+		validateNotNull(viewOptions, "viewOptions");
+		validateNotNull(requestPanel, "requestPanel");
+		validateNotNull(responsePanel, "responsePanel");
+
+		this.requestPanel = requestPanel;
+		this.responsePanel = responsePanel;
+		this.componentMaximiser = new ComponentMaximiser(this);
+		this.showTabNames = true;
+
+		ComponentMaximiserMouseListener maximiseMouseListener = new ComponentMaximiserMouseListener(
+				viewOptions,
+				componentMaximiser);
+
+		responseTabbedPanel = new TabbedPanel2();
+		responseTabbedPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+		responseTabbedPanel.addMouseListener(maximiseMouseListener);
+
+		getTabbedWork().addMouseListener(maximiseMouseListener);
+		getTabbedStatus().addMouseListener(maximiseMouseListener);
+		getTabbedSelect().addMouseListener(maximiseMouseListener);
+
+		addPanel(requestPanel, PanelType.WORK);
+		addPanel(responsePanel, PanelType.WORK);
+
 		this.preferences = Preferences.userNodeForPackage(getClass());
-		this.displayOption = displayOption;
-		this.previousDisplayOption = displayOption;
-		initialize();
-	}
-
-
-    /*
-     * Minimizes the maximized panels when changing layout to prevent panels not being
-     * displayed correctly.
-     */
-    private void minimizeMaximizedPanels() {
-        // minimize the maximized tab when changing layout: solves the problem of presenting
-        // empty panel when going into 'Full Layout' view when certain tab is maximized
-        if(tabbedSelect != null && tabbedSelect.isInAlternativeParent()) {
-          tabbedSelect.alternateParent();
-        }
-        else if(tabbedStatus != null && tabbedStatus.isInAlternativeParent()) {
-          tabbedStatus.alternateParent();
-        }
-        else if(tabbedWork != null && tabbedWork.isInAlternativeParent()) {
-          tabbedWork.alternateParent();
-        }
-        // special use case for when 'Response' is maximized, which is called only after the 
-        // ZAP has already been started. The restoreOriginalParentTabbedPanel returns the 
-        // TabbedPanel object, which we're discaring because we don't need it.
-        if(this.previousDisplayOption != -1) {
-          View.getSingleton().getMessagePanelsPositionController().restoreOriginalParentTabbedPanel();
-        }
-    }
-
-
-	/**
-	 * This method initializes this
-	 */
-	private void initialize() {
-    // set grid layout for the whole pane: tabbedWork, tabbedSelect and tabbedStatus
-		GridBagConstraints consGridBagConstraints1 = new GridBagConstraints();
-
-		this.setLayout(new GridBagLayout());
-		consGridBagConstraints1.gridx = 0;
-		consGridBagConstraints1.gridy = 0;
-		consGridBagConstraints1.weightx = 1.0;
-		consGridBagConstraints1.weighty = 1.0;
-		consGridBagConstraints1.fill = GridBagConstraints.BOTH;
-
-    View.setDisplayOption(this.displayOption);
-
-    // minimize maximized panels when changing layout
-    minimizeMaximizedPanels();
-
-	switch (displayOption) {
-      case View.DISPLAY_OPTION_LEFT_FULL:
-        this.add(getSplitHoriz(), consGridBagConstraints1);
-        break;
-      case View.DISPLAY_OPTION_TOP_FULL:
-        this.add(getPaneStatus(), consGridBagConstraints1);
-        break;
-      case View.DISPLAY_OPTION_BOTTOM_FULL:
-      default:
-        this.add(getSplitVert(), consGridBagConstraints1);
-        break;
-	}
-
-    /*
-     * Correct the tabs position based on the currently selected layout: if Full Layout 
-     * was invoked: Request/Response/Script Console/Quickstart/Break tabs.
-     */ 
-	switch (displayOption) {
-      case View.DISPLAY_OPTION_TOP_FULL:
-        // save the arrangements of tabs when going into 'Full Layout'
-        if(previousDisplayOption != View.DISPLAY_OPTION_TOP_FULL) {
-          tabbedOldSelect = tabbedSelect;
-          tabbedOldStatus = tabbedStatus;
-          tabbedOldWork   = tabbedWork;
-        }
-        // Tabs in sequence: request, response, output, sites.
-        getTabbedStatus().addTab(View.getSingleton().getRequestPanel().getName(), View.getSingleton().getRequestPanel().getIcon(), View.getSingleton().getRequestPanel());
-        getTabbedStatus().addTab(View.getSingleton().getResponsePanel().getName(), View.getSingleton().getResponsePanel().getIcon(), View.getSingleton().getResponsePanel());
-        getTabbedStatus().addTab(View.getSingleton().getSiteTreePanel().getName(), View.getSingleton().getSiteTreePanel().getIcon(), View.getSingleton().getSiteTreePanel());
-     
-        // go over all tabs that extensions added and move them to tabbedStatus
-        for(Component c: getTabbedWork().getTabList()) {
-            if(c instanceof AbstractPanel) {
-                getTabbedStatus().addTab((AbstractPanel)c);
-            }
-        }
-        for(Component c: getTabbedSelect().getTabList()) {
-            if(c instanceof AbstractPanel) {
-                getTabbedStatus().addTab((AbstractPanel)c);
-            }
-        }
-        View.getSingleton().getMessagePanelsPositionController().setEnabled(false);
-        break;
-      case View.DISPLAY_OPTION_BOTTOM_FULL:
-      case View.DISPLAY_OPTION_LEFT_FULL:
-      default:
-        // we shouldn't check against 'previousDisplayOption == View.DISPLAY_OPTION_TOP_FULL',
-        // because the previousDisplayOption can be null when starting ZAP.
-        if((previousDisplayOption != View.DISPLAY_OPTION_BOTTOM_FULL) || (previousDisplayOption != View.DISPLAY_OPTION_LEFT_FULL)) {
-          // Tabs in sequence: request, response, output, sites.
-          getTabbedWork().addTab(View.getSingleton().getRequestPanel().getName(), View.getSingleton().getRequestPanel().getIcon(), View.getSingleton().getRequestPanel());
-          getTabbedWork().addTab(View.getSingleton().getResponsePanel().getName(), View.getSingleton().getResponsePanel().getIcon(), View.getSingleton().getResponsePanel());
-          getTabbedSelect().addTab(View.getSingleton().getSiteTreePanel().getName(), View.getSingleton().getSiteTreePanel().getIcon(), View.getSingleton().getSiteTreePanel());
-        }
-
-        // parse the tabs correctly when previous display option was 'Full Layout'
-        if(previousDisplayOption == View.DISPLAY_OPTION_TOP_FULL) {
-          for(Component c: getTabbedOldWork().getTabList()) {
-              if(c instanceof AbstractPanel) {
-                  getTabbedWork().addTab((AbstractPanel)c);
-              }
-          }
-          for(Component c: getTabbedOldSelect().getTabList()) {
-              if(c instanceof AbstractPanel) {
-                  getTabbedSelect().addTab((AbstractPanel)c);
-              }
-          }
-        }
-    	// Ensure that a tab is selected
-    	if (getTabbedWork().getSelectedComponent() == null && getTabbedWork().getTabCount() > 0) {
-    		getTabbedWork().setSelectedIndex(0);
-    	}
-    	if (getTabbedSelect().getSelectedComponent() == null && getTabbedSelect().getTabCount() > 0) {
-    		getTabbedSelect().setSelectedIndex(0);
-    	}
-    }
-
-    // Restore state of the MessagePanelsPositionController after changing the layout, so
-    // the Request/Response do not appear as empty panels. This should only happen when
-    // changing the layout when starting ZAP and when not switching to 'Full Layout'.
-    if(this.previousDisplayOption != -1) {
-        boolean nonTopFullOption = this.displayOption != View.DISPLAY_OPTION_TOP_FULL;
-        if (nonTopFullOption) {
-            View.getSingleton().getMessagePanelsPositionController().restoreState();
-        }
-        View.getSingleton().getMessagePanelsPositionController().setEnabled(nonTopFullOption);
-    }
-
-    // save previous display option
-    this.previousDisplayOption = this.displayOption;
+
+		setResponsePanelPosition(ResponsePanelPosition.TABS_SIDE_BY_SIDE);
+		setWorkbenchLayout(Layout.EXPAND_STATUS);
+	}
+
+	/**
+	 * Validates that the given {@code parameter} is not {@code null}, throwing an {@code IllegalArgumentException} if it is.
+	 * <p>
+	 * The given parameter name is used in the exception message to indicate which parameter must not be {@code null}.
+	 *
+	 * @param parameter the parameter to be validated
+	 * @param parameterName the name of the parameter
+	 * @throws IllegalArgumentException if the parameter is {@code null}.
+	 */
+	private static void validateNotNull(Object parameter, String parameterName) {
+		if (parameter == null) {
+			throw new IllegalArgumentException("Parameter " + parameterName + " must not be null");
+		}
 	}
 
+	/**
+	 * @deprecated (TODO add version) Use {@link #setWorkbenchLayout(Layout)} instead.
+	 */
+	@Deprecated
+	@SuppressWarnings("javadoc")
+	public void changeDisplayOption(int option) {
+		setWorkbenchLayout(Layout.getLayout(option));
+	}
+
+	/**
+	 * Gets the layout of the workbench panel.
+	 *
+	 * @return the layout, never {@code null}
+	 * @since TODO add version
+	 */
+	public Layout getWorkbenchLayout() {
+		return layout;
+	}
+
+	/**
+	 * Sets the layout of the workbench panel.
+	 *
+	 * @param layout the layout to set
+	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @since TODO add version
+	 */
+	void setWorkbenchLayout(Layout layout) {
+		validateNotNull(layout, "layout");
+
+		if (this.layout == layout) {
+			return;
+		}
+
+		Layout previousLayout = this.layout;
+		this.layout = layout;
+
+		componentMaximiser.unmaximiseComponent();
+		removeAll();
+
+		List<AbstractPanel> visiblePanels;
+		switch (layout) {
+		case FULL:
+			visiblePanels = getTabbedStatus().getVisiblePanels();
+			visiblePanels.addAll(getTabbedWork().getVisiblePanels());
+			visiblePanels.addAll(getTabbedSelect().getVisiblePanels());
+			getTabbedFull().setVisiblePanels(visiblePanels);
+			this.add(getFullLayoutPanel());
+			break;
+		case EXPAND_SELECT:
+		case EXPAND_STATUS:
+		default:
+			this.add(layout == Layout.EXPAND_STATUS ? createStatusPanelsSplit() : createSelectPanelsSplit());
+
+			if (previousLayout == Layout.FULL) {
+				visiblePanels = getTabbedFull().getVisiblePanels();
+				getTabbedStatus().setVisiblePanels(visiblePanels);
+				getTabbedWork().setVisiblePanels(visiblePanels);
+				getTabbedSelect().setVisiblePanels(visiblePanels);
+
+				setResponsePanelPosition(responsePanelPosition);
+			}
+			break;
+		}
 
-  /**
-   * This method is called whenever we change the layout in preferences or in toolbar.
-   * @param displayOption
-   */
-	public void changeDisplayOption(int displayOption) {
-		this.displayOption = displayOption;
-		this.removeAll();
-		splitVert = null;
-		splitHoriz = null;
-		initialize();
 		this.validate();
 		this.repaint();
 	}
 
-
 	/**
-	 * This method initializes splitVert
-	 * (TOP/BOTTOM (History))
+	 * Creates a split pane between the {@code status} area (bottom component) and {@code work} area or a split between
+	 * {@code work} and {@code select} areas (top component), if the layout is {@link Layout#EXPAND_SELECT EXPAND_SELECT} or
+	 * {@link Layout#EXPAND_STATUS EXPAND_STATUS}, respectively.
 	 * 
-	 * @return JSplitPane
-	 */
-	private JSplitPane getSplitVert() {
-		if (splitVert == null) {
-			splitVert = new JSplitPane();
-
-			splitVert.setDividerLocation(restoreDividerLocation(DIVIDER_VERTICAL, 300));
-			splitVert.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new DividerResizedListener(DIVIDER_VERTICAL));
-
-			splitVert.setDividerSize(3);
-			splitVert.setOrientation(JSplitPane.VERTICAL_SPLIT);
-			splitVert.setResizeWeight(0.5D);
-
-			switch (displayOption) {
-			case View.DISPLAY_OPTION_LEFT_FULL:
-				splitVert.setTopComponent(getPaneWork());
-				break;
-			case View.DISPLAY_OPTION_BOTTOM_FULL:
-			default:
-				splitVert.setTopComponent(getSplitHoriz());
-				break;
-			}
-			splitVert.setBottomComponent(getPaneStatus());
-			splitVert.setContinuousLayout(false);
-			splitVert.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+	 * @return a {@code JSplitPane} between the {@code status} area and other areas
+	 */
+	private JSplitPane createStatusPanelsSplit() {
+		JSplitPane splitVert = new JSplitPane();
+
+		splitVert.setDividerLocation(restoreDividerLocation(DIVIDER_VERTICAL, 300));
+		splitVert.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new DividerResizedListener(DIVIDER_VERTICAL));
+
+		splitVert.setDividerSize(3);
+		splitVert.setOrientation(JSplitPane.VERTICAL_SPLIT);
+		splitVert.setResizeWeight(0.5D);
+
+		switch (layout) {
+		case EXPAND_SELECT:
+			splitVert.setTopComponent(getPaneWork());
+			break;
+		case EXPAND_STATUS:
+		default:
+			splitVert.setTopComponent(createSelectPanelsSplit());
+			break;
 		}
+		splitVert.setBottomComponent(getPaneStatus());
+		splitVert.setContinuousLayout(false);
+		splitVert.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
 		return splitVert;
 	}
 
 	/**
-	 * This method initializes splitHoriz
+	 * Creates a split pane between the {@code select} area (left component) and {@code work} area or a split between
+	 * {@code work} and {@code status} areas (right component), if the layout is {@link Layout#EXPAND_STATUS EXPAND_STATUS} or
+	 * {@link Layout#EXPAND_SELECT EXPAND_SELECT}, respectively.
 	 * 
-	 * Site Panel / Work
-	 * 
-	 * @return JSplitPane
-	 */
-	private JSplitPane getSplitHoriz() {
-		if (splitHoriz == null) {
-			splitHoriz = new JSplitPane();
-			splitHoriz.setLeftComponent(getPaneSelect());
-			switch (displayOption) {
-			case View.DISPLAY_OPTION_LEFT_FULL:
-				splitHoriz.setRightComponent(getSplitVert());
-				break;
-			case View.DISPLAY_OPTION_BOTTOM_FULL:
-			default:
-				splitHoriz.setRightComponent(getPaneWork());
-				break;
-			}
+	 * @return a {@code JSplitPane} between the {@code select} area and other areas
+	 */
+	private JSplitPane createSelectPanelsSplit() {
+		JSplitPane splitHoriz = new JSplitPane();
+		splitHoriz.setLeftComponent(getPaneSelect());
+		switch (layout) {
+		case EXPAND_SELECT:
+			splitHoriz.setRightComponent(createStatusPanelsSplit());
+			break;
+		case EXPAND_STATUS:
+		default:
+			splitHoriz.setRightComponent(getPaneWork());
+			break;
+		}
 
-			splitHoriz.setDividerLocation(restoreDividerLocation(DIVIDER_HORIZONTAL, 300));
-			splitHoriz.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new DividerResizedListener(DIVIDER_HORIZONTAL));
+		splitHoriz.setDividerLocation(restoreDividerLocation(DIVIDER_HORIZONTAL, 300));
+		splitHoriz.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new DividerResizedListener(DIVIDER_HORIZONTAL));
 
-			splitHoriz.setDividerSize(3);
-			splitHoriz.setResizeWeight(0.3D);
-			splitHoriz.setContinuousLayout(false);
-			splitHoriz.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
-		}
+		splitHoriz.setDividerSize(3);
+		splitHoriz.setResizeWeight(0.3D);
+		splitHoriz.setContinuousLayout(false);
+		splitHoriz.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
 		return splitHoriz;
 	}
 
@@ -364,33 +583,49 @@ public class WorkbenchPanel extends JPanel {
 		return paneWork;
 	}
 
-	public void splitPaneWorkWithTabbedPanel(TabbedPanel tabbedPanel, int orientation) {
-		getPaneWork().removeAll();
-
-		JSplitPane split = new JSplitPane(orientation);
-		split.setDividerSize(3);
-		split.setResizeWeight(0.5D);
-		split.setContinuousLayout(false);
-		split.setDoubleBuffered(true);
-		split.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+	private JPanel getFullLayoutPanel() {
+		if (fullLayoutPanel == null) {
+			fullLayoutPanel = new JPanel();
+			fullLayoutPanel.setLayout(new BorderLayout(0, 0));
+			fullLayoutPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+			fullLayoutPanel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
+			fullLayoutPanel.add(getTabbedFull());
+		}
+		return fullLayoutPanel;
+	}
 
-		split.setRightComponent(tabbedPanel);
-		split.setLeftComponent(getTabbedWork());
+	private TabbedPanel2 getTabbedFull() {
+		if (tabbedFull == null) {
+			tabbedFull = new TabbedPanel2();
+			tabbedFull.setName("tabbedFull");
+			tabbedFull.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+		}
+		return tabbedFull;
+	}
 
-		getPaneWork().add(split);
-		getPaneWork().validate();
+	/**
+	 * @deprecated (TODO add version) No longer in use, it does nothing.
+	 */
+	@Deprecated
+	@SuppressWarnings("javadoc")
+	public void splitPaneWorkWithTabbedPanel(TabbedPanel tabbedPanel, int orientation) {
 	}
 	
+	/**
+	 * @deprecated (TODO add version) No longer in use, it does nothing.
+	 */
+	@Deprecated
 	public void removeSplitPaneWork() {
-		getPaneWork().removeAll();
-		getPaneWork().add(getTabbedWork());
-		getPaneWork().validate();
 	}
 
 	/**
-	 * This method initializes tabbedStatus
+	 * Gets the tabbed panel that has the {@link PanelType#STATUS STATUS} panels.
+	 * <p>
+	 * Direct access/manipulation of the tabbed panel is discouraged, the changes done to it might be lost while changing
+	 * layouts.
 	 * 
-	 * @return org.parosproxy.paros.view.ParosTabbedPane
+	 * @return the tabbed panel of the {@code status} panels, never {@code null}
+	 * @see #addPanel(AbstractPanel, PanelType)
 	 */
 	public TabbedPanel2 getTabbedStatus() {
 		if (tabbedStatus == null) {
@@ -404,22 +639,23 @@ public class WorkbenchPanel extends JPanel {
 		return tabbedStatus;
 	}
 
+	/**
+	 * @deprecated (TODO add version) No longer in use, it returns a new {@code TabbedPanel2}.
+	 */
+	@Deprecated
+	@SuppressWarnings("javadoc")
 	public TabbedPanel2 getTabbedOldStatus() {
-		if (tabbedOldStatus == null) {
-			tabbedOldStatus = new TabbedPanel2();
-			tabbedOldStatus.setPreferredSize(new Dimension(800, 200));
-			// ZAP: Move tabs to the top of the panel
-			tabbedOldStatus.setTabPlacement(JTabbedPane.TOP);
-			tabbedOldStatus.setName("tabbedOldStatus");
-			tabbedOldStatus.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
-		}
-		return tabbedOldStatus;
+		return new TabbedPanel2();
 	}
 
 	/**
-	 * This method initializes tabbedWork
+	 * Gets the tabbed panel that has the {@link PanelType#WORK WORK} panels.
+	 * <p>
+	 * Direct access/manipulation of the tabbed panel is discouraged, the changes done to it might be lost while changing
+	 * layouts.
 	 * 
-	 * @return org.parosproxy.paros.view.ParosTabbedPane
+	 * @return the tabbed panel of the {@code work} panels, never {@code null}
+	 * @see #addPanel(AbstractPanel, PanelType)
 	 */
 	public TabbedPanel2 getTabbedWork() {
 		if (tabbedWork == null) {
@@ -431,45 +667,71 @@ public class WorkbenchPanel extends JPanel {
 		return tabbedWork;
 	}
 
+	/**
+	 * @deprecated (TODO add version) No longer in use, it returns a new {@code TabbedPanel2}.
+	 */
+	@Deprecated
+	@SuppressWarnings("javadoc")
 	public TabbedPanel2 getTabbedOldWork() {
-		if (tabbedOldWork == null) {
-			tabbedOldWork = new TabbedPanel2();
-			tabbedOldWork.setPreferredSize(new Dimension(600, 400));
-			tabbedOldWork.setName("tabbedOldWork");
-			tabbedOldWork.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
-		}
-		return tabbedOldWork;
+		return new TabbedPanel2();
 	}
 
-
   /**
-   * Set the old tabbed panels called from ExtensionLoader.java and used with 'Full Layout'.
-   * @param t
+   * @deprecated (TODO add version) No longer in use, it does nothing.
    */
+  @Deprecated
+  @SuppressWarnings("javadoc")
   public void setTabbedOldWork(TabbedPanel2 t) {
-    this.tabbedOldWork = t.clone(t);
   }
+  /**
+   * @deprecated (TODO add version) No longer in use, it does nothing.
+   */
+  @Deprecated
+  @SuppressWarnings("javadoc")
   public void setTabbedOldStatus(TabbedPanel2 t) {
-    this.tabbedOldStatus = t.clone(t);
   }
+  /**
+   * @deprecated (TODO add version) No longer in use, it does nothing.
+   */
+  @Deprecated
+  @SuppressWarnings("javadoc")
   public void setTabbedOldSelect(TabbedPanel2 t) {
-    this.tabbedOldSelect = t.clone(t);
   }
 
+	/**
+	 * Sets whether or not the tabs should display the name of the panels.
+	 * <p>
+	 * The call to this method has not effect if the state is already set.
+	 * 
+	 * @param showTabNames {@code true} if the names should be shown, {@code false} otherwise.
+	 * @since 2.4.0
+	 */
+	public void toggleTabNames(boolean showTabNames) {
+		if (this.showTabNames == showTabNames) {
+			return;
+		}
 
-  /**
-   * Toggle the the tab names when Tools - Options - Display - 'Show tab names' is used.
-   */
-  public void toggleTabNames(boolean showTabNames) {
-    getTabbedStatus().setShowTabNames(showTabNames);
-    getTabbedSelect().setShowTabNames(showTabNames);
-    getTabbedWork().setShowTabNames(showTabNames);
-  }
+		this.showTabNames = showTabNames;
+
+		responseTabbedPanel.setShowTabNames(showTabNames);
+
+		if (layout != Layout.FULL) {
+			getTabbedStatus().setShowTabNames(showTabNames);
+			getTabbedSelect().setShowTabNames(showTabNames);
+			getTabbedWork().setShowTabNames(showTabNames);
+		} else {
+			getTabbedFull().setShowTabNames(showTabNames);
+		}
+	}
 
 	/**
-	 * This method initializes tabbedSelect
+	 * Gets the tabbed panel that has the {@link PanelType#SELECT SELECT} panels.
+	 * <p>
+	 * Direct access/manipulation of the tabbed panel is discouraged, the changes done to it might be lost while changing
+	 * layouts.
 	 * 
-	 * @return org.parosproxy.paros.view.ParosTabbedPane
+	 * @return the tabbed panel of the {@code work} panels, never {@code null}
+	 * @see #addPanel(AbstractPanel, PanelType)
 	 */
 	public TabbedPanel2 getTabbedSelect() {
 		if (tabbedSelect == null) {
@@ -482,15 +744,419 @@ public class WorkbenchPanel extends JPanel {
 		return tabbedSelect;
 	}
 
+	/**
+	 * @deprecated (TODO add version) No longer in use, it returns a new {@code TabbedPanel2}.
+	 */
+	@Deprecated
+	@SuppressWarnings("javadoc")
 	public TabbedPanel2 getTabbedOldSelect() {
-		if (tabbedOldSelect == null) {
-			tabbedOldSelect = new TabbedPanel2();
-			tabbedOldSelect.setPreferredSize(new Dimension(200, 400));
-			tabbedOldSelect.setName("tabbedOldSelect");
-			tabbedOldSelect.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+		return new TabbedPanel2();
+	}
+
+	/**
+	 * Adds the given panels to the workbench, hinting with the given panel type.
+	 *
+	 * @param panels the panels to add to the workbench
+	 * @param panelType the type of the panels
+	 * @throws IllegalArgumentException if any of the parameters is {@code null}.
+	 * @since TODO add version
+	 * @see #removePanels(List, PanelType)
+	 * @see #addPanel(AbstractPanel, PanelType)
+	 */
+	public void addPanels(List<AbstractPanel> panels, PanelType panelType) {
+		validateNotNull(panels, "panels");
+		validateNotNull(panelType, "panelType");
+
+		addPanels(getTabbedFull(), panels);
+
+		switch (panelType) {
+		case SELECT:
+			addPanels(getTabbedSelect(), panels);
+			break;
+		case STATUS:
+			addPanels(getTabbedStatus(), panels);
+			break;
+		case WORK:
+			addPanels(getTabbedWork(), panels);
+			break;
+		default:
+			break;
 		}
 
-		return tabbedOldSelect;
+		if (layout == Layout.FULL) {
+			// Force the panels to be visible, adding to other tabbed panels removes the UI components from full tabbed panel
+			getTabbedFull().setVisiblePanels(getTabbedFull().getVisiblePanels());
+		}
+	}
+
+	/**
+	 * Adds the given {@code panels} to the given {@code tabbedPanel}.
+	 * <p>
+	 * After adding all the panels the tabbed panel is revalidated.
+	 *
+	 * @param tabbedPanel the tabbed panel to add the panels
+	 * @param panels the panels to add
+	 * @see #addPanel(TabbedPanel2, AbstractPanel)
+	 * @see javax.swing.JComponent#revalidate()
+	 */
+	private static void addPanels(TabbedPanel2 tabbedPanel, List<AbstractPanel> panels) {
+		for (AbstractPanel panel : panels) {
+			addPanel(tabbedPanel, panel);
+		}
+		tabbedPanel.revalidate();
+	}
+
+	/**
+	 * Adds the given {@code panel} to the given {@code tabbedPanel}.
+	 *
+	 * @param tabbedPanel the tabbed panel to add the panel
+	 * @param panel the panel to add
+	 * @see #addPanels(TabbedPanel2, List)
+	 */
+	private static void addPanel(TabbedPanel2 tabbedPanel, AbstractPanel panel) {
+		tabbedPanel.addTab(panel);
+	}
+
+	/**
+	 * Adds the given panel to the workbench, hinting with the given panel type.
+	 *
+	 * @param panel the panel to add to the workbench
+	 * @param panelType the type of the panel
+	 * @throws IllegalArgumentException if any of the parameters is {@code null}.
+	 * @since TODO add version
+	 * @see #removePanel(AbstractPanel, PanelType)
+	 * @see #addPanels(List, PanelType)
+	 */
+	public void addPanel(AbstractPanel panel, PanelType panelType) {
+		validateNotNull(panel, "panel");
+		validateNotNull(panelType, "panelType");
+
+		addPanel(getTabbedFull(), panel);
+
+		switch (panelType) {
+		case SELECT:
+			addPanel(getTabbedSelect(), panel);
+			getTabbedSelect().revalidate();
+			break;
+		case STATUS:
+			addPanel(getTabbedStatus(), panel);
+			getTabbedStatus().revalidate();
+			break;
+		case WORK:
+			addPanel(getTabbedWork(), panel);
+			getTabbedWork().revalidate();
+			break;
+		default:
+			break;
+		}
+
+		if (layout == Layout.FULL) {
+			// Force the panels to be visible, adding to other tabbed panels removes the UI components from full tabbed panel
+			getTabbedFull().setVisiblePanels(getTabbedFull().getVisiblePanels());
+		}
+	}
+
+	/**
+	 * Removes the given panels of given panel type from the workbench panel.
+	 *
+	 * @param panels the panels to remove from the workbench panel
+	 * @param panelType the type of the panels
+	 * @throws IllegalArgumentException if any of the parameters is {@code null}.
+	 * @since TODO add version
+	 * @see #addPanels(List, PanelType)
+	 * @see #removePanel(AbstractPanel, PanelType)
+	 */
+	public void removePanels(List<AbstractPanel> panels, PanelType panelType) {
+		validateNotNull(panels, "panels");
+		validateNotNull(panelType, "panelType");
+
+		removePanels(getTabbedFull(), panels);
+
+		switch (panelType) {
+		case SELECT:
+			removePanels(getTabbedSelect(), panels);
+			break;
+		case STATUS:
+			removePanels(getTabbedStatus(), panels);
+			break;
+		case WORK:
+			removePanels(getTabbedWork(), panels);
+			break;
+		default:
+			break;
+		}
+	}
+
+	/**
+	 * Removes the given {@code panels} from the given {@code tabbedPanel}.
+	 * <p>
+	 * After removing all the panels the tabbed panel is revalidated.
+	 *
+	 * @param tabbedPanel the tabbed panel to remove the panels
+	 * @param panels the panels to remove
+	 * @see #addPanel(TabbedPanel2, AbstractPanel)
+	 * @see javax.swing.JComponent#revalidate()
+	 */
+	private static void removePanels(TabbedPanel2 tabbedPanel, List<AbstractPanel> panels) {
+		for (AbstractPanel panel : panels) {
+			removeTabPanel(tabbedPanel, panel);
+		}
+		tabbedPanel.revalidate();
+	}
+
+	/**
+	 * Removes the given {@code panel} from the given {@code tabbedPanel}.
+	 *
+	 * @param tabbedPanel the tabbed panel to remove the panel
+	 * @param panel the panel to remove
+	 * @see #removePanels(TabbedPanel2, List)
+	 */
+	private static void removeTabPanel(TabbedPanel2 tabbedPanel, AbstractPanel panel) {
+		tabbedPanel.removeTab(panel);
+	}
+
+	/**
+	 * Removes the given panel of given panel type from the workbench panel.
+	 *
+	 * @param panel the panel to remove from the workbench panel
+	 * @param panelType the type of the panel
+	 * @throws IllegalArgumentException if any of the parameters is {@code null}.
+	 * @since TODO add version
+	 * @see #addPanel(AbstractPanel, PanelType)
+	 * @see #removePanels(List, PanelType)
+	 */
+	public void removePanel(AbstractPanel panel, PanelType panelType) {
+		validateNotNull(panel, "panel");
+		validateNotNull(panelType, "panelType");
+
+		removeTabPanel(getTabbedFull(), panel);
+		getTabbedFull().revalidate();
+
+		switch (panelType) {
+		case SELECT:
+			removeTabPanel(getTabbedSelect(), panel);
+			getTabbedSelect().revalidate();
+			break;
+		case STATUS:
+			removeTabPanel(getTabbedStatus(), panel);
+			getTabbedStatus().revalidate();
+			break;
+		case WORK:
+			removeTabPanel(getTabbedWork(), panel);
+			getTabbedWork().revalidate();
+			break;
+		default:
+			break;
+		}
+	}
+
+	/**
+	 * Gets the panels that were added to the workbench with the given panel type.
+	 * 
+	 * @param panelType the type of the panel
+	 * @return a {@code List} with the panels of the given type
+	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @since TODO add version
+	 */
+	public List<AbstractPanel> getPanels(PanelType panelType) {
+		validateNotNull(panelType, "panelType");
+
+		List<AbstractPanel> panels = new ArrayList<>();
+		switch (panelType) {
+		case SELECT:
+			panels.addAll(getTabbedSelect().getPanels());
+			break;
+		case STATUS:
+			panels.addAll(getTabbedStatus().getPanels());
+			break;
+		case WORK:
+			panels.addAll(getTabbedWork().getPanels());
+			break;
+		default:
+			break;
+		}
+		return panels;
+	}
+
+	/**
+	 * Gets the panels, sorted by name, that were added to the workbench with the given panel type.
+	 * 
+	 * @param panelType the type of the panel
+	 * @return a {@code List} with the sorted panels of the given type
+	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @since TODO add version
+	 */
+	public SortedSet<AbstractPanel> getSortedPanels(PanelType panelType) {
+		validateNotNull(panelType, "panelType");
+
+		List<AbstractPanel> panels = getPanels(panelType);
+		SortedSet<AbstractPanel> sortedPanels = new TreeSet<>(new Comparator<AbstractPanel>() {
+
+			@Override
+			public int compare(AbstractPanel abstractPanel, AbstractPanel otherAbstractPanel) {
+				String name = abstractPanel.getName();
+				String otherName = otherAbstractPanel.getName();
+				if (name == null) {
+					if (otherName == null) {
+						return 0;
+					}
+					return -1;
+				} else if (otherName == null) {
+					return 1;
+				}
+				return name.compareTo(otherName);
+			}
+		});
+		sortedPanels.addAll(panels);
+		return sortedPanels;
+	}
+
+	/**
+	 * Sets whether or not the panels should be visible.
+	 * <p>
+	 * {@link AbstractPanel#isHideable() Non-hideable} and {@link AbstractPanel#isPinned() pinned} panels are not affected by
+	 * this call, when set to not be visible.
+	 *
+	 * @param visible {@code true} if all panels should be visible, {@code false} otherwise.
+	 * @since TODO add version
+	 */
+	public void setPanelsVisible(boolean visible) {
+		if (layout == Layout.FULL) {
+			getTabbedFull().setPanelsVisible(visible);
+		} else {
+			getTabbedSelect().setPanelsVisible(visible);
+			getTabbedWork().setPanelsVisible(visible);
+			getTabbedStatus().setPanelsVisible(visible);
+		}
+	}
+
+	/**
+	 * Pins all visible panels.
+	 *
+	 * @since TODO add version
+	 * @see #unpinVisiblePanels()
+	 * @see AbstractPanel#setPinned(boolean)
+	 */
+	public void pinVisiblePanels() {
+		if (layout == Layout.FULL) {
+			getTabbedFull().pinVisibleTabs();
+		} else {
+			getTabbedSelect().pinVisibleTabs();
+			getTabbedWork().pinVisibleTabs();
+			getTabbedStatus().pinVisibleTabs();
+		}
+	}
+
+	/**
+	 * Unpins all visible panels.
+	 *
+	 * @since TODO add version
+	 * @see #pinVisiblePanels()
+	 * @see AbstractPanel#setPinned(boolean)
+	 */
+	public void unpinVisiblePanels() {
+		if (layout == Layout.FULL) {
+			getTabbedFull().unpinTabs();
+		} else {
+			getTabbedSelect().unpinTabs();
+			getTabbedWork().unpinTabs();
+			getTabbedStatus().unpinTabs();
+		}
+	}
+
+	/**
+	 * Shows the given panel, if it was previously added.
+	 * <p>
+	 * It does nothing, if the tab is already shown.
+	 *
+	 * @param panel the panel to be shown
+	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @since TODO add version
+	 * @see #addPanel(AbstractPanel, PanelType)
+	 */
+	public void showPanel(AbstractPanel panel) {
+		validateNotNull(panel, "panel");
+
+		if (layout == Layout.FULL) {
+			getTabbedFull().setVisible(panel, true);
+		} else {
+			getTabbedSelect().setVisible(panel, true);
+			getTabbedStatus().setVisible(panel, true);
+			getTabbedWork().setVisible(panel, true);
+		}
+		panel.setTabFocus();
+	}
+
+	/**
+	 * Sets the position of the response panel.
+	 *
+	 * @param position the position of the response panel
+	 * @throws IllegalArgumentException if the given parameter is {@code null}.
+	 * @since TODO add version
+	 */
+	void setResponsePanelPosition(ResponsePanelPosition position) {
+		validateNotNull(position, "position");
+
+		responsePanelPosition = position;
+		if (layout == Layout.FULL) {
+			return;
+		}
+
+		Component currentTabbedPanel = componentMaximiser.getMaximisedComponent();
+		if (componentMaximiser.isComponentMaximised()) {
+			componentMaximiser.unmaximiseComponent();
+		}
+
+		switch (position) {
+		case PANEL_ABOVE:
+			splitResponsePanelWithWorkTabbedPanel(JSplitPane.VERTICAL_SPLIT);
+			break;
+		case PANELS_SIDE_BY_SIDE:
+			splitResponsePanelWithWorkTabbedPanel(JSplitPane.HORIZONTAL_SPLIT);
+			break;
+		case TABS_SIDE_BY_SIDE:
+		default:
+			if (currentTabbedPanel == responseTabbedPanel) {
+				currentTabbedPanel = tabbedWork;
+			}
+			String tabName = showTabNames ? responsePanel.getName() : "";
+			tabbedWork.insertTab(
+					tabName,
+					DisplayUtils.getScaledIcon(responsePanel.getIcon()),
+					responsePanel,
+					null,
+					tabbedWork.indexOfComponent(requestPanel) + 1);
+
+			getPaneWork().removeAll();
+			getPaneWork().add(getTabbedWork());
+			getPaneWork().validate();
+		}
+
+		if (currentTabbedPanel != null) {
+			componentMaximiser.maximiseComponent(currentTabbedPanel);
+		}
+	}
+
+	private void splitResponsePanelWithWorkTabbedPanel(int orientation) {
+		responseTabbedPanel.removeAll();
+
+		String name = showTabNames ? responsePanel.getName() : "";
+		responseTabbedPanel.addTab(name, DisplayUtils.getScaledIcon(responsePanel.getIcon()), responsePanel);
+
+		getPaneWork().removeAll();
+
+		JSplitPane split = new JSplitPane(orientation);
+		split.setDividerSize(3);
+		split.setResizeWeight(0.5D);
+		split.setContinuousLayout(false);
+		split.setDoubleBuffered(true);
+		split.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+
+		split.setRightComponent(responseTabbedPanel);
+		split.setLeftComponent(getTabbedWork());
+
+		getPaneWork().add(split);
+		getPaneWork().validate();
 	}
 	
 	/**
diff --git a/src/org/zaproxy/zap/GuiBootstrap.java b/src/org/zaproxy/zap/GuiBootstrap.java
index 4ea20a53d..cf285a265 100644
--- a/src/org/zaproxy/zap/GuiBootstrap.java
+++ b/src/org/zaproxy/zap/GuiBootstrap.java
@@ -128,8 +128,6 @@ public class GuiBootstrap extends ZapBootstrap {
 
         FontUtils.setDefaultFont(viewParam.getFontName(), viewParam.getFontSize());
 
-        View.setDisplayOption(viewParam.getDisplayOption());
-
         setupLocale(options);
 
         View.getSingleton().showSplashScreen();
diff --git a/src/org/zaproxy/zap/view/ComponentMaximiser.java b/src/org/zaproxy/zap/view/ComponentMaximiser.java
new file mode 100644
index 000000000..9324e96c5
--- /dev/null
+++ b/src/org/zaproxy/zap/view/ComponentMaximiser.java
@@ -0,0 +1,151 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development Team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.view;
+
+import java.awt.Component;
+import java.awt.Container;
+
+/**
+ * A utility class to maximise a (non-direct) child {@code Component} of a {@code Container}.
+ * <p>
+ * Adds the component being maximised directly to the container, making it occupy the whole container. The previous state of the
+ * container is preserved internally by this class, any changes done to the container should be done only after unmaximising the
+ * component.
+ *
+ * @since TODO add version
+ * @see #maximiseComponent(Component)
+ * @see ComponentMaximiserMouseListener
+ */
+public class ComponentMaximiser {
+
+    /**
+     * The container that has the components that can be maximised. Never {@code null}.
+     */
+    private final Container container;
+
+    /**
+     * The child component of the container which holds the (sub-)components that can be maximised, {@code null} when no
+     * component is maximised.
+     */
+    private Component containerChild;
+
+    /**
+     * The parent component of the maximised component, {@code null} when no component is maximised.
+     */
+    private Container parentMaximisedComponent;
+
+    /**
+     * The (currently) maximised component, {@code null} if none.
+     * <p>
+     * A maximised component occupies the whole {@code container}, that is, is the only child component.
+     * 
+     * @see #container
+     * @see #maximiseComponent(Component)
+     * @see #unmaximiseComponent()
+     */
+    private Component maximisedComponent;
+
+    /**
+     * Constructs a {@code ComponentMaximiser} with the given container.
+     *
+     * @param container the container that will be used to maximise components
+     * @throws IllegalArgumentException if the given {@code container} is {@code null}.
+     */
+    public ComponentMaximiser(Container container) {
+        if (container == null) {
+            throw new IllegalArgumentException("Parameter container must not be null.");
+        }
+        this.container = container;
+    }
+
+    /**
+     * Maximises the given component, to occupy the whole container.
+     * <p>
+     * The maximisation is done by adding the component directly to the container. If another component is already maximised it
+     * does nothing.
+     * 
+     * @param component the component to maximise
+     * @throws IllegalArgumentException if the given {@code component} is {@code null}.
+     * @see #unmaximiseComponent()
+     * @see #isComponentMaximised()
+     */
+    public void maximiseComponent(Component component) {
+        if (component == null) {
+            throw new IllegalArgumentException("Parameter component must not be null.");
+        }
+
+        if (maximisedComponent != null) {
+            return;
+        }
+
+        maximisedComponent = component;
+        parentMaximisedComponent = component.getParent();
+        containerChild = container.getComponent(0);
+
+        parentMaximisedComponent.remove(component);
+        container.remove(containerChild);
+        container.add(component);
+
+        container.validate();
+    }
+
+    /**
+     * Unmaximises the current maximised component.
+     * <p>
+     * It does nothing if no component is maximised.
+     *
+     * @see #maximiseComponent(Component)
+     */
+    public void unmaximiseComponent() {
+        if (maximisedComponent == null) {
+            return;
+        }
+
+        container.remove(maximisedComponent);
+        container.add(containerChild);
+        parentMaximisedComponent.add(maximisedComponent);
+        container.validate();
+
+        containerChild = null;
+        parentMaximisedComponent = null;
+        maximisedComponent = null;
+    }
+
+    /**
+     * Tells whether or not there is a maximised component.
+     *
+     * @return {@code true} if there is a maximised component, {@code false} otherwise.
+     * @see #getMaximisedComponent()
+     * @see #maximiseComponent(Component)
+     */
+    public boolean isComponentMaximised() {
+        return maximisedComponent != null;
+    }
+
+    /**
+     * Gets the component that is maximised.
+     *
+     * @return the component maximised, or {@code null} if none
+     * @see #isComponentMaximised()
+     */
+    public Component getMaximisedComponent() {
+        return maximisedComponent;
+    }
+}
diff --git a/src/org/zaproxy/zap/view/ComponentMaximiserMouseListener.java b/src/org/zaproxy/zap/view/ComponentMaximiserMouseListener.java
new file mode 100644
index 000000000..6879c520e
--- /dev/null
+++ b/src/org/zaproxy/zap/view/ComponentMaximiserMouseListener.java
@@ -0,0 +1,173 @@
+/*
+ * Zed Attack Proxy (ZAP) and its related class files.
+ * 
+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.
+ * 
+ * Copyright 2016 The ZAP Development Team
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.zaproxy.zap.view;
+
+import java.awt.Component;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+
+import javax.swing.JOptionPane;
+
+import org.apache.commons.configuration.ConfigurationException;
+import org.apache.log4j.Logger;
+import org.parosproxy.paros.Constant;
+import org.parosproxy.paros.extension.option.OptionsParamView;
+import org.parosproxy.paros.view.View;
+
+/**
+ * A {@code MouseListener} that (un)maximises a component, when clicked twice, using a {@link ComponentMaximiser}.
+ *
+ * @since TODO add version
+ * @see #triggerMaximisation(Component)
+ */
+public class ComponentMaximiserMouseListener extends MouseAdapter {
+
+    private static final Logger LOGGER = Logger.getLogger(ComponentMaximiserMouseListener.class);
+
+    private static final String DOUBLE_CLICK_WARN_MESSAGE = Constant.messages.getString("tab.doubleClick.warning");
+
+    /**
+     * The view options to check (and update) if it's required a confirmation from the user to maximise the component. Never
+     * {@code null}.
+     * 
+     * @see #confirmMaximisation()
+     */
+    private final OptionsParamView viewOptions;
+
+    /**
+     * The delegate used to (un)maximise the component, might be {@code null}.
+     * 
+     * @see #triggerMaximisation(Component)
+     */
+    private ComponentMaximiser componentMaximiser;
+
+    /**
+     * Constructs a {@code ComponentMaximiserMouseListener} with the given view options.
+     * <p>
+     * The view options to check (and update) if it's required a confirmation from the user to maximise the component.
+     *
+     * @param viewOptions the view options
+     * @throws IllegalArgumentException if the parameter {@code viewOptions} is {@code null}.
+     * @see #setComponentMaximiser(ComponentMaximiser)
+     */
+    public ComponentMaximiserMouseListener(OptionsParamView viewOptions) {
+        this(viewOptions, null);
+    }
+
+    /**
+     * Constructs a {@code ComponentMaximiserMouseListener} with the given view options and given component maximiser.
+     * <p>
+     * The view options to check (and update) if it's required a confirmation from the user to maximise the component.
+     *
+     * @param viewOptions the view options
+     * @param componentMaximiser the object responsible for maximising the component, might be {@code null}.
+     * @throws IllegalArgumentException if the parameter {@code viewOptions} is {@code null}.
+     */
+    public ComponentMaximiserMouseListener(OptionsParamView viewOptions, ComponentMaximiser componentMaximiser) {
+        if (viewOptions == null) {
+            throw new IllegalArgumentException("Parameter viewOptions must not be null.");
+        }
+        this.viewOptions = viewOptions;
+        setComponentMaximiser(componentMaximiser);
+    }
+
+    /**
+     * Sets the {@code ComponentMaximiser} that will be used to maximise components. Might be {@code null}, in which case there
+     * will be no maximisation when a component is clicked twice.
+     *
+     * @param componentMaximiser the {@code ComponentMaximiser} that will be used to maximise components
+     * @see #getComponentMaximiser()
+     * @see #triggerMaximisation(Component)
+     */
+    public void setComponentMaximiser(ComponentMaximiser componentMaximiser) {
+        this.componentMaximiser = componentMaximiser;
+    }
+
+    /**
+     * Gets the {@code ComponentMaximiser} that's used to maximise components.
+     *
+     * @return the {@code ComponentMaximiser} that's used to maximise the components, might be {@code null}
+     * @see #setComponentMaximiser(ComponentMaximiser)
+     */
+    public ComponentMaximiser getComponentMaximiser() {
+        return componentMaximiser;
+    }
+
+    /**
+     * Calls {@link #triggerMaximisation(Component)} when clicked twice, with the source of the event as parameter.
+     */
+    @Override
+    public void mouseClicked(MouseEvent evt) {
+        if (evt.getClickCount() == 2) {
+            triggerMaximisation((Component) evt.getSource());
+        }
+    }
+
+    /**
+     * Convenience method that programmatically triggers the (un)maximisation logic.
+     * <p>
+     * If a component is already maximised it's unmaximised, otherwise it is maximised the given {@code component}. This is the
+     * same logic that's executed when a component is clicked twice, being the {@code component} the source of the mouse event.
+     * <p>
+     * The call to this method has no effect if there's no {@code ComponentMaximiser}.
+     * 
+     * @param component the component that will be maximised, if none is maximised already
+     * @throws IllegalArgumentException if the given {@code component} is {@code null} and there's no component maximised.
+     * @see #setComponentMaximiser(ComponentMaximiser)
+     */
+    public void triggerMaximisation(Component component) {
+        if (componentMaximiser == null) {
+            return;
+        }
+
+        if (componentMaximiser.isComponentMaximised()) {
+            componentMaximiser.unmaximiseComponent();
+        } else if (confirmMaximisation()) {
+            componentMaximiser.maximiseComponent(component);
+        }
+    }
+
+    /**
+     * Confirms, by asking the user, if the maximisation should be done.
+     * <p>
+     * After positive confirmation this method returns always {@code true}.
+     *
+     * @return {@code true} if the maximisation should be done, {@code false} otherwise.
+     * @see #triggerMaximisation(Component)
+     * @see OptionsParamView#getWarnOnTabDoubleClick()
+     */
+    private boolean confirmMaximisation() {
+        if (!viewOptions.getWarnOnTabDoubleClick()) {
+            return true;
+        }
+
+        if (View.getSingleton().showConfirmDialog(DOUBLE_CLICK_WARN_MESSAGE) != JOptionPane.OK_OPTION) {
+            return false;
+        }
+
+        viewOptions.setWarnOnTabDoubleClick(false);
+        try {
+            viewOptions.getConfig().save();
+        } catch (ConfigurationException e) {
+            LOGGER.error(e.getMessage(), e);
+        }
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/org/zaproxy/zap/view/MainToolbarPanel.java b/src/org/zaproxy/zap/view/MainToolbarPanel.java
index fd6a31bdb..cad15f666 100644
--- a/src/org/zaproxy/zap/view/MainToolbarPanel.java
+++ b/src/org/zaproxy/zap/view/MainToolbarPanel.java
@@ -23,11 +23,8 @@ package org.zaproxy.zap.view;
 import java.awt.GridBagConstraints;
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
-import java.net.URL;
 
-import javax.swing.AbstractAction;
 import javax.swing.BorderFactory;
-import javax.swing.ButtonGroup;
 import javax.swing.ImageIcon;
 import javax.swing.JButton;
 import javax.swing.JComboBox;
@@ -37,7 +34,6 @@ import javax.swing.JToolBar;
 import javax.swing.SwingUtilities;
 import javax.swing.ToolTipManager;
 
-import org.apache.commons.configuration.ConfigurationException;
 import org.apache.log4j.Logger;
 import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.control.Control;
@@ -62,16 +58,6 @@ public class MainToolbarPanel extends JPanel {
 	private JButton btnSession = null;
 	private JButton btnOptions = null;
 
-	private ButtonGroup expandButtons;
-	private JToggleButton btnExpandSites = null;
-	private JToggleButton btnExpandReports = null;
-	private JToggleButton btnExpandFull = null;
-
-	private boolean showtabiconnames = false;
-  	private ZapToggleButton btnShowTabIconNames = null;
-  	private JButton btnShowAllTabs = null;
-  	private JButton btnHideAllTabs = null;
-
 	public MainToolbarPanel () {
 		super();
 		initialise();
@@ -83,8 +69,6 @@ public class MainToolbarPanel extends JPanel {
 		setMaximumSize(DisplayUtils.getScaledDimension(getMaximumSize().width, 25));
 		this.setBorder(BorderFactory.createEtchedBorder());
 
-		expandButtons = new ButtonGroup();
-
 		GridBagConstraints gridBagConstraints1 = new GridBagConstraints();
 		GridBagConstraints gridBagConstraints2 = new GridBagConstraints();
 
@@ -115,16 +99,6 @@ public class MainToolbarPanel extends JPanel {
 		toolbar.add(getBtnSession());
 		toolbar.add(getBtnOptions());
 		
-		toolbar.addSeparator();
-		toolbar.add(getShowAllTabs());
-		toolbar.add(getHideAllTabs());
-		toolbar.add(getShowTabIconNames());
-		toolbar.addSeparator();
-
-		toolbar.add(getBtnExpandSites());
-		toolbar.add(getBtnExpandReports());
-		toolbar.add(getBtnExpandFull());
-		
 		toolbar.addSeparator();
 	}
 	
@@ -353,119 +327,13 @@ public class MainToolbarPanel extends JPanel {
 		return btnOptions;
 	}
 
-	private JToggleButton getBtnExpandSites() {
-		if (btnExpandSites == null) {
-			btnExpandSites = new JToggleButton(new ChangeDisplayOptionAction(
-					MainToolbarPanel.class.getResource("/resource/icon/expand_sites.png"),
-					View.DISPLAY_OPTION_LEFT_FULL));
-			btnExpandSites.setToolTipText(Constant.messages.getString("view.toolbar.expandSites"));
-			
-			expandButtons.add(btnExpandSites);
-		}
-		return btnExpandSites;
-	}
-
-	private JToggleButton getBtnExpandReports() {
-		if (btnExpandReports == null) {
-			btnExpandReports = new JToggleButton(new ChangeDisplayOptionAction(
-					MainToolbarPanel.class.getResource("/resource/icon/expand_info.png"),
-					View.DISPLAY_OPTION_BOTTOM_FULL));
-			btnExpandReports.setToolTipText(Constant.messages.getString("view.toolbar.expandInfo"));
-
-			expandButtons.add(btnExpandReports);
-		}
-		return btnExpandReports;
-	}
-
-	private JToggleButton getBtnExpandFull() {
-		if (btnExpandFull == null) {
-			btnExpandFull = new JToggleButton(new ChangeDisplayOptionAction(
-					MainToolbarPanel.class.getResource("/resource/icon/expand_full.png"),
-					View.DISPLAY_OPTION_TOP_FULL));
-			btnExpandFull.setToolTipText(Constant.messages.getString("view.toolbar.expandFull"));
-
-			expandButtons.add(btnExpandFull);
-		}
-		return btnExpandFull;
-	}
-
-
-	private void setShowTabIconNames(boolean showtabiconnames) {
-		this.showtabiconnames = showtabiconnames; 
-		btnShowTabIconNames.setSelected(showtabiconnames);
-	}
-
-	/*
-	 * Button for showing/hiding names and icons in tabs.
+	/**
+	 * @deprecated (TODO add version) No longer in use, the tool bar buttons are updated at the same time as the layout.
+	 * @see org.parosproxy.paros.view.MainFrame#setWorkbenchLayout(org.parosproxy.paros.view.WorkbenchPanel.Layout)
 	 */
-	private JToggleButton getShowTabIconNames() {
-		if (btnShowTabIconNames == null) {
-			btnShowTabIconNames = new ZapToggleButton();
-			btnShowTabIconNames.setIcon(new ImageIcon(MainToolbarPanel.class.getResource("/resource/icon/ui_tab_icon.png")));
-			btnShowTabIconNames.setToolTipText(Constant.messages.getString("view.toolbar.showNames"));
-			btnShowTabIconNames.setSelectedIcon(new ImageIcon(MainToolbarPanel.class.getResource("/resource/icon/ui_tab_text.png")));
-			btnShowTabIconNames.setSelectedToolTipText(Constant.messages.getString("view.toolbar.showIcons"));
-		  	setShowTabIconNames(Model.getSingleton().getOptionsParam().getViewParam().getShowTabNames());
-			DisplayUtils.scaleIcon(btnShowTabIconNames);
-
-			btnShowTabIconNames.addActionListener(new java.awt.event.ActionListener() {
-				@Override
-				public void actionPerformed(ActionEvent e) {
-				    setShowTabIconNames(getShowTabIconNames().isSelected());
-					Model.getSingleton().getOptionsParam().getViewParam().setShowTabNames(showtabiconnames);
-					try {
-						Model.getSingleton().getOptionsParam().getViewParam().getConfig().save();
-					} catch (ConfigurationException e1) {
-						logger.error(e1.getMessage(), e1);
-					}
-				}
-			});
-		}
-		return btnShowTabIconNames;
-	}
-	
-	private JButton getShowAllTabs() {
-		if (btnShowAllTabs == null) {
-			btnShowAllTabs = new JButton();
-			btnShowAllTabs.setIcon(new ImageIcon(MainToolbarPanel.class.getResource("/resource/icon/fugue/ui-tab-show.png")));
-			btnShowAllTabs.setToolTipText(Constant.messages.getString("menu.view.tabs.show"));
-			DisplayUtils.scaleIcon(btnShowAllTabs);
-
-			btnShowAllTabs.addActionListener(new java.awt.event.ActionListener() {
-				@Override
-				public void actionPerformed(ActionEvent e) {
-					View.getSingleton().showAllTabs();
-				}
-			});
-		}
-		return btnShowAllTabs;
-	}
-
-	private JButton getHideAllTabs() {
-		if (btnHideAllTabs == null) {
-			btnHideAllTabs = new JButton();
-			btnHideAllTabs.setIcon(new ImageIcon(MainToolbarPanel.class.getResource("/resource/icon/fugue/ui-tab-hide.png")));
-			btnHideAllTabs.setToolTipText(Constant.messages.getString("menu.view.tabs.hide"));
-			DisplayUtils.scaleIcon(btnHideAllTabs);
-			
-			btnHideAllTabs.addActionListener(new java.awt.event.ActionListener() {
-				@Override
-				public void actionPerformed(ActionEvent e) {
-					View.getSingleton().hideAllTabs();
-				}
-			});
-		}
-		return btnHideAllTabs;
-	}
-
+	@Deprecated
+	@SuppressWarnings("javadoc")
 	public void setDisplayOption(int option) {
-		if (option == View.DISPLAY_OPTION_BOTTOM_FULL) {
-			btnExpandReports.setSelected(true);
-    	} else if (option == View.DISPLAY_OPTION_LEFT_FULL) {
-      		btnExpandSites.setSelected(true);
-    	} else if (option == View.DISPLAY_OPTION_TOP_FULL) {
-      		btnExpandFull.setSelected(true);
-    	}
 	}
 
 	public void sessionChanged(Session session) {
@@ -475,29 +343,4 @@ public class MainToolbarPanel extends JPanel {
 		}
 	}
 
-    private static class ChangeDisplayOptionAction extends AbstractAction {
-
-        private static final long serialVersionUID = 8323387638733162321L;
-
-        private final int displayOption;
-
-        public ChangeDisplayOptionAction(URL iconURL, int displayOption) {
-            super("", DisplayUtils.getScaledIcon(new ImageIcon(iconURL)));
-
-            this.displayOption = displayOption;
-        }
-
-        @Override
-        public void actionPerformed(ActionEvent evt) {
-            if (Model.getSingleton().getOptionsParam().getViewParam().getDisplayOption() != displayOption) {
-                View.getSingleton().getMainFrame().changeDisplayOption(displayOption);
-                try {
-                    Model.getSingleton().getOptionsParam().getConfig().save();
-                } catch (ConfigurationException e) {
-                    logger.error(e.getMessage(), e);
-                }
-            }
-        }
-    }
-
 }
diff --git a/src/org/zaproxy/zap/view/MessagePanelsPositionController.java b/src/org/zaproxy/zap/view/MessagePanelsPositionController.java
index d9d5f9fd1..fe7a25d96 100644
--- a/src/org/zaproxy/zap/view/MessagePanelsPositionController.java
+++ b/src/org/zaproxy/zap/view/MessagePanelsPositionController.java
@@ -19,27 +19,17 @@
  */
 package org.zaproxy.zap.view;
 
-import java.awt.event.ActionEvent;
-import java.net.URL;
-
-import javax.swing.AbstractAction;
-import javax.swing.BorderFactory;
-import javax.swing.ButtonGroup;
-import javax.swing.ImageIcon;
-import javax.swing.JSplitPane;
-
-import org.apache.commons.configuration.FileConfiguration;
-import org.parosproxy.paros.Constant;
-import org.parosproxy.paros.extension.option.OptionsParamView;
-import org.parosproxy.paros.model.Model;
 import org.parosproxy.paros.view.MainFrame;
 import org.parosproxy.paros.view.TabbedPanel;
-import org.parosproxy.paros.view.View;
 import org.parosproxy.paros.view.WorkbenchPanel;
 import org.zaproxy.zap.extension.httppanel.HttpPanelRequest;
 import org.zaproxy.zap.extension.httppanel.HttpPanelResponse;
-import org.zaproxy.zap.utils.DisplayUtils;
 
+/**
+ * @deprecated (TODO Add version) No longer used/needed. {@link WorkbenchPanel} now manages the position of the message panels.
+ */
+@Deprecated
+@SuppressWarnings("javadoc")
 public class MessagePanelsPositionController {
 
     private enum MessagePanelsPosition {
@@ -48,220 +38,26 @@ public class MessagePanelsPositionController {
         PANELS_SIDE_BY_SIDE
     }
 
-    private static final String TABS_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.tabs");
-    private static final String DISABLED_TABS_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.tabs.disabled");
-    private static final String ABOVE_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.above");
-    private static final String DISABLED_ABOVE_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.above.disabled");
-    private static final String SIDE_BY_SIDE_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.sideBySide");
-    private static final String DISABLED_SIDE_BY_SIDE_VIEW_TOOL_TIP = Constant.messages.getString("view.toolbar.messagePanelsPosition.sideBySide.disabled");
-
-    private static final String BASE_KEY = OptionsParamView.BASE_VIEW_KEY + ".messagePanelsPosition.";
-
-    private static final String LAST_POSITION_CONFIG_KEY = BASE_KEY + "lastSelectedPosition";
-
-    private HttpPanelRequest requestPanel;
-    private HttpPanelResponse responsePanel;
-
-    private WorkbenchPanel workbenchPanel;
-    private TabbedPanel tabbedWork;
-
-    private ZapToggleButton tabsButtonView;
-    private ZapToggleButton aboveButtonView;
-    private ZapToggleButton sideBySideButtonView;
-
-    private TabbedPanel splitTabbedPanel;
-
-    private MessagePanelsPosition currentPosition;
-
     public MessagePanelsPositionController(
             HttpPanelRequest requestPanel,
             HttpPanelResponse responsePanel,
             MainFrame mainFrame,
             WorkbenchPanel workbenchPanel) {
-        this.requestPanel = requestPanel;
-        this.responsePanel = responsePanel;
-        this.workbenchPanel = workbenchPanel;
-        this.tabbedWork = workbenchPanel.getTabbedWork();
-        this.currentPosition = MessagePanelsPosition.TABS_SIDE_BY_SIDE;
-
-        tabsButtonView = new ZapToggleButton(new ChangeMessagePanelsPositionAction(
-                MessagePanelsPositionController.class.getResource("/resource/icon/layout_tabbed.png"),
-                MessagePanelsPosition.TABS_SIDE_BY_SIDE));
-        tabsButtonView.setToolTipText(TABS_VIEW_TOOL_TIP);
-        tabsButtonView.setDisabledToolTipText(DISABLED_TABS_VIEW_TOOL_TIP);
-
-        aboveButtonView = new ZapToggleButton(new ChangeMessagePanelsPositionAction(
-                MessagePanelsPositionController.class.getResource("/resource/icon/layout_vertical_split.png"),
-                MessagePanelsPosition.PANEL_ABOVE));
-        aboveButtonView.setToolTipText(ABOVE_VIEW_TOOL_TIP);
-        aboveButtonView.setDisabledToolTipText(DISABLED_ABOVE_VIEW_TOOL_TIP);
-
-        sideBySideButtonView = new ZapToggleButton(new ChangeMessagePanelsPositionAction(
-                MessagePanelsPositionController.class.getResource("/resource/icon/layout_horizontal_split.png"),
-                MessagePanelsPosition.PANELS_SIDE_BY_SIDE));
-        sideBySideButtonView.setToolTipText(SIDE_BY_SIDE_VIEW_TOOL_TIP);
-        sideBySideButtonView.setDisabledToolTipText(DISABLED_SIDE_BY_SIDE_VIEW_TOOL_TIP);
-
-        ButtonGroup messageTabsPositionButtonGroup = new ButtonGroup();
-        messageTabsPositionButtonGroup.add(tabsButtonView);
-        messageTabsPositionButtonGroup.add(aboveButtonView);
-        messageTabsPositionButtonGroup.add(sideBySideButtonView);
-
-        tabsButtonView.setSelected(true);
-
-        MainToolbarPanel toolbar = mainFrame.getMainToolbarPanel();
-        
-        toolbar.addButton(tabsButtonView);
-        toolbar.addButton(aboveButtonView);
-        toolbar.addButton(sideBySideButtonView);
-
-        toolbar.addSeparator();
-
-        splitTabbedPanel = new TabbedPanel();
-        splitTabbedPanel.setAlternativeParent(mainFrame.getPaneDisplay());
-        splitTabbedPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
-    }
-
-    /**
-     * Sets whether or not the buttons that control the message panels' position should be enabled.
-     *
-     * @param enabled {@code true} if the buttons should be enabled, {@code false} otherwise.
-     * @since TODO add version
-     */
-    public void setEnabled(boolean enabled) {
-        tabsButtonView.setEnabled(enabled);
-        aboveButtonView.setEnabled(enabled);
-        sideBySideButtonView.setEnabled(enabled);
-    }
-
-    private void changeMessageTabsPosition(MessagePanelsPosition position) {
-        // 29.12.2013 Dejan Lukan: commented out this code, so the function is called when
-        // changing the layout where the Request/Response tab representation stays the same.
-        /*if (currentPosition == position) {
-            return;
-        }*/
-
-        // save the current position, so we can change Request/Response view in 'Full Layout'
-        currentPosition = position;
-        saveState(position);
-
-        // Prevent 'Request' icon from being removed when changing Request/Response tabs
-        // in Full Layout mode.
-        if(View.getDisplayOption() == View.DISPLAY_OPTION_TOP_FULL) {
-            return;
-        }
-
-        TabbedPanel tabbedPanel = restoreOriginalParentTabbedPanel();
-
-        switch (position) {
-        case PANEL_ABOVE:
-            splitResponsePanelWithWorkTabbedPanel(JSplitPane.VERTICAL_SPLIT);
-            break;
-        case PANELS_SIDE_BY_SIDE:
-            splitResponsePanelWithWorkTabbedPanel(JSplitPane.HORIZONTAL_SPLIT);
-            break;
-        case TABS_SIDE_BY_SIDE:
-        default:
-            if (tabbedPanel == splitTabbedPanel) {
-                tabbedPanel = tabbedWork;
-            }
-            boolean showTabNames = Model.getSingleton().getOptionsParam().getViewParam().getShowTabNames();
-            String tabName = responsePanel.getName();
-            if(!showTabNames) {
-                tabName = "";
-            }
-            tabbedWork.insertTab(
-                    tabName,
-                    DisplayUtils.getScaledIcon(responsePanel.getIcon()),
-                    responsePanel,
-                    null,
-                    tabbedWork.indexOfComponent(requestPanel) + 1);
-            workbenchPanel.removeSplitPaneWork();
-        }
-
-        restoreAlternativeParentTabbedPanel(tabbedPanel);
-
-    }
-
-
-    private void splitResponsePanelWithWorkTabbedPanel(int orientation) {
-        splitTabbedPanel.removeAll();
-        boolean showTabNames = Model.getSingleton().getOptionsParam().getViewParam().getShowTabNames(); 
-        if(showTabNames) {
-            splitTabbedPanel.addTab(responsePanel.getName(), DisplayUtils.getScaledIcon(responsePanel.getIcon()), responsePanel);
-        }
-        else {
-            splitTabbedPanel.addTab("", DisplayUtils.getScaledIcon(responsePanel.getIcon()), responsePanel);
-        }
-
-        workbenchPanel.splitPaneWorkWithTabbedPanel(splitTabbedPanel, orientation);
     }
 
     /**
      * Restores the original parent of the panels and the panel.
      */
     public TabbedPanel restoreOriginalParentTabbedPanel() {
-        if (tabbedWork.isInAlternativeParent()) {
-            tabbedWork.alternateParent();
-            return tabbedWork;
-        } else if (splitTabbedPanel.isInAlternativeParent()) {
-            splitTabbedPanel.alternateParent();
-            return splitTabbedPanel;
-        }
         return null;
     }
 
-
-    private void restoreAlternativeParentTabbedPanel(TabbedPanel tabbedPanel) {
-        if (tabbedPanel != null) {
-            tabbedPanel.alternateParent();
-        }
-    }
-
     public void restoreState() {
-        FileConfiguration configuration = Model.getSingleton().getOptionsParam().getConfig();
-
-        MessagePanelsPosition position = MessagePanelsPosition.valueOf(configuration.getString(
-                LAST_POSITION_CONFIG_KEY,
-                MessagePanelsPosition.TABS_SIDE_BY_SIDE.toString()));
-
-        changeMessageTabsPosition(position);
-
-        switch (position) {
-        case PANEL_ABOVE:
-            aboveButtonView.setSelected(true);
-            break;
-        case PANELS_SIDE_BY_SIDE:
-            sideBySideButtonView.setSelected(true);
-            break;
-        case TABS_SIDE_BY_SIDE:
-        default:
-            tabsButtonView.setSelected(true);
-        }
+        // No longer in use.
     }
 
     public void saveState(MessagePanelsPosition currentPosition) {
-        FileConfiguration configuration = Model.getSingleton().getOptionsParam().getConfig();
-
-        configuration.setProperty(LAST_POSITION_CONFIG_KEY, currentPosition.toString());
-    }
-
-    private final class ChangeMessagePanelsPositionAction extends AbstractAction {
-
-        private static final long serialVersionUID = 756133292459364854L;
-
-        private final MessagePanelsPosition position;
-
-        public ChangeMessagePanelsPositionAction(URL iconLocation, MessagePanelsPosition position) {
-            super("", new ImageIcon(iconLocation));
-
-            this.position = position;
-        }
-
-        @Override
-        public void actionPerformed(ActionEvent e) {
-            changeMessageTabsPosition(position);
-        }
+        // No longer in use.
     }
 
 }
diff --git a/src/org/zaproxy/zap/view/TabbedPanel2.java b/src/org/zaproxy/zap/view/TabbedPanel2.java
index cfaa3fb6c..45e6b3c70 100644
--- a/src/org/zaproxy/zap/view/TabbedPanel2.java
+++ b/src/org/zaproxy/zap/view/TabbedPanel2.java
@@ -6,6 +6,7 @@ import java.awt.event.ActionListener;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.List;
 
 import javax.swing.Icon;
@@ -103,13 +104,14 @@ public class TabbedPanel2 extends TabbedPanel {
 	}
 	
 	/**
-     * Returns a clone of the TabbedPanel2 object.
-     * @param tabbedPabel
-   	 */
+	 * @deprecated (TODO add version) The implementation is not correct, not all state is correctly cloned.
+	 */
+	@Deprecated
+	@SuppressWarnings("javadoc")
 	public TabbedPanel2 clone(TabbedPanel2 tabbedPanel) {
 		TabbedPanel2 t = new TabbedPanel2();
-		t.fullTabList = tabbedPanel.fullTabList;
-		t.removedTabList = tabbedPanel.removedTabList;
+		t.fullTabList = new ArrayList<>(tabbedPanel.fullTabList);
+		t.removedTabList = new ArrayList<>(tabbedPanel.removedTabList);
 		return t;
 	}
 	
@@ -197,7 +199,7 @@ public class TabbedPanel2 extends TabbedPanel {
 				if (c instanceof AbstractPanel) {
 					// Dont use the addTab(AbstractPanel) methods as we need to force visibility
 					AbstractPanel panel = (AbstractPanel)c;
-					this.addTab(c.getName(), panel.getIcon(), panel, true, true, panel.getTabIndex());
+					this.addTab(c.getName(), panel.getIcon(), panel, panel.isHideable(), true, panel.getTabIndex());
 				} else {
 					// Work out the index to add it back in
 					int index = this.fullTabList.indexOf(c);
@@ -265,9 +267,16 @@ public class TabbedPanel2 extends TabbedPanel {
 
 		if (! visible) {
 			setVisible(c, false);
+		} else {
+			this.removedTabList.remove(c);
 		}
 
 		handleHiddenTabListTab();
+
+		if ((index == 0 || getTabCount() == 1) && indexOfComponent(c) != -1) {
+			// Its now the first one, give it focus
+			setSelectedComponent(c);
+		}
 	}
 
 	private void handleHiddenTabListTab() {
@@ -349,9 +358,21 @@ public class TabbedPanel2 extends TabbedPanel {
 		}
 	}
 
+	@Override
+	public void removeAll() {
+		super.removeAll();
+
+		removedTabList.clear();
+		removedTabList.addAll(fullTabList);
+
+		handleHiddenTabListTab();
+	}
+
   /**
-   * Toggle tab names to enable/disable tab name: used with Tools - Options - Display -
-   * "Show tab names". 
+   * Sets whether or not the tab names should be shown.
+   * 
+   * @param showTabNames {@code true} if the tab names should be shown, {@code false} otherwise.
+   * @since 2.4.0
    */
   public void setShowTabNames(boolean showTabNames) {
         for (int i = 0; i < getTabCount(); i++) {
@@ -382,9 +403,113 @@ public class TabbedPanel2 extends TabbedPanel {
      * Returns true if the tab is 'active' - ie is being used for anything. 
      * This method always returns false so must be overriden to be changed
      * 
-     * @return
+     * @return {@code true} if the tab is active, {@code false} otherwise
      */
     public boolean isActive() {
     	return false;
     }
+
+    /**
+     * Gets all the {@code AbstractPanel}s.
+     *
+     * @return a {@code List} containing all the panels
+     * @since TODO add version
+     * @see #getVisiblePanels()
+     */
+    public List<AbstractPanel> getPanels() {
+        List<AbstractPanel> panels = new ArrayList<>();
+        for (Component component : fullTabList) {
+            if (component instanceof AbstractPanel) {
+                panels.add((AbstractPanel) component);
+            }
+        }
+        return panels;
+    }
+
+    /**
+     * Gets all the {@code AbstractPanel}s that are currently visible.
+     *
+     * @return a {@code List} containing all the visible panels
+     * @since TODO add version
+     * @see #getPanels()
+     */
+    public List<AbstractPanel> getVisiblePanels() {
+        List<AbstractPanel> panels = getPanels();
+        for (Iterator<AbstractPanel> it = panels.iterator(); it.hasNext();) {
+            if (removedTabList.contains(it.next())) {
+                it.remove();
+            }
+        }
+        return panels;
+    }
+
+    /**
+     * Sets the given {@code panels} as visible, while hiding the remaining panels.
+     * <p>
+     * Any panel that cannot be hidden (per {@link AbstractPanel#isHideable()} and {@link AbstractPanel#isPinned()}) will still
+     * be shown, even if the panel was not in the given {@code panels}, moreover {@code panels} that are not currently added to
+     * this tabbed panel are ignored.
+     *
+     * @param panels the panels that should be visible
+     * @since TODO add version
+     * @see #getVisiblePanels()
+     */
+    public void setVisiblePanels(List<AbstractPanel> panels) {
+        removeAll();
+
+        for (Component component : fullTabList) {
+            if (panels.contains(component)) {
+                setVisible(component, true);
+            } else if (component instanceof AbstractPanel) {
+                AbstractPanel ap = (AbstractPanel) component;
+                if (!canHidePanel(ap)) {
+                    setVisible(component, true);
+                }
+            }
+        }
+
+        if (getSelectedComponent() == null && getTabCount() > 0) {
+            setSelectedIndex(0);
+        }
+    }
+
+    /**
+     * Sets whether or not the panels should be visible.
+     * <p>
+     * {@link AbstractPanel#isHideable() Non-hideable} and {@link AbstractPanel#isPinned() pinned} panels are not affected by
+     * this call, when set to not be visible.
+     *
+     * @param visible {@code true} if all panels should be visible, {@code false} otherwise.
+     * @since TODO add version
+     * @see #getVisiblePanels()
+     */
+    public void setPanelsVisible(boolean visible) {
+        for (Component component : fullTabList) {
+            if (component instanceof AbstractPanel) {
+                AbstractPanel ap = (AbstractPanel) component;
+                boolean canChangeVisibility = true;
+                if (!visible) {
+                    canChangeVisibility = canHidePanel(ap);
+                }
+
+                if (canChangeVisibility) {
+                    setVisible(component, visible);
+                }
+            }
+        }
+    }
+
+    /**
+     * Tells whether or not the given panel can be hidden.
+     * <p>
+     * A panel can be hidden if it is {@link AbstractPanel#isHideable() hideable} and it's not {@link AbstractPanel#isPinned()
+     * pinned}.
+     *
+     * @param panel the panel to be checked
+     * @return {@code true} if the panel can be hidden, {@code false} otherwise
+     */
+    private static boolean canHidePanel(AbstractPanel panel) {
+        return panel.isHideable() && !panel.isPinned();
+    }
+
 }
