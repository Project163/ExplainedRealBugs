diff --git a/src/org/parosproxy/paros/extension/history/ExtensionHistory.java b/src/org/parosproxy/paros/extension/history/ExtensionHistory.java
index 9a22e538d..50e4767c1 100644
--- a/src/org/parosproxy/paros/extension/history/ExtensionHistory.java
+++ b/src/org/parosproxy/paros/extension/history/ExtensionHistory.java
@@ -60,16 +60,17 @@
 // ZAP: 2015/03/03 Added delete(href) method to ensure local map updated 
 // ZAP: 2015/04/02 Issue 321: Support multiple databases and Issue 1582: Low memory option
 // ZAP: 2015/07/16 Issue 1617: ZAP 2.4.0 throws HeadlessExceptions when running in daemon mode on headless machine
+// ZAP: 2015/09/16 Issue 1890: ZAP can't completely scan OWASP Benchmark
 
 package org.parosproxy.paros.extension.history;
 
 import java.awt.EventQueue;
-import java.util.Hashtable;
 import java.util.List;
 
 import javax.swing.ImageIcon;
 import javax.swing.JOptionPane;
 
+import org.apache.commons.collections.map.ReferenceMap;
 import org.apache.log4j.Logger;
 import org.parosproxy.paros.Constant;
 import org.parosproxy.paros.control.Control.Mode;
@@ -130,7 +131,7 @@ public class ExtensionHistory extends ExtensionAdaptor implements SessionChanged
 	private String linkWithSitesTreeBaseUri;
 	
 	// Used to cache hrefs not added into the historyList
-	private Hashtable<Integer, HistoryReference> historyIdToRef = new Hashtable<>();
+	private ReferenceMap historyIdToRef = new ReferenceMap();
 
     
 	private Logger logger = Logger.getLogger(ExtensionHistory.class);
@@ -283,11 +284,13 @@ public class ExtensionHistory extends ExtensionAdaptor implements SessionChanged
 		if (href != null) {
 			return href;
 		}
-		href = historyIdToRef.get(historyId);
+		href = (HistoryReference) historyIdToRef.get(historyId);
 		if (href == null) {		
 			try {
 				href = new HistoryReference(historyId);
-				addToMap(href);
+				if (href.getHistoryType() != HistoryReference.TYPE_SCANNER_TEMPORARY) {
+					addToMap(href);
+				}
 			} catch (Exception e) {
 				return null;
 			}
diff --git a/src/org/zaproxy/zap/extension/anticsrf/AntiCsrfToken.java b/src/org/zaproxy/zap/extension/anticsrf/AntiCsrfToken.java
index bee2c59e2..e58cd9f9d 100644
--- a/src/org/zaproxy/zap/extension/anticsrf/AntiCsrfToken.java
+++ b/src/org/zaproxy/zap/extension/anticsrf/AntiCsrfToken.java
@@ -19,29 +19,99 @@
  */
 package org.zaproxy.zap.extension.anticsrf;
 
+import java.lang.ref.SoftReference;
+
+import org.apache.log4j.Logger;
+import org.parosproxy.paros.db.DatabaseException;
+import org.parosproxy.paros.network.HttpMalformedHeaderException;
 import org.parosproxy.paros.network.HttpMessage;
+import org.zaproxy.zap.extension.anticsrf.ExtensionAntiCSRF.HistoryReferenceFactory;
 
 public class AntiCsrfToken implements Cloneable {
 
+	private static final Logger LOGGER = Logger.getLogger(AntiCsrfToken.class);
+
 	private HttpMessage msg; 
+	private SoftReference<HttpMessage> msgReference;
+	private int historyReferenceId;
 	private String name;
 	private String value;
 	private String targetURL;
 	private int formIndex;
+
+	private static HistoryReferenceFactory historyReferenceFactory;
+
+	static void setHistoryReferenceFactory(HistoryReferenceFactory historyReferenceFactory) {
+		AntiCsrfToken.historyReferenceFactory = historyReferenceFactory;
+	}
 	
 	public AntiCsrfToken(HttpMessage msg, String name, String value, int formIndex) {
+		this(msg, null, -1, name, value, formIndex);
+	}
+
+	private AntiCsrfToken(
+			HttpMessage msg,
+			SoftReference<HttpMessage> msgReference,
+			int historyReferenceId,
+			String name,
+			String value,
+			int formIndex) {
 		super();
 		this.msg = msg;
+		this.msgReference = msgReference;
+		this.historyReferenceId = historyReferenceId;
 		this.name = name;
 		this.value = value;
+		this.formIndex = formIndex;
 	}
-	
+
 	public HttpMessage getMsg() {
-		return msg;
+		if (msg != null) {
+			return msg;
+		}
+
+		if (msgReference != null) {
+			HttpMessage msg = msgReference.get();
+			if (msg != null) {
+				return msg;
+			}
+			msgReference.clear();
+			msgReference = null;
+		}
+
+		if (historyReferenceId == -1) {
+			return null;
+		}
+
+		try {
+			HttpMessage msg = historyReferenceFactory.createHistoryReference(historyReferenceId).getHttpMessage();
+			msgReference = new SoftReference<>(msg);
+			return msg;
+		} catch (HttpMalformedHeaderException | DatabaseException e) {
+			LOGGER.error("Failed to load the persisted message: ", e);
+		}
+		return null;
 	}
+
 	public void setMsg(HttpMessage msg) {
 		this.msg = msg;
+
+		if (msgReference != null) {
+			msgReference.clear();
+			msgReference = null;
+		}
+		historyReferenceId = -1;
 	}
+
+	void setHistoryReferenceId(int historyReferenceId) {
+		if (historyReferenceId < 0) {
+			throw new IllegalArgumentException("Parameter historyReferenceId must be equal or greater than zero.");
+		}
+
+		setMsg(null);
+		this.historyReferenceId = historyReferenceId;
+	}
+	
 	public String getName() {
 		return name;
 	}
@@ -73,7 +143,7 @@ public class AntiCsrfToken implements Cloneable {
 
 	@Override	
 	public AntiCsrfToken clone () {
-		return new AntiCsrfToken(msg, name, value, formIndex);
+		return new AntiCsrfToken(msg, msgReference, historyReferenceId, name, value, formIndex);
 	}
 	
 }
diff --git a/src/org/zaproxy/zap/extension/anticsrf/ExtensionAntiCSRF.java b/src/org/zaproxy/zap/extension/anticsrf/ExtensionAntiCSRF.java
index 8df10ba81..0bf41053b 100644
--- a/src/org/zaproxy/zap/extension/anticsrf/ExtensionAntiCSRF.java
+++ b/src/org/zaproxy/zap/extension/anticsrf/ExtensionAntiCSRF.java
@@ -63,7 +63,6 @@ public class ExtensionAntiCSRF extends ExtensionAdaptor implements SessionChange
 	public static final String TAG = "AntiCSRF"; 
 	
 	private Map<String, AntiCsrfToken> valueToToken = new HashMap<>();
-	private Map<String, AntiCsrfToken> urlToToken = new HashMap<>();
 	
 	private OptionsAntiCsrfPanel optionsAntiCsrfPanel = null;
 	private PopupMenuGenerateForm popupMenuGenerateForm = null;
@@ -115,6 +114,7 @@ public class ExtensionAntiCSRF extends ExtensionAdaptor implements SessionChange
 				}
 			};
 		}
+		AntiCsrfToken.setHistoryReferenceFactory(historyReferenceFactory);
 
 	    extensionHook.addSessionListener(this);
 
@@ -182,9 +182,19 @@ public class ExtensionAntiCSRF extends ExtensionAdaptor implements SessionChange
 	public void registerAntiCsrfToken(AntiCsrfToken token) {
 		log.debug("registerAntiCsrfToken " + token.getMsg().getRequestHeader().getURI().toString() + " " + token.getValue());
 		synchronized (valueToToken) {
-			valueToToken.put(encoder.getURLEncode(token.getValue()), token);
+			try {
+				HistoryReference hRef = token.getMsg().getHistoryRef();
+				if (hRef == null) {
+					hRef = new HistoryReference(getModel().getSession(), HistoryReference.TYPE_TEMPORARY, token.getMsg());
+					token.getMsg().setHistoryRef(null);
+				}
+
+				token.setHistoryReferenceId(hRef.getHistoryId());
+				valueToToken.put(encoder.getURLEncode(token.getValue()), token);
+			} catch (HttpMalformedHeaderException | DatabaseException e) {
+				log.error("Failed to persist the message: ", e);
+			}
 		}
-		urlToToken.put(token.getMsg().getRequestHeader().getURI().toString(), token);
 	}
 
 	public boolean requestHasToken(HttpMessage msg) {
@@ -316,7 +326,6 @@ public class ExtensionAntiCSRF extends ExtensionAdaptor implements SessionChange
 		synchronized (valueToToken) {
 			valueToToken = new HashMap<>();
 		}
-		urlToToken = new HashMap<>();
 		// search for tokens...
         try {
 			List<Integer> list = getModel().getDb().getTableHistory().getHistoryIdsOfHistType(
@@ -431,7 +440,7 @@ public class ExtensionAntiCSRF extends ExtensionAdaptor implements SessionChange
 		return null;
 	}
 
-	private static interface HistoryReferenceFactory {
+	static interface HistoryReferenceFactory {
 
 		HistoryReference createHistoryReference(int id) throws DatabaseException, HttpMalformedHeaderException;
 
