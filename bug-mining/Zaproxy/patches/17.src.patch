diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index 645cdd207..8203d4028 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -1620,6 +1620,8 @@ sites.spider.popup         = Spider...
 sites.showinsites.popup    = Show in Sites tab
 
 spider.activeActionPrefix = Spidering: {0}
+spider.api.action.scan = Runs the spider against the given URL. Optionally, the 'maxChildren' parameter can be set to limit the number of children scanned, and the 'recurse' parameter can be used to prevent the spider from seeding recursively.
+spider.api.action.scanAsUser = Runs the spider from the perspective of a User, obtained using the given Context ID and User ID. See 'scan' action for more details.
 spider.api.view.optionSendRefererHeader = Sets whether or not the 'Referer' header should be sent while spidering
 spider.custom.button.reset	= Reset
 spider.custom.button.scan	= Start Scan
diff --git a/src/org/zaproxy/zap/extension/spider/SpiderAPI.java b/src/org/zaproxy/zap/extension/spider/SpiderAPI.java
index 06575f703..93a0214a5 100644
--- a/src/org/zaproxy/zap/extension/spider/SpiderAPI.java
+++ b/src/org/zaproxy/zap/extension/spider/SpiderAPI.java
@@ -92,6 +92,7 @@ public class SpiderAPI extends ApiImplementor {
 	private static final String PARAM_USER_ID = "userId";
 	private static final String PARAM_CONTEXT_ID = "contextId";
 	private static final String PARAM_REGEX = "regex";
+	private static final String PARAM_RECURSE = "recurse";
 	private static final String PARAM_SCAN_ID = "scanId";
 	private static final String PARAM_MAX_CHILDREN = "maxChildren";
 
@@ -112,9 +113,10 @@ public class SpiderAPI extends ApiImplementor {
 		this.extension = extension;
 		// Register the actions
 		this.addApiAction(new ApiAction(ACTION_START_SCAN, new String[] { PARAM_URL },
-				new String[] { PARAM_MAX_CHILDREN }));
+				new String[] { PARAM_MAX_CHILDREN, PARAM_RECURSE }));
 		this.addApiAction(new ApiAction(ACTION_START_SCAN_AS_USER, 
-				new String[] { PARAM_URL, PARAM_CONTEXT_ID, PARAM_USER_ID, PARAM_MAX_CHILDREN }));
+				new String[] { PARAM_URL, PARAM_CONTEXT_ID, PARAM_USER_ID },
+				new String[] { PARAM_MAX_CHILDREN, PARAM_RECURSE }));
 		this.addApiAction(new ApiAction(ACTION_PAUSE_SCAN, new String[] { PARAM_SCAN_ID }));
 		this.addApiAction(new ApiAction(ACTION_RESUME_SCAN, new String[] { PARAM_SCAN_ID }));
 		this.addApiAction(new ApiAction(ACTION_STOP_SCAN, null, new String[] { PARAM_SCAN_ID }));
@@ -160,7 +162,7 @@ public class SpiderAPI extends ApiImplementor {
 					}
 				}
 			}
-			int scanId = scanURL(url, null, maxChildren);
+			int scanId = scanURL(url, null, maxChildren, this.getParam(params, PARAM_RECURSE, true));
 			return new ApiResponseElement(name, Integer.toString(scanId));
 
 		case ACTION_START_SCAN_AS_USER:
@@ -190,7 +192,7 @@ public class SpiderAPI extends ApiImplementor {
 					}
 				}
 			}
-			scanId = scanURL(urlUserScan, user, maxChildren);
+			scanId = scanURL(urlUserScan, user, maxChildren, this.getParam(params, PARAM_RECURSE, true));
 
 			return new ApiResponseElement(name, Integer.toString(scanId));
 
@@ -292,12 +294,14 @@ public class SpiderAPI extends ApiImplementor {
 	 * 
 	 * @param url the url to start the spider scan
 	 * @param user the user to scan as, or null if the scan is done without the perspective of any user
+	 * @param maxChildren Max number of children to scan
+	 * @param recurse Whether or not to scan recursively
 	 * @return the ID of the newly started scan
 	 * @throws ApiException if the {@code url} is not valid
 	 * @see #scanIdCounter
 	 * @see #spiderScans
 	 */
-	private int scanURL(String url, User user, int maxChildren) throws ApiException {
+	private int scanURL(String url, User user, int maxChildren, boolean recurse) throws ApiException {
 		log.debug("API Spider scanning url: " + url);
 
 		URI startURI;
@@ -319,7 +323,7 @@ public class SpiderAPI extends ApiImplementor {
 			throw new ApiException(ApiException.Type.INTERNAL_ERROR);
 		}
 		Target target = new Target(node);
-		target.setRecurse(true);
+		target.setRecurse(recurse);
 		
 		List<Object> objs = new ArrayList<>(maxChildren > 0 ? 3 : 1);
 		objs.add(startURI);
