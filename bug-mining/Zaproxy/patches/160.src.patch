diff --git a/src/lang/Messages.properties b/src/lang/Messages.properties
index 87eb84f15..b82ee6fb4 100644
--- a/src/lang/Messages.properties
+++ b/src/lang/Messages.properties
@@ -918,6 +918,12 @@ core.api.action.sendRequest = Sends the HTTP request, optionally following redir
 core.api.action.setMode = Sets the mode, which may be one of [safe, protect, standard, attack]
 core.api.action.setOptionDnsTtlSuccessfulQueries = Sets the TTL (in seconds) of successful DNS queries (applies after ZAP restart).
 core.api.action.shutdown = Shuts down ZAP
+core.api.action.addProxyChainExcludedDomain = Adds a domain to be excluded from the outgoing proxy, using the specified value. Optionally sets if the new entry is enabled (default, true) and whether or not the new value is specified as a regex (default, false).
+core.api.action.modifyProxyChainExcludedDomain = Modifies a domain excluded from the outgoing proxy. Allows to modify the value, if enabled or if a regex. The domain is selected with its index, which can be obtained with the view proxyChainExcludedDomains.
+core.api.action.removeProxyChainExcludedDomain = Removes a domain excluded from the outgoing proxy, with the given index. The index can be obtained with the view proxyChainExcludedDomains.
+core.api.action.enableAllProxyChainExcludedDomains = Enables all domains excluded from the outgoing proxy.
+core.api.action.disableAllProxyChainExcludedDomains = Disables all domains excluded from the outgoing proxy.
+core.api.action.setOptionProxyChainSkipName = Use actions [add|modify|remove]ProxyChainExcludedDomain instead.
 core.api.other.messagesHar = Gets the HTTP messages sent through/by ZAP, in HAR format, optionally filtered by URL and paginated with 'start' position and 'count' of messages
 core.api.other.sendHarRequest = Sends the first HAR request entry, optionally following redirections. Returns, in HAR format, the request sent and response received and followed redirections, if any. The Mode is enforced when sending the request (and following redirections), custom manual requests are not allowed in 'Safe' mode nor in 'Protected' mode if out of scope.
 core.api.other.htmlreport = Generates a report in HTML format
@@ -936,6 +942,10 @@ core.api.view.messages = Gets the HTTP messages sent by ZAP, request and respons
 core.api.view.mode = Gets the mode
 core.api.view.numberOfMessages = Gets the number of messages, optionally filtering by URL
 core.api.view.optionDnsTtlSuccessfulQueries = Gets the TTL (in seconds) of successful DNS queries.
+core.api.view.optionProxyChainSkipName = Use view proxyChainExcludedDomains instead.
+core.api.view.optionProxyExcludedDomains = Use view proxyChainExcludedDomains instead.
+core.api.view.optionProxyExcludedDomainsEnabled = Use view proxyChainExcludedDomains instead.
+core.api.view.proxyChainExcludedDomains = Gets all the domains that are excluded from the outgoing proxy. For each domain the following are shown: the index, the value (domain), if enabled, and if specified as a regex.
 core.api.view.version = Gets ZAP version
 core.api.view.excludedFromProxy = Gets the regular expressions, applied to URLs, to exclude from the Proxy
 core.api.view.stats = Gets the global stats
diff --git a/src/org/parosproxy/paros/network/ConnectionParam.java b/src/org/parosproxy/paros/network/ConnectionParam.java
index 00e177cfc..90795f67c 100644
--- a/src/org/parosproxy/paros/network/ConnectionParam.java
+++ b/src/org/parosproxy/paros/network/ConnectionParam.java
@@ -35,6 +35,7 @@
 // ZAP: 2014/03/23 Issue 1100: Annotate option methods that shouldn't be exposed in the ZAP API
 // ZAP: 2041/08/14 Issue 1305: Outgoing proxy is disabled when updating from old versions
 // ZAP: 2016/08/08 Issue 2742: Allow for override/customization of Java's "networkaddress.cache.ttl" value
+// ZAP: 2017/01/11 Exclude some options from the API (manually handled to return correct values).
 
 package org.parosproxy.paros.network;
 
@@ -368,6 +369,7 @@ public class ConnectionParam extends AbstractParam {
 	 *             <strong>Note:</strong> Newer regular expression excluded domains will not be returned by this method.
 	 */
 	@Deprecated
+	@ZapApiIgnore
 	@SuppressWarnings({ "javadoc" })
 	public String getProxyChainSkipName() {
 		StringBuilder skipNamesStringBuilder = new StringBuilder("");
@@ -555,6 +557,7 @@ public class ConnectionParam extends AbstractParam {
      * @see #getProxyExcludedDomainsEnabled()
      * @see #setProxyExcludedDomains(List)
      */
+    @ZapApiIgnore
     public List<ProxyExcludedDomainMatcher> getProxyExcludedDomains() {
         return proxyExcludedDomains;
     }
@@ -568,6 +571,7 @@ public class ConnectionParam extends AbstractParam {
      * @see #getProxyExcludedDomains()
      * @see #setProxyExcludedDomains(List)
      */
+    @ZapApiIgnore
     public List<ProxyExcludedDomainMatcher> getProxyExcludedDomainsEnabled() {
         return proxyExcludedDomainsEnabled;
     }
diff --git a/src/org/zaproxy/zap/extension/api/CoreAPI.java b/src/org/zaproxy/zap/extension/api/CoreAPI.java
index 4754e04f7..fc88a6054 100644
--- a/src/org/zaproxy/zap/extension/api/CoreAPI.java
+++ b/src/org/zaproxy/zap/extension/api/CoreAPI.java
@@ -65,12 +65,14 @@ import org.parosproxy.paros.model.Session;
 import org.parosproxy.paros.model.SessionListener;
 import org.parosproxy.paros.model.SiteMap;
 import org.parosproxy.paros.model.SiteNode;
+import org.parosproxy.paros.network.ConnectionParam;
 import org.parosproxy.paros.network.HttpHeader;
 import org.parosproxy.paros.network.HttpMalformedHeaderException;
 import org.parosproxy.paros.network.HttpMessage;
 import org.parosproxy.paros.network.HttpRequestHeader;
 import org.parosproxy.paros.network.HttpResponseHeader;
 import org.parosproxy.paros.network.HttpSender;
+import org.parosproxy.paros.network.ProxyExcludedDomainMatcher;
 import org.parosproxy.paros.view.View;
 import org.zaproxy.zap.extension.alert.ExtensionAlert;
 import org.zaproxy.zap.extension.dynssl.ExtensionDynSSL;
@@ -107,6 +109,11 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 	private static final String ACTION_COLLECT_GARBAGE = "runGarbageCollection";
 	private static final String ACTION_SET_MODE = "setMode";
 	private static final String ACTION_DELETE_SITE_NODE = "deleteSiteNode";
+	private static final String ACTION_ADD_PROXY_CHAIN_EXCLUDED_DOMAIN = "addProxyChainExcludedDomain";
+	private static final String ACTION_MODIFY_PROXY_CHAIN_EXCLUDED_DOMAIN = "modifyProxyChainExcludedDomain";
+	private static final String ACTION_REMOVE_PROXY_CHAIN_EXCLUDED_DOMAIN = "removeProxyChainExcludedDomain";
+	private static final String ACTION_ENABLE_ALL_PROXY_CHAIN_EXCLUDED_DOMAINS = "enableAllProxyChainExcludedDomains";
+	private static final String ACTION_DISABLE_ALL_PROXY_CHAIN_EXCLUDED_DOMAINS = "disableAllProxyChainExcludedDomains";
 	
 	private static final String VIEW_ALERT = "alert";
 	private static final String VIEW_ALERTS = "alerts";
@@ -121,6 +128,10 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 	private static final String VIEW_VERSION = "version";
 	private static final String VIEW_EXCLUDED_FROM_PROXY = "excludedFromProxy";
 	private static final String VIEW_HOME_DIRECTORY = "homeDirectory";
+	private static final String VIEW_PROXY_CHAIN_EXCLUDED_DOMAINS = "proxyChainExcludedDomains";
+	private static final String VIEW_OPTION_PROXY_CHAIN_SKIP_NAME = "optionProxyChainSkipName";
+	private static final String VIEW_OPTION_PROXY_EXCLUDED_DOMAINS = "optionProxyExcludedDomains";
+	private static final String VIEW_OPTION_PROXY_EXCLUDED_DOMAINS_ENABLED = "optionProxyExcludedDomainsEnabled";
 
 	private static final String OTHER_PROXY_PAC = "proxy.pac";
 	private static final String OTHER_SET_PROXY = "setproxy";
@@ -148,6 +159,10 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 	private static final String PARAM_URL = "url";
 	private static final String PARAM_METHOD = "method";
 	private static final String PARAM_POST_DATA = "postData";
+	private static final String PARAM_VALUE = "value";
+	private static final String PARAM_IDX = "idx";
+	private static final String PARAM_IS_REGEX = "isRegex";
+	private static final String PARAM_IS_ENABLED = "isEnabled";
 
 	/* Update the version whenever the script is changed (once per release) */
 	protected static final int API_SCRIPT_VERSION = 1;
@@ -206,6 +221,19 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 		this.addApiAction(new ApiAction(ACTION_DELETE_ALL_ALERTS));
 		this.addApiAction(new ApiAction(ACTION_COLLECT_GARBAGE));
 		this.addApiAction(new ApiAction(ACTION_DELETE_SITE_NODE, new String[] {PARAM_URL}, new String[] {PARAM_METHOD, PARAM_POST_DATA}));
+		this.addApiAction(
+				new ApiAction(
+						ACTION_ADD_PROXY_CHAIN_EXCLUDED_DOMAIN,
+						new String[] { PARAM_VALUE },
+						new String[] { PARAM_IS_REGEX, PARAM_IS_ENABLED }));
+		this.addApiAction(
+				new ApiAction(
+						ACTION_MODIFY_PROXY_CHAIN_EXCLUDED_DOMAIN,
+						new String[] { PARAM_IDX },
+						new String[] { PARAM_VALUE, PARAM_IS_REGEX, PARAM_IS_ENABLED }));
+		this.addApiAction(new ApiAction(ACTION_REMOVE_PROXY_CHAIN_EXCLUDED_DOMAIN, new String[] { PARAM_IDX }));
+		this.addApiAction(new ApiAction(ACTION_ENABLE_ALL_PROXY_CHAIN_EXCLUDED_DOMAINS));
+		this.addApiAction(new ApiAction(ACTION_DISABLE_ALL_PROXY_CHAIN_EXCLUDED_DOMAINS));
 		
 		this.addApiView(new ApiView(VIEW_ALERT, new String[] {PARAM_ID}));
 		this.addApiView(new ApiView(VIEW_ALERTS, null, 
@@ -222,6 +250,16 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 		this.addApiView(new ApiView(VIEW_VERSION));
 		this.addApiView(new ApiView(VIEW_EXCLUDED_FROM_PROXY));
 		this.addApiView(new ApiView(VIEW_HOME_DIRECTORY));
+		this.addApiView(new ApiView(VIEW_PROXY_CHAIN_EXCLUDED_DOMAINS));
+		ApiView apiView = new ApiView(VIEW_OPTION_PROXY_CHAIN_SKIP_NAME);
+		apiView.setDeprecated(true);
+		this.addApiView(apiView);
+		apiView = new ApiView(VIEW_OPTION_PROXY_EXCLUDED_DOMAINS);
+		apiView.setDeprecated(true);
+		this.addApiView(apiView);
+		apiView = new ApiView(VIEW_OPTION_PROXY_EXCLUDED_DOMAINS_ENABLED);
+		apiView.setDeprecated(true);
+		this.addApiView(apiView);
 		
 		this.addApiOthers(new ApiOther(OTHER_PROXY_PAC, false));
 		this.addApiOthers(new ApiOther(OTHER_ROOT_CERT, false));
@@ -500,12 +538,90 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 			} catch (URIException e) {
 				throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_URL, e);
 			}
+		} else if (ACTION_ADD_PROXY_CHAIN_EXCLUDED_DOMAIN.equals(name)) {
+			try {
+				ConnectionParam connectionParam = Model.getSingleton().getOptionsParam().getConnectionParam();
+				String value = params.getString(PARAM_VALUE);
+				ProxyExcludedDomainMatcher domain;
+				if (getParam(params, PARAM_IS_REGEX, false)) {
+					domain = new ProxyExcludedDomainMatcher(ProxyExcludedDomainMatcher.createPattern(value));
+				} else {
+					domain = new ProxyExcludedDomainMatcher(value);
+				}
+				domain.setEnabled(getParam(params, PARAM_IS_ENABLED, true));
+
+				List<ProxyExcludedDomainMatcher> domains = new ArrayList<>(connectionParam.getProxyExcludedDomains());
+				domains.add(domain);
+				connectionParam.setProxyExcludedDomains(domains);
+			} catch (IllegalArgumentException e) {
+				throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_VALUE, e);
+			}
+		} else if (ACTION_MODIFY_PROXY_CHAIN_EXCLUDED_DOMAIN.equals(name)) {
+			try {
+				ConnectionParam connectionParam = Model.getSingleton().getOptionsParam().getConnectionParam();
+				int idx = params.getInt(PARAM_IDX);
+				if (idx < 0 || idx >= connectionParam.getProxyExcludedDomains().size()) {
+					throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_IDX);
+				}
+
+				ProxyExcludedDomainMatcher oldDomain = connectionParam.getProxyExcludedDomains().get(idx);
+				String value = getParam(params, PARAM_VALUE, oldDomain.getValue());
+				if (value.isEmpty()) {
+					value = oldDomain.getValue();
+				}
+
+				ProxyExcludedDomainMatcher newDomain;
+				if (getParam(params, PARAM_IS_REGEX, oldDomain.isRegex())) {
+					newDomain = new ProxyExcludedDomainMatcher(ProxyExcludedDomainMatcher.createPattern(value));
+				} else {
+					newDomain = new ProxyExcludedDomainMatcher(value);
+				}
+				newDomain.setEnabled(getParam(params, PARAM_IS_ENABLED, oldDomain.isEnabled()));
+
+				if (!oldDomain.equals(newDomain)) {
+					List<ProxyExcludedDomainMatcher> domains = new ArrayList<>(connectionParam.getProxyExcludedDomains());
+					domains.set(idx, newDomain);
+					connectionParam.setProxyExcludedDomains(domains);
+				}
+			} catch (JSONException e) {
+				throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_IDX, e);
+			} catch (IllegalArgumentException e) {
+				throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_VALUE, e);
+			}
+		} else if (ACTION_REMOVE_PROXY_CHAIN_EXCLUDED_DOMAIN.equals(name)) {
+			try {
+				ConnectionParam connectionParam = Model.getSingleton().getOptionsParam().getConnectionParam();
+				int idx = params.getInt(PARAM_IDX);
+				if (idx < 0 || idx >= connectionParam.getProxyExcludedDomains().size()) {
+					throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_IDX);
+				}
+
+				List<ProxyExcludedDomainMatcher> domains = new ArrayList<>(
+						connectionParam.getProxyExcludedDomains());
+				domains.remove(idx);
+				connectionParam.setProxyExcludedDomains(domains);
+			} catch (JSONException e) {
+				throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, PARAM_IDX, e);
+			}
+		} else if (ACTION_ENABLE_ALL_PROXY_CHAIN_EXCLUDED_DOMAINS.equals(name)) {
+			setProxyChainExcludedDomainsEnabled(true);
+		} else if (ACTION_DISABLE_ALL_PROXY_CHAIN_EXCLUDED_DOMAINS.equals(name)) {
+			setProxyChainExcludedDomainsEnabled(false);
 		} else {
 			throw new ApiException(ApiException.Type.BAD_ACTION);
 		}
 		return ApiResponseElement.OK;
 	}
 
+	private void setProxyChainExcludedDomainsEnabled(boolean enabled) {
+		ConnectionParam connectionParam = Model.getSingleton().getOptionsParam().getConnectionParam();
+		List<ProxyExcludedDomainMatcher> domains = connectionParam.getProxyExcludedDomains();
+		for (ProxyExcludedDomainMatcher domain : domains) {
+			domain.setEnabled(enabled);
+		}
+		connectionParam.setProxyExcludedDomains(domains);
+	}
+
 	/**
 	 * Validates that the given request is valid for the current {@link Mode}.
 	 *
@@ -771,11 +887,42 @@ public class CoreAPI extends ApiImplementor implements SessionListener {
 		} else if (VIEW_HOME_DIRECTORY.equals(name)) {
 			result = new ApiResponseElement(name, Model.getSingleton().getOptionsParam().getUserDirectory().getAbsolutePath());
 
+		} else if (VIEW_PROXY_CHAIN_EXCLUDED_DOMAINS.equals(name) || VIEW_OPTION_PROXY_EXCLUDED_DOMAINS.equals(name)
+				|| VIEW_OPTION_PROXY_CHAIN_SKIP_NAME.equals(name)) {
+			result = proxyChainExcludedDomainsToApiResponseList(
+					name,
+					Model.getSingleton().getOptionsParam().getConnectionParam().getProxyExcludedDomains(),
+					false);
+		} else if (VIEW_OPTION_PROXY_EXCLUDED_DOMAINS_ENABLED.equals(name)) {
+			result = proxyChainExcludedDomainsToApiResponseList(
+					name,
+					Model.getSingleton().getOptionsParam().getConnectionParam().getProxyExcludedDomains(),
+					true);
 		} else {
 			throw new ApiException(ApiException.Type.BAD_VIEW);
 		}
 		return result;
 	}
+
+	private ApiResponse proxyChainExcludedDomainsToApiResponseList(
+			String name,
+			List<ProxyExcludedDomainMatcher> domains,
+			boolean excludeDisabled) {
+		ApiResponseList apiResponse = new ApiResponseList(name);
+		for (int i = 0; i < domains.size(); i++) {
+			ProxyExcludedDomainMatcher domain = domains.get(i);
+			if (!domain.isEnabled() && excludeDisabled) {
+				continue;
+			}
+			Map<String, Object> domainData = new HashMap<>();
+			domainData.put("idx", i);
+			domainData.put("value", domain.getValue());
+			domainData.put("regex", domain.isRegex());
+			domainData.put("enabled", domain.isEnabled());
+			apiResponse.addItem(new ApiResponseSet("domain", domainData));
+		}
+		return apiResponse;
+	}
 	
 	@Override
 	public HttpMessage handleApiOther(HttpMessage msg, String name,
