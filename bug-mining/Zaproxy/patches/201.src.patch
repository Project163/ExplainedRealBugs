diff --git a/src/org/parosproxy/paros/core/proxy/ProxyThread.java b/src/org/parosproxy/paros/core/proxy/ProxyThread.java
index d7ed65795..ffb485862 100644
--- a/src/org/parosproxy/paros/core/proxy/ProxyThread.java
+++ b/src/org/parosproxy/paros/core/proxy/ProxyThread.java
@@ -71,6 +71,7 @@
 // ZAP: 2017/02/23  Issue 3227: Limit API access to whitelisted IP addresses
 // ZAP: 2017/03/15 Disable API by default
 // ZAP: 2017/03/26 Check the public address when behind NAT.
+// ZAP: 2017/06/12 Do not notify listeners when request is excluded.
 
 package org.parosproxy.paros.core.proxy;
 
@@ -118,6 +119,7 @@ import org.zaproxy.zap.PersistentConnectionListener;
 import org.zaproxy.zap.ZapGetMethod;
 import org.zaproxy.zap.extension.api.API;
 import org.zaproxy.zap.network.HttpRequestBody;
+import org.zaproxy.zap.network.HttpRequestConfig;
 
 
 public class ProxyThread implements Runnable {
@@ -131,6 +133,11 @@ public class ProxyThread implements Runnable {
     private static final String BAD_GATEWAY_RESPONSE_STATUS = "502 Bad Gateway";
     private static final String GATEWAY_TIMEOUT_RESPONSE_STATUS = "504 Gateway Timeout";
     
+    /**
+     * A {@code HttpRequestConfig} that does not allow notification of events to listeners.
+     */
+    private static final HttpRequestConfig EXCLUDED_REQ_CONFIG = HttpRequestConfig.builder().setNotifyListeners(false).build();
+
 	// change httpSender to static to be shared among proxies to reuse keep-alive connections
 
 	protected ProxyServer parentServer = null;
@@ -456,20 +463,25 @@ public class ProxyThread implements Runnable {
 			}
 			
 			boolean send = true;
+			boolean excluded = parentServer.excludeUrl(msg.getRequestHeader().getURI());
 			synchronized (semaphore) {
 			    
-			    if (notifyOverrideListenersRequestSend(msg)) {
-			        send = false;
-			    } else if (! notifyListenerRequestSend(msg)) {
-		        	// One of the listeners has told us to drop the request
-			    	return;
-			    }
+				if (!excluded) {
+					if (notifyOverrideListenersRequestSend(msg)) {
+						send = false;
+					} else if (! notifyListenerRequestSend(msg)) {
+						// One of the listeners has told us to drop the request
+						return;
+					}
+				}
 			    
 			    try {
 //					bug occur where response cannot be processed by various listener
 //			        first so streaming feature was disabled		        
 //					getHttpSender().sendAndReceive(msg, httpOut, buffer);
-			        if (send) {
+					if (excluded) {
+						getHttpSender().sendAndReceive(msg, EXCLUDED_REQ_CONFIG);
+					} else if (send) {
 					    if (msg.getResponseHeader().isEmpty()) {
 					    	// Normally the response is empty.
 					    	// The only reason it wont be is if a script or other ext has deliberately 'hijacked' this request
@@ -500,12 +512,15 @@ public class ProxyThread implements Runnable {
 					log.warn(message);
 					setErrorResponse(msg, GATEWAY_TIMEOUT_RESPONSE_STATUS, message);
 
-			        notifyListenerResponseReceive(msg);
+					if (!excluded) {
+						notifyListenerResponseReceive(msg);
+					}
 			    } catch (IOException e) {
 			    	setErrorResponse(msg, BAD_GATEWAY_RESPONSE_STATUS, e);
-			    	
-			        notifyListenerResponseReceive(msg);
 
+					if (!excluded) {
+						notifyListenerResponseReceive(msg);
+					}
 
 			        //throw e;
 			    }
@@ -629,9 +644,6 @@ public class ProxyThread implements Runnable {
 	 * @return {@code true} if the message should be forwarded to the server, {@code false} otherwise
 	 */
 	private boolean notifyListenerRequestSend(HttpMessage httpMessage) {
-		if (parentServer.excludeUrl(httpMessage.getRequestHeader().getURI())) {
-			return true;
-		}
 		ProxyListener listener = null;
 		List<ProxyListener> listenerList = parentServer.getListenerList();
 		for (int i=0;i<listenerList.size();i++) {
@@ -654,9 +666,6 @@ public class ProxyThread implements Runnable {
 	 * @return {@code true} if the message should be forwarded to the client, {@code false} otherwise
 	 */
 	private boolean notifyListenerResponseReceive(HttpMessage httpMessage) {
-		if (parentServer.excludeUrl(httpMessage.getRequestHeader().getURI())) {
-			return true;
-		}
 		ProxyListener listener = null;
 		List<ProxyListener> listenerList = parentServer.getListenerList();
 		for (int i=0;i<listenerList.size();i++) {
diff --git a/src/org/parosproxy/paros/network/HttpSender.java b/src/org/parosproxy/paros/network/HttpSender.java
index d831bf81f..e7b3c9595 100644
--- a/src/org/parosproxy/paros/network/HttpSender.java
+++ b/src/org/parosproxy/paros/network/HttpSender.java
@@ -63,6 +63,7 @@
 // ZAP: 2016/12/07 Add initiator constant for AJAX spider requests
 // ZAP: 2016/12/12 Add initiator constant for Forced Browse requests
 // ZAP: 2017/03/27 Introduce HttpRequestConfig.
+// ZAP: 2017/06/12 Allow to ignore listeners.
 
 package org.parosproxy.paros.network;
 
@@ -849,13 +850,48 @@ public class HttpSender {
             throw new IllegalArgumentException("Parameter requestConfig must not be null.");
         }
 
-        sendAndReceive(message, false);
+        sendAndReceiveImpl(message, requestConfig);
 
         if (requestConfig.isFollowRedirects()) {
             followRedirections(message, requestConfig);
         }
     }
 
+    /**
+     * Helper method that sends the request of the given HTTP {@code message} with the given configurations.
+     * <p>
+     * No redirections are followed (see {@link #followRedirections(HttpMessage, HttpRequestConfig)}).
+     *
+     * @param message the message that will be sent.
+     * @param requestConfig the request configurations.
+     * @throws IOException if an error occurred while sending the message or following the redirections.
+     */
+    private void sendAndReceiveImpl(HttpMessage message, HttpRequestConfig requestConfig) throws IOException {
+        if (log.isDebugEnabled()) {
+            log.debug("Sending " + message.getRequestHeader().getMethod() + " " + message.getRequestHeader().getURI());
+        }
+        message.setTimeSentMillis(System.currentTimeMillis());
+
+        try {
+            if (requestConfig.isNotifyListeners()) {
+                notifyRequestListeners(message);
+            }
+            sendAuthenticated(message, false);
+        } finally {
+            message.setTimeElapsedMillis((int) (System.currentTimeMillis() - message.getTimeSentMillis()));
+
+            if (log.isDebugEnabled()) {
+                log.debug(
+                        "Received response after " + message.getTimeElapsedMillis() + "ms for "
+                                + message.getRequestHeader().getMethod() + " " + message.getRequestHeader().getURI());
+            }
+
+            if (requestConfig.isNotifyListeners()) {
+                notifyResponseListeners(message);
+            }
+        }
+    }
+
     /**
      * Follows redirections using the response of the given {@code message}. The {@code validator} in the give request
      * configuration will be called for each redirection received. After the call to this method the given {@code message} will
@@ -891,7 +927,7 @@ public class HttpSender {
                 redirectMessage.setRequestBody("");
             }
 
-            sendAndReceive(redirectMessage, false);
+            sendAndReceiveImpl(redirectMessage, requestConfig);
             validator.notifyMessageReceived(redirectMessage);
 
             // Update the response of the (original) message
diff --git a/src/org/zaproxy/zap/network/HttpRequestConfig.java b/src/org/zaproxy/zap/network/HttpRequestConfig.java
index dcc3d58eb..55ebe1055 100644
--- a/src/org/zaproxy/zap/network/HttpRequestConfig.java
+++ b/src/org/zaproxy/zap/network/HttpRequestConfig.java
@@ -30,14 +30,18 @@ public class HttpRequestConfig {
 
     private final boolean followRedirects;
     private final HttpRedirectionValidator redirectionValidator;
+    private final boolean notifyListeners;
 
-    HttpRequestConfig(boolean followRedirects, HttpRedirectionValidator redirectionValidator) {
+    HttpRequestConfig(boolean followRedirects, HttpRedirectionValidator redirectionValidator, boolean notifyListeners) {
         this.followRedirects = followRedirects;
         this.redirectionValidator = redirectionValidator;
+        this.notifyListeners = notifyListeners;
     }
 
     /**
      * Tells whether or not the redirects should be followed.
+     * <p>
+     * Default value: {@code false}.
      *
      * @return {@code true} if the redirects should be followed, {@code false} otherwise.
      * @see #getRedirectionValidator()
@@ -48,6 +52,8 @@ public class HttpRequestConfig {
 
     /**
      * Gets the {@code HttpRedirectionValidator}, to validate the followed redirections.
+     * <p>
+     * Default value: {@link DefaultHttpRedirectionValidator#INSTANCE}.
      *
      * @return the validator responsible for validation of redirections, never {@code null}.
      * @see #isFollowRedirects()
@@ -56,6 +62,19 @@ public class HttpRequestConfig {
         return redirectionValidator;
     }
 
+    /**
+     * Tells whether or not {@link HttpSenderListener}s should be notified before sending the request and after receiving the
+     * response.
+     * <p>
+     * Default value: {@code true}.
+     *
+     * @return {@code true} if the listeners should be notified, {@code false} otherwise.
+     * @since TODO add version
+     */
+    public boolean isNotifyListeners() {
+        return notifyListeners;
+    }
+
     /**
      * Gets a new HTTP request configuration builder.
      *
@@ -86,15 +105,18 @@ public class HttpRequestConfig {
 
         private boolean followRedirects;
         private HttpRedirectionValidator redirectionValidator;
+        private boolean notifyListeners;
 
         private Builder() {
             this.followRedirects = false;
             this.redirectionValidator = DefaultHttpRedirectionValidator.INSTANCE;
+            this.notifyListeners = true;
         }
 
         private Builder(HttpRequestConfig config) {
             this.followRedirects = config.isFollowRedirects();
             this.redirectionValidator = config.getRedirectionValidator();
+            this.notifyListeners = config.isNotifyListeners();
         }
 
         /**
@@ -128,13 +150,26 @@ public class HttpRequestConfig {
             return this;
         }
 
+        /**
+         * Sets whether or not {@link HttpSenderListener}s should be notified before sending the request and after receiving the
+         * response.
+         *
+         * @param notifyListeners {@code true} if the listeners should be notified, {@code false} otherwise.
+         * @return the builder.
+         * @since TODO add version
+         */
+        public Builder setNotifyListeners(boolean notifyListeners) {
+            this.notifyListeners = notifyListeners;
+            return this;
+        }
+
         /**
          * Builds a new {@code HttpRequestConfig}, with the configurations previously set.
          *
          * @return a new {@code HttpRequestConfig}.
          */
         public HttpRequestConfig build() {
-            return new HttpRequestConfig(followRedirects, redirectionValidator);
+            return new HttpRequestConfig(followRedirects, redirectionValidator, notifyListeners);
         }
     }
 }
\ No newline at end of file
