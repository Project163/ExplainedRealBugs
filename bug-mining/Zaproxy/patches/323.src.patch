diff --git a/zap/src/main/java/org/zaproxy/zap/control/AddOn.java b/zap/src/main/java/org/zaproxy/zap/control/AddOn.java
index 9977eece2..afea17c98 100644
--- a/zap/src/main/java/org/zaproxy/zap/control/AddOn.java
+++ b/zap/src/main/java/org/zaproxy/zap/control/AddOn.java
@@ -33,9 +33,11 @@ import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.ResourceBundle;
 import java.util.Set;
+import java.util.stream.Collectors;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipException;
 import java.util.zip.ZipFile;
@@ -155,11 +157,7 @@ public class AddOn {
              * <p>The result contains the {@link ValidationResult#getException() exception}.
              */
             IO_ERROR_FILE,
-            /**
-             * The ZIP file does not have the add-on manifest, {@value #MANIFEST_FILE_NAME}.
-             *
-             * <p>The result contains the {@link ValidationResult#getException() exception}.
-             */
+            /** The ZIP file does not have the add-on manifest, {@value #MANIFEST_FILE_NAME}. */
             MISSING_MANIFEST,
             /**
              * The manifest is not valid.
@@ -167,6 +165,8 @@ public class AddOn {
              * <p>The result contains the {@link ValidationResult#getException() exception}.
              */
             INVALID_MANIFEST,
+            /** The add-on declared a missing/invalid library. */
+            INVALID_LIB,
         };
 
         private final Validity validity;
@@ -291,6 +291,7 @@ public class AddOn {
     private List<PluginPassiveScanner> loadedPscanrules = Collections.emptyList();
     private boolean loadedPscanRulesSet;
     private List<String> files = Collections.emptyList();
+    private List<Lib> libs = Collections.emptyList();
 
     private AddOnClassnames addOnClassnames = AddOnClassnames.ALL_ALLOWED;
 
@@ -420,17 +421,23 @@ public class AddOn {
         }
 
         try (ZipFile zip = new ZipFile(file.toFile())) {
-            ZipEntry manifest = zip.getEntry(MANIFEST_FILE_NAME);
-            if (manifest == null) {
+            ZipEntry manifestEntry = zip.getEntry(MANIFEST_FILE_NAME);
+            if (manifestEntry == null) {
                 return new ValidationResult(ValidationResult.Validity.MISSING_MANIFEST);
             }
 
-            try (InputStream zis = zip.getInputStream(manifest)) {
+            try (InputStream zis = zip.getInputStream(manifestEntry)) {
+                ZapAddOnXmlFile manifest;
                 try {
-                    return new ValidationResult(new ZapAddOnXmlFile(zis));
-                } catch (Exception e) {
+                    manifest = new ZapAddOnXmlFile(zis);
+                } catch (IOException e) {
                     return new ValidationResult(ValidationResult.Validity.INVALID_MANIFEST, e);
                 }
+
+                if (hasInvalidLibs(file, manifest, zip)) {
+                    return new ValidationResult(ValidationResult.Validity.INVALID_LIB);
+                }
+                return new ValidationResult(manifest);
             }
         } catch (ZipException e) {
             return new ValidationResult(ValidationResult.Validity.UNREADABLE_ZIP_FILE, e);
@@ -439,6 +446,24 @@ public class AddOn {
         }
     }
 
+    private static boolean hasInvalidLibs(Path file, ZapAddOnXmlFile manifest, ZipFile zip) {
+        return manifest.getLibs().stream()
+                .anyMatch(
+                        e -> {
+                            ZipEntry libEntry = zip.getEntry(e);
+                            if (libEntry == null) {
+                                logger.warn("The add-on " + file + " does not have the lib: " + e);
+                                return true;
+                            }
+                            if (libEntry.isDirectory()) {
+                                logger.warn(
+                                        "The add-on " + file + " does not have a file lib: " + e);
+                                return true;
+                            }
+                            return false;
+                        });
+    }
+
     /**
      * Convenience method that attempts to create an {@code AddOn} from the given file.
      *
@@ -570,6 +595,7 @@ public class AddOn {
         this.extensions = zapAddOnXml.getExtensions();
         this.extensionsWithDeps = zapAddOnXml.getExtensionsWithDeps();
         this.files = zapAddOnXml.getFiles();
+        this.libs = createLibs(zapAddOnXml.getLibs());
         this.pscanrules = zapAddOnXml.getPscanrules();
 
         this.addOnClassnames = zapAddOnXml.getAddOnClassnames();
@@ -641,6 +667,13 @@ public class AddOn {
         return null;
     }
 
+    private static List<Lib> createLibs(List<String> libPaths) {
+        if (libPaths.isEmpty()) {
+            return Collections.emptyList();
+        }
+        return libPaths.stream().map(Lib::new).collect(Collectors.toList());
+    }
+
     public String getId() {
         return id;
     }
@@ -1152,6 +1185,19 @@ public class AddOn {
         return files;
     }
 
+    /**
+     * Gets the bundled libraries of the add-on.
+     *
+     * @return the bundled libraries, never {@code null}.
+     */
+    List<Lib> getLibs() {
+        return libs;
+    }
+
+    private boolean hasMissingLibs() {
+        return libs.stream().anyMatch(lib -> lib.getFileSystemUrl() == null);
+    }
+
     public boolean isSameAddOn(AddOn addOn) {
         return this.getId().equals(addOn.getId());
     }
@@ -1266,10 +1312,31 @@ public class AddOn {
      * @see AddOnRunRequirements
      */
     public AddOnRunRequirements calculateRunRequirements(Collection<AddOn> availableAddOns) {
+        return calculateRunRequirements(availableAddOns, true);
+    }
+
+    /**
+     * Calculates the requirements to install/run this add-on, same as {@link
+     * #calculateRunRequirements(Collection)} but does not require the libraries of the add-ons
+     * (this or dependencies) to exist in the file system.
+     *
+     * @param availableAddOns the other add-ons available.
+     * @return the requirements to install/run the add-on, and if not runnable the reason why it's
+     *     not.
+     * @since TODO add version
+     * @see #calculateRunRequirements(Collection)
+     * @see AddOnRunRequirements
+     */
+    public AddOnRunRequirements calculateInstallRequirements(Collection<AddOn> availableAddOns) {
+        return calculateRunRequirements(availableAddOns, false);
+    }
+
+    private AddOnRunRequirements calculateRunRequirements(
+            Collection<AddOn> availableAddOns, boolean checkLibs) {
         AddOnRunRequirements requirements = new AddOnRunRequirements(this);
-        calculateRunRequirementsImpl(availableAddOns, requirements, null, this);
+        calculateRunRequirementsImpl(availableAddOns, requirements, null, this, checkLibs);
         if (requirements.isRunnable()) {
-            checkExtensionsWithDeps(availableAddOns, requirements, this);
+            checkExtensionsWithDeps(availableAddOns, requirements, this, checkLibs);
         }
         return requirements;
     }
@@ -1278,7 +1345,13 @@ public class AddOn {
             Collection<AddOn> availableAddOns,
             BaseRunRequirements requirements,
             AddOn parent,
-            AddOn addOn) {
+            AddOn addOn,
+            boolean checkLibs) {
+        if (checkLibs && addOn.hasMissingLibs()) {
+            requirements.setMissingLibsIssue(addOn);
+            return;
+        }
+
         AddOn installedVersion = getAddOn(availableAddOns, addOn.getId());
         if (installedVersion != null && !addOn.equals(installedVersion)) {
             requirements.setIssue(
@@ -1327,7 +1400,8 @@ public class AddOn {
                     }
                 }
 
-                calculateRunRequirementsImpl(availableAddOns, requirements, addOn, addOnDep);
+                calculateRunRequirementsImpl(
+                        availableAddOns, requirements, addOn, addOnDep, checkLibs);
                 if (requirements.hasDependencyIssue()) {
                     return;
                 }
@@ -1336,13 +1410,17 @@ public class AddOn {
     }
 
     private static void checkExtensionsWithDeps(
-            Collection<AddOn> availableAddOns, AddOnRunRequirements requirements, AddOn addOn) {
+            Collection<AddOn> availableAddOns,
+            AddOnRunRequirements requirements,
+            AddOn addOn,
+            boolean checkLibs) {
         if (addOn.extensionsWithDeps.isEmpty()) {
             return;
         }
 
         for (ExtensionWithDeps extension : addOn.extensionsWithDeps) {
-            calculateExtensionRunRequirements(extension, availableAddOns, requirements, addOn);
+            calculateExtensionRunRequirements(
+                    extension, availableAddOns, requirements, addOn, checkLibs);
         }
     }
 
@@ -1350,7 +1428,8 @@ public class AddOn {
             ExtensionWithDeps extension,
             Collection<AddOn> availableAddOns,
             AddOnRunRequirements requirements,
-            AddOn addOn) {
+            AddOn addOn,
+            boolean checkLibs) {
         ExtensionRunRequirements extensionRequirements =
                 new ExtensionRunRequirements(addOn, extension.getClassname());
         requirements.addExtensionRequirements(extensionRequirements);
@@ -1388,7 +1467,8 @@ public class AddOn {
                 }
             }
 
-            calculateRunRequirementsImpl(availableAddOns, extensionRequirements, addOn, addOnDep);
+            calculateRunRequirementsImpl(
+                    availableAddOns, extensionRequirements, addOn, addOnDep, checkLibs);
         }
     }
 
@@ -1423,8 +1503,26 @@ public class AddOn {
      */
     public AddOnRunRequirements calculateExtensionRunRequirements(
             Extension extension, Collection<AddOn> availableAddOns) {
-        return calculateExtensionRunRequirements(
-                extension.getClass().getCanonicalName(), availableAddOns);
+        return calculateExtensionRunRequirementsImpl(
+                extension.getClass().getCanonicalName(), availableAddOns, true);
+    }
+
+    /**
+     * Calculates the requirements to install/run the given {@code extension}, same as {@link
+     * #calculateExtensionRunRequirements(Extension, Collection)} but does not require the libraries
+     * of the add-ons (this or dependencies) to exist in the file system.
+     *
+     * @param extension the extension that will be checked.
+     * @param availableAddOns the add-ons available.
+     * @return the requirements to install/run the extension, and if not runnable the reason why
+     *     it's not.
+     * @since TODO add version
+     * @see AddOnRunRequirements#getExtensionRequirements()
+     */
+    public AddOnRunRequirements calculateExtensionInstallRequirements(
+            Extension extension, Collection<AddOn> availableAddOns) {
+        return calculateExtensionRunRequirementsImpl(
+                extension.getClass().getCanonicalName(), availableAddOns, false);
     }
 
     /**
@@ -1445,11 +1543,33 @@ public class AddOn {
      */
     public AddOnRunRequirements calculateExtensionRunRequirements(
             String classname, Collection<AddOn> availableAddOns) {
+        return calculateExtensionRunRequirementsImpl(classname, availableAddOns, true);
+    }
+
+    /**
+     * Calculates the requirements to install/run the given {@code extension}, same as {@link
+     * #calculateExtensionRunRequirements(String, Collection)} but does not require the libraries of
+     * the add-ons (this or dependencies) to exist in the file system.
+     *
+     * @param classname the classname of extension that will be checked.
+     * @param availableAddOns the add-ons available.
+     * @return the requirements to install/run the extension, and if not runnable the reason why
+     *     it's not.
+     * @since TODO add version
+     * @see AddOnRunRequirements#getExtensionRequirements()
+     */
+    public AddOnRunRequirements calculateExtensionInstallRequirements(
+            String classname, Collection<AddOn> availableAddOns) {
+        return calculateExtensionRunRequirementsImpl(classname, availableAddOns, false);
+    }
+
+    private AddOnRunRequirements calculateExtensionRunRequirementsImpl(
+            String classname, Collection<AddOn> availableAddOns, boolean checkLibs) {
         AddOnRunRequirements requirements = new AddOnRunRequirements(this);
         for (ExtensionWithDeps extensionWithDeps : extensionsWithDeps) {
             if (extensionWithDeps.getClassname().equals(classname)) {
                 calculateExtensionRunRequirements(
-                        extensionWithDeps, availableAddOns, requirements, this);
+                        extensionWithDeps, availableAddOns, requirements, this, checkLibs);
                 break;
             }
         }
@@ -1767,6 +1887,66 @@ public class AddOn {
         return version.equals(other.version);
     }
 
+    /**
+     * A library (JAR) bundled in the add-on.
+     *
+     * <p>Bundled libraries are copied and loaded from the file system, which allows to properly
+     * maintain/access all JAR's data (e.g. module info, manifest, services).
+     */
+    static class Lib {
+        private final String jarPath;
+        private final String name;
+        private URL fileSystemUrl;
+
+        Lib(String path) {
+            jarPath = path;
+            name = extractName(path);
+        }
+
+        String getJarPath() {
+            return jarPath;
+        }
+
+        String getName() {
+            return name;
+        }
+
+        URL getFileSystemUrl() {
+            return fileSystemUrl;
+        }
+
+        void setFileSystemUrl(URL fileSystemUrl) {
+            this.fileSystemUrl = fileSystemUrl;
+        }
+
+        private static String extractName(String path) {
+            int idx = path.lastIndexOf('/');
+            if (idx == -1) {
+                return path;
+            }
+            return path.substring(idx + 1);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(jarPath);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null) {
+                return false;
+            }
+            if (getClass() != obj.getClass()) {
+                return false;
+            }
+            return Objects.equals(jarPath, ((Lib) obj).jarPath);
+        }
+    }
+
     public abstract static class BaseRunRequirements {
 
         /**
@@ -1838,6 +2018,7 @@ public class AddOn {
 
         private String minimumJavaVersion;
         private AddOn addOnMinimumJavaVersion;
+        private AddOn addOnMissingLibs;
 
         private boolean runnable;
 
@@ -2010,6 +2191,37 @@ public class AddOn {
             addOnMinimumJavaVersion = srcAddOn;
             minimumJavaVersion = requiredVersion;
         }
+
+        /**
+         * Tells whether or not this add-on has missing libraries (that is, not present in the file
+         * system).
+         *
+         * <p>The issue might be caused by a dependency or the add-on itself. To check which one use
+         * the methods {@link #getAddOn()} and {@link #getAddOnMissingLibs()}.
+         *
+         * @return {@code true} if the add-on has missing libraries, {@code false} otherwise.
+         * @since TODO add version
+         */
+        public boolean hasMissingLibs() {
+            return addOnMissingLibs != null;
+        }
+
+        /**
+         * Gets the add-on that has missing libraries.
+         *
+         * @return the add-on, or {@code null} if none.
+         * @see #hasMissingLibs()
+         * @see #getAddOn()
+         * @since TODO add version
+         */
+        public AddOn getAddOnMissingLibs() {
+            return addOnMissingLibs;
+        }
+
+        protected void setMissingLibsIssue(AddOn srcAddOn) {
+            setRunnable(false);
+            addOnMissingLibs = srcAddOn;
+        }
     }
 
     /**
diff --git a/zap/src/main/java/org/zaproxy/zap/control/AddOnClassLoader.java b/zap/src/main/java/org/zaproxy/zap/control/AddOnClassLoader.java
index 1fd54439f..c8e4d0599 100644
--- a/zap/src/main/java/org/zaproxy/zap/control/AddOnClassLoader.java
+++ b/zap/src/main/java/org/zaproxy/zap/control/AddOnClassLoader.java
@@ -25,6 +25,7 @@ import java.net.URLClassLoader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * A {@code URLClassLoader} that search for classes and resources (first) in a given add-on file
@@ -255,6 +256,17 @@ public class AddOnClassLoader extends URLClassLoader {
         this.classLoadingLockProvider = parent::getClassLoadingLock;
     }
 
+    /**
+     * Adds the given URLs to the class loader, to search for classes and resources.
+     *
+     * @param urls the URLs to add to the class loader.
+     * @throws NullPointerException if the given list is {@code null}.
+     */
+    void addUrls(List<URL> urls) {
+        Objects.requireNonNull(urls);
+        urls.forEach(this::addURL);
+    }
+
     /**
      * Removes the given child class loader from the list of child class loaders.
      *
diff --git a/zap/src/main/java/org/zaproxy/zap/control/AddOnCollection.java b/zap/src/main/java/org/zaproxy/zap/control/AddOnCollection.java
index 3062ee991..ef663c0b1 100644
--- a/zap/src/main/java/org/zaproxy/zap/control/AddOnCollection.java
+++ b/zap/src/main/java/org/zaproxy/zap/control/AddOnCollection.java
@@ -64,9 +64,9 @@ public class AddOnCollection {
             while (!checkedAddOns.isEmpty()) {
                 AddOn addOn = checkedAddOns.remove(0);
                 // Shouldn't happen but make sure to not show add-ons that wouldn't run, or one of
-                // its extensions
-                // because of dependency issues or
-                AddOn.AddOnRunRequirements requirements = addOn.calculateRunRequirements(addOns);
+                // its extensions because of dependency issues.
+                AddOn.AddOnRunRequirements requirements =
+                        addOn.calculateInstallRequirements(addOns);
                 if (requirements.hasDependencyIssue()) {
                     if (logger.isDebugEnabled()) {
                         logger.debug(
diff --git a/zap/src/main/java/org/zaproxy/zap/control/AddOnInstaller.java b/zap/src/main/java/org/zaproxy/zap/control/AddOnInstaller.java
index 4e5698861..7dfadd509 100644
--- a/zap/src/main/java/org/zaproxy/zap/control/AddOnInstaller.java
+++ b/zap/src/main/java/org/zaproxy/zap/control/AddOnInstaller.java
@@ -24,13 +24,23 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.net.MalformedURLException;
 import java.net.URL;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.StandardCopyOption;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
 import java.util.Set;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
 import org.apache.commons.lang.Validate;
 import org.apache.log4j.Logger;
 import org.parosproxy.paros.Constant;
@@ -58,6 +68,9 @@ public final class AddOnInstaller {
 
     private static final Logger logger = Logger.getLogger(AddOnInstaller.class);
 
+    /** The base directory to where add-on data (e.g. libraries) is copied. */
+    private static final String ADD_ON_DATA_DIR = "addOnData";
+
     private AddOnInstaller() {}
 
     /**
@@ -444,6 +457,160 @@ public final class AddOnInstaller {
         return uninstalledWithoutErrors;
     }
 
+    /**
+     * Installs the libraries declared by the given add-on.
+     *
+     * <p>The libraries are copied to the directory with the following path: {@code
+     * <zapHome>/addOnData/<addOnId>/libs/}
+     *
+     * @param addOn the add-on that will have the declared libraries installed.
+     * @return {@code true} if no error occurred while installing the libraries, {@code false}
+     *     otherwise.
+     * @see #uninstallAddOnLibs(AddOn)
+     * @see #installMissingAddOnLibs(AddOn)
+     * @see #getAddOnDataDir(AddOn)
+     */
+    static boolean installAddOnLibs(AddOn addOn) {
+        return installAddOnLibs(addOn, true);
+    }
+
+    private static boolean installAddOnLibs(AddOn addOn, boolean overwrite) {
+        List<AddOn.Lib> libs = addOn.getLibs();
+        if (libs.isEmpty()) {
+            return true;
+        }
+
+        Path targetDir = getAddOnDataDir(addOn).resolve("libs");
+        try {
+            Files.createDirectories(targetDir);
+        } catch (IOException e) {
+            logger.warn("Failed to create libs directory for " + addOn.getId(), e);
+            return false;
+        }
+
+        try (ZipFile zip = new ZipFile(addOn.getFile())) {
+            for (AddOn.Lib lib : libs) {
+                String name = lib.getName();
+                if (logger.isDebugEnabled()) {
+                    logger.debug("Installing library for " + addOn + ": " + name);
+                }
+
+                Path targetFile = targetDir.resolve(name);
+                try {
+                    lib.setFileSystemUrl(targetFile.toUri().toURL());
+                } catch (MalformedURLException e) {
+                    logger.warn(
+                            "Failed to convert lib's filesystem path to URL for " + addOn.getId(),
+                            e);
+                    return false;
+                }
+
+                if (!overwrite && Files.exists(targetFile)) {
+                    continue;
+                }
+
+                ZipEntry libZipEntry = zip.getEntry(lib.getJarPath());
+                if (libZipEntry == null) {
+                    logger.warn("Library not found in " + addOn + " add-on: " + lib);
+                    return false;
+                }
+
+                try (InputStream in = zip.getInputStream(libZipEntry)) {
+                    Files.copy(in, targetFile, StandardCopyOption.REPLACE_EXISTING);
+                } catch (IOException e) {
+                    logger.warn("Failed to copy the library for " + addOn + ": " + targetFile, e);
+                    return false;
+                }
+            }
+        } catch (IOException e) {
+            logger.error("An error occurred while installing libraries for " + addOn, e);
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Gets the path to the data directory of the given add-on.
+     *
+     * <p>The path is built as: {@code <zapHome>/addOnData/<addOnId>/}
+     *
+     * @param addOn the add-on.
+     * @return the path to the directory.
+     * @see #ADD_ON_DATA_DIR
+     */
+    private static Path getAddOnDataDir(AddOn addOn) {
+        return Paths.get(Constant.getZapHome(), ADD_ON_DATA_DIR, addOn.getId());
+    }
+
+    /**
+     * Installs all the missing libraries declared by the given add-on.
+     *
+     * @param addOn the add-on that will have the missing declared libraries installed.
+     * @return {@code true} if no error occurred while installing the libraries, {@code false}
+     *     otherwise.
+     * @see #uninstallAddOnLibs(AddOn)
+     * @see #installAddOnLibs(AddOn, boolean)
+     */
+    static boolean installMissingAddOnLibs(AddOn addOn) {
+        return installAddOnLibs(addOn, false);
+    }
+
+    /**
+     * Uninstalls the libraries declared by the given add-on.
+     *
+     * @param addOn the add-on that will have the declared libraries uninstalled.
+     * @see #installAddOnLibs(AddOn)
+     * @see #installMissingAddOnLibs(AddOn)
+     */
+    static void uninstallAddOnLibs(AddOn addOn) {
+        List<AddOn.Lib> libs = addOn.getLibs();
+        if (libs.isEmpty()) {
+            return;
+        }
+
+        try {
+            deleteDir(getAddOnDataDir(addOn));
+        } catch (IOException e) {
+            logger.error("An error occurred while uninstalling libraries for " + addOn, e);
+        }
+    }
+
+    /**
+     * Deletes the given directory and all files/directories under it.
+     *
+     * @param dir the directory to delete.
+     * @throws IOException if an error occurred while deleting the directory or any file/directory
+     *     under it.
+     */
+    private static void deleteDir(Path dir) throws IOException {
+        if (Files.notExists(dir)) {
+            return;
+        }
+
+        Files.walkFileTree(
+                dir,
+                new SimpleFileVisitor<Path>() {
+
+                    @Override
+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
+                            throws IOException {
+                        Files.delete(file);
+                        return FileVisitResult.CONTINUE;
+                    }
+
+                    @Override
+                    public FileVisitResult postVisitDirectory(Path dir, IOException e)
+                            throws IOException {
+                        if (e != null) {
+                            throw e;
+                        }
+                        Files.delete(dir);
+                        return FileVisitResult.CONTINUE;
+                    }
+                });
+    }
+
     /**
      * Installs all the missing files declared by the given {@code addOn}.
      *
diff --git a/zap/src/main/java/org/zaproxy/zap/control/AddOnLoader.java b/zap/src/main/java/org/zaproxy/zap/control/AddOnLoader.java
index 51e844f33..3854e1423 100644
--- a/zap/src/main/java/org/zaproxy/zap/control/AddOnLoader.java
+++ b/zap/src/main/java/org/zaproxy/zap/control/AddOnLoader.java
@@ -46,6 +46,7 @@ import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
+import java.util.stream.Collectors;
 import java.util.zip.ZipEntry;
 import org.apache.commons.configuration.Configuration;
 import org.apache.commons.configuration.ConfigurationException;
@@ -191,6 +192,7 @@ public class AddOnLoader extends URLClassLoader {
         for (Iterator<AddOn> iterator = aoc.getAddOns().iterator(); iterator.hasNext(); ) {
             AddOn addOn = iterator.next();
             if (canLoadAddOn(addOn)) {
+                AddOnInstaller.installMissingAddOnLibs(addOn);
                 AddOnRunRequirements reqs = calculateRunRequirements(addOn, aoc.getAddOns());
                 if (reqs.isRunnable()) {
                     AddOnRunState runState = oldRunnableAddOns.get(addOn);
@@ -302,8 +304,7 @@ public class AddOnLoader extends URLClassLoader {
                 addOnClassLoader =
                         new AddOnClassLoader(
                                 ao.getFile().toURI().toURL(), this, ao.getAddOnClassnames());
-                this.addOnLoaders.put(ao.getId(), addOnClassLoader);
-                ao.setClassLoader(addOnClassLoader);
+                putAddOnClassLoader(ao, addOnClassLoader);
                 return addOnClassLoader;
             }
 
@@ -322,8 +323,7 @@ public class AddOnLoader extends URLClassLoader {
                             this,
                             dependencies,
                             ao.getAddOnClassnames());
-            this.addOnLoaders.put(ao.getId(), addOnClassLoader);
-            ao.setClassLoader(addOnClassLoader);
+            putAddOnClassLoader(ao, addOnClassLoader);
             return addOnClassLoader;
         } catch (MalformedURLException e) {
             logger.error(e.getMessage(), e);
@@ -332,6 +332,26 @@ public class AddOnLoader extends URLClassLoader {
         }
     }
 
+    /**
+     * Puts the given add-on class loader into the {@link #addOnLoaders} map and {@link
+     * AddOn#setClassLoader(ClassLoader) sets it into the add-on}.
+     *
+     * <p>The add-on libraries are added to the add-on class loader before that.
+     *
+     * @param ao the add-on to put in the map.
+     * @param addOnClassLoader the class loader of the add-on.
+     */
+    private void putAddOnClassLoader(AddOn ao, AddOnClassLoader addOnClassLoader) {
+        if (!ao.getLibs().isEmpty()) {
+            addOnClassLoader.addUrls(
+                    ao.getLibs().stream()
+                            .map(AddOn.Lib::getFileSystemUrl)
+                            .collect(Collectors.toList()));
+        }
+        ao.setClassLoader(addOnClassLoader);
+        addOnLoaders.put(ao.getId(), addOnClassLoader);
+    }
+
     @Override
     public Class<?> loadClass(String name) throws ClassNotFoundException {
         synchronized (getClassLoadingLock(name)) {
@@ -446,6 +466,11 @@ public class AddOnLoader extends URLClassLoader {
             return;
         }
 
+        if (!AddOnInstaller.installAddOnLibs(ao)) {
+            ao.setInstallationStatus(AddOn.InstallationStatus.NOT_INSTALLED);
+            return;
+        }
+
         AddOnRunRequirements reqs = calculateRunRequirements(ao, aoc.getInstalledAddOns());
         if (!reqs.isRunnable()) {
             ao.setInstallationStatus(AddOn.InstallationStatus.NOT_INSTALLED);
@@ -597,7 +622,7 @@ public class AddOnLoader extends URLClassLoader {
             }
             AddOnInstaller.uninstallAddOnFiles(ao, NULL_CALLBACK, runnableAddOns.keySet());
             removeAddOnClassLoader(ao);
-            deleteAddOnFile(ao, upgrading);
+            deleteAddOn(ao, upgrading);
             ao.setInstallationStatus(AddOn.InstallationStatus.UNINSTALLATION_FAILED);
             Control.getSingleton().getExtensionLoader().addOnUninstalled(ao, false);
             return false;
@@ -613,7 +638,7 @@ public class AddOnLoader extends URLClassLoader {
                 saveAddOnsRunState(runnableAddOns);
             }
 
-            deleteAddOnFile(ao, upgrading);
+            deleteAddOn(ao, upgrading);
 
             return this.aoc.removeAddOn(ao);
         }
@@ -632,7 +657,7 @@ public class AddOnLoader extends URLClassLoader {
             removeAddOnClassLoader(ao);
         }
 
-        deleteAddOnFile(ao, upgrading);
+        deleteAddOn(ao, upgrading);
 
         if (runnableAddOns.remove(ao) != null) {
             saveAddOnsRunState(runnableAddOns);
@@ -647,7 +672,19 @@ public class AddOnLoader extends URLClassLoader {
         return uninstalledWithoutErrors;
     }
 
-    private void deleteAddOnFile(AddOn addOn, boolean upgrading) {
+    /**
+     * Deletes the file and libraries of the given add-on.
+     *
+     * <p>The add-on is added to the {@link #blockList block list} when not able to delete it and if
+     * not updating it.
+     *
+     * @param addOn the add-on to be deleted.
+     * @param upgrading {@code true} if the add-on is being updated, {@code false} otherwise.
+     * @see AddOnInstaller#uninstallAddOnLibs(AddOn)
+     */
+    private void deleteAddOn(AddOn addOn, boolean upgrading) {
+        AddOnInstaller.uninstallAddOnLibs(addOn);
+
         if (addOn.getFile() != null && addOn.getFile().exists()) {
             if (!addOn.getFile().delete() && !upgrading) {
                 logger.debug("Cant delete " + addOn.getFile().getAbsolutePath());
diff --git a/zap/src/main/java/org/zaproxy/zap/control/AddOnRunIssuesUtils.java b/zap/src/main/java/org/zaproxy/zap/control/AddOnRunIssuesUtils.java
index 6e8c4e648..1e9f1006c 100644
--- a/zap/src/main/java/org/zaproxy/zap/control/AddOnRunIssuesUtils.java
+++ b/zap/src/main/java/org/zaproxy/zap/control/AddOnRunIssuesUtils.java
@@ -152,7 +152,7 @@ public final class AddOnRunIssuesUtils {
     }
 
     /**
-     * Returns the textual representations of the running issues (Java version and dependency), if
+     * Returns the textual representations of the running issues (e.g. Java version, dependency), if
      * any.
      *
      * <p>The messages are internationalised thus suitable for UI components.
@@ -166,7 +166,19 @@ public final class AddOnRunIssuesUtils {
      */
     public static List<String> getUiRunningIssues(
             AddOn.BaseRunRequirements requirements, AddOnSearcher addOnSearcher) {
-        List<String> issues = new ArrayList<>(2);
+        List<String> issues = new ArrayList<>(3);
+        if (requirements.hasMissingLibs()) {
+            if (requirements.getAddOn() != requirements.getAddOnMissingLibs()) {
+                issues.add(
+                        Constant.messages.getString(
+                                "cfu.warn.addon.with.missing.requirements.libs.dependency",
+                                requirements.getAddOnMissingLibs().getName()));
+            } else {
+                issues.add(
+                        Constant.messages.getString(
+                                "cfu.warn.addon.with.missing.requirements.libs"));
+            }
+        }
         if (requirements.isNewerJavaVersionRequired()) {
             if (requirements.getAddOn() != requirements.getAddOnMinimumJavaVersion()) {
                 issues.add(
@@ -279,7 +291,7 @@ public final class AddOnRunIssuesUtils {
     }
 
     /**
-     * Returns the textual representations of the running issues (Java version and dependency), if
+     * Returns the textual representations of the running issues (e.g. Java version, dependency), if
      * any.
      *
      * <p>The messages are not internationalised, should be used only for logging and non UI uses.
@@ -291,8 +303,12 @@ public final class AddOnRunIssuesUtils {
      * @see #getUiExtensionsRunningIssues(AddOn.AddOnRunRequirements, AddOnSearcher)
      */
     public static List<String> getRunningIssues(AddOn.BaseRunRequirements requirements) {
-        List<String> issues = new ArrayList<>(2);
-        String issue = getJavaVersionIssue(requirements);
+        List<String> issues = new ArrayList<>(3);
+        String issue = getMissingLibsIssue(requirements);
+        if (issue != null) {
+            issues.add(issue);
+        }
+        issue = getJavaVersionIssue(requirements);
         if (issue != null) {
             issues.add(issue);
         }
@@ -350,6 +366,29 @@ public final class AddOnRunIssuesUtils {
                 "Minimum Java version: {0}", requirements.getMinimumJavaVersion());
     }
 
+    /**
+     * Returns the textual representation of the missing libraries issue that prevents the add-on or
+     * extension from being run, if any.
+     *
+     * <p>The message is not internationalised, should be used only for logging and non UI uses.
+     *
+     * @param requirements the run requirements of the add-on or extension
+     * @return a {@code String} representing the running issue, {@code null} if none.
+     * @since TODO add version
+     */
+    public static String getMissingLibsIssue(AddOn.BaseRunRequirements requirements) {
+        if (!requirements.hasMissingLibs()) {
+            return null;
+        }
+
+        if (requirements.getAddOn() != requirements.getAddOnMissingLibs()) {
+            return MessageFormat.format(
+                    "Bundled libraries of dependency: {0}",
+                    requirements.getAddOnMissingLibs().getName());
+        }
+        return "Bundled libraries.";
+    }
+
     /**
      * Returns the textual representation of the issue that prevents the add-on or extension from
      * being run, if any.
diff --git a/zap/src/main/java/org/zaproxy/zap/control/ZapAddOnXmlFile.java b/zap/src/main/java/org/zaproxy/zap/control/ZapAddOnXmlFile.java
index 3bb4ef883..69ac18241 100644
--- a/zap/src/main/java/org/zaproxy/zap/control/ZapAddOnXmlFile.java
+++ b/zap/src/main/java/org/zaproxy/zap/control/ZapAddOnXmlFile.java
@@ -37,6 +37,8 @@ public class ZapAddOnXmlFile extends BaseZapAddOnXmlData {
     private static final String PSCANRULES_ALL_ELEMENTS = "pscanrules/" + PSCANRULE_ELEMENT;
     private static final String FILE_ELEMENT = "file";
     private static final String FILES_ALL_ELEMENTS = "files/" + FILE_ELEMENT;
+    private static final String LIB_ELEMENT = "lib";
+    private static final String LIBS_ALL_ELEMENTS = "libs/" + LIB_ELEMENT;
     private static final String BUNDLE_ELEMENT = "bundle";
     private static final String BUNDLE_PREFIX_ATT = "bundle/@prefix";
     private static final String HELPSET_ELEMENT = "helpset";
@@ -45,6 +47,7 @@ public class ZapAddOnXmlFile extends BaseZapAddOnXmlData {
     private List<String> ascanrules;
     private List<String> pscanrules;
     private List<String> files;
+    private List<String> libs;
 
     private String bundleBaseName;
     private String bundlePrefix;
@@ -60,6 +63,7 @@ public class ZapAddOnXmlFile extends BaseZapAddOnXmlData {
         ascanrules = getStrings(zapAddOnXml, ASCANRULES_ALL_ELEMENTS, ASCANRULE_ELEMENT);
         pscanrules = getStrings(zapAddOnXml, PSCANRULES_ALL_ELEMENTS, PSCANRULE_ELEMENT);
         files = getStrings(zapAddOnXml, FILES_ALL_ELEMENTS, FILE_ELEMENT);
+        libs = getStrings(zapAddOnXml, LIBS_ALL_ELEMENTS, LIB_ELEMENT);
 
         bundleBaseName = zapAddOnXml.getString(BUNDLE_ELEMENT, "");
         bundlePrefix = zapAddOnXml.getString(BUNDLE_PREFIX_ATT, "");
@@ -79,6 +83,16 @@ public class ZapAddOnXmlFile extends BaseZapAddOnXmlData {
         return files;
     }
 
+    /**
+     * Gets the libraries of the add-on.
+     *
+     * @return the libraries, never {@code null}.
+     * @since TODO add version
+     */
+    public List<String> getLibs() {
+        return libs;
+    }
+
     /**
      * Gets the base name of the bundle.
      *
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/AddOnDependencyChecker.java b/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/AddOnDependencyChecker.java
index 85929b3b4..932c92f66 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/AddOnDependencyChecker.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/AddOnDependencyChecker.java
@@ -119,7 +119,7 @@ class AddOnDependencyChecker {
             Set<AddOn> newVersions,
             Set<AddOn> installs) {
         AddOn.AddOnRunRequirements requirements =
-                addOn.calculateRunRequirements(availableAddOns.getAddOns());
+                addOn.calculateInstallRequirements(availableAddOns.getAddOns());
 
         for (AddOn dep : requirements.getDependencies()) {
             if (selectedAddOns.contains(dep)) {
@@ -496,7 +496,7 @@ class AddOnDependencyChecker {
 
         for (AddOn addOn : remainingInstalledAddOns) {
             if (addOn.dependsOn(changedAddOns)
-                    && addOn.calculateRunRequirements(expectedInstalledAddOns)
+                    && addOn.calculateInstallRequirements(expectedInstalledAddOns)
                             .hasDependencyIssue()) {
                 uninstalls.add(addOn);
             }
@@ -519,7 +519,7 @@ class AddOnDependencyChecker {
             AddOn addOn = it.next();
             if (contains(installs, addOn)
                     || contains(newVersions, addOn)
-                    || (addOn.calculateRunRequirements(installedAddOns.getAddOns())
+                    || (addOn.calculateInstallRequirements(installedAddOns.getAddOns())
                                     .hasDependencyIssue()
                             && !containsAny(addOn.getIdsAddOnDependencies(), uninstalls))) {
                 it.remove();
@@ -545,7 +545,8 @@ class AddOnDependencyChecker {
             List<String> extensionsWithDeps = addOn.getExtensionsWithDeps();
             for (Extension extension : addOn.getLoadedExtensionsWithDeps()) {
                 AddOn.AddOnRunRequirements requirements =
-                        addOn.calculateExtensionRunRequirements(extension, expectedInstalledAddOns);
+                        addOn.calculateExtensionInstallRequirements(
+                                extension, expectedInstalledAddOns);
                 AddOn.ExtensionRunRequirements extReqs =
                         requirements.getExtensionRequirements().get(0);
                 if (!extReqs.isRunnable()) {
@@ -558,7 +559,7 @@ class AddOnDependencyChecker {
 
             for (String classname : extensionsWithDeps) {
                 AddOn.AddOnRunRequirements requirements =
-                        addOn.calculateExtensionRunRequirements(
+                        addOn.calculateExtensionInstallRequirements(
                                 classname, availableAddOns.getAddOns());
                 AddOn.ExtensionRunRequirements extReqs =
                         requirements.getExtensionRequirements().get(0);
@@ -602,7 +603,7 @@ class AddOnDependencyChecker {
         while (!addOnsToCheck.isEmpty()) {
             AddOn addOn = addOnsToCheck.remove(0);
             AddOn.AddOnRunRequirements requirements =
-                    addOn.calculateRunRequirements(remainingAddOns);
+                    addOn.calculateInstallRequirements(remainingAddOns);
 
             if (!requirements.hasDependencyIssue()) {
                 addOnsToCheck.removeAll(requirements.getDependencies());
@@ -614,7 +615,7 @@ class AddOnDependencyChecker {
 
         for (Iterator<AddOn> it = uninstallations.iterator(); it.hasNext(); ) {
             AddOn addOn = it.next();
-            if (addOn.calculateRunRequirements(installedAddOns.getAddOns()).hasDependencyIssue()
+            if (addOn.calculateInstallRequirements(installedAddOns.getAddOns()).hasDependencyIssue()
                     && !containsAny(addOn.getIdsAddOnDependencies(), uninstallations)) {
                 it.remove();
             }
@@ -626,7 +627,7 @@ class AddOnDependencyChecker {
             if (addOn.hasExtensionsWithDeps()) {
                 for (Extension ext : addOn.getLoadedExtensions()) {
                     AddOn.AddOnRunRequirements requirements =
-                            addOn.calculateExtensionRunRequirements(ext, remainingAddOns);
+                            addOn.calculateExtensionInstallRequirements(ext, remainingAddOns);
                     if (!requirements.getExtensionRequirements().isEmpty()) {
                         AddOn.ExtensionRunRequirements extReqs =
                                 requirements.getExtensionRequirements().get(0);
diff --git a/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/ExtensionAutoUpdate.java b/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/ExtensionAutoUpdate.java
index bc2233f10..587aed825 100644
--- a/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/ExtensionAutoUpdate.java
+++ b/zap/src/main/java/org/zaproxy/zap/extension/autoupdate/ExtensionAutoUpdate.java
@@ -358,6 +358,10 @@ public class ExtensionAutoUpdate extends ExtensionAdaptor
                             Constant.messages.getString(
                                     "cfu.warn.invalidAddOn.invalidManifest", e.getMessage()));
                     break;
+                case INVALID_LIB:
+                    showWarningMessageInvalidAddOnFile(
+                            Constant.messages.getString("cfu.warn.invalidAddOn.invalidLib"));
+                    break;
                 default:
                     showWarningMessageInvalidAddOnFile(e.getMessage());
                     logger.warn(e);
@@ -426,7 +430,7 @@ public class ExtensionAutoUpdate extends ExtensionAdaptor
 
         if (result.getOldVersions().isEmpty() && result.getUninstalls().isEmpty()) {
             AddOnRunRequirements reqs =
-                    ao.calculateRunRequirements(getLocalVersionInfo().getAddOns());
+                    ao.calculateInstallRequirements(getLocalVersionInfo().getAddOns());
             if (!reqs.isRunnable()) {
                 if (!AddOnRunIssuesUtils.askConfirmationAddOnNotRunnable(
                         Constant.messages.getString("cfu.warn.addOnNotRunnable.message"),
diff --git a/zap/src/main/resources/org/zaproxy/zap/resources/Messages.properties b/zap/src/main/resources/org/zaproxy/zap/resources/Messages.properties
index 668ab4b76..b839cf495 100644
--- a/zap/src/main/resources/org/zaproxy/zap/resources/Messages.properties
+++ b/zap/src/main/resources/org/zaproxy/zap/resources/Messages.properties
@@ -1088,6 +1088,8 @@ cfu.warn.addon.with.missing.requirements.addon = A cyclic dependency was detecte
 cfu.warn.addon.with.missing.requirements.addon = Add-on "{0}"
 cfu.warn.addon.with.missing.requirements.addon.id = Add-On with ID "{0}"
 cfu.warn.addon.with.missing.requirements.addon.version = Add-on "{0}" with version matching "{1}" (found version {2})
+cfu.warn.addon.with.missing.requirements.libs = Bundled libraries
+cfu.warn.addon.with.missing.requirements.libs.dependency = Bundled libraries of dependency: "{0}"
 cfu.warn.addon.with.missing.requirements.unknown = Unknown (refer to log file for more information)
 cfu.warn.addon.with.missing.requirements.javaversion = Minimum Java version: {0} (found: "{1}")
 cfu.warn.addon.with.missing.requirements.javaversion.dependency = Minimum Java version: {0} (found: "{1}") by dependency: "{2}"
@@ -1098,6 +1100,7 @@ cfu.warn.addOnNotRunnable.message = The add-on will not run until the following
 cfu.warn.addOnNotRunnable.question = Continue with the installation?
 cfu.warn.cantload      = Can not load the specified add-on\:\nNot before \= {0}\nNot from \= {1}
 cfu.warn.invalidAddOn = The selected file is not a valid ZAP add-on{0}
+cfu.warn.invalidAddOn.invalidLib = .\nIt declared missing/invalid library.
 cfu.warn.invalidAddOn.invalidPath = :\nThe path is not valid.
 cfu.warn.invalidAddOn.noZapExtension = :\nThe file does not have a "zap" extension.
 cfu.warn.invalidAddOn.notReadable = :\nThe file is not readable.
diff --git a/zap/src/test/java/org/zaproxy/zap/control/AddOnUnitTest.java b/zap/src/test/java/org/zaproxy/zap/control/AddOnUnitTest.java
index 35720b55c..d98ea1b52 100644
--- a/zap/src/test/java/org/zaproxy/zap/control/AddOnUnitTest.java
+++ b/zap/src/test/java/org/zaproxy/zap/control/AddOnUnitTest.java
@@ -19,15 +19,19 @@
  */
 package org.zaproxy.zap.control;
 
+import static org.hamcrest.Matchers.contains;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.notNullValue;
+import static org.hamcrest.Matchers.nullValue;
 import static org.junit.Assert.*;
 import static org.junit.Assume.assumeTrue;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.net.URL;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
@@ -37,6 +41,7 @@ import java.nio.file.attribute.PosixFileAttributes;
 import java.nio.file.attribute.PosixFilePermission;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Set;
 import java.util.function.Consumer;
 import java.util.zip.ZipEntry;
@@ -475,6 +480,42 @@ public class AddOnUnitTest extends TestUtils {
         assertThat(result.getException(), is(notNullValue()));
     }
 
+    @Test
+    public void shouldNotBeValidAddOnIfHasMissingLib() throws Exception {
+        // Given
+        Path file =
+                createAddOnFile(
+                        "addon.zap",
+                        "release",
+                        "1.0.0",
+                        manifest ->
+                                manifest.append("<libs>")
+                                        .append("<lib>missing.jar</lib>")
+                                        .append("</libs>"));
+        // When
+        ValidationResult result = AddOn.isValidAddOn(file);
+        // Then
+        assertThat(result.getValidity(), is(equalTo(ValidationResult.Validity.INVALID_LIB)));
+    }
+
+    @Test
+    public void shouldNotBeValidAddOnIfHasLibWithMissingName() throws Exception {
+        // Given
+        Path file =
+                createAddOnFile(
+                        "addon.zap",
+                        "release",
+                        "1.0.0",
+                        manifest ->
+                                manifest.append("<libs>")
+                                        .append("<lib>dir/</lib>")
+                                        .append("</libs>"));
+        // When
+        ValidationResult result = AddOn.isValidAddOn(file);
+        // Then
+        assertThat(result.getValidity(), is(equalTo(ValidationResult.Validity.INVALID_LIB)));
+    }
+
     @Test
     public void shouldBeValidAddOnIfValid() throws Exception {
         // Given
@@ -865,6 +906,100 @@ public class AddOnUnitTest extends TestUtils {
         assertThat(canRun, is(equalTo(false)));
     }
 
+    @Test
+    public void shouldReturnLibsInManifest() throws Exception {
+        // Given
+        String lib1 = "lib1.jar";
+        String lib2 = "dir/lib2.jar";
+        Path file = createAddOnWithLibs(lib1, lib2);
+        // When
+        AddOn addOn = new AddOn(file);
+        // Then
+        assertThat(addOn.getLibs(), contains(new AddOn.Lib(lib1), new AddOn.Lib(lib2)));
+    }
+
+    @Test
+    public void shouldNotBeRunnableIfLibsAreNotInFileSystem() throws Exception {
+        // Given
+        AddOn addOn = new AddOn(createAddOnWithLibs("lib1.jar", "lib2.jar"));
+        // When
+        AddOn.AddOnRunRequirements reqs = addOn.calculateRunRequirements(Collections.emptyList());
+        // Then
+        assertThat(reqs.isRunnable(), is(equalTo(false)));
+        assertThat(reqs.hasMissingLibs(), is(equalTo(true)));
+        assertThat(reqs.getAddOnMissingLibs(), is(equalTo(addOn)));
+    }
+
+    @Test
+    public void shouldBeRunnableIfLibsAreInFileSystem() throws Exception {
+        // Given
+        String lib1 = "lib1.jar";
+        String lib2 = "lib2.jar";
+        AddOn addOn = new AddOn(createAddOnWithLibs(lib1, lib2));
+        File libsDir = tempDir.newFolder();
+        addOn.getLibs().get(0).setFileSystemUrl(new File(libsDir, lib1).toURI().toURL());
+        addOn.getLibs().get(1).setFileSystemUrl(new File(libsDir, lib2).toURI().toURL());
+        // When
+        AddOn.AddOnRunRequirements reqs = addOn.calculateRunRequirements(Collections.emptyList());
+        // Then
+        assertThat(reqs.isRunnable(), is(equalTo(true)));
+        assertThat(reqs.hasMissingLibs(), is(equalTo(false)));
+        assertThat(reqs.getAddOnMissingLibs(), is(nullValue()));
+    }
+
+    @Test
+    public void shouldCreateAddOnLibFromRootJarPath() throws Exception {
+        // Given
+        String jarPath = "lib.jar";
+        // When
+        AddOn.Lib lib = new AddOn.Lib(jarPath);
+        // Then
+        assertThat(lib.getJarPath(), is(equalTo(jarPath)));
+        assertThat(lib.getName(), is(equalTo(jarPath)));
+    }
+
+    @Test
+    public void shouldCreateAddOnLibFromNonRootJarPath() throws Exception {
+        // Given
+        String name = "lib.jar";
+        String jarPath = "dir/" + name;
+        // When
+        AddOn.Lib lib = new AddOn.Lib(jarPath);
+        // Then
+        assertThat(lib.getJarPath(), is(equalTo(jarPath)));
+        assertThat(lib.getName(), is(equalTo(name)));
+    }
+
+    @Test
+    public void shouldNotHaveFileSystemUrlInAddOnLibByDefault() throws Exception {
+        // Given / When
+        AddOn.Lib lib = new AddOn.Lib("lib.jar");
+        // Then
+        assertThat(lib.getFileSystemUrl(), is(nullValue()));
+    }
+
+    @Test
+    public void shouldSetFileSystemUrlToAddOnLib() throws Exception {
+        // Given
+        AddOn.Lib lib = new AddOn.Lib("lib.jar");
+        URL fsUrl = new URL("file:///some/path");
+        // When
+        lib.setFileSystemUrl(fsUrl);
+        // Then
+        assertThat(lib.getFileSystemUrl(), is(equalTo(fsUrl)));
+    }
+
+    @Test
+    public void shouldSetNullFileSystemUrlToAddOnLib() throws Exception {
+        // Given
+        AddOn.Lib lib = new AddOn.Lib("lib.jar");
+        lib.setFileSystemUrl(new URL("file:///some/path"));
+        // When
+        lib.setFileSystemUrl(null);
+        // Then
+        assertThat(lib.getFileSystemUrl(), is(nullValue()));
+    }
+
     private static ZapXmlConfiguration createZapVersionsXml() throws Exception {
         ZapXmlConfiguration zapVersionsXml = new ZapXmlConfiguration(ZAP_VERSIONS_XML);
         zapVersionsXml.setExpressionEngine(new XPathExpressionEngine());
@@ -881,13 +1016,44 @@ public class AddOnUnitTest extends TestUtils {
         }
     }
 
+    private Path createAddOnWithLibs(String... libs) {
+        String lib1 = "lib1.jar";
+        String lib2 = "dir/lib2.jar";
+        return createAddOnFile(
+                "addon.zap",
+                "release",
+                "1.0.0",
+                manifest ->
+                        manifest.append("<libs>")
+                                .append("<lib>")
+                                .append(lib1)
+                                .append("</lib>")
+                                .append("<lib>")
+                                .append(lib2)
+                                .append("</lib>")
+                                .append("</libs>"),
+                addOnContents -> {
+                    try {
+                        ZipEntry lib = new ZipEntry(lib1);
+                        addOnContents.putNextEntry(lib);
+                        addOnContents.closeEntry();
+
+                        lib = new ZipEntry(lib2);
+                        addOnContents.putNextEntry(lib);
+                        addOnContents.closeEntry();
+                    } catch (IOException e) {
+                        throw new UncheckedIOException(e);
+                    }
+                });
+    }
+
     private Path createAddOnFile(String fileName, String status, String version) {
         return createAddOnFile(fileName, status, version, (String) null);
     }
 
     private Path createAddOnFile(
             String fileName, String status, String version, String javaVersion) {
-        return createAddOnFile(fileName, status, version, javaVersion, null);
+        return createAddOnFile(fileName, status, version, javaVersion, null, null);
     }
 
     private Path createAddOnFile(
@@ -895,7 +1061,16 @@ public class AddOnUnitTest extends TestUtils {
             String status,
             String version,
             Consumer<StringBuilder> manifestConsumer) {
-        return createAddOnFile(fileName, status, version, null, manifestConsumer);
+        return createAddOnFile(fileName, status, version, null, manifestConsumer, null);
+    }
+
+    private Path createAddOnFile(
+            String fileName,
+            String status,
+            String version,
+            Consumer<StringBuilder> manifestConsumer,
+            Consumer<ZipOutputStream> addOnConsumer) {
+        return createAddOnFile(fileName, status, version, null, manifestConsumer, addOnConsumer);
     }
 
     private Path createAddOnFile(
@@ -903,7 +1078,8 @@ public class AddOnUnitTest extends TestUtils {
             String status,
             String version,
             String javaVersion,
-            Consumer<StringBuilder> manifestConsumer) {
+            Consumer<StringBuilder> manifestConsumer,
+            Consumer<ZipOutputStream> addOnConsumer) {
         try {
             File file = new File(tempDir.newFolder(), fileName);
             try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(file))) {
@@ -925,6 +1101,9 @@ public class AddOnUnitTest extends TestUtils {
                 byte[] bytes = strBuilder.toString().getBytes(StandardCharsets.UTF_8);
                 zos.write(bytes, 0, bytes.length);
                 zos.closeEntry();
+                if (addOnConsumer != null) {
+                    addOnConsumer.accept(zos);
+                }
             }
             return file.toPath();
         } catch (IOException e) {
diff --git a/zap/src/test/java/org/zaproxy/zap/control/ZapAddOnXmlFileUnitTest.java b/zap/src/test/java/org/zaproxy/zap/control/ZapAddOnXmlFileUnitTest.java
index ca68a36a3..4b30c54a9 100644
--- a/zap/src/test/java/org/zaproxy/zap/control/ZapAddOnXmlFileUnitTest.java
+++ b/zap/src/test/java/org/zaproxy/zap/control/ZapAddOnXmlFileUnitTest.java
@@ -86,6 +86,7 @@ public class ZapAddOnXmlFileUnitTest {
         assertThat(manifest.getAscanrules(), is(empty()));
         assertThat(manifest.getPscanrules(), is(empty()));
         assertThat(manifest.getFiles(), is(empty()));
+        assertThat(manifest.getLibs(), is(empty()));
     }
 
     @Test
@@ -184,6 +185,25 @@ public class ZapAddOnXmlFileUnitTest {
         assertThat(manifest.getHelpSetLocaleToken(), is(equalTo(helpSetLocaleToken)));
     }
 
+    @Test
+    public void shouldLoadManifestWithLibs() throws Exception {
+        // Given
+        String lib1 = "lib1.jar";
+        String lib2 = "dir/lib2.jar";
+        InputStream manifestData =
+                manifestData(
+                        "<zapaddon>",
+                        "<libs>",
+                        "  <lib>" + lib1 + "</lib>",
+                        "  <lib>" + lib2 + "</lib>",
+                        "</libs>",
+                        "</zapaddon>");
+        // When
+        ZapAddOnXmlFile manifest = new ZapAddOnXmlFile(manifestData);
+        // Then
+        assertThat(manifest.getLibs(), contains(lib1, lib2));
+    }
+
     @Test
     public void shouldLoadManifestWithDependencies() throws Exception {
         // Given
