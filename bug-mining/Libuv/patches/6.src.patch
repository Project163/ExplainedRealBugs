diff --git a/uv-unix.c b/uv-unix.c
index 5f6295e4..f468228c 100644
--- a/uv-unix.c
+++ b/uv-unix.c
@@ -1180,3 +1180,14 @@ int uv_timer_again(uv_handle_t* handle) {
   ev_timer_again(EV_DEFAULT_UC_ &handle->timer_watcher);
   return 0;
 }
+
+void uv_timer_set_repeat(uv_handle_t* handle, int64_t repeat) {
+  assert(handle->type == UV_TIMER);
+  handle->timer_watcher.repeat = repeat / 1000.0;
+}
+
+int64_t uv_timer_get_repeat(uv_handle_t* handle) {
+  assert(handle->type == UV_TIMER);
+  return (int64_t)(1000 * handle->timer_watcher.repeat);
+}
+
diff --git a/uv-win.c b/uv-win.c
index c8fddfe5..7923f4bf 100644
--- a/uv-win.c
+++ b/uv-win.c
@@ -1278,13 +1278,14 @@ int uv_timer_again(uv_handle_t* handle) {
 }
 
 
-int uv_timer_set_repeat(uv_handle_t* handle, int64_t repeat) {
+void uv_timer_set_repeat(uv_handle_t* handle, int64_t repeat) {
+  assert(handle->type == UV_TIMER);
   handle->repeat = repeat;
-  return 0;
 }
 
 
 int64_t uv_timer_get_repeat(uv_handle_t* handle) {
+  assert(handle->type == UV_TIMER);
   return handle->repeat;
 }
 
diff --git a/uv.h b/uv.h
index d0104e2a..cf425b4b 100644
--- a/uv.h
+++ b/uv.h
@@ -224,16 +224,19 @@ int uv_write(uv_req_t* req, uv_buf_t bufs[], int bufcnt);
 int uv_timer_init(uv_handle_t* handle, uv_close_cb close_cb, void* data);
 int uv_timer_start(uv_handle_t* handle, uv_loop_cb cb, int64_t timeout, int64_t repeat);
 int uv_timer_stop(uv_handle_t* handle);
-/* Stop the timer, and if it is repeating restart it using the repeat value 
+/*
+ * Stop the timer, and if it is repeating restart it using the repeat value 
  * as the timeout. If the timer has never been started before it returns -1 and
- * sets the error to UV_EINVAL. */
+ * sets the error to UV_EINVAL.
+ */
 int uv_timer_again(uv_handle_t* handle);
-/* Set the repeat value. Note that if the repeat value is set from a timer
+/*
+ * Set the repeat value. Note that if the repeat value is set from a timer
  * callback it does not immediately take effect. If the timer was nonrepeating
  * before, it will have been stopped. If it was repeating, then the old repeat
  * value will have been used to schedule the next timeout.
  */
-int uv_timer_set_repeat(uv_handle_t* handle, int64_t repeat);
+void uv_timer_set_repeat(uv_handle_t* handle, int64_t repeat);
 int64_t uv_timer_get_repeat(uv_handle_t* handle);
 
 /* libev wrapper. Every active prepare handle gets its callback called
