diff --git a/msvs/libuv-test.vcxproj b/msvs/libuv-test.vcxproj
index 49538f69..f772f640 100644
--- a/msvs/libuv-test.vcxproj
+++ b/msvs/libuv-test.vcxproj
@@ -148,6 +148,7 @@
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\test\test-async.c" />
+    <ClCompile Include="..\test\test-bind6-error.c" />
     <ClCompile Include="..\test\test-delayed-accept.c" />
     <ClCompile Include="..\test\test-callback-stack.c" />
     <ClCompile Include="..\test\test-connection-fail.c" />
diff --git a/test/test-bind6-error.c b/test/test-bind6-error.c
new file mode 100644
index 00000000..e3db4813
--- /dev/null
+++ b/test/test-bind6-error.c
@@ -0,0 +1,164 @@
+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include "../uv.h"
+#include "task.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+
+static int close_cb_called = 0;
+
+
+static void close_cb(uv_handle_t* handle) {
+  ASSERT(handle != NULL);
+  close_cb_called++;
+}
+
+
+TEST_IMPL(bind6_error_addrinuse) {
+  struct sockaddr_in6 addr = uv_ip6_addr("::", TEST_PORT);
+  uv_tcp_t server1, server2;
+  int r;
+
+  uv_init();
+
+  r = uv_tcp_init(&server1);
+  ASSERT(r == 0);
+  r = uv_bind6(&server1, addr);
+  ASSERT(r == 0);
+
+  r = uv_tcp_init(&server2);
+  ASSERT(r == 0);
+  r = uv_bind6(&server2, addr);
+  ASSERT(r == 0);
+
+  r = uv_listen(&server1, 128, NULL);
+  ASSERT(r == 0);
+  r = uv_listen(&server2, 128, NULL);
+  ASSERT(r == -1);
+
+  ASSERT(uv_last_error().code == UV_EADDRINUSE);
+
+  uv_close((uv_handle_t*)&server1, close_cb);
+  uv_close((uv_handle_t*)&server2, close_cb);
+
+  uv_run();
+
+  ASSERT(close_cb_called == 2);
+
+  return 0;
+}
+
+
+TEST_IMPL(bind6_error_addrnotavail) {
+  struct sockaddr_in6 addr = uv_ip6_addr("4:4:4:4:4:4:4:4", TEST_PORT);
+  uv_tcp_t server;
+  int r;
+
+  uv_init();
+
+  r = uv_tcp_init(&server);
+  ASSERT(r == 0);
+  r = uv_bind6(&server, addr);
+  ASSERT(r == -1);
+  ASSERT(uv_last_error().code == UV_EADDRNOTAVAIL);
+
+  uv_close((uv_handle_t*)&server, close_cb);
+
+  uv_run();
+
+  ASSERT(close_cb_called == 1);
+
+  return 0;
+}
+
+
+TEST_IMPL(bind6_error_fault) {
+  char garbage[] = "blah blah blah blah blah blah blah blah blah blah blah blah";
+  struct sockaddr_in6* garbage_addr;
+  uv_tcp_t server;
+  int r;
+
+  garbage_addr = (struct sockaddr_in6*) &garbage;
+
+  uv_init();
+
+  r = uv_tcp_init(&server);
+  ASSERT(r == 0);
+  r = uv_bind6(&server, *garbage_addr);
+  ASSERT(r == -1);
+
+  ASSERT(uv_last_error().code == UV_EFAULT);
+
+  uv_close((uv_handle_t*)&server, close_cb);
+
+  uv_run();
+
+  ASSERT(close_cb_called == 1);
+
+  return 0;
+}
+
+/* Notes: On Linux uv_bind6(server, NULL) will segfault the program.  */
+
+TEST_IMPL(bind6_error_inval) {
+  struct sockaddr_in6 addr1 = uv_ip6_addr("::", TEST_PORT);
+  struct sockaddr_in6 addr2 = uv_ip6_addr("::", TEST_PORT_2);
+  uv_tcp_t server;
+  int r;
+
+  uv_init();
+
+  r = uv_tcp_init(&server);
+  ASSERT(r == 0);
+  r = uv_bind6(&server, addr1);
+  ASSERT(r == 0);
+  r = uv_bind6(&server, addr2);
+  ASSERT(r == -1);
+
+  ASSERT(uv_last_error().code == UV_EINVAL);
+
+  uv_close((uv_handle_t*)&server, close_cb);
+
+  uv_run();
+
+  ASSERT(close_cb_called == 1);
+
+  return 0;
+}
+
+
+TEST_IMPL(bind6_localhost_ok) {
+  struct sockaddr_in6 addr = uv_ip6_addr("::1", TEST_PORT);
+
+  uv_tcp_t server;
+  int r;
+
+  uv_init();
+
+  r = uv_tcp_init(&server);
+  ASSERT(r == 0);
+  r = uv_bind6(&server, addr);
+  ASSERT(r == 0);
+
+  return 0;
+}
diff --git a/test/test-list.h b/test/test-list.h
index dace1948..ddedfa1b 100644
--- a/test/test-list.h
+++ b/test/test-list.h
@@ -28,6 +28,11 @@ TEST_DECLARE   (bind_error_addrnotavail_2)
 TEST_DECLARE   (bind_error_fault)
 TEST_DECLARE   (bind_error_inval)
 TEST_DECLARE   (bind_localhost_ok)
+TEST_DECLARE   (bind6_error_addrinuse)
+TEST_DECLARE   (bind6_error_addrnotavail)
+TEST_DECLARE   (bind6_error_fault)
+TEST_DECLARE   (bind6_error_inval)
+TEST_DECLARE   (bind6_localhost_ok)
 TEST_DECLARE   (connection_fail)
 TEST_DECLARE   (connection_fail_doesnt_auto_close)
 TEST_DECLARE   (shutdown_eof)
@@ -61,17 +66,18 @@ TASK_LIST_START
   TEST_HELPER (tcp_writealot, echo_server)
 
   TEST_ENTRY  (bind_error_addrinuse)
-
   TEST_ENTRY  (bind_error_addrnotavail_1)
-
   TEST_ENTRY  (bind_error_addrnotavail_2)
-
   TEST_ENTRY  (bind_error_fault)
-
   TEST_ENTRY  (bind_error_inval)
-
   TEST_ENTRY  (bind_localhost_ok)
 
+  TEST_ENTRY  (bind6_error_addrinuse)
+  TEST_ENTRY  (bind6_error_addrnotavail)
+  TEST_ENTRY  (bind6_error_fault)
+  TEST_ENTRY  (bind6_error_inval)
+  TEST_ENTRY  (bind6_localhost_ok)
+
   TEST_ENTRY  (connection_fail)
   TEST_ENTRY  (connection_fail_doesnt_auto_close)
 
diff --git a/uv-common.c b/uv-common.c
index 49d3b8b7..bda6c658 100644
--- a/uv-common.c
+++ b/uv-common.c
@@ -25,6 +25,10 @@
 #include <stddef.h> /* NULL */
 #include <string.h> /* memset */
 
+/* use inet_pton from c-ares if necessary */
+#include "ares_config.h"
+#include "c-ares/inet_net_pton.h"
+
 
 static uv_counters_t counters;
 
@@ -89,3 +93,16 @@ struct sockaddr_in uv_ip4_addr(const char* ip, int port) {
 
   return addr;
 }
+
+
+struct sockaddr_in6 uv_ip6_addr(const char* ip, int port) {
+  struct sockaddr_in6 addr;
+
+  memset(&addr, 0, sizeof(struct sockaddr_in6));
+
+  addr.sin6_family = AF_INET6;
+  addr.sin6_port = htons(port);
+  ares_inet_pton(AF_INET6, ip, &addr.sin6_addr);
+
+  return addr;
+}
diff --git a/uv-unix.c b/uv-unix.c
index e604721b..60f28964 100644
--- a/uv-unix.c
+++ b/uv-unix.c
@@ -235,13 +235,11 @@ int uv_tcp_init(uv_tcp_t* tcp) {
 }
 
 
-int uv_bind(uv_tcp_t* tcp, struct sockaddr_in addr) {
-  int addrsize = sizeof(struct sockaddr_in);
-  int domain = AF_INET;
+int uv__bind(uv_tcp_t* tcp, int domain, struct sockaddr* addr, int addrsize) {
   int r;
 
   if (tcp->fd <= 0) {
-    int fd = socket(AF_INET, SOCK_STREAM, 0);
+    int fd = socket(domain, SOCK_STREAM, 0);
 
     if (fd < 0) {
       uv_err_new((uv_handle_t*)tcp, errno);
@@ -256,12 +254,7 @@ int uv_bind(uv_tcp_t* tcp, struct sockaddr_in addr) {
 
   assert(tcp->fd >= 0);
 
-  if (addr.sin_family != AF_INET) {
-    uv_err_new((uv_handle_t*)tcp, EFAULT);
-    return -1;
-  }
-
-  r = bind(tcp->fd, (struct sockaddr*) &addr, addrsize);
+  r = bind(tcp->fd, addr, addrsize);
   tcp->delayed_error = 0;
 
   if (r) {
@@ -280,6 +273,26 @@ int uv_bind(uv_tcp_t* tcp, struct sockaddr_in addr) {
 }
 
 
+int uv_bind(uv_tcp_t* tcp, struct sockaddr_in addr) {
+  if (addr.sin_family != AF_INET) {
+    uv_err_new((uv_handle_t*)tcp, EFAULT);
+    return -1;
+  }
+
+  return uv__bind(tcp, AF_INET, (struct sockaddr*)&addr, sizeof(struct sockaddr_in));
+}
+
+
+int uv_bind6(uv_tcp_t* tcp, struct sockaddr_in6 addr) {
+  if (addr.sin6_family != AF_INET6) {
+    uv_err_new((uv_handle_t*)tcp, EFAULT);
+    return -1;
+  }
+
+  return uv__bind(tcp, AF_INET6, (struct sockaddr*)&addr, sizeof(struct sockaddr_in6));
+}
+
+
 int uv_tcp_open(uv_tcp_t* tcp, int fd) {
   int yes;
   int r;
@@ -313,8 +326,8 @@ int uv_tcp_open(uv_tcp_t* tcp, int fd) {
 
 void uv__server_io(EV_P_ ev_io* watcher, int revents) {
   int fd;
-  struct sockaddr addr;
-  socklen_t addrlen;
+  struct sockaddr_storage addr;
+  socklen_t addrlen = sizeof(struct sockaddr_storage);
   uv_tcp_t* tcp = watcher->data;
 
   assert(watcher == &tcp->read_watcher ||
@@ -330,7 +343,7 @@ void uv__server_io(EV_P_ ev_io* watcher, int revents) {
 
   while (1) {
     assert(tcp->accepted_fd < 0);
-    fd = accept(tcp->fd, &addr, &addrlen);
+    fd = accept(tcp->fd, (struct sockaddr*)&addr, &addrlen);
 
     if (fd < 0) {
       if (errno == EAGAIN) {
diff --git a/uv-win.c b/uv-win.c
index 82b6d9d5..7eddb8ad 100644
--- a/uv-win.c
+++ b/uv-win.c
@@ -748,19 +748,13 @@ int uv_close(uv_handle_t* handle, uv_close_cb close_cb) {
 }
 
 
-int uv_bind(uv_tcp_t* handle, struct sockaddr_in addr) {
+int uv__bind(uv_tcp_t* handle, int domain, struct sockaddr* addr, int addrsize) {
   DWORD err;
   int r;
   SOCKET sock;
-  int addrsize = sizeof(struct sockaddr_in);
-
-  if (addr.sin_family != AF_INET) {
-    uv_set_sys_error(WSAEFAULT);
-    return -1;
-  }
 
   if (handle->socket == INVALID_SOCKET) {
-    sock = socket(AF_INET, SOCK_STREAM, 0);
+    sock = socket(domain, SOCK_STREAM, 0);
     if (sock == INVALID_SOCKET) {
       uv_set_sys_error(WSAGetLastError());
       return -1;
@@ -772,7 +766,7 @@ int uv_bind(uv_tcp_t* handle, struct sockaddr_in addr) {
     }
   }
 
-  r = bind(handle->socket, (struct sockaddr*) &addr, addrsize);
+  r = bind(handle->socket, addr, addrsize);
 
   if (r == SOCKET_ERROR) {
     err = WSAGetLastError();
@@ -792,6 +786,26 @@ int uv_bind(uv_tcp_t* handle, struct sockaddr_in addr) {
 }
 
 
+int uv_bind(uv_tcp_t* handle, struct sockaddr_in addr) {
+  if (addr.sin_family != AF_INET) {
+    uv_set_sys_error(WSAEFAULT);
+    return -1;
+  }
+
+  return uv__bind(handle, AF_INET, (struct sockaddr*)&addr, sizeof(struct sockaddr_in));
+}
+
+
+int uv_bind6(uv_tcp_t* handle, struct sockaddr_in6 addr) {
+  if (addr.sin6_family != AF_INET6) {
+    uv_set_sys_error(WSAEFAULT);
+    return -1;
+  }
+
+  return uv__bind(handle, AF_INET6, (struct sockaddr*)&addr, sizeof(struct sockaddr_in6));
+}
+
+
 static void uv_queue_accept(uv_tcp_t* handle) {
   uv_req_t* req;
   BOOL success;
diff --git a/uv.h b/uv.h
index f7c54995..37956b44 100644
--- a/uv.h
+++ b/uv.h
@@ -223,6 +223,7 @@ struct uv_tcp_s {
 int uv_tcp_init(uv_tcp_t* handle);
 
 int uv_bind(uv_tcp_t* handle, struct sockaddr_in);
+int uv_bind6(uv_tcp_t* handle, struct sockaddr_in6);
 
 int uv_connect(uv_req_t* req, struct sockaddr_in);
 
@@ -453,6 +454,7 @@ int64_t uv_now();
 
 /* Utility */
 struct sockaddr_in uv_ip4_addr(const char* ip, int port);
+struct sockaddr_in6 uv_ip6_addr(const char* ip, int port);
 
 /* Gets the executable path */
 int uv_get_exepath(char* buffer, size_t* size);
