diff --git a/oio-unix.c b/oio-unix.c
index 196952f5..162ef69f 100644
--- a/oio-unix.c
+++ b/oio-unix.c
@@ -26,7 +26,6 @@
 #include <stdlib.h>
 #include <errno.h>
 #include <assert.h>
-#include <string.h> /* strnlen */
 #include <unistd.h>
 #include <fcntl.h>
 
@@ -35,17 +34,6 @@
 #include <arpa/inet.h>
 
 
-#ifndef strnlen
-size_t strnlen (register const char* s, size_t maxlen) {
-  register const char *e;
-  size_t n;
-
-  for (e = s, n = 0; *e && n < maxlen; e++, n++);
-  return n;
-}
-#endif  /* strnlen */
-
-
 void oio_tcp_io(EV_P_ ev_io* watcher, int revents);
 void oio__next(EV_P_ ev_idle* watcher, int revents);
 void oio_tcp_connect(oio_handle* handle);
@@ -527,6 +515,8 @@ int oio_connect(oio_req *req, struct sockaddr* addr) {
 }
 
 
+/* The buffers to be written must remain valid until the callback is called. */
+/* This is not required for the oio_buf array. */
 int oio_write(oio_req *req, oio_buf* bufs, int bufcnt) {
   oio_handle* handle = req->handle;
   assert(handle->fd >= 0);
@@ -552,15 +542,6 @@ int oio_write(oio_req *req, oio_buf* bufs, int bufcnt) {
 }
 
 
-int oio_write2(oio_req* req, const char* msg) {
-  size_t len = strnlen(msg, 1024 * 1024);
-  oio_buf b;
-  b.base = (char*)msg;
-  b.len = len;
-  return oio_write(req, &b, 1);
-}
-
-
 void oio__timeout(EV_P_ ev_timer* watcher, int revents) {
   oio_req* req = watcher->data;
   assert(watcher == &req->timer);
diff --git a/oio-win.c b/oio-win.c
index 297c0d61..3767a943 100644
--- a/oio-win.c
+++ b/oio-win.c
@@ -660,16 +660,6 @@ int oio_read(oio_req *req, oio_buf* bufs, int bufcnt) {
 }
 
 
-int oio_write2(oio_req *req, const char* msg) {
-  oio_buf buf;
-
-  buf.base = (char*)msg;
-  buf.len = strlen(msg);
-
-  return oio_write(req, &buf, 1);
-}
-
-
 int oio_last_error() {
   return oio_errno_;
 }
diff --git a/oio.h b/oio.h
index 21247c3a..6e6e2de2 100644
--- a/oio.h
+++ b/oio.h
@@ -131,10 +131,11 @@ int oio_listen(oio_handle* handle, int backlog, oio_accept_cb cb);
 int oio_accept(oio_handle* server, oio_handle* client,
     oio_close_cb close_cb, void* data);
 
-/* Generic handle methods */
+/* Generic read/write methods. */
+/* The buffers to be written or read into must remain valid until the */
+/* callback is called. The oio_buf array does need not remain valid! */
 int oio_read(oio_req* req, oio_buf* bufs, int bufcnt);
 int oio_write(oio_req* req, oio_buf* bufs, int bufcnt);
-int oio_write2(oio_req *req, const char* msg);
 
 /* Timer methods */
 int oio_timeout(oio_req *req, int64_t timeout);
diff --git a/test/benchmark-ping-pongs.c b/test/benchmark-ping-pongs.c
index 93f287de..dcecd73a 100644
--- a/test/benchmark-ping-pongs.c
+++ b/test/benchmark-ping-pongs.c
@@ -70,12 +70,16 @@ void pinger_after_write(oio_req *req) {
 
 static void pinger_write_ping(pinger_t* pinger) {
   oio_req *req;
+  oio_buf buf;
+
+  buf.base = (char*)&PING;
+  buf.len = strlen(PING);
 
   req = (oio_req*)malloc(sizeof(*req));
   oio_req_init(req, &pinger->handle, pinger_after_write);
 
-  if (oio_write2(req, (char*)&PING)) {
-    FATAL("oio_write2 failed");
+  if (oio_write(req, &buf, 1)) {
+    FATAL("oio_write failed");
   }
 }
 
diff --git a/test/test-callback-stack.c b/test/test-callback-stack.c
index 9bca8aa2..08dbcdcc 100644
--- a/test/test-callback-stack.c
+++ b/test/test-callback-stack.c
@@ -19,7 +19,7 @@
  * IN THE SOFTWARE.
  */
 
-/* 
+/*
  * TODO: Add explanation of why we want on_close to be called from fresh
  * stack.
  */
diff --git a/test/test-ping-pong.c b/test/test-ping-pong.c
index a1c93c62..89e4483e 100644
--- a/test/test-ping-pong.c
+++ b/test/test-ping-pong.c
@@ -67,12 +67,16 @@ void pinger_after_write(oio_req *req) {
 
 static void pinger_write_ping(pinger_t* pinger) {
   oio_req *req;
+  oio_buf buf;
+
+  buf.base = (char*)&PING;
+  buf.len = strlen(PING);
 
   req = (oio_req*)malloc(sizeof(*req));
   oio_req_init(req, &pinger->handle, pinger_after_write);
 
-  if (oio_write2(req, (char*)&PING)) {
-    FATAL("oio_write2 failed");
+  if (oio_write(req, &buf, 1)) {
+    FATAL("oio_write failed");
   }
 
   puts("PING");
