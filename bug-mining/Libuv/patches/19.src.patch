diff --git a/include/uv-private/uv-win.h b/include/uv-private/uv-win.h
index 7ede6882..365eff6b 100644
--- a/include/uv-private/uv-win.h
+++ b/include/uv-private/uv-win.h
@@ -300,6 +300,7 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);
   int req_pending;                        \
   uv_fs_event_cb cb;                      \
   wchar_t* filew;                         \
+  wchar_t* short_filew;                   \
   int is_path_dir;                        \
   char* buffer;
 
diff --git a/src/win/fs-event.c b/src/win/fs-event.c
index 69cd62d6..aec7cafd 100644
--- a/src/win/fs-event.c
+++ b/src/win/fs-event.c
@@ -41,7 +41,8 @@ static void uv_fs_event_init_handle(uv_loop_t* loop, uv_fs_event_t* handle,
   handle->buffer = NULL;
   handle->req_pending = 0;
   handle->filew = NULL;
-  
+  handle->short_filew = NULL;
+
   uv_req_init(loop, (uv_req_t*)&handle->req);
   handle->req.type = UV_FS_EVENT_REQ;
   handle->req.data = (void*)handle;
@@ -95,25 +96,29 @@ static int uv_split_path(const wchar_t* filename, wchar_t** dir,
   while (i > 0 && filename[--i] != '\\' && filename[i] != '/');
 
   if (i == 0) {
-    *dir = (wchar_t*)malloc((MAX_PATH + 1) * sizeof(wchar_t));
-    if (!*dir) {
-      uv_fatal_error(ERROR_OUTOFMEMORY, "malloc");
-    }
-
-    if (!GetCurrentDirectoryW(MAX_PATH, *dir)) {
-      free(*dir);
-      *dir = NULL;
-      return -1;
+    if (dir) {
+      *dir = (wchar_t*)malloc((MAX_PATH + 1) * sizeof(wchar_t));
+      if (!*dir) {
+        uv_fatal_error(ERROR_OUTOFMEMORY, "malloc");
+      }
+
+      if (!GetCurrentDirectoryW(MAX_PATH, *dir)) {
+        free(*dir);
+        *dir = NULL;
+        return -1;
+      }
     }
     
     *file = wcsdup(filename);
   } else {
-    *dir = (wchar_t*)malloc((i + 1) * sizeof(wchar_t));
-    if (!*dir) {
-      uv_fatal_error(ERROR_OUTOFMEMORY, "malloc");
+    if (dir) {
+      *dir = (wchar_t*)malloc((i + 1) * sizeof(wchar_t));
+      if (!*dir) {
+        uv_fatal_error(ERROR_OUTOFMEMORY, "malloc");
+      }
+      wcsncpy(*dir, filename, i);
+      (*dir)[i] = L'\0';
     }
-    wcsncpy(*dir, filename, i);
-    (*dir)[i] = L'\0';
 
     *file = (wchar_t*)malloc((len - i) * sizeof(wchar_t));
     if (!*file) {
@@ -132,6 +137,7 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,
   int name_size;
   DWORD attr, last_error;
   wchar_t* dir = NULL, *dir_to_watch, *filenamew;
+  wchar_t short_path[MAX_PATH];
 
   uv_fs_event_init_handle(loop, handle, filename, cb);
 
@@ -165,11 +171,23 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,
      * filename is a file.  So we split filename into dir & file parts, and
      * watch the dir directory.
      */
+    
+    /* Convert to short path. */
+    if (!GetShortPathNameW(filenamew, short_path, COUNTOF(short_path))) {
+      last_error = GetLastError();
+      goto error;
+    }
+
     if (uv_split_path(filenamew, &dir, &handle->filew) != 0) {
       last_error = GetLastError();
       goto error;
     }
 
+    if (uv_split_path(short_path, NULL, &handle->short_filew) != 0) {
+      last_error = GetLastError();
+      goto error;
+    }
+
     dir_to_watch = dir;
   }
 
@@ -194,9 +212,9 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,
   }
 
   if (CreateIoCompletionPort(handle->dir_handle,
-                              loop->iocp,
-                              (ULONG_PTR)handle,
-                              0) == NULL) {
+                             loop->iocp,
+                             (ULONG_PTR)handle,
+                             0) == NULL) {
     last_error = GetLastError();
     goto error;
   }
@@ -242,6 +260,11 @@ error:
     handle->filew = NULL;
   }
 
+  if (handle->short_filew) {
+    free(handle->short_filew);
+    handle->short_filew = NULL;
+  }
+
   if (handle->dir_handle != INVALID_HANDLE_VALUE) {
     CloseHandle(handle->dir_handle);
     handle->dir_handle = INVALID_HANDLE_VALUE;
@@ -279,8 +302,11 @@ void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,
          * Fire the event only if we were asked to watch a directory,
          * or if the filename filter matches.
          */
-        if (handle->is_path_dir || _wcsnicmp(handle->filew, file_info->FileName,
-          file_info->FileNameLength / sizeof(wchar_t)) == 0) {
+        if (handle->is_path_dir ||
+          _wcsnicmp(handle->filew, file_info->FileName,
+            file_info->FileNameLength / sizeof(wchar_t)) == 0 ||
+          _wcsnicmp(handle->short_filew, file_info->FileName,
+            file_info->FileNameLength / sizeof(wchar_t)) == 0) {
         
           /* Convert the filename to utf8. */
           utf8size = uv_utf16_to_utf8(file_info->FileName,
@@ -370,6 +396,11 @@ void uv_fs_event_endgame(uv_loop_t* loop, uv_fs_event_t* handle) {
       handle->filew = NULL;
     }
 
+    if (handle->short_filew) {
+      free(handle->short_filew);
+      handle->short_filew = NULL;
+    }
+
     if (handle->filename) {
       free(handle->filename);
       handle->filename = NULL;
