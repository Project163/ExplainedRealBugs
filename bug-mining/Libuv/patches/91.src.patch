diff --git a/src/win/fs.c b/src/win/fs.c
index e732cd24..b90eaa75 100644
--- a/src/win/fs.c
+++ b/src/win/fs.c
@@ -1085,7 +1085,8 @@ cleanup:
 }
 
 
-INLINE static int fs__stat_handle(HANDLE handle, uv_stat_t* statbuf) {
+INLINE static int fs__stat_handle(HANDLE handle, uv_stat_t* statbuf,
+    int do_lstat) {
   FILE_ALL_INFORMATION file_info;
   FILE_FS_VOLUME_INFORMATION volume_info;
   NTSTATUS nt_status;
@@ -1140,17 +1141,25 @@ INLINE static int fs__stat_handle(HANDLE handle, uv_stat_t* statbuf) {
    */
   statbuf->st_mode = 0;
 
-  if (file_info.BasicInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
+  /*
+  * On Windows, FILE_ATTRIBUTE_REPARSE_POINT is a general purpose mechanism
+  * by which filesystem drivers can intercept and alter file system requests.
+  *
+  * The only reparse points we care about are symlinks and mount points, both
+  * of which are treated as POSIX symlinks. Further, we only care when
+  * invoked via lstat, which seeks information about the link instead of its
+  * target. Otherwise, reparse points must be treated as regular files.
+  */
+  if (do_lstat &&
+      (file_info.BasicInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
     /*
-     * It is possible for a file to have FILE_ATTRIBUTE_REPARSE_POINT but not have
-     * any link data. In that case DeviceIoControl() in fs__readlink_handle() sets
-     * the last error to ERROR_NOT_A_REPARSE_POINT. Then the stat result mode
-     * calculated below will indicate a normal directory or file, as if
-     * FILE_ATTRIBUTE_REPARSE_POINT was not present.
+     * If reading the link fails, the reparse point is not a symlink and needs
+     * to be treated as a regular file. The higher level lstat function will
+     * detect this failure and retry without do_lstat if appropriate.
      */
-    if (fs__readlink_handle(handle, NULL, &statbuf->st_size) == 0) {
-      statbuf->st_mode |= S_IFLNK;
-    }
+    if (fs__readlink_handle(handle, NULL, &statbuf->st_size) != 0)
+      return -1;
+    statbuf->st_mode |= S_IFLNK;
   }
 
   if (statbuf->st_mode == 0) {
@@ -1249,9 +1258,11 @@ INLINE static void fs__stat_impl(uv_fs_t* req, int do_lstat) {
     return;
   }
 
-  if (fs__stat_handle(handle, &req->statbuf) != 0) {
+  if (fs__stat_handle(handle, &req->statbuf, do_lstat) != 0) {
     DWORD error = GetLastError();
-    if (do_lstat && error == ERROR_SYMLINK_NOT_SUPPORTED) {
+    if (do_lstat &&
+        (error == ERROR_SYMLINK_NOT_SUPPORTED ||
+         error == ERROR_NOT_A_REPARSE_POINT)) {
       /* We opened a reparse point but it was not a symlink. Try again. */
       fs__stat_impl(req, 0);
 
@@ -1295,7 +1306,7 @@ static void fs__fstat(uv_fs_t* req) {
     return;
   }
 
-  if (fs__stat_handle(handle, &req->statbuf) != 0) {
+  if (fs__stat_handle(handle, &req->statbuf, 0) != 0) {
     SET_REQ_WIN32_ERROR(req, GetLastError());
     return;
   }
diff --git a/test/test-fs.c b/test/test-fs.c
index 0000e563..6afa6507 100644
--- a/test/test-fs.c
+++ b/test/test-fs.c
@@ -115,6 +115,17 @@ static char test_buf[] = "test-buffer\n";
 static char test_buf2[] = "second-buffer\n";
 static uv_buf_t iov;
 
+#ifdef _WIN32
+/*
+ * This tag and guid have no special meaning, and don't conflict with
+ * reserved ids.
+*/
+static unsigned REPARSE_TAG = 0x9913;
+static GUID REPARSE_GUID = {
+  0x1bf6205f, 0x46ae, 0x4527,
+  0xb1, 0x0c, 0xc5, 0x09, 0xb7, 0x55, 0x22, 0x80 };
+#endif
+
 static void check_permission(const char* filename, unsigned int mode) {
   int r;
   uv_fs_t req;
@@ -1991,6 +2002,109 @@ TEST_IMPL(fs_symlink_dir) {
 }
 
 
+#ifdef _WIN32
+TEST_IMPL(fs_non_symlink_reparse_point) {
+  uv_fs_t req;
+  int r;
+  HANDLE file_handle;
+  REPARSE_GUID_DATA_BUFFER reparse_buffer;
+  DWORD bytes_returned;
+  uv_dirent_t dent;
+
+  /* set-up */
+  unlink("test_dir/test_file");
+  rmdir("test_dir");
+
+  loop = uv_default_loop();
+
+  uv_fs_mkdir(NULL, &req, "test_dir", 0777, NULL);
+  uv_fs_req_cleanup(&req);
+
+  file_handle = CreateFile("test_dir/test_file",
+                           GENERIC_WRITE | FILE_WRITE_ATTRIBUTES,
+                           0,
+                           NULL,
+                           CREATE_ALWAYS,
+                           FILE_FLAG_OPEN_REPARSE_POINT |
+                             FILE_FLAG_BACKUP_SEMANTICS,
+                           NULL);
+  ASSERT(file_handle != INVALID_HANDLE_VALUE);
+
+  memset(&reparse_buffer, 0, REPARSE_GUID_DATA_BUFFER_HEADER_SIZE);
+  reparse_buffer.ReparseTag = REPARSE_TAG;
+  reparse_buffer.ReparseDataLength = 0;
+  reparse_buffer.ReparseGuid = REPARSE_GUID;
+
+  r = DeviceIoControl(file_handle,
+                      FSCTL_SET_REPARSE_POINT,
+                      &reparse_buffer,
+                      REPARSE_GUID_DATA_BUFFER_HEADER_SIZE,
+                      NULL,
+                      0,
+                      &bytes_returned,
+                      NULL);
+  ASSERT(r != 0);
+
+  CloseHandle(file_handle);
+
+  r = uv_fs_readlink(NULL, &req, "test_dir/test_file", NULL);
+  ASSERT(r == UV_EINVAL && GetLastError() == ERROR_SYMLINK_NOT_SUPPORTED);
+  uv_fs_req_cleanup(&req);
+
+/*
+  Placeholder tests for exercising the behavior fixed in issue #995.
+  To run, update the path with the IP address of a Mac with the hard drive
+  shared via SMB as "Macintosh HD".
+
+  r = uv_fs_stat(NULL, &req, "\\\\<mac_ip>\\Macintosh HD\\.DS_Store", NULL);
+  ASSERT(r == 0);
+  uv_fs_req_cleanup(&req);
+
+  r = uv_fs_lstat(NULL, &req, "\\\\<mac_ip>\\Macintosh HD\\.DS_Store", NULL);
+  ASSERT(r == 0);
+  uv_fs_req_cleanup(&req);
+*/
+
+/*
+  uv_fs_stat and uv_fs_lstat can only work on non-symlink reparse
+  points when a minifilter driver is registered which intercepts
+  associated filesystem requests. Installing a driver is beyond
+  the scope of this test.
+
+  r = uv_fs_stat(NULL, &req, "test_dir/test_file", NULL);
+  ASSERT(r == 0);
+  uv_fs_req_cleanup(&req);
+
+  r = uv_fs_lstat(NULL, &req, "test_dir/test_file", NULL);
+  ASSERT(r == 0);
+  uv_fs_req_cleanup(&req);
+*/
+
+  r = uv_fs_scandir(NULL, &scandir_req, "test_dir", 0, NULL);
+  ASSERT(r == 1);
+  ASSERT(scandir_req.result == 1);
+  ASSERT(scandir_req.ptr);
+  while (UV_EOF != uv_fs_scandir_next(&scandir_req, &dent)) {
+    ASSERT(strcmp(dent.name, "test_file") == 0);
+    /* uv_fs_scandir incorrectly identifies non-symlink reparse points
+       as links because it doesn't open the file and verify the reparse
+       point tag. The PowerShell Get-ChildItem command shares this
+       behavior, so it's reasonable to leave it as is. */
+    ASSERT(dent.type == UV_DIRENT_LINK);
+  }
+  uv_fs_req_cleanup(&scandir_req);
+  ASSERT(!scandir_req.ptr);
+
+  /* clean-up */
+  unlink("test_dir/test_file");
+  rmdir("test_dir");
+
+  MAKE_VALGRIND_HAPPY();
+  return 0;
+}
+#endif
+
+
 TEST_IMPL(fs_utime) {
   utime_check_t checkme;
   const char* path = "test_file";
diff --git a/test/test-list.h b/test/test-list.h
index 0dde57c2..59d45568 100644
--- a/test/test-list.h
+++ b/test/test-list.h
@@ -282,6 +282,9 @@ TEST_DECLARE   (fs_readlink)
 TEST_DECLARE   (fs_realpath)
 TEST_DECLARE   (fs_symlink)
 TEST_DECLARE   (fs_symlink_dir)
+#ifdef _WIN32
+TEST_DECLARE   (fs_non_symlink_reparse_point)
+#endif
 TEST_DECLARE   (fs_utime)
 TEST_DECLARE   (fs_futime)
 TEST_DECLARE   (fs_file_open_append)
@@ -790,6 +793,9 @@ TASK_LIST_START
   TEST_ENTRY  (fs_realpath)
   TEST_ENTRY  (fs_symlink)
   TEST_ENTRY  (fs_symlink_dir)
+#ifdef _WIN32
+  TEST_ENTRY  (fs_non_symlink_reparse_point)
+#endif
   TEST_ENTRY  (fs_stat_missing_path)
   TEST_ENTRY  (fs_read_file_eof)
   TEST_ENTRY  (fs_file_open_append)
