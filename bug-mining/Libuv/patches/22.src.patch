diff --git a/include/uv.h b/include/uv.h
index fb4e40ab..f4ff6a3a 100644
--- a/include/uv.h
+++ b/include/uv.h
@@ -115,7 +115,8 @@ typedef intptr_t ssize_t;
   XX( 45, EAISOCKTYPE, "") \
   XX( 46, ESHUTDOWN, "") \
   XX( 47, EEXIST, "file already exists") \
-  XX( 48, ESRCH, "no such process")
+  XX( 48, ESRCH, "no such process") \
+  XX( 49, ENAMETOOLONG, "name too long")
 
 
 #define UV_ERRNO_GEN(val, name, s) UV_##name = val,
diff --git a/src/unix/error.c b/src/unix/error.c
index e904d390..80d3270d 100644
--- a/src/unix/error.c
+++ b/src/unix/error.c
@@ -71,6 +71,7 @@ uv_err_code uv_translate_sys_error(int sys_errno) {
     case EFAULT: return UV_EFAULT;
     case EMFILE: return UV_EMFILE;
     case EMSGSIZE: return UV_EMSGSIZE;
+    case ENAMETOOLONG: return UV_ENAMETOOLONG;
     case EINVAL: return UV_EINVAL;
     case ECONNREFUSED: return UV_ECONNREFUSED;
     case EADDRINUSE: return UV_EADDRINUSE;
diff --git a/test/test-fs.c b/test/test-fs.c
index 763af8a7..b8e0ee65 100644
--- a/test/test-fs.c
+++ b/test/test-fs.c
@@ -45,6 +45,7 @@
 # define close _close
 #endif
 
+#define TOO_LONG_NAME_LENGTH 8192
 
 typedef struct {
   const char* path;
@@ -416,6 +417,14 @@ static void open_noent_cb(uv_fs_t* req) {
   uv_fs_req_cleanup(req);
 }
 
+static void open_nametoolong_cb(uv_fs_t* req) {
+  ASSERT(req->fs_type == UV_FS_OPEN);
+  ASSERT(req->errorno == UV_ENAMETOOLONG);
+  ASSERT(req->result == -1);
+  open_cb_count++;
+  uv_fs_req_cleanup(req);
+}
+
 
 TEST_IMPL(fs_file_noent) {
   uv_fs_t req;
@@ -441,6 +450,31 @@ TEST_IMPL(fs_file_noent) {
   return 0;
 }
 
+TEST_IMPL(fs_file_nametoolong) {
+  uv_fs_t req;
+  int r;
+
+  loop = uv_default_loop();
+
+  char name[TOO_LONG_NAME_LENGTH + 1];
+  memset(name, 'a', TOO_LONG_NAME_LENGTH);
+  name[TOO_LONG_NAME_LENGTH] = 0;
+
+  r = uv_fs_open(loop, &req, name, O_RDONLY, 0, NULL);
+  ASSERT(r == -1);
+  ASSERT(req.result == -1);
+  ASSERT(uv_last_error(loop).code == UV_ENAMETOOLONG);
+  uv_fs_req_cleanup(&req);
+
+  r = uv_fs_open(loop, &req, name, O_RDONLY, 0, open_nametoolong_cb);
+  ASSERT(r == 0);
+
+  ASSERT(open_cb_count == 0);
+  uv_run(loop);
+  ASSERT(open_cb_count == 1);
+
+  return 0;
+}
 
 static void check_utime(const char* path, double atime, double mtime) {
   struct stat* s;
@@ -1543,4 +1577,4 @@ TEST_IMPL(fs_rename_to_existing_file) {
   unlink("test_file2");
 
   return 0;
-}
\ No newline at end of file
+}
diff --git a/test/test-list.h b/test/test-list.h
index 5ff16230..fa9390f9 100644
--- a/test/test-list.h
+++ b/test/test-list.h
@@ -103,6 +103,7 @@ TEST_DECLARE   (spawn_and_kill)
 TEST_DECLARE   (spawn_and_ping)
 TEST_DECLARE   (kill)
 TEST_DECLARE   (fs_file_noent)
+TEST_DECLARE   (fs_file_nametoolong)
 TEST_DECLARE   (fs_file_async)
 TEST_DECLARE   (fs_file_sync)
 TEST_DECLARE   (fs_async_dir)
@@ -269,6 +270,7 @@ TASK_LIST_START
 #endif
 
   TEST_ENTRY  (fs_file_noent)
+  TEST_ENTRY  (fs_file_nametoolong)
   TEST_ENTRY  (fs_file_async)
   TEST_ENTRY  (fs_file_sync)
   TEST_ENTRY  (fs_async_dir)
