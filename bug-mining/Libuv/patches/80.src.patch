diff --git a/Makefile.am b/Makefile.am
index 97847ce2..0589e921 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -221,6 +221,7 @@ test_run_tests_SOURCES = test/blackhole-server.c \
                          test/test-udp-options.c \
                          test/test-udp-send-and-recv.c \
                          test/test-udp-send-immediate.c \
+                         test/test-udp-send-unreachable.c \
                          test/test-udp-try-send.c \
                          test/test-walk-handles.c \
                          test/test-watcher-cross-stop.c
diff --git a/src/win/udp.c b/src/win/udp.c
index aabb7817..99fd80fc 100644
--- a/src/win/udp.c
+++ b/src/win/udp.c
@@ -506,9 +506,13 @@ void uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle,
       } else if (err == WSAEWOULDBLOCK) {
         /* Kernel buffer empty */
         handle->recv_cb(handle, 0, &buf, NULL, 0);
-      } else if (err != WSAECONNRESET && err != WSAENETRESET) {
-        /* Serious error. WSAECONNRESET/WSANETRESET is ignored because this */
-        /* just indicates that a previous sendto operation failed. */
+      } else if (err == WSAECONNRESET || err == WSAENETRESET) {
+        /* WSAECONNRESET/WSANETRESET is ignored because this just indicates
+         * that a previous sendto operation failed.
+         */
+        handle->recv_cb(handle, 0, &buf, NULL, 0);
+      } else {
+        /* Any other error that we want to report back to the user. */
         uv_udp_recv_stop(handle);
         handle->recv_cb(handle, uv_translate_sys_error(err), &buf, NULL, 0);
       }
diff --git a/test/test-list.h b/test/test-list.h
index 657ac362..9d51da9a 100644
--- a/test/test-list.h
+++ b/test/test-list.h
@@ -92,6 +92,7 @@ TEST_DECLARE   (udp_bind)
 TEST_DECLARE   (udp_bind_reuseaddr)
 TEST_DECLARE   (udp_send_and_recv)
 TEST_DECLARE   (udp_send_immediate)
+TEST_DECLARE   (udp_send_unreachable)
 TEST_DECLARE   (udp_multicast_join)
 TEST_DECLARE   (udp_multicast_join6)
 TEST_DECLARE   (udp_multicast_ttl)
@@ -397,6 +398,7 @@ TASK_LIST_START
   TEST_ENTRY  (udp_bind_reuseaddr)
   TEST_ENTRY  (udp_send_and_recv)
   TEST_ENTRY  (udp_send_immediate)
+  TEST_ENTRY  (udp_send_unreachable)
   TEST_ENTRY  (udp_dgram_too_big)
   TEST_ENTRY  (udp_dual_stack)
   TEST_ENTRY  (udp_ipv6_only)
diff --git a/test/test-udp-send-unreachable.c b/test/test-udp-send-unreachable.c
new file mode 100644
index 00000000..c6500320
--- /dev/null
+++ b/test/test-udp-send-unreachable.c
@@ -0,0 +1,150 @@
+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include "uv.h"
+#include "task.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define CHECK_HANDLE(handle) \
+  ASSERT((uv_udp_t*)(handle) == &client)
+
+static uv_udp_t client;
+static uv_timer_t timer;
+
+static int send_cb_called;
+static int recv_cb_called;
+static int close_cb_called;
+static int alloc_cb_called;
+static int timer_cb_called;
+
+
+static void alloc_cb(uv_handle_t* handle,
+                     size_t suggested_size,
+                     uv_buf_t* buf) {
+  static char slab[65536];
+  CHECK_HANDLE(handle);
+  ASSERT(suggested_size <= sizeof(slab));
+  buf->base = slab;
+  buf->len = sizeof(slab);
+  alloc_cb_called++;
+}
+
+
+static void close_cb(uv_handle_t* handle) {
+  ASSERT(1 == uv_is_closing(handle));
+  close_cb_called++;
+}
+
+
+static void send_cb(uv_udp_send_t* req, int status) {
+  ASSERT(req != NULL);
+  ASSERT(status == 0);
+  CHECK_HANDLE(req->handle);
+  send_cb_called++;
+}
+
+
+static void recv_cb(uv_udp_t* handle,
+                       ssize_t nread,
+                       const uv_buf_t* rcvbuf,
+                       const struct sockaddr* addr,
+                       unsigned flags) {
+  CHECK_HANDLE(handle);
+  recv_cb_called++;
+
+  if (nread < 0) {
+    ASSERT(0 && "unexpected error");
+  } else if (nread == 0) {
+    /* Returning unused buffer */
+    ASSERT(addr == NULL);
+  } else {
+    ASSERT(addr != NULL);
+  }
+}
+
+
+static void timer_cb(uv_timer_t* h) {
+  ASSERT(h == &timer);
+  timer_cb_called++;
+  uv_close((uv_handle_t*) &client, close_cb);
+  uv_close((uv_handle_t*) h, close_cb);
+}
+
+
+TEST_IMPL(udp_send_unreachable) {
+  struct sockaddr_in addr;
+  struct sockaddr_in addr2;
+  uv_udp_send_t req1, req2;
+  uv_buf_t buf;
+  int r;
+
+  ASSERT(0 == uv_ip4_addr("127.0.0.1", TEST_PORT, &addr));
+  ASSERT(0 == uv_ip4_addr("127.0.0.1", TEST_PORT_2, &addr2));
+
+  r = uv_timer_init( uv_default_loop(), &timer );
+  ASSERT(r == 0);
+
+  r = uv_timer_start( &timer, timer_cb, 1000, 0 );
+  ASSERT(r == 0);
+
+  r = uv_udp_init(uv_default_loop(), &client);
+  ASSERT(r == 0);
+
+  r = uv_udp_bind(&client, (const struct sockaddr*) &addr2, 0);
+  ASSERT(r == 0);
+
+  r = uv_udp_recv_start(&client, alloc_cb, recv_cb);
+  ASSERT(r == 0);
+
+  /* client sends "PING", then "PANG" */
+  buf = uv_buf_init("PING", 4);
+
+  r = uv_udp_send(&req1,
+                  &client,
+                  &buf,
+                  1,
+                  (const struct sockaddr*) &addr,
+                  send_cb);
+  ASSERT(r == 0);
+
+  buf = uv_buf_init("PANG", 4);
+
+  r = uv_udp_send(&req2,
+                  &client,
+                  &buf,
+                  1,
+                  (const struct sockaddr*) &addr,
+                  send_cb);
+  ASSERT(r == 0);
+
+  uv_run(uv_default_loop(), UV_RUN_DEFAULT);
+
+  ASSERT(send_cb_called == 2);
+  ASSERT(recv_cb_called == alloc_cb_called);
+  ASSERT(timer_cb_called == 1);
+  ASSERT(close_cb_called == 2);
+
+  MAKE_VALGRIND_HAPPY();
+  return 0;
+}
diff --git a/uv.gyp b/uv.gyp
index eabeab2e..f741042a 100644
--- a/uv.gyp
+++ b/uv.gyp
@@ -399,6 +399,7 @@
         'test/test-udp-options.c',
         'test/test-udp-send-and-recv.c',
         'test/test-udp-send-immediate.c',
+        'test/test-udp-send-unreachable.c',
         'test/test-udp-multicast-join.c',
         'test/test-udp-multicast-join6.c',
         'test/test-dlerror.c',
