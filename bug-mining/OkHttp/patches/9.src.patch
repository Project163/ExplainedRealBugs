diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index d86db867c..42ddcabc3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -306,6 +306,48 @@ public class HpackDraft05Test {
     assertTrue(hpackReader.getAndReset().isEmpty());
   }
 
+  /** Ensure a later toggle of the same index emits! */
+  @Test public void toggleIndexOffOn() throws IOException {
+
+    bytesIn.writeByte(0x82); // Copy static header 1 to the header table as index 1.
+    bytesIn.writeByte(0x81); // Remove index 1 from the reference set.
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(1, hpackReader.headerCount);
+    assertTrue(hpackReader.getAndReset().isEmpty());
+
+    bytesIn.writeByte(0x81); // Add index 1 back to the reference set.
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
+  }
+
+  /** Check later toggle of the same index for large header sets. */
+  @Test public void toggleIndexOffBeyond64Entries() throws IOException {
+    int expectedHeaderCount = 65;
+
+    for (int i = 0; i < expectedHeaderCount; i++) {
+      bytesIn.writeByte(0x82 + i); // Copy static header 1 to the header table as index 1.
+      bytesIn.writeByte(0x81); // Remove index 1 from the reference set.
+    }
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(expectedHeaderCount, hpackReader.headerCount);
+    assertTrue(hpackReader.getAndReset().isEmpty());
+
+    bytesIn.writeByte(0x81); // Add index 1 back to the reference set.
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(expectedHeaderCount, hpackReader.headerCount);
+    assertHeaderReferenced(headerTableLength() - expectedHeaderCount);
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
+  }
+
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.4
    */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index f1257116d..440b6d57b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -114,6 +114,11 @@ final class HpackDraft05 {
     // Using a BitArray as it has left-shift operator.
     BitArray referencedHeaders = new BitArray.FixedCapacity();
 
+    /**
+     * Set bit positions indicate {@code headerTable[pos]} was already emitted.
+     */
+    BitArray emittedReferencedHeaders = new BitArray.FixedCapacity();
+
     /**
      * Set bit positions indicate {@code STATIC_HEADER_TABLE[pos]} should be
      * emitted.
@@ -168,6 +173,7 @@ final class HpackDraft05 {
           entriesToEvict++;
         }
         referencedHeaders.shiftLeft(entriesToEvict);
+        emittedReferencedHeaders.shiftLeft(entriesToEvict);
         System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
             nextHeaderIndex + 1 + entriesToEvict, headerCount);
         nextHeaderIndex += entriesToEvict;
@@ -209,6 +215,7 @@ final class HpackDraft05 {
     private void clearReferenceSet() {
       referencedStaticHeaders = 0L;
       referencedHeaders.clear();
+      emittedReferencedHeaders.clear();
     }
 
     void emitReferenceSet() {
@@ -218,7 +225,7 @@ final class HpackDraft05 {
         }
       }
       for (int i = headerTable.length - 1; i != nextHeaderIndex; --i) {
-        if (referencedHeaders.get(i)) {
+        if (referencedHeaders.get(i) && !emittedReferencedHeaders.get(i)) {
           emittedHeaders.add(headerTable[i]);
         }
       }
@@ -231,6 +238,7 @@ final class HpackDraft05 {
     List<Header> getAndReset() {
       List<Header> result = new ArrayList<Header>(emittedHeaders);
       emittedHeaders.clear();
+      emittedReferencedHeaders.clear();
       return result;
     }
 
@@ -243,7 +251,12 @@ final class HpackDraft05 {
           insertIntoHeaderTable(-1, staticEntry);
         }
       } else {
-        referencedHeaders.toggle(headerTableIndex(index));
+        int headerTableIndex = headerTableIndex(index);
+        if (!referencedHeaders.get(headerTableIndex)) { // When re-referencing, emit immediately.
+          emittedHeaders.add(headerTable[headerTableIndex]);
+          emittedReferencedHeaders.set(headerTableIndex);
+        }
+        referencedHeaders.toggle(headerTableIndex);
       }
     }
 
@@ -308,14 +321,17 @@ final class HpackDraft05 {
       int bytesToRecover = (headerTableByteCount + delta) - maxHeaderTableByteCount;
       int entriesEvicted = evictToRecoverBytes(bytesToRecover);
 
-      if (index == -1) {
-        if (headerCount + 1 > headerTable.length) {
+      if (index == -1) { // Adding a value to the header table.
+        if (headerCount + 1 > headerTable.length) { // Need to grow the header table.
           Header[] doubled = new Header[headerTable.length * 2];
           System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
           if (doubled.length == 64) {
             referencedHeaders = ((BitArray.FixedCapacity) referencedHeaders).toVariableCapacity();
+            emittedReferencedHeaders =
+                ((BitArray.FixedCapacity) emittedReferencedHeaders).toVariableCapacity();
           }
           referencedHeaders.shiftLeft(headerTable.length);
+          emittedReferencedHeaders.shiftLeft(headerTable.length);
           nextHeaderIndex = headerTable.length - 1;
           headerTable = doubled;
         }
