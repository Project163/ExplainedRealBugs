diff --git a/src/main/java/net/lingala/zip4j/crypto/AESDecrypter.java b/src/main/java/net/lingala/zip4j/crypto/AESDecrypter.java
index b014434..aed08c8 100755
--- a/src/main/java/net/lingala/zip4j/crypto/AESDecrypter.java
+++ b/src/main/java/net/lingala/zip4j/crypto/AESDecrypter.java
@@ -32,8 +32,6 @@ import static net.lingala.zip4j.util.InternalZipConstants.AES_BLOCK_SIZE;
  */
 public class AESDecrypter implements Decrypter {
 
-  private AESExtraDataRecord aesExtraDataRecord;
-  private char[] password;
   private AESEngine aesEngine;
   private MacBasedPRF mac;
 
@@ -42,14 +40,14 @@ public class AESDecrypter implements Decrypter {
   private byte[] counterBlock;
 
   public AESDecrypter(AESExtraDataRecord aesExtraDataRecord, char[] password, byte[] salt, byte[] passwordVerifier) throws ZipException {
-    this.aesExtraDataRecord = aesExtraDataRecord;
-    this.password = password;
     iv = new byte[AES_BLOCK_SIZE];
     counterBlock = new byte[AES_BLOCK_SIZE];
-    init(salt, passwordVerifier);
+    init(salt, passwordVerifier, password, aesExtraDataRecord);
   }
 
-  private void init(byte[] salt, byte[] passwordVerifier) throws ZipException {
+  private void init(byte[] salt, byte[] passwordVerifier, char[] password, AESExtraDataRecord aesExtraDataRecord)
+      throws ZipException {
+
     if (password == null || password.length <= 0) {
       throw new ZipException("empty or null password provided for AES decryption");
     }
diff --git a/src/main/java/net/lingala/zip4j/crypto/StandardDecrypter.java b/src/main/java/net/lingala/zip4j/crypto/StandardDecrypter.java
index 5877487..a21061b 100755
--- a/src/main/java/net/lingala/zip4j/crypto/StandardDecrypter.java
+++ b/src/main/java/net/lingala/zip4j/crypto/StandardDecrypter.java
@@ -18,21 +18,17 @@ package net.lingala.zip4j.crypto;
 
 import net.lingala.zip4j.crypto.engine.ZipCryptoEngine;
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.util.InternalZipConstants;
 
 import static net.lingala.zip4j.util.InternalZipConstants.STD_DEC_HDR_SIZE;
 
 public class StandardDecrypter implements Decrypter {
 
-  private char[] password;
-  private byte[] crcBytes;
-  private byte[] crc = new byte[4];
   private ZipCryptoEngine zipCryptoEngine;
 
-  public StandardDecrypter(char[] password, byte[] crcBytes , byte[] headerBytes) throws ZipException {
-    this.password = password;
-    this.crcBytes = crcBytes;
+  public StandardDecrypter(char[] password, long crc, long lastModifiedFileTime, byte[] headerBytes) throws ZipException {
     this.zipCryptoEngine = new ZipCryptoEngine();
-    init(headerBytes);
+    init(headerBytes, password, lastModifiedFileTime, crc);
   }
 
   public int decryptData(byte[] buff, int start, int len) throws ZipException {
@@ -50,15 +46,7 @@ public class StandardDecrypter implements Decrypter {
     return len;
   }
 
-  private void init(byte[] headerBytes) throws ZipException {
-    crc[3] = (byte) (crcBytes[3] & 0xFF);
-    crc[2] = (byte) ((crcBytes[3] >> 8) & 0xFF);
-    crc[1] = (byte) ((crcBytes[3] >> 16) & 0xFF);
-    crc[0] = (byte) ((crcBytes[3] >> 24) & 0xFF);
-
-    if (crc[2] > 0 || crc[1] > 0 || crc[0] > 0)
-      throw new IllegalStateException("Invalid CRC in File Header");
-
+  private void init(byte[] headerBytes, char[] password, long lastModifiedFileTime, long crc) throws ZipException {
     if (password == null || password.length <= 0) {
       throw new ZipException("Wrong password!", ZipException.Type.WRONG_PASSWORD);
     }
@@ -67,15 +55,18 @@ public class StandardDecrypter implements Decrypter {
 
     int result = headerBytes[0];
     for (int i = 0; i < STD_DEC_HDR_SIZE; i++) {
-//	    Commented this as this check cannot always be trusted
-//  	  New functionality: If there is an error in extracting a password protected file,
-//      "Wrong Password?" text is appended to the exception message
-//      if(i+1 == InternalZipConstants.STD_DEC_HDR_SIZE && ((byte)(result ^ zipCryptoEngine.decryptByte()) != crc[3]) && !isSplit)
-//      throw new ZipException("Wrong password!", ZipExceptionConstants.WRONG_PASSWORD);
+      if (i + 1 == InternalZipConstants.STD_DEC_HDR_SIZE) {
+        byte verificationByte = (byte) (result ^ zipCryptoEngine.decryptByte());
+        if (verificationByte != (byte) (crc >> 24) && verificationByte != (byte) (lastModifiedFileTime >> 8)) {
+          throw new ZipException("Wrong password!", ZipException.Type.WRONG_PASSWORD);
+        }
+      }
 
       zipCryptoEngine.updateKeys((byte) (result ^ zipCryptoEngine.decryptByte()));
-      if (i + 1 != STD_DEC_HDR_SIZE)
+
+      if (i + 1 != STD_DEC_HDR_SIZE) {
         result = headerBytes[i + 1];
+      }
     }
   }
 
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
index 0ad8fc0..188f027 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
@@ -169,7 +169,6 @@ public class HeaderReader {
 
       zip4jRaf.readFully(intBuff);
       fileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));
-      fileHeader.setCrcRawData(intBuff);
 
       fileHeader.setCompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));
       fileHeader.setUncompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));
@@ -549,7 +548,6 @@ public class HeaderReader {
 
     readFully(inputStream, intBuff);
     localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));
-    localFileHeader.setCrcRawData(intBuff.clone());
 
     localFileHeader.setCompressedSize(rawIO.readLongLittleEndian(inputStream, 4));
     localFileHeader.setUncompressedSize(rawIO.readLongLittleEndian(inputStream, 4));
@@ -562,9 +560,6 @@ public class HeaderReader {
     if (fileNameLength > 0) {
       byte[] fileNameBuf = new byte[fileNameLength];
       readFully(inputStream, fileNameBuf);
-      // Modified after user reported an issue http://www.lingala.net/zip4j/forum/index.php?topic=2.0
-//				String fileName = new String(fileNameBuf, "Cp850");
-//				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);
       String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);
 
       if (fileName == null) {
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index 9a17543..cba2852 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -35,7 +35,6 @@ import java.io.PushbackInputStream;
 import java.nio.charset.Charset;
 import java.util.List;
 import java.util.zip.CRC32;
-import java.util.zip.DataFormatException;
 
 import static net.lingala.zip4j.util.InternalZipConstants.MIN_BUFF_SIZE;
 import static net.lingala.zip4j.util.Zip4jUtil.getCompressionMethod;
@@ -157,8 +156,7 @@ public class ZipInputStream extends InputStream {
 
       return readLen;
     } catch (IOException e) {
-      if (e.getCause() != null && e.getCause() instanceof DataFormatException
-          && isEncryptionMethodZipStandard(localFileHeader)) {
+      if (isEncryptionMethodZipStandard(localFileHeader)) {
         throw new ZipException(e.getMessage(), e.getCause(), ZipException.Type.WRONG_PASSWORD);
       }
 
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java
index bdbcc1c..f110c76 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java
@@ -16,7 +16,8 @@ class ZipStandardCipherInputStream extends CipherInputStream<StandardDecrypter>
 
   @Override
   protected StandardDecrypter initializeDecrypter(LocalFileHeader localFileHeader, char[] password) throws IOException {
-    return new StandardDecrypter(password, localFileHeader.getCrcRawData(), getStandardDecrypterHeaderBytes());
+    return new StandardDecrypter(password, localFileHeader.getCrc(), localFileHeader.getLastModifiedTime(),
+        getStandardDecrypterHeaderBytes());
   }
 
   private byte[] getStandardDecrypterHeaderBytes() throws IOException {
diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/ZipStandardCipherOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/ZipStandardCipherOutputStream.java
index c2b20cf..4bdcc8e 100644
--- a/src/main/java/net/lingala/zip4j/io/outputstream/ZipStandardCipherOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/ZipStandardCipherOutputStream.java
@@ -1,7 +1,6 @@
 package net.lingala.zip4j.io.outputstream;
 
 import net.lingala.zip4j.crypto.StandardEncrypter;
-import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.util.Zip4jUtil;
 
@@ -10,12 +9,14 @@ import java.io.OutputStream;
 
 class ZipStandardCipherOutputStream extends CipherOutputStream<StandardEncrypter> {
 
-  public ZipStandardCipherOutputStream(ZipEntryOutputStream outputStream, ZipParameters zipParameters, char[] password) throws IOException, ZipException {
+  public ZipStandardCipherOutputStream(ZipEntryOutputStream outputStream, ZipParameters zipParameters, char[] password)
+      throws IOException {
     super(outputStream, zipParameters, password);
   }
 
   @Override
-  protected StandardEncrypter initializeEncrypter(OutputStream outputStream, ZipParameters zipParameters, char[] password) throws IOException, ZipException {
+  protected StandardEncrypter initializeEncrypter(OutputStream outputStream, ZipParameters zipParameters,
+                                                  char[] password) throws IOException {
     long key = getEncryptionKey(zipParameters);
     StandardEncrypter encrypter = new StandardEncrypter(password, key);
     writeHeaders(encrypter.getHeaderBytes());
diff --git a/src/main/java/net/lingala/zip4j/model/AbstractFileHeader.java b/src/main/java/net/lingala/zip4j/model/AbstractFileHeader.java
index 3473862..ac744b5 100644
--- a/src/main/java/net/lingala/zip4j/model/AbstractFileHeader.java
+++ b/src/main/java/net/lingala/zip4j/model/AbstractFileHeader.java
@@ -13,7 +13,6 @@ public abstract class AbstractFileHeader extends ZipHeader {
   private CompressionMethod compressionMethod;
   private long lastModifiedTime;
   private long crc = 0;
-  private byte[] crcRawData;
   private long compressedSize = 0;
   private long uncompressedSize = 0;
   private int fileNameLength;
@@ -72,14 +71,6 @@ public abstract class AbstractFileHeader extends ZipHeader {
     this.crc = crc;
   }
 
-  public byte[] getCrcRawData() {
-    return crcRawData;
-  }
-
-  public void setCrcRawData(byte[] crcRawData) {
-    this.crcRawData = crcRawData;
-  }
-
   public long getCompressedSize() {
     return compressedSize;
   }
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 1f73af4..1966a2b 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -622,6 +622,26 @@ public class ExtractZipFileIT extends AbstractIT {
     verifyNumberOfFilesInOutputFolder(outputFolder, 10);
   }
 
+  @Test
+  public void testExtractingZipStandardEncryptedZipOverLoopAlwaysThrowsWrongPasswordTypeException() throws IOException {
+    for (int i = 0; i < 1000; i++) {
+      if (generatedZipFile.exists() && !generatedZipFile.delete()) {
+        throw new RuntimeException("Could not delete test zip file");
+      }
+
+      ZipFile zipFile = new ZipFile(generatedZipFile, "password".toCharArray());
+      addFileToZip(zipFile, "sample.pdf", EncryptionMethod.ZIP_STANDARD, "password");
+
+      try {
+        zipFile = new ZipFile(generatedZipFile, "WRONG_password".toCharArray());
+        zipFile.extractAll(outputFolder.getPath());
+      } catch (ZipException e) {
+        assertThat(e).isNotNull();
+        assertThat(e.getType()).isEqualTo(ZipException.Type.WRONG_PASSWORD);
+      }
+    }
+  }
+
   private void addFileToZip(ZipFile zipFile, String fileName, EncryptionMethod encryptionMethod, String password) throws ZipException {
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setEncryptFiles(encryptionMethod != null);
