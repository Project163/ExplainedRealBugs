diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index 914b43d..0b3a8c7 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -42,9 +42,12 @@ import net.lingala.zip4j.tasks.MergeSplitZipFileTask;
 import net.lingala.zip4j.tasks.MergeSplitZipFileTask.MergeSplitZipFileTaskParameters;
 import net.lingala.zip4j.tasks.RemoveEntryFromZipFileTask;
 import net.lingala.zip4j.tasks.RemoveEntryFromZipFileTask.RemoveEntryFromZipFileTaskParameters;
+import net.lingala.zip4j.tasks.RenameFileTask;
+import net.lingala.zip4j.tasks.RenameFileTask.RenameFileTaskParameters;
 import net.lingala.zip4j.tasks.SetCommentTask;
 import net.lingala.zip4j.tasks.SetCommentTask.SetCommentTaskTaskParameters;
 import net.lingala.zip4j.util.FileUtils;
+import net.lingala.zip4j.util.RawIO;
 import net.lingala.zip4j.util.Zip4jUtil;
 
 import java.io.File;
@@ -54,6 +57,7 @@ import java.io.RandomAccessFile;
 import java.nio.charset.Charset;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
@@ -688,6 +692,52 @@ public class ZipFile {
             new RemoveEntryFromZipFileTaskParameters(fileHeader, charset));
   }
 
+  /**
+   * Renames the current entry
+   * @param fileHeader
+   * @param newFileName
+   * @throws ZipException
+   */
+  public void renameFile(FileHeader fileHeader, String newFileName) throws ZipException {
+    if (fileHeader == null) {
+      throw new ZipException("File header is null");
+    }
+
+    renameFile(fileHeader.getFileName(), newFileName);
+  }
+
+  public void renameFile(String fileNameToRename, String newFileName) throws ZipException {
+    if (!Zip4jUtil.isStringNotNullAndNotEmpty(fileNameToRename)) {
+      throw new ZipException("file name to be changed is null or empty");
+    }
+
+    if (!Zip4jUtil.isStringNotNullAndNotEmpty(newFileName)) {
+      throw new ZipException("newFileName is null or empty");
+    }
+
+    renameFiles(Collections.singletonMap(fileNameToRename, newFileName));
+  }
+
+  public void renameFiles(Map<String, String> fileNamesMap) throws ZipException {
+    if (fileNamesMap == null) {
+      throw new ZipException("fileNamesMap is null");
+    }
+
+    if (fileNamesMap.size() == 0) {
+      return;
+    }
+
+    readZipInfo();
+
+    if (zipModel.isSplitArchive()) {
+      throw new ZipException("Zip file format does not allow updating split/spanned files");
+    }
+
+    AsyncZipTask.AsyncTaskParameters asyncTaskParameters = buildAsyncParameters();
+    new RenameFileTask(zipModel, headerWriter, new RawIO(), charset, asyncTaskParameters).execute(
+        new RenameFileTaskParameters(fileNamesMap));
+  }
+
   /**
    * Merges split zip files into a single zip file without the need to extract the
    * files in the archive
diff --git a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
index 2fcc8e7..41eb57b 100644
--- a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
+++ b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
@@ -31,6 +31,7 @@ public class FileHeaderFactory {
     if (zipParameters.isEncryptFiles() && zipParameters.getEncryptionMethod() == EncryptionMethod.AES) {
       fileHeader.setCompressionMethod(CompressionMethod.AES_INTERNAL_ONLY);
       fileHeader.setAesExtraDataRecord(generateAESExtraDataRecord(zipParameters));
+      fileHeader.setExtraFieldLength(fileHeader.getExtraFieldLength() + InternalZipConstants.AES_EXTRA_DATA_RECORD_SIZE);
     } else {
       fileHeader.setCompressionMethod(zipParameters.getCompressionMethod());
     }
@@ -91,6 +92,7 @@ public class FileHeaderFactory {
     localFileHeader.setCompressedSize(fileHeader.getCompressedSize());
     localFileHeader.setGeneralPurposeFlag(fileHeader.getGeneralPurposeFlag().clone());
     localFileHeader.setDataDescriptorExists(fileHeader.isDataDescriptorExists());
+    localFileHeader.setExtraFieldLength(fileHeader.getExtraFieldLength());
     return localFileHeader;
   }
 
diff --git a/src/main/java/net/lingala/zip4j/model/FileHeader.java b/src/main/java/net/lingala/zip4j/model/FileHeader.java
index 619f325..b9aedc6 100755
--- a/src/main/java/net/lingala/zip4j/model/FileHeader.java
+++ b/src/main/java/net/lingala/zip4j/model/FileHeader.java
@@ -87,4 +87,9 @@ public class FileHeader extends AbstractFileHeader {
   public void setFileComment(String fileComment) {
     this.fileComment = fileComment;
   }
+
+  @Override
+  public String toString() {
+    return getFileName();
+  }
 }
diff --git a/src/main/java/net/lingala/zip4j/progress/ProgressMonitor.java b/src/main/java/net/lingala/zip4j/progress/ProgressMonitor.java
index dcd8b03..3277272 100755
--- a/src/main/java/net/lingala/zip4j/progress/ProgressMonitor.java
+++ b/src/main/java/net/lingala/zip4j/progress/ProgressMonitor.java
@@ -23,7 +23,7 @@ public class ProgressMonitor {
 
   public enum State { READY, BUSY }
   public enum Result { SUCCESS, WORK_IN_PROGRESS, ERROR, CANCELLED }
-  public enum Task { NONE, ADD_ENTRY, REMOVE_ENTRY, CALCULATE_CRC, EXTRACT_ENTRY, MERGE_ZIP_FILES, SET_COMMENT}
+  public enum Task { NONE, ADD_ENTRY, REMOVE_ENTRY, CALCULATE_CRC, EXTRACT_ENTRY, MERGE_ZIP_FILES, SET_COMMENT, RENAME_FILE}
 
   private State state;
   private long totalWork;
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
new file mode 100644
index 0000000..03c0884
--- /dev/null
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
@@ -0,0 +1,76 @@
+package net.lingala.zip4j.tasks;
+
+import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.ZipModel;
+import net.lingala.zip4j.progress.ProgressMonitor;
+import net.lingala.zip4j.util.FileUtils;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.RandomAccessFile;
+import java.util.Random;
+
+abstract class AbstractModifyFileTask<T> extends AsyncZipTask<T> {
+
+  AbstractModifyFileTask(AsyncTaskParameters asyncTaskParameters) {
+    super(asyncTaskParameters);
+  }
+
+  File getTemporaryFile(String zipPathWithName) {
+    Random random = new Random();
+    File tmpFile = new File(zipPathWithName + random.nextInt(10000));
+
+    while (tmpFile.exists()) {
+      tmpFile = new File(zipPathWithName + random.nextInt(10000));
+    }
+
+    return tmpFile;
+  }
+
+  long getOffsetLocalFileHeader(FileHeader fileHeader) {
+    long offsetLocalFileHeader = fileHeader.getOffsetLocalHeader();
+
+    if (fileHeader.getZip64ExtendedInfo() != null && fileHeader.getZip64ExtendedInfo().getOffsetLocalHeader() != -1) {
+      offsetLocalFileHeader = fileHeader.getZip64ExtendedInfo().getOffsetLocalHeader();
+    }
+
+    return offsetLocalFileHeader;
+  }
+
+  long getOffsetOfStartOfCentralDirectory(ZipModel zipModel) {
+    long offsetStartCentralDir = zipModel.getEndOfCentralDirectoryRecord().getOffsetOfStartOfCentralDirectory();
+
+    if (zipModel.isZip64Format() && zipModel.getZip64EndOfCentralDirectoryRecord() != null) {
+      offsetStartCentralDir = zipModel.getZip64EndOfCentralDirectoryRecord()
+          .getOffsetStartCentralDirectoryWRTStartDiskNumber();
+    }
+
+    return offsetStartCentralDir;
+  }
+
+  void cleanupFile(boolean successFlag, File zipFile, File temporaryZipFile) throws ZipException {
+    if (successFlag) {
+      restoreFileName(zipFile, temporaryZipFile);
+    } else {
+      temporaryZipFile.delete();
+    }
+  }
+
+  long copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long length,
+                        ProgressMonitor progressMonitor) throws IOException {
+    FileUtils.copyFile(randomAccessFile, outputStream, start, start + length, progressMonitor);
+    return length;
+  }
+
+  private void restoreFileName(File zipFile, File temporaryZipFile) throws ZipException {
+    if (zipFile.delete()) {
+      if (!temporaryZipFile.renameTo(zipFile)) {
+        throw new ZipException("cannot rename modified zip file");
+      }
+    } else {
+      throw new ZipException("cannot delete old zip file");
+    }
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/tasks/RenameFileTask.java b/src/main/java/net/lingala/zip4j/tasks/RenameFileTask.java
new file mode 100644
index 0000000..1488e3f
--- /dev/null
+++ b/src/main/java/net/lingala/zip4j/tasks/RenameFileTask.java
@@ -0,0 +1,212 @@
+package net.lingala.zip4j.tasks;
+
+import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.headers.HeaderUtil;
+import net.lingala.zip4j.headers.HeaderWriter;
+import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.ZipModel;
+import net.lingala.zip4j.model.enums.RandomAccessFileMode;
+import net.lingala.zip4j.progress.ProgressMonitor;
+import net.lingala.zip4j.util.InternalZipConstants;
+import net.lingala.zip4j.util.RawIO;
+import net.lingala.zip4j.util.Zip4jUtil;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.RandomAccessFile;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class RenameFileTask extends AbstractModifyFileTask<RenameFileTask.RenameFileTaskParameters> {
+
+  private ZipModel zipModel;
+  private HeaderWriter headerWriter;
+  private RawIO rawIO;
+  private Charset charset;
+
+  public RenameFileTask(ZipModel zipModel, HeaderWriter headerWriter, RawIO rawIO, Charset charset, AsyncTaskParameters asyncTaskParameters) {
+    super(asyncTaskParameters);
+    this.zipModel = zipModel;
+    this.headerWriter = headerWriter;
+    this.rawIO = rawIO;
+    this.charset = charset;
+  }
+
+  @Override
+  protected void executeTask(RenameFileTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {
+    File temporaryFile = getTemporaryFile(zipModel.getZipFile().getPath());
+    Map<String, String> fileNamesMap = filterNonExistingEntriesAndAddSeparatorIfNeeded(taskParameters.fileNamesMap);
+
+    try(RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.WRITE.getValue());
+        OutputStream outputStream = new FileOutputStream(temporaryFile)) {
+
+      long currentFileCopyPointer = 0;
+
+      // Maintain a different list to iterate, so that when the file name is changed in the central directory
+      // we still have access to the original file names. If iterating on the original list from central directory,
+      // it might be that a file name has changed because of other file name, ex: if a directory name has to be changed
+      // and the file is part of that directory, by the time the file has to be changed, its name might have changed
+      // when changing the name of the directory. There is some overhead with this approach, but is safer.
+      List<FileHeader> allUnchangedFileHeaders = new ArrayList<>(zipModel.getCentralDirectory().getFileHeaders());
+
+      for (FileHeader fileHeader : allUnchangedFileHeaders) {
+        Map.Entry<String, String> fileNameMapForThisEntry = getCorrespondingEntryFromMap(fileHeader, fileNamesMap);
+        progressMonitor.setFileName(fileHeader.getFileName());
+
+        if (fileNameMapForThisEntry == null) {
+          // copy complete entry without any changes
+          int headerSize = 30 + fileHeader.getFileNameLength() + fileHeader.getExtraFieldLength(); // 30 = all fixed lengths in local file header
+          currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, headerSize + fileHeader.getCompressedSize(), progressMonitor);
+        } else {
+          String newFileName = getNewFileName(fileNameMapForThisEntry.getValue(), fileNameMapForThisEntry.getKey(), fileHeader.getFileName());
+          byte[] newFileNameBytes = newFileName.getBytes(charset);
+          int headersOffset = newFileNameBytes.length - fileHeader.getFileNameLength();
+
+          currentFileCopyPointer = copyEntryAndChangeFileName(newFileNameBytes, fileHeader, currentFileCopyPointer,
+              inputStream, outputStream, progressMonitor);
+
+          updateHeadersInZipModel(fileHeader, newFileName, newFileNameBytes, headersOffset);
+        }
+
+        verifyIfTaskIsCancelled();
+      }
+
+      headerWriter.finalizeZipFile(zipModel, outputStream, charset);
+
+      cleanupFile(true, zipModel.getZipFile(), temporaryFile);
+    } catch (Exception e) {
+      cleanupFile(false, zipModel.getZipFile(), temporaryFile);
+      throw e;
+    }
+
+  }
+
+  @Override
+  protected long calculateTotalWork(RenameFileTaskParameters taskParameters) {
+    return zipModel.getZipFile().length();
+  }
+
+  @Override
+  protected ProgressMonitor.Task getTask() {
+    return ProgressMonitor.Task.RENAME_FILE;
+  }
+
+  private long copyEntryAndChangeFileName(byte[] newFileNameBytes, FileHeader fileHeader, long start,
+                                          RandomAccessFile inputStream, OutputStream outputStream,
+                                          ProgressMonitor progressMonitor) throws IOException {
+    long currentFileCopyPointer = start;
+
+    currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, 26, progressMonitor); // 26 is offset until file name length
+
+    rawIO.writeShortLittleEndian(outputStream, newFileNameBytes.length);
+
+    currentFileCopyPointer += 2; // length of file name length
+    currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, 2, progressMonitor); // 2 is for length of extra field length
+
+    outputStream.write(newFileNameBytes);
+    currentFileCopyPointer += fileHeader.getFileNameLength();
+
+    currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer,
+        fileHeader.getExtraFieldLength() + fileHeader.getCompressedSize(), progressMonitor);
+
+    return currentFileCopyPointer;
+  }
+
+  private Map.Entry<String, String> getCorrespondingEntryFromMap(FileHeader fileHeaderToBeChecked, Map<String,
+      String> fileNamesMap) {
+
+    for (Map.Entry<String, String> fileHeaderToBeRenamed : fileNamesMap.entrySet()) {
+      if (fileHeaderToBeChecked.getFileName().startsWith(fileHeaderToBeRenamed.getKey())) {
+        return fileHeaderToBeRenamed;
+      }
+    }
+
+    return null;
+  }
+
+  private void updateHeadersInZipModel(FileHeader fileHeader, String newFileName, byte[] newFileNameBytes,
+                                       int headersOffset) throws ZipException {
+
+    FileHeader fileHeaderToBeChanged = HeaderUtil.getFileHeader(zipModel, fileHeader.getFileName());
+
+    if (fileHeaderToBeChanged == null) {
+      // If this is the case, then the file name in the header that was passed to this method was already changed.
+      // In theory, should never be here.
+      throw new ZipException("could not find any header with name: " + fileHeader.getFileName());
+    }
+
+    fileHeaderToBeChanged.setFileName(newFileName);
+    fileHeaderToBeChanged.setFileNameLength(newFileNameBytes.length);
+
+    updateOffsetsForAllSubsequentFileHeaders(fileHeaderToBeChanged, headersOffset);
+
+    zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(
+        zipModel.getEndOfCentralDirectoryRecord().getOffsetOfStartOfCentralDirectory() + headersOffset);
+
+    if (zipModel.isZip64Format()) {
+      zipModel.getZip64EndOfCentralDirectoryRecord().setOffsetStartCentralDirectoryWRTStartDiskNumber(
+          zipModel.getZip64EndOfCentralDirectoryRecord().getOffsetStartCentralDirectoryWRTStartDiskNumber() + headersOffset
+      );
+
+      zipModel.getZip64EndOfCentralDirectoryLocator().setOffsetZip64EndOfCentralDirectoryRecord(
+          zipModel.getZip64EndOfCentralDirectoryLocator().getOffsetZip64EndOfCentralDirectoryRecord() + headersOffset
+      );
+    }
+  }
+
+  private Map<String, String> filterNonExistingEntriesAndAddSeparatorIfNeeded(Map<String, String> inputFileNamesMap) throws ZipException {
+    Map<String, String> fileNamesMapToBeChanged = new HashMap<>();
+    for (Map.Entry<String, String> allNamesToBeChanged : inputFileNamesMap.entrySet()) {
+      if (!Zip4jUtil.isStringNotNullAndNotEmpty(allNamesToBeChanged.getKey())) {
+        continue;
+      }
+
+      FileHeader fileHeaderToBeChanged = HeaderUtil.getFileHeader(zipModel, allNamesToBeChanged.getKey());
+      if (fileHeaderToBeChanged != null) {
+        if (fileHeaderToBeChanged.isDirectory() && !allNamesToBeChanged.getValue().endsWith(InternalZipConstants.ZIP_FILE_SEPARATOR)) {
+          fileNamesMapToBeChanged.put(allNamesToBeChanged.getKey(), allNamesToBeChanged.getValue() + InternalZipConstants.ZIP_FILE_SEPARATOR);
+        } else {
+          fileNamesMapToBeChanged.put(allNamesToBeChanged.getKey(), allNamesToBeChanged.getValue());
+        }
+      }
+    }
+    return fileNamesMapToBeChanged;
+  }
+
+  private void updateOffsetsForAllSubsequentFileHeaders(FileHeader fileHeaderModified, int offsetToAdd) throws ZipException {
+    int indexOfFileHeader = HeaderUtil.getIndexOfFileHeader(zipModel, fileHeaderModified);
+    List<FileHeader> allFileHeaders = zipModel.getCentralDirectory().getFileHeaders();
+
+    for (int i = indexOfFileHeader + 1; i < allFileHeaders.size(); i++) {
+      FileHeader fileHeaderToUpdate = allFileHeaders.get(i);
+      fileHeaderToUpdate.setOffsetLocalHeader(fileHeaderToUpdate.getOffsetLocalHeader() + offsetToAdd);
+    }
+  }
+
+  private String getNewFileName(String newFileName, String oldFileName, String fileNameFromHeaderToBeChanged) throws ZipException {
+    if (fileNameFromHeaderToBeChanged.equals(oldFileName)) {
+      return newFileName;
+    } else if (fileNameFromHeaderToBeChanged.startsWith(oldFileName)) {
+      String fileNameWithoutOldName = fileNameFromHeaderToBeChanged.substring(oldFileName.length());
+      return newFileName + fileNameWithoutOldName;
+    }
+
+    // Should never be here.
+    // If here by any chance, it means that the file header was marked as to-be-modified, even when the file names do not
+    // match. Logic in the method getCorrespondingEntryFromMap() has to be checked
+    throw new ZipException("old file name was neither an exact match nor a partial match");
+  }
+
+  public static class RenameFileTaskParameters {
+    private Map<String, String> fileNamesMap;
+
+    public RenameFileTaskParameters(Map<String, String> fileNamesMap) {
+      this.fileNamesMap = fileNamesMap;
+    }
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java b/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
index 6aa5c62..86d5e9e 100755
--- a/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
+++ b/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
@@ -31,6 +31,7 @@ public final class InternalZipConstants {
   //AES Constants
   public static final int AES_AUTH_LENGTH = 10;
   public static final int AES_BLOCK_SIZE = 16;
+  public static final int AES_EXTRA_DATA_RECORD_SIZE = 11;
 
   public static final int MIN_SPLIT_LENGTH = 65536;
   public static final long ZIP_64_SIZE_LIMIT = 4294967295L;
diff --git a/src/test/java/net/lingala/zip4j/RenameFilesInZipIT.java b/src/test/java/net/lingala/zip4j/RenameFilesInZipIT.java
new file mode 100644
index 0000000..6fb4f07
--- /dev/null
+++ b/src/test/java/net/lingala/zip4j/RenameFilesInZipIT.java
@@ -0,0 +1,294 @@
+package net.lingala.zip4j;
+
+import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.ZipParameters;
+import net.lingala.zip4j.model.enums.CompressionMethod;
+import net.lingala.zip4j.model.enums.EncryptionMethod;
+import net.lingala.zip4j.progress.ProgressMonitor;
+import net.lingala.zip4j.testutils.TestUtils;
+import net.lingala.zip4j.testutils.ZipFileVerifier;
+import net.lingala.zip4j.util.InternalZipConstants;
+import org.junit.Test;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class RenameFilesInZipIT extends AbstractIT {
+
+  @Test
+  public void testRenameWithFileHeaderRenamesSuccessfully() throws IOException {
+    ZipFile zipFile = createDefaultZipFile();
+
+    zipFile.renameFile(zipFile.getFileHeader("sample.pdf"), "changed.pdf");
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);
+    verifyFileNamesChanged(zipFile, Collections.singletonMap("sample.pdf", "changed.pdf"));
+  }
+
+  @Test
+  public void testRenameWithFileHeaderRenamesAFolderSuccessfully() throws IOException {
+    ZipFile zipFile = createZipFileWithFolder();
+
+    zipFile.renameFile(zipFile.getFileHeader("test-files/sample_directory/"), "test-files/new_directory_name");
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 13, false);
+    verifyFileNamesChanged(zipFile, Collections.singletonMap("test-files/sample_directory/", "test-files/new_directory_name/"));
+  }
+
+  @Test
+  public void testRenameWithFileNameRenamesSuccessfully() throws IOException {
+    ZipFile zipFile = createDefaultZipFile();
+
+    zipFile.renameFile("sample_text_large.txt", "changed.txt");
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);
+    verifyFileNamesChanged(zipFile, Collections.singletonMap("sample_text_large.txt", "changed.txt"));
+  }
+
+  @Test
+  public void testRenameWithFileNameRenamesAFolderSuccessfully() throws IOException {
+    ZipFile zipFile = createZipFileWithFolder();
+
+    zipFile.renameFile(zipFile.getFileHeader("test-files/sample_directory/"), "test-files/가나다");
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 13, false);
+    verifyFileNamesChanged(zipFile, Collections.singletonMap("test-files/sample_directory/", "test-files/가나다/"));
+  }
+
+  @Test
+  public void testRenameWithMapWhenNoEntriesExistWithThatNameDoesNotChangeZipFile() throws IOException {
+    ZipFile zipFile = createDefaultZipFile();
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("does_not_exist_1", "does_not_matter_1");
+    fileNamesMap.put("does_not_exist_2", "does_not_matter_2");
+
+    zipFile.renameFiles(fileNamesMap);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 3);
+    verifyFileHeadersDoesNotExist(zipFile, Arrays.asList("does_not_matter_1", "does_not_matter_2"));
+  }
+
+  @Test
+  public void testRenameWithMapSingleEntry() throws IOException {
+    ZipFile zipFile = createDefaultZipFile();
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("sample_text_large.txt", "new-name.txt");
+
+    zipFile.renameFiles(fileNamesMap);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);
+    verifyFileNamesChanged(zipFile, fileNamesMap);
+  }
+
+  @Test
+  public void testRenameWithMapForAllEntriesInZip() throws IOException {
+    ZipFile zipFile = createDefaultZipFile();
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("sample_text1.txt", "new-sample_text1.txt");
+    fileNamesMap.put("sample_text_large.txt", "new-sample_text_large.txt");
+    fileNamesMap.put("sample.pdf", "new-sample.pdf");
+
+    zipFile.renameFiles(fileNamesMap);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);
+    verifyFileNamesChanged(zipFile, fileNamesMap);
+  }
+
+  @Test
+  public void testRenameWithMapRenamesRootFolder() throws IOException {
+    ZipFile zipFile = createZipFileWithFolder();
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("test-files/", "new-test-files/");
+
+    zipFile.renameFiles(fileNamesMap);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 13, false);
+    verifyFileNamesChanged(zipFile, fileNamesMap);
+  }
+
+  @Test
+  public void testRenameWithMapRenamesSubFolder() throws IOException {
+    ZipFile zipFile = createZipFileWithFolder();
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("test-files/sample_directory/", "new-test-files/new_sample_directory/");
+
+    zipFile.renameFiles(fileNamesMap);
+
+    zipFile.extractAll(outputFolder.getPath());
+    verifyFileNamesChanged(zipFile, fileNamesMap);
+  }
+
+  @Test
+  public void testRenameWithMapForStoreCompressionMethod() throws IOException {
+    ZipFile zipFile = createZipFile(CompressionMethod.STORE, false, null);
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("sample_text1.txt", "new-sample_text1.txt");
+    fileNamesMap.put("sample_text_large.txt", "new-sample_text_large.txt");
+    fileNamesMap.put("sample.pdf", "new-sample.pdf");
+
+    zipFile.renameFiles(fileNamesMap);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);
+    verifyFileNamesChanged(zipFile, fileNamesMap);
+  }
+
+  @Test
+  public void testRenameWithMapWithAesEncryption() throws IOException {
+    ZipFile zipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES);
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("sample_text1.txt", "new-sample_text1.txt");
+    fileNamesMap.put("sample_text_large.txt", "new-sample_text_large.txt");
+    fileNamesMap.put("sample.pdf", "new-sample.pdf");
+
+    zipFile.renameFiles(fileNamesMap);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);
+    verifyFileNamesChanged(zipFile, fileNamesMap);
+  }
+
+  @Test
+  public void testRenameWithMapWithZipStandardEncryption() throws IOException {
+    ZipFile zipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD);
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("sample_text1.txt", "new-sample_text1.txt");
+    fileNamesMap.put("sample_text_large.txt", "new-sample_text_large.txt");
+    fileNamesMap.put("sample.pdf", "new-sample.pdf");
+
+    zipFile.renameFiles(fileNamesMap);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 3, false);
+    verifyFileNamesChanged(zipFile, fileNamesMap);
+  }
+
+  @Test
+  public void testRenameWithMapWithAESEncryptionAndUtf8FileName() throws IOException {
+    ZipFile zipFile = createZipFileWithFolder(CompressionMethod.DEFLATE, true, EncryptionMethod.AES);
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("test-files/가나다.abc", "test-files/üßööß.abc");
+    fileNamesMap.put("test-files/öüäöäö/", "test-files/가나다/");
+
+    zipFile.renameFiles(fileNamesMap);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 13, false);
+    verifyFileNamesChanged(zipFile, fileNamesMap, false);
+  }
+
+  @Test
+  public void testRenameWithMapProgressMonitor() throws IOException, InterruptedException {
+    ZipFile zipFile = createZipFileWithFolder(CompressionMethod.DEFLATE, true, EncryptionMethod.AES);
+    Map<String, String> fileNamesMap = new HashMap<>();
+    fileNamesMap.put("test-files/가나다.abc", "test-files/üßööß.abc");
+    fileNamesMap.put("test-files/öüäöäö/", "test-files/가나다/");
+
+    zipFile.setRunInThread(true);
+    ProgressMonitor progressMonitor = zipFile.getProgressMonitor();
+
+    zipFile.renameFiles(fileNamesMap);
+
+    boolean percentBetweenZeroAndHundred = false;
+    boolean fileNameSet = true;
+    while (ProgressMonitor.State.BUSY.equals(progressMonitor.getState())) {
+      int percentDone = progressMonitor.getPercentDone();
+      String fileName = progressMonitor.getFileName();
+
+      if (percentDone > 0 && percentDone < 100) {
+        percentBetweenZeroAndHundred = true;
+      }
+
+      if (fileName != null) {
+        fileNameSet = true;
+      }
+    }
+
+    assertThat(progressMonitor.getResult()).isEqualTo(ProgressMonitor.Result.SUCCESS);
+    assertThat(progressMonitor.getState().equals(ProgressMonitor.State.READY));
+    assertThat(progressMonitor.getException()).isNull();
+    assertThat(percentBetweenZeroAndHundred).isTrue();
+    assertThat(fileNameSet).isTrue();
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 13, false);
+    verifyFileNamesChanged(zipFile, fileNamesMap, false);
+  }
+
+  private void verifyFileNamesChanged(ZipFile zipFile, Map<String, String> fileNamesMap) throws IOException {
+    verifyFileNamesChanged(zipFile, fileNamesMap, true);
+  }
+
+  private void verifyFileNamesChanged(ZipFile zipFile, Map<String, String> fileNamesMap, boolean verifyFileContent) throws IOException {
+    verifyFileHeadersDoesNotExist(zipFile, fileNamesMap.keySet());
+    verifyFileHeadersExist(zipFile, fileNamesMap.values());
+
+    for (Map.Entry<String, String> changedFileNameEntry : fileNamesMap.entrySet()) {
+      if (changedFileNameEntry.getValue().endsWith(InternalZipConstants.ZIP_FILE_SEPARATOR)) {
+        List<FileHeader> allFileHeaders = zipFile.getFileHeaders();
+        for (FileHeader fileHeader : allFileHeaders) {
+          assertThat(fileHeader.getFileName()).doesNotStartWith(changedFileNameEntry.getKey());
+        }
+      } else {
+        if (verifyFileContent) {
+          verifyContentOfChangedFile(changedFileNameEntry.getKey(), changedFileNameEntry.getValue());
+        }
+      }
+    }
+  }
+
+  private void verifyFileHeadersExist(ZipFile zipFile, Collection<String> fileNamesToVerify) throws IOException {
+    for (String fileNameToVerify : fileNamesToVerify) {
+      assertThat(zipFile.getFileHeader(fileNameToVerify)).isNotNull();
+    }
+  }
+
+  private void verifyFileHeadersDoesNotExist(ZipFile zipFile, Collection<String> fileNamesToVerify) throws IOException {
+    for (String fileNameToVerify : fileNamesToVerify) {
+      assertThat(zipFile.getFileHeader(fileNameToVerify)).isNull();
+    }
+  }
+
+  private void verifyContentOfChangedFile(String oldFileName, String newFileName) throws IOException {
+    File sourceFile = getTestFileFromResources(oldFileName);
+    File extractedFile = Paths.get(outputFolder.getAbsolutePath(), newFileName).toFile();
+    ZipFileVerifier.verifyFileCrc(sourceFile, extractedFile);
+  }
+
+  private ZipFile createDefaultZipFile() throws ZipException {
+    return createZipFile(CompressionMethod.DEFLATE, false, null);
+  }
+
+  private ZipFile createZipFile(CompressionMethod compressionMethod, boolean encrypt, EncryptionMethod encryptionMethod) throws ZipException {
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    ZipParameters zipParameters = buildZipParameters(compressionMethod, encrypt, encryptionMethod);
+    zipFile.addFiles(FILES_TO_ADD, zipParameters);
+    return zipFile;
+  }
+
+  private ZipFile createZipFileWithFolder() throws ZipException {
+    return createZipFileWithFolder(CompressionMethod.DEFLATE, false, null);
+  }
+
+  private ZipFile createZipFileWithFolder(CompressionMethod compressionMethod, boolean encrypt, EncryptionMethod encryptionMethod) throws ZipException {
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    ZipParameters zipParameters = buildZipParameters(compressionMethod, encrypt, encryptionMethod);
+    zipFile.addFolder(TestUtils.getTestFileFromResources(""), zipParameters);
+    return zipFile;
+  }
+
+  private ZipParameters buildZipParameters(CompressionMethod compressionMethod, boolean encrypt, EncryptionMethod encryptionMethod) {
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setEncryptFiles(encrypt);
+    zipParameters.setEncryptionMethod(encryptionMethod);
+    zipParameters.setCompressionMethod(compressionMethod);
+    return zipParameters;
+  }
+
+}
diff --git a/src/test/java/net/lingala/zip4j/ZipFileTest.java b/src/test/java/net/lingala/zip4j/ZipFileTest.java
index 8a2cb82..a688d83 100644
--- a/src/test/java/net/lingala/zip4j/ZipFileTest.java
+++ b/src/test/java/net/lingala/zip4j/ZipFileTest.java
@@ -446,6 +446,76 @@ public class ZipFileTest {
     zipFile.removeFile((FileHeader) null);
   }
 
+  @Test
+  public void testRenameFileWithFileHeaderThrowsExceptionWhenHeaderIsNull() throws ZipException {
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("File header is null");
+
+    zipFile.renameFile((FileHeader) null, "somename");
+  }
+
+  @Test
+  public void testRenameFileWithFileHeaderThrowsExceptionWhenNewFileNameIsNull() throws ZipException {
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("File header is null");
+
+    FileHeader fileHeader = new FileHeader();
+    fileHeader.setFileName("somename");
+
+    zipFile.renameFile(fileHeader, null);
+  }
+
+  @Test
+  public void testRenameFileWithFileHeaderThrowsExceptionWhenNewFileNameIsEmpty() throws ZipException {
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("File header is null");
+
+    FileHeader fileHeader = new FileHeader();
+    fileHeader.setFileName("somename");
+
+    zipFile.renameFile(fileHeader, "");
+  }
+
+  @Test
+  public void testRenameFileWithFileNameThrowsExceptionWhenFileNameToBeChangedIsNull() throws ZipException {
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("file name to be changed is null or empty");
+
+    zipFile.renameFile((String) null, "somename");
+  }
+
+  @Test
+  public void testRenameFileWithFileNameThrowsExceptionWhenFileNameToBeChangedIsEmpty() throws ZipException {
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("file name to be changed is null or empty");
+
+    zipFile.renameFile("", "somename");
+  }
+
+  @Test
+  public void testRenameFileWithFileNameThrowsExceptionWhenNewFileNameIsNull() throws ZipException {
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("newFileName is null or empty");
+
+    zipFile.renameFile("Somename", null);
+  }
+
+  @Test
+  public void testRenameFileWithFileNameThrowsExceptionWhenNewFileNameIsEmpty() throws ZipException {
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("newFileName is null or empty");
+
+    zipFile.renameFile("Somename", "   ");
+  }
+
+  @Test
+  public void testRenameFileWithMapThrowsExceptionWhenMapIsNull() throws ZipException {
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("fileNamesMap is null");
+
+    zipFile.renameFiles(null);
+  }
+
   @Test
   public void testMergeSplitFilesWhenOutputFileIsNullThrowsException() throws ZipException {
     expectedException.expectMessage("outputZipFile is null, cannot merge split files");
diff --git a/src/test/java/net/lingala/zip4j/headers/FileHeaderFactoryTest.java b/src/test/java/net/lingala/zip4j/headers/FileHeaderFactoryTest.java
index dc841e9..6c668f0 100644
--- a/src/test/java/net/lingala/zip4j/headers/FileHeaderFactoryTest.java
+++ b/src/test/java/net/lingala/zip4j/headers/FileHeaderFactoryTest.java
@@ -271,6 +271,7 @@ public class FileHeaderFactoryTest {
     fileHeader.setCompressedSize(23523L);
     fileHeader.setGeneralPurposeFlag(new byte[] {2, 28});
     fileHeader.setDataDescriptorExists(true);
+    fileHeader.setExtraFieldLength(190);
     return fileHeader;
   }
 
@@ -300,6 +301,7 @@ public class FileHeaderFactoryTest {
     verifyCrc(fileHeader);
     assertThat(fileHeader.isDataDescriptorExists()).isEqualTo(zipParameters.isWriteExtendedLocalFileHeader());
     assertThat(fileHeader.getAesExtraDataRecord() != null).isEqualTo(aesExtraDataRecordPresent);
+    assertThat(fileHeader.getExtraFieldLength()).isEqualTo(aesExtraDataRecordPresent ? InternalZipConstants.AES_EXTRA_DATA_RECORD_SIZE : 0);
   }
 
   private void verifyLocalFileHeader(LocalFileHeader localFileHeader, long lastModifiedFileTime) {
@@ -317,6 +319,7 @@ public class FileHeaderFactoryTest {
     assertThat(localFileHeader.getCompressedSize()).isEqualTo(23523L);
     assertThat(localFileHeader.getGeneralPurposeFlag()).containsExactly(2, 28);
     assertThat(localFileHeader.isDataDescriptorExists()).isTrue();
+    assertThat(localFileHeader.getExtraFieldLength()).isEqualTo(190);
   }
 
   private void verifyCompressionMethod(FileHeader fileHeader, ZipParameters zipParameters) {
