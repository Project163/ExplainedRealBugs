diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
index d4e1ff0..4cc21a6 100755
--- a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
@@ -175,7 +175,8 @@ public class ZipOutputStream extends OutputStream {
   private void verifyZipParameters(ZipParameters zipParameters) {
     if (zipParameters.getCompressionMethod() == CompressionMethod.STORE
         && zipParameters.getEntrySize() < 0
-        && !isEntryDirectory(zipParameters.getFileNameInZip())) {
+        && !isEntryDirectory(zipParameters.getFileNameInZip())
+        && zipParameters.isWriteExtendedLocalFileHeader()) {
       throw new IllegalArgumentException("uncompressed size should be set for zip entries of compression type store");
     }
   }
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
index a1cad98..472255d 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
@@ -77,7 +77,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
         FileHeader fileHeader = zipOutputStream.closeEntry();
         fileHeader.setExternalFileAttributes(FileUtils.getFileAttributes(fileToAdd));
 
-        headerWriter.updateLocalFileHeader(fileHeader, zipModel, splitOutputStream);
+        updateLocalFileHeader(fileHeader, splitOutputStream);
       }
     }
   }
@@ -141,6 +141,10 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     }
   }
 
+  void updateLocalFileHeader(FileHeader fileHeader, SplitOutputStream splitOutputStream) throws IOException {
+    headerWriter.updateLocalFileHeader(fileHeader, getZipModel(), splitOutputStream);
+  }
+
   private ZipParameters cloneAndAdjustZipParameters(ZipParameters zipParameters, File fileToAdd,
                                                     ProgressMonitor progressMonitor) throws IOException {
     ZipParameters clonedZipParameters = new ZipParameters(zipParameters);
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
index 2f1ba72..194f81d 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
@@ -4,6 +4,7 @@ import lombok.AllArgsConstructor;
 import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.io.outputstream.SplitOutputStream;
 import net.lingala.zip4j.io.outputstream.ZipOutputStream;
+import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -27,6 +28,8 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
 
     verifyZipParameters(taskParameters.zipParameters);
 
+    taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false);
+
     try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength());
         ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream)) {
 
@@ -43,7 +46,8 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
         }
       }
 
-      zipOutputStream.closeEntry();
+      FileHeader fileHeader = zipOutputStream.closeEntry();
+      updateLocalFileHeader(fileHeader, splitOutputStream);
     }
   }
 
diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index aed9e34..61deb8b 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -11,6 +11,7 @@ import net.lingala.zip4j.model.enums.AesKeyStrength;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.progress.ProgressMonitor;
+import net.lingala.zip4j.util.BitUtils;
 import net.lingala.zip4j.util.InternalZipConstants;
 import net.lingala.zip4j.utils.TestUtils;
 import net.lingala.zip4j.utils.ZipFileVerifier;
@@ -535,6 +536,26 @@ public class AddFilesToZipIT extends AbstractIT {
     verifyZipFileContainsFiles(generatedZipFile, singletonList("бореиская.txt"), CompressionMethod.DEFLATE, null, null);
   }
 
+  @Test
+  public void testAddStreamToWithStoreCompressionAndWithoutEncryption() throws IOException {
+    File fileToAdd = TestUtils.getFileFromResources("бореиская.txt");
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setCompressionMethod(CompressionMethod.STORE);
+    zipParameters.setFileNameInZip(fileToAdd.getName());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    InputStream inputStream = new FileInputStream(fileToAdd);
+
+    zipFile.addStream(inputStream, zipParameters);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 1);
+    verifyZipFileContainsFiles(generatedZipFile, singletonList("бореиская.txt"), CompressionMethod.STORE, null, null);
+
+    zipFile = new ZipFile(generatedZipFile);
+    byte[] generalPurposeBytes = zipFile.getFileHeaders().get(0).getGeneralPurposeFlag();
+    // assert that extra data record is not present
+    assertThat(BitUtils.isBitSet(generalPurposeBytes[0], 3)).isFalse();
+  }
+
   @Test
   public void testAddStreamToZipWithAesEncryptionForNewZipAddsSuccessfully() throws IOException {
     File fileToAdd = TestUtils.getFileFromResources("бореиская.txt");
diff --git a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
index 2049174..66360d1 100644
--- a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
@@ -2,7 +2,6 @@ package net.lingala.zip4j.io.inputstream;
 
 import net.lingala.zip4j.AbstractIT;
 import net.lingala.zip4j.ZipFile;
-import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
@@ -23,48 +22,48 @@ import static org.assertj.core.api.Assertions.assertThat;
 public class ZipInputStreamIT extends AbstractIT {
 
   @Test
-  public void testExtractStoreWithoutEncryption() throws IOException, ZipException {
+  public void testExtractStoreWithoutEncryption() throws IOException {
     File createdZipFile = createZipFile(CompressionMethod.STORE);
     extractZipFileWithInputStreams(createdZipFile, null);
   }
 
   @Test
-  public void testExtractStoreWithZipStandardEncryption() throws IOException, ZipException {
+  public void testExtractStoreWithZipStandardEncryption() throws IOException {
     File createdZipFile = createZipFile(CompressionMethod.STORE, true, EncryptionMethod.ZIP_STANDARD, null, PASSWORD);
     extractZipFileWithInputStreams(createdZipFile, PASSWORD);
   }
 
   @Test
-  public void testExtractStoreWithAesEncryption128() throws IOException, ZipException {
+  public void testExtractStoreWithAesEncryption128() throws IOException {
     File createdZipFile = createZipFile(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128, PASSWORD);
     extractZipFileWithInputStreams(createdZipFile, PASSWORD);
   }
 
   @Test
-  public void testExtractStoreWithAesEncryption256() throws IOException, ZipException {
+  public void testExtractStoreWithAesEncryption256() throws IOException {
     File createdZipFile = createZipFile(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
     extractZipFileWithInputStreams(createdZipFile, PASSWORD);
   }
 
   @Test
-  public void testExtractDeflateWithoutEncryption() throws IOException, ZipException {
+  public void testExtractDeflateWithoutEncryption() throws IOException {
     File createdZipFile = createZipFile(CompressionMethod.DEFLATE);
     extractZipFileWithInputStreams(createdZipFile, null);
   }
 
   @Test
-  public void testExtractDeflateWithAesEncryption128() throws IOException, ZipException {
+  public void testExtractDeflateWithAesEncryption128() throws IOException {
     File createdZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128, PASSWORD);
     extractZipFileWithInputStreams(createdZipFile, PASSWORD);
   }
 
   @Test
-  public void testExtractDeflateWithAesEncryption256() throws IOException, ZipException {
+  public void testExtractDeflateWithAesEncryption256() throws IOException {
     File createdZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
     extractZipFileWithInputStreams(createdZipFile, PASSWORD);
   }
 
-  private void extractZipFileWithInputStreams(File zipFile, char[] password) throws IOException, ZipException {
+  private void extractZipFileWithInputStreams(File zipFile, char[] password) throws IOException {
     LocalFileHeader localFileHeader;
     int readLen;
     byte[] readBuffer = new byte[4096];
@@ -88,13 +87,13 @@ public class ZipInputStreamIT extends AbstractIT {
     assertThat(numberOfEntriesExtracted).isEqualTo(FILES_TO_ADD.size());
   }
 
-  private File createZipFile(CompressionMethod compressionMethod) throws IOException, ZipException {
+  private File createZipFile(CompressionMethod compressionMethod) throws IOException {
     return createZipFile(compressionMethod, false, null, null, null);
   }
 
   private File createZipFile(CompressionMethod compressionMethod, boolean encryptFiles,
                              EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength, char[] password)
-      throws IOException, ZipException {
+      throws IOException {
 
     File outputFile = temporaryFolder.newFile("output.zip");
     deleteFileIfExists(outputFile);
diff --git a/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java b/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
index c0c8ce2..f475bee 100644
--- a/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
@@ -1,12 +1,17 @@
 package net.lingala.zip4j.io.outputstream;
 
 import net.lingala.zip4j.AbstractIT;
+import net.lingala.zip4j.ZipFile;
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
+import net.lingala.zip4j.util.BitUtils;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -15,65 +20,86 @@ import java.io.IOException;
 import java.io.InputStream;
 
 import static net.lingala.zip4j.utils.ZipFileVerifier.verifyZipFileByExtractingAllFiles;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class ZipOutputStreamIT extends AbstractIT {
 
+  @Rule
+  public ExpectedException expectedException = ExpectedException.none();
+
   @Test
-  public void testZipOutputStreamStoreWithoutEncryption() throws IOException, ZipException {
+  public void testZipOutputStreamStoreWithoutEncryption() throws IOException {
     testZipOutputStream(CompressionMethod.STORE, false, null, null);
   }
 
   @Test
-  public void testZipOutputStreamStoreWithStandardEncryption() throws IOException, ZipException {
+  public void testZipOutputStreamStoreWithStandardEncryption() throws IOException {
     testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.ZIP_STANDARD, null);
   }
 
   @Test
-  public void testZipOutputStreamStoreWithAES128() throws IOException, ZipException {
+  public void testZipOutputStreamStoreWithAES128() throws IOException {
     testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
   }
 
   @Test
-  public void testZipOutputStreamStoreWithAES256() throws IOException, ZipException {
+  public void testZipOutputStreamStoreWithAES256() throws IOException {
     testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
   }
 
   @Test
-  public void testZipOutputStreamDeflateWithoutEncryption() throws IOException, ZipException {
+  public void testZipOutputStreamDeflateWithoutEncryption() throws IOException {
     testZipOutputStream(CompressionMethod.DEFLATE, false, null, null);
   }
 
   @Test
-  public void testZipOutputStreamDeflateWithStandardEncryption() throws IOException, ZipException {
+  public void testZipOutputStreamDeflateWithStandardEncryption() throws IOException {
     testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null);
   }
 
   @Test
   public void testZipOutputStreamDeflateWithStandardEncryptionWhenModifiedFileTimeNotSet()
-      throws IOException, ZipException {
+      throws IOException {
     testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, false);
   }
 
   @Test
-  public void testZipOutputStreamDeflateWithAES128() throws IOException, ZipException {
+  public void testZipOutputStreamDeflateWithAES128() throws IOException {
     testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
   }
 
   @Test
-  public void testZipOutputStreamDeflateWithAES256() throws IOException, ZipException {
+  public void testZipOutputStreamDeflateWithAES256() throws IOException {
     testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
   }
 
+  @Test
+  public void testZipOutputStreamThrowsExceptionWhenEntrySizeNotSetForStoreCompression() throws IOException {
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setCompressionMethod(CompressionMethod.STORE);
+
+    expectedException.expect(IllegalArgumentException.class);
+    expectedException.expectMessage("uncompressed size should be set for zip entries of compression type store");
+
+    try(ZipOutputStream zos = initializeZipOutputStream(false)) {
+      for (File fileToAdd : FILES_TO_ADD) {
+        zipParameters.setLastModifiedFileTime(fileToAdd.lastModified());
+        zipParameters.setFileNameInZip(fileToAdd.getName());
+        zos.putNextEntry(zipParameters);
+      }
+    }
+  }
+
   private void testZipOutputStream(CompressionMethod compressionMethod, boolean encrypt,
                                    EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength)
-      throws IOException, ZipException {
+      throws IOException {
     testZipOutputStream(compressionMethod, encrypt, encryptionMethod, aesKeyStrength, true);
   }
 
   private void testZipOutputStream(CompressionMethod compressionMethod, boolean encrypt,
                                    EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength,
                                    boolean setLastModifiedTime)
-      throws IOException, ZipException {
+      throws IOException {
 
     ZipParameters zipParameters = buildZipParameters(compressionMethod, encrypt, encryptionMethod, aesKeyStrength);
     byte[] buff = new byte[4096];
@@ -101,6 +127,15 @@ public class ZipOutputStreamIT extends AbstractIT {
       }
     }
     verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size());
+    verifyDataDescriptorExistsForAllEntries();
+  }
+
+  private void verifyDataDescriptorExistsForAllEntries() throws ZipException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    for (FileHeader fileHeader : zipFile.getFileHeaders()) {
+      byte[] generalPurposeBytes = fileHeader.getGeneralPurposeFlag();
+      assertThat(BitUtils.isBitSet(generalPurposeBytes[0], 3)).isTrue();
+    }
   }
 
   private ZipOutputStream initializeZipOutputStream(boolean encrypt) throws IOException {
