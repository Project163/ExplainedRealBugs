diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index a6db9a6..2fb6524 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -62,7 +62,6 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
 
-import static net.lingala.zip4j.util.FileUtils.assertFilesExist;
 import static net.lingala.zip4j.util.FileUtils.isNumberedSplitFile;
 import static net.lingala.zip4j.util.InternalZipConstants.CHARSET_UTF_8;
 import static net.lingala.zip4j.util.UnzipUtil.createZipInputStream;
@@ -289,8 +288,6 @@ public class ZipFile {
       throw new ZipException("invalid operation - Zip4j is in busy state");
     }
 
-    assertFilesExist(filesToAdd);
-
     readZipInfo();
 
     if (zipModel == null) {
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
index 6971f2b..11aa456 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
@@ -37,6 +37,7 @@ import static net.lingala.zip4j.progress.ProgressMonitor.Task.ADD_ENTRY;
 import static net.lingala.zip4j.progress.ProgressMonitor.Task.CALCULATE_CRC;
 import static net.lingala.zip4j.progress.ProgressMonitor.Task.REMOVE_ENTRY;
 import static net.lingala.zip4j.util.CrcUtil.computeFileCrc;
+import static net.lingala.zip4j.util.FileUtils.assertFilesExist;
 import static net.lingala.zip4j.util.FileUtils.getRelativeFileName;
 import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
 import static net.lingala.zip4j.util.Zip4jUtil.javaToDosTime;
@@ -60,6 +61,8 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
   void addFilesToZip(List<File> filesToAdd, ProgressMonitor progressMonitor, ZipParameters zipParameters, Charset charset)
       throws IOException {
 
+    assertFilesExist(filesToAdd, zipParameters.getSymbolicLinkAction());
+
     List<File> updatedFilesToAdd = removeFilesIfExists(filesToAdd, zipParameters, progressMonitor, charset);
 
     try (SplitOutputStream splitOutputStream = new SplitOutputStream(zipModel.getZipFile(), zipModel.getSplitLength());
@@ -95,7 +98,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
 
     zipOutputStream.putNextEntry(clonedZipParameters);
 
-    String symLinkTarget = fileToAdd.toPath().toRealPath().toString();
+    String symLinkTarget = FileUtils.readSymbolicLink(fileToAdd);
     zipOutputStream.write(symLinkTarget.getBytes());
 
     closeEntry(zipOutputStream, splitOutputStream, fileToAdd, true);
diff --git a/src/main/java/net/lingala/zip4j/util/FileUtils.java b/src/main/java/net/lingala/zip4j/util/FileUtils.java
index 4c950a0..a0145a0 100644
--- a/src/main/java/net/lingala/zip4j/util/FileUtils.java
+++ b/src/main/java/net/lingala/zip4j/util/FileUtils.java
@@ -11,6 +11,7 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.io.RandomAccessFile;
 import java.nio.file.Files;
+import java.nio.file.LinkOption;
 import java.nio.file.Path;
 import java.nio.file.attribute.DosFileAttributeView;
 import java.nio.file.attribute.DosFileAttributes;
@@ -269,7 +270,7 @@ public class FileUtils {
     }
 
     if (isSymbolicLink(fileToAdd)) {
-      return fileToAdd.toPath().toRealPath().getFileName().toString();
+      return fileToAdd.toPath().toRealPath(LinkOption.NOFOLLOW_LINKS).getFileName().toString();
     }
 
     return fileToAdd.getName();
@@ -327,10 +328,17 @@ public class FileUtils {
     }
   }
 
-  public static void assertFilesExist(List<File> files) throws ZipException {
+  public static void assertFilesExist(List<File> files, ZipParameters.SymbolicLinkAction symLinkAction) throws ZipException {
     for (File file : files) {
-      if (!file.exists()) {
-        throw new ZipException("File does not exist: " + file);
+      if (isSymbolicLink(file)) {
+        // If symlink is INCLUDE_LINK_ONLY, and if the above condition is true, it means that the link exists and there
+        // will be no need to check for link existence explicitly, check only for target file existence if required
+        if (symLinkAction.equals(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE)
+            || symLinkAction.equals(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY)) {
+          assertSymbolicLinkTargetExists(file);
+        }
+      } else {
+        assertFileExists(file);
       }
     }
   }
@@ -380,6 +388,14 @@ public class FileUtils {
     }
   }
 
+  public static String readSymbolicLink(File file) {
+    try {
+      return Files.readSymbolicLink(file.toPath()).toString();
+    } catch (Exception | Error e) {
+      return "";
+    }
+  }
+
   private static String getExtensionZerosPrefix(int index) {
     if (index < 9) {
       return "00";
@@ -396,7 +412,7 @@ public class FileUtils {
       return;
     }
 
-    DosFileAttributeView fileAttributeView = Files.getFileAttributeView(file, DosFileAttributeView.class);
+    DosFileAttributeView fileAttributeView = Files.getFileAttributeView(file, DosFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);
     try {
       fileAttributeView.setReadOnly(isBitSet(fileAttributes[0], 0));
       fileAttributeView.setHidden(isBitSet(fileAttributes[0], 1));
@@ -434,7 +450,8 @@ public class FileUtils {
     byte[] fileAttributes = new byte[4];
 
     try {
-      DosFileAttributeView dosFileAttributeView = Files.getFileAttributeView(file, DosFileAttributeView.class);
+      DosFileAttributeView dosFileAttributeView = Files.getFileAttributeView(file, DosFileAttributeView.class,
+          LinkOption.NOFOLLOW_LINKS);
       DosFileAttributes dosFileAttributes = dosFileAttributeView.readAttributes();
 
       byte windowsAttribute = 0;
@@ -451,6 +468,18 @@ public class FileUtils {
     return fileAttributes;
   }
 
+  private static void assertFileExists(File file) throws ZipException {
+    if (!file.exists()) {
+      throw new ZipException("File does not exist: " + file);
+    }
+  }
+
+  private static void assertSymbolicLinkTargetExists(File file) throws ZipException {
+    if (!file.exists()) {
+      throw new ZipException("Symlink target '" + readSymbolicLink(file) + "' does not exist for link '" + file + "'");
+    }
+  }
+
   private static byte[] getPosixFileAttributes(Path file) {
     byte[] fileAttributes = new byte[4];
 
diff --git a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
index e048c52..b116c74 100644
--- a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
@@ -426,6 +426,76 @@ public class CreateZipFileIT extends AbstractIT {
         "sub-folder2/symlink.link");
   }
 
+  @Test
+  public void testAddSymlinkWithLinkOnlyMissingTarget() throws IOException {
+    File targetFile = Paths.get(temporaryFolder.getRoot().getAbsolutePath(), "foo").toFile();
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+
+    zipFile.addFile(symlink, zipParameters);
+
+    assertThat(zipFile.getFileHeaders()).hasSize(1);
+    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo(symlink.getName());
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 1, false);
+    verifyGeneratedSymlink(symlink, targetFile);
+  }
+
+  @Test
+  public void testAddSymlinkWithLinkedFileOnlyMissingTargetThrowsException() throws IOException {
+    testAddSymlinkThrowsExceptionForMissingTarget(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
+  }
+
+  @Test
+  public void testAddSymlinkWithLinkAndLinkedFileMissingTargetThrowsException() throws IOException {
+    testAddSymlinkThrowsExceptionForMissingTarget(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkOnlyMissingTarget() throws IOException {
+    Path testFolderPath = temporaryFolder.newFolder("test-folder").toPath();
+    Path subFolder1 = Files.createDirectory(Paths.get(testFolderPath.toString(), "sub-folder1"));
+    Path subFolder2 = Files.createDirectory(Paths.get(testFolderPath.toString(), "sub-folder2"));
+
+    File targetFile = Paths.get(temporaryFolder.getRoot().getAbsolutePath(), "foo").toFile();
+
+    createSymlink(targetFile, testFolderPath.toFile());
+    createSymlink(getTestFileFromResources("file_PDF_1MB.pdf"), subFolder1.toFile());
+    createSymlink(getTestFileFromResources("sample_text_large.txt"), subFolder2.toFile());
+
+    File testFolder = testFolderPath.toFile();
+
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 6, false);
+    verifyFileNamesInZip(zipFile,
+        "test-folder/",
+        "test-folder/symlink.link",
+        "test-folder/sub-folder1/",
+        "test-folder/sub-folder1/symlink.link",
+        "test-folder/sub-folder2/",
+        "test-folder/sub-folder2/symlink.link");
+  }
+
+  private void testAddSymlinkThrowsExceptionForMissingTarget(ZipParameters.SymbolicLinkAction symbolicLinkAction)
+      throws IOException {
+    File targetFile = Paths.get(temporaryFolder.getRoot().getAbsolutePath(), "foo").toFile();
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(symbolicLinkAction);
+
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("Symlink target '" + targetFile + "' does not exist for link '" + symlink + "'");
+
+    zipFile.addFile(symlink, zipParameters);
+  }
+
   private void testCreateZipFileWithFileEntryComment(String fileCommentPrefix, Charset charset) throws IOException {
     ZipParameters zipParameters = new ZipParameters();
     ZipFile zipFile = initializeZipFileWithCharset(charset);
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
index f0e324a..41752fc 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
@@ -2,6 +2,7 @@ package net.lingala.zip4j.util;
 
 import net.lingala.zip4j.AbstractIT;
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.RandomAccessFileMode;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.testutils.TestUtils;
@@ -18,6 +19,7 @@ import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -131,6 +133,60 @@ public class FileUtilsIT extends AbstractIT {
     }
   }
 
+  @Test
+  public void testAssertFilesExistWhenFileExistsDoesNotThrowException() throws IOException {
+    File newFile = temporaryFolder.newFile("new-file");
+    FileUtils.assertFilesExist(Collections.singletonList(newFile), ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+  }
+
+  @Test
+  public void testAssertFilesExistWhenFileDoesNotExistThrowsException() throws IOException {
+    File newFile = Paths.get(temporaryFolder.getRoot().getPath(), "file-which-does-not-exist").toFile();
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("File does not exist: " + newFile);
+
+    FileUtils.assertFilesExist(Collections.singletonList(newFile), ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+  }
+
+  @Test
+  public void testAssertFilesExistForSymLinkWhenTargetDoesNotExistIncludeLinkOnlySuccess() throws IOException {
+    File targetFile = Paths.get(temporaryFolder.getRoot().getPath(), "file-which-does-not-exist").toFile();
+    File symlink = Paths.get(temporaryFolder.getRoot().getPath(), "symlink.link").toFile();
+    Files.createSymbolicLink(symlink.toPath(), targetFile.toPath());
+
+    FileUtils.assertFilesExist(Collections.singletonList(symlink), ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+  }
+
+  @Test
+  public void testAssertFilesExistForSymLinkWhenTargetDoesNotExistIncludeLinkedFileOnlyThrowsException() throws IOException {
+    testAssertFileExistsForSymLinkWhenTargetDoesNotExist(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
+  }
+
+  @Test
+  public void testAssertFilesExistForSymLinkWhenTargetDoesNotExistIncludeLinkAndLinkedFileThrowsException() throws IOException {
+    testAssertFileExistsForSymLinkWhenTargetDoesNotExist(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+  }
+
+  @Test
+  public void testReadSymbolicLink() throws IOException {
+    File targetFile = temporaryFolder.newFile("target-file");
+    File symlink = Paths.get(temporaryFolder.getRoot().getPath(), "symlink.link").toFile();
+    Files.createSymbolicLink(symlink.toPath(), targetFile.toPath());
+
+    assertThat(FileUtils.readSymbolicLink(symlink)).isEqualTo(targetFile.getPath());
+  }
+
+  private void testAssertFileExistsForSymLinkWhenTargetDoesNotExist(ZipParameters.SymbolicLinkAction symbolicLinkAction) throws IOException {
+    File targetFile = Paths.get(temporaryFolder.getRoot().getPath(), "file-which-does-not-exist").toFile();
+    File symlink = Paths.get(temporaryFolder.getRoot().getPath(), "symlink.link").toFile();
+    Files.createSymbolicLink(symlink.toPath(), targetFile.toPath());
+
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("Symlink target '" + targetFile + "' does not exist for link '" + symlink + "'");
+
+    FileUtils.assertFilesExist(Collections.singletonList(symlink), symbolicLinkAction);
+  }
+
   private void testInvalidOffsetsScenario(int start, int offset) throws IOException {
     expectedException.expectMessage("invalid offsets");
     expectedException.expect(ZipException.class);
