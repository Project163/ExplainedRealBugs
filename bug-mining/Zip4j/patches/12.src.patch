diff --git a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
index b7ce094..a5c5dc5 100644
--- a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
+++ b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
@@ -135,6 +135,10 @@ public class FileHeaderFactory {
   private AESExtraDataRecord generateAESExtraDataRecord(ZipParameters parameters) throws ZipException {
     AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();
 
+    if (parameters.getAesVersion() != null) {
+      aesExtraDataRecord.setAesVersion(parameters.getAesVersion());
+    }
+
     if (parameters.getAesKeyStrength() == AesKeyStrength.KEY_STRENGTH_128) {
       aesExtraDataRecord.setAesKeyStrength(AesKeyStrength.KEY_STRENGTH_128);
     } else if (parameters.getAesKeyStrength() == AesKeyStrength.KEY_STRENGTH_192) {
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
index 57688ca..f763332 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
@@ -30,6 +30,7 @@ import net.lingala.zip4j.model.Zip64EndOfCentralDirectoryRecord;
 import net.lingala.zip4j.model.Zip64ExtendedInfo;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.util.RawIO;
@@ -648,7 +649,7 @@ public class HeaderReader {
         aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());
 
         byte[] aesData = extraDataRecord.getData();
-        aesExtraDataRecord.setVersionNumber(rawIO.readShortLittleEndian(aesData, 0));
+        aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0)));
         byte[] vendorIDBytes = new byte[2];
         System.arraycopy(aesData, 2, vendorIDBytes, 0, 2);
         aesExtraDataRecord.setVendorID(new String(vendorIDBytes));
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java b/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java
index 0a9ef6e..6aa2ca1 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java
@@ -126,7 +126,7 @@ public class HeaderWriter {
         AESExtraDataRecord aesExtraDataRecord = localFileHeader.getAesExtraDataRecord();
         rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) aesExtraDataRecord.getSignature().getValue());
         rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getDataSize());
-        rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getVersionNumber());
+        rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getAesVersion().getVersionNumber());
         byteArrayOutputStream.write(aesExtraDataRecord.getVendorID().getBytes());
 
         byte[] aesStrengthBytes = new byte[1];
@@ -497,7 +497,7 @@ public class HeaderWriter {
         AESExtraDataRecord aesExtraDataRecord = fileHeader.getAesExtraDataRecord();
         rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) aesExtraDataRecord.getSignature().getValue());
         rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getDataSize());
-        rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getVersionNumber());
+        rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getAesVersion().getVersionNumber());
         byteArrayOutputStream.write(aesExtraDataRecord.getVendorID().getBytes());
 
         byte[] aesStrengthBytes = new byte[1];
diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
index 4cc21a6..991b194 100755
--- a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
@@ -8,6 +8,7 @@ import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
+import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.util.RawIO;
@@ -79,8 +80,7 @@ public class ZipOutputStream extends OutputStream {
     fileHeader.setUncompressedSize(uncompressedSizeForThisEntry);
     localFileHeader.setUncompressedSize(uncompressedSizeForThisEntry);
 
-    //Skip writing crc for AES encrypted files
-    if (!fileHeader.isEncrypted() || !EncryptionMethod.AES.equals(fileHeader.getEncryptionMethod())) {
+    if (writeCrc(fileHeader)) {
       fileHeader.setCrc(crc32.getValue());
       localFileHeader.setCrc(crc32.getValue());
     }
@@ -181,6 +181,16 @@ public class ZipOutputStream extends OutputStream {
     }
   }
 
+  private boolean writeCrc(FileHeader fileHeader) {
+    boolean isAesEncrypted = fileHeader.isEncrypted() && fileHeader.getEncryptionMethod().equals(EncryptionMethod.AES);
+
+    if (!isAesEncrypted) {
+      return true;
+    }
+
+    return fileHeader.getAesExtraDataRecord().getAesVersion().equals(AesVersion.ONE);
+  }
+
   private boolean isEntryDirectory(String entryName) {
     return entryName.endsWith("/") || entryName.endsWith("\\");
   }
diff --git a/src/main/java/net/lingala/zip4j/model/AESExtraDataRecord.java b/src/main/java/net/lingala/zip4j/model/AESExtraDataRecord.java
index e4b5082..f6678b6 100755
--- a/src/main/java/net/lingala/zip4j/model/AESExtraDataRecord.java
+++ b/src/main/java/net/lingala/zip4j/model/AESExtraDataRecord.java
@@ -18,12 +18,13 @@ package net.lingala.zip4j.model;
 
 import net.lingala.zip4j.headers.HeaderSignature;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 
 public class AESExtraDataRecord extends ZipHeader {
 
   private int dataSize;
-  private int versionNumber;
+  private AesVersion aesVersion;
   private String vendorID;
   private AesKeyStrength aesKeyStrength;
   private CompressionMethod compressionMethod;
@@ -31,10 +32,7 @@ public class AESExtraDataRecord extends ZipHeader {
   public AESExtraDataRecord() {
     setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD);
     dataSize = 7;
-    // Always set the version number to 2 as we do not store CRC for any AES encrypted files
-    // only MAC is stored and as per the specification, if version number is 2, then MAC is read
-    // and CRC is ignored
-    versionNumber = 2;
+    aesVersion = AesVersion.TWO;
     vendorID = "AE";
     aesKeyStrength = AesKeyStrength.KEY_STRENGTH_256;
     compressionMethod = CompressionMethod.DEFLATE;
@@ -48,12 +46,12 @@ public class AESExtraDataRecord extends ZipHeader {
     this.dataSize = dataSize;
   }
 
-  public int getVersionNumber() {
-    return versionNumber;
+  public AesVersion getAesVersion() {
+    return aesVersion;
   }
 
-  public void setVersionNumber(int versionNumber) {
-    this.versionNumber = versionNumber;
+  public void setAesVersion(AesVersion aesVersion) {
+    this.aesVersion = aesVersion;
   }
 
   public String getVendorID() {
diff --git a/src/main/java/net/lingala/zip4j/model/ZipParameters.java b/src/main/java/net/lingala/zip4j/model/ZipParameters.java
index 511ee52..c9c97d9 100755
--- a/src/main/java/net/lingala/zip4j/model/ZipParameters.java
+++ b/src/main/java/net/lingala/zip4j/model/ZipParameters.java
@@ -17,6 +17,7 @@
 package net.lingala.zip4j.model;
 
 import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionLevel;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
@@ -29,6 +30,7 @@ public class ZipParameters {
   private EncryptionMethod encryptionMethod = EncryptionMethod.NONE;
   private boolean readHiddenFiles = true;
   private AesKeyStrength aesKeyStrength = AesKeyStrength.KEY_STRENGTH_256;
+  private AesVersion aesVersion = AesVersion.TWO;
   private boolean includeRootFolder = true;
   private long entryCRC;
   private String defaultFolderPath;
@@ -47,6 +49,7 @@ public class ZipParameters {
     this.encryptionMethod = zipParameters.getEncryptionMethod();
     this.readHiddenFiles = zipParameters.isReadHiddenFiles();
     this.aesKeyStrength = zipParameters.getAesKeyStrength();
+    this.aesVersion = zipParameters.getAesVersion();
     this.includeRootFolder = zipParameters.isIncludeRootFolder();
     this.entryCRC = zipParameters.getEntryCRC();
     this.defaultFolderPath = zipParameters.getDefaultFolderPath();
@@ -108,6 +111,14 @@ public class ZipParameters {
     this.aesKeyStrength = aesKeyStrength;
   }
 
+  public AesVersion getAesVersion() {
+    return aesVersion;
+  }
+
+  public void setAesVersion(AesVersion aesVersion) {
+    this.aesVersion = aesVersion;
+  }
+
   public boolean isIncludeRootFolder() {
     return includeRootFolder;
   }
diff --git a/src/main/java/net/lingala/zip4j/model/enums/AesVersion.java b/src/main/java/net/lingala/zip4j/model/enums/AesVersion.java
new file mode 100644
index 0000000..00fd668
--- /dev/null
+++ b/src/main/java/net/lingala/zip4j/model/enums/AesVersion.java
@@ -0,0 +1,27 @@
+package net.lingala.zip4j.model.enums;
+
+public enum AesVersion {
+
+  ONE(1),
+  TWO(2);
+
+  private int versionNumber;
+
+  AesVersion(int versionNumber) {
+    this.versionNumber = versionNumber;
+  }
+
+  public int getVersionNumber() {
+    return versionNumber;
+  }
+
+  public static AesVersion getFromVersionNumber(int versionNumber) {
+    for (AesVersion aesVersion : values()) {
+      if (aesVersion.versionNumber == versionNumber) {
+        return aesVersion;
+      }
+    }
+
+    throw new IllegalArgumentException("Unsupported Aes version");
+  }
+}
diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index 38b9f0a..b3cef0e 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -8,6 +8,7 @@ import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -290,7 +291,21 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWithAes256Encryption() throws IOException {
+  public void testAddFilesWithAes256EncryptionV1() throws IOException {
+    ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
+    zipParameters.setAesVersion(AesVersion.ONE);
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+
+    zipFile.addFiles(FILES_TO_ADD, zipParameters);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size());
+    List<String> fileNames = FILES_TO_ADD.stream().map(File::getName).collect(Collectors.toList());
+    verifyZipFileContainsFiles(generatedZipFile, fileNames, CompressionMethod.DEFLATE, EncryptionMethod.AES,
+        AesKeyStrength.KEY_STRENGTH_256, AesVersion.ONE);
+  }
+
+  @Test
+  public void testAddFilesWithAes256EncryptionV2() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
 
@@ -598,11 +613,11 @@ public class AddFilesToZipIT extends AbstractIT {
     zipFile.addStream(inputStream, zipParameters);
 
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 4);
-    verifyFileIsOf(generatedZipFile, "가나다.abc", CompressionMethod.DEFLATE, EncryptionMethod.NONE, null);
+    verifyFileIsOf(generatedZipFile, "가나다.abc", CompressionMethod.DEFLATE, EncryptionMethod.NONE, null, null);
   }
 
   @Test
-  public void testAddStreamToZipWithAesEncryptionForExistingZipAddsSuccessfully() throws IOException {
+  public void testAddStreamToZipWithAesEncryptionV2ForExistingZipAddsSuccessfully() throws IOException {
     File fileToAdd = TestUtils.getTestFileFromResources("가나다.abc");
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     zipParameters.setFileNameInZip(fileToAdd.getName());
@@ -614,16 +629,40 @@ public class AddFilesToZipIT extends AbstractIT {
 
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 4);
     verifyFileIsOf(generatedZipFile, "가나다.abc", CompressionMethod.DEFLATE, EncryptionMethod.AES,
-        AesKeyStrength.KEY_STRENGTH_128);
+        AesKeyStrength.KEY_STRENGTH_128, AesVersion.TWO);
+  }
+
+  @Test
+  public void testAddStreamToZipWithAesEncryptionV1ForExistingZipAddsSuccessfully() throws IOException {
+    File fileToAdd = TestUtils.getTestFileFromResources("가나다.abc");
+    ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
+    zipParameters.setAesVersion(AesVersion.ONE);
+    zipParameters.setFileNameInZip(fileToAdd.getName());
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    zipFile.addFiles(FILES_TO_ADD);
+    InputStream inputStream = new FileInputStream(fileToAdd);
+
+    zipFile.addStream(inputStream, zipParameters);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 4);
+    verifyFileIsOf(generatedZipFile, "가나다.abc", CompressionMethod.DEFLATE, EncryptionMethod.AES,
+        AesKeyStrength.KEY_STRENGTH_256, AesVersion.ONE);
   }
 
   private void verifyZipFileContainsFiles(File generatedZipFile, List<String> fileNames,
                                           CompressionMethod compressionMethod, EncryptionMethod encryptionMethod,
                                           AesKeyStrength aesKeyStrength) throws ZipException {
+    verifyZipFileContainsFiles(generatedZipFile, fileNames, compressionMethod, encryptionMethod, aesKeyStrength,
+        AesVersion.TWO);
+  }
+
+  private void verifyZipFileContainsFiles(File generatedZipFile, List<String> fileNames,
+                                          CompressionMethod compressionMethod, EncryptionMethod encryptionMethod,
+                                          AesKeyStrength aesKeyStrength, AesVersion aesVersion) throws ZipException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     List<FileHeader> fileHeaders = zipFile.getFileHeaders();
     verifyFileHeadersContainsFiles(fileHeaders, fileNames);
-    verifyAllFilesAreOf(fileHeaders, compressionMethod, encryptionMethod, aesKeyStrength);
+    verifyAllFilesAreOf(fileHeaders, compressionMethod, encryptionMethod, aesKeyStrength, aesVersion);
   }
 
   private void verifyFoldersInZip(List<FileHeader> fileHeaders, File generatedZipFile, char[] password)
@@ -665,12 +704,14 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   private void verifyAllFilesAreOf(List<FileHeader> fileHeaders, CompressionMethod compressionMethod,
-                                   EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength) {
+                                   EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength,
+                                   AesVersion aesVersion) {
     for (FileHeader fileHeader : fileHeaders) {
       if (fileHeader.isDirectory()) {
         assertThat(fileHeader.getCompressionMethod()).isEqualTo(CompressionMethod.STORE);
         assertThat(fileHeader.isEncrypted()).isFalse();
         assertThat(fileHeader.getAesExtraDataRecord()).isNull();
+        assertThat(fileHeader.getCrc()).isZero();
       } else {
         CompressionMethod shouldBeCompressionMethod = getShouldBeCompressionMethod(
             encryptionMethod == EncryptionMethod.AES, compressionMethod, fileHeader.getUncompressedSize());
@@ -683,7 +724,15 @@ public class AddFilesToZipIT extends AbstractIT {
         }
 
         if (encryptionMethod == EncryptionMethod.AES) {
-          verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), aesKeyStrength);
+          verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), aesKeyStrength, aesVersion);
+
+          if (fileHeader.getAesExtraDataRecord().getAesVersion().equals(AesVersion.TWO)) {
+            assertThat(fileHeader.getCrc()).isZero();
+          } else {
+            if (fileHeader.getCompressedSize() != 0) {
+              assertThat(fileHeader.getCrc()).isNotZero();
+            }
+          }
         } else {
           assertThat(fileHeader.getAesExtraDataRecord()).isNull();
         }
@@ -692,7 +741,9 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   private void verifyFileIsOf(File generatedZipFile, String fileName, CompressionMethod compressionMethod,
-                              EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength) throws ZipException {
+                              EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength, AesVersion aesVersion)
+      throws ZipException {
+
     List<FileHeader> fileHeaders = getFileHeaders(generatedZipFile);
     FileHeader fileHeader = getFileHeaderFrom(fileHeaders, fileName);
 
@@ -700,7 +751,7 @@ public class AddFilesToZipIT extends AbstractIT {
       assertThat(fileHeader.isEncrypted()).isFalse();
       assertThat(fileHeader.getEncryptionMethod()).isIn(null, EncryptionMethod.NONE);
     } else {
-      verifyAllFilesAreOf(singletonList(fileHeader), compressionMethod, encryptionMethod, aesKeyStrength);
+      verifyAllFilesAreOf(singletonList(fileHeader), compressionMethod, encryptionMethod, aesKeyStrength, aesVersion);
     }
   }
 
@@ -719,9 +770,11 @@ public class AddFilesToZipIT extends AbstractIT {
     return fileHeaders;
   }
 
-  private void verifyAesExtraDataRecord(AESExtraDataRecord aesExtraDataRecord, AesKeyStrength aesKeyStrength) {
+  private void verifyAesExtraDataRecord(AESExtraDataRecord aesExtraDataRecord, AesKeyStrength aesKeyStrength,
+                                        AesVersion aesVersion) {
     assertThat(aesExtraDataRecord).isNotNull();
     assertThat(aesExtraDataRecord.getAesKeyStrength()).isEqualTo(aesKeyStrength);
+    assertThat(aesExtraDataRecord.getAesVersion()).isEqualTo(aesVersion);
   }
 
   private CompressionMethod getShouldBeCompressionMethod(boolean isAesEncrypted, CompressionMethod compressionMethod,
diff --git a/src/test/java/net/lingala/zip4j/headers/FileHeaderFactoryTest.java b/src/test/java/net/lingala/zip4j/headers/FileHeaderFactoryTest.java
index 31adbf0..f14991a 100644
--- a/src/test/java/net/lingala/zip4j/headers/FileHeaderFactoryTest.java
+++ b/src/test/java/net/lingala/zip4j/headers/FileHeaderFactoryTest.java
@@ -6,6 +6,7 @@ import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionLevel;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
@@ -103,7 +104,7 @@ public class FileHeaderFactoryTest {
     FileHeader fileHeader = fileHeaderFactory.generateFileHeader(zipParameters, false, 0);
     verifyFileHeader(fileHeader, zipParameters, false, 0, true);
     verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), AesKeyStrength.KEY_STRENGTH_256,
-        CompressionMethod.DEFLATE);
+        CompressionMethod.DEFLATE, AesVersion.TWO);
   }
 
   @Test
@@ -116,7 +117,7 @@ public class FileHeaderFactoryTest {
     FileHeader fileHeader = fileHeaderFactory.generateFileHeader(zipParameters, false, 0);
     verifyFileHeader(fileHeader, zipParameters, false, 0, true);
     verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), AesKeyStrength.KEY_STRENGTH_128,
-        CompressionMethod.DEFLATE);
+        CompressionMethod.DEFLATE, AesVersion.TWO);
   }
 
   @Test
@@ -129,7 +130,7 @@ public class FileHeaderFactoryTest {
     FileHeader fileHeader = fileHeaderFactory.generateFileHeader(zipParameters, false, 0);
     verifyFileHeader(fileHeader, zipParameters, false, 0, true);
     verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), AesKeyStrength.KEY_STRENGTH_192,
-        CompressionMethod.DEFLATE);
+        CompressionMethod.DEFLATE, AesVersion.TWO);
   }
 
   @Test
@@ -142,7 +143,35 @@ public class FileHeaderFactoryTest {
     FileHeader fileHeader = fileHeaderFactory.generateFileHeader(zipParameters, false, 0);
     verifyFileHeader(fileHeader, zipParameters, false, 0, true);
     verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), AesKeyStrength.KEY_STRENGTH_256,
-        CompressionMethod.DEFLATE);
+        CompressionMethod.DEFLATE, AesVersion.TWO);
+  }
+
+  @Test
+  public void testGenerateFileHeaderWithAesEncryptionVersionV1() throws ZipException {
+    ZipParameters zipParameters = generateZipParameters();
+    zipParameters.setEncryptFiles(true);
+    zipParameters.setEncryptionMethod(EncryptionMethod.AES);
+    zipParameters.setAesKeyStrength(AesKeyStrength.KEY_STRENGTH_256);
+    zipParameters.setAesVersion(AesVersion.ONE);
+
+    FileHeader fileHeader = fileHeaderFactory.generateFileHeader(zipParameters, false, 0);
+    verifyFileHeader(fileHeader, zipParameters, false, 0, true);
+    verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), AesKeyStrength.KEY_STRENGTH_256,
+        CompressionMethod.DEFLATE, AesVersion.ONE);
+  }
+
+  @Test
+  public void testGenerateFileHeaderWithAesEncryptionWithNullVersionUsesV2() throws ZipException {
+    ZipParameters zipParameters = generateZipParameters();
+    zipParameters.setEncryptFiles(true);
+    zipParameters.setEncryptionMethod(EncryptionMethod.AES);
+    zipParameters.setAesKeyStrength(AesKeyStrength.KEY_STRENGTH_256);
+    zipParameters.setAesVersion(null);
+
+    FileHeader fileHeader = fileHeaderFactory.generateFileHeader(zipParameters, false, 0);
+    verifyFileHeader(fileHeader, zipParameters, false, 0, true);
+    verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), AesKeyStrength.KEY_STRENGTH_256,
+        CompressionMethod.DEFLATE, AesVersion.TWO);
   }
 
   @Test
@@ -318,13 +347,13 @@ public class FileHeaderFactoryTest {
   }
 
   private void verifyAesExtraDataRecord(AESExtraDataRecord aesExtraDataRecord, AesKeyStrength aesKeyStrength,
-                                        CompressionMethod compressionMethod) {
+                                        CompressionMethod compressionMethod, AesVersion aesVersion) {
     assertThat(aesExtraDataRecord).isNotNull();
     assertThat(aesExtraDataRecord.getSignature()).isEqualTo(HeaderSignature.AES_EXTRA_DATA_RECORD);
     assertThat(aesExtraDataRecord.getDataSize()).isEqualTo(7);
     assertThat(aesExtraDataRecord.getVendorID()).isEqualTo("AE");
     assertThat(aesExtraDataRecord.getCompressionMethod()).isEqualTo(compressionMethod);
-    assertThat(aesExtraDataRecord.getVersionNumber()).isEqualTo(2);
+    assertThat(aesExtraDataRecord.getAesVersion()).isEqualTo(aesVersion);
     assertThat(aesExtraDataRecord.getAesKeyStrength()).isEqualTo(aesKeyStrength);
   }
 
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
index 49740ab..10ea59d 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
@@ -12,6 +12,7 @@ import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.Zip64ExtendedInfo;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.model.enums.RandomAccessFileMode;
@@ -112,18 +113,33 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testWriteLocalFileHeaderWithAes256() throws IOException {
-    testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_256);
+  public void testWriteLocalFileHeaderWithAes256v1() throws IOException {
+    testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_256, AesVersion.ONE);
   }
 
   @Test
-  public void testWriteLocalFileHeaderWithAes192() throws IOException {
-    testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_192);
+  public void testWriteLocalFileHeaderWithAes192v1() throws IOException {
+    testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_192, AesVersion.ONE);
   }
 
   @Test
-  public void testWriteLocalFileHeaderWithAes128() throws IOException {
-    testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_128);
+  public void testWriteLocalFileHeaderWithAes128v1() throws IOException {
+    testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_128, AesVersion.ONE);
+  }
+
+  @Test
+  public void testWriteLocalFileHeaderWithAes256v2() throws IOException {
+    testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_256, AesVersion.TWO);
+  }
+
+  @Test
+  public void testWriteLocalFileHeaderWithAes192v2() throws IOException {
+    testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_192, AesVersion.TWO);
+  }
+
+  @Test
+  public void testWriteLocalFileHeaderWithAes128v2() throws IOException {
+    testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_128, AesVersion.TWO);
   }
 
   @Test
@@ -224,7 +240,7 @@ public class HeaderWriterIT extends AbstractIT {
       verifyZipModel(readZipModel, 10);
 
       for (FileHeader fileHeader : readZipModel.getCentralDirectory().getFileHeaders()) {
-        verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), AesKeyStrength.KEY_STRENGTH_192);
+        verifyAesExtraDataRecord(fileHeader.getAesExtraDataRecord(), AesKeyStrength.KEY_STRENGTH_192, AesVersion.TWO);
         assertThat(fileHeader.getZip64ExtendedInfo()).isNull();
       }
     }
@@ -407,7 +423,7 @@ public class HeaderWriterIT extends AbstractIT {
     for (FileHeader fileHeader : fileHeaders) {
       fileHeader.setEncrypted(true);
       fileHeader.setEncryptionMethod(EncryptionMethod.AES);
-      fileHeader.setAesExtraDataRecord(createAesExtraDataRecord(aesKeyStrength));
+      fileHeader.setAesExtraDataRecord(createAesExtraDataRecord(aesKeyStrength, AesVersion.TWO));
     }
   }
 
@@ -463,11 +479,12 @@ public class HeaderWriterIT extends AbstractIT {
     assertThat(dataDescriptor.getCrc()).isEqualTo(crc);
   }
 
-  private void testWriteLocalFileHeaderWithAes(AesKeyStrength aesKeyStrength) throws IOException {
+  private void testWriteLocalFileHeaderWithAes(AesKeyStrength aesKeyStrength, AesVersion aesVersion)
+      throws IOException {
     ZipModel zipModel = createZipModel(10);
     LocalFileHeader localFileHeaderToWrite = createLocalFileHeader("TEXT", COMPRESSED_SIZE, UNCOMPRESSED_SIZE, true);
     localFileHeaderToWrite.setEncryptionMethod(EncryptionMethod.AES);
-    localFileHeaderToWrite.setAesExtraDataRecord(createAesExtraDataRecord(aesKeyStrength));
+    localFileHeaderToWrite.setAesExtraDataRecord(createAesExtraDataRecord(aesKeyStrength, aesVersion));
     File headersFile = temporaryFolder.newFile();
 
     try(OutputStream outputStream = new FileOutputStream(headersFile)) {
@@ -477,25 +494,26 @@ public class HeaderWriterIT extends AbstractIT {
     try(InputStream inputStream = new FileInputStream(headersFile)) {
       LocalFileHeader readLocalFileHeader = headerReader.readLocalFileHeader(inputStream);
       assertThat(readLocalFileHeader.getEncryptionMethod()).isEqualTo(EncryptionMethod.AES);
-      verifyAesExtraDataRecord(readLocalFileHeader.getAesExtraDataRecord(), aesKeyStrength);
+      verifyAesExtraDataRecord(readLocalFileHeader.getAesExtraDataRecord(), aesKeyStrength, aesVersion);
     }
   }
 
-  private AESExtraDataRecord createAesExtraDataRecord(AesKeyStrength aesKeyStrength) {
+  private AESExtraDataRecord createAesExtraDataRecord(AesKeyStrength aesKeyStrength, AesVersion aesVersion) {
     AESExtraDataRecord aesDataRecord = new AESExtraDataRecord();
     aesDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD);
     aesDataRecord.setDataSize(7);
-    aesDataRecord.setVersionNumber(2);
+    aesDataRecord.setAesVersion(aesVersion);
     aesDataRecord.setVendorID("AE");
     aesDataRecord.setAesKeyStrength(aesKeyStrength);
     aesDataRecord.setCompressionMethod(CompressionMethod.DEFLATE);
     return aesDataRecord;
   }
 
-  private void verifyAesExtraDataRecord(AESExtraDataRecord aesExtraDataRecord, AesKeyStrength aesKeyStrength) {
+  private void verifyAesExtraDataRecord(AESExtraDataRecord aesExtraDataRecord, AesKeyStrength aesKeyStrength,
+                                        AesVersion aesVersion) {
     assertThat(aesExtraDataRecord).isNotNull();
     assertThat(aesExtraDataRecord.getAesKeyStrength()).isEqualTo(aesKeyStrength);
-    assertThat(aesExtraDataRecord.getVersionNumber()).isEqualTo(2);
+    assertThat(aesExtraDataRecord.getAesVersion()).isEqualTo(aesVersion);
     assertThat(aesExtraDataRecord.getCompressionMethod()).isEqualTo(CompressionMethod.DEFLATE);
     assertThat(aesExtraDataRecord.getVendorID()).isEqualTo("AE");
   }
diff --git a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
index d4745aa..2839e65 100644
--- a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
@@ -5,8 +5,10 @@ import net.lingala.zip4j.ZipFile;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
+import net.lingala.zip4j.util.InternalZipConstants;
 import org.junit.Test;
 
 import java.io.File;
@@ -64,52 +66,58 @@ public class ZipInputStreamIT extends AbstractIT {
     extractZipFileWithInputStreams(createdZipFile, PASSWORD);
   }
 
+  @Test
+  public void testExtractDeflateWithAesEncryption256AndV1() throws IOException {
+    File createdZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD, AesVersion.ONE);
+    extractZipFileWithInputStreams(createdZipFile, PASSWORD, InternalZipConstants.BUFF_SIZE, AesVersion.ONE);
+  }
+
   @Test
   public void testExtractWithReadLengthLessThan16WithAesAndStoreCompression() throws IOException {
     File createZipFile = createZipFile(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
-    extractZipFileWithInputStreams(createZipFile, PASSWORD, 15);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, 15, AesVersion.TWO);
   }
 
   @Test
   public void testExtractWithReadLengthLessThan16WithAesAndDeflateCompression() throws IOException {
     File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
-    extractZipFileWithInputStreams(createZipFile, PASSWORD, 15);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, 15, AesVersion.TWO);
   }
 
   @Test
   public void testExtractWithReadLengthLessThan16WithZipCryptoAndStoreCompression() throws IOException {
     File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, PASSWORD);
-    extractZipFileWithInputStreams(createZipFile, PASSWORD, 12);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, 12, null);
   }
 
   @Test
   public void testExtractWithReadLengthLessThan16WithZipCryptoAndDeflateCompression() throws IOException {
     File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, PASSWORD);
-    extractZipFileWithInputStreams(createZipFile, PASSWORD, 5);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, 5, null);
   }
 
   @Test
   public void testExtractWithReadLengthGreaterThanButNotMultipleOf16WithAesAndStoreCompression() throws IOException {
     File createZipFile = createZipFile(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
-    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 4) + 1);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 4) + 1, AesVersion.TWO);
   }
 
   @Test
   public void testExtractWithReadLengthGreaterThanButNotMultipleOf16WithAesAndDeflateCompression() throws IOException {
     File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
-    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 8) - 10);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 8) - 10, AesVersion.TWO);
   }
 
   @Test
   public void testExtractWithReadLengthGreaterThanButNotMultipleOf16WithZipCryptoAndStoreCompression() throws IOException {
     File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, PASSWORD);
-    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 2) - 6);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 2) - 6, null);
   }
 
   @Test
   public void testExtractWithReadLengthGreaterThanButNotMultipleOf16WithZipCryptoAndDeflateCompression() throws IOException {
     File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, PASSWORD);
-    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 10) - 11);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 10) - 11, null);
   }
 
   @Test
@@ -140,10 +148,11 @@ public class ZipInputStreamIT extends AbstractIT {
   }
 
   private void extractZipFileWithInputStreams(File zipFile, char[] password) throws IOException {
-    extractZipFileWithInputStreams(zipFile, password, 4096);
+    extractZipFileWithInputStreams(zipFile, password, 4096, AesVersion.TWO);
   }
 
-  private void extractZipFileWithInputStreams(File zipFile, char[] password, int bufferLength) throws IOException {
+  private void extractZipFileWithInputStreams(File zipFile, char[] password, int bufferLength, AesVersion aesVersion)
+      throws IOException {
     LocalFileHeader localFileHeader;
     int readLen;
     byte[] readBuffer = new byte[bufferLength];
@@ -158,6 +167,7 @@ public class ZipInputStreamIT extends AbstractIT {
               outputStream.write(readBuffer, 0, readLen);
             }
           }
+          verifyLocalFileHeader(localFileHeader);
           verifyFileContent(getTestFileFromResources(localFileHeader.getFileName()), extractedFile);
           numberOfEntriesExtracted++;
         }
@@ -167,6 +177,15 @@ public class ZipInputStreamIT extends AbstractIT {
     assertThat(numberOfEntriesExtracted).isEqualTo(FILES_TO_ADD.size());
   }
 
+  private void verifyLocalFileHeader(LocalFileHeader localFileHeader) {
+    assertThat(localFileHeader).isNotNull();
+    if (localFileHeader.isEncrypted()
+        && localFileHeader.getEncryptionMethod().equals(EncryptionMethod.AES)
+        && localFileHeader.getAesExtraDataRecord().getAesVersion().equals(AesVersion.TWO)) {
+      assertThat(localFileHeader.getCrc()).isZero();
+    }
+  }
+
   private File createZipFile(CompressionMethod compressionMethod) throws IOException {
     return createZipFile(compressionMethod, false, null, null, null);
   }
@@ -175,6 +194,14 @@ public class ZipInputStreamIT extends AbstractIT {
                              EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength, char[] password)
       throws IOException {
 
+    return createZipFile(compressionMethod, encryptFiles, encryptionMethod, aesKeyStrength, password, AesVersion.TWO);
+  }
+
+  private File createZipFile(CompressionMethod compressionMethod, boolean encryptFiles,
+                             EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength, char[] password,
+                             AesVersion aesVersion)
+      throws IOException {
+
     File outputFile = temporaryFolder.newFile("output.zip");
     deleteFileIfExists(outputFile);
 
@@ -185,6 +212,7 @@ public class ZipInputStreamIT extends AbstractIT {
     zipParameters.setEncryptFiles(encryptFiles);
     zipParameters.setEncryptionMethod(encryptionMethod);
     zipParameters.setAesKeyStrength(aesKeyStrength);
+    zipParameters.setAesVersion(aesVersion);
 
     zipFile.addFiles(AbstractIT.FILES_TO_ADD, zipParameters);
 
diff --git a/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java b/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
index f475bee..abcbdc1 100644
--- a/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
@@ -6,6 +6,7 @@ import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.util.BitUtils;
@@ -29,48 +30,63 @@ public class ZipOutputStreamIT extends AbstractIT {
 
   @Test
   public void testZipOutputStreamStoreWithoutEncryption() throws IOException {
-    testZipOutputStream(CompressionMethod.STORE, false, null, null);
+    testZipOutputStream(CompressionMethod.STORE, false, null, null, null);
   }
 
   @Test
   public void testZipOutputStreamStoreWithStandardEncryption() throws IOException {
-    testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.ZIP_STANDARD, null);
+    testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.ZIP_STANDARD, null, null);
   }
 
   @Test
-  public void testZipOutputStreamStoreWithAES128() throws IOException {
-    testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
+  public void testZipOutputStreamStoreWithAES256V1() throws IOException {
+    testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, AesVersion.ONE);
   }
 
   @Test
-  public void testZipOutputStreamStoreWithAES256() throws IOException {
-    testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
+  public void testZipOutputStreamStoreWithAES128V2() throws IOException {
+    testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128, AesVersion.TWO);
+  }
+
+  @Test
+  public void testZipOutputStreamStoreWithAES256V2() throws IOException {
+    testZipOutputStream(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, AesVersion.TWO);
   }
 
   @Test
   public void testZipOutputStreamDeflateWithoutEncryption() throws IOException {
-    testZipOutputStream(CompressionMethod.DEFLATE, false, null, null);
+    testZipOutputStream(CompressionMethod.DEFLATE, false, null, null, null);
   }
 
   @Test
   public void testZipOutputStreamDeflateWithStandardEncryption() throws IOException {
-    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null);
+    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, null);
   }
 
   @Test
   public void testZipOutputStreamDeflateWithStandardEncryptionWhenModifiedFileTimeNotSet()
       throws IOException {
-    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, false);
+    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, null, false);
+  }
+
+  @Test
+  public void testZipOutputStreamDeflateWithAES128V1() throws IOException {
+    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128, AesVersion.ONE);
   }
 
   @Test
   public void testZipOutputStreamDeflateWithAES128() throws IOException {
-    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
+    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128, AesVersion.TWO);
   }
 
   @Test
   public void testZipOutputStreamDeflateWithAES256() throws IOException {
-    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
+    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, AesVersion.TWO);
+  }
+
+  @Test
+  public void testZipOutputStreamDeflateWithNullVersionUsesV2() throws IOException {
+    testZipOutputStream(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, null);
   }
 
   @Test
@@ -91,17 +107,20 @@ public class ZipOutputStreamIT extends AbstractIT {
   }
 
   private void testZipOutputStream(CompressionMethod compressionMethod, boolean encrypt,
-                                   EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength)
+                                   EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength,
+                                   AesVersion aesVersion)
       throws IOException {
-    testZipOutputStream(compressionMethod, encrypt, encryptionMethod, aesKeyStrength, true);
+    testZipOutputStream(compressionMethod, encrypt, encryptionMethod, aesKeyStrength, aesVersion, true);
   }
 
   private void testZipOutputStream(CompressionMethod compressionMethod, boolean encrypt,
                                    EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength,
-                                   boolean setLastModifiedTime)
+                                   AesVersion aesVersion, boolean setLastModifiedTime)
       throws IOException {
 
     ZipParameters zipParameters = buildZipParameters(compressionMethod, encrypt, encryptionMethod, aesKeyStrength);
+    zipParameters.setAesVersion(aesVersion);
+
     byte[] buff = new byte[4096];
     int readLen;
 
@@ -127,14 +146,24 @@ public class ZipOutputStreamIT extends AbstractIT {
       }
     }
     verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size());
-    verifyDataDescriptorExistsForAllEntries();
+    verifyEntries();
   }
 
-  private void verifyDataDescriptorExistsForAllEntries() throws ZipException {
+  private void verifyEntries() throws ZipException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     for (FileHeader fileHeader : zipFile.getFileHeaders()) {
       byte[] generalPurposeBytes = fileHeader.getGeneralPurposeFlag();
       assertThat(BitUtils.isBitSet(generalPurposeBytes[0], 3)).isTrue();
+
+      if (fileHeader.isEncrypted()
+          && fileHeader.getEncryptionMethod().equals(EncryptionMethod.AES)) {
+
+        if (fileHeader.getAesExtraDataRecord().getAesVersion().equals(AesVersion.TWO)) {
+          assertThat(fileHeader.getCrc()).isZero();
+        } else if (fileHeader.getCompressedSize() > 0) {
+          assertThat(fileHeader.getCrc()).isNotZero();
+        }
+      }
     }
   }
 
