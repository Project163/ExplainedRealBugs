diff --git a/pom.xml b/pom.xml
index ca0518e..bffb763 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
 
     <groupId>net.lingala.zip4j</groupId>
     <artifactId>zip4j</artifactId>
-    <version>2.2.3</version>
+    <version>2.2.4.1-SNAPSHOT</version>
 
     <name>Zip4j</name>
     <description>Zip4j - A Java library for zip files and streams</description>
diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index 0dfac98..40e0030 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -846,6 +846,8 @@ public class ZipFile {
       HeaderReader headerReader = new HeaderReader();
       zipModel = headerReader.readAllHeaders(randomAccessFile, charset);
       zipModel.setZipFile(zipFile);
+    } catch (ZipException e) {
+      throw e;
     } catch (IOException e) {
       throw new ZipException(e);
     }
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
index 972e8ec..f829fa8 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
@@ -49,6 +49,7 @@ import static net.lingala.zip4j.headers.HeaderUtil.decodeStringWithCharset;
 import static net.lingala.zip4j.util.BitUtils.isBitSet;
 import static net.lingala.zip4j.util.InternalZipConstants.ENDHDR;
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT;
+import static net.lingala.zip4j.util.Zip4jUtil.readFully;
 
 /**
  * Helper class to read header information for the zip file
@@ -64,6 +65,8 @@ public class HeaderReader {
 
     try {
       zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO));
+    } catch (ZipException e){
+      throw e;
     } catch (IOException e) {
       throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e);
     }
@@ -302,7 +305,7 @@ public class HeaderReader {
     }
 
     byte[] extraFieldBuf = new byte[extraFieldLength];
-    inputStream.read(extraFieldBuf);
+    readFully(inputStream, extraFieldBuf);
 
     try {
       return parseExtraDataRecords(extraFieldBuf, extraFieldLength);
@@ -540,7 +543,7 @@ public class HeaderReader {
     localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));
 
     byte[] generalPurposeFlags = new byte[2];
-    if (inputStream.read(generalPurposeFlags) != 2) {
+    if (readFully(inputStream, generalPurposeFlags) != 2) {
       throw new ZipException("Could not read enough bytes for generalPurposeFlags");
     }
     localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0));
@@ -552,7 +555,7 @@ public class HeaderReader {
         rawIO.readShortLittleEndian(inputStream)));
     localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));
 
-    inputStream.read(intBuff);
+    readFully(inputStream, intBuff);
     localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));
     localFileHeader.setCrcRawData(intBuff.clone());
 
@@ -566,7 +569,7 @@ public class HeaderReader {
 
     if (fileNameLength > 0) {
       byte[] fileNameBuf = new byte[fileNameLength];
-      inputStream.read(fileNameBuf);
+      readFully(inputStream, fileNameBuf);
       // Modified after user reported an issue http://www.lingala.net/zip4j/forum/index.php?topic=2.0
 //				String fileName = new String(fileNameBuf, "Cp850");
 //				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);
@@ -612,7 +615,7 @@ public class HeaderReader {
     DataDescriptor dataDescriptor = new DataDescriptor();
 
     byte[] intBuff = new byte[4];
-    inputStream.read(intBuff);
+    readFully(inputStream, intBuff);
     long sigOrCrc = rawIO.readLongLittleEndian(intBuff, 0);
 
     //According to zip specification, presence of extra data record header signature is optional.
@@ -620,7 +623,7 @@ public class HeaderReader {
     //If signature not present, assign the read 4 bytes for crc
     if (sigOrCrc == HeaderSignature.EXTRA_DATA_RECORD.getValue()) {
       dataDescriptor.setSignature(HeaderSignature.EXTRA_DATA_RECORD);
-      inputStream.read(intBuff);
+      readFully(inputStream, intBuff);
       dataDescriptor.setCrc(rawIO.readLongLittleEndian(intBuff, 0));
     } else {
       dataDescriptor.setCrc(sigOrCrc);
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
index 1a68460..ee77dd2 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
@@ -13,6 +13,7 @@ import java.io.InputStream;
 import java.util.Arrays;
 
 import static net.lingala.zip4j.util.InternalZipConstants.AES_AUTH_LENGTH;
+import static net.lingala.zip4j.util.Zip4jUtil.readFully;
 
 class AesCipherInputStream extends CipherInputStream<AESDecrypter> {
 
@@ -142,7 +143,7 @@ class AesCipherInputStream extends CipherInputStream<AESDecrypter> {
 
   protected byte[] readStoredMac(InputStream inputStream) throws IOException {
     byte[] storedMac = new byte[AES_AUTH_LENGTH];
-    int readLen = inputStream.read(storedMac);
+    int readLen = readFully(inputStream, storedMac);
 
     if (readLen != AES_AUTH_LENGTH) {
       throw new ZipException("Invalid AES Mac bytes. Could not read sufficient data");
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
index 870bd13..49bfdef 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
@@ -8,6 +8,8 @@ import net.lingala.zip4j.model.enums.CompressionMethod;
 import java.io.IOException;
 import java.io.InputStream;
 
+import static net.lingala.zip4j.util.Zip4jUtil.readFully;
+
 abstract class CipherInputStream<T extends Decrypter> extends InputStream {
 
   private ZipEntryInputStream zipEntryInputStream;
@@ -44,7 +46,7 @@ abstract class CipherInputStream<T extends Decrypter> extends InputStream {
 
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
-    int readLen = zipEntryInputStream.read(b, off, len);
+    int readLen = readFully(zipEntryInputStream, b, off, len);
 
     if (readLen > 0) {
       cacheRawData(b, readLen);
diff --git a/src/main/java/net/lingala/zip4j/util/RawIO.java b/src/main/java/net/lingala/zip4j/util/RawIO.java
index 6d2a491..39f0c3d 100755
--- a/src/main/java/net/lingala/zip4j/util/RawIO.java
+++ b/src/main/java/net/lingala/zip4j/util/RawIO.java
@@ -150,7 +150,7 @@ public class RawIO {
   }
 
   private void readFully(InputStream inputStream, byte[] buff, int readLen) throws IOException {
-    int actualReadLength = inputStream.read(buff, 0, readLen);
+    int actualReadLength = Zip4jUtil.readFully(inputStream, buff, 0, readLen);
     if (actualReadLength != readLen) {
       throw new ZipException("Could not fill buffer");
     }
diff --git a/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java b/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java
index 2f795d4..9d04aab 100755
--- a/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java
+++ b/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java
@@ -21,10 +21,14 @@ import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
 import java.util.Calendar;
 
 public class Zip4jUtil {
 
+  private static final int MAX_RAW_READ_FULLY_RETRY_ATTEMPTS = 15;
+
   public static boolean isStringNotNullAndNotEmpty(String str) {
     return str != null && str.trim().length() > 0;
   }
@@ -95,4 +99,77 @@ public class Zip4jUtil {
     return localFileHeader.getAesExtraDataRecord().getCompressionMethod();
   }
 
+  public static int readFully(InputStream inputStream, byte[] bufferToReadInto) throws IOException {
+
+    int readLen = inputStream.read(bufferToReadInto);
+
+    if (readLen != bufferToReadInto.length) {
+      readLen = readUntilBufferIsFull(inputStream, bufferToReadInto, readLen);
+
+      if (readLen != bufferToReadInto.length) {
+        throw new IOException("Cannot read fully into byte buffer");
+      }
+    }
+
+    return readLen;
+  }
+
+  public static int readFully(InputStream inputStream, byte[] b, int offset, int length) throws IOException {
+    int numberOfBytesRead = 0;
+
+    if (offset < 0) {
+      throw new IllegalArgumentException("Negative offset");
+    }
+
+    if (length < 0) {
+      throw new IllegalArgumentException("Negative length");
+    }
+
+    if (length == 0) {
+      return 0;
+    }
+
+    if (offset + length > b.length) {
+      throw new IllegalArgumentException("Length greater than buffer size");
+    }
+
+    while (numberOfBytesRead != length) {
+      int currentReadLength = inputStream.read(b, offset + numberOfBytesRead, length - numberOfBytesRead);
+      if (currentReadLength == -1) {
+        if (numberOfBytesRead == 0) {
+          return -1;
+        }
+        return numberOfBytesRead;
+      }
+
+      numberOfBytesRead += currentReadLength;
+    }
+
+    return numberOfBytesRead;
+  }
+
+  private static int readUntilBufferIsFull(InputStream inputStream, byte[] bufferToReadInto, int readLength)
+      throws IOException {
+
+    int remainingLength = bufferToReadInto.length - readLength;
+    int loopReadLength = 0;
+    int retryAttempt = 1; // first attempt is already done before this method is called
+
+    while (readLength < bufferToReadInto.length
+        && loopReadLength != -1
+        && retryAttempt < MAX_RAW_READ_FULLY_RETRY_ATTEMPTS) {
+
+      loopReadLength = inputStream.read(bufferToReadInto, readLength, remainingLength);
+
+      if (loopReadLength > 0) {
+        readLength += loopReadLength;
+        remainingLength -= loopReadLength;
+      }
+
+      retryAttempt++;
+    }
+
+    return readLength;
+  }
+
 }
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 19ef2eb..edc4c84 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -1,6 +1,7 @@
 package net.lingala.zip4j;
 
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
@@ -15,6 +16,7 @@ import org.junit.rules.ExpectedException;
 
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
 import java.nio.file.Files;
 import java.util.HashSet;
 import java.util.List;
@@ -329,6 +331,93 @@ public class ExtractZipFileIT extends AbstractIT {
     }
   }
 
+  @Test
+  public void testExtractNestedZipFileWithNoEncryptionOnInnerAndOuter() throws IOException {
+    testExtractNestedZipFileWithEncrpytion(EncryptionMethod.NONE, EncryptionMethod.NONE);
+  }
+
+  @Test
+  public void testExtractNestedZipFileWithNoEncryptionOnInnerAndZipStandardOuter() throws IOException {
+    testExtractNestedZipFileWithEncrpytion(EncryptionMethod.NONE, EncryptionMethod.ZIP_STANDARD);
+  }
+
+  @Test
+  public void testExtractNestedZipFileWithNoEncryptionOnInnerAndAesdOuter() throws IOException {
+    testExtractNestedZipFileWithEncrpytion(EncryptionMethod.NONE, EncryptionMethod.AES);
+  }
+
+  @Test
+  public void testExtractNestedZipFileWithZipStandardEncryptionOnInnerAndNoneOuter() throws IOException {
+    testExtractNestedZipFileWithEncrpytion(EncryptionMethod.ZIP_STANDARD, EncryptionMethod.NONE);
+  }
+
+  @Test
+  public void testExtractNestedZipFileWitAesOnInnerAndNoneOuter() throws IOException {
+    testExtractNestedZipFileWithEncrpytion(EncryptionMethod.AES, EncryptionMethod.NONE);
+  }
+
+  @Test
+  public void testExtractNestedZipFileWithZipStandardEncryptionOnInnerAndAesOuter() throws IOException {
+    testExtractNestedZipFileWithEncrpytion(EncryptionMethod.ZIP_STANDARD, EncryptionMethod.AES);
+  }
+
+  @Test
+  public void testExtractNestedZipFileWithAesOnInnerAndZipStandardOuter() throws IOException {
+    testExtractNestedZipFileWithEncrpytion(EncryptionMethod.AES, EncryptionMethod.ZIP_STANDARD);
+  }
+
+  private void testExtractNestedZipFileWithEncrpytion(EncryptionMethod innerZipEncryption,
+                                                       EncryptionMethod outerZipEncryption) throws IOException {
+    File innerZipFile = temporaryFolder.newFile("inner.zip");
+    File outerZipFile = temporaryFolder.newFile("outer.zip");
+
+    innerZipFile.delete();
+    outerZipFile.delete();
+
+    createNestedZip(innerZipFile, outerZipFile, innerZipEncryption, outerZipEncryption);
+
+    verifyNestedZipFile(outerZipFile, FILES_TO_ADD.size());
+  }
+
+  private void createNestedZip(File innerSourceZipFile, File outerSourceZipFile, EncryptionMethod innerEncryption,
+                               EncryptionMethod outerEncryption) throws ZipException {
+
+    ZipFile innerZipFile = new ZipFile(innerSourceZipFile, PASSWORD);
+    ZipParameters innerZipParameters = createZipParametersForNestedZip(innerEncryption);
+    innerZipFile.addFiles(FILES_TO_ADD, innerZipParameters);
+
+    ZipFile outerZipFile = new ZipFile(outerSourceZipFile, PASSWORD);
+    ZipParameters outerZipParameters = createZipParametersForNestedZip(outerEncryption);
+    outerZipFile.addFile(innerSourceZipFile, outerZipParameters);
+  }
+
+  private void verifyNestedZipFile(File outerZipFileToVerify, int numberOfFilesInNestedZip) throws IOException {
+    ZipFile zipFile = new ZipFile(outerZipFileToVerify, PASSWORD);
+    FileHeader fileHeader = zipFile.getFileHeader("inner.zip");
+
+    assertThat(fileHeader).isNotNull();
+
+    int actualNumberOfFilesInNestedZip = 0;
+    try(InputStream inputStream = zipFile.getInputStream(fileHeader)) {
+      try(ZipInputStream zipInputStream = new ZipInputStream(inputStream, PASSWORD)) {
+        while (zipInputStream.getNextEntry() != null) {
+          actualNumberOfFilesInNestedZip++;
+        }
+      }
+    }
+
+    assertThat(actualNumberOfFilesInNestedZip).isEqualTo(numberOfFilesInNestedZip);
+  }
+
+  private ZipParameters createZipParametersForNestedZip(EncryptionMethod encryptionMethod) {
+    ZipParameters zipParameters = new ZipParameters();
+    if (encryptionMethod != null && !encryptionMethod.equals(EncryptionMethod.NONE)) {
+      zipParameters.setEncryptFiles(true);
+      zipParameters.setEncryptionMethod(encryptionMethod);
+    }
+    return zipParameters;
+  }
+
   private void verifyNumberOfFilesInOutputFolder(File outputFolder, int numberOfExpectedFiles) {
     assertThat(outputFolder.listFiles()).hasSize(numberOfExpectedFiles);
   }
diff --git a/src/test/java/net/lingala/zip4j/testutils/ControlledReadInputStream.java b/src/test/java/net/lingala/zip4j/testutils/ControlledReadInputStream.java
new file mode 100644
index 0000000..2452676
--- /dev/null
+++ b/src/test/java/net/lingala/zip4j/testutils/ControlledReadInputStream.java
@@ -0,0 +1,38 @@
+package net.lingala.zip4j.testutils;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+public class ControlledReadInputStream extends InputStream {
+
+  private InputStream inputStream;
+  private int readLimit;
+  private byte[] singleByteBuffer = new byte[1];
+
+  public ControlledReadInputStream(InputStream inputStream, int maximumNumberOfBytesToReadAtOnce) {
+    this.inputStream = inputStream;
+    this.readLimit = maximumNumberOfBytesToReadAtOnce;
+  }
+
+  @Override
+  public int read() throws IOException {
+    int readLen = read(singleByteBuffer);
+
+    if (readLen == -1) {
+      return -1;
+    }
+
+    return singleByteBuffer[0];
+  }
+
+  @Override
+  public int read(byte[] b) throws IOException {
+    return read(b, 0, b.length);
+  }
+
+  @Override
+  public int read(byte[] b, int off, int len) throws IOException {
+    int toRead = len > readLimit ? readLimit : len;
+    return inputStream.read(b, off, toRead);
+  }
+}
diff --git a/src/test/java/net/lingala/zip4j/util/Zip4jUtilTest.java b/src/test/java/net/lingala/zip4j/util/Zip4jUtilTest.java
index 6ee7059..0489f23 100644
--- a/src/test/java/net/lingala/zip4j/util/Zip4jUtilTest.java
+++ b/src/test/java/net/lingala/zip4j/util/Zip4jUtilTest.java
@@ -4,11 +4,14 @@ import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.AESExtraDataRecord;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.enums.CompressionMethod;
+import net.lingala.zip4j.testutils.ControlledReadInputStream;
+import net.lingala.zip4j.testutils.RandomInputStream;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.TimeZone;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -154,4 +157,134 @@ public class Zip4jUtilTest {
 
     assertThat(Zip4jUtil.getCompressionMethod(localFileHeader)).isEqualTo(CompressionMethod.STORE);
   }
+
+  @Test
+  public void testReadFullyReadsCompleteBuffer() throws IOException {
+    byte[] b = new byte[3423];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(1000);
+
+    assertThat(Zip4jUtil.readFully(controlledReadInputStream, b)).isEqualTo(3423);
+  }
+
+  @Test
+  public void testReadFullyReadsCompleteBufferInOneShot() throws IOException {
+    byte[] b = new byte[4096];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(4097);
+
+    assertThat(Zip4jUtil.readFully(controlledReadInputStream, b)).isEqualTo(4096);
+  }
+
+  @Test
+  public void testReadFullyThrowsExceptionWhenCannotFillBuffer() throws IOException {
+    byte[] b = new byte[4097];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(500);
+
+    expectedException.expect(IOException.class);
+    expectedException.expectMessage("Cannot read fully into byte buffer");
+
+    Zip4jUtil.readFully(controlledReadInputStream, b);
+  }
+
+  @Test
+  public void testReadFullyOnEmptyStreamThrowsException() throws IOException {
+    byte[] b = new byte[4096];
+    RandomInputStream randomInputStream = new RandomInputStream(0);
+    ControlledReadInputStream controlledReadInputStream = new ControlledReadInputStream(randomInputStream, 100);
+
+    expectedException.expect(IOException.class);
+    expectedException.expectMessage("Cannot read fully into byte buffer");
+
+    assertThat(Zip4jUtil.readFully(controlledReadInputStream, b)).isEqualTo(-1);
+  }
+
+  @Test
+  public void testReadFullyThrowsExceptionWhenRetryLimitExceeds() throws IOException {
+    byte[] b = new byte[151];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(10);
+
+    expectedException.expect(IOException.class);
+    expectedException.expectMessage("Cannot read fully into byte buffer");
+
+    Zip4jUtil.readFully(controlledReadInputStream, b);
+  }
+
+  @Test
+  public void testReadFullyWithLengthReadsCompleteLength() throws IOException {
+    byte[] b = new byte[1000];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(100);
+
+    assertThat(Zip4jUtil.readFully(controlledReadInputStream, b, 0, 900)).isEqualTo(900);
+  }
+
+  @Test
+  public void testReadFullyWithLengthReadsMaximumAvailable() throws IOException {
+    byte[] b = new byte[1000];
+    RandomInputStream randomInputStream = new RandomInputStream(150);
+    ControlledReadInputStream controlledReadInputStream = new ControlledReadInputStream(randomInputStream, 700);
+
+    assertThat(Zip4jUtil.readFully(controlledReadInputStream, b, 0, 900)).isEqualTo(150);
+  }
+
+  @Test
+  public void testReadFullyWithLengthReadsCompletelyIntoBuffer() throws IOException {
+    byte[] b = new byte[1000];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(10);
+
+    assertThat(Zip4jUtil.readFully(controlledReadInputStream, b, 0, 1000)).isEqualTo(1000);
+  }
+
+  @Test
+  public void testReadFullyWithNegativeLengthThrowsException() throws IOException {
+    byte[] b = new byte[1000];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(10);
+
+    expectedException.expect(IllegalArgumentException.class);
+    expectedException.expectMessage("Negative length");
+
+    Zip4jUtil.readFully(controlledReadInputStream, b, 0, -5);
+  }
+
+  @Test
+  public void testReadFullyWithNegativeOffsetThrowsException() throws IOException {
+    byte[] b = new byte[10];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(10);
+
+    expectedException.expect(IllegalArgumentException.class);
+    expectedException.expectMessage("Negative offset");
+
+    Zip4jUtil.readFully(controlledReadInputStream, b, -4, 10);
+  }
+
+  @Test
+  public void testReadFullyWithLengthZeroReturnsZero() throws IOException {
+    byte[] b = new byte[1000];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(100);
+
+    assertThat(Zip4jUtil.readFully(controlledReadInputStream, b, 0, 0)).isZero();
+  }
+
+  @Test
+  public void testReadFullyThrowsExceptionWhenOffsetPlusLengthGreaterThanBufferSize() throws IOException {
+    byte[] b = new byte[10];
+    ControlledReadInputStream controlledReadInputStream = initialiseControlledInputStream(10);
+
+    expectedException.expect(IllegalArgumentException.class);
+    expectedException.expectMessage("Length greater than buffer size");
+
+    Zip4jUtil.readFully(controlledReadInputStream, b, 5, 10);
+  }
+
+  @Test
+  public void testReadFullyWithLengthOnAnEmptyStreamReturnsEOF() throws IOException {
+    byte[] b = new byte[1000];
+    RandomInputStream randomInputStream = new RandomInputStream(-1);
+    ControlledReadInputStream controlledReadInputStream = new ControlledReadInputStream(randomInputStream, 100);
+
+    assertThat(Zip4jUtil.readFully(controlledReadInputStream, b, 0, 100)).isEqualTo(-1);
+  }
+
+  private ControlledReadInputStream initialiseControlledInputStream(int maxLengthToReadAtOnce) {
+    RandomInputStream randomInputStream = new RandomInputStream(4096);
+    return new ControlledReadInputStream(randomInputStream, maxLengthToReadAtOnce);
+  }
 }
\ No newline at end of file
