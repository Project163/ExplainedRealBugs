diff --git a/src/main/java/net/lingala/zip4j/model/ZipParameters.java b/src/main/java/net/lingala/zip4j/model/ZipParameters.java
index 693701c..7cc493d 100755
--- a/src/main/java/net/lingala/zip4j/model/ZipParameters.java
+++ b/src/main/java/net/lingala/zip4j/model/ZipParameters.java
@@ -24,6 +24,8 @@ import net.lingala.zip4j.model.enums.EncryptionMethod;
 
 public class ZipParameters {
 
+  public enum SymbolicLinkAction {INCLUDE_LINK_ONLY, INCLUDE_LINKED_FILE_ONLY, INCLUDE_LINK_AND_LINKED_FILE};
+
   private CompressionMethod compressionMethod = CompressionMethod.DEFLATE;
   private CompressionLevel compressionLevel = CompressionLevel.NORMAL;
   private boolean encryptFiles = false;
@@ -42,6 +44,7 @@ public class ZipParameters {
   private boolean overrideExistingFilesInZip = true;
   private String rootFolderNameInZip;
   private String fileComment;
+  private SymbolicLinkAction symbolicLinkAction = SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY;
 
   public ZipParameters() {
   }
@@ -65,6 +68,7 @@ public class ZipParameters {
     this.overrideExistingFilesInZip = zipParameters.isOverrideExistingFilesInZip();
     this.rootFolderNameInZip = zipParameters.getRootFolderNameInZip();
     this.fileComment = zipParameters.getFileComment();
+    this.symbolicLinkAction = zipParameters.getSymbolicLinkAction();
   }
 
   public CompressionMethod getCompressionMethod() {
@@ -218,4 +222,12 @@ public class ZipParameters {
   public void setFileComment(String fileComment) {
     this.fileComment = fileComment;
   }
+
+  public SymbolicLinkAction getSymbolicLinkAction() {
+    return symbolicLinkAction;
+  }
+
+  public void setSymbolicLinkAction(SymbolicLinkAction symbolicLinkAction) {
+    this.symbolicLinkAction = symbolicLinkAction;
+  }
 }
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
index dfb1385..7e1337d 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
@@ -11,7 +11,9 @@ import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.RemoveEntryFromZipFileTask.RemoveEntryFromZipFileTaskParameters;
+import net.lingala.zip4j.util.BitUtils;
 import net.lingala.zip4j.util.FileUtils;
+import net.lingala.zip4j.util.InternalZipConstants;
 import net.lingala.zip4j.util.Zip4jUtil;
 
 import java.io.File;
@@ -19,10 +21,13 @@ import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.Charset;
+import java.nio.file.Files;
 import java.util.ArrayList;
 import java.util.List;
 
 import static net.lingala.zip4j.headers.HeaderUtil.getFileHeader;
+import static net.lingala.zip4j.model.ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE;
+import static net.lingala.zip4j.model.ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY;
 import static net.lingala.zip4j.model.enums.CompressionMethod.DEFLATE;
 import static net.lingala.zip4j.model.enums.CompressionMethod.STORE;
 import static net.lingala.zip4j.model.enums.EncryptionMethod.NONE;
@@ -40,6 +45,8 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
   private ZipModel zipModel;
   private char[] password;
   private HeaderWriter headerWriter;
+  private byte[] readBuff = new byte[BUFF_SIZE];
+  private int readLen = -1;
 
   AbstractAddFileToZipTask(ProgressMonitor progressMonitor, boolean runInThread, ZipModel zipModel,
                            char[] password, HeaderWriter headerWriter) {
@@ -56,34 +63,75 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
 
     try (SplitOutputStream splitOutputStream = new SplitOutputStream(zipModel.getZipFile(), zipModel.getSplitLength());
          ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, charset)) {
-      byte[] readBuff = new byte[BUFF_SIZE];
-      int readLen = -1;
+
 
       for (File fileToAdd : updatedFilesToAdd) {
         verifyIfTaskIsCancelled();
         ZipParameters clonedZipParameters = cloneAndAdjustZipParameters(zipParameters, fileToAdd, progressMonitor);
         progressMonitor.setFileName(fileToAdd.getAbsolutePath());
 
-        zipOutputStream.putNextEntry(clonedZipParameters);
-        if (fileToAdd.isDirectory()) {
-          zipOutputStream.closeEntry();
-          continue;
-        }
+        if (Files.isSymbolicLink(fileToAdd.toPath())) {
+          if (addSymlink(clonedZipParameters)) {
+            addSymlinkToZip(fileToAdd, zipOutputStream, clonedZipParameters, splitOutputStream);
 
-        try (InputStream inputStream = new FileInputStream(fileToAdd)) {
-          while ((readLen = inputStream.read(readBuff)) != -1) {
-            zipOutputStream.write(readBuff, 0, readLen);
-            progressMonitor.updateWorkCompleted(readLen);
-            verifyIfTaskIsCancelled();
+            if (INCLUDE_LINK_ONLY.equals(clonedZipParameters.getSymbolicLinkAction())) {
+              continue;
+            }
           }
         }
 
-        FileHeader fileHeader = zipOutputStream.closeEntry();
-        fileHeader.setExternalFileAttributes(FileUtils.getFileAttributes(fileToAdd));
+        addFileToZip(fileToAdd, zipOutputStream, clonedZipParameters, splitOutputStream, progressMonitor);
+      }
+    }
+  }
+
+  private void addSymlinkToZip(File fileToAdd, ZipOutputStream zipOutputStream, ZipParameters zipParameters,
+                               SplitOutputStream splitOutputStream) throws IOException {
+
+    ZipParameters clonedZipParameters = new ZipParameters(zipParameters);
+    clonedZipParameters.setFileNameInZip(replaceFileNameInZip(zipParameters.getFileNameInZip(), fileToAdd.getName()));
+    clonedZipParameters.setEncryptFiles(false);
+    clonedZipParameters.setCompressionMethod(CompressionMethod.STORE);
 
-        updateLocalFileHeader(fileHeader, splitOutputStream);
+    zipOutputStream.putNextEntry(clonedZipParameters);
+
+    String symLinkTarget = fileToAdd.toPath().toRealPath().toString();
+    zipOutputStream.write(symLinkTarget.getBytes());
+
+    closeEntry(zipOutputStream, splitOutputStream, fileToAdd, true);
+  }
+
+  private void addFileToZip(File fileToAdd, ZipOutputStream zipOutputStream, ZipParameters zipParameters,
+                            SplitOutputStream splitOutputStream, ProgressMonitor progressMonitor) throws IOException {
+
+    zipOutputStream.putNextEntry(zipParameters);
+
+    if (!fileToAdd.isDirectory()) {
+      try (InputStream inputStream = new FileInputStream(fileToAdd)) {
+        while ((readLen = inputStream.read(readBuff)) != -1) {
+          zipOutputStream.write(readBuff, 0, readLen);
+          progressMonitor.updateWorkCompleted(readLen);
+          verifyIfTaskIsCancelled();
+        }
       }
     }
+
+    closeEntry(zipOutputStream, splitOutputStream, fileToAdd, false);
+  }
+
+  private void closeEntry(ZipOutputStream zipOutputStream, SplitOutputStream splitOutputStream, File fileToAdd,
+                          boolean isSymlink) throws IOException {
+    FileHeader fileHeader = zipOutputStream.closeEntry();
+    byte[] fileAttributes = FileUtils.getFileAttributes(fileToAdd);
+
+    if (!isSymlink) {
+      // Unset the symlink byte if the entry being added is a symlink, but the original file is being added
+      fileAttributes[3] = BitUtils.unsetBit(fileAttributes[3], 5);
+    }
+
+    fileHeader.setExternalFileAttributes(fileAttributes);
+
+    updateLocalFileHeader(fileHeader, splitOutputStream);
   }
 
   long calculateWorkForFiles(List<File> filesToAdd, ZipParameters zipParameters) throws ZipException {
@@ -102,7 +150,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
 
       //If an entry already exists, we have to remove that entry first and then add content again.
       //In this case, add corresponding work
-      String relativeFileName = getRelativeFileName(fileToAdd.getAbsolutePath(), zipParameters);
+      String relativeFileName = getRelativeFileName(fileToAdd, zipParameters);
       FileHeader fileHeader = getFileHeader(getZipModel(), relativeFileName);
       if (fileHeader != null) {
         totalWork += (getZipModel().getZipFile().length() - fileHeader.getCompressedSize());
@@ -164,7 +212,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     clonedZipParameters.setLastModifiedFileTime(fileToAdd.lastModified());
 
     if (!Zip4jUtil.isStringNotNullAndNotEmpty(zipParameters.getFileNameInZip())) {
-      String relativeFileName = getRelativeFileName(fileToAdd.getAbsolutePath(), zipParameters);
+      String relativeFileName = getRelativeFileName(fileToAdd, zipParameters);
       clonedZipParameters.setFileNameInZip(relativeFileName);
     }
 
@@ -196,7 +244,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     }
 
     for (File file : files) {
-      String fileName = getRelativeFileName(file.getAbsolutePath(), zipParameters);
+      String fileName = getRelativeFileName(file, zipParameters);
 
       FileHeader fileHeader = getFileHeader(zipModel, fileName);
       if (fileHeader != null) {
@@ -220,6 +268,20 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     removeEntryFromZipFileTask.execute(new RemoveEntryFromZipFileTaskParameters(fileHeader, charset));
   }
 
+  private String replaceFileNameInZip(String fileInZipWithPath, String newFileName) {
+    if (fileInZipWithPath.contains(InternalZipConstants.ZIP_FILE_SEPARATOR)) {
+      return fileInZipWithPath.substring(0, fileInZipWithPath.lastIndexOf(InternalZipConstants.ZIP_FILE_SEPARATOR) + 1) + newFileName;
+    }
+
+    return newFileName;
+  }
+
+
+  private boolean addSymlink(ZipParameters zipParameters) {
+    return INCLUDE_LINK_ONLY.equals(zipParameters.getSymbolicLinkAction()) ||
+        INCLUDE_LINK_AND_LINKED_FILE.equals(zipParameters.getSymbolicLinkAction());
+  }
+
   @Override
   protected ProgressMonitor.Task getTask() {
     return ProgressMonitor.Task.ADD_ENTRY;
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
index a061da8..0b1a2df 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
@@ -6,6 +6,7 @@ import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
+import net.lingala.zip4j.util.BitUtils;
 import net.lingala.zip4j.util.UnzipUtil;
 import net.lingala.zip4j.util.Zip4jUtil;
 
@@ -13,6 +14,9 @@ import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.regex.Matcher;
 
 import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
@@ -53,12 +57,24 @@ public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
           throw new ZipException("Could not create directory: " + outputFile);
         }
       }
+    } else if (isSymbolicLink(fileHeader)) {
+      createSymLink(zipInputStream, fileHeader, outputFile, progressMonitor);
     } else {
       checkOutputDirectoryStructure(outputFile);
       unzipFile(zipInputStream, fileHeader, outputFile, progressMonitor);
     }
   }
 
+  private boolean isSymbolicLink(FileHeader fileHeader) {
+    byte[] externalFileAttributes = fileHeader.getExternalFileAttributes();
+
+    if (externalFileAttributes == null || externalFileAttributes.length < 4) {
+      return false;
+    }
+
+    return BitUtils.isBitSet(externalFileAttributes[3], 5);
+  }
+
   private void unzipFile(ZipInputStream inputStream, FileHeader fileHeader, File outputFile,
                          ProgressMonitor progressMonitor) throws IOException {
     int readLength;
@@ -78,6 +94,32 @@ public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
     UnzipUtil.applyFileAttributes(fileHeader, outputFile);
   }
 
+  private void createSymLink(ZipInputStream zipInputStream, FileHeader fileHeader, File outputFile,
+                             ProgressMonitor progressMonitor) throws IOException {
+    String symLinkPath = new String(readCompleteEntry(zipInputStream, fileHeader, progressMonitor));
+    Path linkTarget = Paths.get(symLinkPath);
+
+    if (!outputFile.getParentFile().exists() && !outputFile.getParentFile().mkdirs()) {
+      throw new ZipException("Could not create parent directories");
+    }
+
+    Files.createSymbolicLink(outputFile.toPath(), linkTarget);
+    UnzipUtil.applyFileAttributes(fileHeader, outputFile);
+  }
+
+  private byte[] readCompleteEntry(ZipInputStream zipInputStream, FileHeader fileHeader,
+                                   ProgressMonitor progressMonitor) throws IOException {
+    byte[] b = new byte[(int) fileHeader.getUncompressedSize()];
+    int readLength = zipInputStream.read(b);
+
+    if (readLength != b.length) {
+      throw new ZipException("Could not read complete entry");
+    }
+
+    progressMonitor.updateWorkCompleted(b.length);
+    return b;
+  }
+
   private void verifyNextEntry(ZipInputStream zipInputStream, FileHeader fileHeader) throws IOException {
     LocalFileHeader localFileHeader = zipInputStream.getNextEntry(fileHeader);
 
diff --git a/src/main/java/net/lingala/zip4j/util/FileUtils.java b/src/main/java/net/lingala/zip4j/util/FileUtils.java
index ec1c118..9132a6c 100644
--- a/src/main/java/net/lingala/zip4j/util/FileUtils.java
+++ b/src/main/java/net/lingala/zip4j/util/FileUtils.java
@@ -182,11 +182,11 @@ public class FileUtils {
     return splitZipFiles;
   }
 
-  public static String getRelativeFileName(String fileToAdd, ZipParameters zipParameters) throws ZipException {
+  public static String getRelativeFileName(File fileToAdd, ZipParameters zipParameters) throws ZipException {
 
     String fileName;
     try {
-      String fileCanonicalPath = new File(fileToAdd).getCanonicalPath();
+      String fileCanonicalPath = fileToAdd.getCanonicalPath();
       if (isStringNotNullAndNotEmpty(zipParameters.getDefaultFolderPath())) {
         File rootFolderFile = new File(zipParameters.getDefaultFolderPath());
         String rootFolderFileRef = rootFolderFile.getCanonicalPath();
@@ -195,7 +195,15 @@ public class FileUtils {
           rootFolderFileRef += FILE_SEPARATOR;
         }
 
-        String tmpFileName = fileCanonicalPath.substring(rootFolderFileRef.length());
+        String tmpFileName;
+
+        if (Files.isSymbolicLink(fileToAdd.toPath())) {
+          String rootPath = new File(fileToAdd.getParentFile().getCanonicalFile().getPath() + File.separator + fileToAdd.getCanonicalFile().getName()).getPath();
+          tmpFileName = rootPath.substring(rootFolderFileRef.length());
+        } else {
+           tmpFileName = fileCanonicalPath.substring(rootFolderFileRef.length());
+        }
+
         if (tmpFileName.startsWith(System.getProperty("file.separator"))) {
           tmpFileName = tmpFileName.substring(1);
         }
@@ -236,11 +244,18 @@ public class FileUtils {
     return fileName;
   }
 
-  private static String getNameOfFileInZip(File fileToAdd, String fileNameInZip) {
+  private static String getNameOfFileInZip(File fileToAdd, String fileNameInZip) throws IOException {
     if (isStringNotNullAndNotEmpty(fileNameInZip)) {
       return fileNameInZip;
     }
-    return fileToAdd.getName();
+
+    Path path = fileToAdd.toPath();
+
+    if (Files.isSymbolicLink(path)) {
+      return path.toRealPath().getFileName().toString();
+    }
+
+    return path.getFileName().toString();
   }
 
   public static boolean isZipEntryDirectory(String fileNameInZip) {
@@ -373,6 +388,7 @@ public class FileUtils {
 
       fileAttributes[3] = setBitIfApplicable(Files.isRegularFile(file), fileAttributes[3], 7);
       fileAttributes[3] = setBitIfApplicable(Files.isDirectory(file), fileAttributes[3], 6);
+      fileAttributes[3] = setBitIfApplicable(Files.isSymbolicLink(file), fileAttributes[3], 5);
       fileAttributes[3] = setBitIfApplicable(posixFilePermissions.contains(OWNER_READ), fileAttributes[3], 0);
       fileAttributes[2] = setBitIfApplicable(posixFilePermissions.contains(OWNER_WRITE), fileAttributes[2], 7);
       fileAttributes[2] = setBitIfApplicable(posixFilePermissions.contains(OWNER_EXECUTE), fileAttributes[2], 6);
diff --git a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
index 0f964d6..e048c52 100644
--- a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
@@ -21,12 +21,16 @@ import java.io.FilenameFilter;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.List;
 
 import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
 import static net.lingala.zip4j.testutils.ZipFileVerifier.verifyZipFileByExtractingAllFiles;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
 
 /**
  * Contains Integration tests for create operations of ZipFile
@@ -284,6 +288,144 @@ public class CreateZipFileIT extends AbstractIT {
     verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 1, false);
   }
 
+  @Test
+  public void testAddSymlinkWithLinkOnly() throws IOException {
+    File targetFile = getTestFileFromResources("sample.pdf");
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+
+    zipFile.addFile(symlink, zipParameters);
+
+    assertThat(zipFile.getFileHeaders()).hasSize(1);
+    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo(symlink.getName());
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 1, false);
+
+    verifyGeneratedSymlink(symlink, targetFile);
+  }
+
+  @Test
+  public void testAddSymlinkWithLinkedFileOnly() throws IOException {
+    File targetFile = getTestFileFromResources("sample.pdf");
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
+
+    zipFile.addFile(symlink, zipParameters);
+
+    assertThat(zipFile.getFileHeaders()).hasSize(1);
+    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo(targetFile.getName());
+    verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 1);
+  }
+
+  @Test
+  public void testAddSymlinkWithLinkAndLinkedFile() throws IOException {
+    File targetFile = getTestFileFromResources("sample.pdf");
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+
+    zipFile.addFile(symlink, zipParameters);
+
+    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
+    assertThat(fileHeaders).hasSize(2);
+    assertThat(fileHeaders.get(0).getFileName()).isEqualTo(symlink.getName());
+    assertThat(fileHeaders.get(1).getFileName()).isEqualTo(targetFile.getName());
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 2, false);
+
+    verifyGeneratedSymlink(symlink, targetFile);
+    File generatedTargetFile = Paths.get(outputFolder.getAbsolutePath(), targetFile.getName()).toFile();
+    ZipFileVerifier.verifyFileCrc(targetFile, generatedTargetFile);
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkOnly() throws IOException {
+    File testFolder = createTestFolderWithSymlinks();
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 6, false);
+    verifyFileNamesInZip(zipFile,
+        "test-folder/",
+        "test-folder/symlink.link",
+        "test-folder/sub-folder1/",
+        "test-folder/sub-folder1/symlink.link",
+        "test-folder/sub-folder2/",
+        "test-folder/sub-folder2/symlink.link");
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkedFilesOnly() throws IOException {
+    File testFolder = createTestFolderWithSymlinks();
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 6, false);
+    verifyFileNamesInZip(zipFile,
+        "test-folder/",
+        "test-folder/sample.pdf",
+        "test-folder/sub-folder1/",
+        "test-folder/sub-folder1/file_PDF_1MB.pdf",
+        "test-folder/sub-folder2/",
+        "test-folder/sub-folder2/sample_text_large.txt");
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkAndLinkedFilesOnly() throws IOException {
+    File testFolder = createTestFolderWithSymlinks();
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 9, false);
+    verifyFileNamesInZip(zipFile,
+        "test-folder/",
+        "test-folder/symlink.link",
+        "test-folder/sample.pdf",
+        "test-folder/sub-folder1/",
+        "test-folder/sub-folder1/symlink.link",
+        "test-folder/sub-folder1/file_PDF_1MB.pdf",
+        "test-folder/sub-folder2/",
+        "test-folder/sub-folder2/sample_text_large.txt",
+        "test-folder/sub-folder2/symlink.link");
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkAndLinkedFilesOnlyWithoutRootFolder() throws IOException {
+    File testFolder = createTestFolderWithSymlinks();
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setIncludeRootFolder(false);
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 8, false);
+    verifyFileNamesInZip(zipFile,
+        "symlink.link",
+        "sample.pdf",
+        "sub-folder1/",
+        "sub-folder1/symlink.link",
+        "sub-folder1/file_PDF_1MB.pdf",
+        "sub-folder2/",
+        "sub-folder2/sample_text_large.txt",
+        "sub-folder2/symlink.link");
+  }
+
   private void testCreateZipFileWithFileEntryComment(String fileCommentPrefix, Charset charset) throws IOException {
     ZipParameters zipParameters = new ZipParameters();
     ZipFile zipFile = initializeZipFileWithCharset(charset);
@@ -381,4 +523,49 @@ public class CreateZipFileIT extends AbstractIT {
 
     return zipFile;
   }
+
+  private void verifyGeneratedSymlink(File actualSymlink, File targetFile) throws IOException {
+    File extractedSymlink = Paths.get(outputFolder.getAbsolutePath(), actualSymlink.getName()).toFile();
+    assertThat(Files.isSymbolicLink(extractedSymlink.toPath())).isTrue();
+    assertThat(actualSymlink.length()).isEqualTo(extractedSymlink.length());
+    File generatedTarget = Files.readSymbolicLink(extractedSymlink.toPath()).toFile();
+    assertThat(generatedTarget).isEqualTo(targetFile);
+  }
+
+  private File createSymlink(File targetFile, File rootFolder) throws IOException {
+    Path link = Paths.get(rootFolder.getAbsolutePath(), "symlink.link");
+    Files.createSymbolicLink(link, targetFile.toPath());
+    return link.toFile();
+  }
+
+  private File createTestFolderWithSymlinks() throws IOException {
+    Path testFolder = temporaryFolder.newFolder("test-folder").toPath();
+    Path subFolder1 = Files.createDirectory(Paths.get(testFolder.toString(), "sub-folder1"));
+    Path subFolder2 = Files.createDirectory(Paths.get(testFolder.toString(), "sub-folder2"));
+
+    createSymlink(getTestFileFromResources("sample.pdf"), testFolder.toFile());
+    createSymlink(getTestFileFromResources("file_PDF_1MB.pdf"), subFolder1.toFile());
+    createSymlink(getTestFileFromResources("sample_text_large.txt"), subFolder2.toFile());
+
+    return testFolder.toFile();
+  }
+
+  private void verifyFileNamesInZip(ZipFile zipFile, String... fileNames) throws ZipException {
+    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
+
+    for (String fileName : fileNames) {
+      boolean entryFound = false;
+      for (FileHeader fileHeader : fileHeaders) {
+        if (fileHeader.getFileName().equals(fileName)) {
+          entryFound = true;
+          break;
+        }
+      }
+
+      if (!entryFound) {
+        fail("Could not find entry: " + fileName + " in zip");
+      }
+    }
+  }
+
 }
diff --git a/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java b/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java
index 09d17d2..1db447f 100644
--- a/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java
+++ b/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java
@@ -73,7 +73,7 @@ public class ZipFileVerifier {
     }
   }
 
-  private static void verifyFileCrc(File sourceFile, File extractedFile) throws IOException {
+  public static void verifyFileCrc(File sourceFile, File extractedFile) throws IOException {
     ProgressMonitor progressMonitor = new ProgressMonitor();
     long sourceFileCrc = CrcUtil.computeFileCrc(sourceFile, progressMonitor);
     long extractedFileCrc = CrcUtil.computeFileCrc(extractedFile, progressMonitor);
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java b/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
index 926d8e4..1399e39 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
@@ -250,7 +250,7 @@ public class FileUtilsTest {
 
   @Test
   public void testGetRelativeFileNameWhenRootFoldersAreNull() throws ZipException {
-    assertThat(FileUtils.getRelativeFileName("somefile.txt", new ZipParameters())).isEqualTo("somefile.txt");
+    assertThat(FileUtils.getRelativeFileName(new File("somefile.txt"), new ZipParameters())).isEqualTo("somefile.txt");
   }
 
   @Test
@@ -258,7 +258,7 @@ public class FileUtilsTest {
     String expectetdFileName = "rootfolder" + FILE_SEPARATOR + "somefile.txt";
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setRootFolderNameInZip("rootfolder");
-    assertThat(FileUtils.getRelativeFileName("somefile.txt", zipParameters)).isEqualTo(expectetdFileName);
+    assertThat(FileUtils.getRelativeFileName(new File("somefile.txt"), zipParameters)).isEqualTo(expectetdFileName);
   }
 
   @Test
@@ -266,7 +266,7 @@ public class FileUtilsTest {
     String expectetdFileName = "rootfolder" + FILE_SEPARATOR + "somefile.txt";
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setRootFolderNameInZip("rootfolder" + File.separator);
-    assertThat(FileUtils.getRelativeFileName("somefile.txt", zipParameters)).isEqualTo(expectetdFileName);
+    assertThat(FileUtils.getRelativeFileName(new File("somefile.txt"), zipParameters)).isEqualTo(expectetdFileName);
   }
 
   @Test
@@ -274,14 +274,14 @@ public class FileUtilsTest {
     String expectedRootFolder = "rootfolder" + FILE_SEPARATOR + "somefile.txt";
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setRootFolderNameInZip("rootfolder\\");
-    assertThat(FileUtils.getRelativeFileName("somefile.txt", zipParameters)).isEqualTo(expectedRootFolder);
+    assertThat(FileUtils.getRelativeFileName(new File("somefile.txt"), zipParameters)).isEqualTo(expectedRootFolder);
   }
 
   @Test
   public void testGetRelativeFileWithDifferentFileNameInZip() throws ZipException {
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setFileNameInZip("anotherName.txt");
-    assertThat(FileUtils.getRelativeFileName("somefile.txt", zipParameters)).isEqualTo("anotherName.txt");
+    assertThat(FileUtils.getRelativeFileName(new File("somefile.txt"), zipParameters)).isEqualTo("anotherName.txt");
   }
 
   @Test
@@ -290,7 +290,7 @@ public class FileUtilsTest {
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setFileNameInZip("anotherName.txt");
     zipParameters.setRootFolderNameInZip("rootfolder");
-    assertThat(FileUtils.getRelativeFileName("somefile.txt", zipParameters)).isEqualTo(expectedRootFolder);
+    assertThat(FileUtils.getRelativeFileName(new File("somefile.txt"), zipParameters)).isEqualTo(expectedRootFolder);
   }
 
   @Test
@@ -300,8 +300,9 @@ public class FileUtilsTest {
     zipParameters.setFileNameInZip("anotherName.txt");
     zipParameters.setDefaultFolderPath("defaultFolderPath");
     zipParameters.setRootFolderNameInZip("rootfolder");
-    assertThat(FileUtils.getRelativeFileName("defaultFolderPath" + FILE_SEPARATOR + "anotherFolder" + FILE_SEPARATOR
-            + "somefile.txt", zipParameters)).isEqualTo(expectedRootFolder);
+    File fileToTest = new File("defaultFolderPath" + FILE_SEPARATOR + "anotherFolder" + FILE_SEPARATOR
+        + "somefile.txt");
+    assertThat(FileUtils.getRelativeFileName(fileToTest, zipParameters)).isEqualTo(expectedRootFolder);
   }
 
   @Test
