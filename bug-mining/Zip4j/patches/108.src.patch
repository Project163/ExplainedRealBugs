diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
index 524ebe5..80bc850 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
@@ -1,6 +1,7 @@
 package net.lingala.zip4j.tasks;
 
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.headers.HeaderUtil;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -84,11 +85,11 @@ abstract class AbstractModifyFileTask<T> extends AsyncZipTask<T> {
   }
 
   long getOffsetOfNextEntry(List<FileHeader> sortedFileHeaders, FileHeader fileHeader,
-                                   long offsetStartOfCentralDirectory) throws ZipException {
+                                   ZipModel zipModel) throws ZipException {
     int indexOfFileHeader = getIndexOfFileHeader(sortedFileHeaders, fileHeader);
 
     if (indexOfFileHeader == sortedFileHeaders.size() - 1) {
-      return offsetStartOfCentralDirectory;
+      return HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);
     } else {
       return sortedFileHeaders.get(indexOfFileHeader + 1).getOffsetLocalHeader();
     }
diff --git a/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java b/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
index 72caacc..3bf6c4d 100644
--- a/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
@@ -44,7 +44,6 @@ public class RemoveFilesFromZipTask extends AbstractModifyFileTask<RemoveFilesFr
 
     File temporaryZipFile = getTemporaryFile(zipModel.getZipFile().getPath());
     boolean successFlag = false;
-    long offsetOfCentralDirectoryBeforeModification = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);
 
     try (SplitOutputStream outputStream = new SplitOutputStream(temporaryZipFile);
          RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.READ.getValue())){
@@ -53,8 +52,7 @@ public class RemoveFilesFromZipTask extends AbstractModifyFileTask<RemoveFilesFr
       List<FileHeader> sortedFileHeaders = cloneAndSortFileHeadersByOffset(zipModel.getCentralDirectory().getFileHeaders());
 
       for (FileHeader fileHeader : sortedFileHeaders) {
-        long lengthOfCurrentEntry = getOffsetOfNextEntry(sortedFileHeaders, fileHeader,
-            offsetOfCentralDirectoryBeforeModification) - outputStream.getFilePointer();
+        long lengthOfCurrentEntry = getOffsetOfNextEntry(sortedFileHeaders, fileHeader, zipModel) - outputStream.getFilePointer();
         if (shouldEntryBeRemoved(fileHeader, entriesToRemove)) {
           updateHeaders(sortedFileHeaders, fileHeader, lengthOfCurrentEntry);
 
diff --git a/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
index 1b9a634..9f894cf 100644
--- a/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
@@ -49,7 +49,6 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
         SplitOutputStream outputStream = new SplitOutputStream(temporaryFile)) {
 
       long currentFileCopyPointer = 0;
-      long offsetOfCentralDirectoryBeforeModification = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);
 
       // Maintain a different list to iterate, so that when the file name is changed in the central directory
       // we still have access to the original file names. If iterating on the original list from central directory,
@@ -62,8 +61,7 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
         Map.Entry<String, String> fileNameMapForThisEntry = getCorrespondingEntryFromMap(fileHeader, fileNamesMap);
         progressMonitor.setFileName(fileHeader.getFileName());
 
-        long lengthToCopy = getOffsetOfNextEntry(sortedFileHeaders, fileHeader,
-            offsetOfCentralDirectoryBeforeModification) - outputStream.getFilePointer();
+        long lengthToCopy = getOffsetOfNextEntry(sortedFileHeaders, fileHeader, zipModel) - outputStream.getFilePointer();
         if (fileNameMapForThisEntry == null) {
           // copy complete entry without any changes
           currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, lengthToCopy, progressMonitor);
