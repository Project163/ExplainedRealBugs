diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index 33ad945..741a2cc 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -58,6 +58,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.RandomAccessFile;
 import java.nio.charset.Charset;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -96,6 +97,8 @@ public class ZipFile {
   private ThreadFactory threadFactory;
   private ExecutorService executorService;
   private int bufferSize = InternalZipConstants.BUFF_SIZE;
+  private List<InputStream> openInputStreams = new ArrayList<>();
+  private boolean zipFileClosed = false;
 
   /**
    * Creates a new ZipFile instance with the zip file at the location specified in zipFile.
@@ -1018,7 +1021,9 @@ public class ZipFile {
       throw new ZipException("zip model is null, cannot get inputstream");
     }
 
-    return createZipInputStream(zipModel, fileHeader, password);
+    ZipInputStream zipInputStream = createZipInputStream(zipModel, fileHeader, password);
+    openInputStreams.add(zipInputStream);
+    return zipInputStream;
   }
 
   /**
@@ -1066,6 +1071,23 @@ public class ZipFile {
     return FileUtils.getSplitZipFiles(zipModel);
   }
 
+  /**
+   * Closes any open streams that were open by an instance of this class.
+   *
+   * @throws IOException when the underlying input stream throws an exception when trying to close it
+   */
+  public void close() throws IOException {
+    if (zipFileClosed) {
+      return;
+    }
+
+    for (InputStream inputStream : openInputStreams) {
+      inputStream.close();
+    }
+    openInputStreams.clear();
+    zipFileClosed = true;
+  }
+
   /**
    * Sets a password to be used for the zip file. Will override if a password supplied via ZipFile constructor
    * @param password - char array of the password to be used
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index 1d00ed3..c5fc7d0 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -134,6 +134,10 @@ public class ZipInputStream extends InputStream {
 
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
+    if (streamClosed) {
+      throw new IOException("Stream closed");
+    }
+
     if (len < 0) {
       throw new IllegalArgumentException("Negative read length");
     }
@@ -173,6 +177,10 @@ public class ZipInputStream extends InputStream {
 
   @Override
   public void close() throws IOException {
+    if (streamClosed) {
+      return;
+    }
+
     if (decompressedInputStream != null) {
       decompressedInputStream.close();
     }
diff --git a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
index 5cb98fc..fba5150 100644
--- a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
@@ -4,6 +4,7 @@ import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.testutils.TestUtils;
 import net.lingala.zip4j.testutils.ZipFileVerifier;
@@ -13,7 +14,11 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
-import java.io.*;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.nio.charset.Charset;
 import java.nio.file.Paths;
 import java.util.ArrayList;
@@ -561,6 +566,38 @@ public class MiscZipFileIT extends AbstractIT {
     assertThat(zipFile.isValidZipFile()).isFalse();
   }
 
+  @Test
+  public void testCloseSuccessfullyClosesAllInputStreams() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.addFile(TestUtils.getTestFileFromResources("after_deflate_remaining_bytes.bin"));
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setCompressionMethod(CompressionMethod.STORE);
+    zipParameters.setEncryptionMethod(EncryptionMethod.AES);
+    zipFile.addFile(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"), zipParameters);
+    zipParameters.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD);
+    zipFile.addFile(TestUtils.getTestFileFromResources("sample.pdf"), zipParameters);
+    zipParameters.setCompressionMethod(CompressionMethod.DEFLATE);
+    zipParameters.setEncryptionMethod(EncryptionMethod.AES);
+    zipFile.addFile(TestUtils.getTestFileFromResources("sample_text1.txt"), zipParameters);
+
+    List<InputStream> inputStreams = new ArrayList<>();
+    for (FileHeader fileHeader : zipFile.getFileHeaders()) {
+      inputStreams.add(zipFile.getInputStream(fileHeader));
+    }
+    zipFile.close();
+
+    assertThat(inputStreams).hasSize(4);
+    for (InputStream inputStream : inputStreams) {
+      try {
+        //noinspection ResultOfMethodCallIgnored
+        inputStream.read();
+        fail("Should have thrown an exception");
+      } catch (IOException e) {
+        assertThat(e.getMessage()).isEqualTo("Stream closed");
+      }
+    }
+  }
+
   private void verifyInputStream(InputStream inputStream, File fileToCompareAgainst) throws IOException {
     File outputFile = temporaryFolder.newFile();
     try (OutputStream outputStream = new FileOutputStream(outputFile)) {
