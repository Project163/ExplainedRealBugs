diff --git a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
index c4837d1..7da21f1 100644
--- a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
+++ b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
@@ -58,7 +58,12 @@ public class FileHeaderFactory {
     //For files added by this library, this attribute will be set after closeEntry is done
     fileHeader.setExternalFileAttributes(new byte[4]);
     fileHeader.setDirectory(isZipEntryDirectory(fileName));
-    fileHeader.setUncompressedSize(zipParameters.getEntrySize());
+
+    if (zipParameters.isWriteExtendedLocalFileHeader() && zipParameters.getEntrySize() == -1) {
+      fileHeader.setUncompressedSize(0);
+    } else {
+      fileHeader.setUncompressedSize(zipParameters.getEntrySize());
+    }
 
     if (zipParameters.isEncryptFiles() && zipParameters.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD) {
       fileHeader.setCrc(zipParameters.getEntryCRC());
diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index 3956505..4e59970 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -12,6 +12,7 @@ import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.progress.ProgressMonitor;
+import net.lingala.zip4j.testutils.HeaderVerifier;
 import net.lingala.zip4j.testutils.TestUtils;
 import net.lingala.zip4j.testutils.ZipFileVerifier;
 import net.lingala.zip4j.util.BitUtils;
@@ -38,6 +39,8 @@ public class AddFilesToZipIT extends AbstractIT {
   @Rule
   public ExpectedException expectedException = ExpectedException.none();
 
+  private HeaderVerifier headerVerifier = new HeaderVerifier();
+
   @Test
   public void testAddFileAsStringParameterThrowsExceptionWhenFileDoesNotExist() throws ZipException {
     expectedException.expectMessage("File does not exist: somefile.txt");
@@ -720,6 +723,7 @@ public class AddFilesToZipIT extends AbstractIT {
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 1);
     verifyZipFileContainsFiles(generatedZipFile, singletonList("бореиская.txt"), CompressionMethod.DEFLATE,
         EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
+    headerVerifier.verifyLocalFileHeaderUncompressedSize(generatedZipFile, "бореиская.txt", 0);
   }
 
   @Test
diff --git a/src/test/java/net/lingala/zip4j/testutils/HeaderVerifier.java b/src/test/java/net/lingala/zip4j/testutils/HeaderVerifier.java
new file mode 100644
index 0000000..cb182c0
--- /dev/null
+++ b/src/test/java/net/lingala/zip4j/testutils/HeaderVerifier.java
@@ -0,0 +1,53 @@
+package net.lingala.zip4j.testutils;
+
+import net.lingala.zip4j.ZipFile;
+import net.lingala.zip4j.headers.HeaderReader;
+import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.LocalFileHeader;
+import net.lingala.zip4j.util.InternalZipConstants;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class HeaderVerifier {
+
+  HeaderReader headerReader = new HeaderReader();
+
+  public void verifyLocalFileHeaderUncompressedSize(File generatedZipFile, String fileNameInZipToVerify,
+                                                    long expectedUncompressedSize) throws IOException {
+
+    LocalFileHeader localFileHeader = getLocalFileHeaderForEntry(generatedZipFile, fileNameInZipToVerify);
+    assertThat(localFileHeader.getUncompressedSize()).isEqualTo(expectedUncompressedSize);
+  }
+
+  private LocalFileHeader getLocalFileHeaderForEntry(File generatedZipFile, String fileNameInZipToVerify)
+      throws IOException {
+
+    InputStream inputStream = positionRandomAccessFileToLocalFileHeaderStart(generatedZipFile,
+        fileNameInZipToVerify);
+    return headerReader.readLocalFileHeader(inputStream, InternalZipConstants.CHARSET_UTF_8);
+  }
+
+  private InputStream positionRandomAccessFileToLocalFileHeaderStart(File generatedZipFile, String fileNameInZip)
+      throws IOException{
+
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    FileHeader fileHeader = zipFile.getFileHeader(fileNameInZip);
+
+    if (fileHeader == null) {
+      throw new RuntimeException("Cannot find an entry with name: " + fileNameInZip + " in zip file: "
+          + generatedZipFile);
+    }
+
+    InputStream inputStream = new FileInputStream(generatedZipFile);
+    if (inputStream.skip(fileHeader.getOffsetLocalHeader()) != fileHeader.getOffsetLocalHeader()) {
+      throw new IOException("Cannot skip " + fileHeader.getOffsetLocalHeader() + " bytes for entry "
+          + fileHeader.getFileName());
+    }
+    return inputStream;
+  }
+}
