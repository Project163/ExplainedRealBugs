diff --git a/pom.xml b/pom.xml
index 2b6c10b..299244f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -29,8 +29,8 @@
     </licenses>
 
     <properties>
-        <maven.compiler.source>1.8</maven.compiler.source>
-        <maven.compiler.target>1.8</maven.compiler.target>
+        <maven.compiler.source>1.7</maven.compiler.source>
+        <maven.compiler.target>1.7</maven.compiler.target>
         <junit.version>4.13.1</junit.version>
         <lombok.version>1.18.8</lombok.version>
         <assertj.version>3.12.2</assertj.version>
@@ -98,6 +98,14 @@
     <build>
         <sourceDirectory>src/main/java</sourceDirectory>
         <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.7</source>
+                    <target>1.7</target>
+                </configuration>
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
index bcb0163..6381c03 100644
--- a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
@@ -7,9 +7,9 @@ import net.lingala.zip4j.util.InternalZipConstants;
 
 import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.stream.Collectors;
 
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP4J_DEFAULT_CHARSET;
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP_STANDARD_CHARSET_NAME;
@@ -70,7 +70,13 @@ public class HeaderUtil {
       return Collections.emptyList();
     }
 
-    return allFileHeaders.stream().filter(e -> e.getFileName().startsWith(rootFileHeader.getFileName())).collect(Collectors.toList());
+    List<FileHeader> fileHeadersUnderDirectory = new ArrayList<>();
+    for (FileHeader fileHeader : allFileHeaders) {
+      if (fileHeader.getFileName().startsWith(rootFileHeader.getFileName())) {
+        fileHeadersUnderDirectory.add(fileHeader);
+      }
+    }
+    return fileHeadersUnderDirectory;
   }
 
   public static long getTotalUncompressedSizeOfAllFileHeaders(List<FileHeader> fileHeaders) {
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
index ad55788..fc9fb7c 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
@@ -13,6 +13,7 @@ import java.io.OutputStream;
 import java.io.RandomAccessFile;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.List;
 import java.util.Random;
 
@@ -75,12 +76,15 @@ abstract class AbstractModifyFileTask<T> extends AsyncZipTask<T> {
   List<FileHeader> cloneAndSortFileHeadersByOffset(List<FileHeader> allFileHeaders) {
     List<FileHeader> clonedFileHeaders = new ArrayList<>(allFileHeaders);
     //noinspection Java8ListSort
-    Collections.sort(clonedFileHeaders, (o1, o2) -> {
-      if (o1.getFileName().equals(o2.getFileName())) {
-        return 0;
+    Collections.sort(clonedFileHeaders, new Comparator<FileHeader>() {
+      @Override
+      public int compare(FileHeader o1, FileHeader o2) {
+        if (o1.getFileName().equals(o2.getFileName())) {
+          return 0;
+        }
+
+        return o1.getOffsetLocalHeader() < o2.getOffsetLocalHeader() ? -1 : 1;
       }
-
-      return o1.getOffsetLocalHeader() < o2.getOffsetLocalHeader() ? -1 : 1;
     });
 
     return clonedFileHeaders;
diff --git a/src/main/java/net/lingala/zip4j/tasks/AsyncZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AsyncZipTask.java
index be20511..9c80c15 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AsyncZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AsyncZipTask.java
@@ -18,7 +18,7 @@ public abstract class AsyncZipTask<T> {
     this.executorService = asyncTaskParameters.executorService;
   }
 
-  public void execute(T taskParameters) throws ZipException {
+  public void execute(final T taskParameters) throws ZipException {
     if (runInThread && ProgressMonitor.State.BUSY.equals(progressMonitor.getState())) {
       throw new ZipException("invalid operation - Zip4j is in busy state");
     }
@@ -29,13 +29,16 @@ public abstract class AsyncZipTask<T> {
       long totalWorkToBeDone = calculateTotalWork(taskParameters);
       progressMonitor.setTotalWork(totalWorkToBeDone);
 
-      executorService.execute(() -> {
-        try {
-          performTaskWithErrorHandling(taskParameters, progressMonitor);
-        } catch (ZipException e) {
-          //Do nothing. Exception will be passed through progress monitor
-        } finally {
-          executorService.shutdown();
+      executorService.execute(new Runnable() {
+        @Override
+        public void run() {
+          try {
+            AsyncZipTask.this.performTaskWithErrorHandling(taskParameters, progressMonitor);
+          } catch (ZipException e) {
+            //Do nothing. Exception will be passed through progress monitor
+          } finally {
+            executorService.shutdown();
+          }
         }
       });
     } else {
diff --git a/src/main/java/net/lingala/zip4j/util/FileUtils.java b/src/main/java/net/lingala/zip4j/util/FileUtils.java
index 9eb970d..5157a6b 100644
--- a/src/main/java/net/lingala/zip4j/util/FileUtils.java
+++ b/src/main/java/net/lingala/zip4j/util/FileUtils.java
@@ -7,6 +7,7 @@ import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.progress.ProgressMonitor;
 
 import java.io.File;
+import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.RandomAccessFile;
@@ -381,8 +382,13 @@ public class FileUtils {
    * @return sorted list of split files. Returns an empty list if no files of that pattern are found in the current directory
    */
   public static File[] getAllSortedNumberedSplitFiles(File firstNumberedFile) {
-    String zipFileNameWithoutExtension = FileUtils.getFileNameWithoutExtension(firstNumberedFile.getName());
-    File[] allSplitFiles = firstNumberedFile.getParentFile().listFiles((dir, name) -> name.startsWith(zipFileNameWithoutExtension + "."));
+    final String zipFileNameWithoutExtension = FileUtils.getFileNameWithoutExtension(firstNumberedFile.getName());
+    File[] allSplitFiles = firstNumberedFile.getParentFile().listFiles(new FilenameFilter() {
+      @Override
+      public boolean accept(File dir, String name) {
+        return name.startsWith(zipFileNameWithoutExtension + ".");
+      }
+    });
 
     if(allSplitFiles == null) {
       return new File[0];
diff --git a/src/test/java/net/lingala/zip4j/AbstractIT.java b/src/test/java/net/lingala/zip4j/AbstractIT.java
index aa37d43..1a024e6 100644
--- a/src/test/java/net/lingala/zip4j/AbstractIT.java
+++ b/src/test/java/net/lingala/zip4j/AbstractIT.java
@@ -42,8 +42,7 @@ public abstract class AbstractIT {
   public void before() throws IOException {
     generatedZipFile = temporaryFolder.newFile("output.zip");
     outputFolder = temporaryFolder.newFolder("output");
-    File[] allTempFiles = temporaryFolder.getRoot().listFiles();
-    Arrays.stream(allTempFiles).forEach(File::delete);
+    cleanupDirectory(temporaryFolder.getRoot());
   }
 
   protected ZipParameters createZipParameters(EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength) {
@@ -73,13 +72,7 @@ public abstract class AbstractIT {
   }
 
   protected void cleanupOutputFolder() {
-    File[] filesInOutputFolder = outputFolder.listFiles();
-
-    if (filesInOutputFolder == null) {
-      return;
-    }
-
-    Arrays.stream(filesInOutputFolder).forEach(File::delete);
+    cleanupDirectory(outputFolder);
   }
 
   protected Zip4jConfig buildDefaultConfig() {
@@ -93,4 +86,16 @@ public abstract class AbstractIT {
   protected Zip4jConfig buildConfig(int bufferSize) {
     return new Zip4jConfig(null, bufferSize);
   }
+
+  private void cleanupDirectory(File directory) {
+    File[] allTempFiles = directory.listFiles();
+    if (allTempFiles == null) {
+      return;
+    }
+    for (File file : allTempFiles) {
+      if (!file.delete()) {
+        throw new RuntimeException("Could not clean up directory. Error deleting file: " + file);
+      }
+    }
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index df18d5f..bd45991 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -4,6 +4,7 @@ import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.AESExtraDataRecord;
 import net.lingala.zip4j.model.AbstractFileHeader;
+import net.lingala.zip4j.model.ExcludeFileFilter;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.ZipParameters;
@@ -29,13 +30,13 @@ import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Optional;
-import java.util.stream.Collectors;
 
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
 import static net.lingala.zip4j.testutils.HeaderVerifier.verifyLocalFileHeaderUncompressedSize;
+import static net.lingala.zip4j.testutils.TestUtils.getFileNamesOfFiles;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
 
 public class AddFilesToZipIT extends AbstractIT {
 
@@ -354,7 +355,7 @@ public class AddFilesToZipIT extends AbstractIT {
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
 
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size());
-    List<String> fileNames = FILES_TO_ADD.stream().map(File::getName).collect(Collectors.toList());
+    List<String> fileNames = getFileNamesOfFiles(FILES_TO_ADD);
     verifyZipFileContainsFiles(generatedZipFile, fileNames, CompressionMethod.DEFLATE, EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_256, AesVersion.ONE);
   }
@@ -367,7 +368,7 @@ public class AddFilesToZipIT extends AbstractIT {
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
 
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size());
-    List<String> fileNames = FILES_TO_ADD.stream().map(File::getName).collect(Collectors.toList());
+    List<String> fileNames = getFileNamesOfFiles(FILES_TO_ADD);
     verifyZipFileContainsFiles(generatedZipFile, fileNames, CompressionMethod.DEFLATE, EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_256);
   }
@@ -380,7 +381,7 @@ public class AddFilesToZipIT extends AbstractIT {
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
 
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size());
-    List<String> fileNames = FILES_TO_ADD.stream().map(File::getName).collect(Collectors.toList());
+    List<String> fileNames = getFileNamesOfFiles(FILES_TO_ADD);
     verifyZipFileContainsFiles(generatedZipFile, fileNames, CompressionMethod.DEFLATE, EncryptionMethod.ZIP_STANDARD,
         null);
   }
@@ -398,7 +399,7 @@ public class AddFilesToZipIT extends AbstractIT {
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
 
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, newPassword, outputFolder, FILES_TO_ADD.size());
-    List<String> fileNames = FILES_TO_ADD.stream().map(File::getName).collect(Collectors.toList());
+    List<String> fileNames = getFileNamesOfFiles(FILES_TO_ADD);
     verifyZipFileContainsFiles(generatedZipFile, fileNames, CompressionMethod.DEFLATE, EncryptionMethod.ZIP_STANDARD,
         null);
   }
@@ -645,13 +646,18 @@ public class AddFilesToZipIT extends AbstractIT {
   @Test
   public void testAddFolderWithExcludeFileFilter() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
-    List<File> filesToExclude = Arrays.asList(
+    final List<File> filesToExclude = Arrays.asList(
         TestUtils.getTestFileFromResources("sample.pdf"),
         TestUtils.getTestFileFromResources("sample_directory/favicon.ico")
     );
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setIncludeRootFolder(false);
-    zipParameters.setExcludeFileFilter(filesToExclude::contains);
+    zipParameters.setExcludeFileFilter(new ExcludeFileFilter() {
+      @Override
+      public boolean isExcluded(File o) {
+        return filesToExclude.contains(o);
+      }
+    });
 
     zipFile.addFolder(TestUtils.getTestFileFromResources(""), zipParameters);
 
@@ -933,7 +939,11 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   private void verifyFoldersInFileHeaders(List<FileHeader> fileHeaders) {
-    fileHeaders.stream().filter(FileHeader::isDirectory).forEach(this::verifyFolderEntryInZip);
+    for (FileHeader fileHeader : fileHeaders){
+      if (fileHeader.isDirectory()) {
+        verifyFolderEntryInZip(fileHeader);
+      }
+    }
   }
 
   private void verifyFoldersInLocalFileHeaders(File generatedZipFile, char[] password) throws IOException {
@@ -957,11 +967,15 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   private void verifyAllFilesInZipContainsPath(List<FileHeader> fileHeaders, String pathToBeChecked) {
-    fileHeaders.forEach(e -> assertThat(e.getFileName()).startsWith(pathToBeChecked));
+    for (FileHeader fileHeader : fileHeaders) {
+      assertThat(fileHeader.getFileName()).startsWith(pathToBeChecked);
+    }
   }
 
   private void verifyAllFilesInZipDoesNotContainPath(List<FileHeader> fileHeaders, String pathToBeChecked) {
-    fileHeaders.forEach(e -> assertThat(e.getFileName()).doesNotStartWith(pathToBeChecked));
+    for (FileHeader fileHeader : fileHeaders) {
+      assertThat(fileHeader.getFileName()).doesNotStartWith(pathToBeChecked);
+    }
   }
 
   private void verifyAllFilesAreOf(List<FileHeader> fileHeaders, CompressionMethod compressionMethod,
@@ -1017,9 +1031,13 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   private FileHeader getFileHeaderFrom(List<FileHeader> fileHeaders, String fileName) {
-    Optional<FileHeader> fileHeader = fileHeaders.stream().filter(e -> e.getFileName().equals(fileName)).findFirst();
-    assertThat(fileHeader).isPresent();
-    return fileHeader.get();
+    for (FileHeader fileHeader : fileHeaders) {
+      if (fileHeader.getFileName().equals(fileName)) {
+        return fileHeader;
+      }
+    }
+    fail("Could not find a file header by filename: " + fileName);
+    return null;
   }
 
   private List<FileHeader> getFileHeaders(File generatedZipFile) throws ZipException {
diff --git a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
index 3b38aca..79a1765 100644
--- a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
@@ -605,8 +605,13 @@ public class CreateZipFileIT extends AbstractIT {
     assertThat(aesExtraDataRecord.getAesKeyStrength()).isEqualTo(aesKeyStrength);
   }
 
-  private File[] getAllSplitZipFilesInFolder(File folder, String fileNameWithoutExtension) {
-    FilenameFilter filenameFilter = (dir, name) -> name.contains(fileNameWithoutExtension + ".");
+  private File[] getAllSplitZipFilesInFolder(File folder, final String fileNameWithoutExtension) {
+    FilenameFilter filenameFilter = new FilenameFilter() {
+      @Override
+      public boolean accept(File dir, String name) {
+        return name.contains(fileNameWithoutExtension + ".");
+      }
+    };
     return folder.listFiles(filenameFilter);
   }
 
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 1966a2b..7dce629 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -21,11 +21,10 @@ import java.io.InputStream;
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.ArrayList;
-import java.util.HashSet;
+import java.util.Arrays;
 import java.util.List;
-import java.util.Optional;
-import java.util.Set;
 
+import static net.lingala.zip4j.testutils.TestUtils.getFileNamesOfFiles;
 import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
 import static net.lingala.zip4j.testutils.ZipFileVerifier.verifyZipFileByExtractingAllFiles;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -392,7 +391,7 @@ public class ExtractZipFileIT extends AbstractIT {
     zipFile.extractAll(outputFolder.getPath());
 
     assertThat(zipFile.getFileHeaders()).hasSize(44);
-    assertThat(Files.walk(outputFolder.toPath()).filter(Files::isRegularFile)).hasSize(44);
+    assertThat(getRegularFilesFromFolder(outputFolder)).hasSize(44);
    }
 
   @Test
@@ -413,7 +412,7 @@ public class ExtractZipFileIT extends AbstractIT {
     zipFile.extractAll(outputFolder.getPath());
 
     assertThat(zipFile.getFileHeaders()).hasSize(3);
-    assertThat(Files.walk(outputFolder.toPath()).filter(Files::isRegularFile)).hasSize(3);
+    assertThat(getRegularFilesFromFolder(outputFolder)).hasSize(3);
   }
 
   @Test
@@ -424,7 +423,7 @@ public class ExtractZipFileIT extends AbstractIT {
     zipFile.extractAll(outputFolder.getPath());
 
     assertThat(zipFile.getFileHeaders()).hasSize(1);
-    assertThat(Files.walk(outputFolder.toPath()).filter(Files::isRegularFile)).hasSize(1);
+    assertThat(getRegularFilesFromFolder(outputFolder)).hasSize(1);
   }
 
   @Test
@@ -436,8 +435,8 @@ public class ExtractZipFileIT extends AbstractIT {
     zipFile.extractAll(outputFolder.getPath());
 
     assertThat(zipFile.getFileHeaders()).hasSize(2);
-    Set<String> filenameSet = new HashSet<>();
-    Files.walk(outputFolder.toPath()).forEach(file -> filenameSet.add(file.getFileName().toString()));
+    @SuppressWarnings("ConstantConditions")
+    List<String> filenameSet = getFileNamesOfFiles(Arrays.asList(outputFolder.listFiles()));
     assertThat(filenameSet.contains(expectedFileName)).isTrue();
   }
 
@@ -504,7 +503,7 @@ public class ExtractZipFileIT extends AbstractIT {
     zipFile.extractAll(outputFolder.getPath());
     assertThat(outputFolder.listFiles()).isEmpty();
   }
-  
+
   @Test
   public void testExtractZipFileCRCError() throws IOException {
     ZipFile zipFile = new ZipFile(getTestArchiveFromResources("archive_with_invalid_zip64_headers.zip"));
@@ -712,9 +711,13 @@ public class ExtractZipFileIT extends AbstractIT {
 
   private File getFileWithNameFrom(File outputFolder, String fileName) throws ZipException {
     List<File> filesInFolder = FileUtils.getFilesInDirectoryRecursive(outputFolder, true, true);
-    Optional<File> file = filesInFolder.stream().filter(e -> e.getName().equals(fileName)).findFirst();
-    assertThat(file).isPresent();
-    return file.get();
+    for (File file : filesInFolder) {
+      if (file.getName().equals(fileName)) {
+        return file;
+      }
+    }
+    fail("Could not find a file by name " + fileName);
+    return null;
   }
 
   private File createZipFileAndSplit(List<File> filesToAddToZip, long splitLength, boolean encrypt,
@@ -753,4 +756,16 @@ public class ExtractZipFileIT extends AbstractIT {
     File targetFile = getTestFileFromResources("file_PDF_1MB.pdf");
     return TestUtils.createSymlink(targetFile, temporaryFolder.getRoot());
   }
+
+  private List<File> getRegularFilesFromFolder(File folder) throws ZipException {
+    List<File> filesInFolder = FileUtils.getFilesInDirectoryRecursive(folder, false, false);
+
+    List<File> regularFiles = new ArrayList<>();
+    for (File file : filesInFolder) {
+      if (Files.isRegularFile(file.toPath())) {
+        regularFiles.add(file);
+      }
+    }
+    return regularFiles;
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
index fba5150..a21b48b 100644
--- a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
@@ -24,9 +24,10 @@ import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
-import java.util.stream.Collectors;
+import java.util.concurrent.ThreadFactory;
 
 import static java.util.Collections.singletonList;
+import static net.lingala.zip4j.testutils.TestUtils.getFileNamesOfFiles;
 import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
@@ -80,8 +81,7 @@ public class MiscZipFileIT extends AbstractIT {
 
     assertThat(fileHeaders).isNotNull();
     assertThat(fileHeaders).hasSize(FILES_TO_ADD.size());
-    List<String> fileNames = FILES_TO_ADD.stream().map(File::getName).collect(Collectors.toList());
-    verifyFileHeadersContainsFiles(fileHeaders, fileNames);
+    verifyFileHeadersContainsFiles(fileHeaders, getFileNamesOfFiles(FILES_TO_ADD));
   }
 
   @Test
@@ -95,7 +95,7 @@ public class MiscZipFileIT extends AbstractIT {
 
     assertThat(fileHeaders).isNotNull();
     assertThat(fileHeaders).hasSize(FILES_TO_ADD.size() + 1);
-    List<String> fileNames = FILES_TO_ADD.stream().map(File::getName).collect(Collectors.toList());
+    List<String> fileNames = getFileNamesOfFiles(FILES_TO_ADD);
     fileNames.add("бореиская.txt");
     verifyFileHeadersContainsFiles(fileHeaders, fileNames);
   }
@@ -483,12 +483,15 @@ public class MiscZipFileIT extends AbstractIT {
   public void testCustomThreadFactory() throws IOException {
     TestUtils.copyFileToFolder(getTestFileFromResources("file_PDF_1MB.pdf"), temporaryFolder.getRoot(), 1000);
 
-    String threadName = "CustomThreadFactoryTest";
+    final String threadName = "CustomThreadFactoryTest";
     ZipFile zipFile = new ZipFile(generatedZipFile);
-    zipFile.setThreadFactory(r -> {
-      Thread t = new Thread(threadName);
-      t.setDaemon(false);
-      return t;
+    zipFile.setThreadFactory(new ThreadFactory() {
+      @Override
+      public Thread newThread(Runnable r) {
+        Thread t = new Thread(threadName);
+        t.setDaemon(false);
+        return t;
+      }
     });
     zipFile.setRunInThread(true);
 
@@ -498,8 +501,7 @@ public class MiscZipFileIT extends AbstractIT {
 
     zipFile.addFolder(temporaryFolder.getRoot(), zipParameters);
 
-    Set<Thread> threadSet = Thread.getAllStackTraces().keySet();
-    List<Thread> zip4jThread = threadSet.stream().filter(e -> e.getName().equals(threadName)).collect(Collectors.toList());
+    List<Thread> zip4jThread = filterForThreadsByName(threadName);
     assertThat(zip4jThread).hasSize(1);
     assertThat(zip4jThread.get(0).getName()).isEqualTo(threadName);
     assertThat(zip4jThread.get(0).isDaemon()).isFalse();
@@ -633,4 +635,14 @@ public class MiscZipFileIT extends AbstractIT {
     }
   }
 
+  private List<Thread> filterForThreadsByName(String threadName) {
+    Set<Thread> threadSet = Thread.getAllStackTraces().keySet();
+    List<Thread> filteredThreads = new ArrayList<>();
+    for (Thread thread : threadSet) {
+      if (thread.getName().equals(threadName)) {
+        filteredThreads.add(thread);
+      }
+    }
+    return filteredThreads;
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java b/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
index f7f9bc2..a81ff23 100644
--- a/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
+++ b/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
@@ -18,7 +18,6 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import java.util.stream.Collectors;
 
 import static net.lingala.zip4j.testutils.HeaderVerifier.verifyFileHeadersDoesNotExist;
 import static net.lingala.zip4j.testutils.HeaderVerifier.verifyZipFileDoesNotContainFolders;
@@ -260,6 +259,10 @@ public class RemoveFilesFromZipIT extends AbstractIT {
   private List<String> getFileNamesFromZip(ZipFile zipFile) throws IOException {
     List<FileHeader> fileHeaders = zipFile.getFileHeaders();
     assertThat(fileHeaders).isNotEmpty();
-    return fileHeaders.stream().map(FileHeader::getFileName).collect(Collectors.toList());
+    List<String> fileNames = new ArrayList<>();
+    for (FileHeader fileHeader :fileHeaders) {
+      fileNames.add(fileHeader.getFileName());
+    }
+    return fileNames;
   }
 }
diff --git a/src/test/java/net/lingala/zip4j/ZipFileTest.java b/src/test/java/net/lingala/zip4j/ZipFileTest.java
index 9a59c6a..e4ee385 100644
--- a/src/test/java/net/lingala/zip4j/ZipFileTest.java
+++ b/src/test/java/net/lingala/zip4j/ZipFileTest.java
@@ -60,7 +60,7 @@ public class ZipFileTest {
     expectedException.expectMessage("zip file: " + sourceZipFile + " already exists. " +
         "To add files to existing zip file use addFile method");
 
-    zipFile.createSplitZipFile(Collections.emptyList(), new ZipParameters(), true, 10000);
+    zipFile.createSplitZipFile(Collections.<File>emptyList(), new ZipParameters(), true, 10000);
   }
 
   @Test
@@ -76,7 +76,7 @@ public class ZipFileTest {
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("input file List is null, cannot create zip file");
 
-    zipFile.createSplitZipFile(Collections.emptyList(), new ZipParameters(), true, 10000);
+    zipFile.createSplitZipFile(Collections.<File>emptyList(), new ZipParameters(), true, 10000);
   }
 
   @Test
@@ -177,7 +177,7 @@ public class ZipFileTest {
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("input file List is null or empty");
 
-    zipFile.addFiles(Collections.emptyList());
+    zipFile.addFiles(Collections.<File>emptyList());
   }
 
   @Test
@@ -204,7 +204,7 @@ public class ZipFileTest {
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("input file List is null or empty");
 
-    zipFile.addFiles(Collections.emptyList(), new ZipParameters());
+    zipFile.addFiles(Collections.<File>emptyList(), new ZipParameters());
   }
 
   @Test
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
index b3d60e1..483ae42 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
@@ -74,7 +74,7 @@ public class HeaderUtilTest {
   public void testGetFileHeaderWithEmptyFileHeadersReturnsNull() throws ZipException {
     ZipModel zipModel = new ZipModel();
     CentralDirectory centralDirectory = new CentralDirectory();
-    centralDirectory.setFileHeaders(Collections.emptyList());
+    centralDirectory.setFileHeaders(Collections.<FileHeader>emptyList());
     zipModel.setCentralDirectory(centralDirectory);
 
     FileHeader fileHeader = HeaderUtil.getFileHeader(zipModel, FILE_NAME);
@@ -282,4 +282,4 @@ public class HeaderUtilTest {
     expectedException.expectMessage(message);
     expectedException.expect(ZipException.class);
   }
-}
\ No newline at end of file
+}
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
index 8249878..2854308 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
@@ -708,10 +708,10 @@ public class HeaderWriterIT extends AbstractIT {
     FileHeader firstFileHeader = zipModel.getCentralDirectory().getFileHeaders().get(0);
 
     if (firstFileHeader.getExtraDataRecords() == null) {
-      firstFileHeader.setExtraDataRecords(new ArrayList<>());
+      firstFileHeader.setExtraDataRecords(new ArrayList<ExtraDataRecord>());
     }
 
     firstFileHeader.getExtraDataRecords().add(extraDataRecord);
   }
 
-}
\ No newline at end of file
+}
diff --git a/src/test/java/net/lingala/zip4j/testutils/HeaderVerifier.java b/src/test/java/net/lingala/zip4j/testutils/HeaderVerifier.java
index a683450..e01cecb 100644
--- a/src/test/java/net/lingala/zip4j/testutils/HeaderVerifier.java
+++ b/src/test/java/net/lingala/zip4j/testutils/HeaderVerifier.java
@@ -39,7 +39,9 @@ public class HeaderVerifier {
 
   public static void verifyZipFileDoesNotContainFolders(ZipFile zipFile, Collection<String> folderNames) throws IOException {
     for (FileHeader fileHeader : zipFile.getFileHeaders()) {
-      folderNames.forEach(e -> assertThat(fileHeader.getFileName().startsWith(e)).isFalse());
+      for (String folderName : folderNames) {
+        assertThat(fileHeader.getFileName().startsWith(folderName)).isFalse();
+      }
     }
   }
 
diff --git a/src/test/java/net/lingala/zip4j/testutils/TestUtils.java b/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
index 4b45c05..0f84fa0 100644
--- a/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
+++ b/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
@@ -17,6 +17,7 @@ import java.net.URLDecoder;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
 
@@ -138,6 +139,18 @@ public class TestUtils {
     return link.toFile();
   }
 
+  public static List<String> getFileNamesOfFiles(List<File> files) {
+    List<String> fileNames = new ArrayList<>();
+    if (files.isEmpty()) {
+      return fileNames;
+    }
+
+    for (File file : files) {
+      fileNames.add(file.getName());
+    }
+    return fileNames;
+  }
+
   private static OutputStream startNext7ZipSplitStream(File sourceFile, File outputFolder, int index) throws IOException {
     File outputFile = getFileNameFor7ZipSplitIndex(sourceFile, outputFolder, index);
     return new FileOutputStream(outputFile);
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
index 010b046..fedfc70 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
@@ -2,6 +2,7 @@ package net.lingala.zip4j.util;
 
 import net.lingala.zip4j.AbstractIT;
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.model.ExcludeFileFilter;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.RandomAccessFileMode;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -122,11 +123,16 @@ public class FileUtilsIT extends AbstractIT {
   @Test
   public void testGetFilesInDirectoryRecursiveWithExcludeFileFilter() throws IOException {
     File rootFolder = TestUtils.getTestFileFromResources("");
-    List<File> filesToExclude = Arrays.asList(
+    final List<File> filesToExclude = Arrays.asList(
         TestUtils.getTestFileFromResources("бореиская.txt"),
         TestUtils.getTestFileFromResources("sample_directory/favicon.ico")
     );
-    List<File> allFiles = FileUtils.getFilesInDirectoryRecursive(rootFolder, true, true, filesToExclude::contains);
+    List<File> allFiles = FileUtils.getFilesInDirectoryRecursive(rootFolder, true, true, new ExcludeFileFilter() {
+      @Override
+      public boolean isExcluded(File o) {
+        return filesToExclude.contains(o);
+      }
+    });
 
     assertThat(allFiles).hasSize(10);
     for (File file : allFiles) {
@@ -198,4 +204,4 @@ public class FileUtilsIT extends AbstractIT {
       FileUtils.copyFile(randomAccessFile, outputStream, start, offset, progressMonitor, BUFF_SIZE);
     }
   }
-}
\ No newline at end of file
+}
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsTestLinuxAndMac.java b/src/test/java/net/lingala/zip4j/util/FileUtilsTestLinuxAndMac.java
index 054084a..6412a63 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsTestLinuxAndMac.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsTestLinuxAndMac.java
@@ -15,9 +15,8 @@ import java.nio.file.attribute.PosixFileAttributeView;
 import java.nio.file.attribute.PosixFileAttributes;
 import java.nio.file.attribute.PosixFilePermission;
 import java.nio.file.spi.FileSystemProvider;
+import java.util.HashSet;
 import java.util.Set;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -121,19 +120,19 @@ public class FileUtilsTestLinuxAndMac {
   }
 
   private Set<PosixFilePermission> getAllPermissions() {
-    return Stream.of(
-        PosixFilePermission.OWNER_READ,
-        PosixFilePermission.OWNER_WRITE,
-        PosixFilePermission.OWNER_EXECUTE,
-        PosixFilePermission.GROUP_READ,
-        PosixFilePermission.GROUP_WRITE,
-        PosixFilePermission.GROUP_EXECUTE,
-        PosixFilePermission.OTHERS_READ,
-        PosixFilePermission.OTHERS_WRITE,
-        PosixFilePermission.OTHERS_EXECUTE
-    ).collect(Collectors.toSet());
+    Set<PosixFilePermission> permissions  = new HashSet<>();
+    permissions.add(PosixFilePermission.OWNER_READ);
+    permissions.add(PosixFilePermission.OWNER_WRITE);
+    permissions.add(PosixFilePermission.OWNER_EXECUTE);
+    permissions.add(PosixFilePermission.GROUP_READ);
+    permissions.add(PosixFilePermission.GROUP_WRITE);
+    permissions.add(PosixFilePermission.GROUP_EXECUTE);
+    permissions.add(PosixFilePermission.OTHERS_READ);
+    permissions.add(PosixFilePermission.OTHERS_WRITE);
+    permissions.add(PosixFilePermission.OTHERS_EXECUTE);
+    return permissions;
   }
-  
+
   private void verifyAllPermissionSet(Set<PosixFilePermission> permissions) {
     assertThat(permissions).contains(
         PosixFilePermission.OWNER_READ,
@@ -173,4 +172,4 @@ public class FileUtilsTestLinuxAndMac {
     when(fileSystemProvider.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS))
         .thenReturn(basicFileAttributes);
   }
-}
\ No newline at end of file
+}
