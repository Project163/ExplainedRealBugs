diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
index b695514..f4caac9 100644
--- a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
@@ -32,39 +32,6 @@ public class HeaderUtil {
     return fileHeader;
   }
 
-  public static int getIndexOfFileHeader(ZipModel zipModel, FileHeader fileHeader) throws ZipException {
-
-    if (zipModel == null || fileHeader == null) {
-      throw new ZipException("input parameters is null, cannot determine index of file header");
-    }
-
-    if (zipModel.getCentralDirectory() == null
-        || zipModel.getCentralDirectory().getFileHeaders() == null
-        || zipModel.getCentralDirectory().getFileHeaders().size() <= 0) {
-      return -1;
-    }
-
-    String fileName = fileHeader.getFileName();
-
-    if (!isStringNotNullAndNotEmpty(fileName)) {
-      throw new ZipException("file name in file header is empty or null, cannot determine index of file header");
-    }
-
-    List<FileHeader> fileHeadersFromCentralDir = zipModel.getCentralDirectory().getFileHeaders();
-    for (int i = 0; i < fileHeadersFromCentralDir.size(); i++) {
-      FileHeader fileHeaderFromCentralDir = fileHeadersFromCentralDir.get(i);
-      String fileNameForHdr = fileHeaderFromCentralDir.getFileName();
-      if (!isStringNotNullAndNotEmpty(fileNameForHdr)) {
-        continue;
-      }
-
-      if (fileName.equalsIgnoreCase(fileNameForHdr)) {
-        return i;
-      }
-    }
-    return -1;
-  }
-
   public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded, Charset charset) {
     if (InternalZipConstants.CHARSET_UTF_8.equals(charset) && !isUtf8Encoded) {
       try {
@@ -81,18 +48,6 @@ public class HeaderUtil {
     return new String(data, InternalZipConstants.CHARSET_UTF_8);
   }
 
-
-  public static long getOffsetOfNextEntry(ZipModel zipModel, FileHeader fileHeader) throws ZipException {
-    int indexOfFileHeader = getIndexOfFileHeader(zipModel, fileHeader);
-
-    List<FileHeader> fileHeaders = zipModel.getCentralDirectory().getFileHeaders();
-    if (indexOfFileHeader == fileHeaders.size() - 1) {
-      return getOffsetStartOfCentralDirectory(zipModel);
-    } else {
-      return fileHeaders.get(indexOfFileHeader + 1).getOffsetLocalHeader();
-    }
-  }
-
   public static long getOffsetStartOfCentralDirectory(ZipModel zipModel) {
     if (zipModel.isZip64Format()) {
       return zipModel.getZip64EndOfCentralDirectoryRecord().getOffsetStartCentralDirectoryWRTStartDiskNumber();
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
index 8581e05..524ebe5 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
@@ -1,7 +1,6 @@
 package net.lingala.zip4j.tasks;
 
 import net.lingala.zip4j.exception.ZipException;
-import net.lingala.zip4j.headers.HeaderUtil;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -11,6 +10,7 @@ import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.RandomAccessFile;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
 
@@ -31,17 +31,16 @@ abstract class AbstractModifyFileTask<T> extends AsyncZipTask<T> {
     return tmpFile;
   }
 
-  void updateOffsetsForAllSubsequentFileHeaders(ZipModel zipModel, FileHeader fileHeaderModified, long offsetToAdd) throws ZipException {
-    int indexOfFileHeader = HeaderUtil.getIndexOfFileHeader(zipModel, fileHeaderModified);
+  void updateOffsetsForAllSubsequentFileHeaders(List<FileHeader> sortedFileHeaders, ZipModel zipModel,
+                                                FileHeader fileHeaderModified, long offsetToAdd) throws ZipException {
+    int indexOfFileHeader = getIndexOfFileHeader(sortedFileHeaders, fileHeaderModified);
 
     if (indexOfFileHeader == -1) {
       throw new ZipException("Could not locate modified file header in zipModel");
     }
 
-    List<FileHeader> allFileHeaders = zipModel.getCentralDirectory().getFileHeaders();
-
-    for (int i = indexOfFileHeader + 1; i < allFileHeaders.size(); i++) {
-      FileHeader fileHeaderToUpdate = allFileHeaders.get(i);
+    for (int i = indexOfFileHeader + 1; i < sortedFileHeaders.size(); i++) {
+      FileHeader fileHeaderToUpdate = sortedFileHeaders.get(i);
       fileHeaderToUpdate.setOffsetLocalHeader(fileHeaderToUpdate.getOffsetLocalHeader() + offsetToAdd);
 
       if (zipModel.isZip64Format()
@@ -71,6 +70,30 @@ abstract class AbstractModifyFileTask<T> extends AsyncZipTask<T> {
     return length;
   }
 
+  List<FileHeader> cloneAndSortFileHeadersByOffset(List<FileHeader> allFileHeaders) {
+    List<FileHeader> clonedFileHeaders = new ArrayList<>(allFileHeaders);
+    clonedFileHeaders.sort((o1, o2) -> {
+      if (o1.getFileName().equals(o2.getFileName())) {
+        return 0;
+      }
+
+      return o1.getOffsetLocalHeader() < o2.getOffsetLocalHeader() ? -1 : 1;
+    });
+
+    return clonedFileHeaders;
+  }
+
+  long getOffsetOfNextEntry(List<FileHeader> sortedFileHeaders, FileHeader fileHeader,
+                                   long offsetStartOfCentralDirectory) throws ZipException {
+    int indexOfFileHeader = getIndexOfFileHeader(sortedFileHeaders, fileHeader);
+
+    if (indexOfFileHeader == sortedFileHeaders.size() - 1) {
+      return offsetStartOfCentralDirectory;
+    } else {
+      return sortedFileHeaders.get(indexOfFileHeader + 1).getOffsetLocalHeader();
+    }
+  }
+
   private void restoreFileName(File zipFile, File temporaryZipFile) throws ZipException {
     if (zipFile.delete()) {
       if (!temporaryZipFile.renameTo(zipFile)) {
@@ -80,4 +103,15 @@ abstract class AbstractModifyFileTask<T> extends AsyncZipTask<T> {
       throw new ZipException("cannot delete old zip file");
     }
   }
+
+  private int getIndexOfFileHeader(List<FileHeader> allFileHeaders, FileHeader fileHeaderForIndex) throws ZipException {
+    for (int i = 0; i < allFileHeaders.size(); i++) {
+      FileHeader fileHeader = allFileHeaders.get(i);
+      if (fileHeader.equals(fileHeaderForIndex)) {
+        return i;
+      }
+    }
+
+    throw new ZipException("Could not find file header in list of central directory file headers");
+  }
 }
diff --git a/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java b/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
index dea258c..72caacc 100644
--- a/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
@@ -44,17 +44,19 @@ public class RemoveFilesFromZipTask extends AbstractModifyFileTask<RemoveFilesFr
 
     File temporaryZipFile = getTemporaryFile(zipModel.getZipFile().getPath());
     boolean successFlag = false;
+    long offsetOfCentralDirectoryBeforeModification = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);
 
     try (SplitOutputStream outputStream = new SplitOutputStream(temporaryZipFile);
          RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.READ.getValue())){
 
       long currentFileCopyPointer = 0;
-      List<FileHeader> allUnchangedFileHeaders = new ArrayList<>(zipModel.getCentralDirectory().getFileHeaders());
+      List<FileHeader> sortedFileHeaders = cloneAndSortFileHeadersByOffset(zipModel.getCentralDirectory().getFileHeaders());
 
-      for (FileHeader fileHeader : allUnchangedFileHeaders) {
-        long lengthOfCurrentEntry = HeaderUtil.getOffsetOfNextEntry(zipModel, fileHeader) - outputStream.getFilePointer();
+      for (FileHeader fileHeader : sortedFileHeaders) {
+        long lengthOfCurrentEntry = getOffsetOfNextEntry(sortedFileHeaders, fileHeader,
+            offsetOfCentralDirectoryBeforeModification) - outputStream.getFilePointer();
         if (shouldEntryBeRemoved(fileHeader, entriesToRemove)) {
-          updateHeaders(fileHeader, lengthOfCurrentEntry);
+          updateHeaders(sortedFileHeaders, fileHeader, lengthOfCurrentEntry);
 
           if (!zipModel.getCentralDirectory().getFileHeaders().remove(fileHeader)) {
             throw new ZipException("Could not remove entry from list of central directory headers");
@@ -102,8 +104,8 @@ public class RemoveFilesFromZipTask extends AbstractModifyFileTask<RemoveFilesFr
     return false;
   }
 
-  private void updateHeaders(FileHeader fileHeaderThatWasRemoved, long offsetToSubtract) throws ZipException {
-    updateOffsetsForAllSubsequentFileHeaders(zipModel, fileHeaderThatWasRemoved, negate(offsetToSubtract));
+  private void updateHeaders(List<FileHeader> sortedFileHeaders, FileHeader fileHeaderThatWasRemoved, long offsetToSubtract) throws ZipException {
+    updateOffsetsForAllSubsequentFileHeaders(sortedFileHeaders, zipModel, fileHeaderThatWasRemoved, negate(offsetToSubtract));
 
     EndOfCentralDirectoryRecord endOfCentralDirectoryRecord = zipModel.getEndOfCentralDirectoryRecord();
     endOfCentralDirectoryRecord.setOffsetOfStartOfCentralDirectory(
diff --git a/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
index 6e0319d..1b9a634 100644
--- a/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
@@ -17,7 +17,6 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.io.RandomAccessFile;
 import java.nio.charset.Charset;
-import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -50,19 +49,21 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
         SplitOutputStream outputStream = new SplitOutputStream(temporaryFile)) {
 
       long currentFileCopyPointer = 0;
+      long offsetOfCentralDirectoryBeforeModification = HeaderUtil.getOffsetStartOfCentralDirectory(zipModel);
 
       // Maintain a different list to iterate, so that when the file name is changed in the central directory
       // we still have access to the original file names. If iterating on the original list from central directory,
       // it might be that a file name has changed because of other file name, ex: if a directory name has to be changed
       // and the file is part of that directory, by the time the file has to be changed, its name might have changed
       // when changing the name of the directory. There is some overhead with this approach, but is safer.
-      List<FileHeader> allUnchangedFileHeaders = new ArrayList<>(zipModel.getCentralDirectory().getFileHeaders());
+      List<FileHeader> sortedFileHeaders = cloneAndSortFileHeadersByOffset(zipModel.getCentralDirectory().getFileHeaders());
 
-      for (FileHeader fileHeader : allUnchangedFileHeaders) {
+      for (FileHeader fileHeader : sortedFileHeaders) {
         Map.Entry<String, String> fileNameMapForThisEntry = getCorrespondingEntryFromMap(fileHeader, fileNamesMap);
         progressMonitor.setFileName(fileHeader.getFileName());
 
-        long lengthToCopy = HeaderUtil.getOffsetOfNextEntry(zipModel, fileHeader) - outputStream.getFilePointer();
+        long lengthToCopy = getOffsetOfNextEntry(sortedFileHeaders, fileHeader,
+            offsetOfCentralDirectoryBeforeModification) - outputStream.getFilePointer();
         if (fileNameMapForThisEntry == null) {
           // copy complete entry without any changes
           currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, lengthToCopy, progressMonitor);
@@ -74,7 +75,7 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
           currentFileCopyPointer = copyEntryAndChangeFileName(newFileNameBytes, fileHeader, currentFileCopyPointer, lengthToCopy,
               inputStream, outputStream, progressMonitor);
 
-          updateHeadersInZipModel(fileHeader, newFileName, newFileNameBytes, headersOffset);
+          updateHeadersInZipModel(sortedFileHeaders, fileHeader, newFileName, newFileNameBytes, headersOffset);
         }
 
         verifyIfTaskIsCancelled();
@@ -133,8 +134,8 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
     return null;
   }
 
-  private void updateHeadersInZipModel(FileHeader fileHeader, String newFileName, byte[] newFileNameBytes,
-                                       int headersOffset) throws ZipException {
+  private void updateHeadersInZipModel(List<FileHeader> sortedFileHeaders, FileHeader fileHeader, String newFileName,
+                                       byte[] newFileNameBytes, int headersOffset) throws ZipException {
 
     FileHeader fileHeaderToBeChanged = HeaderUtil.getFileHeader(zipModel, fileHeader.getFileName());
 
@@ -147,7 +148,7 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
     fileHeaderToBeChanged.setFileName(newFileName);
     fileHeaderToBeChanged.setFileNameLength(newFileNameBytes.length);
 
-    updateOffsetsForAllSubsequentFileHeaders(zipModel, fileHeaderToBeChanged, headersOffset);
+    updateOffsetsForAllSubsequentFileHeaders(sortedFileHeaders, zipModel, fileHeaderToBeChanged, headersOffset);
 
     zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(
         zipModel.getEndOfCentralDirectoryRecord().getOffsetOfStartOfCentralDirectory() + headersOffset);
diff --git a/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java b/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
index 28bfa46..b699cc5 100644
--- a/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
+++ b/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
@@ -201,4 +201,31 @@ public class RemoveFilesFromZipIT extends AbstractIT {
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 2);
     verifyFileHeadersDoesNotExist(zipFile, filesToRemove);
   }
+
+  @Test
+  public void testRemoveFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {
+    testRemoveEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries("test-files/zero_byte_file.txt");
+  }
+
+  @Test
+  public void testRemoveLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {
+    testRemoveEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries("test-files/бореиская.txt");
+  }
+
+  @Test
+  public void testRemoveMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {
+    testRemoveEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries("test-files/file_PDF_1MB.pdf");
+  }
+
+  private void testRemoveEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries(
+      String fileNameToRemove) throws IOException {
+    TestUtils.copyFile(TestUtils.getTestArchiveFromResources("cen_dir_entries_diff_order_as_local_entries.zip"),
+        generatedZipFile);
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.removeFile(fileNameToRemove);
+
+    zipFile = new ZipFile(generatedZipFile);
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 12);
+    verifyFileHeadersDoesNotExist(zipFile, Collections.singletonList(fileNameToRemove));
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/RenameFilesInZipIT.java b/src/test/java/net/lingala/zip4j/RenameFilesInZipIT.java
index 4b64865..5e888f9 100644
--- a/src/test/java/net/lingala/zip4j/RenameFilesInZipIT.java
+++ b/src/test/java/net/lingala/zip4j/RenameFilesInZipIT.java
@@ -260,6 +260,33 @@ public class RenameFilesInZipIT extends AbstractIT {
     verifyFileNamesChanged(zipFile, fileNamesMap, false);
   }
 
+  @Test
+  public void testRenameFirstEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {
+    testRenameEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries("test-files/zero_byte_file.txt");
+  }
+
+  @Test
+  public void testRenameLastEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {
+    testRenameEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries("test-files/бореиская.txt");
+  }
+
+  @Test
+  public void testRenameMiddleEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries() throws IOException {
+    testRenameEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries("test-files/file_PDF_1MB.pdf");
+  }
+
+  private void testRenameEntryFromZipWhichHasCentralDirEntriesInDifferentOrderThanLocalEntries(
+      String fileNameToRename) throws IOException {
+    TestUtils.copyFile(TestUtils.getTestArchiveFromResources("cen_dir_entries_diff_order_as_local_entries.zip"),
+        generatedZipFile);
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.renameFile(fileNameToRename, "somename.txt");
+
+    zipFile = new ZipFile(generatedZipFile);
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 13, false);
+    verifyFileNamesChanged(zipFile, Collections.singletonMap(fileNameToRename, "somename.txt"), false);
+  }
+
   private void verifyFileNamesChanged(ZipFile zipFile, Map<String, String> fileNamesMap) throws IOException {
     verifyFileNamesChanged(zipFile, fileNamesMap, true);
   }
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
index 999124b..533c07a 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
@@ -141,82 +141,6 @@ public class HeaderUtilTest {
     assertThat(HeaderUtil.getFileHeader(zipModel, "SHOULD_NOT_EXIST")).isNull();
   }
 
-  @Test
-  public void testGetIndexOfFileHeaderWhenZipModelIsNullThrowsException() throws ZipException {
-    expectZipException("input parameters is null, cannot determine index of file header");
-    HeaderUtil.getIndexOfFileHeader(null, new FileHeader());
-  }
-
-  @Test
-  public void testGetIndexOfFileHeaderWhenFileHeaderlIsNullThrowsException() throws ZipException {
-    expectZipException("input parameters is null, cannot determine index of file header");
-    HeaderUtil.getIndexOfFileHeader(new ZipModel(), null);
-  }
-
-  @Test
-  public void testGetIndexOfFileHeaderWhenCentralDirectoryIsNullReturnsNegativeOne() throws ZipException {
-    ZipModel zipModel = new ZipModel();
-    zipModel.setCentralDirectory(null);
-
-    assertThat(HeaderUtil.getIndexOfFileHeader(zipModel, new FileHeader())).isEqualTo(-1);
-  }
-
-  @Test
-  public void testGetIndexOfFileHeaderWhenFileHeadersIsNullReturnsNegativeOne() throws ZipException {
-    ZipModel zipModel = new ZipModel();
-    zipModel.getCentralDirectory().setFileHeaders(null);
-
-    assertThat(HeaderUtil.getIndexOfFileHeader(zipModel, new FileHeader())).isEqualTo(-1);
-  }
-
-  @Test
-  public void testGetIndexOfFileHeaderWhenFileHeadersIsEmptyReturnsNegativeOne() throws ZipException {
-    ZipModel zipModel = new ZipModel();
-    zipModel.getCentralDirectory().setFileHeaders(Collections.emptyList());
-
-    assertThat(HeaderUtil.getIndexOfFileHeader(zipModel, new FileHeader())).isEqualTo(-1);
-  }
-
-  @Test
-  public void testGetIndexOfFileHeaderWithNullFileNameInFileHeaderThrowsException() throws ZipException {
-    expectZipException("file name in file header is empty or null, cannot determine index of file header");
-
-    ZipModel zipModel = new ZipModel();
-    zipModel.getCentralDirectory().setFileHeaders(Collections.singletonList(new FileHeader()));
-
-    HeaderUtil.getIndexOfFileHeader(zipModel, new FileHeader());
-  }
-
-  @Test
-  public void testGetIndexOfFileHeaderWithEmptyFileNameInFileHeaderThrowsException() throws ZipException {
-    expectZipException("file name in file header is empty or null, cannot determine index of file header");
-
-    ZipModel zipModel = new ZipModel();
-    zipModel.getCentralDirectory().setFileHeaders(Collections.singletonList(new FileHeader()));
-    FileHeader fileHeader = new FileHeader();
-    fileHeader.setFileName("");
-
-    HeaderUtil.getIndexOfFileHeader(zipModel, new FileHeader());
-  }
-
-  @Test
-  public void testGetIndexOfFileHeaderGetsIndexSuccessfully() throws ZipException {
-    String fileNamePrefix = "FILE_NAME_";
-    int numberOfEntriesToAdd = 10;
-    List<FileHeader> fileHeadersInZipModel = generateFileHeaderWithFileNamesWithEmptyAndNullFileNames(fileNamePrefix, numberOfEntriesToAdd);
-    ZipModel zipModel = new ZipModel();
-    zipModel.getCentralDirectory().setFileHeaders(fileHeadersInZipModel);
-
-    FileHeader fileHeaderToFind = new FileHeader();
-    for (int i = 0; i < numberOfEntriesToAdd; i++) {
-      fileHeaderToFind.setFileName(fileNamePrefix + i);
-      assertThat(HeaderUtil.getIndexOfFileHeader(zipModel, fileHeaderToFind)).isEqualTo(i);
-    }
-
-    fileHeaderToFind.setFileName(fileNamePrefix + numberOfEntriesToAdd);
-    assertThat(HeaderUtil.getIndexOfFileHeader(zipModel, fileHeaderToFind)).isEqualTo(-1);
-  }
-
   @Test
   public void testDecodeStringWithCharsetForUtf8() {
     String utf8StringToEncode = "asdäüöö";
diff --git a/src/test/resources/test-archives/cen_dir_entries_diff_order_as_local_entries.zip b/src/test/resources/test-archives/cen_dir_entries_diff_order_as_local_entries.zip
new file mode 100644
index 0000000..d1bbded
Binary files /dev/null and b/src/test/resources/test-archives/cen_dir_entries_diff_order_as_local_entries.zip differ
