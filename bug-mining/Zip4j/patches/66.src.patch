diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index 6d81966..2986d06 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -20,6 +20,7 @@ import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.headers.HeaderReader;
 import net.lingala.zip4j.headers.HeaderUtil;
 import net.lingala.zip4j.headers.HeaderWriter;
+import net.lingala.zip4j.io.inputstream.NumberedSplitRandomAccessFile;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipModel;
@@ -54,6 +55,7 @@ import java.util.Collections;
 import java.util.List;
 
 import static net.lingala.zip4j.util.FileUtils.assertFilesExist;
+import static net.lingala.zip4j.util.FileUtils.isNumberedSplitFile;
 import static net.lingala.zip4j.util.InternalZipConstants.CHARSET_UTF_8;
 import static net.lingala.zip4j.util.UnzipUtil.createZipInputStream;
 import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;
@@ -846,7 +848,7 @@ public class ZipFile {
       throw new ZipException("no read access for the input zip file");
     }
 
-    try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) {
+    try (RandomAccessFile randomAccessFile = initializeRandomAccessFileForHeaderReading()) {
       HeaderReader headerReader = new HeaderReader();
       zipModel = headerReader.readAllHeaders(randomAccessFile, charset);
       zipModel.setZipFile(zipFile);
@@ -867,6 +869,18 @@ public class ZipFile {
     zipModel.setZipFile(zipFile);
   }
 
+  private RandomAccessFile initializeRandomAccessFileForHeaderReading() throws IOException {
+    if (isNumberedSplitFile(zipFile)) {
+      File[] allSplitFiles = FileUtils.getAllSortedNumberedSplitFiles(zipFile);
+      NumberedSplitRandomAccessFile numberedSplitRandomAccessFile =  new NumberedSplitRandomAccessFile(zipFile,
+          RandomAccessFileMode.READ.getValue(), allSplitFiles);
+      numberedSplitRandomAccessFile.openLastSplitFileForReading();
+      return numberedSplitRandomAccessFile;
+    }
+
+    return new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue());
+  }
+
   public ProgressMonitor getProgressMonitor() {
     return progressMonitor;
   }
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
index 33c11bf..564fad9 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
@@ -17,6 +17,7 @@
 package net.lingala.zip4j.headers;
 
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.io.inputstream.NumberedSplitRandomAccessFile;
 import net.lingala.zip4j.model.AESExtraDataRecord;
 import net.lingala.zip4j.model.CentralDirectory;
 import net.lingala.zip4j.model.DataDescriptor;
@@ -109,7 +110,7 @@ public class HeaderReader {
     int counter = 0;
     int headerSignature;
     do {
-      zip4jRaf.seek(pos--);
+      seekInCurrentPart(zip4jRaf, pos--);
       counter++;
     } while (((headerSignature = rawIO.readIntLittleEndian(zip4jRaf))
         != HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue()) && counter <= zipFileLengthWithoutEndHeader);
@@ -528,7 +529,7 @@ public class HeaderReader {
     long pos = zip4jRaf.length() - ENDHDR;
 
     do {
-      zip4jRaf.seek(pos--);
+      seekInCurrentPart(zip4jRaf, pos--);
     } while (rawIO.readIntLittleEndian(zip4jRaf) != HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue());
 
     // Now the file pointer is at the end of signature of Central Dir Rec
@@ -539,7 +540,7 @@ public class HeaderReader {
     // 4 -> number of the disk with the start of the zip64 end of central directory
     // 4 -> zip64 end of central dir locator signature
     // Refer to Appnote for more information
-    zip4jRaf.seek(zip4jRaf.getFilePointer() - 4 - 4 - 8 - 4 - 4);
+    seekInCurrentPart(zip4jRaf, zip4jRaf.getFilePointer() - 4 - 4 - 8 - 4 - 4);
   }
 
   public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException {
@@ -730,4 +731,12 @@ public class HeaderReader {
 
     return zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory();
   }
+
+  private void seekInCurrentPart(RandomAccessFile randomAccessFile, long pos) throws IOException {
+    if (randomAccessFile instanceof NumberedSplitRandomAccessFile) {
+      ((NumberedSplitRandomAccessFile) randomAccessFile).seekInCurrentPart(pos);
+    } else {
+      randomAccessFile.seek(pos);
+    }
+  }
 }
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/NumberedSplitInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/NumberedSplitInputStream.java
new file mode 100644
index 0000000..782a741
--- /dev/null
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/NumberedSplitInputStream.java
@@ -0,0 +1,26 @@
+package net.lingala.zip4j.io.inputstream;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import static net.lingala.zip4j.util.FileUtils.getNextNumberedSplitFileCounterAsExtension;
+
+/**
+ * A split input stream for zip file split with 7-zip. They end with .zip.001, .zip.002, etc
+ */
+public class NumberedSplitInputStream extends SplitInputStream {
+
+  public NumberedSplitInputStream(File zipFile, boolean isSplitZipArchive, int lastSplitZipFileNumber)
+      throws FileNotFoundException {
+    super(zipFile, isSplitZipArchive, lastSplitZipFileNumber);
+  }
+
+  @Override
+  protected File getNextSplitFile(int zipFileIndex) throws IOException {
+    String currZipFileNameWithPath = zipFile.getCanonicalPath();
+    String fileNameWithPathAndWithoutExtension = currZipFileNameWithPath.substring(0,
+        currZipFileNameWithPath.lastIndexOf("."));
+    return new File(fileNameWithPathAndWithoutExtension + getNextNumberedSplitFileCounterAsExtension(zipFileIndex));
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/NumberedSplitRandomAccessFile.java b/src/main/java/net/lingala/zip4j/io/inputstream/NumberedSplitRandomAccessFile.java
new file mode 100644
index 0000000..6c723c0
--- /dev/null
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/NumberedSplitRandomAccessFile.java
@@ -0,0 +1,163 @@
+package net.lingala.zip4j.io.inputstream;
+
+import net.lingala.zip4j.model.enums.RandomAccessFileMode;
+import net.lingala.zip4j.util.FileUtils;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+
+/**
+ * A RandomAccessFile which reads files split with 7-zip format (.z001, .z002, etc) as a single file making it easier
+ * for calling methods to deal with opening appropriate split file to read
+ */
+public class NumberedSplitRandomAccessFile extends RandomAccessFile {
+
+  private long splitLength;
+  private File[] allSortedSplitFiles;
+  private RandomAccessFile randomAccessFile;
+  private byte[] singleByteBuffer = new byte[1];
+  private int currentOpenSplitFileCounter = 0;
+  private String rwMode;
+
+  public NumberedSplitRandomAccessFile(String name, String mode) throws IOException {
+    this(new File(name), mode);
+  }
+
+  public NumberedSplitRandomAccessFile(File file, String mode) throws IOException {
+    this(file, mode, FileUtils.getAllSortedNumberedSplitFiles(file));
+  }
+
+  public NumberedSplitRandomAccessFile(File file, String mode, File[] allSortedSplitFiles) throws IOException {
+    super(file, mode);
+
+    // A (dirty) hack to be able to open any split file without relying on the Parent class
+    // For that the parent handle is closed, and a new RandomAccessFile is initiated
+    // This makes it possible for this class to still extend RandomAccessFile and be able to open any split file
+    // without calling code having to worry about opening a split file. Code using this class can read the
+    // split files as if it were one file. zip4j uses RandomAccessFile in a lot of places. This hack allows to deal
+    // with split files with RandomAccessFile without having to modify a lot of code, especially for a feature
+    // that will not be used most often
+    super.close();
+
+    if (RandomAccessFileMode.WRITE.getValue().equals(mode)) {
+      throw new IllegalArgumentException("write mode is not allowed for NumberedSplitRandomAccessFile");
+    }
+
+    assertAllSplitFilesExist(allSortedSplitFiles);
+
+    this.randomAccessFile = new RandomAccessFile(file, mode);
+    this.allSortedSplitFiles = allSortedSplitFiles;
+    this.splitLength = file.length();
+    this.rwMode = mode;
+  }
+
+  @Override
+  public int read() throws IOException {
+    int readLen = read(singleByteBuffer);
+
+    if (readLen == -1) {
+      return -1;
+    }
+
+    return singleByteBuffer[0] & 0xff;
+  }
+
+  @Override
+  public int read(byte[] b) throws IOException {
+    return read(b, 0, b.length);
+  }
+
+  @Override
+  public int read(byte[] b, int off, int len) throws IOException {
+    int readLen = randomAccessFile.read(b, off, len);
+
+    if (readLen == -1) {
+      if (currentOpenSplitFileCounter == allSortedSplitFiles.length - 1) {
+        return -1;
+      }
+      openRandomAccessFileForIndex(currentOpenSplitFileCounter + 1);
+      return read(b, off, len);
+    }
+
+    return readLen;
+  }
+
+  @Override
+  public void write(int b) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void write(byte[] b) throws IOException {
+    write(b, 0, b.length);
+  }
+
+  @Override
+  public void write(byte[] b, int off, int len) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void seek(long pos) throws IOException {
+    int splitPartOfPosition = (int) (pos / splitLength);
+
+    if (splitPartOfPosition != currentOpenSplitFileCounter) {
+      openRandomAccessFileForIndex(splitPartOfPosition);
+    }
+
+    randomAccessFile.seek(pos - (splitPartOfPosition * splitLength));
+  }
+
+  @Override
+  public long getFilePointer() throws IOException {
+    return randomAccessFile.getFilePointer();
+  }
+
+  @Override
+  public long length() throws IOException {
+    return randomAccessFile.length();
+  }
+
+  public void seekInCurrentPart(long pos) throws IOException {
+    randomAccessFile.seek(pos);
+  }
+
+  public void openLastSplitFileForReading() throws IOException {
+    openRandomAccessFileForIndex(allSortedSplitFiles.length - 1);
+  }
+
+  private void openRandomAccessFileForIndex(int splitCounter) throws IOException {
+    if (currentOpenSplitFileCounter == splitCounter) {
+      return;
+    }
+
+    if (splitCounter > allSortedSplitFiles.length - 1) {
+      throw new IOException("split counter greater than number of split files");
+    }
+
+    if (randomAccessFile != null) {
+      randomAccessFile.close();
+    }
+
+    randomAccessFile = new RandomAccessFile(allSortedSplitFiles[splitCounter], rwMode);
+    currentOpenSplitFileCounter = splitCounter;
+  }
+
+  private void assertAllSplitFilesExist(File[] allSortedSplitFiles) throws IOException {
+    int splitCounter = 1;
+    for (File splitFile : allSortedSplitFiles) {
+      String fileExtension = FileUtils.getFileExtension(splitFile);
+      try {
+        if (splitCounter != Integer.parseInt(fileExtension)) {
+          throw new IOException("Split file number " + splitCounter + " does not exist");
+        }
+        splitCounter++;
+      } catch (NumberFormatException e) {
+        throw new IOException("Split file extension not in expected format. Found: " + fileExtension
+            + " expected of format: .001, .002, etc");
+      }
+
+    }
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/SplitInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/SplitInputStream.java
index 4d70d5d..e0de8bc 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/SplitInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/SplitInputStream.java
@@ -9,11 +9,11 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.RandomAccessFile;
 
-public class SplitInputStream extends InputStream {
+public abstract class SplitInputStream extends InputStream {
+
+  protected RandomAccessFile randomAccessFile;
+  protected File zipFile;
 
-  private RandomAccessFile randomAccessFile;
-  private File zipFile;
-  private int lastSplitZipFileNumber;
   private boolean isSplitZipArchive;
   private int currentSplitFileCounter = 0;
   private byte[] singleByteArray = new byte[1];
@@ -22,7 +22,7 @@ public class SplitInputStream extends InputStream {
     this.randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue());
     this.zipFile = zipFile;
     this.isSplitZipArchive = isSplitZipArchive;
-    this.lastSplitZipFileNumber = lastSplitZipFileNumber;
+
 
     if (isSplitZipArchive) {
       currentSplitFileCounter = lastSplitZipFileNumber;
@@ -70,8 +70,8 @@ public class SplitInputStream extends InputStream {
     randomAccessFile.seek(fileHeader.getOffsetLocalHeader());
   }
 
-  private void openRandomAccessFileForIndex(int zipFileIndex) throws IOException {
-    File nextSplitFile = getNextSplitFileName(zipFileIndex);
+  protected void openRandomAccessFileForIndex(int zipFileIndex) throws IOException {
+    File nextSplitFile = getNextSplitFile(zipFileIndex);
     if (!nextSplitFile.exists()) {
       throw new FileNotFoundException("zip split file does not exist: " + nextSplitFile);
     }
@@ -79,20 +79,7 @@ public class SplitInputStream extends InputStream {
     randomAccessFile = new RandomAccessFile(nextSplitFile, RandomAccessFileMode.READ.getValue());
   }
 
-  private File getNextSplitFileName(int zipFileIndex) throws IOException {
-    if (zipFileIndex == lastSplitZipFileNumber) {
-      return zipFile;
-    }
-
-    String currZipFileNameWithPath = zipFile.getCanonicalPath();
-    String extensionSubString = ".z0";
-    if (zipFileIndex >= 9) {
-      extensionSubString = ".z";
-    }
-
-    return new File(currZipFileNameWithPath.substring(0,
-        currZipFileNameWithPath.lastIndexOf(".")) + extensionSubString + (zipFileIndex + 1));
-  }
+  protected abstract File getNextSplitFile(int zipFileIndex) throws IOException;
 
   @Override
   public void close() throws IOException {
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardSplitInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardSplitInputStream.java
new file mode 100644
index 0000000..77c1f4c
--- /dev/null
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardSplitInputStream.java
@@ -0,0 +1,34 @@
+package net.lingala.zip4j.io.inputstream;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+/**
+ * A split input stream for zip file split as per zip specification. They end with .z01, .z02... .zip
+ */
+public class ZipStandardSplitInputStream extends SplitInputStream {
+
+  private int lastSplitZipFileNumber;
+
+  public ZipStandardSplitInputStream(File zipFile, boolean isSplitZipArchive, int lastSplitZipFileNumber) throws FileNotFoundException {
+    super(zipFile, isSplitZipArchive, lastSplitZipFileNumber);
+    this.lastSplitZipFileNumber = lastSplitZipFileNumber;
+  }
+
+  @Override
+  protected File getNextSplitFile(int zipFileIndex) throws IOException {
+    if (zipFileIndex == lastSplitZipFileNumber) {
+      return zipFile;
+    }
+
+    String currZipFileNameWithPath = zipFile.getCanonicalPath();
+    String extensionSubString = ".z0";
+    if (zipFileIndex >= 9) {
+      extensionSubString = ".z";
+    }
+
+    return new File(currZipFileNameWithPath.substring(0,
+        currZipFileNameWithPath.lastIndexOf(".")) + extensionSubString + (zipFileIndex + 1));
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
index b80b95d..21ab697 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
@@ -6,6 +6,7 @@ import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.ExtractAllFilesTask.ExtractAllFilesTaskParameters;
+import net.lingala.zip4j.util.UnzipUtil;
 
 import java.io.IOException;
 import java.nio.charset.Charset;
@@ -59,8 +60,7 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
   }
 
   private ZipInputStream prepareZipInputStream(Charset charset) throws IOException {
-    splitInputStream = new SplitInputStream(getZipModel().getZipFile(),
-        getZipModel().isSplitArchive(), getZipModel().getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
+    splitInputStream = UnzipUtil.createSplitInputStream(getZipModel());
 
     FileHeader fileHeader = getFirstFileHeader(getZipModel());
     if (fileHeader != null) {
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
index 2fed6e7..54485e7 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
@@ -6,6 +6,7 @@ import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.ExtractFileTask.ExtractFileTaskParameters;
+import net.lingala.zip4j.util.UnzipUtil;
 
 import java.io.IOException;
 import java.nio.charset.Charset;
@@ -39,8 +40,7 @@ public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskPara
   }
 
   protected ZipInputStream createZipInputStream(FileHeader fileHeader, Charset charset) throws IOException {
-    splitInputStream = new SplitInputStream(getZipModel().getZipFile(),
-        getZipModel().isSplitArchive(), getZipModel().getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
+    splitInputStream = UnzipUtil.createSplitInputStream(getZipModel());
     splitInputStream.prepareExtractionForFileHeader(fileHeader);
     return new ZipInputStream(splitInputStream, password, charset);
   }
diff --git a/src/main/java/net/lingala/zip4j/util/FileUtils.java b/src/main/java/net/lingala/zip4j/util/FileUtils.java
index 9132a6c..fde7d3c 100644
--- a/src/main/java/net/lingala/zip4j/util/FileUtils.java
+++ b/src/main/java/net/lingala/zip4j/util/FileUtils.java
@@ -17,6 +17,7 @@ import java.nio.file.attribute.FileTime;
 import java.nio.file.attribute.PosixFileAttributeView;
 import java.nio.file.attribute.PosixFilePermission;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -121,6 +122,16 @@ public class FileUtils {
     return result;
   }
 
+  public static String getFileNameWithoutExtension(String fileName) {
+    int pos = fileName.lastIndexOf(".");
+    if (pos == -1) {
+      return fileName;
+    }
+
+    return fileName.substring(0, pos);
+  }
+
+
   public static String getZipFileNameWithoutExtension(String zipFile) throws ZipException {
     if (!isStringNotNullAndNotEmpty(zipFile)) {
       throw new ZipException("zip file name is empty or null, cannot determine zip file name");
@@ -318,6 +329,53 @@ public class FileUtils {
     }
   }
 
+  public static boolean isNumberedSplitFile(File file) {
+    return file.getName().endsWith(InternalZipConstants.SEVEN_ZIP_SPLIT_FILE_EXTENSION_PATTERN);
+  }
+
+  public static String getFileExtension(File file) {
+    String fileName = file.getName();
+
+    if (!fileName.contains(".")) {
+      return "";
+    }
+
+    return fileName.substring(fileName.lastIndexOf(".") + 1);
+  }
+
+  /**
+   * A helper method to retrieve all split files which are of the format split by 7-zip, i.e, .zip.001, .zip.002, etc.
+   * This method also sorts all the files by their split part
+   * @param firstNumberedFile - first split file
+   * @return sorted list of split files. Returns an empty list if no files of that pattern are found in the current directory
+   */
+  public static File[] getAllSortedNumberedSplitFiles(File firstNumberedFile) {
+    String zipFileNameWithoutExtension = FileUtils.getFileNameWithoutExtension(firstNumberedFile.getName());
+    File[] allSplitFiles = firstNumberedFile.getParentFile().listFiles((dir, name) -> name.startsWith(zipFileNameWithoutExtension + "."));
+
+    if(allSplitFiles == null) {
+      return new File[0];
+    }
+
+    Arrays.sort(allSplitFiles);
+
+    return allSplitFiles;
+  }
+
+  public static String getNextNumberedSplitFileCounterAsExtension(int index) {
+    return "." + getExtensionZerosPrefix(index) + (index + 1);
+  }
+
+  private static String getExtensionZerosPrefix(int index) {
+    if (index < 9) {
+      return "00";
+    } else if (index < 99) {
+      return "0";
+    } else {
+      return "";
+    }
+  }
+
   private static void applyWindowsFileAttributes(Path file, byte[] fileAttributes) {
     if (fileAttributes[0] == 0) {
       // No file attributes defined in the archive
diff --git a/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java b/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
index 0f71307..6aa5c62 100755
--- a/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
+++ b/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
@@ -56,4 +56,6 @@ public final class InternalZipConstants {
   public static final int MAX_ALLOWED_ZIP_COMMENT_LENGTH = 0xFFFF;
 
   public static final Charset CHARSET_UTF_8 = Charset.forName("UTF-8");
+
+  public static final String SEVEN_ZIP_SPLIT_FILE_EXTENSION_PATTERN = ".zip.001";
 }
diff --git a/src/main/java/net/lingala/zip4j/util/UnzipUtil.java b/src/main/java/net/lingala/zip4j/util/UnzipUtil.java
index 6f445d6..08b76c1 100755
--- a/src/main/java/net/lingala/zip4j/util/UnzipUtil.java
+++ b/src/main/java/net/lingala/zip4j/util/UnzipUtil.java
@@ -1,8 +1,10 @@
 package net.lingala.zip4j.util;
 
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.io.inputstream.NumberedSplitInputStream;
 import net.lingala.zip4j.io.inputstream.SplitInputStream;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
+import net.lingala.zip4j.io.inputstream.ZipStandardSplitInputStream;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipModel;
 
@@ -21,8 +23,7 @@ public class UnzipUtil {
 
     SplitInputStream splitInputStream = null;
     try {
-      splitInputStream = new SplitInputStream(zipModel.getZipFile(), zipModel.isSplitArchive(),
-          zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
+      splitInputStream = createSplitInputStream(zipModel);
       splitInputStream.prepareExtractionForFileHeader(fileHeader);
 
       ZipInputStream zipInputStream = new ZipInputStream(splitInputStream, password);
@@ -50,4 +51,16 @@ public class UnzipUtil {
     }
   }
 
+  public static SplitInputStream createSplitInputStream(ZipModel zipModel) throws IOException {
+    File zipFile = zipModel.getZipFile();
+
+    if (zipFile.getName().endsWith(InternalZipConstants.SEVEN_ZIP_SPLIT_FILE_EXTENSION_PATTERN)) {
+      return new NumberedSplitInputStream(zipModel.getZipFile(), true,
+          zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
+    }
+
+    return new ZipStandardSplitInputStream(zipModel.getZipFile(), zipModel.isSplitArchive(),
+        zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
+  }
+
 }
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 7f1be7f..0fa39e6 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -18,11 +18,14 @@ import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.file.Files;
+import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
 
+import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
+import static net.lingala.zip4j.testutils.ZipFileVerifier.verifyZipFileByExtractingAllFiles;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
 
@@ -141,20 +144,20 @@ public class ExtractZipFileIT extends AbstractIT {
 
     File[] outputFiles = outputFolder.listFiles();
     assertThat(outputFiles).hasSize(1);
-    ZipFileVerifier.verifyFileContent(TestUtils.getTestFileFromResources("sample_text_large.txt"), outputFiles[0]);
+    ZipFileVerifier.verifyFileContent(getTestFileFromResources("sample_text_large.txt"), outputFiles[0]);
   }
 
   @Test
   public void testExtractFileWithFileHeaderWithAes128AndInDirectory() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
-    zipFile.addFolder(TestUtils.getTestFileFromResources(""), zipParameters);
+    zipFile.addFolder(getTestFileFromResources(""), zipParameters);
 
     FileHeader fileHeader = zipFile.getFileHeader("test-files/öüäöäö/asöäööl");
     zipFile.extractFile(fileHeader, outputFolder.getPath());
 
     File outputFile = getFileWithNameFrom(outputFolder, "asöäööl");
-    ZipFileVerifier.verifyFileContent(TestUtils.getTestFileFromResources("öüäöäö/asöäööl"), outputFile);
+    ZipFileVerifier.verifyFileContent(getTestFileFromResources("öüäöäö/asöäööl"), outputFile);
   }
 
   @Test
@@ -168,7 +171,7 @@ public class ExtractZipFileIT extends AbstractIT {
     zipFile.extractFile(fileHeader, outputFolder.getPath(), newFileName);
 
     File outputFile = getFileWithNameFrom(outputFolder, newFileName);
-    ZipFileVerifier.verifyFileContent(TestUtils.getTestFileFromResources("sample_text_large.txt"), outputFile);
+    ZipFileVerifier.verifyFileContent(getTestFileFromResources("sample_text_large.txt"), outputFile);
   }
 
   @Test
@@ -186,25 +189,25 @@ public class ExtractZipFileIT extends AbstractIT {
   public void testExtractFileWithFileNameWithZipStandardEncryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
-    zipFile.addFolder(TestUtils.getTestFileFromResources(""), zipParameters);
+    zipFile.addFolder(getTestFileFromResources(""), zipParameters);
 
     zipFile.extractFile("test-files/sample_directory/favicon.ico", outputFolder.getPath());
 
     File outputFile = getFileWithNameFrom(outputFolder, "favicon.ico");
-    ZipFileVerifier.verifyFileContent(TestUtils.getTestFileFromResources("sample_directory/favicon.ico"), outputFile);
+    ZipFileVerifier.verifyFileContent(getTestFileFromResources("sample_directory/favicon.ico"), outputFile);
   }
 
   @Test
   public void testExtractFileWithFileNameWithZipStandardEncryptionAndNewFileName() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
-    zipFile.addFolder(TestUtils.getTestFileFromResources(""), zipParameters);
+    zipFile.addFolder(getTestFileFromResources(""), zipParameters);
 
     String newFileName = "newFileName";
     zipFile.extractFile("test-files/sample_directory/favicon.ico", outputFolder.getPath(), newFileName);
 
     File outputFile = getFileWithNameFrom(outputFolder, newFileName);
-    ZipFileVerifier.verifyFileContent(TestUtils.getTestFileFromResources("sample_directory/favicon.ico"), outputFile);
+    ZipFileVerifier.verifyFileContent(getTestFileFromResources("sample_directory/favicon.ico"), outputFile);
   }
 
   @Test
@@ -259,7 +262,7 @@ public class ExtractZipFileIT extends AbstractIT {
   @Test
   public void testExtractFilesForAZipMadeWithZip4jv1AndStoreCompressionWithAES() throws IOException {
     File zipArchiveToTest = getTestArchiveFromResources("store_compression_made_with_v1.3.3.zip");
-    ZipFileVerifier.verifyZipFileByExtractingAllFiles(zipArchiveToTest, "aaaaaaaa".toCharArray(), outputFolder, 5,
+    verifyZipFileByExtractingAllFiles(zipArchiveToTest, "aaaaaaaa".toCharArray(), outputFolder, 5,
         false);
   }
 
@@ -383,6 +386,22 @@ public class ExtractZipFileIT extends AbstractIT {
     assertThat(outputFolder.listFiles()).isEmpty();
   }
 
+  @Test
+  public void testExtractZipFileOf7ZipFormatSplitWithoutEncryption() throws IOException {
+    List<File> filesToAddToZip = new ArrayList<>(FILES_TO_ADD);
+    filesToAddToZip.add(getTestFileFromResources("file_PDF_1MB.pdf"));
+    File firstSplitFile = createZipFileAndSplit(filesToAddToZip, 102400, false, null);
+    verifyZipFileByExtractingAllFiles(firstSplitFile, outputFolder, 4);
+  }
+
+  @Test
+  public void testExtractZipFileOf7ZipFormatSplitWithAESEncryption() throws IOException {
+    List<File> filesToAddToZip = new ArrayList<>(FILES_TO_ADD);
+    filesToAddToZip.add(getTestFileFromResources("file_PDF_1MB.pdf"));
+    File firstSplitFile = createZipFileAndSplit(filesToAddToZip, 102000, true, EncryptionMethod.AES);
+    verifyZipFileByExtractingAllFiles(firstSplitFile, PASSWORD, outputFolder, 4);
+  }
+
   private void testExtractNestedZipFileWithEncrpytion(EncryptionMethod innerZipEncryption,
                                                        EncryptionMethod outerZipEncryption) throws IOException {
     File innerZipFile = temporaryFolder.newFile("inner.zip");
@@ -446,4 +465,14 @@ public class ExtractZipFileIT extends AbstractIT {
     return file.get();
   }
 
+  private File createZipFileAndSplit(List<File> filesToAddToZip, long splitLength, boolean encrypt, EncryptionMethod encryptionMethod) throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setEncryptFiles(encrypt);
+    zipParameters.setEncryptionMethod(encryptionMethod);
+    zipFile.addFiles(filesToAddToZip, zipParameters);
+
+    return TestUtils.splitFileWith7ZipFormat(zipFile.getFile(), temporaryFolder.getRoot(), splitLength);
+  }
+
 }
diff --git a/src/test/java/net/lingala/zip4j/io/inputstream/NumberedSplitRandomAccessFileIT.java b/src/test/java/net/lingala/zip4j/io/inputstream/NumberedSplitRandomAccessFileIT.java
new file mode 100644
index 0000000..93b5e40
--- /dev/null
+++ b/src/test/java/net/lingala/zip4j/io/inputstream/NumberedSplitRandomAccessFileIT.java
@@ -0,0 +1,148 @@
+package net.lingala.zip4j.io.inputstream;
+
+import net.lingala.zip4j.AbstractIT;
+import net.lingala.zip4j.model.enums.RandomAccessFileMode;
+import net.lingala.zip4j.testutils.TestUtils;
+import net.lingala.zip4j.util.CrcUtil;
+import net.lingala.zip4j.util.InternalZipConstants;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.util.zip.CRC32;
+
+import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class NumberedSplitRandomAccessFileIT extends AbstractIT {
+
+  private static final int ONE_HUNDRED_KB = 102400;
+
+  @Rule
+  public ExpectedException expectedException = ExpectedException.none();
+
+  @Test
+  public void testOpenInWriteModeThrowsException() throws IOException {
+    expectedException.expect(IllegalArgumentException.class);
+    expectedException.expectMessage("write mode is not allowed for NumberedSplitRandomAccessFile");
+
+    new NumberedSplitRandomAccessFile(getTestFileFromResources("sample.pdf"), RandomAccessFileMode.WRITE.getValue());
+  }
+
+  @Test
+  public void testWriteIntThrowsUnsupportedOperationException() throws IOException {
+    expectedException.expect(UnsupportedOperationException.class);
+
+    String fileName = "somefile.001";
+    File splitFile = temporaryFolder.newFile(fileName);
+    NumberedSplitRandomAccessFile numberedSplitRandomAccessFile = new NumberedSplitRandomAccessFile(
+        splitFile, RandomAccessFileMode.READ.getValue());
+    numberedSplitRandomAccessFile.write(1);
+  }
+
+  @Test
+  public void testWriteByteArrayThrowsUnsupportedOperationException() throws IOException {
+    expectedException.expect(UnsupportedOperationException.class);
+
+    String fileName = "somefile.001";
+    File splitFile = temporaryFolder.newFile(fileName);
+    NumberedSplitRandomAccessFile numberedSplitRandomAccessFile = new NumberedSplitRandomAccessFile(
+        splitFile, RandomAccessFileMode.READ.getValue());
+    numberedSplitRandomAccessFile.write(new byte[100]);
+  }
+
+  @Test
+  public void testWriteByteArrayWithLengthThrowsUnsupportedOperationException() throws IOException {
+    expectedException.expect(UnsupportedOperationException.class);
+
+    String fileName = "somefile.001";
+    File splitFile = temporaryFolder.newFile(fileName);
+    NumberedSplitRandomAccessFile numberedSplitRandomAccessFile = new NumberedSplitRandomAccessFile(
+        splitFile, RandomAccessFileMode.READ.getValue());
+    numberedSplitRandomAccessFile.write(new byte[100], 0, 10);
+  }
+
+  @Test
+  public void testReadIntReadsCompleteFileSuccessfully() throws IOException {
+    File fileToSplit = getTestFileFromResources("file_PDF_1MB.pdf");
+    long sourceFileCrc = CrcUtil.computeFileCrc(fileToSplit, null);
+    File firstSplitFile = TestUtils.splitFileWith7ZipFormat(fileToSplit, temporaryFolder.getRoot(), InternalZipConstants.MIN_SPLIT_LENGTH);
+
+    CRC32 crc32 = new CRC32();
+    int readVal;
+
+    try(NumberedSplitRandomAccessFile randomAccessFile = openSplitFile(firstSplitFile)) {
+      while ((readVal = randomAccessFile.read()) != -1) {
+        crc32.update(readVal);
+      }
+    }
+
+    assertThat(crc32.getValue()).isEqualTo(sourceFileCrc);
+  }
+
+  @Test
+  public void testReadByteArrayReadsCompleteFileSuccessfully() throws IOException {
+    File fileToSplit = getTestFileFromResources("file_PDF_1MB.pdf");
+    long sourceFileCrc = CrcUtil.computeFileCrc(fileToSplit, null);
+    File firstSplitFile = TestUtils.splitFileWith7ZipFormat(fileToSplit, temporaryFolder.getRoot(), ONE_HUNDRED_KB);
+
+    CRC32 crc32 = new CRC32();
+    byte[] buff = new byte[InternalZipConstants.BUFF_SIZE];
+    int readLen;
+
+    try(NumberedSplitRandomAccessFile randomAccessFile = openSplitFile(firstSplitFile)) {
+      while ((readLen = randomAccessFile.read(buff)) != -1) {
+        crc32.update(buff, 0, readLen);
+      }
+    }
+
+    assertThat(crc32.getValue()).isEqualTo(sourceFileCrc);
+  }
+
+  @Test
+  public void testReadByteArrayWithLengthReadsCompleteFileSuccessfully() throws IOException {
+    File fileToSplit = getTestFileFromResources("file_PDF_1MB.pdf");
+    long sourceFileCrc = CrcUtil.computeFileCrc(fileToSplit, null);
+    File firstSplitFile = TestUtils.splitFileWith7ZipFormat(fileToSplit, temporaryFolder.getRoot(), ONE_HUNDRED_KB - 100);
+
+    CRC32 crc32 = new CRC32();
+    byte[] buff = new byte[InternalZipConstants.BUFF_SIZE];
+    int readLen;
+
+    try(NumberedSplitRandomAccessFile randomAccessFile = openSplitFile(firstSplitFile)) {
+      while ((readLen = randomAccessFile.read(buff, 0, 100)) != -1) {
+        crc32.update(buff, 0, readLen);
+      }
+    }
+
+    assertThat(crc32.getValue()).isEqualTo(sourceFileCrc);
+  }
+
+  @Test
+  public void testSeek() throws IOException {
+    File fileToSplit = getTestFileFromResources("file_PDF_1MB.pdf");
+    File firstSplitFile = TestUtils.splitFileWith7ZipFormat(fileToSplit, temporaryFolder.getRoot(), ONE_HUNDRED_KB);
+
+    try(NumberedSplitRandomAccessFile splitRandomAccessFile = openSplitFile(firstSplitFile);
+        RandomAccessFile sourceRandomAccessFile = new RandomAccessFile(fileToSplit, RandomAccessFileMode.READ.getValue())) {
+
+      splitRandomAccessFile.seek(fileToSplit.length() - 200);
+      sourceRandomAccessFile.seek(fileToSplit.length() - 200);
+
+      byte[] sourceBytes = new byte[200];
+      byte[] splitFileBytes = new byte[200];
+
+      sourceRandomAccessFile.read(sourceBytes);
+      splitRandomAccessFile.read(splitFileBytes);
+
+      assertThat(splitFileBytes).isEqualTo(sourceBytes);
+    }
+  }
+
+  private NumberedSplitRandomAccessFile openSplitFile(File firstSplitFile) throws IOException {
+    return new NumberedSplitRandomAccessFile(firstSplitFile, RandomAccessFileMode.READ.getValue());
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/net/lingala/zip4j/testutils/TestUtils.java b/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
index eec475b..4d48203 100644
--- a/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
+++ b/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
@@ -1,8 +1,14 @@
 package net.lingala.zip4j.testutils;
 
+import net.lingala.zip4j.util.FileUtils;
 import net.lingala.zip4j.util.InternalZipConstants;
 
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
 
@@ -24,6 +30,58 @@ public class TestUtils {
     return (os.contains("win"));
   }
 
+  /**
+   * Splits files with extension .001, .002, etc
+   * @param fileToSplit file to be split
+   * @param splitLength the length of each split file
+   * @return File - first split file
+   * @throws IOException if any exception occurs dealing with streams
+   */
+  public static File splitFileWith7ZipFormat(File fileToSplit, File outputFolder, long splitLength) throws IOException {
+    if (splitLength < InternalZipConstants.MIN_SPLIT_LENGTH) {
+      throw new IllegalArgumentException("split length less than minimum allowed split length of " + InternalZipConstants.MIN_SPLIT_LENGTH);
+    }
+
+    int splitCounter = 0;
+    byte[] buff = new byte[InternalZipConstants.BUFF_SIZE];
+    int readLen = 0;
+    long numberOfBytesWrittenInThisPart = 0;
+
+    try (InputStream inputStream = new FileInputStream(fileToSplit)) {
+      OutputStream outputStream = startNext7ZipSplitStream(fileToSplit, outputFolder, splitCounter);
+      splitCounter++;
+
+      while ((readLen = inputStream.read(buff)) != -1) {
+        if (numberOfBytesWrittenInThisPart + readLen > splitLength) {
+          int numberOfBytesToWriteInThisCounter = (int) (splitLength - numberOfBytesWrittenInThisPart);
+          outputStream.write(buff, 0, numberOfBytesToWriteInThisCounter);
+          outputStream.close();
+          outputStream = startNext7ZipSplitStream(fileToSplit, outputFolder, splitCounter);
+          splitCounter++;
+          outputStream.write(buff, numberOfBytesToWriteInThisCounter, readLen - numberOfBytesToWriteInThisCounter);
+          numberOfBytesWrittenInThisPart = readLen - numberOfBytesToWriteInThisCounter;
+        } else {
+          outputStream.write(buff, 0, readLen);
+          numberOfBytesWrittenInThisPart += readLen;
+        }
+      }
+
+      outputStream.close();
+    }
+
+    return getFileNameFor7ZipSplitIndex(fileToSplit, outputFolder, 0);
+  }
+
+  private static OutputStream startNext7ZipSplitStream(File sourceFile, File outputFolder, int index) throws IOException {
+    File outputFile = getFileNameFor7ZipSplitIndex(sourceFile, outputFolder, index);
+    return new FileOutputStream(outputFile);
+  }
+
+  private static File getFileNameFor7ZipSplitIndex(File sourceFile, File outputFolder, int index) throws IOException {
+    return new File(outputFolder.getCanonicalPath() + File.separator + sourceFile.getName()
+        + FileUtils.getNextNumberedSplitFileCounterAsExtension(index));
+  }
+
   private static File getFileFromResources(String parentFolder, String fileName) {
     try {
       String path = "/" + parentFolder + "/" + fileName;
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
index 4e314d3..939962a 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
@@ -25,22 +25,22 @@ public class FileUtilsIT extends AbstractIT {
   private ProgressMonitor progressMonitor = new ProgressMonitor();
 
   @Test
-  public void testCopyFileThrowsExceptionWhenStartsIsLessThanZero() throws IOException, ZipException {
+  public void testCopyFileThrowsExceptionWhenStartsIsLessThanZero() throws IOException {
     testInvalidOffsetsScenario(-1, 100);
   }
 
   @Test
-  public void testCopyFileThrowsExceptionWhenEndIsLessThanZero() throws IOException, ZipException {
+  public void testCopyFileThrowsExceptionWhenEndIsLessThanZero() throws IOException {
     testInvalidOffsetsScenario(0, -1);
   }
 
   @Test
-  public void testCopyFileThrowsExceptionWhenStartIsGreaterThanEnd() throws IOException, ZipException {
+  public void testCopyFileThrowsExceptionWhenStartIsGreaterThanEnd() throws IOException {
     testInvalidOffsetsScenario(300, 100);
   }
 
   @Test
-  public void testCopyFilesWhenStartIsSameAsEndDoesNothing() throws IOException, ZipException {
+  public void testCopyFilesWhenStartIsSameAsEndDoesNothing() throws IOException {
     File sourceFile = TestUtils.getTestFileFromResources("sample.pdf");
     File outputFile = temporaryFolder.newFile();
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
@@ -53,7 +53,7 @@ public class FileUtilsIT extends AbstractIT {
   }
 
   @Test
-  public void testCopyFilesCopiesCompleteFile() throws IOException, ZipException {
+  public void testCopyFilesCopiesCompleteFile() throws IOException {
     File sourceFile = TestUtils.getTestFileFromResources("sample.pdf");
     File outputFile = temporaryFolder.newFile();
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
@@ -65,7 +65,7 @@ public class FileUtilsIT extends AbstractIT {
   }
 
   @Test
-  public void testCopyFilesCopiesPartOfFile() throws IOException, ZipException {
+  public void testCopyFilesCopiesPartOfFile() throws IOException {
     File sourceFile = TestUtils.getTestFileFromResources("sample.pdf");
     File outputFile = temporaryFolder.newFile();
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
@@ -76,7 +76,27 @@ public class FileUtilsIT extends AbstractIT {
     assertThat(outputFile.length()).isEqualTo(300);
   }
 
-  private void testInvalidOffsetsScenario(int start, int offset) throws IOException, ZipException {
+  @Test
+  public void testGetAllSortedNumberedSplitFilesReturnsEmptyForNoFiles() throws IOException {
+    File file = temporaryFolder.newFile("somename");
+    assertThat(FileUtils.getAllSortedNumberedSplitFiles(file)).isEmpty();
+  }
+
+  @Test
+  public void testGetAllSortedNumberedSplitFilesReturnsSortedList() throws IOException {
+    File file001 = temporaryFolder.newFile("somename.zip.001");
+    File file003 = temporaryFolder.newFile("somename.zip.003");
+    File file002 = temporaryFolder.newFile("somename.zip.002");
+    File file006 = temporaryFolder.newFile("somename.zip.006");
+    File file005 = temporaryFolder.newFile("somename.zip.005");
+    File file004 = temporaryFolder.newFile("somename.zip.004");
+
+    File[] sortedList = FileUtils.getAllSortedNumberedSplitFiles(file001);
+
+    assertThat(sortedList).containsExactly(file001, file002, file003, file004, file005, file006);
+  }
+
+  private void testInvalidOffsetsScenario(int start, int offset) throws IOException {
     expectedException.expectMessage("invalid offsets");
     expectedException.expect(ZipException.class);
 
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java b/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
index 1399e39..fdabbc6 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
@@ -141,6 +141,24 @@ public class FileUtilsTest {
     testGetFilesInDirectory(true, true, filesInDirectory, 3, false, false);
   }
 
+  @Test
+  public void testGetFileNameWithoutExtensionWithoutExtensionReturnsSameName() throws ZipException {
+    String fileNameWithoutExtension = FileUtils.getFileNameWithoutExtension("somename");
+    assertThat(fileNameWithoutExtension).isEqualTo("somename");
+  }
+
+  @Test
+  public void testGetFileNameWithoutExtensionReturnsJustTheName() throws ZipException {
+    String fileNameWithoutExtension = FileUtils.getFileNameWithoutExtension("somename.pdf");
+    assertThat(fileNameWithoutExtension).isEqualTo("somename");
+  }
+
+  @Test
+  public void testGetFileNameWithoutExtensionWithTwoExtensions() throws ZipException {
+    String fileNameWithoutExtension = FileUtils.getFileNameWithoutExtension("somename.pdf.001");
+    assertThat(fileNameWithoutExtension).isEqualTo("somename.pdf");
+  }
+
   @Test
   public void testGetZipFileNameWithoutExtensionThrowsExceptionWhenNull() throws ZipException {
     expectedException.expectMessage("zip file name is empty or null, cannot determine zip file name");
@@ -320,6 +338,51 @@ public class FileUtilsTest {
     assertThat(FileUtils.isZipEntryDirectory("somename")).isFalse();
   }
 
+  @Test
+  public void testIsNumberedSplitFileForInvalidReturnsFalse() {
+    assertThat(FileUtils.isNumberedSplitFile(new File("somename.xyz"))).isFalse();
+  }
+
+  @Test
+  public void testIsNumberedSplitFileForValidSpltiFileReturnsTrue() {
+    assertThat(FileUtils.isNumberedSplitFile(new File("somename.xyz.001"))).isFalse();
+  }
+
+  @Test
+  public void testGetFileExtensionWithoutExtensionReturnsEmptyString() {
+    assertThat(FileUtils.getFileExtension(new File("somename"))).isEqualTo("");
+  }
+
+  @Test
+  public void testGetFileExtensionReturnsExtension() {
+    assertThat(FileUtils.getFileExtension(new File("somename.pdf"))).isEqualTo("pdf");
+  }
+
+  @Test
+  public void testGetFileExtensionWithDoubleExtensionReturnsLastExtension() {
+    assertThat(FileUtils.getFileExtension(new File("somename.pdf.001"))).isEqualTo("001");
+  }
+
+  @Test
+  public void testGetNextNumberedSplitFileCounterAsExtensionSingleDigit() {
+    assertThat(FileUtils.getNextNumberedSplitFileCounterAsExtension(8)).isEqualTo(".009");
+  }
+
+  @Test
+  public void testGetNextNumberedSplitFileCounterAsExtensionSkipsToDoubleDigit() {
+    assertThat(FileUtils.getNextNumberedSplitFileCounterAsExtension(9)).isEqualTo(".010");
+  }
+
+  @Test
+  public void testGetNextNumberedSplitFileCounterAsExtensionDoubleDigit() {
+    assertThat(FileUtils.getNextNumberedSplitFileCounterAsExtension(99)).isEqualTo(".100");
+  }
+
+  @Test
+  public void testGetNextNumberedSplitFileCounterAsExtensionThreeDigit() {
+    assertThat(FileUtils.getNextNumberedSplitFileCounterAsExtension(100)).isEqualTo(".101");
+  }
+
   private File mockZipFileAsExists(String path, String zipFileNameWithoutExtension) {
     File file = mock(File.class);
     when(file.exists()).thenReturn(true);
diff --git a/src/test/java/net/lingala/zip4j/util/UnzipUtilIT.java b/src/test/java/net/lingala/zip4j/util/UnzipUtilIT.java
index 0968686..7faadc1 100644
--- a/src/test/java/net/lingala/zip4j/util/UnzipUtilIT.java
+++ b/src/test/java/net/lingala/zip4j/util/UnzipUtilIT.java
@@ -3,6 +3,9 @@ package net.lingala.zip4j.util;
 import net.lingala.zip4j.AbstractIT;
 import net.lingala.zip4j.ZipFile;
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.io.inputstream.NumberedSplitInputStream;
+import net.lingala.zip4j.io.inputstream.SplitInputStream;
+import net.lingala.zip4j.io.inputstream.ZipStandardSplitInputStream;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.testutils.TestUtils;
@@ -99,6 +102,28 @@ public class UnzipUtilIT extends AbstractIT {
     FileUtils.setFileLastModifiedTimeWithoutNio(file, currentTime);
   }
 
+  @Test
+  public void testCreateSplitInputStreamForNumberedSplitZipReturnsInstance() throws IOException {
+    String zipFileName = "somename.zip.001";
+    File zipFile = temporaryFolder.newFile(zipFileName);
+    ZipModel zipModel = createZipModel();
+    zipModel.setZipFile(zipFile);
+
+    SplitInputStream splitInputStream = UnzipUtil.createSplitInputStream(zipModel);
+
+    assertThat(splitInputStream).isInstanceOf(NumberedSplitInputStream.class);
+  }
+
+  @Test
+  public void testCreateSplitInputStreamForNonNumberedSplitZipReturnsInstance() throws IOException {
+    temporaryFolder.newFile(generatedZipFile.getName());
+    ZipModel zipModel = createZipModel();
+
+    SplitInputStream splitInputStream = UnzipUtil.createSplitInputStream(zipModel);
+
+    assertThat(splitInputStream).isInstanceOf(ZipStandardSplitInputStream.class);
+  }
+
   private ZipFile createZipFile() throws ZipException {
     ZipFile zipFile = new ZipFile(generatedZipFile, "password".toCharArray());
     zipFile.addFiles(Arrays.asList(
