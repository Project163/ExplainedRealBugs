diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index cba2852..058365f 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -50,6 +50,8 @@ public class ZipInputStream extends InputStream {
   private byte[] endOfEntryBuffer;
   private boolean canSkipExtendedLocalFileHeader = false;
   private Zip4jConfig zip4jConfig;
+  private boolean streamClosed = false;
+  private boolean entryEOFReached = false;
 
   public ZipInputStream(InputStream inputStream) {
     this(inputStream, null, (Charset) null);
@@ -109,6 +111,7 @@ public class ZipInputStream extends InputStream {
     }
 
     this.decompressedInputStream = initializeEntryInputStream(localFileHeader);
+    this.entryEOFReached = false;
     return localFileHeader;
   }
 
@@ -169,6 +172,13 @@ public class ZipInputStream extends InputStream {
     if (decompressedInputStream != null) {
       decompressedInputStream.close();
     }
+    this.streamClosed = true;
+  }
+
+  @Override
+  public int available() throws IOException {
+    assertStreamOpen();
+    return entryEOFReached ? 0 : 1;
   }
 
   private void endOfCompressedDataReached() throws IOException {
@@ -182,6 +192,7 @@ public class ZipInputStream extends InputStream {
     readExtendedLocalFileHeaderIfPresent();
     verifyCrc();
     resetFields();
+    this.entryEOFReached = true;
   }
 
   private DecompressedInputStream initializeEntryInputStream(LocalFileHeader localFileHeader) throws IOException {
@@ -318,9 +329,16 @@ public class ZipInputStream extends InputStream {
     }
 
     while (read(endOfEntryBuffer) != -1);
+    this.entryEOFReached = true;
   }
 
   private boolean isEncryptionMethodZipStandard(LocalFileHeader localFileHeader) {
     return localFileHeader.isEncrypted() && EncryptionMethod.ZIP_STANDARD.equals(localFileHeader.getEncryptionMethod());
   }
+
+  private void assertStreamOpen() throws IOException {
+    if (streamClosed) {
+      throw new IOException("Stream closed");
+    }
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
index 96a1734..1d6a92e 100644
--- a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
@@ -177,39 +177,41 @@ public class ZipInputStreamIT extends AbstractIT {
   @Test
   public void testExtractFilesForZipFileWithInvalidExtraDataRecordIgnoresIt() throws IOException {
     InputStream inputStream = new FileInputStream(getTestArchiveFromResources("invalid_extra_data_record.zip"));
-    ZipInputStream zipInputStream = new ZipInputStream(inputStream, "password".toCharArray());
-    byte[] b = new byte[4096];
-    while (zipInputStream.getNextEntry() != null) {
-      while (zipInputStream.read(b) != -1) {
+    try (ZipInputStream zipInputStream = new ZipInputStream(inputStream, "password".toCharArray())) {
+      byte[] b = new byte[4096];
+      while (zipInputStream.getNextEntry() != null) {
+        while (zipInputStream.read(b) != -1) {
 
+        }
       }
     }
-    zipInputStream.close();
   }
 
   @Test
   public void testGetNextEntryReturnsNextEntryEvenIfEntryNotCompletelyRead() throws IOException {
     File createZipFile = createZipFile(CompressionMethod.DEFLATE);
-    ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(createZipFile));
-    int numberOfEntries = 0;
-    while (zipInputStream.getNextEntry() != null) {
-      numberOfEntries++;
+    try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(createZipFile))) {
+      int numberOfEntries = 0;
+      while (zipInputStream.getNextEntry() != null) {
+        numberOfEntries++;
+      }
+      assertThat(numberOfEntries).isEqualTo(FILES_TO_ADD.size());
     }
-    assertThat(numberOfEntries).isEqualTo(FILES_TO_ADD.size());
   }
 
   @Test
   public void testGetFileNamesWithChineseCharset() throws IOException {
     InputStream inputStream = new FileInputStream(getTestArchiveFromResources("testfile_with_chinese_filename_by_7zip.zip"));
-    ZipInputStream zipInputStream = new ZipInputStream(inputStream, CHARSET_GBK);
-    LocalFileHeader localFileHeader;
-    String expactedFileName = "fff - 副本.txt";
-    Set<String> filenameSet = new HashSet<>();
+    try (ZipInputStream zipInputStream = new ZipInputStream(inputStream, CHARSET_GBK)) {
+      LocalFileHeader localFileHeader;
+      String expactedFileName = "fff - 副本.txt";
+      Set<String> filenameSet = new HashSet<>();
 
-    while ((localFileHeader = zipInputStream.getNextEntry()) != null) {
-      filenameSet.add(localFileHeader.getFileName());
+      while ((localFileHeader = zipInputStream.getNextEntry()) != null) {
+        filenameSet.add(localFileHeader.getFileName());
+      }
+      assertThat(filenameSet.contains(expactedFileName)).isTrue();
     }
-    assertThat(filenameSet.contains(expactedFileName)).isTrue();
   }
 
   @Test
@@ -254,6 +256,32 @@ public class ZipInputStreamIT extends AbstractIT {
     assertThat(totalNumberOfEntriesRead).isEqualTo(6);
   }
 
+  @Test
+  public void testAvailableThrowsExceptionWhenStreamClosed() throws IOException {
+    expectedException.expect(IOException.class);
+    expectedException.expectMessage("Stream closed");
+
+    File createZipFile = createZipFile(CompressionMethod.DEFLATE);
+    ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(createZipFile));
+    zipInputStream.close();
+
+    zipInputStream.available();
+  }
+
+  @Test
+  public void testAvailableReturns1WhenEntryEOFNotReachedAnd0AfterEOFReached() throws IOException {
+    byte[] b = new byte[InternalZipConstants.BUFF_SIZE];
+    File createZipFile = createZipFile(CompressionMethod.DEFLATE);
+    try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(createZipFile))) {
+      while (zipInputStream.getNextEntry() != null) {
+        while (zipInputStream.read(b) != -1) {
+          assertThat(zipInputStream.available()).isEqualTo(1);
+        }
+        assertThat(zipInputStream.available()).isEqualTo(0);
+      }
+    }
+  }
+
   private void extractZipFileWithInputStreams(File zipFile, char[] password) throws IOException {
     extractZipFileWithInputStreams(zipFile, password, 4096, AesVersion.TWO);
   }
@@ -354,4 +382,4 @@ public class ZipInputStreamIT extends AbstractIT {
     }
     return generatedZipFile;
   }
-}
\ No newline at end of file
+}
