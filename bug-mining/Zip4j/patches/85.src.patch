diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index a2c1c28..ca3305e 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -453,9 +453,7 @@ public class ZipFile {
    * Extracts a specific file from the zip file to the destination path.
    * If destination path is invalid, then this method throws an exception.
    * <br><br>
-   * If newFileName is not null or empty, newly created file name will be replaced by
-   * the value in newFileName. If this value is null, then the file name will be the
-   * value in FileHeader.getFileName
+   * If fileHeader is a directory, this method extracts all files under this directory
    *
    * @param fileHeader
    * @param destinationPath
@@ -468,6 +466,13 @@ public class ZipFile {
   /**
    * Extracts a specific file from the zip file to the destination path.
    * If destination path is invalid, then this method throws an exception.
+   * <br><br>
+   * If newFileName is not null or empty, newly created file name will be replaced by
+   * the value in newFileName. If this value is null, then the file name will be the
+   * value in FileHeader.getFileName. newFileName is ignored if fileHeader is a directory.
+   * <br><br>
+   * If fileHeader is a directory, this method extracts all files under this directory.
+   * In this case, newFileName is ignored.
    *
    * @param fileHeader
    * @param destinationPath
@@ -502,6 +507,8 @@ public class ZipFile {
    * example is if there is a file "b.txt" in a folder "abc" in the zip file, then the
    * input file name has to be abc/b.txt
    * <br><br>
+   * If fileHeader is a directory, this method extracts all files under this directory.
+   * <br><br>
    * Throws an exception of type {@link ZipException.Type#FILE_NOT_FOUND} if file header could not be found for the given file name.
    * Throws an exception if the destination path is invalid.
    *
@@ -524,7 +531,10 @@ public class ZipFile {
    * <br><br>
    * If newFileName is not null or empty, newly created file name will be replaced by
    * the value in newFileName. If this value is null, then the file name will be the
-   * value in FileHeader.getFileName
+   * value in FileHeader.getFileName. newFileName is ignored if fileName is a directory.
+   * <br><br>
+   * If fileHeader is a directory, this method extracts all files under this directory.
+   * In this case, newFileName is ignored.
    * <br><br>
    * Throws an exception of type {@link ZipException.Type#FILE_NOT_FOUND} if file header could not be found for the given file name.
    * Throws an exception if the destination path is invalid.
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
index 9ab9eae..0f7fbec 100644
--- a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
@@ -7,7 +7,9 @@ import net.lingala.zip4j.util.InternalZipConstants;
 
 import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
+import java.util.Collections;
 import java.util.List;
+import java.util.stream.Collectors;
 
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP_STANDARD_CHARSET;
 import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;
@@ -91,6 +93,27 @@ public class HeaderUtil {
     }
   }
 
+  public static List<FileHeader> getFileHeadersUnderDirectory(List<FileHeader> allFileHeaders, FileHeader rootFileHeader) {
+    if (!rootFileHeader.isDirectory()) {
+      return Collections.emptyList();
+    }
+
+    return allFileHeaders.stream().filter(e -> e.getFileName().startsWith(rootFileHeader.getFileName())).collect(Collectors.toList());
+  }
+
+  public static long getTotalUncompressedSizeOfAllFileHeaders(List<FileHeader> fileHeaders) {
+    long totalUncompressedSize = 0;
+    for (FileHeader fileHeader : fileHeaders) {
+      if (fileHeader.getZip64ExtendedInfo() != null &&
+          fileHeader.getZip64ExtendedInfo().getUncompressedSize() > 0) {
+        totalUncompressedSize += fileHeader.getZip64ExtendedInfo().getUncompressedSize();
+      } else {
+        totalUncompressedSize += fileHeader.getUncompressedSize();
+      }
+    }
+    return totalUncompressedSize;
+  }
+
   private static long getOffsetOfEndOfCentralDirectory(ZipModel zipModel) {
     if (zipModel.isZip64Format()) {
       return zipModel.getZip64EndOfCentralDirectoryRecord().getOffsetStartCentralDirectoryWRTStartDiskNumber();
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
index d81506b..4c3b6b7 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
@@ -11,6 +11,8 @@ import net.lingala.zip4j.util.UnzipUtil;
 import java.io.IOException;
 import java.nio.charset.Charset;
 
+import static net.lingala.zip4j.headers.HeaderUtil.getTotalUncompressedSizeOfAllFileHeaders;
+
 public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFilesTaskParameters> {
 
   private char[] password;
@@ -45,18 +47,7 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
 
   @Override
   protected long calculateTotalWork(ExtractAllFilesTaskParameters taskParameters) {
-    long totalWork = 0;
-
-    for (FileHeader fileHeader : getZipModel().getCentralDirectory().getFileHeaders()) {
-      if (fileHeader.getZip64ExtendedInfo() != null &&
-          fileHeader.getZip64ExtendedInfo().getUncompressedSize() > 0) {
-        totalWork += fileHeader.getZip64ExtendedInfo().getUncompressedSize();
-      } else {
-        totalWork += fileHeader.getUncompressedSize();
-      }
-    }
-
-    return totalWork;
+    return getTotalUncompressedSizeOfAllFileHeaders(getZipModel().getCentralDirectory().getFileHeaders());
   }
 
   private ZipInputStream prepareZipInputStream(Charset charset) throws IOException {
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
index 37f9b86..306c324 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
@@ -10,6 +10,11 @@ import net.lingala.zip4j.util.UnzipUtil;
 
 import java.io.IOException;
 import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.List;
+
+import static net.lingala.zip4j.headers.HeaderUtil.getFileHeadersUnderDirectory;
+import static net.lingala.zip4j.headers.HeaderUtil.getTotalUncompressedSizeOfAllFileHeaders;
 
 public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskParameters> {
 
@@ -24,9 +29,17 @@ public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskPara
   @Override
   protected void executeTask(ExtractFileTaskParameters taskParameters, ProgressMonitor progressMonitor)
       throws IOException {
+
+    String newFileName = taskParameters.newFileName;
+    if (taskParameters.fileHeader.isDirectory()) {
+      newFileName = null;
+    }
+
     try(ZipInputStream zipInputStream = createZipInputStream(taskParameters.fileHeader, taskParameters.charset)) {
-      extractFile(zipInputStream, taskParameters.fileHeader, taskParameters.outputPath, taskParameters.newFileName,
-          progressMonitor);
+      List<FileHeader> fileHeadersUnderDirectory = getFileHeadersToExtract(taskParameters.fileHeader);
+      for (FileHeader fileHeader : fileHeadersUnderDirectory) {
+        extractFile(zipInputStream, fileHeader, taskParameters.outputPath, newFileName, progressMonitor);
+      }
     } finally {
       if (splitInputStream != null) {
         splitInputStream.close();
@@ -36,10 +49,20 @@ public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskPara
 
   @Override
   protected long calculateTotalWork(ExtractFileTaskParameters taskParameters) {
-    return taskParameters.fileHeader.getUncompressedSize();
+    List<FileHeader> fileHeadersUnderDirectory = getFileHeadersToExtract(taskParameters.fileHeader);
+    return getTotalUncompressedSizeOfAllFileHeaders(fileHeadersUnderDirectory);
+  }
+
+  private List<FileHeader> getFileHeadersToExtract(FileHeader rootFileHeader) {
+    if (!rootFileHeader.isDirectory()) {
+      return Collections.singletonList(rootFileHeader);
+    }
+
+    return getFileHeadersUnderDirectory(
+        getZipModel().getCentralDirectory().getFileHeaders(), rootFileHeader);
   }
 
-  protected ZipInputStream createZipInputStream(FileHeader fileHeader, Charset charset) throws IOException {
+  private ZipInputStream createZipInputStream(FileHeader fileHeader, Charset charset) throws IOException {
     splitInputStream = UnzipUtil.createSplitInputStream(getZipModel());
     splitInputStream.prepareExtractionForFileHeader(fileHeader);
     return new ZipInputStream(splitInputStream, password, charset);
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index bd037ac..80f4b40 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -18,6 +18,7 @@ import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -448,6 +449,19 @@ public class ExtractZipFileIT extends AbstractIT {
     assertThat(zipFile.getFileHeaders()).hasSize(19);
   }
 
+  @Test
+  public void testExtractFileHeaderExtractAllFilesIfFileHeaderIsDirectory() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setIncludeRootFolder(false);
+    zipFile.addFolder(TestUtils.getTestFileFromResources(""), zipParameters);
+
+    zipFile.extractFile(zipFile.getFileHeader("öüäöäö/"), outputFolder.getPath());
+    File outputFile = Paths.get(outputFolder.getPath(), "öüäöäö", "asöäööl").toFile();
+    assertThat(outputFile).exists();
+    ZipFileVerifier.verifyFileContent(TestUtils.getTestFileFromResources("öüäöäö/asöäööl"), outputFile);
+  }
+
   private void addFileToZip(ZipFile zipFile, String fileName, EncryptionMethod encryptionMethod, String password) throws ZipException {
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setEncryptFiles(encryptionMethod != null);
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
index 2244155..f0de9eb 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
@@ -3,6 +3,7 @@ package net.lingala.zip4j.headers;
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.CentralDirectory;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.Zip64ExtendedInfo;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.util.InternalZipConstants;
 import org.junit.Rule;
@@ -200,7 +201,7 @@ public class HeaderUtilTest {
   public void testGetIndexOfFileHeaderGetsIndexSuccessfully() throws ZipException {
     String fileNamePrefix = "FILE_NAME_";
     int numberOfEntriesToAdd = 10;
-    List<FileHeader> fileHeadersInZipModel = generateFileHeaderWithFileNames(fileNamePrefix, numberOfEntriesToAdd);
+    List<FileHeader> fileHeadersInZipModel = generateFileHeaderWithFileNamesWithEmptyAndNullFileNames(fileNamePrefix, numberOfEntriesToAdd);
     ZipModel zipModel = new ZipModel();
     zipModel.getCentralDirectory().setFileHeaders(fileHeadersInZipModel);
 
@@ -265,13 +266,60 @@ public class HeaderUtilTest {
     assertThat(HeaderUtil.decodeStringWithCharset(plainEncodedBytes, false, null)).isEqualTo(englishString);
   }
 
+  @Test
+  public void testGetFileHeadersUnderDirectoryWhenNotDirectoryReturnsEmptyList() {
+    List<FileHeader> allFileHeaders = generateFileHeaderWithFileNames("header", 5);
+    FileHeader rootFileHeader = generateFileHeader("some_name");
+    rootFileHeader.setDirectory(false);
+
+    assertThat(HeaderUtil.getFileHeadersUnderDirectory(allFileHeaders, rootFileHeader)).isEmpty();
+  }
+
+  @Test
+  public void testGetFileHeadersUnderDirectoryReturnsFileHeadersUnderDirectory() {
+    List<FileHeader> allFileHeaders = generateFileHeaderWithFileNames("some_name/header", 5);
+    allFileHeaders.add(generateFileHeader("some_name/"));
+    allFileHeaders.add(generateFileHeader("some_other_name.txt"));
+    FileHeader rootFileHeader = generateFileHeader("some_name/");
+    rootFileHeader.setDirectory(true);
+
+    List<FileHeader> filHeadersUnderDirectory = HeaderUtil.getFileHeadersUnderDirectory(allFileHeaders, rootFileHeader);
+    assertThat(filHeadersUnderDirectory).hasSize(6);
+    for (FileHeader fileHeader : filHeadersUnderDirectory) {
+      assertThat(fileHeader)
+          .withFailMessage("file header with name some_other_name.txt should not exist")
+          .isNotEqualTo("some_other_name.txt");
+    }
+  }
+
+  @Test
+  public void testGetUncompressedSizeOfAllFileHeaders() {
+    FileHeader fileHeader1 = generateFileHeader("1");
+    fileHeader1.setUncompressedSize(1000);
+    FileHeader fileHeader2 = generateFileHeader("2");
+    fileHeader2.setUncompressedSize(2000);
+    FileHeader fileHeader3 = generateFileHeader("3");
+    Zip64ExtendedInfo zip64ExtendedInfo = new Zip64ExtendedInfo();
+    zip64ExtendedInfo.setUncompressedSize(3000);
+    fileHeader3.setZip64ExtendedInfo(zip64ExtendedInfo);
+    fileHeader3.setUncompressedSize(0);
+    List<FileHeader> fileHeaders = Arrays.asList(fileHeader1, fileHeader2, fileHeader3);
+
+    assertThat(HeaderUtil.getTotalUncompressedSizeOfAllFileHeaders(fileHeaders)).isEqualTo(6000);
+  }
+
+  private List<FileHeader> generateFileHeaderWithFileNamesWithEmptyAndNullFileNames(String fileNamePrefix, int numberOfEntriesToAdd) {
+    List<FileHeader> fileHeaders = generateFileHeaderWithFileNames(fileNamePrefix, numberOfEntriesToAdd);
+    fileHeaders.add(generateFileHeader(""));
+    fileHeaders.add(generateFileHeader(null));
+    return fileHeaders;
+  }
+
   private List<FileHeader> generateFileHeaderWithFileNames(String fileNamePrefix, int numberOfEntriesToAdd) {
     List<FileHeader> fileHeaders = new ArrayList<>();
     for (int i = 0; i < numberOfEntriesToAdd; i++) {
       fileHeaders.add(generateFileHeader(fileNamePrefix + i));
     }
-    fileHeaders.add(generateFileHeader(""));
-    fileHeaders.add(generateFileHeader(null));
     return fileHeaders;
   }
 
