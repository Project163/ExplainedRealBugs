diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index 9dc083d..e2c8599 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -27,7 +27,6 @@ import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
-import net.lingala.zip4j.util.BitUtils;
 import net.lingala.zip4j.util.InternalZipConstants;
 
 import java.io.IOException;
@@ -48,8 +47,9 @@ public class ZipInputStream extends InputStream {
   private char[] password;
   private LocalFileHeader localFileHeader;
   private CRC32 crc32 = new CRC32();
-  private boolean extraDataRecordReadForThisEntry = false;
   private byte[] endOfEntryBuffer;
+  private boolean extraDataRecordReadForThisEntry = false;
+  private boolean canSkipExtendedLocalFileHeader = false;
 
   public ZipInputStream(InputStream inputStream) {
     this(inputStream, null);
@@ -82,6 +82,9 @@ public class ZipInputStream extends InputStream {
       localFileHeader.setCrc(fileHeader.getCrc());
       localFileHeader.setCompressedSize(fileHeader.getCompressedSize());
       localFileHeader.setUncompressedSize(fileHeader.getUncompressedSize());
+      canSkipExtendedLocalFileHeader = true;
+    } else {
+      canSkipExtendedLocalFileHeader = false;
     }
 
     if (!isZipEntryDirectory(localFileHeader.getFileName())) {
@@ -206,7 +209,7 @@ public class ZipInputStream extends InputStream {
   }
 
   private void readExtendedLocalFileHeaderIfPresent() throws IOException {
-    if (!isExtendedLocalFileHeaderPresent(localFileHeader)) {
+    if (!localFileHeader.isDataDescriptorExists() || canSkipExtendedLocalFileHeader) {
       return;
     }
 
@@ -217,11 +220,6 @@ public class ZipInputStream extends InputStream {
     localFileHeader.setCrc(dataDescriptor.getCrc());
   }
 
-  private boolean isExtendedLocalFileHeaderPresent(LocalFileHeader localFileHeader) {
-    byte[] generalPurposeFlags = localFileHeader.getGeneralPurposeFlag();
-    return BitUtils.isBitSet(generalPurposeFlags[0], 3);
-  }
-
   private void verifyLocalFileHeader(LocalFileHeader localFileHeader) throws IOException {
     if (!isEntryDirectory(localFileHeader.getFileName())
         && localFileHeader.getCompressionMethod() == CompressionMethod.STORE
@@ -278,7 +276,7 @@ public class ZipInputStream extends InputStream {
       return localFileHeader.getUncompressedSize();
     }
 
-    if (localFileHeader.isDataDescriptorExists()) {
+    if (localFileHeader.isDataDescriptorExists() && !canSkipExtendedLocalFileHeader) {
       return -1;
     }
 
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
index 6bb7a59..a6869b3 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
@@ -31,7 +31,6 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
         }
 
         splitInputStream.prepareExtractionForFileHeader(fileHeader);
-        splitInputStream.skip(zipInputStream.getAvailableBytesInPushBackInputStream());
 
         extractFile(zipInputStream, fileHeader, taskParameters.outputPath, null, progressMonitor);
         verifyIfTaskIsCancelled();
diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index 04c0893..78b6668 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -557,6 +557,24 @@ public class AddFilesToZipIT extends AbstractIT {
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 13);
   }
 
+  @Test
+  public void testAddFolderWithNotNormalizedPath() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters parameters = new ZipParameters();
+
+    String folderToAddPath = TestUtils.getTestFileFromResources("").getPath()
+        + InternalZipConstants.FILE_SEPARATOR + ".."
+        + InternalZipConstants.FILE_SEPARATOR
+        + TestUtils.getTestFileFromResources("").getName();
+    File folderToAdd = new File(folderToAddPath);
+    zipFile.addFolder(folderToAdd, parameters);
+
+    File fileToAdd = TestUtils.getTestFileFromResources("file_PDF_1MB.pdf");
+    zipFile.addFile(fileToAdd, parameters);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 13);
+  }
+
   @Test
   public void testAddStreamToZipThrowsExceptionWhenFileNameIsNull() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 2964641..55e20cf 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -9,7 +9,6 @@ import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.testutils.TestUtils;
 import net.lingala.zip4j.testutils.ZipFileVerifier;
 import net.lingala.zip4j.util.FileUtils;
-import net.lingala.zip4j.util.InternalZipConstants;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -282,18 +281,13 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFolderWithNotNormalizedPath() throws IOException {
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    ZipParameters parameters = new ZipParameters();
-
-    String folderToAddPath = TestUtils.getTestFileFromResources("").getPath() + InternalZipConstants.FILE_SEPARATOR + ".." + InternalZipConstants.FILE_SEPARATOR + TestUtils.getTestFileFromResources("").getName();
-    File folderToAdd = new File(folderToAddPath);
-    zipFile.addFolder(folderToAdd, parameters);
+  public void testExtractZipFileWithMissingExtendedLocalFileHeader() throws IOException {
+    ZipFile zipFile = new ZipFile(getTestArchiveFromResources("missing_exended_local_file_header.zip"));
 
-    File fileToAdd = TestUtils.getTestFileFromResources("file_PDF_1MB.pdf");
-    zipFile.addFile(fileToAdd, parameters);
+    zipFile.extractAll(outputFolder.getPath());
 
-    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 13);
+    assertThat(zipFile.getFileHeaders()).hasSize(3);
+    assertThat(Files.walk(outputFolder.toPath()).filter(Files::isRegularFile)).hasSize(3);
   }
 
   private void verifyNumberOfFilesInOutputFolder(File outputFolder, int numberOfExpectedFiles) {
diff --git a/src/test/resources/test-archives/missing_exended_local_file_header.zip b/src/test/resources/test-archives/missing_exended_local_file_header.zip
new file mode 100644
index 0000000..f2d306f
Binary files /dev/null and b/src/test/resources/test-archives/missing_exended_local_file_header.zip differ
