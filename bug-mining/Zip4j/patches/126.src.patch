diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index 1a09eb9..a4b70af 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -24,6 +24,7 @@ import net.lingala.zip4j.io.inputstream.NumberedSplitRandomAccessFile;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.UnzipParameters;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.RandomAccessFileMode;
@@ -48,6 +49,7 @@ import net.lingala.zip4j.tasks.RenameFilesTask.RenameFilesTaskParameters;
 import net.lingala.zip4j.tasks.SetCommentTask;
 import net.lingala.zip4j.tasks.SetCommentTask.SetCommentTaskTaskParameters;
 import net.lingala.zip4j.util.FileUtils;
+import net.lingala.zip4j.util.InternalZipConstants;
 import net.lingala.zip4j.util.RawIO;
 import net.lingala.zip4j.util.Zip4jUtil;
 
@@ -65,6 +67,7 @@ import java.util.concurrent.ThreadFactory;
 
 import static net.lingala.zip4j.util.FileUtils.isNumberedSplitFile;
 import static net.lingala.zip4j.util.InternalZipConstants.CHARSET_UTF_8;
+import static net.lingala.zip4j.util.InternalZipConstants.MIN_BUFF_SIZE;
 import static net.lingala.zip4j.util.UnzipUtil.createZipInputStream;
 import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;
 
@@ -92,6 +95,7 @@ public class ZipFile {
   private Charset charset = null;
   private ThreadFactory threadFactory;
   private ExecutorService executorService;
+  private int bufferSize = InternalZipConstants.BUFF_SIZE;
 
   /**
    * Creates a new ZipFile instance with the zip file at the location specified in zipFile.
@@ -175,7 +179,7 @@ public class ZipFile {
     zipModel.setSplitLength(splitLength);
 
     new AddFilesToZipTask(zipModel, password, headerWriter, buildAsyncParameters()).execute(
-        new AddFilesToZipTaskParameters(filesToAdd, parameters, charset));
+        new AddFilesToZipTaskParameters(filesToAdd, parameters, buildConfig()));
   }
 
   /**
@@ -313,7 +317,7 @@ public class ZipFile {
     }
 
     new AddFilesToZipTask(zipModel, password, headerWriter, buildAsyncParameters()).execute(
-        new AddFilesToZipTaskParameters(filesToAdd, parameters, charset));
+        new AddFilesToZipTaskParameters(filesToAdd, parameters, buildConfig()));
   }
 
   /**
@@ -385,7 +389,7 @@ public class ZipFile {
     }
 
     new AddFolderToZipTask(zipModel, password, headerWriter, buildAsyncParameters()).execute(
-        new AddFolderToZipTaskParameters(folderToAdd, zipParameters, charset));
+        new AddFolderToZipTaskParameters(folderToAdd, zipParameters, buildConfig()));
   }
 
   /**
@@ -422,7 +426,7 @@ public class ZipFile {
     }
 
     new AddStreamToZipTask(zipModel, password, headerWriter, buildAsyncParameters()).execute(
-        new AddStreamToZipTaskParameters(inputStream, parameters, charset));
+        new AddStreamToZipTaskParameters(inputStream, parameters, buildConfig()));
   }
 
   /**
@@ -468,7 +472,7 @@ public class ZipFile {
     }
 
     new ExtractAllFilesTask(zipModel, password, unzipParameters, buildAsyncParameters()).execute(
-        new ExtractAllFilesTaskParameters(destinationPath, charset));
+        new ExtractAllFilesTaskParameters(destinationPath, buildConfig()));
   }
 
   /**
@@ -683,7 +687,7 @@ public class ZipFile {
     readZipInfo();
 
     new ExtractFileTask(zipModel, password, unzipParameters, buildAsyncParameters()).execute(
-        new ExtractFileTaskParameters(destinationPath, fileHeader, newFileName, charset));
+        new ExtractFileTaskParameters(destinationPath, fileHeader, newFileName, buildConfig()));
   }
 
   /**
@@ -842,7 +846,7 @@ public class ZipFile {
     }
 
     new RemoveFilesFromZipTask(zipModel, headerWriter, buildAsyncParameters()).execute(
-        new RemoveFilesFromZipTaskParameters(fileNames, charset));
+        new RemoveFilesFromZipTaskParameters(fileNames, buildConfig()));
   }
 
   /**
@@ -923,8 +927,8 @@ public class ZipFile {
     }
 
     AsyncZipTask.AsyncTaskParameters asyncTaskParameters = buildAsyncParameters();
-    new RenameFilesTask(zipModel, headerWriter, new RawIO(), charset, asyncTaskParameters).execute(
-        new RenameFilesTaskParameters(fileNamesMap));
+    new RenameFilesTask(zipModel, headerWriter, new RawIO(), asyncTaskParameters).execute(
+        new RenameFilesTaskParameters(fileNamesMap, buildConfig()));
   }
 
   /**
@@ -950,7 +954,7 @@ public class ZipFile {
     }
 
     new MergeSplitZipFileTask(zipModel, buildAsyncParameters()).execute(
-            new MergeSplitZipFileTaskParameters(outputZipFile, charset));
+            new MergeSplitZipFileTaskParameters(outputZipFile, buildConfig()));
   }
 
   /**
@@ -979,7 +983,7 @@ public class ZipFile {
     }
 
     new SetCommentTask(zipModel, buildAsyncParameters()).execute(
-            new SetCommentTaskTaskParameters(comment, charset));
+            new SetCommentTaskTaskParameters(comment, buildConfig()));
   }
 
   /**
@@ -1082,6 +1086,30 @@ public class ZipFile {
     this.password = password;
   }
 
+  /**
+   * Returns the size of the buffer used to read streams
+   *
+   * @return size of the buffer used to read streams
+   */
+  public int getBufferSize() {
+    return bufferSize;
+  }
+
+  /**
+   * Sets the size of buffer that should be used when reading streams. This size cannot be less than the value defined
+   * in InternalZipConstants.MIN_BUFF_SIZE
+   *
+   * @param bufferSize size of the buffer that should be used when reading streams
+   * @throws IllegalArgumentException if bufferSize is less than value configured in InternalZipConstants.MIN_BUFF_SIZE
+   */
+  public void setBufferSize(int bufferSize) {
+    if (bufferSize < MIN_BUFF_SIZE) {
+      throw new IllegalArgumentException("Buffer size cannot be less than " + MIN_BUFF_SIZE + " bytes");
+    }
+
+    this.bufferSize = bufferSize;
+  }
+
   /**
    * Reads the zip header information for this zip file. If the zip file
    * does not exist, it creates an empty zip model.<br><br>
@@ -1105,7 +1133,7 @@ public class ZipFile {
 
     try (RandomAccessFile randomAccessFile = initializeRandomAccessFileForHeaderReading()) {
       HeaderReader headerReader = new HeaderReader();
-      zipModel = headerReader.readAllHeaders(randomAccessFile, charset);
+      zipModel = headerReader.readAllHeaders(randomAccessFile, buildConfig());
       zipModel.setZipFile(zipFile);
     } catch (ZipException e) {
       throw e;
@@ -1114,11 +1142,6 @@ public class ZipFile {
     }
   }
 
-  /**
-   * Creates a new instance of zip model
-   *
-   * @throws ZipException
-   */
   private void createNewZipModel() {
     zipModel = new ZipModel();
     zipModel.setZipFile(zipFile);
@@ -1210,4 +1233,8 @@ public class ZipFile {
   public String toString() {
     return zipFile.toString();
   }
+
+  private Zip4jConfig buildConfig() {
+    return new Zip4jConfig(charset, bufferSize);
+  }
 }
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
index 1a4b122..188f027 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
@@ -26,6 +26,7 @@ import net.lingala.zip4j.model.EndOfCentralDirectoryRecord;
 import net.lingala.zip4j.model.ExtraDataRecord;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.LocalFileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.Zip64EndOfCentralDirectoryLocator;
 import net.lingala.zip4j.model.Zip64EndOfCentralDirectoryRecord;
 import net.lingala.zip4j.model.Zip64ExtendedInfo;
@@ -46,7 +47,6 @@ import java.util.List;
 
 import static net.lingala.zip4j.headers.HeaderUtil.decodeStringWithCharset;
 import static net.lingala.zip4j.util.BitUtils.isBitSet;
-import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
 import static net.lingala.zip4j.util.InternalZipConstants.ENDHDR;
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP4J_DEFAULT_CHARSET;
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT;
@@ -62,7 +62,7 @@ public class HeaderReader {
   private RawIO rawIO = new RawIO();
   private byte[] intBuff = new byte[4];
 
-  public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Charset charset) throws IOException {
+  public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {
 
     if (zip4jRaf.length() < ENDHDR) {
       throw new ZipException("Zip file size less than minimum expected zip file size. " +
@@ -72,8 +72,9 @@ public class HeaderReader {
     zipModel = new ZipModel();
 
     try {
-      zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, charset));
-    } catch (ZipException e){
+      zipModel.setEndOfCentralDirectoryRecord(
+          readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig));
+    } catch (ZipException e) {
       throw e;
     } catch (IOException e) {
       throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e);
@@ -97,20 +98,20 @@ public class HeaderReader {
       }
     }
 
-    zipModel.setCentralDirectory(readCentralDirectory(zip4jRaf, rawIO, charset));
+    zipModel.setCentralDirectory(readCentralDirectory(zip4jRaf, rawIO, zip4jConfig.getCharset()));
 
     return zipModel;
   }
 
-  private EndOfCentralDirectoryRecord readEndOfCentralDirectoryRecord(RandomAccessFile zip4jRaf, RawIO rawIO, Charset charset)
-      throws IOException {
+  private EndOfCentralDirectoryRecord readEndOfCentralDirectoryRecord(RandomAccessFile zip4jRaf, RawIO rawIO,
+                                                                      Zip4jConfig zip4jConfig) throws IOException {
 
     long offsetEndOfCentralDirectory = zip4jRaf.length() - ENDHDR;
     seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectory);
     int headerSignature = rawIO.readIntLittleEndian(zip4jRaf);
 
     if (headerSignature != HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue()) {
-      offsetEndOfCentralDirectory = determineOffsetOfEndOfCentralDirectory(zip4jRaf);
+      offsetEndOfCentralDirectory = determineOffsetOfEndOfCentralDirectory(zip4jRaf, zip4jConfig.getBufferSize());
       zip4jRaf.seek(offsetEndOfCentralDirectory + 4); // 4 to ignore reading signature again
     }
 
@@ -128,7 +129,7 @@ public class HeaderReader {
     endOfCentralDirectoryRecord.setOffsetOfStartOfCentralDirectory(rawIO.readLongLittleEndian(intBuff, 0));
 
     int commentLength = rawIO.readShortLittleEndian(zip4jRaf);
-    endOfCentralDirectoryRecord.setComment(readZipComment(zip4jRaf, commentLength, charset));
+    endOfCentralDirectoryRecord.setComment(readZipComment(zip4jRaf, commentLength, zip4jConfig.getCharset()));
 
     zipModel.setSplitArchive(endOfCentralDirectoryRecord.getNumberOfThisDisk() > 0);
     return endOfCentralDirectoryRecord;
@@ -697,12 +698,14 @@ public class HeaderReader {
     return zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory();
   }
 
-  private long determineOffsetOfEndOfCentralDirectory(RandomAccessFile randomAccessFile) throws IOException {
-    byte[] buff = new byte[BUFF_SIZE];
+  private long determineOffsetOfEndOfCentralDirectory(RandomAccessFile randomAccessFile, int bufferSize)
+      throws IOException {
+
+    byte[] buff = new byte[bufferSize];
     long currentFilePointer = randomAccessFile.getFilePointer();
 
     do {
-      int toRead = currentFilePointer > BUFF_SIZE ? BUFF_SIZE : (int) currentFilePointer;
+      int toRead = currentFilePointer > bufferSize ? bufferSize : (int) currentFilePointer;
       // read 4 bytes again to make sure that the header is not spilled over
       long seekPosition = currentFilePointer - toRead + 4;
       if (seekPosition == 4) {
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
index ee77dd2..a3cb2ef 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
@@ -27,9 +27,9 @@ class AesCipherInputStream extends CipherInputStream<AESDecrypter> {
   private int lengthToCopyInThisIteration = 0;
   private int aes16ByteBlockReadLength = 0;
 
-  public AesCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader, char[] password)
-      throws IOException {
-    super(zipEntryInputStream, localFileHeader, password);
+  public AesCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader,
+                              char[] password, int bufferSize) throws IOException {
+    super(zipEntryInputStream, localFileHeader, password, bufferSize);
   }
 
   @Override
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
index 9ee5212..1edb20c 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
@@ -4,7 +4,6 @@ import net.lingala.zip4j.crypto.Decrypter;
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.model.enums.CompressionMethod;
-import net.lingala.zip4j.util.InternalZipConstants;
 import net.lingala.zip4j.util.Zip4jUtil;
 
 import java.io.IOException;
@@ -20,13 +19,14 @@ abstract class CipherInputStream<T extends Decrypter> extends InputStream {
   private byte[] singleByteBuffer = new byte[1];
   private LocalFileHeader localFileHeader;
 
-  public CipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader, char[] password) throws IOException, ZipException {
+  public CipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader,
+                           char[] password, int bufferSize) throws IOException {
     this.zipEntryInputStream = zipEntryInputStream;
     this.decrypter = initializeDecrypter(localFileHeader, password);
     this.localFileHeader = localFileHeader;
 
     if (Zip4jUtil.getCompressionMethod(localFileHeader).equals(CompressionMethod.DEFLATE)) {
-      lastReadRawDataCache = new byte[InternalZipConstants.BUFF_SIZE];
+      lastReadRawDataCache = new byte[bufferSize];
     }
   }
 
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/InflaterInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/InflaterInputStream.java
index 48412ea..4c2709b 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/InflaterInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/InflaterInputStream.java
@@ -1,7 +1,5 @@
 package net.lingala.zip4j.io.inputstream;
 
-import net.lingala.zip4j.util.InternalZipConstants;
-
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -16,10 +14,10 @@ public class InflaterInputStream extends DecompressedInputStream {
   private byte[] singleByteBuffer = new byte[1];
   private int len;
 
-  public InflaterInputStream(CipherInputStream cipherInputStream) {
+  public InflaterInputStream(CipherInputStream cipherInputStream, int bufferSize) {
     super(cipherInputStream);
     this.inflater = new Inflater(true);
-    buff = new byte[InternalZipConstants.BUFF_SIZE];
+    buff = new byte[bufferSize];
   }
 
   @Override
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/NoCipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/NoCipherInputStream.java
index dd1aa54..1883c94 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/NoCipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/NoCipherInputStream.java
@@ -1,15 +1,15 @@
 package net.lingala.zip4j.io.inputstream;
 
 import net.lingala.zip4j.crypto.Decrypter;
-import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.LocalFileHeader;
 
 import java.io.IOException;
 
 class NoCipherInputStream extends CipherInputStream {
 
-  public NoCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader, char[] password) throws IOException, ZipException {
-    super(zipEntryInputStream, localFileHeader, password);
+  public NoCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader,
+                             char[] password, int bufferSize) throws IOException {
+    super(zipEntryInputStream, localFileHeader, password, bufferSize);
   }
 
   @Override
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index 6889e45..37decca 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -23,6 +23,7 @@ import net.lingala.zip4j.model.DataDescriptor;
 import net.lingala.zip4j.model.ExtraDataRecord;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.LocalFileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
@@ -35,6 +36,7 @@ import java.nio.charset.Charset;
 import java.util.List;
 import java.util.zip.CRC32;
 
+import static net.lingala.zip4j.util.InternalZipConstants.MIN_BUFF_SIZE;
 import static net.lingala.zip4j.util.Zip4jUtil.getCompressionMethod;
 
 public class ZipInputStream extends InputStream {
@@ -47,10 +49,10 @@ public class ZipInputStream extends InputStream {
   private CRC32 crc32 = new CRC32();
   private byte[] endOfEntryBuffer;
   private boolean canSkipExtendedLocalFileHeader = false;
-  private Charset charset;
+  private Zip4jConfig zip4jConfig;
 
   public ZipInputStream(InputStream inputStream) {
-    this(inputStream, null, null);
+    this(inputStream, null, (Charset) null);
   }
 
   public ZipInputStream(InputStream inputStream, Charset charset) {
@@ -58,13 +60,21 @@ public class ZipInputStream extends InputStream {
   }
 
   public ZipInputStream(InputStream inputStream, char[] password) {
-    this(inputStream, password, null);
+    this(inputStream, password, (Charset) null);
   }
 
   public ZipInputStream(InputStream inputStream, char[] password, Charset charset) {
-    this.inputStream = new PushbackInputStream(inputStream, InternalZipConstants.BUFF_SIZE);
+    this(inputStream, password, new Zip4jConfig(charset, InternalZipConstants.BUFF_SIZE));
+  }
+
+  public ZipInputStream(InputStream inputStream, char[] password, Zip4jConfig zip4jConfig) {
+    if (zip4jConfig.getBufferSize() < InternalZipConstants.MIN_BUFF_SIZE) {
+      throw new IllegalArgumentException("Buffer size cannot be less than " + MIN_BUFF_SIZE + " bytes");
+    }
+
+    this.inputStream = new PushbackInputStream(inputStream, zip4jConfig.getBufferSize());
     this.password = password;
-    this.charset = charset;
+    this.zip4jConfig = zip4jConfig;
   }
 
   public LocalFileHeader getNextEntry() throws IOException {
@@ -76,7 +86,7 @@ public class ZipInputStream extends InputStream {
       readUntilEndOfEntry();
     }
 
-    localFileHeader = headerReader.readLocalFileHeader(inputStream, charset);
+    localFileHeader = headerReader.readLocalFileHeader(inputStream, zip4jConfig.getCharset());
 
     if (localFileHeader == null) {
       return null;
@@ -153,10 +163,6 @@ public class ZipInputStream extends InputStream {
     }
   }
 
-  public int getAvailableBytesInPushBackInputStream() throws IOException {
-    return inputStream.available();
-  }
-
   private void endOfCompressedDataReached() throws IOException {
     //With inflater, without knowing the compressed or uncompressed size, we over read necessary data
     //In such cases, we have to push back the inputstream to the end of data
@@ -176,26 +182,28 @@ public class ZipInputStream extends InputStream {
     return initializeDecompressorForThisEntry(cipherInputStream, localFileHeader);
   }
 
-  private CipherInputStream initializeCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader) throws IOException {
+  private CipherInputStream initializeCipherInputStream(ZipEntryInputStream zipEntryInputStream,
+                                                        LocalFileHeader localFileHeader) throws IOException {
     if (!localFileHeader.isEncrypted()) {
-      return new NoCipherInputStream(zipEntryInputStream, localFileHeader, password);
+      return new NoCipherInputStream(zipEntryInputStream, localFileHeader, password, zip4jConfig.getBufferSize());
     }
 
     if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) {
-      return new AesCipherInputStream(zipEntryInputStream, localFileHeader, password);
+      return new AesCipherInputStream(zipEntryInputStream, localFileHeader, password, zip4jConfig.getBufferSize());
     } else if (localFileHeader.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD) {
-      return new ZipStandardCipherInputStream(zipEntryInputStream, localFileHeader, password);
+      return new ZipStandardCipherInputStream(zipEntryInputStream, localFileHeader, password, zip4jConfig.getBufferSize());
     } else {
       final String message = String.format("Entry [%s] Strong Encryption not supported", localFileHeader.getFileName());
       throw new ZipException(message, ZipException.Type.UNSUPPORTED_ENCRYPTION);
     }
   }
 
-  private DecompressedInputStream initializeDecompressorForThisEntry(CipherInputStream cipherInputStream, LocalFileHeader localFileHeader) {
+  private DecompressedInputStream initializeDecompressorForThisEntry(CipherInputStream cipherInputStream,
+                                                                     LocalFileHeader localFileHeader) {
     CompressionMethod compressionMethod = getCompressionMethod(localFileHeader);
 
     if (compressionMethod == CompressionMethod.DEFLATE) {
-      return new InflaterInputStream(cipherInputStream);
+      return new InflaterInputStream(cipherInputStream, zip4jConfig.getBufferSize());
     }
 
     return new StoreInputStream(cipherInputStream);
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java
index 9408277..f110c76 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java
@@ -10,8 +10,8 @@ import static net.lingala.zip4j.util.InternalZipConstants.STD_DEC_HDR_SIZE;
 class ZipStandardCipherInputStream extends CipherInputStream<StandardDecrypter> {
 
   public ZipStandardCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader,
-                                      char[] password) throws IOException {
-    super(zipEntryInputStream, localFileHeader, password);
+                                      char[] password, int bufferSize) throws IOException {
+    super(zipEntryInputStream, localFileHeader, password, bufferSize);
   }
 
   @Override
diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/DeflaterOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/DeflaterOutputStream.java
index 8141b64..e39930a 100755
--- a/src/main/java/net/lingala/zip4j/io/outputstream/DeflaterOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/DeflaterOutputStream.java
@@ -21,16 +21,15 @@ import net.lingala.zip4j.model.enums.CompressionLevel;
 import java.io.IOException;
 import java.util.zip.Deflater;
 
-import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
-
 class DeflaterOutputStream extends CompressedOutputStream {
 
-  private byte[] buff = new byte[BUFF_SIZE];
+  private byte[] buff;
   protected Deflater deflater;
 
-  public DeflaterOutputStream(CipherOutputStream cipherOutputStream, CompressionLevel compressionLevel) {
+  public DeflaterOutputStream(CipherOutputStream cipherOutputStream, CompressionLevel compressionLevel, int bufferSize) {
     super(cipherOutputStream);
     deflater = new Deflater(compressionLevel.getLevel(), true);
+    buff = new byte[bufferSize];
   }
 
   public void write(byte[] b) throws IOException {
diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
index 8a5d752..1b819ff 100755
--- a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
@@ -6,11 +6,13 @@ import net.lingala.zip4j.headers.HeaderSignature;
 import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.LocalFileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
+import net.lingala.zip4j.util.InternalZipConstants;
 import net.lingala.zip4j.util.RawIO;
 
 import java.io.IOException;
@@ -18,6 +20,9 @@ import java.io.OutputStream;
 import java.nio.charset.Charset;
 import java.util.zip.CRC32;
 
+import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
+import static net.lingala.zip4j.util.InternalZipConstants.MIN_BUFF_SIZE;
+
 public class ZipOutputStream extends OutputStream {
 
   private CountingOutputStream countingOutputStream;
@@ -31,7 +36,7 @@ public class ZipOutputStream extends OutputStream {
   private CRC32 crc32 = new CRC32();
   private RawIO rawIO = new RawIO();
   private long uncompressedSizeForThisEntry = 0;
-  private Charset charset;
+  private Zip4jConfig zip4jConfig;
   private boolean streamClosed;
 
   public ZipOutputStream(OutputStream outputStream) throws IOException {
@@ -47,13 +52,18 @@ public class ZipOutputStream extends OutputStream {
   }
 
   public ZipOutputStream(OutputStream outputStream, char[] password, Charset charset) throws IOException {
-    this(outputStream, password, charset, new ZipModel());
+    this(outputStream, password, new Zip4jConfig(charset, BUFF_SIZE), new ZipModel());
   }
 
-  public ZipOutputStream(OutputStream outputStream, char[] password, Charset charset, ZipModel zipModel) throws IOException {
+  public ZipOutputStream(OutputStream outputStream, char[] password, Zip4jConfig zip4jConfig,
+                         ZipModel zipModel) throws IOException {
+    if (zip4jConfig.getBufferSize() < InternalZipConstants.MIN_BUFF_SIZE) {
+      throw new IllegalArgumentException("Buffer size cannot be less than " + MIN_BUFF_SIZE + " bytes");
+    }
+
     this.countingOutputStream = new CountingOutputStream(outputStream);
     this.password = password;
-    this.charset = charset;
+    this.zip4jConfig = zip4jConfig;
     this.zipModel = initializeZipModel(zipModel, countingOutputStream);
     this.streamClosed = false;
     writeSplitZipHeaderIfApplicable();
@@ -112,7 +122,7 @@ public class ZipOutputStream extends OutputStream {
   @Override
   public void close() throws IOException {
     zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(countingOutputStream.getNumberOfBytesWritten());
-    headerWriter.finalizeZipFile(zipModel, countingOutputStream, charset);
+    headerWriter.finalizeZipFile(zipModel, countingOutputStream, zip4jConfig.getCharset());
     countingOutputStream.close();
     this.streamClosed = true;
   }
@@ -143,11 +153,11 @@ public class ZipOutputStream extends OutputStream {
 
   private void initializeAndWriteFileHeader(ZipParameters zipParameters) throws IOException {
     fileHeader = fileHeaderFactory.generateFileHeader(zipParameters, countingOutputStream.isSplitZipFile(),
-        countingOutputStream.getCurrentSplitFileCounter(), charset, rawIO);
+        countingOutputStream.getCurrentSplitFileCounter(), zip4jConfig.getCharset(), rawIO);
     fileHeader.setOffsetLocalHeader(countingOutputStream.getOffsetForNextEntry());
 
     localFileHeader = fileHeaderFactory.generateLocalFileHeader(fileHeader);
-    headerWriter.writeLocalFileHeader(zipModel, localFileHeader, countingOutputStream, charset);
+    headerWriter.writeLocalFileHeader(zipModel, localFileHeader, countingOutputStream, zip4jConfig.getCharset());
   }
 
   private void reset() throws IOException {
@@ -194,7 +204,7 @@ public class ZipOutputStream extends OutputStream {
   private CompressedOutputStream initializeCompressedOutputStream(CipherOutputStream cipherOutputStream,
                                                                   ZipParameters zipParameters) {
     if (zipParameters.getCompressionMethod() == CompressionMethod.DEFLATE) {
-      return new DeflaterOutputStream(cipherOutputStream, zipParameters.getCompressionLevel());
+      return new DeflaterOutputStream(cipherOutputStream, zipParameters.getCompressionLevel(), zip4jConfig.getBufferSize());
     }
 
     return new StoreOutputStream(cipherOutputStream);
diff --git a/src/main/java/net/lingala/zip4j/model/Zip4jConfig.java b/src/main/java/net/lingala/zip4j/model/Zip4jConfig.java
new file mode 100644
index 0000000..73de503
--- /dev/null
+++ b/src/main/java/net/lingala/zip4j/model/Zip4jConfig.java
@@ -0,0 +1,22 @@
+package net.lingala.zip4j.model;
+
+import java.nio.charset.Charset;
+
+public class Zip4jConfig {
+
+  private Charset charset;
+  private int bufferSize;
+
+  public Zip4jConfig(Charset charset, int bufferSize) {
+    this.charset = charset;
+    this.bufferSize = bufferSize;
+  }
+
+  public Charset getCharset() {
+    return charset;
+  }
+
+  public int getBufferSize() {
+    return bufferSize;
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
index c436f2a..1e771cd 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
@@ -6,6 +6,7 @@ import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.io.outputstream.SplitOutputStream;
 import net.lingala.zip4j.io.outputstream.ZipOutputStream;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.CompressionMethod;
@@ -21,7 +22,6 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -33,11 +33,12 @@ import static net.lingala.zip4j.model.enums.CompressionMethod.DEFLATE;
 import static net.lingala.zip4j.model.enums.CompressionMethod.STORE;
 import static net.lingala.zip4j.model.enums.EncryptionMethod.NONE;
 import static net.lingala.zip4j.model.enums.EncryptionMethod.ZIP_STANDARD;
-import static net.lingala.zip4j.progress.ProgressMonitor.Task.*;
+import static net.lingala.zip4j.progress.ProgressMonitor.Task.ADD_ENTRY;
+import static net.lingala.zip4j.progress.ProgressMonitor.Task.CALCULATE_CRC;
+import static net.lingala.zip4j.progress.ProgressMonitor.Task.REMOVE_ENTRY;
 import static net.lingala.zip4j.util.CrcUtil.computeFileCrc;
 import static net.lingala.zip4j.util.FileUtils.assertFilesExist;
 import static net.lingala.zip4j.util.FileUtils.getRelativeFileName;
-import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
 import static net.lingala.zip4j.util.Zip4jUtil.epochToExtendedDosTime;
 
 public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
@@ -45,8 +46,6 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
   private ZipModel zipModel;
   private char[] password;
   private HeaderWriter headerWriter;
-  private byte[] readBuff = new byte[BUFF_SIZE];
-  private int readLen = -1;
 
   AbstractAddFileToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter,
                            AsyncTaskParameters asyncTaskParameters) {
@@ -54,17 +53,19 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     this.zipModel = zipModel;
     this.password = password;
     this.headerWriter = headerWriter;
+
   }
 
-  void addFilesToZip(List<File> filesToAdd, ProgressMonitor progressMonitor, ZipParameters zipParameters, Charset charset)
-      throws IOException {
+  void addFilesToZip(List<File> filesToAdd, ProgressMonitor progressMonitor, ZipParameters zipParameters,
+                     Zip4jConfig zip4jConfig) throws IOException {
 
     assertFilesExist(filesToAdd, zipParameters.getSymbolicLinkAction());
 
-    List<File> updatedFilesToAdd = removeFilesIfExists(filesToAdd, zipParameters, progressMonitor, charset);
+    byte[] readBuff = new byte[zip4jConfig.getBufferSize()];
+    List<File> updatedFilesToAdd = removeFilesIfExists(filesToAdd, zipParameters, progressMonitor, zip4jConfig);
 
     try (SplitOutputStream splitOutputStream = new SplitOutputStream(zipModel.getZipFile(), zipModel.getSplitLength());
-         ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, charset)) {
+         ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, zip4jConfig)) {
 
       for (File fileToAdd : updatedFilesToAdd) {
         verifyIfTaskIsCancelled();
@@ -81,7 +82,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
           }
         }
 
-        addFileToZip(fileToAdd, zipOutputStream, clonedZipParameters, splitOutputStream, progressMonitor);
+        addFileToZip(fileToAdd, zipOutputStream, clonedZipParameters, splitOutputStream, progressMonitor, readBuff);
       }
     }
   }
@@ -103,10 +104,11 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
   }
 
   private void addFileToZip(File fileToAdd, ZipOutputStream zipOutputStream, ZipParameters zipParameters,
-                            SplitOutputStream splitOutputStream, ProgressMonitor progressMonitor) throws IOException {
+                            SplitOutputStream splitOutputStream, ProgressMonitor progressMonitor,
+                            byte[] readBuff) throws IOException {
 
     zipOutputStream.putNextEntry(zipParameters);
-
+    int readLen;
     if (fileToAdd.exists() && !fileToAdd.isDirectory()) {
       try (InputStream inputStream = new FileInputStream(fileToAdd)) {
         while ((readLen = inputStream.read(readBuff)) != -1) {
@@ -161,12 +163,12 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     return totalWork;
   }
 
-  ZipOutputStream initializeOutputStream(SplitOutputStream splitOutputStream, Charset charset) throws IOException {
+  ZipOutputStream initializeOutputStream(SplitOutputStream splitOutputStream, Zip4jConfig zip4jConfig) throws IOException {
     if (zipModel.getZipFile().exists()) {
       splitOutputStream.seek(HeaderUtil.getOffsetStartOfCentralDirectory(zipModel));
     }
 
-    return new ZipOutputStream(splitOutputStream, password, charset, zipModel);
+    return new ZipOutputStream(splitOutputStream, password, zip4jConfig, zipModel);
   }
 
   void verifyZipParameters(ZipParameters parameters) throws ZipException {
@@ -233,7 +235,8 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     return clonedZipParameters;
   }
 
-  private List<File> removeFilesIfExists(List<File> files, ZipParameters zipParameters, ProgressMonitor progressMonitor, Charset charset)
+  private List<File> removeFilesIfExists(List<File> files, ZipParameters zipParameters, ProgressMonitor progressMonitor,
+                                         Zip4jConfig zip4jConfig)
       throws ZipException {
 
     List<File> filesToAdd = new ArrayList<>(files);
@@ -248,7 +251,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
       if (fileHeader != null) {
         if (zipParameters.isOverrideExistingFilesInZip()) {
           progressMonitor.setCurrentTask(REMOVE_ENTRY);
-          removeFile(fileHeader, progressMonitor, charset);
+          removeFile(fileHeader, progressMonitor, zip4jConfig);
           verifyIfTaskIsCancelled();
           progressMonitor.setCurrentTask(ADD_ENTRY);
         } else {
@@ -260,10 +263,12 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     return filesToAdd;
   }
 
-  void removeFile(FileHeader fileHeader, ProgressMonitor progressMonitor, Charset charset) throws ZipException {
+  void removeFile(FileHeader fileHeader, ProgressMonitor progressMonitor, Zip4jConfig zip4jConfig) throws ZipException {
     AsyncTaskParameters asyncTaskParameters = new AsyncTaskParameters(null, false, progressMonitor);
     RemoveFilesFromZipTask removeFilesFromZipTask = new RemoveFilesFromZipTask(zipModel, headerWriter, asyncTaskParameters);
-    removeFilesFromZipTask.execute(new RemoveFilesFromZipTaskParameters(Collections.singletonList(fileHeader.getFileName()), charset));
+    RemoveFilesFromZipTaskParameters parameters = new RemoveFilesFromZipTaskParameters(
+        Collections.singletonList(fileHeader.getFileName()), zip4jConfig);
+    removeFilesFromZipTask.execute(parameters);
   }
 
   private String replaceFileNameInZip(String fileInZipWithPath, String newFileName) {
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
index 3ae326b..a405ebf 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
@@ -20,14 +20,12 @@ import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.regex.Matcher;
 
-import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
 import static net.lingala.zip4j.util.InternalZipConstants.FILE_SEPARATOR;
 
 public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
 
   private ZipModel zipModel;
   private UnzipParameters unzipParameters;
-  private byte[] buff = new byte[BUFF_SIZE];
 
   public AbstractExtractFileTask(ZipModel zipModel, UnzipParameters unzipParameters,
                                  AsyncTaskParameters asyncTaskParameters) {
@@ -37,7 +35,7 @@ public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
   }
 
   protected void extractFile(ZipInputStream zipInputStream, FileHeader fileHeader, String outputPath,
-                             String newFileName, ProgressMonitor progressMonitor) throws IOException {
+                             String newFileName, ProgressMonitor progressMonitor, byte[] readBuff) throws IOException {
 
     boolean isSymbolicLink = isSymbolicLink(fileHeader);
     if (isSymbolicLink && !unzipParameters.isExtractSymbolicLinks()) {
@@ -70,7 +68,7 @@ public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
       createSymLink(zipInputStream, fileHeader, outputFile, progressMonitor);
     } else {
       checkOutputDirectoryStructure(outputFile);
-      unzipFile(zipInputStream, outputFile, progressMonitor);
+      unzipFile(zipInputStream, outputFile, progressMonitor, readBuff);
     }
 
     UnzipUtil.applyFileAttributes(fileHeader, outputFile);
@@ -86,7 +84,7 @@ public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
     return BitUtils.isBitSet(externalFileAttributes[3], 5);
   }
 
-  private void unzipFile(ZipInputStream inputStream, File outputFile, ProgressMonitor progressMonitor)
+  private void unzipFile(ZipInputStream inputStream, File outputFile, ProgressMonitor progressMonitor, byte[] buff)
       throws IOException {
 
     int readLength;
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
index a775557..ad55788 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
@@ -67,8 +67,8 @@ abstract class AbstractModifyFileTask<T> extends AsyncZipTask<T> {
   }
 
   long copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long length,
-                        ProgressMonitor progressMonitor) throws IOException {
-    FileUtils.copyFile(randomAccessFile, outputStream, start, start + length, progressMonitor);
+                        ProgressMonitor progressMonitor, int bufferSize) throws IOException {
+    FileUtils.copyFile(randomAccessFile, outputStream, start, start + length, progressMonitor, bufferSize);
     return length;
   }
 
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractZipTaskParameters.java b/src/main/java/net/lingala/zip4j/tasks/AbstractZipTaskParameters.java
index cbdde97..28d9cb2 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractZipTaskParameters.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractZipTaskParameters.java
@@ -1,12 +1,12 @@
 package net.lingala.zip4j.tasks;
 
-import java.nio.charset.Charset;
+import net.lingala.zip4j.model.Zip4jConfig;
 
 public abstract class AbstractZipTaskParameters {
 
-  protected Charset charset;
+  protected Zip4jConfig zip4jConfig;
 
-  protected AbstractZipTaskParameters(Charset charset) {
-    this.charset = charset;
+  protected AbstractZipTaskParameters(Zip4jConfig zip4jConfig) {
+    this.zip4jConfig = zip4jConfig;
   }
 }
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java
index 0e97866..89b6121 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java
@@ -2,6 +2,7 @@ package net.lingala.zip4j.tasks;
 
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.headers.HeaderWriter;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -9,12 +10,12 @@ import net.lingala.zip4j.tasks.AddFilesToZipTask.AddFilesToZipTaskParameters;
 
 import java.io.File;
 import java.io.IOException;
-import java.nio.charset.Charset;
 import java.util.List;
 
 public class AddFilesToZipTask extends AbstractAddFileToZipTask<AddFilesToZipTaskParameters> {
 
-  public AddFilesToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter, AsyncTaskParameters asyncTaskParameters) {
+  public AddFilesToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter,
+                           AsyncTaskParameters asyncTaskParameters) {
     super(zipModel, password, headerWriter, asyncTaskParameters);
   }
 
@@ -23,7 +24,7 @@ public class AddFilesToZipTask extends AbstractAddFileToZipTask<AddFilesToZipTas
       throws IOException {
 
     verifyZipParameters(taskParameters.zipParameters);
-    addFilesToZip(taskParameters.filesToAdd, progressMonitor, taskParameters.zipParameters, taskParameters.charset);
+    addFilesToZip(taskParameters.filesToAdd, progressMonitor, taskParameters.zipParameters, taskParameters.zip4jConfig);
   }
 
   @Override
@@ -40,8 +41,8 @@ public class AddFilesToZipTask extends AbstractAddFileToZipTask<AddFilesToZipTas
     private List<File> filesToAdd;
     private ZipParameters zipParameters;
 
-    public AddFilesToZipTaskParameters(List<File> filesToAdd, ZipParameters zipParameters, Charset charset) {
-      super(charset);
+    public AddFilesToZipTaskParameters(List<File> filesToAdd, ZipParameters zipParameters, Zip4jConfig zip4jConfig) {
+      super(zip4jConfig);
       this.filesToAdd = filesToAdd;
       this.zipParameters = zipParameters;
     }
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
index ecc9903..2195ffe 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
@@ -2,6 +2,7 @@ package net.lingala.zip4j.tasks;
 
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.headers.HeaderWriter;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -9,7 +10,6 @@ import net.lingala.zip4j.tasks.AddFolderToZipTask.AddFolderToZipTaskParameters;
 
 import java.io.File;
 import java.io.IOException;
-import java.nio.charset.Charset;
 import java.util.List;
 
 import static net.lingala.zip4j.util.FileUtils.getFilesInDirectoryRecursive;
@@ -25,7 +25,7 @@ public class AddFolderToZipTask extends AbstractAddFileToZipTask<AddFolderToZipT
       throws IOException {
     List<File> filesToAdd = getFilesToAdd(taskParameters);
     setDefaultFolderPath(taskParameters);
-    addFilesToZip(filesToAdd, progressMonitor, taskParameters.zipParameters, taskParameters.charset);
+    addFilesToZip(filesToAdd, progressMonitor, taskParameters.zipParameters, taskParameters.zip4jConfig);
   }
 
   @Override
@@ -76,8 +76,8 @@ public class AddFolderToZipTask extends AbstractAddFileToZipTask<AddFolderToZipT
     private File folderToAdd;
     private ZipParameters zipParameters;
 
-    public AddFolderToZipTaskParameters(File folderToAdd, ZipParameters zipParameters, Charset charset) {
-      super(charset);
+    public AddFolderToZipTaskParameters(File folderToAdd, ZipParameters zipParameters, Zip4jConfig zip4jConfig) {
+      super(zip4jConfig);
       this.folderToAdd = folderToAdd;
       this.zipParameters = zipParameters;
     }
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
index c25e4bb..c3ed5a7 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
@@ -6,6 +6,7 @@ import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.io.outputstream.SplitOutputStream;
 import net.lingala.zip4j.io.outputstream.ZipOutputStream;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.CompressionMethod;
@@ -15,9 +16,6 @@ import net.lingala.zip4j.util.Zip4jUtil;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.charset.Charset;
-
-import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
 
 public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipTaskParameters> {
 
@@ -35,7 +33,8 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
       throw new ZipException("fileNameInZip has to be set in zipParameters when adding stream");
     }
 
-    removeFileIfExists(getZipModel(), taskParameters.charset, taskParameters.zipParameters.getFileNameInZip(), progressMonitor);
+    removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(),
+        progressMonitor);
 
     // For streams, it is necessary to write extended local file header because of Zip standard encryption.
     // If we do not write extended local file header, zip standard encryption needs a crc upfront for key,
@@ -49,10 +48,10 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
     }
 
     try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength());
-        ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.charset)) {
+        ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {
 
-      byte[] readBuff = new byte[BUFF_SIZE];
-      int readLen = -1;
+      byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()];
+      int readLen;
 
       ZipParameters zipParameters = taskParameters.zipParameters;
       zipOutputStream.putNextEntry(zipParameters);
@@ -77,12 +76,12 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
     return 0;
   }
 
-  private void removeFileIfExists(ZipModel zipModel, Charset charset, String fileNameInZip, ProgressMonitor progressMonitor)
-      throws ZipException {
+  private void removeFileIfExists(ZipModel zipModel, Zip4jConfig zip4jConfig, String fileNameInZip,
+                                  ProgressMonitor progressMonitor) throws ZipException {
 
     FileHeader fileHeader = HeaderUtil.getFileHeader(zipModel, fileNameInZip);
     if (fileHeader  != null) {
-      removeFile(fileHeader, progressMonitor, charset);
+      removeFile(fileHeader, progressMonitor, zip4jConfig);
     }
   }
 
@@ -90,8 +89,8 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
     private InputStream inputStream;
     private ZipParameters zipParameters;
 
-    public AddStreamToZipTaskParameters(InputStream inputStream, ZipParameters zipParameters, Charset charset) {
-      super(charset);
+    public AddStreamToZipTaskParameters(InputStream inputStream, ZipParameters zipParameters, Zip4jConfig zip4jConfig) {
+      super(zip4jConfig);
       this.inputStream = inputStream;
       this.zipParameters = zipParameters;
     }
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
index f0eef95..bce7d7d 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
@@ -4,13 +4,13 @@ import net.lingala.zip4j.io.inputstream.SplitInputStream;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.UnzipParameters;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.ExtractAllFilesTask.ExtractAllFilesTaskParameters;
 import net.lingala.zip4j.util.UnzipUtil;
 
 import java.io.IOException;
-import java.nio.charset.Charset;
 
 import static net.lingala.zip4j.headers.HeaderUtil.getTotalUncompressedSizeOfAllFileHeaders;
 
@@ -28,7 +28,7 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
   @Override
   protected void executeTask(ExtractAllFilesTaskParameters taskParameters, ProgressMonitor progressMonitor)
       throws IOException {
-    try (ZipInputStream zipInputStream = prepareZipInputStream(taskParameters.charset)) {
+    try (ZipInputStream zipInputStream = prepareZipInputStream(taskParameters.zip4jConfig)) {
       for (FileHeader fileHeader : getZipModel().getCentralDirectory().getFileHeaders()) {
         if (fileHeader.getFileName().startsWith("__MACOSX")) {
           progressMonitor.updateWorkCompleted(fileHeader.getUncompressedSize());
@@ -37,7 +37,8 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
 
         splitInputStream.prepareExtractionForFileHeader(fileHeader);
 
-        extractFile(zipInputStream, fileHeader, taskParameters.outputPath, null, progressMonitor);
+        byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()];
+        extractFile(zipInputStream, fileHeader, taskParameters.outputPath, null, progressMonitor, readBuff);
         verifyIfTaskIsCancelled();
       }
     } finally {
@@ -52,7 +53,7 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
     return getTotalUncompressedSizeOfAllFileHeaders(getZipModel().getCentralDirectory().getFileHeaders());
   }
 
-  private ZipInputStream prepareZipInputStream(Charset charset) throws IOException {
+  private ZipInputStream prepareZipInputStream(Zip4jConfig zip4jConfig) throws IOException {
     splitInputStream = UnzipUtil.createSplitInputStream(getZipModel());
 
     FileHeader fileHeader = getFirstFileHeader(getZipModel());
@@ -60,7 +61,7 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
       splitInputStream.prepareExtractionForFileHeader(fileHeader);
     }
 
-    return new ZipInputStream(splitInputStream, password, charset);
+    return new ZipInputStream(splitInputStream, password, zip4jConfig);
   }
 
   private FileHeader getFirstFileHeader(ZipModel zipModel) {
@@ -76,8 +77,8 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
   public static class ExtractAllFilesTaskParameters extends AbstractZipTaskParameters {
     private String outputPath;
 
-    public ExtractAllFilesTaskParameters(String outputPath, Charset charset) {
-      super(charset);
+    public ExtractAllFilesTaskParameters(String outputPath, Zip4jConfig zip4jConfig) {
+      super(zip4jConfig);
       this.outputPath = outputPath;
     }
   }
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
index da25a17..661a686 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
@@ -4,6 +4,7 @@ import net.lingala.zip4j.io.inputstream.SplitInputStream;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.UnzipParameters;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.ExtractFileTask.ExtractFileTaskParameters;
@@ -12,7 +13,6 @@ import net.lingala.zip4j.util.UnzipUtil;
 import net.lingala.zip4j.util.Zip4jUtil;
 
 import java.io.IOException;
-import java.nio.charset.Charset;
 import java.util.Collections;
 import java.util.List;
 
@@ -34,11 +34,13 @@ public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskPara
   protected void executeTask(ExtractFileTaskParameters taskParameters, ProgressMonitor progressMonitor)
       throws IOException {
 
-    try(ZipInputStream zipInputStream = createZipInputStream(taskParameters.fileHeader, taskParameters.charset)) {
+    try(ZipInputStream zipInputStream =
+            createZipInputStream(taskParameters.fileHeader, taskParameters.zip4jConfig)) {
       List<FileHeader> fileHeadersUnderDirectory = getFileHeadersToExtract(taskParameters.fileHeader);
+      byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()];
       for (FileHeader fileHeader : fileHeadersUnderDirectory) {
         String newFileName = determineNewFileName(taskParameters.newFileName, taskParameters.fileHeader, fileHeader);
-        extractFile(zipInputStream, fileHeader, taskParameters.outputPath, newFileName, progressMonitor);
+        extractFile(zipInputStream, fileHeader, taskParameters.outputPath, newFileName, progressMonitor, readBuff);
       }
     } finally {
       if (splitInputStream != null) {
@@ -62,13 +64,14 @@ public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskPara
         getZipModel().getCentralDirectory().getFileHeaders(), rootFileHeader);
   }
 
-  private ZipInputStream createZipInputStream(FileHeader fileHeader, Charset charset) throws IOException {
+  private ZipInputStream createZipInputStream(FileHeader fileHeader, Zip4jConfig zip4jConfig) throws IOException {
     splitInputStream = UnzipUtil.createSplitInputStream(getZipModel());
     splitInputStream.prepareExtractionForFileHeader(fileHeader);
-    return new ZipInputStream(splitInputStream, password, charset);
+    return new ZipInputStream(splitInputStream, password, zip4jConfig);
   }
 
-  private String determineNewFileName(String newFileName, FileHeader fileHeaderToExtract, FileHeader fileHeaderBeingExtracted) {
+  private String determineNewFileName(String newFileName, FileHeader fileHeaderToExtract,
+                                      FileHeader fileHeaderBeingExtracted) {
     if (!Zip4jUtil.isStringNotNullAndNotEmpty(newFileName)) {
       return newFileName;
     }
@@ -91,8 +94,9 @@ public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskPara
     private FileHeader fileHeader;
     private String newFileName;
 
-    public ExtractFileTaskParameters(String outputPath, FileHeader fileHeader, String newFileName, Charset charset) {
-      super(charset);
+    public ExtractFileTaskParameters(String outputPath, FileHeader fileHeader, String newFileName,
+                                     Zip4jConfig zip4jConfig) {
+      super(zip4jConfig);
       this.outputPath = outputPath;
       this.fileHeader = fileHeader;
       this.newFileName = newFileName;
diff --git a/src/main/java/net/lingala/zip4j/tasks/MergeSplitZipFileTask.java b/src/main/java/net/lingala/zip4j/tasks/MergeSplitZipFileTask.java
index 30a90ee..c27e703 100644
--- a/src/main/java/net/lingala/zip4j/tasks/MergeSplitZipFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/MergeSplitZipFileTask.java
@@ -5,6 +5,7 @@ import net.lingala.zip4j.headers.HeaderSignature;
 import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.model.EndOfCentralDirectoryRecord;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.Zip64EndOfCentralDirectoryLocator;
 import net.lingala.zip4j.model.Zip64EndOfCentralDirectoryRecord;
 import net.lingala.zip4j.model.ZipModel;
@@ -68,14 +69,15 @@ public class MergeSplitZipFileTask extends AsyncZipTask<MergeSplitZipFileTaskPar
             end = zipModel.getEndOfCentralDirectoryRecord().getOffsetOfStartOfCentralDirectory();
           }
 
-          copyFile(randomAccessFile, outputStream, start, end, progressMonitor);
+          copyFile(randomAccessFile, outputStream, start, end, progressMonitor, taskParameters.zip4jConfig.getBufferSize());
           totalBytesWritten += (end - start);
           updateFileHeaderOffsetsForIndex(zipModel.getCentralDirectory().getFileHeaders(),
               i == 0 ? 0 : totalBytesWritten, i, splitSignatureOverhead);
           verifyIfTaskIsCancelled();
         }
       }
-      updateHeadersForMergeSplitFileAction(zipModel, totalBytesWritten, outputStream, taskParameters.charset);
+      updateHeadersForMergeSplitFileAction(zipModel, totalBytesWritten, outputStream,
+          taskParameters.zip4jConfig.getCharset());
       progressMonitor.endProgressMonitor();
     } catch (CloneNotSupportedException e) {
       throw new ZipException(e);
@@ -192,8 +194,8 @@ public class MergeSplitZipFileTask extends AsyncZipTask<MergeSplitZipFileTaskPar
   public static class MergeSplitZipFileTaskParameters extends AbstractZipTaskParameters {
     private File outputZipFile;
 
-    public MergeSplitZipFileTaskParameters(File outputZipFile, Charset charset) {
-      super(charset);
+    public MergeSplitZipFileTaskParameters(File outputZipFile, Zip4jConfig zip4jConfig) {
+      super(zip4jConfig);
       this.outputZipFile = outputZipFile;
     }
   }
diff --git a/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java b/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
index 3bf6c4d..512f38e 100644
--- a/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
@@ -6,6 +6,7 @@ import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.io.outputstream.SplitOutputStream;
 import net.lingala.zip4j.model.EndOfCentralDirectoryRecord;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.enums.RandomAccessFileMode;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -14,7 +15,6 @@ import net.lingala.zip4j.tasks.RemoveFilesFromZipTask.RemoveFilesFromZipTaskPara
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
-import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -63,12 +63,13 @@ public class RemoveFilesFromZipTask extends AbstractModifyFileTask<RemoveFilesFr
           currentFileCopyPointer += lengthOfCurrentEntry;
         } else {
           // copy complete entry without any changes
-          currentFileCopyPointer += super.copyFile(inputStream, outputStream, currentFileCopyPointer, lengthOfCurrentEntry, progressMonitor);
+          currentFileCopyPointer += super.copyFile(inputStream, outputStream, currentFileCopyPointer,
+              lengthOfCurrentEntry, progressMonitor, taskParameters.zip4jConfig.getBufferSize());
         }
         verifyIfTaskIsCancelled();
       }
 
-      headerWriter.finalizeZipFile(zipModel, outputStream, taskParameters.charset);
+      headerWriter.finalizeZipFile(zipModel, outputStream, taskParameters.zip4jConfig.getCharset());
       successFlag = true;
     } finally {
       cleanupFile(successFlag, zipModel.getZipFile(), temporaryZipFile);
@@ -102,7 +103,8 @@ public class RemoveFilesFromZipTask extends AbstractModifyFileTask<RemoveFilesFr
     return false;
   }
 
-  private void updateHeaders(List<FileHeader> sortedFileHeaders, FileHeader fileHeaderThatWasRemoved, long offsetToSubtract) throws ZipException {
+  private void updateHeaders(List<FileHeader> sortedFileHeaders, FileHeader fileHeaderThatWasRemoved,
+                             long offsetToSubtract) throws ZipException {
     updateOffsetsForAllSubsequentFileHeaders(sortedFileHeaders, zipModel, fileHeaderThatWasRemoved, negate(offsetToSubtract));
 
     EndOfCentralDirectoryRecord endOfCentralDirectoryRecord = zipModel.getEndOfCentralDirectoryRecord();
@@ -144,8 +146,8 @@ public class RemoveFilesFromZipTask extends AbstractModifyFileTask<RemoveFilesFr
   public static class RemoveFilesFromZipTaskParameters extends AbstractZipTaskParameters {
     private List<String> filesToRemove;
 
-    public RemoveFilesFromZipTaskParameters(List<String> filesToRemove, Charset charset) {
-      super(charset);
+    public RemoveFilesFromZipTaskParameters(List<String> filesToRemove, Zip4jConfig zip4jConfig) {
+      super(zip4jConfig);
       this.filesToRemove = filesToRemove;
     }
   }
diff --git a/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
index 6323093..c98b28d 100644
--- a/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
@@ -5,6 +5,7 @@ import net.lingala.zip4j.headers.HeaderUtil;
 import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.io.outputstream.SplitOutputStream;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.enums.RandomAccessFileMode;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -26,14 +27,12 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
   private ZipModel zipModel;
   private HeaderWriter headerWriter;
   private RawIO rawIO;
-  private Charset charset;
 
-  public RenameFilesTask(ZipModel zipModel, HeaderWriter headerWriter, RawIO rawIO, Charset charset, AsyncTaskParameters asyncTaskParameters) {
+  public RenameFilesTask(ZipModel zipModel, HeaderWriter headerWriter, RawIO rawIO, AsyncTaskParameters asyncTaskParameters) {
     super(asyncTaskParameters);
     this.zipModel = zipModel;
     this.headerWriter = headerWriter;
     this.rawIO = rawIO;
-    this.charset = charset;
   }
 
   @Override
@@ -49,6 +48,7 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
         SplitOutputStream outputStream = new SplitOutputStream(temporaryFile)) {
 
       long currentFileCopyPointer = 0;
+      Charset charset = taskParameters.zip4jConfig.getCharset();
 
       // Maintain a different list to iterate, so that when the file name is changed in the central directory
       // we still have access to the original file names. If iterating on the original list from central directory,
@@ -64,14 +64,15 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
         long lengthToCopy = getOffsetOfNextEntry(sortedFileHeaders, fileHeader, zipModel) - outputStream.getFilePointer();
         if (fileNameMapForThisEntry == null) {
           // copy complete entry without any changes
-          currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, lengthToCopy, progressMonitor);
+          currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, lengthToCopy,
+              progressMonitor, taskParameters.zip4jConfig.getBufferSize());
         } else {
           String newFileName = getNewFileName(fileNameMapForThisEntry.getValue(), fileNameMapForThisEntry.getKey(), fileHeader.getFileName());
           byte[] newFileNameBytes = HeaderUtil.getBytesFromString(newFileName, charset);
           int headersOffset = newFileNameBytes.length - fileHeader.getFileNameLength();
 
           currentFileCopyPointer = copyEntryAndChangeFileName(newFileNameBytes, fileHeader, currentFileCopyPointer, lengthToCopy,
-              inputStream, outputStream, progressMonitor);
+              inputStream, outputStream, progressMonitor, taskParameters.zip4jConfig.getBufferSize());
 
           updateHeadersInZipModel(sortedFileHeaders, fileHeader, newFileName, newFileNameBytes, headersOffset);
         }
@@ -99,15 +100,15 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
 
   private long copyEntryAndChangeFileName(byte[] newFileNameBytes, FileHeader fileHeader, long start, long totalLengthOfEntry,
                                           RandomAccessFile inputStream, OutputStream outputStream,
-                                          ProgressMonitor progressMonitor) throws IOException {
+                                          ProgressMonitor progressMonitor, int bufferSize) throws IOException {
     long currentFileCopyPointer = start;
 
-    currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, 26, progressMonitor); // 26 is offset until file name length
+    currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, 26, progressMonitor, bufferSize); // 26 is offset until file name length
 
     rawIO.writeShortLittleEndian(outputStream, newFileNameBytes.length);
 
     currentFileCopyPointer += 2; // length of file name length
-    currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, 2, progressMonitor); // 2 is for length of extra field length
+    currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, 2, progressMonitor, bufferSize); // 2 is for length of extra field length
 
     outputStream.write(newFileNameBytes);
     currentFileCopyPointer += fileHeader.getFileNameLength();
@@ -115,7 +116,7 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
     long remainingLengthToCopy = totalLengthOfEntry - (currentFileCopyPointer - start);
 
     currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer,
-       remainingLengthToCopy, progressMonitor);
+       remainingLengthToCopy, progressMonitor, bufferSize);
 
     return currentFileCopyPointer;
   }
@@ -195,10 +196,11 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
     throw new ZipException("old file name was neither an exact match nor a partial match");
   }
 
-  public static class RenameFilesTaskParameters {
+  public static class RenameFilesTaskParameters extends AbstractZipTaskParameters {
     private Map<String, String> fileNamesMap;
 
-    public RenameFilesTaskParameters(Map<String, String> fileNamesMap) {
+    public RenameFilesTaskParameters(Map<String, String> fileNamesMap, Zip4jConfig zip4jConfig) {
+      super(zip4jConfig);
       this.fileNamesMap = fileNamesMap;
     }
   }
diff --git a/src/main/java/net/lingala/zip4j/tasks/SetCommentTask.java b/src/main/java/net/lingala/zip4j/tasks/SetCommentTask.java
index 5498088..a5c4008 100644
--- a/src/main/java/net/lingala/zip4j/tasks/SetCommentTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/SetCommentTask.java
@@ -4,12 +4,12 @@ import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.io.outputstream.SplitOutputStream;
 import net.lingala.zip4j.model.EndOfCentralDirectoryRecord;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.SetCommentTask.SetCommentTaskTaskParameters;
 
 import java.io.IOException;
-import java.nio.charset.Charset;
 
 public class SetCommentTask extends AsyncZipTask<SetCommentTaskTaskParameters> {
 
@@ -38,7 +38,7 @@ public class SetCommentTask extends AsyncZipTask<SetCommentTaskTaskParameters> {
       }
 
       HeaderWriter headerWriter = new HeaderWriter();
-      headerWriter.finalizeZipFileWithoutValidations(zipModel, outputStream, taskParameters.charset);
+      headerWriter.finalizeZipFileWithoutValidations(zipModel, outputStream, taskParameters.zip4jConfig.getCharset());
     }
   }
 
@@ -55,8 +55,8 @@ public class SetCommentTask extends AsyncZipTask<SetCommentTaskTaskParameters> {
   public static class SetCommentTaskTaskParameters extends AbstractZipTaskParameters {
     private String comment;
 
-    public SetCommentTaskTaskParameters(String comment, Charset charset) {
-      super(charset);
+    public SetCommentTaskTaskParameters(String comment, Zip4jConfig zip4jConfig) {
+      super(zip4jConfig);
       this.comment = comment;
     }
   }
diff --git a/src/main/java/net/lingala/zip4j/util/FileUtils.java b/src/main/java/net/lingala/zip4j/util/FileUtils.java
index 451a78b..c9a1ba5 100644
--- a/src/main/java/net/lingala/zip4j/util/FileUtils.java
+++ b/src/main/java/net/lingala/zip4j/util/FileUtils.java
@@ -35,7 +35,6 @@ import static java.nio.file.attribute.PosixFilePermission.OWNER_READ;
 import static java.nio.file.attribute.PosixFilePermission.OWNER_WRITE;
 import static net.lingala.zip4j.util.BitUtils.isBitSet;
 import static net.lingala.zip4j.util.BitUtils.setBit;
-import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
 import static net.lingala.zip4j.util.InternalZipConstants.FILE_SEPARATOR;
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP_FILE_SEPARATOR;
 import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;
@@ -289,7 +288,7 @@ public class FileUtils {
   }
 
   public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end,
-                              ProgressMonitor progressMonitor) throws ZipException {
+                              ProgressMonitor progressMonitor, int bufferSize) throws ZipException {
 
     if (start < 0 || end < 0 || start > end) {
       throw new ZipException("invalid offsets");
@@ -307,10 +306,10 @@ public class FileUtils {
       long bytesRead = 0;
       long bytesToRead = end - start;
 
-      if ((end - start) < BUFF_SIZE) {
+      if ((end - start) < bufferSize) {
         buff = new byte[(int) bytesToRead];
       } else {
-        buff = new byte[BUFF_SIZE];
+        buff = new byte[bufferSize];
       }
 
       while ((readLen = randomAccessFile.read(buff)) != -1) {
diff --git a/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java b/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
index b79184b..c1d82a2 100755
--- a/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
+++ b/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
@@ -42,6 +42,7 @@ public final class InternalZipConstants {
   public static final int ZIP_64_NUMBER_OF_ENTRIES_LIMIT = 65535;
 
   public static final int BUFF_SIZE = 1024 * 4;
+  public static final int MIN_BUFF_SIZE = 512;
 
   // Update local file header constants
   // This value holds the number of bytes to skip from
diff --git a/src/test/java/net/lingala/zip4j/AbstractIT.java b/src/test/java/net/lingala/zip4j/AbstractIT.java
index e4266b2..aa37d43 100644
--- a/src/test/java/net/lingala/zip4j/AbstractIT.java
+++ b/src/test/java/net/lingala/zip4j/AbstractIT.java
@@ -1,10 +1,12 @@
 package net.lingala.zip4j;
 
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.testutils.TestUtils;
+import net.lingala.zip4j.util.InternalZipConstants;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.rules.TemporaryFolder;
@@ -79,4 +81,16 @@ public abstract class AbstractIT {
 
     Arrays.stream(filesInOutputFolder).forEach(File::delete);
   }
+
+  protected Zip4jConfig buildDefaultConfig() {
+    return buildConfig(null);
+  }
+
+  protected Zip4jConfig buildConfig(Charset charset) {
+    return new Zip4jConfig(charset, InternalZipConstants.BUFF_SIZE);
+  }
+
+  protected Zip4jConfig buildConfig(int bufferSize) {
+    return new Zip4jConfig(null, bufferSize);
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index 53f9b77..f48dd7d 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -858,6 +858,16 @@ public class AddFilesToZipIT extends AbstractIT {
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 1);
   }
 
+  @Test
+  public void testAddFolderWithCustomBufferSize() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.setBufferSize(16 * 1024);
+
+    zipFile.addFolder(TestUtils.getTestFileFromResources(""));
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 13);
+  }
+
   private void verifyZipFileContainsFiles(File generatedZipFile, List<String> fileNames,
                                           CompressionMethod compressionMethod, EncryptionMethod encryptionMethod,
                                           AesKeyStrength aesKeyStrength) throws ZipException {
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 094aa0e..1f73af4 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -608,6 +608,20 @@ public class ExtractZipFileIT extends AbstractIT {
     zipFile.extractAll(outputFolder.getPath());
   }
 
+  @Test
+  public void testExtractAllWithCustomBufferSize() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setIncludeRootFolder(false);
+    zipFile.addFolder(getTestFileFromResources(""), zipParameters);
+    zipFile.setBufferSize(32 * 1024);
+
+    zipFile.extractAll(outputFolder.getPath());
+
+    ZipFileVerifier.verifyFolderContentsSameAsSourceFiles(outputFolder);
+    verifyNumberOfFilesInOutputFolder(outputFolder, 10);
+  }
+
   private void addFileToZip(ZipFile zipFile, String fileName, EncryptionMethod encryptionMethod, String password) throws ZipException {
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setEncryptFiles(encryptionMethod != null);
diff --git a/src/test/java/net/lingala/zip4j/ZipFileTest.java b/src/test/java/net/lingala/zip4j/ZipFileTest.java
index 8cea3bd..3b8b2aa 100644
--- a/src/test/java/net/lingala/zip4j/ZipFileTest.java
+++ b/src/test/java/net/lingala/zip4j/ZipFileTest.java
@@ -14,6 +14,7 @@ import java.io.File;
 import java.io.IOException;
 import java.util.Collections;
 
+import static net.lingala.zip4j.util.InternalZipConstants.MIN_BUFF_SIZE;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.reset;
@@ -609,6 +610,14 @@ public class ZipFileTest {
     assertThat(zipFile.toString()).isEqualTo("SOME_PATH");
   }
 
+  @Test
+  public void testSetBufferSizeThrowsExceptionWhenSizeLessThanExpected()  {
+    expectedException.expect(IllegalArgumentException.class);
+    expectedException.expectMessage("Buffer size cannot be less than " + MIN_BUFF_SIZE + " bytes");
+
+    zipFile.setBufferSize(MIN_BUFF_SIZE - 1);
+  }
+
   private File mockFile(boolean fileExists) {
     File file = mock(File.class);
     when(file.exists()).thenReturn(fileExists);
diff --git a/src/test/java/net/lingala/zip4j/ZipFileZip64IT.java b/src/test/java/net/lingala/zip4j/ZipFileZip64IT.java
index c79d645..be1b543 100644
--- a/src/test/java/net/lingala/zip4j/ZipFileZip64IT.java
+++ b/src/test/java/net/lingala/zip4j/ZipFileZip64IT.java
@@ -168,7 +168,7 @@ public class ZipFileZip64IT extends AbstractIT {
   private void verifyZip64HeadersPresent() throws IOException {
     HeaderReader headerReader = new HeaderReader();
     ZipModel zipModel = headerReader.readAllHeaders(new RandomAccessFile(generatedZipFile,
-        RandomAccessFileMode.READ.getValue()), InternalZipConstants.CHARSET_UTF_8);
+        RandomAccessFileMode.READ.getValue()), buildDefaultConfig());
     assertThat(zipModel.getZip64EndOfCentralDirectoryLocator()).isNotNull();
     assertThat(zipModel.getZip64EndOfCentralDirectoryRecord()).isNotNull();
     assertThat(zipModel.isZip64Format()).isTrue();
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderReaderIT.java b/src/test/java/net/lingala/zip4j/headers/HeaderReaderIT.java
index 955d9b7..bb19be3 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderReaderIT.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderReaderIT.java
@@ -47,7 +47,7 @@ public class HeaderReaderIT extends AbstractIT {
     ZipModel actualZipModel = generateZipHeadersFile(numberOfEntries, EncryptionMethod.NONE);
 
     try(RandomAccessFile randomAccessFile = initializeRandomAccessFile(actualZipModel.getZipFile())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 10, false);
       assertThat(readZipModel.getEndOfCentralDirectoryRecord().getComment()).isEmpty();
     }
@@ -61,7 +61,7 @@ public class HeaderReaderIT extends AbstractIT {
     actualZipModel.setZipFile(headersFile);
 
     try(RandomAccessFile randomAccessFile = initializeRandomAccessFile(actualZipModel.getZipFile())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, InternalZipConstants.CHARSET_UTF_8);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 1, false);
 
       EndOfCentralDirectoryRecord endOfCentralDirectoryRecord = readZipModel.getEndOfCentralDirectoryRecord();
@@ -77,7 +77,7 @@ public class HeaderReaderIT extends AbstractIT {
       randomAccessFile.seek(4000);
       randomAccessFile.write(1);
 
-      headerReader.readAllHeaders(randomAccessFile, null);
+      headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       fail("Should throw an exception");
     } catch (ZipException e) {
       assertThat(e.getMessage()).isEqualTo("Zip headers not found. Probably not a zip file");
@@ -92,7 +92,7 @@ public class HeaderReaderIT extends AbstractIT {
       randomAccessFile.seek(1000);
       randomAccessFile.write(1);
 
-      headerReader.readAllHeaders(randomAccessFile, null);
+      headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       fail("Should throw an exception");
     } catch (ZipException e) {
       assertThat(e.getMessage()).isEqualTo("Zip headers not found. Probably not a zip file");
@@ -109,7 +109,7 @@ public class HeaderReaderIT extends AbstractIT {
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(actualZipModel.getZipFile(),
         RandomAccessFileMode.READ.getValue())) {
-      headerReader.readAllHeaders(randomAccessFile, null);
+      headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       fail("Should throw an exception");
     } catch (ZipException e) {
       assertThat(e.getMessage()).isEqualTo("Expected central directory entry not found (#2)");
@@ -126,7 +126,7 @@ public class HeaderReaderIT extends AbstractIT {
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(actualZipModel.getZipFile(),
         RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       FileHeader fileHeader = readZipModel.getCentralDirectory().getFileHeaders().get(0);
       assertThat(fileHeader.getFileName()).isEqualTo("test.txt");
     }
@@ -141,7 +141,7 @@ public class HeaderReaderIT extends AbstractIT {
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(actualZipModel.getZipFile(),
         RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       FileHeader fileHeader = readZipModel.getCentralDirectory().getFileHeaders().get(0);
       assertThat(fileHeader.getFileName()).isNull();
     }
@@ -176,7 +176,7 @@ public class HeaderReaderIT extends AbstractIT {
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(actualZipModel.getZipFile(),
         RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       for (FileHeader fileHeader : readZipModel.getCentralDirectory().getFileHeaders()) {
         assertThat(fileHeader.getAesExtraDataRecord()).isNotNull();
         assertThat(fileHeader.getAesExtraDataRecord().getAesKeyStrength()).isEqualTo(AesKeyStrength.KEY_STRENGTH_256);
@@ -190,7 +190,7 @@ public class HeaderReaderIT extends AbstractIT {
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(actualZipModel.getZipFile(),
         RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       for (FileHeader fileHeader : readZipModel.getCentralDirectory().getFileHeaders()) {
         assertThat(fileHeader.isEncrypted()).isTrue();
         assertThat(fileHeader.getEncryptionMethod()).isEqualTo(EncryptionMethod.ZIP_STANDARD);
@@ -210,7 +210,7 @@ public class HeaderReaderIT extends AbstractIT {
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(actualZipModel.getZipFile(),
         RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       assertThat(readZipModel.isZip64Format()).isTrue();
       assertThat(readZipModel.getZip64EndOfCentralDirectoryRecord()).isNotNull();
       assertThat(readZipModel.getZip64EndOfCentralDirectoryLocator()).isNotNull();
@@ -278,7 +278,7 @@ public class HeaderReaderIT extends AbstractIT {
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(actualZipModel.getZipFile(),
         RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, charsetToUseForReading);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildConfig(charsetToUseForReading));
       FileHeader fileHeader = readZipModel.getCentralDirectory().getFileHeaders().get(1);
       if (shouldFileNamesMatch) {
         assertThat(fileHeader.getFileName()).isEqualTo(fileName);
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
index 999b830..8249878 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
@@ -218,7 +218,7 @@ public class HeaderWriterIT extends AbstractIT {
     }
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(headersFile, RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 10);
 
       for (FileHeader fileHeader : readZipModel.getCentralDirectory().getFileHeaders()) {
@@ -249,7 +249,7 @@ public class HeaderWriterIT extends AbstractIT {
     }
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(headersFile, RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 10, COMPRESSED_SIZE_ZIP64, UNCOMPRESSED_SIZE_ZIP64, true);
 
       List<FileHeader> fileHeaders = readZipModel.getCentralDirectory().getFileHeaders();
@@ -272,7 +272,7 @@ public class HeaderWriterIT extends AbstractIT {
     }
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(headersFile, RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 10);
 
       for (FileHeader fileHeader : readZipModel.getCentralDirectory().getFileHeaders()) {
@@ -294,7 +294,7 @@ public class HeaderWriterIT extends AbstractIT {
     }
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(headersFile, RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 10, COMPRESSED_SIZE_ZIP64, UNCOMPRESSED_SIZE_ZIP64, true);
 
       List<FileHeader> fileHeaders = readZipModel.getCentralDirectory().getFileHeaders();
@@ -316,7 +316,7 @@ public class HeaderWriterIT extends AbstractIT {
     }
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(headersFile, RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 10, COMPRESSED_SIZE_ZIP64, UNCOMPRESSED_SIZE_ZIP64, true);
 
       List<FileHeader> fileHeaders = readZipModel.getCentralDirectory().getFileHeaders();
@@ -355,7 +355,7 @@ public class HeaderWriterIT extends AbstractIT {
     }
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(headersFile, RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, InternalZipConstants.CHARSET_UTF_8);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 10);
 
       for (FileHeader fileHeader : readZipModel.getCentralDirectory().getFileHeaders()) {
@@ -376,7 +376,7 @@ public class HeaderWriterIT extends AbstractIT {
     }
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(headersFile, RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, InternalZipConstants.CHARSET_UTF_8);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 10, COMPRESSED_SIZE_ZIP64, UNCOMPRESSED_SIZE_ZIP64, true);
 
       List<FileHeader> fileHeaders = readZipModel.getCentralDirectory().getFileHeaders();
@@ -445,7 +445,7 @@ public class HeaderWriterIT extends AbstractIT {
     }
 
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(headersFile, RandomAccessFileMode.READ.getValue())) {
-      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, null);
+      ZipModel readZipModel = headerReader.readAllHeaders(randomAccessFile, buildDefaultConfig());
       verifyZipModel(readZipModel, 10);
 
       for (int i = 0; i < zipModel.getCentralDirectory().getFileHeaders().size(); i++) {
diff --git a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
index 9bc316c..96a1734 100644
--- a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
@@ -4,6 +4,7 @@ import net.lingala.zip4j.AbstractIT;
 import net.lingala.zip4j.ZipFile;
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.LocalFileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
 import net.lingala.zip4j.model.enums.AesVersion;
@@ -14,6 +15,7 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
+import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -30,6 +32,7 @@ import java.util.zip.ZipOutputStream;
 
 import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
 import static net.lingala.zip4j.testutils.ZipFileVerifier.verifyFileContent;
+import static net.lingala.zip4j.util.InternalZipConstants.MIN_BUFF_SIZE;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class ZipInputStreamIT extends AbstractIT {
@@ -37,6 +40,17 @@ public class ZipInputStreamIT extends AbstractIT {
   @Rule
   public ExpectedException expectedException = ExpectedException.none();
 
+  @Test
+  public void testZipInputStreamConstructorThrowsExceptionWhenBufferSizeIsLessThanExpected() {
+    InputStream inputStream = new ByteArrayInputStream(new byte[1]);
+    Zip4jConfig zip4jConfig = new Zip4jConfig(null, InternalZipConstants.MIN_BUFF_SIZE - 1);
+
+    expectedException.expect(IllegalArgumentException.class);
+    expectedException.expectMessage("Buffer size cannot be less than " + MIN_BUFF_SIZE + " bytes");
+
+    new ZipInputStream(inputStream, null, zip4jConfig);
+  }
+
   @Test
   public void testExtractStoreWithoutEncryption() throws IOException {
     File createdZipFile = createZipFile(CompressionMethod.STORE);
diff --git a/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java b/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
index a0662cf..8b83c5b 100644
--- a/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
@@ -4,6 +4,7 @@ import net.lingala.zip4j.AbstractIT;
 import net.lingala.zip4j.ZipFile;
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.Zip4jConfig;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
 import net.lingala.zip4j.model.enums.AesVersion;
@@ -17,11 +18,13 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
@@ -32,6 +35,7 @@ import static net.lingala.zip4j.testutils.ZipFileVerifier.verifyZipFileByExtract
 import static net.lingala.zip4j.util.FileUtils.isMac;
 import static net.lingala.zip4j.util.FileUtils.isUnix;
 import static net.lingala.zip4j.util.FileUtils.isWindows;
+import static net.lingala.zip4j.util.InternalZipConstants.MIN_BUFF_SIZE;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class ZipOutputStreamIT extends AbstractIT {
@@ -39,6 +43,17 @@ public class ZipOutputStreamIT extends AbstractIT {
   @Rule
   public ExpectedException expectedException = ExpectedException.none();
 
+  @Test
+  public void testConstructorThrowsExceptionWhenBufferSizeIsLessThanExpected() throws IOException {
+    OutputStream outputStream = new ByteArrayOutputStream();
+    Zip4jConfig zip4jConfig = new Zip4jConfig(null, InternalZipConstants.MIN_BUFF_SIZE - 1);
+
+    expectedException.expect(IllegalArgumentException.class);
+    expectedException.expectMessage("Buffer size cannot be less than " + MIN_BUFF_SIZE + " bytes");
+
+    new ZipOutputStream(outputStream, null, zip4jConfig, null);
+  }
+
   @Test
   public void testZipOutputStreamStoreWithoutEncryption() throws IOException {
     testZipOutputStream(CompressionMethod.STORE, false, null, null, null);
diff --git a/src/test/java/net/lingala/zip4j/testutils/ControlledReadInputStream.java b/src/test/java/net/lingala/zip4j/testutils/ControlledReadInputStream.java
index 2452676..166a9e3 100644
--- a/src/test/java/net/lingala/zip4j/testutils/ControlledReadInputStream.java
+++ b/src/test/java/net/lingala/zip4j/testutils/ControlledReadInputStream.java
@@ -32,7 +32,7 @@ public class ControlledReadInputStream extends InputStream {
 
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
-    int toRead = len > readLimit ? readLimit : len;
+    int toRead = Math.min(len, readLimit);
     return inputStream.read(b, off, toRead);
   }
 }
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
index 41752fc..010b046 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
@@ -22,6 +22,7 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
+import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class FileUtilsIT extends AbstractIT {
@@ -52,7 +53,7 @@ public class FileUtilsIT extends AbstractIT {
     File outputFile = temporaryFolder.newFile();
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
         OutputStream outputStream = new FileOutputStream(outputFile)) {
-      FileUtils.copyFile(randomAccessFile, outputStream, 100, 100, progressMonitor);
+      FileUtils.copyFile(randomAccessFile, outputStream, 100, 100, progressMonitor, BUFF_SIZE);
     }
 
     assertThat(outputFile.exists()).isTrue();
@@ -65,7 +66,7 @@ public class FileUtilsIT extends AbstractIT {
     File outputFile = temporaryFolder.newFile();
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
         OutputStream outputStream = new FileOutputStream(outputFile)) {
-      FileUtils.copyFile(randomAccessFile, outputStream, 0, sourceFile.length(), progressMonitor);
+      FileUtils.copyFile(randomAccessFile, outputStream, 0, sourceFile.length(), progressMonitor, BUFF_SIZE);
     }
 
     assertThat(outputFile.length()).isEqualTo(sourceFile.length());
@@ -77,7 +78,7 @@ public class FileUtilsIT extends AbstractIT {
     File outputFile = temporaryFolder.newFile();
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
         OutputStream outputStream = new FileOutputStream(outputFile)) {
-      FileUtils.copyFile(randomAccessFile, outputStream, 500, 800, progressMonitor);
+      FileUtils.copyFile(randomAccessFile, outputStream, 500, 800, progressMonitor, BUFF_SIZE);
     }
 
     assertThat(outputFile.length()).isEqualTo(300);
@@ -194,7 +195,7 @@ public class FileUtilsIT extends AbstractIT {
     File sourceFile = TestUtils.getTestFileFromResources("sample.pdf");
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
         OutputStream outputStream = new FileOutputStream(temporaryFolder.newFile())) {
-      FileUtils.copyFile(randomAccessFile, outputStream, start, offset, progressMonitor);
+      FileUtils.copyFile(randomAccessFile, outputStream, start, offset, progressMonitor, BUFF_SIZE);
     }
   }
 }
\ No newline at end of file
