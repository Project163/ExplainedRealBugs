diff --git a/pom.xml b/pom.xml
index 3dc72c9..7a2b087 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
 
     <groupId>net.lingala.zip4j</groupId>
     <artifactId>zip4j</artifactId>
-    <version>2.0.3</version>
+    <version>2.1.0-SNAPSHOT</version>
 
     <name>Zip4j</name>
     <description>Zip4j - A Java library for zip files and streams</description>
diff --git a/src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java b/src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java
index 7adcb77..3d69b29 100755
--- a/src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java
+++ b/src/main/java/net/lingala/zip4j/crypto/StandardEncrypter.java
@@ -62,19 +62,14 @@ public class StandardEncrypter implements Encrypter {
   }
 
   public int encryptData(byte[] buff, int start, int len) throws ZipException {
-
     if (len < 0) {
       throw new ZipException("invalid length specified to decrpyt data");
     }
 
-    try {
-      for (int i = start; i < start + len; i++) {
-        buff[i] = encryptByte(buff[i]);
-      }
-      return len;
-    } catch (Exception e) {
-      throw new ZipException(e);
+    for (int i = start; i < start + len; i++) {
+      buff[i] = encryptByte(buff[i]);
     }
+    return len;
   }
 
   protected byte encryptByte(byte val) {
diff --git a/src/main/java/net/lingala/zip4j/exception/ZipException.java b/src/main/java/net/lingala/zip4j/exception/ZipException.java
index 55b72b1..b13be2a 100755
--- a/src/main/java/net/lingala/zip4j/exception/ZipException.java
+++ b/src/main/java/net/lingala/zip4j/exception/ZipException.java
@@ -16,7 +16,9 @@
 
 package net.lingala.zip4j.exception;
 
-public class ZipException extends Exception {
+import java.io.IOException;
+
+public class ZipException extends IOException {
 
   private static final long serialVersionUID = 1L;
 
@@ -39,6 +41,11 @@ public class ZipException extends Exception {
     this.type = type;
   }
 
+  public ZipException(Throwable throwable, Type type) {
+    super(throwable);
+    this.type = type;
+  }
+
   public Type getType() {
     return type;
   }
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
index a1860b4..032b465 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
@@ -55,9 +55,14 @@ public class HeaderReader {
   private RawIO rawIO = new RawIO();
   private byte[] intBuff = new byte[4];
 
-  public ZipModel readAllHeaders(RandomAccessFile zip4jRaf) throws ZipException {
+  public ZipModel readAllHeaders(RandomAccessFile zip4jRaf) throws IOException {
     zipModel = new ZipModel();
-    zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO));
+
+    try {
+      zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO));
+    } catch (IOException e) {
+      throw new ZipException("Probably not a zip file or a corrupted zip file", e);
+    }
 
     // If file is Zip64 format, Zip64 headers have to be read before reading central directory
     zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO));
@@ -78,172 +83,164 @@ public class HeaderReader {
   }
 
   private EndOfCentralDirectoryRecord readEndOfCentralDirectoryRecord(RandomAccessFile zip4jRaf, RawIO rawIO)
-      throws ZipException {
-    try {
-      long pos = zip4jRaf.length() - ENDHDR;
-
-      EndOfCentralDirectoryRecord endOfCentralDirectoryRecord = new EndOfCentralDirectoryRecord();
-
-      int counter = 0;
-      int headerSignature;
-      do {
-        zip4jRaf.seek(pos--);
-        counter++;
-      } while (((headerSignature = rawIO.readIntLittleEndian(zip4jRaf))
-          != HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue()) && counter <= 3000);
+      throws IOException {
+    long pos = zip4jRaf.length() - ENDHDR;
 
-      if (headerSignature != HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue()) {
-        throw new ZipException("zip headers not found. probably not a zip file");
-      }
+    EndOfCentralDirectoryRecord endOfCentralDirectoryRecord = new EndOfCentralDirectoryRecord();
 
-      endOfCentralDirectoryRecord.setSignature(HeaderSignature.END_OF_CENTRAL_DIRECTORY);
-      endOfCentralDirectoryRecord.setNumberOfThisDisk(rawIO.readShortLittleEndian(zip4jRaf));
-      endOfCentralDirectoryRecord.setNumberOfThisDiskStartOfCentralDir(rawIO.readShortLittleEndian(zip4jRaf));
-      endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(
-          rawIO.readShortLittleEndian(zip4jRaf));
-      endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectory(rawIO.readShortLittleEndian(zip4jRaf));
-      endOfCentralDirectoryRecord.setSizeOfCentralDirectory(rawIO.readIntLittleEndian(zip4jRaf));
+    int counter = 0;
+    int headerSignature;
+    do {
+      zip4jRaf.seek(pos--);
+      counter++;
+    } while (((headerSignature = rawIO.readIntLittleEndian(zip4jRaf))
+        != HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue()) && counter <= 3000);
+
+    if (headerSignature != HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue()) {
+      throw new ZipException("zip headers not found. probably not a zip file");
+    }
 
-      zip4jRaf.readFully(intBuff);
-      endOfCentralDirectoryRecord.setOffsetOfStartOfCentralDirectory(rawIO.readLongLittleEndian(intBuff, 0));
+    endOfCentralDirectoryRecord.setSignature(HeaderSignature.END_OF_CENTRAL_DIRECTORY);
+    endOfCentralDirectoryRecord.setNumberOfThisDisk(rawIO.readShortLittleEndian(zip4jRaf));
+    endOfCentralDirectoryRecord.setNumberOfThisDiskStartOfCentralDir(rawIO.readShortLittleEndian(zip4jRaf));
+    endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(
+        rawIO.readShortLittleEndian(zip4jRaf));
+    endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectory(rawIO.readShortLittleEndian(zip4jRaf));
+    endOfCentralDirectoryRecord.setSizeOfCentralDirectory(rawIO.readIntLittleEndian(zip4jRaf));
 
-      int commentLength = rawIO.readShortLittleEndian(zip4jRaf);
+    zip4jRaf.readFully(intBuff);
+    endOfCentralDirectoryRecord.setOffsetOfStartOfCentralDirectory(rawIO.readLongLittleEndian(intBuff, 0));
 
-      if (commentLength > 0) {
-        byte[] commentBuf = new byte[commentLength];
-        zip4jRaf.readFully(commentBuf);
-        endOfCentralDirectoryRecord.setComment(new String(commentBuf, StandardCharsets.UTF_8));
-      } else {
-        endOfCentralDirectoryRecord.setComment(null);
-      }
+    int commentLength = rawIO.readShortLittleEndian(zip4jRaf);
 
-      zipModel.setSplitArchive(endOfCentralDirectoryRecord.getNumberOfThisDisk() > 0);
-      return endOfCentralDirectoryRecord;
-    } catch (IOException e) {
-      throw new ZipException("Probably not a zip file or a corrupted zip file", e);
+    if (commentLength > 0) {
+      byte[] commentBuf = new byte[commentLength];
+      zip4jRaf.readFully(commentBuf);
+      endOfCentralDirectoryRecord.setComment(new String(commentBuf, StandardCharsets.UTF_8));
+    } else {
+      endOfCentralDirectoryRecord.setComment(null);
     }
-  }
 
-  private CentralDirectory readCentralDirectory(RandomAccessFile zip4jRaf, RawIO rawIO) throws ZipException {
-    try {
-      CentralDirectory centralDirectory = new CentralDirectory();
-      List<FileHeader> fileHeaders = new ArrayList<>();
+    zipModel.setSplitArchive(endOfCentralDirectoryRecord.getNumberOfThisDisk() > 0);
+    return endOfCentralDirectoryRecord;
+  }
 
-      long offSetStartCentralDir = getOffsetCentralDirectory(zipModel);
-      long centralDirEntryCount = getNumberOfEntriesInCentralDirectory(zipModel);
+  private CentralDirectory readCentralDirectory(RandomAccessFile zip4jRaf, RawIO rawIO) throws IOException {
+    CentralDirectory centralDirectory = new CentralDirectory();
+    List<FileHeader> fileHeaders = new ArrayList<>();
 
-      if (zipModel.isZip64Format()) {
-        offSetStartCentralDir = zipModel.getZip64EndOfCentralDirectoryRecord()
-            .getOffsetStartCentralDirectoryWRTStartDiskNumber();
-        centralDirEntryCount = (int) zipModel.getZip64EndOfCentralDirectoryRecord()
-            .getTotalNumberOfEntriesInCentralDirectory();
-      }
+    long offSetStartCentralDir = getOffsetCentralDirectory(zipModel);
+    long centralDirEntryCount = getNumberOfEntriesInCentralDirectory(zipModel);
 
-      zip4jRaf.seek(offSetStartCentralDir);
+    if (zipModel.isZip64Format()) {
+      offSetStartCentralDir = zipModel.getZip64EndOfCentralDirectoryRecord()
+          .getOffsetStartCentralDirectoryWRTStartDiskNumber();
+      centralDirEntryCount = (int) zipModel.getZip64EndOfCentralDirectoryRecord()
+          .getTotalNumberOfEntriesInCentralDirectory();
+    }
 
-      byte[] shortBuff = new byte[2];
-      byte[] intBuff = new byte[4];
+    zip4jRaf.seek(offSetStartCentralDir);
 
-      for (int i = 0; i < centralDirEntryCount; i++) {
-        FileHeader fileHeader = new FileHeader();
-        if (rawIO.readIntLittleEndian(zip4jRaf) != HeaderSignature.CENTRAL_DIRECTORY.getValue()) {
-          throw new ZipException("Expected central directory entry not found (#" + (i + 1) + ")");
-        }
-        fileHeader.setSignature(HeaderSignature.CENTRAL_DIRECTORY);
-        fileHeader.setVersionMadeBy(rawIO.readShortLittleEndian(zip4jRaf));
-        fileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(zip4jRaf));
+    byte[] shortBuff = new byte[2];
+    byte[] intBuff = new byte[4];
 
-        byte[] generalPurposeFlags = new byte[2];
-        zip4jRaf.readFully(generalPurposeFlags);
-        fileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0));
-        fileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3));
-        fileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3));
-        fileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());
+    for (int i = 0; i < centralDirEntryCount; i++) {
+      FileHeader fileHeader = new FileHeader();
+      if (rawIO.readIntLittleEndian(zip4jRaf) != HeaderSignature.CENTRAL_DIRECTORY.getValue()) {
+        throw new ZipException("Expected central directory entry not found (#" + (i + 1) + ")");
+      }
+      fileHeader.setSignature(HeaderSignature.CENTRAL_DIRECTORY);
+      fileHeader.setVersionMadeBy(rawIO.readShortLittleEndian(zip4jRaf));
+      fileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(zip4jRaf));
 
-        fileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode(rawIO.readShortLittleEndian(
-            zip4jRaf)));
-        fileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(zip4jRaf));
+      byte[] generalPurposeFlags = new byte[2];
+      zip4jRaf.readFully(generalPurposeFlags);
+      fileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0));
+      fileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3));
+      fileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3));
+      fileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());
 
-        zip4jRaf.readFully(intBuff);
-        fileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));
-        fileHeader.setCrcRawData(intBuff);
+      fileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode(rawIO.readShortLittleEndian(
+          zip4jRaf)));
+      fileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(zip4jRaf));
 
-        fileHeader.setCompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));
-        fileHeader.setUncompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));
+      zip4jRaf.readFully(intBuff);
+      fileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));
+      fileHeader.setCrcRawData(intBuff);
 
-        int fileNameLength = rawIO.readShortLittleEndian(zip4jRaf);
-        fileHeader.setFileNameLength(fileNameLength);
+      fileHeader.setCompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));
+      fileHeader.setUncompressedSize(rawIO.readLongLittleEndian(zip4jRaf, 4));
 
-        fileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(zip4jRaf));
+      int fileNameLength = rawIO.readShortLittleEndian(zip4jRaf);
+      fileHeader.setFileNameLength(fileNameLength);
 
-        int fileCommentLength = rawIO.readShortLittleEndian(zip4jRaf);
-        fileHeader.setFileCommentLength(fileCommentLength);
+      fileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(zip4jRaf));
 
-        fileHeader.setDiskNumberStart(rawIO.readShortLittleEndian(zip4jRaf));
+      int fileCommentLength = rawIO.readShortLittleEndian(zip4jRaf);
+      fileHeader.setFileCommentLength(fileCommentLength);
 
-        zip4jRaf.readFully(shortBuff);
-        fileHeader.setInternalFileAttributes(shortBuff.clone());
+      fileHeader.setDiskNumberStart(rawIO.readShortLittleEndian(zip4jRaf));
 
-        zip4jRaf.readFully(intBuff);
-        fileHeader.setExternalFileAttributes(intBuff.clone());
+      zip4jRaf.readFully(shortBuff);
+      fileHeader.setInternalFileAttributes(shortBuff.clone());
 
-        zip4jRaf.readFully(intBuff);
-        fileHeader.setOffsetLocalHeader(rawIO.readLongLittleEndian(intBuff, 0));
+      zip4jRaf.readFully(intBuff);
+      fileHeader.setExternalFileAttributes(intBuff.clone());
 
-        if (fileNameLength > 0) {
-          byte[] fileNameBuff = new byte[fileNameLength];
-          zip4jRaf.readFully(fileNameBuff);
-          String fileName = decodeStringWithCharset(fileNameBuff, fileHeader.isFileNameUTF8Encoded());
+      zip4jRaf.readFully(intBuff);
+      fileHeader.setOffsetLocalHeader(rawIO.readLongLittleEndian(intBuff, 0));
 
-          if (fileName.contains(":\\")) {
-            fileName = fileName.substring(fileName.indexOf(":\\") + 2);
-          }
+      if (fileNameLength > 0) {
+        byte[] fileNameBuff = new byte[fileNameLength];
+        zip4jRaf.readFully(fileNameBuff);
+        String fileName = decodeStringWithCharset(fileNameBuff, fileHeader.isFileNameUTF8Encoded());
 
-          fileHeader.setFileName(fileName);
-          fileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\"));
-        } else {
-          fileHeader.setFileName(null);
+        if (fileName.contains(":\\")) {
+          fileName = fileName.substring(fileName.indexOf(":\\") + 2);
         }
 
-        readExtraDataRecords(zip4jRaf, fileHeader);
-        readZip64ExtendedInfo(fileHeader, rawIO);
-        readAesExtraDataRecord(fileHeader, rawIO);
+        fileHeader.setFileName(fileName);
+        fileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\"));
+      } else {
+        fileHeader.setFileName(null);
+      }
 
-        if (fileCommentLength > 0) {
-          byte[] fileCommentBuff = new byte[fileCommentLength];
-          zip4jRaf.readFully(fileCommentBuff);
-          fileHeader.setFileComment(decodeStringWithCharset(fileCommentBuff, fileHeader.isFileNameUTF8Encoded()));
-        }
+      readExtraDataRecords(zip4jRaf, fileHeader);
+      readZip64ExtendedInfo(fileHeader, rawIO);
+      readAesExtraDataRecord(fileHeader, rawIO);
 
-        if (fileHeader.isEncrypted()) {
-          if (fileHeader.getAesExtraDataRecord() != null) {
-            fileHeader.setEncryptionMethod(EncryptionMethod.AES);
-          } else {
-            fileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD);
-          }
-        }
+      if (fileCommentLength > 0) {
+        byte[] fileCommentBuff = new byte[fileCommentLength];
+        zip4jRaf.readFully(fileCommentBuff);
+        fileHeader.setFileComment(decodeStringWithCharset(fileCommentBuff, fileHeader.isFileNameUTF8Encoded()));
+      }
 
-        fileHeaders.add(fileHeader);
+      if (fileHeader.isEncrypted()) {
+        if (fileHeader.getAesExtraDataRecord() != null) {
+          fileHeader.setEncryptionMethod(EncryptionMethod.AES);
+        } else {
+          fileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD);
+        }
       }
 
-      centralDirectory.setFileHeaders(fileHeaders);
+      fileHeaders.add(fileHeader);
+    }
 
-      DigitalSignature digitalSignature = new DigitalSignature();
-      if (rawIO.readIntLittleEndian(zip4jRaf) == HeaderSignature.DIGITAL_SIGNATURE.getValue()) {
-        digitalSignature.setSignature(HeaderSignature.DIGITAL_SIGNATURE);
-        digitalSignature.setSizeOfData(rawIO.readShortLittleEndian(zip4jRaf));
+    centralDirectory.setFileHeaders(fileHeaders);
 
-        if (digitalSignature.getSizeOfData() > 0) {
-          byte[] signatureDataBuff = new byte[digitalSignature.getSizeOfData()];
-          zip4jRaf.readFully(signatureDataBuff);
-          digitalSignature.setSignatureData(new String(signatureDataBuff));
-        }
-      }
+    DigitalSignature digitalSignature = new DigitalSignature();
+    if (rawIO.readIntLittleEndian(zip4jRaf) == HeaderSignature.DIGITAL_SIGNATURE.getValue()) {
+      digitalSignature.setSignature(HeaderSignature.DIGITAL_SIGNATURE);
+      digitalSignature.setSizeOfData(rawIO.readShortLittleEndian(zip4jRaf));
 
-      return centralDirectory;
-    } catch (IOException e) {
-      throw new ZipException(e);
+      if (digitalSignature.getSizeOfData() > 0) {
+        byte[] signatureDataBuff = new byte[digitalSignature.getSizeOfData()];
+        zip4jRaf.readFully(signatureDataBuff);
+        digitalSignature.setSignatureData(new String(signatureDataBuff));
+      }
     }
+
+    return centralDirectory;
   }
 
   private void readExtraDataRecords(RandomAccessFile zip4jRaf, FileHeader fileHeader)
@@ -316,35 +313,31 @@ public class HeaderReader {
   }
 
   private Zip64EndOfCentralDirectoryLocator readZip64EndOfCentralDirectoryLocator(RandomAccessFile zip4jRaf,
-                                                                                  RawIO rawIO) throws ZipException {
-    try {
-      Zip64EndOfCentralDirectoryLocator zip64EndOfCentralDirectoryLocator = new Zip64EndOfCentralDirectoryLocator();
+                                                                                  RawIO rawIO) throws IOException {
+    Zip64EndOfCentralDirectoryLocator zip64EndOfCentralDirectoryLocator = new Zip64EndOfCentralDirectoryLocator();
 
-      setFilePointerToReadZip64EndCentralDirLoc(zip4jRaf, rawIO);
+    setFilePointerToReadZip64EndCentralDirLoc(zip4jRaf, rawIO);
 
-      int signature = rawIO.readIntLittleEndian(zip4jRaf);
-      if (signature == HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_LOCATOR.getValue()) {
-        zipModel.setZip64Format(true);
-        zip64EndOfCentralDirectoryLocator.setSignature(HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_LOCATOR);
-      } else {
-        zipModel.setZip64Format(false);
-        return null;
-      }
+    int signature = rawIO.readIntLittleEndian(zip4jRaf);
+    if (signature == HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_LOCATOR.getValue()) {
+      zipModel.setZip64Format(true);
+      zip64EndOfCentralDirectoryLocator.setSignature(HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_LOCATOR);
+    } else {
+      zipModel.setZip64Format(false);
+      return null;
+    }
 
-      zip64EndOfCentralDirectoryLocator.setNumberOfDiskStartOfZip64EndOfCentralDirectoryRecord(
-          rawIO.readIntLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryLocator.setOffsetZip64EndOfCentralDirectoryRecord(
-          rawIO.readLongLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryLocator.setTotalNumberOfDiscs(rawIO.readIntLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryLocator.setNumberOfDiskStartOfZip64EndOfCentralDirectoryRecord(
+        rawIO.readIntLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryLocator.setOffsetZip64EndOfCentralDirectoryRecord(
+        rawIO.readLongLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryLocator.setTotalNumberOfDiscs(rawIO.readIntLittleEndian(zip4jRaf));
 
-      return zip64EndOfCentralDirectoryLocator;
-    } catch (IOException e) {
-      throw new ZipException(e);
-    }
+    return zip64EndOfCentralDirectoryLocator;
   }
 
   private Zip64EndOfCentralDirectoryRecord readZip64EndCentralDirRec(RandomAccessFile zip4jRaf, RawIO rawIO)
-      throws ZipException {
+      throws IOException {
 
     if (zipModel.getZip64EndOfCentralDirectoryLocator() == null) {
       throw new ZipException("invalid zip64 end of central directory locator");
@@ -357,41 +350,37 @@ public class HeaderReader {
       throw new ZipException("invalid offset for start of end of central directory record");
     }
 
-    try {
-      zip4jRaf.seek(offSetStartOfZip64CentralDir);
-
-      Zip64EndOfCentralDirectoryRecord zip64EndOfCentralDirectoryRecord = new Zip64EndOfCentralDirectoryRecord();
+    zip4jRaf.seek(offSetStartOfZip64CentralDir);
 
-      int signature = rawIO.readIntLittleEndian(zip4jRaf);
-      if (signature != HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_RECORD.getValue()) {
-        throw new ZipException("invalid signature for zip64 end of central directory record");
-      }
-      zip64EndOfCentralDirectoryRecord.setSignature(HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_RECORD);
-      zip64EndOfCentralDirectoryRecord.setSizeOfZip64EndCentralDirectoryRecord(rawIO.readLongLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryRecord.setVersionMadeBy(rawIO.readShortLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryRecord.setVersionNeededToExtract(rawIO.readShortLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryRecord.setNumberOfThisDisk(rawIO.readIntLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryRecord.setNumberOfThisDiskStartOfCentralDirectory(rawIO.readIntLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(
-          rawIO.readLongLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectory(rawIO.readLongLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryRecord.setSizeOfCentralDirectory(rawIO.readLongLittleEndian(zip4jRaf));
-      zip64EndOfCentralDirectoryRecord.setOffsetStartCentralDirectoryWRTStartDiskNumber(
-          rawIO.readLongLittleEndian(zip4jRaf));
-
-      //zip64 extensible data sector
-      //44 is the size of fixed variables in this record
-      long extDataSecSize = zip64EndOfCentralDirectoryRecord.getSizeOfZip64EndCentralDirectoryRecord() - 44;
-      if (extDataSecSize > 0) {
-        byte[] extDataSecRecBuf = new byte[(int) extDataSecSize];
-        zip4jRaf.readFully(extDataSecRecBuf);
-        zip64EndOfCentralDirectoryRecord.setExtensibleDataSector(extDataSecRecBuf);
-      }
+    Zip64EndOfCentralDirectoryRecord zip64EndOfCentralDirectoryRecord = new Zip64EndOfCentralDirectoryRecord();
 
-      return zip64EndOfCentralDirectoryRecord;
-    } catch (IOException e) {
-      throw new ZipException(e);
+    int signature = rawIO.readIntLittleEndian(zip4jRaf);
+    if (signature != HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_RECORD.getValue()) {
+      throw new ZipException("invalid signature for zip64 end of central directory record");
     }
+    zip64EndOfCentralDirectoryRecord.setSignature(HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_RECORD);
+    zip64EndOfCentralDirectoryRecord.setSizeOfZip64EndCentralDirectoryRecord(rawIO.readLongLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryRecord.setVersionMadeBy(rawIO.readShortLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryRecord.setVersionNeededToExtract(rawIO.readShortLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryRecord.setNumberOfThisDisk(rawIO.readIntLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryRecord.setNumberOfThisDiskStartOfCentralDirectory(rawIO.readIntLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(
+        rawIO.readLongLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectory(rawIO.readLongLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryRecord.setSizeOfCentralDirectory(rawIO.readLongLittleEndian(zip4jRaf));
+    zip64EndOfCentralDirectoryRecord.setOffsetStartCentralDirectoryWRTStartDiskNumber(
+        rawIO.readLongLittleEndian(zip4jRaf));
+
+    //zip64 extensible data sector
+    //44 is the size of fixed variables in this record
+    long extDataSecSize = zip64EndOfCentralDirectoryRecord.getSizeOfZip64EndCentralDirectoryRecord() - 44;
+    if (extDataSecSize > 0) {
+      byte[] extDataSecRecBuf = new byte[(int) extDataSecSize];
+      zip4jRaf.readFully(extDataSecRecBuf);
+      zip64EndOfCentralDirectoryRecord.setExtensibleDataSector(extDataSecRecBuf);
+    }
+
+    return zip64EndOfCentralDirectoryRecord;
   }
 
   private void readZip64ExtendedInfo(FileHeader fileHeader, RawIO rawIO) throws ZipException {
@@ -475,110 +464,102 @@ public class HeaderReader {
     return null;
   }
 
-  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, RawIO rawIO) throws ZipException {
-    try {
-      long pos = zip4jRaf.length() - ENDHDR;
-
-      do {
-        zip4jRaf.seek(pos--);
-      } while (rawIO.readIntLittleEndian(zip4jRaf) != HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue());
-
-      // Now the file pointer is at the end of signature of Central Dir Rec
-      // Seek back with the following values
-      // 4 -> end of central dir signature
-      // 4 -> total number of disks
-      // 8 -> relative offset of the zip64 end of central directory record
-      // 4 -> number of the disk with the start of the zip64 end of central directory
-      // 4 -> zip64 end of central dir locator signature
-      // Refer to Appnote for more information
-      zip4jRaf.seek(zip4jRaf.getFilePointer() - 4 - 4 - 8 - 4 - 4);
-    } catch (IOException e) {
-      throw new ZipException(e);
-    }
+  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, RawIO rawIO) throws IOException {
+    long pos = zip4jRaf.length() - ENDHDR;
+
+    do {
+      zip4jRaf.seek(pos--);
+    } while (rawIO.readIntLittleEndian(zip4jRaf) != HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue());
+
+    // Now the file pointer is at the end of signature of Central Dir Rec
+    // Seek back with the following values
+    // 4 -> end of central dir signature
+    // 4 -> total number of disks
+    // 8 -> relative offset of the zip64 end of central directory record
+    // 4 -> number of the disk with the start of the zip64 end of central directory
+    // 4 -> zip64 end of central dir locator signature
+    // Refer to Appnote for more information
+    zip4jRaf.seek(zip4jRaf.getFilePointer() - 4 - 4 - 8 - 4 - 4);
   }
 
   public LocalFileHeader readLocalFileHeader(InputStream inputStream) throws IOException {
-    try {
-      LocalFileHeader localFileHeader = new LocalFileHeader();
-      byte[] intBuff = new byte[4];
+    LocalFileHeader localFileHeader = new LocalFileHeader();
+    byte[] intBuff = new byte[4];
 
-      //signature
-      int sig = rawIO.readIntLittleEndian(inputStream);
-      if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) {
-        return null;
-      }
-      localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER);
-      localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));
+    //signature
+    int sig = rawIO.readIntLittleEndian(inputStream);
+    if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) {
+      return null;
+    }
+    localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER);
+    localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));
 
-      byte[] generalPurposeFlags = new byte[2];
-      if (inputStream.read(generalPurposeFlags) != 2) {
-        throw new ZipException("Could not read enough bytes for generalPurposeFlags");
-      }
-      localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0));
-      localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3));
-      localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3));
-      localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());
+    byte[] generalPurposeFlags = new byte[2];
+    if (inputStream.read(generalPurposeFlags) != 2) {
+      throw new ZipException("Could not read enough bytes for generalPurposeFlags");
+    }
+    localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0));
+    localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3));
+    localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3));
+    localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());
 
-      localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode(
-          rawIO.readShortLittleEndian(inputStream)));
-      localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));
+    localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode(
+        rawIO.readShortLittleEndian(inputStream)));
+    localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));
 
-      inputStream.read(intBuff);
-      localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));
-      localFileHeader.setCrcRawData(intBuff.clone());
+    inputStream.read(intBuff);
+    localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0));
+    localFileHeader.setCrcRawData(intBuff.clone());
 
-      localFileHeader.setCompressedSize(rawIO.readLongLittleEndian(inputStream, 4));
-      localFileHeader.setUncompressedSize(rawIO.readLongLittleEndian(inputStream, 4));
+    localFileHeader.setCompressedSize(rawIO.readLongLittleEndian(inputStream, 4));
+    localFileHeader.setUncompressedSize(rawIO.readLongLittleEndian(inputStream, 4));
 
-      int fileNameLength = rawIO.readShortLittleEndian(inputStream);
-      localFileHeader.setFileNameLength(fileNameLength);
+    int fileNameLength = rawIO.readShortLittleEndian(inputStream);
+    localFileHeader.setFileNameLength(fileNameLength);
 
-      localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));
+    localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));
 
-      if (fileNameLength > 0) {
-        byte[] fileNameBuf = new byte[fileNameLength];
-        inputStream.read(fileNameBuf);
-        // Modified after user reported an issue http://www.lingala.net/zip4j/forum/index.php?topic=2.0
+    if (fileNameLength > 0) {
+      byte[] fileNameBuf = new byte[fileNameLength];
+      inputStream.read(fileNameBuf);
+      // Modified after user reported an issue http://www.lingala.net/zip4j/forum/index.php?topic=2.0
 //				String fileName = new String(fileNameBuf, "Cp850");
 //				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);
-        String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded());
+      String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded());
 
-        if (fileName == null) {
-          throw new ZipException("file name is null, cannot assign file name to local file header");
-        }
-
-        if (fileName.contains(":" + System.getProperty("file.separator"))) {
-          fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2);
-        }
+      if (fileName == null) {
+        throw new ZipException("file name is null, cannot assign file name to local file header");
+      }
 
-        localFileHeader.setFileName(fileName);
-        localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\"));
-      } else {
-        localFileHeader.setFileName(null);
+      if (fileName.contains(":" + System.getProperty("file.separator"))) {
+        fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2);
       }
 
-      readExtraDataRecords(inputStream, localFileHeader);
-      readZip64ExtendedInfo(localFileHeader, rawIO);
-      readAesExtraDataRecord(localFileHeader, rawIO);
+      localFileHeader.setFileName(fileName);
+      localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\"));
+    } else {
+      localFileHeader.setFileName(null);
+    }
+
+    readExtraDataRecords(inputStream, localFileHeader);
+    readZip64ExtendedInfo(localFileHeader, rawIO);
+    readAesExtraDataRecord(localFileHeader, rawIO);
 
-      if (localFileHeader.isEncrypted()) {
+    if (localFileHeader.isEncrypted()) {
 
-        if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) {
-          //Do nothing
+      if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) {
+        //Do nothing
+      } else {
+        if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) {
+          localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG);
         } else {
-          if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) {
-            localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG);
-          } else {
-            localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD);
-          }
+          localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD);
         }
-
       }
 
-      return localFileHeader;
-    } catch (ZipException e) {
-      throw new IOException(e);
     }
+
+    return localFileHeader;
   }
 
   public DataDescriptor readDataDescriptor(InputStream inputStream, boolean isZip64Format) throws IOException {
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java b/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java
index 38d2533..0a9ef6e 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java
@@ -49,7 +49,7 @@ public class HeaderWriter {
   private byte[] longBuff = new byte[8];
 
   public void writeLocalFileHeader(ZipModel zipModel, LocalFileHeader localFileHeader, OutputStream outputStream)
-      throws ZipException {
+      throws IOException {
 
     try(ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
       rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) localFileHeader.getSignature().getValue());
@@ -137,13 +137,11 @@ public class HeaderWriter {
       }
 
       outputStream.write(byteArrayOutputStream.toByteArray());
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
   }
 
   public void writeExtendedLocalHeader(LocalFileHeader localFileHeader, OutputStream outputStream)
-      throws ZipException, IOException {
+      throws IOException {
 
     if (localFileHeader == null || outputStream == null) {
       throw new ZipException("input parameters is null, cannot write extended local header");
@@ -170,7 +168,7 @@ public class HeaderWriter {
     }
   }
 
-  public void finalizeZipFile(ZipModel zipModel, OutputStream outputStream) throws ZipException {
+  public void finalizeZipFile(ZipModel zipModel, OutputStream outputStream) throws IOException {
     if (zipModel == null || outputStream == null) {
       throw new ZipException("input parameters is null, cannot finalize zip file");
     }
@@ -211,12 +209,10 @@ public class HeaderWriter {
 
       writeEndOfCentralDirectoryRecord(zipModel, sizeOfCentralDir, offsetCentralDir, byteArrayOutputStream, rawIO);
       writeZipHeaderBytes(zipModel, outputStream, byteArrayOutputStream.toByteArray());
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
   }
 
-  public void finalizeZipFileWithoutValidations(ZipModel zipModel, OutputStream outputStream) throws ZipException {
+  public void finalizeZipFileWithoutValidations(ZipModel zipModel, OutputStream outputStream) throws IOException {
 
     if (zipModel == null || outputStream == null) {
       throw new ZipException("input parameters is null, cannot finalize zip file without validations");
@@ -247,88 +243,77 @@ public class HeaderWriter {
 
       writeEndOfCentralDirectoryRecord(zipModel, sizeOfCentralDir, offsetCentralDir, byteArrayOutputStream, rawIO);
       writeZipHeaderBytes(zipModel, outputStream, byteArrayOutputStream.toByteArray());
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
   }
 
   public void updateLocalFileHeader(FileHeader fileHeader, ZipModel zipModel, SplitOutputStream outputStream)
-      throws ZipException {
+      throws IOException {
 
     if (fileHeader == null || zipModel == null) {
       throw new ZipException("invalid input parameters, cannot update local file header");
     }
 
-    try {
-      boolean closeFlag = false;
-      SplitOutputStream currOutputStream;
-
-      if (fileHeader.getDiskNumberStart() != outputStream.getCurrentSplitFileCounter()) {
-        String parentFile = zipModel.getZipFile().getParent();
-        String fileNameWithoutExt = getZipFileNameWithoutExtension(zipModel.getZipFile().getName());
-        String fileName = parentFile + System.getProperty("file.separator");
-        if (fileHeader.getDiskNumberStart() < 9) {
-          fileName += fileNameWithoutExt + ".z0" + (fileHeader.getDiskNumberStart() + 1);
-        } else {
-          fileName += fileNameWithoutExt + ".z" + (fileHeader.getDiskNumberStart() + 1);
-        }
-        currOutputStream = new SplitOutputStream(new File(fileName));
-        closeFlag = true;
+    boolean closeFlag = false;
+    SplitOutputStream currOutputStream;
+
+    if (fileHeader.getDiskNumberStart() != outputStream.getCurrentSplitFileCounter()) {
+      String parentFile = zipModel.getZipFile().getParent();
+      String fileNameWithoutExt = getZipFileNameWithoutExtension(zipModel.getZipFile().getName());
+      String fileName = parentFile + System.getProperty("file.separator");
+      if (fileHeader.getDiskNumberStart() < 9) {
+        fileName += fileNameWithoutExt + ".z0" + (fileHeader.getDiskNumberStart() + 1);
       } else {
-        currOutputStream = outputStream;
+        fileName += fileNameWithoutExt + ".z" + (fileHeader.getDiskNumberStart() + 1);
       }
+      currOutputStream = new SplitOutputStream(new File(fileName));
+      closeFlag = true;
+    } else {
+      currOutputStream = outputStream;
+    }
 
-      long currOffset = currOutputStream.getFilePointer();
+    long currOffset = currOutputStream.getFilePointer();
 
-      currOutputStream.seek(fileHeader.getOffsetLocalHeader() + InternalZipConstants.UPDATE_LFH_CRC);
-      rawIO.writeLongLittleEndian(longBuff, 0, fileHeader.getCrc());
-      currOutputStream.write(longBuff, 0, 4);
+    currOutputStream.seek(fileHeader.getOffsetLocalHeader() + InternalZipConstants.UPDATE_LFH_CRC);
+    rawIO.writeLongLittleEndian(longBuff, 0, fileHeader.getCrc());
+    currOutputStream.write(longBuff, 0, 4);
 
-      updateFileSizesInLocalFileHeader(currOutputStream, fileHeader);
+    updateFileSizesInLocalFileHeader(currOutputStream, fileHeader);
 
-      if (closeFlag) {
-        currOutputStream.close();
-      } else {
-        outputStream.seek(currOffset);
-      }
-    } catch (IOException e) {
-      throw new ZipException(e);
+    if (closeFlag) {
+      currOutputStream.close();
+    } else {
+      outputStream.seek(currOffset);
     }
   }
 
   private void updateFileSizesInLocalFileHeader(SplitOutputStream outputStream, FileHeader fileHeader)
-      throws ZipException {
-
-    try {
-      if (fileHeader.getUncompressedSize() >= ZIP_64_SIZE_LIMIT) {
-        rawIO.writeLongLittleEndian(longBuff, 0, ZIP_64_SIZE_LIMIT);
-        outputStream.write(longBuff, 0, 4);
-        outputStream.write(longBuff, 0, 4);
-
-        //2 - file name length
-        //2 - extra field length
-        //variable - file name which can be determined by fileNameLength
-        //2 - Zip64 signature
-        //2 - size of zip64 data
-        //8 - uncompressed size
-        //8 - compressed size
-        int zip64CompressedSizeOffset = 2 + 2 + fileHeader.getFileNameLength() + 2 + 2 + 2;
-        if (outputStream.skipBytes(zip64CompressedSizeOffset) != zip64CompressedSizeOffset) {
-          throw new ZipException("Unable to skip " + zip64CompressedSizeOffset + " bytes to update LFH");
-        }
-        rawIO.writeLongLittleEndian(outputStream, fileHeader.getUncompressedSize());
-        rawIO.writeLongLittleEndian(outputStream, fileHeader.getCompressedSize());
-      } else {
-        rawIO.writeLongLittleEndian(longBuff, 0, fileHeader.getCompressedSize());
-        outputStream.write(longBuff, 0, 4);
-
-        rawIO.writeLongLittleEndian(longBuff, 0, fileHeader.getUncompressedSize());
-        outputStream.write(longBuff, 0, 4);
-      }
-    } catch (IOException e) {
-      throw new ZipException(e);
+      throws IOException {
+
+    if (fileHeader.getUncompressedSize() >= ZIP_64_SIZE_LIMIT) {
+      rawIO.writeLongLittleEndian(longBuff, 0, ZIP_64_SIZE_LIMIT);
+      outputStream.write(longBuff, 0, 4);
+      outputStream.write(longBuff, 0, 4);
+
+      //2 - file name length
+      //2 - extra field length
+      //variable - file name which can be determined by fileNameLength
+      //2 - Zip64 signature
+      //2 - size of zip64 data
+      //8 - uncompressed size
+      //8 - compressed size
+      int zip64CompressedSizeOffset = 2 + 2 + fileHeader.getFileNameLength() + 2 + 2 + 2;
+      if (outputStream.skipBytes(zip64CompressedSizeOffset) != zip64CompressedSizeOffset) {
+        throw new ZipException("Unable to skip " + zip64CompressedSizeOffset + " bytes to update LFH");
+      }
+      rawIO.writeLongLittleEndian(outputStream, fileHeader.getUncompressedSize());
+      rawIO.writeLongLittleEndian(outputStream, fileHeader.getCompressedSize());
+    } else {
+      rawIO.writeLongLittleEndian(longBuff, 0, fileHeader.getCompressedSize());
+      outputStream.write(longBuff, 0, 4);
+
+      rawIO.writeLongLittleEndian(longBuff, 0, fileHeader.getUncompressedSize());
+      outputStream.write(longBuff, 0, 4);
     }
-
   }
 
   private boolean isSplitZipFile(OutputStream outputStream) {
@@ -348,53 +333,44 @@ public class HeaderWriter {
     return ((CountingOutputStream) outputStream).getCurrentSplitFileCounter();
   }
 
-  private void writeZipHeaderBytes(ZipModel zipModel, OutputStream outputStream, byte[] buff)
-      throws ZipException {
+  private void writeZipHeaderBytes(ZipModel zipModel, OutputStream outputStream, byte[] buff) throws IOException {
     if (buff == null) {
       throw new ZipException("invalid buff to write as zip headers");
     }
 
-    try {
-      if (outputStream instanceof CountingOutputStream) {
-        if (((CountingOutputStream) outputStream).checkBuffSizeAndStartNextSplitFile(buff.length)) {
-          //TODO check if this is correct
-          finalizeZipFile(zipModel, outputStream);
-          return;
-        }
+    if (outputStream instanceof CountingOutputStream) {
+      if (((CountingOutputStream) outputStream).checkBuffSizeAndStartNextSplitFile(buff.length)) {
+        //TODO check if this is correct
+        finalizeZipFile(zipModel, outputStream);
+        return;
       }
-
-      outputStream.write(buff);
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
-  }
 
-  private void processHeaderData(ZipModel zipModel, OutputStream outputStream) throws ZipException {
-    try {
-      int currentSplitFileCounter = 0;
-      if (outputStream instanceof CountingOutputStream) {
-        zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(
-            ((CountingOutputStream) outputStream).getFilePointer());
-        currentSplitFileCounter = ((CountingOutputStream) outputStream).getCurrentSplitFileCounter();
-      }
+    outputStream.write(buff);
+  }
 
-      if (zipModel.isZip64Format()) {
-        if (zipModel.getZip64EndOfCentralDirectoryRecord() == null) {
-          zipModel.setZip64EndOfCentralDirectoryRecord(new Zip64EndOfCentralDirectoryRecord());
-        }
-        if (zipModel.getZip64EndOfCentralDirectoryLocator() == null) {
-          zipModel.setZip64EndOfCentralDirectoryLocator(new Zip64EndOfCentralDirectoryLocator());
-        }
+  private void processHeaderData(ZipModel zipModel, OutputStream outputStream) throws IOException {
+    int currentSplitFileCounter = 0;
+    if (outputStream instanceof CountingOutputStream) {
+      zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(
+          ((CountingOutputStream) outputStream).getFilePointer());
+      currentSplitFileCounter = ((CountingOutputStream) outputStream).getCurrentSplitFileCounter();
+    }
 
-        zipModel.getZip64EndOfCentralDirectoryLocator().setNumberOfDiskStartOfZip64EndOfCentralDirectoryRecord(
-            currentSplitFileCounter);
-        zipModel.getZip64EndOfCentralDirectoryLocator().setTotalNumberOfDiscs(currentSplitFileCounter + 1);
+    if (zipModel.isZip64Format()) {
+      if (zipModel.getZip64EndOfCentralDirectoryRecord() == null) {
+        zipModel.setZip64EndOfCentralDirectoryRecord(new Zip64EndOfCentralDirectoryRecord());
       }
-      zipModel.getEndOfCentralDirectoryRecord().setNumberOfThisDisk(currentSplitFileCounter);
-      zipModel.getEndOfCentralDirectoryRecord().setNumberOfThisDiskStartOfCentralDir(currentSplitFileCounter);
-    } catch (IOException e) {
-      throw new ZipException(e);
+      if (zipModel.getZip64EndOfCentralDirectoryLocator() == null) {
+        zipModel.setZip64EndOfCentralDirectoryLocator(new Zip64EndOfCentralDirectoryLocator());
+      }
+
+      zipModel.getZip64EndOfCentralDirectoryLocator().setNumberOfDiskStartOfZip64EndOfCentralDirectoryRecord(
+          currentSplitFileCounter);
+      zipModel.getZip64EndOfCentralDirectoryLocator().setTotalNumberOfDiscs(currentSplitFileCounter + 1);
     }
+    zipModel.getEndOfCentralDirectoryRecord().setNumberOfThisDisk(currentSplitFileCounter);
+    zipModel.getEndOfCentralDirectoryRecord().setNumberOfThisDiskStartOfCentralDir(currentSplitFileCounter);
   }
 
   private void writeCentralDirectory(ZipModel zipModel, ByteArrayOutputStream byteArrayOutputStream, RawIO rawIO)
@@ -541,114 +517,101 @@ public class HeaderWriter {
 
   private void writeZip64EndOfCentralDirectoryRecord(ZipModel zipModel, int sizeOfCentralDir, long offsetCentralDir,
                                                      ByteArrayOutputStream byteArrayOutputStream, RawIO rawIO)
-      throws ZipException {
+      throws IOException {
 
-    try {
-      byte[] emptyShortByte = {0, 0};
+    byte[] emptyShortByte = {0, 0};
 
-      rawIO.writeIntLittleEndian(byteArrayOutputStream,
-          (int) HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_RECORD.getValue());
-      rawIO.writeLongLittleEndian(byteArrayOutputStream, (long) 44);
+    rawIO.writeIntLittleEndian(byteArrayOutputStream,
+        (int) HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_RECORD.getValue());
+    rawIO.writeLongLittleEndian(byteArrayOutputStream, (long) 44);
 
-      if (zipModel.getCentralDirectory() != null &&
-          zipModel.getCentralDirectory().getFileHeaders() != null &&
-          zipModel.getCentralDirectory().getFileHeaders().size() > 0) {
-        rawIO.writeShortLittleEndian(byteArrayOutputStream,
-            zipModel.getCentralDirectory().getFileHeaders().get(0).getVersionMadeBy());
+    if (zipModel.getCentralDirectory() != null &&
+        zipModel.getCentralDirectory().getFileHeaders() != null &&
+        zipModel.getCentralDirectory().getFileHeaders().size() > 0) {
+      rawIO.writeShortLittleEndian(byteArrayOutputStream,
+          zipModel.getCentralDirectory().getFileHeaders().get(0).getVersionMadeBy());
 
-        rawIO.writeShortLittleEndian(byteArrayOutputStream,
-            zipModel.getCentralDirectory().getFileHeaders().get(0).getVersionNeededToExtract());
-      } else {
-        byteArrayOutputStream.write(emptyShortByte);
-        byteArrayOutputStream.write(emptyShortByte);
-      }
+      rawIO.writeShortLittleEndian(byteArrayOutputStream,
+          zipModel.getCentralDirectory().getFileHeaders().get(0).getVersionNeededToExtract());
+    } else {
+      byteArrayOutputStream.write(emptyShortByte);
+      byteArrayOutputStream.write(emptyShortByte);
+    }
 
-      rawIO.writeIntLittleEndian(byteArrayOutputStream,
-          zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
-      rawIO.writeIntLittleEndian(byteArrayOutputStream, zipModel.getEndOfCentralDirectoryRecord()
-          .getNumberOfThisDiskStartOfCentralDir());
-
-      long numEntries = zipModel.getCentralDirectory().getFileHeaders().size();
-      long numEntriesOnThisDisk = numEntries;
-      if (zipModel.isSplitArchive()) {
-        numEntriesOnThisDisk = countNumberOfFileHeaderEntriesOnDisk(zipModel.getCentralDirectory().getFileHeaders(),
-            zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
-      }
+    rawIO.writeIntLittleEndian(byteArrayOutputStream,
+        zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
+    rawIO.writeIntLittleEndian(byteArrayOutputStream, zipModel.getEndOfCentralDirectoryRecord()
+        .getNumberOfThisDiskStartOfCentralDir());
 
-      rawIO.writeLongLittleEndian(byteArrayOutputStream, numEntriesOnThisDisk);
-      rawIO.writeLongLittleEndian(byteArrayOutputStream, numEntries);
-      rawIO.writeLongLittleEndian(byteArrayOutputStream, sizeOfCentralDir);
-      rawIO.writeLongLittleEndian(byteArrayOutputStream, offsetCentralDir);
-    } catch (ZipException zipException) {
-      throw zipException;
-    } catch (Exception e) {
-      throw new ZipException(e);
+    long numEntries = zipModel.getCentralDirectory().getFileHeaders().size();
+    long numEntriesOnThisDisk = numEntries;
+    if (zipModel.isSplitArchive()) {
+      numEntriesOnThisDisk = countNumberOfFileHeaderEntriesOnDisk(zipModel.getCentralDirectory().getFileHeaders(),
+          zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
     }
+
+    rawIO.writeLongLittleEndian(byteArrayOutputStream, numEntriesOnThisDisk);
+    rawIO.writeLongLittleEndian(byteArrayOutputStream, numEntries);
+    rawIO.writeLongLittleEndian(byteArrayOutputStream, sizeOfCentralDir);
+    rawIO.writeLongLittleEndian(byteArrayOutputStream, offsetCentralDir);
   }
 
   private void writeZip64EndOfCentralDirectoryLocator(ZipModel zipModel, ByteArrayOutputStream byteArrayOutputStream,
-                                                      RawIO rawIO) throws ZipException {
-    try {
-      rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_LOCATOR.getValue());
-      rawIO.writeIntLittleEndian(byteArrayOutputStream,
-          zipModel.getZip64EndOfCentralDirectoryLocator().getNumberOfDiskStartOfZip64EndOfCentralDirectoryRecord());
-      rawIO.writeLongLittleEndian(byteArrayOutputStream,
-          zipModel.getZip64EndOfCentralDirectoryLocator().getOffsetZip64EndOfCentralDirectoryRecord());
-      rawIO.writeIntLittleEndian(byteArrayOutputStream,
-          zipModel.getZip64EndOfCentralDirectoryLocator().getTotalNumberOfDiscs());
-    } catch (IOException e) {
-      throw new ZipException(e);
-    }
+                                                      RawIO rawIO) throws IOException {
+    rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) HeaderSignature.ZIP64_END_CENTRAL_DIRECTORY_LOCATOR.getValue());
+    rawIO.writeIntLittleEndian(byteArrayOutputStream,
+        zipModel.getZip64EndOfCentralDirectoryLocator().getNumberOfDiskStartOfZip64EndOfCentralDirectoryRecord());
+    rawIO.writeLongLittleEndian(byteArrayOutputStream,
+        zipModel.getZip64EndOfCentralDirectoryLocator().getOffsetZip64EndOfCentralDirectoryRecord());
+    rawIO.writeIntLittleEndian(byteArrayOutputStream,
+        zipModel.getZip64EndOfCentralDirectoryLocator().getTotalNumberOfDiscs());
+
   }
 
   private void writeEndOfCentralDirectoryRecord(ZipModel zipModel, int sizeOfCentralDir, long offsetCentralDir,
                                                 ByteArrayOutputStream byteArrayOutputStream, RawIO rawIO)
-      throws ZipException {
-
-    try {
-      byte[] longByte = new byte[8];
-      rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue());
-      rawIO.writeShortLittleEndian(byteArrayOutputStream,
+      throws IOException {
+
+    byte[] longByte = new byte[8];
+    rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) HeaderSignature.END_OF_CENTRAL_DIRECTORY.getValue());
+    rawIO.writeShortLittleEndian(byteArrayOutputStream,
+        zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
+    rawIO.writeShortLittleEndian(byteArrayOutputStream,
+        zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDiskStartOfCentralDir());
+
+    long numEntries = zipModel.getCentralDirectory().getFileHeaders().size();
+    long numEntriesOnThisDisk = numEntries;
+    if (zipModel.isSplitArchive()) {
+      numEntriesOnThisDisk = countNumberOfFileHeaderEntriesOnDisk(zipModel.getCentralDirectory().getFileHeaders(),
           zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
-      rawIO.writeShortLittleEndian(byteArrayOutputStream,
-          zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDiskStartOfCentralDir());
-
-      long numEntries = zipModel.getCentralDirectory().getFileHeaders().size();
-      long numEntriesOnThisDisk = numEntries;
-      if (zipModel.isSplitArchive()) {
-        numEntriesOnThisDisk = countNumberOfFileHeaderEntriesOnDisk(zipModel.getCentralDirectory().getFileHeaders(),
-            zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
-      }
-
-      if (numEntriesOnThisDisk > InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT) {
-        numEntriesOnThisDisk = InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT;
-      }
-      rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) numEntriesOnThisDisk);
+    }
 
-      if (numEntries > InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT) {
-        numEntries = InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT;
-      }
-      rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) numEntries);
+    if (numEntriesOnThisDisk > InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT) {
+      numEntriesOnThisDisk = InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT;
+    }
+    rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) numEntriesOnThisDisk);
 
-      rawIO.writeIntLittleEndian(byteArrayOutputStream, sizeOfCentralDir);
-      if (offsetCentralDir > ZIP_64_SIZE_LIMIT) {
-        rawIO.writeLongLittleEndian(longByte, 0, ZIP_64_SIZE_LIMIT);
-        byteArrayOutputStream.write(longByte, 0, 4);
-      } else {
-        rawIO.writeLongLittleEndian(longByte, 0, offsetCentralDir);
-        byteArrayOutputStream.write(longByte, 0, 4);
-      }
+    if (numEntries > InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT) {
+      numEntries = InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT;
+    }
+    rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) numEntries);
+
+    rawIO.writeIntLittleEndian(byteArrayOutputStream, sizeOfCentralDir);
+    if (offsetCentralDir > ZIP_64_SIZE_LIMIT) {
+      rawIO.writeLongLittleEndian(longByte, 0, ZIP_64_SIZE_LIMIT);
+      byteArrayOutputStream.write(longByte, 0, 4);
+    } else {
+      rawIO.writeLongLittleEndian(longByte, 0, offsetCentralDir);
+      byteArrayOutputStream.write(longByte, 0, 4);
+    }
 
-      String comment = zipModel.getEndOfCentralDirectoryRecord().getComment();
-      if (isStringNotNullAndNotEmpty(comment)) {
-        byte[] commentBytes = comment.getBytes(StandardCharsets.UTF_8);
-        rawIO.writeShortLittleEndian(byteArrayOutputStream, commentBytes.length);
-        byteArrayOutputStream.write(commentBytes);
-      } else {
-        rawIO.writeShortLittleEndian(byteArrayOutputStream, 0);
-      }
-    } catch (IOException e) {
-      throw new ZipException(e);
+    String comment = zipModel.getEndOfCentralDirectoryRecord().getComment();
+    if (isStringNotNullAndNotEmpty(comment)) {
+      byte[] commentBytes = comment.getBytes(StandardCharsets.UTF_8);
+      rawIO.writeShortLittleEndian(byteArrayOutputStream, commentBytes.length);
+      byteArrayOutputStream.write(commentBytes);
+    } else {
+      rawIO.writeShortLittleEndian(byteArrayOutputStream, 0);
     }
   }
 
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
index c2e5d9b..35e540d 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
@@ -45,15 +45,8 @@ abstract class CipherInputStream<T extends Decrypter> extends InputStream {
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
     int readLen = zipEntryInputStream.read(b, off, len);
-
     cacheRawData(b, readLen);
-
-    try {
-      decrypter.decryptData(b, off, readLen);
-    } catch (ZipException e) {
-      throw new IOException(e);
-    }
-
+    decrypter.decryptData(b, off, readLen);
     return readLen;
   }
 
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index a3188dd..bb74d73 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -33,6 +33,7 @@ import java.io.InputStream;
 import java.io.PushbackInputStream;
 import java.util.List;
 import java.util.zip.CRC32;
+import java.util.zip.DataFormatException;
 
 import static net.lingala.zip4j.util.FileUtils.isZipEntryDirectory;
 import static net.lingala.zip4j.util.Zip4jUtil.getCompressionMethod;
@@ -56,23 +57,19 @@ public class ZipInputStream extends InputStream {
   }
 
   public LocalFileHeader getNextEntry() throws IOException {
-    try {
-      localFileHeader = headerReader.readLocalFileHeader(inputStream);
+    localFileHeader = headerReader.readLocalFileHeader(inputStream);
 
-      if (localFileHeader == null) {
-        return null;
-      }
+    if (localFileHeader == null) {
+      return null;
+    }
 
-      verifyLocalFileHeader(localFileHeader);
-      crc32.reset();
+    verifyLocalFileHeader(localFileHeader);
+    crc32.reset();
 
-      if (!isZipEntryDirectory(localFileHeader.getFileName())) {
-        this.decompressedInputStream = initializeEntryInputStream(localFileHeader);
-      }
-      return localFileHeader;
-    } catch (ZipException e) {
-      throw new IOException(e);
+    if (!isZipEntryDirectory(localFileHeader.getFileName())) {
+      this.decompressedInputStream = initializeEntryInputStream(localFileHeader);
     }
+    return localFileHeader;
   }
 
   @Override
@@ -98,15 +95,24 @@ public class ZipInputStream extends InputStream {
       return -1;
     }
 
-    int readLen = decompressedInputStream.read(b, off, (len - len %16));
+    try {
+      int readLen = decompressedInputStream.read(b, off, (len - len %16));
 
-    if (readLen == -1) {
-      endOfCompressedDataReached();
-    } else {
-      crc32.update(b, off, readLen);
-    }
+      if (readLen == -1) {
+        endOfCompressedDataReached();
+      } else {
+        crc32.update(b, off, readLen);
+      }
+
+      return readLen;
+    } catch (IOException e) {
+      if (e.getCause() != null && e.getCause() instanceof DataFormatException
+          && isEncryptionMethodZipStandard(localFileHeader)) {
+        throw new ZipException(e.getCause(), ZipException.Type.WRONG_PASSWORD);
+      }
 
-    return readLen;
+      throw e;
+    }
   }
 
   @Override
@@ -129,13 +135,13 @@ public class ZipInputStream extends InputStream {
     resetFields();
   }
 
-  private DecompressedInputStream initializeEntryInputStream(LocalFileHeader localFileHeader) throws IOException, ZipException {
+  private DecompressedInputStream initializeEntryInputStream(LocalFileHeader localFileHeader) throws IOException {
     ZipEntryInputStream zipEntryInputStream = new ZipEntryInputStream(inputStream);
     CipherInputStream cipherInputStream = initializeCipherInputStream(zipEntryInputStream, localFileHeader);
     return initializeDecompressorForThisEntry(cipherInputStream, localFileHeader);
   }
 
-  private CipherInputStream initializeCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader) throws IOException, ZipException {
+  private CipherInputStream initializeCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader) throws IOException {
     if (!localFileHeader.isEncrypted()) {
       return new NoCipherInputStream(zipEntryInputStream, localFileHeader, password);
     }
@@ -204,7 +210,14 @@ public class ZipInputStream extends InputStream {
     }
 
     if (localFileHeader.getCrc() != crc32.getValue()) {
-      throw new IOException("Reached end of entry, but crc verification failed for " + localFileHeader.getFileName());
+      ZipException.Type exceptionType = ZipException.Type.UNKNOWN;
+
+      if (isEncryptionMethodZipStandard(localFileHeader)) {
+        exceptionType = ZipException.Type.WRONG_PASSWORD;
+      }
+
+      throw new ZipException("Reached end of entry, but crc verification failed for " + localFileHeader.getFileName(),
+          exceptionType);
     }
   }
 
@@ -243,7 +256,10 @@ public class ZipInputStream extends InputStream {
     } else {
       return 0;
     }
+  }
 
+  private boolean isEncryptionMethodZipStandard(LocalFileHeader localFileHeader) {
+    return localFileHeader.isEncrypted() && EncryptionMethod.ZIP_STANDARD.equals(localFileHeader.getEncryptionMethod());
   }
 
 }
diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/CipherOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/CipherOutputStream.java
index e392358..bb55b99 100755
--- a/src/main/java/net/lingala/zip4j/io/outputstream/CipherOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/CipherOutputStream.java
@@ -46,12 +46,7 @@ abstract class CipherOutputStream<T extends Encrypter> extends OutputStream {
 
   @Override
   public void write(byte[] b, int off, int len) throws IOException {
-    try {
-      encrypter.encryptData(b, off, len);
-    } catch (ZipException e) {
-      throw new IOException(e);
-    }
-
+    encrypter.encryptData(b, off, len);
     zipEntryOutputStream.write(b, off, len);
   }
 
diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/SplitOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/SplitOutputStream.java
index 0c87f54..8ba2125 100755
--- a/src/main/java/net/lingala/zip4j/io/outputstream/SplitOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/SplitOutputStream.java
@@ -97,36 +97,32 @@ public class SplitOutputStream extends OutputStream {
   }
 
   private void startNextSplitFile() throws IOException {
-    try {
-      String zipFileWithoutExt = getZipFileNameWithoutExtension(zipFile.getName());
-      String zipFileName = zipFile.getAbsolutePath();
-      String parentPath = (zipFile.getParent() == null) ? "" : zipFile.getParent()
-          + System.getProperty("file.separator");
-
-      String fileExtension = ".z0" + (currSplitFileCounter + 1);
-      if (currSplitFileCounter >= 9) {
-        fileExtension = ".z" + (currSplitFileCounter + 1);
-      }
-
-      File currSplitFile = new File(parentPath + zipFileWithoutExt + fileExtension);
+    String zipFileWithoutExt = getZipFileNameWithoutExtension(zipFile.getName());
+    String zipFileName = zipFile.getAbsolutePath();
+    String parentPath = (zipFile.getParent() == null) ? "" : zipFile.getParent()
+        + System.getProperty("file.separator");
+
+    String fileExtension = ".z0" + (currSplitFileCounter + 1);
+    if (currSplitFileCounter >= 9) {
+      fileExtension = ".z" + (currSplitFileCounter + 1);
+    }
 
-      raf.close();
+    File currSplitFile = new File(parentPath + zipFileWithoutExt + fileExtension);
 
-      if (currSplitFile.exists()) {
-        throw new IOException("split file: " + currSplitFile.getName()
-            + " already exists in the current directory, cannot rename this file");
-      }
+    raf.close();
 
-      if (!zipFile.renameTo(currSplitFile)) {
-        throw new IOException("cannot rename newly created split file");
-      }
+    if (currSplitFile.exists()) {
+      throw new IOException("split file: " + currSplitFile.getName()
+          + " already exists in the current directory, cannot rename this file");
+    }
 
-      zipFile = new File(zipFileName);
-      raf = new RandomAccessFile(zipFile, RandomAccessFileMode.WRITE.getValue());
-      currSplitFileCounter++;
-    } catch (ZipException e) {
-      throw new IOException(e);
+    if (!zipFile.renameTo(currSplitFile)) {
+      throw new IOException("cannot rename newly created split file");
     }
+
+    zipFile = new File(zipFileName);
+    raf = new RandomAccessFile(zipFile, RandomAccessFileMode.WRITE.getValue());
+    currSplitFileCounter++;
   }
 
   private boolean isHeaderData(byte[] buff) {
@@ -174,9 +170,8 @@ public class SplitOutputStream extends OutputStream {
    *
    * @param bufferSize
    * @return true if the buffer size is fit in the current split file or else false.
-   * @throws ZipException
    */
-  private boolean isBufferSizeFitForCurrSplitFile(int bufferSize) throws ZipException {
+  private boolean isBufferSizeFitForCurrSplitFile(int bufferSize) {
     if (splitLength >= MIN_SPLIT_LENGTH) {
       return (bytesWrittenForThisPart + bufferSize <= splitLength);
     } else {
diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
index 4b39247..d4e1ff0 100755
--- a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
@@ -46,19 +46,13 @@ public class ZipOutputStream extends OutputStream {
   }
 
   public void putNextEntry(ZipParameters zipParameters) throws IOException {
-    try {
-      verifyZipParameters(zipParameters);
-      initializeAndWriteFileHeader(zipParameters);
-
-      //Initialisation of below compressedOutputStream should happen after writing local file header
-      //because local header data should be written first and then the encryption header data
-      //and below initialisation writes encryption header data
-      compressedOutputStream = initializeCompressedOutputStream(zipParameters);
-    } catch (IOException e) {
-      throw e;
-    } catch (ZipException e) {
-      throw new IOException(e);
-    }
+    verifyZipParameters(zipParameters);
+    initializeAndWriteFileHeader(zipParameters);
+
+    //Initialisation of below compressedOutputStream should happen after writing local file header
+    //because local header data should be written first and then the encryption header data
+    //and below initialisation writes encryption header data
+    compressedOutputStream = initializeCompressedOutputStream(zipParameters);
   }
 
   public void write(int b) throws IOException {
@@ -76,44 +70,35 @@ public class ZipOutputStream extends OutputStream {
   }
 
   public FileHeader closeEntry() throws IOException {
-    try {
-      compressedOutputStream.closeEntry();
-
-      long compressedSize = compressedOutputStream.getCompressedSize();
-      fileHeader.setCompressedSize(compressedSize);
-      localFileHeader.setCompressedSize(compressedSize);
-
-      fileHeader.setUncompressedSize(uncompressedSizeForThisEntry);
-      localFileHeader.setUncompressedSize(uncompressedSizeForThisEntry);
-
-      //Skip writing crc for AES encrypted files
-      if (!fileHeader.isEncrypted() || !EncryptionMethod.AES.equals(fileHeader.getEncryptionMethod())) {
-        fileHeader.setCrc(crc32.getValue());
-        localFileHeader.setCrc(crc32.getValue());
-      }
-
-      zipModel.getLocalFileHeaders().add(localFileHeader);
-      zipModel.getCentralDirectory().getFileHeaders().add(fileHeader);
-
-      if (localFileHeader.isDataDescriptorExists()) {
-        headerWriter.writeExtendedLocalHeader(localFileHeader, countingOutputStream);
-      }
-      reset();
-      return fileHeader;
-    } catch (ZipException e) {
-      throw new IOException(e);
+    compressedOutputStream.closeEntry();
+
+    long compressedSize = compressedOutputStream.getCompressedSize();
+    fileHeader.setCompressedSize(compressedSize);
+    localFileHeader.setCompressedSize(compressedSize);
+
+    fileHeader.setUncompressedSize(uncompressedSizeForThisEntry);
+    localFileHeader.setUncompressedSize(uncompressedSizeForThisEntry);
+
+    //Skip writing crc for AES encrypted files
+    if (!fileHeader.isEncrypted() || !EncryptionMethod.AES.equals(fileHeader.getEncryptionMethod())) {
+      fileHeader.setCrc(crc32.getValue());
+      localFileHeader.setCrc(crc32.getValue());
     }
+
+    zipModel.getLocalFileHeaders().add(localFileHeader);
+    zipModel.getCentralDirectory().getFileHeaders().add(fileHeader);
+
+    if (localFileHeader.isDataDescriptorExists()) {
+      headerWriter.writeExtendedLocalHeader(localFileHeader, countingOutputStream);
+    }
+    reset();
+    return fileHeader;
   }
 
   @Override
   public void close() throws IOException {
-    try {
-      zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(countingOutputStream.getNumberOfBytesWritten());
-      headerWriter.finalizeZipFile(zipModel, countingOutputStream);
-    } catch (ZipException e) {
-      throw new IOException(e);
-    }
-
+    zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(countingOutputStream.getNumberOfBytesWritten());
+    headerWriter.finalizeZipFile(zipModel, countingOutputStream);
     countingOutputStream.close();
   }
 
@@ -130,7 +115,7 @@ public class ZipOutputStream extends OutputStream {
     return zipModel;
   }
 
-  private void initializeAndWriteFileHeader(ZipParameters zipParameters) throws ZipException, IOException {
+  private void initializeAndWriteFileHeader(ZipParameters zipParameters) throws IOException {
     fileHeader = fileHeaderFactory.generateFileHeader(zipParameters, countingOutputStream.isSplitZipFile(),
         countingOutputStream.getCurrentSplitFileCounter());
     fileHeader.setOffsetLocalHeader(countingOutputStream.getOffsetForNextEntry());
@@ -153,13 +138,14 @@ public class ZipOutputStream extends OutputStream {
     rawIO.writeIntLittleEndian(countingOutputStream, (int) HeaderSignature.SPLIT_ZIP.getValue());
   }
 
-  private CompressedOutputStream initializeCompressedOutputStream(ZipParameters zipParameters) throws IOException, ZipException {
+  private CompressedOutputStream initializeCompressedOutputStream(ZipParameters zipParameters) throws IOException {
     ZipEntryOutputStream zipEntryOutputStream = new ZipEntryOutputStream(countingOutputStream);
     CipherOutputStream cipherOutputStream = initializeCipherOutputStream(zipEntryOutputStream, zipParameters);
     return initializeCompressedOutputStream(cipherOutputStream, zipParameters);
   }
 
-  private CipherOutputStream initializeCipherOutputStream(ZipEntryOutputStream zipEntryOutputStream, ZipParameters zipParameters) throws IOException, ZipException {
+  private CipherOutputStream initializeCipherOutputStream(ZipEntryOutputStream zipEntryOutputStream,
+                                                          ZipParameters zipParameters) throws IOException {
     if (!zipParameters.isEncryptFiles()) {
       return new NoCipherOutputStream(zipEntryOutputStream, zipParameters, null);
     }
@@ -177,7 +163,8 @@ public class ZipOutputStream extends OutputStream {
     }
   }
 
-  private CompressedOutputStream initializeCompressedOutputStream(CipherOutputStream cipherOutputStream, ZipParameters zipParameters) {
+  private CompressedOutputStream initializeCompressedOutputStream(CipherOutputStream cipherOutputStream,
+                                                                  ZipParameters zipParameters) {
     if (zipParameters.getCompressionMethod() == CompressionMethod.DEFLATE) {
       return new DeflaterOutputStream(cipherOutputStream, zipParameters.getCompressionLevel());
     }
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
index 9affe8f..a1cad98 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
@@ -46,7 +46,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
   }
 
   void addFilesToZip(List<File> filesToAdd, ProgressMonitor progressMonitor, ZipParameters zipParameters)
-      throws ZipException {
+      throws IOException {
 
     removeFilesIfExists(filesToAdd, zipParameters, progressMonitor);
 
@@ -79,8 +79,6 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
 
         headerWriter.updateLocalFileHeader(fileHeader, zipModel, splitOutputStream);
       }
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
   }
 
@@ -110,7 +108,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     return totalWork;
   }
 
-  ZipOutputStream initializeOutputStream(SplitOutputStream splitOutputStream) throws IOException, ZipException {
+  ZipOutputStream initializeOutputStream(SplitOutputStream splitOutputStream) throws IOException {
     if (zipModel.getZipFile().exists()) {
       if (zipModel.getEndOfCentralDirectoryRecord() == null) {
         throw new ZipException("invalid end of central directory record");
@@ -144,7 +142,7 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
   }
 
   private ZipParameters cloneAndAdjustZipParameters(ZipParameters zipParameters, File fileToAdd,
-                                                    ProgressMonitor progressMonitor) throws ZipException {
+                                                    ProgressMonitor progressMonitor) throws IOException {
     ZipParameters clonedZipParameters = new ZipParameters(zipParameters);
     clonedZipParameters.setLastModifiedFileTime(javaToDosTime((fileToAdd.lastModified())));
     clonedZipParameters.setFileNameInZip(fileToAdd.getName());
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
index 46ac596..2c21e51 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
@@ -28,7 +28,7 @@ public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
   }
 
   protected void extractFile(ZipInputStream zipInputStream, FileHeader fileHeader, String outPath, String newFileName,
-                             ProgressMonitor progressMonitor) throws ZipException {
+                             ProgressMonitor progressMonitor) throws IOException {
 
     progressMonitor.setFileName(fileHeader.getFileName());
 
@@ -60,7 +60,7 @@ public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
   }
 
   private void unzipFile(ZipInputStream inputStream, FileHeader fileHeader, String outputPath, String newFileName,
-                         ProgressMonitor progressMonitor) throws ZipException {
+                         ProgressMonitor progressMonitor) throws IOException {
 
     String outputFileName = Zip4jUtil.isStringNotNullAndNotEmpty(newFileName) ? newFileName : fileHeader.getFileName();
     File outputFile = new File(outputPath + System.getProperty("file.separator") + outputFileName);
@@ -72,27 +72,21 @@ public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
         progressMonitor.updateWorkCompleted(readLength);
         verifyIfTaskIsCancelled();
       }
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
 
     UnzipUtil.applyFileAttributes(fileHeader, outputFile);
   }
 
-  private void verifyNextEntry(ZipInputStream zipInputStream, FileHeader fileHeader) throws ZipException {
-    try {
-      LocalFileHeader localFileHeader = zipInputStream.getNextEntry();
+  private void verifyNextEntry(ZipInputStream zipInputStream, FileHeader fileHeader) throws IOException {
+    LocalFileHeader localFileHeader = zipInputStream.getNextEntry();
 
-      if (localFileHeader == null) {
-        throw new ZipException("Could not read corresponding local file header for file header: "
-            + fileHeader.getFileName());
-      }
+    if (localFileHeader == null) {
+      throw new ZipException("Could not read corresponding local file header for file header: "
+          + fileHeader.getFileName());
+    }
 
-      if (!fileHeader.getFileName().equals(localFileHeader.getFileName())) {
-        throw new ZipException("File header and local file header mismatch");
-      }
-    } catch (IOException e) {
-      throw new ZipException(e);
+    if (!fileHeader.getFileName().equals(localFileHeader.getFileName())) {
+      throw new ZipException("File header and local file header mismatch");
     }
   }
 
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java
index deaccff..9012eda 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java
@@ -9,6 +9,7 @@ import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.AddFilesToZipTask.AddFilesToZipTaskParameters;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.List;
 
 public class AddFilesToZipTask extends AbstractAddFileToZipTask<AddFilesToZipTaskParameters> {
@@ -20,7 +21,7 @@ public class AddFilesToZipTask extends AbstractAddFileToZipTask<AddFilesToZipTas
 
   @Override
   protected void executeTask(AddFilesToZipTaskParameters taskParameters, ProgressMonitor progressMonitor)
-      throws ZipException {
+      throws IOException {
 
     verifyZipParameters(taskParameters.zipParameters);
     addFilesToZip(taskParameters.filesToAdd, progressMonitor, taskParameters.zipParameters);
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
index b026a90..cbc58d1 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
@@ -9,6 +9,7 @@ import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.AddFolderToZipTask.AddFolderToZipTaskParameters;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.List;
 
 import static net.lingala.zip4j.util.FileUtils.getFilesInDirectoryRecursive;
@@ -22,7 +23,7 @@ public class AddFolderToZipTask extends AbstractAddFileToZipTask<AddFolderToZipT
 
   @Override
   protected void executeTask(AddFolderToZipTaskParameters taskParameters, ProgressMonitor progressMonitor)
-      throws ZipException {
+      throws IOException {
     List<File> filesToAdd = getFilesToAdd(taskParameters);
     setDefaultFolderPath(taskParameters);
     addFilesToZip(filesToAdd, progressMonitor, taskParameters.zipParameters);
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
index 784dc87..2f1ba72 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
@@ -1,7 +1,6 @@
 package net.lingala.zip4j.tasks;
 
 import lombok.AllArgsConstructor;
-import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.io.outputstream.SplitOutputStream;
 import net.lingala.zip4j.io.outputstream.ZipOutputStream;
@@ -24,7 +23,7 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
 
   @Override
   protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor)
-      throws ZipException {
+      throws IOException {
 
     verifyZipParameters(taskParameters.zipParameters);
 
@@ -45,8 +44,6 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
       }
 
       zipOutputStream.closeEntry();
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
   }
 
diff --git a/src/main/java/net/lingala/zip4j/tasks/AsyncZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AsyncZipTask.java
index 54df193..40aeb54 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AsyncZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AsyncZipTask.java
@@ -3,6 +3,7 @@ package net.lingala.zip4j.tasks;
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.progress.ProgressMonitor;
 
+import java.io.IOException;
 import java.util.concurrent.Executors;
 
 public abstract class AsyncZipTask<T> {
@@ -58,7 +59,7 @@ public abstract class AsyncZipTask<T> {
     throw new ZipException("Task cancelled", ZipException.Type.TASK_CANCELLED_EXCEPTION);
   }
 
-  protected abstract void executeTask(T taskParameters, ProgressMonitor progressMonitor) throws ZipException;
+  protected abstract void executeTask(T taskParameters, ProgressMonitor progressMonitor) throws IOException;
 
   protected abstract long calculateTotalWork(T taskParameters) throws ZipException;
 
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
index e627440..73a7520 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
@@ -1,7 +1,6 @@
 package net.lingala.zip4j.tasks;
 
 import lombok.AllArgsConstructor;
-import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.io.inputstream.SplitInputStream;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
@@ -23,7 +22,7 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
 
   @Override
   protected void executeTask(ExtractAllFilesTaskParameters taskParameters, ProgressMonitor progressMonitor)
-      throws ZipException {
+      throws IOException {
     try (ZipInputStream zipInputStream = prepareZipInputStream()) {
       for (FileHeader fileHeader : getZipModel().getCentralDirectory().getFileHeaders()) {
         if (fileHeader.getFileName().startsWith("__MACOSX")) {
@@ -36,10 +35,7 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
         extractFile(zipInputStream, fileHeader, taskParameters.outputPath, null, progressMonitor);
         verifyIfTaskIsCancelled();
       }
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
-
   }
 
   @Override
@@ -58,20 +54,16 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
     return totalWork;
   }
 
-  private ZipInputStream prepareZipInputStream() throws ZipException {
-    try {
-      splitInputStream = new SplitInputStream(getZipModel().getZipFile(),
-          getZipModel().isSplitArchive(), getZipModel().getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
-
-      FileHeader fileHeader = getFirstFileHeader(getZipModel());
-      if (fileHeader != null) {
-        splitInputStream.prepareExtractionForFileHeader(fileHeader);
-      }
+  private ZipInputStream prepareZipInputStream() throws IOException {
+    splitInputStream = new SplitInputStream(getZipModel().getZipFile(),
+        getZipModel().isSplitArchive(), getZipModel().getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
 
-      return new ZipInputStream(splitInputStream, password);
-    } catch (IOException e) {
-      throw new ZipException(e);
+    FileHeader fileHeader = getFirstFileHeader(getZipModel());
+    if (fileHeader != null) {
+      splitInputStream.prepareExtractionForFileHeader(fileHeader);
     }
+
+    return new ZipInputStream(splitInputStream, password);
   }
 
   private FileHeader getFirstFileHeader(ZipModel zipModel) {
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
index 9e959c1..8cf05a8 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
@@ -1,7 +1,6 @@
 package net.lingala.zip4j.tasks;
 
 import lombok.AllArgsConstructor;
-import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.io.inputstream.SplitInputStream;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
@@ -22,14 +21,11 @@ public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskPara
 
   @Override
   protected void executeTask(ExtractFileTaskParameters taskParameters, ProgressMonitor progressMonitor)
-      throws ZipException {
+      throws IOException {
     try(ZipInputStream zipInputStream = createZipInputStream(taskParameters.fileHeader)) {
       extractFile(zipInputStream, taskParameters.fileHeader, taskParameters.outputPath, taskParameters.newFileName,
           progressMonitor);
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
-
   }
 
   @Override
@@ -37,15 +33,11 @@ public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskPara
     return taskParameters.fileHeader.getCompressedSize();
   }
 
-  protected ZipInputStream createZipInputStream(FileHeader fileHeader) throws ZipException {
-    try {
-      SplitInputStream splitInputStream = new SplitInputStream(getZipModel().getZipFile(),
-          getZipModel().isSplitArchive(), getZipModel().getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
-      splitInputStream.prepareExtractionForFileHeader(fileHeader);
-      return new ZipInputStream(splitInputStream, password);
-    } catch (IOException e) {
-      throw new ZipException(e);
-    }
+  protected ZipInputStream createZipInputStream(FileHeader fileHeader) throws IOException {
+    SplitInputStream splitInputStream = new SplitInputStream(getZipModel().getZipFile(),
+        getZipModel().isSplitArchive(), getZipModel().getEndOfCentralDirectoryRecord().getNumberOfThisDisk());
+    splitInputStream.prepareExtractionForFileHeader(fileHeader);
+    return new ZipInputStream(splitInputStream, password);
   }
 
   @AllArgsConstructor
diff --git a/src/main/java/net/lingala/zip4j/tasks/MergeSplitZipFileTask.java b/src/main/java/net/lingala/zip4j/tasks/MergeSplitZipFileTask.java
index 26ca263..d053138 100644
--- a/src/main/java/net/lingala/zip4j/tasks/MergeSplitZipFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/MergeSplitZipFileTask.java
@@ -15,6 +15,7 @@ import net.lingala.zip4j.util.RawIO;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
+import java.io.IOException;
 import java.io.OutputStream;
 import java.io.RandomAccessFile;
 import java.util.List;
@@ -32,7 +33,7 @@ public class MergeSplitZipFileTask extends AsyncZipTask<File> {
   }
 
   @Override
-  protected void executeTask(File outputZipFile, ProgressMonitor progressMonitor) throws ZipException {
+  protected void executeTask(File outputZipFile, ProgressMonitor progressMonitor) throws IOException {
     if (!zipModel.isSplitArchive()) {
       ZipException e = new ZipException("archive not a split zip file");
       progressMonitor.endProgressMonitor(e);
@@ -74,17 +75,13 @@ public class MergeSplitZipFileTask extends AsyncZipTask<File> {
       }
       updateHeadersForMergeSplitFileAction(zipModel, totalBytesWritten, outputStream);
       progressMonitor.endProgressMonitor();
-    } catch (ZipException e) {
-      progressMonitor.endProgressMonitor(e);
-      throw e;
-    } catch (Exception e) {
-      progressMonitor.endProgressMonitor(e);
+    } catch (CloneNotSupportedException e) {
       throw new ZipException(e);
     }
   }
 
   @Override
-  protected long calculateTotalWork(File outputZipFile) throws ZipException {
+  protected long calculateTotalWork(File outputZipFile) {
     if (!zipModel.isSplitArchive()) {
       return 0;
     }
@@ -128,7 +125,7 @@ public class MergeSplitZipFileTask extends AsyncZipTask<File> {
 
   private void updateHeadersForMergeSplitFileAction(ZipModel zipModel, long totalBytesWritten,
                                                     OutputStream outputStream)
-      throws ZipException, CloneNotSupportedException {
+      throws IOException, CloneNotSupportedException {
 
     ZipModel newZipModel = (ZipModel) zipModel.clone();
     newZipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(totalBytesWritten);
diff --git a/src/main/java/net/lingala/zip4j/tasks/RemoveEntryFromZipFileTask.java b/src/main/java/net/lingala/zip4j/tasks/RemoveEntryFromZipFileTask.java
index 38129b9..942325a 100644
--- a/src/main/java/net/lingala/zip4j/tasks/RemoveEntryFromZipFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/RemoveEntryFromZipFileTask.java
@@ -29,7 +29,7 @@ public class RemoveEntryFromZipFileTask extends AsyncZipTask<FileHeader>  {
 
   @Override
   protected void executeTask(FileHeader fileHeader, ProgressMonitor progressMonitor)
-      throws ZipException {
+      throws IOException {
     if (zipModel.isSplitArchive()) {
       throw new ZipException("This is a split archive. Zip file format does not allow updating split/spanned files");
     }
@@ -66,8 +66,6 @@ public class RemoveEntryFromZipFileTask extends AsyncZipTask<FileHeader>  {
 
       updateHeaders(zipModel, outputStream, indexOfFileHeader, offsetEndOfCompressedData, offsetLocalFileHeader);
       successFlag = true;
-    } catch (IOException e) {
-      throw new ZipException(e);
     } finally {
       cleanupFile(successFlag, zipModel.getZipFile(), temporaryZipFile);
     }
diff --git a/src/main/java/net/lingala/zip4j/tasks/SetCommentTask.java b/src/main/java/net/lingala/zip4j/tasks/SetCommentTask.java
index 2ba5175..95230df 100644
--- a/src/main/java/net/lingala/zip4j/tasks/SetCommentTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/SetCommentTask.java
@@ -19,7 +19,7 @@ public class SetCommentTask extends AsyncZipTask<String> {
   }
 
   @Override
-  protected void executeTask(String comment, ProgressMonitor progressMonitor) throws ZipException {
+  protected void executeTask(String comment, ProgressMonitor progressMonitor) throws IOException {
     if (comment == null) {
       throw new ZipException("comment is null, cannot update Zip file with comment");
     }
@@ -37,8 +37,6 @@ public class SetCommentTask extends AsyncZipTask<String> {
 
       HeaderWriter headerWriter = new HeaderWriter();
       headerWriter.finalizeZipFileWithoutValidations(zipModel, outputStream);
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
   }
 
diff --git a/src/main/java/net/lingala/zip4j/util/CrcUtil.java b/src/main/java/net/lingala/zip4j/util/CrcUtil.java
index a26ec3b..2509006 100755
--- a/src/main/java/net/lingala/zip4j/util/CrcUtil.java
+++ b/src/main/java/net/lingala/zip4j/util/CrcUtil.java
@@ -29,7 +29,7 @@ public class CrcUtil {
 
   private static final int BUF_SIZE = 1 << 14; //16384
 
-  public static long computeFileCrc(File inputFile, ProgressMonitor progressMonitor) throws ZipException {
+  public static long computeFileCrc(File inputFile, ProgressMonitor progressMonitor) throws IOException {
 
     if (inputFile == null || !inputFile.exists() || !inputFile.canRead()) {
       throw new ZipException("input file is null or does not exist or cannot read. " +
@@ -54,8 +54,6 @@ public class CrcUtil {
         }
       }
       return crc32.getValue();
-    } catch (IOException e) {
-      throw new ZipException(e);
     }
   }
 
diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index 4b11e1f..aed9e34 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -46,7 +46,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileAsStringParameterWithoutZipParameterAddsAsDeflate() throws ZipException {
+  public void testAddFileAsStringParameterWithoutZipParameterAddsAsDeflate() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     zipFile.addFile(TestUtils.getFileFromResources("sample.pdf").getPath());
 
@@ -55,7 +55,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileAsStringWithZipParametersStoreAndStandardEncryption() throws ZipException {
+  public void testAddFileAsStringWithZipParametersStoreAndStandardEncryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -88,7 +88,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileWithoutZipParameterAddsAsDeflate() throws ZipException {
+  public void testAddFileWithoutZipParameterAddsAsDeflate() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     zipFile.addFile(TestUtils.getFileFromResources("file_PDF_1MB.pdf"));
 
@@ -98,7 +98,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileWithZipParametersStoreAndStandardZip() throws ZipException {
+  public void testAddFileWithZipParametersStoreAndStandardZip() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -111,7 +111,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileWithZipParametersStoreAndAes128Encryption() throws ZipException {
+  public void testAddFileWithZipParametersStoreAndAes128Encryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -124,7 +124,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileWithZipParametersStoreAndAes256Encryption() throws ZipException {
+  public void testAddFileWithZipParametersStoreAndAes256Encryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -137,7 +137,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileRemovesExistingFileNoEncryption() throws ZipException {
+  public void testAddFileRemovesExistingFileNoEncryption() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     zipFile.addFiles(FILES_TO_ADD);
 
@@ -149,7 +149,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileRemovesExistingFileNoEncryptionSingleFileInZip() throws ZipException {
+  public void testAddFileRemovesExistingFileNoEncryptionSingleFileInZip() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     zipFile.addFile(TestUtils.getFileFromResources("sample_text_large.txt"));
 
@@ -163,7 +163,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileRemovesExistingFileWithAesEncryption() throws ZipException {
+  public void testAddFileRemovesExistingFileWithAesEncryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
@@ -191,7 +191,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFileWithProgressMonitor() throws ZipException, InterruptedException {
+  public void testAddFileWithProgressMonitor() throws IOException, InterruptedException {
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     ProgressMonitor progressMonitor = zipFile.getProgressMonitor();
     boolean percentBetweenZeroAndHundred = false;
@@ -234,7 +234,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWithoutParametersWhenZipFileDoesNotExistCreatesSuccessfully() throws ZipException {
+  public void testAddFilesWithoutParametersWhenZipFileDoesNotExistCreatesSuccessfully() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
 
     zipFile.addFiles(asList(
@@ -248,7 +248,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWhenZipFileDoesNotExistCreatesSuccessfully() throws ZipException {
+  public void testAddFilesWhenZipFileDoesNotExistCreatesSuccessfully() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
 
     zipFile.addFiles(asList(
@@ -262,7 +262,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWithZeroByteFileWithAes128Encryption() throws ZipException {
+  public void testAddFilesWithZeroByteFileWithAes128Encryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
 
@@ -274,7 +274,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWithAes256Encryption() throws ZipException {
+  public void testAddFilesWithAes256Encryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
 
@@ -287,7 +287,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWithZipStandardEncryption() throws ZipException {
+  public void testAddFilesWithZipStandardEncryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
 
@@ -300,7 +300,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWhenFilesAlreadyExistsRemovesFiles() throws ZipException {
+  public void testAddFilesWhenFilesAlreadyExistsRemovesFiles() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
@@ -341,7 +341,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWithDifferentEncryptionType() throws ZipException {
+  public void testAddFilesWithDifferentEncryptionType() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFiles(singletonList(TestUtils.getFileFromResources("sample.pdf")), zipParameters);
@@ -354,7 +354,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWithUtf8Characters() throws ZipException {
+  public void testAddFilesWithUtf8Characters() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
 
@@ -379,7 +379,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFilesWithProgressMonitor() throws ZipException, InterruptedException {
+  public void testAddFilesWithProgressMonitor() throws IOException, InterruptedException {
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     ProgressMonitor progressMonitor = zipFile.getProgressMonitor();
     boolean percentBetweenZeroAndHundred = false;
@@ -422,7 +422,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFolderWithoutZipParameters() throws ZipException, IOException {
+  public void testAddFolderWithoutZipParameters() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
 
     zipFile.addFolder(TestUtils.getFileFromResources(""));
@@ -434,7 +434,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFolderWithStoreAndAes128() throws ZipException, IOException {
+  public void testAddFolderWithStoreAndAes128() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -448,7 +448,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFolderWithDeflateAndAes256AndWithoutRootFolder() throws ZipException, IOException {
+  public void testAddFolderWithDeflateAndAes256AndWithoutRootFolder() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     zipParameters.setIncludeRootFolder(false);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -462,7 +462,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddFolderWithProgressMonitor() throws ZipException, InterruptedException {
+  public void testAddFolderWithProgressMonitor() throws IOException, InterruptedException {
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     ProgressMonitor progressMonitor = zipFile.getProgressMonitor();
     boolean percentBetweenZeroAndHundred = false;
@@ -496,7 +496,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddStreamToZipThrowsExceptionWhenFileNameIsNull() throws ZipException, IOException {
+  public void testAddStreamToZipThrowsExceptionWhenFileNameIsNull() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     InputStream inputStream = new FileInputStream(TestUtils.getFileFromResources(".txt"));
     ZipParameters zipParameters = new ZipParameters();
@@ -509,7 +509,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddStreamToZipThrowsExceptionWhenFileNameIsEmpty() throws ZipException, IOException {
+  public void testAddStreamToZipThrowsExceptionWhenFileNameIsEmpty() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     InputStream inputStream = new FileInputStream(TestUtils.getFileFromResources(".txt"));
     ZipParameters zipParameters = new ZipParameters();
@@ -522,7 +522,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddStreamToZipWithoutEncryptionForNewZipAddsSuccessfully() throws ZipException, IOException {
+  public void testAddStreamToZipWithoutEncryptionForNewZipAddsSuccessfully() throws IOException {
     File fileToAdd = TestUtils.getFileFromResources(".txt");
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setFileNameInZip(fileToAdd.getName());
@@ -536,7 +536,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddStreamToZipWithAesEncryptionForNewZipAddsSuccessfully() throws ZipException, IOException {
+  public void testAddStreamToZipWithAesEncryptionForNewZipAddsSuccessfully() throws IOException {
     File fileToAdd = TestUtils.getFileFromResources(".txt");
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     zipParameters.setFileNameInZip(fileToAdd.getName());
@@ -551,7 +551,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddStreamToZipWithoutEncryptionForExistingZipAddsSuccessfully() throws ZipException, IOException {
+  public void testAddStreamToZipWithoutEncryptionForExistingZipAddsSuccessfully() throws IOException {
     File fileToAdd = TestUtils.getFileFromResources(".abc");
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setFileNameInZip(fileToAdd.getName());
@@ -566,7 +566,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   @Test
-  public void testAddStreamToZipWithAesEncryptionForExistingZipAddsSuccessfully() throws ZipException, IOException {
+  public void testAddStreamToZipWithAesEncryptionForExistingZipAddsSuccessfully() throws IOException {
     File fileToAdd = TestUtils.getFileFromResources(".abc");
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     zipParameters.setFileNameInZip(fileToAdd.getName());
@@ -597,9 +597,7 @@ public class AddFilesToZipIT extends AbstractIT {
   }
 
   private void verifyFoldersInFileHeaders(List<FileHeader> fileHeaders) {
-    fileHeaders.stream().filter(FileHeader::isDirectory).forEach(e -> {
-      verifyFolderEntryInZip(e);
-    });
+    fileHeaders.stream().filter(FileHeader::isDirectory).forEach(this::verifyFolderEntryInZip);
   }
 
   private void verifyFoldersInLocalFileHeaders(File generatedZipFile, char[] password) throws IOException {
diff --git a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
index adcec76..9d5302e 100644
--- a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
@@ -18,6 +18,7 @@ import org.junit.rules.ExpectedException;
 
 import java.io.File;
 import java.io.FilenameFilter;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -33,7 +34,7 @@ public class CreateZipFileIT extends AbstractIT {
   public ExpectedException expectedException = ExpectedException.none();
 
   @Test
-  public void testCreateSplitZipFileNotSplitArchiveWithZipNameAsString() throws ZipException {
+  public void testCreateSplitZipFileNotSplitArchiveWithZipNameAsString() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile.getPath());
     zipFile.createSplitZipFile(FILES_TO_ADD, new ZipParameters(), false, -1);
 
@@ -41,8 +42,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileNotSplitArchiveWithZipNameAsStringWithAESEncryption256()
-      throws ZipException {
+  public void testCreateSplitZipFileNotSplitArchiveWithZipNameAsStringWithAESEncryption256() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile.getPath(), PASSWORD);
@@ -54,8 +54,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileNotSplitArchiveWithZipNameAsStringWithAESEncryption128()
-      throws ZipException {
+  public void testCreateSplitZipFileNotSplitArchiveWithZipNameAsStringWithAESEncryption128() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_128);
     ZipFile zipFile = new ZipFile(generatedZipFile.getPath(), PASSWORD);
@@ -67,7 +66,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileNotSplitArchiveWithFile() throws ZipException {
+  public void testCreateSplitZipFileNotSplitArchiveWithFile() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     zipFile.createSplitZipFile(FILES_TO_ADD, new ZipParameters(), false, -1);
 
@@ -75,8 +74,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileNotSplitArchiveWithFileAndWithAESEncryption256()
-      throws ZipException {
+  public void testCreateSplitZipFileNotSplitArchiveWithFileAndWithAESEncryption256() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile.getPath(), PASSWORD);
@@ -88,8 +86,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileNotSplitArchiveWithFileAndWithAESEncryption128()
-      throws ZipException {
+  public void testCreateSplitZipFileNotSplitArchiveWithFileAndWithAESEncryption128() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_128);
     ZipFile zipFile = new ZipFile(generatedZipFile.getPath(), PASSWORD);
@@ -101,8 +98,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileNotSplitArchiveWithFileAndWithStandardEncryption()
-      throws ZipException {
+  public void testCreateSplitZipFileNotSplitArchiveWithFileAndWithStandardEncryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD,
         AesKeyStrength.KEY_STRENGTH_128);
     ZipFile zipFile = new ZipFile(generatedZipFile.getPath(), PASSWORD);
@@ -124,7 +120,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileStoreAndWithoutEncryption() throws ZipException {
+  public void testCreateSplitZipFileStoreAndWithoutEncryption() throws IOException {
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
 
@@ -136,7 +132,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileStoreAndStandardZipEncryption() throws ZipException {
+  public void testCreateSplitZipFileStoreAndStandardZipEncryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
 
@@ -148,7 +144,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileStoreAndWithAesEncryptionKeyStrength256() throws ZipException {
+  public void testCreateSplitZipFileStoreAndWithAesEncryptionKeyStrength256() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_256);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
@@ -161,7 +157,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileStoreAndWithAesEncryptionKeyStrength128() throws ZipException {
+  public void testCreateSplitZipFileStoreAndWithAesEncryptionKeyStrength128() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_128);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
@@ -176,7 +172,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileDeflateAndWithoutEncryption() throws ZipException {
+  public void testCreateSplitZipFileDeflateAndWithoutEncryption() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
     filesToAdd.add(TestUtils.getFileFromResources("file_PDF_1MB.pdf"));
@@ -188,7 +184,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileDeflateAndStandardZipEncryption() throws ZipException {
+  public void testCreateSplitZipFileDeflateAndStandardZipEncryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     zipParameters.setCompressionMethod(CompressionMethod.DEFLATE);
 
@@ -202,7 +198,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileDeflateAndWithAesEncryptionKeyStrength256() throws ZipException {
+  public void testCreateSplitZipFileDeflateAndWithAesEncryptionKeyStrength256() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_256);
 
@@ -216,7 +212,7 @@ public class CreateZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testCreateSplitZipFileDeflateAndWithAesEncryptionKeyStrength128() throws ZipException {
+  public void testCreateSplitZipFileDeflateAndWithAesEncryptionKeyStrength128() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES,
         AesKeyStrength.KEY_STRENGTH_128);
 
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index f0850af..0d5abbc 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -14,10 +14,12 @@ import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.List;
 import java.util.Optional;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
 
 public class ExtractZipFileIT extends AbstractIT {
 
@@ -25,7 +27,7 @@ public class ExtractZipFileIT extends AbstractIT {
   public ExpectedException expectedException = ExpectedException.none();
 
   @Test
-  public void testExtractAllStoreAndNoEncryptionExtractsSuccessfully() throws ZipException {
+  public void testExtractAllStoreAndNoEncryptionExtractsSuccessfully() throws IOException {
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
     ZipFile zipFile = new ZipFile(generatedZipFile);
@@ -38,7 +40,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractAllStoreAndZipStandardEncryptionExtractsSuccessfully() throws ZipException {
+  public void testExtractAllStoreAndZipStandardEncryptionExtractsSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -51,7 +53,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractAllStoreAndAes128EncryptionExtractsSuccessfully() throws ZipException {
+  public void testExtractAllStoreAndAes128EncryptionExtractsSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -64,7 +66,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractAllStoreAndAes256EncryptionExtractsSuccessfully() throws ZipException {
+  public void testExtractAllStoreAndAes256EncryptionExtractsSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     zipParameters.setCompressionMethod(CompressionMethod.STORE);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -77,7 +79,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractAllDeflateAndNoEncryptionExtractsSuccessfully() throws ZipException {
+  public void testExtractAllDeflateAndNoEncryptionExtractsSuccessfully() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     zipFile.addFiles(FILES_TO_ADD);
 
@@ -88,7 +90,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractAllDeflateAndZipStandardEncryptionExtractsSuccessfully() throws ZipException {
+  public void testExtractAllDeflateAndZipStandardEncryptionExtractsSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
@@ -100,7 +102,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractAllDeflateAndAes128EncryptionExtractsSuccessfully() throws ZipException {
+  public void testExtractAllDeflateAndAes128EncryptionExtractsSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
@@ -112,7 +114,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractAllDeflateAndAes256EncryptionExtractsSuccessfully() throws ZipException {
+  public void testExtractAllDeflateAndAes256EncryptionExtractsSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
@@ -124,7 +126,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractFileWithFileHeaderWithAes128() throws ZipException {
+  public void testExtractFileWithFileHeaderWithAes128() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
@@ -138,7 +140,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractFileWithFileHeaderWithAes128AndInDirectory() throws ZipException {
+  public void testExtractFileWithFileHeaderWithAes128AndInDirectory() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFolder(TestUtils.getFileFromResources(""), zipParameters);
@@ -151,7 +153,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractFileWithFileHeaderWithAes256AndWithANewFileName() throws ZipException {
+  public void testExtractFileWithFileHeaderWithAes256AndWithANewFileName() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
@@ -176,7 +178,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractFileWithFileNameWithZipStandardEncryption() throws ZipException {
+  public void testExtractFileWithFileNameWithZipStandardEncryption() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFolder(TestUtils.getFileFromResources(""), zipParameters);
@@ -188,7 +190,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testExtractFileWithFileNameWithZipStandardEncryptionAndNewFileName() throws ZipException {
+  public void testExtractFileWithFileNameWithZipStandardEncryptionAndNewFileName() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFolder(TestUtils.getFileFromResources(""), zipParameters);
@@ -200,6 +202,55 @@ public class ExtractZipFileIT extends AbstractIT {
     ZipFileVerifier.verifyFileContent(TestUtils.getFileFromResources("sample_directory/favicon.ico"), outputFile);
   }
 
+  @Test
+  public void testExtractFilesThrowsExceptionForWrongPasswordForAes() throws ZipException {
+    ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    zipFile.addFiles(FILES_TO_ADD, zipParameters);
+
+    try {
+      zipFile = new ZipFile(generatedZipFile, "WRONG_PASSWORD".toCharArray());
+      zipFile.extractAll(outputFolder.getPath());
+      fail("Should throw an exception");
+    } catch (ZipException e) {
+      assertThat(e).isNotNull();
+      assertThat(e.getType()).isEqualTo(ZipException.Type.WRONG_PASSWORD);
+    }
+  }
+
+  @Test
+  public void testExtractFilesThrowsExceptionForWrongPasswordForZipStandardAndDeflate() throws ZipException {
+    ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    zipFile.addFiles(FILES_TO_ADD, zipParameters);
+
+    try {
+      zipFile = new ZipFile(generatedZipFile, "WRONG_PASSWORD".toCharArray());
+      zipFile.extractAll(outputFolder.getPath());
+      fail("Should throw an exception");
+    } catch (ZipException e) {
+      assertThat(e).isNotNull();
+      assertThat(e.getType()).isEqualTo(ZipException.Type.WRONG_PASSWORD);
+    }
+  }
+
+  @Test
+  public void testExtractFilesThrowsExceptionForWrongPasswordForZipStandardAndStore() throws ZipException {
+    ZipParameters zipParameters = createZipParameters(EncryptionMethod.ZIP_STANDARD, null);
+    zipParameters.setCompressionMethod(CompressionMethod.STORE);
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    zipFile.addFiles(FILES_TO_ADD, zipParameters);
+
+    try {
+      zipFile = new ZipFile(generatedZipFile, "WRONG_PASSWORD".toCharArray());
+      zipFile.extractAll(outputFolder.getPath());
+      fail("Should throw an exception");
+    } catch (ZipException e) {
+      assertThat(e).isNotNull();
+      assertThat(e.getType()).isEqualTo(ZipException.Type.WRONG_PASSWORD);
+    }
+  }
+
   private void verifyNumberOfFilesInOutputFolder(File outputFolder, int numberOfExpectedFiles) {
     assertThat(outputFolder.listFiles()).hasSize(numberOfExpectedFiles);
   }
diff --git a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
index 29d5880..929e357 100644
--- a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
@@ -30,7 +30,7 @@ public class MiscZipFileIT extends AbstractIT {
   public ExpectedException expectedException = ExpectedException.none();
 
   @Test
-  public void testMergeSplitZipFilesMergesSuccessfully() throws ZipException {
+  public void testMergeSplitZipFilesMergesSuccessfully() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
     filesToAdd.add(TestUtils.getFileFromResources("file_PDF_1MB.pdf"));
@@ -44,7 +44,7 @@ public class MiscZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testMergeSplitZipFilesWithAesEncryptionMergesSuccessfully() throws ZipException {
+  public void testMergeSplitZipFilesWithAesEncryptionMergesSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
@@ -283,7 +283,7 @@ public class MiscZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testGetInputStreamWithoutEncryptionReturnsSuccessfully() throws ZipException, IOException {
+  public void testGetInputStreamWithoutEncryptionReturnsSuccessfully() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     zipFile.addFiles(FILES_TO_ADD);
 
@@ -295,7 +295,7 @@ public class MiscZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testGetInputStreamWithAesEncryptionReturnsSuccessfully() throws ZipException, IOException {
+  public void testGetInputStreamWithAesEncryptionReturnsSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFiles(FILES_TO_ADD, zipParameters);
@@ -307,7 +307,7 @@ public class MiscZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testGetInputStreamWithAesEncryptionAndSplitFileReturnsSuccessfully() throws ZipException, IOException {
+  public void testGetInputStreamWithAesEncryptionAndSplitFileReturnsSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
@@ -369,7 +369,7 @@ public class MiscZipFileIT extends AbstractIT {
   }
 
   @Test
-  public void testRenameZipFileAfterExtractionWithInputStreamSucceeds() throws ZipException, IOException {
+  public void testRenameZipFileAfterExtractionWithInputStreamSucceeds() throws IOException {
     new ZipFile(generatedZipFile).addFiles(FILES_TO_ADD);
 
     ZipFile zipFile = new ZipFile(generatedZipFile);
@@ -388,7 +388,7 @@ public class MiscZipFileIT extends AbstractIT {
     assertThat(new File(oldFile)).doesNotExist();
   }
 
-  private void verifyInputStream(InputStream inputStream, File fileToCompareAgainst) throws IOException, ZipException {
+  private void verifyInputStream(InputStream inputStream, File fileToCompareAgainst) throws IOException {
     File outputFile = temporaryFolder.newFile();
     try (OutputStream outputStream = new FileOutputStream(outputFile)) {
       byte[] b = new byte[InternalZipConstants.BUFF_SIZE];
diff --git a/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java b/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
index 84b8db0..8ca0be2 100644
--- a/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
+++ b/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
@@ -13,6 +13,7 @@ import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
@@ -59,7 +60,7 @@ public class RemoveFilesFromZipIT extends AbstractIT {
   }
 
   @Test
-  public void testRemoveFileAsFileNameRemovesSuccessfully() throws ZipException {
+  public void testRemoveFileAsFileNameRemovesSuccessfully() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     zipFile.addFiles(FILES_TO_ADD);
 
@@ -70,7 +71,7 @@ public class RemoveFilesFromZipIT extends AbstractIT {
   }
 
   @Test
-  public void testRemoveFileAsFileNameRemovesSuccessfullyWithFolderNameInPath() throws ZipException {
+  public void testRemoveFileAsFileNameRemovesSuccessfullyWithFolderNameInPath() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFolder(TestUtils.getFileFromResources(""), zipParameters);
@@ -95,7 +96,7 @@ public class RemoveFilesFromZipIT extends AbstractIT {
   }
 
   @Test
-  public void testRemoveFileAsFileHeaderRemovesSuccessfully() throws ZipException {
+  public void testRemoveFileAsFileHeaderRemovesSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     zipFile.addFolder(TestUtils.getFileFromResources(""), zipParameters);
diff --git a/src/test/java/net/lingala/zip4j/ZipFileZip64IT.java b/src/test/java/net/lingala/zip4j/ZipFileZip64IT.java
index f87c553..d84654a 100644
--- a/src/test/java/net/lingala/zip4j/ZipFileZip64IT.java
+++ b/src/test/java/net/lingala/zip4j/ZipFileZip64IT.java
@@ -1,6 +1,5 @@
 package net.lingala.zip4j;
 
-import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.headers.HeaderReader;
 import net.lingala.zip4j.io.outputstream.ZipOutputStream;
 import net.lingala.zip4j.model.ZipModel;
@@ -14,7 +13,6 @@ import net.lingala.zip4j.utils.ZipFileVerifier;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
-import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -28,7 +26,7 @@ public class ZipFileZip64IT extends AbstractIT {
   private byte[] readBuffer = new byte[4096];
 
   @Test
-  public void testZip64WithSingleLargeZipEntry() throws IOException, ZipException {
+  public void testZip64WithSingleLargeZipEntry() throws IOException {
     long entrySize = InternalZipConstants.ZIP_64_SIZE_LIMIT + 1;
 
     ZipParameters zipParameters = new ZipParameters();
@@ -42,7 +40,7 @@ public class ZipFileZip64IT extends AbstractIT {
   }
 
   @Test
-  public void testZip64WithCentralDirectoryOffsetGreaterThanZip64Limit() throws IOException, ZipException {
+  public void testZip64WithCentralDirectoryOffsetGreaterThanZip64Limit() throws IOException {
     long eachEntrySize = (InternalZipConstants.ZIP_64_SIZE_LIMIT / 2) + 100;
 
     ZipParameters zipParameters = new ZipParameters();
@@ -55,7 +53,7 @@ public class ZipFileZip64IT extends AbstractIT {
   }
 
   @Test
-  public void testZip64WithNumberOfEntriesGreaterThan70k() throws IOException, ZipException {
+  public void testZip64WithNumberOfEntriesGreaterThan70k() throws IOException {
     long eachEntrySize = 100;
 
     ZipParameters zipParameters = new ZipParameters();
@@ -68,7 +66,7 @@ public class ZipFileZip64IT extends AbstractIT {
     verifyZip64HeadersPresent();
   }
 
-  private void verifyZip64HeadersPresent() throws FileNotFoundException, ZipException {
+  private void verifyZip64HeadersPresent() throws IOException {
     HeaderReader headerReader = new HeaderReader();
     ZipModel zipModel = headerReader.readAllHeaders(new RandomAccessFile(generatedZipFile,
         RandomAccessFileMode.READ.getValue()));
@@ -95,5 +93,4 @@ public class ZipFileZip64IT extends AbstractIT {
       }
     }
   }
-
 }
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
index 8421e86..49740ab 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
@@ -56,7 +56,7 @@ public class HeaderWriterIT extends AbstractIT {
   private HeaderReader headerReader = new HeaderReader();
 
   @Test
-  public void testWriteLocalFileHeaderSimpleLocalFileHeaderSuccessScenario() throws IOException, ZipException {
+  public void testWriteLocalFileHeaderSimpleLocalFileHeaderSuccessScenario() throws IOException {
     ZipModel zipModel = createZipModel(10);
     LocalFileHeader localFileHeaderToWrite = createLocalFileHeader("LFH", COMPRESSED_SIZE, UNCOMPRESSED_SIZE, true);
     File headersFile = temporaryFolder.newFile();
@@ -72,7 +72,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testWriteLocalFileHeaderForZip64Format() throws IOException, ZipException {
+  public void testWriteLocalFileHeaderForZip64Format() throws IOException {
     ZipModel zipModel = createZipModel(10);
     LocalFileHeader localFileHeaderToWrite = createLocalFileHeader("LFH", COMPRESSED_SIZE_ZIP64,
         UNCOMPRESSED_SIZE_ZIP64, true);
@@ -95,65 +95,63 @@ public class HeaderWriterIT extends AbstractIT {
 
   @Test
   public void testWriteLocalFileHeaderJapaneseCharactersInFileNameAndWithUtf8FlagShouldMatch()
-      throws IOException, ZipException {
+      throws IOException {
     testWriteLocalFileHeaderWithFileName("", true, true);
   }
 
   @Test
   public void testWriteLocalFileHeaderEnglishCharactersInFileNameWithoutUtf8ShouldMatch()
-      throws IOException, ZipException {
+      throws IOException {
     testWriteLocalFileHeaderWithFileName("SOME_TEXT", false, true);
   }
 
   @Test
   public void testWriteLocalFileHeaderJapaneseCharactersInFileNameWithoutUtf8ShouldNotMatch()
-      throws IOException, ZipException {
+      throws IOException {
     testWriteLocalFileHeaderWithFileName("", false, false);
   }
 
   @Test
-  public void testWriteLocalFileHeaderWithAes256() throws IOException, ZipException {
+  public void testWriteLocalFileHeaderWithAes256() throws IOException {
     testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_256);
   }
 
   @Test
-  public void testWriteLocalFileHeaderWithAes192() throws IOException, ZipException {
+  public void testWriteLocalFileHeaderWithAes192() throws IOException {
     testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_192);
   }
 
   @Test
-  public void testWriteLocalFileHeaderWithAes128() throws IOException, ZipException {
+  public void testWriteLocalFileHeaderWithAes128() throws IOException {
     testWriteLocalFileHeaderWithAes(AesKeyStrength.KEY_STRENGTH_128);
   }
 
   @Test
-  public void testWriteExtendedLocalFileHeaderWhenLocalFileHeaderIsNullThrowsException()
-      throws IOException, ZipException {
+  public void testWriteExtendedLocalFileHeaderWhenLocalFileHeaderIsNullThrowsException() throws IOException {
     expectedException.expectMessage("input parameters is null, cannot write extended local header");
     expectedException.expect(ZipException.class);
     headerWriter.writeExtendedLocalHeader(null, new FileOutputStream(temporaryFolder.newFile()));
   }
 
   @Test
-  public void testWriteExtendedLocalFileHeaderWhenOutputStreamIsNullThrowsException()
-      throws IOException, ZipException {
+  public void testWriteExtendedLocalFileHeaderWhenOutputStreamIsNullThrowsException() throws IOException {
     expectedException.expectMessage("input parameters is null, cannot write extended local header");
     expectedException.expect(ZipException.class);
     headerWriter.writeExtendedLocalHeader(new LocalFileHeader(), null);
   }
 
   @Test
-  public void testWriteExtendedLocalFileHeaderNonZip64FormatWritesSuccessfully() throws IOException, ZipException {
+  public void testWriteExtendedLocalFileHeaderNonZip64FormatWritesSuccessfully() throws IOException {
     testWriteExtendedLocalFileHeader(COMPRESSED_SIZE + 99, UNCOMPRESSED_SIZE + 423, 2342342L, false);
   }
 
   @Test
-  public void testWriteExtendedLocalFileHeaderZip64FormatWritesSuccessfully() throws IOException, ZipException {
+  public void testWriteExtendedLocalFileHeaderZip64FormatWritesSuccessfully() throws IOException {
     testWriteExtendedLocalFileHeader(COMPRESSED_SIZE_ZIP64 + 99, UNCOMPRESSED_SIZE_ZIP64 + 423, 32452342L, true);
   }
 
   @Test
-  public void testFinalizeZipFileWhenZipModelNullThrowsException() throws ZipException, IOException {
+  public void testFinalizeZipFileWhenZipModelNullThrowsException() throws IOException {
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("input parameters is null, cannot finalize zip file");
 
@@ -161,7 +159,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testFinalizeZipFileWhenOutputStreamIsNullThrowsException() throws ZipException, IOException {
+  public void testFinalizeZipFileWhenOutputStreamIsNullThrowsException() throws IOException {
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("input parameters is null, cannot finalize zip file");
 
@@ -169,7 +167,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testFinalizeZipFileForNonZip64Format() throws ZipException, IOException {
+  public void testFinalizeZipFileForNonZip64Format() throws IOException {
     ZipModel zipModel = createZipModel(10);
     File headersFile = temporaryFolder.newFile();
 
@@ -190,7 +188,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testFinalizeZipFileForZip64Format() throws ZipException, IOException {
+  public void testFinalizeZipFileForZip64Format() throws IOException {
     ZipModel zipModel = createZipModel(10, COMPRESSED_SIZE_ZIP64, UNCOMPRESSED_SIZE_ZIP64);
     File headersFile = temporaryFolder.newFile();
 
@@ -212,7 +210,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testFinalizeZipFileForAes() throws ZipException, IOException {
+  public void testFinalizeZipFileForAes() throws IOException {
     ZipModel zipModel = createZipModel(10);
     setFileHeadersAsAesEncrypted(zipModel.getCentralDirectory().getFileHeaders(), AesKeyStrength.KEY_STRENGTH_192);
     File headersFile = temporaryFolder.newFile();
@@ -233,7 +231,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testFinalizeZipFileForZip64FormatForSplitFileWithSplitOutputStream() throws ZipException, IOException {
+  public void testFinalizeZipFileForZip64FormatForSplitFileWithSplitOutputStream() throws IOException {
     ZipModel zipModel = createZipModel(10, COMPRESSED_SIZE_ZIP64, UNCOMPRESSED_SIZE_ZIP64);
     zipModel.setZip64EndOfCentralDirectoryRecord(null);
     zipModel.setZip64EndOfCentralDirectoryLocator(null);
@@ -257,7 +255,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testFinalizeZipFileForZip64FormatForSplitFileWithCountingOutputStream() throws ZipException, IOException {
+  public void testFinalizeZipFileForZip64FormatForSplitFileWithCountingOutputStream() throws IOException {
     ZipModel zipModel = createZipModel(10, COMPRESSED_SIZE_ZIP64, UNCOMPRESSED_SIZE_ZIP64);
     File headersFile = temporaryFolder.newFile();
 
@@ -279,7 +277,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testFinalizeZipFileWithoutValidationsWhenZipModelNullThrowsException() throws ZipException, IOException {
+  public void testFinalizeZipFileWithoutValidationsWhenZipModelNullThrowsException() throws IOException {
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("input parameters is null, cannot finalize zip file");
 
@@ -288,7 +286,7 @@ public class HeaderWriterIT extends AbstractIT {
 
   @Test
   public void testFinalizeZipFileWithoutValidationsWhenOutputStreamIsNullThrowsException()
-      throws ZipException {
+      throws IOException {
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("input parameters is null, cannot finalize zip file");
 
@@ -296,7 +294,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testFinalizeZipFileWithoutValidationsForNonZip64Format() throws ZipException, IOException {
+  public void testFinalizeZipFileWithoutValidationsForNonZip64Format() throws IOException {
     ZipModel zipModel = createZipModel(10);
     File headersFile = temporaryFolder.newFile();
 
@@ -317,7 +315,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testFinalizeZipFileWithoutValidationsForZip64Format() throws ZipException, IOException {
+  public void testFinalizeZipFileWithoutValidationsForZip64Format() throws IOException {
     ZipModel zipModel = createZipModel(10, COMPRESSED_SIZE_ZIP64, UNCOMPRESSED_SIZE_ZIP64);
     File headersFile = temporaryFolder.newFile();
 
@@ -339,7 +337,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testUpdateLocalFileHeaderWhenFileHeaderIsNullThrowsException() throws ZipException, IOException {
+  public void testUpdateLocalFileHeaderWhenFileHeaderIsNullThrowsException() throws IOException {
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("invalid input parameters, cannot update local file header");
 
@@ -347,7 +345,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testUpdateLocalFileHeaderWhenZipModelIsNullThrowsException() throws ZipException, IOException {
+  public void testUpdateLocalFileHeaderWhenZipModelIsNullThrowsException() throws IOException {
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("invalid input parameters, cannot update local file header");
 
@@ -355,7 +353,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testUpdateLocalFileHeaderForNonZip64() throws IOException, ZipException {
+  public void testUpdateLocalFileHeaderForNonZip64() throws IOException {
     File headersFile = temporaryFolder.newFile();
     createAndUpdateLocalFileHeader(headersFile, COMPRESSED_SIZE, UNCOMPRESSED_SIZE, 23423);
 
@@ -369,7 +367,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testUpdateLocalFileHeaderForZip64() throws IOException, ZipException {
+  public void testUpdateLocalFileHeaderForZip64() throws IOException {
     File headersFile = temporaryFolder.newFile();
     createAndUpdateLocalFileHeader(headersFile, COMPRESSED_SIZE_ZIP64, UNCOMPRESSED_SIZE_ZIP64, 546423);
 
@@ -386,7 +384,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   public void createAndUpdateLocalFileHeader(File headersFile, long compressedSize, long uncompressedSize, long crc)
-      throws IOException, ZipException {
+      throws IOException {
     ZipModel zipModel = createZipModel(3);
     LocalFileHeader localFileHeaderToWrite = createLocalFileHeader("LFH", compressedSize, uncompressedSize, false);
     localFileHeaderToWrite.setCompressedSize(compressedSize);
@@ -440,7 +438,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   private void testWriteExtendedLocalFileHeader(long compressedSize, long uncompressedSize, long crc,
-                                                boolean isZip64Format) throws IOException, ZipException {
+                                                boolean isZip64Format) throws IOException {
     LocalFileHeader localFileHeader = createLocalFileHeader("SOME_NAME", compressedSize, uncompressedSize, true);
     localFileHeader.setCrc(crc);
     localFileHeader.setWriteCompressedSizeInZip64ExtraRecord(isZip64Format);
@@ -465,7 +463,7 @@ public class HeaderWriterIT extends AbstractIT {
     assertThat(dataDescriptor.getCrc()).isEqualTo(crc);
   }
 
-  private void testWriteLocalFileHeaderWithAes(AesKeyStrength aesKeyStrength) throws IOException, ZipException {
+  private void testWriteLocalFileHeaderWithAes(AesKeyStrength aesKeyStrength) throws IOException {
     ZipModel zipModel = createZipModel(10);
     LocalFileHeader localFileHeaderToWrite = createLocalFileHeader("TEXT", COMPRESSED_SIZE, UNCOMPRESSED_SIZE, true);
     localFileHeaderToWrite.setEncryptionMethod(EncryptionMethod.AES);
@@ -503,7 +501,7 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   private void testWriteLocalFileHeaderWithFileName(String fileNameSuffix, boolean useUtf8,
-                                                    boolean expectFileNamesToMatch) throws IOException, ZipException {
+                                                    boolean expectFileNamesToMatch) throws IOException {
     ZipModel zipModel = createZipModel(10);
     LocalFileHeader localFileHeaderToWrite = createLocalFileHeader(fileNameSuffix, COMPRESSED_SIZE, UNCOMPRESSED_SIZE,
         useUtf8);
diff --git a/src/test/java/net/lingala/zip4j/util/CrcUtilIT.java b/src/test/java/net/lingala/zip4j/util/CrcUtilIT.java
index 4465694..4ee5c34 100644
--- a/src/test/java/net/lingala/zip4j/util/CrcUtilIT.java
+++ b/src/test/java/net/lingala/zip4j/util/CrcUtilIT.java
@@ -27,7 +27,7 @@ public class CrcUtilIT extends AbstractIT {
   private ProgressMonitor progressMonitor = new ProgressMonitor();
 
   @Test
-  public void testComputeFileCrcThrowsExceptionWhenFileIsNull() throws ZipException {
+  public void testComputeFileCrcThrowsExceptionWhenFileIsNull() throws IOException {
     expectedException.expectMessage("input file is null or does not exist or cannot read. " +
         "Cannot calculate CRC for the file");
     expectedException.expect(ZipException.class);
@@ -36,7 +36,7 @@ public class CrcUtilIT extends AbstractIT {
   }
 
   @Test
-  public void testComputeFileCrcThrowsExceptionWhenCannotReadFile() throws ZipException {
+  public void testComputeFileCrcThrowsExceptionWhenCannotReadFile() throws IOException {
     expectedException.expectMessage("input file is null or does not exist or cannot read. " +
         "Cannot calculate CRC for the file");
     expectedException.expect(ZipException.class);
@@ -48,7 +48,7 @@ public class CrcUtilIT extends AbstractIT {
   }
 
   @Test
-  public void testComputeFileCrcThrowsExceptionWhenFileDoesNotExist() throws ZipException {
+  public void testComputeFileCrcThrowsExceptionWhenFileDoesNotExist() throws IOException {
     expectedException.expectMessage("input file is null or does not exist or cannot read. " +
         "Cannot calculate CRC for the file");
     expectedException.expect(ZipException.class);
@@ -57,13 +57,13 @@ public class CrcUtilIT extends AbstractIT {
   }
 
   @Test
-  public void testComputeFileCrcGetsValueSuccessfully() throws ZipException, IOException {
+  public void testComputeFileCrcGetsValueSuccessfully() throws IOException {
     testComputeFileCrcForFile(getFileFromResources("sample.pdf"));
     testComputeFileCrcForFile(getFileFromResources("sample_text1.txt"));
     testComputeFileCrcForFile(getFileFromResources("sample_text_large.txt"));
   }
 
-  private void testComputeFileCrcForFile(File file) throws ZipException, IOException {
+  private void testComputeFileCrcForFile(File file) throws IOException {
     long actualFileCrc = calculateFileCrc(file);
     assertThat(CrcUtil.computeFileCrc(file, progressMonitor)).isEqualTo(actualFileCrc);
   }
diff --git a/src/test/java/net/lingala/zip4j/utils/ZipFileVerifier.java b/src/test/java/net/lingala/zip4j/utils/ZipFileVerifier.java
index f8a0f06..a841005 100644
--- a/src/test/java/net/lingala/zip4j/utils/ZipFileVerifier.java
+++ b/src/test/java/net/lingala/zip4j/utils/ZipFileVerifier.java
@@ -1,13 +1,13 @@
 package net.lingala.zip4j.utils;
 
 import net.lingala.zip4j.ZipFile;
-import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.LocalFileHeader;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.util.CrcUtil;
 import net.lingala.zip4j.util.FileUtils;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.List;
 
 import static net.lingala.zip4j.util.BitUtils.isBitSet;
@@ -16,18 +16,18 @@ import static org.assertj.core.api.Assertions.assertThat;
 public class ZipFileVerifier {
 
   public static void verifyZipFileByExtractingAllFiles(File zipFileToExtract, File outputFolder,
-                                                       int expectedNumberOfEntries) throws ZipException {
+                                                       int expectedNumberOfEntries) throws IOException {
     verifyZipFileByExtractingAllFiles(zipFileToExtract, null, outputFolder, expectedNumberOfEntries);
   }
 
   public static void verifyZipFileByExtractingAllFiles(File zipFileToExtract, char[] password, File outputFolder,
-                                                       int expectedNumberOfEntries) throws ZipException {
+                                                       int expectedNumberOfEntries) throws IOException {
     verifyZipFileByExtractingAllFiles(zipFileToExtract, password, outputFolder, expectedNumberOfEntries, true);
   }
 
   public static void verifyZipFileByExtractingAllFiles(File zipFileToExtract, char[] password, File outputFolder,
                                                        int expectedNumberOfEntries, boolean verifyFileContents)
-      throws ZipException {
+      throws IOException {
 
     assertThat(zipFileToExtract).isNotNull();
     assertThat(zipFileToExtract).exists();
@@ -44,12 +44,12 @@ public class ZipFileVerifier {
     }
   }
 
-  public static void verifyFileContent(File sourceFile, File extractedFile) throws ZipException {
+  public static void verifyFileContent(File sourceFile, File extractedFile) throws IOException {
     assertThat(extractedFile.length()).isEqualTo(sourceFile.length());
     verifyFileCrc(sourceFile, extractedFile);
   }
 
-  public static void verifyFolderContentsSameAsSourceFiles(File outputFolder) throws ZipException {
+  public static void verifyFolderContentsSameAsSourceFiles(File outputFolder) throws IOException {
     File[] filesInOutputFolder = outputFolder.listFiles();
 
     for (File file : filesInOutputFolder) {
@@ -69,7 +69,7 @@ public class ZipFileVerifier {
     return localFileHeader.getUncompressedSize();
   }
 
-  private static void verifyFileCrc(File sourceFile, File extractedFile) throws ZipException {
+  private static void verifyFileCrc(File sourceFile, File extractedFile) throws IOException {
     ProgressMonitor progressMonitor = new ProgressMonitor();
     long sourceFileCrc = CrcUtil.computeFileCrc(sourceFile, progressMonitor);
     long extractedFileCrc = CrcUtil.computeFileCrc(extractedFile, progressMonitor);
