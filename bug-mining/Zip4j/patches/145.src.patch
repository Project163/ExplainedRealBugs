diff --git a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
index 353762a..28547f9 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
@@ -17,6 +17,8 @@ import net.lingala.zip4j.util.Zip4jUtil;
 import java.io.IOException;
 import java.io.InputStream;
 
+import static net.lingala.zip4j.util.Zip4jUtil.getCompressionMethod;
+
 public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipTaskParameters> {
 
   public AddStreamToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter, AsyncTaskParameters asyncTaskParameters) {
@@ -36,15 +38,16 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
     removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(),
         progressMonitor);
 
-    // For streams, it is necessary to write extended local file header because of Zip standard encryption.
-    // If we do not write extended local file header, zip standard encryption needs a crc upfront for key,
-    // which cannot be calculated until we read the complete stream. If we use extended local file header,
-    // last modified file time is used, or current system time if not available.
-    taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true);
-
     if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) {
       // Set some random value here. This will be updated again when closing entry
       taskParameters.zipParameters.setEntrySize(0);
+      taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false);
+    } else {
+      // For streams, it is necessary to write extended local file header because of Zip standard encryption.
+      // If we do not write extended local file header, zip standard encryption needs a crc upfront for key,
+      // which cannot be calculated until we read the complete stream. If we use extended local file header,
+      // last modified file time is used, or current system time if not available.
+      taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true);
     }
 
     try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength());
@@ -65,7 +68,7 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
 
       FileHeader fileHeader = zipOutputStream.closeEntry();
 
-      if (fileHeader.getCompressionMethod().equals(CompressionMethod.STORE)) {
+      if (CompressionMethod.STORE.equals(getCompressionMethod(fileHeader))) {
         updateLocalFileHeader(fileHeader, splitOutputStream);
       }
     }
diff --git a/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java b/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java
index 4925bb7..39a8f56 100755
--- a/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java
+++ b/src/main/java/net/lingala/zip4j/util/Zip4jUtil.java
@@ -17,7 +17,7 @@
 package net.lingala.zip4j.util;
 
 import net.lingala.zip4j.exception.ZipException;
-import net.lingala.zip4j.model.LocalFileHeader;
+import net.lingala.zip4j.model.AbstractFileHeader;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 
 import java.io.File;
@@ -112,7 +112,7 @@ public class Zip4jUtil {
     }
   }
 
-  public static CompressionMethod getCompressionMethod(LocalFileHeader localFileHeader) {
+  public static CompressionMethod getCompressionMethod(AbstractFileHeader localFileHeader) {
     if (localFileHeader.getCompressionMethod() != CompressionMethod.AES_INTERNAL_ONLY) {
       return localFileHeader.getCompressionMethod();
     }
diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index 89943ab..df18d5f 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -872,6 +872,23 @@ public class AddFilesToZipIT extends AbstractIT {
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 1);
   }
 
+  @Test
+  public void testAddStreamWithStoreCompressionAndAesEncryptionWorksFine() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    File fileToAdd = TestUtils.getTestFileFromResources("sample.pdf");
+
+    try(InputStream inputStream = new FileInputStream(fileToAdd)) {
+      ZipParameters zipParameters = new ZipParameters();
+      zipParameters.setCompressionMethod(CompressionMethod.STORE);
+      zipParameters.setEncryptionMethod(EncryptionMethod.AES);
+      zipParameters.setEncryptFiles(true);
+      zipParameters.setFileNameInZip(fileToAdd.getName());
+      zipFile.addStream(inputStream, zipParameters);
+    }
+
+    extractZipFileWithStream(generatedZipFile, PASSWORD);
+  }
+
   @Test
   public void testAddFolderWithCustomBufferSize() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
@@ -1041,4 +1058,15 @@ public class AddFilesToZipIT extends AbstractIT {
     assertThat(fileHeader.getVersionMadeBy()).isEqualTo(versionMadeBy);
     assertThat(fileHeader.getVersionNeededToExtract()).isEqualTo(versionNeededToExtract);
   }
+
+  @SuppressWarnings("StatementWithEmptyBody")
+  private void extractZipFileWithStream(File zipFileToExtract, char[] password) throws IOException {
+    byte[] readBuff = new byte[InternalZipConstants.BUFF_SIZE];
+    try (ZipInputStream inputStream = new ZipInputStream(new FileInputStream(zipFileToExtract), password)) {
+      while ((inputStream.getNextEntry()) != null) {
+        while (inputStream.read(readBuff) != -1) {
+        }
+      }
+    }
+  }
 }
