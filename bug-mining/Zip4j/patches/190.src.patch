diff --git a/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java
index 2813ab7..718343e 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddFilesToZipTask.java
@@ -7,11 +7,16 @@ import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.AddFilesToZipTask.AddFilesToZipTaskParameters;
+import net.lingala.zip4j.util.FileUtils;
 
 import java.io.File;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.List;
 
+import static net.lingala.zip4j.model.ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY;
+import static net.lingala.zip4j.util.FileUtils.isSymbolicLink;
+
 public class AddFilesToZipTask extends AbstractAddFileToZipTask<AddFilesToZipTaskParameters> {
 
   public AddFilesToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter,
@@ -24,7 +29,8 @@ public class AddFilesToZipTask extends AbstractAddFileToZipTask<AddFilesToZipTas
       throws IOException {
 
     verifyZipParameters(taskParameters.zipParameters);
-    addFilesToZip(taskParameters.filesToAdd, progressMonitor, taskParameters.zipParameters, taskParameters.zip4jConfig);
+    List<File> filesToAdd = determineActualFilesToAdd(taskParameters);
+    addFilesToZip(filesToAdd, progressMonitor, taskParameters.zipParameters, taskParameters.zip4jConfig);
   }
 
   @Override
@@ -32,6 +38,22 @@ public class AddFilesToZipTask extends AbstractAddFileToZipTask<AddFilesToZipTas
     return calculateWorkForFiles(taskParameters.filesToAdd, taskParameters.zipParameters);
   }
 
+  private List<File> determineActualFilesToAdd(AddFilesToZipTaskParameters taskParameters) throws ZipException {
+    List<File> filesToAdd = new ArrayList<>();
+
+    for (File inputFile : taskParameters.filesToAdd) {
+      filesToAdd.add(inputFile);
+      boolean isSymLink = isSymbolicLink(inputFile);
+      ZipParameters.SymbolicLinkAction symbolicLinkAction = taskParameters.zipParameters.getSymbolicLinkAction();
+      if (isSymLink && !INCLUDE_LINK_ONLY.equals(symbolicLinkAction)) {
+        filesToAdd.addAll(FileUtils.getFilesInDirectoryRecursive(inputFile, taskParameters.zipParameters));
+      }
+
+    }
+
+    return filesToAdd;
+  }
+
   @Override
   protected ProgressMonitor.Task getTask() {
     return super.getTask();
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
index a84f301..b48a2ef 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
@@ -30,10 +30,7 @@ public class AddFolderToZipTask extends AbstractAddFileToZipTask<AddFolderToZipT
 
   @Override
   protected long calculateTotalWork(AddFolderToZipTaskParameters taskParameters) throws ZipException {
-    List<File> filesToAdd = getFilesInDirectoryRecursive(taskParameters.folderToAdd,
-        taskParameters.zipParameters.isReadHiddenFiles(),
-        taskParameters.zipParameters.isReadHiddenFolders(),
-        taskParameters.zipParameters.getExcludeFileFilter());
+    List<File> filesToAdd = getFilesToAdd(taskParameters);
 
     if (taskParameters.zipParameters.isIncludeRootFolder()) {
       filesToAdd.add(taskParameters.folderToAdd);
@@ -60,10 +57,7 @@ public class AddFolderToZipTask extends AbstractAddFileToZipTask<AddFolderToZipT
   }
 
   private List<File> getFilesToAdd(AddFolderToZipTaskParameters taskParameters) throws ZipException {
-    List<File> filesToAdd = getFilesInDirectoryRecursive(taskParameters.folderToAdd,
-        taskParameters.zipParameters.isReadHiddenFiles(),
-        taskParameters.zipParameters.isReadHiddenFolders(),
-        taskParameters.zipParameters.getExcludeFileFilter());
+    List<File> filesToAdd = getFilesInDirectoryRecursive(taskParameters.folderToAdd, taskParameters.zipParameters);
 
     if (taskParameters.zipParameters.isIncludeRootFolder()) {
       filesToAdd.add(taskParameters.folderToAdd);
diff --git a/src/main/java/net/lingala/zip4j/util/FileUtils.java b/src/main/java/net/lingala/zip4j/util/FileUtils.java
index 5157a6b..3142f78 100644
--- a/src/main/java/net/lingala/zip4j/util/FileUtils.java
+++ b/src/main/java/net/lingala/zip4j/util/FileUtils.java
@@ -1,7 +1,6 @@
 package net.lingala.zip4j.util;
 
 import net.lingala.zip4j.exception.ZipException;
-import net.lingala.zip4j.model.ExcludeFileFilter;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -34,6 +33,9 @@ import static java.nio.file.attribute.PosixFilePermission.OTHERS_WRITE;
 import static java.nio.file.attribute.PosixFilePermission.OWNER_EXECUTE;
 import static java.nio.file.attribute.PosixFilePermission.OWNER_READ;
 import static java.nio.file.attribute.PosixFilePermission.OWNER_WRITE;
+import static net.lingala.zip4j.model.ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY;
+import static net.lingala.zip4j.model.ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE;
+import static net.lingala.zip4j.model.ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY;
 import static net.lingala.zip4j.util.BitUtils.isBitSet;
 import static net.lingala.zip4j.util.BitUtils.setBit;
 import static net.lingala.zip4j.util.InternalZipConstants.FILE_SEPARATOR;
@@ -93,12 +95,8 @@ public class FileUtils {
     }
   }
 
-  public static List<File> getFilesInDirectoryRecursive(File path, boolean readHiddenFiles, boolean readHiddenFolders) throws ZipException {
-    return getFilesInDirectoryRecursive(path, readHiddenFiles, readHiddenFolders, null);
-  }
-
-  public static List<File> getFilesInDirectoryRecursive(File path, boolean readHiddenFiles, boolean readHiddenFolders, ExcludeFileFilter excludedFiles)
-      throws ZipException {
+  public static List<File> getFilesInDirectoryRecursive(File path, ZipParameters zipParameters)
+          throws ZipException {
 
     if (path == null) {
       throw new ZipException("input path is null, cannot read files in the directory");
@@ -112,22 +110,27 @@ public class FileUtils {
     }
 
     for (File file : filesAndDirs) {
-      if (excludedFiles != null && excludedFiles.isExcluded(file)) {
+      if (!isFileRegularOrDirectoryOrSymlink(file)) {
         continue;
       }
 
-      if (file.isHidden()) {
-        if (file.isDirectory()) {
-          if (!readHiddenFolders) {
-            continue;
-          }
-        } else if (!readHiddenFiles) {
-          continue;
-        }
+      if (zipParameters.getExcludeFileFilter() != null && zipParameters.getExcludeFileFilter().isExcluded(file)) {
+        continue;
       }
+
+      if (file.isHidden() && !zipParameters.isReadHiddenFiles()) {
+        continue;
+      }
+
       result.add(file);
-      if (file.isDirectory()) {
-        result.addAll(getFilesInDirectoryRecursive(file, readHiddenFiles, readHiddenFolders, excludedFiles));
+
+      ZipParameters.SymbolicLinkAction symbolicLinkAction = zipParameters.getSymbolicLinkAction();
+      boolean isSymLink = isSymbolicLink(file);
+      // If a symlink's target is a directory, file.isDirectory is true. Only check if file is a directory is file is
+      // not a symlink.
+      if ((isSymLink && !INCLUDE_LINK_ONLY.equals(symbolicLinkAction))
+              || (!isSymLink && file.isDirectory())) {
+        result.addAll(getFilesInDirectoryRecursive(file,zipParameters));
       }
     }
 
@@ -223,7 +226,11 @@ public class FileUtils {
           String rootPath = new File(fileToAdd.getParentFile().getCanonicalFile().getPath() + File.separator + fileToAdd.getCanonicalFile().getName()).getPath();
           tmpFileName = rootPath.substring(rootFolderFileRef.length());
         } else {
-           tmpFileName = fileCanonicalPath.substring(rootFolderFileRef.length());
+          if (!fileCanonicalPath.startsWith(rootFolderFileRef)) {
+            tmpFileName = fileToAdd.getCanonicalFile().getParentFile().getName() + FILE_SEPARATOR + fileToAdd.getCanonicalFile().getName();
+          } else {
+            tmpFileName = fileCanonicalPath.substring(rootFolderFileRef.length());
+          }
         }
 
         if (tmpFileName.startsWith(System.getProperty("file.separator"))) {
@@ -351,8 +358,8 @@ public class FileUtils {
       if (isSymbolicLink(file)) {
         // If symlink is INCLUDE_LINK_ONLY, and if the above condition is true, it means that the link exists and there
         // will be no need to check for link existence explicitly, check only for target file existence if required
-        if (symLinkAction.equals(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE)
-            || symLinkAction.equals(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY)) {
+        if (symLinkAction.equals(INCLUDE_LINK_AND_LINKED_FILE)
+            || symLinkAction.equals(INCLUDE_LINKED_FILE_ONLY)) {
           assertSymbolicLinkTargetExists(file);
         }
       } else {
@@ -574,4 +581,11 @@ public class FileUtils {
       posixFilePermissions.add(posixFilePermissionToAdd);
     }
   }
+
+  private static boolean isFileRegularOrDirectoryOrSymlink(File file) {
+    byte[] fileAttributes = getFileAttributes(file);
+    return  BitUtils.isBitSet(fileAttributes[3], 5)
+            || BitUtils.isBitSet(fileAttributes[3], 6)
+            || BitUtils.isBitSet(fileAttributes[3], 7);
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index bd45991..3eff38b 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -27,6 +27,11 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -34,7 +39,12 @@ import java.util.List;
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
 import static net.lingala.zip4j.testutils.HeaderVerifier.verifyLocalFileHeaderUncompressedSize;
+import static net.lingala.zip4j.testutils.TestUtils.copyDirectory;
+import static net.lingala.zip4j.testutils.TestUtils.copyFileToFolder;
+import static net.lingala.zip4j.testutils.TestUtils.createSymlink;
 import static net.lingala.zip4j.testutils.TestUtils.getFileNamesOfFiles;
+import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
+import static net.lingala.zip4j.testutils.ZipFileVerifier.verifyZipFileByExtractingAllFiles;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
 
@@ -306,6 +316,37 @@ public class AddFilesToZipIT extends AbstractIT {
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 1);
   }
 
+  @Test
+  public void testAddFileWithFileEntryCommentAndUtf8Charset() throws IOException {
+    testCreateZipFileWithFileEntryComment("FILE_COMMET_", StandardCharsets.UTF_8);
+  }
+
+  @Test
+  public void testAddFileWithFileEntryCommentAndNullCharsetUsesUtf8() throws IOException {
+    testCreateZipFileWithFileEntryComment("FILE_COMMET_", null);
+  }
+
+  @Test
+  public void testAddFileWithFileEntryCommentAndGBKCharset() throws IOException {
+    testCreateZipFileWithFileEntryComment("测试中文_", Charset.forName("GBK"));
+  }
+
+  @Test
+  public void testAddingSameFileMultipleTimesResultsInOnlyOneFileInZip() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setFileNameInZip("renamed-file.pdf");
+
+    zipFile.addFile(getTestFileFromResources("sample.pdf"), zipParameters);
+    zipFile.addFile(getTestFileFromResources("sample.pdf"), zipParameters);
+    zipFile.addFile(getTestFileFromResources("sample.pdf"), zipParameters);
+
+    assertThat(zipFile.getFileHeaders()).hasSize(1);
+    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo("renamed-file.pdf");
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 1, false);
+  }
+
   @Test
   public void testAddFilesWithoutParametersWhenZipFileDoesNotExistCreatesSuccessfully() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
@@ -508,6 +549,19 @@ public class AddFilesToZipIT extends AbstractIT {
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 4);
   }
 
+  @Test
+  public void testEncryptWithZipStrongEncryptionThrowsException() throws ZipException {
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG);
+    zipParameters.setEncryptFiles(true);
+
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("ZIP_STANDARD_VARIANT_STRONG encryption method is not supported");
+
+    zipFile.addFiles(FILES_TO_ADD, zipParameters);
+  }
+
   @Test
   public void testAddFolderWithoutZipParameters() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
@@ -905,6 +959,360 @@ public class AddFilesToZipIT extends AbstractIT {
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 13);
   }
 
+  @Test
+  public void testAddSymlinkWithLinkOnly() throws IOException {
+    File targetFile = getTestFileFromResources("sample.pdf");
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+
+    zipFile.addFile(symlink, zipParameters);
+
+    assertThat(zipFile.getFileHeaders()).hasSize(1);
+    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo(symlink.getName());
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 1, false);
+
+    verifyGeneratedSymlink(symlink, targetFile);
+  }
+
+  @Test
+  public void testAddSymlinkWithLinkedFileOnly() throws IOException {
+    File targetFile = getTestFileFromResources("sample.pdf");
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
+
+    zipFile.addFile(symlink, zipParameters);
+
+    assertThat(zipFile.getFileHeaders()).hasSize(1);
+    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo(targetFile.getName());
+    verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 1);
+  }
+
+  @Test
+  public void testAddSymlinkWithLinkAndLinkedFile() throws IOException {
+    File targetFile = getTestFileFromResources("sample.pdf");
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+
+    zipFile.addFile(symlink, zipParameters);
+
+    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
+    assertThat(fileHeaders).hasSize(2);
+    assertThat(fileHeaders.get(0).getFileName()).isEqualTo(symlink.getName());
+    assertThat(fileHeaders.get(1).getFileName()).isEqualTo(targetFile.getName());
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 2, false);
+
+    verifyGeneratedSymlink(symlink, targetFile);
+    File generatedTargetFile = Paths.get(outputFolder.getAbsolutePath(), targetFile.getName()).toFile();
+    ZipFileVerifier.verifyFileCrc(targetFile, generatedTargetFile);
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkOnly() throws IOException {
+    File testFolder = createTestFolderWithSymlinks();
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 6, false);
+    verifyFileNamesInZip(zipFile,
+            "test-folder/",
+            "test-folder/symlink.link",
+            "test-folder/sub-folder1/",
+            "test-folder/sub-folder1/symlink.link",
+            "test-folder/sub-folder2/",
+            "test-folder/sub-folder2/symlink.link");
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkedFilesOnly() throws IOException {
+    File testFolder = createTestFolderWithSymlinks();
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 6, false);
+    verifyFileNamesInZip(zipFile,
+            "test-folder/",
+            "test-folder/sample.pdf",
+            "test-folder/sub-folder1/",
+            "test-folder/sub-folder1/file_PDF_1MB.pdf",
+            "test-folder/sub-folder2/",
+            "test-folder/sub-folder2/sample_text_large.txt");
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkAndLinkedFilesOnly() throws IOException {
+    File testFolder = createTestFolderWithSymlinks();
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 9, false);
+    verifyFileNamesInZip(zipFile,
+            "test-folder/",
+            "test-folder/symlink.link",
+            "test-folder/sample.pdf",
+            "test-folder/sub-folder1/",
+            "test-folder/sub-folder1/symlink.link",
+            "test-folder/sub-folder1/file_PDF_1MB.pdf",
+            "test-folder/sub-folder2/",
+            "test-folder/sub-folder2/sample_text_large.txt",
+            "test-folder/sub-folder2/symlink.link");
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkAndLinkedFilesOnlyWithoutRootFolder() throws IOException {
+    File testFolder = createTestFolderWithSymlinks();
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setIncludeRootFolder(false);
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 8, false);
+    verifyFileNamesInZip(zipFile,
+            "symlink.link",
+            "sample.pdf",
+            "sub-folder1/",
+            "sub-folder1/symlink.link",
+            "sub-folder1/file_PDF_1MB.pdf",
+            "sub-folder2/",
+            "sub-folder2/sample_text_large.txt",
+            "sub-folder2/symlink.link");
+  }
+
+  @Test
+  public void testAddSymlinkWithLinkOnlyMissingTarget() throws IOException {
+    File targetFile = Paths.get(temporaryFolder.getRoot().getAbsolutePath(), "foo").toFile();
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+
+    zipFile.addFile(symlink, zipParameters);
+
+    assertThat(zipFile.getFileHeaders()).hasSize(1);
+    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo(symlink.getName());
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 1, false);
+    verifyGeneratedSymlink(symlink, targetFile);
+  }
+
+  @Test
+  public void testAddSymlinkWithLinkedFileOnlyMissingTargetThrowsException() throws IOException {
+    testAddSymlinkThrowsExceptionForMissingTarget(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
+  }
+
+  @Test
+  public void testAddSymlinkWithLinkAndLinkedFileMissingTargetThrowsException() throws IOException {
+    testAddSymlinkThrowsExceptionForMissingTarget(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+  }
+
+  @Test
+  public void testAddSymlinksInAFolderWithLinkOnlyMissingTarget() throws IOException {
+    Path testFolderPath = temporaryFolder.newFolder("test-folder").toPath();
+    Path subFolder1 = Files.createDirectory(Paths.get(testFolderPath.toString(), "sub-folder1"));
+    Path subFolder2 = Files.createDirectory(Paths.get(testFolderPath.toString(), "sub-folder2"));
+
+    File targetFile = Paths.get(temporaryFolder.getRoot().getAbsolutePath(), "foo").toFile();
+
+    createSymlink(targetFile, testFolderPath.toFile());
+    createSymlink(getTestFileFromResources("file_PDF_1MB.pdf"), subFolder1.toFile());
+    createSymlink(getTestFileFromResources("sample_text_large.txt"), subFolder2.toFile());
+
+    File testFolder = testFolderPath.toFile();
+
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
+
+    zipFile.addFolder(testFolder, zipParameters);
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 6, false);
+    verifyFileNamesInZip(zipFile,
+            "test-folder/",
+            "test-folder/symlink.link",
+            "test-folder/sub-folder1/",
+            "test-folder/sub-folder1/symlink.link",
+            "test-folder/sub-folder2/",
+            "test-folder/sub-folder2/symlink.link");
+  }
+  @Test
+  public void testAddFileSymlinkWithTargetFolderWithIncludeLinkOnly() throws IOException {
+    testAddFileSymlinkWithTargetFolder(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY, 1);
+  }
+
+  @Test
+  public void testAddFileSymlinkWithTargetFolderWithIncludeLinkedFileOnly() throws IOException {
+    testAddFileSymlinkWithTargetFolder(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY, 2);
+  }
+
+  @Test
+  public void testAddFileSymlinkWithTargetFolderWithIncludeLinkAndLinkedFile() throws IOException {
+    testAddFileSymlinkWithTargetFolder(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE, 3);
+  }
+
+  @Test
+  public void testAddFolderSymlinkWithTargetFolderWithIncludeLinkOnly() throws IOException {
+    testAddFolderSymlinkWithTargetFolder(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY, 3);
+  }
+
+  @Test
+  public void testAddFolderSymlinkWithTargetFolderWithIncludeLinkedFileOnly() throws IOException {
+    testAddFolderSymlinkWithTargetFolder(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY, 4);
+  }
+
+  @Test
+  public void testAddFolderSymlinkWithTargetFolderWithIncludeLinkAndLinkedFile() throws IOException {
+    testAddFolderSymlinkWithTargetFolder(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE, 5);
+  }
+
+  private void testAddSymlinkThrowsExceptionForMissingTarget(ZipParameters.SymbolicLinkAction symbolicLinkAction)
+          throws IOException {
+    File targetFile = Paths.get(temporaryFolder.getRoot().getAbsolutePath(), "foo").toFile();
+    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(symbolicLinkAction);
+
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("Symlink target '" + targetFile + "' does not exist for link '" + symlink + "'");
+
+    zipFile.addFile(symlink, zipParameters);
+  }
+
+  private void testCreateZipFileWithFileEntryComment(String fileCommentPrefix, Charset charset) throws IOException {
+    ZipParameters zipParameters = new ZipParameters();
+    ZipFile zipFile = initializeZipFileWithCharset(charset);
+
+    for (int i = 0; i < FILES_TO_ADD.size(); i++) {
+      if (i == 0) {
+        zipParameters.setFileComment(fileCommentPrefix + i);
+      } else {
+        zipParameters.setFileComment(null);
+      }
+      zipFile.addFile(FILES_TO_ADD.get(i), zipParameters);
+    }
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, FILES_TO_ADD.size());
+    verifyFileEntryComment(fileCommentPrefix, charset);
+  }
+
+  private ZipFile initializeZipFileWithCharset(Charset charset) {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    if (charset != null) {
+      zipFile.setCharset(charset);
+    }
+
+    return zipFile;
+  }
+
+  private void verifyGeneratedSymlink(File actualSymlink, File targetFile) throws IOException {
+    File extractedSymlink = Paths.get(outputFolder.getAbsolutePath(), actualSymlink.getName()).toFile();
+    assertThat(Files.isSymbolicLink(extractedSymlink.toPath())).isTrue();
+    assertThat(actualSymlink.length()).isEqualTo(extractedSymlink.length());
+    File generatedTarget = Files.readSymbolicLink(extractedSymlink.toPath()).toFile();
+    assertThat(generatedTarget).isEqualTo(targetFile);
+  }
+
+  private void verifyFileEntryComment(String commentPrefix, Charset charset) throws IOException {
+    ZipFile zipFile = initializeZipFileWithCharset(charset);
+    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
+    for (int i = 0; i < fileHeaders.size(); i++) {
+      FileHeader fileHeader = fileHeaders.get(i);
+      if (i == 0) {
+        assertThat(fileHeader.getFileComment()).isEqualTo(commentPrefix + i);
+      } else {
+        assertThat(fileHeader.getFileComment()).isNull();
+      }
+    }
+  }
+
+  private File createTestFolderWithSymlinks() throws IOException {
+    Path testFolder = temporaryFolder.newFolder("test-folder").toPath();
+    Path subFolder1 = Files.createDirectory(Paths.get(testFolder.toString(), "sub-folder1"));
+    Path subFolder2 = Files.createDirectory(Paths.get(testFolder.toString(), "sub-folder2"));
+
+    createSymlink(getTestFileFromResources("sample.pdf"), testFolder.toFile());
+    createSymlink(getTestFileFromResources("file_PDF_1MB.pdf"), subFolder1.toFile());
+    createSymlink(getTestFileFromResources("sample_text_large.txt"), subFolder2.toFile());
+
+    return testFolder.toFile();
+  }
+
+  private void verifyFileNamesInZip(ZipFile zipFile, String... fileNames) throws ZipException {
+    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
+
+    for (String fileName : fileNames) {
+      boolean entryFound = false;
+      for (FileHeader fileHeader : fileHeaders) {
+        if (fileHeader.getFileName().equals(fileName)) {
+          entryFound = true;
+          break;
+        }
+      }
+
+      if (!entryFound) {
+        fail("Could not find entry: " + fileName + " in zip");
+      }
+    }
+  }
+
+  private void testAddFileSymlinkWithTargetFolder(ZipParameters.SymbolicLinkAction symbolicLinkAction,
+                                                  int numberOfFilesToExpect) throws IOException {
+    File testFolder = temporaryFolder.newFolder("test-folder");
+    File symlink = createSymlinkTestDataWithTargetFolder(testFolder);
+
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(symbolicLinkAction);
+    zipFile.addFile(symlink, zipParameters);
+
+    assertThat(zipFile.getFileHeaders()).hasSize(numberOfFilesToExpect);
+    zipFile = new ZipFile(generatedZipFile);
+    assertThat(zipFile.getFileHeaders()).hasSize(numberOfFilesToExpect);
+  }
+
+  private void testAddFolderSymlinkWithTargetFolder(ZipParameters.SymbolicLinkAction symbolicLinkAction,
+                                                    int numberOfFilesToExpect) throws IOException {
+    File testFolder = temporaryFolder.newFolder("test-folder");
+    createSymlinkTestDataWithTargetFolder(testFolder);
+
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(symbolicLinkAction);
+    zipFile.addFolder(testFolder, zipParameters);
+
+    assertThat(zipFile.getFileHeaders()).hasSize(numberOfFilesToExpect);
+    zipFile = new ZipFile(generatedZipFile);
+    assertThat(zipFile.getFileHeaders()).hasSize(numberOfFilesToExpect);
+  }
+
+  private File createSymlinkTestDataWithTargetFolder(File testDirectory) throws IOException {
+    copyDirectory(getTestFileFromResources("sample_directory"),
+            new File(temporaryFolder.getRoot().getAbsolutePath(), "sample_directory"));
+    File targetFile = Paths.get(temporaryFolder.getRoot().getPath(), "sample_directory").toFile();
+    File symlink = createSymlink(targetFile, testDirectory);
+    copyFileToFolder(getTestFileFromResources("sample.pdf"), testDirectory);
+    return symlink;
+  }
+
   private void verifyZipFileContainsFiles(File generatedZipFile, List<String> fileNames,
                                           CompressionMethod compressionMethod, EncryptionMethod encryptionMethod,
                                           AesKeyStrength aesKeyStrength) throws ZipException {
diff --git a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
index 721f2dd..2873c54 100644
--- a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
@@ -8,7 +8,6 @@ import net.lingala.zip4j.model.enums.AesKeyStrength;
 import net.lingala.zip4j.model.enums.CompressionLevel;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
-import net.lingala.zip4j.testutils.TestUtils;
 import net.lingala.zip4j.testutils.ZipFileVerifier;
 import net.lingala.zip4j.util.FileUtils;
 import net.lingala.zip4j.util.InternalZipConstants;
@@ -20,19 +19,12 @@ import org.junit.rules.ExpectedException;
 import java.io.File;
 import java.io.FilenameFilter;
 import java.io.IOException;
-import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.List;
 
-import static net.lingala.zip4j.testutils.TestUtils.createSymlink;
 import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
 import static net.lingala.zip4j.testutils.ZipFileVerifier.verifyZipFileByExtractingAllFiles;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.fail;
 
 /**
  * Contains Integration tests for create operations of ZipFile
@@ -187,7 +179,7 @@ public class CreateZipFileIT extends AbstractIT {
 
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
-    filesToAdd.add(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"));
+    filesToAdd.add(getTestFileFromResources("file_PDF_1MB.pdf"));
     zipFile.createSplitZipFile(filesToAdd, zipParameters, true, InternalZipConstants.MIN_SPLIT_LENGTH);
 
     verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size() + 1);
@@ -198,7 +190,7 @@ public class CreateZipFileIT extends AbstractIT {
   public void testCreateSplitZipFileDeflateAndWithoutEncryption() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
-    filesToAdd.add(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"));
+    filesToAdd.add(getTestFileFromResources("file_PDF_1MB.pdf"));
 
     zipFile.createSplitZipFile(filesToAdd, new ZipParameters(), true, 716800);
 
@@ -213,7 +205,7 @@ public class CreateZipFileIT extends AbstractIT {
 
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
-    filesToAdd.add(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"));
+    filesToAdd.add(getTestFileFromResources("file_PDF_1MB.pdf"));
     zipFile.createSplitZipFile(filesToAdd, zipParameters, true, 512000);
 
     verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size() + 1);
@@ -227,7 +219,7 @@ public class CreateZipFileIT extends AbstractIT {
 
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
-    filesToAdd.add(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"));
+    filesToAdd.add(getTestFileFromResources("file_PDF_1MB.pdf"));
     zipFile.createSplitZipFile(filesToAdd, zipParameters, true, InternalZipConstants.MIN_SPLIT_LENGTH);
 
     verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size() + 1);
@@ -241,7 +233,7 @@ public class CreateZipFileIT extends AbstractIT {
 
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
     List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
-    filesToAdd.add(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"));
+    filesToAdd.add(getTestFileFromResources("file_PDF_1MB.pdf"));
     zipFile.createSplitZipFile(filesToAdd, zipParameters, true, InternalZipConstants.MIN_SPLIT_LENGTH + 2000);
 
     verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size() + 1);
@@ -259,244 +251,6 @@ public class CreateZipFileIT extends AbstractIT {
     verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size());
   }
 
-  @Test
-  public void testAddFileWithFileEntryCommentAndUtf8Charset() throws IOException {
-    testCreateZipFileWithFileEntryComment("FILE_COMMET_", StandardCharsets.UTF_8);
-  }
-
-  @Test
-  public void testAddFileWithFileEntryCommentAndNullCharsetUsesUtf8() throws IOException {
-    testCreateZipFileWithFileEntryComment("FILE_COMMET_", null);
-  }
-
-  @Test
-  public void testAddFileWithFileEntryCommentAndGBKCharset() throws IOException {
-    testCreateZipFileWithFileEntryComment("测试中文_", Charset.forName("GBK"));
-  }
-
-  @Test
-  public void testAddingSameFileMultipleTimesResultsInOnlyOneFileInZip() throws IOException {
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setFileNameInZip("renamed-file.pdf");
-
-    zipFile.addFile(getTestFileFromResources("sample.pdf"), zipParameters);
-    zipFile.addFile(getTestFileFromResources("sample.pdf"), zipParameters);
-    zipFile.addFile(getTestFileFromResources("sample.pdf"), zipParameters);
-
-    assertThat(zipFile.getFileHeaders()).hasSize(1);
-    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo("renamed-file.pdf");
-
-    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 1, false);
-  }
-
-  @Test
-  public void testAddSymlinkWithLinkOnly() throws IOException {
-    File targetFile = getTestFileFromResources("sample.pdf");
-    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
-
-    zipFile.addFile(symlink, zipParameters);
-
-    assertThat(zipFile.getFileHeaders()).hasSize(1);
-    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo(symlink.getName());
-    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 1, false);
-
-    verifyGeneratedSymlink(symlink, targetFile);
-  }
-
-  @Test
-  public void testAddSymlinkWithLinkedFileOnly() throws IOException {
-    File targetFile = getTestFileFromResources("sample.pdf");
-    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
-
-    zipFile.addFile(symlink, zipParameters);
-
-    assertThat(zipFile.getFileHeaders()).hasSize(1);
-    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo(targetFile.getName());
-    verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 1);
-  }
-
-  @Test
-  public void testAddSymlinkWithLinkAndLinkedFile() throws IOException {
-    File targetFile = getTestFileFromResources("sample.pdf");
-    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
-
-    zipFile.addFile(symlink, zipParameters);
-
-    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
-    assertThat(fileHeaders).hasSize(2);
-    assertThat(fileHeaders.get(0).getFileName()).isEqualTo(symlink.getName());
-    assertThat(fileHeaders.get(1).getFileName()).isEqualTo(targetFile.getName());
-    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 2, false);
-
-    verifyGeneratedSymlink(symlink, targetFile);
-    File generatedTargetFile = Paths.get(outputFolder.getAbsolutePath(), targetFile.getName()).toFile();
-    ZipFileVerifier.verifyFileCrc(targetFile, generatedTargetFile);
-  }
-
-  @Test
-  public void testAddSymlinksInAFolderWithLinkOnly() throws IOException {
-    File testFolder = createTestFolderWithSymlinks();
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
-
-    zipFile.addFolder(testFolder, zipParameters);
-
-    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 6, false);
-    verifyFileNamesInZip(zipFile,
-        "test-folder/",
-        "test-folder/symlink.link",
-        "test-folder/sub-folder1/",
-        "test-folder/sub-folder1/symlink.link",
-        "test-folder/sub-folder2/",
-        "test-folder/sub-folder2/symlink.link");
-  }
-
-  @Test
-  public void testAddSymlinksInAFolderWithLinkedFilesOnly() throws IOException {
-    File testFolder = createTestFolderWithSymlinks();
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
-
-    zipFile.addFolder(testFolder, zipParameters);
-
-    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 6, false);
-    verifyFileNamesInZip(zipFile,
-        "test-folder/",
-        "test-folder/sample.pdf",
-        "test-folder/sub-folder1/",
-        "test-folder/sub-folder1/file_PDF_1MB.pdf",
-        "test-folder/sub-folder2/",
-        "test-folder/sub-folder2/sample_text_large.txt");
-  }
-
-  @Test
-  public void testAddSymlinksInAFolderWithLinkAndLinkedFilesOnly() throws IOException {
-    File testFolder = createTestFolderWithSymlinks();
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
-
-    zipFile.addFolder(testFolder, zipParameters);
-
-    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 9, false);
-    verifyFileNamesInZip(zipFile,
-        "test-folder/",
-        "test-folder/symlink.link",
-        "test-folder/sample.pdf",
-        "test-folder/sub-folder1/",
-        "test-folder/sub-folder1/symlink.link",
-        "test-folder/sub-folder1/file_PDF_1MB.pdf",
-        "test-folder/sub-folder2/",
-        "test-folder/sub-folder2/sample_text_large.txt",
-        "test-folder/sub-folder2/symlink.link");
-  }
-
-  @Test
-  public void testAddSymlinksInAFolderWithLinkAndLinkedFilesOnlyWithoutRootFolder() throws IOException {
-    File testFolder = createTestFolderWithSymlinks();
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setIncludeRootFolder(false);
-    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
-
-    zipFile.addFolder(testFolder, zipParameters);
-
-    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 8, false);
-    verifyFileNamesInZip(zipFile,
-        "symlink.link",
-        "sample.pdf",
-        "sub-folder1/",
-        "sub-folder1/symlink.link",
-        "sub-folder1/file_PDF_1MB.pdf",
-        "sub-folder2/",
-        "sub-folder2/sample_text_large.txt",
-        "sub-folder2/symlink.link");
-  }
-
-  @Test
-  public void testAddSymlinkWithLinkOnlyMissingTarget() throws IOException {
-    File targetFile = Paths.get(temporaryFolder.getRoot().getAbsolutePath(), "foo").toFile();
-    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
-
-    zipFile.addFile(symlink, zipParameters);
-
-    assertThat(zipFile.getFileHeaders()).hasSize(1);
-    assertThat(zipFile.getFileHeaders().get(0).getFileName()).isEqualTo(symlink.getName());
-    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 1, false);
-    verifyGeneratedSymlink(symlink, targetFile);
-  }
-
-  @Test
-  public void testAddSymlinkWithLinkedFileOnlyMissingTargetThrowsException() throws IOException {
-    testAddSymlinkThrowsExceptionForMissingTarget(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY);
-  }
-
-  @Test
-  public void testAddSymlinkWithLinkAndLinkedFileMissingTargetThrowsException() throws IOException {
-    testAddSymlinkThrowsExceptionForMissingTarget(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
-  }
-
-  @Test
-  public void testAddSymlinksInAFolderWithLinkOnlyMissingTarget() throws IOException {
-    Path testFolderPath = temporaryFolder.newFolder("test-folder").toPath();
-    Path subFolder1 = Files.createDirectory(Paths.get(testFolderPath.toString(), "sub-folder1"));
-    Path subFolder2 = Files.createDirectory(Paths.get(testFolderPath.toString(), "sub-folder2"));
-
-    File targetFile = Paths.get(temporaryFolder.getRoot().getAbsolutePath(), "foo").toFile();
-
-    createSymlink(targetFile, testFolderPath.toFile());
-    createSymlink(getTestFileFromResources("file_PDF_1MB.pdf"), subFolder1.toFile());
-    createSymlink(getTestFileFromResources("sample_text_large.txt"), subFolder2.toFile());
-
-    File testFolder = testFolderPath.toFile();
-
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_ONLY);
-
-    zipFile.addFolder(testFolder, zipParameters);
-
-    verifyZipFileByExtractingAllFiles(generatedZipFile, null, outputFolder, 6, false);
-    verifyFileNamesInZip(zipFile,
-        "test-folder/",
-        "test-folder/symlink.link",
-        "test-folder/sub-folder1/",
-        "test-folder/sub-folder1/symlink.link",
-        "test-folder/sub-folder2/",
-        "test-folder/sub-folder2/symlink.link");
-  }
-
-  @Test
-  public void testEncryptWithZipStrongEncryptionThrowsException() throws ZipException {
-    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG);
-    zipParameters.setEncryptFiles(true);
-
-    expectedException.expect(ZipException.class);
-    expectedException.expectMessage("ZIP_STANDARD_VARIANT_STRONG encryption method is not supported");
-
-    zipFile.addFiles(FILES_TO_ADD, zipParameters);
-  }
-
   @Test
   public void testCreateZipFileWithFasterCompressionLevel() throws IOException {
     createZipFileWithCompressionLevel(CompressionLevel.FASTER);
@@ -527,37 +281,6 @@ public class CreateZipFileIT extends AbstractIT {
     verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 3);
   }
 
-  private void testAddSymlinkThrowsExceptionForMissingTarget(ZipParameters.SymbolicLinkAction symbolicLinkAction)
-      throws IOException {
-    File targetFile = Paths.get(temporaryFolder.getRoot().getAbsolutePath(), "foo").toFile();
-    File symlink = createSymlink(targetFile, temporaryFolder.getRoot());
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    ZipParameters zipParameters = new ZipParameters();
-    zipParameters.setSymbolicLinkAction(symbolicLinkAction);
-
-    expectedException.expect(ZipException.class);
-    expectedException.expectMessage("Symlink target '" + targetFile + "' does not exist for link '" + symlink + "'");
-
-    zipFile.addFile(symlink, zipParameters);
-  }
-
-  private void testCreateZipFileWithFileEntryComment(String fileCommentPrefix, Charset charset) throws IOException {
-    ZipParameters zipParameters = new ZipParameters();
-    ZipFile zipFile = initializeZipFileWithCharset(charset);
-
-    for (int i = 0; i < FILES_TO_ADD.size(); i++) {
-      if (i == 0) {
-        zipParameters.setFileComment(fileCommentPrefix + i);
-      } else {
-        zipParameters.setFileComment(null);
-      }
-      zipFile.addFile(FILES_TO_ADD.get(i), zipParameters);
-    }
-
-    verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, FILES_TO_ADD.size());
-    verifyFileEntryComment(fileCommentPrefix, charset);
-  }
-
   private void verifySplitZip(File zipFile, int numberOfExpectedSplitFiles, long splitLength) throws ZipException {
     assertNumberOfSplitFile(zipFile, numberOfExpectedSplitFiles);
     assertSplitFileSizes(zipFile, numberOfExpectedSplitFiles, splitLength);
@@ -621,67 +344,6 @@ public class CreateZipFileIT extends AbstractIT {
     return folder.listFiles(filenameFilter);
   }
 
-  private void verifyFileEntryComment(String commentPrefix, Charset charset) throws IOException {
-    ZipFile zipFile = initializeZipFileWithCharset(charset);
-    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
-    for (int i = 0; i < fileHeaders.size(); i++) {
-      FileHeader fileHeader = fileHeaders.get(i);
-      if (i == 0) {
-        assertThat(fileHeader.getFileComment()).isEqualTo(commentPrefix + i);
-      } else {
-        assertThat(fileHeader.getFileComment()).isNull();
-      }
-    }
-  }
-
-  private ZipFile initializeZipFileWithCharset(Charset charset) {
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-
-    if (charset != null) {
-      zipFile.setCharset(charset);
-    }
-
-    return zipFile;
-  }
-
-  private void verifyGeneratedSymlink(File actualSymlink, File targetFile) throws IOException {
-    File extractedSymlink = Paths.get(outputFolder.getAbsolutePath(), actualSymlink.getName()).toFile();
-    assertThat(Files.isSymbolicLink(extractedSymlink.toPath())).isTrue();
-    assertThat(actualSymlink.length()).isEqualTo(extractedSymlink.length());
-    File generatedTarget = Files.readSymbolicLink(extractedSymlink.toPath()).toFile();
-    assertThat(generatedTarget).isEqualTo(targetFile);
-  }
-
-  private File createTestFolderWithSymlinks() throws IOException {
-    Path testFolder = temporaryFolder.newFolder("test-folder").toPath();
-    Path subFolder1 = Files.createDirectory(Paths.get(testFolder.toString(), "sub-folder1"));
-    Path subFolder2 = Files.createDirectory(Paths.get(testFolder.toString(), "sub-folder2"));
-
-    createSymlink(getTestFileFromResources("sample.pdf"), testFolder.toFile());
-    createSymlink(getTestFileFromResources("file_PDF_1MB.pdf"), subFolder1.toFile());
-    createSymlink(getTestFileFromResources("sample_text_large.txt"), subFolder2.toFile());
-
-    return testFolder.toFile();
-  }
-
-  private void verifyFileNamesInZip(ZipFile zipFile, String... fileNames) throws ZipException {
-    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
-
-    for (String fileName : fileNames) {
-      boolean entryFound = false;
-      for (FileHeader fileHeader : fileHeaders) {
-        if (fileHeader.getFileName().equals(fileName)) {
-          entryFound = true;
-          break;
-        }
-      }
-
-      if (!entryFound) {
-        fail("Could not find entry: " + fileName + " in zip");
-      }
-    }
-  }
-
   private ZipFile createZipFileWithCompressionLevel(CompressionLevel compressionLevel) throws ZipException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     ZipParameters zipParameters = new ZipParameters();
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 95eed79..78c5199 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -555,7 +555,7 @@ public class ExtractZipFileIT extends AbstractIT {
   public void testExtractZipFileWithEndOfCentralDirectoryNotAtExpectedPosition() throws IOException {
     ZipFile zipFile = new ZipFile(getTestArchiveFromResources("end_of_cen_dir_not_at_expected_position.zip"));
     zipFile.extractAll(outputFolder.getPath());
-    List<File> outputFiles = FileUtils.getFilesInDirectoryRecursive(outputFolder, true, true);
+    List<File> outputFiles = FileUtils.getFilesInDirectoryRecursive(outputFolder, new ZipParameters());
 
     assertThat(outputFiles).hasSize(24);
     assertThat(zipFile.getFileHeaders()).hasSize(19);
@@ -594,7 +594,10 @@ public class ExtractZipFileIT extends AbstractIT {
 
     zipFile.extractFile("items/", outputFolderPath);
 
-    List<File> extractedFiles = FileUtils.getFilesInDirectoryRecursive(outputFolder, false, false);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setReadHiddenFiles(false);
+    zipParameters.setReadHiddenFolders(false);
+    List<File> extractedFiles = FileUtils.getFilesInDirectoryRecursive(outputFolder, zipParameters);
     assertThat(extractedFiles).isNotEmpty();
     assertThat(extractedFiles).hasSize(3);
     assertThat(extractedFiles).contains(
@@ -747,7 +750,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   private File getFileWithNameFrom(File outputFolder, String fileName) throws ZipException {
-    List<File> filesInFolder = FileUtils.getFilesInDirectoryRecursive(outputFolder, true, true);
+    List<File> filesInFolder = FileUtils.getFilesInDirectoryRecursive(outputFolder, new ZipParameters());
     for (File file : filesInFolder) {
       if (file.getName().equals(fileName)) {
         return file;
@@ -795,7 +798,10 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   private List<File> getRegularFilesFromFolder(File folder) throws ZipException {
-    List<File> filesInFolder = FileUtils.getFilesInDirectoryRecursive(folder, false, false);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setReadHiddenFiles(false);
+    zipParameters.setReadHiddenFolders(false);
+    List<File> filesInFolder = FileUtils.getFilesInDirectoryRecursive(folder, zipParameters);
 
     List<File> regularFiles = new ArrayList<>();
     for (File file : filesInFolder) {
diff --git a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
index c7700ec..0c5d388 100644
--- a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
@@ -416,7 +416,7 @@ public class MiscZipFileIT extends AbstractIT {
     File newFile = temporaryFolder.newFile("NEW_FILE_NAME.ZIP");
     String oldFile = generatedZipFile.getPath();
 
-    if(TestUtils.isWindows())
+    if(FileUtils.isWindows())
     {
       newFile.delete();
     }
diff --git a/src/test/java/net/lingala/zip4j/testutils/TestUtils.java b/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
index da094ca..14792a2 100644
--- a/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
+++ b/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
@@ -35,11 +35,6 @@ public class TestUtils {
    return getFileFromResources(TEST_ARCHIVES_FOLDER_NAME, fileName);
   }
 
-  public static Boolean isWindows() {
-    String os = System.getProperty("os.name").toLowerCase();
-    return (os.contains("win"));
-  }
-
   /**
    * Splits files with extension .001, .002, etc
    * @param fileToSplit file to be split
@@ -86,13 +81,35 @@ public class TestUtils {
     Files.copy(sourceFile.toPath(), destinationFile.toPath());
   }
 
+  public static void copyFileToFolder(File sourceFile, File outputFolder) throws IOException {
+    File destinationFile = new File(outputFolder.getAbsolutePath(), sourceFile.getName());
+    copyFile(sourceFile, destinationFile);
+  }
+
   public static void copyFileToFolder(File sourceFile, File outputFolder, int numberOfCopiesToMake) throws IOException {
     for (int i = 0; i < numberOfCopiesToMake; i++) {
-      File destinationFile = Paths.get(outputFolder.getAbsolutePath(), i + ".pdf").toFile();
+      File destinationFile = new File(outputFolder.getAbsolutePath(), i + ".pdf");
       copyFile(sourceFile, destinationFile);
     }
   }
 
+  public static void copyDirectory(File sourceDirectory, File destinationDirectory) throws IOException {
+    if (!destinationDirectory.exists()) {
+      destinationDirectory.mkdir();
+    }
+    for (String f : sourceDirectory.list()) {
+      copyDirectoryCompatibilityMode(new File(sourceDirectory, f), new File(destinationDirectory, f));
+    }
+  }
+
+  public static void copyDirectoryCompatibilityMode(File source, File destination) throws IOException {
+    if (source.isDirectory()) {
+      copyDirectory(source, destination);
+    } else {
+      copyFile(source, destination);
+    }
+  }
+
   public static void createZipFileWithZipOutputStream(File zipFile, List<File> filesToAdd) throws IOException {
 
     byte[] buff = new byte[InternalZipConstants.BUFF_SIZE];
diff --git a/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java b/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java
index 1db447f..662b099 100644
--- a/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java
+++ b/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java
@@ -1,6 +1,7 @@
 package net.lingala.zip4j.testutils;
 
 import net.lingala.zip4j.ZipFile;
+import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.util.CrcUtil;
 import net.lingala.zip4j.util.FileUtils;
@@ -47,7 +48,10 @@ public class ZipFileVerifier {
     zipFile.extractAll(outputFolder.getPath());
     assertThat(zipFile.getFileHeaders().size()).as("Number of file headers").isEqualTo(expectedNumberOfEntries);
 
-    List<File> extractedFiles = FileUtils.getFilesInDirectoryRecursive(outputFolder, true, true);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setReadHiddenFiles(true);
+    zipParameters.setReadHiddenFolders(true);
+    List<File> extractedFiles = FileUtils.getFilesInDirectoryRecursive(outputFolder, zipParameters);
     assertThat(extractedFiles).hasSize(expectedNumberOfEntries);
 
     if (verifyFileContents) {
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
index fedfc70..113ed79 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsIT.java
@@ -6,7 +6,6 @@ import net.lingala.zip4j.model.ExcludeFileFilter;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.RandomAccessFileMode;
 import net.lingala.zip4j.progress.ProgressMonitor;
-import net.lingala.zip4j.testutils.TestUtils;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -23,6 +22,7 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
+import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
 import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -50,7 +50,7 @@ public class FileUtilsIT extends AbstractIT {
 
   @Test
   public void testCopyFilesWhenStartIsSameAsEndDoesNothing() throws IOException {
-    File sourceFile = TestUtils.getTestFileFromResources("sample.pdf");
+    File sourceFile = getTestFileFromResources("sample.pdf");
     File outputFile = temporaryFolder.newFile();
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
         OutputStream outputStream = new FileOutputStream(outputFile)) {
@@ -63,7 +63,7 @@ public class FileUtilsIT extends AbstractIT {
 
   @Test
   public void testCopyFilesCopiesCompleteFile() throws IOException {
-    File sourceFile = TestUtils.getTestFileFromResources("sample.pdf");
+    File sourceFile = getTestFileFromResources("sample.pdf");
     File outputFile = temporaryFolder.newFile();
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
         OutputStream outputStream = new FileOutputStream(outputFile)) {
@@ -75,7 +75,7 @@ public class FileUtilsIT extends AbstractIT {
 
   @Test
   public void testCopyFilesCopiesPartOfFile() throws IOException {
-    File sourceFile = TestUtils.getTestFileFromResources("sample.pdf");
+    File sourceFile = getTestFileFromResources("sample.pdf");
     File outputFile = temporaryFolder.newFile();
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
         OutputStream outputStream = new FileOutputStream(outputFile)) {
@@ -122,17 +122,19 @@ public class FileUtilsIT extends AbstractIT {
 
   @Test
   public void testGetFilesInDirectoryRecursiveWithExcludeFileFilter() throws IOException {
-    File rootFolder = TestUtils.getTestFileFromResources("");
+    File rootFolder = getTestFileFromResources("");
     final List<File> filesToExclude = Arrays.asList(
-        TestUtils.getTestFileFromResources("бореиская.txt"),
-        TestUtils.getTestFileFromResources("sample_directory/favicon.ico")
+        getTestFileFromResources("бореиская.txt"),
+        getTestFileFromResources("sample_directory/favicon.ico")
     );
-    List<File> allFiles = FileUtils.getFilesInDirectoryRecursive(rootFolder, true, true, new ExcludeFileFilter() {
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setExcludeFileFilter(new ExcludeFileFilter() {
       @Override
       public boolean isExcluded(File o) {
         return filesToExclude.contains(o);
       }
     });
+    List<File> allFiles = FileUtils.getFilesInDirectoryRecursive(rootFolder, zipParameters);
 
     assertThat(allFiles).hasSize(10);
     for (File file : allFiles) {
@@ -198,7 +200,7 @@ public class FileUtilsIT extends AbstractIT {
     expectedException.expectMessage("invalid offsets");
     expectedException.expect(ZipException.class);
 
-    File sourceFile = TestUtils.getTestFileFromResources("sample.pdf");
+    File sourceFile = getTestFileFromResources("sample.pdf");
     try(RandomAccessFile randomAccessFile = new RandomAccessFile(sourceFile, RandomAccessFileMode.READ.getValue());
         OutputStream outputStream = new FileOutputStream(temporaryFolder.newFile())) {
       FileUtils.copyFile(randomAccessFile, outputStream, start, offset, progressMonitor, BUFF_SIZE);
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java b/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
index d4335cb..2e2455b 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
@@ -97,52 +97,28 @@ public class FileUtilsTest {
     expectedException.expectMessage("input path is null, cannot read files in the directory");
     expectedException.expect(ZipException.class);
 
-    FileUtils.getFilesInDirectoryRecursive(null, true, true);
+    FileUtils.getFilesInDirectoryRecursive(null, new ZipParameters());
   }
 
   @Test
-  public void testGetFilesInDirectoryRecursiveReturnsEmptyWhenInputFileIsNotDirectory() throws ZipException {
+  public void testGetFilesInDirectoryRecursiveReturnsEmptyWhenInputFileIsNotDirectory() throws IOException {
     File[] filesInDirectory = generateFilesForDirectory();
     testGetFilesInDirectory(false, true, filesInDirectory, 0, true, true);
   }
 
   @Test
-  public void testGetFilesInDirectoryRecursiveReturnsEmptyWhenCannotReadInputFile() throws ZipException {
+  public void testGetFilesInDirectoryRecursiveReturnsEmptyWhenCannotReadInputFile() throws IOException {
     File[] filesInDirectory = generateFilesForDirectory();
     testGetFilesInDirectory(true, false, filesInDirectory, 0, true, true);
   }
 
   @Test
-  public void testGetFilesInDirectoryRecursiveReturnsEmptyWhenFilesInDirIsNull() throws ZipException {
+  public void testGetFilesInDirectoryRecursiveReturnsEmptyWhenFilesInDirIsNull() throws IOException {
     testGetFilesInDirectory(true, true, null, 0, true, true);
   }
 
   @Test
-  public void testGetFilesInDirectoryRecursiveWithHiddenModeOnListsHiddenFiles() throws ZipException {
-    File[] filesInDirectory = generateFilesForDirectory();
-    testGetFilesInDirectory(true, true, filesInDirectory, 6, true, true);
-  }
-
-  @Test
-  public void testGetFilesInDirectoryRecursiveWithHiddenModeOffDoesNotListsHiddenFiles() throws ZipException {
-    File[] filesInDirectory = generateFilesForDirectory();
-    testGetFilesInDirectory(true, true, filesInDirectory, 5, false, true);
-  }
-
-  @Test
-  public void testGetFilesInDirectoryRecursiveWithHiddenModeOffDoesNotListsHiddenFolders() throws ZipException {
-    File[] filesInDirectory = generateFilesForDirectory();
-    testGetFilesInDirectory(true, true, filesInDirectory, 4, true, false);
-  }
-
-  @Test
-  public void testGetFilesInDirectoryRecursiveWithHiddenModeOffForFilesAndFolders() throws ZipException {
-    File[] filesInDirectory = generateFilesForDirectory();
-    testGetFilesInDirectory(true, true, filesInDirectory, 3, false, false);
-  }
-
-  @Test
-  public void testGetFileNameWithoutExtensionWithoutExtensionReturnsSameName() throws ZipException {
+  public void testGetFileNameWithoutExtensionReturnsSameName() throws ZipException {
     String fileNameWithoutExtension = FileUtils.getFileNameWithoutExtension("somename");
     assertThat(fileNameWithoutExtension).isEqualTo("somename");
   }
@@ -400,19 +376,21 @@ public class FileUtilsTest {
 
   private void testGetFilesInDirectory(boolean isDirectory, boolean canRead, File[] filesInDirectory,
                                        int expectedReturnSize, boolean shouldReadHiddenFiles,
-                                       boolean shouldReadHiddenFolders) throws ZipException {
+                                       boolean shouldReadHiddenFolders) throws IOException {
     File file = mock(File.class);
     when(file.isDirectory()).thenReturn(isDirectory);
     when(file.canRead()).thenReturn(canRead);
     when(file.listFiles()).thenReturn(filesInDirectory);
 
-    List<File> returnedFiles = FileUtils.getFilesInDirectoryRecursive(file, shouldReadHiddenFiles,
-        shouldReadHiddenFolders);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setReadHiddenFiles(shouldReadHiddenFiles);
+    zipParameters.setReadHiddenFolders(shouldReadHiddenFolders);
+    List<File> returnedFiles = FileUtils.getFilesInDirectoryRecursive(file, zipParameters);
 
     assertThat(returnedFiles).hasSize(expectedReturnSize);
   }
 
-  private File[] generateFilesForDirectory() {
+  private File[] generateFilesForDirectory() throws IOException {
     return new File[]{
         mockFile(false, false),
         mockFile(false, false),
@@ -423,10 +401,14 @@ public class FileUtilsTest {
     };
   }
 
-  private File mockFile(boolean isHidden, boolean isDirectory) {
+  private File mockFile(boolean isHidden, boolean isDirectory) throws IOException {
     File file = mock(File.class);
+    Path path = mock(Path.class);
+    when(file.toPath()).thenReturn(path);
     when(file.isHidden()).thenReturn(isHidden);
     when(file.isDirectory()).thenReturn(isDirectory);
+    when(file.canRead()).thenReturn(true);
+    when(file.getCanonicalFile()).thenReturn(file);
     return file;
   }
 
