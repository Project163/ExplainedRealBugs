diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index 2fb6524..f992252 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -27,24 +27,15 @@ import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.RandomAccessFileMode;
 import net.lingala.zip4j.progress.ProgressMonitor;
-import net.lingala.zip4j.tasks.AddFilesToZipTask;
+import net.lingala.zip4j.tasks.*;
 import net.lingala.zip4j.tasks.AddFilesToZipTask.AddFilesToZipTaskParameters;
-import net.lingala.zip4j.tasks.AddFolderToZipTask;
 import net.lingala.zip4j.tasks.AddFolderToZipTask.AddFolderToZipTaskParameters;
-import net.lingala.zip4j.tasks.AddStreamToZipTask;
 import net.lingala.zip4j.tasks.AddStreamToZipTask.AddStreamToZipTaskParameters;
-import net.lingala.zip4j.tasks.AsyncZipTask;
-import net.lingala.zip4j.tasks.ExtractAllFilesTask;
 import net.lingala.zip4j.tasks.ExtractAllFilesTask.ExtractAllFilesTaskParameters;
-import net.lingala.zip4j.tasks.ExtractFileTask;
 import net.lingala.zip4j.tasks.ExtractFileTask.ExtractFileTaskParameters;
-import net.lingala.zip4j.tasks.MergeSplitZipFileTask;
 import net.lingala.zip4j.tasks.MergeSplitZipFileTask.MergeSplitZipFileTaskParameters;
-import net.lingala.zip4j.tasks.RemoveFilesFromZipTask;
 import net.lingala.zip4j.tasks.RemoveFilesFromZipTask.RemoveFilesFromZipTaskParameters;
-import net.lingala.zip4j.tasks.RenameFilesTask;
 import net.lingala.zip4j.tasks.RenameFilesTask.RenameFilesTaskParameters;
-import net.lingala.zip4j.tasks.SetCommentTask;
 import net.lingala.zip4j.tasks.SetCommentTask.SetCommentTaskTaskParameters;
 import net.lingala.zip4j.util.FileUtils;
 import net.lingala.zip4j.util.RawIO;
@@ -904,9 +895,14 @@ public class ZipFile {
   /**
    * Checks to see if the input zip file is a valid zip file. This method
    * will try to read zip headers. If headers are read successfully, this
-   * method returns true else false
+   * method returns true else false.
+   *
+   * Since v2.7.0: if the zip file is a split zip file, this method also checks to see if
+   * all the split files of the zip exists.
+   *
+   * @return boolean - true if a valid zip file, i.e, zip4j is able to read the
+   * zip headers, and in case of a split zip file, all split files of the zip exists; false otherwise
    *
-   * @return boolean
    * @since 1.2.3
    */
   public boolean isValidZipFile() {
@@ -916,6 +912,11 @@ public class ZipFile {
 
     try {
       readZipInfo();
+
+      if (zipModel.isSplitArchive() && !verifyAllSplitFilesOfZipExists(getSplitZipFiles())) {
+        return false;
+      }
+
       return true;
     } catch (Exception e) {
       return false;
@@ -1009,6 +1010,15 @@ public class ZipFile {
     return new AsyncZipTask.AsyncTaskParameters(executorService, runInThread, progressMonitor);
   }
 
+  private boolean verifyAllSplitFilesOfZipExists(List<File> allSplitFiles) {
+    for (File splitFile : allSplitFiles) {
+      if (!splitFile.exists()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
   public ProgressMonitor getProgressMonitor() {
     return progressMonitor;
   }
diff --git a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
index f1aa059..5cb98fc 100644
--- a/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/MiscZipFileIT.java
@@ -15,11 +15,13 @@ import org.junit.rules.ExpectedException;
 
 import java.io.*;
 import java.nio.charset.Charset;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 import java.util.stream.Collectors;
 
+import static java.util.Collections.singletonList;
 import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
@@ -522,6 +524,43 @@ public class MiscZipFileIT extends AbstractIT {
     assertThat(fileHeader.getLastModifiedTimeEpoch()).isEqualTo(fileToAdd.lastModified());
   }
 
+  @Test
+  public void testVerifyZipFileForNonSplitZipFileReturnsTrue() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.addFile(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"));
+
+    assertThat(zipFile.isValidZipFile()).isTrue();
+  }
+
+  @Test
+  public void testVerifyZipFileForNonZipFileReturnsFalse() throws IOException {
+    ZipFile zipFile = new ZipFile(TestUtils.getTestFileFromResources("sample.pdf"));
+    assertThat(zipFile.isValidZipFile()).isFalse();
+  }
+
+  @Test
+  public void testVerifyZipFileForSplitZipFileReturnsTrueWhenAllSplitFilesExists() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.createSplitZipFile(singletonList(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf")), new ZipParameters(),
+            true, InternalZipConstants.MIN_SPLIT_LENGTH);
+
+    assertThat(zipFile.isValidZipFile()).isTrue();
+  }
+
+  @Test
+  public void testVerifyZipFileForSplitZipFileReturnsFalseWhenOneSplitFileDoesNotExist() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.createSplitZipFile(singletonList(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf")), new ZipParameters(),
+            true, InternalZipConstants.MIN_SPLIT_LENGTH);
+    String firstSplitFileName = zipFile.getFile().getName().replace(".zip", ".z02");
+    File firstSplitFile = Paths.get(zipFile.getFile().getParentFile().getPath(), firstSplitFileName).toFile();
+    if (!firstSplitFile.delete()) {
+      throw new RuntimeException("Unable to delete a split file of zip which is a requirement to run this test");
+    }
+
+    assertThat(zipFile.isValidZipFile()).isFalse();
+  }
+
   private void verifyInputStream(InputStream inputStream, File fileToCompareAgainst) throws IOException {
     File outputFile = temporaryFolder.newFile();
     try (OutputStream outputStream = new FileOutputStream(outputFile)) {
