diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index a5d2cca..9e8c27f 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -93,7 +93,17 @@ public class ZipInputStream extends InputStream {
 
     if (fileHeader != null) {
       localFileHeader.setCrc(fileHeader.getCrc());
-      localFileHeader.setCompressedSize(fileHeader.getCompressedSize());
+
+      // In case of jar files, directories' compressed size in file header is 2 and local file header is 0.
+      // The actual value of compressed size in file header should be 0.
+      // This is a workaround to ignore the comprressed size from file header if directory and is deflate and
+      // compressed sizes does not match
+      if (!(fileHeader.isDirectory()
+          && fileHeader.getCompressionMethod().equals(CompressionMethod.DEFLATE)
+          && fileHeader.getCompressedSize() != localFileHeader.getCompressedSize())) {
+        localFileHeader.setCompressedSize(fileHeader.getCompressedSize());
+      }
+
       localFileHeader.setUncompressedSize(fileHeader.getUncompressedSize());
       canSkipExtendedLocalFileHeader = true;
     } else {
@@ -300,9 +310,14 @@ public class ZipInputStream extends InputStream {
   }
 
   private void readUntilEndOfEntry() throws IOException {
+    if (localFileHeader.getCompressedSize() == 0) {
+      return;
+    }
+
     if (endOfEntryBuffer == null) {
       endOfEntryBuffer = new byte[512];
     }
+
     while (read(endOfEntryBuffer) != -1);
   }
 
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 61da977..40e8e54 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -475,6 +475,12 @@ public class ExtractZipFileIT extends AbstractIT {
     ZipFileVerifier.verifyFileContent(TestUtils.getTestFileFromResources("öüäöäö/asöäööl"), outputFile);
   }
 
+  @Test
+  public void testExtractJarFile() throws IOException {
+    ZipFile zipFile = new ZipFile(TestUtils.getTestArchiveFromResources("zip4j-for-testing.jar"));
+    zipFile.extractAll(outputFolder.getPath());
+  }
+
   private void addFileToZip(ZipFile zipFile, String fileName, EncryptionMethod encryptionMethod, String password) throws ZipException {
     ZipParameters zipParameters = new ZipParameters();
     zipParameters.setEncryptFiles(encryptionMethod != null);
diff --git a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
index 7bdd28b..8f948b5 100644
--- a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
@@ -188,6 +188,17 @@ public class ZipInputStreamIT extends AbstractIT {
     assertThat(filenameSet.contains(expactedFileName)).isTrue();
   }
 
+  @Test
+  public void testExtractJarFile() throws IOException {
+    byte[] b = new byte[4096];
+    File jarFile = getTestArchiveFromResources("zip4j-for-testing.jar");
+    try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(jarFile))) {
+      while (zipInputStream.getNextEntry() != null) {
+        zipInputStream.read(b);
+      }
+    }
+  }
+
   private void extractZipFileWithInputStreams(File zipFile, char[] password) throws IOException {
     extractZipFileWithInputStreams(zipFile, password, 4096, AesVersion.TWO);
   }
diff --git a/src/test/resources/test-archives/zip4j-for-testing.jar b/src/test/resources/test-archives/zip4j-for-testing.jar
new file mode 100644
index 0000000..263fba3
Binary files /dev/null and b/src/test/resources/test-archives/zip4j-for-testing.jar differ
