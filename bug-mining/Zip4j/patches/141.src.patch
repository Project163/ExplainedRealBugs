diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index 2653210..1d00ed3 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -185,6 +185,17 @@ public class ZipInputStream extends InputStream {
     return entryEOFReached ? 0 : 1;
   }
 
+  /**
+   * Sets the password for the inputstream. This password will be used for any subsequent encrypted entries that will be
+   * read from this stream. If this method is called when an entry is being read, it has no effect on the read action
+   * of the current entry, and the password will take effect from any subsequent entry reads.
+   *
+   * @param password Password to be used for reading of entries from the zip input stream
+   */
+  public void setPassword(char[] password) {
+    this.password = password;
+  }
+
   private void endOfCompressedDataReached() throws IOException {
     //With inflater, without knowing the compressed or uncompressed size, we over read necessary data
     //In such cases, we have to push back the inputstream to the end of data
diff --git a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
index 1d6a92e..649fbcd 100644
--- a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
@@ -10,6 +10,7 @@ import net.lingala.zip4j.model.enums.AesKeyStrength;
 import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
+import net.lingala.zip4j.testutils.TestUtils;
 import net.lingala.zip4j.util.InternalZipConstants;
 import org.junit.Rule;
 import org.junit.Test;
@@ -282,6 +283,18 @@ public class ZipInputStreamIT extends AbstractIT {
     }
   }
 
+  @Test
+  public void testExtractZipWithDifferentPasswords() throws IOException {
+    byte[] buffer = new byte[InternalZipConstants.BUFF_SIZE];
+    File zipFileUnderTest = TestUtils.getTestArchiveFromResources("zip_with_different_passwords.zip");
+    try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(zipFileUnderTest))) {
+      readAndAssertNextEntry(zipInputStream, "after_deflate_remaining_bytes.bin", "password_1");
+      readAndAssertNextEntry(zipInputStream, "file_PDF_1MB.pdf", "password_2");
+      // 3rd entry is not encrypted, but it should not be impacted if a password is set
+      readAndAssertNextEntry(zipInputStream, "sample.pdf", null);
+    }
+  }
+
   private void extractZipFileWithInputStreams(File zipFile, char[] password) throws IOException {
     extractZipFileWithInputStreams(zipFile, password, 4096, AesVersion.TWO);
   }
@@ -382,4 +395,16 @@ public class ZipInputStreamIT extends AbstractIT {
     }
     return generatedZipFile;
   }
+
+  private void readAndAssertNextEntry(ZipInputStream zipInputStream, String fileNameToExpect, String passwordToUse)
+      throws IOException {
+    byte[] buffer = new byte[InternalZipConstants.BUFF_SIZE];
+    if (passwordToUse != null) {
+      zipInputStream.setPassword(passwordToUse.toCharArray());
+    }
+    LocalFileHeader localFileHeader = zipInputStream.getNextEntry();
+    assertThat(localFileHeader.getFileName()).isEqualTo(fileNameToExpect);
+    //noinspection StatementWithEmptyBody
+    while (zipInputStream.read(buffer) != -1);
+  }
 }
diff --git a/src/test/resources/test-archives/zip_with_different_passwords.zip b/src/test/resources/test-archives/zip_with_different_passwords.zip
new file mode 100644
index 0000000..9ea8763
Binary files /dev/null and b/src/test/resources/test-archives/zip_with_different_passwords.zip differ
