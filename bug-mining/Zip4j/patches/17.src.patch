diff --git a/src/main/java/net/lingala/zip4j/model/ZipParameters.java b/src/main/java/net/lingala/zip4j/model/ZipParameters.java
index c9c97d9..4e54329 100755
--- a/src/main/java/net/lingala/zip4j/model/ZipParameters.java
+++ b/src/main/java/net/lingala/zip4j/model/ZipParameters.java
@@ -1,181 +1,191 @@
-/*
- * Copyright 2010 Srikanth Reddy Lingala
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package net.lingala.zip4j.model;
-
-import net.lingala.zip4j.model.enums.AesKeyStrength;
-import net.lingala.zip4j.model.enums.AesVersion;
-import net.lingala.zip4j.model.enums.CompressionLevel;
-import net.lingala.zip4j.model.enums.CompressionMethod;
-import net.lingala.zip4j.model.enums.EncryptionMethod;
-
-public class ZipParameters {
-
-  private CompressionMethod compressionMethod = CompressionMethod.DEFLATE;
-  private CompressionLevel compressionLevel = CompressionLevel.NORMAL;
-  private boolean encryptFiles = false;
-  private EncryptionMethod encryptionMethod = EncryptionMethod.NONE;
-  private boolean readHiddenFiles = true;
-  private AesKeyStrength aesKeyStrength = AesKeyStrength.KEY_STRENGTH_256;
-  private AesVersion aesVersion = AesVersion.TWO;
-  private boolean includeRootFolder = true;
-  private long entryCRC;
-  private String defaultFolderPath;
-  private String fileNameInZip;
-  private long lastModifiedFileTime = System.currentTimeMillis();
-  private long entrySize = -1;
-  private boolean writeExtendedLocalFileHeader = true;
-
-  public ZipParameters() {
-  }
-
-  public ZipParameters(ZipParameters zipParameters) {
-    this.compressionMethod = zipParameters.getCompressionMethod();
-    this.compressionLevel = zipParameters.getCompressionLevel();
-    this.encryptFiles = zipParameters.isEncryptFiles();
-    this.encryptionMethod = zipParameters.getEncryptionMethod();
-    this.readHiddenFiles = zipParameters.isReadHiddenFiles();
-    this.aesKeyStrength = zipParameters.getAesKeyStrength();
-    this.aesVersion = zipParameters.getAesVersion();
-    this.includeRootFolder = zipParameters.isIncludeRootFolder();
-    this.entryCRC = zipParameters.getEntryCRC();
-    this.defaultFolderPath = zipParameters.getDefaultFolderPath();
-    this.fileNameInZip = zipParameters.getFileNameInZip();
-    this.lastModifiedFileTime = zipParameters.getLastModifiedFileTime();
-    this.entrySize = zipParameters.getEntrySize();
-    this.writeExtendedLocalFileHeader = zipParameters.isWriteExtendedLocalFileHeader();
-  }
-
-  public CompressionMethod getCompressionMethod() {
-    return compressionMethod;
-  }
-
-  public void setCompressionMethod(CompressionMethod compressionMethod) {
-    this.compressionMethod = compressionMethod;
-  }
-
-  public boolean isEncryptFiles() {
-    return encryptFiles;
-  }
-
-  public void setEncryptFiles(boolean encryptFiles) {
-    this.encryptFiles = encryptFiles;
-  }
-
-  public EncryptionMethod getEncryptionMethod() {
-    return encryptionMethod;
-  }
-
-  public void setEncryptionMethod(EncryptionMethod encryptionMethod) {
-    this.encryptionMethod = encryptionMethod;
-  }
-
-  public CompressionLevel getCompressionLevel() {
-    return compressionLevel;
-  }
-
-  public void setCompressionLevel(CompressionLevel compressionLevel) {
-    this.compressionLevel = compressionLevel;
-  }
-
-  public boolean isReadHiddenFiles() {
-    return readHiddenFiles;
-  }
-
-  public void setReadHiddenFiles(boolean readHiddenFiles) {
-    this.readHiddenFiles = readHiddenFiles;
-  }
-
-  public Object clone() throws CloneNotSupportedException {
-    return super.clone();
-  }
-
-  public AesKeyStrength getAesKeyStrength() {
-    return aesKeyStrength;
-  }
-
-  public void setAesKeyStrength(AesKeyStrength aesKeyStrength) {
-    this.aesKeyStrength = aesKeyStrength;
-  }
-
-  public AesVersion getAesVersion() {
-    return aesVersion;
-  }
-
-  public void setAesVersion(AesVersion aesVersion) {
-    this.aesVersion = aesVersion;
-  }
-
-  public boolean isIncludeRootFolder() {
-    return includeRootFolder;
-  }
-
-  public void setIncludeRootFolder(boolean includeRootFolder) {
-    this.includeRootFolder = includeRootFolder;
-  }
-
-  public long getEntryCRC() {
-    return entryCRC;
-  }
-
-  public void setEntryCRC(long entryCRC) {
-    this.entryCRC = entryCRC;
-  }
-
-  public String getDefaultFolderPath() {
-    return defaultFolderPath;
-  }
-
-  public void setDefaultFolderPath(String defaultFolderPath) {
-    this.defaultFolderPath = defaultFolderPath;
-  }
-
-  public String getFileNameInZip() {
-    return fileNameInZip;
-  }
-
-  public void setFileNameInZip(String fileNameInZip) {
-    this.fileNameInZip = fileNameInZip;
-  }
-
-  public long getLastModifiedFileTime() {
-    return lastModifiedFileTime;
-  }
-
-  public void setLastModifiedFileTime(long lastModifiedFileTime) {
-    if (lastModifiedFileTime <= 0) {
-      return;
-    }
-
-    this.lastModifiedFileTime = lastModifiedFileTime;
-  }
-
-  public long getEntrySize() {
-    return entrySize;
-  }
-
-  public void setEntrySize(long entrySize) {
-    this.entrySize = entrySize;
-  }
-
-  public boolean isWriteExtendedLocalFileHeader() {
-    return writeExtendedLocalFileHeader;
-  }
-
-  public void setWriteExtendedLocalFileHeader(boolean writeExtendedLocalFileHeader) {
-    this.writeExtendedLocalFileHeader = writeExtendedLocalFileHeader;
-  }
-}
+/*
+ * Copyright 2010 Srikanth Reddy Lingala
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.lingala.zip4j.model;
+
+import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
+import net.lingala.zip4j.model.enums.CompressionLevel;
+import net.lingala.zip4j.model.enums.CompressionMethod;
+import net.lingala.zip4j.model.enums.EncryptionMethod;
+
+public class ZipParameters {
+
+  private CompressionMethod compressionMethod = CompressionMethod.DEFLATE;
+  private CompressionLevel compressionLevel = CompressionLevel.NORMAL;
+  private boolean encryptFiles = false;
+  private EncryptionMethod encryptionMethod = EncryptionMethod.NONE;
+  private boolean readHiddenFiles = true;
+  private boolean readHiddenFolders = true;
+  private AesKeyStrength aesKeyStrength = AesKeyStrength.KEY_STRENGTH_256;
+  private AesVersion aesVersion = AesVersion.TWO;
+  private boolean includeRootFolder = true;
+  private long entryCRC;
+  private String defaultFolderPath;
+  private String fileNameInZip;
+  private long lastModifiedFileTime = System.currentTimeMillis();
+  private long entrySize = -1;
+  private boolean writeExtendedLocalFileHeader = true;
+
+  public ZipParameters() {
+  }
+
+  public ZipParameters(ZipParameters zipParameters) {
+    this.compressionMethod = zipParameters.getCompressionMethod();
+    this.compressionLevel = zipParameters.getCompressionLevel();
+    this.encryptFiles = zipParameters.isEncryptFiles();
+    this.encryptionMethod = zipParameters.getEncryptionMethod();
+    this.readHiddenFiles = zipParameters.isReadHiddenFiles();
+    this.readHiddenFolders = zipParameters.isReadHiddenFolders();
+    this.aesKeyStrength = zipParameters.getAesKeyStrength();
+    this.aesVersion = zipParameters.getAesVersion();
+    this.includeRootFolder = zipParameters.isIncludeRootFolder();
+    this.entryCRC = zipParameters.getEntryCRC();
+    this.defaultFolderPath = zipParameters.getDefaultFolderPath();
+    this.fileNameInZip = zipParameters.getFileNameInZip();
+    this.lastModifiedFileTime = zipParameters.getLastModifiedFileTime();
+    this.entrySize = zipParameters.getEntrySize();
+    this.writeExtendedLocalFileHeader = zipParameters.isWriteExtendedLocalFileHeader();
+  }
+
+  public CompressionMethod getCompressionMethod() {
+    return compressionMethod;
+  }
+
+  public void setCompressionMethod(CompressionMethod compressionMethod) {
+    this.compressionMethod = compressionMethod;
+  }
+
+  public boolean isEncryptFiles() {
+    return encryptFiles;
+  }
+
+  public void setEncryptFiles(boolean encryptFiles) {
+    this.encryptFiles = encryptFiles;
+  }
+
+  public EncryptionMethod getEncryptionMethod() {
+    return encryptionMethod;
+  }
+
+  public void setEncryptionMethod(EncryptionMethod encryptionMethod) {
+    this.encryptionMethod = encryptionMethod;
+  }
+
+  public CompressionLevel getCompressionLevel() {
+    return compressionLevel;
+  }
+
+  public void setCompressionLevel(CompressionLevel compressionLevel) {
+    this.compressionLevel = compressionLevel;
+  }
+
+  public boolean isReadHiddenFiles() {
+    return readHiddenFiles;
+  }
+
+  public void setReadHiddenFiles(boolean readHiddenFiles) {
+    this.readHiddenFiles = readHiddenFiles;
+  }
+
+  public boolean isReadHiddenFolders() {
+    return readHiddenFolders;
+  }
+
+  public void setReadHiddenFolders(boolean readHiddenFolders) {
+    this.readHiddenFolders = readHiddenFolders;
+  }
+
+  public Object clone() throws CloneNotSupportedException {
+    return super.clone();
+  }
+
+  public AesKeyStrength getAesKeyStrength() {
+    return aesKeyStrength;
+  }
+
+  public void setAesKeyStrength(AesKeyStrength aesKeyStrength) {
+    this.aesKeyStrength = aesKeyStrength;
+  }
+
+  public AesVersion getAesVersion() {
+    return aesVersion;
+  }
+
+  public void setAesVersion(AesVersion aesVersion) {
+    this.aesVersion = aesVersion;
+  }
+
+  public boolean isIncludeRootFolder() {
+    return includeRootFolder;
+  }
+
+  public void setIncludeRootFolder(boolean includeRootFolder) {
+    this.includeRootFolder = includeRootFolder;
+  }
+
+  public long getEntryCRC() {
+    return entryCRC;
+  }
+
+  public void setEntryCRC(long entryCRC) {
+    this.entryCRC = entryCRC;
+  }
+
+  public String getDefaultFolderPath() {
+    return defaultFolderPath;
+  }
+
+  public void setDefaultFolderPath(String defaultFolderPath) {
+    this.defaultFolderPath = defaultFolderPath;
+  }
+
+  public String getFileNameInZip() {
+    return fileNameInZip;
+  }
+
+  public void setFileNameInZip(String fileNameInZip) {
+    this.fileNameInZip = fileNameInZip;
+  }
+
+  public long getLastModifiedFileTime() {
+    return lastModifiedFileTime;
+  }
+
+  public void setLastModifiedFileTime(long lastModifiedFileTime) {
+    if (lastModifiedFileTime <= 0) {
+      return;
+    }
+
+    this.lastModifiedFileTime = lastModifiedFileTime;
+  }
+
+  public long getEntrySize() {
+    return entrySize;
+  }
+
+  public void setEntrySize(long entrySize) {
+    this.entrySize = entrySize;
+  }
+
+  public boolean isWriteExtendedLocalFileHeader() {
+    return writeExtendedLocalFileHeader;
+  }
+
+  public void setWriteExtendedLocalFileHeader(boolean writeExtendedLocalFileHeader) {
+    this.writeExtendedLocalFileHeader = writeExtendedLocalFileHeader;
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
index cbc58d1..8f486e6 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddFolderToZipTask.java
@@ -32,7 +32,8 @@ public class AddFolderToZipTask extends AbstractAddFileToZipTask<AddFolderToZipT
   @Override
   protected long calculateTotalWork(AddFolderToZipTaskParameters taskParameters) throws ZipException {
     List<File> filesToAdd = getFilesInDirectoryRecursive(taskParameters.folderToAdd,
-        taskParameters.zipParameters.isReadHiddenFiles());
+        taskParameters.zipParameters.isReadHiddenFiles(),
+        taskParameters.zipParameters.isReadHiddenFolders());
 
     if (taskParameters.zipParameters.isIncludeRootFolder()) {
       filesToAdd.add(taskParameters.folderToAdd);
@@ -55,7 +56,8 @@ public class AddFolderToZipTask extends AbstractAddFileToZipTask<AddFolderToZipT
 
   private List<File> getFilesToAdd(AddFolderToZipTaskParameters taskParameters) throws ZipException {
     List<File> filesToAdd = getFilesInDirectoryRecursive(taskParameters.folderToAdd,
-        taskParameters.zipParameters.isReadHiddenFiles());
+        taskParameters.zipParameters.isReadHiddenFiles(),
+        taskParameters.zipParameters.isReadHiddenFolders());
 
     if (taskParameters.zipParameters.isIncludeRootFolder()) {
       filesToAdd.add(taskParameters.folderToAdd);
diff --git a/src/main/java/net/lingala/zip4j/util/FileUtils.java b/src/main/java/net/lingala/zip4j/util/FileUtils.java
index 9c3dcde..eedeb7a 100644
--- a/src/main/java/net/lingala/zip4j/util/FileUtils.java
+++ b/src/main/java/net/lingala/zip4j/util/FileUtils.java
@@ -87,7 +87,9 @@ public class FileUtils {
     }
   }
 
-  public static List<File> getFilesInDirectoryRecursive(File path, boolean readHiddenFiles) throws ZipException {
+  public static List<File> getFilesInDirectoryRecursive(File path, boolean readHiddenFiles, boolean readHiddenFolders)
+      throws ZipException {
+
     if (path == null) {
       throw new ZipException("input path is null, cannot read files in the directory");
     }
@@ -100,14 +102,21 @@ public class FileUtils {
     }
 
     for (File file : filesAndDirs) {
-      if (file.isHidden() && !readHiddenFiles) {
-        continue;
+      if (file.isHidden()) {
+        if (file.isDirectory()) {
+          if (!readHiddenFolders) {
+            continue;
+          }
+        } else if (!readHiddenFiles) {
+          continue;
+        }
       }
       result.add(file);
       if (file.isDirectory()) {
-        result.addAll(getFilesInDirectoryRecursive(file, readHiddenFiles));
+        result.addAll(getFilesInDirectoryRecursive(file, readHiddenFiles, readHiddenFolders));
       }
     }
+
     return result;
   }
 
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 5bf6163..52d1d65 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -274,7 +274,7 @@ public class ExtractZipFileIT extends AbstractIT {
   }
 
   private File getFileWithNameFrom(File outputFolder, String fileName) throws ZipException {
-    List<File> filesInFolder = FileUtils.getFilesInDirectoryRecursive(outputFolder, true);
+    List<File> filesInFolder = FileUtils.getFilesInDirectoryRecursive(outputFolder, true, true);
     Optional<File> file = filesInFolder.stream().filter(e -> e.getName().equals(fileName)).findFirst();
     assertThat(file).isPresent();
     return file.get();
diff --git a/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java b/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
index d465c18..e95578f 100644
--- a/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
+++ b/src/test/java/net/lingala/zip4j/util/FileUtilsTest.java
@@ -95,36 +95,48 @@ public class FileUtilsTest {
     expectedException.expectMessage("input path is null, cannot read files in the directory");
     expectedException.expect(ZipException.class);
 
-    FileUtils.getFilesInDirectoryRecursive(null, true);
+    FileUtils.getFilesInDirectoryRecursive(null, true, true);
   }
 
   @Test
   public void testGetFilesInDirectoryRecursiveReturnsEmptyWhenInputFileIsNotDirectory() throws ZipException {
     File[] filesInDirectory = generateFilesForDirectory();
-    testGetFilesInDirectory(false, true, filesInDirectory, 0, true);
+    testGetFilesInDirectory(false, true, filesInDirectory, 0, true, true);
   }
 
   @Test
   public void testGetFilesInDirectoryRecursiveReturnsEmptyWhenCannotReadInputFile() throws ZipException {
     File[] filesInDirectory = generateFilesForDirectory();
-    testGetFilesInDirectory(true, false, filesInDirectory, 0, true);
+    testGetFilesInDirectory(true, false, filesInDirectory, 0, true, true);
   }
 
   @Test
   public void testGetFilesInDirectoryRecursiveReturnsEmptyWhenFilesInDirIsNull() throws ZipException {
-    testGetFilesInDirectory(true, true, null, 0, true);
+    testGetFilesInDirectory(true, true, null, 0, true, true);
   }
 
   @Test
   public void testGetFilesInDirectoryRecursiveWithHiddenModeOnListsHiddenFiles() throws ZipException {
     File[] filesInDirectory = generateFilesForDirectory();
-    testGetFilesInDirectory(true, true, filesInDirectory, 5, true);
+    testGetFilesInDirectory(true, true, filesInDirectory, 6, true, true);
   }
 
   @Test
   public void testGetFilesInDirectoryRecursiveWithHiddenModeOffDoesNotListsHiddenFiles() throws ZipException {
     File[] filesInDirectory = generateFilesForDirectory();
-    testGetFilesInDirectory(true, true, filesInDirectory, 3, false);
+    testGetFilesInDirectory(true, true, filesInDirectory, 5, false, true);
+  }
+
+  @Test
+  public void testGetFilesInDirectoryRecursiveWithHiddenModeOffDoesNotListsHiddenFolders() throws ZipException {
+    File[] filesInDirectory = generateFilesForDirectory();
+    testGetFilesInDirectory(true, true, filesInDirectory, 4, true, false);
+  }
+
+  @Test
+  public void testGetFilesInDirectoryRecursiveWithHiddenModeOffForFilesAndFolders() throws ZipException {
+    File[] filesInDirectory = generateFilesForDirectory();
+    testGetFilesInDirectory(true, true, filesInDirectory, 3, false, false);
   }
 
   @Test
@@ -258,13 +270,15 @@ public class FileUtilsTest {
   }
 
   private void testGetFilesInDirectory(boolean isDirectory, boolean canRead, File[] filesInDirectory,
-                                       int expectedReturnSize, boolean shouldReadHiddenFiles) throws ZipException {
+                                       int expectedReturnSize, boolean shouldReadHiddenFiles,
+                                       boolean shouldReadHiddenFolders) throws ZipException {
     File file = mock(File.class);
     when(file.isDirectory()).thenReturn(isDirectory);
     when(file.canRead()).thenReturn(canRead);
     when(file.listFiles()).thenReturn(filesInDirectory);
 
-    List<File> returnedFiles = FileUtils.getFilesInDirectoryRecursive(file, shouldReadHiddenFiles);
+    List<File> returnedFiles = FileUtils.getFilesInDirectoryRecursive(file, shouldReadHiddenFiles,
+        shouldReadHiddenFolders);
 
     assertThat(returnedFiles).hasSize(expectedReturnSize);
   }
@@ -275,7 +289,8 @@ public class FileUtilsTest {
         mockFile(false, false),
         mockFile(true, false),
         mockFile(true, true),
-        mockFile(false, true)
+        mockFile(false, true),
+        mockFile(true, true),
     };
   }
 
diff --git a/src/test/java/net/lingala/zip4j/utils/ZipFileVerifier.java b/src/test/java/net/lingala/zip4j/utils/ZipFileVerifier.java
index 09622cb..aba8ec0 100644
--- a/src/test/java/net/lingala/zip4j/utils/ZipFileVerifier.java
+++ b/src/test/java/net/lingala/zip4j/utils/ZipFileVerifier.java
@@ -36,7 +36,7 @@ public class ZipFileVerifier {
     zipFile.extractAll(outputFolder.getPath());
     assertThat(zipFile.getFileHeaders().size()).as("Number of file headers").isEqualTo(expectedNumberOfEntries);
 
-    List<File> extractedFiles = FileUtils.getFilesInDirectoryRecursive(outputFolder, true);
+    List<File> extractedFiles = FileUtils.getFilesInDirectoryRecursive(outputFolder, true, true);
     assertThat(extractedFiles).hasSize(expectedNumberOfEntries);
 
     if (verifyFileContents) {
