diff --git a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
index f48dd7d..89943ab 100644
--- a/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
+++ b/src/test/java/net/lingala/zip4j/AddFilesToZipIT.java
@@ -255,6 +255,7 @@ public class AddFilesToZipIT extends AbstractIT {
     expectedException.expect(ZipException.class);
 
     ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.setRunInThread(true);
     ProgressMonitor progressMonitor = zipFile.getProgressMonitor();
     progressMonitor.setState(ProgressMonitor.State.BUSY);
 
@@ -610,6 +611,19 @@ public class AddFilesToZipIT extends AbstractIT {
     ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, 13);
   }
 
+  @Test
+  public void testAddFolderProgressMonitorThrowsExceptionWhenPerformingActionInBusyState() throws ZipException {
+    expectedException.expectMessage("invalid operation - Zip4j is in busy state");
+    expectedException.expect(ZipException.class);
+
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.setRunInThread(true);
+    ProgressMonitor progressMonitor = zipFile.getProgressMonitor();
+    progressMonitor.setState(ProgressMonitor.State.BUSY);
+
+    zipFile.addFile(TestUtils.getTestFileFromResources(""));
+  }
+
   @Test
   public void testAddFolderWithNotNormalizedPath() throws IOException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
diff --git a/src/test/java/net/lingala/zip4j/ZipFileTest.java b/src/test/java/net/lingala/zip4j/ZipFileTest.java
index 3b8b2aa..9a59c6a 100644
--- a/src/test/java/net/lingala/zip4j/ZipFileTest.java
+++ b/src/test/java/net/lingala/zip4j/ZipFileTest.java
@@ -155,6 +155,7 @@ public class ZipFileTest {
   @Test
   public void testAddFileAsFileThrowsExceptionWhenProgressMonitorStateIsBusy() throws ZipException {
     File fileToAdd = mockFile(true);
+    zipFile.setRunInThread(true);
     zipFile.getProgressMonitor().setState(ProgressMonitor.State.BUSY);
 
     expectedException.expect(ZipException.class);
@@ -182,6 +183,7 @@ public class ZipFileTest {
   @Test
   public void testAddFilesThrowsExceptionWhenProgressMonitorStateIsBusy() throws ZipException {
     zipFile.getProgressMonitor().setState(ProgressMonitor.State.BUSY);
+    zipFile.setRunInThread(true);
 
     expectedException.expect(ZipException.class);
     expectedException.expectMessage("invalid operation - Zip4j is in busy state");
@@ -216,6 +218,7 @@ public class ZipFileTest {
 
   @Test
   public void testAddFilesWithParametersThrowsExceptionWhenProgressMonitorStateIsBusy() throws ZipException {
+    zipFile.setRunInThread(true);
     zipFile.getProgressMonitor().setState(ProgressMonitor.State.BUSY);
 
     expectedException.expect(ZipException.class);
@@ -318,6 +321,18 @@ public class ZipFileTest {
     zipFile.addFolder(folderToAdd, null);
   }
 
+  @Test
+  public void testAddFolderThrowsExceptionWhenProgressMonitorStateIsBusy() throws ZipException {
+    File folderToAdd = mockFolder();
+    zipFile.setRunInThread(true);
+    zipFile.getProgressMonitor().setState(ProgressMonitor.State.BUSY);
+
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("invalid operation - Zip4j is in busy state");
+
+    zipFile.addFolder(folderToAdd, new ZipParameters());
+  }
+
   @Test
   public void testAddStreamThrowsExceptionWhenInputStreamIsNull() throws ZipException {
     expectedException.expectMessage("inputstream is null, cannot add file to zip");
@@ -376,6 +391,7 @@ public class ZipFileTest {
 
   @Test
   public void testExtractFileWithFileHeaderWhenBusyStateThrowsException() throws ZipException {
+    zipFile.setRunInThread(true);
     zipFile.getProgressMonitor().setState(ProgressMonitor.State.BUSY);
 
     expectedException.expectMessage("invalid operation - Zip4j is in busy state");
@@ -625,4 +641,12 @@ public class ZipFileTest {
     return file;
   }
 
-}
\ No newline at end of file
+  private File mockFolder() {
+    File folder = mock(File.class);
+    when(folder.exists()).thenReturn(true);
+    when(folder.toString()).thenReturn("SOME_PATH");
+    when(folder.isDirectory()).thenReturn(true);
+    when(folder.canRead()).thenReturn(true);
+    return folder;
+  }
+}
