diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index 2d77f4a..3056d37 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -89,7 +89,7 @@ public class ZipFile {
   private boolean runInThread;
   private char[] password;
   private HeaderWriter headerWriter = new HeaderWriter();
-  private Charset charset = CHARSET_UTF_8;
+  private Charset charset = null;
   private ThreadFactory threadFactory;
   private ExecutorService executorService;
 
@@ -1159,10 +1159,25 @@ public class ZipFile {
     return zipFile;
   }
 
+  /**
+   * Returns user defined charset that was set by setCharset() method. If no charset was explicitly defined
+   * (by calling setCharset()), this method returns the default charset which zip4j uses, which is utf-8.
+   *
+   * @return user-defined charset or utf-8 if no charset explicitly set
+   */
   public Charset getCharset() {
+    if (charset == null) {
+      return CHARSET_UTF_8;
+    }
     return charset;
   }
 
+  /**
+   * Sets the charset to be used for encoding file names and comments
+   *
+   * @param charset charset to use to encode file names and comments
+   * @throws IllegalArgumentException if charset is null
+   */
   public void setCharset(Charset charset) throws IllegalArgumentException {
     if(charset == null) {
       throw new IllegalArgumentException("charset cannot be null");
diff --git a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
index 677d231..fbbaae2 100644
--- a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
+++ b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
@@ -104,8 +104,9 @@ public class FileHeaderFactory {
   private byte[] determineGeneralPurposeBitFlag(boolean isEncrypted, ZipParameters zipParameters, Charset charset) {
     byte[] generalPurposeBitFlag = new byte[2];
     generalPurposeBitFlag[0] = generateFirstGeneralPurposeByte(isEncrypted, zipParameters);
-    if(charset.equals(InternalZipConstants.CHARSET_UTF_8)) {
-      generalPurposeBitFlag[1] = setBit(generalPurposeBitFlag[1], 3); // set 3rd bit which corresponds to utf-8 file name charset
+    if(charset == null || InternalZipConstants.CHARSET_UTF_8.equals(charset)) {
+      // set 3rd bit which corresponds to utf-8 file name charset
+      generalPurposeBitFlag[1] = setBit(generalPurposeBitFlag[1], 3);
     }
     return generalPurposeBitFlag;
   }
@@ -171,6 +172,6 @@ public class FileHeaderFactory {
   }
 
   private int determineFileNameLength(String fileName, Charset charset) {
-    return fileName.getBytes(charset).length;
+    return HeaderUtil.getBytesFromString(fileName, charset).length;
   }
 }
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
index 39f26b1..24793bb 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
@@ -49,6 +49,7 @@ import static net.lingala.zip4j.headers.HeaderUtil.decodeStringWithCharset;
 import static net.lingala.zip4j.util.BitUtils.isBitSet;
 import static net.lingala.zip4j.util.InternalZipConstants.BUFF_SIZE;
 import static net.lingala.zip4j.util.InternalZipConstants.ENDHDR;
+import static net.lingala.zip4j.util.InternalZipConstants.ZIP4J_DEFAULT_CHARSET;
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT;
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT;
 import static net.lingala.zip4j.util.Zip4jUtil.readFully;
@@ -744,7 +745,7 @@ public class HeaderReader {
     try {
       byte[] commentBuf = new byte[commentLength];
       raf.readFully(commentBuf);
-      return new String(commentBuf, charset);
+      return decodeStringWithCharset(commentBuf, false, charset != null ? charset : ZIP4J_DEFAULT_CHARSET);
     } catch (IOException e) {
       // Ignore any exception and set comment to null if comment cannot be read
       return null;
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
index f4caac9..bcb0163 100644
--- a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
@@ -11,7 +11,8 @@ import java.util.Collections;
 import java.util.List;
 import java.util.stream.Collectors;
 
-import static net.lingala.zip4j.util.InternalZipConstants.ZIP_STANDARD_CHARSET;
+import static net.lingala.zip4j.util.InternalZipConstants.ZIP4J_DEFAULT_CHARSET;
+import static net.lingala.zip4j.util.InternalZipConstants.ZIP_STANDARD_CHARSET_NAME;
 import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;
 
 public class HeaderUtil {
@@ -33,19 +34,27 @@ public class HeaderUtil {
   }
 
   public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded, Charset charset) {
-    if (InternalZipConstants.CHARSET_UTF_8.equals(charset) && !isUtf8Encoded) {
-      try {
-        return new String(data, ZIP_STANDARD_CHARSET);
-      } catch (UnsupportedEncodingException e) {
-        return new String(data);
-      }
+    if (charset != null) {
+      return new String(data, charset);
     }
 
-    if(charset != null) {
-      return new String(data, charset);
+    if (isUtf8Encoded) {
+      return new String(data, InternalZipConstants.CHARSET_UTF_8);
+    }
+
+    try {
+      return new String(data, ZIP_STANDARD_CHARSET_NAME);
+    } catch (UnsupportedEncodingException e) {
+      return new String(data);
+    }
+  }
+
+  public static byte[] getBytesFromString(String string, Charset charset) {
+    if (charset == null) {
+      return string.getBytes(ZIP4J_DEFAULT_CHARSET);
     }
 
-    return new String(data, InternalZipConstants.CHARSET_UTF_8);
+    return string.getBytes(charset);
   }
 
   public static long getOffsetStartOfCentralDirectory(ZipModel zipModel) {
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java b/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java
index 4e3de3e..1852884 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderWriter.java
@@ -37,6 +37,7 @@ import java.io.OutputStream;
 import java.nio.charset.Charset;
 import java.util.List;
 
+import static net.lingala.zip4j.headers.HeaderUtil.getBytesFromString;
 import static net.lingala.zip4j.util.FileUtils.getZipFileNameWithoutExtension;
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT;
 import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT;
@@ -92,7 +93,7 @@ public class HeaderWriter {
 
       byte[] fileNameBytes = new byte[0];
       if (isStringNotNullAndNotEmpty(localFileHeader.getFileName())) {
-        fileNameBytes = localFileHeader.getFileName().getBytes(charset);
+        fileNameBytes = getBytesFromString(localFileHeader.getFileName(), charset);
       }
       rawIO.writeShortLittleEndian(byteArrayOutputStream, fileNameBytes.length);
 
@@ -336,7 +337,9 @@ public class HeaderWriter {
     return ((CountingOutputStream) outputStream).getCurrentSplitFileCounter();
   }
 
-  private void writeZipHeaderBytes(ZipModel zipModel, OutputStream outputStream, byte[] buff, Charset charset) throws IOException {
+  private void writeZipHeaderBytes(ZipModel zipModel, OutputStream outputStream, byte[] buff, Charset charset)
+      throws IOException {
+
     if (buff == null) {
       throw new ZipException("invalid buff to write as zip headers");
     }
@@ -377,8 +380,8 @@ public class HeaderWriter {
     zipModel.getEndOfCentralDirectoryRecord().setNumberOfThisDiskStartOfCentralDir(currentSplitFileCounter);
   }
 
-  private void writeCentralDirectory(ZipModel zipModel, ByteArrayOutputStream byteArrayOutputStream, RawIO rawIO, Charset charset)
-      throws ZipException {
+  private void writeCentralDirectory(ZipModel zipModel, ByteArrayOutputStream byteArrayOutputStream, RawIO rawIO,
+                                     Charset charset) throws ZipException {
 
     if (zipModel.getCentralDirectory() == null || zipModel.getCentralDirectory().getFileHeaders() == null
         || zipModel.getCentralDirectory().getFileHeaders().size() <= 0) {
@@ -426,7 +429,7 @@ public class HeaderWriter {
 
       byte[] fileNameBytes = new byte[0];
       if (isStringNotNullAndNotEmpty(fileHeader.getFileName())) {
-        fileNameBytes = fileHeader.getFileName().getBytes(charset);
+        fileNameBytes = getBytesFromString(fileHeader.getFileName(), charset);
       }
       rawIO.writeShortLittleEndian(byteArrayOutputStream, fileNameBytes.length);
 
@@ -447,7 +450,7 @@ public class HeaderWriter {
       String fileComment = fileHeader.getFileComment();
       byte[] fileCommentBytes = new byte[0];
       if (isStringNotNullAndNotEmpty(fileComment)) {
-        fileCommentBytes = fileComment.getBytes(charset);
+        fileCommentBytes = getBytesFromString(fileComment, charset);
       }
       rawIO.writeShortLittleEndian(byteArrayOutputStream, fileCommentBytes.length);
 
@@ -509,7 +512,7 @@ public class HeaderWriter {
     }
   }
 
-  private int calculateExtraDataRecordsSize(FileHeader fileHeader, boolean writeZip64ExtendedInfo) throws IOException {
+  private int calculateExtraDataRecordsSize(FileHeader fileHeader, boolean writeZip64ExtendedInfo) {
     int extraFieldLength = 0;
 
     if (writeZip64ExtendedInfo) {
@@ -534,7 +537,8 @@ public class HeaderWriter {
     return extraFieldLength;
   }
 
-  private void writeRemainingExtraDataRecordsIfPresent(FileHeader fileHeader, OutputStream outputStream) throws IOException {
+  private void writeRemainingExtraDataRecordsIfPresent(FileHeader fileHeader, OutputStream outputStream)
+      throws IOException {
     if (fileHeader.getExtraDataRecords() == null || fileHeader.getExtraDataRecords().size() == 0) {
       return;
     }
@@ -582,7 +586,8 @@ public class HeaderWriter {
   }
 
   private void writeEndOfCentralDirectoryRecord(ZipModel zipModel, int sizeOfCentralDir, long offsetCentralDir,
-                                                ByteArrayOutputStream byteArrayOutputStream, RawIO rawIO, Charset charset)
+                                                ByteArrayOutputStream byteArrayOutputStream, RawIO rawIO,
+                                                Charset charset)
       throws IOException {
 
     byte[] longByte = new byte[8];
@@ -620,7 +625,7 @@ public class HeaderWriter {
 
     String comment = zipModel.getEndOfCentralDirectoryRecord().getComment();
     if (isStringNotNullAndNotEmpty(comment)) {
-      byte[] commentBytes = comment.getBytes(charset);
+      byte[] commentBytes = getBytesFromString(comment, charset);
       rawIO.writeShortLittleEndian(byteArrayOutputStream, commentBytes.length);
       byteArrayOutputStream.write(commentBytes);
     } else {
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index d4ddb06..2c24250 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -51,7 +51,7 @@ public class ZipInputStream extends InputStream {
   private Charset charset;
 
   public ZipInputStream(InputStream inputStream) {
-    this(inputStream, null, InternalZipConstants.CHARSET_UTF_8);
+    this(inputStream, null, null);
   }
 
   public ZipInputStream(InputStream inputStream, Charset charset) {
@@ -59,14 +59,10 @@ public class ZipInputStream extends InputStream {
   }
 
   public ZipInputStream(InputStream inputStream, char[] password) {
-    this(inputStream, password, InternalZipConstants.CHARSET_UTF_8);
+    this(inputStream, password, null);
   }
 
   public ZipInputStream(InputStream inputStream, char[] password, Charset charset) {
-    if(charset == null) {
-      charset = InternalZipConstants.CHARSET_UTF_8;
-    }
-
     this.inputStream = new PushbackInputStream(inputStream, InternalZipConstants.BUFF_SIZE);
     this.password = password;
     this.charset = charset;
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java
index d941ebc..ad45564 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipStandardCipherInputStream.java
@@ -1,7 +1,6 @@
 package net.lingala.zip4j.io.inputstream;
 
 import net.lingala.zip4j.crypto.StandardDecrypter;
-import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.LocalFileHeader;
 
 import java.io.IOException;
@@ -10,12 +9,13 @@ import static net.lingala.zip4j.util.InternalZipConstants.STD_DEC_HDR_SIZE;
 
 class ZipStandardCipherInputStream extends CipherInputStream<StandardDecrypter> {
 
-  public ZipStandardCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader, char[] password) throws IOException, ZipException {
+  public ZipStandardCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader,
+                                      char[] password) throws IOException {
     super(zipEntryInputStream, localFileHeader, password);
   }
 
   @Override
-  protected StandardDecrypter initializeDecrypter(LocalFileHeader localFileHeader, char[] password) throws ZipException, IOException {
+  protected StandardDecrypter initializeDecrypter(LocalFileHeader localFileHeader, char[] password) throws IOException {
     return new StandardDecrypter(password, localFileHeader.getCrcRawData(), getStandardDecrypterHeaderBytes());
   }
 
diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
index 265c7c2..3f76e61 100755
--- a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
@@ -11,7 +11,6 @@ import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesVersion;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
-import net.lingala.zip4j.util.InternalZipConstants;
 import net.lingala.zip4j.util.RawIO;
 
 import java.io.IOException;
@@ -36,7 +35,7 @@ public class ZipOutputStream extends OutputStream {
   private boolean streamClosed;
 
   public ZipOutputStream(OutputStream outputStream) throws IOException {
-    this(outputStream, null, InternalZipConstants.CHARSET_UTF_8);
+    this(outputStream, null, null);
   }
 
   public ZipOutputStream(OutputStream outputStream, Charset charset) throws IOException {
@@ -44,7 +43,7 @@ public class ZipOutputStream extends OutputStream {
   }
 
   public ZipOutputStream(OutputStream outputStream, char[] password) throws IOException {
-    this(outputStream, password, InternalZipConstants.CHARSET_UTF_8);
+    this(outputStream, password, null);
   }
 
   public ZipOutputStream(OutputStream outputStream, char[] password, Charset charset) throws IOException {
@@ -52,10 +51,6 @@ public class ZipOutputStream extends OutputStream {
   }
 
   public ZipOutputStream(OutputStream outputStream, char[] password, Charset charset, ZipModel zipModel) throws IOException {
-    if(charset == null) {
-      charset = InternalZipConstants.CHARSET_UTF_8;
-    }
-
     this.countingOutputStream = new CountingOutputStream(outputStream);
     this.password = password;
     this.charset = charset;
diff --git a/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
index 9f894cf..6323093 100644
--- a/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
@@ -67,7 +67,7 @@ public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.Rena
           currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, lengthToCopy, progressMonitor);
         } else {
           String newFileName = getNewFileName(fileNameMapForThisEntry.getValue(), fileNameMapForThisEntry.getKey(), fileHeader.getFileName());
-          byte[] newFileNameBytes = newFileName.getBytes(charset);
+          byte[] newFileNameBytes = HeaderUtil.getBytesFromString(newFileName, charset);
           int headersOffset = newFileNameBytes.length - fileHeader.getFileNameLength();
 
           currentFileCopyPointer = copyEntryAndChangeFileName(newFileNameBytes, fileHeader, currentFileCopyPointer, lengthToCopy,
diff --git a/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java b/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
index 5ce3811..b79184b 100755
--- a/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
+++ b/src/main/java/net/lingala/zip4j/util/InternalZipConstants.java
@@ -1,66 +1,69 @@
-/*
- * Copyright 2010 Srikanth Reddy Lingala
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package net.lingala.zip4j.util;
-
-import java.io.File;
-import java.nio.charset.Charset;
-
-public final class InternalZipConstants {
-
-  private InternalZipConstants() {
-
-  }
-
-  public static final int ENDHDR = 22;	// END header size
-  public static final int STD_DEC_HDR_SIZE = 12;
-
-  //AES Constants
-  public static final int AES_AUTH_LENGTH = 10;
-  public static final int AES_BLOCK_SIZE = 16;
-  public static final int AES_EXTRA_DATA_RECORD_SIZE = 11;
-  public static final String AES_MAC_ALGORITHM = "HmacSHA1";
-  public static final String AES_HASH_CHARSET = "ISO-8859-1";
-  public static final int AES_HASH_ITERATIONS = 1000;
-  public static final int AES_PASSWORD_VERIFIER_LENGTH = 2;
-
-  public static final int MIN_SPLIT_LENGTH = 65536;
-  public static final long ZIP_64_SIZE_LIMIT = 4294967295L;
-  public static final int ZIP_64_NUMBER_OF_ENTRIES_LIMIT = 65535;
-
-  public static final int BUFF_SIZE = 1024 * 4;
-
-  // Update local file header constants
-  // This value holds the number of bytes to skip from
-  // the offset of start of local header
-  public static final int UPDATE_LFH_CRC = 14;
-
-  public static final int UPDATE_LFH_COMP_SIZE = 18;
-
-  public static final int UPDATE_LFH_UNCOMP_SIZE = 22;
-
-  public static final String ZIP_STANDARD_CHARSET = "Cp437";
-
-  public static final String FILE_SEPARATOR = File.separator;
-
-  public static final String ZIP_FILE_SEPARATOR = "/";
-
-  public static final int MAX_ALLOWED_ZIP_COMMENT_LENGTH = 0xFFFF;
-
-  public static final Charset CHARSET_UTF_8 = Charset.forName("UTF-8");
-
-  public static final String SEVEN_ZIP_SPLIT_FILE_EXTENSION_PATTERN = ".zip.001";
-}
+/*
+ * Copyright 2010 Srikanth Reddy Lingala
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.lingala.zip4j.util;
+
+import java.io.File;
+import java.nio.charset.Charset;
+
+public final class InternalZipConstants {
+
+  private InternalZipConstants() {
+
+  }
+
+  public static final int ENDHDR = 22;	// END header size
+  public static final int STD_DEC_HDR_SIZE = 12;
+
+  //AES Constants
+  public static final int AES_AUTH_LENGTH = 10;
+  public static final int AES_BLOCK_SIZE = 16;
+  public static final int AES_EXTRA_DATA_RECORD_SIZE = 11;
+  public static final String AES_MAC_ALGORITHM = "HmacSHA1";
+  public static final String AES_HASH_CHARSET = "ISO-8859-1";
+  public static final int AES_HASH_ITERATIONS = 1000;
+  public static final int AES_PASSWORD_VERIFIER_LENGTH = 2;
+
+  public static final int MIN_SPLIT_LENGTH = 65536;
+  public static final long ZIP_64_SIZE_LIMIT = 4294967295L;
+  public static final int ZIP_64_NUMBER_OF_ENTRIES_LIMIT = 65535;
+
+  public static final int BUFF_SIZE = 1024 * 4;
+
+  // Update local file header constants
+  // This value holds the number of bytes to skip from
+  // the offset of start of local header
+  public static final int UPDATE_LFH_CRC = 14;
+
+  public static final int UPDATE_LFH_COMP_SIZE = 18;
+
+  public static final int UPDATE_LFH_UNCOMP_SIZE = 22;
+
+  public static final String FILE_SEPARATOR = File.separator;
+
+  public static final String ZIP_FILE_SEPARATOR = "/";
+
+  public static final int MAX_ALLOWED_ZIP_COMMENT_LENGTH = 0xFFFF;
+
+  public static final String ZIP_STANDARD_CHARSET_NAME = "Cp437";
+
+  // StandardCharset.UTF-8 could have been used below but StandardCharset does not exist in older versions of Android
+  public static final Charset CHARSET_UTF_8 = Charset.forName("UTF-8");
+
+  public static final Charset ZIP4J_DEFAULT_CHARSET = CHARSET_UTF_8;
+
+  public static final String SEVEN_ZIP_SPLIT_FILE_EXTENSION_PATTERN = ".zip.001";
+}
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderReaderIT.java b/src/test/java/net/lingala/zip4j/headers/HeaderReaderIT.java
index 112d802..955d9b7 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderReaderIT.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderReaderIT.java
@@ -153,9 +153,15 @@ public class HeaderReaderIT extends AbstractIT {
   }
 
   @Test
-  public void testReadAllWithoutUtf8FlagDecodesWithoutCharsetFlagForJapaneseCharactersDoesNotMatch()
+  public void testReadAllWithoutUtf8FlagDecodesWithoutCharsetFlagForJapaneseCharactersMatches()
       throws IOException {
-    testWithoutUtf8FileName("公ゃ的年社", "育ざどろめ", false, true, InternalZipConstants.CHARSET_UTF_8);
+    testWithoutUtf8FileName("公ゃ的年社", "育ざどろめ", true, true, InternalZipConstants.CHARSET_UTF_8);
+  }
+
+  @Test
+  public void testReadAllWithoutUtf8FlagAndWithoutCharsetForJapaneseCharactersDoesNotMatch()
+      throws IOException {
+    testWithoutUtf8FileName("公ゃ的年社", "育ざどろめ", false, true, null);
   }
 
   @Test
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
index 533c07a..b3d60e1 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
@@ -12,8 +12,8 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
-import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -147,16 +147,16 @@ public class HeaderUtilTest {
     byte[] utf8EncodedBytes = utf8StringToEncode.getBytes(InternalZipConstants.CHARSET_UTF_8);
 
     assertThat(HeaderUtil.decodeStringWithCharset(utf8EncodedBytes, true, null)).isEqualTo(utf8StringToEncode);
-
   }
 
   @Test
-  public void testDecodeStringWithCharsetWithUtf8ForUtf8String() {
-    String utf8StringToEncode = "asdäüöö";
-    byte[] utf8EncodedBytes = utf8StringToEncode.getBytes(InternalZipConstants.CHARSET_UTF_8);
+  public void testDecodeStringWithCharsetWithCharsetGBKForChineseString() {
+    String chineseStringToEncode = "写記立要";
+    byte[] gbkEncodedBytes = chineseStringToEncode.getBytes(Charset.forName("GBK"));
 
-    assertThat(HeaderUtil.decodeStringWithCharset(utf8EncodedBytes, false, InternalZipConstants.CHARSET_UTF_8)).isNotEqualTo(utf8StringToEncode);
+    String decodedString = HeaderUtil.decodeStringWithCharset(gbkEncodedBytes, false, Charset.forName("GBK"));
 
+    assertThat(decodedString).isEqualTo(chineseStringToEncode);
   }
 
   @Test
@@ -165,15 +165,14 @@ public class HeaderUtilTest {
     byte[] plainEncodedBytes = plainString.getBytes();
 
     assertThat(HeaderUtil.decodeStringWithCharset(plainEncodedBytes, false, null)).isEqualTo(plainString);
-
   }
 
   @Test
-  public void testDecodeStringWithCharsetWithISO8859AndFinnishChars() throws UnsupportedEncodingException {
+  public void testDecodeStringWithCharsetWithISO8859AndFinnishChars() {
     String finnishString = "asdäüöö";
-    byte[] plainEncodedBytes = finnishString.getBytes("ISO-8859-1");
+    byte[] plainEncodedBytes = finnishString.getBytes(StandardCharsets.ISO_8859_1);
 
-    assertThat(HeaderUtil.decodeStringWithCharset(plainEncodedBytes, false, Charset.forName("ISO-8859-1"))).isEqualTo(finnishString);
+    assertThat(HeaderUtil.decodeStringWithCharset(plainEncodedBytes, false, StandardCharsets.ISO_8859_1)).isEqualTo(finnishString);
   }
 
   @Test
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
index fc1c80a..999b830 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderWriterIT.java
@@ -4,8 +4,19 @@ import net.lingala.zip4j.AbstractIT;
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.io.outputstream.CountingOutputStream;
 import net.lingala.zip4j.io.outputstream.SplitOutputStream;
-import net.lingala.zip4j.model.*;
-import net.lingala.zip4j.model.enums.*;
+import net.lingala.zip4j.model.AESExtraDataRecord;
+import net.lingala.zip4j.model.CentralDirectory;
+import net.lingala.zip4j.model.DataDescriptor;
+import net.lingala.zip4j.model.ExtraDataRecord;
+import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.LocalFileHeader;
+import net.lingala.zip4j.model.Zip64ExtendedInfo;
+import net.lingala.zip4j.model.ZipModel;
+import net.lingala.zip4j.model.enums.AesKeyStrength;
+import net.lingala.zip4j.model.enums.AesVersion;
+import net.lingala.zip4j.model.enums.CompressionMethod;
+import net.lingala.zip4j.model.enums.EncryptionMethod;
+import net.lingala.zip4j.model.enums.RandomAccessFileMode;
 import net.lingala.zip4j.util.BitUtils;
 import net.lingala.zip4j.util.InternalZipConstants;
 import net.lingala.zip4j.util.RawIO;
@@ -13,7 +24,13 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
-import java.io.*;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.RandomAccessFile;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
@@ -92,9 +109,9 @@ public class HeaderWriterIT extends AbstractIT {
   }
 
   @Test
-  public void testWriteLocalFileHeaderJapaneseCharactersInFileNameWithoutUtf8ShouldNotMatch()
+  public void testWriteLocalFileHeaderJapaneseCharactersInFileNameWithoutUtf8ShouldMatch()
       throws IOException {
-    testWriteLocalFileHeaderWithFileName("公ゃ的年社", false, false);
+    testWriteLocalFileHeaderWithFileName("公ゃ的年社", false, true);
   }
 
   @Test
