diff --git a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
index 077d478..2fcc8e7 100644
--- a/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
+++ b/src/main/java/net/lingala/zip4j/headers/FileHeaderFactory.java
@@ -71,6 +71,7 @@ public class FileHeaderFactory {
 
     fileHeader.setGeneralPurposeFlag(determineGeneralPurposeBitFlag(fileHeader.isEncrypted(), zipParameters, charset));
     fileHeader.setDataDescriptorExists(zipParameters.isWriteExtendedLocalFileHeader());
+    fileHeader.setFileComment(zipParameters.getFileComment());
     return fileHeader;
   }
 
diff --git a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
index eae53b4..3ab9144 100755
--- a/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/outputstream/ZipOutputStream.java
@@ -33,6 +33,7 @@ public class ZipOutputStream extends OutputStream {
   private RawIO rawIO = new RawIO();
   private long uncompressedSizeForThisEntry = 0;
   private Charset charset;
+  private boolean streamClosed;
 
   public ZipOutputStream(OutputStream outputStream) throws IOException {
     this(outputStream, null, InternalZipConstants.CHARSET_UTF_8);
@@ -59,6 +60,7 @@ public class ZipOutputStream extends OutputStream {
     this.password = password;
     this.charset = charset;
     this.zipModel = initializeZipModel(zipModel, countingOutputStream);
+    this.streamClosed = false;
     writeSplitZipHeaderIfApplicable();
   }
 
@@ -81,6 +83,7 @@ public class ZipOutputStream extends OutputStream {
   }
 
   public void write(byte[] b, int off, int len) throws IOException {
+    ensureStreamOpen();
     crc32.update(b, off, len);
     compressedOutputStream.write(b, off, len);
     uncompressedSizeForThisEntry += len;
@@ -116,6 +119,18 @@ public class ZipOutputStream extends OutputStream {
     zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(countingOutputStream.getNumberOfBytesWritten());
     headerWriter.finalizeZipFile(zipModel, countingOutputStream, charset);
     countingOutputStream.close();
+    this.streamClosed = true;
+  }
+
+  public void setComment(String comment) throws IOException {
+    ensureStreamOpen();
+    zipModel.getEndOfCentralDirectoryRecord().setComment(comment);
+  }
+
+  private void ensureStreamOpen() throws IOException {
+    if (streamClosed) {
+      throw new IOException("Stream is closed");
+    }
   }
 
   private ZipModel initializeZipModel(ZipModel zipModel, CountingOutputStream countingOutputStream) {
diff --git a/src/main/java/net/lingala/zip4j/model/ZipParameters.java b/src/main/java/net/lingala/zip4j/model/ZipParameters.java
index ae05c6f..693701c 100755
--- a/src/main/java/net/lingala/zip4j/model/ZipParameters.java
+++ b/src/main/java/net/lingala/zip4j/model/ZipParameters.java
@@ -41,6 +41,7 @@ public class ZipParameters {
   private boolean writeExtendedLocalFileHeader = true;
   private boolean overrideExistingFilesInZip = true;
   private String rootFolderNameInZip;
+  private String fileComment;
 
   public ZipParameters() {
   }
@@ -63,6 +64,7 @@ public class ZipParameters {
     this.writeExtendedLocalFileHeader = zipParameters.isWriteExtendedLocalFileHeader();
     this.overrideExistingFilesInZip = zipParameters.isOverrideExistingFilesInZip();
     this.rootFolderNameInZip = zipParameters.getRootFolderNameInZip();
+    this.fileComment = zipParameters.getFileComment();
   }
 
   public CompressionMethod getCompressionMethod() {
@@ -208,4 +210,12 @@ public class ZipParameters {
   public void setRootFolderNameInZip(String rootFolderNameInZip) {
     this.rootFolderNameInZip = rootFolderNameInZip;
   }
+
+  public String getFileComment() {
+    return fileComment;
+  }
+
+  public void setFileComment(String fileComment) {
+    this.fileComment = fileComment;
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
index 35429f9..d73e421 100644
--- a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
@@ -19,6 +19,8 @@ import org.junit.rules.ExpectedException;
 import java.io.File;
 import java.io.FilenameFilter;
 import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -251,6 +253,38 @@ public class CreateZipFileIT extends AbstractIT {
     verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size());
   }
 
+  @Test
+  public void testAddFileWithFileEntryCommentAndUtf8Charset() throws IOException {
+    testCreateZipFileWithFileEntryComment("FILE_COMMET_", StandardCharsets.UTF_8);
+  }
+
+  @Test
+  public void testAddFileWithFileEntryCommentAndNullCharsetUsesUtf8() throws IOException {
+    testCreateZipFileWithFileEntryComment("FILE_COMMET_", null);
+  }
+
+  @Test
+  public void testAddFileWithFileEntryCommentAndGBKCharset() throws IOException {
+    testCreateZipFileWithFileEntryComment("测试中文_", Charset.forName("GBK"));
+  }
+
+  private void testCreateZipFileWithFileEntryComment(String fileCommentPrefix, Charset charset) throws IOException {
+    ZipParameters zipParameters = new ZipParameters();
+    ZipFile zipFile = initializeZipFileWithCharset(charset);
+
+    for (int i = 0; i < FILES_TO_ADD.size(); i++) {
+      if (i == 0) {
+        zipParameters.setFileComment(fileCommentPrefix + i);
+      } else {
+        zipParameters.setFileComment(null);
+      }
+      zipFile.addFile(FILES_TO_ADD.get(i), zipParameters);
+    }
+
+    verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, FILES_TO_ADD.size());
+    verifyFileEntryComment(fileCommentPrefix, charset);
+  }
+
   private void verifySplitZip(File zipFile, int numberOfExpectedSplitFiles, long splitLength) throws ZipException {
     assertNumberOfSplitFile(zipFile, numberOfExpectedSplitFiles);
     assertSplitFileSizes(zipFile, numberOfExpectedSplitFiles, splitLength);
@@ -308,4 +342,27 @@ public class CreateZipFileIT extends AbstractIT {
     FilenameFilter filenameFilter = (dir, name) -> name.contains(fileNameWithoutExtension + ".");
     return folder.listFiles(filenameFilter);
   }
+
+  private void verifyFileEntryComment(String commentPrefix, Charset charset) throws IOException {
+    ZipFile zipFile = initializeZipFileWithCharset(charset);
+    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
+    for (int i = 0; i < fileHeaders.size(); i++) {
+      FileHeader fileHeader = fileHeaders.get(i);
+      if (i == 0) {
+        assertThat(fileHeader.getFileComment()).isEqualTo(commentPrefix + i);
+      } else {
+        assertThat(fileHeader.getFileComment()).isNull();
+      }
+    }
+  }
+
+  private ZipFile initializeZipFileWithCharset(Charset charset) {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    if (charset != null) {
+      zipFile.setCharset(charset);
+    }
+
+    return zipFile;
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java b/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
index cf14adb..c7ec653 100644
--- a/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/outputstream/ZipOutputStreamIT.java
@@ -21,6 +21,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -120,6 +121,52 @@ public class ZipOutputStreamIT extends AbstractIT {
     }
   }
 
+  @Test
+  public void testAddCommentToEntryWithUtf8Charset() throws IOException {
+    testAddCommentToEntryWithCharset(StandardCharsets.UTF_8, "COMMENT_");
+  }
+
+  @Test
+  public void testAddCommentToEntryWithNullCharset() throws IOException {
+    testAddCommentToEntryWithCharset(null, "COMMENT_ÜÖ_");
+  }
+
+  @Test
+  public void testAddCommentToEntryWithGBKCharset() throws IOException {
+    testAddCommentToEntryWithCharset(Charset.forName("GBK"), "fff - 副本");
+  }
+
+  @Test
+  public void testAddCommentToZipOutputStreamWithUtf8Charset() throws IOException {
+    testAddCommentToZipOutputStreamWithCharset(StandardCharsets.UTF_8, "SOME_COMMENT");
+  }
+
+  @Test
+  public void testAddCommentToZipOutputStreamWithNullCharsetUsesUtf8() throws IOException {
+    testAddCommentToZipOutputStreamWithCharset(null, "SOME_COMMENT_WITH_NO_CHARSET");
+  }
+
+  @Test
+  public void testAddCommentToZipOutputStreamWithGBKCharset() throws IOException {
+    testAddCommentToZipOutputStreamWithCharset(Charset.forName("GBK"), "fff - 副本");
+  }
+
+  @Test
+  public void testAddCommentToZipOutputStreamAfterClosingThrowsException() throws IOException {
+    expectedException.expect(IOException.class);
+    expectedException.expectMessage("Stream is closed");
+
+    ZipParameters zipParameters = new ZipParameters();
+    ZipOutputStream zos = initializeZipOutputStream(false, InternalZipConstants.CHARSET_UTF_8);
+    for (File fileToAdd : FILES_TO_ADD) {
+      zipParameters.setLastModifiedFileTime(fileToAdd.lastModified());
+      zipParameters.setFileNameInZip(fileToAdd.getName());
+      zos.putNextEntry(zipParameters);
+    }
+    zos.close();
+    zos.setComment("SOME_COMMENT");
+  }
+
   private void testZipOutputStream(CompressionMethod compressionMethod, boolean encrypt,
                                    EncryptionMethod encryptionMethod, AesKeyStrength aesKeyStrength,
                                    AesVersion aesVersion)
@@ -170,6 +217,65 @@ public class ZipOutputStreamIT extends AbstractIT {
     verifyEntries();
   }
 
+  private void testAddCommentToEntryWithCharset(Charset charset, String fileCommentPrefix) throws IOException {
+    ZipParameters zipParameters = new ZipParameters();
+    byte[] buff = new byte[4096];
+    int readLen;
+
+    List<File> filesToAdd = FILES_TO_ADD;
+    try(ZipOutputStream zos = initializeZipOutputStream(false, charset)) {
+      for (int i = 0; i < filesToAdd.size(); i++) {
+        File fileToAdd = filesToAdd.get(i);
+        zipParameters.setFileNameInZip(fileToAdd.getName());
+
+        if (i == 0) {
+          zipParameters.setFileComment(fileCommentPrefix + i);
+        } else {
+          zipParameters.setFileComment(null);
+        }
+
+        zos.putNextEntry(zipParameters);
+
+        try(InputStream inputStream = new FileInputStream(fileToAdd)) {
+          while ((readLen = inputStream.read(buff)) != -1) {
+            zos.write(buff, 0, readLen);
+          }
+        }
+        zos.closeEntry();
+      }
+    }
+    verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, filesToAdd.size(), true, charset);
+    verifyEntries();
+    verifyFileEntryComment(fileCommentPrefix, charset);
+  }
+
+  private void testAddCommentToZipOutputStreamWithCharset(Charset charset, String comment) throws IOException {
+    ZipParameters zipParameters = new ZipParameters();
+    byte[] buff = new byte[4096];
+    int readLen;
+
+    List<File> filesToAdd = FILES_TO_ADD;
+    try(ZipOutputStream zos = initializeZipOutputStream(false, charset)) {
+      for (int i = 0; i < filesToAdd.size(); i++) {
+        File fileToAdd = filesToAdd.get(i);
+        zipParameters.setFileNameInZip(fileToAdd.getName());
+
+        zos.putNextEntry(zipParameters);
+
+        try(InputStream inputStream = new FileInputStream(fileToAdd)) {
+          while ((readLen = inputStream.read(buff)) != -1) {
+            zos.write(buff, 0, readLen);
+          }
+        }
+        zos.closeEntry();
+      }
+      zos.setComment(comment);
+    }
+    verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, filesToAdd.size(), true, charset);
+    verifyEntries();
+    verifyZipComment(comment, charset);
+  }
+
   private void verifyEntries() throws ZipException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
     for (FileHeader fileHeader : zipFile.getFileHeaders()) {
@@ -207,4 +313,32 @@ public class ZipOutputStreamIT extends AbstractIT {
     zipParameters.setEncryptFiles(encrypt);
     return zipParameters;
   }
+
+  private void verifyFileEntryComment(String commentPrefix, Charset charset) throws IOException {
+    ZipFile zipFile = initializeZipFileWithCharset(charset);
+    List<FileHeader> fileHeaders = zipFile.getFileHeaders();
+    for (int i = 0; i < fileHeaders.size(); i++) {
+      FileHeader fileHeader = fileHeaders.get(i);
+      if (i == 0) {
+        assertThat(fileHeader.getFileComment()).isEqualTo(commentPrefix + i);
+      } else {
+        assertThat(fileHeader.getFileComment()).isNull();
+      }
+    }
+  }
+
+  private void verifyZipComment(String expectedComment, Charset charset) throws IOException {
+    ZipFile zipFile = initializeZipFileWithCharset(charset);
+    assertThat(zipFile.getComment()).isEqualTo(expectedComment);
+  }
+
+  private ZipFile initializeZipFileWithCharset(Charset charset) {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    if (charset != null) {
+      zipFile.setCharset(charset);
+    }
+
+    return zipFile;
+  }
 }
\ No newline at end of file
diff --git a/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java b/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java
index f95c130..09d17d2 100644
--- a/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java
+++ b/src/test/java/net/lingala/zip4j/testutils/ZipFileVerifier.java
@@ -39,7 +39,11 @@ public class ZipFileVerifier {
     assertThat(zipFileToExtract).exists();
 
     ZipFile zipFile = new ZipFile(zipFileToExtract, password);
-    zipFile.setCharset(charset);
+
+    if (charset != null) {
+      zipFile.setCharset(charset);
+    }
+
     zipFile.extractAll(outputFolder.getPath());
     assertThat(zipFile.getFileHeaders().size()).as("Number of file headers").isEqualTo(expectedNumberOfEntries);
 
