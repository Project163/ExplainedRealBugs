diff --git a/src/main/java/net/lingala/zip4j/exception/ZipException.java b/src/main/java/net/lingala/zip4j/exception/ZipException.java
index b13be2a..2de1357 100755
--- a/src/main/java/net/lingala/zip4j/exception/ZipException.java
+++ b/src/main/java/net/lingala/zip4j/exception/ZipException.java
@@ -41,8 +41,8 @@ public class ZipException extends IOException {
     this.type = type;
   }
 
-  public ZipException(Throwable throwable, Type type) {
-    super(throwable);
+  public ZipException(String message, Throwable throwable, Type type) {
+    super(message, throwable);
     this.type = type;
   }
 
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
index 8ab865b..1a68460 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
@@ -16,29 +16,35 @@ import static net.lingala.zip4j.util.InternalZipConstants.AES_AUTH_LENGTH;
 
 class AesCipherInputStream extends CipherInputStream<AESDecrypter> {
 
-  private byte[] aesBlockByte = new byte[16];
-  private int aesBytesReturned = 0;
-  private boolean non16ByteBlockRead = false;
+  private byte[] singleByteBuffer = new byte[1];
+  private byte[] aes16ByteBlock = new byte[16];
+  private int aes16ByteBlockPointer = 0;
+  private int remainingAes16ByteBlockLength = 0;
+  private int lengthToRead = 0;
+  private int offsetWithAesBlock = 0;
+  private int bytesCopiedInThisIteration = 0;
+  private int lengthToCopyInThisIteration = 0;
+  private int aes16ByteBlockReadLength = 0;
 
   public AesCipherInputStream(ZipEntryInputStream zipEntryInputStream, LocalFileHeader localFileHeader, char[] password)
-      throws IOException, ZipException {
+      throws IOException {
     super(zipEntryInputStream, localFileHeader, password);
   }
 
   @Override
-  protected AESDecrypter initializeDecrypter(LocalFileHeader localFileHeader, char[] password) throws IOException, ZipException {
+  protected AESDecrypter initializeDecrypter(LocalFileHeader localFileHeader, char[] password) throws IOException {
     return new AESDecrypter(localFileHeader.getAesExtraDataRecord(), password, getSalt(localFileHeader), getPasswordVerifier());
   }
 
   @Override
   public int read() throws IOException {
-    if (aesBytesReturned == 0 || aesBytesReturned == 16) {
-      if (read(aesBlockByte) == -1) {
-        return -1;
-      }
-      aesBytesReturned = 0;
+    int readLen = read(singleByteBuffer);
+
+    if (readLen == -1) {
+      return -1;
     }
-    return aesBlockByte[aesBytesReturned++] & 0xff;
+
+    return singleByteBuffer[0];
   }
 
   @Override
@@ -48,8 +54,65 @@ class AesCipherInputStream extends CipherInputStream<AESDecrypter> {
 
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
-    assertNon16ByteBlockNotReadTwice(len);
-    return super.read(b, off, len);
+    lengthToRead = len;
+    offsetWithAesBlock = off;
+    bytesCopiedInThisIteration = 0;
+
+    if (remainingAes16ByteBlockLength != 0) {
+      copyBytesFromBuffer(b, offsetWithAesBlock);
+
+      if (bytesCopiedInThisIteration == len) {
+        return bytesCopiedInThisIteration;
+      }
+    }
+
+    if (lengthToRead < 16) {
+      aes16ByteBlockReadLength = super.read(aes16ByteBlock, 0, aes16ByteBlock.length);
+      aes16ByteBlockPointer = 0;
+
+      if (aes16ByteBlockReadLength == -1) {
+        remainingAes16ByteBlockLength = 0;
+
+        if (bytesCopiedInThisIteration > 0) {
+          return bytesCopiedInThisIteration;
+        }
+
+        return -1;
+      }
+
+      remainingAes16ByteBlockLength = aes16ByteBlockReadLength;
+
+      copyBytesFromBuffer(b, offsetWithAesBlock);
+
+      if (bytesCopiedInThisIteration == len) {
+        return bytesCopiedInThisIteration;
+      }
+    }
+
+    int readLen = super.read(b, offsetWithAesBlock, (lengthToRead - lengthToRead %16));
+
+    if (readLen == -1) {
+      if (bytesCopiedInThisIteration > 0) {
+        return bytesCopiedInThisIteration;
+      } else {
+        return -1;
+      }
+    } else {
+      return readLen + bytesCopiedInThisIteration;
+    }
+  }
+
+  private void copyBytesFromBuffer(byte[] b, int off) {
+    lengthToCopyInThisIteration = lengthToRead < remainingAes16ByteBlockLength ? lengthToRead : remainingAes16ByteBlockLength;
+    System.arraycopy(aes16ByteBlock, aes16ByteBlockPointer, b, off, lengthToCopyInThisIteration);
+
+    incrementAesByteBlockPointer(lengthToCopyInThisIteration);
+    decrementRemainingAesBytesLength(lengthToCopyInThisIteration);
+
+    bytesCopiedInThisIteration += lengthToCopyInThisIteration;
+
+    lengthToRead -= lengthToCopyInThisIteration;
+    offsetWithAesBlock += lengthToCopyInThisIteration;
   }
 
   @Override
@@ -82,21 +145,12 @@ class AesCipherInputStream extends CipherInputStream<AESDecrypter> {
     int readLen = inputStream.read(storedMac);
 
     if (readLen != AES_AUTH_LENGTH) {
-      throw new IOException("Invalid AES Mac bytes. Could not read sufficient data");
+      throw new ZipException("Invalid AES Mac bytes. Could not read sufficient data");
     }
 
     return storedMac;
   }
 
-  private void assertNon16ByteBlockNotReadTwice(int readLen) throws IOException {
-    if (readLen % 16 != 0) {
-      if (non16ByteBlockRead) {
-        throw new IOException("AES non-16 byte block already read");
-      }
-      non16ByteBlockRead = true;
-    }
-  }
-
   private byte[] getSalt(LocalFileHeader localFileHeader) throws IOException {
     if (localFileHeader.getAesExtraDataRecord() == null) {
       throw new IOException("invalid aes extra data record");
@@ -113,4 +167,20 @@ class AesCipherInputStream extends CipherInputStream<AESDecrypter> {
     readRaw(pvBytes);
     return pvBytes;
   }
+
+  private void incrementAesByteBlockPointer(int incrementBy) {
+    aes16ByteBlockPointer += incrementBy;
+
+    if (aes16ByteBlockPointer >= 15) {
+      aes16ByteBlockPointer = 15;
+    }
+  }
+
+  private void decrementRemainingAesBytesLength(int decrementBy) {
+    remainingAes16ByteBlockLength -= decrementBy;
+
+    if (remainingAes16ByteBlockLength <= 0) {
+      remainingAes16ByteBlockLength = 0;
+    }
+  }
 }
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
index 35e540d..9335165 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
@@ -39,14 +39,18 @@ abstract class CipherInputStream<T extends Decrypter> extends InputStream {
 
   @Override
   public int read(byte[] b) throws IOException {
-    return read(b, 0, b.length);
+    return this.read(b, 0, b.length);
   }
 
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
     int readLen = zipEntryInputStream.read(b, off, len);
-    cacheRawData(b, readLen);
-    decrypter.decryptData(b, off, readLen);
+
+    if (readLen > 0) {
+      cacheRawData(b, readLen);
+      decrypter.decryptData(b, off, readLen);
+    }
+
     return readLen;
   }
 
@@ -60,7 +64,7 @@ abstract class CipherInputStream<T extends Decrypter> extends InputStream {
   }
 
   protected int readRaw(byte[] b) throws IOException {
-    return zipEntryInputStream.read(b);
+    return zipEntryInputStream.readHeaders(b);
   }
 
   private void cacheRawData(byte[] b, int len) {
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/DecompressedInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/DecompressedInputStream.java
index c7646eb..ed36cbf 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/DecompressedInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/DecompressedInputStream.java
@@ -7,13 +7,10 @@ import java.io.PushbackInputStream;
 abstract class DecompressedInputStream extends InputStream {
 
   private CipherInputStream cipherInputStream;
-  private long bytesRead = 0;
-  private long compressedSize;
   protected byte[] oneByteBuffer = new byte[1];
 
-  public DecompressedInputStream(CipherInputStream cipherInputStream, long compressedSize) {
+  public DecompressedInputStream(CipherInputStream cipherInputStream) {
     this.cipherInputStream = cipherInputStream;
-    this.compressedSize = compressedSize;
   }
 
   @Override
@@ -34,19 +31,7 @@ abstract class DecompressedInputStream extends InputStream {
 
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
-    if (compressedSize != -1) {
-      if (bytesRead >= compressedSize) {
-        return -1;
-      }
-
-      if (len > compressedSize - bytesRead) {
-        len = (int) (compressedSize - bytesRead);
-      }
-    }
-
-    int readLen = cipherInputStream.read(b, off, len);
-    bytesRead += readLen;
-    return readLen;
+    return cipherInputStream.read(b, off, len);
   }
 
   @Override
@@ -65,8 +50,4 @@ abstract class DecompressedInputStream extends InputStream {
   protected byte[] getLastReadRawDataCache() {
     return cipherInputStream.getLastReadRawDataCache();
   }
-
-  protected long getCompressedSize() {
-    return compressedSize;
-  }
 }
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/InflaterInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/InflaterInputStream.java
index 0b3abf5..06e50c8 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/InflaterInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/InflaterInputStream.java
@@ -13,8 +13,8 @@ public class InflaterInputStream extends DecompressedInputStream {
   private byte[] singleByteBuffer = new byte[1];
   private int len;
 
-  public InflaterInputStream(CipherInputStream cipherInputStream, long compressedSize) {
-    super(cipherInputStream, compressedSize);
+  public InflaterInputStream(CipherInputStream cipherInputStream) {
+    super(cipherInputStream);
     this.inflater = new Inflater(true);
     buff = new byte[512];
   }
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/StoreInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/StoreInputStream.java
index 0ed396d..81c0e15 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/StoreInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/StoreInputStream.java
@@ -2,7 +2,7 @@ package net.lingala.zip4j.io.inputstream;
 
 class StoreInputStream extends DecompressedInputStream {
 
-  public StoreInputStream(CipherInputStream cipherInputStream, long compressedSize) {
-    super(cipherInputStream, compressedSize);
+  public StoreInputStream(CipherInputStream cipherInputStream) {
+    super(cipherInputStream);
   }
 }
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipEntryInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipEntryInputStream.java
index 511d263..ac3015f 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipEntryInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipEntryInputStream.java
@@ -8,9 +8,11 @@ class ZipEntryInputStream extends InputStream {
   private InputStream inputStream;
   private long numberOfBytesRead = 0;
   private byte[] singleByteArray = new byte[1];
+  private long compressedSize;
 
-  public ZipEntryInputStream(InputStream inputStream) {
+  public ZipEntryInputStream(InputStream inputStream, long compressedSize) {
     this.inputStream = inputStream;
+    this.compressedSize = compressedSize;
   }
 
   @Override
@@ -30,11 +32,30 @@ class ZipEntryInputStream extends InputStream {
 
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
+
+    if (compressedSize != -1) {
+      if (numberOfBytesRead >= compressedSize) {
+        return -1;
+      }
+
+      if (len > compressedSize - numberOfBytesRead) {
+        len = (int) (compressedSize - numberOfBytesRead);
+      }
+    }
+
     int readLen = inputStream.read(b, off, len);
-    numberOfBytesRead += readLen;
+
+    if (readLen > 0) {
+      numberOfBytesRead += readLen;
+    }
+
     return readLen;
   }
 
+  public int readHeaders(byte[] b) throws  IOException {
+    return inputStream.read(b);
+  }
+
   @Override
   public void close() throws IOException {
     inputStream.close();
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
index 9c14b21..180a0f5 100755
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipInputStream.java
@@ -102,12 +102,20 @@ public class ZipInputStream extends InputStream {
 
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
-    if (isZipEntryDirectory(localFileHeader.getFileName())) {
+    if (len < 0) {
+      throw new IllegalArgumentException("Negative read length");
+    }
+
+    if (len == 0) {
+      return 0;
+    }
+
+    if (localFileHeader.isDirectory()) {
       return -1;
     }
 
     try {
-      int readLen = decompressedInputStream.read(b, off, (len - len %16));
+      int readLen = decompressedInputStream.read(b, off, len);
 
       if (readLen == -1) {
         endOfCompressedDataReached();
@@ -119,7 +127,7 @@ public class ZipInputStream extends InputStream {
     } catch (IOException e) {
       if (e.getCause() != null && e.getCause() instanceof DataFormatException
           && isEncryptionMethodZipStandard(localFileHeader)) {
-        throw new ZipException(e.getCause(), ZipException.Type.WRONG_PASSWORD);
+        throw new ZipException(e.getMessage(), e.getCause(), ZipException.Type.WRONG_PASSWORD);
       }
 
       throw e;
@@ -147,7 +155,7 @@ public class ZipInputStream extends InputStream {
   }
 
   private DecompressedInputStream initializeEntryInputStream(LocalFileHeader localFileHeader) throws IOException {
-    ZipEntryInputStream zipEntryInputStream = new ZipEntryInputStream(inputStream);
+    ZipEntryInputStream zipEntryInputStream = new ZipEntryInputStream(inputStream, getCompressedSize(localFileHeader));
     CipherInputStream cipherInputStream = initializeCipherInputStream(zipEntryInputStream, localFileHeader);
     return initializeDecompressorForThisEntry(cipherInputStream, localFileHeader);
   }
@@ -168,10 +176,10 @@ public class ZipInputStream extends InputStream {
     CompressionMethod compressionMethod = getCompressionMethod(localFileHeader);
 
     if (compressionMethod == CompressionMethod.DEFLATE) {
-      return new InflaterInputStream(cipherInputStream, getCompressedSize(localFileHeader));
+      return new InflaterInputStream(cipherInputStream);
     }
 
-    return new StoreInputStream(cipherInputStream, localFileHeader.getUncompressedSize());
+    return new StoreInputStream(cipherInputStream);
   }
 
   private void readExtendedLocalFileHeaderIfPresent() throws IOException {
@@ -242,6 +250,10 @@ public class ZipInputStream extends InputStream {
   }
 
   private long getCompressedSize(LocalFileHeader localFileHeader) {
+    if (getCompressionMethod(localFileHeader).equals(CompressionMethod.STORE)) {
+      return localFileHeader.getUncompressedSize();
+    }
+
     if (localFileHeader.isDataDescriptorExists()) {
       return -1;
     }
diff --git a/src/main/java/net/lingala/zip4j/util/RawIO.java b/src/main/java/net/lingala/zip4j/util/RawIO.java
index 2b6aa87..6d2a491 100755
--- a/src/main/java/net/lingala/zip4j/util/RawIO.java
+++ b/src/main/java/net/lingala/zip4j/util/RawIO.java
@@ -16,6 +16,8 @@
 
 package net.lingala.zip4j.util;
 
+import net.lingala.zip4j.exception.ZipException;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -150,7 +152,7 @@ public class RawIO {
   private void readFully(InputStream inputStream, byte[] buff, int readLen) throws IOException {
     int actualReadLength = inputStream.read(buff, 0, readLen);
     if (actualReadLength != readLen) {
-      throw new IOException("Could not fill buffer");
+      throw new ZipException("Could not fill buffer");
     }
   }
 
diff --git a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
index d0c4d95..d4745aa 100644
--- a/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
+++ b/src/test/java/net/lingala/zip4j/io/inputstream/ZipInputStreamIT.java
@@ -14,6 +14,7 @@ import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.util.Random;
 
 import static net.lingala.zip4j.utils.TestUtils.getTestFileFromResources;
 import static net.lingala.zip4j.utils.ZipFileVerifier.verifyFileContent;
@@ -63,12 +64,91 @@ public class ZipInputStreamIT extends AbstractIT {
     extractZipFileWithInputStreams(createdZipFile, PASSWORD);
   }
 
-  private void extractZipFileWithInputStreams(File zipFile, char[] password) throws IOException {
+  @Test
+  public void testExtractWithReadLengthLessThan16WithAesAndStoreCompression() throws IOException {
+    File createZipFile = createZipFile(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, 15);
+  }
+
+  @Test
+  public void testExtractWithReadLengthLessThan16WithAesAndDeflateCompression() throws IOException {
+    File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, 15);
+  }
+
+  @Test
+  public void testExtractWithReadLengthLessThan16WithZipCryptoAndStoreCompression() throws IOException {
+    File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, PASSWORD);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, 12);
+  }
+
+  @Test
+  public void testExtractWithReadLengthLessThan16WithZipCryptoAndDeflateCompression() throws IOException {
+    File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, PASSWORD);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, 5);
+  }
+
+  @Test
+  public void testExtractWithReadLengthGreaterThanButNotMultipleOf16WithAesAndStoreCompression() throws IOException {
+    File createZipFile = createZipFile(CompressionMethod.STORE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 4) + 1);
+  }
+
+  @Test
+  public void testExtractWithReadLengthGreaterThanButNotMultipleOf16WithAesAndDeflateCompression() throws IOException {
+    File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 8) - 10);
+  }
+
+  @Test
+  public void testExtractWithReadLengthGreaterThanButNotMultipleOf16WithZipCryptoAndStoreCompression() throws IOException {
+    File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, PASSWORD);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 2) - 6);
+  }
+
+  @Test
+  public void testExtractWithReadLengthGreaterThanButNotMultipleOf16WithZipCryptoAndDeflateCompression() throws IOException {
+    File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.ZIP_STANDARD, null, PASSWORD);
+    extractZipFileWithInputStreams(createZipFile, PASSWORD, (16 * 10) - 11);
+  }
+
+  @Test
+  public void testExtractWithRandomLengthWithAesAndDeflateCompression() throws IOException {
+    Random random = new Random();
+    File createZipFile = createZipFile(CompressionMethod.DEFLATE, true, EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256, PASSWORD);
     LocalFileHeader localFileHeader;
     int readLen;
     byte[] readBuffer = new byte[4096];
     int numberOfEntriesExtracted = 0;
 
+    try (FileInputStream fileInputStream = new FileInputStream(createZipFile)) {
+      try (ZipInputStream zipInputStream = new ZipInputStream(fileInputStream, PASSWORD)) {
+        while ((localFileHeader = zipInputStream.getNextEntry()) != null) {
+          File extractedFile = temporaryFolder.newFile(localFileHeader.getFileName());
+          try (OutputStream outputStream = new FileOutputStream(extractedFile)) {
+            while ((readLen = zipInputStream.read(readBuffer, 0, random.nextInt((25 - 1) + 1) + 1)) != -1) {
+              outputStream.write(readBuffer, 0, readLen);
+            }
+          }
+          verifyFileContent(getTestFileFromResources(localFileHeader.getFileName()), extractedFile);
+          numberOfEntriesExtracted++;
+        }
+      }
+    }
+
+    assertThat(numberOfEntriesExtracted).isEqualTo(FILES_TO_ADD.size());
+  }
+
+  private void extractZipFileWithInputStreams(File zipFile, char[] password) throws IOException {
+    extractZipFileWithInputStreams(zipFile, password, 4096);
+  }
+
+  private void extractZipFileWithInputStreams(File zipFile, char[] password, int bufferLength) throws IOException {
+    LocalFileHeader localFileHeader;
+    int readLen;
+    byte[] readBuffer = new byte[bufferLength];
+    int numberOfEntriesExtracted = 0;
+
     try (FileInputStream fileInputStream = new FileInputStream(zipFile)) {
       try (ZipInputStream zipInputStream = new ZipInputStream(fileInputStream, password)) {
         while ((localFileHeader = zipInputStream.getNextEntry()) != null) {
