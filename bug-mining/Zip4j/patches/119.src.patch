diff --git a/pom.xml b/pom.xml
index 61f8132..2479b90 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
 
     <groupId>net.lingala.zip4j</groupId>
     <artifactId>zip4j</artifactId>
-    <version>2.6.5-SNAPSHOT</version>
+    <version>2.6.5.1-SNAPSHOT</version>
 
     <name>Zip4j</name>
     <description>Zip4j - A Java library for zip files and streams</description>
@@ -81,6 +81,11 @@
             <version>${powermock.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <version>2.8.0</version>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index f992252..2d77f4a 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -23,19 +23,29 @@ import net.lingala.zip4j.headers.HeaderWriter;
 import net.lingala.zip4j.io.inputstream.NumberedSplitRandomAccessFile;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.UnzipParameters;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.RandomAccessFileMode;
 import net.lingala.zip4j.progress.ProgressMonitor;
-import net.lingala.zip4j.tasks.*;
+import net.lingala.zip4j.tasks.AddFilesToZipTask;
 import net.lingala.zip4j.tasks.AddFilesToZipTask.AddFilesToZipTaskParameters;
+import net.lingala.zip4j.tasks.AddFolderToZipTask;
 import net.lingala.zip4j.tasks.AddFolderToZipTask.AddFolderToZipTaskParameters;
+import net.lingala.zip4j.tasks.AddStreamToZipTask;
 import net.lingala.zip4j.tasks.AddStreamToZipTask.AddStreamToZipTaskParameters;
+import net.lingala.zip4j.tasks.AsyncZipTask;
+import net.lingala.zip4j.tasks.ExtractAllFilesTask;
 import net.lingala.zip4j.tasks.ExtractAllFilesTask.ExtractAllFilesTaskParameters;
+import net.lingala.zip4j.tasks.ExtractFileTask;
 import net.lingala.zip4j.tasks.ExtractFileTask.ExtractFileTaskParameters;
+import net.lingala.zip4j.tasks.MergeSplitZipFileTask;
 import net.lingala.zip4j.tasks.MergeSplitZipFileTask.MergeSplitZipFileTaskParameters;
+import net.lingala.zip4j.tasks.RemoveFilesFromZipTask;
 import net.lingala.zip4j.tasks.RemoveFilesFromZipTask.RemoveFilesFromZipTaskParameters;
+import net.lingala.zip4j.tasks.RenameFilesTask;
 import net.lingala.zip4j.tasks.RenameFilesTask.RenameFilesTaskParameters;
+import net.lingala.zip4j.tasks.SetCommentTask;
 import net.lingala.zip4j.tasks.SetCommentTask.SetCommentTaskTaskParameters;
 import net.lingala.zip4j.util.FileUtils;
 import net.lingala.zip4j.util.RawIO;
@@ -407,11 +417,22 @@ public class ZipFile {
    * If zip file does not exist or destination path is invalid then an
    * exception is thrown.
    *
-   * @param destinationPath
-   * @throws ZipException
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @throws ZipException when an issue occurs during extraction
    */
   public void extractAll(String destinationPath) throws ZipException {
+    extractAll(destinationPath, new UnzipParameters());
+  }
 
+  /**
+   * Extracts all entries in the zip file to the destination path considering the options defined in
+   * UnzipParameters
+   *
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @param unzipParameters parameters to be considered during extraction
+   * @throws ZipException when an issue occurs during extraction
+   */
+  public void extractAll(String destinationPath, UnzipParameters unzipParameters) throws ZipException {
     if (!isStringNotNullAndNotEmpty(destinationPath)) {
       throw new ZipException("output path is null or invalid");
     }
@@ -433,7 +454,7 @@ public class ZipFile {
       throw new ZipException("invalid operation - Zip4j is in busy state");
     }
 
-    new ExtractAllFilesTask(zipModel, password, buildAsyncParameters()).execute(
+    new ExtractAllFilesTask(zipModel, password, unzipParameters, buildAsyncParameters()).execute(
         new ExtractAllFilesTaskParameters(destinationPath, charset));
   }
 
@@ -443,47 +464,50 @@ public class ZipFile {
    * <br><br>
    * If fileHeader is a directory, this method extracts all files under this directory
    *
-   * @param fileHeader
-   * @param destinationPath
-   * @throws ZipException
+   * @param fileHeader file header corresponding to the entry which has to be extracted
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @throws ZipException when an issue occurs during extraction
    */
   public void extractFile(FileHeader fileHeader, String destinationPath) throws ZipException {
-    extractFile(fileHeader, destinationPath, null);
+    extractFile(fileHeader, destinationPath, null, new UnzipParameters());
   }
 
   /**
    * Extracts a specific file from the zip file to the destination path.
    * If destination path is invalid, then this method throws an exception.
    * <br><br>
-   * If newFileName is not null or empty, newly created file name will be replaced by
-   * the value in newFileName. If this value is null, then the file name will be the
-   * value in FileHeader.getFileName. If file being extract is a directory, the directory name
-   * will be replaced with the newFileName
+   * If fileHeader is a directory, this method extracts all files under this directory
+   *
+   * @param fileHeader file header corresponding to the entry which has to be extracted
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @param unzipParameters any parameters that have to be considered during extraction
+   * @throws ZipException when an issue occurs during extraction
+   */
+  public void extractFile(FileHeader fileHeader, String destinationPath, UnzipParameters unzipParameters)
+      throws ZipException {
+    extractFile(fileHeader, destinationPath, null, unzipParameters);
+  }
+
+  /**
+   * Extracts a specific file from the zip file to the destination path.
+   * This method first finds the necessary file header from the input file name.
+   * <br><br>
+   * File name is relative file name in the zip file. For example if a zip file contains
+   * a file "a.txt", then to extract this file, input file name has to be "a.txt". Another
+   * example is if there is a file "b.txt" in a folder "abc" in the zip file, then the
+   * input file name has to be abc/b.txt
    * <br><br>
    * If fileHeader is a directory, this method extracts all files under this directory.
+   * <br><br>
+   * Throws an exception of type {@link ZipException.Type#FILE_NOT_FOUND} if file header could not be found for the given file name.
+   * Throws an exception if the destination path is invalid.
    *
-   * @param fileHeader
-   * @param destinationPath
-   * @param newFileName
-   * @throws ZipException
+   * @param fileName name of the entry which has to be extracted
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @throws ZipException when an issue occurs during extraction
    */
-  public void extractFile(FileHeader fileHeader, String destinationPath, String newFileName) throws ZipException {
-    if (fileHeader == null) {
-      throw new ZipException("input file header is null, cannot extract file");
-    }
-
-    if (!isStringNotNullAndNotEmpty(destinationPath)) {
-      throw new ZipException("destination path is empty or null, cannot extract file");
-    }
-
-    if (progressMonitor.getState() == ProgressMonitor.State.BUSY) {
-      throw new ZipException("invalid operation - Zip4j is in busy state");
-    }
-
-    readZipInfo();
-
-    new ExtractFileTask(zipModel, password, buildAsyncParameters()).execute(
-        new ExtractFileTaskParameters(destinationPath, fileHeader, newFileName, charset));
+  public void extractFile(String fileName, String destinationPath) throws ZipException {
+    extractFile(fileName, destinationPath, null, new UnzipParameters());
   }
 
   /**
@@ -497,15 +521,19 @@ public class ZipFile {
    * <br><br>
    * If fileHeader is a directory, this method extracts all files under this directory.
    * <br><br>
+   * Any parameters that have to be considered during extraction can be passed in through unzipParameters
+   * <br/><br/>
    * Throws an exception of type {@link ZipException.Type#FILE_NOT_FOUND} if file header could not be found for the given file name.
    * Throws an exception if the destination path is invalid.
    *
-   * @param fileName
-   * @param destinationPath
-   * @throws ZipException
+   * @param fileName name of the entry which has to be extracted
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @param unzipParameters any parameters that have to be considered during extraction
+   * @throws ZipException when an issue occurs during extraction
    */
-  public void extractFile(String fileName, String destinationPath) throws ZipException {
-    extractFile(fileName, destinationPath, null);
+  public void extractFile(String fileName, String destinationPath, UnzipParameters unzipParameters)
+      throws ZipException {
+    extractFile(fileName, destinationPath, null, unzipParameters);
   }
 
   /**
@@ -527,12 +555,65 @@ public class ZipFile {
    * Throws an exception of type {@link ZipException.Type#FILE_NOT_FOUND} if file header could not be found for the given file name.
    * Throws an exception if the destination path is invalid.
    *
-   * @param fileName
-   * @param destinationPath
-   * @param newFileName
-   * @throws ZipException
+   * @param fileName name of the entry which has to be extracted
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @param newFileName if not null, this will be the name given to the file upon extraction
+   * @throws ZipException when an issue occurs during extraction
    */
   public void extractFile(String fileName, String destinationPath, String newFileName) throws ZipException {
+    extractFile(fileName, destinationPath, newFileName, new UnzipParameters());
+  }
+
+  /**
+   * Extracts a specific file from the zip file to the destination path.
+   * If destination path is invalid, then this method throws an exception.
+   * <br><br>
+   * If newFileName is not null or empty, newly created file name will be replaced by
+   * the value in newFileName. If this value is null, then the file name will be the
+   * value in FileHeader.getFileName. If file being extract is a directory, the directory name
+   * will be replaced with the newFileName
+   * <br><br>
+   * If fileHeader is a directory, this method extracts all files under this directory.
+   *
+   * @param fileHeader file header corresponding to the entry which has to be extracted
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @param newFileName if not null, this will be the name given to the file upon extraction
+   * @throws ZipException when an issue occurs during extraction
+   */
+  public void extractFile(FileHeader fileHeader, String destinationPath, String newFileName) throws ZipException {
+    extractFile(fileHeader, destinationPath, newFileName, new UnzipParameters());
+  }
+
+  /**
+   * Extracts a specific file from the zip file to the destination path.
+   * This method first finds the necessary file header from the input file name.
+   * <br/><br/>
+   * File name is relative file name in the zip file. For example if a zip file contains
+   * a file "a.txt", then to extract this file, input file name has to be "a.txt". Another
+   * example is if there is a file "b.txt" in a folder "abc" in the zip file, then the
+   * input file name has to be abc/b.txt
+   * <br/><br/>
+   * If newFileName is not null or empty, newly created file name will be replaced by
+   * the value in newFileName. If this value is null, then the file name will be the
+   * value in FileHeader.getFileName. If file being extract is a directory, the directory name
+   * will be replaced with the newFileName
+   * <br/><br/>
+   * If fileHeader is a directory, this method extracts all files under this directory.
+   * <br/><br/>
+   * Any parameters that have to be considered during extraction can be passed in through unzipParameters
+   * <br/><br/>
+   * Throws an exception of type {@link ZipException.Type#FILE_NOT_FOUND} if file header could not be found for the
+   * given file name.
+   * Throws an exception if the destination path is invalid.
+   *
+   * @param fileName name of the entry which has to be extracted
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @param newFileName if not null, this will be the name given to the file upon extraction
+   * @param unzipParameters any parameters that have to be considered during extraction
+   * @throws ZipException when an issue occurs during extraction
+   */
+  public void extractFile(String fileName, String destinationPath, String newFileName, UnzipParameters unzipParameters)
+      throws ZipException {
 
     if (!isStringNotNullAndNotEmpty(fileName)) {
       throw new ZipException("file to extract is null or empty, cannot extract file");
@@ -546,7 +627,50 @@ public class ZipFile {
       throw new ZipException("No file found with name " + fileName + " in zip file", ZipException.Type.FILE_NOT_FOUND);
     }
 
-    extractFile(fileHeader, destinationPath, newFileName);
+    extractFile(fileHeader, destinationPath, newFileName, unzipParameters);
+  }
+
+  /**
+   * Extracts a specific file from the zip file to the destination path.
+   * If destination path is invalid, then this method throws an exception.
+   * <br><br>
+   * If newFileName is not null or empty, newly created file name will be replaced by
+   * the value in newFileName. If this value is null, then the file name will be the
+   * value in FileHeader.getFileName. If file being extract is a directory, the directory name
+   * will be replaced with the newFileName
+   * <br><br>
+   * If fileHeader is a directory, this method extracts all files under this directory.
+   * <br/><br/>
+   * Any parameters that have to be considered during extraction can be passed in through unzipParameters
+   *
+   * @param fileHeader file header corresponding to the entry which has to be extracted
+   * @param destinationPath path to which the entries of the zip are to be extracted
+   * @param newFileName if not null, this will be the name given to the file upon extraction
+   * @param unzipParameters any parameters that have to be considered during extraction
+   * @throws ZipException when an issue occurs during extraction
+   */
+  public void extractFile(FileHeader fileHeader, String destinationPath, String newFileName,
+                          UnzipParameters unzipParameters) throws ZipException {
+    if (fileHeader == null) {
+      throw new ZipException("input file header is null, cannot extract file");
+    }
+
+    if (!isStringNotNullAndNotEmpty(destinationPath)) {
+      throw new ZipException("destination path is empty or null, cannot extract file");
+    }
+
+    if (progressMonitor.getState() == ProgressMonitor.State.BUSY) {
+      throw new ZipException("invalid operation - Zip4j is in busy state");
+    }
+
+    if (unzipParameters == null) {
+      unzipParameters = new UnzipParameters();
+    }
+
+    readZipInfo();
+
+    new ExtractFileTask(zipModel, password, unzipParameters, buildAsyncParameters()).execute(
+        new ExtractFileTaskParameters(destinationPath, fileHeader, newFileName, charset));
   }
 
   /**
diff --git a/src/main/java/net/lingala/zip4j/model/UnzipParameters.java b/src/main/java/net/lingala/zip4j/model/UnzipParameters.java
new file mode 100644
index 0000000..b5720e4
--- /dev/null
+++ b/src/main/java/net/lingala/zip4j/model/UnzipParameters.java
@@ -0,0 +1,14 @@
+package net.lingala.zip4j.model;
+
+public class UnzipParameters {
+
+  private boolean extractSymbolicLinks = true;
+
+  public boolean isExtractSymbolicLinks() {
+    return extractSymbolicLinks;
+  }
+
+  public void setExtractSymbolicLinks(boolean extractSymbolicLinks) {
+    this.extractSymbolicLinks = extractSymbolicLinks;
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
index 6d34d29..df3ac6f 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractExtractFileTask.java
@@ -4,6 +4,7 @@ import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.LocalFileHeader;
+import net.lingala.zip4j.model.UnzipParameters;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.util.BitUtils;
@@ -25,16 +26,24 @@ import static net.lingala.zip4j.util.InternalZipConstants.FILE_SEPARATOR;
 public abstract class AbstractExtractFileTask<T> extends AsyncZipTask<T> {
 
   private ZipModel zipModel;
+  private UnzipParameters unzipParameters;
   private byte[] buff = new byte[BUFF_SIZE];
 
-  public AbstractExtractFileTask(ZipModel zipModel, AsyncTaskParameters asyncTaskParameters) {
+  public AbstractExtractFileTask(ZipModel zipModel, UnzipParameters unzipParameters,
+                                 AsyncTaskParameters asyncTaskParameters) {
     super(asyncTaskParameters);
     this.zipModel = zipModel;
+    this.unzipParameters = unzipParameters;
   }
 
   protected void extractFile(ZipInputStream zipInputStream, FileHeader fileHeader, String outputPath,
                              String newFileName, ProgressMonitor progressMonitor) throws IOException {
 
+    boolean isSymbolicLink = isSymbolicLink(fileHeader);
+    if (isSymbolicLink && !unzipParameters.isExtractSymbolicLinks()) {
+      return;
+    }
+
     if (!outputPath.endsWith(FILE_SEPARATOR)) {
       outputPath += FILE_SEPARATOR;
     }
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
index 4c3b6b7..f0eef95 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractAllFilesTask.java
@@ -3,6 +3,7 @@ package net.lingala.zip4j.tasks;
 import net.lingala.zip4j.io.inputstream.SplitInputStream;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.UnzipParameters;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.ExtractAllFilesTask.ExtractAllFilesTaskParameters;
@@ -18,8 +19,9 @@ public class ExtractAllFilesTask extends AbstractExtractFileTask<ExtractAllFiles
   private char[] password;
   private SplitInputStream splitInputStream;
 
-  public ExtractAllFilesTask(ZipModel zipModel, char[] password, AsyncTaskParameters asyncTaskParameters) {
-    super(zipModel, asyncTaskParameters);
+  public ExtractAllFilesTask(ZipModel zipModel, char[] password, UnzipParameters unzipParameters,
+                             AsyncTaskParameters asyncTaskParameters) {
+    super(zipModel, unzipParameters, asyncTaskParameters);
     this.password = password;
   }
 
diff --git a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
index 99b12ca..da25a17 100644
--- a/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/ExtractFileTask.java
@@ -3,6 +3,7 @@ package net.lingala.zip4j.tasks;
 import net.lingala.zip4j.io.inputstream.SplitInputStream;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.UnzipParameters;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.ExtractFileTask.ExtractFileTaskParameters;
@@ -23,8 +24,9 @@ public class ExtractFileTask extends AbstractExtractFileTask<ExtractFileTaskPara
   private char[] password;
   private SplitInputStream splitInputStream;
 
-  public ExtractFileTask(ZipModel zipModel, char[] password, AsyncTaskParameters asyncTaskParameters) {
-    super(zipModel, asyncTaskParameters);
+  public ExtractFileTask(ZipModel zipModel, char[] password, UnzipParameters unzipParameters,
+                         AsyncTaskParameters asyncTaskParameters) {
+    super(zipModel, unzipParameters, asyncTaskParameters);
     this.password = password;
   }
 
diff --git a/src/main/java/net/lingala/zip4j/util/FileUtils.java b/src/main/java/net/lingala/zip4j/util/FileUtils.java
index 8f081ae..d6bfe11 100644
--- a/src/main/java/net/lingala/zip4j/util/FileUtils.java
+++ b/src/main/java/net/lingala/zip4j/util/FileUtils.java
@@ -262,6 +262,12 @@ public class FileUtils {
       fileName = rootFolderNameInZip + fileName;
     }
 
+    if (!isStringNotNullAndNotEmpty(fileName)) {
+      throw new ZipException("fileName to add to zip is empty or null. fileName: '" + fileName
+          + "'. DefaultFolderPath: '" + zipParameters.getDefaultFolderPath() + "'. "
+          + "isSymlink: " + isSymbolicLink(fileToAdd));
+    }
+
     return fileName;
   }
 
diff --git a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
index b116c74..f565b1a 100644
--- a/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/CreateZipFileIT.java
@@ -27,6 +27,7 @@ import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.List;
 
+import static net.lingala.zip4j.testutils.TestUtils.createSymlink;
 import static net.lingala.zip4j.testutils.TestUtils.getTestFileFromResources;
 import static net.lingala.zip4j.testutils.ZipFileVerifier.verifyZipFileByExtractingAllFiles;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -602,12 +603,6 @@ public class CreateZipFileIT extends AbstractIT {
     assertThat(generatedTarget).isEqualTo(targetFile);
   }
 
-  private File createSymlink(File targetFile, File rootFolder) throws IOException {
-    Path link = Paths.get(rootFolder.getAbsolutePath(), "symlink.link");
-    Files.createSymbolicLink(link, targetFile.toPath());
-    return link.toFile();
-  }
-
   private File createTestFolderWithSymlinks() throws IOException {
     Path testFolder = temporaryFolder.newFolder("test-folder").toPath();
     Path subFolder1 = Files.createDirectory(Paths.get(testFolder.toString(), "sub-folder1"));
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index d3b08bb..094aa0e 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -3,6 +3,7 @@ package net.lingala.zip4j;
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.io.inputstream.ZipInputStream;
 import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.UnzipParameters;
 import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.AesKeyStrength;
 import net.lingala.zip4j.model.enums.CompressionMethod;
@@ -134,6 +135,25 @@ public class ExtractZipFileIT extends AbstractIT {
     verifyNumberOfFilesInOutputFolder(outputFolder, 3);
   }
 
+  @Test
+  public void testExtractAllSkipsSymlinksWhenSymlinkExtractionSetToFalse() throws IOException {
+    ZipFile zipFile = createZipFileWithASymlink(createSymlink());
+
+    zipFile.extractAll(outputFolder.getPath(), buildUnzipParameters(false));
+
+    ZipFileVerifier.verifyFolderContentsSameAsSourceFiles(outputFolder);
+    verifyNumberOfFilesInOutputFolder(outputFolder, 4);
+  }
+
+  @Test
+  public void testExtractAllExtractsSymlinksWhenSymlinkExtractionSetToTrue() throws IOException {
+    ZipFile zipFile = createZipFileWithASymlink(createSymlink());
+
+    zipFile.extractAll(outputFolder.getPath(), buildUnzipParameters(true));
+
+    verifyNumberOfFilesInOutputFolder(outputFolder, 5);
+  }
+
   @Test
   public void testExtractFileWithFileHeaderWithAes128() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_128);
@@ -175,6 +195,55 @@ public class ExtractZipFileIT extends AbstractIT {
     ZipFileVerifier.verifyFileContent(getTestFileFromResources("sample_text_large.txt"), outputFile);
   }
 
+  @Test
+  public void testExtractFileWithFileHeaderDoesNotExtractSymlinkWhenSymlinkExtractionIsNotSet() throws IOException {
+    File symlink = createSymlink();
+    ZipFile zipFile = createZipFileWithASymlink(symlink);
+
+    FileHeader fileHeader = zipFile.getFileHeader(symlink.getName());
+    zipFile.extractFile(fileHeader, outputFolder.getPath(), buildUnzipParameters(false));
+
+    assertThat(outputFolder.listFiles()).isNull();
+  }
+
+  @Test
+  public void testExtractFileWithFileHeaderExtractsSymlinkWhenSymlinkExtractionIsSet() throws IOException {
+    File symlink = createSymlink();
+    ZipFile zipFile = createZipFileWithASymlink(symlink);
+
+    FileHeader fileHeader = zipFile.getFileHeader(symlink.getName());
+    zipFile.extractFile(fileHeader, outputFolder.getPath(), buildUnzipParameters(true));
+
+    verifyNumberOfFilesInOutputFolder(outputFolder, 1);
+    assertThat(outputFolder.listFiles()[0].getName()).isEqualTo(symlink.getName());
+  }
+
+  @Test
+  public void testExtractFileWithFileHeaderAndNewFileDoesNotExtractSymlinkWhenSymlinkExtractionIsNotSet()
+      throws IOException {
+    File symlink = createSymlink();
+    ZipFile zipFile = createZipFileWithASymlink(symlink);
+
+    FileHeader fileHeader = zipFile.getFileHeader(symlink.getName());
+    zipFile.extractFile(fileHeader, outputFolder.getPath(), "newFileName", buildUnzipParameters(false));
+
+    assertThat(outputFolder.listFiles()).isNull();
+  }
+
+  @Test
+  public void testExtractFileWithFileHeaderAndNewFileNameExtractsSymlinkWhenSymlinkExtractionIsSet()
+      throws IOException {
+    File symlink = createSymlink();
+    ZipFile zipFile = createZipFileWithASymlink(symlink);
+
+    FileHeader fileHeader = zipFile.getFileHeader(symlink.getName());
+    String newFileName = "newName.link";
+    zipFile.extractFile(fileHeader, outputFolder.getPath(), newFileName, buildUnzipParameters(true));
+
+    verifyNumberOfFilesInOutputFolder(outputFolder, 1);
+    assertThat(outputFolder.listFiles()[0].getName()).isEqualTo(newFileName);
+  }
+
   @Test
   public void testExtractFileWithFileNameThrowsExceptionWhenFileNotFound() throws ZipException {
     ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
@@ -216,6 +285,50 @@ public class ExtractZipFileIT extends AbstractIT {
     ZipFileVerifier.verifyFileContent(getTestFileFromResources("sample_directory/favicon.ico"), outputFile);
   }
 
+  @Test
+  public void testExtractFileWithFileNameDoesNotExtractSymlinkWhenSymlinkExtractionIsNotSet() throws IOException {
+    File symlink = createSymlink();
+    ZipFile zipFile = createZipFileWithASymlink(symlink);
+
+    zipFile.extractFile(symlink.getName(), outputFolder.getPath(), buildUnzipParameters(false));
+
+    assertThat(outputFolder.listFiles()).isNull();
+  }
+
+  @Test
+  public void testExtractFileWithFileNameExtractsSymlinkWhenSymlinkExtractionIsSet() throws IOException {
+    File symlink = createSymlink();
+    ZipFile zipFile = createZipFileWithASymlink(symlink);
+
+    zipFile.extractFile(symlink.getName(), outputFolder.getPath(), buildUnzipParameters(true));
+
+    verifyNumberOfFilesInOutputFolder(outputFolder, 1);
+    assertThat(outputFolder.listFiles()[0].getName()).isEqualTo(symlink.getName());
+  }
+
+  @Test
+  public void testExtractFileWithFileNameAndNewFileNameDoesNotExtractSymlinkWhenSymlinkExtractionIsNotSet()
+      throws IOException {
+    File symlink = createSymlink();
+    ZipFile zipFile = createZipFileWithASymlink(symlink);
+
+    zipFile.extractFile(symlink.getName(), outputFolder.getPath(), "newFileName", buildUnzipParameters(false));
+
+    assertThat(outputFolder.listFiles()).isNull();
+  }
+
+  @Test
+  public void testExtractFileWithFileNameAndNewFileNameExtractsSymlinkWhenSymlinkExtractionIsSet() throws IOException {
+    File symlink = createSymlink();
+    ZipFile zipFile = createZipFileWithASymlink(symlink);
+
+    String newFileName = "newName.link";
+    zipFile.extractFile(symlink.getName(), outputFolder.getPath(), newFileName, buildUnzipParameters(true));
+
+    verifyNumberOfFilesInOutputFolder(outputFolder, 1);
+    assertThat(outputFolder.listFiles()[0].getName()).isEqualTo(newFileName);
+  }
+
   @Test
   public void testExtractFilesThrowsExceptionForWrongPasswordForAes() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
@@ -586,4 +699,24 @@ public class ExtractZipFileIT extends AbstractIT {
     ZipFile zipFile = new ZipFile(fileToExtract);
     zipFile.extractAll(outputFolder.getPath());
   }
+
+  private ZipFile createZipFileWithASymlink(File symlink) throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setSymbolicLinkAction(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE);
+    zipFile.addFiles(FILES_TO_ADD, zipParameters);
+    zipFile.addFile(symlink, zipParameters);
+    return zipFile;
+  }
+
+  private UnzipParameters buildUnzipParameters(boolean extractSymlinks) {
+    UnzipParameters unzipParameters = new UnzipParameters();
+    unzipParameters.setExtractSymbolicLinks(extractSymlinks);
+    return unzipParameters;
+  }
+
+  private File createSymlink() throws IOException {
+    File targetFile = getTestFileFromResources("file_PDF_1MB.pdf");
+    return TestUtils.createSymlink(targetFile, temporaryFolder.getRoot());
+  }
 }
diff --git a/src/test/java/net/lingala/zip4j/testutils/TestUtils.java b/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
index eb920a0..4b45c05 100644
--- a/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
+++ b/src/test/java/net/lingala/zip4j/testutils/TestUtils.java
@@ -15,6 +15,7 @@ import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.List;
 import java.util.Random;
@@ -131,6 +132,12 @@ public class TestUtils {
     return outputFile;
   }
 
+  public static File createSymlink(File targetFile, File rootFolder) throws IOException {
+    Path link = Paths.get(rootFolder.getAbsolutePath(), "symlink.link");
+    Files.createSymbolicLink(link, targetFile.toPath());
+    return link.toFile();
+  }
+
   private static OutputStream startNext7ZipSplitStream(File sourceFile, File outputFolder, int index) throws IOException {
     File outputFile = getFileNameFor7ZipSplitIndex(sourceFile, outputFolder, index);
     return new FileOutputStream(outputFile);
