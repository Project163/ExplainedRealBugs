diff --git a/pom.xml b/pom.xml
index 25adbaf..96f0e13 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
 
     <groupId>net.lingala.zip4j</groupId>
     <artifactId>zip4j</artifactId>
-    <version>2.2.3.4-SNAPSHOT</version>
+    <version>2.2.3.5-SNAPSHOT</version>
 
     <name>Zip4j</name>
     <description>Zip4j - A Java library for zip files and streams</description>
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
index 9335165..870bd13 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/CipherInputStream.java
@@ -64,7 +64,7 @@ abstract class CipherInputStream<T extends Decrypter> extends InputStream {
   }
 
   protected int readRaw(byte[] b) throws IOException {
-    return zipEntryInputStream.readHeaders(b);
+    return zipEntryInputStream.readRawFully(b);
   }
 
   private void cacheRawData(byte[] b, int len) {
diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/ZipEntryInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/ZipEntryInputStream.java
index ac3015f..9d92593 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/ZipEntryInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/ZipEntryInputStream.java
@@ -5,6 +5,8 @@ import java.io.InputStream;
 
 class ZipEntryInputStream extends InputStream {
 
+  private static final int MAX_RAW_READ_FULLY_RETRY_ATTEMPTS = 15;
+
   private InputStream inputStream;
   private long numberOfBytesRead = 0;
   private byte[] singleByteArray = new byte[1];
@@ -52,8 +54,38 @@ class ZipEntryInputStream extends InputStream {
     return readLen;
   }
 
-  public int readHeaders(byte[] b) throws  IOException {
-    return inputStream.read(b);
+  public int readRawFully(byte[] b) throws  IOException {
+
+    int readLen = inputStream.read(b);
+
+    if (readLen != b.length) {
+      readLen = readUntilBufferIsFull(b, readLen);
+
+      if (readLen != b.length) {
+        throw new IOException("Cannot read fully into byte buffer");
+      }
+    }
+
+    return readLen;
+  }
+
+  private int readUntilBufferIsFull(byte[] b, int readLength) throws IOException {
+    int remainingLength = b.length - readLength;
+    int loopReadLength = 0;
+    int retryAttempt = 0;
+
+    while (readLength < b.length && loopReadLength != -1 && retryAttempt < MAX_RAW_READ_FULLY_RETRY_ATTEMPTS) {
+      loopReadLength += inputStream.read(b, readLength, remainingLength);
+
+      if (loopReadLength > 0) {
+        readLength += loopReadLength;
+        remainingLength -= loopReadLength;
+      }
+
+      retryAttempt++;
+    }
+
+    return readLength;
   }
 
   @Override
