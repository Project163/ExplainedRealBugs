diff --git a/README.md b/README.md
index 29865e7..91264fc 100644
--- a/README.md
+++ b/README.md
@@ -244,6 +244,9 @@ the zip, then you can use `zipFile.getFileHeader("root_folder/entry_name_in_zip.
 new ZipFile("filename.zip").removeFile("fileNameInZipToRemove");
 ~~~~
 
+If `fileNameInZipToRemove` represents a folder. All the files and folders under this folder will be removed as well
+(this is valid since v2.5.0 of zip4j. All prior versions remove just the single entry even if it is a folder). 
+
 Please note that the file name is relative the root folder in zip. That is, if the file you want to remove exists in a 
 folder called "folder1", which in-turn exists in a folder called "root-folder", removing this file from zip can be done 
 as below:
@@ -266,6 +269,20 @@ if (fileHeader == null) {
 zipFile.removeFile(fileHeader);
 ~~~~
 
+Since v2.5.0 of zip4j, it is possible to remove multiple files and folders from a zip file. You can now pass in a list
+as shown in the code below:
+
+~~~~
+ZipFile zipFile = new ZipFile("someZip.zip");
+List<String> filesToRemove = Arrays.asList("file1.txt", "file2.txt", "some-folder/", "some-new-folder-1/somefile.pdf");
+
+zipFile.removeFiles(filesToRemove);
+~~~~
+
+The above code will remove `file1.txt`, `file2.txt`, all files and folders under `some-folder` (including `some-folder`)
+and just the entry `somefile.pdf` in folder `some-new-folder-1`. All other files and folders are kept intact in the zip
+file.
+
 ### Rename entries in the zip file
 
 There are three ways to rename an entry in a zip file with zip4j. One way is to pass in a file header and the new file 
diff --git a/src/main/java/net/lingala/zip4j/ZipFile.java b/src/main/java/net/lingala/zip4j/ZipFile.java
index 2815193..faf3363 100755
--- a/src/main/java/net/lingala/zip4j/ZipFile.java
+++ b/src/main/java/net/lingala/zip4j/ZipFile.java
@@ -40,10 +40,10 @@ import net.lingala.zip4j.tasks.ExtractFileTask;
 import net.lingala.zip4j.tasks.ExtractFileTask.ExtractFileTaskParameters;
 import net.lingala.zip4j.tasks.MergeSplitZipFileTask;
 import net.lingala.zip4j.tasks.MergeSplitZipFileTask.MergeSplitZipFileTaskParameters;
-import net.lingala.zip4j.tasks.RemoveEntryFromZipFileTask;
-import net.lingala.zip4j.tasks.RemoveEntryFromZipFileTask.RemoveEntryFromZipFileTaskParameters;
-import net.lingala.zip4j.tasks.RenameFileTask;
-import net.lingala.zip4j.tasks.RenameFileTask.RenameFileTaskParameters;
+import net.lingala.zip4j.tasks.RemoveFilesFromZipTask;
+import net.lingala.zip4j.tasks.RemoveFilesFromZipTask.RemoveFilesFromZipTaskParameters;
+import net.lingala.zip4j.tasks.RenameFilesTask;
+import net.lingala.zip4j.tasks.RenameFilesTask.RenameFilesTaskParameters;
 import net.lingala.zip4j.tasks.SetCommentTask;
 import net.lingala.zip4j.tasks.SetCommentTask.SetCommentTaskTaskParameters;
 import net.lingala.zip4j.util.FileUtils;
@@ -635,49 +635,68 @@ public class ZipFile {
     return zipModel.isSplitArchive();
   }
 
+  /**
+   * Removes the file provided in the input file header from the zip file.
+   *
+   * If zip file is a split zip file, then this method throws an exception as
+   * zip specification does not allow for updating split zip archives.
+   *
+   * If this file header is a directory, all files and directories
+   * under this directory will be removed as well.
+   *
+   * @param fileHeader
+   * @throws ZipException
+   */
+  public void removeFile(FileHeader fileHeader) throws ZipException {
+    if (fileHeader == null) {
+      throw new ZipException("input file header is null, cannot remove file");
+    }
+
+    removeFile(fileHeader.getFileName());
+  }
+
   /**
    * Removes the file provided in the input parameters from the zip file.
    * This method first finds the file header and then removes the file.
+   *
    * If file does not exist, then this method throws an exception.
+   *
    * If zip file is a split zip file, then this method throws an exception as
    * zip specification does not allow for updating split zip archives.
    *
+   * If the entry representing this file name is a directory, all files and directories
+   * under this directory will be removed as well.
+   *
    * @param fileName
    * @throws ZipException
    */
   public void removeFile(String fileName) throws ZipException {
-
     if (!isStringNotNullAndNotEmpty(fileName)) {
       throw new ZipException("file name is empty or null, cannot remove file");
     }
 
-    if (zipModel == null) {
-      readZipInfo();
-    }
-
-    if (zipModel.isSplitArchive()) {
-      throw new ZipException("Zip file format does not allow updating split/spanned files");
-    }
-
-    FileHeader fileHeader = HeaderUtil.getFileHeader(zipModel, fileName);
-    if (fileHeader == null) {
-      throw new ZipException("could not find file header for file: " + fileName);
-    }
-
-    removeFile(fileHeader);
+    removeFiles(Collections.singletonList(fileName));
   }
 
   /**
-   * Removes the file provided in the input file header from the zip file.
+   * Removes all files from the zip file that match the names in the input list.
+   *
+   * If any of the file is a directory, all the files and directories under this directory
+   * will be removed as well
+   *
    * If zip file is a split zip file, then this method throws an exception as
    * zip specification does not allow for updating split zip archives.
    *
-   * @param fileHeader
+   * @param fileNames
    * @throws ZipException
    */
-  public void removeFile(FileHeader fileHeader) throws ZipException {
-    if (fileHeader == null) {
-      throw new ZipException("input file header is null, cannot remove file");
+  public void removeFiles(List<String> fileNames) throws ZipException {
+    if (fileNames == null) {
+      throw new ZipException("fileNames list is null");
+    }
+
+    if (fileNames.isEmpty()) {
+      return;
     }
 
     if (zipModel == null) {
@@ -688,8 +707,8 @@ public class ZipFile {
       throw new ZipException("Zip file format does not allow updating split/spanned files");
     }
 
-    new RemoveEntryFromZipFileTask(zipModel, buildAsyncParameters()).execute(
-            new RemoveEntryFromZipFileTaskParameters(fileHeader, charset));
+    new RemoveFilesFromZipTask(zipModel, headerWriter, buildAsyncParameters()).execute(
+        new RemoveFilesFromZipTaskParameters(fileNames, charset));
   }
 
   /**
@@ -770,8 +789,8 @@ public class ZipFile {
     }
 
     AsyncZipTask.AsyncTaskParameters asyncTaskParameters = buildAsyncParameters();
-    new RenameFileTask(zipModel, headerWriter, new RawIO(), charset, asyncTaskParameters).execute(
-        new RenameFileTaskParameters(fileNamesMap));
+    new RenameFilesTask(zipModel, headerWriter, new RawIO(), charset, asyncTaskParameters).execute(
+        new RenameFilesTaskParameters(fileNamesMap));
   }
 
   /**
diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
index c5523a1..e68329f 100644
--- a/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderUtil.java
@@ -79,6 +79,10 @@ public class HeaderUtil {
     }
   }
 
+  public static int getLocalFileHeaderSize(FileHeader fileHeader) {
+    return 30 + fileHeader.getFileNameLength() + fileHeader.getExtraFieldLength(); // 30 = all fixed lengths in local file header
+  }
+
   private static FileHeader getFileHeaderWithExactMatch(ZipModel zipModel, String fileName) throws ZipException {
     if (zipModel == null) {
       throw new ZipException("zip model is null, cannot determine file header with exact match for fileName: "
diff --git a/src/main/java/net/lingala/zip4j/model/AbstractFileHeader.java b/src/main/java/net/lingala/zip4j/model/AbstractFileHeader.java
index 0be1d36..12b988f 100644
--- a/src/main/java/net/lingala/zip4j/model/AbstractFileHeader.java
+++ b/src/main/java/net/lingala/zip4j/model/AbstractFileHeader.java
@@ -178,4 +178,17 @@ public abstract class AbstractFileHeader extends ZipHeader {
   public void setDirectory(boolean directory) {
     isDirectory = directory;
   }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == null) {
+      return false;
+    }
+
+    if (!(obj instanceof AbstractFileHeader)) {
+      return false;
+    }
+
+    return this.getFileName().equals(((AbstractFileHeader) obj).getFileName());
+  }
 }
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
index 9b4f5d5..85303e2 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractAddFileToZipTask.java
@@ -10,7 +10,7 @@ import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.model.enums.EncryptionMethod;
 import net.lingala.zip4j.progress.ProgressMonitor;
-import net.lingala.zip4j.tasks.RemoveEntryFromZipFileTask.RemoveEntryFromZipFileTaskParameters;
+import net.lingala.zip4j.tasks.RemoveFilesFromZipTask.RemoveFilesFromZipTaskParameters;
 import net.lingala.zip4j.util.BitUtils;
 import net.lingala.zip4j.util.FileUtils;
 import net.lingala.zip4j.util.InternalZipConstants;
@@ -22,6 +22,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import static net.lingala.zip4j.headers.HeaderUtil.getFileHeader;
@@ -261,10 +262,10 @@ public abstract class AbstractAddFileToZipTask<T> extends AsyncZipTask<T> {
     return filesToAdd;
   }
 
-  private void removeFile(FileHeader fileHeader, ProgressMonitor progressMonitor, Charset charset) throws ZipException {
+  void removeFile(FileHeader fileHeader, ProgressMonitor progressMonitor, Charset charset) throws ZipException {
     AsyncTaskParameters asyncTaskParameters = new AsyncTaskParameters(null, false, progressMonitor);
-    RemoveEntryFromZipFileTask removeEntryFromZipFileTask = new RemoveEntryFromZipFileTask(zipModel, asyncTaskParameters);
-    removeEntryFromZipFileTask.execute(new RemoveEntryFromZipFileTaskParameters(fileHeader, charset));
+    RemoveFilesFromZipTask removeFilesFromZipTask = new RemoveFilesFromZipTask(zipModel, headerWriter, asyncTaskParameters);
+    removeFilesFromZipTask.execute(new RemoveFilesFromZipTaskParameters(Collections.singletonList(fileHeader.getFileName()), charset));
   }
 
   private String replaceFileNameInZip(String fileInZipWithPath, String newFileName) {
diff --git a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
index 03c0884..7b6b76c 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AbstractModifyFileTask.java
@@ -1,6 +1,7 @@
 package net.lingala.zip4j.tasks;
 
 import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.headers.HeaderUtil;
 import net.lingala.zip4j.model.FileHeader;
 import net.lingala.zip4j.model.ZipModel;
 import net.lingala.zip4j.progress.ProgressMonitor;
@@ -10,6 +11,7 @@ import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.RandomAccessFile;
+import java.util.List;
 import java.util.Random;
 
 abstract class AbstractModifyFileTask<T> extends AsyncZipTask<T> {
@@ -29,32 +31,37 @@ abstract class AbstractModifyFileTask<T> extends AsyncZipTask<T> {
     return tmpFile;
   }
 
-  long getOffsetLocalFileHeader(FileHeader fileHeader) {
-    long offsetLocalFileHeader = fileHeader.getOffsetLocalHeader();
+  void updateOffsetsForAllSubsequentFileHeaders(ZipModel zipModel, FileHeader fileHeaderModified, long offsetToAdd) throws ZipException {
+    int indexOfFileHeader = HeaderUtil.getIndexOfFileHeader(zipModel, fileHeaderModified);
 
-    if (fileHeader.getZip64ExtendedInfo() != null && fileHeader.getZip64ExtendedInfo().getOffsetLocalHeader() != -1) {
-      offsetLocalFileHeader = fileHeader.getZip64ExtendedInfo().getOffsetLocalHeader();
+    if (indexOfFileHeader == -1) {
+      throw new ZipException("Could not locate modified file header in zipModel");
     }
 
-    return offsetLocalFileHeader;
-  }
+    List<FileHeader> allFileHeaders = zipModel.getCentralDirectory().getFileHeaders();
 
-  long getOffsetOfStartOfCentralDirectory(ZipModel zipModel) {
-    long offsetStartCentralDir = zipModel.getEndOfCentralDirectoryRecord().getOffsetOfStartOfCentralDirectory();
+    for (int i = indexOfFileHeader + 1; i < allFileHeaders.size(); i++) {
+      FileHeader fileHeaderToUpdate = allFileHeaders.get(i);
+      fileHeaderToUpdate.setOffsetLocalHeader(fileHeaderToUpdate.getOffsetLocalHeader() + offsetToAdd);
 
-    if (zipModel.isZip64Format() && zipModel.getZip64EndOfCentralDirectoryRecord() != null) {
-      offsetStartCentralDir = zipModel.getZip64EndOfCentralDirectoryRecord()
-          .getOffsetStartCentralDirectoryWRTStartDiskNumber();
-    }
+      if (zipModel.isZip64Format()
+          && fileHeaderToUpdate.getZip64ExtendedInfo() != null
+          && fileHeaderToUpdate.getZip64ExtendedInfo().getOffsetLocalHeader() != -1) {
 
-    return offsetStartCentralDir;
+        fileHeaderToUpdate.getZip64ExtendedInfo().setOffsetLocalHeader(
+            fileHeaderModified.getZip64ExtendedInfo().getOffsetLocalHeader() + offsetToAdd
+        );
+      }
+    }
   }
 
   void cleanupFile(boolean successFlag, File zipFile, File temporaryZipFile) throws ZipException {
     if (successFlag) {
       restoreFileName(zipFile, temporaryZipFile);
     } else {
-      temporaryZipFile.delete();
+      if (!temporaryZipFile.delete()) {
+        throw new ZipException("Could not delete temporary file");
+      }
     }
   }
 
diff --git a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
index e32bd84..c25e4bb 100644
--- a/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/AddStreamToZipTask.java
@@ -11,7 +11,6 @@ import net.lingala.zip4j.model.ZipParameters;
 import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.progress.ProgressMonitor;
 import net.lingala.zip4j.tasks.AddStreamToZipTask.AddStreamToZipTaskParameters;
-import net.lingala.zip4j.tasks.RemoveEntryFromZipFileTask.RemoveEntryFromZipFileTaskParameters;
 import net.lingala.zip4j.util.Zip4jUtil;
 
 import java.io.IOException;
@@ -83,9 +82,7 @@ public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipT
 
     FileHeader fileHeader = HeaderUtil.getFileHeader(zipModel, fileNameInZip);
     if (fileHeader  != null) {
-      AsyncTaskParameters asyncTaskParameters = new AsyncTaskParameters(null, false, progressMonitor);
-      RemoveEntryFromZipFileTask removeEntryFromZipFileTask = new RemoveEntryFromZipFileTask(zipModel, asyncTaskParameters);
-      removeEntryFromZipFileTask.execute(new RemoveEntryFromZipFileTaskParameters(fileHeader, charset));
+      removeFile(fileHeader, progressMonitor, charset);
     }
   }
 
diff --git a/src/main/java/net/lingala/zip4j/tasks/RemoveEntryFromZipFileTask.java b/src/main/java/net/lingala/zip4j/tasks/RemoveEntryFromZipFileTask.java
deleted file mode 100644
index 0f7a615..0000000
--- a/src/main/java/net/lingala/zip4j/tasks/RemoveEntryFromZipFileTask.java
+++ /dev/null
@@ -1,199 +0,0 @@
-package net.lingala.zip4j.tasks;
-
-import net.lingala.zip4j.exception.ZipException;
-import net.lingala.zip4j.headers.HeaderWriter;
-import net.lingala.zip4j.io.outputstream.SplitOutputStream;
-import net.lingala.zip4j.model.EndOfCentralDirectoryRecord;
-import net.lingala.zip4j.model.FileHeader;
-import net.lingala.zip4j.model.ZipModel;
-import net.lingala.zip4j.model.enums.RandomAccessFileMode;
-import net.lingala.zip4j.progress.ProgressMonitor;
-import net.lingala.zip4j.tasks.RemoveEntryFromZipFileTask.RemoveEntryFromZipFileTaskParameters;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.nio.charset.Charset;
-import java.util.List;
-import java.util.Random;
-
-import static net.lingala.zip4j.headers.HeaderUtil.getIndexOfFileHeader;
-import static net.lingala.zip4j.util.FileUtils.copyFile;
-
-public class RemoveEntryFromZipFileTask extends AsyncZipTask<RemoveEntryFromZipFileTaskParameters>  {
-
-  private ZipModel zipModel;
-
-  public RemoveEntryFromZipFileTask(ZipModel zipModel, AsyncTaskParameters asyncTaskParameters) {
-    super(asyncTaskParameters);
-    this.zipModel = zipModel;
-  }
-
-  @Override
-  protected void executeTask(RemoveEntryFromZipFileTaskParameters taskParameters, ProgressMonitor progressMonitor)
-      throws IOException {
-    if (zipModel.isSplitArchive()) {
-      throw new ZipException("This is a split archive. Zip file format does not allow updating split/spanned files");
-    }
-
-    File temporaryZipFile = getTemporaryFile(zipModel.getZipFile().getPath());
-    boolean successFlag = false;
-
-    try (SplitOutputStream outputStream = new SplitOutputStream(temporaryZipFile);
-         RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(),
-             RandomAccessFileMode.READ.getValue())){
-
-      int indexOfFileHeader = getIndexOfFileHeader(zipModel, taskParameters.fileHeader);
-      long offsetLocalFileHeader = getOffsetLocalFileHeader(taskParameters.fileHeader);
-      long offsetStartOfCentralDirectory = getOffsetOfStartOfCentralDirectory(zipModel);
-      List<FileHeader> fileHeaders = zipModel.getCentralDirectory().getFileHeaders();
-      long offsetEndOfCompressedData = getOffsetEndOfCompressedData(indexOfFileHeader,
-          offsetStartOfCentralDirectory, fileHeaders);
-
-      if (indexOfFileHeader == 0) {
-        if (zipModel.getCentralDirectory().getFileHeaders().size() > 1) {
-          // if this is the only file and it is deleted then no need to do this
-          copyFile(inputStream, outputStream, offsetEndOfCompressedData + 1,
-              offsetStartOfCentralDirectory, progressMonitor);
-        }
-      } else if (indexOfFileHeader == fileHeaders.size() - 1) {
-        copyFile(inputStream, outputStream, 0, offsetLocalFileHeader, progressMonitor);
-      } else {
-        copyFile(inputStream, outputStream, 0, offsetLocalFileHeader, progressMonitor);
-        copyFile(inputStream, outputStream, offsetEndOfCompressedData + 1,
-            offsetStartOfCentralDirectory, progressMonitor);
-      }
-
-      verifyIfTaskIsCancelled();
-
-      updateHeaders(zipModel, outputStream, indexOfFileHeader, offsetEndOfCompressedData, offsetLocalFileHeader, taskParameters.charset);
-      successFlag = true;
-    } finally {
-      cleanupFile(successFlag, zipModel.getZipFile(), temporaryZipFile);
-    }
-  }
-
-  private long getOffsetOfStartOfCentralDirectory(ZipModel zipModel) {
-    long offsetStartCentralDir = zipModel.getEndOfCentralDirectoryRecord().getOffsetOfStartOfCentralDirectory();
-
-    if (zipModel.isZip64Format() && zipModel.getZip64EndOfCentralDirectoryRecord() != null) {
-      offsetStartCentralDir = zipModel.getZip64EndOfCentralDirectoryRecord()
-          .getOffsetStartCentralDirectoryWRTStartDiskNumber();
-    }
-
-    return offsetStartCentralDir;
-  }
-
-  private long getOffsetEndOfCompressedData(int indexOfFileHeader, long offsetStartOfCentralDirectory,
-                                            List<FileHeader> fileHeaders) {
-    if (indexOfFileHeader == fileHeaders.size() - 1) {
-      return offsetStartOfCentralDirectory - 1;
-    }
-
-    FileHeader nextFileHeader = fileHeaders.get(indexOfFileHeader + 1);
-    long offsetEndOfCompressedFile = nextFileHeader.getOffsetLocalHeader() - 1;
-    if (nextFileHeader.getZip64ExtendedInfo() != null
-        && nextFileHeader.getZip64ExtendedInfo().getOffsetLocalHeader() != -1) {
-      offsetEndOfCompressedFile = nextFileHeader.getZip64ExtendedInfo().getOffsetLocalHeader() - 1;
-    }
-
-    return offsetEndOfCompressedFile;
-  }
-
-  private File getTemporaryFile(String zipPathWithName) {
-    Random random = new Random();
-    File tmpFile = new File(zipPathWithName + random.nextInt(10000));
-
-    while (tmpFile.exists()) {
-      tmpFile = new File(zipPathWithName + random.nextInt(10000));
-    }
-
-    return tmpFile;
-  }
-
-  private long getOffsetLocalFileHeader(FileHeader fileHeader) {
-    long offsetLocalFileHeader = fileHeader.getOffsetLocalHeader();
-
-    if (fileHeader.getZip64ExtendedInfo() != null && fileHeader.getZip64ExtendedInfo().getOffsetLocalHeader() != -1) {
-      offsetLocalFileHeader = fileHeader.getZip64ExtendedInfo().getOffsetLocalHeader();
-    }
-
-    return offsetLocalFileHeader;
-  }
-
-  private void updateHeaders(ZipModel zipModel, SplitOutputStream splitOutputStream, int indexOfFileHeader, long
-      offsetEndOfCompressedFile, long offsetLocalFileHeader, Charset charset) throws IOException {
-
-    updateEndOfCentralDirectoryRecord(zipModel, splitOutputStream);
-    zipModel.getCentralDirectory().getFileHeaders().remove(indexOfFileHeader);
-    updateFileHeadersWithLocalHeaderOffsets(zipModel.getCentralDirectory().getFileHeaders(), offsetEndOfCompressedFile,
-        offsetLocalFileHeader);
-
-    HeaderWriter headerWriter = new HeaderWriter();
-    headerWriter.finalizeZipFile(zipModel, splitOutputStream, charset);
-  }
-
-  private void updateEndOfCentralDirectoryRecord(ZipModel zipModel, SplitOutputStream splitOutputStream)
-      throws IOException {
-    EndOfCentralDirectoryRecord endOfCentralDirectoryRecord = zipModel.getEndOfCentralDirectoryRecord();
-    endOfCentralDirectoryRecord.setOffsetOfStartOfCentralDirectory(splitOutputStream.getFilePointer());
-    endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectory(
-        endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectory() - 1);
-    endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(
-        endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectoryOnThisDisk() - 1);
-    zipModel.setEndOfCentralDirectoryRecord(endOfCentralDirectoryRecord);
-  }
-
-  private void updateFileHeadersWithLocalHeaderOffsets(List<FileHeader> fileHeaders, long offsetEndOfCompressedFile,
-                                                       long offsetLocalFileHeader) {
-    for (int i = 0; i < fileHeaders.size(); i ++) {
-      FileHeader fileHeader = fileHeaders.get(i);
-      long offsetLocalHdr = fileHeader.getOffsetLocalHeader();
-
-      if (fileHeader.getZip64ExtendedInfo() != null && fileHeader.getZip64ExtendedInfo().getOffsetLocalHeader() != -1) {
-        offsetLocalHdr = fileHeader.getZip64ExtendedInfo().getOffsetLocalHeader();
-      }
-
-      if (offsetLocalHdr > offsetLocalFileHeader) {
-        fileHeader.setOffsetLocalHeader(offsetLocalHdr - (offsetEndOfCompressedFile - offsetLocalFileHeader) - 1);
-      }
-    }
-  }
-
-  private void cleanupFile(boolean successFlag, File zipFile, File temporaryZipFile) throws ZipException {
-    if (successFlag) {
-      restoreFileName(zipFile, temporaryZipFile);
-    } else {
-      temporaryZipFile.delete();
-    }
-  }
-
-  private void restoreFileName(File zipFile, File temporaryZipFile) throws ZipException {
-    if (zipFile.delete()) {
-      if (!temporaryZipFile.renameTo(zipFile)) {
-        throw new ZipException("cannot rename modified zip file");
-      }
-    } else {
-      throw new ZipException("cannot delete old zip file");
-    }
-  }
-
-  @Override
-  protected long calculateTotalWork(RemoveEntryFromZipFileTaskParameters taskParameters) {
-    return zipModel.getZipFile().length() - taskParameters.fileHeader.getCompressedSize();
-  }
-
-  @Override
-  protected ProgressMonitor.Task getTask() {
-    return ProgressMonitor.Task.REMOVE_ENTRY;
-  }
-
-  public static class RemoveEntryFromZipFileTaskParameters extends AbstractZipTaskParameters {
-    private FileHeader fileHeader;
-
-    public RemoveEntryFromZipFileTaskParameters(FileHeader fileHeader, Charset charset) {
-      super(charset);
-      this.fileHeader = fileHeader;
-    }
-  }
-}
diff --git a/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java b/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
new file mode 100644
index 0000000..e5cf2b9
--- /dev/null
+++ b/src/main/java/net/lingala/zip4j/tasks/RemoveFilesFromZipTask.java
@@ -0,0 +1,148 @@
+package net.lingala.zip4j.tasks;
+
+import net.lingala.zip4j.exception.ZipException;
+import net.lingala.zip4j.headers.HeaderUtil;
+import net.lingala.zip4j.headers.HeaderWriter;
+import net.lingala.zip4j.io.outputstream.SplitOutputStream;
+import net.lingala.zip4j.model.EndOfCentralDirectoryRecord;
+import net.lingala.zip4j.model.FileHeader;
+import net.lingala.zip4j.model.ZipModel;
+import net.lingala.zip4j.model.enums.RandomAccessFileMode;
+import net.lingala.zip4j.progress.ProgressMonitor;
+import net.lingala.zip4j.tasks.RemoveFilesFromZipTask.RemoveFilesFromZipTaskParameters;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+
+import static net.lingala.zip4j.headers.HeaderUtil.getLocalFileHeaderSize;
+
+public class RemoveFilesFromZipTask extends AbstractModifyFileTask<RemoveFilesFromZipTaskParameters>  {
+
+  private ZipModel zipModel;
+  private HeaderWriter headerWriter;
+
+  public RemoveFilesFromZipTask(ZipModel zipModel, HeaderWriter headerWriter, AsyncTaskParameters asyncTaskParameters) {
+    super(asyncTaskParameters);
+    this.zipModel = zipModel;
+    this.headerWriter = headerWriter;
+  }
+
+  @Override
+  protected void executeTask(RemoveFilesFromZipTaskParameters taskParameters, ProgressMonitor progressMonitor)
+      throws IOException {
+    if (zipModel.isSplitArchive()) {
+      throw new ZipException("This is a split archive. Zip file format does not allow updating split/spanned files");
+    }
+
+    List<String> entriesToRemove = filterNonExistingEntries(taskParameters.filesToRemove);
+
+    if (entriesToRemove.isEmpty()) {
+      return;
+    }
+
+    File temporaryZipFile = getTemporaryFile(zipModel.getZipFile().getPath());
+    boolean successFlag = false;
+
+    try (SplitOutputStream outputStream = new SplitOutputStream(temporaryZipFile);
+         RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.READ.getValue())){
+
+      long currentFileCopyPointer = 0;
+      List<FileHeader> allUnchangedFileHeaders = new ArrayList<>(zipModel.getCentralDirectory().getFileHeaders());
+
+      for (FileHeader fileHeader : allUnchangedFileHeaders) {
+        if (shouldEntryBeRemoved(fileHeader, entriesToRemove)) {
+          long offsetToSubtract = getLocalFileHeaderSize(fileHeader) + fileHeader.getCompressedSize();
+          updateHeaders(fileHeader, offsetToSubtract);
+
+          if (!zipModel.getCentralDirectory().getFileHeaders().remove(fileHeader)) {
+            throw new ZipException("Could not remove entry from list of central directory headers");
+          }
+
+          currentFileCopyPointer += offsetToSubtract;
+        } else {
+          // copy complete entry without any changes
+          int headerSize = getLocalFileHeaderSize(fileHeader);
+          currentFileCopyPointer += super.copyFile(inputStream, outputStream, currentFileCopyPointer, headerSize + fileHeader.getCompressedSize(), progressMonitor);
+        }
+        verifyIfTaskIsCancelled();
+      }
+
+      headerWriter.finalizeZipFile(zipModel, outputStream, taskParameters.charset);
+      successFlag = true;
+    } finally {
+      cleanupFile(successFlag, zipModel.getZipFile(), temporaryZipFile);
+    }
+  }
+
+  @Override
+  protected long calculateTotalWork(RemoveFilesFromZipTaskParameters taskParameters) {
+    return zipModel.getZipFile().length();
+  }
+
+  private List<String> filterNonExistingEntries(List<String> filesToRemove) throws ZipException {
+    List<String> filteredFilesToRemove = new ArrayList<>();
+
+    for (String fileToRemove : filesToRemove) {
+      if (HeaderUtil.getFileHeader(zipModel, fileToRemove) != null) {
+        filteredFilesToRemove.add(fileToRemove);
+      }
+    }
+
+    return filteredFilesToRemove;
+  }
+
+  private boolean shouldEntryBeRemoved(FileHeader fileHeaderToBeChecked, List<String> fileNamesToBeRemoved) {
+    for (String fileNameToBeRemoved : fileNamesToBeRemoved) {
+      if (fileHeaderToBeChecked.getFileName().startsWith(fileNameToBeRemoved)) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  private void updateHeaders(FileHeader fileHeaderThatWasRemoved, long offsetToSubtract) throws ZipException {
+    updateOffsetsForAllSubsequentFileHeaders(zipModel, fileHeaderThatWasRemoved, Math.negateExact(offsetToSubtract));
+
+    EndOfCentralDirectoryRecord endOfCentralDirectoryRecord = zipModel.getEndOfCentralDirectoryRecord();
+    endOfCentralDirectoryRecord.setOffsetOfStartOfCentralDirectory(
+        endOfCentralDirectoryRecord.getOffsetOfStartOfCentralDirectory() - offsetToSubtract);
+    endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectory(
+        endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectory() - 1);
+
+    if (endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectoryOnThisDisk() > 0) {
+      endOfCentralDirectoryRecord.setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(
+          endOfCentralDirectoryRecord.getTotalNumberOfEntriesInCentralDirectoryOnThisDisk() - 1);
+    }
+
+    if (zipModel.isZip64Format()) {
+      zipModel.getZip64EndOfCentralDirectoryRecord().setOffsetStartCentralDirectoryWRTStartDiskNumber(
+          zipModel.getZip64EndOfCentralDirectoryRecord().getOffsetStartCentralDirectoryWRTStartDiskNumber() - offsetToSubtract);
+
+      zipModel.getZip64EndOfCentralDirectoryRecord().setTotalNumberOfEntriesInCentralDirectoryOnThisDisk(
+          zipModel.getZip64EndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() - 1);
+
+      zipModel.getZip64EndOfCentralDirectoryLocator().setOffsetZip64EndOfCentralDirectoryRecord(
+          zipModel.getZip64EndOfCentralDirectoryLocator().getOffsetZip64EndOfCentralDirectoryRecord() - offsetToSubtract
+      );
+    }
+  }
+
+  @Override
+  protected ProgressMonitor.Task getTask() {
+    return ProgressMonitor.Task.REMOVE_ENTRY;
+  }
+
+  public static class RemoveFilesFromZipTaskParameters extends AbstractZipTaskParameters {
+    private List<String> filesToRemove;
+
+    public RemoveFilesFromZipTaskParameters(List<String> filesToRemove, Charset charset) {
+      super(charset);
+      this.filesToRemove = filesToRemove;
+    }
+  }
+}
diff --git a/src/main/java/net/lingala/zip4j/tasks/RenameFileTask.java b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
similarity index 84%
rename from src/main/java/net/lingala/zip4j/tasks/RenameFileTask.java
rename to src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
index a120a15..008f846 100644
--- a/src/main/java/net/lingala/zip4j/tasks/RenameFileTask.java
+++ b/src/main/java/net/lingala/zip4j/tasks/RenameFilesTask.java
@@ -22,14 +22,16 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-public class RenameFileTask extends AbstractModifyFileTask<RenameFileTask.RenameFileTaskParameters> {
+import static net.lingala.zip4j.headers.HeaderUtil.getLocalFileHeaderSize;
+
+public class RenameFilesTask extends AbstractModifyFileTask<RenameFilesTask.RenameFilesTaskParameters> {
 
   private ZipModel zipModel;
   private HeaderWriter headerWriter;
   private RawIO rawIO;
   private Charset charset;
 
-  public RenameFileTask(ZipModel zipModel, HeaderWriter headerWriter, RawIO rawIO, Charset charset, AsyncTaskParameters asyncTaskParameters) {
+  public RenameFilesTask(ZipModel zipModel, HeaderWriter headerWriter, RawIO rawIO, Charset charset, AsyncTaskParameters asyncTaskParameters) {
     super(asyncTaskParameters);
     this.zipModel = zipModel;
     this.headerWriter = headerWriter;
@@ -38,13 +40,14 @@ public class RenameFileTask extends AbstractModifyFileTask<RenameFileTask.Rename
   }
 
   @Override
-  protected void executeTask(RenameFileTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {
+  protected void executeTask(RenameFilesTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {
     Map<String, String> fileNamesMap = filterNonExistingEntriesAndAddSeparatorIfNeeded(taskParameters.fileNamesMap);
     if (fileNamesMap.size() == 0) {
       return;
     }
 
     File temporaryFile = getTemporaryFile(zipModel.getZipFile().getPath());
+    boolean successFlag = false;
     try(RandomAccessFile inputStream = new RandomAccessFile(zipModel.getZipFile(), RandomAccessFileMode.WRITE.getValue());
         OutputStream outputStream = new FileOutputStream(temporaryFile)) {
 
@@ -63,7 +66,7 @@ public class RenameFileTask extends AbstractModifyFileTask<RenameFileTask.Rename
 
         if (fileNameMapForThisEntry == null) {
           // copy complete entry without any changes
-          int headerSize = 30 + fileHeader.getFileNameLength() + fileHeader.getExtraFieldLength(); // 30 = all fixed lengths in local file header
+          int headerSize = getLocalFileHeaderSize(fileHeader);
           currentFileCopyPointer += copyFile(inputStream, outputStream, currentFileCopyPointer, headerSize + fileHeader.getCompressedSize(), progressMonitor);
         } else {
           String newFileName = getNewFileName(fileNameMapForThisEntry.getValue(), fileNameMapForThisEntry.getKey(), fileHeader.getFileName());
@@ -80,17 +83,15 @@ public class RenameFileTask extends AbstractModifyFileTask<RenameFileTask.Rename
       }
 
       headerWriter.finalizeZipFile(zipModel, outputStream, charset);
-
-      cleanupFile(true, zipModel.getZipFile(), temporaryFile);
-    } catch (Exception e) {
-      cleanupFile(false, zipModel.getZipFile(), temporaryFile);
-      throw e;
+      successFlag = true;
+    } finally {
+      cleanupFile(successFlag, zipModel.getZipFile(), temporaryFile);
     }
 
   }
 
   @Override
-  protected long calculateTotalWork(RenameFileTaskParameters taskParameters) {
+  protected long calculateTotalWork(RenameFilesTaskParameters taskParameters) {
     return zipModel.getZipFile().length();
   }
 
@@ -146,7 +147,7 @@ public class RenameFileTask extends AbstractModifyFileTask<RenameFileTask.Rename
     fileHeaderToBeChanged.setFileName(newFileName);
     fileHeaderToBeChanged.setFileNameLength(newFileNameBytes.length);
 
-    updateOffsetsForAllSubsequentFileHeaders(fileHeaderToBeChanged, headersOffset);
+    updateOffsetsForAllSubsequentFileHeaders(zipModel, fileHeaderToBeChanged, headersOffset);
 
     zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(
         zipModel.getEndOfCentralDirectoryRecord().getOffsetOfStartOfCentralDirectory() + headersOffset);
@@ -181,16 +182,6 @@ public class RenameFileTask extends AbstractModifyFileTask<RenameFileTask.Rename
     return fileNamesMapToBeChanged;
   }
 
-  private void updateOffsetsForAllSubsequentFileHeaders(FileHeader fileHeaderModified, int offsetToAdd) throws ZipException {
-    int indexOfFileHeader = HeaderUtil.getIndexOfFileHeader(zipModel, fileHeaderModified);
-    List<FileHeader> allFileHeaders = zipModel.getCentralDirectory().getFileHeaders();
-
-    for (int i = indexOfFileHeader + 1; i < allFileHeaders.size(); i++) {
-      FileHeader fileHeaderToUpdate = allFileHeaders.get(i);
-      fileHeaderToUpdate.setOffsetLocalHeader(fileHeaderToUpdate.getOffsetLocalHeader() + offsetToAdd);
-    }
-  }
-
   private String getNewFileName(String newFileName, String oldFileName, String fileNameFromHeaderToBeChanged) throws ZipException {
     if (fileNameFromHeaderToBeChanged.equals(oldFileName)) {
       return newFileName;
@@ -205,10 +196,10 @@ public class RenameFileTask extends AbstractModifyFileTask<RenameFileTask.Rename
     throw new ZipException("old file name was neither an exact match nor a partial match");
   }
 
-  public static class RenameFileTaskParameters {
+  public static class RenameFilesTaskParameters {
     private Map<String, String> fileNamesMap;
 
-    public RenameFileTaskParameters(Map<String, String> fileNamesMap) {
+    public RenameFilesTaskParameters(Map<String, String> fileNamesMap) {
       this.fileNamesMap = fileNamesMap;
     }
   }
diff --git a/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java b/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
index 005fe3e..6f4c928 100644
--- a/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
+++ b/src/test/java/net/lingala/zip4j/RemoveFilesFromZipIT.java
@@ -15,8 +15,9 @@ import org.junit.rules.ExpectedException;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
-import java.util.Optional;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -26,37 +27,28 @@ public class RemoveFilesFromZipIT extends AbstractIT {
   public ExpectedException expectedException = ExpectedException.none();
 
   @Test
-  public void testRemoveFileAsFileNameThrowsExceptionWhenZipFileDoesNotExist() throws ZipException {
-    String fileNameToRemove = "SOME_NAME";
+  public void testRemoveFileAsFileNameThrowsExceptionForSplitArchive() throws ZipException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
+    filesToAdd.add(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"));
+    zipFile.createSplitZipFile(filesToAdd, new ZipParameters(), true, InternalZipConstants.MIN_SPLIT_LENGTH);
+
     expectedException.expect(ZipException.class);
-    expectedException.expectMessage("could not find file header for file: " + fileNameToRemove);
+    expectedException.expectMessage("Zip file format does not allow updating split/spanned files");
 
-    new ZipFile(generatedZipFile).removeFile(fileNameToRemove);
+    zipFile.removeFile("file_PDF_1MB.pdf");
   }
 
   @Test
-  public void testRemoveFileAsFileNameThrowsExceptionWhenFileDoesNotExistInZip() throws ZipException {
+  public void testRemoveFileAsFileNameDoesNotModifyZipFileWhenFileDoesNotExistInZip() throws IOException {
     String fileNameToRemove = "SOME_NAME";
-    expectedException.expect(ZipException.class);
-    expectedException.expectMessage("could not find file header for file: " + fileNameToRemove);
 
     ZipFile zipFile = new ZipFile(generatedZipFile);
     zipFile.addFiles(FILES_TO_ADD);
 
     zipFile.removeFile(fileNameToRemove);
-  }
 
-  @Test
-  public void testRemoveFileAsFileNameThrowsExceptionForSplitArchive() throws ZipException {
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
-    filesToAdd.add(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"));
-    zipFile.createSplitZipFile(filesToAdd, new ZipParameters(), true, InternalZipConstants.MIN_SPLIT_LENGTH);
-
-    expectedException.expect(ZipException.class);
-    expectedException.expectMessage("Zip file format does not allow updating split/spanned files");
-
-    zipFile.removeFile("file_PDF_1MB.pdf");
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, FILES_TO_ADD.size());
   }
 
   @Test
@@ -97,19 +89,6 @@ public class RemoveFilesFromZipIT extends AbstractIT {
     verifyZipFileDoesNotContainFile(generatedZipFile, "test-files/öüäöäö/asöäööl");
   }
 
-  @Test
-  public void testRemoveFileAsFileHeaderThrowsExceptionForSplitArchive() throws ZipException {
-    ZipFile zipFile = new ZipFile(generatedZipFile);
-    List<File> filesToAdd = new ArrayList<>(FILES_TO_ADD);
-    filesToAdd.add(TestUtils.getTestFileFromResources("file_PDF_1MB.pdf"));
-    zipFile.createSplitZipFile(filesToAdd, new ZipParameters(), true, InternalZipConstants.MIN_SPLIT_LENGTH);
-
-    expectedException.expect(ZipException.class);
-    expectedException.expectMessage("Zip file format does not allow updating split/spanned files");
-
-    zipFile.removeFile(zipFile.getFileHeader("file_PDF_1MB.pdf"));
-  }
-
   @Test
   public void testRemoveFileAsFileHeaderRemovesSuccessfully() throws IOException {
     ZipParameters zipParameters = createZipParameters(EncryptionMethod.AES, AesKeyStrength.KEY_STRENGTH_256);
@@ -122,10 +101,113 @@ public class RemoveFilesFromZipIT extends AbstractIT {
     verifyZipFileDoesNotContainFile(generatedZipFile, "sample_directory/favicon.ico");
   }
 
+  @Test
+  public void testRemoveFilesRemovesFirstEntrySuccessfully() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.addFiles(FILES_TO_ADD);
+
+    zipFile.removeFiles(Collections.singletonList("sample_text1.txt"));
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, FILES_TO_ADD.size() - 1);
+    verifyZipFileDoesNotContainFile(generatedZipFile, "sample_text1.txt");
+  }
+
+  @Test
+  public void testRemoveFilesRemovesLastEntrySuccessfully() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.addFiles(FILES_TO_ADD);
+
+    zipFile.removeFiles(Collections.singletonList("sample.pdf"));
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, FILES_TO_ADD.size() - 1);
+    verifyZipFileDoesNotContainFile(generatedZipFile, "sample.pdf");
+  }
+
+  @Test
+  public void testRemoveFilesRemovesMultipleEntriesSuccessfully() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.addFiles(FILES_TO_ADD);
+    List<String> filesToRemove = Arrays.asList("sample_text1.txt", "sample.pdf");
+
+    zipFile.removeFiles(filesToRemove);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, FILES_TO_ADD.size() - 2);
+    verifyZipFileDoesNotContainFiles(generatedZipFile, filesToRemove);
+  }
+
+  @Test
+  public void testRemoveFilesRemovesMultipleEntriesFromEncryptedZipSuccessfully() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile, PASSWORD);
+    ZipParameters zipParameters = new ZipParameters();
+    zipParameters.setEncryptFiles(true);
+    zipParameters.setEncryptionMethod(EncryptionMethod.AES);
+    zipFile.addFiles(FILES_TO_ADD, zipParameters);
+    List<String> filesToRemove = Arrays.asList("sample_text1.txt", "sample.pdf");
+
+    zipFile.removeFiles(filesToRemove);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, PASSWORD, outputFolder, FILES_TO_ADD.size() - 2);
+    verifyZipFileDoesNotContainFiles(generatedZipFile, filesToRemove);
+  }
+
+  @Test
+  public void testRemoveFilesRemovesDirectorySuccessfully() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.addFolder(TestUtils.getTestFileFromResources(""));
+
+    zipFile.removeFiles(Collections.singletonList("test-files/öüäöäö/"));
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 11);
+    verifyZipFileDoesNotContainFolders(generatedZipFile, Collections.singletonList("test-files/öüäöäö/"));
+  }
+
+  @Test
+  public void testRemoveFilesRemovesMultipleFilesAndDirectoriesSuccessfully() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.addFolder(TestUtils.getTestFileFromResources(""));
+
+    zipFile.removeFiles(Arrays.asList(
+        "test-files/öüäöäö/",
+        "test-files/sample_directory/",
+        "test-files/after_deflate_remaining_bytes.bin",
+        "test-files/бореиская.txt"
+    ));
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 7);
+    verifyZipFileDoesNotContainFolders(generatedZipFile, Arrays.asList("test-files/öüäöäö/", "test-files/sample_directory"));
+    verifyZipFileDoesNotContainFiles(generatedZipFile, Arrays.asList("test-files/after_deflate_remaining_bytes.bin", "test-files/бореиская.txt"));
+  }
+
+  @Test
+  public void testRemoveFilesRemovesSinglEntryFromAFolderInAZip() throws IOException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+    zipFile.addFolder(TestUtils.getTestFileFromResources(""));
+    List<String> fileToRemove = Collections.singletonList("test-files/öüäöäö/asöäööl");
+
+    zipFile.removeFiles(fileToRemove);
+
+    ZipFileVerifier.verifyZipFileByExtractingAllFiles(generatedZipFile, outputFolder, 12);
+    verifyZipFileDoesNotContainFiles(generatedZipFile, fileToRemove);
+  }
+
   private void verifyZipFileDoesNotContainFile(File generatedZipFile, String fileNameToCheck) throws ZipException {
+    verifyZipFileDoesNotContainFiles(generatedZipFile, Collections.singletonList(fileNameToCheck));
+  }
+
+  private void verifyZipFileDoesNotContainFiles(File generatedZipFile, List<String> filesNamesToCheck) throws ZipException {
+    ZipFile zipFile = new ZipFile(generatedZipFile);
+
+    for (FileHeader fileHeader : zipFile.getFileHeaders()) {
+      assertThat(filesNamesToCheck).doesNotContain(fileHeader.getFileName());
+    }
+  }
+
+  private void verifyZipFileDoesNotContainFolders(File generatedZipFile, List<String> folderNames) throws ZipException {
     ZipFile zipFile = new ZipFile(generatedZipFile);
-    Optional<FileHeader> fileHeader = zipFile.getFileHeaders().stream()
-        .filter(e -> e.getFileName().equals(fileNameToCheck)).findFirst();
-    assertThat(fileHeader).isNotPresent();
+
+    for (FileHeader fileHeader : zipFile.getFileHeaders()) {
+      folderNames.forEach(e -> assertThat(fileHeader.getFileName().startsWith(e)).isFalse());
+    }
   }
+
 }
diff --git a/src/test/java/net/lingala/zip4j/ZipFileTest.java b/src/test/java/net/lingala/zip4j/ZipFileTest.java
index fa755cc..8aa785f 100644
--- a/src/test/java/net/lingala/zip4j/ZipFileTest.java
+++ b/src/test/java/net/lingala/zip4j/ZipFileTest.java
@@ -446,6 +446,14 @@ public class ZipFileTest {
     zipFile.removeFile((FileHeader) null);
   }
 
+  @Test
+  public void testRemoveFilesWithListThrowsExceptionWhenListIsNull() throws ZipException {
+    expectedException.expect(ZipException.class);
+    expectedException.expectMessage("fileNames list is null");
+
+    zipFile.removeFiles(null);
+  }
+
   @Test
   public void testRenameFileWithFileHeaderThrowsExceptionWhenHeaderIsNull() throws ZipException {
     expectedException.expect(ZipException.class);
diff --git a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
index ce7e4bb..30973fd 100644
--- a/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
+++ b/src/test/java/net/lingala/zip4j/headers/HeaderUtilTest.java
@@ -265,6 +265,15 @@ public class HeaderUtilTest {
     assertThat(HeaderUtil.decodeStringWithCharset(plainEncodedBytes, false, null)).isEqualTo(englishString);
   }
 
+  @Test
+  public void testGetLocalFileHeaderSize() {
+    FileHeader fileHeader = new FileHeader();
+    fileHeader.setFileNameLength(10);
+    fileHeader.setExtraFieldLength(20);
+
+    assertThat(HeaderUtil.getLocalFileHeaderSize(fileHeader)).isEqualTo(60);
+  }
+
   private List<FileHeader> generateFileHeaderWithFileNames(String fileNamePrefix, int numberOfEntriesToAdd) {
     List<FileHeader> fileHeaders = new ArrayList<>();
     for (int i = 0; i < numberOfEntriesToAdd; i++) {
