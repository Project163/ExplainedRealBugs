diff --git a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
index b957f69..0a39e36 100755
--- a/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
+++ b/src/main/java/net/lingala/zip4j/headers/HeaderReader.java
@@ -76,6 +76,10 @@ public class HeaderReader {
       throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e);
     }
 
+    if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) {
+      return zipModel;
+    }
+
     // If file is Zip64 format, Zip64 headers have to be read before reading central directory
     zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO));
 
diff --git a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
index 041e5f5..ada86e1 100644
--- a/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
+++ b/src/test/java/net/lingala/zip4j/ExtractZipFileIT.java
@@ -376,6 +376,13 @@ public class ExtractZipFileIT extends AbstractIT {
     zipFile.extractAll(temporaryFolder.toString());
   }
 
+  @Test
+  public void testExtractZipFileEmptyZipFileExtractsNone() throws IOException {
+    ZipFile zipFile = new ZipFile(getTestArchiveFromResources("valid_empty_zip_file.zip"));
+    zipFile.extractAll(outputFolder.getPath());
+    assertThat(outputFolder.listFiles()).isEmpty();
+  }
+
   private void testExtractNestedZipFileWithEncrpytion(EncryptionMethod innerZipEncryption,
                                                        EncryptionMethod outerZipEncryption) throws IOException {
     File innerZipFile = temporaryFolder.newFile("inner.zip");
diff --git a/src/test/resources/test-archives/valid_empty_zip_file.zip b/src/test/resources/test-archives/valid_empty_zip_file.zip
new file mode 100644
index 0000000..15cb0ec
Binary files /dev/null and b/src/test/resources/test-archives/valid_empty_zip_file.zip differ
