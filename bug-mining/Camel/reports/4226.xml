<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 10:25:18 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CAMEL-11666] Camel Hazelcast Queue Cosumer implementation</title>
                <link>https://issues.apache.org/jira/browse/CAMEL-11666</link>
                <project id="12311211" key="CAMEL">Camel</project>
                    <description>&lt;p&gt;Guys, &lt;br/&gt;
i have following concern / question about Hazelcast Queue Consumer:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;I do understand why Topic is build based on CamelItemListener as ItemListener in HazelcastTopicConsumer. But the same behavior in HazelcastQueueConsumer doesn&apos;t look meaningful:
	&lt;ol&gt;
		&lt;li&gt;Unlike Topic, Queue has state and someone subscribed to Queue and didn&apos;t process it (any reason here) no one will take it from queue (Event Already happened and will not happen again). Message will be stuck there. Until you explicitly poll it, which Camel-Hazelcast doesn&apos;t support (as consumer). I had to do Polling via Camel-Timer as workaround.&lt;/li&gt;
		&lt;li&gt;Another problem is that ItemListener doesn&apos;t actually drain the Queue. It just listens to events. As for me it doesn&apos;t make any sense to receive message from Queue and don&apos;t have it removed from Queue. In current implementation you&apos;ll have to inject queue in Processor to actually Poll the message after ADD Event.&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;If you won&apos;t change the code just please warn user here (&lt;a href=&quot;http://camel.apache.org/hazelcast-component.html#HazelcastComponent-queue&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://camel.apache.org/hazelcast-component.html#HazelcastComponent-queue&lt;/a&gt;) that Queue consumer doesn&apos;t drain the queue. And Processor should actually drain it.&lt;br/&gt;
If node has failed to process message it should be explicitly polled to drain the queue via for example Timer.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13094109">CAMEL-11666</key>
            <summary>Camel Hazelcast Queue Cosumer implementation</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="acosentino">Andrea Cosentino</assignee>
                                    <reporter username="Batter">Ruslan Belinskyy</reporter>
                        <labels>
                            <label>documentation</label>
                            <label>features</label>
                    </labels>
                <created>Fri, 11 Aug 2017 14:28:55 +0000</created>
                <updated>Wed, 23 Aug 2017 11:45:10 +0000</updated>
                            <resolved>Wed, 23 Aug 2017 11:45:10 +0000</resolved>
                                                    <fixVersion>2.20.0</fixVersion>
                                    <component>camel-hazelcast</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16123453" author="ancosen" created="Fri, 11 Aug 2017 14:53:10 +0000"  >&lt;p&gt;If this is a discussion about the design maybe it&apos;s better to start a thread on users/dev mailing list&lt;/p&gt;</comment>
                            <comment id="16123473" author="batter" created="Fri, 11 Aug 2017 15:13:19 +0000"  >&lt;p&gt;I think it&apos;s a design bug IMHO. &lt;/p&gt;

&lt;p&gt;But if you consider not as a bug (but rather a feature) that messages are not drained from Queue - it can be moved/closed with &apos;Works As Designed&apos; Resolution.&lt;/p&gt;</comment>
                            <comment id="16135068" author="ancosen" created="Mon, 21 Aug 2017 11:49:10 +0000"  >&lt;p&gt;I&apos;m not sure I&apos;m completely following the problem. The Hazelcast Queue Consumer is designed to consume events on a specific queue. So for example if you add an entry, the consumer will create an ADD event message to consume and if you remove an entry you&apos;ll have a REMOVE event message to consume.&lt;/p&gt;

&lt;p&gt;If you want to perform operation on your queue you need to use the Hazelcast Queue Producer. Using it you&apos;ll be able to do what you want:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-hazelcast/src/main/java/org/apache/camel/component/hazelcast/queue/HazelcastQueueProducer.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/camel/blob/master/components/camel-hazelcast/src/main/java/org/apache/camel/component/hazelcast/queue/HazelcastQueueProducer.java&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16135213" author="batter" created="Mon, 21 Aug 2017 14:12:56 +0000"  >&lt;p&gt;Ok, let me give you scenario:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;We have &lt;b&gt;one&lt;/b&gt; of boxes which will be receiving some messages&lt;/li&gt;
	&lt;li&gt;Once it has received it should publish message to queue&lt;/li&gt;
	&lt;li&gt;Once messages in Queue now work will be distributed among all hosts participating in Hazelcast cluster.&lt;/li&gt;
	&lt;li&gt;Each message is processed* only once* (by single host)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Now how it would look like if i would choose any JMS provider (Active MQ for example):&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;First host is picking up messages and puts into the queue.&lt;/li&gt;
	&lt;li&gt;Any hosts which are listening to the queue will pick up message and process it (Just One host processing One message)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;In case of current Camel Hazelcast implementation:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;First host is picking up messages and puts into the queue.&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;All&lt;/b&gt; hosts which are subscribed to the queue will pick up message event:&lt;/li&gt;
	&lt;li&gt;Now you have to:
	&lt;ol&gt;
		&lt;li&gt;Lock object in memory to avoid duplicated processing on all hosts (&lt;b&gt;One message All hosts&lt;/b&gt;)&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;Poll message&lt;/b&gt; from queue (because message listener doesn&apos;t remove item from queue)&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
	&lt;li&gt;If for some reason host didn&apos;t perform &quot;Poll message from queue&quot; (any reason: restart, failure). Message will be stuck in queue until whole cluster rebooted and message will be lost.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;But in case above how it differs from Topic? Absolutely the same implementation. No need to have queue.&lt;br/&gt;
Topic and Queue can&apos;t have the same implementation.&lt;br/&gt;
Topic = Subscription&lt;br/&gt;
Queue = Polling&lt;/p&gt;</comment>
                            <comment id="16135217" author="ancosen" created="Mon, 21 Aug 2017 14:18:17 +0000"  >&lt;p&gt;This is more clear now. I&apos;ll take a look tomorrow. It waan&apos;t clear you were talking from the cluster perspective. Btw now it&apos;s clear&lt;/p&gt;</comment>
                            <comment id="16136530" author="lb" created="Tue, 22 Aug 2017 09:01:22 +0000"  >&lt;p&gt;Maybe a solution would be to have a way to configure how the queue is &quot;consumed&quot; :&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;&lt;b&gt;ConsumerMode.SNIFF&lt;/b&gt; the consumer uses a listener to receive events, no remove is performed (&lt;em&gt;default to preserve behavior&lt;/em&gt;)&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;ConsumerMode.POLL&lt;/b&gt; the consumer polls the queue so elements are removed&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Thoughts ?&lt;/p&gt;</comment>
                            <comment id="16136535" author="ancosen" created="Tue, 22 Aug 2017 09:03:00 +0000"  >&lt;p&gt;Fine to me.&lt;/p&gt;</comment>
                            <comment id="16136839" author="batter" created="Tue, 22 Aug 2017 14:10:00 +0000"  >&lt;p&gt;Just please add to documentation:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;SNIFF = Subscribe which doesn&apos;t remove item from Queue and only listens for events. Object received by consumer will be com.hazelcast.core.ItemEvent.&amp;lt;Object&amp;gt;.&lt;/li&gt;
	&lt;li&gt;POLL = Poll. Not sure if there will be any parameters (didn&apos;t find any here: &lt;a href=&quot;http://camel.apache.org/activemq.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://camel.apache.org/activemq.html&lt;/a&gt;) like polling delay/period, Object received by consumer will be original object (or some wrapper).&lt;br/&gt;
Thanks&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="16136850" author="lb" created="Tue, 22 Aug 2017 14:17:52 +0000"  >&lt;p&gt;POLL will have a timeout as IQueue#poll(timeout, timeUnit)&lt;/p&gt;</comment>
                            <comment id="16137509" author="davsclaus" created="Tue, 22 Aug 2017 22:28:41 +0000"  >&lt;p&gt;Is SNIFF a term used by hazeclast? Otherwise Isn&apos;t PEAK a more common term?&lt;/p&gt;</comment>
                            <comment id="16138001" author="lb" created="Wed, 23 Aug 2017 07:19:43 +0000"  >&lt;p&gt;No it is not an hazelcast term, it&apos;s the first thing that I had in mind to describe the functionality.&lt;/p&gt;

&lt;p&gt;The current implementation listens for events on the queue so it gets notified about elements being added or removed so maybe LISTEN is a better name. PEEK would be confusing as it is not supposed to handle removal of elements.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310060" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Estimated Complexity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10060"><![CDATA[Unknown]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 13 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3ip2v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>