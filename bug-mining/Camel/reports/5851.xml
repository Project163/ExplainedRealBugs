<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 10:49:36 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CAMEL-16594] DynamoDB stream updates are missed when there are more than one active shards</title>
                <link>https://issues.apache.org/jira/browse/CAMEL-16594</link>
                <project id="12311211" key="CAMEL">Camel</project>
                    <description>&lt;p&gt;The current Camel ddbstream implementation seems to incorrectly apply the concept of &lt;tt&gt;ShardIteratorType&lt;/tt&gt; to the list of shards forming a DynamoDB stream rather than each shard individually.&lt;/p&gt;

&lt;p&gt;According to the &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_GetShardIterator.html#DDB-streams_GetShardIterator-request-ShardIteratorType&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;AWS documentation&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ShardIteratorType determines how the shard iterator is used to start reading stream records from the shard.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For example, for a given shard, when &lt;tt&gt;ShardIteratorType&lt;/tt&gt; equal to &lt;tt&gt;LATEST&lt;/tt&gt;, the AWS SDK will read the most recent data in that particular shard. However, when &lt;tt&gt;ShardIteratorType&lt;/tt&gt; equal to &lt;tt&gt;LATEST&lt;/tt&gt;, Camel will additionally use &lt;tt&gt;ShardIteratorType&lt;/tt&gt; to determine which shard it considers amongst all the available ones in the stream: &lt;a href=&quot;https://github.com/apache/camel/blob/6119fdc379db343030bd25b191ab88bbec34d6b6/components/camel-aws/camel-aws2-ddb/src/main/java/org/apache/camel/component/aws2/ddbstream/ShardIteratorHandler.java#L132&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/camel/blob/6119fdc379db343030bd25b191ab88bbec34d6b6/components/camel-aws/camel-aws2-ddb/src/main/java/org/apache/camel/component/aws2/ddbstream/ShardIteratorHandler.java#L132&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If my understanding is correct, shards in DynamoDB are modelled as a tree, with the child leaf nodes being the shards that are still active, i.e. the ones where new stream data will appear. These child shards will have a &lt;tt&gt;StartingSequenceNumber&lt;/tt&gt;, but no &lt;tt&gt;EndingSequenceNumber&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;The most common case is to have a single shard, or a single branch of parent and child nodes:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Shard0
   |
Shard1
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the above case, new data will be added to &lt;tt&gt;Shard1&lt;/tt&gt;, and the Camel implementation which  looks only at the last shard when &lt;tt&gt;ShardIteratorType&lt;/tt&gt; is equal to &lt;tt&gt;LATEST&lt;/tt&gt;, will be correct.&lt;/p&gt;

&lt;p&gt;However, the tree can also look like this (see related example in the attached JSON output from the AWS CLI, where the shard number matches the index in the JSON list):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;             Shard0
            /      \
     Shard1          Shard2
    /      \        /      \ 
Shard3   Shard4  Shard5   Shard6
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this case, Camel will only consider Shard6, even though new data may be added to any of Shard3, Shard4, Shard5 or Shard6. This leads to updates being missed.&lt;/p&gt;

&lt;p&gt;As far as I can tell, DynamoDB will split into multiple shards depending on the number of table partitions, which will either grow for a table with huge amounts of data, or when an exiting table with provisioned capacity is migrated to on-demand provisioning.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13377235">CAMEL-16594</key>
            <summary>DynamoDB stream updates are missed when there are more than one active shards</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="acosentino">Andrea Cosentino</assignee>
                                    <reporter username="Pyves">Pierre-Yves Bigourdan</reporter>
                        <labels>
                    </labels>
                <created>Fri, 7 May 2021 13:02:52 +0000</created>
                <updated>Thu, 23 Sep 2021 11:51:52 +0000</updated>
                            <resolved>Thu, 23 Sep 2021 11:51:23 +0000</resolved>
                                                    <fixVersion>3.12.0</fixVersion>
                                    <component>camel-aws</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="17340835" author="ancosen" created="Fri, 7 May 2021 13:30:38 +0000"  >&lt;p&gt;It&apos;s not really easy to solve.. I mean we may need to get events from multiple shard at the same time. Need to investigate a bit. Thanks for the detailed explanation and if you have time/will to help, we&apos;ll be very happy to review your PR or your findings.&lt;/p&gt;

&lt;p&gt;Thanks again.&lt;/p&gt;</comment>
                            <comment id="17340858" author="pyves" created="Fri, 7 May 2021 14:11:03 +0000"  >&lt;p&gt;Yes, I did have a look at the code, Camel will probably need to get updates from multiple shards. Amongst other things, the fix would involve turning single fields or return values into lists or maps. One additional challenge is that the existing ddbstream implementation does not have many unit tests.&lt;/p&gt;

&lt;p&gt;This issue is not business critical for my company&apos;s use case, but I&apos;ve done the digging and analysis as part of &quot;10% time&quot; (&lt;a href=&quot;https://en.wikipedia.org/wiki/20%25_Project&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;this kind of initiative&lt;/a&gt; if you&apos;re not familiar with it). No guarantees, but I&apos;m happy to carry on and attempt a pull request. As I&apos;ll only dedicate a trickle of effort to this, worth keeping in mind that it will take some time to land. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="17340861" author="ancosen" created="Fri, 7 May 2021 14:15:34 +0000"  >&lt;p&gt;My main concern is how to determine the active shards correctly.&lt;/p&gt;</comment>
                            <comment id="17341752" author="pyves" created="Mon, 10 May 2021 07:49:53 +0000"  >&lt;p&gt;I think those are simply the ones that have a &lt;tt&gt;StartingSequenceNumber&lt;/tt&gt;, but no &lt;tt&gt;EndingSequenceNumber.&lt;/tt&gt;&lt;/p&gt;</comment>
                            <comment id="17415420" author="pyves" created="Wed, 15 Sep 2021 09:55:44 +0000"  >&lt;p&gt;&amp;gt; The current Camel ddbstream implementation seems to incorrectly apply the concept of &lt;tt&gt;ShardIteratorType&lt;/tt&gt; to the list of shards forming a DynamoDB stream rather than each shard individually.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;I&apos;ve been thinking about this quite a bit lately. My first attempt is to keep support for all Camel URI parameters to ensure backwards compatibility, so I&apos;m trying to extend the concept of &lt;tt&gt;ShardIteratorType&lt;/tt&gt;, which in theory should only apply at a single shard level, to a tree of shards. The four possible values of &lt;tt&gt;ShardIteratorType&lt;/tt&gt; are the following:&lt;/p&gt;
&lt;h5&gt;&lt;a name=&quot;LATEST&quot;&gt;&lt;/a&gt;LATEST&lt;/h5&gt;

&lt;p&gt;Those would be the leaves of the tree, i.e. the shards that have a &lt;tt&gt;StartingSequenceNumber&lt;/tt&gt;, but no &lt;tt&gt;EndingSequenceNumber&lt;/tt&gt; (shards 3, 4, 5 and 6).&lt;/p&gt;

&lt;p&gt;The behaviour of &lt;tt&gt;LATEST&lt;/tt&gt; applied to a whole tree sounds reasonable in my opinion.&lt;/p&gt;
&lt;h5&gt;&lt;a name=&quot;TRIMHORIZON&quot;&gt;&lt;/a&gt;TRIM_HORIZON&lt;/h5&gt;

&lt;p&gt;Those would be the root of tree, i.e. the shards that have no &lt;tt&gt;ParentShardId&lt;/tt&gt;. I&apos;m not entirely sure what would happen if DynamoDB decided to drop Shard 0 (or if that&apos;s even possible), so a slightly more general/safer definition would be either shards that have no &lt;tt&gt;ParentShardId&lt;/tt&gt; or which have a &lt;tt&gt;ParentShardId&lt;/tt&gt; that can no longer be found in the tree. In my above example, if DynamoDB decided to drop Shard 0, Shard 1 and 2 would be the roots of two small subtrees.&lt;/p&gt;

&lt;p&gt;The behaviour of &lt;tt&gt;TRIM_HORIZON&lt;/tt&gt; applied to a whole tree sounds reasonable in my opinion.&lt;/p&gt;
&lt;h5&gt;&lt;a name=&quot;ATSEQUENCENUMBER&quot;&gt;&lt;/a&gt;AT_SEQUENCE_NUMBER&lt;/h5&gt;

&lt;p&gt;This is where things become more troublesome. Consider the attached JSON. Take sequence number 105800000000033207000000 for example. This sequence number definitely doesn&apos;t belong to Shards 0, 1 and 2.&lt;/p&gt;

&lt;p&gt;If you apply the same logic as the current implementation (&lt;a href=&quot;https://github.com/apache/camel/blob/6119fdc379db343030bd25b191ab88bbec34d6b6/components/camel-aws/camel-aws2-ddb/src/main/java/org/apache/camel/component/aws2/ddbstream/ShardList.java#L106&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/camel/blob/6119fdc379db343030bd25b191ab88bbec34d6b6/components/camel-aws/camel-aws2-ddb/src/main/java/org/apache/camel/component/aws2/ddbstream/ShardList.java#L106&lt;/a&gt;), you would end up with shard 5 because it has the biggest &lt;tt&gt;StartingSequenceNumber&lt;/tt&gt;. However, the sequence number we&apos;ve picked, 105800000000033207000000, is smaller than the &lt;tt&gt;StartingSequenceNumber&lt;/tt&gt; of shard 5, 105800000000033207048658. The current logic is incorrect and will probably result in a 400 being returned by AWS.&lt;/p&gt;

&lt;p&gt;If we refine our logic and look for a shard that has a &lt;tt&gt;StartingSequenceNumber&lt;/tt&gt; smaller than the one we&apos;ve picked, shards 3, 4, 6 are all candidates. We&apos;ve narrowed things down a little, but if we tried to iterate over the three shards with that target sequence number, we&apos;d still likely get two 400 errors returned by AWS.&lt;/p&gt;

&lt;p&gt;The most likely answer is shard 6: indeed, 105800000000033207000000 is greater than 105800000000025199618049, the &lt;tt&gt;StartingSequenceNumber&lt;/tt&gt; of shard 6, and 105800000000033207000000 is numerically the closest amongst the &lt;tt&gt;StartingSequenceNumbers&lt;/tt&gt; of shards 3, 4 and 6.&lt;/p&gt;

&lt;p&gt;We&apos;ve come up with the following algorithm:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;iterate through all non-leaf shards in the tree and try to find a shard that has a &lt;tt&gt;StartingSequenceNumber&lt;/tt&gt; smaller and an &lt;tt&gt;EndingSequenceNumber&lt;/tt&gt; greater than the target sequence number.&lt;/li&gt;
	&lt;li&gt;if none are found, iterate through leaf shards and pick the one that has a &lt;tt&gt;StartingSequenceNumber&lt;/tt&gt; smaller than the target sequence number but numerically closest.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;However, I don&apos;t think we can definitely say it will be shard 6 for sure:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;what if the sequence number within shard 3 had suddenly jumped and had reached 105800000000033207000000? The &lt;a href=&quot;https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html#terminology&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;documentation of Kinesis&lt;/a&gt;, which I believe underpins DynamoDB streams, states that &quot;sequence numbers for the same partition key generally increase over time&quot;. That is very vague, even comparing numbers within a given shard is an approximation, let alone across multiple shards.&lt;/li&gt;
	&lt;li&gt;what if the same sequence number is present in multiple shards? The Kinesis documentation does states that &quot;each data record has a sequence number that is unique per partition-key within its shard&quot;. Uniqueness across multiple shards is not guaranteed.&lt;/li&gt;
	&lt;li&gt;even if we did manage to select the correct shard(s), users would never get future updates from the other three leaf shards. Is that really what they&apos;d want?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I feel that anything we come up with in this area would be a potentially confusing heuristic, rather than a rigorous algorithm. Using &lt;tt&gt;AT_SEQUENCE_NUMBER&lt;/tt&gt; really only makes sense if you provide the specific shard identifier with it (which the AWS CLI forces you to do).&lt;/p&gt;
&lt;h5&gt;&lt;a name=&quot;AFTERSEQUENCENUMBER&quot;&gt;&lt;/a&gt;AFTER_SEQUENCE_NUMBER&lt;/h5&gt;

&lt;p&gt;Pretty much the same as AT_SEQUENCE_NUMBER.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Taking a step back, if I had the opportunity to redesign things from scratch, I would only allow Camel users to define two modes of iteration through a DynamoDB stream, &lt;tt&gt;FROM_LATEST&lt;/tt&gt; and &lt;tt&gt;FROM_START&lt;/tt&gt;, intentionally stepping away from the &lt;tt&gt;ShardIteratorType&lt;/tt&gt; wording. You&apos;d simply pick either the roots or leaves of the tree, and not let users select random sequence numbers which could belong to any shard.&lt;/p&gt;</comment>
                            <comment id="17415433" author="ancosen" created="Wed, 15 Sep 2021 10:36:08 +0000"  >&lt;p&gt;We are currently in a situation where we can introduce breaking changes, until we release Camel 3.14.0. Personally I think the most important point is having something that really consume all the entries in a correct way. Conceptually the component is wrong at the moment. So it&apos;s completely fine to revisit it and make some assumptions.&lt;/p&gt;</comment>
                            <comment id="17419045" author="pyves" created="Thu, 23 Sep 2021 08:49:06 +0000"  >&lt;p&gt;Some personal context: this is the last day of work at my current job, and I&apos;ll probably not be able to carry over this work with my next employer. However, I&apos;ve put in some extra effort in the past few days and the good news is that I&apos;m able to provide a working PR. At the very least, I&apos;m hoping it will be a good basis to fix this issue.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I&apos;ve managed to do some some quick testing with a real DynamoDB stream, and haven&apos;t been able to fault the new implementation, apart from one caveat which I&apos;ll expand on in the next section.&lt;/p&gt;

&lt;p&gt;As far as testing is concerned, to end up with a complex tree-structure as described in the issue, one can put DynamoDB under a huge data load. However, that&apos;s inconvenient for manual testing purposes. Fortunately, there&apos;s a trick one can do:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;create a brand new DynamoDB table with provisioned capacity.&lt;/li&gt;
	&lt;li&gt;enable streams.&lt;/li&gt;
	&lt;li&gt;add one or two items in it.&lt;/li&gt;
	&lt;li&gt;at that point, you should have a &quot;tree&quot; with exactly one shard.&lt;/li&gt;
	&lt;li&gt;switch the table to On-demand provisioning.&lt;/li&gt;
	&lt;li&gt;wait a few minutes.&lt;/li&gt;
	&lt;li&gt;you&apos;ll notice that the two new shards have been added, children of the first one. Your tree structure is starting to grow!&lt;/li&gt;
	&lt;li&gt;wait a few more minutes (we&apos;re talking ~15 minutes in total).&lt;/li&gt;
	&lt;li&gt;you&apos;ll notice that you&apos;ve ended up with 7 shards, in a tree-like structure as depicted in the issue&apos;s description.&lt;/li&gt;
	&lt;li&gt;adding new items will place them in any of the four leaf shards.&lt;/li&gt;
&lt;/ol&gt;


&lt;hr /&gt;
&lt;p&gt;I&apos;ve somewhat followed the caching approach of the previous implementation. Indeed, it would probably be quite bad for performance to issue a new &lt;tt&gt;ListStreamsRequest&lt;/tt&gt; and parse the shard tree on every single Camel poll.&lt;/p&gt;

&lt;p&gt;However, this leads to a potential race condition edge-case when the tree is rebalanced. In step 7 above, I&apos;ve not observed what actually happens underneath the hood, but I believe the initial shard is assigned an end sequence number, and one child shard is added. A second child shard is added a little later to the inactive parent shard. My revised implementation will see that the initial shard is no longer active (the returned shard iterator will be null) and will reload the entire shard tree as it no longer has any active shards cached. It will then see the first child, but potentially not the second one depending on whether Camel polls in that transient one-child state or not. You may end up in a situation where you&apos;ll be missing updates from the second child until the first child itself becomes inactive.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;In addition to the performance hit, assuming that new branches can arbitrarily grow from inactive parent nodes would require more complex logic. I believe that tree rebalancing is a rare event in DynamoDB, so in my opinion improved performance and simpler code is worth the trade-off.&lt;/p&gt;</comment>
                            <comment id="17419153" author="ancosen" created="Thu, 23 Sep 2021 11:51:16 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Pyves&quot; class=&quot;user-hover&quot; rel=&quot;Pyves&quot;&gt;Pyves&lt;/a&gt; the PR has been merged.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="13025159" name="shards.json" size="2780" author="Pyves" created="Fri, 7 May 2021 12:53:18 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310060" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Estimated Complexity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10063"><![CDATA[Advanced]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 7 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z0qtpc:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>