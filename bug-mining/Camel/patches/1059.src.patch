diff --git a/camel-core/src/main/java/org/apache/camel/management/JmxNotificationEventNotifier.java b/camel-core/src/main/java/org/apache/camel/management/JmxNotificationEventNotifier.java
index 19fe4c75cb6..7a92416d779 100644
--- a/camel-core/src/main/java/org/apache/camel/management/JmxNotificationEventNotifier.java
+++ b/camel-core/src/main/java/org/apache/camel/management/JmxNotificationEventNotifier.java
@@ -16,26 +16,11 @@
  */
 package org.apache.camel.management;
 
-import java.util.ArrayList;
 import java.util.EventObject;
-import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
-import javax.management.Attribute;
-import javax.management.AttributeList;
-import javax.management.AttributeNotFoundException;
-import javax.management.DynamicMBean;
-import javax.management.InvalidAttributeValueException;
-import javax.management.MBeanAttributeInfo;
-import javax.management.MBeanConstructorInfo;
-import javax.management.MBeanException;
-import javax.management.MBeanInfo;
-import javax.management.MBeanNotificationInfo;
-import javax.management.MBeanOperationInfo;
 import javax.management.Notification;
 import javax.management.NotificationBroadcasterSupport;
-import javax.management.ReflectionException;
 
-import org.apache.camel.Service;
 import org.apache.camel.spi.EventNotifier;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -46,26 +31,24 @@ import org.apache.commons.logging.LogFactory;
  * @version $Revision$
  */
 public class JmxNotificationEventNotifier extends EventNotifierSupport implements JmxNotificationBroadcasterAware {
-
-    private static final Log LOG = LogFactory.getLog(JmxNotificationEventNotifier.class);
+    private static final transient Log LOG = LogFactory.getLog(JmxNotificationEventNotifier.class);
     private final AtomicLong counter = new AtomicLong();
-    private NotificationBroadcasterSupport notificationBroadcaseter;
-    
+    private NotificationBroadcasterSupport notificationBroadcaster;
     
-    public void setNotificationBroadcaster(NotificationBroadcasterSupport broadcaseter) {
-        notificationBroadcaseter = broadcaseter;
+    public void setNotificationBroadcaster(NotificationBroadcasterSupport broadcaster) {
+        notificationBroadcaster = broadcaster;
     }
 
     public void notify(EventObject event) throws Exception {
-        // use simple class name as the type
-        String type = event.getClass().getSimpleName();
-        Notification notification = new Notification(type, event, counter.getAndIncrement());
+        if (notificationBroadcaster != null) {
+            // use simple class name as the type
+            String type = event.getClass().getSimpleName();
+            Notification notification = new Notification(type, event, counter.getAndIncrement());
 
-        if (LOG.isTraceEnabled()) {
-            LOG.trace("Broadcasting JMX notification " + notification);
-        }
-        if (notificationBroadcaseter != null) {
-            notificationBroadcaseter.sendNotification(notification);
+            if (LOG.isTraceEnabled()) {
+                LOG.trace("Broadcasting JMX notification: " + notification);
+            }
+            notificationBroadcaster.sendNotification(notification);
         }
     }
 
@@ -73,14 +56,11 @@ public class JmxNotificationEventNotifier extends EventNotifierSupport implement
         return true;
     }
 
-    @Override
     protected void doStart() throws Exception {
         counter.set(0);
     }
 
-    @Override
     protected void doStop() throws Exception {
-        // TODO Auto-generated method stub
-        
+        // noop
     }
 }
diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
index 02d7ca0bdbc..59f775e223f 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
@@ -75,9 +75,7 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
 
     private static final Log LOG = LogFactory.getLog(AggregateProcessor.class);
 
-    // use a fair lock so timeout checker will have a chance to acquire the lock if
-    // a lot of new messages keep arriving
-    private final Lock lock = new ReentrantLock(true);
+    private final Lock lock = new ReentrantLock();
     private final CamelContext camelContext;
     private final Processor processor;
     private final AggregationStrategy aggregationStrategy;
@@ -90,6 +88,7 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
     private AggregationRepository aggregationRepository = new MemoryAggregationRepository();
     private Map<Object, Object> closedCorrelationKeys;
     private Set<String> batchConsumerCorrelationKeys = new LinkedHashSet<String>();
+    private Set<String> arrivedCorrelationKeys = new LinkedHashSet<String>();
     private final Set<String> inProgressCompleteExchanges = new HashSet<String>();
     private final Map<String, RedeliveryData> redeliveryState = new ConcurrentHashMap<String, RedeliveryData>();
     // optional dead letter channel for exhausted recovered exchanges
@@ -179,8 +178,11 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
         // improve performance as we can run aggregation repository get/add in parallel
         lock.lock();
         try {
+            // keep track on the arrived keys
+            arrivedCorrelationKeys.add(key);
             doAggregation(key, exchange);
         } finally {
+            arrivedCorrelationKeys.remove(key);
             lock.unlock();
         }
     }
@@ -194,6 +196,7 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
      * @param key      the correlation key
      * @param exchange the exchange
      * @return the aggregated exchange
+     * @throws org.apache.camel.CamelExchangeException is thrown if error aggregating
      */
     private Exchange doAggregation(String key, Exchange exchange) throws CamelExchangeException {
         if (LOG.isTraceEnabled()) {
@@ -379,11 +382,8 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
 
                 try {
                     processor.process(exchange);
-                } catch (Exception e) {
+                } catch (Throwable e) {
                     exchange.setException(e);
-                } catch (Throwable t) {
-                    // must catch throwable so we will handle all exceptions as the executor service will by default ignore them
-                    exchange.setException(new CamelExchangeException("Error processing aggregated exchange", exchange, t));
                 }
 
                 // log exception if there was a problem
@@ -556,18 +556,27 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
         }
 
         @Override
-        public void onEviction(String key, String exchangeId) {
+        public boolean onEviction(String key, String exchangeId) {
             if (log.isDebugEnabled()) {
                 log.debug("Completion timeout triggered for correlation key: " + key);
             }
 
-            // double check that its not already in progress
+            // double check that its not already arrived or in progress
+            boolean arrived = arrivedCorrelationKeys.contains(key);
+            if (arrived) {
+                if (LOG.isTraceEnabled()) {
+                    LOG.trace("A new Exchange with correlation key: " + key + " has just arrived,"
+                        + " which postpones the timeout condition for aggregated exchange id: " + exchangeId);
+                }
+                // do not evict the entry as a new exchange has arrived with the same correlation key
+                return false;
+            }
             boolean inProgress = inProgressCompleteExchanges.contains(exchangeId);
             if (inProgress) {
                 if (LOG.isTraceEnabled()) {
                     LOG.trace("Aggregated exchange with id: " + exchangeId + " is already in progress.");
                 }
-                return;
+                return true;
             }
 
             // get the aggregated exchange
@@ -582,6 +591,7 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
             // and running the on completion logic can occur concurrently, its just the aggregation logic
             // which is preferred to run non concurrent.
             onCompletion(key, answer, true);
+            return true;
         }
     }
 
@@ -612,11 +622,11 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
                             LOG.trace("Completion interval triggered for correlation key: " + key);
                         }
                         Exchange exchange = aggregationRepository.get(camelContext, key);
-
-                        // indicate it was completed by interval
-                        exchange.setProperty(Exchange.AGGREGATED_COMPLETED_BY, "interval");
-
-                        onCompletion(key, exchange, false);
+                        if (exchange != null) {
+                            // indicate it was completed by interval
+                            exchange.setProperty(Exchange.AGGREGATED_COMPLETED_BY, "interval");
+                            onCompletion(key, exchange, false);
+                        }
                     }
                 } finally {
                     lock.unlock();
@@ -687,7 +697,7 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
                                 exchange.getIn().setHeader(Exchange.REDELIVERY_COUNTER, data.redeliveryCounter);
                                 exchange.getIn().setHeader(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE);
                                 deadLetterProcessor.process(exchange);
-                            } catch (Exception e) {
+                            } catch (Throwable e) {
                                 exchange.setException(e);
                             }
 
@@ -808,6 +818,7 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
         }
         batchConsumerCorrelationKeys.clear();
         redeliveryState.clear();
+        arrivedCorrelationKeys.clear();
     }
 
     @Override
diff --git a/camel-core/src/main/java/org/apache/camel/util/DefaultTimeoutMap.java b/camel-core/src/main/java/org/apache/camel/util/DefaultTimeoutMap.java
index 58f49418115..7bb72bb1f95 100644
--- a/camel-core/src/main/java/org/apache/camel/util/DefaultTimeoutMap.java
+++ b/camel-core/src/main/java/org/apache/camel/util/DefaultTimeoutMap.java
@@ -160,15 +160,20 @@ public class DefaultTimeoutMap<K, V> implements TimeoutMap<K, V>, Runnable, Serv
                     }
                 });
 
+                List<K> evicts = new ArrayList<K>(expired.size());
                 try {
                     // now fire eviction notification
                     for (TimeoutMapEntry<K, V> entry : expired) {
-                        onEviction(entry.getKey(), entry.getValue());
+                        boolean evict = onEviction(entry.getKey(), entry.getValue());
+                        if (evict) {
+                            // okay this entry should be evicted
+                            evicts.add(entry.getKey());
+                        }
                     }
                 } finally {
                     // and must remove from list after we have fired the notifications
-                    for (TimeoutMapEntry<K, V> entry : expired) {
-                        map.remove(entry.getKey());
+                    for (K key : evicts) {
+                        map.remove(key);
                     }
                 }
             }
@@ -207,8 +212,8 @@ public class DefaultTimeoutMap<K, V> implements TimeoutMap<K, V>, Runnable, Serv
         return true;
     }
 
-    public void onEviction(K key, V value) {
-        // noop
+    public boolean onEviction(K key, V value) {
+        return true;
     }
 
     protected void updateExpireTime(TimeoutMapEntry entry) {
diff --git a/camel-core/src/main/java/org/apache/camel/util/TimeoutMap.java b/camel-core/src/main/java/org/apache/camel/util/TimeoutMap.java
index cafe852e8d4..1da17ce69d2 100644
--- a/camel-core/src/main/java/org/apache/camel/util/TimeoutMap.java
+++ b/camel-core/src/main/java/org/apache/camel/util/TimeoutMap.java
@@ -17,8 +17,7 @@
 package org.apache.camel.util;
 
 /**
- * Represents a thread safe map of values which timeout after a period of
- * inactivity.
+ * Represents a thread safe map of values which timeout after a period of inactivity.
  *
  * @version $Revision$
  */
@@ -61,8 +60,9 @@ public interface TimeoutMap<K, V> extends Runnable {
      *
      * @param key the key
      * @param value the value
+     * @return <tt>true</tt> to remove the evicted value, or <tt>false</tt> to veto the veto and thus keep the value.
      */
-    void onEviction(K key, V value);
+    boolean onEviction(K key, V value);
 
     /**
      * Removes the object with the given key
diff --git a/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateFromWireTapTest.java b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateFromWireTapTest.java
index 5a985665ebd..a1c7ff48a0e 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateFromWireTapTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateFromWireTapTest.java
@@ -20,7 +20,6 @@ import org.apache.camel.ContextTestSupport;
 import org.apache.camel.Exchange;
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.component.mock.MockEndpoint;
-import org.apache.camel.processor.BodyInAggregatingStrategy;
 import org.apache.camel.processor.aggregate.AggregationStrategy;
 
 public class AggregateFromWireTapTest extends ContextTestSupport {
@@ -30,12 +29,16 @@ public class AggregateFromWireTapTest extends ContextTestSupport {
         end.expectedBodiesReceived("A", "B");
 
         MockEndpoint aggregated = getMockEndpoint("mock:aggregated");
-        aggregated.expectedBodiesReceived("AB");
+        aggregated.expectedMessageCount(1);
 
         template.sendBody("direct:start", "A");
         template.sendBody("direct:start", "B");
 
         assertMockEndpointsSatisfied();
+
+        String body = aggregated.getReceivedExchanges().get(0).getIn().getBody(String.class);
+        // should be either AB or BA (wiretap can be run out of order)
+        assertTrue("Should be AB or BA, was: " + body, "AB".equals(body) || "BA".equals(body));
     }
 
     @Override
diff --git a/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregatorTest.java b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregatorTest.java
index f8c368708db..f3cb6baf0ef 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregatorTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregatorTest.java
@@ -92,8 +92,6 @@ public class AggregatorTest extends ContextTestSupport {
                     .aggregate(header("cheese"), new MyAggregationStrategy())
                         .eagerCheckCompletion()
                         .completionPredicate(header("bar").isEqualTo("viper bar"))
-                        // or complete with a timeout
-                        .completionTimeout(1000L)
                         .to("mock:result");
                 // END SNIPPET: ex
             }
diff --git a/camel-core/src/test/java/org/apache/camel/util/DefaultTimeoutMapTest.java b/camel-core/src/test/java/org/apache/camel/util/DefaultTimeoutMapTest.java
index c0d9071d699..60157fce959 100644
--- a/camel-core/src/test/java/org/apache/camel/util/DefaultTimeoutMapTest.java
+++ b/camel-core/src/test/java/org/apache/camel/util/DefaultTimeoutMapTest.java
@@ -126,9 +126,10 @@ public class DefaultTimeoutMapTest extends TestCase {
 
         DefaultTimeoutMap<String, Integer> map = new DefaultTimeoutMap<String, Integer>() {
             @Override
-            public void onEviction(String key, Integer value) {
+            public boolean onEviction(String key, Integer value) {
                 keys.add(key);
                 values.add(value);
+                return true;
             }
         };
         assertEquals(0, map.size());
@@ -160,4 +161,44 @@ public class DefaultTimeoutMapTest extends TestCase {
         assertEquals(1, map.size());
     }
 
+    public void testExpiredNotEvicted() throws Exception {
+        final List<String> keys = new ArrayList<String>();
+        final List<Integer> values = new ArrayList<Integer>();
+
+        DefaultTimeoutMap<String, Integer> map = new DefaultTimeoutMap<String, Integer>() {
+            @Override
+            public boolean onEviction(String key, Integer value) {
+                // do not evict special key
+                if ("gold".equals(key)) {
+                    return false;
+                }
+                keys.add(key);
+                values.add(value);
+                return true;
+            }
+        };
+        assertEquals(0, map.size());
+
+        map.put("A", 1, 900);
+        map.put("B", 2, 1000);
+        map.put("gold", 9, 1100);
+        map.put("C", 3, 1200);
+
+        Thread.sleep(2000);
+
+        // force purge
+        map.purge();
+
+        assertEquals("A", keys.get(0));
+        assertEquals(1, values.get(0).intValue());
+        assertEquals("B", keys.get(1));
+        assertEquals(2, values.get(1).intValue());
+        assertEquals("C", keys.get(2));
+        assertEquals(3, values.get(2).intValue());
+
+        // and keep the gold in the map
+        assertEquals(1, map.size());
+        assertEquals(Integer.valueOf(9), map.get("gold"));
+    }
+
 }
