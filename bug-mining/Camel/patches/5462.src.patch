diff --git a/core/camel-api/src/main/java/org/apache/camel/StreamCacheException.java b/core/camel-api/src/main/java/org/apache/camel/StreamCacheException.java
new file mode 100644
index 00000000000..6fa8fd3ab80
--- /dev/null
+++ b/core/camel-api/src/main/java/org/apache/camel/StreamCacheException.java
@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel;
+
+public class StreamCacheException extends TypeConversionException {
+
+    public StreamCacheException(Object value, Throwable cause) {
+        super(value, StreamCache.class, cause);
+    }
+}
diff --git a/core/camel-base/src/main/java/org/apache/camel/processor/CamelInternalProcessor.java b/core/camel-base/src/main/java/org/apache/camel/processor/CamelInternalProcessor.java
index d244cc871b2..d872bf62b1f 100644
--- a/core/camel-base/src/main/java/org/apache/camel/processor/CamelInternalProcessor.java
+++ b/core/camel-base/src/main/java/org/apache/camel/processor/CamelInternalProcessor.java
@@ -35,6 +35,7 @@ import org.apache.camel.Processor;
 import org.apache.camel.Route;
 import org.apache.camel.StatefulService;
 import org.apache.camel.StreamCache;
+import org.apache.camel.StreamCacheException;
 import org.apache.camel.processor.interceptor.BacklogDebugger;
 import org.apache.camel.processor.interceptor.BacklogTracer;
 import org.apache.camel.processor.interceptor.DefaultBacklogTracerEventMessage;
@@ -798,11 +799,25 @@ public class CamelInternalProcessor extends DelegateAsyncProcessor {
                 return sc;
             }
             // cache the body and if we could do that replace it as the new body
-            StreamCache sc = strategy.cache(exchange);
-            if (sc != null) {
-                exchange.getIn().setBody(sc);
+            boolean failed = exchange.getException(StreamCacheException.class) != null
+                    || exchange.getProperty(Exchange.EXCEPTION_CAUGHT, StreamCacheException.class) != null;
+            if (!failed) {
+                try {
+                    StreamCache sc = strategy.cache(exchange);
+                    if (sc != null) {
+                        exchange.getIn().setBody(sc);
+                    }
+                    return sc;
+                } catch (Exception e) {
+                    // lets allow Camels error handler to deal with stream cache failures
+                    StreamCacheException tce = new StreamCacheException(exchange.getMessage().getBody(), e);
+                    exchange.setException(tce);
+                    // because this is stream caching error then we cannot use redelivery as the message body is corrupt
+                    // so mark as redelivery exhausted
+                    exchange.adapt(ExtendedExchange.class).setRedeliveryExhausted(true);
+                }
             }
-            return sc;
+            return null;
         }
 
         @Override
diff --git a/core/camel-core/src/test/java/org/apache/camel/processor/StreamCacheInternalErrorTest.java b/core/camel-core/src/test/java/org/apache/camel/processor/StreamCacheInternalErrorTest.java
new file mode 100644
index 00000000000..ec84f24c684
--- /dev/null
+++ b/core/camel-core/src/test/java/org/apache/camel/processor/StreamCacheInternalErrorTest.java
@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import java.io.ByteArrayInputStream;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.StreamCache;
+import org.apache.camel.TypeConversionException;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.converter.stream.ByteArrayInputStreamCache;
+import org.apache.camel.support.TypeConverterSupport;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+public class StreamCacheInternalErrorTest extends ContextTestSupport {
+
+    private BodyToStreamCacheConverter converter = new BodyToStreamCacheConverter();
+
+    @Test
+    public void testOk() throws Exception {
+        converter.reset();
+
+        getMockEndpoint("mock:a").expectedBodiesReceived("Hello World");
+        getMockEndpoint("mock:a").message(0).body().isInstanceOf(StreamCache.class);
+        getMockEndpoint("mock:b").expectedBodiesReceived("Hello World");
+        getMockEndpoint("mock:b").message(0).body().isInstanceOf(StreamCache.class);
+        getMockEndpoint("mock:c").expectedBodiesReceived("Hello World");
+        getMockEndpoint("mock:c").message(0).body().isInstanceOf(StreamCache.class);
+        getMockEndpoint("mock:result").expectedBodiesReceived("Hello World");
+        getMockEndpoint("mock:result").message(0).body().isInstanceOf(StreamCache.class);
+        getMockEndpoint("mock:exception").expectedMessageCount(0);
+
+        template.sendBody("direct:start", new MyBody("Hello World"));
+
+        assertMockEndpointsSatisfied();
+
+        Assertions.assertEquals(1, converter.getInvoked());
+    }
+
+    @Test
+    public void testError() throws Exception {
+        converter.reset();
+
+        getMockEndpoint("mock:a").expectedMessageCount(0);
+        getMockEndpoint("mock:b").expectedMessageCount(0);
+        getMockEndpoint("mock:c").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:error").expectedMessageCount(1);
+        getMockEndpoint("mock:error").message(0).body().isInstanceOf(MyBody.class);
+        getMockEndpoint("mock:exception").message(0).body().contains(
+                "Handled big error due to Error during type conversion from type: org.apache.camel.processor.StreamCacheInternalErrorTest.MyBody");
+        getMockEndpoint("mock:exception").message(0).body().contains("Kaboom");
+
+        template.sendBody("direct:start", new MyBody("Kaboom"));
+
+        assertMockEndpointsSatisfied();
+
+        Assertions.assertEquals(1, converter.getInvoked());
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            public void configure() {
+                context.getTypeConverterRegistry().addTypeConverter(StreamCache.class, MyBody.class, converter);
+
+                // enable support for stream caching
+                context.setStreamCaching(true);
+
+                onException(Exception.class)
+                        .maximumRedeliveries(2)
+                        .handled(true)
+                        .to("mock:error")
+                        .setBody(simple("Handled big error due to ${exception.message}"))
+                        .to("mock:exception");
+
+                from("direct:start").tracing()
+                        .to("mock:a")
+                        .to("mock:b")
+                        .to("mock:c")
+                        .to("mock:result");
+            }
+        };
+    }
+
+    private class BodyToStreamCacheConverter extends TypeConverterSupport {
+
+        private int invoked;
+
+        @Override
+        public <T> T convertTo(Class<T> type, Exchange exchange, Object value) throws TypeConversionException {
+            invoked++;
+
+            String str = value.toString();
+            if ("Kaboom".equals(str)) {
+                throw new IllegalArgumentException("Kaboom");
+            } else {
+                byte[] data = str.getBytes();
+                return (T) new ByteArrayInputStreamCache(new ByteArrayInputStream(data));
+            }
+        }
+
+        public int getInvoked() {
+            return invoked;
+        }
+
+        public void reset() {
+            invoked = 0;
+        }
+    }
+
+    private class MyBody {
+        private String body;
+
+        public MyBody(String body) {
+            this.body = body;
+        }
+
+        @Override
+        public String toString() {
+            return body;
+        }
+    }
+}
diff --git a/docs/user-manual/modules/ROOT/pages/camel-3x-upgrade-guide-3_6.adoc b/docs/user-manual/modules/ROOT/pages/camel-3x-upgrade-guide-3_6.adoc
index 916c22920a8..893bd66cfca 100644
--- a/docs/user-manual/modules/ROOT/pages/camel-3x-upgrade-guide-3_6.adoc
+++ b/docs/user-manual/modules/ROOT/pages/camel-3x-upgrade-guide-3_6.adoc
@@ -172,6 +172,11 @@ You will see an exception about `camel-core-catalog` not found on classpath othe
 The API in `org.apache.camel.spi.SendDynamicAware` has changed and any custom implementations must be updated accordingly.
 There is a new abstract `org.apache.camel.support.component.SendDynamicAwareSupport` class which can be used as base for custom implementations.
 
+=== Stream Caching
+
+If stream caching is enabled and an exception is thrown while converting the message payload to `StreamCache` then the error handler
+can now handle this exception (eg onException). The exception is regard as non-recoverable and redelivery is not in use.
+
 === Camel Caffeine
 
 To configure the component to use a pre-configured cache, it is not more required to use the now removed `cache` option as the component perorm a look-up from the registry based on the `cacheName` URI param.
