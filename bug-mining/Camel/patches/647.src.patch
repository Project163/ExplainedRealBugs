diff --git a/camel-core/src/main/java/org/apache/camel/management/InstrumentationLifecycleStrategy.java b/camel-core/src/main/java/org/apache/camel/management/InstrumentationLifecycleStrategy.java
index 39a75a8d3f8..94f0fcccda2 100644
--- a/camel-core/src/main/java/org/apache/camel/management/InstrumentationLifecycleStrategy.java
+++ b/camel-core/src/main/java/org/apache/camel/management/InstrumentationLifecycleStrategy.java
@@ -272,6 +272,10 @@ public class InstrumentationLifecycleStrategy implements LifecycleStrategy {
 
                 return wrapper;
             }
+
+            public String toString() {
+                return "Instrument";
+            }
         });
 
     }
diff --git a/camel-core/src/main/java/org/apache/camel/model/ChoiceDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ChoiceDefinition.java
index a9a7f669578..aba33f678d3 100644
--- a/camel-core/src/main/java/org/apache/camel/model/ChoiceDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/ChoiceDefinition.java
@@ -33,8 +33,6 @@ import org.apache.camel.processor.ChoiceProcessor;
 import org.apache.camel.processor.FilterProcessor;
 import org.apache.camel.spi.RouteContext;
 import org.apache.camel.util.CollectionStringBuffer;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 
 /**
  * Represents an XML &lt;choice/&gt; element
@@ -44,8 +42,7 @@ import org.apache.commons.logging.LogFactory;
 @XmlRootElement(name = "choice")
 @XmlAccessorType(XmlAccessType.FIELD)
 public class ChoiceDefinition extends ProcessorDefinition<ChoiceDefinition> {
-    private static final transient Log LOG = LogFactory.getLog(ChoiceDefinition.class);
-    
+
     @XmlElementRef
     private List<WhenDefinition> whenClauses = new ArrayList<WhenDefinition>();
     @XmlElement(required = false)
@@ -74,8 +71,6 @@ public class ChoiceDefinition extends ProcessorDefinition<ChoiceDefinition> {
         Processor otherwiseProcessor = null;
         if (otherwise != null) {
             otherwiseProcessor = otherwise.createProcessor(routeContext);
-        } else {
-            LOG.warn("No otherwise clause was specified for this choice block: " + this + ", any unmatched exchanges will be dropped.");
         }
         return new ChoiceProcessor(filters, otherwiseProcessor);
     }
@@ -157,4 +152,5 @@ public class ChoiceDefinition extends ProcessorDefinition<ChoiceDefinition> {
     public void setOtherwise(OtherwiseDefinition otherwise) {
         this.otherwise = otherwise;
     }
+
 }
diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java
index 4a031536ba1..48cc67fddbe 100644
--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java
@@ -714,9 +714,16 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition> exte
      */
     @SuppressWarnings("unchecked")
     public ProcessorDefinition<? extends ProcessorDefinition> end() {
+        // when using doTry .. doCatch .. doFinally we should always
+        // end the try definition to avoid having to use 2 x end() in the route
+        // this is counter intuitive for end users
+        if (this instanceof TryDefinition) {
+            popBlock();
+        }
+
         if (blocks.isEmpty()) {
             if (parent == null) {
-                throw new IllegalArgumentException("Root node with no active block");
+                return this; 
             }
             return parent;
         }
diff --git a/camel-core/src/main/java/org/apache/camel/model/TryDefinition.java b/camel-core/src/main/java/org/apache/camel/model/TryDefinition.java
index e059be92627..0d42ca595b6 100644
--- a/camel-core/src/main/java/org/apache/camel/model/TryDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/TryDefinition.java
@@ -101,6 +101,19 @@ public class TryDefinition extends OutputDefinition<TryDefinition> {
         return this;
     }
 
+    /**
+     * The finally block for a given handle
+     *
+     * @return  the try builder
+     */
+    public TryDefinition doFinally() {
+        popBlock();
+        FinallyDefinition answer = new FinallyDefinition();
+        addOutput(answer);
+        pushBlock(answer);
+        return this;
+    }
+
     /**
      * Sets an additional predicate that should be true before the onCatch is triggered.
      * <p/>
@@ -186,25 +199,6 @@ public class TryDefinition extends OutputDefinition<TryDefinition> {
         return handled(toPredicate(handled));
     }
 
-    /**
-     * The finally block for a given handle
-     *
-     * @return  the try builder
-     */
-    public TryDefinition doFinally() {
-        popBlock();
-        FinallyDefinition answer = new FinallyDefinition();
-        addOutput(answer);
-        pushBlock(answer);
-        return this;
-    }
-
-    @Override
-    public ProcessorDefinition<? extends ProcessorDefinition> end() {
-        popBlock();
-        return super.end();
-    }
-
     // Properties
     // -------------------------------------------------------------------------
 
diff --git a/camel-core/src/test/java/org/apache/camel/processor/ChoiceWithEndTest.java b/camel-core/src/test/java/org/apache/camel/processor/ChoiceWithEndTest.java
new file mode 100644
index 00000000000..7aaedd9ef52
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/ChoiceWithEndTest.java
@@ -0,0 +1,126 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import java.util.List;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Navigate;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision$
+ */
+public class ChoiceWithEndTest extends ContextTestSupport {
+
+    public void testRouteIsCorrectAtRuntime() throws Exception {
+        // use navigate to find that the end works as expected
+        Navigate<Processor> nav = context.getRoutes().get(0).navigate();
+        List<Processor> node = nav.next();
+        node = ((Navigate) node.get(0)).next();
+
+        // there should be 4 outputs as the end in the otherwise should
+        // ensure that the transform and last send is not within the choice
+        assertEquals(4, node.size());
+        // the navigate API is a bit simple at this time of writing so it does take a little
+        // bit of ugly code to find the correct processor in the runtime route
+        assertIsInstanceOf(SendProcessor.class, unwrapChannel(node.get(0)).getNextProcessor());
+        assertIsInstanceOf(ChoiceProcessor.class, unwrapChannel(node.get(1)).getNextProcessor());
+        assertIsInstanceOf(TransformProcessor.class, unwrapChannel(node.get(2)).getNextProcessor());
+        assertIsInstanceOf(SendProcessor.class, unwrapChannel(node.get(3)).getNextProcessor());
+    }
+
+    public void testChoiceHello() throws Exception {
+        getMockEndpoint("mock:start").expectedBodiesReceived("Hello World");
+        getMockEndpoint("mock:echo").expectedBodiesReceived("echo Hello World");
+        getMockEndpoint("mock:last").expectedBodiesReceived("last echo Hello World");
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testChoiceBye() throws Exception {
+        getMockEndpoint("mock:start").expectedBodiesReceived("Bye World");
+        getMockEndpoint("mock:bye").expectedBodiesReceived("We do not care");
+        getMockEndpoint("mock:last").expectedBodiesReceived("last We do not care");
+
+        template.sendBody("direct:start", "Bye World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testChoiceOther() throws Exception {
+        getMockEndpoint("mock:start").expectedBodiesReceived("Camel");
+        getMockEndpoint("mock:other").expectedBodiesReceived("other Camel");
+        getMockEndpoint("mock:last").expectedBodiesReceived("last other Camel");
+
+        template.sendBody("direct:start", "Camel");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                MyChoiceBean bean = new MyChoiceBean();
+
+                from("direct:start")
+                    .to("mock:start")
+                    .choice()
+                        .when(body().contains("Hello"))
+                            .bean(bean, "echo").to("mock:echo")
+                        .when(body().contains("Bye"))
+                            // must use another route as the Java DSL
+                            // will lose its scope so you cannot call otherwise later
+                            .to("direct:bye").to("mock:bye")
+                        .otherwise()
+                            .bean(bean, "other").to("mock:other")
+                        .end()
+                    .transform(body().prepend("last "))
+                    .to("mock:last");
+
+                from("direct:bye")
+                    .doTry()
+                        .bean(bean, "bye").to("mock:bye")
+                    .doCatch(Exception.class)
+                        .setBody(constant("We do not care"))
+                    .end();
+            }
+        };
+    }
+
+    public class MyChoiceBean {
+
+        public String echo(String s) {
+            return "echo " + s;
+        }
+
+        public String bye(String s) throws Exception {
+            throw new IllegalArgumentException("Damn does not work");
+        }
+
+        public String other(String s) {
+            return "other " + s;
+        }
+    }
+
+}
+
diff --git a/camel-core/src/test/java/org/apache/camel/processor/SplitShouldSkipFilteredExchanges.java b/camel-core/src/test/java/org/apache/camel/processor/SplitShouldSkipFilteredExchanges.java
index 468446a32b9..25112a8a198 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/SplitShouldSkipFilteredExchanges.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/SplitShouldSkipFilteredExchanges.java
@@ -64,16 +64,15 @@ public class SplitShouldSkipFilteredExchanges extends ContextTestSupport {
                 from("direct:split")
                     .split(body(List.class), new MyAggregationStrategy())
                         .filter(goodWord)
-                        .to("mock:filtered");
+                            .to("mock:filtered");
             }
         };
     }
 
-    private class MyAggregationStrategy implements AggregationStrategy {
+    protected class MyAggregationStrategy implements AggregationStrategy {
 
         public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
             String newBody = newExchange.getIn().getBody(String.class);
-            assertTrue("Should have been filtered: " + newBody, newBody.contains("World"));
 
             if (oldExchange == null) {
                 return newExchange;
diff --git a/camel-core/src/test/java/org/apache/camel/processor/SplitWithEndTest.java b/camel-core/src/test/java/org/apache/camel/processor/SplitWithEndTest.java
new file mode 100644
index 00000000000..822a8150311
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/SplitWithEndTest.java
@@ -0,0 +1,97 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import java.util.List;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Navigate;
+import org.apache.camel.Processor;
+import org.apache.camel.Exchange;
+import org.apache.camel.processor.aggregate.AggregationStrategy;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision$
+ */
+public class SplitWithEndTest extends ContextTestSupport {
+
+    public void testRouteIsCorrectAtRuntime() throws Exception {
+        // use navigate to find that the end works as expected
+        Navigate<Processor> nav = context.getRoutes().get(0).navigate();
+        List<Processor> node = nav.next();
+        node = ((Navigate) node.get(0)).next();
+
+        // there should be 4 outputs as the end in the otherwise should
+        // ensure that the transform and last send is not within the choice
+        assertEquals(4, node.size());
+        // the navigate API is a bit simple at this time of writing so it does take a little
+        // bit of ugly code to find the correct processor in the runtime route
+        assertIsInstanceOf(SendProcessor.class, unwrapChannel(node.get(0)).getNextProcessor());
+        assertIsInstanceOf(Splitter.class, unwrapChannel(node.get(1)).getNextProcessor());
+        assertIsInstanceOf(TransformProcessor.class, unwrapChannel(node.get(2)).getNextProcessor());
+        assertIsInstanceOf(SendProcessor.class, unwrapChannel(node.get(3)).getNextProcessor());
+    }
+
+    public void testSplit() throws Exception {
+        getMockEndpoint("mock:start").expectedBodiesReceived("Hello,World");
+        getMockEndpoint("mock:last").expectedBodiesReceived("last hi Hello@hi World");
+
+        template.sendBody("direct:start", "Hello,World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                MySplitBean bean = new MySplitBean();
+
+                from("direct:start")
+                    .to("mock:start")
+                    .split(body().tokenize(","),
+                            new AggregationStrategy() {
+                                public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
+                                    if (oldExchange == null) {
+                                        return newExchange;
+                                    }
+                                    String body = oldExchange.getIn().getBody(String.class);
+                                    String newBody = newExchange.getIn().getBody(String.class);
+                                    newExchange.getIn().setBody(body + "@" + newBody);
+                                    return newExchange;
+                                }
+                            })
+                        .bean(bean, "hi").to("mock:split")
+                    .end()
+                    .transform(body().prepend("last "))
+                    .to("mock:last");
+            }
+        };
+    }
+
+    public class MySplitBean {
+
+        public String hi(String s) {
+            return "hi " + s;
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/camel-core/src/test/java/org/apache/camel/processor/SplitWithNestedFilterShouldSkipFilteredExchanges.java b/camel-core/src/test/java/org/apache/camel/processor/SplitWithNestedFilterShouldSkipFilteredExchanges.java
new file mode 100644
index 00000000000..9f1d99a69a1
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/SplitWithNestedFilterShouldSkipFilteredExchanges.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import java.util.List;
+
+import org.apache.camel.Predicate;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * Unit test to verify that Splitter aggregator does not included filtered exchanges.
+ *
+ * @version $Revision$
+ */
+public class SplitWithNestedFilterShouldSkipFilteredExchanges extends SplitShouldSkipFilteredExchanges {
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                Predicate goodWord = body().contains("World");
+
+                from("direct:start")
+                    .split(body(List.class), new MyAggregationStrategy())
+                        .to("mock:split")
+                        .filter(goodWord)
+                            .to("mock:filtered")
+                        .end()
+                    .end()
+                .to("mock:result");
+            }
+        };
+    }
+
+}
\ No newline at end of file
diff --git a/camel-core/src/test/java/org/apache/camel/processor/TryProcessorTest.java b/camel-core/src/test/java/org/apache/camel/processor/TryProcessorTest.java
index 70b5c45dfd2..f163848522e 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/TryProcessorTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/TryProcessorTest.java
@@ -33,6 +33,7 @@ public class TryProcessorTest extends ContextTestSupport {
         MockEndpoint mock = getMockEndpoint("mock:result");
         mock.expectedMessageCount(0);
 
+        getMockEndpoint("mock:last").expectedMessageCount(1);
         getMockEndpoint("mock:finally").expectedMessageCount(1);
 
         sendBody("direct:start", "<test>Hello World!</test>");
@@ -52,7 +53,8 @@ public class TryProcessorTest extends ContextTestSupport {
                         .process(new ProcessorHandle())
                     .doFinally()
                         .to("mock:finally")
-                    .end();
+                    .end()
+                    .to("mock:last");
             }
         };
     }
diff --git a/camel-core/src/test/java/org/apache/camel/processor/intercept/InterceptFromWhenWithChoiceTest.java b/camel-core/src/test/java/org/apache/camel/processor/intercept/InterceptFromWhenWithChoiceTest.java
index cffbaa02250..95da1627d5d 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/intercept/InterceptFromWhenWithChoiceTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/intercept/InterceptFromWhenWithChoiceTest.java
@@ -68,7 +68,7 @@ public class InterceptFromWhenWithChoiceTest extends ContextTestSupport {
                     .when(toPredicate(simple("${body} contains 'Goofy'")))
                         .choice()
                             .when(body().contains("Hello")).to("mock:hello")
-                            .otherwise().to("mock:goofy")
+                            .otherwise().to("log:foo").to("mock:goofy")
                         .end()
                     .stop();
 
diff --git a/components/camel-spring/src/test/java/org/apache/camel/spring/processor/SpringComplexBlockWithEndTest.java b/components/camel-spring/src/test/java/org/apache/camel/spring/processor/SpringComplexBlockWithEndTest.java
new file mode 100644
index 00000000000..e0a3b9a5c90
--- /dev/null
+++ b/components/camel-spring/src/test/java/org/apache/camel/spring/processor/SpringComplexBlockWithEndTest.java
@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.spring.processor;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.processor.AggregatorTest;
+import org.apache.camel.processor.aggregate.AggregationStrategy;
+import static org.apache.camel.spring.processor.SpringTestHelper.createSpringCamelContext;
+
+/**
+ * @version $Revision$
+ */
+public class SpringComplexBlockWithEndTest extends ContextTestSupport {
+
+    public void testHello() throws Exception {
+        getMockEndpoint("mock:hello").expectedMessageCount(1);
+        getMockEndpoint("mock:bye").expectedMessageCount(0);
+        getMockEndpoint("mock:otherwise").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedMessageCount(1);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testBye() throws Exception {
+        getMockEndpoint("mock:hello").expectedMessageCount(0);
+        getMockEndpoint("mock:bye").expectedMessageCount(1);
+        getMockEndpoint("mock:otherwise").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedMessageCount(1);
+
+        template.sendBody("direct:start", "Bye World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOther() throws Exception {
+        getMockEndpoint("mock:hello").expectedMessageCount(0);
+        getMockEndpoint("mock:bye").expectedMessageCount(0);
+        getMockEndpoint("mock:otherwise").expectedMessageCount(1);
+        getMockEndpoint("mock:trapped").expectedMessageCount(1);
+        getMockEndpoint("mock:result").expectedBodiesReceived("Cowboys");
+        getMockEndpoint("mock:split").expectedBodiesReceived("Hi The good", "Hi The ugly");
+
+        template.sendBody("direct:start", "The good,The bad,The ugly");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    protected CamelContext createCamelContext() throws Exception {
+        return createSpringCamelContext(this, "org/apache/camel/spring/processor/SpringComplexBlockWithEndTest.xml");
+    }
+
+    public static class SplitAggregate implements AggregationStrategy {
+
+        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
+            newExchange.getOut().setBody("Cowboys");
+            return newExchange;
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/components/camel-spring/src/test/resources/org/apache/camel/spring/processor/SpringComplexBlockWithEndTest.xml b/components/camel-spring/src/test/resources/org/apache/camel/spring/processor/SpringComplexBlockWithEndTest.xml
new file mode 100644
index 00000000000..c393acc978e
--- /dev/null
+++ b/components/camel-spring/src/test/resources/org/apache/camel/spring/processor/SpringComplexBlockWithEndTest.xml
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<beans xmlns="http://www.springframework.org/schema/beans"
+       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+       xsi:schemaLocation="
+       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
+       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
+    ">
+
+    <camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
+        <route>
+            <from uri="direct:start"/>
+            <choice>
+                <when>
+                    <simple>${in.body} contains 'Hello'</simple>
+                    <pipeline>
+                        <to uri="log:hello"/>
+                        <to uri="mock:hello"/>
+                    </pipeline>
+                </when>
+                <when>
+                    <simple>${in.body} contains 'Bye'</simple>
+                    <multicast parallelProcessing="true">
+                        <to uri="log:bye"/>
+                        <to uri="mock:bye"/>
+                    </multicast>
+                </when>
+                <otherwise>
+                    <to uri="log:otherwise"/>
+                    <to uri="mock:otherwise"/>
+                    <multicast streaming="true">
+                        <wireTap uri="mock:trapped"/>
+                        <split strategyRef="splitAggregate">
+                            <tokenize token=","/>
+                            <filter>
+                                <simple>${in.body} not contains 'bad'</simple>
+                                <transform>
+                                    <simple>Hi ${in.body}</simple>
+                                </transform>
+                                <to uri="mock:split"/>
+                            </filter>
+                        </split>
+                    </multicast>
+                </otherwise>
+            </choice>
+            <to uri="log:result"/>
+            <to uri="mock:result"/>
+        </route>
+    </camelContext>
+
+    <bean id="splitAggregate" class="org.apache.camel.spring.processor.SpringComplexBlockWithEndTest$SplitAggregate"/>
+
+</beans>
