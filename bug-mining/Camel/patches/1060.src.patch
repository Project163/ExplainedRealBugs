diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
index 59f775e223f..2b197866063 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
@@ -88,7 +88,6 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
     private AggregationRepository aggregationRepository = new MemoryAggregationRepository();
     private Map<Object, Object> closedCorrelationKeys;
     private Set<String> batchConsumerCorrelationKeys = new LinkedHashSet<String>();
-    private Set<String> arrivedCorrelationKeys = new LinkedHashSet<String>();
     private final Set<String> inProgressCompleteExchanges = new HashSet<String>();
     private final Map<String, RedeliveryData> redeliveryState = new ConcurrentHashMap<String, RedeliveryData>();
     // optional dead letter channel for exhausted recovered exchanges
@@ -178,11 +177,8 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
         // improve performance as we can run aggregation repository get/add in parallel
         lock.lock();
         try {
-            // keep track on the arrived keys
-            arrivedCorrelationKeys.add(key);
             doAggregation(key, exchange);
         } finally {
-            arrivedCorrelationKeys.remove(key);
             lock.unlock();
         }
     }
@@ -552,7 +548,19 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
     private final class AggregationTimeoutMap extends DefaultTimeoutMap<String, String> {
 
         private AggregationTimeoutMap(ScheduledExecutorService executor, long requestMapPollTimeMillis) {
-            super(executor, requestMapPollTimeMillis);
+            // do NOT use locking on the timeout map as this aggregator has its own shared lock we will use instead
+            super(executor, requestMapPollTimeMillis, false);
+        }
+
+        @Override
+        public void purge() {
+            // must acquire the shared aggregation lock to be able to purge
+            lock.lock();
+            try {
+                super.purge();
+            } finally {
+                lock.unlock();
+            }
         }
 
         @Override
@@ -561,16 +569,6 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
                 log.debug("Completion timeout triggered for correlation key: " + key);
             }
 
-            // double check that its not already arrived or in progress
-            boolean arrived = arrivedCorrelationKeys.contains(key);
-            if (arrived) {
-                if (LOG.isTraceEnabled()) {
-                    LOG.trace("A new Exchange with correlation key: " + key + " has just arrived,"
-                        + " which postpones the timeout condition for aggregated exchange id: " + exchangeId);
-                }
-                // do not evict the entry as a new exchange has arrived with the same correlation key
-                return false;
-            }
             boolean inProgress = inProgressCompleteExchanges.contains(exchangeId);
             if (inProgress) {
                 if (LOG.isTraceEnabled()) {
@@ -581,16 +579,11 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
 
             // get the aggregated exchange
             Exchange answer = aggregationRepository.get(camelContext, key);
-
-            // indicate it was completed by timeout
-            answer.setProperty(Exchange.AGGREGATED_COMPLETED_BY, "timeout");
-
-            // do not acquire locks as we already have a lock on the timeout map
-            // and we want to avoid a dead lock if another thread (currently aggregating)
-            // which wants to put into the timeout map as well (CAMEL-2824)
-            // and running the on completion logic can occur concurrently, its just the aggregation logic
-            // which is preferred to run non concurrent.
-            onCompletion(key, answer, true);
+            if (answer != null) {
+                // indicate it was completed by timeout
+                answer.setProperty(Exchange.AGGREGATED_COMPLETED_BY, "timeout");
+                onCompletion(key, answer, true);
+            }
             return true;
         }
     }
@@ -615,14 +608,15 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
             Set<String> keys = aggregationRepository.getKeys();
 
             if (keys != null && !keys.isEmpty()) {
+                // must acquire the shared aggregation lock to be able to trigger interval completion
                 lock.lock();
                 try {
                     for (String key : keys) {
-                        if (LOG.isTraceEnabled()) {
-                            LOG.trace("Completion interval triggered for correlation key: " + key);
-                        }
                         Exchange exchange = aggregationRepository.get(camelContext, key);
                         if (exchange != null) {
+                            if (LOG.isTraceEnabled()) {
+                                LOG.trace("Completion interval triggered for correlation key: " + key);
+                            }
                             // indicate it was completed by interval
                             exchange.setProperty(Exchange.AGGREGATED_COMPLETED_BY, "interval");
                             onCompletion(key, exchange, false);
@@ -818,7 +812,6 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
         }
         batchConsumerCorrelationKeys.clear();
         redeliveryState.clear();
-        arrivedCorrelationKeys.clear();
     }
 
     @Override
diff --git a/camel-core/src/main/java/org/apache/camel/util/DefaultTimeoutMap.java b/camel-core/src/main/java/org/apache/camel/util/DefaultTimeoutMap.java
index 7bb72bb1f95..ceb03648bde 100644
--- a/camel-core/src/main/java/org/apache/camel/util/DefaultTimeoutMap.java
+++ b/camel-core/src/main/java/org/apache/camel/util/DefaultTimeoutMap.java
@@ -35,6 +35,9 @@ import org.apache.commons.logging.LogFactory;
 
 /**
  * Default implementation of the {@link TimeoutMap}.
+ * <p/>
+ * This implementation supports thread safe and non thread safe, in the manner you can enable locking or not.
+ * By default locking is enabled and thus we are thread safe.
  *
  * @version $Revision$
  */
@@ -47,20 +50,32 @@ public class DefaultTimeoutMap<K, V> implements TimeoutMap<K, V>, Runnable, Serv
     private final long purgePollTime;
     private final long initialDelay = 1000L;
     private final Lock lock = new ReentrantLock();
+    private boolean useLock = true;
 
     public DefaultTimeoutMap() {
         this(null, 1000L);
     }
 
+    public DefaultTimeoutMap(boolean useLock) {
+        this(null, 1000L, useLock);
+    }
+
     public DefaultTimeoutMap(ScheduledExecutorService executor, long requestMapPollTimeMillis) {
+        this(executor, requestMapPollTimeMillis, true);
+    }
+
+    public DefaultTimeoutMap(ScheduledExecutorService executor, long requestMapPollTimeMillis, boolean useLock) {
         this.executor = executor;
         this.purgePollTime = requestMapPollTimeMillis;
+        this.useLock = useLock;
         schedulePoll();
     }
 
     public V get(K key) {
         TimeoutMapEntry<K, V> entry;
-        lock.lock();
+        if (useLock) {
+            lock.lock();
+        }
         try {
             entry = map.get(key);
             if (entry == null) {
@@ -68,40 +83,54 @@ public class DefaultTimeoutMap<K, V> implements TimeoutMap<K, V>, Runnable, Serv
             }
             updateExpireTime(entry);
         } finally {
-            lock.unlock();
+            if (useLock) {
+                lock.unlock();
+            }
         }
         return entry.getValue();
     }
 
     public void put(K key, V value, long timeoutMillis) {
         TimeoutMapEntry<K, V> entry = new TimeoutMapEntry<K, V>(key, value, timeoutMillis);
-        lock.lock();
+        if (useLock) {
+            lock.lock();
+        }
         try {
             map.put(key, entry);
             updateExpireTime(entry);
         } finally {
-            lock.unlock();
+            if (useLock) {
+                lock.unlock();
+            }
         }
     }
 
     public void remove(K id) {
-        lock.lock();
+        if (useLock) {
+            lock.lock();
+        }
         try {
             map.remove(id);
         } finally {
-            lock.unlock();
+            if (useLock) {
+                lock.unlock();
+            }
         }
     }
 
     public Object[] getKeys() {
         Object[] keys;
-        lock.lock();
+        if (useLock) {
+            lock.lock();
+        }
         try {
             Set<K> keySet = map.keySet();
             keys = new Object[keySet.size()];
             keySet.toArray(keys);
         } finally {
-            lock.unlock();
+            if (useLock) {
+                lock.unlock();
+            }
         }
         return keys;
     }
@@ -133,7 +162,9 @@ public class DefaultTimeoutMap<K, V> implements TimeoutMap<K, V>, Runnable, Serv
 
         List<TimeoutMapEntry<K, V>> expired = new ArrayList<TimeoutMapEntry<K, V>>();
 
-        lock.lock();
+        if (useLock) {
+            lock.lock();
+        }
         try {
             // need to find the expired entries and add to the expired list
             for (Map.Entry<K, TimeoutMapEntry<K, V>> entry : map.entrySet()) {
@@ -178,7 +209,9 @@ public class DefaultTimeoutMap<K, V> implements TimeoutMap<K, V>, Runnable, Serv
                 }
             }
         } finally {
-            lock.unlock();
+            if (useLock) {
+                lock.unlock();
+            }
         }
     }
 
diff --git a/camel-core/src/main/java/org/apache/camel/util/TimeoutMap.java b/camel-core/src/main/java/org/apache/camel/util/TimeoutMap.java
index 24bd46f6d54..270be3fd5c7 100644
--- a/camel-core/src/main/java/org/apache/camel/util/TimeoutMap.java
+++ b/camel-core/src/main/java/org/apache/camel/util/TimeoutMap.java
@@ -17,7 +17,7 @@
 package org.apache.camel.util;
 
 /**
- * Represents a thread safe map of values which timeout after a period of inactivity.
+ * Represents a map of values which timeout after a period of inactivity.
  *
  * @version $Revision$
  */
diff --git a/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutManualTest.java b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutManualTest.java
new file mode 100644
index 00000000000..2a06caa1d7b
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutManualTest.java
@@ -0,0 +1,64 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.aggregator;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
+
+/**
+ * To be run manually when testing the timeout aggregator
+ *
+ * @version $Revision$
+ */
+public class AggregateTimeoutManualTest extends ContextTestSupport {
+
+    public void testDisabled() throws Exception {
+        // noop
+    }
+
+    public void xxxtestAggregateTimeoutManual() throws Exception {
+        MockEndpoint result = getMockEndpoint("mock:result");
+        // by default the use latest aggregation strategy
+        result.expectedBodiesReceived("Message 1999");
+        // should take at least 3 seconds to complete this one
+        result.setMinimumResultWaitTime(2500);
+
+        for (int i = 0; i < 2000; i++) {
+            template.sendBodyAndHeader("direct:start", "Message " + i, "id", "1");
+            Thread.sleep(3);
+        }
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // START SNIPPET: e1
+                from("direct:start")
+                    // timeout after 3 seconds
+                    .aggregate(header("id"), new UseLatestAggregationStrategy()).completionTimeout(3000)
+                    .to("mock:result");
+                // END SNIPPET: e1
+            }
+        };
+    }
+}
\ No newline at end of file
diff --git a/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutOnlyTest.java b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutOnlyTest.java
index 78459faa44d..a7eeaacfeac 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutOnlyTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutOnlyTest.java
@@ -49,8 +49,8 @@ public class AggregateTimeoutOnlyTest extends ContextTestSupport {
             public void configure() throws Exception {
                 // START SNIPPET: e1
                 from("direct:start")
-                    // aggregate every 3th second and disable the batch size so we set it to 0
-                    .aggregate(header("id"), new UseLatestAggregationStrategy()).completionTimeout(3000).completionSize(0)
+                    // aggregate timeout after 3th seconds
+                    .aggregate(header("id"), new UseLatestAggregationStrategy()).completionTimeout(3000)
                     .to("mock:result");
                 // END SNIPPET: e1
             }
