diff --git a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsEndpoint.java b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsEndpoint.java
index ab02902f751..059a5db370e 100644
--- a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsEndpoint.java
+++ b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsEndpoint.java
@@ -16,11 +16,8 @@
  */
 package org.apache.camel.component.jms;
 
-import java.util.HashMap;
-import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
 import javax.jms.ConnectionFactory;
 import javax.jms.Destination;
@@ -43,16 +40,12 @@ import org.apache.camel.Service;
 import org.apache.camel.ServiceStatus;
 import org.apache.camel.api.management.ManagedAttribute;
 import org.apache.camel.api.management.ManagedResource;
-import org.apache.camel.component.jms.reply.PersistentQueueReplyManager;
-import org.apache.camel.component.jms.reply.ReplyManager;
-import org.apache.camel.component.jms.reply.TemporaryQueueReplyManager;
 import org.apache.camel.impl.DefaultEndpoint;
 import org.apache.camel.impl.DefaultExchange;
 import org.apache.camel.impl.SynchronousDelegateProducer;
 import org.apache.camel.spi.HeaderFilterStrategy;
 import org.apache.camel.spi.HeaderFilterStrategyAware;
 import org.apache.camel.util.ObjectHelper;
-import org.apache.camel.util.ServiceHelper;
 import org.apache.camel.util.UnsafeUriCharactersEncoder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -81,10 +74,6 @@ public class JmsEndpoint extends DefaultEndpoint implements HeaderFilterStrategy
     private Destination destination;
     private String selector;
     private JmsConfiguration configuration;
-    private final Map<String, ReplyManager> replyToReplyManager = new HashMap<String, ReplyManager>();
-    private ReplyManager replyManager;
-    // scheduled executor to check for timeout (reply not received)
-    private ScheduledExecutorService replyManagerExecutorService;
     private final AtomicBoolean running = new AtomicBoolean();
     private volatile boolean destroying;
 
@@ -177,14 +166,6 @@ public class JmsEndpoint extends DefaultEndpoint implements HeaderFilterStrategy
             notifyAll();
         }
     }
-    public void destroyMessageListenerContainer(final AbstractMessageListenerContainer listenerContainer) {
-        destroying = true;
-        this.getReplyManagerExecutorService().execute(new Runnable() {
-            public void run() {
-                destroyMessageListenerContainerInternal(listenerContainer);
-            }
-        });
-    }
 
     public AbstractMessageListenerContainer createMessageListenerContainer() throws Exception {
         return configuration.createMessageListenerContainer(this);
@@ -389,31 +370,6 @@ public class JmsEndpoint extends DefaultEndpoint implements HeaderFilterStrategy
         return true;
     }
 
-    public synchronized ReplyManager getReplyManager() throws Exception {
-        if (replyManager == null) {
-            // use a temporary queue
-            replyManager = new TemporaryQueueReplyManager();
-            replyManager.setEndpoint(this);
-            replyManager.setScheduledExecutorService(getReplyManagerExecutorService());
-            ServiceHelper.startService(replyManager);
-        }
-        return replyManager;
-    }
-
-    public synchronized ReplyManager getReplyManager(String replyTo) throws Exception {
-        ReplyManager answer = replyToReplyManager.get(replyTo);
-        if (answer == null) {
-            // use a persistent queue
-            answer = new PersistentQueueReplyManager();
-            answer.setEndpoint(this);
-            answer.setScheduledExecutorService(getReplyManagerExecutorService());
-            ServiceHelper.startService(answer);
-            // remember this manager so we can re-use it
-            replyToReplyManager.put(replyTo, answer);
-        }
-        return answer;
-    }
-
     public boolean isPubSubDomain() {
         return pubSubDomain;
     }
@@ -449,7 +405,6 @@ public class JmsEndpoint extends DefaultEndpoint implements HeaderFilterStrategy
         return metadata;
     }
 
-
     /**
      * Returns the {@link JmsOperations} used for metadata operations such as creating temporary destinations
      */
@@ -461,14 +416,6 @@ public class JmsEndpoint extends DefaultEndpoint implements HeaderFilterStrategy
         return template;
     }
 
-    protected synchronized ScheduledExecutorService getReplyManagerExecutorService() {
-        if (replyManagerExecutorService == null) {
-            String name = "JmsReplyManagerTimeoutChecker[" + getEndpointConfiguredDestinationName() + "]";
-            replyManagerExecutorService = getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name);
-        }
-        return replyManagerExecutorService;
-    }
-    
     protected ExecutorService getAsyncStartStopExecutorService() {
         if (getComponent() == null) {
             throw new IllegalStateException("AsyncStartStopListener requires JmsComponent to be configured on this endpoint: " + this);
@@ -492,23 +439,6 @@ public class JmsEndpoint extends DefaultEndpoint implements HeaderFilterStrategy
     @Override
     protected void doStop() throws Exception {
         running.set(false);
-
-        if (replyManager != null) {
-            ServiceHelper.stopService(replyManager);
-            replyManager = null;
-        }
-
-        if (!replyToReplyManager.isEmpty()) {
-            for (ReplyManager replyManager : replyToReplyManager.values()) {
-                ServiceHelper.stopService(replyManager);
-            }
-            replyToReplyManager.clear();
-        }
-
-        if (replyManagerExecutorService != null) {
-            getCamelContext().getExecutorServiceManager().shutdownNow(replyManagerExecutorService);
-            replyManagerExecutorService = null;
-        }
     }
 
     // Delegated properties from the configuration
diff --git a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsProducer.java b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsProducer.java
index 1f4fe2af265..270fa6c7d68 100644
--- a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsProducer.java
+++ b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsProducer.java
@@ -17,6 +17,7 @@
 package org.apache.camel.component.jms;
 
 import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
 import javax.jms.Connection;
 import javax.jms.Destination;
@@ -29,11 +30,14 @@ import org.apache.camel.Exchange;
 import org.apache.camel.FailedToCreateProducerException;
 import org.apache.camel.RuntimeExchangeException;
 import org.apache.camel.component.jms.JmsConfiguration.CamelJmsTemplate;
+import org.apache.camel.component.jms.reply.PersistentQueueReplyManager;
 import org.apache.camel.component.jms.reply.ReplyManager;
+import org.apache.camel.component.jms.reply.TemporaryQueueReplyManager;
 import org.apache.camel.component.jms.reply.UseMessageIdAsCorrelationIdMessageSentCallback;
 import org.apache.camel.impl.DefaultAsyncProducer;
 import org.apache.camel.spi.UuidGenerator;
 import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.ServiceHelper;
 import org.apache.camel.util.ValueHolder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -42,6 +46,7 @@ import org.springframework.jms.core.MessageCreator;
 import org.springframework.jms.support.JmsUtils;
 
 import static org.apache.camel.component.jms.JmsMessageHelper.normalizeDestinationName;
+
 /**
  * @version 
  */
@@ -59,6 +64,11 @@ public class JmsProducer extends DefaultAsyncProducer {
         this.endpoint = endpoint;
     }
 
+    @Override
+    public JmsEndpoint getEndpoint() {
+        return (JmsEndpoint) super.getEndpoint();
+    }
+
     protected void initReplyManager() {
         if (!started.get()) {
             synchronized (this) {
@@ -76,12 +86,12 @@ public class JmsProducer extends DefaultAsyncProducer {
                     }
 
                     if (endpoint.getReplyTo() != null) {
-                        replyManager = endpoint.getReplyManager(endpoint.getReplyTo());
+                        replyManager = createReplyManager(endpoint.getReplyTo());
                         if (LOG.isDebugEnabled()) {
                             LOG.debug("Using JmsReplyManager: {} to process replies from: {}", replyManager, endpoint.getReplyTo());
                         }
                     } else {
-                        replyManager = endpoint.getReplyManager();
+                        replyManager = createReplyManager();
                         LOG.debug("Using JmsReplyManager: {} to process replies from temporary queue", replyManager);
                     }
                 } catch (Exception e) {
@@ -92,6 +102,16 @@ public class JmsProducer extends DefaultAsyncProducer {
         }
     }
 
+    protected void unInitReplyManager() {
+        try {
+            ServiceHelper.stopService(replyManager);
+        } catch (Exception e) {
+            throw ObjectHelper.wrapRuntimeCamelException(e);
+        } finally {
+            started.set(false);
+        }
+    }
+
     public boolean process(Exchange exchange, AsyncCallback callback) {
         // deny processing if we are not started
         if (!isRunAllowed()) {
@@ -444,5 +464,35 @@ public class JmsProducer extends DefaultAsyncProducer {
 
     protected void doStop() throws Exception {
         super.doStop();
+
+        // must stop/un-init reply manager if it was in use
+        unInitReplyManager();
     }
+
+    protected ReplyManager createReplyManager() throws Exception {
+        // use a temporary queue
+        ReplyManager replyManager = new TemporaryQueueReplyManager(getEndpoint().getCamelContext());
+        replyManager.setEndpoint(getEndpoint());
+
+        String name = "JmsReplyManagerTimeoutChecker[" + getEndpoint().getEndpointConfiguredDestinationName() + "]";
+        ScheduledExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name);
+        replyManager.setScheduledExecutorService(replyManagerExecutorService);
+        ServiceHelper.startService(replyManager);
+
+        return replyManager;
+    }
+
+    protected ReplyManager createReplyManager(String replyTo) throws Exception {
+        // use a persistent queue
+        ReplyManager replyManager = new PersistentQueueReplyManager(getEndpoint().getCamelContext());
+        replyManager.setEndpoint(getEndpoint());
+
+        String name = "JmsReplyManagerTimeoutChecker[" + replyTo + "]";
+        ScheduledExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name);
+        replyManager.setScheduledExecutorService(replyManagerExecutorService);
+        ServiceHelper.startService(replyManager);
+
+        return replyManager;
+    }
+
 }
diff --git a/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/PersistentQueueReplyManager.java b/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/PersistentQueueReplyManager.java
index d35fc60c4a8..e7097af4bb7 100644
--- a/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/PersistentQueueReplyManager.java
+++ b/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/PersistentQueueReplyManager.java
@@ -24,6 +24,7 @@ import javax.jms.Message;
 import javax.jms.Session;
 
 import org.apache.camel.AsyncCallback;
+import org.apache.camel.CamelContext;
 import org.apache.camel.Exchange;
 import org.apache.camel.component.jms.DefaultSpringErrorHandler;
 import org.apache.camel.component.jms.ReplyToType;
@@ -41,6 +42,10 @@ public class PersistentQueueReplyManager extends ReplyManagerSupport {
     private String replyToSelectorValue;
     private MessageSelectorCreator dynamicMessageSelector;
 
+    public PersistentQueueReplyManager(CamelContext camelContext) {
+        super(camelContext);
+    }
+
     public String registerReply(ReplyManager replyManager, Exchange exchange, AsyncCallback callback,
                                 String originalCorrelationId, String correlationId, long requestTimeout) {
         // add to correlation map
diff --git a/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/ReplyManagerSupport.java b/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/ReplyManagerSupport.java
index f9524d786c9..850a650434f 100644
--- a/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/ReplyManagerSupport.java
+++ b/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/ReplyManagerSupport.java
@@ -24,6 +24,7 @@ import javax.jms.JMSException;
 import javax.jms.Message;
 
 import org.apache.camel.AsyncCallback;
+import org.apache.camel.CamelContext;
 import org.apache.camel.Exchange;
 import org.apache.camel.ExchangeTimedOutException;
 import org.apache.camel.component.jms.JmsEndpoint;
@@ -45,6 +46,7 @@ import org.springframework.jms.listener.AbstractMessageListenerContainer;
 public abstract class ReplyManagerSupport extends ServiceSupport implements ReplyManager {
 
     protected final Logger log = LoggerFactory.getLogger(getClass());
+    protected final CamelContext camelContext;
     protected ScheduledExecutorService executorService;
     protected JmsEndpoint endpoint;
     protected Destination replyTo;
@@ -53,6 +55,10 @@ public abstract class ReplyManagerSupport extends ServiceSupport implements Repl
     protected final long replyToTimeout = 10000;
     protected CorrelationTimeoutMap correlation;
 
+    public ReplyManagerSupport(CamelContext camelContext) {
+        this.camelContext = camelContext;
+    }
+
     public void setScheduledExecutorService(ScheduledExecutorService executorService) {
         this.executorService = executorService;
     }
@@ -229,6 +235,12 @@ public abstract class ReplyManagerSupport extends ServiceSupport implements Repl
             listenerContainer.destroy();
             listenerContainer = null;
         }
+
+        // must also stop executor service
+        if (executorService != null) {
+            camelContext.getExecutorServiceManager().shutdownNow(executorService);
+            executorService = null;
+        }
     }
 
 }
diff --git a/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/TemporaryQueueReplyManager.java b/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/TemporaryQueueReplyManager.java
index 9bded7b0e25..e4cc69c21bd 100644
--- a/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/TemporaryQueueReplyManager.java
+++ b/components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/TemporaryQueueReplyManager.java
@@ -23,6 +23,7 @@ import javax.jms.Session;
 import javax.jms.TemporaryQueue;
 
 import org.apache.camel.AsyncCallback;
+import org.apache.camel.CamelContext;
 import org.apache.camel.Exchange;
 import org.apache.camel.component.jms.DefaultSpringErrorHandler;
 import org.springframework.jms.listener.AbstractMessageListenerContainer;
@@ -36,6 +37,10 @@ import org.springframework.jms.support.destination.DestinationResolver;
  */
 public class TemporaryQueueReplyManager extends ReplyManagerSupport {
 
+    public TemporaryQueueReplyManager(CamelContext camelContext) {
+        super(camelContext);
+    }
+
     public String registerReply(ReplyManager replyManager, Exchange exchange, AsyncCallback callback,
                                 String originalCorrelationId, String correlationId, long requestTimeout) {
         // add to correlation map
diff --git a/components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsRequestReplyExclusiveReplyToRemoveAddRouteTest.java b/components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsRequestReplyExclusiveReplyToRemoveAddRouteTest.java
new file mode 100644
index 00000000000..86062b8c524
--- /dev/null
+++ b/components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsRequestReplyExclusiveReplyToRemoveAddRouteTest.java
@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jms;
+
+import javax.jms.ConnectionFactory;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+import static org.apache.camel.component.jms.JmsComponent.jmsComponentAutoAcknowledge;
+
+/**
+ * @version
+ */
+public class JmsRequestReplyExclusiveReplyToRemoveAddRouteTest extends CamelTestSupport {
+
+    @Test
+    public void testJmsRequestReplyExclusiveFixedReplyTo() throws Exception {
+        assertEquals("Hello A", template.requestBody("direct:start", "A"));
+
+        // stop and remove route
+        context.stopRoute("start");
+        context.removeRoute("start");
+
+        // add new route using same jms endpoint uri
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start2").routeId("start2")
+                        .to("activemq:queue:foo?replyTo=bar&replyToType=Exclusive")
+                        .to("log:start2");
+            }
+        });
+        // and it should still work
+
+        assertEquals("Hello B", template.requestBody("direct:start2", "B"));
+        assertEquals("Hello C", template.requestBody("direct:start2", "C"));
+        assertEquals("Hello D", template.requestBody("direct:start2", "D"));
+        assertEquals("Hello E", template.requestBody("direct:start2", "E"));
+    }
+
+    protected CamelContext createCamelContext() throws Exception {
+        CamelContext camelContext = super.createCamelContext();
+        ConnectionFactory connectionFactory = CamelJmsTestHelper.createConnectionFactory();
+        camelContext.addComponent("activemq", jmsComponentAutoAcknowledge(connectionFactory));
+        return camelContext;
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start").routeId("start")
+                    .to("activemq:queue:foo?replyTo=bar&replyToType=Exclusive")
+                    .to("log:start");
+
+                from("activemq:queue:foo").routeId("foo")
+                    .transform(body().prepend("Hello "));
+            }
+        };
+    }
+}
\ No newline at end of file
