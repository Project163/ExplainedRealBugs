diff --git a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsConsumer.java b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsConsumer.java
index addff6b3f07..50b783337e3 100644
--- a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsConsumer.java
+++ b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsConsumer.java
@@ -16,6 +16,7 @@
  */
 package org.apache.camel.component.jms;
 
+import java.util.concurrent.ExecutorService;
 import javax.jms.Connection;
 
 import org.apache.camel.FailedToCreateConsumerException;
@@ -37,6 +38,8 @@ public class JmsConsumer extends DefaultConsumer implements SuspendableService {
     private volatile AbstractMessageListenerContainer listenerContainer;
     private volatile EndpointMessageListener messageListener;
     private volatile boolean initialized;
+    private volatile ExecutorService executorService;
+    private volatile boolean shutdownExecutorService;
 
     public JmsConsumer(JmsEndpoint endpoint, Processor processor, AbstractMessageListenerContainer listenerContainer) {
         super(endpoint, processor);
@@ -75,6 +78,23 @@ public class JmsConsumer extends DefaultConsumer implements SuspendableService {
         listenerContainer.setMessageListener(getEndpointMessageListener());
     }
 
+    /**
+     * Sets the {@link ExecutorService} the {@link AbstractMessageListenerContainer} is using (if any).
+     * <p/>
+     * The {@link AbstractMessageListenerContainer} may use a private thread pool, and then when this consumer
+     * is stopped, we need to shutdown this thread pool as well, to clean up all resources.
+     * If a shared thread pool is used by the {@link AbstractMessageListenerContainer} then the lifecycle
+     * of that shared thread pool is handled elsewhere (not by this consumer); and therefore
+     * the <tt>shutdownExecutorService</tt> parameter should be <tt>false</tt>.
+     *
+     * @param executorService         the thread pool
+     * @param shutdownExecutorService whether to shutdown the thread pool when this consumer stops
+     */
+    void setListenerContainerExecutorService(ExecutorService executorService, boolean shutdownExecutorService) {
+        this.executorService = executorService;
+        this.shutdownExecutorService = shutdownExecutorService;
+    }
+
     /**
      * Starts the JMS listener container
      * <p/>
@@ -160,6 +180,12 @@ public class JmsConsumer extends DefaultConsumer implements SuspendableService {
         // then we will use updated configuration from jms endpoint that may have been managed using JMX
         listenerContainer = null;
         messageListener = null;
+
+        // shutdown thread pool if listener container was using a private thread pool
+        if (shutdownExecutorService && executorService != null) {
+            getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(executorService);
+        }
+        executorService = null;
     }
 
     @Override
diff --git a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsEndpoint.java b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsEndpoint.java
index 4392fd2b036..509f10e1531 100644
--- a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsEndpoint.java
+++ b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsEndpoint.java
@@ -183,6 +183,12 @@ public class JmsEndpoint extends DefaultEndpoint implements HeaderFilterStrategy
                 log.debug("Using custom TaskExecutor: {} on listener container: {}", configuration.getTaskExecutor(), listenerContainer);
             }
             setContainerTaskExecutor(listenerContainer, configuration.getTaskExecutor());
+            // we are using a shared thread pool that this listener container is using.
+            // store a reference to the consumer, but we should not shutdown the thread pool when the consumer stops
+            // as the lifecycle of the shared thread pool is handled elsewhere
+            if (configuration.getTaskExecutor() instanceof ExecutorService) {
+                consumer.setListenerContainerExecutorService((ExecutorService) configuration.getTaskExecutor(), false);
+            }
         } else if ((listenerContainer instanceof DefaultJmsMessageListenerContainer && configuration.getDefaultTaskExecutorType() == null)
                 || !(listenerContainer instanceof DefaultJmsMessageListenerContainer)) {
             // preserve backwards compatibility if an explicit Default TaskExecutor Type was not set;
@@ -190,6 +196,9 @@ public class JmsEndpoint extends DefaultEndpoint implements HeaderFilterStrategy
             // use a cached pool as DefaultMessageListenerContainer will throttle pool sizing
             ExecutorService executor = getCamelContext().getExecutorServiceManager().newCachedThreadPool(consumer, consumerName);
             setContainerTaskExecutor(listenerContainer, executor);
+            // we created a new private thread pool that this listener container is using, now store a reference on the consumer
+            // so when the consumer is stopped we can shutdown the thread pool also, to ensure all resources is shutdown
+            consumer.setListenerContainerExecutorService(executor, true);
         } else {
             // do nothing, as we're working with a DefaultJmsMessageListenerContainer with an explicit DefaultTaskExecutorType,
             // so DefaultJmsMessageListenerContainer#createDefaultTaskExecutor will handle the creation
diff --git a/components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsAddAndRemoveRouteManagementTest.java b/components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsAddAndRemoveRouteManagementTest.java
new file mode 100644
index 00000000000..eb35bea7284
--- /dev/null
+++ b/components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsAddAndRemoveRouteManagementTest.java
@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jms;
+
+import java.util.Set;
+import javax.jms.ConnectionFactory;
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.management.DefaultManagementNamingStrategy;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+import static org.apache.camel.component.jms.JmsComponent.jmsComponentAutoAcknowledge;
+
+/**
+ * Test that all thread pools is removed when adding and removing a route dynamically
+ */
+public class JmsAddAndRemoveRouteManagementTest extends CamelTestSupport {
+
+    @Override
+    protected boolean useJmx() {
+        return true;
+    }
+
+    protected MBeanServer getMBeanServer() {
+        return context.getManagementStrategy().getManagementAgent().getMBeanServer();
+    }
+
+    @Test
+    public void testAddAndRemoveRoute() throws Exception {
+        MBeanServer mbeanServer = getMBeanServer();
+
+        Set<ObjectName> before = mbeanServer.queryNames(new ObjectName("*:type=threadpools,*"), null);
+
+        getMockEndpoint("mock:result").expectedMessageCount(1);
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("activemq:queue:in").routeId("myNewRoute")
+                    .to("activemq:queue:foo");
+            }
+        });
+
+        Set<ObjectName> during = mbeanServer.queryNames(new ObjectName("*:type=threadpools,*"), null);
+        assertEquals("There should be one more thread pool in JMX", before.size() + 1, during.size());
+
+        template.sendBody("activemq:queue:in", "Hello World");
+
+        assertMockEndpointsSatisfied();
+
+        // now stop and remove that route
+        context.stopRoute("myNewRoute");
+        context.removeRoute("myNewRoute");
+
+        Set<ObjectName> after = mbeanServer.queryNames(new ObjectName("*:type=threadpools,*"), null);
+        assertEquals("Should have removed all thread pools from removed route", before.size(), after.size());
+    }
+
+    protected CamelContext createCamelContext() throws Exception {
+        CamelContext camelContext = super.createCamelContext();
+        ConnectionFactory connectionFactory = CamelJmsTestHelper.createConnectionFactory();
+        camelContext.addComponent("activemq", jmsComponentAutoAcknowledge(connectionFactory));
+
+        DefaultManagementNamingStrategy naming = (DefaultManagementNamingStrategy) camelContext.getManagementStrategy().getManagementNamingStrategy();
+        naming.setHostName("localhost");
+        naming.setDomainName("org.apache.camel");
+
+        return camelContext;
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("activemq:queue:foo").to("mock:result");
+            }
+        };
+    }
+}
