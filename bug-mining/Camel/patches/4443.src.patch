diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfConsumer.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfConsumer.java
index 0e5478a7375..799f5d53153 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfConsumer.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfConsumer.java
@@ -187,6 +187,7 @@ public class CxfConsumer extends DefaultConsumer {
         // NOTE this code cannot work with CXF 2.2.x and JMSContinuation
         // as it doesn't break out the interceptor chain when we call it
         private Object asyncInvoke(Exchange cxfExchange, final Continuation continuation) {
+            log.trace("asyncInvoke continuation: {}", continuation);
             synchronized (continuation) {
                 if (continuation.isNew()) {
                     final org.apache.camel.Exchange camelExchange = prepareCamelExchange(cxfExchange);
diff --git a/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfConsumerContinuationTimeoutTest.java b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfConsumerContinuationTimeoutTest.java
new file mode 100644
index 00000000000..49a942e0ef2
--- /dev/null
+++ b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/CxfConsumerContinuationTimeoutTest.java
@@ -0,0 +1,123 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.cxf;
+
+import java.util.concurrent.ExecutorService;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.AsyncProcessor;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.apache.camel.util.AsyncProcessorHelper;
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class CxfConsumerContinuationTimeoutTest extends CamelTestSupport {
+
+    private static final String ECHO_METHOD = "ns1:echo xmlns:ns1=\"http://cxf.component.camel.apache.org/\"";
+
+    private static final String ECHO_RESPONSE = "<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">"
+            + "<soap:Body><ns1:echoResponse xmlns:ns1=\"http://cxf.component.camel.apache.org/\">"
+            + "<return xmlns=\"http://cxf.component.camel.apache.org/\">echo Hello World!</return>"
+            + "</ns1:echoResponse></soap:Body></soap:Envelope>";
+    private static final String ECHO_BOOLEAN_RESPONSE = "<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">"
+            + "<soap:Body><ns1:echoBooleanResponse xmlns:ns1=\"http://cxf.component.camel.apache.org/\">"
+            + "<return xmlns=\"http://cxf.component.camel.apache.org/\">true</return>"
+            + "</ns1:echoBooleanResponse></soap:Body></soap:Envelope>";
+
+    protected final String simpleEndpointAddress = "http://localhost:"
+        + CXFTestSupport.getPort1() + "/" + getClass().getSimpleName() + "/test";
+    protected final String simpleEndpointURI = "cxf://" + simpleEndpointAddress
+        + "?serviceClass=org.apache.camel.component.cxf.HelloService";
+
+    protected ExecutorService pool;
+    
+    @Override
+    public boolean isCreateCamelContextPerClass() {
+        return true;
+    }
+
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            public void configure() {
+                pool = context.getExecutorServiceManager().newSingleThreadExecutor(this, "MyPool");
+
+                from("direct:start")
+                    .setBody(constant("Sensitive Data"))
+                    .to(simpleEndpointURI + "&continuationTimeout=30000&dataFormat=MESSAGE");
+
+                from(simpleEndpointURI + "&continuationTimeout=30000&dataFormat=MESSAGE").process(new AsyncProcessor() {
+                    @Override
+                    public void process(Exchange exchange) throws Exception {
+                        AsyncProcessorHelper.process(this, exchange);
+                    }
+
+                    @Override
+                    public boolean process(Exchange exchange, AsyncCallback asyncCallback) {
+                        Message in = exchange.getIn();
+                        // check the content-length header is filtered
+                        Object value = in.getHeader("Content-Length");
+                        assertNull("The Content-Length header should be removed", value);
+                        // Get the request message
+                        String request = in.getBody(String.class);
+                        String priority = in.getHeader("priority", "fast", String.class);
+
+                        // need not to block this thread to simulate slow response so use a thread pool to wait
+                        if ("slow".equalsIgnoreCase(priority)) {
+                            pool.submit(() -> {
+                                try {
+                                    log.info("Sleeping for 50 seconds to simulate slow response");
+                                    Thread.sleep(50000);
+                                } catch (InterruptedException e) {
+                                    // ignore
+                                } finally {
+                                    asyncCallback.done(false);
+                                }
+                            });
+                            return false;
+                        } else {
+                            // Send the response message back
+                            if (request.indexOf(ECHO_METHOD) > 0) {
+                                exchange.getOut().setBody(ECHO_RESPONSE);
+                            } else { // echoBoolean call
+                                exchange.getOut().setBody(ECHO_BOOLEAN_RESPONSE);
+                            }
+                        }
+                        asyncCallback.done(true);
+                        return true;
+                    }
+                });
+            }
+        };
+    }
+
+    @Test
+    public void testNoTimeout() throws Exception {
+        Object out = template.requestBody("direct:start", "Hello World", String.class);
+        assertEquals(ECHO_BOOLEAN_RESPONSE, out);
+    }
+
+    @Test
+    @Ignore("CAMEL-12104")
+    public void testTimeout() throws Exception {
+        Object out = template.requestBodyAndHeader("direct:start", "Bye World", "priority", "slow", String.class);
+        // here we should get some kind of timeout exception
+    }
+
+}
