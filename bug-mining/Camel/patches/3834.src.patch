diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java
index 87be7ee2642..1fc4404d65c 100644
--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java
+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java
@@ -328,13 +328,18 @@ public class BeanInfo {
         }
 
         Set<Method> overrides = new HashSet<Method>();
-        Set<Method> bridges = new HashSet<Method>();
 
         // do not remove duplicates form class from the Java itself as they have some "duplicates" we need
         boolean javaClass = clazz.getName().startsWith("java.") || clazz.getName().startsWith("javax.");
         if (!javaClass) {
             // it may have duplicate methods already, even from declared or from interfaces + declared
             for (Method source : methods) {
+
+                // skip bridge methods in duplicate checks (as the bridge method is inserted by the compiler due to type erasure)
+                if (source.isBridge()) {
+                    continue;
+                }
+
                 for (Method target : methods) {
                     // skip ourselves
                     if (ObjectHelper.isOverridingMethod(source, target, true)) {
@@ -354,10 +359,15 @@ public class BeanInfo {
         if (Modifier.isPublic(clazz.getModifiers())) {
             // add additional interface methods
             List<Method> extraMethods = getInterfaceMethods(clazz);
-            for (Method target : extraMethods) {
-                for (Method source : methods) {
+            for (Method source : extraMethods) {
+                for (Method target : methods) {
                     if (ObjectHelper.isOverridingMethod(source, target, false)) {
-                        overrides.add(target);
+                        overrides.add(source);
+                    }
+                }
+                for (Method target : methodMap.keySet()) {
+                    if (ObjectHelper.isOverridingMethod(source, target, false)) {
+                        overrides.add(source);
                     }
                 }
             }
diff --git a/camel-core/src/test/java/org/apache/camel/component/bean/BeanInfoWithBridgedMethodTest.java b/camel-core/src/test/java/org/apache/camel/component/bean/BeanInfoWithBridgedMethodTest.java
new file mode 100644
index 00000000000..813c11e063f
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/component/bean/BeanInfoWithBridgedMethodTest.java
@@ -0,0 +1,71 @@
+package org.apache.camel.component.bean;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Service;
+import org.apache.camel.impl.DefaultExchange;
+
+/**
+ * Unit test for bridged methods.
+ */
+public class BeanInfoWithBridgedMethodTest extends ContextTestSupport {
+
+    public void testBridgedMethod() throws Exception {
+        BeanInfo beanInfo = new BeanInfo(context, MyService.class);
+
+        DefaultExchange exchange = new DefaultExchange(context);
+        exchange.getIn().setBody(new Request(1));
+
+        try {
+            MyService myService = new MyService();
+            MethodInvocation mi = beanInfo.createInvocation(null, exchange);
+            assertEquals("MyService", mi.getMethod().getDeclaringClass().getSimpleName());
+            assertEquals(2, mi.getMethod().invoke(myService, new Request(1)));
+        } catch (AmbiguousMethodCallException e) {
+            fail("This should not be ambiguous!");
+        }
+    }
+
+    public void testPackagePrivate() throws Exception {
+        BeanInfo beanInfo = new BeanInfo(context, MyPackagePrivateService.class);
+
+        DefaultExchange exchange = new DefaultExchange(context);
+        exchange.getIn().setBody(new Request(1));
+
+        try {
+            MyPackagePrivateService myService = new MyPackagePrivateService();
+            MethodInvocation mi = beanInfo.createInvocation(null, exchange);
+            assertEquals("Service", mi.getMethod().getDeclaringClass().getSimpleName());
+            assertEquals(4, mi.getMethod().invoke(myService, new Request(2)));
+        } catch (AmbiguousMethodCallException e) {
+            fail("This should not be ambiguous!");
+        }
+    }
+
+    public static class Request {
+        int x;
+
+        public Request(int x) {
+            this.x = x;
+        }
+    }
+
+    public interface Service<R> {
+
+        int process(R request);
+    }
+
+    public static class MyService implements Service<Request> {
+
+        public int process(Request request) {
+            return request.x + 1;
+        }
+    }
+
+    static class MyPackagePrivateService implements Service<Request> {
+
+        public int process(Request request) {
+            return request.x + 2;
+        }
+    }
+
+}
