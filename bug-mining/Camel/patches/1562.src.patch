diff --git a/camel-core/pom.xml b/camel-core/pom.xml
index a4e934ff4e1..cd24c44a8ea 100755
--- a/camel-core/pom.xml
+++ b/camel-core/pom.xml
@@ -56,6 +56,11 @@
   <dependencies>
 
     <!-- required dependencies by camel-core -->
+    <dependency>
+      <groupId>com.googlecode.concurrentlinkedhashmap</groupId>
+      <artifactId>concurrentlinkedhashmap-lru</artifactId>
+    </dependency>
+
     <dependency>
       <groupId>org.slf4j</groupId>
       <artifactId>slf4j-api</artifactId>
@@ -90,6 +95,26 @@
 
   <build>
     <plugins>
+    <!-- Shade the googlecode stuff for OSGi -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-shade-plugin</artifactId>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>shade</goal>
+            </goals>
+            <configuration>
+              <artifactSet>
+                <includes>
+                  <include>com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru</include>
+                </includes>
+              </artifactSet>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
       <!-- generate the attached tests jar -->
       <plugin>
         <artifactId>maven-jar-plugin</artifactId>
diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java
index 33ec94c0cdf..f6fb0189f40 100644
--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java
+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java
@@ -335,40 +335,34 @@ public class DefaultCamelContext extends ServiceSupport implements CamelContext,
     // -----------------------------------------------------------------------
 
     public Collection<Endpoint> getEndpoints() {
-        synchronized (endpoints) {
-            return new ArrayList<Endpoint>(endpoints.values());
-        }
+        return new ArrayList<Endpoint>(endpoints.values());
     }
 
     public Map<String, Endpoint> getEndpointMap() {
-        synchronized (endpoints) {
-            TreeMap<String, Endpoint> answer = new TreeMap<String, Endpoint>();
-            for (Map.Entry<EndpointKey, Endpoint> entry : endpoints.entrySet()) {
-                answer.put(entry.getKey().get(), entry.getValue());
-            }
-            return answer;
+        TreeMap<String, Endpoint> answer = new TreeMap<String, Endpoint>();
+        for (Map.Entry<EndpointKey, Endpoint> entry : endpoints.entrySet()) {
+            answer.put(entry.getKey().get(), entry.getValue());
         }
+        return answer;
     }
 
     public Endpoint hasEndpoint(String uri) {
-        synchronized (endpoints) {
-            return endpoints.get(getEndpointKey(uri));
-        }
+        return endpoints.get(getEndpointKey(uri));
     }
 
     public Endpoint addEndpoint(String uri, Endpoint endpoint) throws Exception {
         Endpoint oldEndpoint;
-        synchronized (endpoints) {
-            startServices(endpoint);
-            oldEndpoint = endpoints.remove(getEndpointKey(uri));
-            for (LifecycleStrategy strategy : lifecycleStrategies) {
-                strategy.onEndpointAdd(endpoint);
-            }
-            addEndpointToRegistry(uri, endpoint);
-            if (oldEndpoint != null) {
-                stopServices(oldEndpoint);
-            }
+
+        startServices(endpoint);
+        oldEndpoint = endpoints.remove(getEndpointKey(uri));
+        for (LifecycleStrategy strategy : lifecycleStrategies) {
+            strategy.onEndpointAdd(endpoint);
+        }
+        addEndpointToRegistry(uri, endpoint);
+        if (oldEndpoint != null) {
+            stopServices(oldEndpoint);
         }
+
         return oldEndpoint;
     }
 
@@ -420,39 +414,37 @@ public class DefaultCamelContext extends ServiceSupport implements CamelContext,
 
         Endpoint answer;
         String scheme = null;
-        synchronized (endpoints) {
-            answer = endpoints.get(getEndpointKey(uri));
-            if (answer == null) {
-                try {
-                    // Use the URI prefix to find the component.
-                    String splitURI[] = ObjectHelper.splitOnCharacter(uri, ":", 2);
-                    if (splitURI[1] != null) {
-                        scheme = splitURI[0];
-                        Component component = getComponent(scheme);
-
-                        // Ask the component to resolve the endpoint.
-                        if (component != null) {
-                            // Have the component create the endpoint if it can.
-                            answer = component.createEndpoint(uri);
-
-                            if (answer != null && log.isDebugEnabled()) {
-                                log.debug("{} converted to endpoint: {} by component: {}", new Object[]{uri, answer, component});
-                            }
+        answer = endpoints.get(getEndpointKey(uri));
+        if (answer == null) {
+            try {
+                // Use the URI prefix to find the component.
+                String splitURI[] = ObjectHelper.splitOnCharacter(uri, ":", 2);
+                if (splitURI[1] != null) {
+                    scheme = splitURI[0];
+                    Component component = getComponent(scheme);
+
+                    // Ask the component to resolve the endpoint.
+                    if (component != null) {
+                        // Have the component create the endpoint if it can.
+                        answer = component.createEndpoint(uri);
+
+                        if (answer != null && log.isDebugEnabled()) {
+                            log.debug("{} converted to endpoint: {} by component: {}", new Object[]{uri, answer, component});
                         }
                     }
+                }
 
-                    if (answer == null) {
-                        // no component then try in registry and elsewhere
-                        answer = createEndpoint(uri);
-                    }
+                if (answer == null) {
+                    // no component then try in registry and elsewhere
+                    answer = createEndpoint(uri);
+                }
 
-                    if (answer != null) {
-                        addService(answer);
-                        answer = addEndpointToRegistry(uri, answer);
-                    }
-                } catch (Exception e) {
-                    throw new ResolveEndpointFailedException(uri, e);
+                if (answer != null) {
+                    addService(answer);
+                    answer = addEndpointToRegistry(uri, answer);
                 }
+            } catch (Exception e) {
+                throw new ResolveEndpointFailedException(uri, e);
             }
         }
 
diff --git a/camel-core/src/main/java/org/apache/camel/util/LRUCache.java b/camel-core/src/main/java/org/apache/camel/util/LRUCache.java
index f638e97bd98..11cfc0b2d29 100644
--- a/camel-core/src/main/java/org/apache/camel/util/LRUCache.java
+++ b/camel-core/src/main/java/org/apache/camel/util/LRUCache.java
@@ -16,10 +16,10 @@
  */
 package org.apache.camel.util;
 
-import java.util.LinkedHashMap;
-import java.util.Map;
+import java.util.*;
 import java.util.concurrent.atomic.AtomicLong;
 
+import com.googlecode.concurrentlinkedhashmap.ConcurrentLinkedHashMap;
 import org.apache.camel.Service;
 
 /**
@@ -27,14 +27,15 @@ import org.apache.camel.Service;
  *
  * @version 
  */
-public class LRUCache<K, V> extends LinkedHashMap<K, V> implements Service {
+public class LRUCache<K, V> implements Service, Map<K,V> {
     private static final long serialVersionUID = -342098639681884414L;
     private int maxCacheSize = 10000;
     private final AtomicLong hits = new AtomicLong();
     private final AtomicLong misses = new AtomicLong();
+    private ConcurrentLinkedHashMap<K, V> map;
 
     public LRUCache(int maximumCacheSize) {
-        this(maximumCacheSize, maximumCacheSize, 0.75f, true);
+        this(maximumCacheSize, maximumCacheSize);
     }
 
     /**
@@ -43,20 +44,21 @@ public class LRUCache<K, V> extends LinkedHashMap<K, V> implements Service {
      *
      * @param initialCapacity  the initial capacity.
      * @param maximumCacheSize the max capacity.
-     * @param loadFactor       the load factor.
-     * @param accessOrder      the ordering mode - <tt>true</tt> for
-     *                         access-order, <tt>false</tt> for insertion-order.
      * @throws IllegalArgumentException if the initial capacity is negative
      *                                  or the load factor is non positive.
      */
-    public LRUCache(int initialCapacity, int maximumCacheSize, float loadFactor, boolean accessOrder) {
-        super(initialCapacity, loadFactor, accessOrder);
+    public LRUCache(int initialCapacity, int maximumCacheSize) {
+        map = new ConcurrentLinkedHashMap
+                .Builder<K, V>()
+                .initialCapacity(initialCapacity)
+                .maximumWeightedCapacity(maximumCacheSize).build();
+//        super(initialCapacity, loadFactor, accessOrder);
         this.maxCacheSize = maximumCacheSize;
     }
 
     @Override
     public V get(Object o) {
-        V answer = super.get(o);
+        V answer = map.get(o);
         if (answer != null) {
             hits.incrementAndGet();
         } else {
@@ -65,6 +67,61 @@ public class LRUCache<K, V> extends LinkedHashMap<K, V> implements Service {
         return answer;
     }
 
+    @Override
+    public int size() {
+        return map.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return map.isEmpty();
+    }
+
+    @Override
+    public boolean containsKey(Object o) {
+        return map.containsKey(o);
+    }
+
+    @Override
+    public boolean containsValue(Object o) {
+        return map.containsValue(0);
+    }
+
+    @Override
+    public V put(K k, V v) {
+        return map.put(k, v);
+    }
+
+    @Override
+    public V remove(Object o) {
+        return map.remove(o);
+    }
+
+    @Override
+    public void putAll(Map<? extends K, ? extends V> map) {
+        ((AbstractMap)map).putAll(map);
+    }
+
+    @Override
+    public void clear() {
+        map.clear();
+    }
+
+    @Override
+    public Set<K> keySet() {
+        return map.ascendingKeySet();
+    }
+
+    @Override
+    public Collection<V> values() {
+        return map.ascendingMap().values();
+    }
+
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        return map.ascendingMap().entrySet();
+    }
+
     /**
      * Gets the number of cache hits
      */
@@ -95,7 +152,7 @@ public class LRUCache<K, V> extends LinkedHashMap<K, V> implements Service {
     }
 
     protected boolean removeEldestEntry(Map.Entry<K, V> entry) {
-        return size() > maxCacheSize;
+        return map.size() > maxCacheSize;
     }
 
     public void start() throws Exception {
@@ -106,7 +163,7 @@ public class LRUCache<K, V> extends LinkedHashMap<K, V> implements Service {
         // stop the value and clear the cache
         if (!isEmpty()) {
             ServiceHelper.stopServices(values());
-            clear();
+            map.clear();
             hits.set(0);
             misses.set(0);
         }
diff --git a/camel-core/src/main/java/org/apache/camel/util/LRUSoftCache.java b/camel-core/src/main/java/org/apache/camel/util/LRUSoftCache.java
index d0a69bfdb88..283e9308f05 100644
--- a/camel-core/src/main/java/org/apache/camel/util/LRUSoftCache.java
+++ b/camel-core/src/main/java/org/apache/camel/util/LRUSoftCache.java
@@ -55,8 +55,8 @@ public class LRUSoftCache<K, V> extends LRUCache<K, V> {
         super(maximumCacheSize);
     }
 
-    public LRUSoftCache(int initialCapacity, int maximumCacheSize, float loadFactor, boolean accessOrder) {
-        super(initialCapacity, maximumCacheSize, loadFactor, accessOrder);
+    public LRUSoftCache(int initialCapacity, int maximumCacheSize) {
+        super(initialCapacity, maximumCacheSize);
     }
 
     @Override
@@ -129,21 +129,6 @@ public class LRUSoftCache<K, V> extends LRUCache<K, V> {
         return get(o) != null;
     }
 
-    @Override
-    public Set<K> keySet() {
-        // must use a copy of the keys to avoid concurrent modifications
-        Set<K> keys = new LinkedHashSet<K>(super.keySet());
-
-        // filter out un referenced values
-        Set<K> answer = new LinkedHashSet<K>();
-        for (K key : keys) {
-            if (containsKey(key)) {
-                answer.add(key);
-            }
-        }
-        return answer;
-    }
-
     @Override
     public Set<Map.Entry<K, V>> entrySet() {
         Set<Map.Entry<K, V>> original = super.entrySet();
diff --git a/camel-core/src/test/java/org/apache/camel/impl/DefaultCamelContextTest.java b/camel-core/src/test/java/org/apache/camel/impl/DefaultCamelContextTest.java
index b4ae0b7bf7a..fee67092886 100644
--- a/camel-core/src/test/java/org/apache/camel/impl/DefaultCamelContextTest.java
+++ b/camel-core/src/test/java/org/apache/camel/impl/DefaultCamelContextTest.java
@@ -116,6 +116,7 @@ public class DefaultCamelContextTest extends TestSupport {
 
         list = ctx.removeEndpoints("log:*");
         assertEquals(2, list.size());
+
         Iterator<Endpoint> it = list.iterator();
         assertEquals("log://bar", it.next().getEndpointUri());
         assertEquals("log://baz", it.next().getEndpointUri());
diff --git a/parent/pom.xml b/parent/pom.xml
index f5fea3b5f45..52c90849c3c 100644
--- a/parent/pom.xml
+++ b/parent/pom.xml
@@ -55,6 +55,7 @@
     <commons-logging-version>1.1.1</commons-logging-version>
     <commons-net-version>2.2</commons-net-version>
     <commons-pool-version>1.5.4</commons-pool-version>
+    <concurrentlinkedhashmap.version>1.2</concurrentlinkedhashmap.version>
     <!-- When updating cxf-version, may need to change CXF version range in 
          platforms/karaf/features/src/main/resources/features.xml -->
     <cxf-version>2.4.2</cxf-version>
@@ -892,6 +893,13 @@
         <version>${project.version}</version>
       </dependency>
 
+        <!-- API -->
+      <dependency>
+        <groupId>com.googlecode.concurrentlinkedhashmap</groupId>
+        <artifactId>concurrentlinkedhashmap-lru</artifactId>
+        <version>${concurrentlinkedhashmap.version}</version>
+      </dependency>
+
       <!-- optional dependencies -->
       <dependency>
         <groupId>javax.xml.bind</groupId>
@@ -1608,6 +1616,12 @@
           </dependencies>
         </plugin>
 
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-shade-plugin</artifactId>
+          <version>1.4</version>
+        </plugin>
+
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-archetype-plugin</artifactId>
