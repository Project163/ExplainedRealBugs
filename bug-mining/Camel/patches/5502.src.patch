diff --git a/components/camel-file/src/main/java/org/apache/camel/component/file/GenericFileDefaultMoveExistingFileStrategy.java b/components/camel-file/src/main/java/org/apache/camel/component/file/GenericFileDefaultMoveExistingFileStrategy.java
index 6d1e6f7f8bf..9bd9f021823 100644
--- a/components/camel-file/src/main/java/org/apache/camel/component/file/GenericFileDefaultMoveExistingFileStrategy.java
+++ b/components/camel-file/src/main/java/org/apache/camel/component/file/GenericFileDefaultMoveExistingFileStrategy.java
@@ -25,6 +25,8 @@ import org.apache.camel.util.ObjectHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static org.apache.camel.component.file.MoveExistingFileStrategyUtils.completePartialRelativePath;
+
 public class GenericFileDefaultMoveExistingFileStrategy implements FileMoveExistingStrategy {
 
     private static final Logger LOG = LoggerFactory.getLogger(GenericFileDefaultMoveExistingFileStrategy.class);
@@ -49,14 +51,18 @@ public class GenericFileDefaultMoveExistingFileStrategy implements FileMoveExist
         dummy.getIn().setHeader(Exchange.FILE_PARENT, parent);
 
         String to = endpoint.getMoveExisting().evaluate(dummy, String.class);
-        // we must normalize it (to avoid having both \ and / in the name which
-        // confuses java.io.File)
-        to = FileUtil.normalizePath(to);
+
         if (ObjectHelper.isEmpty(to)) {
             throw new GenericFileOperationFailedException(
                     "moveExisting evaluated as empty String, cannot move existing file: " + fileName);
         }
 
+        to = completePartialRelativePath(to, onlyName, parent);
+
+        // we must normalize it (to avoid having both \ and / in the name which
+        // confuses java.io.File)
+        to = FileUtil.normalizePath(to);
+
         // ensure any paths is created before we rename as the renamed file may
         // be in a different path (which may be non exiting)
         // use java.io.File to compute the file path
diff --git a/components/camel-file/src/main/java/org/apache/camel/component/file/GenericFileProducer.java b/components/camel-file/src/main/java/org/apache/camel/component/file/GenericFileProducer.java
index ea252471094..e70d815cd14 100644
--- a/components/camel-file/src/main/java/org/apache/camel/component/file/GenericFileProducer.java
+++ b/components/camel-file/src/main/java/org/apache/camel/component/file/GenericFileProducer.java
@@ -146,7 +146,7 @@ public class GenericFileProducer<T> extends DefaultProducer {
                                     "File already exist: " + target + ". Cannot write new file.");
                         } else if (endpoint.getFileExist() == GenericFileExist.Move) {
                             // move any existing file first
-                            doMoveExistingFile(target);
+                            this.endpoint.getMoveExistingFileStrategy().moveExistingFile(endpoint, operations, target);
                         } else if (endpoint.isEagerDeleteTargetFile() && endpoint.getFileExist() == GenericFileExist.Override) {
                             // we override the target so we do this by deleting
                             // it so the temp file can be renamed later
@@ -242,34 +242,6 @@ public class GenericFileProducer<T> extends DefaultProducer {
         postWriteCheck(exchange);
     }
 
-    private void doMoveExistingFile(String fileName) throws GenericFileOperationFailedException {
-        // need to evaluate using a dummy and simulate the file first, to have
-        // access to all the file attributes
-        // create a dummy exchange as Exchange is needed for expression
-        // evaluation
-        // we support only the following 3 tokens.
-        Exchange dummy = endpoint.createExchange();
-        String parent = FileUtil.onlyPath(fileName);
-        String onlyName = FileUtil.stripPath(fileName);
-        dummy.getIn().setHeader(Exchange.FILE_NAME, fileName);
-        dummy.getIn().setHeader(Exchange.FILE_NAME_ONLY, onlyName);
-        dummy.getIn().setHeader(Exchange.FILE_PARENT, parent);
-
-        String to = endpoint.getMoveExisting().evaluate(dummy, String.class);
-        // we must normalize it (to avoid having both \ and / in the name which
-        // confuses java.io.File)
-        to = FileUtil.normalizePath(to);
-        if (ObjectHelper.isEmpty(to)) {
-            throw new GenericFileOperationFailedException(
-                    "moveExisting evaluated as empty String, cannot move existing file: " + fileName);
-        }
-
-        boolean renamed = operations.renameFile(fileName, to);
-        if (!renamed) {
-            throw new GenericFileOperationFailedException("Cannot rename file from: " + fileName + " to: " + to);
-        }
-    }
-
     /**
      * If we fail writing out a file, we will call this method. This hook is provided to disconnect from servers or
      * clean up files we created (if needed).
diff --git a/components/camel-file/src/main/java/org/apache/camel/component/file/MoveExistingFileStrategyUtils.java b/components/camel-file/src/main/java/org/apache/camel/component/file/MoveExistingFileStrategyUtils.java
new file mode 100644
index 00000000000..142614d7ed3
--- /dev/null
+++ b/components/camel-file/src/main/java/org/apache/camel/component/file/MoveExistingFileStrategyUtils.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.file;
+
+import java.io.File;
+
+import org.apache.camel.util.FileUtil;
+import org.apache.camel.util.ObjectHelper;
+
+public final class MoveExistingFileStrategyUtils {
+
+    private MoveExistingFileStrategyUtils() {
+    }
+
+    /**
+     * This method manipulates the destinationPath in case of moveExisting parameter is expressed as file language
+     * expression subdirectory name of the directoryName adding directoryName on top and file name at the end.
+     *
+     * for example, a camel endpoint like that:
+     *
+     * file://data/file?fileExist=Move&moveExisting=archive-${date:now:yyyyMMddHHmmssSSS}/
+     *
+     * directoryName = data/file, fileOnlyName = whatever.ext, destinationPath = archive-20201110115125770
+     *
+     * the outcome of this method would be data/file/archive-20201110115125770/whatever.ext
+     *
+     * @param  destinationPath the destination path
+     * @param  fileOnlyName    the file name without the path
+     * @param  directoryName   the path of the file to be moved/renamed
+     * @return                 the full destination path
+     */
+    public static String completePartialRelativePath(String destinationPath, String fileOnlyName, String directoryName) {
+
+        if (destinationPath.length() > 1 && destinationPath.endsWith("/")) {
+            destinationPath = destinationPath + fileOnlyName;
+        }
+
+        if (ObjectHelper.isNotEmpty(directoryName) && !destinationPath.startsWith(directoryName)
+                && !FileUtil.isAbsolute(new File(destinationPath))) {
+            destinationPath = directoryName + "/" + destinationPath;
+        }
+
+        return destinationPath;
+    }
+
+}
diff --git a/components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/FtpDefaultMoveExistingFileStrategy.java b/components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/FtpDefaultMoveExistingFileStrategy.java
index f233211e593..48225bc6f7c 100644
--- a/components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/FtpDefaultMoveExistingFileStrategy.java
+++ b/components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/FtpDefaultMoveExistingFileStrategy.java
@@ -29,6 +29,8 @@ import org.apache.commons.net.ftp.FTPFile;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static org.apache.camel.component.file.MoveExistingFileStrategyUtils.completePartialRelativePath;
+
 public class FtpDefaultMoveExistingFileStrategy implements FileMoveExistingStrategy {
 
     private static final Logger LOG = LoggerFactory.getLogger(FtpDefaultMoveExistingFileStrategy.class);
@@ -45,9 +47,9 @@ public class FtpDefaultMoveExistingFileStrategy implements FileMoveExistingStrat
         // evaluation
         // we support only the following 3 tokens.
         Exchange dummy = endpoint.createExchange();
-        // we only support relative paths for the ftp component, so dont provide
-        // any parent
-        String parent = null;
+        // we only support relative paths for the ftp component, so we strip out
+        //any leading separator
+        String parent = FileUtil.stripLeadingSeparator(FileUtil.onlyPath(fileName));
         String onlyName = FileUtil.stripPath(fileName);
         dummy.getIn().setHeader(Exchange.FILE_NAME, fileName);
         dummy.getIn().setHeader(Exchange.FILE_NAME_ONLY, onlyName);
@@ -58,12 +60,17 @@ public class FtpDefaultMoveExistingFileStrategy implements FileMoveExistingStrat
         // leading paths
         to = FileUtil.stripLeadingSeparator(to);
         // normalize accordingly to configuration
-        to = ((FtpEndpoint<FTPFile>) endpoint).getConfiguration().normalizePath(to);
+
         if (ObjectHelper.isEmpty(to)) {
             throw new GenericFileOperationFailedException(
                     "moveExisting evaluated as empty String, cannot move existing file: " + fileName);
         }
 
+        to = completePartialRelativePath(to, onlyName, parent);
+
+        // normalize accordingly to configuration
+        to = ((FtpEndpoint<FTPFile>) endpoint).getConfiguration().normalizePath(to);
+
         // do we have a sub directory
         String dir = FileUtil.onlyPath(to);
         if (dir != null) {
diff --git a/components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpDefaultMoveExistingFileStrategy.java b/components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpDefaultMoveExistingFileStrategy.java
index 4a8b706f482..f139fbb7d01 100644
--- a/components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpDefaultMoveExistingFileStrategy.java
+++ b/components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpDefaultMoveExistingFileStrategy.java
@@ -26,6 +26,8 @@ import org.apache.camel.util.ObjectHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static org.apache.camel.component.file.MoveExistingFileStrategyUtils.completePartialRelativePath;
+
 public class SftpDefaultMoveExistingFileStrategy implements FileMoveExistingStrategy {
 
     private static final Logger LOG = LoggerFactory.getLogger(SftpDefaultMoveExistingFileStrategy.class);
@@ -42,25 +44,30 @@ public class SftpDefaultMoveExistingFileStrategy implements FileMoveExistingStra
         // evaluation
         // we support only the following 3 tokens.
         Exchange dummy = endpoint.createExchange();
-        // we only support relative paths for the ftp component, so dont provide
-        // any parent
-        String parent = null;
+        // we only support relative paths for the ftp component, so we strip out
+        //any leading separator
+        String parent = FileUtil.stripLeadingSeparator(FileUtil.onlyPath(fileName));
         String onlyName = FileUtil.stripPath(fileName);
         dummy.getIn().setHeader(Exchange.FILE_NAME, fileName);
         dummy.getIn().setHeader(Exchange.FILE_NAME_ONLY, onlyName);
         dummy.getIn().setHeader(Exchange.FILE_PARENT, parent);
 
         String to = endpoint.getMoveExisting().evaluate(dummy, String.class);
+
         // we only support relative paths for the ftp component, so strip any
         // leading paths
         to = FileUtil.stripLeadingSeparator(to);
-        // normalize accordingly to configuration
-        to = ((SftpEndpoint) endpoint).getConfiguration().normalizePath(to);
+
         if (ObjectHelper.isEmpty(to)) {
             throw new GenericFileOperationFailedException(
                     "moveExisting evaluated as empty String, cannot move existing file: " + fileName);
         }
 
+        to = completePartialRelativePath(to, onlyName, parent);
+
+        // normalize accordingly to configuration
+        to = ((SftpEndpoint) endpoint).getConfiguration().normalizePath(to);
+
         // do we have a sub directory
         String dir = FileUtil.onlyPath(to);
         if (dir != null) {
diff --git a/components/camel-ftp/src/test/java/org/apache/camel/component/file/remote/FtpProducerMoveExistingTest.java b/components/camel-ftp/src/test/java/org/apache/camel/component/file/remote/FtpProducerMoveExistingTest.java
index cc69e9d68c6..06d49078d8b 100644
--- a/components/camel-ftp/src/test/java/org/apache/camel/component/file/remote/FtpProducerMoveExistingTest.java
+++ b/components/camel-ftp/src/test/java/org/apache/camel/component/file/remote/FtpProducerMoveExistingTest.java
@@ -17,6 +17,10 @@
 package org.apache.camel.component.file.remote;
 
 import java.io.File;
+import java.io.FilenameFilter;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Random;
 
 import org.apache.camel.CamelExecutionException;
 import org.apache.camel.Exchange;
@@ -84,6 +88,78 @@ public class FtpProducerMoveExistingTest extends FtpServerTestSupport {
                 context.getTypeConverter().convertTo(String.class, new File(FTP_ROOT_DIR + "/move/renamed-hello.txt")));
     }
 
+    @Test
+    public void testExistingFileExistsTempFileNameMoveDynamicSubdir() throws Exception {
+        final String subdirPrefix = generateRandomString(5);
+        template.sendBodyAndHeader(getFtpUrl() + "&tempFileName=${file:onlyname}.temp&moveExisting=" + subdirPrefix
+                                   + "-${date:now:yyyyMMddHHmmssSSS}/",
+                "Hello World", Exchange.FILE_NAME, "hello.txt");
+        template.sendBodyAndHeader(getFtpUrl() + "&tempFileName=${file:onlyname}.temp&moveExisting=" + subdirPrefix
+                                   + "-${date:now:yyyyMMddHHmmssSSS}/",
+                "Bye World", Exchange.FILE_NAME, "hello.txt");
+        assertFileExists(FTP_ROOT_DIR + "/move/hello.txt");
+        assertEquals("Bye World",
+                context.getTypeConverter().convertTo(String.class, new File(FTP_ROOT_DIR + "/move/hello.txt")));
+
+        File folder = new File(FTP_ROOT_DIR + "/move");
+        String[] directories = folder.list(new FilenameFilter() {
+            @Override
+            public boolean accept(File current, String name) {
+                String date = new SimpleDateFormat("yyyyMMdd").format(new Date());
+                return new File(current, name).isDirectory() && name.startsWith(subdirPrefix + "-" + date);
+            }
+        });
+        assertEquals(1, directories.length);
+        File movedFilePath = new File(FTP_ROOT_DIR + "/move/" + directories[0] + "/hello.txt");
+
+        assertTrue(movedFilePath.exists());
+        assertEquals("Hello World", context.getTypeConverter().convertTo(String.class, movedFilePath));
+    }
+
+    @Test
+    public void testExistingFileExistsTempFileNameMoveDynamicSubdirFullPath() throws Exception {
+        final String subdirPrefix = generateRandomString(5);
+        template.sendBodyAndHeader(getFtpUrl() + "&tempFileName=${file:onlyname}.temp&moveExisting=${file:parent}/"
+                                   + subdirPrefix + "-${date:now:yyyyMMddHHmmssSSS}/${file:onlyname}",
+                "Hello World", Exchange.FILE_NAME, "hello.txt");
+        template.sendBodyAndHeader(getFtpUrl() + "&tempFileName=${file:onlyname}.temp&moveExisting=${file:parent}/"
+                                   + subdirPrefix + "-${date:now:yyyyMMddHHmmssSSS}/${file:onlyname}",
+                "Bye World", Exchange.FILE_NAME, "hello.txt");
+        assertFileExists(FTP_ROOT_DIR + "/move/hello.txt");
+        assertEquals("Bye World",
+                context.getTypeConverter().convertTo(String.class, new File(FTP_ROOT_DIR + "/move/hello.txt")));
+
+        File folder = new File(FTP_ROOT_DIR + "/move");
+        String[] directories = folder.list(new FilenameFilter() {
+            @Override
+            public boolean accept(File current, String name) {
+                String date = new SimpleDateFormat("yyyyMMdd").format(new Date());
+                return new File(current, name).isDirectory() && name.startsWith(subdirPrefix + "-" + date);
+            }
+        });
+        assertEquals(1, directories.length);
+        File movedFilePath = new File(FTP_ROOT_DIR + "/move/" + directories[0] + "/hello.txt");
+
+        assertTrue(movedFilePath.exists());
+        assertEquals("Hello World", context.getTypeConverter().convertTo(String.class, movedFilePath));
+    }
+
+    @Test
+    public void testExistingFileExistsTempFilenameMoveSubDir() throws Exception {
+        template.sendBodyAndHeader(getFtpUrl() + "&tempFileName=${file:onlyname}.temp&moveExisting=archive", "Hello World",
+                Exchange.FILE_NAME, "hello.txt");
+        template.sendBodyAndHeader(getFtpUrl() + "&tempFileName=${file:onlyname}.temp&moveExisting=archive", "Bye World",
+                Exchange.FILE_NAME, "hello.txt");
+
+        assertFileExists(FTP_ROOT_DIR + "/move/hello.txt");
+        assertEquals("Bye World",
+                context.getTypeConverter().convertTo(String.class, new File(FTP_ROOT_DIR + "/move/hello.txt")));
+
+        assertFileExists(FTP_ROOT_DIR + "/move/archive/hello.txt");
+        assertEquals("Hello World",
+                context.getTypeConverter().convertTo(String.class, new File(FTP_ROOT_DIR + "/move/archive/hello.txt")));
+    }
+
     @Test
     public void testExistingFileExistsMoveSubDir() throws Exception {
         template.sendBodyAndHeader(getFtpUrl() + "&moveExisting=backup", "Hello World", Exchange.FILE_NAME, "hello.txt");
@@ -160,4 +236,16 @@ public class FtpProducerMoveExistingTest extends FtpServerTestSupport {
         assertEquals("Old file",
                 context.getTypeConverter().convertTo(String.class, new File(FTP_ROOT_DIR + "/move/renamed-hello.txt")));
     }
+
+    private String generateRandomString(int targetStringLength) {
+        int leftLimit = 97; // letter 'a'
+        int rightLimit = 122; // letter 'z'
+        Random random = new Random();
+        StringBuilder buffer = new StringBuilder(targetStringLength);
+        for (int i = 0; i < targetStringLength; i++) {
+            int randomLimitedInt = leftLimit + (int) (random.nextFloat() * (rightLimit - leftLimit + 1));
+            buffer.append((char) randomLimitedInt);
+        }
+        return buffer.toString();
+    }
 }
diff --git a/core/camel-core/src/test/java/org/apache/camel/component/file/FileProducerMoveExistingTest.java b/core/camel-core/src/test/java/org/apache/camel/component/file/FileProducerMoveExistingTest.java
index c07a31b60af..bd092720694 100644
--- a/core/camel-core/src/test/java/org/apache/camel/component/file/FileProducerMoveExistingTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/component/file/FileProducerMoveExistingTest.java
@@ -17,6 +17,9 @@
 package org.apache.camel.component.file;
 
 import java.io.File;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Random;
 
 import org.apache.camel.CamelExecutionException;
 import org.apache.camel.ContextTestSupport;
@@ -24,6 +27,7 @@ import org.apache.camel.Exchange;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
+import static java.io.File.separator;
 import static org.junit.jupiter.api.Assertions.*;
 
 /**
@@ -84,6 +88,166 @@ public class FileProducerMoveExistingTest extends ContextTestSupport {
                 context.getTypeConverter().convertTo(String.class, new File("target/data/file/renamed-hello.txt")));
     }
 
+    @Test
+    public void testExistingFileExistsTempFileName2() throws Exception {
+        template.sendBodyAndHeader(
+                "file://target/data/file?tempFileName=${file:onlyname}.temp&fileExist=Move&moveExisting=renamed",
+                "Hello World",
+                Exchange.FILE_NAME, "hello.txt");
+        template.sendBodyAndHeader(
+                "file://target/data/file?tempFileName=${file:onlyname}.temp&fileExist=Move&moveExisting=renamed",
+                "Bye World",
+                Exchange.FILE_NAME, "hello.txt");
+
+        assertFileExists("target/data/file/hello.txt");
+        assertEquals("Bye World", context.getTypeConverter().convertTo(String.class, new File("target/data/file/hello.txt")));
+
+        assertFileExists("target/data/file/renamed/hello.txt");
+        assertEquals("Hello World",
+                context.getTypeConverter().convertTo(String.class, new File("target/data/file/renamed/hello.txt")));
+    }
+
+    @Test
+    public void testFailOnMoveExistingFileExistsEagerDeleteFalseTempFileName() throws Exception {
+        final String filename = "hello.txt";
+        final String fileParent = "target" + "/" + "data" + "/" + "file";
+
+        template.sendBodyAndHeader("file://target/data/file?tempFileName=${file:onlyname}.temp", "First File",
+                Exchange.FILE_NAME,
+                "renamed-hello.txt");
+
+        template.sendBodyAndHeader(
+                "file://target/data/file?tempFileName=${file:onlyname}.temp&fileExist=Move&moveExisting=${file:parent}/renamed-${file:onlyname}&eagerDeleteTargetFile=false",
+                "Second File", Exchange.FILE_NAME, filename);
+        // we should be okay as we will just delete any existing file
+        template.sendBodyAndHeader(
+                "file://target/data/file?tempFileName=${file:onlyname}.temp&fileExist=Move&moveExisting=${file:parent}/renamed-${file:onlyname}&eagerDeleteTargetFile=false",
+                "Third File", Exchange.FILE_NAME, filename);
+
+        // we could  write the new file so the old context should be moved
+        assertFileExists(fileParent + "/" + filename);
+        assertEquals("Third File",
+                context.getTypeConverter().convertTo(String.class, new File(fileParent + "/" + filename)));
+
+        // and the renamed file should not be overridden
+        assertFileExists(fileParent + "/" + "renamed-" + filename);
+        assertEquals("First File",
+                context.getTypeConverter().convertTo(String.class, new File(fileParent + "/" + "renamed-" + filename)));
+    }
+
+    @Test
+    public void testExistingFileExistsTempFileNameMoveDynamicSubdirFullPath() throws Exception {
+        final String subdirPrefix = generateRandomString(5);
+        final String dynamicPath = "${file:parent}/" + subdirPrefix + "-${date:now:yyyyMMddHHmmssSSS}/${file:onlyname}";
+        final String tempFilename = "tempFileName=${file:onlyname}.temp&";
+        testDynamicSubdir(subdirPrefix, dynamicPath, tempFilename);
+    }
+
+    @Test
+    public void testExistingFileExistsTempFileNameMoveDynamicSubdir() throws Exception {
+        final String subdirPrefix = generateRandomString(5);
+        final String dynamicPath = subdirPrefix + "-${date:now:yyyyMMddHHmmssSSS}/";
+        final String tempFilename = "tempFileName=${file:onlyname}.temp&";
+        testDynamicSubdir(subdirPrefix, dynamicPath, tempFilename);
+    }
+
+    @Test
+    public void testExistingFileExistsMoveDynamicSubdir() throws Exception {
+        final String subdirPrefix = generateRandomString(5);
+        final String dynamicPath = subdirPrefix + "-${date:now:yyyyMMddHHmmssSSS}/";
+        final String tempFilename = "";
+        testDynamicSubdir(subdirPrefix, dynamicPath, tempFilename);
+    }
+
+    @Test
+    public void testExistingFileExistsMoveDynamicSubdirFullPath() throws Exception {
+        final String subdirPrefix = generateRandomString(5);
+        final String dynamicPath = "${file:parent}/" + subdirPrefix + "-${date:now:yyyyMMddHHmmssSSS}/${file:onlyname}";
+        final String tempFilename = "";
+        testDynamicSubdir(subdirPrefix, dynamicPath, tempFilename);
+    }
+
+    private void testDynamicSubdir(String subdirPrefix, String dynamicPath, String tempFilename) {
+        final String filename = "howdy.txt";
+        final String fileContent = "Hello World";
+        final String fileParent = "target" + separator + "data" + separator + "file";
+        template.sendBodyAndHeader("file://target/data/file?" + tempFilename + "fileExist=Move&moveExisting="
+                                   + dynamicPath,
+                fileContent, Exchange.FILE_NAME, filename);
+        template.sendBodyAndHeader("file://target/data/file?" + tempFilename + "fileExist=Move&moveExisting="
+                                   + dynamicPath,
+                fileContent, Exchange.FILE_NAME, filename);
+        assertFileExists(fileParent + separator + filename);
+        assertEquals(fileContent,
+                context.getTypeConverter().convertTo(String.class, new File(fileParent + separator + filename)));
+
+        File folder = new File(fileParent);
+        String[] directories = folder.list((current, name) -> {
+            String date = new SimpleDateFormat("yyyyMMdd").format(new Date());
+            return new File(current, name).isDirectory() && name.startsWith(subdirPrefix + "-" + date);
+        });
+        assertEquals(1, directories.length);
+        File movedFilePath = new File(fileParent + separator + directories[0] + separator + filename);
+
+        assertTrue(movedFilePath.exists());
+        assertEquals(fileContent, context.getTypeConverter().convertTo(String.class, movedFilePath));
+    }
+
+    @Test
+    public void testExistingFileExistsTempFileNameMoveSubDir() throws Exception {
+
+        final String filename = "howdy.txt";
+        final String fileContent = "Hello World";
+        final String fileParent = "target" + separator + "data" + separator + "file";
+        final String archivePath = fileParent + separator + "archive";
+
+        template.sendBodyAndHeader(
+                "file://target/data/file?tempFileName=${file:onlyname}.temp&fileExist=Move&moveExisting=archive",
+                fileContent, Exchange.FILE_NAME, filename);
+        template.sendBodyAndHeader(
+                "file://target/data/file?tempFileName=${file:onlyname}.temp&fileExist=Move&moveExisting=archive",
+                fileContent, Exchange.FILE_NAME, filename);
+
+        assertFileExists(fileParent + separator + filename);
+        assertEquals(fileContent,
+                context.getTypeConverter().convertTo(String.class, new File(fileParent + separator + filename)));
+
+        assertFileExists(archivePath + separator + filename);
+        assertEquals(fileContent,
+                context.getTypeConverter().convertTo(String.class, new File(archivePath + separator + filename)));
+    }
+
+    @Test
+    public void testExistingFileExistsTempFileNameRename() throws Exception {
+
+        final String filename = "howdy.txt";
+        final String fileContent1 = "Hello World1";
+        final String fileContent2 = "Hello World2";
+
+        final String fileParent = "target" + separator + "data" + separator + "file";
+
+        template.sendBodyAndHeader(
+                "file://target/data/file?tempFileName=${file:onlyname}.temp&fileExist=Move&moveExisting=${file:onlyname}.${date:now:yyyyMMddHHmmssSSS}",
+                fileContent1, Exchange.FILE_NAME, filename);
+        template.sendBodyAndHeader(
+                "file://target/data/file?tempFileName=${file:onlyname}.temp&fileExist=Move&moveExisting=${file:onlyname}.${date:now:yyyyMMddHHmmssSSS}",
+                fileContent2, Exchange.FILE_NAME, filename);
+
+        File folder = new File(fileParent);
+        String[] files = folder.list((current, name) -> {
+            String date = new SimpleDateFormat("yyyyMMdd").format(new Date());
+            return new File(current, name).isFile() && name.startsWith(filename + "." + date);
+        });
+        assertEquals(1, files.length);
+        File movedFilePath = new File(fileParent + separator + files[0]);
+
+        assertTrue(movedFilePath.exists());
+        assertEquals(fileContent1, context.getTypeConverter().convertTo(String.class, movedFilePath));
+        assertEquals(fileContent2,
+                context.getTypeConverter().convertTo(String.class, new File(fileParent + separator + filename)));
+
+    }
+
     @Test
     public void testExistingFileExistsMoveSubDir() throws Exception {
         template.sendBodyAndHeader("file://target/data/file?fileExist=Move&moveExisting=backup", "Hello World",
@@ -155,4 +319,16 @@ public class FileProducerMoveExistingTest extends ContextTestSupport {
                 context.getTypeConverter().convertTo(String.class, new File("target/data/file/renamed-hello.txt")));
     }
 
+    private String generateRandomString(int targetStringLength) {
+        int leftLimit = 97; // letter 'a'
+        int rightLimit = 122; // letter 'z'
+        Random random = new Random();
+        StringBuilder buffer = new StringBuilder(targetStringLength);
+        for (int i = 0; i < targetStringLength; i++) {
+            int randomLimitedInt = leftLimit + (int) (random.nextFloat() * (rightLimit - leftLimit + 1));
+            buffer.append((char) randomLimitedInt);
+        }
+        return buffer.toString();
+    }
+
 }
