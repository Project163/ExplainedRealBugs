diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/xquery.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/xquery.json
index 5df5016f9a4..187fc5f522f 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/xquery.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/xquery.json
@@ -33,38 +33,36 @@
   "properties": {
     "resourceUri": { "index": 0, "kind": "path", "displayName": "Resource Uri", "group": "common", "label": "", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The name of the template to load from classpath or file system" },
     "allowStAX": { "index": 1, "kind": "parameter", "displayName": "Allow St AX", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to allow using StAX mode" },
-    "headerName": { "index": 2, "kind": "parameter", "displayName": "Header Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Message header as the input source instead of Message body." },
-    "namespacePrefixes": { "index": 3, "kind": "parameter", "displayName": "Namespace Prefixes", "group": "common", "label": "", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.String>", "deprecated": false, "autowired": false, "secret": false, "description": "Allows to control which namespace prefixes to use for a set of namespace mappings" },
-    "propertyName": { "index": 4, "kind": "parameter", "displayName": "Property Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Exchange property as the input source instead of Message body." },
-    "resultsFormat": { "index": 5, "kind": "parameter", "displayName": "Results Format", "group": "common", "label": "", "required": false, "type": "object", "javaType": "org.apache.camel.component.xquery.ResultFormat", "enum": [ "Bytes", "BytesSource", "DOM", "DOMSource", "List", "String", "StringSource" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "DOM", "description": "What output result to use" },
-    "resultType": { "index": 6, "kind": "parameter", "displayName": "Result Type", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.Class<java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "What output result to use defined as a class" },
-    "stripsAllWhiteSpace": { "index": 7, "kind": "parameter", "displayName": "Strips All White Space", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to strip all whitespaces" },
-    "variableName": { "index": 8, "kind": "parameter", "displayName": "Variable Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a variable as the input source instead of Message body." },
-    "sendEmptyMessageWhenIdle": { "index": 9, "kind": "parameter", "displayName": "Send Empty Message When Idle", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead." },
-    "bridgeErrorHandler": { "index": 10, "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
-    "exceptionHandler": { "index": 11, "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
-    "exchangePattern": { "index": 12, "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
-    "pollStrategy": { "index": 13, "kind": "parameter", "displayName": "Poll Strategy", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.PollingConsumerPollStrategy", "deprecated": false, "autowired": false, "secret": false, "description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel." },
-    "lazyStartProducer": { "index": 14, "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
-    "configuration": { "index": 15, "kind": "parameter", "displayName": "Configuration", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.Configuration", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon configuration" },
-    "configurationProperties": { "index": 16, "kind": "parameter", "displayName": "Configuration Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "To set custom Saxon configuration properties" },
-    "moduleURIResolver": { "index": 17, "kind": "parameter", "displayName": "Module URIResolver", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.lib.ModuleURIResolver", "deprecated": false, "autowired": false, "secret": false, "description": "To use the custom ModuleURIResolver" },
-    "parameters": { "index": 18, "kind": "parameter", "displayName": "Parameters", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Additional parameters" },
-    "properties": { "index": 19, "kind": "parameter", "displayName": "Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Properties", "deprecated": false, "autowired": false, "secret": false, "description": "Properties to configure the serialization parameters" },
-    "staticQueryContext": { "index": 20, "kind": "parameter", "displayName": "Static Query Context", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.query.StaticQueryContext", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon StaticQueryContext" },
-    "backoffErrorThreshold": { "index": 21, "kind": "parameter", "displayName": "Backoff Error Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in." },
-    "backoffIdleThreshold": { "index": 22, "kind": "parameter", "displayName": "Backoff Idle Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in." },
-    "backoffMultiplier": { "index": 23, "kind": "parameter", "displayName": "Backoff Multiplier", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles\/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and\/or backoffErrorThreshold must also be configured." },
-    "delay": { "index": 24, "kind": "parameter", "displayName": "Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 500, "description": "Milliseconds before the next poll." },
-    "greedy": { "index": 25, "kind": "parameter", "displayName": "Greedy", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages." },
-    "initialDelay": { "index": 26, "kind": "parameter", "displayName": "Initial Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Milliseconds before the first poll starts." },
-    "repeatCount": { "index": 27, "kind": "parameter", "displayName": "Repeat Count", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever." },
-    "runLoggingLevel": { "index": 28, "kind": "parameter", "displayName": "Run Logging Level", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "org.apache.camel.LoggingLevel", "enum": [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "TRACE", "description": "The consumer logs a start\/complete log line when it polls. This option allows you to configure the logging level for that." },
-    "scheduledExecutorService": { "index": 29, "kind": "parameter", "displayName": "Scheduled Executor Service", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.ScheduledExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "Allows for configuring a custom\/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool." },
-    "scheduler": { "index": 30, "kind": "parameter", "displayName": "Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.lang.Object", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "none", "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler" },
-    "schedulerProperties": { "index": 31, "kind": "parameter", "displayName": "Scheduler Properties", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "prefix": "scheduler.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler." },
-    "startScheduler": { "index": 32, "kind": "parameter", "displayName": "Start Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether the scheduler should be auto started." },
-    "timeUnit": { "index": 33, "kind": "parameter", "displayName": "Time Unit", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.TimeUnit", "enum": [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "MILLISECONDS", "description": "Time unit for initialDelay and delay options." },
-    "useFixedDelay": { "index": 34, "kind": "parameter", "displayName": "Use Fixed Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details." }
+    "namespacePrefixes": { "index": 2, "kind": "parameter", "displayName": "Namespace Prefixes", "group": "common", "label": "", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.String>", "deprecated": false, "autowired": false, "secret": false, "description": "Allows to control which namespace prefixes to use for a set of namespace mappings" },
+    "resultsFormat": { "index": 3, "kind": "parameter", "displayName": "Results Format", "group": "common", "label": "", "required": false, "type": "object", "javaType": "org.apache.camel.component.xquery.ResultFormat", "enum": [ "Bytes", "BytesSource", "DOM", "DOMSource", "List", "String", "StringSource" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "DOM", "description": "What output result to use" },
+    "resultType": { "index": 4, "kind": "parameter", "displayName": "Result Type", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.Class<java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "What output result to use defined as a class" },
+    "source": { "index": 5, "kind": "parameter", "displayName": "Source", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "stripsAllWhiteSpace": { "index": 6, "kind": "parameter", "displayName": "Strips All White Space", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to strip all whitespaces" },
+    "sendEmptyMessageWhenIdle": { "index": 7, "kind": "parameter", "displayName": "Send Empty Message When Idle", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead." },
+    "bridgeErrorHandler": { "index": 8, "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
+    "exceptionHandler": { "index": 9, "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
+    "exchangePattern": { "index": 10, "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
+    "pollStrategy": { "index": 11, "kind": "parameter", "displayName": "Poll Strategy", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.PollingConsumerPollStrategy", "deprecated": false, "autowired": false, "secret": false, "description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel." },
+    "lazyStartProducer": { "index": 12, "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
+    "configuration": { "index": 13, "kind": "parameter", "displayName": "Configuration", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.Configuration", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon configuration" },
+    "configurationProperties": { "index": 14, "kind": "parameter", "displayName": "Configuration Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "To set custom Saxon configuration properties" },
+    "moduleURIResolver": { "index": 15, "kind": "parameter", "displayName": "Module URIResolver", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.lib.ModuleURIResolver", "deprecated": false, "autowired": false, "secret": false, "description": "To use the custom ModuleURIResolver" },
+    "parameters": { "index": 16, "kind": "parameter", "displayName": "Parameters", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Additional parameters" },
+    "properties": { "index": 17, "kind": "parameter", "displayName": "Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Properties", "deprecated": false, "autowired": false, "secret": false, "description": "Properties to configure the serialization parameters" },
+    "staticQueryContext": { "index": 18, "kind": "parameter", "displayName": "Static Query Context", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.query.StaticQueryContext", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon StaticQueryContext" },
+    "backoffErrorThreshold": { "index": 19, "kind": "parameter", "displayName": "Backoff Error Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in." },
+    "backoffIdleThreshold": { "index": 20, "kind": "parameter", "displayName": "Backoff Idle Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in." },
+    "backoffMultiplier": { "index": 21, "kind": "parameter", "displayName": "Backoff Multiplier", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles\/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and\/or backoffErrorThreshold must also be configured." },
+    "delay": { "index": 22, "kind": "parameter", "displayName": "Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 500, "description": "Milliseconds before the next poll." },
+    "greedy": { "index": 23, "kind": "parameter", "displayName": "Greedy", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages." },
+    "initialDelay": { "index": 24, "kind": "parameter", "displayName": "Initial Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Milliseconds before the first poll starts." },
+    "repeatCount": { "index": 25, "kind": "parameter", "displayName": "Repeat Count", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever." },
+    "runLoggingLevel": { "index": 26, "kind": "parameter", "displayName": "Run Logging Level", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "org.apache.camel.LoggingLevel", "enum": [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "TRACE", "description": "The consumer logs a start\/complete log line when it polls. This option allows you to configure the logging level for that." },
+    "scheduledExecutorService": { "index": 27, "kind": "parameter", "displayName": "Scheduled Executor Service", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.ScheduledExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "Allows for configuring a custom\/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool." },
+    "scheduler": { "index": 28, "kind": "parameter", "displayName": "Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.lang.Object", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "none", "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler" },
+    "schedulerProperties": { "index": 29, "kind": "parameter", "displayName": "Scheduler Properties", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "prefix": "scheduler.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler." },
+    "startScheduler": { "index": 30, "kind": "parameter", "displayName": "Start Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether the scheduler should be auto started." },
+    "timeUnit": { "index": 31, "kind": "parameter", "displayName": "Time Unit", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.TimeUnit", "enum": [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "MILLISECONDS", "description": "Time unit for initialDelay and delay options." },
+    "useFixedDelay": { "index": 32, "kind": "parameter", "displayName": "Use Fixed Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details." }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/datasonnet.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/datasonnet.json
index aaf22efac7c..46b2629991c 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/datasonnet.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/datasonnet.json
@@ -20,10 +20,8 @@
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
     "bodyMediaType": { "index": 2, "kind": "attribute", "displayName": "Body Media Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The String representation of the message's body MediaType" },
     "outputMediaType": { "index": 3, "kind": "attribute", "displayName": "Output Media Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The String representation of the MediaType to output" },
-    "variableName": { "index": 4, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 5, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 6, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 7, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 8, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 4, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/hl7terser.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/hl7terser.json
index f329ef92cf8..d8a78847953 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/hl7terser.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/hl7terser.json
@@ -18,10 +18,8 @@
   "properties": {
     "id": { "index": 0, "kind": "attribute", "displayName": "Id", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the id of this node" },
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
-    "variableName": { "index": 2, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 3, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 4, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 2, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 3, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 4, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/jq.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/jq.json
index 96cb84de67d..4b660303d61 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/jq.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/jq.json
@@ -18,10 +18,8 @@
   "properties": {
     "id": { "index": 0, "kind": "attribute", "displayName": "Id", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the id of this node" },
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
-    "variableName": { "index": 2, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 3, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 4, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 2, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 3, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 4, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/jsonpath.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/jsonpath.json
index 7df00004fa3..13bcc8d8180 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/jsonpath.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/jsonpath.json
@@ -24,10 +24,8 @@
     "writeAsString": { "index": 5, "kind": "attribute", "displayName": "Write As String", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to write the output of each row\/element as a JSON String value instead of a Map\/POJO value." },
     "unpackArray": { "index": 6, "kind": "attribute", "displayName": "Unpack Array", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to unpack a single element json-array into an object." },
     "option": { "index": 7, "kind": "attribute", "displayName": "Option", "label": "advanced", "required": false, "type": "enum", "javaType": "java.lang.String", "enum": [ "DEFAULT_PATH_LEAF_TO_NULL", "ALWAYS_RETURN_LIST", "AS_PATH_LIST", "SUPPRESS_EXCEPTIONS", "REQUIRE_PROPERTIES" ], "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional options on JSONPath. Multiple values can be separated by comma." },
-    "variableName": { "index": 8, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 9, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 10, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 11, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 12, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 8, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 9, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 10, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/tokenize.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/tokenize.json
index 497c8a11f53..d59c5aa9b5c 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/tokenize.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/tokenize.json
@@ -26,10 +26,8 @@
     "group": { "index": 7, "kind": "attribute", "displayName": "Group", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To group N parts together, for example to split big files into chunks of 1000 lines. You can use simple language as the group to support dynamic group sizes." },
     "groupDelimiter": { "index": 8, "kind": "attribute", "displayName": "Group Delimiter", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the delimiter to use when grouping. If this has not been set then token will be used as the delimiter." },
     "skipFirst": { "index": 9, "kind": "attribute", "displayName": "Skip First", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "To skip the very first element" },
-    "variableName": { "index": 10, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 11, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 12, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 13, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 14, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 10, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 11, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 12, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xpath.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xpath.json
index f834f12ece3..ba5ae99aed3 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xpath.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xpath.json
@@ -27,10 +27,8 @@
     "threadSafety": { "index": 8, "kind": "attribute", "displayName": "Thread Safety", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to enable thread-safety for the returned result of the xpath expression. This applies to when using NODESET as the result type, and the returned set has multiple elements. In this situation there can be thread-safety issues if you process the NODESET concurrently such as from a Camel Splitter EIP in parallel processing mode. This option prevents concurrency issues by doing defensive copies of the nodes. It is recommended to turn this option on if you are using camel-saxon or Saxon in your application. Saxon has thread-safety issues which can be prevented by turning this option on." },
     "preCompile": { "index": 9, "kind": "attribute", "displayName": "Pre Compile", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to enable pre-compiling the xpath expression during initialization phase. pre-compile is enabled by default. This can be used to turn off, for example in cases the compilation phase is desired at the starting phase, such as if the application is ahead of time compiled (for example with camel-quarkus) which would then load the xpath factory of the built operating system, and not a JVM runtime." },
     "namespace": { "index": 10, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 11, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 12, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 13, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 14, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 15, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 11, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 12, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 13, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xquery.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xquery.json
index f08be39928e..56fbc40ed72 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xquery.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xquery.json
@@ -20,10 +20,8 @@
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
     "configurationRef": { "index": 2, "kind": "attribute", "displayName": "Configuration Ref", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Reference to a saxon configuration instance in the registry to use for xquery (requires camel-saxon). This may be needed to add custom functions to a saxon configuration, so these custom functions can be used in xquery expressions." },
     "namespace": { "index": 3, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 4, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 5, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 6, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 7, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 8, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 4, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xtokenize.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xtokenize.json
index 42e98419416..c51276739f5 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xtokenize.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/languages/xtokenize.json
@@ -21,10 +21,8 @@
     "mode": { "index": 2, "kind": "attribute", "displayName": "Mode", "required": false, "type": "enum", "javaType": "java.lang.String", "enum": [ "i", "w", "u", "t" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "i", "description": "The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element" },
     "group": { "index": 3, "kind": "attribute", "displayName": "Group", "required": false, "type": "integer", "javaType": "java.lang.Integer", "deprecated": false, "autowired": false, "secret": false, "description": "To group N parts together" },
     "namespace": { "index": 4, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 5, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 6, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 7, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 8, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 9, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 5, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 6, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 7, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/datasonnet.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/datasonnet.json
index 6b4bfe1e4ba..d73586cff49 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/datasonnet.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/datasonnet.json
@@ -17,10 +17,8 @@
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
     "bodyMediaType": { "index": 2, "kind": "attribute", "displayName": "Body Media Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The String representation of the message's body MediaType" },
     "outputMediaType": { "index": 3, "kind": "attribute", "displayName": "Output Media Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The String representation of the MediaType to output" },
-    "variableName": { "index": 4, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 5, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 6, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 7, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 8, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 4, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/hl7terser.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/hl7terser.json
index 2d0e1f3bc50..21bdacde06b 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/hl7terser.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/hl7terser.json
@@ -15,10 +15,8 @@
   "properties": {
     "id": { "index": 0, "kind": "attribute", "displayName": "Id", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the id of this node" },
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
-    "variableName": { "index": 2, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 3, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 4, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 2, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 3, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 4, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/jq.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/jq.json
index ca29248dc3d..e7682cee3a2 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/jq.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/jq.json
@@ -15,10 +15,8 @@
   "properties": {
     "id": { "index": 0, "kind": "attribute", "displayName": "Id", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the id of this node" },
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
-    "variableName": { "index": 2, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 3, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 4, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 2, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 3, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 4, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/jsonpath.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/jsonpath.json
index e1911e5e387..ffb339e6bac 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/jsonpath.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/jsonpath.json
@@ -21,10 +21,8 @@
     "writeAsString": { "index": 5, "kind": "attribute", "displayName": "Write As String", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to write the output of each row\/element as a JSON String value instead of a Map\/POJO value." },
     "unpackArray": { "index": 6, "kind": "attribute", "displayName": "Unpack Array", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to unpack a single element json-array into an object." },
     "option": { "index": 7, "kind": "attribute", "displayName": "Option", "label": "advanced", "required": false, "type": "enum", "javaType": "java.lang.String", "enum": [ "DEFAULT_PATH_LEAF_TO_NULL", "ALWAYS_RETURN_LIST", "AS_PATH_LIST", "SUPPRESS_EXCEPTIONS", "REQUIRE_PROPERTIES" ], "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional options on JSONPath. Multiple values can be separated by comma." },
-    "variableName": { "index": 8, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 9, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 10, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 11, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 12, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 8, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 9, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 10, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/tokenize.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/tokenize.json
index 02311acd6e6..734b52e2070 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/tokenize.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/tokenize.json
@@ -23,10 +23,8 @@
     "group": { "index": 7, "kind": "attribute", "displayName": "Group", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To group N parts together, for example to split big files into chunks of 1000 lines. You can use simple language as the group to support dynamic group sizes." },
     "groupDelimiter": { "index": 8, "kind": "attribute", "displayName": "Group Delimiter", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the delimiter to use when grouping. If this has not been set then token will be used as the delimiter." },
     "skipFirst": { "index": 9, "kind": "attribute", "displayName": "Skip First", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "To skip the very first element" },
-    "variableName": { "index": 10, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 11, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 12, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 13, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 14, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 10, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 11, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 12, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xpath.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xpath.json
index bc1b25d8257..62b90f8b58a 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xpath.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xpath.json
@@ -24,10 +24,8 @@
     "threadSafety": { "index": 8, "kind": "attribute", "displayName": "Thread Safety", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to enable thread-safety for the returned result of the xpath expression. This applies to when using NODESET as the result type, and the returned set has multiple elements. In this situation there can be thread-safety issues if you process the NODESET concurrently such as from a Camel Splitter EIP in parallel processing mode. This option prevents concurrency issues by doing defensive copies of the nodes. It is recommended to turn this option on if you are using camel-saxon or Saxon in your application. Saxon has thread-safety issues which can be prevented by turning this option on." },
     "preCompile": { "index": 9, "kind": "attribute", "displayName": "Pre Compile", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to enable pre-compiling the xpath expression during initialization phase. pre-compile is enabled by default. This can be used to turn off, for example in cases the compilation phase is desired at the starting phase, such as if the application is ahead of time compiled (for example with camel-quarkus) which would then load the xpath factory of the built operating system, and not a JVM runtime." },
     "namespace": { "index": 10, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 11, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 12, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 13, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 14, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 15, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 11, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 12, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 13, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xquery.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xquery.json
index c98d6092c8b..5eb28b65ed0 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xquery.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xquery.json
@@ -17,10 +17,8 @@
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
     "configurationRef": { "index": 2, "kind": "attribute", "displayName": "Configuration Ref", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Reference to a saxon configuration instance in the registry to use for xquery (requires camel-saxon). This may be needed to add custom functions to a saxon configuration, so these custom functions can be used in xquery expressions." },
     "namespace": { "index": 3, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 4, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 5, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 6, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 7, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 8, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 4, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xtokenize.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xtokenize.json
index 6ee02088613..dcf8221e6f6 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xtokenize.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/models/xtokenize.json
@@ -18,10 +18,8 @@
     "mode": { "index": 2, "kind": "attribute", "displayName": "Mode", "required": false, "type": "enum", "javaType": "java.lang.String", "enum": [ "i", "w", "u", "t" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "i", "description": "The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element" },
     "group": { "index": 3, "kind": "attribute", "displayName": "Group", "required": false, "type": "integer", "javaType": "java.lang.Integer", "deprecated": false, "autowired": false, "secret": false, "description": "To group N parts together" },
     "namespace": { "index": 4, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 5, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 6, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 7, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 8, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 9, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 5, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 6, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 7, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/schemas/camel-spring.xsd b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/schemas/camel-spring.xsd
index a70759e4269..bdf7a264bea 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/schemas/camel-spring.xsd
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/schemas/camel-spring.xsd
@@ -15240,29 +15240,12 @@ The String representation of the MediaType to output.
   <xs:complexType abstract="true" name="singleInputTypedExpressionDefinition">
     <xs:simpleContent>
       <xs:extension base="tns:typedExpressionDefinition">
-        <xs:attribute name="variableName" type="xs:string">
+        <xs:attribute name="source" type="xs:string">
           <xs:annotation>
             <xs:documentation xml:lang="en">
 <![CDATA[
-Name of variable to use as input, instead of the message body.
-]]>
-            </xs:documentation>
-          </xs:annotation>
-        </xs:attribute>
-        <xs:attribute name="headerName" type="xs:string">
-          <xs:annotation>
-            <xs:documentation xml:lang="en">
-<![CDATA[
-Name of header to use as input, instead of the message body.
-]]>
-            </xs:documentation>
-          </xs:annotation>
-        </xs:attribute>
-        <xs:attribute name="propertyName" type="xs:string">
-          <xs:annotation>
-            <xs:documentation xml:lang="en">
-<![CDATA[
-Name of property to use as input, instead of the message body.
+Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source.
+Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.
 ]]>
             </xs:documentation>
           </xs:annotation>
@@ -15517,15 +15500,6 @@ Whether to validate the bean has the configured method. Default value: true
       <xs:extension base="tns:typedExpressionDefinition"/>
     </xs:simpleContent>
   </xs:complexType>
-  <xs:complexType abstract="true" name="singleInputExpressionDefinition">
-    <xs:simpleContent>
-      <xs:extension base="tns:expression">
-        <xs:attribute name="variableName" type="xs:string"/>
-        <xs:attribute name="headerName" type="xs:string"/>
-        <xs:attribute name="propertyName" type="xs:string"/>
-      </xs:extension>
-    </xs:simpleContent>
-  </xs:complexType>
   <xs:complexType name="spELExpression">
     <xs:simpleContent>
       <xs:extension base="tns:typedExpressionDefinition"/>
diff --git a/catalog/camel-route-parser/src/test/java/org/apache/camel/parser/java/SplitTokenizeTest.java b/catalog/camel-route-parser/src/test/java/org/apache/camel/parser/java/SplitTokenizeTest.java
index 31833e9a99c..359a7247b17 100644
--- a/catalog/camel-route-parser/src/test/java/org/apache/camel/parser/java/SplitTokenizeTest.java
+++ b/catalog/camel-route-parser/src/test/java/org/apache/camel/parser/java/SplitTokenizeTest.java
@@ -105,13 +105,13 @@ public class SplitTokenizeTest extends CamelTestSupport {
                         .split().tokenize(",")
                         .to("mock:split");
 
+                var byHeader = expression().tokenize().token(",").source("header:myHeader").end();
                 from("direct:b")
-                        .split().tokenize(",", "myHeader")
+                        .split(byHeader)
                         .to("mock:split");
 
                 from("direct:c")
-                        .split().tokenize("(\\W+)\\s*", null, true)
-                        .to("mock:split");
+                        .split().tokenize("(\\W+)\\s*", true).to("mock:split");
 
                 from("direct:d")
                         .split().tokenizePair("[", "]", true)
diff --git a/components/camel-datasonnet/src/generated/resources/org/apache/camel/language/datasonnet/datasonnet.json b/components/camel-datasonnet/src/generated/resources/org/apache/camel/language/datasonnet/datasonnet.json
index aaf22efac7c..46b2629991c 100644
--- a/components/camel-datasonnet/src/generated/resources/org/apache/camel/language/datasonnet/datasonnet.json
+++ b/components/camel-datasonnet/src/generated/resources/org/apache/camel/language/datasonnet/datasonnet.json
@@ -20,10 +20,8 @@
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
     "bodyMediaType": { "index": 2, "kind": "attribute", "displayName": "Body Media Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The String representation of the message's body MediaType" },
     "outputMediaType": { "index": 3, "kind": "attribute", "displayName": "Output Media Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The String representation of the MediaType to output" },
-    "variableName": { "index": 4, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 5, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 6, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 7, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 8, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 4, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/Datasonnet.java b/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/Datasonnet.java
index 6e5de5fa328..69f58d2eabc 100644
--- a/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/Datasonnet.java
+++ b/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/Datasonnet.java
@@ -31,7 +31,33 @@ import org.apache.camel.support.language.LanguageAnnotation;
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
-@LanguageAnnotation(language = "datasonnet")
+@LanguageAnnotation(language = "datasonnet", factory = DatasonnetAnnotationExpressionFactory.class)
 public @interface Datasonnet {
+
+    /**
+     * The datasonnet expression which will be applied
+     */
     String value();
+
+    /**
+     * The desired return type from the evaluated datasonnet.
+     */
+    Class<?> resultType() default Object.class;
+
+    /**
+     * Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of
+     * source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the
+     * message body.
+     */
+    String source() default "";
+
+    /**
+     * The message body media type.
+     */
+    String bodyMediaType() default "";
+
+    /**
+     * The media type to output.
+     */
+    String outputMediaType() default "";
 }
diff --git a/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetAnnotationExpressionFactory.java b/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetAnnotationExpressionFactory.java
new file mode 100644
index 00000000000..08fa3e129dd
--- /dev/null
+++ b/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetAnnotationExpressionFactory.java
@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.language.datasonnet;
+
+import java.lang.annotation.Annotation;
+
+import com.datasonnet.document.MediaType;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Expression;
+import org.apache.camel.support.builder.ExpressionBuilder;
+import org.apache.camel.support.language.DefaultAnnotationExpressionFactory;
+import org.apache.camel.support.language.LanguageAnnotation;
+
+/**
+ * Factory for the Datasonnet expression annotations.
+ */
+public class DatasonnetAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
+
+    @Override
+    public Expression createExpression(
+            CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation,
+            Class<?> expressionReturnType) {
+
+        String ds = getExpressionFromAnnotation(annotation);
+        DatasonnetExpression answer = new DatasonnetExpression(ds);
+
+        Class<?> resultType = getResultType(annotation);
+        if (resultType.equals(Object.class)) {
+            resultType = expressionReturnType;
+        }
+        String source = getSource(annotation);
+        answer.setSource(ExpressionBuilder.singleInputExpression(source));
+
+        if (annotation instanceof Datasonnet) {
+            Datasonnet ann = (Datasonnet) annotation;
+            if (!ann.bodyMediaType().isEmpty()) {
+                answer.setBodyMediaType(MediaType.valueOf(ann.bodyMediaType()));
+            }
+            if (!ann.outputMediaType().isEmpty()) {
+                answer.setOutputMediaType(MediaType.valueOf(ann.outputMediaType()));
+            }
+        }
+
+        return ExpressionBuilder.convertToExpression(answer, resultType);
+    }
+
+    protected Class<?> getResultType(Annotation annotation) {
+        return (Class<?>) getAnnotationObjectValue(annotation, "resultType");
+    }
+
+    protected String getSource(Annotation annotation) {
+        String answer = null;
+        try {
+            answer = (String) getAnnotationObjectValue(annotation, "source");
+        } catch (Exception e) {
+            // Do Nothing
+        }
+        if (answer != null && answer.isBlank()) {
+            return null;
+        }
+        return answer;
+    }
+}
diff --git a/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetLanguage.java b/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetLanguage.java
index 214a277fb51..a1eaff5984a 100644
--- a/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetLanguage.java
+++ b/components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetLanguage.java
@@ -83,11 +83,11 @@ public class DatasonnetLanguage extends SingleInputTypedLanguageSupport {
         DatasonnetExpression answer = new DatasonnetExpression(expression);
         answer.setSource(source);
         answer.setResultType(property(Class.class, properties, 0, null));
-        String mediaType = property(String.class, properties, 4, null);
+        String mediaType = property(String.class, properties, 2, null);
         if (mediaType != null) {
             answer.setBodyMediaType(MediaType.valueOf(mediaType));
         }
-        mediaType = property(String.class, properties, 5, null);
+        mediaType = property(String.class, properties, 3, null);
         if (mediaType != null) {
             answer.setOutputMediaType(MediaType.valueOf(mediaType));
         }
diff --git a/components/camel-datasonnet/src/test/java/org/apache/camel/language/datasonnet/DatasonnetAnnotationTest.java b/components/camel-datasonnet/src/test/java/org/apache/camel/language/datasonnet/DatasonnetAnnotationTest.java
new file mode 100644
index 00000000000..0fec292e8c8
--- /dev/null
+++ b/components/camel-datasonnet/src/test/java/org/apache/camel/language/datasonnet/DatasonnetAnnotationTest.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.language.datasonnet;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.junit.jupiter.api.Test;
+
+public class DatasonnetAnnotationTest extends CamelTestSupport {
+
+    @Override
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            @Override
+            public void configure() {
+                from("direct:start")
+                        .bean(MyBean.class)
+                        .to("mock:result");
+            }
+        };
+    }
+
+    @Test
+    public void testAnnotation() throws Exception {
+        getMockEndpoint("mock:result").expectedBodiesReceived("Hello, DataSonnet. I am Camel");
+
+        template.sendBody("direct:start", "DataSonnet");
+
+        MockEndpoint.assertIsSatisfied(context);
+    }
+
+    public static class MyBean {
+
+        public String hello(@Datasonnet("'Hello, ' + payload") String payload) {
+            return payload + ". I am Camel";
+        }
+    }
+
+}
diff --git a/components/camel-hl7/src/generated/resources/org/apache/camel/component/hl7/hl7terser.json b/components/camel-hl7/src/generated/resources/org/apache/camel/component/hl7/hl7terser.json
index f329ef92cf8..d8a78847953 100644
--- a/components/camel-hl7/src/generated/resources/org/apache/camel/component/hl7/hl7terser.json
+++ b/components/camel-hl7/src/generated/resources/org/apache/camel/component/hl7/hl7terser.json
@@ -18,10 +18,8 @@
   "properties": {
     "id": { "index": 0, "kind": "attribute", "displayName": "Id", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the id of this node" },
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
-    "variableName": { "index": 2, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 3, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 4, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 2, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 3, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 4, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7Terser.java b/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7Terser.java
index 6bf2d5fbef4..48c6b1072fb 100644
--- a/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7Terser.java
+++ b/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7Terser.java
@@ -27,7 +27,24 @@ import org.apache.camel.support.language.LanguageAnnotation;
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
-@LanguageAnnotation(language = "hl7terser")
+@LanguageAnnotation(language = "hl7terser", factory = Hl7TerserAnnotationExpressionFactory.class)
 public @interface Hl7Terser {
+
+    /**
+     * The HL7 terser which will be applied
+     */
     String value();
+
+    /**
+     * The desired return type from the evaluated HL7 terser.
+     */
+    Class<?> resultType() default Object.class;
+
+    /**
+     * Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of
+     * source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the
+     * message body.
+     */
+    String source() default "";
+
 }
diff --git a/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserAnnotationExpressionFactory.java b/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserAnnotationExpressionFactory.java
new file mode 100644
index 00000000000..8e969d050e3
--- /dev/null
+++ b/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserAnnotationExpressionFactory.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.hl7;
+
+import java.lang.annotation.Annotation;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Expression;
+import org.apache.camel.support.builder.ExpressionBuilder;
+import org.apache.camel.support.language.DefaultAnnotationExpressionFactory;
+import org.apache.camel.support.language.LanguageAnnotation;
+
+/**
+ * Factory for the HL7 terser expression annotations.
+ */
+public class Hl7TerserAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
+
+    @Override
+    public Expression createExpression(
+            CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation,
+            Class<?> expressionReturnType) {
+
+        String hl7 = getExpressionFromAnnotation(annotation);
+        Class<?> resultType = getResultType(annotation);
+        if (resultType.equals(Object.class)) {
+            resultType = expressionReturnType;
+        }
+        String source = getSource(annotation);
+        Expression input = ExpressionBuilder.singleInputExpression(source);
+        Expression exp = Hl7TerserLanguage.terser(input, hl7);
+
+        return ExpressionBuilder.convertToExpression(exp, resultType);
+    }
+
+    protected Class<?> getResultType(Annotation annotation) {
+        return (Class<?>) getAnnotationObjectValue(annotation, "resultType");
+    }
+
+    protected String getSource(Annotation annotation) {
+        String answer = null;
+        try {
+            answer = (String) getAnnotationObjectValue(annotation, "source");
+        } catch (Exception e) {
+            // Do Nothing
+        }
+        if (answer != null && answer.isBlank()) {
+            return null;
+        }
+        return answer;
+    }
+}
diff --git a/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserLanguage.java b/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserLanguage.java
index 0732c2e308a..a4170bbd65c 100644
--- a/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserLanguage.java
+++ b/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserLanguage.java
@@ -35,7 +35,7 @@ public class Hl7TerserLanguage extends SingleInputTypedLanguageSupport {
         return terser(ExpressionBuilder.bodyExpression(), expression);
     }
 
-    private static Expression terser(final Expression source, final String expression) {
+    public static Expression terser(final Expression source, final String expression) {
         ObjectHelper.notNull(expression, "expression");
         return new ExpressionAdapter() {
 
diff --git a/components/camel-jq/src/generated/resources/org/apache/camel/language/jq/jq.json b/components/camel-jq/src/generated/resources/org/apache/camel/language/jq/jq.json
index 96cb84de67d..4b660303d61 100644
--- a/components/camel-jq/src/generated/resources/org/apache/camel/language/jq/jq.json
+++ b/components/camel-jq/src/generated/resources/org/apache/camel/language/jq/jq.json
@@ -18,10 +18,8 @@
   "properties": {
     "id": { "index": 0, "kind": "attribute", "displayName": "Id", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the id of this node" },
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
-    "variableName": { "index": 2, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 3, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 4, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 2, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 3, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 4, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/components/camel-jq/src/main/java/org/apache/camel/language/jq/Jq.java b/components/camel-jq/src/main/java/org/apache/camel/language/jq/Jq.java
index 307cbcdfccc..7459e145a3e 100644
--- a/components/camel-jq/src/main/java/org/apache/camel/language/jq/Jq.java
+++ b/components/camel-jq/src/main/java/org/apache/camel/language/jq/Jq.java
@@ -41,17 +41,10 @@ public @interface Jq {
     Class<?> resultType() default Object.class;
 
     /**
-     * The name of the variable we want to apply the expression to.
+     * Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of
+     * source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the
+     * message body.
      */
-    String variableName() default "";
+    String source() default "";
 
-    /**
-     * The name of the header we want to apply the expression to.
-     */
-    String headerName() default "";
-
-    /**
-     * The name of the exchange property we want to apply the expression to.
-     */
-    String propertyName() default "";
 }
diff --git a/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqAnnotationExpressionFactory.java b/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqAnnotationExpressionFactory.java
index 20ecba2ddb3..50d811518c7 100644
--- a/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqAnnotationExpressionFactory.java
+++ b/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqAnnotationExpressionFactory.java
@@ -23,7 +23,6 @@ import org.apache.camel.Expression;
 import org.apache.camel.support.builder.ExpressionBuilder;
 import org.apache.camel.support.language.DefaultAnnotationExpressionFactory;
 import org.apache.camel.support.language.LanguageAnnotation;
-import org.apache.camel.util.ObjectHelper;
 
 public class JqAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
 
@@ -42,25 +41,9 @@ public class JqAnnotationExpressionFactory extends DefaultAnnotationExpressionFa
         if (resultType != null) {
             answer.setResultType(resultType);
         }
-
-        if (annotation instanceof Jq) {
-            Jq jqAnnotation = (Jq) annotation;
-
-            String variableName = null;
-            String headerName = null;
-            String propertyName = null;
-            if (ObjectHelper.isNotEmpty(jqAnnotation.variableName())) {
-                variableName = jqAnnotation.variableName();
-            }
-            if (ObjectHelper.isNotEmpty(jqAnnotation.headerName())) {
-                headerName = jqAnnotation.headerName();
-            }
-            if (ObjectHelper.isNotEmpty(jqAnnotation.propertyName())) {
-                propertyName = jqAnnotation.propertyName();
-            }
-            if (variableName != null || headerName != null || propertyName != null) {
-                answer.setSource(ExpressionBuilder.singleInputExpression(variableName, headerName, propertyName));
-            }
+        String source = getSource(annotation);
+        if (source != null) {
+            answer.setSource(ExpressionBuilder.singleInputExpression(source));
         }
 
         answer.init(camelContext);
@@ -70,4 +53,18 @@ public class JqAnnotationExpressionFactory extends DefaultAnnotationExpressionFa
     private Class<?> getResultType(Annotation annotation) {
         return (Class<?>) getAnnotationObjectValue(annotation, "resultType");
     }
+
+    protected String getSource(Annotation annotation) {
+        String answer = null;
+        try {
+            answer = (String) getAnnotationObjectValue(annotation, "source");
+        } catch (Exception e) {
+            // Do Nothing
+        }
+        if (answer != null && answer.isBlank()) {
+            return null;
+        }
+        return answer;
+    }
+
 }
diff --git a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderAsStringTest.java b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderAsStringTest.java
index 03d8b992271..61cab528810 100644
--- a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderAsStringTest.java
+++ b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderAsStringTest.java
@@ -27,8 +27,10 @@ public class JqExpressionFromHeaderAsStringTest extends JqTestSupport {
         return new RouteBuilder() {
             @Override
             public void configure() {
+                var jq = expression().jq().expression(".foo").resultType(String.class).source("header:Content").end();
+
                 from("direct:start")
-                        .transform().jq(".foo", String.class, "Content")
+                        .transform(jq)
                         .to("mock:result");
             }
         };
diff --git a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderTest.java b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderTest.java
index cd302de09fa..35e613f2837 100644
--- a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderTest.java
+++ b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderTest.java
@@ -28,9 +28,11 @@ public class JqExpressionFromHeaderTest extends JqTestSupport {
         return new RouteBuilder() {
             @Override
             public void configure() {
+                var jq = expression().jq().expression(".foo").source("header:Content").end();
+
                 from("direct:start")
                         .doTry()
-                        .transform().jq(".foo", "Content")
+                        .transform(jq)
                         .to("mock:result")
                         .doCatch(NoSuchHeaderException.class)
                         .to("mock:fail");
diff --git a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromPropertyTest.java b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromPropertyTest.java
index 56469318a3a..aef6c16064c 100644
--- a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromPropertyTest.java
+++ b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromPropertyTest.java
@@ -29,9 +29,11 @@ public class JqExpressionFromPropertyTest extends JqTestSupport {
         return new RouteBuilder() {
             @Override
             public void configure() {
+                var jq = expression().jq().expression(".foo").source("property:Content").end();
+
                 from("direct:start")
                         .doTry()
-                        .transform().jq(".foo", Object.class, null, "Content")
+                        .transform(jq)
                         .to("mock:result")
                         .doCatch(NoSuchPropertyException.class)
                         .to("mock:fail");
diff --git a/components/camel-jsonpath/src/generated/resources/org/apache/camel/jsonpath/jsonpath.json b/components/camel-jsonpath/src/generated/resources/org/apache/camel/jsonpath/jsonpath.json
index 7df00004fa3..13bcc8d8180 100644
--- a/components/camel-jsonpath/src/generated/resources/org/apache/camel/jsonpath/jsonpath.json
+++ b/components/camel-jsonpath/src/generated/resources/org/apache/camel/jsonpath/jsonpath.json
@@ -24,10 +24,8 @@
     "writeAsString": { "index": 5, "kind": "attribute", "displayName": "Write As String", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to write the output of each row\/element as a JSON String value instead of a Map\/POJO value." },
     "unpackArray": { "index": 6, "kind": "attribute", "displayName": "Unpack Array", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to unpack a single element json-array into an object." },
     "option": { "index": 7, "kind": "attribute", "displayName": "Option", "label": "advanced", "required": false, "type": "enum", "javaType": "java.lang.String", "enum": [ "DEFAULT_PATH_LEAF_TO_NULL", "ALWAYS_RETURN_LIST", "AS_PATH_LIST", "SUPPRESS_EXCEPTIONS", "REQUIRE_PROPERTIES" ], "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional options on JSONPath. Multiple values can be separated by comma." },
-    "variableName": { "index": 8, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 9, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 10, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 11, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 12, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 8, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 9, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 10, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPath.java b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPath.java
index b7e24366d95..5577cacd24e 100644
--- a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPath.java
+++ b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPath.java
@@ -58,17 +58,10 @@ public @interface JsonPath {
     Class<?> resultType() default Object.class;
 
     /**
-     * The name of the variable we want to apply the expression to.
+     * Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of
+     * source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the
+     * message body.
      */
-    String variableName() default "";
+    String source() default "";
 
-    /**
-     * The name of the header we want to apply the expression to.
-     */
-    String headerName() default "";
-
-    /**
-     * The name of the exchange property we want to apply the expression to.
-     */
-    String propertyName() default "";
 }
diff --git a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathAnnotationExpressionFactory.java b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathAnnotationExpressionFactory.java
index 312ea82994a..d011ed91bdc 100644
--- a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathAnnotationExpressionFactory.java
+++ b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathAnnotationExpressionFactory.java
@@ -24,7 +24,6 @@ import org.apache.camel.Expression;
 import org.apache.camel.support.builder.ExpressionBuilder;
 import org.apache.camel.support.language.DefaultAnnotationExpressionFactory;
 import org.apache.camel.support.language.LanguageAnnotation;
-import org.apache.camel.util.ObjectHelper;
 
 public class JsonPathAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
 
@@ -49,25 +48,13 @@ public class JsonPathAnnotationExpressionFactory extends DefaultAnnotationExpres
 
             answer.setSuppressExceptions(jsonPathAnnotation.suppressExceptions());
             answer.setAllowSimple(jsonPathAnnotation.allowSimple());
-
-            String variableName = null;
-            String headerName = null;
-            String propertyName = null;
-            if (ObjectHelper.isNotEmpty(jsonPathAnnotation.variableName())) {
-                variableName = jsonPathAnnotation.variableName();
-            }
-            if (ObjectHelper.isNotEmpty(jsonPathAnnotation.headerName())) {
-                headerName = jsonPathAnnotation.headerName();
-            }
-            if (ObjectHelper.isNotEmpty(jsonPathAnnotation.propertyName())) {
-                propertyName = jsonPathAnnotation.propertyName();
-            }
-            if (variableName != null || headerName != null || propertyName != null) {
-                answer.setSource(ExpressionBuilder.singleInputExpression(variableName, headerName, propertyName));
-            }
-
             Option[] options = jsonPathAnnotation.options();
             answer.setOptions(options);
+
+            String source = getSource(annotation);
+            if (source != null) {
+                answer.setSource(ExpressionBuilder.singleInputExpression(source));
+            }
         }
 
         answer.init(camelContext);
@@ -77,4 +64,18 @@ public class JsonPathAnnotationExpressionFactory extends DefaultAnnotationExpres
     private Class<?> getResultType(Annotation annotation) {
         return (Class<?>) getAnnotationObjectValue(annotation, "resultType");
     }
+
+    protected String getSource(Annotation annotation) {
+        String answer = null;
+        try {
+            answer = (String) getAnnotationObjectValue(annotation, "source");
+        } catch (Exception e) {
+            // Do Nothing
+        }
+        if (answer != null && answer.isBlank()) {
+            return null;
+        }
+        return answer;
+    }
+
 }
diff --git a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathLanguage.java b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathLanguage.java
index 233b8689900..6b5df842e8d 100644
--- a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathLanguage.java
+++ b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathLanguage.java
@@ -105,12 +105,12 @@ public class JsonPathLanguage extends SingleInputTypedLanguageSupport implements
         answer.setSource(source);
         answer.setPredicate(predicate);
         answer.setResultType(property(Class.class, properties, 0, null));
-        answer.setSuppressExceptions(property(boolean.class, properties, 4, isSuppressExceptions()));
-        answer.setAllowSimple(property(boolean.class, properties, 5, isAllowSimple()));
-        answer.setAllowEasyPredicate(property(boolean.class, properties, 6, isAllowEasyPredicate()));
-        answer.setWriteAsString(property(boolean.class, properties, 7, isWriteAsString()));
-        answer.setUnpackArray(property(boolean.class, properties, 8, isUnpackArray()));
-        Object option = property(Object.class, properties, 9, null);
+        answer.setSuppressExceptions(property(boolean.class, properties, 2, isSuppressExceptions()));
+        answer.setAllowSimple(property(boolean.class, properties, 3, isAllowSimple()));
+        answer.setAllowEasyPredicate(property(boolean.class, properties, 4, isAllowEasyPredicate()));
+        answer.setWriteAsString(property(boolean.class, properties, 5, isWriteAsString()));
+        answer.setUnpackArray(property(boolean.class, properties, 6, isUnpackArray()));
+        Object option = property(Object.class, properties, 7, null);
         if (option != null) {
             List<Option> list = new ArrayList<>();
             if (option instanceof String str) {
diff --git a/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathHeaderNameTest.java b/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathHeaderNameTest.java
index e844b9e66af..b17a34a257b 100644
--- a/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathHeaderNameTest.java
+++ b/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathHeaderNameTest.java
@@ -30,8 +30,11 @@ public class JsonPathHeaderNameTest extends CamelTestSupport {
         return new RouteBuilder() {
             @Override
             public void configure() {
+                var jp = expression().jsonpath().expression("$..store.book.length()").resultType(int.class)
+                        .source("header:myHeader").end();
+
                 from("direct:start")
-                        .setHeader("number").jsonpath("$..store.book.length()", false, int.class, "myHeader")
+                        .setHeader("number", jp)
                         .to("mock:result");
             }
         };
diff --git a/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathLanguageTest.java b/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathLanguageTest.java
index 16c4665abf1..badc320399c 100644
--- a/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathLanguageTest.java
+++ b/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathLanguageTest.java
@@ -131,7 +131,7 @@ public class JsonPathLanguageTest extends CamelTestSupport {
         JsonPathLanguage lan = (JsonPathLanguage) context.resolveLanguage("jsonpath");
 
         Expression exp = lan.createExpression("$.foo",
-                new Object[] { null, null, null, null, null, null, null, null, null, Option.SUPPRESS_EXCEPTIONS });
+                new Object[] { null, null, null, null, null, null, null, Option.SUPPRESS_EXCEPTIONS });
         String nofoo = exp.evaluate(exchange, String.class);
 
         assertNull(nofoo);
@@ -145,7 +145,7 @@ public class JsonPathLanguageTest extends CamelTestSupport {
         JsonPathLanguage language = (JsonPathLanguage) context.resolveLanguage("jsonpath");
 
         Expression expression = language.createExpression("$.store.book",
-                new Object[] { String.class, null, null, null, null, null, null, null, true });
+                new Object[] { String.class, null, null, null, null, null, true });
         String json = expression.evaluate(exchange, String.class);
 
         // check that a single json object is returned, not an array
@@ -160,7 +160,7 @@ public class JsonPathLanguageTest extends CamelTestSupport {
         JsonPathLanguage language = (JsonPathLanguage) context.resolveLanguage("jsonpath");
 
         Expression expression = language.createExpression("$.store.book",
-                new Object[] { String.class, null, null, null, null, null, false });
+                new Object[] { String.class, null, null, null, false });
         String json = expression.evaluate(exchange, String.class);
 
         // check that an array is returned, not a single object
diff --git a/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathTransformHeaderNameTest.java b/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathTransformHeaderNameTest.java
index 5474c40dc07..dcf3a187a12 100644
--- a/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathTransformHeaderNameTest.java
+++ b/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathTransformHeaderNameTest.java
@@ -33,8 +33,10 @@ public class JsonPathTransformHeaderNameTest extends CamelTestSupport {
         return new RouteBuilder() {
             @Override
             public void configure() {
+                var jp = expression().jsonpath().expression("$.store.book[*].author").source("header:myHeader").end();
+
                 from("direct:start")
-                        .transform().jsonpath("$.store.book[*].author", false, null, "myHeader")
+                        .transform(jp)
                         .to("mock:authors");
             }
         };
diff --git a/components/camel-jsonpath/src/test/resources/org/apache/camel/jsonpath/SpringJsonPathTransformHeaderNameTest.xml b/components/camel-jsonpath/src/test/resources/org/apache/camel/jsonpath/SpringJsonPathTransformHeaderNameTest.xml
index 1bac1745a5e..3206a0d48c3 100644
--- a/components/camel-jsonpath/src/test/resources/org/apache/camel/jsonpath/SpringJsonPathTransformHeaderNameTest.xml
+++ b/components/camel-jsonpath/src/test/resources/org/apache/camel/jsonpath/SpringJsonPathTransformHeaderNameTest.xml
@@ -27,7 +27,7 @@
     <route>
       <from uri="direct:start"/>
       <transform>
-        <jsonpath headerName="myHeader">$.store.book[*].author</jsonpath>
+        <jsonpath source="header:myHeader">$.store.book[*].author</jsonpath>
       </transform>
       <to uri="mock:authors"/>
     </route>
diff --git a/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointConfigurer.java b/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointConfigurer.java
index 0dfe66d086a..0583cf8ce12 100644
--- a/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointConfigurer.java
+++ b/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointConfigurer.java
@@ -40,8 +40,6 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "exchangepattern":
         case "exchangePattern": target.setExchangePattern(property(camelContext, org.apache.camel.ExchangePattern.class, value)); return true;
         case "greedy": target.setGreedy(property(camelContext, boolean.class, value)); return true;
-        case "headername":
-        case "headerName": target.setHeaderName(property(camelContext, java.lang.String.class, value)); return true;
         case "initialdelay":
         case "initialDelay": target.setInitialDelay(property(camelContext, long.class, value)); return true;
         case "lazystartproducer":
@@ -54,8 +52,6 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "pollstrategy":
         case "pollStrategy": target.setPollStrategy(property(camelContext, org.apache.camel.spi.PollingConsumerPollStrategy.class, value)); return true;
         case "properties": target.setProperties(property(camelContext, java.util.Properties.class, value)); return true;
-        case "propertyname":
-        case "propertyName": target.setPropertyName(property(camelContext, java.lang.String.class, value)); return true;
         case "repeatcount":
         case "repeatCount": target.setRepeatCount(property(camelContext, long.class, value)); return true;
         case "resulttype":
@@ -71,6 +67,7 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "schedulerProperties": target.setSchedulerProperties(property(camelContext, java.util.Map.class, value)); return true;
         case "sendemptymessagewhenidle":
         case "sendEmptyMessageWhenIdle": target.setSendEmptyMessageWhenIdle(property(camelContext, boolean.class, value)); return true;
+        case "source": target.setSource(property(camelContext, java.lang.String.class, value)); return true;
         case "startscheduler":
         case "startScheduler": target.setStartScheduler(property(camelContext, boolean.class, value)); return true;
         case "staticquerycontext":
@@ -81,8 +78,6 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "timeUnit": target.setTimeUnit(property(camelContext, java.util.concurrent.TimeUnit.class, value)); return true;
         case "usefixeddelay":
         case "useFixedDelay": target.setUseFixedDelay(property(camelContext, boolean.class, value)); return true;
-        case "variablename":
-        case "variableName": target.setVariableName(property(camelContext, java.lang.String.class, value)); return true;
         default: return false;
         }
     }
@@ -109,8 +104,6 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "exchangepattern":
         case "exchangePattern": return org.apache.camel.ExchangePattern.class;
         case "greedy": return boolean.class;
-        case "headername":
-        case "headerName": return java.lang.String.class;
         case "initialdelay":
         case "initialDelay": return long.class;
         case "lazystartproducer":
@@ -123,8 +116,6 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "pollstrategy":
         case "pollStrategy": return org.apache.camel.spi.PollingConsumerPollStrategy.class;
         case "properties": return java.util.Properties.class;
-        case "propertyname":
-        case "propertyName": return java.lang.String.class;
         case "repeatcount":
         case "repeatCount": return long.class;
         case "resulttype":
@@ -140,6 +131,7 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "schedulerProperties": return java.util.Map.class;
         case "sendemptymessagewhenidle":
         case "sendEmptyMessageWhenIdle": return boolean.class;
+        case "source": return java.lang.String.class;
         case "startscheduler":
         case "startScheduler": return boolean.class;
         case "staticquerycontext":
@@ -150,8 +142,6 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "timeUnit": return java.util.concurrent.TimeUnit.class;
         case "usefixeddelay":
         case "useFixedDelay": return boolean.class;
-        case "variablename":
-        case "variableName": return java.lang.String.class;
         default: return null;
         }
     }
@@ -179,8 +169,6 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "exchangepattern":
         case "exchangePattern": return target.getExchangePattern();
         case "greedy": return target.isGreedy();
-        case "headername":
-        case "headerName": return target.getHeaderName();
         case "initialdelay":
         case "initialDelay": return target.getInitialDelay();
         case "lazystartproducer":
@@ -193,8 +181,6 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "pollstrategy":
         case "pollStrategy": return target.getPollStrategy();
         case "properties": return target.getProperties();
-        case "propertyname":
-        case "propertyName": return target.getPropertyName();
         case "repeatcount":
         case "repeatCount": return target.getRepeatCount();
         case "resulttype":
@@ -210,6 +196,7 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "schedulerProperties": return target.getSchedulerProperties();
         case "sendemptymessagewhenidle":
         case "sendEmptyMessageWhenIdle": return target.isSendEmptyMessageWhenIdle();
+        case "source": return target.getSource();
         case "startscheduler":
         case "startScheduler": return target.isStartScheduler();
         case "staticquerycontext":
@@ -220,8 +207,6 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "timeUnit": return target.getTimeUnit();
         case "usefixeddelay":
         case "useFixedDelay": return target.isUseFixedDelay();
-        case "variablename":
-        case "variableName": return target.getVariableName();
         default: return null;
         }
     }
diff --git a/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointUriFactory.java b/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointUriFactory.java
index 88348ef2a12..478f8b8fe33 100644
--- a/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointUriFactory.java
+++ b/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointUriFactory.java
@@ -21,7 +21,7 @@ public class XQueryEndpointUriFactory extends org.apache.camel.support.component
     private static final Set<String> SECRET_PROPERTY_NAMES;
     private static final Set<String> MULTI_VALUE_PREFIXES;
     static {
-        Set<String> props = new HashSet<>(35);
+        Set<String> props = new HashSet<>(33);
         props.add("allowStAX");
         props.add("backoffErrorThreshold");
         props.add("backoffIdleThreshold");
@@ -33,7 +33,6 @@ public class XQueryEndpointUriFactory extends org.apache.camel.support.component
         props.add("exceptionHandler");
         props.add("exchangePattern");
         props.add("greedy");
-        props.add("headerName");
         props.add("initialDelay");
         props.add("lazyStartProducer");
         props.add("moduleURIResolver");
@@ -41,7 +40,6 @@ public class XQueryEndpointUriFactory extends org.apache.camel.support.component
         props.add("parameters");
         props.add("pollStrategy");
         props.add("properties");
-        props.add("propertyName");
         props.add("repeatCount");
         props.add("resourceUri");
         props.add("resultType");
@@ -51,12 +49,12 @@ public class XQueryEndpointUriFactory extends org.apache.camel.support.component
         props.add("scheduler");
         props.add("schedulerProperties");
         props.add("sendEmptyMessageWhenIdle");
+        props.add("source");
         props.add("startScheduler");
         props.add("staticQueryContext");
         props.add("stripsAllWhiteSpace");
         props.add("timeUnit");
         props.add("useFixedDelay");
-        props.add("variableName");
         PROPERTY_NAMES = Collections.unmodifiableSet(props);
         SECRET_PROPERTY_NAMES = Collections.emptySet();
         Set<String> prefixes = new HashSet<>(1);
diff --git a/components/camel-saxon/src/generated/resources/org/apache/camel/component/xquery/xquery.json b/components/camel-saxon/src/generated/resources/org/apache/camel/component/xquery/xquery.json
index 5df5016f9a4..187fc5f522f 100644
--- a/components/camel-saxon/src/generated/resources/org/apache/camel/component/xquery/xquery.json
+++ b/components/camel-saxon/src/generated/resources/org/apache/camel/component/xquery/xquery.json
@@ -33,38 +33,36 @@
   "properties": {
     "resourceUri": { "index": 0, "kind": "path", "displayName": "Resource Uri", "group": "common", "label": "", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "deprecationNote": "", "autowired": false, "secret": false, "description": "The name of the template to load from classpath or file system" },
     "allowStAX": { "index": 1, "kind": "parameter", "displayName": "Allow St AX", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to allow using StAX mode" },
-    "headerName": { "index": 2, "kind": "parameter", "displayName": "Header Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Message header as the input source instead of Message body." },
-    "namespacePrefixes": { "index": 3, "kind": "parameter", "displayName": "Namespace Prefixes", "group": "common", "label": "", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.String>", "deprecated": false, "autowired": false, "secret": false, "description": "Allows to control which namespace prefixes to use for a set of namespace mappings" },
-    "propertyName": { "index": 4, "kind": "parameter", "displayName": "Property Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Exchange property as the input source instead of Message body." },
-    "resultsFormat": { "index": 5, "kind": "parameter", "displayName": "Results Format", "group": "common", "label": "", "required": false, "type": "object", "javaType": "org.apache.camel.component.xquery.ResultFormat", "enum": [ "Bytes", "BytesSource", "DOM", "DOMSource", "List", "String", "StringSource" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "DOM", "description": "What output result to use" },
-    "resultType": { "index": 6, "kind": "parameter", "displayName": "Result Type", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.Class<java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "What output result to use defined as a class" },
-    "stripsAllWhiteSpace": { "index": 7, "kind": "parameter", "displayName": "Strips All White Space", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to strip all whitespaces" },
-    "variableName": { "index": 8, "kind": "parameter", "displayName": "Variable Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a variable as the input source instead of Message body." },
-    "sendEmptyMessageWhenIdle": { "index": 9, "kind": "parameter", "displayName": "Send Empty Message When Idle", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead." },
-    "bridgeErrorHandler": { "index": 10, "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
-    "exceptionHandler": { "index": 11, "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
-    "exchangePattern": { "index": 12, "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
-    "pollStrategy": { "index": 13, "kind": "parameter", "displayName": "Poll Strategy", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.PollingConsumerPollStrategy", "deprecated": false, "autowired": false, "secret": false, "description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel." },
-    "lazyStartProducer": { "index": 14, "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
-    "configuration": { "index": 15, "kind": "parameter", "displayName": "Configuration", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.Configuration", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon configuration" },
-    "configurationProperties": { "index": 16, "kind": "parameter", "displayName": "Configuration Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "To set custom Saxon configuration properties" },
-    "moduleURIResolver": { "index": 17, "kind": "parameter", "displayName": "Module URIResolver", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.lib.ModuleURIResolver", "deprecated": false, "autowired": false, "secret": false, "description": "To use the custom ModuleURIResolver" },
-    "parameters": { "index": 18, "kind": "parameter", "displayName": "Parameters", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Additional parameters" },
-    "properties": { "index": 19, "kind": "parameter", "displayName": "Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Properties", "deprecated": false, "autowired": false, "secret": false, "description": "Properties to configure the serialization parameters" },
-    "staticQueryContext": { "index": 20, "kind": "parameter", "displayName": "Static Query Context", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.query.StaticQueryContext", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon StaticQueryContext" },
-    "backoffErrorThreshold": { "index": 21, "kind": "parameter", "displayName": "Backoff Error Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in." },
-    "backoffIdleThreshold": { "index": 22, "kind": "parameter", "displayName": "Backoff Idle Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in." },
-    "backoffMultiplier": { "index": 23, "kind": "parameter", "displayName": "Backoff Multiplier", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles\/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and\/or backoffErrorThreshold must also be configured." },
-    "delay": { "index": 24, "kind": "parameter", "displayName": "Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 500, "description": "Milliseconds before the next poll." },
-    "greedy": { "index": 25, "kind": "parameter", "displayName": "Greedy", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages." },
-    "initialDelay": { "index": 26, "kind": "parameter", "displayName": "Initial Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Milliseconds before the first poll starts." },
-    "repeatCount": { "index": 27, "kind": "parameter", "displayName": "Repeat Count", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever." },
-    "runLoggingLevel": { "index": 28, "kind": "parameter", "displayName": "Run Logging Level", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "org.apache.camel.LoggingLevel", "enum": [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "TRACE", "description": "The consumer logs a start\/complete log line when it polls. This option allows you to configure the logging level for that." },
-    "scheduledExecutorService": { "index": 29, "kind": "parameter", "displayName": "Scheduled Executor Service", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.ScheduledExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "Allows for configuring a custom\/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool." },
-    "scheduler": { "index": 30, "kind": "parameter", "displayName": "Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.lang.Object", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "none", "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler" },
-    "schedulerProperties": { "index": 31, "kind": "parameter", "displayName": "Scheduler Properties", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "prefix": "scheduler.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler." },
-    "startScheduler": { "index": 32, "kind": "parameter", "displayName": "Start Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether the scheduler should be auto started." },
-    "timeUnit": { "index": 33, "kind": "parameter", "displayName": "Time Unit", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.TimeUnit", "enum": [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "MILLISECONDS", "description": "Time unit for initialDelay and delay options." },
-    "useFixedDelay": { "index": 34, "kind": "parameter", "displayName": "Use Fixed Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details." }
+    "namespacePrefixes": { "index": 2, "kind": "parameter", "displayName": "Namespace Prefixes", "group": "common", "label": "", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.String>", "deprecated": false, "autowired": false, "secret": false, "description": "Allows to control which namespace prefixes to use for a set of namespace mappings" },
+    "resultsFormat": { "index": 3, "kind": "parameter", "displayName": "Results Format", "group": "common", "label": "", "required": false, "type": "object", "javaType": "org.apache.camel.component.xquery.ResultFormat", "enum": [ "Bytes", "BytesSource", "DOM", "DOMSource", "List", "String", "StringSource" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "DOM", "description": "What output result to use" },
+    "resultType": { "index": 4, "kind": "parameter", "displayName": "Result Type", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.Class<java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "What output result to use defined as a class" },
+    "source": { "index": 5, "kind": "parameter", "displayName": "Source", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "stripsAllWhiteSpace": { "index": 6, "kind": "parameter", "displayName": "Strips All White Space", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to strip all whitespaces" },
+    "sendEmptyMessageWhenIdle": { "index": 7, "kind": "parameter", "displayName": "Send Empty Message When Idle", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead." },
+    "bridgeErrorHandler": { "index": 8, "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
+    "exceptionHandler": { "index": 9, "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
+    "exchangePattern": { "index": 10, "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
+    "pollStrategy": { "index": 11, "kind": "parameter", "displayName": "Poll Strategy", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.PollingConsumerPollStrategy", "deprecated": false, "autowired": false, "secret": false, "description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel." },
+    "lazyStartProducer": { "index": 12, "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
+    "configuration": { "index": 13, "kind": "parameter", "displayName": "Configuration", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.Configuration", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon configuration" },
+    "configurationProperties": { "index": 14, "kind": "parameter", "displayName": "Configuration Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "To set custom Saxon configuration properties" },
+    "moduleURIResolver": { "index": 15, "kind": "parameter", "displayName": "Module URIResolver", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.lib.ModuleURIResolver", "deprecated": false, "autowired": false, "secret": false, "description": "To use the custom ModuleURIResolver" },
+    "parameters": { "index": 16, "kind": "parameter", "displayName": "Parameters", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Additional parameters" },
+    "properties": { "index": 17, "kind": "parameter", "displayName": "Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Properties", "deprecated": false, "autowired": false, "secret": false, "description": "Properties to configure the serialization parameters" },
+    "staticQueryContext": { "index": 18, "kind": "parameter", "displayName": "Static Query Context", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.query.StaticQueryContext", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon StaticQueryContext" },
+    "backoffErrorThreshold": { "index": 19, "kind": "parameter", "displayName": "Backoff Error Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in." },
+    "backoffIdleThreshold": { "index": 20, "kind": "parameter", "displayName": "Backoff Idle Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in." },
+    "backoffMultiplier": { "index": 21, "kind": "parameter", "displayName": "Backoff Multiplier", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles\/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and\/or backoffErrorThreshold must also be configured." },
+    "delay": { "index": 22, "kind": "parameter", "displayName": "Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 500, "description": "Milliseconds before the next poll." },
+    "greedy": { "index": 23, "kind": "parameter", "displayName": "Greedy", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages." },
+    "initialDelay": { "index": 24, "kind": "parameter", "displayName": "Initial Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Milliseconds before the first poll starts." },
+    "repeatCount": { "index": 25, "kind": "parameter", "displayName": "Repeat Count", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever." },
+    "runLoggingLevel": { "index": 26, "kind": "parameter", "displayName": "Run Logging Level", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "org.apache.camel.LoggingLevel", "enum": [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "TRACE", "description": "The consumer logs a start\/complete log line when it polls. This option allows you to configure the logging level for that." },
+    "scheduledExecutorService": { "index": 27, "kind": "parameter", "displayName": "Scheduled Executor Service", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.ScheduledExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "Allows for configuring a custom\/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool." },
+    "scheduler": { "index": 28, "kind": "parameter", "displayName": "Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.lang.Object", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "none", "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler" },
+    "schedulerProperties": { "index": 29, "kind": "parameter", "displayName": "Scheduler Properties", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "prefix": "scheduler.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler." },
+    "startScheduler": { "index": 30, "kind": "parameter", "displayName": "Start Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether the scheduler should be auto started." },
+    "timeUnit": { "index": 31, "kind": "parameter", "displayName": "Time Unit", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.TimeUnit", "enum": [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "MILLISECONDS", "description": "Time unit for initialDelay and delay options." },
+    "useFixedDelay": { "index": 32, "kind": "parameter", "displayName": "Use Fixed Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details." }
   }
 }
diff --git a/components/camel-saxon/src/generated/resources/org/apache/camel/language/xquery/xquery.json b/components/camel-saxon/src/generated/resources/org/apache/camel/language/xquery/xquery.json
index f08be39928e..56fbc40ed72 100644
--- a/components/camel-saxon/src/generated/resources/org/apache/camel/language/xquery/xquery.json
+++ b/components/camel-saxon/src/generated/resources/org/apache/camel/language/xquery/xquery.json
@@ -20,10 +20,8 @@
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
     "configurationRef": { "index": 2, "kind": "attribute", "displayName": "Configuration Ref", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Reference to a saxon configuration instance in the registry to use for xquery (requires camel-saxon). This may be needed to add custom functions to a saxon configuration, so these custom functions can be used in xquery expressions." },
     "namespace": { "index": 3, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 4, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 5, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 6, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 7, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 8, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 4, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQuery.java b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQuery.java
index 43631161df5..45d3108acd3 100644
--- a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQuery.java
+++ b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQuery.java
@@ -34,6 +34,7 @@ import org.apache.camel.support.language.NamespacePrefix;
 @Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
 @LanguageAnnotation(language = "xquery", factory = XQueryAnnotationExpressionFactory.class)
 public @interface XQuery {
+
     String value();
 
     boolean stripsAllWhiteSpace() default true;
@@ -49,17 +50,10 @@ public @interface XQuery {
     Class<?> resultType() default Object.class;
 
     /**
-     * The name of the variable we want to apply the expression to.
-     */
-    String variableName() default "";
-
-    /**
-     * The name of the header we want to apply the expression to.
+     * Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of
+     * source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the
+     * message body.
      */
-    String headerName() default "";
+    String source() default "";
 
-    /**
-     * The name of the exchange property we want to apply the expression to.
-     */
-    String propertyName() default "";
 }
diff --git a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryAnnotationExpressionFactory.java b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryAnnotationExpressionFactory.java
index cfe3156ce37..b701378382c 100644
--- a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryAnnotationExpressionFactory.java
+++ b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryAnnotationExpressionFactory.java
@@ -27,7 +27,6 @@ import org.apache.camel.support.builder.ExpressionBuilder;
 import org.apache.camel.support.language.DefaultAnnotationExpressionFactory;
 import org.apache.camel.support.language.LanguageAnnotation;
 import org.apache.camel.support.language.NamespacePrefix;
-import org.apache.camel.util.ObjectHelper;
 
 public class XQueryAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
 
@@ -41,22 +40,6 @@ public class XQueryAnnotationExpressionFactory extends DefaultAnnotationExpressi
             XQuery xQueryAnnotation = (XQuery) annotation;
             builder.setStripsAllWhiteSpace(xQueryAnnotation.stripsAllWhiteSpace());
 
-            String variableName = null;
-            String headerName = null;
-            String propertyName = null;
-            if (ObjectHelper.isNotEmpty(xQueryAnnotation.variableName())) {
-                variableName = xQueryAnnotation.variableName();
-            }
-            if (ObjectHelper.isNotEmpty(xQueryAnnotation.headerName())) {
-                headerName = xQueryAnnotation.headerName();
-            }
-            if (ObjectHelper.isNotEmpty(xQueryAnnotation.propertyName())) {
-                propertyName = xQueryAnnotation.propertyName();
-            }
-            if (variableName != null || headerName != null || propertyName != null) {
-                builder.setSource(ExpressionBuilder.singleInputExpression(variableName, headerName, propertyName));
-            }
-
             NamespacePrefix[] namespaces = xQueryAnnotation.namespaces();
             if (namespaces != null) {
                 for (NamespacePrefix namespacePrefix : namespaces) {
@@ -64,6 +47,10 @@ public class XQueryAnnotationExpressionFactory extends DefaultAnnotationExpressi
                 }
             }
         }
+        String source = getSource(annotation);
+        if (source != null) {
+            builder.setSource(ExpressionBuilder.singleInputExpression(source));
+        }
         Class<?> resultType = getResultType(annotation);
         if (resultType.equals(Object.class)) {
             resultType = expressionReturnType;
@@ -83,4 +70,18 @@ public class XQueryAnnotationExpressionFactory extends DefaultAnnotationExpressi
     protected Class<?> getResultType(Annotation annotation) {
         return (Class<?>) getAnnotationObjectValue(annotation, "resultType");
     }
+
+    protected String getSource(Annotation annotation) {
+        String answer = null;
+        try {
+            answer = (String) getAnnotationObjectValue(annotation, "source");
+        } catch (Exception e) {
+            // Do Nothing
+        }
+        if (answer != null && answer.isBlank()) {
+            return null;
+        }
+        return answer;
+    }
+
 }
diff --git a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryEndpoint.java b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryEndpoint.java
index fb5daf6edbd..cce4fc33ffd 100644
--- a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryEndpoint.java
+++ b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryEndpoint.java
@@ -74,11 +74,7 @@ public class XQueryEndpoint extends ProcessorEndpoint {
     @UriParam
     private boolean allowStAX;
     @UriParam
-    private String variableName;
-    @UriParam
-    private String headerName;
-    @UriParam
-    private String propertyName;
+    private String source;
 
     public XQueryEndpoint(String endpointUri, Component component) {
         super(endpointUri, component);
@@ -216,37 +212,17 @@ public class XQueryEndpoint extends ProcessorEndpoint {
         this.allowStAX = allowStAX;
     }
 
-    public String getVariableName() {
-        return variableName;
-    }
-
-    /**
-     * To use a variable as the input source instead of Message body.
-     */
-    public void setVariableName(String variableName) {
-        this.variableName = variableName;
-    }
-
-    public String getHeaderName() {
-        return headerName;
-    }
-
-    /**
-     * To use a Camel Message header as the input source instead of Message body.
-     */
-    public void setHeaderName(String headerName) {
-        this.headerName = headerName;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
+    public String getSource() {
+        return source;
     }
 
     /**
-     * To use a Camel Exchange property as the input source instead of Message body.
+     * Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of
+     * source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the
+     * message body.
      */
-    public void setPropertyName(String propertyName) {
-        this.propertyName = propertyName;
+    public void setSource(String source) {
+        this.source = source;
     }
 
     @Override
@@ -282,7 +258,7 @@ public class XQueryEndpoint extends ProcessorEndpoint {
         this.xquery.setStripsAllWhiteSpace(isStripsAllWhiteSpace());
         this.xquery.setAllowStAX(isAllowStAX());
         this.xquery.setModuleURIResolver(getModuleURIResolver());
-        this.xquery.setSource(ExpressionBuilder.singleInputExpression(getVariableName(), getHeaderName(), getPropertyName()));
+        this.xquery.setSource(ExpressionBuilder.singleInputExpression(getSource()));
         this.xquery.init(getCamelContext());
 
         setProcessor(xquery);
diff --git a/components/camel-saxon/src/test/java/org/apache/camel/builder/saxon/XQueryHeaderNameResultTypeAndNamespaceTest.java b/components/camel-saxon/src/test/java/org/apache/camel/builder/saxon/XQueryHeaderNameResultTypeAndNamespaceTest.java
index c1b0cee6f7d..f77262723fc 100644
--- a/components/camel-saxon/src/test/java/org/apache/camel/builder/saxon/XQueryHeaderNameResultTypeAndNamespaceTest.java
+++ b/components/camel-saxon/src/test/java/org/apache/camel/builder/saxon/XQueryHeaderNameResultTypeAndNamespaceTest.java
@@ -26,6 +26,7 @@ import org.junit.jupiter.api.Test;
  * Test XPath DSL with the ability to apply XPath on a header
  */
 public class XQueryHeaderNameResultTypeAndNamespaceTest extends CamelTestSupport {
+
     @Test
     public void testXPathWithNamespace() throws Exception {
         MockEndpoint mock = getMockEndpoint("mock:55");
@@ -43,12 +44,14 @@ public class XQueryHeaderNameResultTypeAndNamespaceTest extends CamelTestSupport
         return new RouteBuilder() {
             public void configure() {
                 Namespaces ns = new Namespaces("c", "http://acme.com/cheese");
+                var xq = expression().xquery().expression("/c:number = 55").namespaces(ns).resultType(Integer.class)
+                        .source("header:cheeseDetails").end();
 
                 from("direct:in").choice()
-                        .when().xquery("/c:number = 55", Integer.class, ns, "cheeseDetails")
-                        .to("mock:55")
+                        .when(xq)
+                            .to("mock:55")
                         .otherwise()
-                        .to("mock:other")
+                            .to("mock:other")
                         .end();
             }
         };
diff --git a/components/camel-saxon/src/test/java/org/apache/camel/builder/saxon/XQueryHeaderNameTest.java b/components/camel-saxon/src/test/java/org/apache/camel/builder/saxon/XQueryHeaderNameTest.java
index 3266fb221af..2fc310e5576 100644
--- a/components/camel-saxon/src/test/java/org/apache/camel/builder/saxon/XQueryHeaderNameTest.java
+++ b/components/camel-saxon/src/test/java/org/apache/camel/builder/saxon/XQueryHeaderNameTest.java
@@ -25,6 +25,7 @@ import org.junit.jupiter.api.Test;
  * Test XQuery DSL with the ability to apply XPath on a header
  */
 public class XQueryHeaderNameTest extends CamelTestSupport {
+
     @Test
     public void testChoiceWithHeaderNamePremium() throws Exception {
         MockEndpoint mock = getMockEndpoint("mock:premium");
@@ -67,14 +68,19 @@ public class XQueryHeaderNameTest extends CamelTestSupport {
     protected RouteBuilder createRouteBuilder() {
         return new RouteBuilder() {
             public void configure() {
+                var premium = expression().xquery().expression("/invoice/@orderType = 'premium'")
+                        .source("header:invoiceDetails").end();
+                var standard = expression().xquery().expression("/invoice/@orderType = 'standard'")
+                        .source("header:invoiceDetails").end();
+
                 from("direct:in")
-                        .choice()
-                        .when().xquery("/invoice/@orderType = 'premium'", "invoiceDetails")
-                        .to("mock:premium")
-                        .when().xquery("/invoice/@orderType = 'standard'", "invoiceDetails")
-                        .to("mock:standard")
+                    .choice()
+                        .when(premium)
+                            .to("mock:premium")
+                        .when(standard)
+                            .to("mock:standard")
                         .otherwise()
-                        .to("mock:unknown")
+                            .to("mock:unknown")
                         .end();
             }
         };
diff --git a/components/camel-saxon/src/test/java/org/apache/camel/component/xquery/BeanWithXQueryInjectionUsingHeaderValueTest.java b/components/camel-saxon/src/test/java/org/apache/camel/component/xquery/BeanWithXQueryInjectionUsingHeaderValueTest.java
index d511d1cd204..d51f8cc4f34 100644
--- a/components/camel-saxon/src/test/java/org/apache/camel/component/xquery/BeanWithXQueryInjectionUsingHeaderValueTest.java
+++ b/components/camel-saxon/src/test/java/org/apache/camel/component/xquery/BeanWithXQueryInjectionUsingHeaderValueTest.java
@@ -49,8 +49,8 @@ public class BeanWithXQueryInjectionUsingHeaderValueTest extends CamelTestSuppor
         @Handler
         public void handler(
                 @XQuery("/response") String response,
-                @XQuery(headerName = "invoiceDetails", value = "/invoice/person/name") String userName,
-                @XQuery(headerName = "invoiceDetails", value = "/invoice/person/date") String date) {
+                @XQuery(source = "header:invoiceDetails", value = "/invoice/person/name") String userName,
+                @XQuery(source = "header:invoiceDetails", value = "/invoice/person/date") String date) {
             this.response = response;
             this.userName = userName;
             this.date = date;
diff --git a/components/camel-spring-xml/src/test/resources/org/apache/camel/spring/processor/xPathHeaderNameContext.xml b/components/camel-spring-xml/src/test/resources/org/apache/camel/spring/processor/xPathHeaderNameContext.xml
index 35b2812fe74..804a34baf71 100644
--- a/components/camel-spring-xml/src/test/resources/org/apache/camel/spring/processor/xPathHeaderNameContext.xml
+++ b/components/camel-spring-xml/src/test/resources/org/apache/camel/spring/processor/xPathHeaderNameContext.xml
@@ -31,11 +31,11 @@
             <from uri="direct:in"/>
             <choice>
                 <when>
-                    <xpath headerName="invoiceDetails">/invoice/@orderType='premium'</xpath>
+                    <xpath source="header:invoiceDetails">/invoice/@orderType='premium'</xpath>
                     <to uri="mock:premium"/>
                 </when>
                 <when>
-                    <xpath headerName="invoiceDetails">/invoice/@orderType='standard'</xpath>
+                    <xpath source="header:invoiceDetails">/invoice/@orderType='standard'</xpath>
                     <to uri="mock:standard"/>
                 </when>
                 <otherwise>
diff --git a/components/camel-spring-xml/src/test/resources/org/apache/camel/spring/processor/xPathHeaderNameResultTypeAndNamespaceContext.xml b/components/camel-spring-xml/src/test/resources/org/apache/camel/spring/processor/xPathHeaderNameResultTypeAndNamespaceContext.xml
index 2cc2a484348..421e4539f51 100644
--- a/components/camel-spring-xml/src/test/resources/org/apache/camel/spring/processor/xPathHeaderNameResultTypeAndNamespaceContext.xml
+++ b/components/camel-spring-xml/src/test/resources/org/apache/camel/spring/processor/xPathHeaderNameResultTypeAndNamespaceContext.xml
@@ -32,7 +32,7 @@
             <from uri="direct:in"/>
             <choice>
                 <when>
-                    <xpath headerName="cheeseDetails" resultType="java.lang.Integer">/c:number = 55</xpath>
+                    <xpath source="header:cheeseDetails" resultType="java.lang.Integer">/c:number = 55</xpath>
                     <to uri="mock:55"/>
                 </when>
                 <otherwise>
diff --git a/components/camel-stax/src/generated/resources/org/apache/camel/language/xtokenizer/xtokenize.json b/components/camel-stax/src/generated/resources/org/apache/camel/language/xtokenizer/xtokenize.json
index 42e98419416..c51276739f5 100644
--- a/components/camel-stax/src/generated/resources/org/apache/camel/language/xtokenizer/xtokenize.json
+++ b/components/camel-stax/src/generated/resources/org/apache/camel/language/xtokenizer/xtokenize.json
@@ -21,10 +21,8 @@
     "mode": { "index": 2, "kind": "attribute", "displayName": "Mode", "required": false, "type": "enum", "javaType": "java.lang.String", "enum": [ "i", "w", "u", "t" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "i", "description": "The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element" },
     "group": { "index": 3, "kind": "attribute", "displayName": "Group", "required": false, "type": "integer", "javaType": "java.lang.Integer", "deprecated": false, "autowired": false, "secret": false, "description": "To group N parts together" },
     "namespace": { "index": 4, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 5, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 6, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 7, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 8, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 9, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 5, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 6, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 7, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/components/camel-stax/src/main/java/org/apache/camel/language/xtokenizer/XMLTokenizeLanguage.java b/components/camel-stax/src/main/java/org/apache/camel/language/xtokenizer/XMLTokenizeLanguage.java
index 5d41314788d..2826207c362 100644
--- a/components/camel-stax/src/main/java/org/apache/camel/language/xtokenizer/XMLTokenizeLanguage.java
+++ b/components/camel-stax/src/main/java/org/apache/camel/language/xtokenizer/XMLTokenizeLanguage.java
@@ -51,11 +51,11 @@ public class XMLTokenizeLanguage extends SingleInputTypedLanguageSupport {
     @Override
     public Expression createExpression(Expression source, String expression, Object[] properties) {
         Class<?> type = property(Class.class, properties, 0, null);
-        Character mode = property(Character.class, properties, 4, "i");
+        Character mode = property(Character.class, properties, 2, "i");
 
         XMLTokenExpressionIterator xml = new XMLTokenExpressionIterator(source, expression, mode);
-        xml.setGroup(property(int.class, properties, 5, 1));
-        Object obj = properties[6];
+        xml.setGroup(property(int.class, properties, 3, 1));
+        Object obj = properties[4];
         if (obj != null) {
             Namespaces ns;
             if (obj instanceof Namespaces) {
diff --git a/components/camel-xpath/src/generated/resources/org/apache/camel/language/xpath/xpath.json b/components/camel-xpath/src/generated/resources/org/apache/camel/language/xpath/xpath.json
index f834f12ece3..ba5ae99aed3 100644
--- a/components/camel-xpath/src/generated/resources/org/apache/camel/language/xpath/xpath.json
+++ b/components/camel-xpath/src/generated/resources/org/apache/camel/language/xpath/xpath.json
@@ -27,10 +27,8 @@
     "threadSafety": { "index": 8, "kind": "attribute", "displayName": "Thread Safety", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to enable thread-safety for the returned result of the xpath expression. This applies to when using NODESET as the result type, and the returned set has multiple elements. In this situation there can be thread-safety issues if you process the NODESET concurrently such as from a Camel Splitter EIP in parallel processing mode. This option prevents concurrency issues by doing defensive copies of the nodes. It is recommended to turn this option on if you are using camel-saxon or Saxon in your application. Saxon has thread-safety issues which can be prevented by turning this option on." },
     "preCompile": { "index": 9, "kind": "attribute", "displayName": "Pre Compile", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to enable pre-compiling the xpath expression during initialization phase. pre-compile is enabled by default. This can be used to turn off, for example in cases the compilation phase is desired at the starting phase, such as if the application is ahead of time compiled (for example with camel-quarkus) which would then load the xpath factory of the built operating system, and not a JVM runtime." },
     "namespace": { "index": 10, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 11, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 12, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 13, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 14, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 15, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 11, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 12, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 13, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPath.java b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPath.java
index 74165579346..8eeb1cc2747 100644
--- a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPath.java
+++ b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPath.java
@@ -54,19 +54,11 @@ public @interface XPath {
     Class<?> resultType() default Object.class;
 
     /**
-     * The name of the variable we want to apply the XPath expression to.
+     * Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of
+     * source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the
+     * message body.
      */
-    String variableName() default "";
-
-    /**
-     * The name of the message header we want to apply the XPath expression to.
-     */
-    String headerName() default "";
-
-    /**
-     * The name of the exchange propery we want to apply the XPath expression to.
-     */
-    String propertyName() default "";
+    String source() default "";
 
     /**
      * Whether to log namespaces which can assist during troubleshooting
diff --git a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathAnnotationExpressionFactory.java b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathAnnotationExpressionFactory.java
index f31bc1a3bc4..0dbe9d410d7 100644
--- a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathAnnotationExpressionFactory.java
+++ b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathAnnotationExpressionFactory.java
@@ -51,12 +51,9 @@ public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressio
             }
         }
 
-        String variableName = getVariableName(annotation);
-        String headerName = getHeaderName(annotation);
-        String propertyName = getPropertyName(annotation);
-        if (variableName != null || headerName != null || propertyName != null) {
-            Expression source = ExpressionBuilder.singleInputExpression(variableName, headerName, propertyName);
-            builder.setSource(source);
+        String source = getSource(annotation);
+        if (source != null) {
+            builder.setSource(ExpressionBuilder.singleInputExpression(source));
         }
 
         return builder;
@@ -70,57 +67,10 @@ public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressio
         return (NamespacePrefix[]) getAnnotationObjectValue(annotation, "namespaces");
     }
 
-    /**
-     * Extracts the value of the header method in the Annotation. For backwards compatibility this method will return
-     * null if the annotation's method is not found.
-     *
-     * @return If the annotation has the method 'headerName' then the name of the header we want to apply the XPath
-     *         expression to. Otherwise, null will be returned
-     */
-    protected String getHeaderName(Annotation annotation) {
+    protected String getSource(Annotation annotation) {
         String answer = null;
         try {
-            answer = (String) getAnnotationObjectValue(annotation, "headerName");
-        } catch (Exception e) {
-            // Do Nothing
-        }
-        if (answer != null && answer.isBlank()) {
-            return null;
-        }
-        return answer;
-    }
-
-    /**
-     * Extracts the value of the property method in the Annotation. For backwards compatibility this method will return
-     * null if the annotation's method is not found.
-     *
-     * @return If the annotation has the method 'propertyName' then the name of the property we want to apply the XPath
-     *         expression to. Otherwise, null will be returned
-     */
-    protected String getPropertyName(Annotation annotation) {
-        String answer = null;
-        try {
-            answer = (String) getAnnotationObjectValue(annotation, "propertyName");
-        } catch (Exception e) {
-            // Do Nothing
-        }
-        if (answer != null && answer.isBlank()) {
-            return null;
-        }
-        return answer;
-    }
-
-    /**
-     * Extracts the value of the property method in the Annotation. For backwards compatibility this method will return
-     * null if the annotation's method is not found.
-     *
-     * @return If the annotation has the method 'variableName' then the name of the property we want to apply the XPath
-     *         expression to. Otherwise, null will be returned
-     */
-    protected String getVariableName(Annotation annotation) {
-        String answer = null;
-        try {
-            answer = (String) getAnnotationObjectValue(annotation, "variableName");
+            answer = (String) getAnnotationObjectValue(annotation, "source");
         } catch (Exception e) {
             // Do Nothing
         }
diff --git a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathLanguage.java b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathLanguage.java
index 93244c25290..0bc94777575 100644
--- a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathLanguage.java
+++ b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathLanguage.java
@@ -134,15 +134,15 @@ public class XPathLanguage extends SingleInputTypedLanguageSupport implements Pr
         if (clazz != null) {
             builder.setResultType(clazz);
         }
-        clazz = property(Class.class, properties, 4, documentType);
+        clazz = property(Class.class, properties, 2, documentType);
         if (clazz != null) {
             builder.setDocumentType(clazz);
         }
-        QName qname = property(QName.class, properties, 5, resultQName);
+        QName qname = property(QName.class, properties, 3, resultQName);
         if (qname != null) {
             builder.setResultQName(qname);
         }
-        Boolean bool = property(Boolean.class, properties, 6, saxon);
+        Boolean bool = property(Boolean.class, properties, 4, saxon);
         if (bool != null) {
             builder.setUseSaxon(bool);
             if (bool) {
@@ -151,28 +151,28 @@ public class XPathLanguage extends SingleInputTypedLanguageSupport implements Pr
         }
         if (!builder.isUseSaxon()) {
             // xpath factory can only be set if not saxon is enabled as saxon has its own factory and object model
-            XPathFactory fac = property(XPathFactory.class, properties, 7, xpathFactory);
+            XPathFactory fac = property(XPathFactory.class, properties, 5, xpathFactory);
             if (fac != null) {
                 builder.setXPathFactory(fac);
             }
-            String str = property(String.class, properties, 8, objectModelUri);
+            String str = property(String.class, properties, 6, objectModelUri);
             if (str != null) {
                 builder.setObjectModelUri(str);
             }
         }
-        bool = property(Boolean.class, properties, 9, threadSafety);
+        bool = property(Boolean.class, properties, 7, threadSafety);
         if (bool != null) {
             builder.setThreadSafety(bool);
         }
-        bool = property(Boolean.class, properties, 10, preCompile);
+        bool = property(Boolean.class, properties, 8, preCompile);
         if (bool != null) {
             builder.setPreCompile(bool);
         }
-        bool = property(Boolean.class, properties, 11, logNamespaces);
+        bool = property(Boolean.class, properties, 9, logNamespaces);
         if (bool != null) {
             builder.setLogNamespaces(bool);
         }
-        Map<String, String> ns = property(Map.class, properties, 12, null);
+        Map<String, String> ns = property(Map.class, properties, 10, null);
         if (ns != null && !ns.isEmpty()) {
             builder.setNamespaces(ns);
         }
diff --git a/core/camel-core-languages/src/generated/resources/org/apache/camel/language/tokenizer/tokenize.json b/core/camel-core-languages/src/generated/resources/org/apache/camel/language/tokenizer/tokenize.json
index 497c8a11f53..d59c5aa9b5c 100644
--- a/core/camel-core-languages/src/generated/resources/org/apache/camel/language/tokenizer/tokenize.json
+++ b/core/camel-core-languages/src/generated/resources/org/apache/camel/language/tokenizer/tokenize.json
@@ -26,10 +26,8 @@
     "group": { "index": 7, "kind": "attribute", "displayName": "Group", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To group N parts together, for example to split big files into chunks of 1000 lines. You can use simple language as the group to support dynamic group sizes." },
     "groupDelimiter": { "index": 8, "kind": "attribute", "displayName": "Group Delimiter", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the delimiter to use when grouping. If this has not been set then token will be used as the delimiter." },
     "skipFirst": { "index": 9, "kind": "attribute", "displayName": "Skip First", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "To skip the very first element" },
-    "variableName": { "index": 10, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 11, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 12, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 13, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 14, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 10, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 11, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 12, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/core/camel-core-languages/src/main/java/org/apache/camel/language/tokenizer/TokenizeLanguage.java b/core/camel-core-languages/src/main/java/org/apache/camel/language/tokenizer/TokenizeLanguage.java
index ad2986db362..e596c186ee9 100644
--- a/core/camel-core-languages/src/main/java/org/apache/camel/language/tokenizer/TokenizeLanguage.java
+++ b/core/camel-core-languages/src/main/java/org/apache/camel/language/tokenizer/TokenizeLanguage.java
@@ -50,15 +50,15 @@ public class TokenizeLanguage extends SingleInputTypedLanguageSupport {
     @Override
     public Expression createExpression(Expression source, String expression, Object[] properties) {
         Class<?> type = property(Class.class, properties, 0, null);
-        String token = property(String.class, properties, 4, expression);
-        String endToken = property(String.class, properties, 5, null);
-        String inheritNamespaceTagName = property(String.class, properties, 6, null);
-        String groupDelimiter = property(String.class, properties, 7, null);
-        boolean regex = property(boolean.class, properties, 8, false);
-        boolean xml = property(boolean.class, properties, 9, false);
-        boolean includeTokens = property(boolean.class, properties, 10, false);
-        String group = property(String.class, properties, 11, null);
-        boolean skipFirst = property(boolean.class, properties, 12, false);
+        String token = property(String.class, properties, 2, expression);
+        String endToken = property(String.class, properties, 3, null);
+        String inheritNamespaceTagName = property(String.class, properties, 4, null);
+        String groupDelimiter = property(String.class, properties, 5, null);
+        boolean regex = property(boolean.class, properties, 6, false);
+        boolean xml = property(boolean.class, properties, 7, false);
+        boolean includeTokens = property(boolean.class, properties, 8, false);
+        String group = property(String.class, properties, 9, null);
+        boolean skipFirst = property(boolean.class, properties, 10, false);
 
         if (endToken != null && inheritNamespaceTagName != null) {
             throw new IllegalArgumentException("Cannot have both xml and pair tokenizer enabled.");
diff --git a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/datasonnet.json b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/datasonnet.json
index 6b4bfe1e4ba..d73586cff49 100644
--- a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/datasonnet.json
+++ b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/datasonnet.json
@@ -17,10 +17,8 @@
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
     "bodyMediaType": { "index": 2, "kind": "attribute", "displayName": "Body Media Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The String representation of the message's body MediaType" },
     "outputMediaType": { "index": 3, "kind": "attribute", "displayName": "Output Media Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The String representation of the MediaType to output" },
-    "variableName": { "index": 4, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 5, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 6, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 7, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 8, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 4, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/hl7terser.json b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/hl7terser.json
index 2d0e1f3bc50..21bdacde06b 100644
--- a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/hl7terser.json
+++ b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/hl7terser.json
@@ -15,10 +15,8 @@
   "properties": {
     "id": { "index": 0, "kind": "attribute", "displayName": "Id", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the id of this node" },
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
-    "variableName": { "index": 2, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 3, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 4, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 2, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 3, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 4, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/jq.json b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/jq.json
index ca29248dc3d..e7682cee3a2 100644
--- a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/jq.json
+++ b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/jq.json
@@ -15,10 +15,8 @@
   "properties": {
     "id": { "index": 0, "kind": "attribute", "displayName": "Id", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the id of this node" },
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
-    "variableName": { "index": 2, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 3, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 4, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 2, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 3, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 4, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/jsonpath.json b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/jsonpath.json
index e1911e5e387..ffb339e6bac 100644
--- a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/jsonpath.json
+++ b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/jsonpath.json
@@ -21,10 +21,8 @@
     "writeAsString": { "index": 5, "kind": "attribute", "displayName": "Write As String", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to write the output of each row\/element as a JSON String value instead of a Map\/POJO value." },
     "unpackArray": { "index": 6, "kind": "attribute", "displayName": "Unpack Array", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to unpack a single element json-array into an object." },
     "option": { "index": 7, "kind": "attribute", "displayName": "Option", "label": "advanced", "required": false, "type": "enum", "javaType": "java.lang.String", "enum": [ "DEFAULT_PATH_LEAF_TO_NULL", "ALWAYS_RETURN_LIST", "AS_PATH_LIST", "SUPPRESS_EXCEPTIONS", "REQUIRE_PROPERTIES" ], "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional options on JSONPath. Multiple values can be separated by comma." },
-    "variableName": { "index": 8, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 9, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 10, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 11, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 12, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 8, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 9, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 10, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/tokenize.json b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/tokenize.json
index 02311acd6e6..734b52e2070 100644
--- a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/tokenize.json
+++ b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/tokenize.json
@@ -23,10 +23,8 @@
     "group": { "index": 7, "kind": "attribute", "displayName": "Group", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To group N parts together, for example to split big files into chunks of 1000 lines. You can use simple language as the group to support dynamic group sizes." },
     "groupDelimiter": { "index": 8, "kind": "attribute", "displayName": "Group Delimiter", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the delimiter to use when grouping. If this has not been set then token will be used as the delimiter." },
     "skipFirst": { "index": 9, "kind": "attribute", "displayName": "Skip First", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "To skip the very first element" },
-    "variableName": { "index": 10, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 11, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 12, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 13, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 14, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 10, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 11, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 12, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xpath.json b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xpath.json
index bc1b25d8257..62b90f8b58a 100644
--- a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xpath.json
+++ b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xpath.json
@@ -24,10 +24,8 @@
     "threadSafety": { "index": 8, "kind": "attribute", "displayName": "Thread Safety", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to enable thread-safety for the returned result of the xpath expression. This applies to when using NODESET as the result type, and the returned set has multiple elements. In this situation there can be thread-safety issues if you process the NODESET concurrently such as from a Camel Splitter EIP in parallel processing mode. This option prevents concurrency issues by doing defensive copies of the nodes. It is recommended to turn this option on if you are using camel-saxon or Saxon in your application. Saxon has thread-safety issues which can be prevented by turning this option on." },
     "preCompile": { "index": 9, "kind": "attribute", "displayName": "Pre Compile", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to enable pre-compiling the xpath expression during initialization phase. pre-compile is enabled by default. This can be used to turn off, for example in cases the compilation phase is desired at the starting phase, such as if the application is ahead of time compiled (for example with camel-quarkus) which would then load the xpath factory of the built operating system, and not a JVM runtime." },
     "namespace": { "index": 10, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 11, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 12, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 13, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 14, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 15, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 11, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 12, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 13, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xquery.json b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xquery.json
index c98d6092c8b..5eb28b65ed0 100644
--- a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xquery.json
+++ b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xquery.json
@@ -17,10 +17,8 @@
     "expression": { "index": 1, "kind": "value", "displayName": "Expression", "required": true, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The expression value in your chosen language syntax" },
     "configurationRef": { "index": 2, "kind": "attribute", "displayName": "Configuration Ref", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Reference to a saxon configuration instance in the registry to use for xquery (requires camel-saxon). This may be needed to add custom functions to a saxon configuration, so these custom functions can be used in xquery expressions." },
     "namespace": { "index": 3, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 4, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 5, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 6, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 7, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 8, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 4, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 5, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 6, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xtokenize.json b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xtokenize.json
index 6ee02088613..dcf8221e6f6 100644
--- a/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xtokenize.json
+++ b/core/camel-core-model/src/generated/resources/org/apache/camel/model/language/xtokenize.json
@@ -18,10 +18,8 @@
     "mode": { "index": 2, "kind": "attribute", "displayName": "Mode", "required": false, "type": "enum", "javaType": "java.lang.String", "enum": [ "i", "w", "u", "t" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "i", "description": "The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element" },
     "group": { "index": 3, "kind": "attribute", "displayName": "Group", "required": false, "type": "integer", "javaType": "java.lang.Integer", "deprecated": false, "autowired": false, "secret": false, "description": "To group N parts together" },
     "namespace": { "index": 4, "kind": "element", "displayName": "Namespace", "label": "common", "required": false, "type": "array", "javaType": "java.util.List<org.apache.camel.model.PropertyDefinition>", "deprecated": false, "autowired": false, "secret": false, "description": "Injects the XML Namespaces of prefix - uri mappings" },
-    "variableName": { "index": 5, "kind": "attribute", "displayName": "Variable Name", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of variable to use as input, instead of the message body" },
-    "headerName": { "index": 6, "kind": "attribute", "displayName": "Header Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of header to use as input, instead of the message body" },
-    "propertyName": { "index": 7, "kind": "attribute", "displayName": "Property Name", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Name of property to use as input, instead of the message body." },
-    "resultType": { "index": 8, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
-    "trim": { "index": 9, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
+    "source": { "index": 5, "kind": "attribute", "displayName": "Source", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body." },
+    "resultType": { "index": 6, "kind": "attribute", "displayName": "Result Type", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Sets the class of the result type (type from output)" },
+    "trim": { "index": 7, "kind": "attribute", "displayName": "Trim", "label": "advanced", "required": false, "type": "boolean", "javaType": "java.lang.Boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks" }
   }
 }
diff --git a/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClause.java b/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClause.java
index 9a4e468b23e..a80e93349c2 100644
--- a/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClause.java
+++ b/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClause.java
@@ -415,54 +415,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.jq(value, resultType);
     }
 
-    /**
-     * Evaluates a <a href="http://camel.apache.org/jq.html">JQ expression</a>
-     *
-     * @param  value                the expression to be evaluated
-     * @param  headerOrPropertyName the name of the header or property to apply the expression to
-     * @return                      the builder to continue processing the DSL
-     */
-    public T jq(String value, String headerOrPropertyName) {
-        return delegate.jq(value, headerOrPropertyName);
-    }
-
-    /**
-     * Evaluates a <a href="http://camel.apache.org/jq.html">JQ expression</a>
-     *
-     * @param  value        the expression to be evaluated
-     * @param  headerName   the name of the header to apply the expression to
-     * @param  propertyName the name of the property to apply the expression to
-     * @return              the builder to continue processing the DSL
-     */
-    public T jq(String value, String headerName, String propertyName) {
-        return delegate.jq(value, headerName, propertyName);
-    }
-
-    /**
-     * Evaluates a <a href="http://camel.apache.org/jq.html">JQ expression</a>
-     *
-     * @param  value                the expression to be evaluated
-     * @param  resultType           the return type expected by the expression
-     * @param  headerOrPropertyName the name of the header or property to apply the expression to
-     * @return                      the builder to continue processing the DSL
-     */
-    public T jq(String value, Class<?> resultType, String headerOrPropertyName) {
-        return delegate.jq(value, resultType, headerOrPropertyName);
-    }
-
-    /**
-     * Evaluates a <a href="http://camel.apache.org/jq.html">JQ expression</a>
-     *
-     * @param  value        the expression to be evaluated
-     * @param  resultType   the return type expected by the expression
-     * @param  headerName   the name of the header to apply the expression to
-     * @param  propertyName the name of the property to apply the expression to
-     * @return              the builder to continue processing the DSL
-     */
-    public T jq(String value, Class<?> resultType, String headerName, String propertyName) {
-        return delegate.jq(value, resultType, headerName, propertyName);
-    }
-
     /**
      * Returns a JavaScript expression value builder
      */
@@ -531,19 +483,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.jsonpath(text, suppressExceptions, resultType);
     }
 
-    /**
-     * Evaluates a <a href="http://camel.apache.org/jsonpath.html">Json Path expression</a>
-     *
-     * @param  text               the expression to be evaluated
-     * @param  suppressExceptions whether to suppress exceptions such as PathNotFoundException
-     * @param  resultType         the return type expected by the expression
-     * @param  headerName         the name of the header to apply the expression to
-     * @return                    the builder to continue processing the DSL
-     */
-    public T jsonpath(String text, boolean suppressExceptions, Class<?> resultType, String headerName) {
-        return delegate.jsonpath(text, suppressExceptions, true, resultType, headerName);
-    }
-
     /**
      * Evaluates a <a href="http://camel.apache.org/jsonpath.html">Json Path expression</a> with writeAsString enabled.
      *
@@ -588,18 +527,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.jsonpathWriteAsString(text, suppressExceptions, resultType);
     }
 
-    /**
-     * Evaluates a <a href="http://camel.apache.org/jsonpath.html">Json Path expression</a> with writeAsString enabled.
-     *
-     * @param  text               the expression to be evaluated
-     * @param  suppressExceptions whether to suppress exceptions such as PathNotFoundException
-     * @param  headerName         the name of the header to apply the expression to
-     * @return                    the builder to continue processing the DSL
-     */
-    public T jsonpathWriteAsString(String text, boolean suppressExceptions, String headerName) {
-        return delegate.jsonpathWriteAsString(text, suppressExceptions, true, headerName);
-    }
-
     /**
      * Evaluates a <a href="http://camel.apache.org/jsonpath.html">Json Path expression</a> with unpacking a
      * single-element array into an object enabled.
@@ -738,7 +665,7 @@ public class ExpressionClause<T> implements Expression, Predicate {
      * @return           the builder to continue processing the DSL
      */
     public T tokenize(String token, boolean regex, boolean skipFirst) {
-        return delegate.tokenize(token, null, regex, skipFirst);
+        return delegate.tokenize(token, regex, null, skipFirst);
     }
 
     /**
@@ -775,7 +702,7 @@ public class ExpressionClause<T> implements Expression, Predicate {
      * @return           the builder to continue processing the DSL
      */
     public T tokenize(String token, boolean regex, int group, boolean skipFirst) {
-        return delegate.tokenize(token, null, regex, group, skipFirst);
+        return delegate.tokenize(token, regex, group, skipFirst);
     }
 
     /**
@@ -788,20 +715,7 @@ public class ExpressionClause<T> implements Expression, Predicate {
      * @return           the builder to continue processing the DSL
      */
     public T tokenize(String token, boolean regex, String group, boolean skipFirst) {
-        return delegate.tokenize(token, null, regex, group, skipFirst);
-    }
-
-    /**
-     * Evaluates a token expression on the message body
-     *
-     * @param  token     the token
-     * @param  regex     whether the token is a regular expression or not
-     * @param  group     to group by the given number
-     * @param  skipFirst whether to skip the first element
-     * @return           the builder to continue processing the DSL
-     */
-    public T tokenize(String token, boolean regex, int group, String groupDelimiter, boolean skipFirst) {
-        return delegate.tokenize(token, null, regex, Integer.toString(group), groupDelimiter, skipFirst);
+        return delegate.tokenize(token, regex, group, skipFirst);
     }
 
     /**
@@ -827,29 +741,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.tokenize(token, group, skipFirst);
     }
 
-    /**
-     * Evaluates a token expression on the given header
-     *
-     * @param  token      the token
-     * @param  headerName name of header to tokenize
-     * @return            the builder to continue processing the DSL
-     */
-    public T tokenize(String token, String headerName) {
-        return delegate.tokenize(token, headerName);
-    }
-
-    /**
-     * Evaluates a token expression on the given header
-     *
-     * @param  token      the token
-     * @param  headerName name of header to tokenize
-     * @param  regex      whether the token is a regular expression or not
-     * @return            the builder to continue processing the DSL
-     */
-    public T tokenize(String token, String headerName, boolean regex) {
-        return delegate.tokenize(token, headerName, regex);
-    }
-
     /**
      * Evaluates a token pair expression on the message body.
      * <p/>
@@ -941,18 +832,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.xpath(text);
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> on the supplied header name's
-     * contents
-     *
-     * @param  text       the expression to be evaluated
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xpath(String text, String headerName) {
-        return delegate.xpath(text, headerName);
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type
      *
@@ -964,19 +843,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.xpath(text, resultType);
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type on
-     * the supplied header name's contents
-     *
-     * @param  text       the expression to be evaluated
-     * @param  resultType the return type expected by the expression
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xpath(String text, Class<?> resultType, String headerName) {
-        return delegate.xpath(text, resultType, headerName);
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type and
      * set of namespace prefixes and URIs
@@ -990,20 +856,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.xpath(text, resultType, namespaces);
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type and
-     * set of namespace prefixes and URIs on the supplied header name's contents
-     *
-     * @param  text       the expression to be evaluated
-     * @param  resultType the return type expected by the expression
-     * @param  headerName the name of the header to apply the expression to
-     * @param  namespaces the namespace prefix and URIs to use
-     * @return            the builder to continue processing the DSL
-     */
-    public T xpath(String text, Class<?> resultType, Namespaces namespaces, String headerName) {
-        return delegate.xpath(text, resultType, namespaces, headerName);
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type and
      * set of namespace prefixes and URIs
@@ -1051,18 +903,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.xquery(text);
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> on the supplied header name's
-     * contents
-     *
-     * @param  text       the expression to be evaluated
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xquery(String text, String headerName) {
-        return delegate.xquery(text, headerName);
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
      *
@@ -1074,18 +914,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.xquery(text, resultType);
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
-     *
-     * @param  text       the expression to be evaluated
-     * @param  resultType the return type expected by the expression
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xquery(String text, Class<?> resultType, String headerName) {
-        return delegate.xquery(text, resultType, headerName);
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
      * and set of namespace prefixes and URIs
@@ -1099,19 +927,6 @@ public class ExpressionClause<T> implements Expression, Predicate {
         return delegate.xquery(text, resultType, namespaces);
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
-     *
-     * @param  text       the expression to be evaluated
-     * @param  resultType the return type expected by the expression
-     * @param  headerName the name of the header to apply the expression to
-     * @param  namespaces the namespace prefix and URIs to use
-     * @return            the builder to continue processing the DSL
-     */
-    public T xquery(String text, Class<?> resultType, Namespaces namespaces, String headerName) {
-        return delegate.xquery(text, resultType, namespaces, headerName);
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
      * and set of namespace prefixes and URIs
diff --git a/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClauseSupport.java b/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClauseSupport.java
index 5acd7b97e3e..25a476e9e02 100644
--- a/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClauseSupport.java
+++ b/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClauseSupport.java
@@ -455,66 +455,6 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
         return expression(exp);
     }
 
-    /**
-     * Evaluates <a href="http://camel.apache.org/jq.html">JQ expression</a>
-     *
-     * @param  text       the expression to be evaluated
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T jq(String text, String headerName) {
-        JqExpression exp = new JqExpression(text);
-        exp.setHeaderName(headerName);
-        return expression(exp);
-    }
-
-    /**
-     * Evaluates <a href="http://camel.apache.org/jq.html">JQ expression</a>
-     *
-     * @param  text         the expression to be evaluated
-     * @param  headerName   the name of the header to apply the expression to
-     * @param  propertyName the name of the propertyName to apply the expression to
-     * @return              the builder to continue processing the DSL
-     */
-    public T jq(String text, String headerName, String propertyName) {
-        JqExpression exp = new JqExpression(text);
-        exp.setHeaderName(headerName);
-        exp.setPropertyName(propertyName);
-        return expression(exp);
-    }
-
-    /**
-     * Evaluates <a href="http://camel.apache.org/jq.html">JQ expression</a>
-     *
-     * @param  text       the expression to be evaluated
-     * @param  resultType the return type expected by the expression
-     * @param  headerName the name of the header or the property to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T jq(String text, Class<?> resultType, String headerName) {
-        JqExpression exp = new JqExpression(text);
-        exp.setResultType(resultType);
-        exp.setHeaderName(headerName);
-        return expression(exp);
-    }
-
-    /**
-     * Evaluates <a href="http://camel.apache.org/jq.html">JQ expression</a>
-     *
-     * @param  text         the expression to be evaluated
-     * @param  resultType   the return type expected by the expression
-     * @param  headerName   the name of the header to apply the expression to
-     * @param  propertyName the name of the propertyName to apply the expression to
-     * @return              the builder to continue processing the DSL
-     */
-    public T jq(String text, Class<?> resultType, String headerName, String propertyName) {
-        JqExpression exp = new JqExpression(text);
-        exp.setResultType(resultType);
-        exp.setHeaderName(headerName);
-        exp.setPropertyName(propertyName);
-        return expression(exp);
-    }
-
     /**
      * Evaluates a <a href="http://camel.apache.org/datasonnet.html">Datasonnet expression</a>
      *
@@ -623,30 +563,6 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
         return result;
     }
 
-    /**
-     * Evaluates a <a href="http://camel.apache.org/jsonpath.html">Json Path expression</a>
-     *
-     * @param  text               the expression to be evaluated
-     * @param  suppressExceptions whether to suppress exceptions such as PathNotFoundException
-     * @param  allowSimple        whether to allow in inlined simple exceptions in the json path expression
-     * @param  resultType         the return type expected by the expression
-     * @param  headerName         the name of the header to apply the expression to
-     * @return                    the builder to continue processing the DSL
-     */
-    public T jsonpath(String text, boolean suppressExceptions, boolean allowSimple, Class<?> resultType, String headerName) {
-        JsonPathExpression expression = new JsonPathExpression(text);
-        if (suppressExceptions) {
-            expression.setSuppressExceptions("true");
-        }
-        if (allowSimple) {
-            expression.setAllowSimple("true");
-        }
-        expression.setResultType(resultType);
-        expression.setHeaderName(headerName);
-        expression(expression);
-        return result;
-    }
-
     /**
      * Evaluates a <a href="http://camel.apache.org/jsonpath.html">Json Path expression</a> with writeAsString enabled.
      *
@@ -722,53 +638,6 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
         return expression(expression);
     }
 
-    /**
-     * Evaluates a <a href="http://camel.apache.org/jsonpath.html">Json Path expression</a> with writeAsString enabled.
-     *
-     * @param  text               the expression to be evaluated
-     * @param  suppressExceptions whether to suppress exceptions such as PathNotFoundException
-     * @param  allowSimple        whether to allow in inlined simple exceptions in the json path expression
-     * @param  headerName         the name of the header to apply the expression to
-     * @return                    the builder to continue processing the DSL
-     */
-    public T jsonpathWriteAsString(String text, boolean suppressExceptions, boolean allowSimple, String headerName) {
-        JsonPathExpression expression = new JsonPathExpression(text);
-        expression.setWriteAsString("true");
-        if (suppressExceptions) {
-            expression.setSuppressExceptions("true");
-        }
-        if (allowSimple) {
-            expression.setAllowSimple("true");
-        }
-        expression.setHeaderName(headerName);
-        return expression(expression);
-    }
-
-    /**
-     * Evaluates a <a href="http://camel.apache.org/jsonpath.html">Json Path expression</a> with writeAsString enabled.
-     *
-     * @param  text               the expression to be evaluated
-     * @param  suppressExceptions whether to suppress exceptions such as PathNotFoundException
-     * @param  allowSimple        whether to allow in inlined simple exceptions in the json path expression
-     * @param  headerName         the name of the header to apply the expression to
-     * @param  resultType         the return type expected by the expression
-     * @return                    the builder to continue processing the DSL
-     */
-    public T jsonpathWriteAsString(
-            String text, boolean suppressExceptions, boolean allowSimple, String headerName, Class<?> resultType) {
-        JsonPathExpression expression = new JsonPathExpression(text);
-        expression.setWriteAsString("true");
-        if (suppressExceptions) {
-            expression.setSuppressExceptions("true");
-        }
-        if (allowSimple) {
-            expression.setAllowSimple("true");
-        }
-        expression.setHeaderName(headerName);
-        expression.setResultType(resultType);
-        return expression(expression);
-    }
-
     /**
      * Evaluates a <a href="http://camel.apache.org/jsonpath.html">Json Path expression</a> with unpacking a
      * single-element array into an object enabled.
@@ -912,7 +781,7 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
      * @return       the builder to continue processing the DSL
      */
     public T tokenize(String token) {
-        return tokenize(token, null, false);
+        return tokenize(token, false);
     }
 
     /**
@@ -923,7 +792,7 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
      * @return       the builder to continue processing the DSL
      */
     public T tokenize(String token, int group) {
-        return tokenize(token, null, false, group);
+        return tokenize(token, false, group);
     }
 
     /**
@@ -935,7 +804,12 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
      * @return           the builder to continue processing the DSL
      */
     public T tokenize(String token, int group, boolean skipFirst) {
-        return tokenize(token, null, false, group, skipFirst);
+        TokenizerExpression expression = new TokenizerExpression();
+        expression.setToken(token);
+        expression.setSkipFirst(Boolean.toString(skipFirst));
+        expression.setGroup(Integer.toString(group));
+        expression(expression);
+        return result;
     }
 
     /**
@@ -946,7 +820,11 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
      * @return       the builder to continue processing the DSL
      */
     public T tokenize(String token, boolean regex) {
-        return tokenize(token, null, regex);
+        TokenizerExpression expression = new TokenizerExpression();
+        expression.setToken(token);
+        expression.setRegex(Boolean.toString(regex));
+        expression(expression);
+        return result;
     }
 
     /**
@@ -958,115 +836,47 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
      * @return       the builder to continue processing the DSL
      */
     public T tokenize(String token, boolean regex, int group) {
-        return tokenize(token, null, regex, group);
-    }
-
-    /**
-     * Evaluates a token expression on the given header
-     *
-     * @param  token      the token
-     * @param  headerName name of header to tokenize
-     * @return            the builder to continue processing the DSL
-     */
-    public T tokenize(String token, String headerName) {
-        return tokenize(token, headerName, false);
-    }
-
-    /**
-     * Evaluates a token expression on the given header
-     *
-     * @param  token      the token
-     * @param  headerName name of header to tokenize
-     * @param  regex      whether the token is a regular expression or not
-     * @return            the builder to continue processing the DSL
-     */
-    public T tokenize(String token, String headerName, boolean regex) {
         TokenizerExpression expression = new TokenizerExpression();
         expression.setToken(token);
-        expression.setHeaderName(headerName);
         expression.setRegex(Boolean.toString(regex));
+        expression.setGroup(Integer.toString(group));
         expression(expression);
         return result;
     }
 
     /**
-     * Evaluates a token expression on the given header
-     *
-     * @param  token      the token
-     * @param  headerName name of header to tokenize
-     * @param  regex      whether the token is a regular expression or not
-     * @param  group      to group by number of parts
-     * @return            the builder to continue processing the DSL
-     */
-    public T tokenize(String token, String headerName, boolean regex, int group) {
-        return tokenize(token, headerName, regex, group, false);
-    }
-
-    /**
-     * Evaluates a token expression on the given header
+     * Evaluates a token expression on the message body
      *
-     * @param  token      the token
-     * @param  headerName name of header to tokenize
-     * @param  regex      whether the token is a regular expression or not
-     * @param  skipFirst  whether to skip the very first element
-     * @return            the builder to continue processing the DSL
+     * @param  token     the token
+     * @param  regex     whether the token is a regular expression or not
+     * @param  group     to group by the given number
+     * @param  skipFirst whether to skip the very first element
+     * @return           the builder to continue processing the DSL
      */
-    public T tokenize(String token, String headerName, boolean regex, boolean skipFirst) {
+    public T tokenize(String token, boolean regex, int group, boolean skipFirst) {
         TokenizerExpression expression = new TokenizerExpression();
         expression.setToken(token);
-        expression.setHeaderName(headerName);
-        expression.setRegex(Boolean.toString(regex));
+        expression.setSkipFirst(Boolean.toString(skipFirst));
+        expression.setGroup(Integer.toString(group));
         expression.setSkipFirst(Boolean.toString(skipFirst));
         expression(expression);
         return result;
     }
 
     /**
-     * Evaluates a token expression on the given header
-     *
-     * @param  token      the token
-     * @param  headerName name of header to tokenize
-     * @param  regex      whether the token is a regular expression or not
-     * @param  group      to group by number of parts
-     * @param  skipFirst  whether to skip the very first element
-     * @return            the builder to continue processing the DSL
-     */
-    public T tokenize(String token, String headerName, boolean regex, int group, boolean skipFirst) {
-        return tokenize(token, headerName, regex, Integer.toString(group), skipFirst);
-    }
-
-    /**
-     * Evaluates a token expression on the given header
-     *
-     * @param  token      the token
-     * @param  headerName name of header to tokenize
-     * @param  regex      whether the token is a regular expression or not
-     * @param  group      to group by number of parts
-     * @param  skipFirst  whether to skip the very first element
-     * @return            the builder to continue processing the DSL
-     */
-    public T tokenize(String token, String headerName, boolean regex, String group, boolean skipFirst) {
-        return tokenize(token, headerName, regex, group, null, skipFirst);
-    }
-
-    /**
-     * Evaluates a token expression on the given header
+     * Evaluates a token expression on the message body
      *
-     * @param  token          the token
-     * @param  headerName     name of header to tokenize
-     * @param  regex          whether the token is a regular expression or not
-     * @param  group          to group by number of parts
-     * @param  groupDelimiter delimiter to use when grouping
-     * @param  skipFirst      whether to skip the very first element
-     * @return                the builder to continue processing the DSL
+     * @param  token     the token
+     * @param  regex     whether the token is a regular expression or not
+     * @param  group     to group by the given number
+     * @param  skipFirst whether to skip the very first element
+     * @return           the builder to continue processing the DSL
      */
-    public T tokenize(String token, String headerName, boolean regex, String group, String groupDelimiter, boolean skipFirst) {
+    public T tokenize(String token, boolean regex, String group, boolean skipFirst) {
         TokenizerExpression expression = new TokenizerExpression();
         expression.setToken(token);
-        expression.setHeaderName(headerName);
-        expression.setRegex(Boolean.toString(regex));
+        expression.setSkipFirst(Boolean.toString(skipFirst));
         expression.setGroup(group);
-        expression.setGroupDelimiter(groupDelimiter);
         expression.setSkipFirst(Boolean.toString(skipFirst));
         expression(expression);
         return result;
@@ -1151,20 +961,6 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
         return expression(new XPathExpression(text));
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> on the supplied header name's
-     * contents
-     *
-     * @param  text       the expression to be evaluated
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xpath(String text, String headerName) {
-        XPathExpression expression = new XPathExpression(text);
-        expression.setHeaderName(headerName);
-        return expression(expression);
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type
      *
@@ -1179,23 +975,6 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
         return result;
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type on
-     * the supplied header name's contents
-     *
-     * @param  text       the expression to be evaluated
-     * @param  resultType the return type expected by the expression
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xpath(String text, Class<?> resultType, String headerName) {
-        XPathExpression expression = new XPathExpression(text);
-        expression.setResultType(resultType);
-        expression.setHeaderName(headerName);
-        expression(expression);
-        return result;
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type and
      * set of namespace prefixes and URIs
@@ -1209,25 +988,6 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
         return xpath(text, resultType, namespaces.getNamespaces());
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type and
-     * set of namespace prefixes and URIs on the supplied header name's contents
-     *
-     * @param  text       the expression to be evaluated
-     * @param  resultType the return type expected by the expression
-     * @param  namespaces the namespace prefix and URIs to use
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xpath(String text, Class<?> resultType, Namespaces namespaces, String headerName) {
-        XPathExpression expression = new XPathExpression(text);
-        expression.setResultType(resultType);
-        expression.setNamespaces(namespaces.getNamespaces());
-        expression.setHeaderName(headerName);
-        expression(expression);
-        return result;
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath expression</a> with the specified result type and
      * set of namespace prefixes and URIs
@@ -1282,19 +1042,6 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
         return expression(new XQueryExpression(text));
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a>
-     *
-     * @param  text       the expression to be evaluated
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xquery(String text, String headerName) {
-        XQueryExpression expression = new XQueryExpression(text);
-        expression.setHeaderName(headerName);
-        return expression(expression);
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
      *
@@ -1309,22 +1056,6 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
         return result;
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
-     *
-     * @param  text       the expression to be evaluated
-     * @param  resultType the return type expected by the expression
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xquery(String text, Class<?> resultType, String headerName) {
-        XQueryExpression expression = new XQueryExpression(text);
-        expression.setResultType(resultType);
-        expression.setHeaderName(headerName);
-        expression(expression);
-        return result;
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
      * and set of namespace prefixes and URIs
@@ -1338,25 +1069,6 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
         return xquery(text, resultType, namespaces.getNamespaces());
     }
 
-    /**
-     * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
-     * and set of namespace prefixes and URIs
-     *
-     * @param  text       the expression to be evaluated
-     * @param  resultType the return type expected by the expression
-     * @param  namespaces the namespace prefix and URIs to use
-     * @param  headerName the name of the header to apply the expression to
-     * @return            the builder to continue processing the DSL
-     */
-    public T xquery(String text, Class<?> resultType, Namespaces namespaces, String headerName) {
-        XQueryExpression expression = new XQueryExpression(text);
-        expression.setResultType(resultType);
-        expression.setNamespaces(namespaces.getNamespaces());
-        expression.setHeaderName(headerName);
-        expression(expression);
-        return result;
-    }
-
     /**
      * Evaluates an <a href="http://camel.apache.org/xquery.html">XQuery expression</a> with the specified result type
      * and set of namespace prefixes and URIs
diff --git a/core/camel-core-model/src/main/java/org/apache/camel/model/language/SingleInputExpressionDefinition.java b/core/camel-core-model/src/main/java/org/apache/camel/model/language/SingleInputExpressionDefinition.java
deleted file mode 100644
index 80d33a8cb39..00000000000
--- a/core/camel-core-model/src/main/java/org/apache/camel/model/language/SingleInputExpressionDefinition.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.camel.model.language;
-
-import jakarta.xml.bind.annotation.XmlAttribute;
-import jakarta.xml.bind.annotation.XmlTransient;
-
-import org.apache.camel.Expression;
-import org.apache.camel.spi.Metadata;
-
-/**
- * Expression for which the source of the input (body, header or property) can be provided.
- */
-@Deprecated
-public abstract class SingleInputExpressionDefinition extends ExpressionDefinition {
-
-    @XmlAttribute
-    private String variableName;
-    @XmlAttribute
-    @Metadata(label = "advanced")
-    private String headerName;
-    @XmlAttribute
-    @Metadata(label = "advanced")
-    private String propertyName;
-
-    protected SingleInputExpressionDefinition() {
-    }
-
-    protected SingleInputExpressionDefinition(String expression) {
-        super(expression);
-    }
-
-    protected SingleInputExpressionDefinition(Expression expression) {
-        super(expression);
-    }
-
-    protected SingleInputExpressionDefinition(AbstractBuilder<?, ?> builder) {
-        super(builder);
-        this.variableName = builder.variableName;
-        this.headerName = builder.headerName;
-        this.propertyName = builder.propertyName;
-    }
-
-    public String getVariableName() {
-        return variableName;
-    }
-
-    /**
-     * Name of variable to use as input, instead of the message body
-     */
-    public void setVariableName(String variableName) {
-        this.variableName = variableName;
-    }
-
-    public String getHeaderName() {
-        return headerName;
-    }
-
-    /**
-     * Name of header to use as input, instead of the message body
-     */
-    public void setHeaderName(String headerName) {
-        this.headerName = headerName;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
-    }
-
-    /**
-     * Name of property to use as input, instead of the message body.
-     * </p>
-     * It has a lower precedent than the headerName if both are set.
-     */
-    public void setPropertyName(String propertyName) {
-        this.propertyName = propertyName;
-    }
-
-    /**
-     * {@code AbstractBuilder} is the base builder for typed expression.
-     */
-    @XmlTransient
-    @SuppressWarnings("unchecked")
-    public abstract static class AbstractBuilder<
-            T extends AbstractBuilder<T, E>, E extends SingleInputExpressionDefinition>
-            extends ExpressionDefinition.AbstractBuilder<T, E> {
-
-        private String variableName;
-        private String headerName;
-        private String propertyName;
-
-        /**
-         * Name of variable to use as input, instead of the message body
-         */
-        public T variableName(String variableName) {
-            this.variableName = variableName;
-            return (T) this;
-        }
-
-        /**
-         * Name of header to use as input, instead of the message body
-         */
-        public T headerName(String headerName) {
-            this.headerName = headerName;
-            return (T) this;
-        }
-
-        /**
-         * Name of property to use as input, instead of the message body.
-         * </p>
-         * It has a lower precedent than the headerName if both are set.
-         */
-        public T propertyName(String propertyName) {
-            this.propertyName = propertyName;
-            return (T) this;
-        }
-    }
-}
diff --git a/core/camel-core-model/src/main/java/org/apache/camel/model/language/SingleInputTypedExpressionDefinition.java b/core/camel-core-model/src/main/java/org/apache/camel/model/language/SingleInputTypedExpressionDefinition.java
index 10ad8518b67..46ab6e998f5 100644
--- a/core/camel-core-model/src/main/java/org/apache/camel/model/language/SingleInputTypedExpressionDefinition.java
+++ b/core/camel-core-model/src/main/java/org/apache/camel/model/language/SingleInputTypedExpressionDefinition.java
@@ -20,7 +20,6 @@ import jakarta.xml.bind.annotation.XmlAttribute;
 import jakarta.xml.bind.annotation.XmlTransient;
 
 import org.apache.camel.Expression;
-import org.apache.camel.spi.Metadata;
 
 /**
  * Expression for which a result type can be provided along with the source of the input (body, header or property).
@@ -28,13 +27,7 @@ import org.apache.camel.spi.Metadata;
 public abstract class SingleInputTypedExpressionDefinition extends TypedExpressionDefinition {
 
     @XmlAttribute
-    private String variableName;
-    @XmlAttribute
-    @Metadata(label = "advanced")
-    private String headerName;
-    @XmlAttribute
-    @Metadata(label = "advanced")
-    private String propertyName;
+    private String source;
 
     protected SingleInputTypedExpressionDefinition() {
     }
@@ -49,42 +42,20 @@ public abstract class SingleInputTypedExpressionDefinition extends TypedExpressi
 
     protected SingleInputTypedExpressionDefinition(AbstractBuilder<?, ?> builder) {
         super(builder);
-        this.variableName = builder.variableName;
-        this.headerName = builder.headerName;
-        this.propertyName = builder.propertyName;
-    }
-
-    public String getVariableName() {
-        return variableName;
-    }
-
-    /**
-     * Name of variable to use as input, instead of the message body
-     */
-    public void setVariableName(String variableName) {
-        this.variableName = variableName;
+        this.source = builder.source;
     }
 
-    public String getHeaderName() {
-        return headerName;
+    public String getSource() {
+        return source;
     }
 
     /**
-     * Name of header to use as input, instead of the message body
+     * Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of
+     * source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the
+     * message body.
      */
-    public void setHeaderName(String headerName) {
-        this.headerName = headerName;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
-    }
-
-    /**
-     * Name of property to use as input, instead of the message body.
-     */
-    public void setPropertyName(String propertyName) {
-        this.propertyName = propertyName;
+    public void setSource(String source) {
+        this.source = source;
     }
 
     /**
@@ -96,15 +67,23 @@ public abstract class SingleInputTypedExpressionDefinition extends TypedExpressi
             T extends AbstractBuilder<T, E>, E extends SingleInputTypedExpressionDefinition>
             extends TypedExpressionDefinition.AbstractBuilder<T, E> {
 
-        private String variableName;
-        private String headerName;
-        private String propertyName;
+        private String source;
+
+        /**
+         * Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind
+         * of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which
+         * is the message body.
+         */
+        public T source(String source) {
+            this.source = source;
+            return (T) this;
+        }
 
         /**
-         * Name of variable to use as input, instead of the message body
+         * Name of variable to use as source, instead of the message body
          */
         public T variableName(String variableName) {
-            this.variableName = variableName;
+            this.source = "variable:" + variableName;
             return (T) this;
         }
 
@@ -112,7 +91,7 @@ public abstract class SingleInputTypedExpressionDefinition extends TypedExpressi
          * Name of header to use as input, instead of the message body
          */
         public T headerName(String headerName) {
-            this.headerName = headerName;
+            this.source = "header:" + headerName;
             return (T) this;
         }
 
@@ -120,7 +99,7 @@ public abstract class SingleInputTypedExpressionDefinition extends TypedExpressi
          * Name of property to use as input, instead of the message body.
          */
         public T propertyName(String propertyName) {
-            this.propertyName = propertyName;
+            this.source = "property:" + propertyName;
             return (T) this;
         }
     }
diff --git a/core/camel-core-model/src/main/java/org/apache/camel/model/language/TokenizerExpression.java b/core/camel-core-model/src/main/java/org/apache/camel/model/language/TokenizerExpression.java
index 4e97047864c..3214d32f31f 100644
--- a/core/camel-core-model/src/main/java/org/apache/camel/model/language/TokenizerExpression.java
+++ b/core/camel-core-model/src/main/java/org/apache/camel/model/language/TokenizerExpression.java
@@ -195,15 +195,11 @@ public class TokenizerExpression extends SingleInputTypedExpressionDefinition {
         if (endToken != null) {
             return "tokenize{body() using tokens: " + token + "..." + endToken + "}";
         } else {
-            final String source;
-            if (getHeaderName() != null) {
-                source = "header: " + getHeaderName();
-            } else if (getPropertyName() != null) {
-                source = "property: " + getPropertyName();
-            } else {
-                source = "body()";
+            String s = getSource();
+            if (s == null) {
+                s = "body";
             }
-            return "tokenize{" + source + " using token: " + token + "}";
+            return "tokenize{" + s + " using token: " + token + "}";
         }
     }
 
@@ -315,6 +311,15 @@ public class TokenizerExpression extends SingleInputTypedExpressionDefinition {
             return this;
         }
 
+        /**
+         * To group N parts together, for example to split big files into chunks of 1000 lines. You can use simple
+         * language as the group to support dynamic group sizes.
+         */
+        public Builder group(int group) {
+            this.group = Integer.toString(group);
+            return this;
+        }
+
         /**
          * Sets the delimiter to use when grouping. If this has not been set then token will be used as the delimiter.
          */
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/DatasonnetExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/DatasonnetExpressionReifier.java
index daa52811857..b623233809c 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/DatasonnetExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/DatasonnetExpressionReifier.java
@@ -20,7 +20,7 @@ import org.apache.camel.CamelContext;
 import org.apache.camel.model.language.DatasonnetExpression;
 import org.apache.camel.model.language.ExpressionDefinition;
 
-public class DatasonnetExpressionReifier extends TypedExpressionReifier<DatasonnetExpression> {
+public class DatasonnetExpressionReifier extends SingleInputTypedExpressionReifier<DatasonnetExpression> {
 
     public DatasonnetExpressionReifier(CamelContext camelContext, ExpressionDefinition definition) {
         super(camelContext, definition);
@@ -28,13 +28,11 @@ public class DatasonnetExpressionReifier extends TypedExpressionReifier<Datasonn
 
     @Override
     protected Object[] createProperties() {
-        Object[] properties = new Object[6];
+        Object[] properties = new Object[4];
         properties[0] = asResultType();
-        properties[1] = parseString(definition.getVariableName());
-        properties[2] = parseString(definition.getHeaderName());
-        properties[3] = parseString(definition.getPropertyName());
-        properties[4] = parseString(definition.getBodyMediaType());
-        properties[5] = parseString(definition.getOutputMediaType());
+        properties[1] = parseString(definition.getSource());
+        properties[2] = parseString(definition.getBodyMediaType());
+        properties[3] = parseString(definition.getOutputMediaType());
         return properties;
     }
 }
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/JsonPathExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/JsonPathExpressionReifier.java
index 306ed50c029..a9990e59435 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/JsonPathExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/JsonPathExpressionReifier.java
@@ -28,17 +28,15 @@ public class JsonPathExpressionReifier extends SingleInputTypedExpressionReifier
 
     @Override
     protected Object[] createProperties() {
-        Object[] properties = new Object[10];
+        Object[] properties = new Object[8];
         properties[0] = asResultType();
-        properties[1] = parseString(definition.getVariableName());
-        properties[2] = parseString(definition.getHeaderName());
-        properties[3] = parseString(definition.getPropertyName());
-        properties[4] = parseBoolean(definition.getSuppressExceptions());
-        properties[5] = parseBoolean(definition.getAllowSimple());
-        properties[6] = parseBoolean(definition.getAllowEasyPredicate());
-        properties[7] = parseBoolean(definition.getWriteAsString());
-        properties[8] = parseBoolean(definition.getUnpackArray());
-        properties[9] = parseString(definition.getOption());
+        properties[1] = parseString(definition.getSource());
+        properties[2] = parseBoolean(definition.getSuppressExceptions());
+        properties[3] = parseBoolean(definition.getAllowSimple());
+        properties[4] = parseBoolean(definition.getAllowEasyPredicate());
+        properties[5] = parseBoolean(definition.getWriteAsString());
+        properties[6] = parseBoolean(definition.getUnpackArray());
+        properties[7] = parseString(definition.getOption());
         return properties;
     }
 
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/SingleInputTypedExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/SingleInputTypedExpressionReifier.java
index e3261967d89..d56cdf6a90e 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/SingleInputTypedExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/SingleInputTypedExpressionReifier.java
@@ -35,11 +35,9 @@ class SingleInputTypedExpressionReifier<T extends SingleInputTypedExpressionDefi
 
     @Override
     protected Object[] createProperties() {
-        Object[] properties = new Object[4];
+        Object[] properties = new Object[2];
         properties[0] = asResultType();
-        properties[1] = parseString(definition.getVariableName());
-        properties[2] = parseString(definition.getHeaderName());
-        properties[3] = parseString(definition.getPropertyName());
+        properties[1] = parseString(definition.getSource());
         return properties;
     }
 }
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/TokenizerExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/TokenizerExpressionReifier.java
index 88cfeba2322..e8171f4220c 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/TokenizerExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/TokenizerExpressionReifier.java
@@ -17,55 +17,35 @@
 package org.apache.camel.reifier.language;
 
 import org.apache.camel.CamelContext;
-import org.apache.camel.Expression;
-import org.apache.camel.Predicate;
 import org.apache.camel.model.language.ExpressionDefinition;
 import org.apache.camel.model.language.TokenizerExpression;
-import org.apache.camel.spi.Language;
-import org.apache.camel.support.ExpressionToPredicateAdapter;
 
-public class TokenizerExpressionReifier extends TypedExpressionReifier<TokenizerExpression> {
+public class TokenizerExpressionReifier extends SingleInputTypedExpressionReifier<TokenizerExpression> {
 
     public TokenizerExpressionReifier(CamelContext camelContext, ExpressionDefinition definition) {
         super(camelContext, (TokenizerExpression) definition);
     }
 
     protected Object[] createProperties() {
-        Object[] properties = new Object[13];
+        Object[] properties = new Object[11];
         properties[0] = asResultType();
-        properties[1] = parseString(definition.getVariableName());
-        properties[2] = parseString(definition.getHeaderName());
-        properties[3] = parseString(definition.getPropertyName());
+        properties[1] = parseString(definition.getSource());
         // special for new line tokens, if defined from XML then its 2
         // characters, so we replace that back to a single char
         String token = definition.getToken();
         if (token.startsWith("\\n")) {
             token = '\n' + token.substring(2);
         }
-        properties[4] = parseString(token);
-        properties[5] = parseString(definition.getEndToken());
-        properties[6] = parseString(definition.getInheritNamespaceTagName());
-        properties[7] = parseString(definition.getGroupDelimiter());
-        properties[8] = parseBoolean(definition.getRegex());
-        properties[9] = parseBoolean(definition.getXml());
-        properties[10] = parseBoolean(definition.getIncludeTokens());
-        properties[11] = parseString(definition.getGroup());
-        properties[12] = parseBoolean(definition.getSkipFirst());
+        properties[2] = parseString(token);
+        properties[3] = parseString(definition.getEndToken());
+        properties[4] = parseString(definition.getInheritNamespaceTagName());
+        properties[5] = parseString(definition.getGroupDelimiter());
+        properties[6] = parseBoolean(definition.getRegex());
+        properties[7] = parseBoolean(definition.getXml());
+        properties[8] = parseBoolean(definition.getIncludeTokens());
+        properties[9] = parseString(definition.getGroup());
+        properties[10] = parseBoolean(definition.getSkipFirst());
         return properties;
     }
 
-    @Override
-    public Predicate createPredicate() {
-        return ExpressionToPredicateAdapter.toPredicate(createExpression());
-    }
-
-    @Override
-    protected Expression createExpression(Language language, String exp) {
-        return language.createExpression(exp, createProperties());
-    }
-
-    @Override
-    protected Predicate createPredicate(Language language, String exp) {
-        return language.createPredicate(exp, createProperties());
-    }
 }
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XMLTokenizerExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XMLTokenizerExpressionReifier.java
index 001696fae83..8c33ac43907 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XMLTokenizerExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XMLTokenizerExpressionReifier.java
@@ -21,32 +21,14 @@ import org.apache.camel.Expression;
 import org.apache.camel.Predicate;
 import org.apache.camel.model.language.ExpressionDefinition;
 import org.apache.camel.model.language.XMLTokenizerExpression;
-import org.apache.camel.spi.Language;
 import org.apache.camel.spi.NamespaceAware;
-import org.apache.camel.support.ExpressionToPredicateAdapter;
 
-public class XMLTokenizerExpressionReifier extends TypedExpressionReifier<XMLTokenizerExpression> {
+public class XMLTokenizerExpressionReifier extends SingleInputTypedExpressionReifier<XMLTokenizerExpression> {
 
     public XMLTokenizerExpressionReifier(CamelContext camelContext, ExpressionDefinition definition) {
         super(camelContext, (XMLTokenizerExpression) definition);
     }
 
-    @Override
-    public Predicate createPredicate() {
-        Expression exp = createExpression();
-        return ExpressionToPredicateAdapter.toPredicate(exp);
-    }
-
-    @Override
-    protected Expression createExpression(Language language, String exp) {
-        return language.createExpression(exp, createProperties());
-    }
-
-    @Override
-    protected Predicate createPredicate(Language language, String exp) {
-        return language.createPredicate(exp, createProperties());
-    }
-
     @Override
     protected void configurePredicate(Predicate predicate) {
         configureNamespaceAware(predicate);
@@ -65,14 +47,12 @@ public class XMLTokenizerExpressionReifier extends TypedExpressionReifier<XMLTok
     }
 
     protected Object[] createProperties() {
-        Object[] properties = new Object[7];
+        Object[] properties = new Object[5];
         properties[0] = asResultType();
-        properties[1] = parseString(definition.getVariableName());
-        properties[2] = parseString(definition.getHeaderName());
-        properties[3] = parseString(definition.getPropertyName());
-        properties[4] = parseString(definition.getMode());
-        properties[5] = parseInt(definition.getGroup());
-        properties[6] = definition.getNamespaces();
+        properties[1] = parseString(definition.getSource());
+        properties[2] = parseString(definition.getMode());
+        properties[3] = parseInt(definition.getGroup());
+        properties[4] = definition.getNamespaces();
         return properties;
     }
 
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XPathExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XPathExpressionReifier.java
index 5e72919575c..f3e56a15077 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XPathExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XPathExpressionReifier.java
@@ -28,22 +28,12 @@ import org.apache.camel.model.language.XPathExpression;
 import org.apache.camel.spi.Language;
 import org.apache.camel.spi.NamespaceAware;
 
-public class XPathExpressionReifier extends TypedExpressionReifier<XPathExpression> {
+public class XPathExpressionReifier extends SingleInputTypedExpressionReifier<XPathExpression> {
 
     public XPathExpressionReifier(CamelContext camelContext, ExpressionDefinition definition) {
         super(camelContext, (XPathExpression) definition);
     }
 
-    @Override
-    protected Expression createExpression(Language language, String exp) {
-        return language.createExpression(exp, createProperties());
-    }
-
-    @Override
-    protected Predicate createPredicate(Language language, String exp) {
-        return language.createPredicate(exp, createProperties());
-    }
-
     @Override
     protected void configurePredicate(Predicate predicate) {
         configureNamespaceAware(predicate);
@@ -62,20 +52,18 @@ public class XPathExpressionReifier extends TypedExpressionReifier<XPathExpressi
     }
 
     protected Object[] createProperties() {
-        Object[] properties = new Object[13];
+        Object[] properties = new Object[11];
         properties[0] = asResultType();
-        properties[1] = parseString(definition.getVariableName());
-        properties[2] = parseString(definition.getHeaderName());
-        properties[3] = parseString(definition.getPropertyName());
-        properties[4] = definition.getDocumentType();
-        properties[5] = asQName(parseString(definition.getResultQName()));
-        properties[6] = parseBoolean(definition.getSaxon());
-        properties[7] = definition.getXPathFactory();
-        properties[8] = parseString(definition.getObjectModel());
-        properties[9] = parseBoolean(definition.getThreadSafety());
-        properties[10] = parseBoolean(definition.getPreCompile());
-        properties[11] = parseBoolean(definition.getLogNamespaces());
-        properties[12] = definition.getNamespaces();
+        properties[1] = parseString(definition.getSource());
+        properties[2] = definition.getDocumentType();
+        properties[3] = asQName(parseString(definition.getResultQName()));
+        properties[4] = parseBoolean(definition.getSaxon());
+        properties[5] = definition.getXPathFactory();
+        properties[6] = parseString(definition.getObjectModel());
+        properties[7] = parseBoolean(definition.getThreadSafety());
+        properties[8] = parseBoolean(definition.getPreCompile());
+        properties[9] = parseBoolean(definition.getLogNamespaces());
+        properties[10] = definition.getNamespaces();
         return properties;
     }
 
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XQueryExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XQueryExpressionReifier.java
index 9646bfb4eef..cc13d1248ed 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XQueryExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XQueryExpressionReifier.java
@@ -24,22 +24,12 @@ import org.apache.camel.model.language.XQueryExpression;
 import org.apache.camel.spi.Language;
 import org.apache.camel.spi.NamespaceAware;
 
-public class XQueryExpressionReifier extends TypedExpressionReifier<XQueryExpression> {
+public class XQueryExpressionReifier extends SingleInputTypedExpressionReifier<XQueryExpression> {
 
     public XQueryExpressionReifier(CamelContext camelContext, ExpressionDefinition definition) {
         super(camelContext, (XQueryExpression) definition);
     }
 
-    @Override
-    protected Expression createExpression(Language language, String exp) {
-        return language.createExpression(exp, createProperties());
-    }
-
-    @Override
-    protected Predicate createPredicate(Language language, String exp) {
-        return language.createPredicate(exp, createProperties());
-    }
-
     @Override
     protected void configurePredicate(Predicate predicate) {
         configureNamespaceAware(predicate);
@@ -58,11 +48,9 @@ public class XQueryExpressionReifier extends TypedExpressionReifier<XQueryExpres
     }
 
     protected Object[] createProperties() {
-        Object[] properties = new Object[4];
+        Object[] properties = new Object[2];
         properties[0] = asResultType();
-        properties[1] = parseString(definition.getVariableName());
-        properties[2] = parseString(definition.getHeaderName());
-        properties[3] = parseString(definition.getPropertyName());
+        properties[1] = parseString(definition.getSource());
         return properties;
     }
 
diff --git a/core/camel-core/src/test/java/org/apache/camel/builder/xml/XPathHeaderNameResultTypeAndNamespaceTest.java b/core/camel-core/src/test/java/org/apache/camel/builder/xml/XPathHeaderNameResultTypeAndNamespaceTest.java
index 37bf0acc251..c7167043a6a 100644
--- a/core/camel-core/src/test/java/org/apache/camel/builder/xml/XPathHeaderNameResultTypeAndNamespaceTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/builder/xml/XPathHeaderNameResultTypeAndNamespaceTest.java
@@ -26,6 +26,7 @@ import org.junit.jupiter.api.Test;
  * Test XPath DSL with the ability to apply XPath on a header
  */
 public class XPathHeaderNameResultTypeAndNamespaceTest extends ContextTestSupport {
+
     @Test
     public void testXPathWithNamespace() throws Exception {
         MockEndpoint mock = getMockEndpoint("mock:55");
@@ -43,8 +44,10 @@ public class XPathHeaderNameResultTypeAndNamespaceTest extends ContextTestSuppor
         return new RouteBuilder() {
             public void configure() throws Exception {
                 Namespaces ns = new Namespaces("c", "http://acme.com/cheese");
+                var xpath = expression().xpath().expression("/c:number = 55").namespaces(ns).resultType(Integer.class)
+                        .source("header:cheeseDetails").end();
 
-                from("direct:in").choice().when().xpath("/c:number = 55", Integer.class, ns, "cheeseDetails").to("mock:55")
+                from("direct:in").choice().when(xpath).to("mock:55")
                         .otherwise().to("mock:other").end();
             }
         };
diff --git a/core/camel-core/src/test/java/org/apache/camel/builder/xml/XPathHeaderNameTest.java b/core/camel-core/src/test/java/org/apache/camel/builder/xml/XPathHeaderNameTest.java
index 38fe33bb7b3..52ea50d872c 100644
--- a/core/camel-core/src/test/java/org/apache/camel/builder/xml/XPathHeaderNameTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/builder/xml/XPathHeaderNameTest.java
@@ -66,9 +66,17 @@ public class XPathHeaderNameTest extends ContextTestSupport {
     protected RouteBuilder createRouteBuilder() throws Exception {
         return new RouteBuilder() {
             public void configure() throws Exception {
-                from("direct:in").choice().when().xpath("/invoice/@orderType = 'premium'", "invoiceDetails").to("mock:premium")
-                        .when()
-                        .xpath("/invoice/@orderType = 'standard'", "invoiceDetails").to("mock:standard").otherwise()
+
+                var premium = expression().xpath().expression("/invoice/@orderType = 'premium'").source("header:invoiceDetails")
+                        .end();
+                var standard = expression().xpath().expression("/invoice/@orderType = 'standard'")
+                        .source("header:invoiceDetails").end();
+
+                from("direct:in").choice().when(premium)
+                        .to("mock:premium")
+                        .when(standard)
+                        .to("mock:standard")
+                        .otherwise()
                         .to("mock:unknown").end();
             }
         };
diff --git a/core/camel-core/src/test/java/org/apache/camel/component/bean/BeanWithXPathInjectionUsingHeaderValueTest.java b/core/camel-core/src/test/java/org/apache/camel/component/bean/BeanWithXPathInjectionUsingHeaderValueTest.java
index fd1030c7fdd..b2c131c2fce 100644
--- a/core/camel-core/src/test/java/org/apache/camel/component/bean/BeanWithXPathInjectionUsingHeaderValueTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/component/bean/BeanWithXPathInjectionUsingHeaderValueTest.java
@@ -63,8 +63,9 @@ public class BeanWithXPathInjectionUsingHeaderValueTest extends ContextTestSuppo
         @Handler
         public void handler(
                 @XPath("//response/text()") String response,
-                @XPath(headerName = "invoiceDetails", value = "//invoice/person/name/text()") String userName,
-                @XPath(headerName = "invoiceDetails", value = "//invoice/person/date", resultType = String.class) String date) {
+                @XPath(source = "header:invoiceDetails", value = "//invoice/person/name/text()") String userName,
+                @XPath(source = "header:invoiceDetails", value = "//invoice/person/date",
+                       resultType = String.class) String date) {
             this.response = response;
             this.userName = userName;
             this.date = date;
diff --git a/core/camel-core/src/test/java/org/apache/camel/language/TokenizerTest.java b/core/camel-core/src/test/java/org/apache/camel/language/TokenizerTest.java
index bf48e643372..67864abf2f1 100644
--- a/core/camel-core/src/test/java/org/apache/camel/language/TokenizerTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/language/TokenizerTest.java
@@ -36,27 +36,27 @@ public class TokenizerTest extends ExchangeTestSupport {
     Expression tokenize(String token, boolean regex) {
         TokenizeLanguage language = new TokenizeLanguage();
         language.setCamelContext(context);
-        return language.createExpression(null, new Object[] { null, null, null, null, token, null, null, null, regex });
+        return language.createExpression(null, new Object[] { null, null, token, null, null, null, regex });
     }
 
     Expression tokenize(String headerName, String token) {
         TokenizeLanguage language = new TokenizeLanguage();
         language.setCamelContext(context);
-        return language.createExpression(null, new Object[] { null, null, headerName, null, token });
+        return language.createExpression(null, new Object[] { null, "header:" + headerName, token });
     }
 
     Expression tokenizePair(String startToken, String endToken, boolean includeTokens) {
         TokenizeLanguage language = new TokenizeLanguage();
         language.setCamelContext(context);
         return language.createExpression(null,
-                new Object[] { null, null, null, null, startToken, endToken, null, null, null, null, includeTokens });
+                new Object[] { null, null, startToken, endToken, null, null, null, null, includeTokens });
     }
 
     Expression tokenizeXML(String tagName, String inheritNamespaceTagName) {
         TokenizeLanguage language = new TokenizeLanguage();
         language.setCamelContext(context);
         return language.createExpression(null,
-                new Object[] { null, null, null, null, tagName, null, inheritNamespaceTagName, null, null, true });
+                new Object[] { null, null, tagName, null, inheritNamespaceTagName, null, null, true });
     }
 
     @Override
@@ -135,7 +135,7 @@ public class TokenizerTest extends ExchangeTestSupport {
     public void testTokenizeManualConfiguration() throws Exception {
         TokenizeLanguage lan = new TokenizeLanguage();
         lan.setCamelContext(context);
-        Expression exp = lan.createExpression(null, new Object[] { null, null, "names", null, "," });
+        Expression exp = lan.createExpression(null, new Object[] { null, "header:names", "," });
         exp.init(context);
 
         List<?> names = exp.evaluate(exchange, List.class);
diff --git a/core/camel-core/src/test/java/org/apache/camel/processor/SplitTokenizerRegexpGroupTest.java b/core/camel-core/src/test/java/org/apache/camel/processor/SplitTokenizerRegexpGroupTest.java
index 8d8c44ca4b1..d1a50ef48ca 100644
--- a/core/camel-core/src/test/java/org/apache/camel/processor/SplitTokenizerRegexpGroupTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/processor/SplitTokenizerRegexpGroupTest.java
@@ -41,7 +41,9 @@ public class SplitTokenizerRegexpGroupTest extends ContextTestSupport {
         return new RouteBuilder() {
             @Override
             public void configure() throws Exception {
-                from("direct:start").split().tokenize("\r\n|\n", true, 2, "\n", true).log("${body}").to("mock:line");
+                var token = expression().tokenize().token("\r\n|\n").regex(true).group(2).groupDelimiter("\n").skipFirst(true)
+                        .end();
+                from("direct:start").split(token).to("mock:line");
             }
         };
     }
diff --git a/core/camel-core/src/test/java/org/apache/camel/processor/SplitTokenizerTest.java b/core/camel-core/src/test/java/org/apache/camel/processor/SplitTokenizerTest.java
index 8a3763d951b..49dc9900d3e 100644
--- a/core/camel-core/src/test/java/org/apache/camel/processor/SplitTokenizerTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/processor/SplitTokenizerTest.java
@@ -106,9 +106,10 @@ public class SplitTokenizerTest extends ContextTestSupport {
 
                 from("direct:a").split().tokenize(",").to("mock:split");
 
-                from("direct:b").split().tokenize(",", "myHeader").to("mock:split");
+                var byHeader = expression().tokenize().token(",").source("header:myHeader").end();
+                from("direct:b").split(byHeader).to("mock:split");
 
-                from("direct:c").split().tokenize("(\\W+)\\s*", null, true).to("mock:split");
+                from("direct:c").split().tokenize("(\\W+)\\s*", true).to("mock:split");
 
                 from("direct:d").split().tokenizePair("[", "]", true).to("mock:split");
 
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/SingleInputTypedLanguageSupport.java b/core/camel-support/src/main/java/org/apache/camel/support/SingleInputTypedLanguageSupport.java
index 3bd3c23f5b0..a88a3a203bf 100644
--- a/core/camel-support/src/main/java/org/apache/camel/support/SingleInputTypedLanguageSupport.java
+++ b/core/camel-support/src/main/java/org/apache/camel/support/SingleInputTypedLanguageSupport.java
@@ -51,17 +51,15 @@ public abstract class SingleInputTypedLanguageSupport extends TypedLanguageSuppo
         }
 
         Class<?> type = property(Class.class, properties, 0, null);
-        String variable = property(String.class, properties, 1, null);
-        String header = property(String.class, properties, 2, null);
-        String property = property(String.class, properties, 3, null);
-        Expression source = ExpressionBuilder.singleInputExpression(variable, header, property);
+        String source = property(String.class, properties, 1, null);
+        Expression input = ExpressionBuilder.singleInputExpression(source);
         if (getCamelContext() != null) {
-            source.init(getCamelContext());
+            input.init(getCamelContext());
         }
         if (type == null || type == Object.class || !supportResultType()) {
-            return createExpression(source, expression, properties);
+            return createExpression(input, expression, properties);
         }
-        return ExpressionBuilder.convertToExpression(createExpression(source, expression, properties), type);
+        return ExpressionBuilder.convertToExpression(createExpression(input, expression, properties), type);
     }
 
     @Override
@@ -71,14 +69,12 @@ public abstract class SingleInputTypedLanguageSupport extends TypedLanguageSuppo
         }
 
         Class<?> type = property(Class.class, properties, 0, null);
-        String variable = property(String.class, properties, 1, null);
-        String header = property(String.class, properties, 2, null);
-        String property = property(String.class, properties, 3, null);
-        Expression source = ExpressionBuilder.singleInputExpression(variable, header, property);
+        String source = property(String.class, properties, 1, null);
+        Expression input = ExpressionBuilder.singleInputExpression(source);
         if (getCamelContext() != null) {
-            source.init(getCamelContext());
+            input.init(getCamelContext());
         }
-        return createPredicate(source, expression, properties);
+        return createPredicate(input, expression, properties);
     }
 
     /**
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java b/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java
index 2017ac246e9..7d855069a63 100644
--- a/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java
+++ b/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java
@@ -1047,10 +1047,13 @@ public class ExpressionBuilder {
      * Returns an expression for evaluating the expression/predicate using the given language
      *
      * @param  expression the expression or predicate
-     * @param  input      input to use instead of message body
+     * @param  source     Source to use, instead of message body. You can prefix with variable:, header:, or property:
+     *                    to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or
+     *                    null to use default source, which is the message body.
      * @return            an expression object which will evaluate the expression/predicate using the given language
      */
-    public static Expression singleInputLanguageExpression(final String language, final String expression, final String input) {
+    public static Expression singleInputLanguageExpression(
+            final String language, final String expression, final String source) {
         return new ExpressionAdapter() {
             private Expression expr;
             private Predicate pred;
@@ -1070,31 +1073,9 @@ public class ExpressionBuilder {
                 super.init(context);
                 Language lan = context.resolveLanguage(language);
                 if (lan != null) {
-                    if (input != null && lan instanceof SingleInputTypedLanguageSupport sil) {
-                        String prefix = StringHelper.before(input, ":");
-                        String name = StringHelper.after(input, ":");
-                        if (prefix != null) {
-                            prefix = prefix.trim();
-                        }
-                        if (name != null) {
-                            name = name.trim();
-                        }
-                        String header = null;
-                        String property = null;
-                        String variable = null;
-                        if ("header".equals(prefix)) {
-                            header = name;
-                        } else if ("property".equals(prefix) || "exchangeProperty".equals(prefix)) {
-                            property = name;
-                        } else if ("variable".equals(prefix)) {
-                            variable = name;
-                        } else {
-                            throw new IllegalArgumentException(
-                                    "Invalid input source for language. Should either be header:key, exchangeProperty:key, or variable:key, was: "
-                                                               + input);
-                        }
-                        Expression source = ExpressionBuilder.singleInputExpression(variable, header, property);
-                        expr = sil.createExpression(source, expression, null);
+                    if (source != null && lan instanceof SingleInputTypedLanguageSupport sil) {
+                        Expression input = ExpressionBuilder.singleInputExpression(source);
+                        expr = sil.createExpression(input, expression, null);
                         expr.init(context);
                         pred = PredicateBuilder.toPredicate(expr);
                         pred.init(context);
@@ -1303,24 +1284,26 @@ public class ExpressionBuilder {
     /**
      * Creates a source {@link Expression} for languages that can accept input from other sources than the message body.
      *
-     * @param  variableName the name of the variable from which the input data must be extracted if not empty.
-     * @param  headerName   the name of the header from which the input data must be extracted if not empty.
-     * @param  propertyName the name of the property from which the input data must be extracted if not empty and
-     *                      {@code headerName} is empty.
-     * @return              a variable expression if {@code variableName} is not empty, a header expression if
-     *                      {@code headerName} is not empty, otherwise a property expression if {@code propertyName} is
-     *                      not empty or finally a body expression.
-     */
-    public static Expression singleInputExpression(String variableName, String headerName, String propertyName) {
+     * @param  source Source to use, instead of message body. You can prefix with variable:, header:, or property: to
+     *                specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to
+     *                use default source, which is the message body.
+     * @return        a variable expression if {@code variableName} is not empty, a header expression if
+     *                {@code headerName} is not empty, otherwise a property expression if {@code propertyName} is not
+     *                empty or finally a body expression.
+     */
+    public static Expression singleInputExpression(String source) {
         final Expression exp;
-        if (ObjectHelper.isNotEmpty(variableName)) {
-            exp = variableExpression(variableName, true);
-        } else if (ObjectHelper.isNotEmpty(headerName)) {
-            exp = headerExpression(headerName, true);
-        } else if (ObjectHelper.isNotEmpty(propertyName)) {
-            exp = exchangePropertyExpression(propertyName, true);
-        } else {
+        if (source == null || source.isEmpty()) {
             exp = bodyExpression();
+        } else if (source.startsWith("header:")) {
+            exp = headerExpression(source.substring(7), true);
+        } else if (source.startsWith("property:")) {
+            exp = exchangePropertyExpression(source.substring(9), true);
+        } else {
+            if (source.startsWith("variable:")) {
+                source = source.substring(9);
+            }
+            exp = variableExpression(source);
         }
         return exp;
     }
@@ -2414,29 +2397,22 @@ public class ExpressionBuilder {
      * Returns an {@link TokenXMLExpressionIterator} expression
      */
     public static Expression tokenizeXMLExpression(String tagName, String inheritNamespaceTagName) {
-        StringHelper.notEmpty(tagName, "tagName");
         return new TokenXMLExpressionIterator(tagName, inheritNamespaceTagName);
     }
 
     public static Expression tokenizeXMLExpression(Expression source, String tagName, String inheritNamespaceTagName) {
-        StringHelper.notEmpty(tagName, "tagName");
         return new TokenXMLExpressionIterator(source, tagName, inheritNamespaceTagName);
     }
 
     public static Expression tokenizeXMLAwareExpression(String path, char mode) {
-        return tokenizeXMLAwareExpression(null, path, mode, 1, null);
+        return tokenizeXMLAwareExpression(path, mode, 1, null);
     }
 
     public static Expression tokenizeXMLAwareExpression(String path, char mode, int group) {
-        return tokenizeXMLAwareExpression(null, path, mode, group, null);
+        return tokenizeXMLAwareExpression(path, mode, group, null);
     }
 
     public static Expression tokenizeXMLAwareExpression(String path, char mode, int group, Namespaces namespaces) {
-        return tokenizeXMLAwareExpression(null, path, mode, group, namespaces);
-    }
-
-    public static Expression tokenizeXMLAwareExpression(
-            String headerName, String path, char mode, int group, Namespaces namespaces) {
         StringHelper.notEmpty(path, "path");
         return new ExpressionAdapter() {
             private Expression exp;
@@ -2451,7 +2427,7 @@ public class ExpressionBuilder {
                 super.init(context);
                 final Language language = context.resolveLanguage("xtokenize");
                 this.exp = language.createExpression(path,
-                        new Object[] { null, null, headerName, null, mode, group, namespaces });
+                        new Object[] { null, null, mode, group, namespaces });
                 this.exp.init(context);
             }
 
diff --git a/core/camel-xml-io/src/generated/java/org/apache/camel/xml/in/ModelParser.java b/core/camel-xml-io/src/generated/java/org/apache/camel/xml/in/ModelParser.java
index 147fa513081..1e3b60f0e2d 100644
--- a/core/camel-xml-io/src/generated/java/org/apache/camel/xml/in/ModelParser.java
+++ b/core/camel-xml-io/src/generated/java/org/apache/camel/xml/in/ModelParser.java
@@ -2878,13 +2878,11 @@ public class ModelParser extends BaseParser {
     }
     protected <T extends SingleInputTypedExpressionDefinition> AttributeHandler<T> singleInputTypedExpressionDefinitionAttributeHandler() {
         return (def, key, val) -> {
-            switch (key) {
-                case "headerName": def.setHeaderName(val); break;
-                case "propertyName": def.setPropertyName(val); break;
-                case "variableName": def.setVariableName(val); break;
-                default: return typedExpressionDefinitionAttributeHandler().accept(def, key, val);
+            if ("source".equals(key)) {
+                def.setSource(val);
+                return true;
             }
-            return true;
+            return typedExpressionDefinitionAttributeHandler().accept(def, key, val);
         };
     }
     protected ExchangePropertyExpression doParseExchangePropertyExpression() throws IOException, XmlPullParserException {
diff --git a/core/camel-xml-io/src/generated/java/org/apache/camel/xml/out/ModelWriter.java b/core/camel-xml-io/src/generated/java/org/apache/camel/xml/out/ModelWriter.java
index 39304c0c88e..b476ea80af6 100644
--- a/core/camel-xml-io/src/generated/java/org/apache/camel/xml/out/ModelWriter.java
+++ b/core/camel-xml-io/src/generated/java/org/apache/camel/xml/out/ModelWriter.java
@@ -4146,9 +4146,7 @@ public class ModelWriter extends BaseWriter {
             SingleInputTypedExpressionDefinition def)
             throws IOException {
         doWriteTypedExpressionDefinitionAttributes(def);
-        doWriteAttribute("headerName", def.getHeaderName());
-        doWriteAttribute("variableName", def.getVariableName());
-        doWriteAttribute("propertyName", def.getPropertyName());
+        doWriteAttribute("source", def.getSource());
     }
     protected void doWriteSingleInputTypedExpressionDefinition(
             String name,
diff --git a/core/camel-yaml-io/src/generated/java/org/apache/camel/yaml/out/ModelWriter.java b/core/camel-yaml-io/src/generated/java/org/apache/camel/yaml/out/ModelWriter.java
index e70ae9cdf21..d0e72f25c78 100644
--- a/core/camel-yaml-io/src/generated/java/org/apache/camel/yaml/out/ModelWriter.java
+++ b/core/camel-yaml-io/src/generated/java/org/apache/camel/yaml/out/ModelWriter.java
@@ -4146,9 +4146,7 @@ public class ModelWriter extends BaseWriter {
             SingleInputTypedExpressionDefinition def)
             throws IOException {
         doWriteTypedExpressionDefinitionAttributes(def);
-        doWriteAttribute("headerName", def.getHeaderName());
-        doWriteAttribute("variableName", def.getVariableName());
-        doWriteAttribute("propertyName", def.getPropertyName());
+        doWriteAttribute("source", def.getSource());
     }
     protected void doWriteSingleInputTypedExpressionDefinition(
             String name,
diff --git a/docs/user-manual/modules/ROOT/pages/camel-4x-upgrade-guide-4_4.adoc b/docs/user-manual/modules/ROOT/pages/camel-4x-upgrade-guide-4_4.adoc
index 92bd507382c..a9311bec5d3 100644
--- a/docs/user-manual/modules/ROOT/pages/camel-4x-upgrade-guide-4_4.adoc
+++ b/docs/user-manual/modules/ROOT/pages/camel-4x-upgrade-guide-4_4.adoc
@@ -21,6 +21,68 @@ Durations and some time-related information were consolidated in a new internal
 
 The `lookup` method in `org.apache.camel.component.properties.PropertiesLookup` now has a 2nd parameter for the default value.
 
+Some of the Java DSL for `tokenize`, `xmlTokenize`, `xpath`, `xquery` and `jsonpath` has been removed as part of making the DSL model consistent.
+
+Here are a few examples of migration before vs after:
+
+[source,java]
+----
+ from("direct:in")
+    .choice()
+        .when().xpath("/invoice/@orderType = 'premium'", "invoiceDetails")
+            .to("mock:premium")
+        .when() .xpath("/invoice/@orderType = 'standard'", "invoiceDetails")
+            .to("mock:standard")
+        .otherwise()
+            .to("mock:unknown")
+    .end();
+----
+
+You can use the _fluent expression_ builder to configure all the options:
+
+[source,java]
+----
+// use fluent builder expression to create the languages
+var premium = expression().xpath().expression("/invoice/@orderType = 'premium'").source("header:invoiceDetails").end();
+var standard = expression().xpath().expression("/invoice/@orderType = 'standard'").source("header:invoiceDetails").end();
+
+from("direct:in")
+    .choice()
+        .when(premium)
+            .to("mock:premium")
+        .when(standard)
+            .to("mock:standard")
+        .otherwise()
+            .to("mock:unknown")
+    .end();
+----
+
+In the example above notice how we use `source` to specify the input to use, in this case a header named invoiceDetails.
+The `source` can also be variable, or exchange property.
+
+And another example with `tokenize`:
+
+[source,java]
+----
+from("direct:start")
+    .split().tokenize("\r\n|\n", true, 2, "\n", true)
+        .log("${body}")
+        .to("mock:line");
+----
+
+You can use the _fluent expression_ builder to configure all the options:
+
+[source,java]
+----
+// use fluent builder expression to create the languages
+var token = expression().tokenize().token("\r\n|\n").regex(true).group(2).groupDelimiter("\n").skipFirst(true).end();
+
+from("direct:start")
+    .split(token)
+        .log("${body}")
+        .to("mock:line");
+----
+
 ==== Languages
 
 The way languages are created and configured by Camel has been refactored to be aligned and avoid a thread-safety issues
@@ -28,6 +90,10 @@ when using Java DSL. The setter/getter on the `Language` classes for options tha
 
 In XML and YAML DSL the `type` option in `<xquery>` has been renamed to `resultType` to be aligned with the other languages.
 
+In XML and YAML DSL The `headerName` on `<xpath>`, `<xquery>` has been renamed to `source` and you should prefix the value with `header:name` to declare
+it is a header, because other kind of sources can be specified also. The same change has applied to `@XPath` and `@XQuery`
+language annotations.
+
 ==== WireTap EIP
 
 The copied exchange is no longer having exchange property CORRELATION_ID set that links to the original exchange.
diff --git a/dsl/camel-yaml-dsl/camel-yaml-dsl-deserializers/src/generated/java/org/apache/camel/dsl/yaml/deserializers/ModelDeserializers.java b/dsl/camel-yaml-dsl/camel-yaml-dsl-deserializers/src/generated/java/org/apache/camel/dsl/yaml/deserializers/ModelDeserializers.java
index 0ef2905807e..1937f2467c7 100644
--- a/dsl/camel-yaml-dsl/camel-yaml-dsl-deserializers/src/generated/java/org/apache/camel/dsl/yaml/deserializers/ModelDeserializers.java
+++ b/dsl/camel-yaml-dsl/camel-yaml-dsl-deserializers/src/generated/java/org/apache/camel/dsl/yaml/deserializers/ModelDeserializers.java
@@ -4257,13 +4257,11 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
             properties = {
                     @YamlProperty(name = "bodyMediaType", type = "string", description = "The String representation of the message's body MediaType", displayName = "Body Media Type"),
                     @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
-                    @YamlProperty(name = "headerName", type = "string", description = "Name of header to use as input, instead of the message body", displayName = "Header Name"),
                     @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                     @YamlProperty(name = "outputMediaType", type = "string", description = "The String representation of the MediaType to output", displayName = "Output Media Type"),
-                    @YamlProperty(name = "propertyName", type = "string", description = "Name of property to use as input, instead of the message body.", displayName = "Property Name"),
                     @YamlProperty(name = "resultType", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
-                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
-                    @YamlProperty(name = "variableName", type = "string", description = "Name of variable to use as input, instead of the message body", displayName = "Variable Name")
+                    @YamlProperty(name = "source", type = "string", description = "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.", displayName = "Source"),
+                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
             }
     )
     public static class DatasonnetExpressionDeserializer extends YamlDeserializerBase<DatasonnetExpression> {
@@ -4296,11 +4294,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setExpression(val);
                     break;
                 }
-                case "headerName": {
-                    String val = asText(node);
-                    target.setHeaderName(val);
-                    break;
-                }
                 case "id": {
                     String val = asText(node);
                     target.setId(val);
@@ -4311,24 +4304,19 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setOutputMediaType(val);
                     break;
                 }
-                case "propertyName": {
-                    String val = asText(node);
-                    target.setPropertyName(val);
-                    break;
-                }
                 case "resultType": {
                     String val = asText(node);
                     target.setResultTypeName(val);
                     break;
                 }
-                case "trim": {
+                case "source": {
                     String val = asText(node);
-                    target.setTrim(val);
+                    target.setSource(val);
                     break;
                 }
-                case "variableName": {
+                case "trim": {
                     String val = asText(node);
-                    target.setVariableName(val);
+                    target.setTrim(val);
                     break;
                 }
                 default: {
@@ -6885,12 +6873,10 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
             deprecated = false,
             properties = {
                     @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
-                    @YamlProperty(name = "headerName", type = "string", description = "Name of header to use as input, instead of the message body", displayName = "Header Name"),
                     @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
-                    @YamlProperty(name = "propertyName", type = "string", description = "Name of property to use as input, instead of the message body.", displayName = "Property Name"),
                     @YamlProperty(name = "resultType", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
-                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
-                    @YamlProperty(name = "variableName", type = "string", description = "Name of variable to use as input, instead of the message body", displayName = "Variable Name")
+                    @YamlProperty(name = "source", type = "string", description = "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.", displayName = "Source"),
+                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
             }
     )
     public static class Hl7TerserExpressionDeserializer extends YamlDeserializerBase<Hl7TerserExpression> {
@@ -6918,34 +6904,24 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setExpression(val);
                     break;
                 }
-                case "headerName": {
-                    String val = asText(node);
-                    target.setHeaderName(val);
-                    break;
-                }
                 case "id": {
                     String val = asText(node);
                     target.setId(val);
                     break;
                 }
-                case "propertyName": {
-                    String val = asText(node);
-                    target.setPropertyName(val);
-                    break;
-                }
                 case "resultType": {
                     String val = asText(node);
                     target.setResultTypeName(val);
                     break;
                 }
-                case "trim": {
+                case "source": {
                     String val = asText(node);
-                    target.setTrim(val);
+                    target.setSource(val);
                     break;
                 }
-                case "variableName": {
+                case "trim": {
                     String val = asText(node);
-                    target.setVariableName(val);
+                    target.setTrim(val);
                     break;
                 }
                 default: {
@@ -7959,12 +7935,10 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
             deprecated = false,
             properties = {
                     @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
-                    @YamlProperty(name = "headerName", type = "string", description = "Name of header to use as input, instead of the message body", displayName = "Header Name"),
                     @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
-                    @YamlProperty(name = "propertyName", type = "string", description = "Name of property to use as input, instead of the message body.", displayName = "Property Name"),
                     @YamlProperty(name = "resultType", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
-                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
-                    @YamlProperty(name = "variableName", type = "string", description = "Name of variable to use as input, instead of the message body", displayName = "Variable Name")
+                    @YamlProperty(name = "source", type = "string", description = "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.", displayName = "Source"),
+                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
             }
     )
     public static class JqExpressionDeserializer extends YamlDeserializerBase<JqExpression> {
@@ -7992,34 +7966,24 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setExpression(val);
                     break;
                 }
-                case "headerName": {
-                    String val = asText(node);
-                    target.setHeaderName(val);
-                    break;
-                }
                 case "id": {
                     String val = asText(node);
                     target.setId(val);
                     break;
                 }
-                case "propertyName": {
-                    String val = asText(node);
-                    target.setPropertyName(val);
-                    break;
-                }
                 case "resultType": {
                     String val = asText(node);
                     target.setResultTypeName(val);
                     break;
                 }
-                case "trim": {
+                case "source": {
                     String val = asText(node);
-                    target.setTrim(val);
+                    target.setSource(val);
                     break;
                 }
-                case "variableName": {
+                case "trim": {
                     String val = asText(node);
-                    target.setVariableName(val);
+                    target.setTrim(val);
                     break;
                 }
                 default: {
@@ -8275,15 +8239,13 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     @YamlProperty(name = "allowEasyPredicate", type = "boolean", description = "Whether to allow using the easy predicate parser to pre-parse predicates.", displayName = "Allow Easy Predicate"),
                     @YamlProperty(name = "allowSimple", type = "boolean", description = "Whether to allow in inlined Simple exceptions in the JSONPath expression", displayName = "Allow Simple"),
                     @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
-                    @YamlProperty(name = "headerName", type = "string", description = "Name of header to use as input, instead of the message body", displayName = "Header Name"),
                     @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                     @YamlProperty(name = "option", type = "enum:DEFAULT_PATH_LEAF_TO_NULL,ALWAYS_RETURN_LIST,AS_PATH_LIST,SUPPRESS_EXCEPTIONS,REQUIRE_PROPERTIES", description = "To configure additional options on JSONPath. Multiple values can be separated by comma.", displayName = "Option"),
-                    @YamlProperty(name = "propertyName", type = "string", description = "Name of property to use as input, instead of the message body.", displayName = "Property Name"),
                     @YamlProperty(name = "resultType", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
+                    @YamlProperty(name = "source", type = "string", description = "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.", displayName = "Source"),
                     @YamlProperty(name = "suppressExceptions", type = "boolean", description = "Whether to suppress exceptions such as PathNotFoundException.", displayName = "Suppress Exceptions"),
                     @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
                     @YamlProperty(name = "unpackArray", type = "boolean", description = "Whether to unpack a single element json-array into an object.", displayName = "Unpack Array"),
-                    @YamlProperty(name = "variableName", type = "string", description = "Name of variable to use as input, instead of the message body", displayName = "Variable Name"),
                     @YamlProperty(name = "writeAsString", type = "boolean", description = "Whether to write the output of each row/element as a JSON String value instead of a Map/POJO value.", displayName = "Write As String")
             }
     )
@@ -8322,11 +8284,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setExpression(val);
                     break;
                 }
-                case "headerName": {
-                    String val = asText(node);
-                    target.setHeaderName(val);
-                    break;
-                }
                 case "id": {
                     String val = asText(node);
                     target.setId(val);
@@ -8337,14 +8294,14 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setOption(val);
                     break;
                 }
-                case "propertyName": {
+                case "resultType": {
                     String val = asText(node);
-                    target.setPropertyName(val);
+                    target.setResultTypeName(val);
                     break;
                 }
-                case "resultType": {
+                case "source": {
                     String val = asText(node);
-                    target.setResultTypeName(val);
+                    target.setSource(val);
                     break;
                 }
                 case "suppressExceptions": {
@@ -8362,11 +8319,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setUnpackArray(val);
                     break;
                 }
-                case "variableName": {
-                    String val = asText(node);
-                    target.setVariableName(val);
-                    break;
-                }
                 case "writeAsString": {
                     String val = asText(node);
                     target.setWriteAsString(val);
@@ -18453,17 +18405,15 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     @YamlProperty(name = "endToken", type = "string", description = "The end token to use as tokenizer if using start/end token pairs. You can use simple language as the token to support dynamic tokens.", displayName = "End Token"),
                     @YamlProperty(name = "group", type = "string", description = "To group N parts together, for example to split big files into chunks of 1000 lines. You can use simple language as the group to support dynamic group sizes.", displayName = "Group"),
                     @YamlProperty(name = "groupDelimiter", type = "string", description = "Sets the delimiter to use when grouping. If this has not been set then token will be used as the delimiter.", displayName = "Group Delimiter"),
-                    @YamlProperty(name = "headerName", type = "string", description = "Name of header to use as input, instead of the message body", displayName = "Header Name"),
                     @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                     @YamlProperty(name = "includeTokens", type = "boolean", description = "Whether to include the tokens in the parts when using pairs. When including tokens then the endToken property must also be configured (to use pair mode). The default value is false", displayName = "Include Tokens"),
                     @YamlProperty(name = "inheritNamespaceTagName", type = "string", description = "To inherit namespaces from a root/parent tag name when using XML You can use simple language as the tag name to support dynamic names.", displayName = "Inherit Namespace Tag Name"),
-                    @YamlProperty(name = "propertyName", type = "string", description = "Name of property to use as input, instead of the message body.", displayName = "Property Name"),
                     @YamlProperty(name = "regex", type = "boolean", description = "If the token is a regular expression pattern. The default value is false", displayName = "Regex"),
                     @YamlProperty(name = "resultType", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                     @YamlProperty(name = "skipFirst", type = "boolean", description = "To skip the very first element", displayName = "Skip First"),
+                    @YamlProperty(name = "source", type = "string", description = "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.", displayName = "Source"),
                     @YamlProperty(name = "token", type = "string", required = true, description = "The (start) token to use as tokenizer, for example you can use the new line token. You can use simple language as the token to support dynamic tokens.", displayName = "Token"),
                     @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
-                    @YamlProperty(name = "variableName", type = "string", description = "Name of variable to use as input, instead of the message body", displayName = "Variable Name"),
                     @YamlProperty(name = "xml", type = "boolean", description = "Whether the input is XML messages. This option must be set to true if working with XML payloads.", displayName = "Xml")
             }
     )
@@ -18502,11 +18452,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setGroupDelimiter(val);
                     break;
                 }
-                case "headerName": {
-                    String val = asText(node);
-                    target.setHeaderName(val);
-                    break;
-                }
                 case "id": {
                     String val = asText(node);
                     target.setId(val);
@@ -18522,11 +18467,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setInheritNamespaceTagName(val);
                     break;
                 }
-                case "propertyName": {
-                    String val = asText(node);
-                    target.setPropertyName(val);
-                    break;
-                }
                 case "regex": {
                     String val = asText(node);
                     target.setRegex(val);
@@ -18542,6 +18482,11 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setSkipFirst(val);
                     break;
                 }
+                case "source": {
+                    String val = asText(node);
+                    target.setSource(val);
+                    break;
+                }
                 case "token": {
                     String val = asText(node);
                     target.setToken(val);
@@ -18552,11 +18497,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setTrim(val);
                     break;
                 }
-                case "variableName": {
-                    String val = asText(node);
-                    target.setVariableName(val);
-                    break;
-                }
                 case "xml": {
                     String val = asText(node);
                     target.setXml(val);
@@ -20545,14 +20485,12 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
             properties = {
                     @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                     @YamlProperty(name = "group", type = "number", description = "To group N parts together", displayName = "Group"),
-                    @YamlProperty(name = "headerName", type = "string", description = "Name of header to use as input, instead of the message body", displayName = "Header Name"),
                     @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                     @YamlProperty(name = "mode", type = "enum:i,w,u,t", defaultValue = "i", description = "The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element", displayName = "Mode"),
                     @YamlProperty(name = "namespace", type = "array:org.apache.camel.model.PropertyDefinition", description = "Injects the XML Namespaces of prefix - uri mappings", displayName = "Namespace"),
-                    @YamlProperty(name = "propertyName", type = "string", description = "Name of property to use as input, instead of the message body.", displayName = "Property Name"),
                     @YamlProperty(name = "resultType", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
-                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
-                    @YamlProperty(name = "variableName", type = "string", description = "Name of variable to use as input, instead of the message body", displayName = "Variable Name")
+                    @YamlProperty(name = "source", type = "string", description = "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.", displayName = "Source"),
+                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
             }
     )
     public static class XMLTokenizerExpressionDeserializer extends YamlDeserializerBase<XMLTokenizerExpression> {
@@ -20585,11 +20523,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setGroup(val);
                     break;
                 }
-                case "headerName": {
-                    String val = asText(node);
-                    target.setHeaderName(val);
-                    break;
-                }
                 case "id": {
                     String val = asText(node);
                     target.setId(val);
@@ -20605,24 +20538,19 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setNamespace(val);
                     break;
                 }
-                case "propertyName": {
-                    String val = asText(node);
-                    target.setPropertyName(val);
-                    break;
-                }
                 case "resultType": {
                     String val = asText(node);
                     target.setResultTypeName(val);
                     break;
                 }
-                case "trim": {
+                case "source": {
                     String val = asText(node);
-                    target.setTrim(val);
+                    target.setSource(val);
                     break;
                 }
-                case "variableName": {
+                case "trim": {
                     String val = asText(node);
-                    target.setVariableName(val);
+                    target.setTrim(val);
                     break;
                 }
                 default: {
@@ -20654,19 +20582,17 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     @YamlProperty(name = "documentType", type = "string", description = "Name of class for document type The default value is org.w3c.dom.Document", displayName = "Document Type"),
                     @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
                     @YamlProperty(name = "factoryRef", type = "string", description = "References to a custom XPathFactory to lookup in the registry", displayName = "Factory Ref"),
-                    @YamlProperty(name = "headerName", type = "string", description = "Name of header to use as input, instead of the message body", displayName = "Header Name"),
                     @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                     @YamlProperty(name = "logNamespaces", type = "boolean", description = "Whether to log namespaces which can assist during troubleshooting", displayName = "Log Namespaces"),
                     @YamlProperty(name = "namespace", type = "array:org.apache.camel.model.PropertyDefinition", description = "Injects the XML Namespaces of prefix - uri mappings", displayName = "Namespace"),
                     @YamlProperty(name = "objectModel", type = "string", description = "The XPath object model to use", displayName = "Object Model"),
                     @YamlProperty(name = "preCompile", type = "boolean", description = "Whether to enable pre-compiling the xpath expression during initialization phase. pre-compile is enabled by default. This can be used to turn off, for example in cases the compilation phase is desired at the starting phase, such as if the application is ahead of time compiled (for example with camel-quarkus) which would then load the xpath factory of the built operating system, and not a JVM runtime.", displayName = "Pre Compile"),
-                    @YamlProperty(name = "propertyName", type = "string", description = "Name of property to use as input, instead of the message body.", displayName = "Property Name"),
                     @YamlProperty(name = "resultQName", type = "enum:NUMBER,STRING,BOOLEAN,NODESET,NODE", defaultValue = "NODESET", description = "Sets the output type supported by XPath.", displayName = "Result QName"),
                     @YamlProperty(name = "resultType", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
                     @YamlProperty(name = "saxon", type = "boolean", description = "Whether to use Saxon.", displayName = "Saxon"),
+                    @YamlProperty(name = "source", type = "string", description = "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.", displayName = "Source"),
                     @YamlProperty(name = "threadSafety", type = "boolean", description = "Whether to enable thread-safety for the returned result of the xpath expression. This applies to when using NODESET as the result type, and the returned set has multiple elements. In this situation there can be thread-safety issues if you process the NODESET concurrently such as from a Camel Splitter EIP in parallel processing mode. This option prevents concurrency issues by doing defensive copies of the nodes. It is recommended to turn this option on if you are using camel-saxon or Saxon in your application. Saxon has thread-safety issues which can be prevented by turning this option on.", displayName = "Thread Safety"),
-                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
-                    @YamlProperty(name = "variableName", type = "string", description = "Name of variable to use as input, instead of the message body", displayName = "Variable Name")
+                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
             }
     )
     public static class XPathExpressionDeserializer extends YamlDeserializerBase<XPathExpression> {
@@ -20704,11 +20630,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setFactoryRef(val);
                     break;
                 }
-                case "headerName": {
-                    String val = asText(node);
-                    target.setHeaderName(val);
-                    break;
-                }
                 case "id": {
                     String val = asText(node);
                     target.setId(val);
@@ -20734,11 +20655,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setPreCompile(val);
                     break;
                 }
-                case "propertyName": {
-                    String val = asText(node);
-                    target.setPropertyName(val);
-                    break;
-                }
                 case "resultQName": {
                     String val = asText(node);
                     target.setResultQName(val);
@@ -20754,6 +20670,11 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setSaxon(val);
                     break;
                 }
+                case "source": {
+                    String val = asText(node);
+                    target.setSource(val);
+                    break;
+                }
                 case "threadSafety": {
                     String val = asText(node);
                     target.setThreadSafety(val);
@@ -20764,11 +20685,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setTrim(val);
                     break;
                 }
-                case "variableName": {
-                    String val = asText(node);
-                    target.setVariableName(val);
-                    break;
-                }
                 default: {
                     ExpressionDefinition ed = target.getExpressionType();
                     if (ed != null) {
@@ -20797,13 +20713,11 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
             properties = {
                     @YamlProperty(name = "configurationRef", type = "string", description = "Reference to a saxon configuration instance in the registry to use for xquery (requires camel-saxon). This may be needed to add custom functions to a saxon configuration, so these custom functions can be used in xquery expressions.", displayName = "Configuration Ref"),
                     @YamlProperty(name = "expression", type = "string", required = true, description = "The expression value in your chosen language syntax", displayName = "Expression"),
-                    @YamlProperty(name = "headerName", type = "string", description = "Name of header to use as input, instead of the message body", displayName = "Header Name"),
                     @YamlProperty(name = "id", type = "string", description = "Sets the id of this node", displayName = "Id"),
                     @YamlProperty(name = "namespace", type = "array:org.apache.camel.model.PropertyDefinition", description = "Injects the XML Namespaces of prefix - uri mappings", displayName = "Namespace"),
-                    @YamlProperty(name = "propertyName", type = "string", description = "Name of property to use as input, instead of the message body.", displayName = "Property Name"),
                     @YamlProperty(name = "resultType", type = "string", description = "Sets the class of the result type (type from output)", displayName = "Result Type"),
-                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim"),
-                    @YamlProperty(name = "variableName", type = "string", description = "Name of variable to use as input, instead of the message body", displayName = "Variable Name")
+                    @YamlProperty(name = "source", type = "string", description = "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.", displayName = "Source"),
+                    @YamlProperty(name = "trim", type = "boolean", description = "Whether to trim the value to remove leading and trailing whitespaces and line breaks", displayName = "Trim")
             }
     )
     public static class XQueryExpressionDeserializer extends YamlDeserializerBase<XQueryExpression> {
@@ -20836,11 +20750,6 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setExpression(val);
                     break;
                 }
-                case "headerName": {
-                    String val = asText(node);
-                    target.setHeaderName(val);
-                    break;
-                }
                 case "id": {
                     String val = asText(node);
                     target.setId(val);
@@ -20851,24 +20760,19 @@ public final class ModelDeserializers extends YamlDeserializerSupport {
                     target.setNamespace(val);
                     break;
                 }
-                case "propertyName": {
-                    String val = asText(node);
-                    target.setPropertyName(val);
-                    break;
-                }
                 case "resultType": {
                     String val = asText(node);
                     target.setResultTypeName(val);
                     break;
                 }
-                case "trim": {
+                case "source": {
                     String val = asText(node);
-                    target.setTrim(val);
+                    target.setSource(val);
                     break;
                 }
-                case "variableName": {
+                case "trim": {
                     String val = asText(node);
-                    target.setVariableName(val);
+                    target.setTrim(val);
                     break;
                 }
                 default: {
diff --git a/dsl/camel-yaml-dsl/camel-yaml-dsl/src/generated/resources/schema/camelYamlDsl.json b/dsl/camel-yaml-dsl/camel-yaml-dsl/src/generated/resources/schema/camelYamlDsl.json
index b82aca255dc..838032eaddd 100644
--- a/dsl/camel-yaml-dsl/camel-yaml-dsl/src/generated/resources/schema/camelYamlDsl.json
+++ b/dsl/camel-yaml-dsl/camel-yaml-dsl/src/generated/resources/schema/camelYamlDsl.json
@@ -12683,11 +12683,6 @@
               "title" : "Expression",
               "description" : "The expression value in your chosen language syntax"
             },
-            "headerName" : {
-              "type" : "string",
-              "title" : "Header Name",
-              "description" : "Name of header to use as input, instead of the message body"
-            },
             "id" : {
               "type" : "string",
               "title" : "Id",
@@ -12698,25 +12693,20 @@
               "title" : "Output Media Type",
               "description" : "The String representation of the MediaType to output"
             },
-            "propertyName" : {
-              "type" : "string",
-              "title" : "Property Name",
-              "description" : "Name of property to use as input, instead of the message body."
-            },
             "resultType" : {
               "type" : "string",
               "title" : "Result Type",
               "description" : "Sets the class of the result type (type from output)"
             },
+            "source" : {
+              "type" : "string",
+              "title" : "Source",
+              "description" : "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body."
+            },
             "trim" : {
               "type" : "boolean",
               "title" : "Trim",
               "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
-            },
-            "variableName" : {
-              "type" : "string",
-              "title" : "Variable Name",
-              "description" : "Name of variable to use as input, instead of the message body"
             }
           }
         } ],
@@ -13067,35 +13057,25 @@
               "title" : "Expression",
               "description" : "The expression value in your chosen language syntax"
             },
-            "headerName" : {
-              "type" : "string",
-              "title" : "Header Name",
-              "description" : "Name of header to use as input, instead of the message body"
-            },
             "id" : {
               "type" : "string",
               "title" : "Id",
               "description" : "Sets the id of this node"
             },
-            "propertyName" : {
-              "type" : "string",
-              "title" : "Property Name",
-              "description" : "Name of property to use as input, instead of the message body."
-            },
             "resultType" : {
               "type" : "string",
               "title" : "Result Type",
               "description" : "Sets the class of the result type (type from output)"
             },
+            "source" : {
+              "type" : "string",
+              "title" : "Source",
+              "description" : "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body."
+            },
             "trim" : {
               "type" : "boolean",
               "title" : "Trim",
               "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
-            },
-            "variableName" : {
-              "type" : "string",
-              "title" : "Variable Name",
-              "description" : "Name of variable to use as input, instead of the message body"
             }
           }
         } ],
@@ -13235,35 +13215,25 @@
               "title" : "Expression",
               "description" : "The expression value in your chosen language syntax"
             },
-            "headerName" : {
-              "type" : "string",
-              "title" : "Header Name",
-              "description" : "Name of header to use as input, instead of the message body"
-            },
             "id" : {
               "type" : "string",
               "title" : "Id",
               "description" : "Sets the id of this node"
             },
-            "propertyName" : {
-              "type" : "string",
-              "title" : "Property Name",
-              "description" : "Name of property to use as input, instead of the message body."
-            },
             "resultType" : {
               "type" : "string",
               "title" : "Result Type",
               "description" : "Sets the class of the result type (type from output)"
             },
+            "source" : {
+              "type" : "string",
+              "title" : "Source",
+              "description" : "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body."
+            },
             "trim" : {
               "type" : "boolean",
               "title" : "Trim",
               "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
-            },
-            "variableName" : {
-              "type" : "string",
-              "title" : "Variable Name",
-              "description" : "Name of variable to use as input, instead of the message body"
             }
           }
         } ],
@@ -13293,11 +13263,6 @@
               "title" : "Expression",
               "description" : "The expression value in your chosen language syntax"
             },
-            "headerName" : {
-              "type" : "string",
-              "title" : "Header Name",
-              "description" : "Name of header to use as input, instead of the message body"
-            },
             "id" : {
               "type" : "string",
               "title" : "Id",
@@ -13309,16 +13274,16 @@
               "description" : "To configure additional options on JSONPath. Multiple values can be separated by comma.",
               "enum" : [ "DEFAULT_PATH_LEAF_TO_NULL", "ALWAYS_RETURN_LIST", "AS_PATH_LIST", "SUPPRESS_EXCEPTIONS", "REQUIRE_PROPERTIES" ]
             },
-            "propertyName" : {
-              "type" : "string",
-              "title" : "Property Name",
-              "description" : "Name of property to use as input, instead of the message body."
-            },
             "resultType" : {
               "type" : "string",
               "title" : "Result Type",
               "description" : "Sets the class of the result type (type from output)"
             },
+            "source" : {
+              "type" : "string",
+              "title" : "Source",
+              "description" : "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body."
+            },
             "suppressExceptions" : {
               "type" : "boolean",
               "title" : "Suppress Exceptions",
@@ -13334,11 +13299,6 @@
               "title" : "Unpack Array",
               "description" : "Whether to unpack a single element json-array into an object."
             },
-            "variableName" : {
-              "type" : "string",
-              "title" : "Variable Name",
-              "description" : "Name of variable to use as input, instead of the message body"
-            },
             "writeAsString" : {
               "type" : "boolean",
               "title" : "Write As String",
@@ -13653,11 +13613,6 @@
               "title" : "Group Delimiter",
               "description" : "Sets the delimiter to use when grouping. If this has not been set then token will be used as the delimiter."
             },
-            "headerName" : {
-              "type" : "string",
-              "title" : "Header Name",
-              "description" : "Name of header to use as input, instead of the message body"
-            },
             "id" : {
               "type" : "string",
               "title" : "Id",
@@ -13673,11 +13628,6 @@
               "title" : "Inherit Namespace Tag Name",
               "description" : "To inherit namespaces from a root/parent tag name when using XML You can use simple language as the tag name to support dynamic names."
             },
-            "propertyName" : {
-              "type" : "string",
-              "title" : "Property Name",
-              "description" : "Name of property to use as input, instead of the message body."
-            },
             "regex" : {
               "type" : "boolean",
               "title" : "Regex",
@@ -13693,6 +13643,11 @@
               "title" : "Skip First",
               "description" : "To skip the very first element"
             },
+            "source" : {
+              "type" : "string",
+              "title" : "Source",
+              "description" : "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body."
+            },
             "token" : {
               "type" : "string",
               "title" : "Token",
@@ -13703,11 +13658,6 @@
               "title" : "Trim",
               "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
             },
-            "variableName" : {
-              "type" : "string",
-              "title" : "Variable Name",
-              "description" : "Name of variable to use as input, instead of the message body"
-            },
             "xml" : {
               "type" : "boolean",
               "title" : "Xml",
@@ -13802,11 +13752,6 @@
               "title" : "Group",
               "description" : "To group N parts together"
             },
-            "headerName" : {
-              "type" : "string",
-              "title" : "Header Name",
-              "description" : "Name of header to use as input, instead of the message body"
-            },
             "id" : {
               "type" : "string",
               "title" : "Id",
@@ -13827,25 +13772,20 @@
                 "$ref" : "#/items/definitions/org.apache.camel.model.PropertyDefinition"
               }
             },
-            "propertyName" : {
-              "type" : "string",
-              "title" : "Property Name",
-              "description" : "Name of property to use as input, instead of the message body."
-            },
             "resultType" : {
               "type" : "string",
               "title" : "Result Type",
               "description" : "Sets the class of the result type (type from output)"
             },
+            "source" : {
+              "type" : "string",
+              "title" : "Source",
+              "description" : "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body."
+            },
             "trim" : {
               "type" : "boolean",
               "title" : "Trim",
               "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
-            },
-            "variableName" : {
-              "type" : "string",
-              "title" : "Variable Name",
-              "description" : "Name of variable to use as input, instead of the message body"
             }
           }
         } ],
@@ -13875,11 +13815,6 @@
               "title" : "Factory Ref",
               "description" : "References to a custom XPathFactory to lookup in the registry"
             },
-            "headerName" : {
-              "type" : "string",
-              "title" : "Header Name",
-              "description" : "Name of header to use as input, instead of the message body"
-            },
             "id" : {
               "type" : "string",
               "title" : "Id",
@@ -13908,11 +13843,6 @@
               "title" : "Pre Compile",
               "description" : "Whether to enable pre-compiling the xpath expression during initialization phase. pre-compile is enabled by default. This can be used to turn off, for example in cases the compilation phase is desired at the starting phase, such as if the application is ahead of time compiled (for example with camel-quarkus) which would then load the xpath factory of the built operating system, and not a JVM runtime."
             },
-            "propertyName" : {
-              "type" : "string",
-              "title" : "Property Name",
-              "description" : "Name of property to use as input, instead of the message body."
-            },
             "resultQName" : {
               "type" : "string",
               "title" : "Result QName",
@@ -13930,6 +13860,11 @@
               "title" : "Saxon",
               "description" : "Whether to use Saxon."
             },
+            "source" : {
+              "type" : "string",
+              "title" : "Source",
+              "description" : "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body."
+            },
             "threadSafety" : {
               "type" : "boolean",
               "title" : "Thread Safety",
@@ -13939,11 +13874,6 @@
               "type" : "boolean",
               "title" : "Trim",
               "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
-            },
-            "variableName" : {
-              "type" : "string",
-              "title" : "Variable Name",
-              "description" : "Name of variable to use as input, instead of the message body"
             }
           }
         } ],
@@ -13968,11 +13898,6 @@
               "title" : "Expression",
               "description" : "The expression value in your chosen language syntax"
             },
-            "headerName" : {
-              "type" : "string",
-              "title" : "Header Name",
-              "description" : "Name of header to use as input, instead of the message body"
-            },
             "id" : {
               "type" : "string",
               "title" : "Id",
@@ -13986,25 +13911,20 @@
                 "$ref" : "#/items/definitions/org.apache.camel.model.PropertyDefinition"
               }
             },
-            "propertyName" : {
-              "type" : "string",
-              "title" : "Property Name",
-              "description" : "Name of property to use as input, instead of the message body."
-            },
             "resultType" : {
               "type" : "string",
               "title" : "Result Type",
               "description" : "Sets the class of the result type (type from output)"
             },
+            "source" : {
+              "type" : "string",
+              "title" : "Source",
+              "description" : "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body."
+            },
             "trim" : {
               "type" : "boolean",
               "title" : "Trim",
               "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
-            },
-            "variableName" : {
-              "type" : "string",
-              "title" : "Variable Name",
-              "description" : "Name of variable to use as input, instead of the message body"
             }
           }
         } ],
