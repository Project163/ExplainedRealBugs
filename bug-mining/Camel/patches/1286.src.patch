diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyAbstractFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyAbstractFactory.java
index 70b91cfb635..6288957483b 100644
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyAbstractFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyAbstractFactory.java
@@ -32,12 +32,12 @@ import org.apache.commons.logging.LogFactory;
 
 /**
  * The {@link BindyAbstractFactory} implements what its common to all the formats
- * supported by camel bindy
+ * supported by Camel Bindy
  */
 public abstract class BindyAbstractFactory implements BindyFactory {
     private static final transient Log LOG = LogFactory.getLog(BindyAbstractFactory.class);
+    protected final Map<String, List<Field>> annotatedLinkFields = new LinkedHashMap<String, List<Field>>();
     protected Set<Class<?>> models;
-    protected Map<String, List<Field>> annotedLinkFields = new LinkedHashMap<String, List<Field>>();
     protected String crlf;
 
     private AnnotationModelLoader modelsLoader;
@@ -50,7 +50,7 @@ public abstract class BindyAbstractFactory implements BindyFactory {
 
         if (LOG.isDebugEnabled()) {
             for (String str : this.packageNames) {
-                LOG.debug("Package name : " + str);
+                LOG.debug("Package name: " + str);
             }
         }
 
@@ -79,7 +79,7 @@ public abstract class BindyAbstractFactory implements BindyFactory {
     /**
      * Find fields annotated in each class of the model
      */
-    public abstract void initAnnotedFields() throws Exception;
+    public abstract void initAnnotatedFields() throws Exception;
 
     public abstract void bind(List<String> data, Map<String, Object> model, int line) throws Exception;
     
@@ -91,8 +91,8 @@ public abstract class BindyAbstractFactory implements BindyFactory {
     public void link(Map<String, Object> model) throws Exception {
 
         // Iterate class by class
-        for (String link : annotedLinkFields.keySet()) {
-            List<Field> linkFields = annotedLinkFields.get(link);
+        for (String link : annotatedLinkFields.keySet()) {
+            List<Field> linkFields = annotatedLinkFields.get(link);
 
             // Iterate through Link fields list
             for (Field field : linkFields) {
@@ -147,7 +147,7 @@ public abstract class BindyAbstractFactory implements BindyFactory {
             key2Formated = getNumberFormat().format((long) key2);
             keyGenerated = String.valueOf(key1) + key2Formated;
         } else {
-            throw new IllegalArgumentException("@Section and/or @KeyValuePairDataField have not been defined !");
+            throw new IllegalArgumentException("@Section and/or @KeyValuePairDataField have not been defined!");
         }
 
         return Integer.valueOf(keyGenerated);
@@ -196,25 +196,17 @@ public abstract class BindyAbstractFactory implements BindyFactory {
     
     /**
      * Format the object into a string according to the format rue defined
-     * 
-     * @param format
-     * @param value
-     * @return String
-     * @throws Exception
      */
+    @SuppressWarnings("unchecked")
     public String formatString(Format format, Object value) throws Exception {
-
         String strValue = "";
 
         if (value != null) {
-
-            // Format field value
             try {
                 strValue = format.format(value);
             } catch (Exception e) {
-                throw new IllegalArgumentException("Formatting error detected for the value : " + value, e);
+                throw new IllegalArgumentException("Formatting error detected for the value: " + value, e);
             }
-
         }
 
         return strValue;
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java
index 85484bae5c3..55eea4971fa 100755
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java
@@ -83,14 +83,14 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
     public void initCsvModel() throws Exception {
 
         // Find annotated Datafields declared in the Model classes
-        initAnnotedFields();
+        initAnnotatedFields();
 
         // initialize Csv parameter(s)
         // separator and skip first line from @CSVrecord annotation
         initCsvRecordParameters();
     }
 
-    public void initAnnotedFields() {
+    public void initAnnotatedFields() {
 
         for (Class<?> cl : models) {
 
@@ -129,7 +129,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
             }
 
             if (!linkFields.isEmpty()) {
-                annotedLinkFields.put(cl.getName(), linkFields);
+                annotatedLinkFields.put(cl.getName(), linkFields);
             }
 
             totalFields = numberMandatoryFields + numberOptionalFields;
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyFixedLengthFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyFixedLengthFactory.java
index 015f936a578..99709e6962d 100644
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyFixedLengthFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyFixedLengthFactory.java
@@ -27,14 +27,10 @@ import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
 
-import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
 import org.apache.camel.dataformat.bindy.annotation.DataField;
 import org.apache.camel.dataformat.bindy.annotation.FixedLengthRecord;
 import org.apache.camel.dataformat.bindy.annotation.Link;
-import org.apache.camel.dataformat.bindy.annotation.OneToMany;
-import org.apache.camel.dataformat.bindy.annotation.Section;
 import org.apache.camel.dataformat.bindy.format.FormatException;
-import org.apache.camel.dataformat.bindy.util.Converter;
 import org.apache.camel.spi.PackageScanClassResolver;
 import org.apache.camel.util.ObjectHelper;
 import org.apache.commons.logging.Log;
@@ -53,7 +49,7 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
     boolean isOneToMany;
 
     private Map<Integer, DataField> dataFields = new LinkedHashMap<Integer, DataField>();
-    private Map<Integer, Field> annotedFields = new LinkedHashMap<Integer, Field>();
+    private Map<Integer, Field> annotatedFields = new LinkedHashMap<Integer, Field>();
 
     private Map<Integer, List> results;
 
@@ -77,34 +73,33 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
      * method uses to initialize the model representing the classes who will
      * bind the data. This process will scan for classes according to the
      * package name provided, check the annotated classes and fields
-     * 
-     * @throws Exception
      */
     public void initFixedLengthModel() throws Exception {
 
         // Find annotated fields declared in the Model classes
-        initAnnotedFields();
+        initAnnotatedFields();
 
         // initialize Fixed length parameter(s)
         // from @FixedLengthrecord annotation
         initFixedLengthRecordParameters();
     }
 
-    public void initAnnotedFields() {
+    public void initAnnotatedFields() {
 
         for (Class<?> cl : models) {
 
             List<Field> linkFields = new ArrayList<Field>();
 
             if (LOG.isDebugEnabled()) {
-                LOG.debug("Class retrieved : " + cl.getName());
+                LOG.debug("Class retrieved: " + cl.getName());
             }
 
             for (Field field : cl.getDeclaredFields()) {
                 DataField dataField = field.getAnnotation(DataField.class);
                 if (dataField != null) {
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Position defined in the class : " + cl.getName() + ", position : " + dataField.pos() + ", Field : " + dataField.toString());
+                        LOG.debug("Position defined in the class: " + cl.getName()
+                                + ", position: " + dataField.pos() + ", Field: " + dataField.toString());
                     }
 
                     if (dataField.required()) {
@@ -114,14 +109,14 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
                     }
 
                     dataFields.put(dataField.pos(), dataField);
-                    annotedFields.put(dataField.pos(), field);
+                    annotatedFields.put(dataField.pos(), field);
                 }
 
                 Link linkField = field.getAnnotation(Link.class);
 
                 if (linkField != null) {
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Class linked  : " + cl.getName() + ", Field" + field.toString());
+                        LOG.debug("Class linked: " + cl.getName() + ", Field: " + field.toString());
                     }
                     linkFields.add(field);
                 }
@@ -129,15 +124,15 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
             }
 
             if (!linkFields.isEmpty()) {
-                annotedLinkFields.put(cl.getName(), linkFields);
+                annotatedLinkFields.put(cl.getName(), linkFields);
             }
 
             totalFields = numberMandatoryFields + numberOptionalFields;
 
             if (LOG.isDebugEnabled()) {
-                LOG.debug("Number of optional fields : " + numberOptionalFields);
-                LOG.debug("Number of mandatory fields : " + numberMandatoryFields);
-                LOG.debug("Total : " + totalFields);
+                LOG.debug("Number of optional fields: " + numberOptionalFields);
+                LOG.debug("Number of mandatory fields: " + numberMandatoryFields);
+                LOG.debug("Total: " + totalFields);
             }
 
         }
@@ -148,8 +143,7 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
     // we don't split it as this is the case for a CSV record
     @Override
     public void bind(List<String> data, Map<String, Object> model, int line) throws Exception {
-        // TODO Auto-generated method stub
-
+        // noop
     }
 
     public void bind(String record, Map<String, Object> model, int line) throws Exception {
@@ -165,7 +159,7 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
         String pattern;
 
         // Iterate through the list of positions
-        // defined in the @DataFieldf
+        // defined in the @DataField
         // and grab the data from the line
         Collection c = dataFields.values();
         Iterator itr = c.iterator();
@@ -175,13 +169,12 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
             offset = dataField.pos();
             length = dataField.length();
 
-            ObjectHelper.notNull(offset, "Position/offset is not defined for  the  field "
-                                         + dataField.toString());
-            ObjectHelper.notNull(offset, "Length is not defined for the  field " + dataField.toString());
+            ObjectHelper.notNull(offset, "Position/offset is not defined for the field: " + dataField.toString());
+            ObjectHelper.notNull(offset, "Length is not defined for the field: " + dataField.toString());
 
             if (offset - 1 <= -1) {
-                throw new IllegalArgumentException("Offset / Position of the field " + dataField.toString()
-                                                   + " cannot be negative !");
+                throw new IllegalArgumentException("Offset/Position of the field " + dataField.toString()
+                                                   + " cannot be negative!");
             }
 
             token = record.substring(offset - 1, offset + length - 1);
@@ -196,16 +189,16 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
                 // This is not possible for mandatory fields
                 if (token.equals("")) {
                     throw new IllegalArgumentException("The mandatory field defined at the position " + pos
-                                                       + " is empty for the line : " + line);
+                                                       + " is empty for the line: " + line);
                 }
             }
             
             // Get Field to be setted
-            field = annotedFields.get(offset);
+            field = annotatedFields.get(offset);
             field.setAccessible(true);
 
             if (LOG.isDebugEnabled()) {
-                LOG.debug("Pos/Offset : " + offset + ", Data : " + token + ", Field type : " + field.getType());
+                LOG.debug("Pos/Offset: " + offset + ", Data: " + token + ", Field type: " + field.getType());
             }
             
             Format<?> format;
@@ -226,9 +219,9 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
                 try {
                     value = format.parse(token);
                 } catch (FormatException ie) {
-                    throw new IllegalArgumentException(ie.getMessage() + ", position : " + offset + ", line : " + line, ie);
+                    throw new IllegalArgumentException(ie.getMessage() + ", position: " + offset + ", line: " + line, ie);
                 } catch (Exception e) {
-                    throw new IllegalArgumentException("Parsing error detected for field defined at the position/offset : " + offset + ", line : " + line, e);
+                    throw new IllegalArgumentException("Parsing error detected for field defined at the position/offset: " + offset + ", line: " + line, e);
                 }
             } else {
                 value = getDefaultValueForPrimitive(field.getType());
@@ -241,15 +234,15 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
         }
 
         if (LOG.isDebugEnabled()) {
-            LOG.debug("Counter mandatory fields : " + counterMandatoryFields);
+            LOG.debug("Counter mandatory fields: " + counterMandatoryFields);
         }
 
         if (pos < totalFields) {
-            throw new IllegalArgumentException("Some fields are missing (optional or mandatory), line : " + line);
+            throw new IllegalArgumentException("Some fields are missing (optional or mandatory), line: " + line);
         }
 
         if (counterMandatoryFields < numberMandatoryFields) {
-            throw new IllegalArgumentException("Some mandatory fields are missing, line : " + line);
+            throw new IllegalArgumentException("Some mandatory fields are missing, line: " + line);
         }  
         
     }
@@ -266,7 +259,7 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
                 Object obj = model.get(clazz.getName());
 
                 if (LOG.isDebugEnabled()) {
-                    LOG.debug("Model object : " + obj + ", class : " + obj.getClass().getName());
+                    LOG.debug("Model object: " + obj + ", class: " + obj.getClass().getName());
                 }
 
                 if (obj != null) {
@@ -281,31 +274,24 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
 
         // Convert Map<Integer, List> into List<List>
         TreeMap<Integer, List> sortValues = new TreeMap<Integer, List>(results);
-        List<String> temp = new ArrayList<String>();
-
         for (Integer key : sortValues.keySet()) {
 
             // Get list of values
             List<String> val = sortValues.get(key);
-            String value = (String)val.get(0);
+            String value = val.get(0);
             
             buffer.append(value);
-
         }
         
         return buffer.toString();
-
     }
 
     /**
      * 
-     * Generate a table containing the data formated and sorted with their position/offset
+     * Generate a table containing the data formatted and sorted with their position/offset
      * The result is placed in the Map<Integer, List> results
-     * 
-     * @param clazz
-     * @param obj
-     * @throws Exception
      */
+
     private void generateFixedLengthPositionMap(Class clazz, Object obj) throws Exception {
 
         String result = "";
@@ -326,58 +312,74 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
                     String pattern = datafield.pattern();
                     int precision = datafield.precision();
 
+
+
                     // Create format
                     Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision);
 
                     // Get field value
                     Object value = field.get(obj);
 
+
                     result = formatString(format, value);
-                    
+
+                    // trim if enabled
+                    if (datafield.trim()) {
+                        result = result.trim();
+                    }
+
                     // Get length of the field, alignment (LEFT or RIGHT), pad
                     int fieldLength = datafield.length();
                     String align = datafield.align();
-                    char paddCharField = datafield.paddingChar();
-                    char paddChar;
+                    char padCharField = datafield.paddingChar();
+                    char padChar;
                     
                     if (fieldLength > 0) {
                        
                         StringBuilder temp = new StringBuilder();
 
-                        // Check if we must padd
+                        // Check if we must pad
                         if (result.length() < fieldLength) {
 
                             // No padding defined for the field
-                            if (paddCharField == 0) {
+                            if (padCharField == 0) {
                                 // We use the padding defined for the Record
-                                paddChar = paddingChar;
+                                padChar = paddingChar;
                             } else {
-                                paddChar = paddCharField;
+                                padChar = padCharField;
                             }
 
                             if (align.contains("R")) {
-                                temp.append(generatePaddingChars(paddChar, fieldLength, result.length()));
+                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));
                                 temp.append(result);
                             } else if (align.contains("L")) {
                                 temp.append(result);
-                                temp.append(generatePaddingChars(paddChar, fieldLength, result.length()));
+                                temp.append(generatePaddingChars(padChar, fieldLength, result.length()));
                             } else {
-                                throw new IllegalArgumentException("Alignement for the "
-                                                                       + field.getName()
-                                                                       + " must be equal to R for RIGHT or L for LEFT !");
+                                throw new IllegalArgumentException("Alignment for the field: " + field.getName()
+                                        + " must be equal to R for RIGHT or L for LEFT !");
                             }
 
                             result = temp.toString();
+                        } else if (result.length() > fieldLength) {
+                            // we are bigger than allowed
+
+                            // is clipped enabled? if so clip the field
+                            if (datafield.clip()) {
+                                result = result.substring(0, fieldLength);
+                            } else {
+                                throw new IllegalArgumentException("Length for the " + field.getName()
+                                        + " must not be larger than allowed, was: " + result.length() + ", allowed: " + fieldLength);
+                            }
                         }
 
                     } else {
-                        throw new IllegalArgumentException("Lenght of the field : "
-                                                               + field.getName()
-                                                               + " is a mandatory field and cannot be equal to zero or to be negative !");
+                        throw new IllegalArgumentException("Length of the field: " + field.getName()
+                                + " is a mandatory field and cannot be equal to zero or to be negative !");
                     }
 
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Value to be formatted : " + value + ", position : " + datafield.pos() + ", and its formated value : " + result);
+                        LOG.debug("Value to be formatted: " + value + ", position: " + datafield.pos() + ", and its formatted value: " + result);
                     }
 
                 } else {
@@ -388,14 +390,11 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
                 key = datafield.pos();
 
                 if (!results.containsKey(key)) {
-
                     List list = new LinkedList();
                     list.add(result);
                     results.put(key, list);
-
                 } else {
-
-                    List list = (LinkedList)results.get(key);
+                    List list = results.get(key);
                     list.add(result);
                 }
 
@@ -406,7 +405,6 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
     }
     
     private String generatePaddingChars(char pad, int lengthField, int lengthString) {
-
         StringBuilder buffer = new StringBuilder();
         int size = lengthField - lengthString;
 
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyKeyValuePairFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyKeyValuePairFactory.java
index 1ff6348cc85..451901e6f0a 100644
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyKeyValuePairFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyKeyValuePairFactory.java
@@ -77,14 +77,14 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
     public void initKeyValuePairModel() throws Exception {
 
         // Find annotated KeyValuePairfields declared in the Model classes
-        initAnnotedFields();
+        initAnnotatedFields();
 
         // Initialize key value pair parameter(s)
         initMessageParameters();
 
     }
 
-    public void initAnnotedFields() {
+    public void initAnnotatedFields() {
 
         for (Class<?> cl : models) {
 
@@ -111,7 +111,7 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
             }
 
             if (!linkFields.isEmpty()) {
-                annotedLinkFields.put(cl.getName(), linkFields);
+                annotatedLinkFields.put(cl.getName(), linkFields);
             }
 
         }
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/annotation/DataField.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/annotation/DataField.java
index bc132aa7f07..912eb096bff 100755
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/annotation/DataField.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/annotation/DataField.java
@@ -38,80 +38,62 @@ import java.lang.annotation.RetentionPolicy;
 public @interface DataField {
 
     /**
-     * position of the data in the record (mandatory)
-     * 
-     * @return int
+     * Position of the data in the record, must start from 1 (mandatory).
      */
     int pos();
 
     /**
-     * name of the field (optional)
-     * 
-     * @return String
+     * Name of the field (optional)
      */
     String name() default "";
 
     /**
-     * name of the header column (optional)
-     * 
-     * @return String
+     * Name of the header column (optional)
      */
     String columnName() default "";
 
     /**
-     * pattern that the formater will use to transform the data (optional)
-     * 
-     * @return String
+     * Pattern that the formatter will use to transform the data (optional)
      */
     String pattern() default "";
 
     /**
-     * length of the data block (useful for the fixedlength record) 
-     * 
-     * @return int
+     * Length of the data block if the record is set to a fixed length
      */
     int length() default 0;
     
     /**
-     * align the text to the RIGHT or to LEFT part 
-     * 
-     * @return String
+     * Align the text to the right or left. Use values <tt>R</tt> or <tt>L</tt>.
      */
     String align() default "R";
     
     /**
-     * The char to pad with.
-     * @return the char to pad with if the record is set to a fixed length;
-     * 
-     * @return char
+     * The char to pad with if the record is set to a fixed length
      */
     char paddingChar() default ' ';
 
     /**
-     * precision of the BigDecimal number to be created
-     * 
-     * @return int
+     * precision of the {@link java.math.BigDecimal} number to be created
      */
     int precision() default 0;
 
     /**
-     * Position of the field in the message generated
-     * 
-     * @return int
+     * Position of the field in the message generated (should start from 1)
      */
     int position() default 0;
 
     /**
      * Indicates if the field is mandatory
-     * 
-     * @return boolean
      */
     boolean required() default false;
 
     /**
-     * Indicates if the value should be trimed
-     * 
-     * @return boolean
+     * Indicates if the value should be trimmed
      */
     boolean trim() default false;
+
+    /**
+     * Indicates to clip data in the field if it exceeds the allowed length when using fixed length.
+     */
+    boolean clip() default false;
 }
diff --git a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fix/BindySimpleKeyValuePairWithoutSectionMarshallDslTest.java b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fix/BindySimpleKeyValuePairWithoutSectionMarshallDslTest.java
index 4b18333c3f5..0699a40d8c1 100644
--- a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fix/BindySimpleKeyValuePairWithoutSectionMarshallDslTest.java
+++ b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fix/BindySimpleKeyValuePairWithoutSectionMarshallDslTest.java
@@ -78,7 +78,7 @@ public class BindySimpleKeyValuePairWithoutSectionMarshallDslTest extends Abstra
         Exchange exch = error.getReceivedExchanges().get(0);
         Exception cause = exch.getProperty(Exchange.EXCEPTION_CAUGHT, IllegalArgumentException.class);
         assertNotNull(cause);
-        assertEquals("@Section and/or @KeyValuePairDataField have not been defined !", cause.getMessage());
+        assertEquals("@Section and/or @KeyValuePairDataField have not been defined!", cause.getMessage());
     }
 
     public List<Map<String, Object>> generateModel() {
diff --git a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fixed/marshall/simple/BindySimpleFixedLengthMarshallWithClipAndTrimTest.java b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fixed/marshall/simple/BindySimpleFixedLengthMarshallWithClipAndTrimTest.java
new file mode 100644
index 00000000000..7d9ef921d0a
--- /dev/null
+++ b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fixed/marshall/simple/BindySimpleFixedLengthMarshallWithClipAndTrimTest.java
@@ -0,0 +1,223 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.bindy.fixed.marshall.simple;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.dataformat.bindy.annotation.DataField;
+import org.apache.camel.dataformat.bindy.annotation.FixedLengthRecord;
+import org.apache.camel.dataformat.bindy.fixed.BindyFixedLengthDataFormat;
+import org.apache.camel.test.CamelTestSupport;
+import org.junit.Test;
+
+public class BindySimpleFixedLengthMarshallWithClipAndTrimTest extends CamelTestSupport {
+
+    private List<Map<String, Object>> models = new ArrayList<Map<String, Object>>();
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                BindyFixedLengthDataFormat bindy = new BindyFixedLengthDataFormat("org.apache.camel.dataformat.bindy.fixed.marshall.simple");
+
+                from("direct:start")
+                    .marshal(bindy)
+                    .to("mock:result");
+            }
+        };
+    }
+
+    @Test
+    public void testMarshallMessage() throws Exception {
+        String expected = "10A9Madame deM    ISINXD12345678BUYShare000002500.45USD01-08-2009\r\n";
+        getMockEndpoint("mock:result").expectedBodiesReceived(expected);
+
+        template.sendBody("direct:start", generateModel());
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public List<Map<String, Object>> generateModel() {
+        Map<String, Object> modelObjects = new HashMap<String, Object>();
+
+        Order order = new Order();
+        order.setOrderNr(10);
+        order.setOrderType("BUY");
+        order.setClientNr("A9  ");
+        order.setFirstName("Madame de Sol");
+        order.setLastName("M");
+        order.setAmount(new BigDecimal("2500.45"));
+        order.setInstrumentCode("ISIN");
+        order.setInstrumentNumber("XD12345678");
+        order.setInstrumentType("Share");
+        order.setCurrency("USD");
+
+        Calendar calendar = new GregorianCalendar();
+        calendar.set(2009, 7, 1);
+        order.setOrderDate(calendar.getTime());
+
+        modelObjects.put(order.getClass().getName(), order);
+
+        models.add(modelObjects);
+
+        return models;
+    }
+
+    @FixedLengthRecord(length = 65, paddingChar = ' ')
+    public static class Order {
+
+        @DataField(pos = 1, length = 2)
+        private int orderNr;
+
+        @DataField(pos = 3, length = 2, trim = true)
+        private String clientNr;
+
+        @DataField(pos = 5, length = 9, clip = true)
+        private String firstName;
+
+        @DataField(pos = 14, length = 5, align = "L")
+        private String lastName;
+
+        @DataField(pos = 19, length = 4)
+        private String instrumentCode;
+
+        @DataField(pos = 23, length = 10)
+        private String instrumentNumber;
+
+        @DataField(pos = 33, length = 3)
+        private String orderType;
+
+        @DataField(pos = 36, length = 5)
+        private String instrumentType;
+
+        @DataField(pos = 41, precision = 2, length = 12, paddingChar = '0')
+        private BigDecimal amount;
+
+        @DataField(pos = 53, length = 3)
+        private String currency;
+
+        @DataField(pos = 56, length = 10, pattern = "dd-MM-yyyy")
+        private Date orderDate;
+
+
+        public int getOrderNr() {
+            return orderNr;
+        }
+
+        public void setOrderNr(int orderNr) {
+            this.orderNr = orderNr;
+        }
+
+        public String getClientNr() {
+            return clientNr;
+        }
+
+        public void setClientNr(String clientNr) {
+            this.clientNr = clientNr;
+        }
+
+        public String getFirstName() {
+            return firstName;
+        }
+
+        public void setFirstName(String firstName) {
+            this.firstName = firstName;
+        }
+
+        public String getLastName() {
+            return lastName;
+        }
+
+        public void setLastName(String lastName) {
+            this.lastName = lastName;
+        }
+
+        public String getInstrumentCode() {
+            return instrumentCode;
+        }
+
+        public void setInstrumentCode(String instrumentCode) {
+            this.instrumentCode = instrumentCode;
+        }
+
+        public String getInstrumentNumber() {
+            return instrumentNumber;
+        }
+
+        public void setInstrumentNumber(String instrumentNumber) {
+            this.instrumentNumber = instrumentNumber;
+        }
+
+        public String getOrderType() {
+            return orderType;
+        }
+
+        public void setOrderType(String orderType) {
+            this.orderType = orderType;
+        }
+
+        public String getInstrumentType() {
+            return instrumentType;
+        }
+
+        public void setInstrumentType(String instrumentType) {
+            this.instrumentType = instrumentType;
+        }
+
+        public BigDecimal getAmount() {
+            return amount;
+        }
+
+        public void setAmount(BigDecimal amount) {
+            this.amount = amount;
+        }
+
+        public String getCurrency() {
+            return currency;
+        }
+
+        public void setCurrency(String currency) {
+            this.currency = currency;
+        }
+
+        public Date getOrderDate() {
+            return orderDate;
+        }
+
+        public void setOrderDate(Date orderDate) {
+            this.orderDate = orderDate;
+        }
+
+        @Override
+        public String toString() {
+            return "Model : " + Order.class.getName() + " : " + this.orderNr + ", " + this.orderType + ", " + String.valueOf(this.amount) + ", " + this.instrumentCode + ", "
+                    + this.instrumentNumber + ", " + this.instrumentType + ", " + this.currency + ", " + this.clientNr + ", " + this.firstName + ", " + this.lastName + ", "
+                    + String.valueOf(this.orderDate);
+        }
+    }
+
+
+}
diff --git a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fixed/marshall/simple/BindySimpleFixedLengthMarshallWithClipTest.java b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fixed/marshall/simple/BindySimpleFixedLengthMarshallWithClipTest.java
new file mode 100644
index 00000000000..906ea0b694f
--- /dev/null
+++ b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fixed/marshall/simple/BindySimpleFixedLengthMarshallWithClipTest.java
@@ -0,0 +1,223 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.bindy.fixed.marshall.simple;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.dataformat.bindy.annotation.DataField;
+import org.apache.camel.dataformat.bindy.annotation.FixedLengthRecord;
+import org.apache.camel.dataformat.bindy.fixed.BindyFixedLengthDataFormat;
+import org.apache.camel.test.CamelTestSupport;
+import org.junit.Test;
+
+public class BindySimpleFixedLengthMarshallWithClipTest extends CamelTestSupport {
+
+    private List<Map<String, Object>> models = new ArrayList<Map<String, Object>>();
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                BindyFixedLengthDataFormat bindy = new BindyFixedLengthDataFormat("org.apache.camel.dataformat.bindy.fixed.marshall.simple");
+
+                from("direct:start")
+                    .marshal(bindy)
+                    .to("mock:result");
+            }
+        };
+    }
+
+    @Test
+    public void testMarshallMessage() throws Exception {
+        String expected = "10A9Madame deM    ISINXD12345678BUYShare000002500.45USD01-08-2009\r\n";
+        getMockEndpoint("mock:result").expectedBodiesReceived(expected);
+
+        template.sendBody("direct:start", generateModel());
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public List<Map<String, Object>> generateModel() {
+        Map<String, Object> modelObjects = new HashMap<String, Object>();
+
+        Order order = new Order();
+        order.setOrderNr(10);
+        order.setOrderType("BUY");
+        order.setClientNr("A98");
+        order.setFirstName("Madame de Sol");
+        order.setLastName("M");
+        order.setAmount(new BigDecimal("2500.45"));
+        order.setInstrumentCode("ISIN");
+        order.setInstrumentNumber("XD12345678");
+        order.setInstrumentType("Share");
+        order.setCurrency("USD");
+
+        Calendar calendar = new GregorianCalendar();
+        calendar.set(2009, 7, 1);
+        order.setOrderDate(calendar.getTime());
+
+        modelObjects.put(order.getClass().getName(), order);
+
+        models.add(modelObjects);
+
+        return models;
+    }
+
+    @FixedLengthRecord(length = 65, paddingChar = ' ')
+    public static class Order {
+
+        @DataField(pos = 1, length = 2)
+        private int orderNr;
+
+        @DataField(pos = 3, length = 2, clip = true)
+        private String clientNr;
+
+        @DataField(pos = 5, length = 9, clip = true)
+        private String firstName;
+
+        @DataField(pos = 14, length = 5, align = "L")
+        private String lastName;
+
+        @DataField(pos = 19, length = 4)
+        private String instrumentCode;
+
+        @DataField(pos = 23, length = 10)
+        private String instrumentNumber;
+
+        @DataField(pos = 33, length = 3)
+        private String orderType;
+
+        @DataField(pos = 36, length = 5)
+        private String instrumentType;
+
+        @DataField(pos = 41, precision = 2, length = 12, paddingChar = '0')
+        private BigDecimal amount;
+
+        @DataField(pos = 53, length = 3)
+        private String currency;
+
+        @DataField(pos = 56, length = 10, pattern = "dd-MM-yyyy")
+        private Date orderDate;
+
+
+        public int getOrderNr() {
+            return orderNr;
+        }
+
+        public void setOrderNr(int orderNr) {
+            this.orderNr = orderNr;
+        }
+
+        public String getClientNr() {
+            return clientNr;
+        }
+
+        public void setClientNr(String clientNr) {
+            this.clientNr = clientNr;
+        }
+
+        public String getFirstName() {
+            return firstName;
+        }
+
+        public void setFirstName(String firstName) {
+            this.firstName = firstName;
+        }
+
+        public String getLastName() {
+            return lastName;
+        }
+
+        public void setLastName(String lastName) {
+            this.lastName = lastName;
+        }
+
+        public String getInstrumentCode() {
+            return instrumentCode;
+        }
+
+        public void setInstrumentCode(String instrumentCode) {
+            this.instrumentCode = instrumentCode;
+        }
+
+        public String getInstrumentNumber() {
+            return instrumentNumber;
+        }
+
+        public void setInstrumentNumber(String instrumentNumber) {
+            this.instrumentNumber = instrumentNumber;
+        }
+
+        public String getOrderType() {
+            return orderType;
+        }
+
+        public void setOrderType(String orderType) {
+            this.orderType = orderType;
+        }
+
+        public String getInstrumentType() {
+            return instrumentType;
+        }
+
+        public void setInstrumentType(String instrumentType) {
+            this.instrumentType = instrumentType;
+        }
+
+        public BigDecimal getAmount() {
+            return amount;
+        }
+
+        public void setAmount(BigDecimal amount) {
+            this.amount = amount;
+        }
+
+        public String getCurrency() {
+            return currency;
+        }
+
+        public void setCurrency(String currency) {
+            this.currency = currency;
+        }
+
+        public Date getOrderDate() {
+            return orderDate;
+        }
+
+        public void setOrderDate(Date orderDate) {
+            this.orderDate = orderDate;
+        }
+
+        @Override
+        public String toString() {
+            return "Model : " + Order.class.getName() + " : " + this.orderNr + ", " + this.orderType + ", " + String.valueOf(this.amount) + ", " + this.instrumentCode + ", "
+                    + this.instrumentNumber + ", " + this.instrumentType + ", " + this.currency + ", " + this.clientNr + ", " + this.firstName + ", " + this.lastName + ", "
+                    + String.valueOf(this.orderDate);
+        }
+    }
+
+
+}
diff --git a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fixed/marshall/simple/BindySimpleFixedLengthMarshallWithNoClipTest.java b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fixed/marshall/simple/BindySimpleFixedLengthMarshallWithNoClipTest.java
new file mode 100644
index 00000000000..4729cf7cf00
--- /dev/null
+++ b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fixed/marshall/simple/BindySimpleFixedLengthMarshallWithNoClipTest.java
@@ -0,0 +1,225 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.bindy.fixed.marshall.simple;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.CamelExecutionException;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.dataformat.bindy.annotation.DataField;
+import org.apache.camel.dataformat.bindy.annotation.FixedLengthRecord;
+import org.apache.camel.dataformat.bindy.fixed.BindyFixedLengthDataFormat;
+import org.apache.camel.test.CamelTestSupport;
+import org.junit.Test;
+
+public class BindySimpleFixedLengthMarshallWithNoClipTest extends CamelTestSupport {
+
+    private List<Map<String, Object>> models = new ArrayList<Map<String, Object>>();
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                BindyFixedLengthDataFormat bindy = new BindyFixedLengthDataFormat("org.apache.camel.dataformat.bindy.fixed.marshall.simple");
+
+                from("direct:start")
+                    .marshal(bindy)
+                    .to("mock:result");
+            }
+        };
+    }
+
+    @Test
+    public void testMarshallMessage() throws Exception {
+        try {
+            template.sendBody("direct:start", generateModel());
+            fail("Should have thrown an exception");
+        } catch (CamelExecutionException e) {
+            IllegalArgumentException cause = assertIsInstanceOf(IllegalArgumentException.class, e.getCause());
+            assertEquals("Length for the firstName must not be larger than allowed, was: 13, allowed: 9", cause.getMessage());
+        }
+    }
+
+    public List<Map<String, Object>> generateModel() {
+        Map<String, Object> modelObjects = new HashMap<String, Object>();
+
+        Order order = new Order();
+        order.setOrderNr(10);
+        order.setOrderType("BUY");
+        order.setClientNr("A98");
+        order.setFirstName("Madame de Sol");
+        order.setLastName("M");
+        order.setAmount(new BigDecimal("2500.45"));
+        order.setInstrumentCode("ISIN");
+        order.setInstrumentNumber("XD12345678");
+        order.setInstrumentType("Share");
+        order.setCurrency("USD");
+
+        Calendar calendar = new GregorianCalendar();
+        calendar.set(2009, 7, 1);
+        order.setOrderDate(calendar.getTime());
+
+        modelObjects.put(order.getClass().getName(), order);
+
+        models.add(modelObjects);
+
+        return models;
+    }
+
+    @FixedLengthRecord(length = 65, paddingChar = ' ')
+    public static class Order {
+
+        @DataField(pos = 1, length = 2)
+        private int orderNr;
+
+        @DataField(pos = 3, length = 2, clip = true)
+        private String clientNr;
+
+        @DataField(pos = 5, length = 9)
+        private String firstName;
+
+        @DataField(pos = 14, length = 5, align = "L")
+        private String lastName;
+
+        @DataField(pos = 19, length = 4)
+        private String instrumentCode;
+
+        @DataField(pos = 23, length = 10)
+        private String instrumentNumber;
+
+        @DataField(pos = 33, length = 3)
+        private String orderType;
+
+        @DataField(pos = 36, length = 5)
+        private String instrumentType;
+
+        @DataField(pos = 41, precision = 2, length = 12, paddingChar = '0')
+        private BigDecimal amount;
+
+        @DataField(pos = 53, length = 3)
+        private String currency;
+
+        @DataField(pos = 56, length = 10, pattern = "dd-MM-yyyy")
+        private Date orderDate;
+
+
+        public int getOrderNr() {
+            return orderNr;
+        }
+
+        public void setOrderNr(int orderNr) {
+            this.orderNr = orderNr;
+        }
+
+        public String getClientNr() {
+            return clientNr;
+        }
+
+        public void setClientNr(String clientNr) {
+            this.clientNr = clientNr;
+        }
+
+        public String getFirstName() {
+            return firstName;
+        }
+
+        public void setFirstName(String firstName) {
+            this.firstName = firstName;
+        }
+
+        public String getLastName() {
+            return lastName;
+        }
+
+        public void setLastName(String lastName) {
+            this.lastName = lastName;
+        }
+
+        public String getInstrumentCode() {
+            return instrumentCode;
+        }
+
+        public void setInstrumentCode(String instrumentCode) {
+            this.instrumentCode = instrumentCode;
+        }
+
+        public String getInstrumentNumber() {
+            return instrumentNumber;
+        }
+
+        public void setInstrumentNumber(String instrumentNumber) {
+            this.instrumentNumber = instrumentNumber;
+        }
+
+        public String getOrderType() {
+            return orderType;
+        }
+
+        public void setOrderType(String orderType) {
+            this.orderType = orderType;
+        }
+
+        public String getInstrumentType() {
+            return instrumentType;
+        }
+
+        public void setInstrumentType(String instrumentType) {
+            this.instrumentType = instrumentType;
+        }
+
+        public BigDecimal getAmount() {
+            return amount;
+        }
+
+        public void setAmount(BigDecimal amount) {
+            this.amount = amount;
+        }
+
+        public String getCurrency() {
+            return currency;
+        }
+
+        public void setCurrency(String currency) {
+            this.currency = currency;
+        }
+
+        public Date getOrderDate() {
+            return orderDate;
+        }
+
+        public void setOrderDate(Date orderDate) {
+            this.orderDate = orderDate;
+        }
+
+        @Override
+        public String toString() {
+            return "Model : " + Order.class.getName() + " : " + this.orderNr + ", " + this.orderType + ", " + String.valueOf(this.amount) + ", " + this.instrumentCode + ", "
+                    + this.instrumentNumber + ", " + this.instrumentType + ", " + this.currency + ", " + this.clientNr + ", " + this.firstName + ", " + this.lastName + ", "
+                    + String.valueOf(this.orderDate);
+        }
+    }
+
+
+}
