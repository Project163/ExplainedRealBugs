diff --git a/components/camel-git/src/generated/java/org/apache/camel/component/git/GitEndpointConfigurer.java b/components/camel-git/src/generated/java/org/apache/camel/component/git/GitEndpointConfigurer.java
index 0eba38b2049..422aa5674bc 100644
--- a/components/camel-git/src/generated/java/org/apache/camel/component/git/GitEndpointConfigurer.java
+++ b/components/camel-git/src/generated/java/org/apache/camel/component/git/GitEndpointConfigurer.java
@@ -41,6 +41,8 @@ public class GitEndpointConfigurer extends PropertyConfigurerSupport implements
         case "remotePath": target.setRemotePath(property(camelContext, java.lang.String.class, value)); return true;
         case "tagname":
         case "tagName": target.setTagName(property(camelContext, java.lang.String.class, value)); return true;
+        case "targetbranchname":
+        case "targetBranchName": target.setTargetBranchName(property(camelContext, java.lang.String.class, value)); return true;
         case "type": target.setType(property(camelContext, org.apache.camel.component.git.consumer.GitType.class, value)); return true;
         case "username": target.setUsername(property(camelContext, java.lang.String.class, value)); return true;
         default: return false;
@@ -70,6 +72,8 @@ public class GitEndpointConfigurer extends PropertyConfigurerSupport implements
         case "remotePath": return java.lang.String.class;
         case "tagname":
         case "tagName": return java.lang.String.class;
+        case "targetbranchname":
+        case "targetBranchName": return java.lang.String.class;
         case "type": return org.apache.camel.component.git.consumer.GitType.class;
         case "username": return java.lang.String.class;
         default: return null;
@@ -100,6 +104,8 @@ public class GitEndpointConfigurer extends PropertyConfigurerSupport implements
         case "remotePath": return target.getRemotePath();
         case "tagname":
         case "tagName": return target.getTagName();
+        case "targetbranchname":
+        case "targetBranchName": return target.getTargetBranchName();
         case "type": return target.getType();
         case "username": return target.getUsername();
         default: return null;
diff --git a/components/camel-git/src/generated/java/org/apache/camel/component/git/GitEndpointUriFactory.java b/components/camel-git/src/generated/java/org/apache/camel/component/git/GitEndpointUriFactory.java
index a07ecd08a48..0dd639fff86 100644
--- a/components/camel-git/src/generated/java/org/apache/camel/component/git/GitEndpointUriFactory.java
+++ b/components/camel-git/src/generated/java/org/apache/camel/component/git/GitEndpointUriFactory.java
@@ -21,7 +21,7 @@ public class GitEndpointUriFactory extends org.apache.camel.support.component.En
     private static final Set<String> SECRET_PROPERTY_NAMES;
     private static final Set<String> MULTI_VALUE_PREFIXES;
     static {
-        Set<String> props = new HashSet<>(14);
+        Set<String> props = new HashSet<>(15);
         props.add("allowEmpty");
         props.add("branchName");
         props.add("bridgeErrorHandler");
@@ -34,6 +34,7 @@ public class GitEndpointUriFactory extends org.apache.camel.support.component.En
         props.add("remoteName");
         props.add("remotePath");
         props.add("tagName");
+        props.add("targetBranchName");
         props.add("type");
         props.add("username");
         PROPERTY_NAMES = Collections.unmodifiableSet(props);
diff --git a/components/camel-git/src/generated/resources/org/apache/camel/component/git/git.json b/components/camel-git/src/generated/resources/org/apache/camel/component/git/git.json
index f7fdd7ffc00..7dcb8c41c80 100644
--- a/components/camel-git/src/generated/resources/org/apache/camel/component/git/git.json
+++ b/components/camel-git/src/generated/resources/org/apache/camel/component/git/git.json
@@ -53,6 +53,7 @@
     "remoteName": { "kind": "parameter", "displayName": "Remote Name", "group": "producer", "label": "producer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The remote repository name to use in particular operation like pull" },
     "remotePath": { "kind": "parameter", "displayName": "Remote Path", "group": "producer", "label": "producer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The remote repository path" },
     "tagName": { "kind": "parameter", "displayName": "Tag Name", "group": "producer", "label": "producer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "The tag name to work on" },
+    "targetBranchName": { "kind": "parameter", "displayName": "Target Branch Name", "group": "producer", "label": "producer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "master", "description": "Name of target branch in merge operation. If not supplied will try to use init.defaultBranch git configs. If not configured will use default value" },
     "username": { "kind": "parameter", "displayName": "Username", "group": "producer", "label": "producer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "Remote repository username" },
     "lazyStartProducer": { "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." }
   }
diff --git a/components/camel-git/src/main/java/org/apache/camel/component/git/GitEndpoint.java b/components/camel-git/src/main/java/org/apache/camel/component/git/GitEndpoint.java
index bccd4ce1fd4..8537f2f3071 100644
--- a/components/camel-git/src/main/java/org/apache/camel/component/git/GitEndpoint.java
+++ b/components/camel-git/src/main/java/org/apache/camel/component/git/GitEndpoint.java
@@ -45,6 +45,11 @@ public class GitEndpoint extends DefaultEndpoint {
     @UriParam
     private String branchName;
 
+    @UriParam(label = "producer",
+              description = "Name of target branch in merge operation. If not supplied will try to use init.defaultBranch git configs. If not configured will use default value",
+              defaultValue = "master")
+    private String targetBranchName;
+
     @UriParam(label = "producer")
     private String tagName;
 
@@ -203,4 +208,15 @@ public class GitEndpoint extends DefaultEndpoint {
     public void setAllowEmpty(boolean allowEmpty) {
         this.allowEmpty = allowEmpty;
     }
+
+    /**
+     * The branch name to merge
+     */
+    public String getTargetBranchName() {
+        return this.targetBranchName;
+    }
+
+    public void setTargetBranchName(String targetBranchName) {
+        this.targetBranchName = targetBranchName;
+    }
 }
diff --git a/components/camel-git/src/main/java/org/apache/camel/component/git/producer/GitProducer.java b/components/camel-git/src/main/java/org/apache/camel/component/git/producer/GitProducer.java
index 083e06ec8e7..51267dc1d47 100644
--- a/components/camel-git/src/main/java/org/apache/camel/component/git/producer/GitProducer.java
+++ b/components/camel-git/src/main/java/org/apache/camel/component/git/producer/GitProducer.java
@@ -38,6 +38,8 @@ import org.eclipse.jgit.api.PullResult;
 import org.eclipse.jgit.api.RemoteAddCommand;
 import org.eclipse.jgit.api.Status;
 import org.eclipse.jgit.api.errors.GitAPIException;
+import org.eclipse.jgit.errors.ConfigInvalidException;
+import org.eclipse.jgit.lib.ConfigConstants;
 import org.eclipse.jgit.lib.Constants;
 import org.eclipse.jgit.lib.ObjectId;
 import org.eclipse.jgit.lib.Ref;
@@ -49,6 +51,7 @@ import org.eclipse.jgit.transport.PushResult;
 import org.eclipse.jgit.transport.RemoteConfig;
 import org.eclipse.jgit.transport.URIish;
 import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
+import org.eclipse.jgit.util.SystemReader;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -500,7 +503,7 @@ public class GitProducer extends DefaultProducer {
         updateExchange(exchange, result);
     }
 
-    protected void doMerge(Exchange exchange, String operation) throws GitAPIException, IOException {
+    protected void doMerge(Exchange exchange, String operation) throws ConfigInvalidException, GitAPIException, IOException {
         MergeResult result = null;
         ObjectId mergeBase;
         try {
@@ -508,15 +511,26 @@ public class GitProducer extends DefaultProducer {
                 throw new IllegalArgumentException("Branch name must be specified to execute " + operation);
             }
             mergeBase = git.getRepository().resolve(endpoint.getBranchName());
-            git.checkout().setName("master").call();
+            git.checkout().setName(defineTargetBranchName()).call();
             result = git.merge().include(mergeBase).setFastForward(FastForwardMode.FF).setCommit(true).call();
-        } catch (GitAPIException | IOException e) {
+        } catch (ConfigInvalidException | GitAPIException | IOException e) {
             LOG.error("There was an error in Git {} operation", operation);
             throw e;
         }
         updateExchange(exchange, result);
     }
 
+    private String defineTargetBranchName() throws ConfigInvalidException, IOException {
+        if (ObjectHelper.isNotEmpty(endpoint.getTargetBranchName())) {
+            return endpoint.getTargetBranchName();
+        }
+
+        String defaultBranch = SystemReader.getInstance().getUserConfig().getString(ConfigConstants.CONFIG_INIT_SECTION, null,
+                ConfigConstants.CONFIG_KEY_DEFAULT_BRANCH);
+
+        return ObjectHelper.isNotEmpty(defaultBranch) ? defaultBranch : "master";
+    }
+
     protected void doCreateTag(String operation) throws GitAPIException {
         if (ObjectHelper.isEmpty(endpoint.getTagName())) {
             throw new IllegalArgumentException("Tag Name must be specified to execute " + operation);
diff --git a/components/camel-git/src/test/java/org/apache/camel/component/git/GitTestSupport.java b/components/camel-git/src/test/java/org/apache/camel/component/git/GitTestSupport.java
index 70df54bc373..49a9eb86b21 100644
--- a/components/camel-git/src/test/java/org/apache/camel/component/git/GitTestSupport.java
+++ b/components/camel-git/src/test/java/org/apache/camel/component/git/GitTestSupport.java
@@ -47,8 +47,12 @@ public class GitTestSupport extends CamelTestSupport {
 
     public final String commitMessageBranch = "Test commit on a branch";
 
+    public final String commitMessageMergeBranch = "Test merge on a target branch";
+
     public final String branchTest = "testBranch";
 
+    public final String targetBranchTest = "targetTestBranch";
+
     public final String tagTest = "testTag";
 
     public final String remoteUriTest = "https://github.com/oscerd/json-webserver-example.git";
diff --git a/components/camel-git/src/test/java/org/apache/camel/component/git/producer/GitProducerTest.java b/components/camel-git/src/test/java/org/apache/camel/component/git/producer/GitProducerTest.java
index 5f9bc6c1356..50af2b91f20 100644
--- a/components/camel-git/src/test/java/org/apache/camel/component/git/producer/GitProducerTest.java
+++ b/components/camel-git/src/test/java/org/apache/camel/component/git/producer/GitProducerTest.java
@@ -17,6 +17,7 @@
 package org.apache.camel.component.git.producer;
 
 import java.io.File;
+import java.nio.file.Files;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -885,6 +886,37 @@ public class GitProducerTest extends GitTestSupport {
         git.close();
     }
 
+    @Test
+    public void mergeTargetBranchTest() throws Exception {
+        // Init
+        Git git = getGitTestRepository();
+        File gitDir = new File(gitLocalRepo, ".git");
+        assertEquals(true, gitDir.exists());
+        File fileToAdd = new File(gitLocalRepo, filenameToAdd);
+        fileToAdd.createNewFile();
+        git.add().addFilepattern(filenameToAdd).call();
+        Status status = git.status().call();
+        assertTrue(status.getAdded().contains(filenameToAdd));
+        git.commit().setMessage(commitMessage).call();
+
+        template.sendBody("direct:create-targetBranch", ""); //create target branch
+        template.sendBody("direct:checkout", ""); //checkout test branch
+
+        //add file to test branch and commit
+        fileToAdd = new File(gitLocalRepo, filenameBranchToAdd);
+        fileToAdd.createNewFile();
+        git.add().addFilepattern(filenameBranchToAdd).call();
+        status = git.status().call();
+        assertTrue(status.getAdded().contains(filenameBranchToAdd));
+        git.commit().setMessage(commitMessageMergeBranch).call();
+
+        //merge test branch into target branch
+        MergeResult result = template.requestBody("direct:merge-targetBranch", "", MergeResult.class);
+        assertEquals("Fast-forward", result.getMergeStatus().toString());
+        assertTrue(Files.exists(fileToAdd.toPath())); //file exists in target branch, so merge was successful
+        git.close();
+    }
+
     @Override
     protected RouteBuilder createRouteBuilder() {
         return new RouteBuilder() {
@@ -934,6 +966,10 @@ public class GitProducerTest extends GitTestSupport {
                 from("direct:remoteList").to("git://" + gitLocalRepo + "?operation=remoteList");
                 from("direct:merge").to("git://" + gitLocalRepo + "?operation=merge&branchName=" + branchTest);
                 from("direct:show-tags").to("git://" + gitLocalRepo + "?operation=showTags");
+                from("direct:create-targetBranch")
+                        .to("git://" + gitLocalRepo + "?operation=createBranch&branchName=" + targetBranchTest);
+                from("direct:merge-targetBranch").to("git://" + gitLocalRepo + "?operation=merge&targetBranchName="
+                                                     + targetBranchTest + "&branchName=" + branchTest);
             }
         };
     }
