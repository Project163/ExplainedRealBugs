diff --git a/docs/user-manual/modules/ROOT/pages/index.adoc b/docs/user-manual/modules/ROOT/pages/index.adoc
index 7660a808559..5468a0fe551 100644
--- a/docs/user-manual/modules/ROOT/pages/index.adoc
+++ b/docs/user-manual/modules/ROOT/pages/index.adoc
@@ -95,7 +95,6 @@ camel routes without them knowing
 * xref:route-builder.adoc[RouteBuilder]
 * xref:route-policy.adoc[RoutePolicy]
 * xref:routes.adoc[Routes]
-* xref:servicepool.adoc[ServicePool]
 * xref:stream-caching.adoc[Stream caching]
 * xref:threading-model.adoc[Threading Model]
 * xref:tracer.adoc[Tracer]
diff --git a/docs/user-manual/modules/ROOT/pages/servicepool.adoc b/docs/user-manual/modules/ROOT/pages/servicepool.adoc
deleted file mode 100644
index 5fbb9aa6430..00000000000
--- a/docs/user-manual/modules/ROOT/pages/servicepool.adoc
+++ /dev/null
@@ -1,55 +0,0 @@
-[[ServicePool-ServicePool]]
-= Service Pool
-
-*Since Camel 2.0*
-
-Camel supports pluggable pools for services. At this time of write we
-have pools for:
-
-* Producer
-
-The default producer service pool is
-`org.apache.camel.impl.DefaultProducerServicePool` and is used by
-default in Camel for pooling Producer.
-
-The need for pooling Producer is only apparent in some
-xref:components::index.adoc[Components] in Camel to support thread safe
-producers and support concurrency. And using pooling we can improve
-performance as we do not have the overhead of creating, starting and
-stopping the Producer at each invocation. So where is it needed then?
-Well these components uses pooled producers:
-
-* xref:components::ftp-component.adoc[FTP]
-* xref:components::mina-component.adoc[Mina]
-
-[[ServicePool-Usage]]
-== Usage
-
-By default Camel uses a shared
-`org.apache.camel.impl.DefaultProducerServicePool` provided by
-`CamelContext`. This default pool will pool up till 100 producers per
-xref:endpoint.adoc[Endpoint]. So if you have 6 endpoints there can be up
-till 6 x 100 in total in the pool, where each distinct
-xref:endpoint.adoc[Endpoint] have a limit of up till 100 producers.
-
-[[ServicePool-Pluggableproducerpooling]]
-== Pluggable producer pooling
-
-Camel supports using a 3rd part pool implementation. What is needed is
-to implement an adapter by implementing the
-`org.apache.camel.spi.ServicePool` interface and define the generic as
-`Endpoint` as the key and `Producer` as the service.
-
-Then set your custom pooling on the `CamelContext` with the
-`setProducerServicePool` method.
-
-[[ServicePool-Developingpooleableproducers]]
-== Developing pooleable producers
-
-The producer service pool identify a producer as being pool capable if
-the producer implements the marker interface
-`org.apache.camel.ServicePoolAware`. +
- As the producer will be pooled and thus long lived, your producer
-should be able to automatic safely recover lost connection. Usually you
-implement logic that re connects if needed.
-
diff --git a/docs/user-manual/modules/ROOT/pages/threading-model.adoc b/docs/user-manual/modules/ROOT/pages/threading-model.adoc
index 8c2d1ce8b23..6c5e5cb0ccb 100644
--- a/docs/user-manual/modules/ROOT/pages/threading-model.adoc
+++ b/docs/user-manual/modules/ROOT/pages/threading-model.adoc
@@ -12,7 +12,6 @@ Camel leverages thread pools in the following places:
 concurrency
 * xref:components::seda-component.adoc[SEDA] component for asynchronous connectivity
 * xref:async.adoc[Threads DSL] in the Camel route
-* xref:servicepool.adoc[ServicePool] for pooling services
 * And some component provide thread pools by nature such as
 xref:components::jms-component.adoc[JMS], xref:components::jetty-component.adoc[Jetty]
 
@@ -22,7 +21,7 @@ xref:components::jms-component.adoc[JMS], xref:components::jetty-component.adoc[
 By default when a thread pool is to be created then its based on the
 default thread pool profile which is:
 
-[source,java]
+[source,xml]
 --------------------------------------------------------------------------------------------------------
     <threadPoolProfile id="defaultThreadPoolProfile" defaultProfile="true"
                        poolSize="10" maxPoolSize="20" maxQueueSize="1000" allowCoreThreadTimeOut="false"
@@ -57,7 +56,7 @@ Suppose you want to use a custom thread pool profile for a Multicast EIP
 pattern in a Camel route you can do it using the `executorServiceRef`
 attribute as shown:
 
-[source,java]
+[source,xml]
 ---------------------------------------------------------------------------
 <camelContext ...>
     ...
@@ -168,7 +167,7 @@ In Camel 2.11 onwards its easier to set the thread name pattern on the
 CamelContext using the threadNamePattern attribute in the XML files as
 shown below:
 
-[source,java]
+[source,xml]
 --------------------------------------------------------------------------------------------------------------
   <camelContext xmlns="http://camel.apache.org/schema/spring" threadNamePattern="Riding the thread #counter#">
     <route>
