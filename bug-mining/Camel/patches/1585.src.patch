diff --git a/camel-core/src/main/java/org/apache/camel/model/ResequenceDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ResequenceDefinition.java
index 3b16960f6f6..b34d341e3ff 100644
--- a/camel-core/src/main/java/org/apache/camel/model/ResequenceDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/ResequenceDefinition.java
@@ -137,10 +137,14 @@ public class ResequenceDefinition extends ProcessorDefinition<ResequenceDefiniti
      * @return the builder
      */
     public ResequenceDefinition timeout(long timeout) {
-        if (batchConfig != null) {
-            batchConfig.setBatchTimeout(timeout);
-        } else {
+        if (streamConfig != null) {
             streamConfig.setTimeout(timeout);
+        } else {
+            // initialize batch mode as its default mode
+            if (batchConfig == null) {
+                batch();
+            }
+            batchConfig.setBatchTimeout(timeout);
         }
         return this;
     }
@@ -213,6 +217,24 @@ public class ResequenceDefinition extends ProcessorDefinition<ResequenceDefiniti
         return this;
     }
 
+    /**
+     * If an incoming {@link org.apache.camel.Exchange} is invalid, then it will be ignored.
+     *
+     * @return builder
+     */
+    public ResequenceDefinition ignoreInvalidExchanges() {
+        if (streamConfig != null) {
+            streamConfig.setIgnoreInvalidExchanges(true);
+        } else {
+            // initialize batch mode as its default mode
+            if (batchConfig == null) {
+                batch();
+            }
+            batchConfig.setIgnoreInvalidExchanges(true);
+        }
+        return this;
+    }
+
     /**
      * Sets the comparator to use for stream resequencer
      *
@@ -318,6 +340,9 @@ public class ResequenceDefinition extends ProcessorDefinition<ResequenceDefiniti
                 config.isAllowDuplicates(), config.isReverse());
         resequencer.setBatchSize(config.getBatchSize());
         resequencer.setBatchTimeout(config.getBatchTimeout());
+        if (config.getIgnoreInvalidExchanges() != null) {
+            resequencer.setIgnoreInvalidExchanges(config.getIgnoreInvalidExchanges());
+        }
         return resequencer;
     }
 
@@ -343,6 +368,9 @@ public class ResequenceDefinition extends ProcessorDefinition<ResequenceDefiniti
         StreamResequencer resequencer = new StreamResequencer(routeContext.getCamelContext(), processor, comparator);
         resequencer.setTimeout(config.getTimeout());
         resequencer.setCapacity(config.getCapacity());
+        if (config.getIgnoreInvalidExchanges() != null) {
+            resequencer.setIgnoreInvalidExchanges(config.getIgnoreInvalidExchanges());
+        }
         return resequencer;
     }
 
diff --git a/camel-core/src/main/java/org/apache/camel/model/config/BatchResequencerConfig.java b/camel-core/src/main/java/org/apache/camel/model/config/BatchResequencerConfig.java
index e2cc02aa557..20db69ddf2e 100644
--- a/camel-core/src/main/java/org/apache/camel/model/config/BatchResequencerConfig.java
+++ b/camel-core/src/main/java/org/apache/camel/model/config/BatchResequencerConfig.java
@@ -36,6 +36,8 @@ public class BatchResequencerConfig extends ResequencerConfig {
     private Boolean allowDuplicates;
     @XmlAttribute
     private Boolean reverse;
+    @XmlAttribute
+    private Boolean ignoreInvalidExchanges;
 
     /**
      * Creates a new {@link BatchResequencerConfig} instance using default
@@ -108,4 +110,12 @@ public class BatchResequencerConfig extends ResequencerConfig {
     public void setReverse(Boolean reverse) {
         this.reverse = reverse;
     }
+
+    public Boolean getIgnoreInvalidExchanges() {
+        return ignoreInvalidExchanges;
+    }
+
+    public void setIgnoreInvalidExchanges(Boolean ignoreInvalidExchanges) {
+        this.ignoreInvalidExchanges = ignoreInvalidExchanges;
+    }
 }
diff --git a/camel-core/src/main/java/org/apache/camel/model/config/StreamResequencerConfig.java b/camel-core/src/main/java/org/apache/camel/model/config/StreamResequencerConfig.java
index 2087726fbfd..c2b978257b3 100644
--- a/camel-core/src/main/java/org/apache/camel/model/config/StreamResequencerConfig.java
+++ b/camel-core/src/main/java/org/apache/camel/model/config/StreamResequencerConfig.java
@@ -37,6 +37,8 @@ public class StreamResequencerConfig extends ResequencerConfig {
     private Integer capacity;
     @XmlAttribute
     private Long timeout;
+    @XmlAttribute
+    private Boolean ignoreInvalidExchanges;
     @XmlTransient
     private ExpressionResultComparator comparator;
 
@@ -106,6 +108,14 @@ public class StreamResequencerConfig extends ResequencerConfig {
         this.timeout = timeout;
     }
 
+    public Boolean getIgnoreInvalidExchanges() {
+        return ignoreInvalidExchanges;
+    }
+
+    public void setIgnoreInvalidExchanges(Boolean ignoreInvalidExchanges) {
+        this.ignoreInvalidExchanges = ignoreInvalidExchanges;
+    }
+
     public ExpressionResultComparator getComparator() {
         return comparator;
     }
diff --git a/camel-core/src/main/java/org/apache/camel/processor/BatchProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/BatchProcessor.java
index 873180fc439..1ffe3a90396 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/BatchProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/BatchProcessor.java
@@ -29,7 +29,9 @@ import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
 import org.apache.camel.CamelContext;
+import org.apache.camel.CamelExchangeException;
 import org.apache.camel.Exchange;
+import org.apache.camel.Expression;
 import org.apache.camel.Navigate;
 import org.apache.camel.Predicate;
 import org.apache.camel.Processor;
@@ -60,7 +62,9 @@ public class BatchProcessor extends ServiceSupport implements Processor, Navigat
     private int outBatchSize;
     private boolean groupExchanges;
     private boolean batchConsumer;
+    private boolean ignoreInvalidExchanges;
     private Predicate completionPredicate;
+    private Expression expression;
 
     private final CamelContext camelContext;
     private final Processor processor;
@@ -69,15 +73,17 @@ public class BatchProcessor extends ServiceSupport implements Processor, Navigat
 
     private final BatchSender sender;
 
-    public BatchProcessor(CamelContext camelContext, Processor processor, Collection<Exchange> collection) {
+    public BatchProcessor(CamelContext camelContext, Processor processor, Collection<Exchange> collection, Expression expression) {
         ObjectHelper.notNull(camelContext, "camelContext");
         ObjectHelper.notNull(processor, "processor");
         ObjectHelper.notNull(collection, "collection");
+        ObjectHelper.notNull(expression, "expression");
 
         // wrap processor in UnitOfWork so what we send out of the batch runs in a UoW
         this.camelContext = camelContext;
         this.processor = new UnitOfWorkProcessor(processor);
         this.collection = collection;
+        this.expression = expression;
         this.sender = new BatchSender();
     }
 
@@ -159,6 +165,14 @@ public class BatchProcessor extends ServiceSupport implements Processor, Navigat
         this.batchConsumer = batchConsumer;
     }
 
+    public boolean isIgnoreInvalidExchanges() {
+        return ignoreInvalidExchanges;
+    }
+
+    public void setIgnoreInvalidExchanges(boolean ignoreInvalidExchanges) {
+        this.ignoreInvalidExchanges = ignoreInvalidExchanges;
+    }
+
     public Predicate getCompletionPredicate() {
         return completionPredicate;
     }
@@ -242,9 +256,36 @@ public class BatchProcessor extends ServiceSupport implements Processor, Navigat
             }
         }
 
+        // validate that the exchange can be used
+        if (!isValid(exchange)) {
+            if (isIgnoreInvalidExchanges()) {
+                LOG.debug("Invalid Exchange. This Exchange will be ignored: {}", exchange);
+                return;
+            } else {
+                throw new CamelExchangeException("Exchange is not valid to be used by the BatchProcessor", exchange);
+            }
+        }
+
+        // exchange is valid so enqueue the exchange
         sender.enqueueExchange(exchange);
     }
 
+    /**
+     * Is the given exchange valid to be used.
+     *
+     * @param exchange the given exchange
+     * @return <tt>true</tt> if valid, <tt>false</tt> otherwise
+     */
+    private boolean isValid(Exchange exchange) {
+        Object result = null;
+        try {
+            result = expression.evaluate(exchange, Object.class);
+        } catch (Exception e) {
+            // ignore
+        }
+        return result != null;
+    }
+
     /**
      * Sender thread for queued-up exchanges.
      */
diff --git a/camel-core/src/main/java/org/apache/camel/processor/Resequencer.java b/camel-core/src/main/java/org/apache/camel/processor/Resequencer.java
index da8d689c3c5..e73377d4dbd 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/Resequencer.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/Resequencer.java
@@ -40,16 +40,16 @@ public class Resequencer extends BatchProcessor implements Traceable {
     // TODO: Rework to avoid using BatchProcessor
 
     public Resequencer(CamelContext camelContext, Processor processor, Expression expression) {
-        this(camelContext, processor, createSet(expression, false, false));
+        this(camelContext, processor, createSet(expression, false, false), expression);
     }
 
     public Resequencer(CamelContext camelContext, Processor processor, Expression expression,
                        boolean allowDuplicates, boolean reverse) {
-        this(camelContext, processor, createSet(expression, allowDuplicates, reverse));
+        this(camelContext, processor, createSet(expression, allowDuplicates, reverse), expression);
     }
 
-    public Resequencer(CamelContext camelContext, Processor processor, Set<Exchange> collection) {
-        super(camelContext, processor, collection);
+    public Resequencer(CamelContext camelContext, Processor processor, Set<Exchange> collection, Expression expression) {
+        super(camelContext, processor, collection, expression);
     }
 
     @Override
@@ -68,13 +68,6 @@ public class Resequencer extends BatchProcessor implements Traceable {
         return createSet(new ExpressionComparator(expression), allowDuplicates, reverse);
     }
 
-    protected static Set<Exchange> createSet(List<Expression> expressions, boolean allowDuplicates, boolean reverse) {
-        if (expressions.size() == 1) {
-            return createSet(expressions.get(0), allowDuplicates, reverse);
-        }
-        return createSet(new ExpressionListComparator(expressions), allowDuplicates, reverse);
-    }
-
     protected static Set<Exchange> createSet(final Comparator<? super Exchange> comparator, boolean allowDuplicates, boolean reverse) {
         Comparator<? super Exchange> answer = comparator;
 
diff --git a/camel-core/src/main/java/org/apache/camel/processor/StreamResequencer.java b/camel-core/src/main/java/org/apache/camel/processor/StreamResequencer.java
index efb59d00271..2763daa214b 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/StreamResequencer.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/StreamResequencer.java
@@ -24,6 +24,7 @@ import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
 import org.apache.camel.CamelContext;
+import org.apache.camel.CamelExchangeException;
 import org.apache.camel.Exchange;
 import org.apache.camel.Navigate;
 import org.apache.camel.Processor;
@@ -35,6 +36,8 @@ import org.apache.camel.spi.ExceptionHandler;
 import org.apache.camel.support.ServiceSupport;
 import org.apache.camel.util.ObjectHelper;
 import org.apache.camel.util.ServiceHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A resequencer that re-orders a (continuous) stream of {@link Exchange}s. The
@@ -61,6 +64,7 @@ import org.apache.camel.util.ServiceHelper;
 public class StreamResequencer extends ServiceSupport implements SequenceSender<Exchange>, Processor, Navigate<Processor>, Traceable {
 
     private static final long DELIVERY_ATTEMPT_INTERVAL = 1000L;
+    private static final Logger LOG = LoggerFactory.getLogger(StreamResequencer.class);
 
     private final CamelContext camelContext;
     private final ExceptionHandler exceptionHandler;
@@ -68,6 +72,7 @@ public class StreamResequencer extends ServiceSupport implements SequenceSender<
     private final Processor processor;
     private Delivery delivery;
     private int capacity;
+    private boolean ignoreInvalidExchanges;
     
     /**
      * Creates a new {@link StreamResequencer} instance.
@@ -131,6 +136,20 @@ public class StreamResequencer extends ServiceSupport implements SequenceSender<
         engine.setTimeout(timeout);
     }
 
+    public boolean isIgnoreInvalidExchanges() {
+        return ignoreInvalidExchanges;
+    }
+
+    /**
+     * Sets whether to ignore invalid exchanges which cannot be used by this stream resequencer.
+     * <p/>
+     * Default is <tt>false</tt>, by which an {@link CamelExchangeException} is thrown if the {@link Exchange}
+     * is invalid.
+     */
+    public void setIgnoreInvalidExchanges(boolean ignoreInvalidExchanges) {
+        this.ignoreInvalidExchanges = ignoreInvalidExchanges;
+    }
+
     @Override
     public String toString() {
         return "StreamResequencer[to: " + processor + "]";
@@ -169,8 +188,18 @@ public class StreamResequencer extends ServiceSupport implements SequenceSender<
         while (engine.size() >= capacity) {
             Thread.sleep(getTimeout());
         }
-        engine.insert(exchange);
-        delivery.request();
+
+        try {
+            engine.insert(exchange);
+            delivery.request();
+        } catch (Exception e) {
+            if (isIgnoreInvalidExchanges()) {
+                LOG.debug("Invalid Exchange. This Exchange will be ignored: {}", exchange);
+                return;
+            } else {
+                throw new CamelExchangeException("Error processing Exchange in StreamResequencer", exchange, e);
+            }
+        }
     }
 
     public boolean hasNext() {
diff --git a/camel-core/src/main/java/org/apache/camel/processor/resequencer/DefaultExchangeComparator.java b/camel-core/src/main/java/org/apache/camel/processor/resequencer/DefaultExchangeComparator.java
index ab62bac63f1..f933f3ebc27 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/resequencer/DefaultExchangeComparator.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/resequencer/DefaultExchangeComparator.java
@@ -30,29 +30,49 @@ public class DefaultExchangeComparator implements ExpressionResultComparator {
 
     private Expression expression;
 
+    @Override
     public void setExpression(Expression expression) {
         this.expression = expression;
     }
 
+    @Override
     public boolean predecessor(Exchange o1, Exchange o2) {
         long n1 = getSequenceNumber(o1);
         long n2 = getSequenceNumber(o2);
         return n1 == (n2 - 1L);
     }
 
+    @Override
     public boolean successor(Exchange o1, Exchange o2) {
         long n1 = getSequenceNumber(o1);
         long n2 = getSequenceNumber(o2);
         return n2 == (n1 - 1L);
     }
 
+    @Override
     public int compare(Exchange o1, Exchange o2) {
         Long n1 = getSequenceNumber(o1);
         Long n2 = getSequenceNumber(o2);
         return n1.compareTo(n2);
     }
 
-    private long getSequenceNumber(Exchange exchange) {
+    private Long getSequenceNumber(Exchange exchange) {
         return expression.evaluate(exchange, Long.class);
     }
+
+    @Override
+    public boolean isValid(Exchange exchange) {
+        Long num = null;
+        try {
+            num = expression.evaluate(exchange, Long.class);
+        } catch (Exception e) {
+            // ignore
+        }
+        return num != null;
+    }
+
+    @Override
+    public String toString() {
+        return "Comparator[" + expression + "]";
+    }
 }
diff --git a/camel-core/src/main/java/org/apache/camel/processor/resequencer/ElementComparator.java b/camel-core/src/main/java/org/apache/camel/processor/resequencer/ElementComparator.java
index 9697767f026..037ffcfc37e 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/resequencer/ElementComparator.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/resequencer/ElementComparator.java
@@ -28,7 +28,7 @@ class ElementComparator<E> implements SequenceElementComparator<Element<E>> {
     /**
      * A sequence element comparator this comparator delegates to.
      */
-    private SequenceElementComparator<E> comparator;
+    private final SequenceElementComparator<E> comparator;
     
     /**
      * Creates a new element comparator instance.
@@ -39,16 +39,28 @@ class ElementComparator<E> implements SequenceElementComparator<Element<E>> {
         this.comparator = comparator;
     }
     
+    @Override
     public boolean predecessor(Element<E> o1, Element<E> o2) {
         return comparator.predecessor(o1.getObject(), o2.getObject());
     }
 
+    @Override
     public boolean successor(Element<E> o1, Element<E> o2) {
         return comparator.successor(o1.getObject(), o2.getObject());
     }
 
+    @Override
     public int compare(Element<E> o1, Element<E> o2) {
         return comparator.compare(o1.getObject(), o2.getObject());
     }
 
+    @Override
+    public boolean isValid(Element<E> o1) {
+        return comparator.isValid(o1.getObject());
+    }
+
+    @Override
+    public String toString() {
+        return comparator.toString();
+    }
 }
diff --git a/camel-core/src/main/java/org/apache/camel/processor/resequencer/ResequencerEngine.java b/camel-core/src/main/java/org/apache/camel/processor/resequencer/ResequencerEngine.java
index 0e002d66abe..2e954858102 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/resequencer/ResequencerEngine.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/resequencer/ResequencerEngine.java
@@ -18,6 +18,7 @@ package org.apache.camel.processor.resequencer;
 
 import java.util.Timer;
 
+import org.apache.camel.CamelExchangeException;
 import org.apache.camel.util.concurrent.ThreadHelper;
 
 /**
@@ -182,10 +183,17 @@ public class ResequencerEngine<E> {
      * scheduled for timing out. After being timed out it is ready for delivery.
      *
      * @param o an element.
+     * @throws IllegalArgumentException if the element cannot be used with this resequencer engine
      */
     public synchronized void insert(E o) {
         // wrap object into internal element
         Element<E> element = new Element<E>(o);
+
+        // validate the exchange has no problem
+        if (!sequence.comparator().isValid(element)) {
+            throw new IllegalArgumentException("Element cannot be used in comparator: " + sequence.comparator());
+        }
+
         // add element to sequence in proper order
         sequence.add(element);
 
diff --git a/camel-core/src/main/java/org/apache/camel/processor/resequencer/SequenceElementComparator.java b/camel-core/src/main/java/org/apache/camel/processor/resequencer/SequenceElementComparator.java
index bf0474d008b..2ebbaabc7a8 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/resequencer/SequenceElementComparator.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/resequencer/SequenceElementComparator.java
@@ -44,5 +44,13 @@ public interface SequenceElementComparator<E> extends Comparator<E> {
      * @return true if its an immediate successor
      */
     boolean successor(E o1, E o2);
+
+    /**
+     * Returns <tt>true</tt> if the <code>o1</code> can be used in this comparator.
+     *
+     * @param o1 a sequence element
+     * @return true if its usable for this comparator
+     */
+    boolean isValid(E o1);
     
 }
diff --git a/camel-core/src/test/java/org/apache/camel/processor/ResequenceBatchIgnoreInvalidExchangesTest.java b/camel-core/src/test/java/org/apache/camel/processor/ResequenceBatchIgnoreInvalidExchangesTest.java
new file mode 100644
index 00000000000..ff7ed6a3854
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/ResequenceBatchIgnoreInvalidExchangesTest.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ *
+ */
+public class ResequenceBatchIgnoreInvalidExchangesTest extends ResequenceStreamIgnoreInvalidExchangesTest {
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // START SNIPPET: e1
+                from("direct:start")
+                    .resequence(header("seqno")).batch().timeout(1000)
+                        // ignore invalid exchanges (they are discarded)
+                        .ignoreInvalidExchanges()
+                    .to("mock:result");
+                // END SNIPPET: e1
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/ResequenceBatchNotIgnoreInvalidExchangesTest.java b/camel-core/src/test/java/org/apache/camel/processor/ResequenceBatchNotIgnoreInvalidExchangesTest.java
new file mode 100644
index 00000000000..ac408e532b1
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/ResequenceBatchNotIgnoreInvalidExchangesTest.java
@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ *
+ */
+public class ResequenceBatchNotIgnoreInvalidExchangesTest extends ResequenceStreamNotIgnoreInvalidExchangesTest {
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                    .resequence(header("seqno")).batch().timeout(1000)
+                    .to("mock:result");
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/ResequenceStreamIgnoreInvalidExchangesTest.java b/camel-core/src/test/java/org/apache/camel/processor/ResequenceStreamIgnoreInvalidExchangesTest.java
new file mode 100644
index 00000000000..678c6227c21
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/ResequenceStreamIgnoreInvalidExchangesTest.java
@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ *
+ */
+public class ResequenceStreamIgnoreInvalidExchangesTest extends ContextTestSupport {
+
+    public void testBadFirstMessage() throws Exception {
+        // bad messages is ignored
+        getMockEndpoint("mock:result").expectedBodiesReceived("B", "C", "D");
+
+        template.sendBody("direct:start", "A");
+        template.sendBodyAndHeader("direct:start", "D", "seqno", 4);
+        template.sendBodyAndHeader("direct:start", "C", "seqno", 3);
+        template.sendBodyAndHeader("direct:start", "B", "seqno", 2);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testBadSecondMessage() throws Exception {
+        // bad messages is ignored
+        getMockEndpoint("mock:result").expectedBodiesReceived("B", "C", "D");
+
+        template.sendBodyAndHeader("direct:start", "D", "seqno", 4);
+        template.sendBody("direct:start", "A");
+        template.sendBodyAndHeader("direct:start", "C", "seqno", 3);
+        template.sendBodyAndHeader("direct:start", "B", "seqno", 2);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testBadThirdMessage() throws Exception {
+        // bad messages is ignored
+        getMockEndpoint("mock:result").expectedBodiesReceived("B", "C", "D");
+
+        template.sendBodyAndHeader("direct:start", "D", "seqno", 4);
+        template.sendBodyAndHeader("direct:start", "C", "seqno", 3);
+        template.sendBody("direct:start", "A");
+        template.sendBodyAndHeader("direct:start", "B", "seqno", 2);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testBadForthMessage() throws Exception {
+        // bad messages is ignored
+        getMockEndpoint("mock:result").expectedBodiesReceived("B", "C", "D");
+
+        template.sendBodyAndHeader("direct:start", "D", "seqno", 4);
+        template.sendBodyAndHeader("direct:start", "C", "seqno", 3);
+        template.sendBodyAndHeader("direct:start", "B", "seqno", 2);
+        template.sendBody("direct:start", "A");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // START SNIPPET: e1
+                from("direct:start")
+                    .resequence(header("seqno")).stream().timeout(1000)
+                        // ignore invalid exchanges (they are discarded)
+                        .ignoreInvalidExchanges()
+                    .to("mock:result");
+                // END SNIPPET: e1
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/ResequenceStreamNotIgnoreInvalidExchangesTest.java b/camel-core/src/test/java/org/apache/camel/processor/ResequenceStreamNotIgnoreInvalidExchangesTest.java
new file mode 100644
index 00000000000..c0307a25187
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/ResequenceStreamNotIgnoreInvalidExchangesTest.java
@@ -0,0 +1,103 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.CamelExecutionException;
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ *
+ */
+public class ResequenceStreamNotIgnoreInvalidExchangesTest extends ContextTestSupport {
+
+    public void testBadFirstMessage() throws Exception {
+        getMockEndpoint("mock:result").expectedBodiesReceived("B", "C", "D");
+
+        try {
+            template.sendBody("direct:start", "A");
+            fail("Should fail");
+        } catch (CamelExecutionException e) {
+            // expected
+        }
+        template.sendBodyAndHeader("direct:start", "D", "seqno", 4);
+        template.sendBodyAndHeader("direct:start", "C", "seqno", 3);
+        template.sendBodyAndHeader("direct:start", "B", "seqno", 2);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testBadSecondMessage() throws Exception {
+        getMockEndpoint("mock:result").expectedBodiesReceived("B", "C", "D");
+
+        template.sendBodyAndHeader("direct:start", "D", "seqno", 4);
+        try {
+            template.sendBody("direct:start", "A");
+            fail("Should fail");
+        } catch (CamelExecutionException e) {
+            // expected
+        }
+        template.sendBodyAndHeader("direct:start", "C", "seqno", 3);
+        template.sendBodyAndHeader("direct:start", "B", "seqno", 2);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testBadThirdMessage() throws Exception {
+        getMockEndpoint("mock:result").expectedBodiesReceived("B", "C", "D");
+
+        template.sendBodyAndHeader("direct:start", "D", "seqno", 4);
+        template.sendBodyAndHeader("direct:start", "C", "seqno", 3);
+        try {
+            template.sendBody("direct:start", "A");
+            fail("Should fail");
+        } catch (CamelExecutionException e) {
+            // expected
+        }
+        template.sendBodyAndHeader("direct:start", "B", "seqno", 2);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testBadForthMessage() throws Exception {
+        getMockEndpoint("mock:result").expectedBodiesReceived("B", "C", "D");
+
+        template.sendBodyAndHeader("direct:start", "D", "seqno", 4);
+        template.sendBodyAndHeader("direct:start", "C", "seqno", 3);
+        template.sendBodyAndHeader("direct:start", "B", "seqno", 2);
+        try {
+            template.sendBody("direct:start", "A");
+            fail("Should fail");
+        } catch (CamelExecutionException e) {
+            // expected
+        }
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                    .resequence(header("seqno")).stream().timeout(1000)
+                    .to("mock:result");
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/resequencer/IntegerComparator.java b/camel-core/src/test/java/org/apache/camel/processor/resequencer/IntegerComparator.java
index e0e3f6e68d8..a31f5e44821 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/resequencer/IntegerComparator.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/resequencer/IntegerComparator.java
@@ -18,16 +18,24 @@ package org.apache.camel.processor.resequencer;
 
 public class IntegerComparator implements SequenceElementComparator<Integer> {
 
+    @Override
     public boolean predecessor(Integer o1, Integer o2) {
         return o1.intValue() == (o2.intValue() - 1);
     }
 
+    @Override
     public boolean successor(Integer o1, Integer o2) {
         return o2.intValue() == (o1.intValue() - 1);
     }
 
+    @Override
     public int compare(Integer o1, Integer o2) {
         return o1.compareTo(o2);
     }
 
+    @Override
+    public boolean isValid(Integer o1) {
+        return o1 != null;
+    }
+
 }
diff --git a/camel-core/src/test/java/org/apache/camel/processor/resequencer/TestComparator.java b/camel-core/src/test/java/org/apache/camel/processor/resequencer/TestComparator.java
index d0888b9d68e..2c05718c1e6 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/resequencer/TestComparator.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/resequencer/TestComparator.java
@@ -18,16 +18,24 @@ package org.apache.camel.processor.resequencer;
 
 public class TestComparator implements SequenceElementComparator<TestObject> {
 
+    @Override
     public boolean predecessor(TestObject o1, TestObject o2) {
         return (o2.getValue() - 1) == o1.getValue();
     }
 
+    @Override
     public boolean successor(TestObject o1, TestObject o2) {
         return (o1.getValue() - 1) == o2.getValue();
     }
 
+    @Override
     public int compare(TestObject o1, TestObject o2) {
         return Integer.valueOf(o1.getValue()).compareTo(o2.getValue());
     }
 
+    @Override
+    public boolean isValid(TestObject o1) {
+        return o1 != null;
+    }
+
 }
