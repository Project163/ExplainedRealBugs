diff --git a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/OpenTracingTracer.java b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/OpenTracingTracer.java
index e6f9c6d747e..37063776f12 100644
--- a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/OpenTracingTracer.java
+++ b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/OpenTracingTracer.java
@@ -30,7 +30,6 @@ import io.opentracing.contrib.tracerresolver.TracerResolver;
 import io.opentracing.noop.NoopTracerFactory;
 import io.opentracing.propagation.Format;
 import io.opentracing.tag.Tags;
-
 import org.apache.camel.CamelContext;
 import org.apache.camel.CamelContextAware;
 import org.apache.camel.Endpoint;
@@ -56,11 +55,15 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * To use OpenTracing with Camel then setup this {@link OpenTracingTracer} in your Camel application.
+ * To use OpenTracing with Camel then setup this {@link OpenTracingTracer} in
+ * your Camel application.
  * <p/>
- * This class is implemented as both an {@link org.apache.camel.spi.EventNotifier} and {@link RoutePolicy} that allows
- * to trap when Camel starts/ends an {@link Exchange} being routed using the {@link RoutePolicy} and during the routing
- * if the {@link Exchange} sends messages, then we track them using the {@link org.apache.camel.spi.EventNotifier}.
+ * This class is implemented as both an
+ * {@link org.apache.camel.spi.EventNotifier} and {@link RoutePolicy} that
+ * allows to trap when Camel starts/ends an {@link Exchange} being routed using
+ * the {@link RoutePolicy} and during the routing if the {@link Exchange} sends
+ * messages, then we track them using the
+ * {@link org.apache.camel.spi.EventNotifier}.
  */
 @ManagedResource(description = "OpenTracingTracer")
 public class OpenTracingTracer extends ServiceSupport implements RoutePolicyFactory, StaticService, CamelContextAware {
@@ -100,12 +103,14 @@ public class OpenTracingTracer extends ServiceSupport implements RoutePolicyFact
     }
 
     /**
-     * Registers this {@link OpenTracingTracer} on the {@link CamelContext} if not already registered.
+     * Registers this {@link OpenTracingTracer} on the {@link CamelContext} if
+     * not already registered.
      */
     public void init(CamelContext camelContext) {
         if (!camelContext.hasService(this)) {
             try {
-                // start this service eager so we init before Camel is starting up
+                // start this service eager so we init before Camel is starting
+                // up
                 camelContext.addService(this, true, true);
 
             } catch (Exception e) {
@@ -133,17 +138,18 @@ public class OpenTracingTracer extends ServiceSupport implements RoutePolicyFact
     }
 
     public boolean isEncoding() {
-		return encoding;
-	}
+        return encoding;
+    }
 
-	public void setEncoding(boolean encoding) {
-		this.encoding = encoding;
-	}
+    public void setEncoding(boolean encoding) {
+        this.encoding = encoding;
+    }
 
-	/**
-     * Adds an exclude pattern that will disable tracing for Camel messages that matches the pattern.
+    /**
+     * Adds an exclude pattern that will disable tracing for Camel messages that
+     * matches the pattern.
      *
-     * @param pattern  the pattern such as route id, endpoint url
+     * @param pattern the pattern such as route id, endpoint url
      */
     public void addExcludePattern(String pattern) {
         excludePatterns.add(pattern);
@@ -227,29 +233,29 @@ public class OpenTracingTracer extends ServiceSupport implements RoutePolicyFact
         public void notify(EventObject event) throws Exception {
             try {
                 if (event instanceof ExchangeSendingEvent) {
-                    ExchangeSendingEvent ese = (ExchangeSendingEvent) event;
+                    ExchangeSendingEvent ese = (ExchangeSendingEvent)event;
                     SpanDecorator sd = getSpanDecorator(ese.getEndpoint());
                     if (!sd.newSpan() || isExcluded(ese.getExchange(), ese.getEndpoint())) {
                         return;
                     }
                     Span parent = ActiveSpanManager.getSpan(ese.getExchange());
-                    SpanBuilder spanBuilder = tracer.buildSpan(sd.getOperationName(ese.getExchange(), ese.getEndpoint()))
-                        .withTag(Tags.SPAN_KIND.getKey(), sd.getInitiatorSpanKind());
-                    // Temporary workaround to avoid adding 'null' span as a parent
+                    SpanBuilder spanBuilder = tracer.buildSpan(sd.getOperationName(ese.getExchange(), ese.getEndpoint())).withTag(Tags.SPAN_KIND.getKey(),
+                                                                                                                                  sd.getInitiatorSpanKind());
+                    // Temporary workaround to avoid adding 'null' span as a
+                    // parent
                     if (parent != null) {
                         spanBuilder.asChildOf(parent);
                     }
                     Span span = spanBuilder.start();
                     sd.pre(span, ese.getExchange(), ese.getEndpoint());
-                    tracer.inject(span.context(), Format.Builtin.TEXT_MAP,
-                        sd.getInjectAdapter(ese.getExchange().getIn().getHeaders(), encoding));
+                    tracer.inject(span.context(), Format.Builtin.TEXT_MAP, sd.getInjectAdapter(ese.getExchange().getIn().getHeaders(), encoding));
                     ActiveSpanManager.activate(ese.getExchange(), span);
 
                     if (LOG.isTraceEnabled()) {
                         LOG.trace("OpenTracing: start client span={}", span);
                     }
                 } else if (event instanceof ExchangeSentEvent) {
-                    ExchangeSentEvent ese = (ExchangeSentEvent) event;
+                    ExchangeSentEvent ese = (ExchangeSentEvent)event;
                     SpanDecorator sd = getSpanDecorator(ese.getEndpoint());
                     if (!sd.newSpan() || isExcluded(ese.getExchange(), ese.getEndpoint())) {
                         return;
@@ -274,8 +280,7 @@ public class OpenTracingTracer extends ServiceSupport implements RoutePolicyFact
 
         @Override
         public boolean isEnabled(EventObject event) {
-            return event instanceof ExchangeSendingEvent
-                || event instanceof ExchangeSentEvent;
+            return event instanceof ExchangeSendingEvent || event instanceof ExchangeSentEvent;
         }
 
         @Override
@@ -297,10 +302,8 @@ public class OpenTracingTracer extends ServiceSupport implements RoutePolicyFact
                 }
                 SpanDecorator sd = getSpanDecorator(route.getEndpoint());
                 Span span = tracer.buildSpan(sd.getOperationName(exchange, route.getEndpoint()))
-                    .asChildOf(tracer.extract(Format.Builtin.TEXT_MAP,
-                        sd.getExtractAdapter(exchange.getIn().getHeaders(), encoding)))
-                    .withTag(Tags.SPAN_KIND.getKey(), sd.getReceiverSpanKind())
-                    .start();
+                    .asChildOf(tracer.extract(Format.Builtin.TEXT_MAP, sd.getExtractAdapter(exchange.getIn().getHeaders(), encoding)))
+                    .withTag(Tags.SPAN_KIND.getKey(), sd.getReceiverSpanKind()).start();
                 sd.pre(span, exchange, route.getEndpoint());
                 ActiveSpanManager.activate(exchange, span);
                 if (LOG.isTraceEnabled()) {
diff --git a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/SpanDecorator.java b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/SpanDecorator.java
index 44c2a41f168..e94e3181ad5 100644
--- a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/SpanDecorator.java
+++ b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/SpanDecorator.java
@@ -16,11 +16,10 @@
  */
 package org.apache.camel.opentracing;
 
-import io.opentracing.propagation.TextMap;
-import io.opentracing.Span;
-
 import java.util.Map;
 
+import io.opentracing.Span;
+import io.opentracing.propagation.TextMap;
 import org.apache.camel.Endpoint;
 import org.apache.camel.Exchange;
 import org.apache.camel.opentracing.decorators.AbstractSpanDecorator;
diff --git a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/decorators/AbstractMessagingSpanDecorator.java b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/decorators/AbstractMessagingSpanDecorator.java
index 5a039536b24..bccae81f2cc 100644
--- a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/decorators/AbstractMessagingSpanDecorator.java
+++ b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/decorators/AbstractMessagingSpanDecorator.java
@@ -16,12 +16,11 @@
  */
 package org.apache.camel.opentracing.decorators;
 
+import java.util.Map;
+
 import io.opentracing.Span;
 import io.opentracing.propagation.TextMap;
 import io.opentracing.tag.Tags;
-
-import java.util.Map;
-
 import org.apache.camel.Endpoint;
 import org.apache.camel.Exchange;
 import org.apache.camel.opentracing.propagation.CamelMessagingHeadersExtractAdapter;
@@ -50,7 +49,8 @@ public abstract class AbstractMessagingSpanDecorator extends AbstractSpanDecorat
     }
 
     /**
-     * This method identifies the destination from the supplied exchange and/or endpoint.
+     * This method identifies the destination from the supplied exchange and/or
+     * endpoint.
      *
      * @param exchange The exchange
      * @param endpoint The endpoint
@@ -81,11 +81,11 @@ public abstract class AbstractMessagingSpanDecorator extends AbstractSpanDecorat
 
     @Override
     public TextMap getExtractAdapter(final Map<String, Object> map, final boolean jmsEncoding) {
-    	return new CamelMessagingHeadersExtractAdapter(map, jmsEncoding);
+        return new CamelMessagingHeadersExtractAdapter(map, jmsEncoding);
     }
 
     @Override
     public TextMap getInjectAdapter(final Map<String, Object> map, final boolean jmsEncoding) {
-    	return new CamelMessagingHeadersInjectAdapter(map, jmsEncoding);    	
+        return new CamelMessagingHeadersInjectAdapter(map, jmsEncoding);
     }
 }
diff --git a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/decorators/AbstractSpanDecorator.java b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/decorators/AbstractSpanDecorator.java
index 6f51365586b..e0576517741 100644
--- a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/decorators/AbstractSpanDecorator.java
+++ b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/decorators/AbstractSpanDecorator.java
@@ -20,10 +20,9 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
-import io.opentracing.propagation.TextMap;
 import io.opentracing.Span;
+import io.opentracing.propagation.TextMap;
 import io.opentracing.tag.Tags;
-
 import org.apache.camel.Endpoint;
 import org.apache.camel.Exchange;
 import org.apache.camel.opentracing.SpanDecorator;
@@ -44,17 +43,18 @@ public abstract class AbstractSpanDecorator implements SpanDecorator {
 
     @Override
     public String getOperationName(Exchange exchange, Endpoint endpoint) {
-        // OpenTracing aims to use low cardinality operation names. Ideally a specific
-        // span decorator should be defined for all relevant Camel components that
+        // OpenTracing aims to use low cardinality operation names. Ideally a
+        // specific
+        // span decorator should be defined for all relevant Camel components
+        // that
         // identify a meaningful operation name
         return getComponentName(endpoint);
     }
 
     /**
-     * This method removes the scheme, any leading slash characters and
-     * options from the supplied URI. This is intended to extract a meaningful
-     * name from the URI that can be used in situations, such as the operation
-     * name.
+     * This method removes the scheme, any leading slash characters and options
+     * from the supplied URI. This is intended to extract a meaningful name from
+     * the URI that can be used in situations, such as the operation name.
      *
      * @param endpoint The endpoint
      * @return The stripped value from the URI
@@ -67,8 +67,7 @@ public abstract class AbstractSpanDecorator implements SpanDecorator {
             start++;
         }
         int end = endpoint.getEndpointUri().indexOf('?');
-        return end == -1 ? endpoint.getEndpointUri().substring(start)
-                : endpoint.getEndpointUri().substring(start, end);
+        return end == -1 ? endpoint.getEndpointUri().substring(start) : endpoint.getEndpointUri().substring(start, end);
     }
 
     @Override
@@ -76,7 +75,8 @@ public abstract class AbstractSpanDecorator implements SpanDecorator {
         String scheme = getComponentName(endpoint);
         span.setTag(Tags.COMPONENT.getKey(), CAMEL_COMPONENT + scheme);
 
-        // Including the endpoint URI provides access to any options that may have been provided, for
+        // Including the endpoint URI provides access to any options that may
+        // have been provided, for
         // subsequent analysis
         span.setTag("camel.uri", URISupport.sanitizeUri(endpoint.getEndpointUri()));
     }
@@ -132,13 +132,13 @@ public abstract class AbstractSpanDecorator implements SpanDecorator {
 
     @Override
     public TextMap getExtractAdapter(final Map<String, Object> map, boolean encoding) {
-    	// no encoding supported per default
-    	return new CamelHeadersExtractAdapter(map);
+        // no encoding supported per default
+        return new CamelHeadersExtractAdapter(map);
     }
 
     @Override
     public TextMap getInjectAdapter(final Map<String, Object> map, boolean encoding) {
-    	// no encoding supported per default
-    	return new CamelHeadersInjectAdapter(map);    	
+        // no encoding supported per default
+        return new CamelHeadersInjectAdapter(map);
     }
 }
diff --git a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersExtractAdapter.java b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersExtractAdapter.java
index 30d3d082371..3a2b467c099 100644
--- a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersExtractAdapter.java
+++ b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersExtractAdapter.java
@@ -16,22 +16,21 @@
  */
 package org.apache.camel.opentracing.propagation;
 
-import io.opentracing.propagation.TextMap;
-
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
+import io.opentracing.propagation.TextMap;
+
 public final class CamelMessagingHeadersExtractAdapter implements TextMap {
- 
+
     private final Map<String, String> map = new HashMap<>();
     private final boolean jmsEncoding;
 
     public CamelMessagingHeadersExtractAdapter(final Map<String, Object> map, boolean jmsEncoding) {
-    	// Extract string valued map entries
+        // Extract string valued map entries
         this.jmsEncoding = jmsEncoding;
-        map.entrySet().stream().filter(e -> e.getValue() instanceof String).forEach(e ->
-            this.map.put(decodeDash(e.getKey()), (String) e.getValue()));
+        map.entrySet().stream().filter(e -> e.getValue() instanceof String).forEach(e -> this.map.put(decodeDash(e.getKey()), (String)e.getValue()));
     }
 
     @Override
@@ -43,19 +42,21 @@ public final class CamelMessagingHeadersExtractAdapter implements TextMap {
     public void put(String key, String value) {
         throw new UnsupportedOperationException("CamelMessagingHeadersExtractAdapter should only be used with Tracer.extract()");
     }
-    
+
     /**
-     * Decode dashes (encoded in {@link CamelMessagingHeadersInjectAdapter}
-     * Dash encoding and decoding is required by JMS. This is implemented here
-     * rather than specifically to JMS so that other Camel messaging endpoints
-     * can take part in traces where the peer is using JMS. 
+     * Decode dashes (encoded in {@link CamelMessagingHeadersInjectAdapter} Dash
+     * encoding and decoding is required by JMS. This is implemented here rather
+     * than specifically to JMS so that other Camel messaging endpoints can take
+     * part in traces where the peer is using JMS.
+     * 
      * @param the source
      * @return the result
      */
     private String decodeDash(String key) {
-    	if (jmsEncoding)
-    		return key.replace(CamelMessagingHeadersInjectAdapter.JMS_DASH, "-");
-    	else
-    		return key;
-  }
+        if (jmsEncoding) {
+            return key.replace(CamelMessagingHeadersInjectAdapter.JMS_DASH, "-");
+        } else {
+            return key;
+        }
+    }
 }
diff --git a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersInjectAdapter.java b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersInjectAdapter.java
index cb979c66ef0..1c532d668f0 100644
--- a/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersInjectAdapter.java
+++ b/components/camel-opentracing/src/main/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersInjectAdapter.java
@@ -23,13 +23,15 @@ import io.opentracing.propagation.TextMap;
 
 public final class CamelMessagingHeadersInjectAdapter implements TextMap {
 
-	// As per the JMS specs, header names must be valid Java identifier part characters.
-	// This means that any header names that contain illegal characters (- for example) should be handled correctly
-	// Opentracing java-jms does it as follows.
-	static final String JMS_DASH = "_$dash$_";
+    // As per the JMS specs, header names must be valid Java identifier part
+    // characters.
+    // This means that any header names that contain illegal characters (- for
+    // example) should be handled correctly
+    // Opentracing java-jms does it as follows.
+    static final String JMS_DASH = "_$dash$_";
 
-	private final Map<String, Object> map;
-	private final boolean jmsEncoding;
+    private final Map<String, Object> map;
+    private final boolean jmsEncoding;
 
     public CamelMessagingHeadersInjectAdapter(final Map<String, Object> map, boolean jmsEncoding) {
         this.map = map;
@@ -43,20 +45,22 @@ public final class CamelMessagingHeadersInjectAdapter implements TextMap {
 
     @Override
     public void put(String key, String value) {
-        // Assume any header property that begins with 'Camel' is for internal use
+        // Assume any header property that begins with 'Camel' is for internal
+        // use
         if (!key.startsWith("Camel")) {
             this.map.put(encodeDash(key), value);
         }
     }
-    
+
     /**
-     * Encode all dashes because JMS specification doesn't allow them in property name
+     * Encode all dashes because JMS specification doesn't allow them in
+     * property name
      */
     private String encodeDash(String key) {
-      if (key == null || key.isEmpty() || !jmsEncoding) {
-        return key;
-      }
+        if (key == null || key.isEmpty() || !jmsEncoding) {
+            return key;
+        }
 
-      return key.replace("-", JMS_DASH);
-   }
-}
\ No newline at end of file
+        return key.replace("-", JMS_DASH);
+    }
+}
diff --git a/components/camel-opentracing/src/test/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersExtractAdapterTest.java b/components/camel-opentracing/src/test/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersExtractAdapterTest.java
index 0d7bf851b8b..f0edd3bfee6 100644
--- a/components/camel-opentracing/src/test/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersExtractAdapterTest.java
+++ b/components/camel-opentracing/src/test/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersExtractAdapterTest.java
@@ -1,10 +1,21 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.camel.opentracing.propagation;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-
-import static org.apache.camel.opentracing.propagation.CamelMessagingHeadersInjectAdapter.JMS_DASH;
-
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
@@ -12,48 +23,52 @@ import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.apache.camel.opentracing.propagation.CamelMessagingHeadersInjectAdapter.JMS_DASH;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
 public class CamelMessagingHeadersExtractAdapterTest {
-	
-	private Map<String,Object> map;
-	
-	@Before
-	public void before() {
-	    map = new HashMap<String,Object>();
-	}
-	
-	@Test
-	public void noProperties() {
-		CamelMessagingHeadersExtractAdapter adapter = new CamelMessagingHeadersExtractAdapter(map,true);
-		Iterator<Map.Entry<String, String>> iterator = adapter.iterator();
-		assertFalse(iterator.hasNext());
-	}
-
-	@Test
-	public void oneProperty() {
-		map.put("key", "value");
-		CamelMessagingHeadersExtractAdapter adapter = new CamelMessagingHeadersExtractAdapter(map,true);
-		Iterator<Map.Entry<String, String>> iterator = adapter.iterator();
-		Map.Entry<String, String> entry = iterator.next();
-		assertEquals("key", entry.getKey());
-		assertEquals("value", entry.getValue());
-	}
-
-	@Test
-	public void propertyWithDash() {
-		map.put(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH, "value1");
-		CamelMessagingHeadersExtractAdapter adapter = new CamelMessagingHeadersExtractAdapter(map,true);
-		Iterator<Map.Entry<String, String>> iterator = adapter.iterator();
-		Map.Entry<String, String> entry = iterator.next();
-		assertEquals("-key-1-", entry.getKey());
-		assertEquals("value1", entry.getValue());
-	}
-
-	@Test
-	public void propertyWithoutDashEncoding() {
-		map.put(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH, "value1");
-		CamelMessagingHeadersExtractAdapter adapter = new CamelMessagingHeadersExtractAdapter(map,false);
-		Iterator<Map.Entry<String, String>> iterator = adapter.iterator();
-		Map.Entry<String, String> entry = iterator.next();
-		assertEquals(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH, entry.getKey());
-	}
+
+    private Map<String, Object> map;
+
+    @Before
+    public void before() {
+        map = new HashMap<String, Object>();
+    }
+
+    @Test
+    public void noProperties() {
+        CamelMessagingHeadersExtractAdapter adapter = new CamelMessagingHeadersExtractAdapter(map, true);
+        Iterator<Map.Entry<String, String>> iterator = adapter.iterator();
+        assertFalse(iterator.hasNext());
+    }
+
+    @Test
+    public void oneProperty() {
+        map.put("key", "value");
+        CamelMessagingHeadersExtractAdapter adapter = new CamelMessagingHeadersExtractAdapter(map, true);
+        Iterator<Map.Entry<String, String>> iterator = adapter.iterator();
+        Map.Entry<String, String> entry = iterator.next();
+        assertEquals("key", entry.getKey());
+        assertEquals("value", entry.getValue());
+    }
+
+    @Test
+    public void propertyWithDash() {
+        map.put(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH, "value1");
+        CamelMessagingHeadersExtractAdapter adapter = new CamelMessagingHeadersExtractAdapter(map, true);
+        Iterator<Map.Entry<String, String>> iterator = adapter.iterator();
+        Map.Entry<String, String> entry = iterator.next();
+        assertEquals("-key-1-", entry.getKey());
+        assertEquals("value1", entry.getValue());
+    }
+
+    @Test
+    public void propertyWithoutDashEncoding() {
+        map.put(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH, "value1");
+        CamelMessagingHeadersExtractAdapter adapter = new CamelMessagingHeadersExtractAdapter(map, false);
+        Iterator<Map.Entry<String, String>> iterator = adapter.iterator();
+        Map.Entry<String, String> entry = iterator.next();
+        assertEquals(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH, entry.getKey());
+    }
 }
diff --git a/components/camel-opentracing/src/test/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersInjectAdapterTest.java b/components/camel-opentracing/src/test/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersInjectAdapterTest.java
index 7fe81525525..95cafe9ce08 100644
--- a/components/camel-opentracing/src/test/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersInjectAdapterTest.java
+++ b/components/camel-opentracing/src/test/java/org/apache/camel/opentracing/propagation/CamelMessagingHeadersInjectAdapterTest.java
@@ -1,9 +1,21 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.camel.opentracing.propagation;
 
-import static org.apache.camel.opentracing.propagation.CamelMessagingHeadersInjectAdapter.JMS_DASH;
-
-import static org.junit.Assert.assertEquals;
-
 import java.util.HashMap;
 import java.util.Map;
 
@@ -12,47 +24,49 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
+import static org.apache.camel.opentracing.propagation.CamelMessagingHeadersInjectAdapter.JMS_DASH;
+import static org.junit.Assert.assertEquals;
+
 public class CamelMessagingHeadersInjectAdapterTest {
 
-	private Map<String,Object> map;
-	
-
-	@Rule
-	public ExpectedException thrown = ExpectedException.none();
-	  
-	@Before
-	public void before() {
-	    map = new HashMap<String,Object>();
-	}
-	
-	@Test
-	public void cannotGetIterator() {
-		CamelMessagingHeadersInjectAdapter adapter = new CamelMessagingHeadersInjectAdapter(map,true);
-		thrown.expect(UnsupportedOperationException.class);
-		adapter.iterator();
-	}
-
-	@Test
-	public void putProperties() {
-		CamelMessagingHeadersInjectAdapter adapter = new CamelMessagingHeadersInjectAdapter(map,true);
-		adapter.put("key1", "value1");
-	    adapter.put("key2", "value2");
-	    adapter.put("key1", "value3");
-	    assertEquals("value3", map.get("key1"));
-	    assertEquals("value2", map.get("key2"));
-	}
-
-	@Test
-	public void propertyWithDash() {
-		CamelMessagingHeadersInjectAdapter adapter = new CamelMessagingHeadersInjectAdapter(map,true);
-		adapter.put("-key-1-", "value1");
-		assertEquals("value1", map.get(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH));
-	}
-
-	@Test
-	public void propertyWithoutDashEncoding() {
-		CamelMessagingHeadersInjectAdapter adapter = new CamelMessagingHeadersInjectAdapter(map,false);
-		adapter.put("-key-1-", "value1");
-		assertEquals(null, map.get(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH));
-	}
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+
+    private Map<String, Object> map;
+
+    @Before
+    public void before() {
+        map = new HashMap<String, Object>();
+    }
+
+    @Test
+    public void cannotGetIterator() {
+        CamelMessagingHeadersInjectAdapter adapter = new CamelMessagingHeadersInjectAdapter(map, true);
+        thrown.expect(UnsupportedOperationException.class);
+        adapter.iterator();
+    }
+
+    @Test
+    public void putProperties() {
+        CamelMessagingHeadersInjectAdapter adapter = new CamelMessagingHeadersInjectAdapter(map, true);
+        adapter.put("key1", "value1");
+        adapter.put("key2", "value2");
+        adapter.put("key1", "value3");
+        assertEquals("value3", map.get("key1"));
+        assertEquals("value2", map.get("key2"));
+    }
+
+    @Test
+    public void propertyWithDash() {
+        CamelMessagingHeadersInjectAdapter adapter = new CamelMessagingHeadersInjectAdapter(map, true);
+        adapter.put("-key-1-", "value1");
+        assertEquals("value1", map.get(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH));
+    }
+
+    @Test
+    public void propertyWithoutDashEncoding() {
+        CamelMessagingHeadersInjectAdapter adapter = new CamelMessagingHeadersInjectAdapter(map, false);
+        adapter.put("-key-1-", "value1");
+        assertEquals(null, map.get(JMS_DASH + "key" + JMS_DASH + "1" + JMS_DASH));
+    }
 }
