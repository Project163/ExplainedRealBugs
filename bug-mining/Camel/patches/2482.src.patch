diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java
index a4dd2e075c3..0c22e75041d 100644
--- a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java
+++ b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java
@@ -393,8 +393,6 @@ public class MethodInfo {
     /**
      * Returns true if this method is covariant with the specified method
      * (this method may above or below the specified method in the class hierarchy)
-     * @param method
-     * @return
      */
     public boolean isCovariantWith(MethodInfo method) {
         return 
@@ -541,13 +539,18 @@ public class MethodInfo {
                         return Void.TYPE;
                     }
 
-                    // the parameter value was not already valid, but since the simple language have evaluated the expression
-                    // which may change the parameterValue, so we have to check it again to see if its now valid
-                    exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);
-                    // String values from the simple language is always valid
-                    if (!valid) {
-                        // re validate if the parameter was not valid the first time (String values should be accepted)
-                        valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);
+                    // the parameter value may match the expected type, then we use it as-is
+                    if (parameterType.isAssignableFrom(parameterValue.getClass())) {
+                        valid = true;
+                    } else {
+                        // the parameter value was not already valid, but since the simple language have evaluated the expression
+                        // which may change the parameterValue, so we have to check it again to see if its now valid
+                        exp = exchange.getContext().getTypeConverter().tryConvertTo(String.class, parameterValue);
+                        // String values from the simple language is always valid
+                        if (!valid) {
+                            // re validate if the parameter was not valid the first time (String values should be accepted)
+                            valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);
+                        }
                     }
 
                     if (valid) {
diff --git a/camel-core/src/test/java/org/apache/camel/component/bean/BeanWithInputStreamBodyTest.java b/camel-core/src/test/java/org/apache/camel/component/bean/BeanWithInputStreamBodyTest.java
new file mode 100644
index 00000000000..cbf88158bf0
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/component/bean/BeanWithInputStreamBodyTest.java
@@ -0,0 +1,153 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.bean;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.impl.JndiRegistry;
+
+public class BeanWithInputStreamBodyTest extends ContextTestSupport {
+
+    @Override
+    protected JndiRegistry createRegistry() throws Exception {
+        JndiRegistry jndi = super.createRegistry();
+        jndi.bind("myBean", new MyCoolBean());
+        return jndi;
+    }
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+
+    public void testBeanWithInputStreamBody() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                        .bean(MyCoolBean.class)
+                        .to("mock:result");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:result").expectedBodiesReceived("There is 11 bytes");
+
+        InputStream bais = new ByteArrayInputStream("Hello World".getBytes());
+
+        template.sendBody("direct:start", bais);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testBeanWithInputStreamBodyMethod() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                        .bean(MyCoolBean.class, "doSomething")
+                        .to("mock:result");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:result").expectedBodiesReceived("There is 11 bytes");
+
+        InputStream bais = new ByteArrayInputStream("Hello World".getBytes());
+
+        template.sendBody("direct:start", bais);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testToBeanWithInputStreamBody() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                    .to("bean:myBean")
+                    .to("mock:result");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:result").expectedBodiesReceived("There is 11 bytes");
+
+        InputStream bais = new ByteArrayInputStream("Hello World".getBytes());
+
+        template.sendBody("direct:start", bais);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testToBeanWithInputStreamBodyMethod() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                    .to("bean:myBean?method=doSomething")
+                    .to("mock:result");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:result").expectedBodiesReceived("There is 11 bytes");
+
+        InputStream bais = new ByteArrayInputStream("Hello World".getBytes());
+
+        template.sendBody("direct:start", bais);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testToBeanWithInputStreamBodyMethodOGNL() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                    .to("bean:myBean?method=doSomething(${body})")
+                    .to("mock:result");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:result").expectedBodiesReceived("There is 11 bytes");
+
+        InputStream bais = new ByteArrayInputStream("Hello World".getBytes());
+
+        template.sendBody("direct:start", bais);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public static final class MyCoolBean {
+
+        public static String doSomething(InputStream is) throws IOException {
+            int byteCount = 0;
+            int c;
+            while ((c = is.read()) != -1) {
+                byteCount++;
+            }
+            return "There is " + byteCount + " bytes";
+        }
+
+    }
+}
