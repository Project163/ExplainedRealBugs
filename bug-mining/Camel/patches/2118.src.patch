diff --git a/components/camel-netty/src/main/java/org/apache/camel/component/netty/NettyProducer.java b/components/camel-netty/src/main/java/org/apache/camel/component/netty/NettyProducer.java
index cc9d004c13f..685d8b641c1 100644
--- a/components/camel-netty/src/main/java/org/apache/camel/component/netty/NettyProducer.java
+++ b/components/camel-netty/src/main/java/org/apache/camel/component/netty/NettyProducer.java
@@ -18,10 +18,8 @@ package org.apache.camel.component.netty;
 
 import java.net.InetSocketAddress;
 import java.util.Map;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeUnit;
 
 import org.apache.camel.AsyncCallback;
 import org.apache.camel.CamelContext;
@@ -305,7 +303,7 @@ public class NettyProducer extends DefaultAsyncProducer {
         }
     }
 
-    private ChannelFuture openConnection() throws Exception {
+    protected ChannelFuture openConnection() throws Exception {
         ChannelFuture answer;
 
         if (isTcp()) {
@@ -365,20 +363,13 @@ public class NettyProducer extends DefaultAsyncProducer {
     }
 
     private Channel openChannel(ChannelFuture channelFuture) throws Exception {
-        // wait until until the operation is complete
-        final CountDownLatch latch = new CountDownLatch(1);
-        channelFuture.addListener(new ChannelFutureListener() {
-            @Override
-            public void operationComplete(ChannelFuture channelFuture) throws Exception {
-                LOG.trace("Operation complete {}", channelFuture);
-                latch.countDown();
-            }
-        });
         // blocking for channel to be done
-        LOG.trace("Waiting for operation to complete {} for {} millis", channelFuture, configuration.getConnectTimeout());
-        latch.await(configuration.getConnectTimeout(), TimeUnit.MILLISECONDS);
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Waiting for operation to complete {} for {} millis", channelFuture, configuration.getConnectTimeout());
+        }
+        channelFuture.awaitUninterruptibly(configuration.getConnectTimeout());
 
-        if (!channelFuture.isSuccess()) {
+        if (!channelFuture.isDone() || !channelFuture.isSuccess()) {
             throw new CamelException("Cannot connect to " + configuration.getAddress(), channelFuture.getCause());
         }
         Channel answer = channelFuture.getChannel();
diff --git a/components/camel-netty/src/main/java/org/apache/camel/component/netty/handlers/ClientChannelHandler.java b/components/camel-netty/src/main/java/org/apache/camel/component/netty/handlers/ClientChannelHandler.java
index a41208f0211..88b4754f951 100644
--- a/components/camel-netty/src/main/java/org/apache/camel/component/netty/handlers/ClientChannelHandler.java
+++ b/components/camel-netty/src/main/java/org/apache/camel/component/netty/handlers/ClientChannelHandler.java
@@ -50,6 +50,9 @@ public class ClientChannelHandler extends SimpleChannelUpstreamHandler {
 
     @Override
     public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent channelStateEvent) throws Exception {
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Channel open: {}", ctx.getChannel());
+        }
         // to keep track of open sockets
         producer.getAllChannels().add(channelStateEvent.getChannel());
     }
@@ -90,7 +93,9 @@ public class ClientChannelHandler extends SimpleChannelUpstreamHandler {
 
     @Override
     public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
-        LOG.trace("Channel closed: {}", ctx.getChannel());
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Channel closed: {}", ctx.getChannel());
+        }
 
         Exchange exchange = getExchange(ctx);
         AsyncCallback callback = getAsyncCallback(ctx);
@@ -98,6 +103,9 @@ public class ClientChannelHandler extends SimpleChannelUpstreamHandler {
         // remove state
         producer.removeState(ctx.getChannel());
 
+        // to keep track of open sockets
+        producer.getAllChannels().remove(ctx.getChannel());
+
         if (producer.getConfiguration().isSync() && !messageReceived && !exceptionHandled) {
             // session was closed but no message received. This could be because the remote server had an internal error
             // and could not return a response. We should count down to stop waiting for a response
