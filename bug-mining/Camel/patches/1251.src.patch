diff --git a/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java b/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java
index b7b12145a1c..8533a6af17c 100644
--- a/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java
@@ -117,9 +117,14 @@ public class MulticastDefinition extends OutputDefinition<MulticastDefinition> i
     }
 
     /**
-     * Will now stop further processing if an exception occurred during processing of an
+     * Will now stop further processing if an exception or failure occurred during processing of an
      * {@link org.apache.camel.Exchange} and the caused exception will be thrown.
      * <p/>
+     * Will also stop if processing the exchange failed (has a fault message) or an exception
+     * was thrown and handled by the error handler (such as using onException). In all situations
+     * the multicast will stop further processing. This is the same behavior as in pipeline, which
+     * is used by the routing engine.
+     * <p/>
      * The default behavior is to <b>not</b> stop but continue processing till the end
      *
      * @return the builder
diff --git a/camel-core/src/main/java/org/apache/camel/model/RecipientListDefinition.java b/camel-core/src/main/java/org/apache/camel/model/RecipientListDefinition.java
index 22da4734de6..971943a7b74 100644
--- a/camel-core/src/main/java/org/apache/camel/model/RecipientListDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/RecipientListDefinition.java
@@ -192,9 +192,14 @@ public class RecipientListDefinition<Type extends ProcessorDefinition> extends N
     }
 
     /**
-     * Will now stop further processing if an exception occurred during processing of an
+     * Will now stop further processing if an exception or failure occurred during processing of an
      * {@link org.apache.camel.Exchange} and the caused exception will be thrown.
      * <p/>
+     * Will also stop if processing the exchange failed (has a fault message) or an exception
+     * was thrown and handled by the error handler (such as using onException). In all situations
+     * the recipient list will stop further processing. This is the same behavior as in pipeline, which
+     * is used by the routing engine.
+     * <p/>
      * The default behavior is to <b>not</b> stop but continue processing till the end
      *
      * @return the builder
diff --git a/camel-core/src/main/java/org/apache/camel/model/SplitDefinition.java b/camel-core/src/main/java/org/apache/camel/model/SplitDefinition.java
index 709a0112510..e4dac0c783d 100644
--- a/camel-core/src/main/java/org/apache/camel/model/SplitDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/SplitDefinition.java
@@ -167,9 +167,14 @@ public class SplitDefinition extends ExpressionNode implements ExecutorServiceAw
     }
     
     /**
-     * Will now stop further processing if an exception occurred during processing of an
+     * Will now stop further processing if an exception or failure occurred during processing of an
      * {@link org.apache.camel.Exchange} and the caused exception will be thrown.
      * <p/>
+     * Will also stop if processing the exchange failed (has a fault message) or an exception
+     * was thrown and handled by the error handler (such as using onException). In all situations
+     * the splitter will stop further processing. This is the same behavior as in pipeline, which
+     * is used by the routing engine.
+     * <p/>
      * The default behavior is to <b>not</b> stop but continue processing till the end
      *
      * @return the builder
diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java
index fea9c415ce6..fcb8bfc1501 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java
@@ -236,15 +236,19 @@ public class MulticastProcessor extends ServiceSupport implements AsyncProcessor
 
                     try {
                         doProcessParallel(pair);
-                    } catch (Exception e) {
+                    } catch (Throwable e) {
                         subExchange.setException(e);
                     }
 
-                    // should we stop in case of an exception occurred during processing?
-                    if (stopOnException && subExchange.getException() != null) {
+                    // Decide whether to continue with the multicast or not; similar logic to the Pipeline
+                    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, "Parallel processing failed for number " + total.get(), LOG);
+                    if (stopOnException && !continueProcessing) {
+                        if (subExchange.getException() != null) {
+                            // wrap in exception to explain where it failed
+                            throw new CamelExchangeException("Parallel processing failed for number " + total.get(), subExchange, subExchange.getException());
+                        }
                         // signal to stop running
                         running.set(false);
-                        throw new CamelExchangeException("Parallel processing failed for number " + total.intValue(), subExchange, subExchange.getException());
                     }
 
                     if (LOG.isTraceEnabled()) {
@@ -261,6 +265,7 @@ public class MulticastProcessor extends ServiceSupport implements AsyncProcessor
         // its to hard to do parallel async routing so we let the caller thread be synchronously
         // and have it pickup the replies and do the aggregation
         boolean timedOut = false;
+        boolean stoppedOnException = false;
         final StopWatch watch = new StopWatch();
         for (int i = 0; i < total.intValue(); i++) {
             Future<Exchange> future;
@@ -305,17 +310,33 @@ public class MulticastProcessor extends ServiceSupport implements AsyncProcessor
                 }
                 timedOut = true;
             } else {
-                // we got a result so aggregate it
+                // there is a result to aggregate
                 Exchange subExchange = future.get();
+
+                // Decide whether to continue with the multicast or not; similar logic to the Pipeline
+                boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, "Parallel processing failed for number " + total.get(), LOG);
+                if (stopOnException && !continueProcessing) {
+                    // we want to stop on exception and an exception or failure occurred
+                    // this is similar to what the pipeline does, so we should do the same to not surprise end users
+                    // so we should set the failed exchange as the result and break out
+                    result.set(subExchange);
+                    stoppedOnException = true;
+                    break;
+                }
+
+                // we got a result so aggregate it
                 AggregationStrategy strategy = getAggregationStrategy(subExchange);
                 doAggregate(strategy, result, subExchange);
             }
         }
 
-        if (timedOut) {
-            if (LOG.isDebugEnabled()) {
+        if (timedOut || stoppedOnException) {
+            if (timedOut && LOG.isDebugEnabled()) {
                 LOG.debug("Cancelling future tasks due timeout after " + timeout + " millis.");
             }
+            if (stoppedOnException && LOG.isDebugEnabled()) {
+                LOG.debug("Cancelling future tasks due stopOnException.");
+            }
             // cancel tasks as we timed out (its safe to cancel done tasks)
             for (Future future : tasks) {
                 future.cancel(true);
@@ -350,9 +371,20 @@ public class MulticastProcessor extends ServiceSupport implements AsyncProcessor
                 LOG.trace("Processing exchangeId: " + pair.getExchange().getExchangeId() + " is continued being processed synchronously");
             }
 
-            // should we stop in case of an exception occurred during processing?
-            if (stopOnException && subExchange.getException() != null) {
-                throw new CamelExchangeException("Sequential processing failed for number " + total.get(), subExchange, subExchange.getException());
+            // Decide whether to continue with the multicast or not; similar logic to the Pipeline
+            // remember to test for stop on exception and aggregate before copying back results
+            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, "Sequential processing failed for number " + total.get(), LOG);
+            if (stopOnException && !continueProcessing) {
+                if (subExchange.getException() != null) {
+                    // wrap in exception to explain where it failed
+                    throw new CamelExchangeException("Sequential processing failed for number " + total.get(), subExchange, subExchange.getException());
+                } else {
+                    // we want to stop on exception, and the exception was handled by the error handler
+                    // this is similar to what the pipeline does, so we should do the same to not surprise end users
+                    // so we should set the failed exchange as the result and be done
+                    result.set(subExchange);
+                    return true;
+                }
             }
 
             if (LOG.isTraceEnabled()) {
@@ -409,10 +441,19 @@ public class MulticastProcessor extends ServiceSupport implements AsyncProcessor
                     // continue processing the multicast asynchronously
                     Exchange subExchange = exchange;
 
+                    // Decide whether to continue with the multicast or not; similar logic to the Pipeline
                     // remember to test for stop on exception and aggregate before copying back results
-                    if (stopOnException && subExchange.getException() != null) {
-                        // wrap in exception to explain where it failed
-                        subExchange.setException(new CamelExchangeException("Sequential processing failed for number " + total, subExchange, subExchange.getException()));
+                    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, "Sequential processing failed for number " + total.get(), LOG);
+                    if (stopOnException && !continueProcessing) {
+                        if (subExchange.getException() != null) {
+                            // wrap in exception to explain where it failed
+                            subExchange.setException(new CamelExchangeException("Sequential processing failed for number " + total, subExchange, subExchange.getException()));
+                        } else {
+                            // we want to stop on exception, and the exception was handled by the error handler
+                            // this is similar to what the pipeline does, so we should do the same to not surprise end users
+                            // so we should set the failed exchange as the result and be done
+                            result.set(subExchange);
+                        }
                         // and do the done work
                         doDone(original, subExchange, callback, false);
                         return;
@@ -446,9 +487,19 @@ public class MulticastProcessor extends ServiceSupport implements AsyncProcessor
                             return;
                         }
 
-                        if (stopOnException && subExchange.getException() != null) {
-                            // wrap in exception to explain where it failed
-                            subExchange.setException(new CamelExchangeException("Sequential processing failed for number " + total, subExchange, subExchange.getException()));
+                        // Decide whether to continue with the multicast or not; similar logic to the Pipeline
+                        // remember to test for stop on exception and aggregate before copying back results
+                        continueProcessing = PipelineHelper.continueProcessing(subExchange, "Sequential processing failed for number " + total.get(), LOG);
+                        if (stopOnException && !continueProcessing) {
+                            if (subExchange.getException() != null) {
+                                // wrap in exception to explain where it failed
+                                subExchange.setException(new CamelExchangeException("Sequential processing failed for number " + total, subExchange, subExchange.getException()));
+                            } else {
+                                // we want to stop on exception, and the exception was handled by the error handler
+                                // this is similar to what the pipeline does, so we should do the same to not surprise end users
+                                // so we should set the failed exchange as the result and be done
+                                result.set(subExchange);
+                            }
                             // and do the done work
                             doDone(original, subExchange, callback, false);
                             return;
diff --git a/camel-core/src/main/java/org/apache/camel/processor/PipelineHelper.java b/camel-core/src/main/java/org/apache/camel/processor/PipelineHelper.java
index 47d0f436d96..afd453653bc 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/PipelineHelper.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/PipelineHelper.java
@@ -19,6 +19,8 @@ package org.apache.camel.processor;
 import org.apache.camel.Exchange;
 import org.apache.commons.logging.Log;
 
+import static org.apache.camel.util.ExchangeHelper.hasExceptionBeenHandledByErrorHandler;
+
 /**
  * Helper for processing {@link org.apache.camel.Exchange} in a
  * <a href="http://camel.apache.org/pipes-and-filters.html">pipeline</a>.
@@ -30,10 +32,6 @@ public final class PipelineHelper {
     private PipelineHelper() {
     }
 
-    private static boolean hasExceptionBeenHandledByErrorHandler(Exchange nextExchange) {
-        return Boolean.TRUE.equals(nextExchange.getProperty(Exchange.ERRORHANDLER_HANDLED));
-    }
-
     /**
      * Should we continue processing the next exchange?
      *
diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/UseLatestAggregationStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/UseLatestAggregationStrategy.java
index 0c478c62f57..e662f473be3 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/UseLatestAggregationStrategy.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/UseLatestAggregationStrategy.java
@@ -18,6 +18,8 @@ package org.apache.camel.processor.aggregate;
 
 import org.apache.camel.Exchange;
 
+import static org.apache.camel.util.ExchangeHelper.hasExceptionBeenHandledByErrorHandler;
+
 /**
  * An {@link AggregationStrategy} which just uses the latest exchange which is useful
  * for status messages where old status messages have no real value. Another example is things
@@ -31,18 +33,50 @@ public class UseLatestAggregationStrategy implements AggregationStrategy {
         if (newExchange == null) {
             return oldExchange;
         }
-        newExchange.setException(checkException(oldExchange, newExchange));
-        return newExchange;
+        if (oldExchange == null) {
+            return newExchange;
+        }
+
+        Exchange answer = null;
+
+        // propagate exception first
+        propagateException(oldExchange, newExchange);
+        if (newExchange.getException() != null) {
+            answer = newExchange;
+        }
+
+        if (answer == null) {
+            // the propagate failures
+            answer = propagateFailure(oldExchange, newExchange);
+        }
+
+        return answer;
     }
     
-    protected Exception checkException(Exchange oldExchange, Exchange newExchange) {
+    protected void propagateException(Exchange oldExchange, Exchange newExchange) {
         if (oldExchange == null) {
-            return newExchange.getException();
-        } else {
-            return (newExchange != null && newExchange.getException() != null)
-                ? newExchange.getException()
-                : oldExchange.getException();
+            return;
         }
+
+        // propagate exception from old exchange if there isn't already an exception
+        if (newExchange.getException() == null) {
+            newExchange.setException(oldExchange.getException());
+        }
+    }
+
+    protected Exchange propagateFailure(Exchange oldExchange, Exchange newExchange) {
+        if (oldExchange == null) {
+            return newExchange;
+        }
+
+        // propagate exception from old exchange if there isn't already an exception
+        boolean exceptionHandled = hasExceptionBeenHandledByErrorHandler(oldExchange);
+        if (oldExchange.isFailed() || oldExchange.isRollbackOnly() || exceptionHandled) {
+            // propagate failure by using old exchange as the answer
+            return oldExchange;
+        }
+
+        return newExchange;
     }
 
     @Override
diff --git a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java
index 0baae436afc..03ce98e0c8a 100644
--- a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java
+++ b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java
@@ -494,6 +494,16 @@ public final class ExchangeHelper {
         return exchange.hasOut() && exchange.getOut().isFault() && exchange.getOut().getBody() != null;
     }
 
+    /**
+     * Tests whether the exchange has already been handled by the error handler
+     *
+     * @param exchange the exchange
+     * @return <tt>true</tt> if handled already by error handler, <tt>false</tt> otherwise
+     */
+    public static boolean hasExceptionBeenHandledByErrorHandler(Exchange exchange) {
+        return Boolean.TRUE.equals(exchange.getProperty(Exchange.ERRORHANDLER_HANDLED));
+    }
+
     /**
      * Extracts the body from the given future, that represents a handle to an asynchronous exchange.
      * <p/>
diff --git a/camel-core/src/test/java/org/apache/camel/issues/MulticastParallelStopOnExceptionWithOnExceptionIssueTest.java b/camel-core/src/test/java/org/apache/camel/issues/MulticastParallelStopOnExceptionWithOnExceptionIssueTest.java
new file mode 100644
index 00000000000..69aad5b2e94
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/issues/MulticastParallelStopOnExceptionWithOnExceptionIssueTest.java
@@ -0,0 +1,68 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.issues;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+
+/**
+ * @version $Revision$
+ */
+public class MulticastParallelStopOnExceptionWithOnExceptionIssueTest extends MulticastStopOnExceptionWithOnExceptionIssueTest {
+
+    public void testEnd1FailureTest() throws Exception {
+        MockEndpoint end1 = getMockEndpoint("mock:end1");
+        end1.whenAnyExchangeReceived(new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                throw new RuntimeException("Simulated Exception");
+            }
+        });
+
+        // we run in parallel so the task could have been submitted so we either get 0 or 1 messages at mock:end2
+        getMockEndpoint("mock:end2").expectedMinimumMessageCount(0);
+        getMockEndpoint("mock:end3").expectedMessageCount(0);
+        getMockEndpoint("mock:end4").expectedMessageCount(1);
+
+        String result = template.requestBody("direct:start", "Hello World!", String.class);
+        assertEquals("Stop!", result);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("log:onException")
+                    .to("mock:end4")    
+                    .transform(constant("Stop!"));
+
+                from("direct:start")
+                    .multicast().parallelProcessing().stopOnException()
+                        .to("mock:end1", "mock:end2")
+                    .end()
+                    .to("mock:end3")
+                    .transform(constant("Hello to you too!"));
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/issues/MulticastParallelWithOnExceptionIssueTest.java b/camel-core/src/test/java/org/apache/camel/issues/MulticastParallelWithOnExceptionIssueTest.java
new file mode 100644
index 00000000000..add8326f805
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/issues/MulticastParallelWithOnExceptionIssueTest.java
@@ -0,0 +1,46 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.issues;
+
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision$
+ */
+public class MulticastParallelWithOnExceptionIssueTest extends MulticastWithOnExceptionIssueTest {
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("log:onException")
+                    .to("mock:end4")    
+                    .transform(constant("Stop!"));
+
+                from("direct:start")
+                    .multicast().parallelProcessing()
+                        .to("mock:end1", "mock:end2")
+                    .end()
+                    .to("mock:end3")
+                    .transform(constant("Hello to you too!"));
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/issues/MulticastStopOnExceptionWithOnExceptionIssueTest.java b/camel-core/src/test/java/org/apache/camel/issues/MulticastStopOnExceptionWithOnExceptionIssueTest.java
new file mode 100644
index 00000000000..2685739ef64
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/issues/MulticastStopOnExceptionWithOnExceptionIssueTest.java
@@ -0,0 +1,116 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.issues;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+
+/**
+ * @version $Revision$
+ */
+public class MulticastStopOnExceptionWithOnExceptionIssueTest extends ContextTestSupport {
+
+    public void testEnd1FailureTest() throws Exception {
+        MockEndpoint end1 = getMockEndpoint("mock:end1");
+        end1.whenAnyExchangeReceived(new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                throw new RuntimeException("Simulated Exception");
+            }
+        });
+
+        getMockEndpoint("mock:end2").expectedMessageCount(0);
+        getMockEndpoint("mock:end3").expectedMessageCount(0);
+        getMockEndpoint("mock:end4").expectedMessageCount(1);
+
+        String result = template.requestBody("direct:start", "Hello World!", String.class);
+        assertEquals("Stop!", result);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testEnd2FailureTest() throws Exception {
+        MockEndpoint end2 = getMockEndpoint("mock:end2");
+        end2.whenAnyExchangeReceived(new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                throw new RuntimeException("Simulated Exception");
+            }
+        });
+
+        getMockEndpoint("mock:end1").expectedMessageCount(1);
+        getMockEndpoint("mock:end3").expectedMessageCount(0);
+        getMockEndpoint("mock:end4").expectedMessageCount(1);
+
+        String result = template.requestBody("direct:start", "Hello World!", String.class);
+        assertEquals("Stop!", result);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testEnd3FailureTest() throws Exception {
+        MockEndpoint end3 = getMockEndpoint("mock:end3");
+        end3.whenAnyExchangeReceived(new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                throw new RuntimeException("Simulated Exception");
+            }
+        });
+
+        getMockEndpoint("mock:end1").expectedMessageCount(1);
+        getMockEndpoint("mock:end2").expectedMessageCount(1);
+        getMockEndpoint("mock:end4").expectedMessageCount(1);
+
+        String result = template.requestBody("direct:start", "Hello World!", String.class);
+        assertEquals("Stop!", result);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOK() throws Exception {
+        getMockEndpoint("mock:end1").expectedMessageCount(1);
+        getMockEndpoint("mock:end2").expectedMessageCount(1);
+        getMockEndpoint("mock:end3").expectedMessageCount(1);
+        getMockEndpoint("mock:end4").expectedMessageCount(0);
+
+        String result = template.requestBody("direct:start", "Hello World!", String.class);
+        assertEquals("Hello to you too!", result);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("log:onException")
+                    .to("mock:end4")    
+                    .transform(constant("Stop!"));
+
+                from("direct:start")
+                    .multicast().stopOnException()
+                        .to("mock:end1", "mock:end2")
+                    .end()
+                    .to("mock:end3")
+                    .transform(constant("Hello to you too!"));
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/issues/MulticastWithOnExceptionIssueTest.java b/camel-core/src/test/java/org/apache/camel/issues/MulticastWithOnExceptionIssueTest.java
new file mode 100644
index 00000000000..22974991b31
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/issues/MulticastWithOnExceptionIssueTest.java
@@ -0,0 +1,116 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.issues;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+
+/**
+ * @version $Revision$
+ */
+public class MulticastWithOnExceptionIssueTest extends ContextTestSupport {
+
+    public void testEnd1FailureTest() throws Exception {
+        MockEndpoint end1 = getMockEndpoint("mock:end1");
+        end1.whenAnyExchangeReceived(new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                throw new RuntimeException("Simulated Exception");
+            }
+        });
+
+        getMockEndpoint("mock:end2").expectedMessageCount(1);
+        getMockEndpoint("mock:end3").expectedMessageCount(0);
+        getMockEndpoint("mock:end4").expectedMessageCount(1);
+
+        String result = template.requestBody("direct:start", "Hello World!", String.class);
+        assertEquals("Stop!", result);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testEnd2FailureTest() throws Exception {
+        MockEndpoint end2 = getMockEndpoint("mock:end2");
+        end2.whenAnyExchangeReceived(new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                throw new RuntimeException("Simulated Exception");
+            }
+        });
+
+        getMockEndpoint("mock:end1").expectedMessageCount(1);
+        getMockEndpoint("mock:end3").expectedMessageCount(0);
+        getMockEndpoint("mock:end4").expectedMessageCount(1);
+
+        String result = template.requestBody("direct:start", "Hello World!", String.class);
+        assertEquals("Stop!", result);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testEnd3FailureTest() throws Exception {
+        MockEndpoint end3 = getMockEndpoint("mock:end3");
+        end3.whenAnyExchangeReceived(new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                throw new RuntimeException("Simulated Exception");
+            }
+        });
+
+        getMockEndpoint("mock:end1").expectedMessageCount(1);
+        getMockEndpoint("mock:end2").expectedMessageCount(1);
+        getMockEndpoint("mock:end4").expectedMessageCount(1);
+
+        String result = template.requestBody("direct:start", "Hello World!", String.class);
+        assertEquals("Stop!", result);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOK() throws Exception {
+        getMockEndpoint("mock:end1").expectedMessageCount(1);
+        getMockEndpoint("mock:end2").expectedMessageCount(1);
+        getMockEndpoint("mock:end3").expectedMessageCount(1);
+        getMockEndpoint("mock:end4").expectedMessageCount(0);
+
+        String result = template.requestBody("direct:start", "Hello World!", String.class);
+        assertEquals("Hello to you too!", result);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("log:onException")
+                    .to("mock:end4")    
+                    .transform(constant("Stop!"));
+
+                from("direct:start")
+                    .multicast()
+                        .to("mock:end1", "mock:end2")
+                    .end()
+                    .to("mock:end3")
+                    .transform(constant("Hello to you too!"));
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionLastWithOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionLastWithOnExceptionTest.java
new file mode 100644
index 00000000000..3bff5132612
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionLastWithOnExceptionTest.java
@@ -0,0 +1,64 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision: 891253 $
+ */
+public class MulticastStopOnExceptionLastWithOnExceptionTest extends MulticastStopOnExceptionWithOnExceptionTest {
+
+    public void testMulticastStopOnExceptionStop() throws Exception {
+        getMockEndpoint("mock:foo").expectedBodiesReceived("Kaboom");
+        getMockEndpoint("mock:baz").expectedBodiesReceived("Kaboom");
+        getMockEndpoint("mock:bar").expectedMessageCount(0);
+        getMockEndpoint("mock:handled").expectedMessageCount(1);
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+
+        String out = template.requestBody("direct:start", "Kaboom", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("mock:handled")
+                    .transform(simple("Damn ${exception.message}"));
+
+                from("direct:start")
+                    .multicast()
+                        .stopOnException().to("direct:foo", "direct:baz", "direct:bar")
+                    .end()
+                    .to("mock:result");
+
+                from("direct:foo").to("mock:foo");
+
+                from("direct:bar").process(new MyProcessor()).to("mock:bar");
+
+                from("direct:baz").to("mock:baz");
+            }
+        };
+    }
+
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionWithOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionWithOnExceptionTest.java
new file mode 100644
index 00000000000..74f19df90a4
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionWithOnExceptionTest.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision$
+ */
+public class MulticastStopOnExceptionWithOnExceptionTest extends ContextTestSupport {
+
+    public void testMulticastStopOnExceptionOk() throws Exception {
+        getMockEndpoint("mock:foo").expectedBodiesReceived("Hello");
+        getMockEndpoint("mock:bar").expectedBodiesReceived("Hello");
+        getMockEndpoint("mock:baz").expectedBodiesReceived("Hello");
+        getMockEndpoint("mock:handled").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedBodiesReceived("Hello");
+
+        template.sendBody("direct:start", "Hello");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testMulticastStopOnExceptionStop() throws Exception {
+        getMockEndpoint("mock:foo").expectedBodiesReceived("Kaboom");
+        getMockEndpoint("mock:bar").expectedMessageCount(0);
+        getMockEndpoint("mock:handled").expectedMessageCount(1);
+        // we do stop so we should NOT continue and thus baz do not receive any message
+        getMockEndpoint("mock:baz").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+
+        String out = template.requestBody("direct:start", "Kaboom", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("mock:handled")
+                    .transform(simple("Damn ${exception.message}"));
+
+                from("direct:start")
+                    .multicast()
+                        .stopOnException().to("direct:foo", "direct:bar", "direct:baz")
+                    .end()
+                    .to("mock:result");
+
+                from("direct:foo").to("mock:foo");
+
+                from("direct:bar").process(new MyProcessor()).to("mock:bar");
+
+                from("direct:baz").to("mock:baz");
+            }
+        };
+    }
+
+    public static class MyProcessor implements Processor {
+
+        public void process(Exchange exchange) throws Exception {
+            String body = exchange.getIn().getBody(String.class);
+            if ("Kaboom".equals(body)) {
+                throw new IllegalArgumentException("Forced");
+            }
+        }
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastWithOnExceptionFirstTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastWithOnExceptionFirstTest.java
new file mode 100644
index 00000000000..0d8140a3dd7
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastWithOnExceptionFirstTest.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision: 891253 $
+ */
+public class MulticastWithOnExceptionFirstTest extends MulticastWithOnExceptionTest {
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("mock:handled")
+                    .transform(simple("Damn ${exception.message}"));
+
+                from("direct:start")
+                    .multicast()
+                        .to("direct:bar", "direct:foo", "direct:baz")
+                    .end()
+                    .to("mock:result");
+
+                from("direct:foo").to("mock:foo");
+
+                from("direct:bar").process(new MyProcessor()).to("mock:bar");
+
+                from("direct:baz").to("mock:baz");
+            }
+        };
+    }
+
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastWithOnExceptionLastTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastWithOnExceptionLastTest.java
new file mode 100644
index 00000000000..320f53d9644
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastWithOnExceptionLastTest.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision: 891253 $
+ */
+public class MulticastWithOnExceptionLastTest extends MulticastWithOnExceptionTest {
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("mock:handled")
+                    .transform(simple("Damn ${exception.message}"));
+
+                from("direct:start")
+                    .multicast()
+                        .to("direct:foo", "direct:baz", "direct:bar")
+                    .end()
+                    .to("mock:result");
+
+                from("direct:foo").to("mock:foo");
+
+                from("direct:bar").process(new MyProcessor()).to("mock:bar");
+
+                from("direct:baz").to("mock:baz");
+            }
+        };
+    }
+
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastWithOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastWithOnExceptionTest.java
new file mode 100644
index 00000000000..7635db2936b
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastWithOnExceptionTest.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision: 891253 $
+ */
+public class MulticastWithOnExceptionTest extends ContextTestSupport {
+
+    public void testMulticastOk() throws Exception {
+        getMockEndpoint("mock:foo").expectedBodiesReceived("Hello");
+        getMockEndpoint("mock:bar").expectedBodiesReceived("Hello");
+        getMockEndpoint("mock:baz").expectedBodiesReceived("Hello");
+        getMockEndpoint("mock:handled").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedBodiesReceived("Hello");
+
+        template.sendBody("direct:start", "Hello");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testMulticastFail() throws Exception {
+        getMockEndpoint("mock:foo").expectedBodiesReceived("Kaboom");
+        getMockEndpoint("mock:baz").expectedBodiesReceived("Kaboom");
+        getMockEndpoint("mock:bar").expectedMessageCount(0);
+        getMockEndpoint("mock:handled").expectedMessageCount(1);
+        // should not go to result after multicast as there was a failure
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+
+        String out = template.requestBody("direct:start", "Kaboom", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("mock:handled")
+                    .transform(simple("Damn ${exception.message}"));
+
+                from("direct:start")
+                    .multicast()
+                        .to("direct:foo", "direct:bar", "direct:baz")
+                    .end()
+                    .to("mock:result");
+
+                from("direct:foo").to("mock:foo");
+
+                from("direct:bar").process(new MyProcessor()).to("mock:bar");
+
+                from("direct:baz").to("mock:baz");
+            }
+        };
+    }
+
+    public static class MyProcessor implements Processor {
+
+        public void process(Exchange exchange) throws Exception {
+            String body = exchange.getIn().getBody(String.class);
+            if ("Kaboom".equals(body)) {
+                throw new IllegalArgumentException("Forced");
+            }
+        }
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/RecipientListParallelStopOnExceptionWithOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/RecipientListParallelStopOnExceptionWithOnExceptionTest.java
new file mode 100644
index 00000000000..755ba26ba1f
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/RecipientListParallelStopOnExceptionWithOnExceptionTest.java
@@ -0,0 +1,60 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision: 887262 $
+ */
+public class RecipientListParallelStopOnExceptionWithOnExceptionTest extends ContextTestSupport {
+
+    public void testRecipientListStopOnException() throws Exception {
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:b").expectedMessageCount(1);
+        // we run parallel so the tasks could haven been processed so we get 0 or more messages
+        getMockEndpoint("mock:a").expectedMinimumMessageCount(0);
+        getMockEndpoint("mock:c").expectedMinimumMessageCount(0);
+
+        String out = template.requestBodyAndHeader("direct:start", "Hello World", "foo", "direct:a,direct:b,direct:c", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("mock:handled")
+                    .transform(simple("Damn ${exception.message}"));
+
+                from("direct:start")
+                    .recipientList(header("foo")).stopOnException().parallelProcessing()
+                    .to("mock:result");
+
+                from("direct:a").to("mock:a");
+                from("direct:b").to("mock:b").throwException(new IllegalArgumentException("Forced"));
+                from("direct:c").to("mock:c");
+            }
+        };
+    }
+}
\ No newline at end of file
diff --git a/camel-core/src/test/java/org/apache/camel/processor/RecipientListStopOnExceptionWithOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/RecipientListStopOnExceptionWithOnExceptionTest.java
new file mode 100644
index 00000000000..192bdb87f5b
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/RecipientListStopOnExceptionWithOnExceptionTest.java
@@ -0,0 +1,59 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision$
+ */
+public class RecipientListStopOnExceptionWithOnExceptionTest extends ContextTestSupport {
+
+    public void testRecipientListStopOnException() throws Exception {
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:b").expectedMessageCount(1);
+        getMockEndpoint("mock:c").expectedMessageCount(0);
+
+        String out = template.requestBodyAndHeader("direct:start", "Hello World", "foo", "direct:a,direct:b,direct:c", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("mock:handled")
+                    .transform(simple("Damn ${exception.message}"));
+
+                from("direct:start")
+                    .recipientList(header("foo")).stopOnException()
+                    .to("mock:result");
+
+                from("direct:a").to("mock:a");
+                from("direct:b").to("mock:b").throwException(new IllegalArgumentException("Forced"));
+                from("direct:c").to("mock:c");
+            }
+        };
+    }
+}
\ No newline at end of file
diff --git a/camel-core/src/test/java/org/apache/camel/processor/SplitterParallelStopOnExceptionWithOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/SplitterParallelStopOnExceptionWithOnExceptionTest.java
new file mode 100644
index 00000000000..7e948a96dce
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/SplitterParallelStopOnExceptionWithOnExceptionTest.java
@@ -0,0 +1,100 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+
+/**
+ * @version $Revision: 891253 $
+ */
+public class SplitterParallelStopOnExceptionWithOnExceptionTest extends ContextTestSupport {
+
+    public void testSplitStopOnExceptionOk() throws Exception {
+        MockEndpoint mock = getMockEndpoint("mock:split");
+        mock.expectedBodiesReceivedInAnyOrder("Hello World", "Bye World");
+        getMockEndpoint("mock:handled").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World,Bye World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testSplitStopOnExceptionStop1() throws Exception {
+        // we run parallel so the tasks could haven been processed so we get 0 or more messages
+        getMockEndpoint("mock:split").expectedMinimumMessageCount(0);
+        getMockEndpoint("mock:handled").expectedMessageCount(1);
+
+        String out = template.requestBody("direct:start", "Kaboom,Hello World,Bye World", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testSplitStopOnExceptionStop2() throws Exception {
+        // we run parallel so the tasks could haven been processed so we get 0 or more messages
+        getMockEndpoint("mock:split").expectedMinimumMessageCount(0);
+        getMockEndpoint("mock:handled").expectedMessageCount(1);
+
+        String out = template.requestBody("direct:start", "Hello World,Kaboom,Bye World", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testSplitStopOnExceptionStop3() throws Exception {
+        // we run parallel so the tasks could haven been processed so we get 0 or more messages
+        getMockEndpoint("mock:split").expectedMinimumMessageCount(0);
+        getMockEndpoint("mock:handled").expectedMessageCount(1);
+
+        String out = template.requestBody("direct:start", "Hello World,Bye World,Kaboom", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("mock:handled")
+                    .transform(simple("Damn ${exception.message}"));
+
+                from("direct:start")
+                    .split(body().tokenize(",")).stopOnException().parallelProcessing()
+                        .process(new MyProcessor())
+                        .to("mock:split");
+            }
+        };
+    }
+
+    public static class MyProcessor implements Processor {
+
+        public void process(Exchange exchange) throws Exception {
+            String body = exchange.getIn().getBody(String.class);
+            if ("Kaboom".equals(body)) {
+                throw new IllegalArgumentException("Forced");
+            }
+        }
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/SplitterStopOnExceptionWithOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/SplitterStopOnExceptionWithOnExceptionTest.java
new file mode 100644
index 00000000000..f743089cbdb
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/SplitterStopOnExceptionWithOnExceptionTest.java
@@ -0,0 +1,102 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+
+/**
+ * @version $Revision$
+ */
+public class SplitterStopOnExceptionWithOnExceptionTest extends ContextTestSupport {
+
+    public void testSplitStopOnExceptionOk() throws Exception {
+        MockEndpoint mock = getMockEndpoint("mock:split");
+        mock.expectedBodiesReceived("Hello World", "Bye World");
+        getMockEndpoint("mock:handled").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World,Bye World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testSplitStopOnExceptionStop1() throws Exception {
+        // we do stop so we stop splitting when the exception occurs and thus we wont receive any message
+        getMockEndpoint("mock:split").expectedMessageCount(0);
+        getMockEndpoint("mock:handled").expectedMessageCount(1);
+
+        String out = template.requestBody("direct:start", "Kaboom,Hello World,Bye World", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testSplitStopOnExceptionStop2() throws Exception {
+        MockEndpoint mock = getMockEndpoint("mock:split");
+        // we do stop so we stop splitting when the exception occurs and thus we only receive 1 message
+        mock.expectedBodiesReceived("Hello World");
+        getMockEndpoint("mock:handled").expectedMessageCount(1);
+
+        String out = template.requestBody("direct:start", "Hello World,Kaboom,Bye World", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testSplitStopOnExceptionStop3() throws Exception {
+        MockEndpoint mock = getMockEndpoint("mock:split");
+        // we do stop so we stop splitting when the exception occurs and thus we only receive 2 message
+        mock.expectedBodiesReceived("Hello World", "Bye World");
+        getMockEndpoint("mock:handled").expectedMessageCount(1);
+
+        String out = template.requestBody("direct:start", "Hello World,Bye World,Kaboom", String.class);
+        assertEquals("Damn Forced", out);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class)
+                    .handled(true)
+                    .to("mock:handled")
+                    .transform(simple("Damn ${exception.message}"));
+
+                from("direct:start")
+                    .split(body().tokenize(",")).stopOnException()
+                        .process(new MyProcessor())
+                        .to("mock:split");
+            }
+        };
+    }
+
+    public static class MyProcessor implements Processor {
+
+        public void process(Exchange exchange) throws Exception {
+            String body = exchange.getIn().getBody(String.class);
+            if ("Kaboom".equals(body)) {
+                throw new IllegalArgumentException("Forced");
+            }
+        }
+    }
+}
