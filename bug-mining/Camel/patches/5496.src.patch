diff --git a/components/camel-bean/src/main/java/org/apache/camel/component/bean/MethodInfo.java b/components/camel-bean/src/main/java/org/apache/camel/component/bean/MethodInfo.java
index 264317920db..70d911092c2 100644
--- a/components/camel-bean/src/main/java/org/apache/camel/component/bean/MethodInfo.java
+++ b/components/camel-bean/src/main/java/org/apache/camel/component/bean/MethodInfo.java
@@ -671,13 +671,16 @@ public class MethodInfo {
                 if (parameterType.isAssignableFrom(parameterValue.getClass())) {
                     valid = true;
                 } else {
-                    // the parameter value was not already valid, but since the simple language have evaluated the expression
-                    // which may change the parameterValue, so we have to check it again to see if its now valid
-                    exp = exchange.getContext().getTypeConverter().tryConvertTo(String.class, parameterValue);
                     // String values from the simple language is always valid
                     if (!valid) {
-                        // re validate if the parameter was not valid the first time (String values should be accepted)
-                        valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);
+                        valid = parameterValue instanceof String;
+                        if (!valid) {
+                            // the parameter value was not already valid, but since the simple language have evaluated the expression
+                            // which may change the parameterValue, so we have to check it again to see if its now valid
+                            exp = exchange.getContext().getTypeConverter().tryConvertTo(String.class, parameterValue);
+                            // re validate if the parameter was not valid the first time
+                            valid = BeanHelper.isValidParameterValue(exp);
+                        }
                     }
                 }
 
@@ -686,22 +689,20 @@ public class MethodInfo {
                     if (parameterValue instanceof String) {
                         parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);
                     }
-                    if (parameterValue != null) {
-                        try {
-                            // its a valid parameter value, so convert it to the expected type of the parameter
-                            answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange,
-                                    parameterValue);
-                            if (LOG.isTraceEnabled()) {
-                                LOG.trace("Parameter #{} evaluated as: {} type: {}", index, answer,
-                                        org.apache.camel.util.ObjectHelper.type(answer));
-                            }
-                        } catch (Exception e) {
-                            if (LOG.isDebugEnabled()) {
-                                LOG.debug("Cannot convert from type: {} to type: {} for parameter #{}",
-                                        org.apache.camel.util.ObjectHelper.type(parameterValue), parameterType, index);
-                            }
-                            throw new ParameterBindingException(e, method, index, parameterType, parameterValue);
+                    try {
+                        // its a valid parameter value, so convert it to the expected type of the parameter
+                        answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange,
+                                parameterValue);
+                        if (LOG.isTraceEnabled()) {
+                            LOG.trace("Parameter #{} evaluated as: {} type: {}", index, answer,
+                                    org.apache.camel.util.ObjectHelper.type(answer));
+                        }
+                    } catch (Exception e) {
+                        if (LOG.isDebugEnabled()) {
+                            LOG.debug("Cannot convert from type: {} to type: {} for parameter #{}",
+                                    org.apache.camel.util.ObjectHelper.type(parameterValue), parameterType, index);
                         }
+                        throw new ParameterBindingException(e, method, index, parameterType, parameterValue);
                     }
                 }
             }
diff --git a/core/camel-core/src/test/java/org/apache/camel/language/simple/SimpleInheritanceIssueTest.java b/core/camel-core/src/test/java/org/apache/camel/language/simple/SimpleInheritanceIssueTest.java
new file mode 100644
index 00000000000..ca3e4721f45
--- /dev/null
+++ b/core/camel-core/src/test/java/org/apache/camel/language/simple/SimpleInheritanceIssueTest.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.language.simple;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.Scanner;
+
+import org.apache.camel.Expression;
+import org.apache.camel.LanguageTestSupport;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+public class SimpleInheritanceIssueTest extends LanguageTestSupport {
+
+    @Override
+    protected String getLanguageName() {
+        return "simple";
+    }
+
+    @Test
+    public void testMethodCall() throws Exception {
+        MySingleParser parser = new MySingleParser();
+        exchange.getIn().setBody(parser);
+
+        Expression expression = context.resolveLanguage("simple").createExpression("${body.parse('data')}");
+        String result = expression.evaluate(exchange, String.class);
+        assertEquals("data", result);
+    }
+
+    @Test
+    public void testMethodCallHeader() throws Exception {
+        MySingleParser parser = new MySingleParser();
+        exchange.getIn().setBody(parser);
+        // the input stream should only be read once so we should get the byte array
+        ByteArrayInputStream bais = new ByteArrayInputStream("data".getBytes());
+        exchange.getIn().setHeader("input", bais);
+
+        Expression expression = context.resolveLanguage("simple").createExpression("${body.parse(${header.input})}");
+        String result = expression.evaluate(exchange, String.class);
+        assertEquals("data", result);
+    }
+
+    @Test
+    @Disabled
+    public void testMethodCallOverloaded() throws Exception {
+        MyParser parser = new MyParser();
+        exchange.getIn().setBody(parser);
+
+        Expression expression = context.resolveLanguage("simple").createExpression("${body.parse('data')}");
+        String result = expression.evaluate(exchange, String.class);
+        assertEquals("data", result);
+    }
+
+    @Test
+    @Disabled
+    public void testMethodCallOverloadedHeader() throws Exception {
+        MyParser parser = new MyParser();
+        exchange.getIn().setBody(parser);
+        // the input stream should only be read once so we should get the byte array
+        ByteArrayInputStream bais = new ByteArrayInputStream("data".getBytes());
+        exchange.getIn().setHeader("input", bais);
+
+        Expression expression = context.resolveLanguage("simple").createExpression("${body.parse(${header.input})}");
+        String result = expression.evaluate(exchange, String.class);
+        assertEquals("data", result);
+    }
+
+    public static class MySingleParser {
+
+        public String parse(byte[] input) {
+            return new String(input);
+        }
+
+    }
+
+    public static class MyParser {
+
+        public String parse(byte[] input) {
+            return new String(input);
+        }
+
+        public String parse(InputStream input) {
+            Scanner s = new Scanner(input).useDelimiter("\\A");
+            return s.hasNext() ? s.next() : "";
+        }
+    }
+
+}
