diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java
index f5499401617..21a217a5e86 100755
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java
@@ -219,60 +219,6 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
 
     }
 
-    /*
-     * public String unbind(Map<String, Object> model) throws Exception {
-     * StringBuilder builder = new StringBuilder(); Map<Integer, DataField>
-     * dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields);
-     * Iterator<Integer> it = dataFieldsSorted.keySet().iterator(); // Map
-     * containing the OUT position of the field // The key is double and is
-     * created using the position of the field and // location of the class in
-     * the message (using section) Map<Integer, String> positions = new
-     * TreeMap<Integer, String>(); // Check if separator exists ObjectHelper
-     * .notNull(this.separator,
-     * "The separator has not been instantiated or property not defined in the @CsvRecord annotation"
-     * ); char separator = Converter.getCharDelimitor(this.getSeparator()); if
-     * (LOG.isDebugEnabled()) { LOG.debug("Separator converted : '0x" +
-     * Integer.toHexString(separator) + "', from : " + this.getSeparator()); }
-     * while (it.hasNext()) { DataField dataField =
-     * dataFieldsSorted.get(it.next()); // Retrieve the field Field field =
-     * annotedFields.get(dataField.pos()); // Change accessibility to allow to
-     * read protected/private fields field.setAccessible(true); // Retrieve the
-     * format, pattern and precision associated to the type Class type =
-     * field.getType(); String pattern = dataField.pattern(); int precision =
-     * dataField.precision(); // Create format Format format =
-     * FormatFactory.getFormat(type, pattern, precision); // Get field from
-     * model Object modelField = model.get(field.getDeclaringClass().getName());
-     * if (modelField != null) { // Get field value Object value =
-     * field.get(modelField); String strValue = ""; if (this.isMessageOrdered())
-     * { // Generate a key using the number of the section // and the position
-     * of the field Integer key1 =
-     * sections.get(modelField.getClass().getName()); Integer key2 =
-     * dataField.position(); Integer keyGenerated = generateKey(key1, key2); if
-     * (LOG.isDebugEnabled()) { LOG.debug("Key generated : " +
-     * String.valueOf(keyGenerated) + ", for section : " + key1); } if (value !=
-     * null) { // Format field value try { strValue = format.format(value); }
-     * catch (Exception e) { throw new
-     * IllegalArgumentException("Formating error detected for the value : " +
-     * value, e); } } // Add the content to the TreeMap according to the //
-     * position defined positions.put(keyGenerated, strValue); if
-     * (LOG.isDebugEnabled()) { LOG.debug("Positions size : " +
-     * positions.size()); } } else { // Add value to the appender if not null if
-     * (value != null) { // Format field value try { strValue =
-     * format.format(value); } catch (Exception e) { throw new
-     * IllegalArgumentException("Formating error detected for the value : " +
-     * value, e); } } if (LOG.isDebugEnabled()) {
-     * LOG.debug("Value to be formatted : " + value + ", position : " +
-     * dataField.pos() + ", and its formated value : " + strValue); }
-     * builder.append(strValue); if (it.hasNext()) { builder.append(separator);
-     * } } } } // Iterate through the list to generate // the message according
-     * to the order/position if (this.isMessageOrdered()) { Iterator<Integer>
-     * posit = positions.keySet().iterator(); while (posit.hasNext()) { String
-     * value = positions.get(posit.next()); if (LOG.isDebugEnabled()) {
-     * LOG.debug("Value added at the position (" + posit + ") : " + value +
-     * separator); } builder.append(value); if (it.hasNext()) {
-     * builder.append(separator); } } } return builder.toString(); }
-     */
-
     public String unbind(Map<String, Object> model) throws Exception {
 
         StringBuffer buffer = new StringBuffer();
@@ -542,7 +488,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
             try {
                 strValue = format.format(value);
             } catch (Exception e) {
-                throw new IllegalArgumentException("Formating error detected for the value : " + value, e);
+                throw new IllegalArgumentException("Formatting error detected for the value : " + value, e);
             }
 
         }
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/csv/BindyCsvDataFormat.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/csv/BindyCsvDataFormat.java
index 6ca6c247964..5f641343a74 100755
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/csv/BindyCsvDataFormat.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/csv/BindyCsvDataFormat.java
@@ -21,6 +21,8 @@ import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
@@ -57,11 +59,8 @@ public class BindyCsvDataFormat implements DataFormat {
         BindyCsvFactory factory = getFactory(exchange.getContext().getPackageScanClassResolver());
         ObjectHelper.notNull(factory, "not instantiated");
 
-        List<Map<String, Object>> models = (ArrayList<Map<String, Object>>)body;
-        byte[] bytesCRLF;
-
         // Get CRLF
-        bytesCRLF = Converter.getByteReturn(factory.getCarriageReturn());
+        byte[] bytesCRLF = Converter.getByteReturn(factory.getCarriageReturn());
 
         if (factory.getGenerateHeaderColumnNames()) {
 
@@ -73,6 +72,24 @@ public class BindyCsvDataFormat implements DataFormat {
             outputStream.write(bytesCRLF);
         }
 
+        List<Map<String, Object>> models;
+
+        // the body is not a prepared list so help a bit here and create one for us
+        if (exchange.getContext().getTypeConverter().convertTo(List.class, body) == null) {
+            models = new ArrayList<Map<String, Object>>();
+            Iterator it = ObjectHelper.createIterator(body);
+            while (it.hasNext()) {
+                Object model = it.next();
+                String name = model.getClass().getName();
+                Map<String, Object> row = new HashMap<String, Object>();
+                row.put(name, body);
+                models.add(row);
+            }
+        } else {
+            // cast to the expected type
+            models = (List<Map<String, Object>>) body;
+        }
+
         for (Map<String, Object> model : models) {
 
             String result = factory.unbind(model);
diff --git a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindyPojoSimpleCsvMarshallTest.java b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindyPojoSimpleCsvMarshallTest.java
new file mode 100755
index 00000000000..a68ba999cd1
--- /dev/null
+++ b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindyPojoSimpleCsvMarshallTest.java
@@ -0,0 +1,120 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.bindy.csv;
+
+import java.math.BigDecimal;
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+
+import org.apache.camel.EndpointInject;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Produce;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.dataformat.bindy.model.simple.oneclass.Order;
+import org.apache.camel.processor.interceptor.Tracer;
+import org.apache.camel.spring.javaconfig.SingleRouteCamelConfiguration;
+import org.junit.Test;
+import org.springframework.config.java.annotation.Bean;
+import org.springframework.config.java.annotation.Configuration;
+import org.springframework.config.java.test.JavaConfigContextLoader;
+import org.springframework.test.annotation.DirtiesContext;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;
+
+@ContextConfiguration(locations = "org.apache.camel.dataformat.bindy.csv.BindySimpleCsvMarshallTest$ContextConfig", loader = JavaConfigContextLoader.class)
+public class BindyPojoSimpleCsvMarshallTest extends AbstractJUnit4SpringContextTests {
+
+    private static final String URI_MOCK_RESULT = "mock:result";
+    private static final String URI_MOCK_ERROR = "mock:error";
+    private static final String URI_DIRECT_START = "direct:start";
+
+    private String expected;
+
+    @Produce(uri = URI_DIRECT_START)
+    private ProducerTemplate template;
+
+    @EndpointInject(uri = URI_MOCK_RESULT)
+    private MockEndpoint result;
+
+    @EndpointInject(uri = URI_MOCK_ERROR)
+    private MockEndpoint error;
+
+    @Test
+    @DirtiesContext
+    public void testMarshallMessage() throws Exception {
+
+        expected = "1,B2,Keira,Knightley,ISIN,XX23456789,BUY,Share,400.25,EUR,14-01-2009\r\n";
+
+        result.expectedBodiesReceived(expected);
+
+        template.sendBody(generateModel());
+
+        result.assertIsSatisfied();
+    }
+
+    public Object generateModel() {
+        // just use the order POJO directly
+        Order order = new Order();
+        order.setOrderNr(1);
+        order.setOrderType("BUY");
+        order.setClientNr("B2");
+        order.setFirstName("Keira");
+        order.setLastName("Knightley");
+        order.setAmount(new BigDecimal("400.25"));
+        order.setInstrumentCode("ISIN");
+        order.setInstrumentNumber("XX23456789");
+        order.setInstrumentType("Share");
+        order.setCurrency("EUR");
+
+        Calendar calendar = new GregorianCalendar();
+        calendar.set(2009, 0, 14);
+        order.setOrderDate(calendar.getTime());
+
+        return order;
+    }
+
+    @Configuration
+    public static class ContextConfig extends SingleRouteCamelConfiguration {
+        BindyCsvDataFormat camelDataFormat = new BindyCsvDataFormat("org.apache.camel.dataformat.bindy.model.simple.oneclass");
+
+        @Override
+        @Bean
+        public RouteBuilder route() {
+            return new RouteBuilder() {
+                @Override
+                public void configure() {
+
+                    Tracer tracer = new Tracer();
+                    tracer.setLogLevel(LoggingLevel.FATAL);
+                    tracer.setLogName("org.apache.camel.bindy");
+
+                    getContext().addInterceptStrategy(tracer);
+
+                    // default should errors go to mock:error
+                    errorHandler(deadLetterChannel(URI_MOCK_ERROR).redeliverDelay(0));
+
+                    onException(Exception.class).maximumRedeliveries(0).handled(true);
+
+                    from(URI_DIRECT_START).marshal(camelDataFormat).to(URI_MOCK_RESULT);
+                }
+            };
+        }
+    }
+
+}
\ No newline at end of file
