diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java
index c1487ddf8e2..65c40c63169 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java
@@ -42,6 +42,7 @@ import org.apache.camel.spi.RouteContext;
 import org.apache.camel.spi.TracedRouteNodes;
 import org.apache.camel.util.EventHelper;
 import org.apache.camel.util.ExchangeHelper;
+import org.apache.camel.util.ObjectHelper;
 import org.apache.camel.util.ServiceHelper;
 import org.apache.camel.util.concurrent.AtomicExchange;
 import org.apache.camel.util.concurrent.ExecutorServiceHelper;
@@ -68,10 +69,21 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
      */
     static class ProcessorExchangePair {
         private final Processor processor;
+        private final Processor prepared;
         private final Exchange exchange;
 
-        public ProcessorExchangePair(Processor processor, Exchange exchange) {
+        /**
+         * Private constructor as you must use the static creator
+         * {@link org.apache.camel.processor.MulticastProcessor#createProcessorExchangePair(org.apache.camel.Processor,
+         *        org.apache.camel.Exchange)} which prepares the processor before its ready to be used.
+         *
+         * @param processor  the original processor
+         * @param prepared   the prepared processor
+         * @param exchange   the exchange
+         */
+        private ProcessorExchangePair(Processor processor, Processor prepared, Exchange exchange) {
             this.processor = processor;
+            this.prepared = prepared;
             this.exchange = exchange;
         }
 
@@ -79,6 +91,10 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
             return processor;
         }
 
+        public Processor getPrepared() {
+            return prepared;
+        }
+
         public Exchange getExchange() {
             return exchange;
         }
@@ -166,7 +182,8 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
         final AtomicInteger total =  new AtomicInteger(0);
 
         for (ProcessorExchangePair pair : pairs) {
-            final Processor producer = pair.getProcessor();
+            final Processor processor = pair.getProcessor();
+            final Processor prepared = pair.getPrepared();
             final Exchange subExchange = pair.getExchange();
             updateNewExchange(subExchange, total.intValue(), pairs);
 
@@ -177,7 +194,7 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
                         return subExchange;
                     }
 
-                    doProcess(producer, subExchange);
+                    doProcess(processor, prepared, subExchange);
 
                     // should we stop in case of an exception occurred during processing?
                     if (stopOnException && subExchange.getException() != null) {
@@ -213,11 +230,12 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
         int total = 0;
 
         for (ProcessorExchangePair pair : pairs) {
-            Processor producer = pair.getProcessor();
+            Processor processor = pair.getProcessor();
+            Processor prepared = pair.getPrepared();
             Exchange subExchange = pair.getExchange();
             updateNewExchange(subExchange, total, pairs);
 
-            doProcess(producer, subExchange);
+            doProcess(processor, prepared, subExchange);
 
             // should we stop in case of an exception occurred during processing?
             if (stopOnException && subExchange.getException() != null) {
@@ -239,12 +257,12 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
         }
     }
 
-    private void doProcess(Processor producer, Exchange exchange) {
+    private void doProcess(Processor processor, Processor prepared, Exchange exchange) {
         TracedRouteNodes traced = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getTracedRouteNodes() : null;
 
         // compute time taken if sending to another endpoint
         long start = 0;
-        if (producer instanceof Producer) {
+        if (processor instanceof Producer) {
             start = System.currentTimeMillis();
         }
 
@@ -254,26 +272,8 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
                 traced.pushBlock();
             }
 
-            // set property which endpoint we send to
-            setToEndpoint(exchange, producer);
-
-            // wrap error handler
-            Processor wrapped = producer;
-            if (exchange.getUnitOfWork() != null && exchange.getUnitOfWork().getRouteContext() != null) {
-                // wrap the producer in error handler so we have fine grained error handling on
-                // the output side instead of the input side
-                // this is needed to support redelivery on that output alone and not doing redelivery
-                // for the entire multicast block again which will start from scratch again
-                RouteContext routeContext = exchange.getUnitOfWork().getRouteContext();
-                ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder();
-
-                // create error handler (create error handler directly to keep it light weight,
-                // instead of using ProcessorDefinition.wrapInErrorHandler)
-                wrapped = builder.createErrorHandler(routeContext, wrapped);
-            }
-
-            // let the producer process it
-            wrapped.process(exchange);
+            // let the prepared process it
+            prepared.process(exchange);
         } catch (Exception e) {
             exchange.setException(e);
         } finally {
@@ -281,9 +281,9 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
             if (traced != null) {
                 traced.popBlock();
             }
-            if (producer instanceof Producer) {
+            if (processor instanceof Producer) {
                 long timeTaken = System.currentTimeMillis() - start;
-                Endpoint endpoint = ((Producer) producer).getEndpoint();
+                Endpoint endpoint = ((Producer) processor).getEndpoint();
                 // emit event that the exchange was sent to the endpoint
                 EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);
             }
@@ -309,16 +309,53 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
         exchange.setProperty(Exchange.MULTICAST_INDEX, index);
     }
 
-    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) {
+    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {
         List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>(processors.size());
 
         for (Processor processor : processors) {
             Exchange copy = exchange.copy();
-            result.add(new ProcessorExchangePair(processor, copy));
+            result.add(createProcessorExchangePair(processor, copy));
         }
+
         return result;
     }
 
+    /**
+     * Creates the {@link ProcessorExchangePair} which holds the processor and exchange to be send out.
+     * <p/>
+     * You <b>must</b> use this method to create the instances of {@link ProcessorExchangePair} as they
+     * need to be specially prepared before use.
+     *
+     * @param processor  the processor
+     * @param exchange   the exchange
+     * @return prepared for use
+     */
+    protected static ProcessorExchangePair createProcessorExchangePair(Processor processor, Exchange exchange) {
+        Processor prepared = processor;
+
+        // set property which endpoint we send to
+        setToEndpoint(exchange, prepared);
+
+        // rework error handling to support fine grained error handling
+        if (exchange.getUnitOfWork() != null && exchange.getUnitOfWork().getRouteContext() != null) {
+            // wrap the producer in error handler so we have fine grained error handling on
+            // the output side instead of the input side
+            // this is needed to support redelivery on that output alone and not doing redelivery
+            // for the entire multicast block again which will start from scratch again
+            RouteContext routeContext = exchange.getUnitOfWork().getRouteContext();
+            ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder();
+            // create error handler (create error handler directly to keep it light weight,
+            // instead of using ProcessorDefinition.wrapInErrorHandler)
+            try {
+                prepared = builder.createErrorHandler(routeContext, prepared);
+            } catch (Exception e) {
+                throw ObjectHelper.wrapRuntimeCamelException(e);
+            }
+        }
+
+        return new ProcessorExchangePair(processor, prepared, exchange);
+    }
+
     protected void doStop() throws Exception {
         if (executorService != null) {
             executorService.shutdown();
diff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java
index 6328f273ea4..266ebff3af5 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java
@@ -99,7 +99,7 @@ public class Splitter extends MulticastProcessor implements Processor, Traceable
                             Message in = newExchange.getIn();
                             in.setBody(part);
                         }
-                        return new ProcessorExchangePair(getProcessors().iterator().next(), newExchange);
+                        return createProcessorExchangePair(getProcessors().iterator().next(), newExchange);
                     }
 
                     public void remove() {
@@ -129,7 +129,7 @@ public class Splitter extends MulticastProcessor implements Processor, Traceable
                 Message in = newExchange.getIn();
                 in.setBody(part);
             }
-            result.add(new ProcessorExchangePair(getProcessors().iterator().next(), newExchange));
+            result.add(createProcessorExchangePair(getProcessors().iterator().next(), newExchange));
         }
         return result;
     }
diff --git a/camel-core/src/test/java/org/apache/camel/issues/RetryRouteScopedUntilRecipientListIssueTest.java b/camel-core/src/test/java/org/apache/camel/issues/RetryRouteScopedUntilRecipientListIssueTest.java
index df77bca28c2..481d3e34baa 100644
--- a/camel-core/src/test/java/org/apache/camel/issues/RetryRouteScopedUntilRecipientListIssueTest.java
+++ b/camel-core/src/test/java/org/apache/camel/issues/RetryRouteScopedUntilRecipientListIssueTest.java
@@ -116,6 +116,21 @@ public class RetryRouteScopedUntilRecipientListIssueTest extends ContextTestSupp
         assertEquals(0, invoked.get());
     }
 
+    public void testRetryUntilRecipientListOkNotFail() throws Exception {
+        invoked.set(0);
+
+        getMockEndpoint("mock:result").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+
+        template.sendBodyAndHeader("seda:start", "Hello World", "recipientListHeader", "direct:foo,not-fail");
+
+        assertMockEndpointsSatisfied();
+
+        context.stop();
+
+        assertEquals(0, invoked.get());
+    }
+
     public void testRetryUntilRecipientListFailOnly() throws Exception {
         invoked.set(0);
 
@@ -129,7 +144,8 @@ public class RetryRouteScopedUntilRecipientListIssueTest extends ContextTestSupp
         assertMockEndpointsSatisfied();
 
         // wait until its done before we stop and check that retry was invoked
-        notify.matches(5, TimeUnit.SECONDS);
+        boolean matches = notify.matches(10, TimeUnit.SECONDS);
+        assertTrue(matches);
 
         context.stop();
 
@@ -149,7 +165,8 @@ public class RetryRouteScopedUntilRecipientListIssueTest extends ContextTestSupp
         assertMockEndpointsSatisfied();
 
         // wait until its done before we stop and check that retry was invoked
-        notify.matches(5, TimeUnit.SECONDS);
+        boolean matches = notify.matches(10, TimeUnit.SECONDS);
+        assertTrue(matches);
 
         context.stop();
 
@@ -159,17 +176,18 @@ public class RetryRouteScopedUntilRecipientListIssueTest extends ContextTestSupp
     public void testRetryUntilRecipientListOkAndFail() throws Exception {
         invoked.set(0);
 
-        NotifyBuilder notify = new NotifyBuilder(context).whenDone(1).create();
+        NotifyBuilder notify = new NotifyBuilder(context).whenFailed(1).create();
 
         getMockEndpoint("mock:result").expectedMessageCount(0);
-        getMockEndpoint("mock:foo").expectedMinimumMessageCount(0);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
 
         template.sendBodyAndHeader("seda:start", "Hello World", "recipientListHeader", "direct:foo,fail");
 
         assertMockEndpointsSatisfied();
 
         // wait until its done before we stop and check that retry was invoked
-        notify.matches(5, TimeUnit.SECONDS);
+        boolean matches = notify.matches(10, TimeUnit.SECONDS);
+        assertTrue(matches);
 
         context.stop();
 
@@ -204,7 +222,8 @@ public class RetryRouteScopedUntilRecipientListIssueTest extends ContextTestSupp
         assertMockEndpointsSatisfied();
 
         // wait until its done before we stop and check that retry was invoked
-        notify.matches(5, TimeUnit.SECONDS);
+        boolean matches = notify.matches(10, TimeUnit.SECONDS);
+        assertTrue(matches);
 
         context.stop();
 
@@ -224,7 +243,8 @@ public class RetryRouteScopedUntilRecipientListIssueTest extends ContextTestSupp
         assertMockEndpointsSatisfied();
 
         // wait until its done before we stop and check that retry was invoked
-        notify.matches(5, TimeUnit.SECONDS);
+        boolean matches = notify.matches(10, TimeUnit.SECONDS);
+        assertTrue(matches);
 
         context.stop();
 
@@ -237,15 +257,12 @@ public class RetryRouteScopedUntilRecipientListIssueTest extends ContextTestSupp
         return new RouteBuilder() {
             @Override
             public void configure() throws Exception {
-
                 from("seda:start")
                     .onException(Exception.class).retryUntil(bean("myRetryBean")).end()
                     .recipientList(header("recipientListHeader"))
                     .to("mock:result");
 
                 from("direct:foo").to("log:foo").to("mock:foo");
-
-                from("direct:fail").to("log:fail", "mock:fail").throwException(new IllegalArgumentException("Forced"));
             }
         };
     }
