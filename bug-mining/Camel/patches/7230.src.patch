diff --git a/components/camel-zipfile/pom.xml b/components/camel-zipfile/pom.xml
index 8251789377c..6cec47e8e6e 100644
--- a/components/camel-zipfile/pom.xml
+++ b/components/camel-zipfile/pom.xml
@@ -43,6 +43,11 @@
             <groupId>org.apache.camel</groupId>
             <artifactId>camel-file</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-compress</artifactId>
+            <version>${commons-compress-version}</version>
+        </dependency>
 
         <!-- test dependencies -->
         <dependency>
diff --git a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java
index dcbcbb52180..c0487cf8b6a 100644
--- a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java
+++ b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java
@@ -16,15 +16,13 @@
  */
 package org.apache.camel.dataformat.zipfile;
 
+import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Iterator;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-import java.util.zip.ZipOutputStream;
 
 import org.apache.camel.Exchange;
 import org.apache.camel.spi.DataFormat;
@@ -34,11 +32,16 @@ import org.apache.camel.support.builder.OutputStreamBuilder;
 import org.apache.camel.support.service.ServiceSupport;
 import org.apache.camel.util.IOHelper;
 import org.apache.camel.util.StringHelper;
+import org.apache.commons.compress.archivers.ArchiveStreamFactory;
+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
+import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
+import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
 
+import static org.apache.camel.Exchange.FILE_LENGTH;
 import static org.apache.camel.Exchange.FILE_NAME;
 
 /**
- * Zip file data format. See {@link org.apache.camel.model.dataformat.ZipDataFormat} for "deflate" compression.
+ * Zip file data format. See {@link org.apache.camel.model.dataformat.ZipFileDataFormat} for "deflate" compression.
  */
 @Dataformat("zipFile")
 public class ZipFileDataFormat extends ServiceSupport implements DataFormat, DataFormatName {
@@ -60,6 +63,7 @@ public class ZipFileDataFormat extends ServiceSupport implements DataFormat, Dat
     public void marshal(final Exchange exchange, final Object graph, final OutputStream stream) throws Exception {
         String filename;
         String filepath = exchange.getIn().getHeader(FILE_NAME, String.class);
+        Long fileLength = exchange.getIn().getHeader(FILE_LENGTH, Long.class);
         if (filepath == null) {
             // generate the file name as the camel file component would do
             filename = filepath = StringHelper.sanitize(exchange.getIn().getMessageId());
@@ -73,19 +77,23 @@ public class ZipFileDataFormat extends ServiceSupport implements DataFormat, Dat
             }
         }
 
-        ZipOutputStream zos = new ZipOutputStream(stream);
+        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(stream);
+
+        InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, graph);
+        if (fileLength == null) {
+            fileLength = (long) is.available();
+        }
 
         if (preservePathElements) {
-            createZipEntries(zos, filepath);
+            createZipEntries(zos, filepath, fileLength);
         } else {
-            createZipEntries(zos, filename);
+            createZipEntries(zos, filename, fileLength);
         }
 
-        InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, graph);
-
         try {
             IOHelper.copy(is, zos);
         } finally {
+            zos.closeArchiveEntry();
             IOHelper.close(is, zos);
         }
 
@@ -100,11 +108,13 @@ public class ZipFileDataFormat extends ServiceSupport implements DataFormat, Dat
             zipIterator.setAllowEmptyDirectory(allowEmptyDirectory);
             return zipIterator;
         } else {
-            ZipInputStream zis = new ZipInputStream(inputStream);
+            BufferedInputStream bis = new BufferedInputStream(inputStream);
+            ZipArchiveInputStream zis = (ZipArchiveInputStream) new ArchiveStreamFactory()
+                    .createArchiveInputStream(ArchiveStreamFactory.ZIP, bis);
             OutputStreamBuilder osb = OutputStreamBuilder.withExchange(exchange);
 
             try {
-                ZipEntry entry = zis.getNextEntry();
+                ZipArchiveEntry entry = zis.getNextEntry();
                 if (entry != null) {
                     exchange.getMessage().setHeader(FILE_NAME, entry.getName());
                     IOHelper.copy(zis, osb, IOHelper.DEFAULT_BUFFER_SIZE, false, maxDecompressedSize);
@@ -119,27 +129,31 @@ public class ZipFileDataFormat extends ServiceSupport implements DataFormat, Dat
 
                 return osb.build();
             } finally {
-                IOHelper.close(zis, osb);
+                IOHelper.close(osb, zis, bis);
             }
         }
     }
 
-    private void createZipEntries(ZipOutputStream zos, String filepath) throws IOException {
+    private void createZipEntries(ZipArchiveOutputStream zos, String filepath, Long fileLength) throws IOException {
         Iterator<Path> elements = Paths.get(filepath).iterator();
         StringBuilder sb = new StringBuilder(256);
 
         while (elements.hasNext()) {
             Path path = elements.next();
             String element = path.toString();
+            Long length = fileLength;
 
             // If there are more elements to come this element is a directory
             // The "/" at the end tells the ZipEntry it is a folder
             if (elements.hasNext()) {
                 element += "/";
+                length = 0L;
             }
 
             // Each entry needs the complete path, including previous created folders.
-            zos.putNextEntry(new ZipEntry(sb + element));
+            ZipArchiveEntry entry = new ZipArchiveEntry(sb + element);
+            entry.setSize(length);
+            zos.putArchiveEntry(entry);
 
             sb.append(element);
         }
diff --git a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipIterator.java b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipIterator.java
index 974b8d5b94d..637d6cbaa94 100644
--- a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipIterator.java
+++ b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipIterator.java
@@ -16,20 +16,20 @@
  */
 package org.apache.camel.dataformat.zipfile;
 
-import java.io.BufferedInputStream;
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
+import java.io.*;
 import java.util.Iterator;
 import java.util.Objects;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
 
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.RuntimeCamelException;
 import org.apache.camel.support.DefaultMessage;
 import org.apache.camel.util.IOHelper;
+import org.apache.commons.compress.archivers.ArchiveException;
+import org.apache.commons.compress.archivers.ArchiveInputStream;
+import org.apache.commons.compress.archivers.ArchiveStreamFactory;
+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
+import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -42,7 +42,8 @@ public class ZipIterator implements Iterator<Message>, Closeable {
 
     private final Exchange exchange;
     private boolean allowEmptyDirectory;
-    private volatile ZipInputStream zipInputStream;
+    private volatile ZipArchiveInputStream zipInputStream;
+    private volatile ZipArchiveEntry currentEntry;
     private volatile Message parent;
     private volatile boolean first;
 
@@ -52,13 +53,15 @@ public class ZipIterator implements Iterator<Message>, Closeable {
 
         Objects.requireNonNull(inputStream);
 
-        if (inputStream instanceof ZipInputStream) {
-            zipInputStream = (ZipInputStream) inputStream;
+        if (inputStream instanceof ZipArchiveInputStream) {
+            zipInputStream = (ZipArchiveInputStream) inputStream;
         } else {
-            if (inputStream instanceof InputStream) {
-                zipInputStream = new ZipInputStream(inputStream);
-            } else {
-                zipInputStream = new ZipInputStream(new BufferedInputStream(inputStream));
+            try {
+                ArchiveInputStream input = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP,
+                        new BufferedInputStream(inputStream));
+                zipInputStream = (ZipArchiveInputStream) input;
+            } catch (ArchiveException e) {
+                throw new RuntimeException(e.getMessage(), e);
             }
         }
         parent = null;
@@ -77,7 +80,7 @@ public class ZipIterator implements Iterator<Message>, Closeable {
             if (zipInputStream == null) {
                 return false;
             }
-            boolean availableDataInCurrentEntry = zipInputStream.available() == 1;
+            boolean availableDataInCurrentEntry = currentEntry != null;
             if (!availableDataInCurrentEntry) {
                 // advance to the next entry.
                 parent = getNextElement();
@@ -110,6 +113,7 @@ public class ZipIterator implements Iterator<Message>, Closeable {
         }
         Message answer = parent;
         parent = null;
+        currentEntry = null;
 
         if (first && answer == null) {
             throw new IllegalStateException("Unable to unzip the file, it may be corrupted.");
@@ -127,15 +131,28 @@ public class ZipIterator implements Iterator<Message>, Closeable {
         }
 
         try {
-            ZipEntry current = getNextEntry();
+            currentEntry = getNextEntry();
+
+            if (currentEntry != null) {
+                LOG.debug("read zipEntry {}", currentEntry.getName());
 
-            if (current != null) {
-                LOG.debug("read zipEntry {}", current.getName());
                 Message answer = new DefaultMessage(exchange.getContext());
                 answer.getHeaders().putAll(exchange.getIn().getHeaders());
-                answer.setHeader("zipFileName", current.getName());
-                answer.setHeader(Exchange.FILE_NAME, current.getName());
-                answer.setBody(new ZipInputStreamWrapper(zipInputStream));
+                answer.setHeader("zipFileName", currentEntry.getName());
+                answer.setHeader(Exchange.FILE_NAME, currentEntry.getName());
+                if (currentEntry.isDirectory()) {
+                    if (allowEmptyDirectory) {
+                        answer.setBody(new ByteArrayInputStream(new byte[0]));
+                    } else {
+                        return getNextElement(); // skip directory
+                    }
+                } else {
+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                    IOHelper.copy(zipInputStream, baos);
+                    byte[] data = baos.toByteArray();
+                    answer.setBody(new ByteArrayInputStream(data));
+                }
+
                 return answer;
             } else {
                 LOG.trace("close zipInputStream");
@@ -153,8 +170,8 @@ public class ZipIterator implements Iterator<Message>, Closeable {
         }
     }
 
-    private ZipEntry getNextEntry() throws IOException {
-        ZipEntry entry;
+    private ZipArchiveEntry getNextEntry() throws IOException {
+        ZipArchiveEntry entry;
 
         while ((entry = zipInputStream.getNextEntry()) != null) {
             if (!entry.isDirectory()) {
@@ -178,6 +195,7 @@ public class ZipIterator implements Iterator<Message>, Closeable {
     public void close() throws IOException {
         IOHelper.close(zipInputStream);
         zipInputStream = null;
+        currentEntry = null;
     }
 
     public boolean isSupportIteratorForEmptyDirectory() {
diff --git a/components/camel-zipfile/src/test/java/org/apache/camel/processor/aggregate/zipfile/ZipSplitAggregateTransactedStreamingIssueTest.java b/components/camel-zipfile/src/test/java/org/apache/camel/processor/aggregate/zipfile/ZipSplitAggregateTransactedStreamingIssueTest.java
index a31bfb542d0..b9d53c51999 100644
--- a/components/camel-zipfile/src/test/java/org/apache/camel/processor/aggregate/zipfile/ZipSplitAggregateTransactedStreamingIssueTest.java
+++ b/components/camel-zipfile/src/test/java/org/apache/camel/processor/aggregate/zipfile/ZipSplitAggregateTransactedStreamingIssueTest.java
@@ -33,7 +33,7 @@ import org.springframework.transaction.support.TransactionTemplate;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
-@Disabled("")
+
 public class ZipSplitAggregateTransactedStreamingIssueTest extends CamelTestSupport {
 
     private static final Logger LOG = LoggerFactory.getLogger(ZipSplitAggregateTransactedStreamingIssueTest.class);
@@ -78,7 +78,7 @@ public class ZipSplitAggregateTransactedStreamingIssueTest extends CamelTestSupp
                 getContext().getRegistry().bind("transacted", springTransactionPolicy);
                 getContext().getRegistry().bind("zipSplitter", new ZipSplitter());
 
-                from("direct:start").streamCache(false)
+                from("direct:start").streamCache(true)
                         .transacted("transacted")
                         .setBody().simple(zipArchiveWithTwoFiles)
                         .unmarshal().base64()
