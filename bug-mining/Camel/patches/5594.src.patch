diff --git a/core/camel-api/src/main/java/org/apache/camel/Exchange.java b/core/camel-api/src/main/java/org/apache/camel/Exchange.java
index 07bf559f789..7630c65d3c8 100644
--- a/core/camel-api/src/main/java/org/apache/camel/Exchange.java
+++ b/core/camel-api/src/main/java/org/apache/camel/Exchange.java
@@ -190,6 +190,7 @@ public interface Exchange {
     String NOTIFY_EVENT = "CamelNotifyEvent";
 
     String ON_COMPLETION = "CamelOnCompletion";
+    String ON_COMPLETION_ROUTE_IDS = "CamelOnCompletionRouteIds";
     String OVERRULE_FILE_NAME = "CamelOverruleFileName";
 
     String PARENT_UNIT_OF_WORK = "CamelParentUnitOfWork";
diff --git a/core/camel-core-processor/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java b/core/camel-core-processor/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java
index d6de01b77c9..3083c9c1df7 100644
--- a/core/camel-core-processor/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java
+++ b/core/camel-core-processor/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java
@@ -16,6 +16,8 @@
  */
 package org.apache.camel.processor;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 
@@ -249,10 +251,30 @@ public class OnCompletionProcessor extends AsyncProcessorSupport implements Trac
             return Ordered.LOWEST;
         }
 
+        @Override
+        public void onAfterRoute(Route route, Exchange exchange) {
+            // route scope = should be from this route
+            if (routeScoped && route.getRouteId().equals(routeId)) {
+                List routeIds = exchange.getProperty(Exchange.ON_COMPLETION_ROUTE_IDS, List.class);
+                if (routeIds == null) {
+                    routeIds = new ArrayList<>();
+                    exchange.setProperty(Exchange.ON_COMPLETION_ROUTE_IDS, routeIds);
+                }
+                routeIds.add(route.getRouteId());
+
+            }
+        }
+
         @Override
         public void onComplete(final Exchange exchange) {
             String currentRouteId = ExchangeHelper.getRouteId(exchange);
-            if (currentRouteId != null && !routeId.equals(currentRouteId)) {
+            if (!routeScoped && currentRouteId != null && !routeId.equals(currentRouteId)) {
+                return;
+            }
+
+            List routeIds = exchange.getProperty(Exchange.ON_COMPLETION_ROUTE_IDS, List.class);
+
+            if (routeScoped && (routeIds == null || !routeIds.contains(routeId))) {
                 return;
             }
 
diff --git a/core/camel-core/src/test/java/org/apache/camel/issues/OnCompletionAfterConsumerModeIssueTest.java b/core/camel-core/src/test/java/org/apache/camel/issues/OnCompletionAfterConsumerModeIssueTest.java
new file mode 100644
index 00000000000..361d8f5bf4b
--- /dev/null
+++ b/core/camel-core/src/test/java/org/apache/camel/issues/OnCompletionAfterConsumerModeIssueTest.java
@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.issues;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+import org.junit.jupiter.api.Test;
+
+public class OnCompletionAfterConsumerModeIssueTest extends ContextTestSupport {
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+
+    @Test
+    public void testOnCompletionInSub() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                        .transform(constant("a"))
+                        .to("mock:a")
+                        .to("direct:sub")
+                        .transform(constant("c"))
+                        .to("mock:c");
+
+                from("direct:sub")
+                        .transform(constant("b"))
+                        .to("mock:b")
+                        .onCompletion()
+                            .to("mock:end")
+                        .end();
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedBodiesReceived("a");
+        getMockEndpoint("mock:b").expectedBodiesReceived("b");
+        getMockEndpoint("mock:c").expectedBodiesReceived("c");
+        getMockEndpoint("mock:end").expectedBodiesReceived("c");
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Test
+    public void testOnCompletionInMainAndSub() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+
+                from("direct:start")
+                        .transform(constant("a"))
+                        .to("mock:a")
+                        .to("direct:sub")
+                        .transform(constant("c"))
+                        .to("mock:c")
+                        .onCompletion()
+                            .to("mock:end")
+                        .end();
+
+                from("direct:sub")
+                        .transform(constant("b"))
+                        .to("mock:b")
+                        .onCompletion()
+                            .to("mock:end")
+                        .end();
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedBodiesReceived("a");
+        getMockEndpoint("mock:b").expectedBodiesReceived("b");
+        getMockEndpoint("mock:c").expectedBodiesReceived("c");
+        getMockEndpoint("mock:end").expectedBodiesReceived("c", "c");
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Test
+    public void testOnCompletionInGlobalAndSub() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+
+                onCompletion().to("mock:end");
+
+                from("direct:start")
+                        .transform(constant("a"))
+                        .to("mock:a")
+                        .to("direct:sub")
+                        .transform(constant("c"))
+                        .to("mock:c");
+
+                from("direct:sub")
+                        .transform(constant("b"))
+                        .to("mock:b")
+                        .onCompletion()
+                            .to("mock:end")
+                        .end();
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedBodiesReceived("a");
+        getMockEndpoint("mock:b").expectedBodiesReceived("b");
+        getMockEndpoint("mock:c").expectedBodiesReceived("c");
+        getMockEndpoint("mock:end").expectedBodiesReceived("c", "c");
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+}
