diff --git a/core/camel-main/src/main/java/org/apache/camel/main/MainSupport.java b/core/camel-main/src/main/java/org/apache/camel/main/MainSupport.java
index 00a4393e2eb..e036e98cf8b 100644
--- a/core/camel-main/src/main/java/org/apache/camel/main/MainSupport.java
+++ b/core/camel-main/src/main/java/org/apache/camel/main/MainSupport.java
@@ -524,6 +524,20 @@ public abstract class MainSupport extends ServiceSupport {
         this.initialProperties = initialProperties;
     }
 
+    /**
+     * Adds a initial property for the properties component,
+     * which will be used before any locations are resolved.
+     *
+     * @param key    the property key
+     * @param value  the property value
+     */
+    public void addInitialProperty(String key, String value) {
+        if (initialProperties == null) {
+            initialProperties = new OrderedProperties();
+        }
+        initialProperties.setProperty(key, value);
+    }
+
     public Properties getOverrideProperties() {
         return overrideProperties;
     }
@@ -536,6 +550,20 @@ public abstract class MainSupport extends ServiceSupport {
         this.overrideProperties = overrideProperties;
     }
 
+    /**
+     * Adds an override property that take precedence
+     * and will use first, if a property exist.
+     *
+     * @param key    the property key
+     * @param value  the property value
+     */
+    public void addOverrideProperty(String key, String value) {
+        if (overrideProperties == null) {
+            overrideProperties = new OrderedProperties();
+        }
+        overrideProperties.setProperty(key, value);
+    }
+
     public boolean isTrace() {
         return mainConfigurationProperties.isTracing();
     }
diff --git a/core/camel-main/src/test/java/org/apache/camel/main/MainSedaTest.java b/core/camel-main/src/test/java/org/apache/camel/main/MainSedaTest.java
new file mode 100644
index 00000000000..fe0669ace99
--- /dev/null
+++ b/core/camel-main/src/test/java/org/apache/camel/main/MainSedaTest.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.main;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.seda.SedaComponent;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class MainSedaTest extends Assert {
+
+    @Test
+    public void testSedaMain() throws Exception {
+        Main main = new Main();
+        main.addRouteBuilder(new MyRouteBuilder());
+        main.addInitialProperty("camel.component.seda.defaultQueueFactory", "#class:org.apache.camel.main.MySedaBlockingQueueFactory");
+        main.addInitialProperty("camel.component.seda.defaultQueueFactory.counter", "123");
+        main.start();
+
+        CamelContext camelContext = main.getCamelContext();
+        assertNotNull(camelContext);
+
+        SedaComponent seda = camelContext.getComponent("seda", SedaComponent.class);
+        assertNotNull(seda);
+        assertTrue(seda.getDefaultQueueFactory() instanceof MySedaBlockingQueueFactory);
+        MySedaBlockingQueueFactory myBQF = (MySedaBlockingQueueFactory) seda.getDefaultQueueFactory();
+        assertEquals(123, myBQF.getCounter());
+
+        main.stop();
+    }
+
+    public static class MyRouteBuilder extends RouteBuilder {
+        @Override
+        public void configure() throws Exception {
+            from("direct:start").to("seda:foo");
+        }
+    }
+
+}
diff --git a/core/camel-main/src/test/java/org/apache/camel/main/MySedaBlockingQueueFactory.java b/core/camel-main/src/test/java/org/apache/camel/main/MySedaBlockingQueueFactory.java
new file mode 100644
index 00000000000..c596f279880
--- /dev/null
+++ b/core/camel-main/src/test/java/org/apache/camel/main/MySedaBlockingQueueFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.main;
+
+import java.util.concurrent.BlockingQueue;
+
+import org.apache.camel.component.seda.BlockingQueueFactory;
+
+public class MySedaBlockingQueueFactory implements BlockingQueueFactory {
+
+    private int counter;
+
+    public int getCounter() {
+        return counter;
+    }
+
+    public void setCounter(int counter) {
+        this.counter = counter;
+    }
+
+    @Override
+    public BlockingQueue create() {
+        // just return null
+        return null;
+    }
+
+    @Override
+    public BlockingQueue create(int capacity) {
+        // just return null
+        return null;
+    }
+}
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/PropertyBindingSupport.java b/core/camel-support/src/main/java/org/apache/camel/support/PropertyBindingSupport.java
index b619a7c7863..24458c47f4b 100644
--- a/core/camel-support/src/main/java/org/apache/camel/support/PropertyBindingSupport.java
+++ b/core/camel-support/src/main/java/org/apache/camel/support/PropertyBindingSupport.java
@@ -33,6 +33,7 @@ import org.apache.camel.spi.GeneratedPropertyConfigurer;
 import org.apache.camel.spi.PropertyConfigurer;
 import org.apache.camel.util.StringHelper;
 
+import static org.apache.camel.util.ObjectHelper.cast;
 import static org.apache.camel.util.ObjectHelper.isNotEmpty;
 
 /**
@@ -471,9 +472,17 @@ public final class PropertyBindingSupport {
                     // property configurer does not support nested names so skip if the name has a dot
                     valid = key.indexOf('.') == -1;
                 }
-                if (valid && removeParameter && gen.configure(camelContext, target, key, value, ignoreCase)) {
-                    iter.remove();
-                    rc = true;
+                if (valid) {
+                    try {
+                        value = resolveValue(camelContext, target, key, value, ignoreCase, fluentBuilder, allowPrivateSetter);
+                    } catch (Exception e) {
+                        throw new PropertyBindingException(target, e);
+                    }
+                    boolean hit = gen.configure(camelContext, target, key, value, ignoreCase);
+                    if (removeParameter && hit) {
+                        iter.remove();
+                        rc = true;
+                    }
                 }
             }
         }
@@ -528,6 +537,62 @@ public final class PropertyBindingSupport {
         return false;
     }
 
+    private static Object resolveValue(CamelContext context, Object target, String name, Object value,
+                                       boolean ignoreCase, boolean fluentBuilder, boolean allowPrivateSetter) throws Exception {
+        if (value instanceof String) {
+            if (value.toString().startsWith("#class:")) {
+                // its a new class to be created
+                String className = value.toString().substring(7);
+                String factoryMethod = null;
+                if (className.indexOf('#') != -1) {
+                    factoryMethod = StringHelper.after(className, "#");
+                    className = StringHelper.before(className, "#");
+                }
+                Class<?> type = context.getClassResolver().resolveMandatoryClass(className);
+                if (factoryMethod != null) {
+                    value = context.getInjector().newInstance(type, factoryMethod);
+                } else {
+                    value = context.getInjector().newInstance(type);
+                }
+                if (value == null) {
+                    throw new IllegalStateException("Cannot create instance of class: " + className);
+                }
+            } else if (value.toString().startsWith("#type:")) {
+                // its reference by type, so lookup the actual value and use it if there is only one instance in the registry
+                String typeName = value.toString().substring(6);
+                Class<?> type = context.getClassResolver().resolveMandatoryClass(typeName);
+                Set<?> types = context.getRegistry().findByType(type);
+                if (types.size() == 1) {
+                    value = types.iterator().next();
+                } else if (types.size() > 1) {
+                    throw new IllegalStateException("Cannot select single type: " + typeName + " as there are " + types.size() + " beans in the registry with this type");
+                } else {
+                    throw new IllegalStateException("Cannot select single type: " + typeName + " as there are no beans in the registry with this type");
+                }
+            } else if (value.toString().equals("#autowired")) {
+                // we should get the type from the setter
+                Method method = findBestSetterMethod(context, target.getClass(), name, fluentBuilder, allowPrivateSetter, ignoreCase);
+                if (method != null) {
+                    Class<?> parameterType = method.getParameterTypes()[0];
+                    Set<?> types = context.getRegistry().findByType(parameterType);
+                    if (types.size() == 1) {
+                        value = types.iterator().next();
+                    } else if (types.size() > 1) {
+                        throw new IllegalStateException("Cannot select single type: " + parameterType + " as there are " + types.size() + " beans in the registry with this type");
+                    } else {
+                        throw new IllegalStateException("Cannot select single type: " + parameterType + " as there are no beans in the registry with this type");
+                    }
+                } else {
+                    throw new IllegalStateException("Cannot find setter method with name: " + name + " on class: " + target.getClass().getName() + " to use for autowiring");
+                }
+            } else if (value.toString().equals("#bean:")) {
+                String key = value.toString().substring(6);
+                value = context.getRegistry().lookupByName(key);
+            }
+        }
+        return value;
+    }
+
     private static boolean setProperty(CamelContext context, Object target, String name, Object value, boolean mandatory,
                                        boolean ignoreCase, boolean nesting, boolean deepNesting, boolean fluentBuilder,
                                        boolean allowPrivateSetter, boolean reference, boolean placeholder) throws Exception {
@@ -592,58 +657,14 @@ public final class PropertyBindingSupport {
         }
 
         if (reference && value instanceof String) {
-            if (value.toString().startsWith("#class:")) {
-                // its a new class to be created
-                String className = value.toString().substring(7);
-                String factoryMethod = null;
-                if (className.indexOf('#') != -1) {
-                    factoryMethod = StringHelper.after(className, "#");
-                    className = StringHelper.before(className, "#");
-                }
-                Class<?> type = context.getClassResolver().resolveMandatoryClass(className);
-                if (factoryMethod != null) {
-                    value = context.getInjector().newInstance(type, factoryMethod);
-                } else {
-                    value = context.getInjector().newInstance(type);
-                }
-                if (value == null) {
-                    throw new IllegalStateException("Cannot create instance of class: " + className);
-                }
-            } else if (value.toString().startsWith("#type:")) {
-                // its reference by type, so lookup the actual value and use it if there is only one instance in the registry
-                String typeName = value.toString().substring(6);
-                Class<?> type = context.getClassResolver().resolveMandatoryClass(typeName);
-                Set<?> types = context.getRegistry().findByType(type);
-                if (types.size() == 1) {
-                    value = types.iterator().next();
-                } else if (types.size() > 1) {
-                    throw new IllegalStateException("Cannot select single type: " + typeName + " as there are " + types.size() + " beans in the registry with this type");
-                } else {
-                    throw new IllegalStateException("Cannot select single type: " + typeName + " as there are no beans in the registry with this type");
-                }
-            } else if (value.toString().equals("#autowired")) {
-                // we should get the type from the setter
-                Method method = findBestSetterMethod(context, target.getClass(), name, fluentBuilder, allowPrivateSetter, ignoreCase);
-                if (method != null) {
-                    Class<?> parameterType = method.getParameterTypes()[0];
-                    Set<?> types = context.getRegistry().findByType(parameterType);
-                    if (types.size() == 1) {
-                        value = types.iterator().next();
-                    } else if (types.size() > 1) {
-                        throw new IllegalStateException("Cannot select single type: " + parameterType + " as there are " + types.size() + " beans in the registry with this type");
-                    } else {
-                        throw new IllegalStateException("Cannot select single type: " + parameterType + " as there are no beans in the registry with this type");
-                    }
-                } else {
-                    throw new IllegalStateException("Cannot find setter method with name: " + name + " on class: " + target.getClass().getName() + " to use for autowiring");
-                }
-            } else if (value.toString().startsWith("#bean:")) {
+            if (value.toString().startsWith("#bean:")) {
                 // okay its a reference so swap to lookup this which is already supported in IntrospectionSupport
                 refName = "#" + ((String) value).substring(6);
                 value = null;
+            } else {
+                value = resolveValue(context, target, name, value, ignoreCase, fluentBuilder, allowPrivateSetter);
             }
         }
-
         boolean hit = context.adapt(ExtendedCamelContext.class).getBeanIntrospection().setProperty(context, context.getTypeConverter(), target, name, value, refName, fluentBuilder, allowPrivateSetter, ignoreCase);
         if (!hit && mandatory) {
             // there is no setter with this given name, so lets report this as a problem
