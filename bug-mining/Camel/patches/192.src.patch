diff --git a/camel-core/src/main/java/org/apache/camel/model/InterceptType.java b/camel-core/src/main/java/org/apache/camel/model/InterceptType.java
index 4322e0333ad..6e4a4af5725 100644
--- a/camel-core/src/main/java/org/apache/camel/model/InterceptType.java
+++ b/camel-core/src/main/java/org/apache/camel/model/InterceptType.java
@@ -16,6 +16,10 @@
  */
 package org.apache.camel.model;
 
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -63,10 +67,45 @@ public class InterceptType extends OutputType<ProcessorType> {
         ChoiceType choice = choice().when(PredicateBuilder.not(predicate));
         choice.addOutput(proceed);
         return choice.otherwise();
-        //return choice.proceed().otherwise();
     }
 
     public ProceedType getProceed() {
         return proceed;
     }
+    
+    public InterceptType createProxy() {
+        InterceptType answer = new InterceptType();
+        answer.getOutputs().addAll(this.getOutputs());
+
+        // hack: now we need to replace the proceed of the proxy with its own
+        // a bit ugly, operating based on the assumption that the proceed is
+        // in its outputs (if proceed() was called) and/or in the
+        // outputs of the otherwise or last when clause for the predicated version.
+        proxifyProceed(this.getProceed(), answer.getProceed(), answer);
+        
+        if (answer.getOutputs().size() > 0) {
+            // this is for the predicate version
+            ProcessorType<?> processor = answer; 
+            processor = (ProcessorType<?>) answer.getOutputs().get(0);
+            if (processor instanceof ChoiceType) {
+        	    ChoiceType choice = (ChoiceType) processor;
+                proxifyProceed(this.getProceed(), answer.getProceed(), 
+                        choice.getWhenClauses().get(choice.getWhenClauses().size() - 1));
+                proxifyProceed(this.getProceed(), answer.getProceed(), choice.getOtherwise());
+            }
+        }
+        return answer;
+    }
+    
+    private void proxifyProceed(ProceedType orig, ProceedType proxy, ProcessorType<?> processor) {
+    	int index = processor.getOutputs().indexOf(orig);
+        if (index >= 0) {
+            // replace original proceed with proxy
+            processor.addOutput(proxy);
+        
+            List<ProcessorType<?>> outs = processor.getOutputs();
+            outs.remove(proxy);
+            outs.set(index, proxy);
+        }
+    }
 }
diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorType.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorType.java
index c487da156a4..5e34c68fc20 100644
--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorType.java
+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorType.java
@@ -918,14 +918,11 @@ public abstract class ProcessorType<Type extends ProcessorType> extends Optional
                     break;
                 }
             }
-        }
 
-        if (currentProcessor instanceof InterceptType) {
-            proceed = ((InterceptType) currentProcessor).getProceed();
-        }
+            if (proceed == null) {
+                throw new IllegalArgumentException("Cannot use proceed() without being within an intercept() block");
+            }
 
-        if (proceed == null) {
-            throw new IllegalArgumentException("Cannot use proceed() without being within an intercept() block");
         }
 
         addOutput(proceed);
@@ -1488,10 +1485,9 @@ public abstract class ProcessorType<Type extends ProcessorType> extends Optional
     protected Processor wrapProcessorInInterceptors(RouteContext routeContext, Processor target) throws Exception {
         // The target is required.
         if (target == null) {
-            throw new RuntimeCamelException("target provided.");
+            throw new RuntimeCamelException("target not provided.");
         }
 
-
         List<InterceptStrategy> strategies = new ArrayList<InterceptStrategy>();
         CamelContext camelContext = routeContext.getCamelContext();
         if (camelContext instanceof DefaultCamelContext) {
diff --git a/camel-core/src/main/java/org/apache/camel/model/RoutesType.java b/camel-core/src/main/java/org/apache/camel/model/RoutesType.java
index 843e7e75cc2..89b31bc4113 100644
--- a/camel-core/src/main/java/org/apache/camel/model/RoutesType.java
+++ b/camel-core/src/main/java/org/apache/camel/model/RoutesType.java
@@ -164,8 +164,11 @@ public class RoutesType extends OptionalIdentifiedType<RoutesType> implements Ro
         }
         List<InterceptType> intercepts = getIntercepts();
         for (InterceptType intercept : intercepts) {
-            route.addOutput(intercept);
-            route.pushBlock(intercept.getProceed());
+            // need to create a proxy for this one and use the 
+            // proceed of the proxy which will be local to this route
+            InterceptType proxy = intercept.createProxy();       	
+            route.addOutput(proxy);
+            route.pushBlock(proxy.getProceed());
         }
         route.getOutputs().addAll(getExceptions());
         getRoutes().add(route);
diff --git a/camel-core/src/test/java/org/apache/camel/issues/InterceptorLogTest.java b/camel-core/src/test/java/org/apache/camel/issues/InterceptorLogTest.java
index 94b5e0e4fb3..0e3229cb5e2 100644
--- a/camel-core/src/test/java/org/apache/camel/issues/InterceptorLogTest.java
+++ b/camel-core/src/test/java/org/apache/camel/issues/InterceptorLogTest.java
@@ -26,13 +26,15 @@ import org.apache.camel.component.mock.MockEndpoint;
 public class InterceptorLogTest extends ContextTestSupport {
 
     public void testInterceptor() throws Exception {
+        MockEndpoint intercept = getMockEndpoint("mock:intercept");
+        intercept.expectedMessageCount(2);
         MockEndpoint mock = getMockEndpoint("mock:result");
-        // TODO: we should only expect 1 message, but seda queues can sometimes send multiple
-        mock.expectedMinimumMessageCount(1);
+        mock.expectedMessageCount(1);
         mock.expectedBodiesReceived("Hello World");
 
         template.sendBody("seda:foo", "Hello World");
 
+        intercept.assertIsSatisfied();
         mock.assertIsSatisfied();
     }
 
@@ -41,10 +43,11 @@ public class InterceptorLogTest extends ContextTestSupport {
             public void configure() throws Exception {
                 // lets log all steps in all routes (must use proceed to let the exchange continue its
                 // normal route path instead of swallowing it here by our intercepter.
-                intercept().to("log:foo").proceed();
+                intercept().to("log:foo").proceed().to("mock:intercept");
+                intercept().to("log:bar").proceed();
 
                 from("seda:foo").to("seda:bar");
-                from("seda:bar").to("mock:result");
+                from("seda:bar").intercept().to("log:cheese").to("mock:result");
             }
         };
     }
