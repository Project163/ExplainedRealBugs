diff --git a/camel-core/src/main/java/org/apache/camel/model/ChoiceDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ChoiceDefinition.java
index 253467b3f03..11b8119fc30 100644
--- a/camel-core/src/main/java/org/apache/camel/model/ChoiceDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/ChoiceDefinition.java
@@ -135,7 +135,7 @@ public class ChoiceDefinition extends ProcessorDefinition<ChoiceDefinition> {
     @Override
     public void addOutput(ProcessorDefinition output) {
         super.addOutput(output);
-        // re-configure parent as its a tad more complex for the CNR
+        // re-configure parent as its a tad more complex for the Content Based Router
         if (otherwise != null) {
             output.setParent(otherwise);
         } else if (!getWhenClauses().isEmpty()) {
diff --git a/camel-core/src/test/java/org/apache/camel/issues/ExceptionCamel4022Test.java b/camel-core/src/test/java/org/apache/camel/issues/ExceptionCamel4022Test.java
new file mode 100644
index 00000000000..56808bb9c17
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/issues/ExceptionCamel4022Test.java
@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.issues;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version 
+ */
+public class ExceptionCamel4022Test extends ContextTestSupport {
+
+    public void testExceptionWithFatalException() throws Exception {
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:intermediate").expectedMessageCount(0);
+        getMockEndpoint("mock:onexception").expectedMessageCount(0);
+        // TODO: CAMEL-4022 should not go into DLC
+        //getMockEndpoint("mock:dlc").expectedMessageCount(0);
+
+        try {
+            // TODO: if sending to direct:intermediate then it works as expected
+            template.sendBody("direct:start", "<body/>");
+            // TODO: should fail
+            // fail("Should throw an exception");
+        } catch (Exception e) {
+            IllegalArgumentException cause = assertIsInstanceOf(IllegalArgumentException.class, e.getCause());
+            assertEquals("Forced by unit test", cause.getMessage());
+        }
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        final Processor exceptionThrower = new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                throw new IllegalArgumentException("Forced by unit test");
+            }
+        };
+
+        return new RouteBuilder() {
+            public void configure() {
+                // DLC
+                errorHandler(deadLetterChannel("mock:dlc").redeliveryDelay(0).maximumRedeliveries(3));
+
+                // onException that does NOT handle the exception
+                onException(IllegalArgumentException.class)
+                    .process(exceptionThrower)
+                    .to("mock:onexception");
+
+                // route
+                from("direct:start")
+                    .to("direct:intermediate")
+                    .to("mock:result2");
+
+                from("direct:intermediate")
+                    .setBody(constant("<some-value/>"))
+                    .process(exceptionThrower)
+                    .to("mock:intermediate");
+            }
+        };
+    }
+}
+
diff --git a/camel-core/src/test/java/org/apache/camel/issues/ExceptionTest.java b/camel-core/src/test/java/org/apache/camel/issues/ExceptionTest.java
index 0bc2d6b2415..2ebea53fee4 100644
--- a/camel-core/src/test/java/org/apache/camel/issues/ExceptionTest.java
+++ b/camel-core/src/test/java/org/apache/camel/issues/ExceptionTest.java
@@ -21,8 +21,6 @@ import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.component.mock.MockEndpoint;
-import org.junit.Ignore;
-import org.junit.Test;
 
 /**
  * @version 
@@ -91,43 +89,12 @@ public class ExceptionTest extends ContextTestSupport {
         assertMockEndpointsSatisfied();
     }
 
-    public void testExceptionWithFatalException() throws Exception {
-        MockEndpoint resultEndpoint = getMockEndpoint("mock:result");
-        MockEndpoint exceptionEndpoint = getMockEndpoint("mock:exception");
-        MockEndpoint fatalEndpoint = getMockEndpoint("mock:fatal");
-        MockEndpoint errorEndpoint = getMockEndpoint("mock:error");
-
-        fatalEndpoint.expectedMessageCount(0);
-        exceptionEndpoint.expectedMessageCount(0);
-        resultEndpoint.expectedMessageCount(0);
-        errorEndpoint.expectedMessageCount(1);
-        // TODO: CAMEL-4022. Message should probably not go to DLC for this scenario
-        // We need agree on a solution and implement it. See jira for more details.
-        errorEndpoint.expectedBodiesReceived("<some-value/>");
-
-        try {
-            template.sendBody("direct:start2", "<body/>");
-        } catch (Exception e) {
-            // expected
-        }
-
-        assertMockEndpointsSatisfied();
-    }
-
     @Override
     protected RouteBuilder createRouteBuilder() throws Exception {
         final Processor exceptionThrower = new Processor() {
             public void process(Exchange exchange) throws Exception {
-                String body = exchange.getIn().getBody(String.class);
-                body = body.substring(1, body.length() - 2);
-                boolean fatal = body.equals("exception") || body.indexOf(' ') != -1;
-                String message = fatal ? "FATAL " : "";
-                body = fatal ? message + body : "exception";
-
-                // TODO: CAMEL-4022. Set a breakpoint here and see the body growing "FATAl FATAL ... Exception thrown"
-                // See discussion in the issue above for solution found (which will probably lead to changing this test
-                exchange.getIn().setBody("<" + body + "/>");
-                throw new IllegalArgumentException(message + "Exception thrown");
+                exchange.getIn().setBody("<exception/>");
+                throw new IllegalArgumentException("Exception thrown intentionally.");
             }
         };
 
@@ -142,9 +109,6 @@ public class ExceptionTest extends ContextTestSupport {
                 } else if (getName().endsWith("WithHandler")) {
                     log.debug("Using exception handler");
                     onException(IllegalArgumentException.class).to("mock:exception");
-                } else if (getName().endsWith("WithFatalException")) {
-                    log.debug("Using fatal exception");
-                    onException(IllegalArgumentException.class).process(exceptionThrower).to("mock:fatal");
                 }
                 from("direct:start").process(exceptionThrower).to("mock:result");
                 from("direct:start2").to("direct:intermediate").to("mock:result");
diff --git a/camel-core/src/test/java/org/apache/camel/issues/ExceptionThrownFromOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/issues/ExceptionThrownFromOnExceptionTest.java
new file mode 100644
index 00000000000..f07aedd32c8
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/issues/ExceptionThrownFromOnExceptionTest.java
@@ -0,0 +1,417 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.issues;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.camel.CamelExecutionException;
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version 
+ */
+public class ExceptionThrownFromOnExceptionTest extends ContextTestSupport {
+
+    private static AtomicInteger RETRY = new AtomicInteger();
+    private static AtomicInteger ON_EXCEPTION_RETRY = new AtomicInteger();
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+
+    public void testExceptionThrownFromOnException() throws Exception {
+        RETRY.set(0);
+        ON_EXCEPTION_RETRY.set(0);
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // on exception to catch all IO exceptions and handle them specially
+                onException(IOException.class)
+                    .maximumRedeliveries(3)
+                    .to("mock:b")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            ON_EXCEPTION_RETRY.incrementAndGet();
+                            throw new IOException("Some other IOException");
+                        }
+                    })
+                    .to("mock:c");
+
+                from("direct:start")
+                    .to("direct:intermediate")
+                    .to("mock:result");
+
+                from("direct:intermediate")
+                    .to("mock:a")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            RETRY.incrementAndGet();
+                            throw new IOException("IO error");
+                        }
+                    })
+                    .to("mock:end");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:b").expectedMessageCount(1);
+        getMockEndpoint("mock:c").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:end").expectedMessageCount(0);
+
+        try {
+            template.sendBody("direct:start", "Hello World");
+            fail("Should have thrown an exception");
+        } catch (CamelExecutionException e) {
+            IOException cause = assertIsInstanceOf(IOException.class, e.getCause());
+            assertEquals("Some other IOException", cause.getMessage());
+        }
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals("Should try 4 times (1 first, 3 retry)", 4, RETRY.get());
+        assertEquals("Should only invoke onException once", 1, ON_EXCEPTION_RETRY.get());
+    }
+
+    public void testExceptionThrownFromOnExceptionAndHandled() throws Exception {
+        RETRY.set(0);
+        ON_EXCEPTION_RETRY.set(0);
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // on exception to catch all IO exceptions and handle them specially
+                onException(IOException.class)
+                    .maximumRedeliveries(3)
+                    // this time we handle the exception
+                    .handled(true)
+                    .to("mock:b")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            ON_EXCEPTION_RETRY.incrementAndGet();
+                            throw new IOException("Some other IOException");
+                        }
+                    })
+                    .to("mock:c");
+
+                from("direct:start")
+                    .to("direct:intermediate")
+                    .to("mock:result");
+
+                from("direct:intermediate")
+                    .to("mock:a")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            RETRY.incrementAndGet();
+                            throw new IOException("IO error");
+                        }
+                    })
+                    .to("mock:end");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:b").expectedMessageCount(1);
+        getMockEndpoint("mock:c").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:end").expectedMessageCount(0);
+
+        try {
+            template.sendBody("direct:start", "Hello World");
+            fail("Should have thrown an exception");
+        } catch (CamelExecutionException e) {
+            IOException cause = assertIsInstanceOf(IOException.class, e.getCause());
+            assertEquals("Some other IOException", cause.getMessage());
+        }
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals("Should try 4 times (1 first, 3 retry)", 4, RETRY.get());
+        assertEquals("Should only invoke onException once", 1, ON_EXCEPTION_RETRY.get());
+    }
+
+    public void testExceptionThrownFromOnExceptionWithDeadLetterChannel() throws Exception {
+        RETRY.set(0);
+        ON_EXCEPTION_RETRY.set(0);
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // DLC
+                deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3);
+
+                // on exception to catch all IO exceptions and handle them specially
+                onException(IOException.class)
+                    .maximumRedeliveries(3)
+                    .to("mock:b")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            ON_EXCEPTION_RETRY.incrementAndGet();
+                            throw new IOException("Some other IOException");
+                        }
+                    })
+                    .to("mock:c");
+
+                from("direct:start")
+                    .to("direct:intermediate")
+                    .to("mock:result");
+
+                from("direct:intermediate")
+                    .to("mock:a")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            RETRY.incrementAndGet();
+                            throw new IOException("IO error");
+                        }
+                    })
+                    .to("mock:end");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:b").expectedMessageCount(1);
+        getMockEndpoint("mock:c").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:end").expectedMessageCount(0);
+        // the error will not be handled by DLC since we had an onException, and that failed,
+        // so the exchange will throw an exception
+        getMockEndpoint("mock:error").expectedMessageCount(0);
+
+        try {
+            template.sendBody("direct:start", "Hello World");
+            fail("Should have thrown an exception");
+        } catch (CamelExecutionException e) {
+            IOException cause = assertIsInstanceOf(IOException.class, e.getCause());
+            assertEquals("Some other IOException", cause.getMessage());
+        }
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals("Should try 4 times (1 first, 3 retry)", 4, RETRY.get());
+        assertEquals("Should only invoke onException once", 1, ON_EXCEPTION_RETRY.get());
+    }
+
+    public void testExceptionThrownFromOnExceptionAndHandledWithDeadLetterChannel() throws Exception {
+        RETRY.set(0);
+        ON_EXCEPTION_RETRY.set(0);
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // DLC
+                deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3);
+
+                // on exception to catch all IO exceptions and handle them specially
+                onException(IOException.class)
+                    .maximumRedeliveries(3)
+                    // this time we handle the exception
+                    .handled(true)
+                    .to("mock:b")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            ON_EXCEPTION_RETRY.incrementAndGet();
+                            throw new IOException("Some other IOException");
+                        }
+                    })
+                    .to("mock:c");
+
+                from("direct:start")
+                    .to("direct:intermediate")
+                    .to("mock:result");
+
+                from("direct:intermediate")
+                    .to("mock:a")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            RETRY.incrementAndGet();
+                            throw new IOException("IO error");
+                        }
+                    })
+                    .to("mock:end");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:b").expectedMessageCount(1);
+        getMockEndpoint("mock:c").expectedMessageCount(0);
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:end").expectedMessageCount(0);
+        // the error will not be handled by DLC since we had an onException, and that failed,
+        // so the exchange will throw an exception
+        getMockEndpoint("mock:error").expectedMessageCount(0);
+
+        try {
+            template.sendBody("direct:start", "Hello World");
+            fail("Should have thrown an exception");
+        } catch (CamelExecutionException e) {
+            IOException cause = assertIsInstanceOf(IOException.class, e.getCause());
+            assertEquals("Some other IOException", cause.getMessage());
+        }
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals("Should try 4 times (1 first, 3 retry)", 4, RETRY.get());
+        assertEquals("Should only invoke onException once", 1, ON_EXCEPTION_RETRY.get());
+    }
+
+    public void testNoExceptionThrownFromOnExceptionWithDeadLetterChannel() throws Exception {
+        RETRY.set(0);
+        ON_EXCEPTION_RETRY.set(0);
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // DLC
+                deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3);
+
+                // on exception to catch all IO exceptions and handle them specially
+                onException(IOException.class)
+                    .maximumRedeliveries(3)
+                    .to("mock:b")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            ON_EXCEPTION_RETRY.incrementAndGet();
+                            // no exception is thrown this time
+                        }
+                    })
+                    .to("mock:c");
+
+                from("direct:start")
+                     .to("direct:intermediate")
+                     .to("mock:result");
+
+                from("direct:intermediate")
+                    .to("mock:a")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            RETRY.incrementAndGet();
+                            throw new IOException("IO error");
+                        }
+                    })
+                    .to("mock:end");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:b").expectedMessageCount(1);
+        getMockEndpoint("mock:c").expectedMessageCount(1);
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:end").expectedMessageCount(0);
+        // the exception is handled by the onException and thus not the DLC
+        getMockEndpoint("mock:error").expectedMessageCount(0);
+
+        // and this time there was no exception thrown from onException,
+        // but the caller still fails since handled is false on onException
+        try {
+            template.sendBody("direct:start", "Hello World");
+            fail("Should have thrown an exception");
+        } catch (CamelExecutionException e) {
+            // this time its the first exception thrown from the route
+            IOException cause = assertIsInstanceOf(IOException.class, e.getCause());
+            assertEquals("IO error", cause.getMessage());
+        }
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals("Should try 4 times (1 first, 3 retry)", 4, RETRY.get());
+        assertEquals("Should only invoke onException once", 1, ON_EXCEPTION_RETRY.get());
+    }
+
+    public void testNoExceptionThrownFromOnExceptionAndHandledWithDeadLetterChannel() throws Exception {
+        RETRY.set(0);
+        ON_EXCEPTION_RETRY.set(0);
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // DLC
+                deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3);
+
+                // on exception to catch all IO exceptions and handle them specially
+                onException(IOException.class)
+                    .maximumRedeliveries(3)
+                    // we now handle the exception
+                    .handled(true)
+                    .to("mock:b")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            ON_EXCEPTION_RETRY.incrementAndGet();
+                            // no exception is thrown this time
+                        }
+                    })
+                    .to("mock:c");
+
+                from("direct:start")
+                     .to("direct:intermediate")
+                     .to("mock:result");
+
+                from("direct:intermediate")
+                    .to("mock:a")
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            RETRY.incrementAndGet();
+                            throw new IOException("IO error");
+                        }
+                    })
+                    .to("mock:end");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:b").expectedMessageCount(1);
+        getMockEndpoint("mock:c").expectedMessageCount(1);
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:end").expectedMessageCount(0);
+        // the exception is handled by onException so it goes not in DLC
+        getMockEndpoint("mock:error").expectedMessageCount(0);
+
+        // and this time there was no exception thrown from onException,
+        // and the exception is handled so the caller should not fail
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals("Should try 4 times (1 first, 3 retry)", 4, RETRY.get());
+        assertEquals("Should only invoke onException once", 1, ON_EXCEPTION_RETRY.get());
+    }
+
+}
+
