diff --git a/core/camel-api/src/main/java/org/apache/camel/support/service/BaseService.java b/core/camel-api/src/main/java/org/apache/camel/support/service/BaseService.java
index 6ee434ced10..35513e39741 100644
--- a/core/camel-api/src/main/java/org/apache/camel/support/service/BaseService.java
+++ b/core/camel-api/src/main/java/org/apache/camel/support/service/BaseService.java
@@ -49,8 +49,6 @@ public abstract class BaseService {
     protected static final byte SHUTDOWN = 11;
     protected static final byte FAILED = 12;
 
-    private static final Logger LOG = LoggerFactory.getLogger(BaseService.class);
-
     protected final Object lock = new Object();
     protected volatile byte status = NEW;
 
@@ -58,14 +56,12 @@ public abstract class BaseService {
         if (status == NEW) {
             synchronized (lock) {
                 if (status == NEW) {
-                    LOG.trace("Building service: {}", this);
                     try (AutoCloseable ignored = doLifecycleChange()) {
                         doBuild();
                     } catch (Exception e) {
                         doFail(e);
                     }
                     status = BUILT;
-                    LOG.trace("Built service: {}", this);
                 }
             }
         }
@@ -77,14 +73,12 @@ public abstract class BaseService {
             synchronized (lock) {
                 if (status <= BUILT || status >= STOPPED) {
                     build();
-                    LOG.trace("Initializing service: {}", this);
                     try (AutoCloseable ignored = doLifecycleChange()) {
                         status = INITIALIZING;
                         doInit();
                         status = INITIALIZED;
-                        LOG.trace("Initialized service: {}", this);
                     } catch (Exception e) {
-                        LOG.trace("Error while initializing service: {}", this, e);
+                        logger().trace("Error while initializing service: {}", this, e);
                         fail(e);
                     }
                 }
@@ -101,34 +95,34 @@ public abstract class BaseService {
     public void start() {
         synchronized (lock) {
             if (status == STARTED) {
-                LOG.trace("Service: {} already started", this);
+                logger().trace("Service: {} already started", this);
                 return;
             }
             if (status == STARTING) {
-                LOG.trace("Service: {} already starting", this);
+                logger().trace("Service: {} already starting", this);
                 return;
             }
             init();
             if (status == FAILED) {
-                LOG.trace("Init failed");
+                logger().trace("Init failed");
                 return;
             }
             try (AutoCloseable ignored = doLifecycleChange()) {
                 status = STARTING;
-                LOG.trace("Starting service: {}", this);
+                logger().trace("Starting service: {}", this);
                 doStart();
                 status = STARTED;
-                LOG.trace("Started service: {}", this);
+                logger().trace("Started service: {}", this);
             } catch (Exception e) {
                 // need to stop as some resources may have been started during startup
                 try {
                     stop();
                 } catch (Exception e2) {
                     // ignore
-                    LOG.trace("Error while stopping service after it failed to start: {}. This exception is ignored",
+                    logger().trace("Error while stopping service after it failed to start: {}. This exception is ignored",
                             this, e);
                 }
-                LOG.trace("Error while starting service: {}", this, e);
+                logger().trace("Error while starting service: {}", this, e);
                 fail(e);
             }
         }
@@ -143,25 +137,25 @@ public abstract class BaseService {
     public void stop() {
         synchronized (lock) {
             if (status == FAILED) {
-                LOG.trace("Service: {} failed and regarded as already stopped", this);
+                logger().trace("Service: {} failed and regarded as already stopped", this);
                 return;
             }
             if (status == STOPPED || status == SHUTTING_DOWN || status == SHUTDOWN) {
-                LOG.trace("Service: {} already stopped", this);
+                logger().trace("Service: {} already stopped", this);
                 return;
             }
             if (status == STOPPING) {
-                LOG.trace("Service: {} already stopping", this);
+                logger().trace("Service: {} already stopping", this);
                 return;
             }
             status = STOPPING;
-            LOG.trace("Stopping service: {}", this);
+            logger().trace("Stopping service: {}", this);
             try (AutoCloseable ignored = doLifecycleChange()) {
                 doStop();
                 status = STOPPED;
-                LOG.trace("Stopped: {} service", this);
+                logger().trace("Stopped: {} service", this);
             } catch (Exception e) {
-                LOG.trace("Error while stopping service: {}", this, e);
+                logger().trace("Error while stopping service: {}", this, e);
                 fail(e);
             }
         }
@@ -176,21 +170,21 @@ public abstract class BaseService {
     public void suspend() {
         synchronized (lock) {
             if (status == SUSPENDED) {
-                LOG.trace("Service: {} already suspended", this);
+                logger().trace("Service: {} already suspended", this);
                 return;
             }
             if (status == SUSPENDING) {
-                LOG.trace("Service: {} already suspending", this);
+                logger().trace("Service: {} already suspending", this);
                 return;
             }
             status = SUSPENDING;
-            LOG.trace("Suspending service: {}", this);
+            logger().trace("Suspending service: {}", this);
             try (AutoCloseable ignored = doLifecycleChange()) {
                 doSuspend();
                 status = SUSPENDED;
-                LOG.trace("Suspended service: {}", this);
+                logger().trace("Suspended service: {}", this);
             } catch (Exception e) {
-                LOG.trace("Error while suspending service: {}", this, e);
+                logger().trace("Error while suspending service: {}", this, e);
                 fail(e);
             }
         }
@@ -205,17 +199,17 @@ public abstract class BaseService {
     public void resume() {
         synchronized (lock) {
             if (status != SUSPENDED) {
-                LOG.trace("Service is not suspended: {}", this);
+                logger().trace("Service is not suspended: {}", this);
                 return;
             }
             status = STARTING;
-            LOG.trace("Resuming service: {}", this);
+            logger().trace("Resuming service: {}", this);
             try (AutoCloseable ignored = doLifecycleChange()) {
                 doResume();
                 status = STARTED;
-                LOG.trace("Resumed service: {}", this);
+                logger().trace("Resumed service: {}", this);
             } catch (Exception e) {
-                LOG.trace("Error while resuming service: {}", this, e);
+                logger().trace("Error while resuming service: {}", this, e);
                 fail(e);
             }
         }
@@ -230,22 +224,22 @@ public abstract class BaseService {
     public void shutdown() {
         synchronized (lock) {
             if (status == SHUTDOWN) {
-                LOG.trace("Service: {} already shutdown", this);
+                logger().trace("Service: {} already shutdown", this);
                 return;
             }
             if (status == SHUTTING_DOWN) {
-                LOG.trace("Service: {} already shutting down", this);
+                logger().trace("Service: {} already shutting down", this);
                 return;
             }
             stop();
             status = SHUTDOWN;
-            LOG.trace("Shutting down service: {}", this);
+            logger().trace("Shutting down service: {}", this);
             try (AutoCloseable ignored = doLifecycleChange()) {
                 doShutdown();
-                LOG.trace("Shutdown service: {}", this);
+                logger().trace("Shutdown service: {}", this);
                 status = SHUTDOWN;
             } catch (Exception e) {
-                LOG.trace("Error shutting down service: {}", this, e);
+                logger().trace("Error shutting down service: {}", this, e);
                 fail(e);
             }
         }
@@ -420,4 +414,17 @@ public abstract class BaseService {
         return null;
     }
 
+    /*
+     * NOTE: see CAMEL-19724. We log like this instead of using a statically declared logger in order to
+     * reduce the risk of dropping log messages due to slf4j log substitution behavior during its own
+     * initialization.
+     */
+    private Logger logger() {
+        class Holder {
+            static final Logger LOG = LoggerFactory.getLogger(BaseService.class);
+        }
+
+        return Holder.LOG;
+    }
+
 }
diff --git a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/BasePackageScanResolver.java b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/BasePackageScanResolver.java
index 30968f2e1f4..af27b193f02 100644
--- a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/BasePackageScanResolver.java
+++ b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/BasePackageScanResolver.java
@@ -37,7 +37,6 @@ import org.slf4j.LoggerFactory;
  * Base class for package scan resolvers.
  */
 public abstract class BasePackageScanResolver extends ServiceSupport implements CamelContextAware {
-    protected final Logger log = LoggerFactory.getLogger(getClass());
     protected String[] acceptableSchemes = {};
     private final Set<ClassLoader> classLoaders = new LinkedHashSet<>();
     private CamelContext camelContext;
@@ -53,12 +52,11 @@ public abstract class BasePackageScanResolver extends ServiceSupport implements
         try {
             ClassLoader ccl = Thread.currentThread().getContextClassLoader();
             if (ccl != null) {
-                log.trace("Adding ContextClassLoader from current thread: {}", ccl);
                 classLoaders.add(ccl);
             }
         } catch (Exception e) {
             // Ignore this exception
-            log.warn("Cannot add ContextClassLoader from current thread due {}. This exception will be ignored.",
+            logger().warn("Cannot add ContextClassLoader from current thread due {}. This exception will be ignored.",
                     e.getMessage());
         }
 
@@ -133,7 +131,7 @@ public abstract class BasePackageScanResolver extends ServiceSupport implements
      * @throws IOException is thrown by the classloader
      */
     protected Enumeration<URL> getResources(ClassLoader loader, String packageName) throws IOException {
-        log.trace("Getting resource URL for package: {} with classloader: {}", packageName, loader);
+        logger().trace("Getting resource URL for package: {} with classloader: {}", packageName, loader);
 
         // If the URL is a jar, the URLClassloader.getResources() seems to require a trailing slash.  The
         // trailing slash is harmless for other URLs
@@ -146,8 +144,8 @@ public abstract class BasePackageScanResolver extends ServiceSupport implements
     protected String parseUrlPath(URL url) {
         String urlPath = url.getFile();
         urlPath = URLDecoder.decode(urlPath, StandardCharsets.UTF_8);
-        if (log.isTraceEnabled()) {
-            log.trace("Decoded urlPath: {} with protocol: {}", urlPath, url.getProtocol());
+        if (logger().isTraceEnabled()) {
+            logger().trace("Decoded urlPath: {} with protocol: {}", urlPath, url.getProtocol());
         }
 
         // If it's a file in a directory, trim the stupid file: spec
@@ -169,13 +167,13 @@ public abstract class BasePackageScanResolver extends ServiceSupport implements
 
         // osgi bundles should be skipped
         if (url.toString().startsWith("bundle:") || urlPath.startsWith("bundle:")) {
-            log.trace("Skipping OSGi bundle: {}", url);
+            logger().trace("Skipping OSGi bundle: {}", url);
             return null;
         }
 
         // bundle resource should be skipped
         if (url.toString().startsWith("bundleresource:") || urlPath.startsWith("bundleresource:")) {
-            log.trace("Skipping bundleresource: {}", url);
+            logger().trace("Skipping bundleresource: {}", url);
             return null;
         }
 
@@ -191,13 +189,26 @@ public abstract class BasePackageScanResolver extends ServiceSupport implements
         try {
             urls = getResources(loader, packageName);
             if (!urls.hasMoreElements()) {
-                log.trace("No URLs returned by classloader");
+                logger().trace("No URLs returned by classloader");
             }
         } catch (IOException ioe) {
-            log.warn("Cannot read package: {}", packageName, ioe);
+            logger().warn("Cannot read package: {}", packageName, ioe);
             return null;
         }
         return urls;
     }
 
+    /*
+     * NOTE: see CAMEL-19724. We log like this instead of using a statically declared logger in order to
+     * reduce the risk of dropping log messages due to slf4j log substitution behavior during its own
+     * initialization.
+     */
+    private Logger logger() {
+        class Holder {
+            static final Logger LOG = LoggerFactory.getLogger(BasePackageScanResolver.class);
+        }
+
+        return Holder.LOG;
+    }
+
 }
diff --git a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultCamelContextExtension.java b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultCamelContextExtension.java
index b829d68d03b..a32cf1c34a3 100644
--- a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultCamelContextExtension.java
+++ b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultCamelContextExtension.java
@@ -69,8 +69,6 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 class DefaultCamelContextExtension implements ExtendedCamelContext {
-    private static final Logger LOG = LoggerFactory.getLogger(DefaultCamelContextExtension.class);
-
     private final AbstractCamelContext camelContext;
     private final ThreadLocal<Boolean> isSetupRoutes = new ThreadLocal<>();
     private final List<InterceptStrategy> interceptStrategies = new ArrayList<>();
@@ -210,7 +208,7 @@ class DefaultCamelContextExtension implements ExtendedCamelContext {
             try {
                 bootstrap.close();
             } catch (Exception e) {
-                LOG.warn("Error during closing bootstrap. This exception is ignored.", e);
+                logger().warn("Error during closing bootstrap. This exception is ignored.", e);
             }
         }
         bootstraps.clear();
@@ -230,7 +228,7 @@ class DefaultCamelContextExtension implements ExtendedCamelContext {
         if (text != null && text.contains(PropertiesComponent.PREFIX_TOKEN)) {
             // the parser will throw exception if property key was not found
             String answer = camelContext.getPropertiesComponent().parseUri(text, keepUnresolvedOptional);
-            LOG.debug("Resolved text: {} -> {}", text, answer);
+            logger().debug("Resolved text: {} -> {}", text, answer);
             return answer;
         }
         // is the value a known field (currently we only support
@@ -239,7 +237,7 @@ class DefaultCamelContextExtension implements ExtendedCamelContext {
             String field = StringHelper.after(text, "Exchange.");
             String constant = ExchangeConstantProvider.lookup(field);
             if (constant != null) {
-                LOG.debug("Resolved constant: {} -> {}", text, constant);
+                logger().debug("Resolved constant: {} -> {}", text, constant);
                 return constant;
             } else {
                 throw new IllegalArgumentException("Constant field with name: " + field + " not found on Exchange.class");
@@ -371,7 +369,7 @@ class DefaultCamelContextExtension implements ExtendedCamelContext {
 
     @Override
     public void setupManagement(Map<String, Object> options) {
-        LOG.trace("Setting up management");
+        logger().trace("Setting up management");
 
         ManagementStrategyFactory factory = null;
         if (!camelContext.isJMXDisabled()) {
@@ -388,17 +386,17 @@ class DefaultCamelContextExtension implements ExtendedCamelContext {
                 DebuggerFactory df
                         = getBootstrapFactoryFinder().newInstance(Debugger.FACTORY, DebuggerFactory.class).orElse(null);
                 if (df != null) {
-                    LOG.info("Detected: {} JAR (Enabling Camel Debugging)", df);
+                    logger().info("Detected: {} JAR (Enabling Camel Debugging)", df);
                     camelContext.enableDebugging(df);
                 }
             } catch (Exception e) {
-                LOG.warn("Cannot create JmxManagementStrategyFactory. Will fallback and disable JMX.", e);
+                logger().warn("Cannot create JmxManagementStrategyFactory. Will fallback and disable JMX.", e);
             }
         }
         if (factory == null) {
             factory = new DefaultManagementStrategyFactory();
         }
-        LOG.debug("Setting up management with factory: {}", factory);
+        logger().debug("Setting up management with factory: {}", factory);
 
         // preserve any existing event notifiers that may have been already added
         List<EventNotifier> notifiers = null;
@@ -414,7 +412,7 @@ class DefaultCamelContextExtension implements ExtendedCamelContext {
             LifecycleStrategy lifecycle = factory.createLifecycle(camelContext);
             factory.setupManagement(camelContext, strategy, lifecycle);
         } catch (Exception e) {
-            LOG.warn("Error setting up management due {}", e.getMessage());
+            logger().warn("Error setting up management due {}", e.getMessage());
             throw RuntimeCamelException.wrapRuntimeCamelException(e);
         }
     }
@@ -613,4 +611,17 @@ class DefaultCamelContextExtension implements ExtendedCamelContext {
 
         return camelContext.getInternalServiceManager().addService(module);
     }
+
+    /*
+     * NOTE: see CAMEL-19724. We log like this instead of using a statically declared logger in order to
+     * reduce the risk of dropping log messages due to slf4j log substitution behavior during its own
+     * initialization.
+     */
+    private Logger logger() {
+        class Holder {
+            static final Logger LOG = LoggerFactory.getLogger(DefaultCamelContextExtension.class);
+        }
+
+        return Holder.LOG;
+    }
 }
diff --git a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultPackageScanClassResolver.java b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultPackageScanClassResolver.java
index f3f72b0910b..3e1dff0f322 100644
--- a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultPackageScanClassResolver.java
+++ b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultPackageScanClassResolver.java
@@ -44,12 +44,15 @@ import org.apache.camel.spi.PackageScanFilter;
 import org.apache.camel.support.LRUCacheFactory;
 import org.apache.camel.util.IOHelper;
 import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Default implement of {@link org.apache.camel.spi.PackageScanClassResolver}
  */
 public class DefaultPackageScanClassResolver extends BasePackageScanResolver
         implements PackageScanClassResolver, NonManagedService {
+    private static final Logger LOG = LoggerFactory.getLogger(DefaultPackageScanClassResolver.class);
 
     private volatile Map<String, List<String>> jarCache;
     private Set<PackageScanFilter> scanFilters;
@@ -75,8 +78,8 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             return Collections.emptySet();
         }
 
-        if (log.isDebugEnabled()) {
-            log.debug("Searching for annotations of {} in packages: {}", annotation.getName(), Arrays.asList(packageNames));
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Searching for annotations of {} in packages: {}", annotation.getName(), Arrays.asList(packageNames));
         }
 
         PackageScanFilter test = getCompositeFilter(new AnnotatedWithPackageScanFilter(annotation, true));
@@ -85,7 +88,7 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             find(test, pkg, classes);
         }
 
-        log.debug("Found: {}", classes);
+        LOG.debug("Found: {}", classes);
 
         return classes;
     }
@@ -96,8 +99,8 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             return Collections.emptySet();
         }
 
-        if (log.isDebugEnabled()) {
-            log.debug("Searching for annotations of {} in packages: {}", annotations, Arrays.asList(packageNames));
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Searching for annotations of {} in packages: {}", annotations, Arrays.asList(packageNames));
         }
 
         PackageScanFilter test = getCompositeFilter(new AnnotatedWithAnyPackageScanFilter(annotations, true));
@@ -106,7 +109,7 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             find(test, pkg, classes);
         }
 
-        log.debug("Found: {}", classes);
+        LOG.debug("Found: {}", classes);
 
         return classes;
     }
@@ -117,8 +120,8 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             return Collections.emptySet();
         }
 
-        if (log.isDebugEnabled()) {
-            log.debug("Searching for implementations of {} in packages: {}", parent.getName(), Arrays.asList(packageNames));
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Searching for implementations of {} in packages: {}", parent.getName(), Arrays.asList(packageNames));
         }
 
         PackageScanFilter test = getCompositeFilter(new AssignableToPackageScanFilter(parent));
@@ -127,7 +130,7 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             find(test, pkg, classes);
         }
 
-        log.debug("Found: {}", classes);
+        LOG.debug("Found: {}", classes);
 
         return classes;
     }
@@ -143,7 +146,7 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             find(filter, pkg, classes);
         }
 
-        log.debug("Found: {}", classes);
+        LOG.debug("Found: {}", classes);
 
         return classes;
     }
@@ -164,8 +167,8 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
     }
 
     protected void find(PackageScanFilter test, String packageName, ClassLoader loader, Set<Class<?>> classes) {
-        if (log.isTraceEnabled()) {
-            log.trace("Searching for: {} in package: {} using classloader: {}",
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Searching for: {} in package: {} using classloader: {}",
                     test, packageName, loader.getClass().getName());
         }
 
@@ -178,7 +181,7 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             URL url = null;
             try {
                 url = urls.nextElement();
-                log.trace("URL from classloader: {}", url);
+                LOG.trace("URL from classloader: {}", url);
 
                 url = customResourceLocator(url);
 
@@ -187,11 +190,11 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
                     continue;
                 }
 
-                log.trace("Scanning for classes in: {} matching criteria: {}", urlPath, test);
+                LOG.trace("Scanning for classes in: {} matching criteria: {}", urlPath, test);
 
                 File file = new File(urlPath);
                 if (file.isDirectory()) {
-                    log.trace("Loading from directory using file: {}", file);
+                    LOG.trace("Loading from directory using file: {}", file);
                     loadImplementationsInDirectory(test, packageName, file, classes);
                 } else {
                     InputStream stream = null;
@@ -201,14 +204,14 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
                                 || isAcceptableScheme(urlPath)) {
                             // load resources using http/https, sonicfs and other acceptable scheme
                             // sonic ESB requires to be loaded using a regular URLConnection
-                            log.trace("Loading from jar using url: {}", urlPath);
+                            LOG.trace("Loading from jar using url: {}", urlPath);
                             URL urlStream = new URL(urlPath);
                             URLConnection con = urlStream.openConnection();
                             // disable cache mainly to avoid jar file locking on Windows
                             con.setUseCaches(false);
                             stream = con.getInputStream();
                         } else {
-                            log.trace("Loading from jar using file: {}", file);
+                            LOG.trace("Loading from jar using file: {}", file);
                             stream = new FileInputStream(file);
                         }
 
@@ -225,7 +228,7 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
                 }
             } catch (IOException e) {
                 // use debug logging to avoid being to noisy in logs
-                log.debug("Cannot read entries in url: {}", url, e);
+                LOG.debug("Cannot read entries in url: {}", url, e);
             }
         }
     }
@@ -295,10 +298,10 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             entries = doLoadJarClassEntries(stream, urlPath);
             if (jarCache != null) {
                 jarCache.put(urlPath, entries);
-                log.trace("Cached {} JAR with {} entries", urlPath, entries.size());
+                LOG.trace("Cached {} JAR with {} entries", urlPath, entries.size());
             }
         } else {
-            log.trace("Using cached {} JAR with {} entries", urlPath, entries.size());
+            LOG.trace("Using cached {} JAR with {} entries", urlPath, entries.size());
         }
 
         doLoadImplementationsInJar(test, parent, entries, classes);
@@ -326,9 +329,9 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
                 }
             }
         } catch (IOException ioe) {
-            log.warn("Cannot search jar file '{}' due to an IOException: {}", urlPath, ioe.getMessage(), ioe);
+            LOG.warn("Cannot search jar file '{}' due to an IOException: {}", urlPath, ioe.getMessage(), ioe);
         } finally {
-            IOHelper.close(jarStream, urlPath, log);
+            IOHelper.close(jarStream, urlPath, LOG);
         }
 
         return entries;
@@ -364,36 +367,36 @@ public class DefaultPackageScanClassResolver extends BasePackageScanResolver
             Set<ClassLoader> set = getClassLoaders();
             boolean found = false;
             for (ClassLoader classLoader : set) {
-                if (log.isTraceEnabled()) {
-                    log.trace("Testing for class {} matches criteria [{}] using classloader: {}", externalName, test,
+                if (LOG.isTraceEnabled()) {
+                    LOG.trace("Testing for class {} matches criteria [{}] using classloader: {}", externalName, test,
                             classLoader);
                 }
                 try {
                     Class<?> type = classLoader.loadClass(externalName);
-                    log.trace("Loaded the class: {} in classloader: {}", type, classLoader);
+                    LOG.trace("Loaded the class: {} in classloader: {}", type, classLoader);
                     if (test.matches(type)) {
-                        log.trace("Found class: {} which matches the filter in classloader: {}", type, classLoader);
+                        LOG.trace("Found class: {} which matches the filter in classloader: {}", type, classLoader);
                         classes.add(type);
                     }
                     found = true;
                     break;
                 } catch (ClassNotFoundException e) {
-                    if (log.isTraceEnabled()) {
-                        log.trace("Cannot find class '{}' in classloader: {}. Reason: {}", fqn, classLoader,
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace("Cannot find class '{}' in classloader: {}. Reason: {}", fqn, classLoader,
                                 e.getMessage(), e);
                     }
                 } catch (NoClassDefFoundError e) {
-                    if (log.isTraceEnabled()) {
-                        log.trace("Cannot find the class definition '{}' in classloader: {}. Reason: {}", fqn, classLoader,
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace("Cannot find the class definition '{}' in classloader: {}. Reason: {}", fqn, classLoader,
                                 e.getMessage(), e);
                     }
                 }
             }
             if (!found) {
-                log.debug("Cannot find class '{}' in any classloaders: {}", fqn, set);
+                LOG.debug("Cannot find class '{}' in any classloaders: {}", fqn, set);
             }
         } catch (Exception e) {
-            log.warn("Cannot examine class '{}' due to a {} with message: {}", fqn, e.getClass().getName(),
+            LOG.warn("Cannot examine class '{}' due to a {} with message: {}", fqn, e.getClass().getName(),
                     e.getMessage(), e);
 
         }
diff --git a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultPackageScanResourceResolver.java b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultPackageScanResourceResolver.java
index 358030969ad..14107a437f1 100644
--- a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultPackageScanResourceResolver.java
+++ b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultPackageScanResourceResolver.java
@@ -42,12 +42,15 @@ import org.apache.camel.support.PluginHelper;
 import org.apache.camel.support.ResourceHelper;
 import org.apache.camel.util.AntPathMatcher;
 import org.apache.camel.util.IOHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Default implement of {@link org.apache.camel.spi.PackageScanResourceResolver}
  */
 public class DefaultPackageScanResourceResolver extends BasePackageScanResolver
         implements PackageScanResourceResolver, NonManagedService, CamelContextAware {
+    private static final Logger LOG = LoggerFactory.getLogger(DefaultPackageScanResourceResolver.class);
 
     private static final AntPathMatcher PATH_MATCHER = AntPathMatcher.INSTANCE;
 
@@ -140,7 +143,7 @@ public class DefaultPackageScanResourceResolver extends BasePackageScanResolver
             URL url = null;
             try {
                 url = urls.nextElement();
-                log.trace("URL from classloader: {}", url);
+                LOG.trace("URL from classloader: {}", url);
 
                 url = customResourceLocator(url);
 
@@ -149,11 +152,11 @@ public class DefaultPackageScanResourceResolver extends BasePackageScanResolver
                     continue;
                 }
 
-                log.trace("Scanning for resources in: {} matching pattern: {}", urlPath, subPattern);
+                LOG.trace("Scanning for resources in: {} matching pattern: {}", urlPath, subPattern);
 
                 File file = new File(urlPath);
                 if (file.isDirectory()) {
-                    log.trace("Loading from directory using file: {}", file);
+                    LOG.trace("Loading from directory using file: {}", file);
                     loadImplementationsInDirectory(subPattern, packageName, file, resources);
                 } else {
                     InputStream stream;
@@ -162,14 +165,14 @@ public class DefaultPackageScanResourceResolver extends BasePackageScanResolver
                             || isAcceptableScheme(urlPath)) {
                         // load resources using http/https, sonicfs and other acceptable scheme
                         // sonic ESB requires to be loaded using a regular URLConnection
-                        log.trace("Loading from jar using url: {}", urlPath);
+                        LOG.trace("Loading from jar using url: {}", urlPath);
                         URL urlStream = new URL(urlPath);
                         URLConnection con = urlStream.openConnection();
                         // disable cache mainly to avoid jar file locking on Windows
                         con.setUseCaches(false);
                         stream = con.getInputStream();
                     } else {
-                        log.trace("Loading from jar using file: {}", file);
+                        LOG.trace("Loading from jar using file: {}", file);
                         stream = new FileInputStream(file);
                     }
 
@@ -177,7 +180,7 @@ public class DefaultPackageScanResourceResolver extends BasePackageScanResolver
                 }
             } catch (IOException e) {
                 // use debug logging to avoid being to noisy in logs
-                log.debug("Cannot read entries in url: {}", url, e);
+                LOG.debug("Cannot read entries in url: {}", url, e);
             }
         }
     }
@@ -203,7 +206,7 @@ public class DefaultPackageScanResourceResolver extends BasePackageScanResolver
         for (String name : entries) {
             String shortName = name.substring(packageName.length());
             boolean match = PATH_MATCHER.match(subPattern, shortName);
-            log.debug("Found resource: {} matching pattern: {} -> {}", shortName, subPattern, match);
+            LOG.debug("Found resource: {} matching pattern: {} -> {}", shortName, subPattern, match);
             if (match) {
                 final ResourceLoader loader = PluginHelper.getResourceLoader(getCamelContext());
 
@@ -235,9 +238,9 @@ public class DefaultPackageScanResourceResolver extends BasePackageScanResolver
 
             }
         } catch (IOException ioe) {
-            log.warn("Cannot search jar file '" + urlPath + " due to an IOException: " + ioe.getMessage(), ioe);
+            LOG.warn("Cannot search jar file '" + urlPath + " due to an IOException: " + ioe.getMessage(), ioe);
         } finally {
-            IOHelper.close(jarStream, urlPath, log);
+            IOHelper.close(jarStream, urlPath, LOG);
         }
 
         return entries;
@@ -277,7 +280,7 @@ public class DefaultPackageScanResourceResolver extends BasePackageScanResolver
                 loadImplementationsInDirectory(subPattern, packageOrClass, file, resources);
             } else if (file.isFile() && file.exists() && !name.endsWith(".class")) {
                 boolean match = PATH_MATCHER.match(subPattern, name);
-                log.debug("Found resource: {} matching pattern: {} -> {}", name, subPattern, match);
+                LOG.debug("Found resource: {} matching pattern: {} -> {}", name, subPattern, match);
                 if (match) {
                     final ResourceLoader loader = PluginHelper.getResourceLoader(getCamelContext());
 
diff --git a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/WebSpherePackageScanClassResolver.java b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/WebSpherePackageScanClassResolver.java
index c06b4cb6e10..250f593414b 100644
--- a/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/WebSpherePackageScanClassResolver.java
+++ b/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/WebSpherePackageScanClassResolver.java
@@ -20,10 +20,14 @@ import java.io.IOException;
 import java.net.URL;
 import java.util.Enumeration;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * WebSphere specific resolver to handle loading annotated resources in JAR files.
  */
 public class WebSpherePackageScanClassResolver extends DefaultPackageScanClassResolver {
+    private static final Logger LOG = LoggerFactory.getLogger(WebSpherePackageScanClassResolver.class);
 
     private final String resourcePath;
 
@@ -62,7 +66,7 @@ public class WebSpherePackageScanClassResolver extends DefaultPackageScanClassRe
         // try super first, just in vase
         Enumeration<URL> enumeration = super.getResources(loader, packageName);
         if (!enumeration.hasMoreElements()) {
-            log.trace("Using WebSphere workaround to load the camel jars with the annotated converters.");
+            LOG.trace("Using WebSphere workaround to load the camel jars with the annotated converters.");
             // Special WebSphere trick to load a file that exists in the JAR and then let it go from there.
             // The trick is that we just need the URL's for the .jars that contains the type
             // converters that is annotated. So by searching for this resource WebSphere is able to find
