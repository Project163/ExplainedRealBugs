diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/xquery.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/xquery.json
index 7f8340f892a..5df5016f9a4 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/xquery.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/xquery.json
@@ -35,35 +35,36 @@
     "allowStAX": { "index": 1, "kind": "parameter", "displayName": "Allow St AX", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to allow using StAX mode" },
     "headerName": { "index": 2, "kind": "parameter", "displayName": "Header Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Message header as the input source instead of Message body." },
     "namespacePrefixes": { "index": 3, "kind": "parameter", "displayName": "Namespace Prefixes", "group": "common", "label": "", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.String>", "deprecated": false, "autowired": false, "secret": false, "description": "Allows to control which namespace prefixes to use for a set of namespace mappings" },
-    "propertyName": { "index": 4, "kind": "parameter", "displayName": "Property Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Exchange property as the input source instead of Message body. It has a lower precedent than the name of header if both are set." },
+    "propertyName": { "index": 4, "kind": "parameter", "displayName": "Property Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Exchange property as the input source instead of Message body." },
     "resultsFormat": { "index": 5, "kind": "parameter", "displayName": "Results Format", "group": "common", "label": "", "required": false, "type": "object", "javaType": "org.apache.camel.component.xquery.ResultFormat", "enum": [ "Bytes", "BytesSource", "DOM", "DOMSource", "List", "String", "StringSource" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "DOM", "description": "What output result to use" },
     "resultType": { "index": 6, "kind": "parameter", "displayName": "Result Type", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.Class<java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "What output result to use defined as a class" },
     "stripsAllWhiteSpace": { "index": 7, "kind": "parameter", "displayName": "Strips All White Space", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to strip all whitespaces" },
-    "sendEmptyMessageWhenIdle": { "index": 8, "kind": "parameter", "displayName": "Send Empty Message When Idle", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead." },
-    "bridgeErrorHandler": { "index": 9, "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
-    "exceptionHandler": { "index": 10, "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
-    "exchangePattern": { "index": 11, "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
-    "pollStrategy": { "index": 12, "kind": "parameter", "displayName": "Poll Strategy", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.PollingConsumerPollStrategy", "deprecated": false, "autowired": false, "secret": false, "description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel." },
-    "lazyStartProducer": { "index": 13, "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
-    "configuration": { "index": 14, "kind": "parameter", "displayName": "Configuration", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.Configuration", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon configuration" },
-    "configurationProperties": { "index": 15, "kind": "parameter", "displayName": "Configuration Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "To set custom Saxon configuration properties" },
-    "moduleURIResolver": { "index": 16, "kind": "parameter", "displayName": "Module URIResolver", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.lib.ModuleURIResolver", "deprecated": false, "autowired": false, "secret": false, "description": "To use the custom ModuleURIResolver" },
-    "parameters": { "index": 17, "kind": "parameter", "displayName": "Parameters", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Additional parameters" },
-    "properties": { "index": 18, "kind": "parameter", "displayName": "Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Properties", "deprecated": false, "autowired": false, "secret": false, "description": "Properties to configure the serialization parameters" },
-    "staticQueryContext": { "index": 19, "kind": "parameter", "displayName": "Static Query Context", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.query.StaticQueryContext", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon StaticQueryContext" },
-    "backoffErrorThreshold": { "index": 20, "kind": "parameter", "displayName": "Backoff Error Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in." },
-    "backoffIdleThreshold": { "index": 21, "kind": "parameter", "displayName": "Backoff Idle Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in." },
-    "backoffMultiplier": { "index": 22, "kind": "parameter", "displayName": "Backoff Multiplier", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles\/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and\/or backoffErrorThreshold must also be configured." },
-    "delay": { "index": 23, "kind": "parameter", "displayName": "Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 500, "description": "Milliseconds before the next poll." },
-    "greedy": { "index": 24, "kind": "parameter", "displayName": "Greedy", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages." },
-    "initialDelay": { "index": 25, "kind": "parameter", "displayName": "Initial Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Milliseconds before the first poll starts." },
-    "repeatCount": { "index": 26, "kind": "parameter", "displayName": "Repeat Count", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever." },
-    "runLoggingLevel": { "index": 27, "kind": "parameter", "displayName": "Run Logging Level", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "org.apache.camel.LoggingLevel", "enum": [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "TRACE", "description": "The consumer logs a start\/complete log line when it polls. This option allows you to configure the logging level for that." },
-    "scheduledExecutorService": { "index": 28, "kind": "parameter", "displayName": "Scheduled Executor Service", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.ScheduledExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "Allows for configuring a custom\/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool." },
-    "scheduler": { "index": 29, "kind": "parameter", "displayName": "Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.lang.Object", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "none", "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler" },
-    "schedulerProperties": { "index": 30, "kind": "parameter", "displayName": "Scheduler Properties", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "prefix": "scheduler.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler." },
-    "startScheduler": { "index": 31, "kind": "parameter", "displayName": "Start Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether the scheduler should be auto started." },
-    "timeUnit": { "index": 32, "kind": "parameter", "displayName": "Time Unit", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.TimeUnit", "enum": [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "MILLISECONDS", "description": "Time unit for initialDelay and delay options." },
-    "useFixedDelay": { "index": 33, "kind": "parameter", "displayName": "Use Fixed Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details." }
+    "variableName": { "index": 8, "kind": "parameter", "displayName": "Variable Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a variable as the input source instead of Message body." },
+    "sendEmptyMessageWhenIdle": { "index": 9, "kind": "parameter", "displayName": "Send Empty Message When Idle", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead." },
+    "bridgeErrorHandler": { "index": 10, "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
+    "exceptionHandler": { "index": 11, "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
+    "exchangePattern": { "index": 12, "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
+    "pollStrategy": { "index": 13, "kind": "parameter", "displayName": "Poll Strategy", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.PollingConsumerPollStrategy", "deprecated": false, "autowired": false, "secret": false, "description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel." },
+    "lazyStartProducer": { "index": 14, "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
+    "configuration": { "index": 15, "kind": "parameter", "displayName": "Configuration", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.Configuration", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon configuration" },
+    "configurationProperties": { "index": 16, "kind": "parameter", "displayName": "Configuration Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "To set custom Saxon configuration properties" },
+    "moduleURIResolver": { "index": 17, "kind": "parameter", "displayName": "Module URIResolver", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.lib.ModuleURIResolver", "deprecated": false, "autowired": false, "secret": false, "description": "To use the custom ModuleURIResolver" },
+    "parameters": { "index": 18, "kind": "parameter", "displayName": "Parameters", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Additional parameters" },
+    "properties": { "index": 19, "kind": "parameter", "displayName": "Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Properties", "deprecated": false, "autowired": false, "secret": false, "description": "Properties to configure the serialization parameters" },
+    "staticQueryContext": { "index": 20, "kind": "parameter", "displayName": "Static Query Context", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.query.StaticQueryContext", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon StaticQueryContext" },
+    "backoffErrorThreshold": { "index": 21, "kind": "parameter", "displayName": "Backoff Error Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in." },
+    "backoffIdleThreshold": { "index": 22, "kind": "parameter", "displayName": "Backoff Idle Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in." },
+    "backoffMultiplier": { "index": 23, "kind": "parameter", "displayName": "Backoff Multiplier", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles\/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and\/or backoffErrorThreshold must also be configured." },
+    "delay": { "index": 24, "kind": "parameter", "displayName": "Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 500, "description": "Milliseconds before the next poll." },
+    "greedy": { "index": 25, "kind": "parameter", "displayName": "Greedy", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages." },
+    "initialDelay": { "index": 26, "kind": "parameter", "displayName": "Initial Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Milliseconds before the first poll starts." },
+    "repeatCount": { "index": 27, "kind": "parameter", "displayName": "Repeat Count", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever." },
+    "runLoggingLevel": { "index": 28, "kind": "parameter", "displayName": "Run Logging Level", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "org.apache.camel.LoggingLevel", "enum": [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "TRACE", "description": "The consumer logs a start\/complete log line when it polls. This option allows you to configure the logging level for that." },
+    "scheduledExecutorService": { "index": 29, "kind": "parameter", "displayName": "Scheduled Executor Service", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.ScheduledExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "Allows for configuring a custom\/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool." },
+    "scheduler": { "index": 30, "kind": "parameter", "displayName": "Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.lang.Object", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "none", "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler" },
+    "schedulerProperties": { "index": 31, "kind": "parameter", "displayName": "Scheduler Properties", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "prefix": "scheduler.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler." },
+    "startScheduler": { "index": 32, "kind": "parameter", "displayName": "Start Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether the scheduler should be auto started." },
+    "timeUnit": { "index": 33, "kind": "parameter", "displayName": "Time Unit", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.TimeUnit", "enum": [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "MILLISECONDS", "description": "Time unit for initialDelay and delay options." },
+    "useFixedDelay": { "index": 34, "kind": "parameter", "displayName": "Use Fixed Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details." }
   }
 }
diff --git a/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserLanguage.java b/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserLanguage.java
index bf8048169c3..0732c2e308a 100644
--- a/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserLanguage.java
+++ b/components/camel-hl7/src/main/java/org/apache/camel/component/hl7/Hl7TerserLanguage.java
@@ -22,10 +22,8 @@ import ca.uhn.hl7v2.util.Terser;
 import org.apache.camel.CamelContext;
 import org.apache.camel.Exchange;
 import org.apache.camel.Expression;
-import org.apache.camel.Predicate;
 import org.apache.camel.RuntimeCamelException;
 import org.apache.camel.support.ExpressionAdapter;
-import org.apache.camel.support.ExpressionToPredicateAdapter;
 import org.apache.camel.support.SingleInputTypedLanguageSupport;
 import org.apache.camel.support.builder.ExpressionBuilder;
 import org.apache.camel.util.ObjectHelper;
@@ -65,17 +63,7 @@ public class Hl7TerserLanguage extends SingleInputTypedLanguageSupport {
     }
 
     @Override
-    public Predicate createPredicate(String expression) {
-        return ExpressionToPredicateAdapter.toPredicate(createExpression(expression));
-    }
-
-    @Override
-    public Expression createExpression(String expression) {
-        return terser(expression);
-    }
-
-    @Override
-    protected Expression createExpression(Expression source, String expression, Object[] properties) {
+    public Expression createExpression(Expression source, String expression, Object[] properties) {
         return terser(source, expression);
     }
 }
diff --git a/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqExpression.java b/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqExpression.java
index a72cc5f90a3..1c9e3f6b068 100644
--- a/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqExpression.java
+++ b/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqExpression.java
@@ -29,16 +29,15 @@ import net.thisptr.jackson.jq.Versions;
 import net.thisptr.jackson.jq.exception.JsonQueryException;
 import org.apache.camel.CamelContext;
 import org.apache.camel.Exchange;
+import org.apache.camel.Expression;
 import org.apache.camel.ExpressionIllegalSyntaxException;
 import org.apache.camel.InvalidPayloadException;
-import org.apache.camel.NoSuchHeaderOrPropertyException;
-import org.apache.camel.NoSuchVariableException;
 import org.apache.camel.RuntimeCamelException;
 import org.apache.camel.TypeConverter;
 import org.apache.camel.spi.ExpressionResultTypeAware;
-import org.apache.camel.support.ExchangeHelper;
 import org.apache.camel.support.ExpressionAdapter;
 import org.apache.camel.support.MessageHelper;
+import org.apache.camel.support.builder.ExpressionBuilder;
 
 public class JqExpression extends ExpressionAdapter implements ExpressionResultTypeAware {
 
@@ -49,10 +48,7 @@ public class JqExpression extends ExpressionAdapter implements ExpressionResultT
     private Class<?> resultType;
     private JsonQuery query;
     private TypeConverter typeConverter;
-
-    private String variableName;
-    private String headerName;
-    private String propertyName;
+    private Expression source;
 
     public JqExpression(String expression) {
         this(null, expression);
@@ -88,6 +84,9 @@ public class JqExpression extends ExpressionAdapter implements ExpressionResultT
                 resultType = JsonNode.class;
             }
         }
+        if (this.source == null) {
+            source = ExpressionBuilder.bodyExpression();
+        }
     }
 
     public Scope getScope() {
@@ -120,41 +119,12 @@ public class JqExpression extends ExpressionAdapter implements ExpressionResultT
         this.resultTypeName = resultTypeName;
     }
 
-    public String getVariableName() {
-        return variableName;
-    }
-
-    /**
-     * Name of the variable to use as input instead of the message body.
-     */
-    public void setVariableName(String variableName) {
-        this.variableName = variableName;
-    }
-
-    public String getHeaderName() {
-        return headerName;
-    }
-
-    /**
-     * Name of the header to use as input instead of the message body.
-     * </p>
-     * It has higher precedence than the propertyName if both are set.
-     */
-    public void setHeaderName(String headerName) {
-        this.headerName = headerName;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
+    public Expression getSource() {
+        return source;
     }
 
-    /**
-     * Name of the property to use as input instead of the message body.
-     * </p>
-     * It has lower precedence than the headerName if both are set.
-     */
-    public void setPropertyName(String propertyName) {
-        this.propertyName = propertyName;
+    public void setSource(Expression source) {
+        this.source = source;
     }
 
     @Override
@@ -218,33 +188,12 @@ public class JqExpression extends ExpressionAdapter implements ExpressionResultT
      * @return          the {@link JsonNode} to be processed by the expression
      */
     private JsonNode getPayload(Exchange exchange) throws Exception {
-        JsonNode payload = null;
-
-        if (variableName == null && headerName == null && propertyName == null) {
-            payload = exchange.getMessage().getBody(JsonNode.class);
-            if (payload == null) {
-                throw new InvalidPayloadException(exchange, JsonNode.class);
-            }
-            // if body is stream cached then reset, so we can re-read it again
-            MessageHelper.resetStreamCache(exchange.getMessage());
-        } else {
-            if (variableName != null) {
-                payload = ExchangeHelper.getVariable(exchange, variableName, JsonNode.class);
-                if (payload == null) {
-                    throw new NoSuchVariableException(exchange, variableName, JsonNode.class);
-                }
-            }
-            if (payload == null && headerName != null) {
-                payload = exchange.getMessage().getHeader(headerName, JsonNode.class);
-            }
-            if (payload == null && propertyName != null) {
-                payload = exchange.getProperty(propertyName, JsonNode.class);
-            }
-            if (payload == null) {
-                throw new NoSuchHeaderOrPropertyException(exchange, headerName, propertyName, JsonNode.class);
-            }
+        JsonNode payload = source.evaluate(exchange, JsonNode.class);
+        // if body is stream cached then reset, so we can re-read it again
+        MessageHelper.resetStreamCache(exchange.getMessage());
+        if (payload == null) {
+            throw new InvalidPayloadException(exchange, JsonNode.class);
         }
-
         return payload;
     }
 }
diff --git a/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqLanguage.java b/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqLanguage.java
index 138fcbeb722..9be23525b60 100644
--- a/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqLanguage.java
+++ b/components/camel-jq/src/main/java/org/apache/camel/language/jq/JqLanguage.java
@@ -19,10 +19,8 @@ package org.apache.camel.language.jq;
 import net.thisptr.jackson.jq.Scope;
 import net.thisptr.jackson.jq.module.loaders.BuiltinModuleLoader;
 import org.apache.camel.Expression;
-import org.apache.camel.Predicate;
 import org.apache.camel.StaticService;
 import org.apache.camel.spi.annotations.Language;
-import org.apache.camel.support.ExpressionToPredicateAdapter;
 import org.apache.camel.support.SingleInputTypedLanguageSupport;
 import org.apache.camel.util.ObjectHelper;
 
@@ -58,30 +56,14 @@ public class JqLanguage extends SingleInputTypedLanguageSupport implements Stati
     }
 
     @Override
-    public Predicate createPredicate(String expression) {
-        return ExpressionToPredicateAdapter.toPredicate(createExpression(expression));
-    }
-
-    @Override
-    public Expression createExpression(String expression) {
-        return createExpression(expression, null);
-    }
-
-    @Override
-    public Predicate createPredicate(String expression, Object[] properties) {
-        return ExpressionToPredicateAdapter.toPredicate(createExpression(expression, properties));
-    }
-
-    @Override
-    public Expression createExpression(String expression, Object[] properties) {
+    public Expression createExpression(Expression source, String expression, Object[] properties) {
         JqExpression answer = new JqExpression(Scope.newChildScope(rootScope), expression);
         answer.setResultType(property(Class.class, properties, 0, getResultType()));
-        answer.setVariableName(property(String.class, properties, 1, getVariableName()));
-        answer.setHeaderName(property(String.class, properties, 2, getHeaderName()));
-        answer.setPropertyName(property(String.class, properties, 3, getPropertyName()));
+        answer.setSource(source);
         if (getCamelContext() != null) {
             answer.init(getCamelContext());
         }
         return answer;
     }
+
 }
diff --git a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderOrPropertyTest.java b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderOrPropertyTest.java
deleted file mode 100644
index dc6fdfcc092..00000000000
--- a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderOrPropertyTest.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.camel.language.jq;
-
-import com.fasterxml.jackson.databind.node.TextNode;
-import org.apache.camel.NoSuchHeaderOrPropertyException;
-import org.apache.camel.builder.RouteBuilder;
-import org.apache.camel.component.mock.MockEndpoint;
-import org.junit.jupiter.api.Test;
-
-public class JqExpressionFromHeaderOrPropertyTest extends JqTestSupport {
-    @Override
-    protected RouteBuilder createRouteBuilder() {
-        return new RouteBuilder() {
-            @Override
-            public void configure() {
-                from("direct:start")
-                        .doTry()
-                        .transform().jq(".foo", "Content", "ContentProp")
-                        .to("mock:result")
-                        .doCatch(NoSuchHeaderOrPropertyException.class)
-                        .to("mock:fail");
-
-            }
-        };
-    }
-
-    @Test
-    public void testExpressionFromProperty() throws Exception {
-        getMockEndpoint("mock:result")
-                .expectedBodiesReceived(new TextNode("bar"));
-        getMockEndpoint("mock:fail")
-                .expectedMessageCount(0);
-
-        fluentTemplate.to("direct:start")
-                .withProcessor(e -> {
-                    e.getMessage().setHeader("Invalid", node("foo", "baz"));
-                    e.setProperty("ContentProp", node("foo", "bar"));
-                })
-                .send();
-
-        MockEndpoint.assertIsSatisfied(context);
-    }
-
-    @Test
-    public void testExpressionFromHeader() throws Exception {
-        getMockEndpoint("mock:result")
-                .expectedBodiesReceived(new TextNode("baz"));
-        getMockEndpoint("mock:fail")
-                .expectedMessageCount(0);
-
-        fluentTemplate.to("direct:start")
-                .withProcessor(e -> {
-                    e.getMessage().setHeader("Content", node("foo", "baz"));
-                    e.setProperty("ContentProp", node("foo", "bar"));
-                })
-                .send();
-
-        MockEndpoint.assertIsSatisfied(context);
-    }
-
-    @Test
-    public void testExpressionFail() throws Exception {
-        getMockEndpoint("mock:result")
-                .expectedMessageCount(0);
-        getMockEndpoint("mock:fail")
-                .expectedMessageCount(1);
-
-        fluentTemplate.to("direct:start")
-                .withProcessor(e -> {
-                    e.getMessage().setHeader("Invalid", node("foo", "baz"));
-                    e.setProperty("Invalid", node("foo", "bar"));
-                })
-                .send();
-
-        MockEndpoint.assertIsSatisfied(context);
-    }
-}
diff --git a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderTest.java b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderTest.java
index d13ec9bae97..cd302de09fa 100644
--- a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderTest.java
+++ b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromHeaderTest.java
@@ -17,7 +17,7 @@
 package org.apache.camel.language.jq;
 
 import com.fasterxml.jackson.databind.node.TextNode;
-import org.apache.camel.NoSuchHeaderOrPropertyException;
+import org.apache.camel.NoSuchHeaderException;
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.component.mock.MockEndpoint;
 import org.junit.jupiter.api.Test;
@@ -32,7 +32,7 @@ public class JqExpressionFromHeaderTest extends JqTestSupport {
                         .doTry()
                         .transform().jq(".foo", "Content")
                         .to("mock:result")
-                        .doCatch(NoSuchHeaderOrPropertyException.class)
+                        .doCatch(NoSuchHeaderException.class)
                         .to("mock:fail");
 
             }
@@ -55,23 +55,6 @@ public class JqExpressionFromHeaderTest extends JqTestSupport {
         MockEndpoint.assertIsSatisfied(context);
     }
 
-    @Test
-    public void testExpressionFromHeaderPriority() throws Exception {
-        getMockEndpoint("mock:result")
-                .expectedBodiesReceived(new TextNode("bar"));
-        getMockEndpoint("mock:fail")
-                .expectedMessageCount(0);
-
-        fluentTemplate.to("direct:start")
-                .withProcessor(e -> {
-                    e.getMessage().setHeader("Content", node("foo", "bar"));
-                    e.setProperty("Content", node("foo", "baz"));
-                })
-                .send();
-
-        MockEndpoint.assertIsSatisfied(context);
-    }
-
     @Test
     public void testExpressionFromHeaderFail() throws Exception {
         getMockEndpoint("mock:result")
diff --git a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromPropertyTest.java b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromPropertyTest.java
index 51a9fd6b70f..56469318a3a 100644
--- a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromPropertyTest.java
+++ b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqExpressionFromPropertyTest.java
@@ -18,7 +18,7 @@ package org.apache.camel.language.jq;
 
 import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.fasterxml.jackson.databind.node.TextNode;
-import org.apache.camel.NoSuchHeaderOrPropertyException;
+import org.apache.camel.NoSuchPropertyException;
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.component.mock.MockEndpoint;
 import org.junit.jupiter.api.Test;
@@ -31,9 +31,9 @@ public class JqExpressionFromPropertyTest extends JqTestSupport {
             public void configure() {
                 from("direct:start")
                         .doTry()
-                        .transform().jq(".foo", "Content")
+                        .transform().jq(".foo", Object.class, null, "Content")
                         .to("mock:result")
-                        .doCatch(NoSuchHeaderOrPropertyException.class)
+                        .doCatch(NoSuchPropertyException.class)
                         .to("mock:fail");
 
             }
diff --git a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqSimpleTransformVariableTest.java b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqSimpleTransformVariableTest.java
index 5e62dbad94f..73a11d49e75 100644
--- a/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqSimpleTransformVariableTest.java
+++ b/components/camel-jq/src/test/java/org/apache/camel/language/jq/JqSimpleTransformVariableTest.java
@@ -24,7 +24,9 @@ public class JqSimpleTransformVariableTest extends JqTestSupport {
 
     private static String EXPECTED = """
             {
+              "roll": 123,
               "country": "se",
+              "fullname": "scott"
             }""";
 
     @Override
@@ -36,7 +38,9 @@ public class JqSimpleTransformVariableTest extends JqTestSupport {
                         .setVariable("place", constant("{ \"name\": \"sweden\", \"iso\": \"se\" }"))
                         .transform().simple("""
                                 {
+                                  "roll": ${jq(.id)},
                                   "country": "${jq(variable:place,.iso)}",
+                                  "fullname": "${jq(.name)}"
                                 }""")
                         .to("mock:result");
             }
diff --git a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPath.java b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPath.java
index 118f3995d9b..b7e24366d95 100644
--- a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPath.java
+++ b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPath.java
@@ -58,14 +58,17 @@ public @interface JsonPath {
     Class<?> resultType() default Object.class;
 
     /**
-     * @return The name of the header we want to apply the expression to. If this is empty then the expression will be
-     *         applied to the value of the exchange property or the body instead.
+     * The name of the variable we want to apply the expression to.
+     */
+    String variableName() default "";
+
+    /**
+     * The name of the header we want to apply the expression to.
      */
     String headerName() default "";
 
     /**
-     * @return The name of the property we want to apply the expression to. If this is empty then the expression will be
-     *         applied to the body instead.
+     * The name of the exchange property we want to apply the expression to.
      */
     String propertyName() default "";
 }
diff --git a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathAnnotationExpressionFactory.java b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathAnnotationExpressionFactory.java
index 39c8ef43df5..312ea82994a 100644
--- a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathAnnotationExpressionFactory.java
+++ b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathAnnotationExpressionFactory.java
@@ -21,6 +21,7 @@ import java.lang.annotation.Annotation;
 import com.jayway.jsonpath.Option;
 import org.apache.camel.CamelContext;
 import org.apache.camel.Expression;
+import org.apache.camel.support.builder.ExpressionBuilder;
 import org.apache.camel.support.language.DefaultAnnotationExpressionFactory;
 import org.apache.camel.support.language.LanguageAnnotation;
 import org.apache.camel.util.ObjectHelper;
@@ -48,12 +49,23 @@ public class JsonPathAnnotationExpressionFactory extends DefaultAnnotationExpres
 
             answer.setSuppressExceptions(jsonPathAnnotation.suppressExceptions());
             answer.setAllowSimple(jsonPathAnnotation.allowSimple());
+
+            String variableName = null;
+            String headerName = null;
+            String propertyName = null;
+            if (ObjectHelper.isNotEmpty(jsonPathAnnotation.variableName())) {
+                variableName = jsonPathAnnotation.variableName();
+            }
             if (ObjectHelper.isNotEmpty(jsonPathAnnotation.headerName())) {
-                answer.setHeaderName(jsonPathAnnotation.headerName());
+                headerName = jsonPathAnnotation.headerName();
             }
             if (ObjectHelper.isNotEmpty(jsonPathAnnotation.propertyName())) {
-                answer.setPropertyName(jsonPathAnnotation.propertyName());
+                propertyName = jsonPathAnnotation.propertyName();
             }
+            if (variableName != null || headerName != null || propertyName != null) {
+                answer.setSource(ExpressionBuilder.singleInputExpression(variableName, headerName, propertyName));
+            }
+
             Option[] options = jsonPathAnnotation.options();
             answer.setOptions(options);
         }
diff --git a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathEngine.java b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathEngine.java
index 13739a2d621..afbdc83b699 100644
--- a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathEngine.java
+++ b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathEngine.java
@@ -56,24 +56,22 @@ public class JsonPathEngine {
     private static final Pattern SIMPLE_PATTERN = Pattern.compile("\\$\\{[^\\}]+\\}", Pattern.MULTILINE);
     private final String expression;
     private final boolean writeAsString;
-    private final String headerName;
-    private final String propertyName;
     private final Configuration configuration;
     private final boolean hasSimple;
+    private final Expression source;
     private JsonPathAdapter adapter;
     private volatile boolean initJsonAdapter;
 
     @Deprecated
     public JsonPathEngine(String expression) {
-        this(expression, false, false, true, null, null, null, null);
+        this(expression, null, false, false, true, null, null);
     }
 
-    public JsonPathEngine(String expression, boolean writeAsString, boolean suppressExceptions, boolean allowSimple,
-                          String headerName, String propertyName, Option[] options, CamelContext context) {
+    public JsonPathEngine(String expression, Expression source, boolean writeAsString, boolean suppressExceptions,
+                          boolean allowSimple, Option[] options, CamelContext context) {
         this.expression = expression;
+        this.source = source;
         this.writeAsString = writeAsString;
-        this.headerName = headerName;
-        this.propertyName = propertyName;
 
         Configuration.ConfigurationBuilder builder = Configuration.builder();
         if (options != null) {
@@ -174,18 +172,7 @@ public class JsonPathEngine {
     }
 
     private Object getPayload(Exchange exchange) {
-        Object payload = null;
-        if (headerName == null && propertyName == null) {
-            payload = exchange.getIn().getBody();
-        } else {
-            if (headerName != null) {
-                payload = exchange.getIn().getHeader(headerName);
-            }
-            if (payload == null && propertyName != null) {
-                payload = exchange.getProperty(propertyName);
-            }
-        }
-        return payload;
+        return source != null ? source.evaluate(exchange, Object.class) : exchange.getMessage().getBody();
     }
 
     private Object doRead(String path, Exchange exchange) throws IOException, CamelExchangeException {
@@ -239,15 +226,15 @@ public class JsonPathEngine {
         }
 
         // okay it was not then lets throw a failure
-        if (headerName != null) {
-            throw new CamelExchangeException("Cannot read message header " + headerName + " as supported JSON value", exchange);
+        if (source != null) {
+            throw new CamelExchangeException("Cannot read " + source + " as supported JSON value", exchange);
         } else {
             throw new CamelExchangeException("Cannot read message body as supported JSON value", exchange);
         }
     }
 
     private Object readWithInputStream(String path, Exchange exchange) throws IOException {
-        Object json = headerName != null ? exchange.getIn().getHeader(headerName) : exchange.getIn().getBody();
+        Object json = getPayload(exchange);
         LOG.trace("JSonPath: {} is read as InputStream: {}", path, json);
 
         InputStream is = exchange.getContext().getTypeConverter().tryConvertTo(InputStream.class, exchange, json);
@@ -273,7 +260,7 @@ public class JsonPathEngine {
     }
 
     private Object readWithAdapter(String path, Exchange exchange) {
-        Object json = headerName != null ? exchange.getIn().getHeader(headerName) : exchange.getIn().getBody();
+        Object json = getPayload(exchange);
         LOG.trace("JSonPath: {} is read with adapter: {}", path, json);
 
         doInitAdapter(exchange);
diff --git a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathExpression.java b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathExpression.java
index f0c27d7cd4a..e6bbfd0a473 100644
--- a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathExpression.java
+++ b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathExpression.java
@@ -22,6 +22,7 @@ import java.util.List;
 import com.jayway.jsonpath.Option;
 import org.apache.camel.CamelContext;
 import org.apache.camel.Exchange;
+import org.apache.camel.Expression;
 import org.apache.camel.ExpressionEvaluationException;
 import org.apache.camel.ExpressionIllegalSyntaxException;
 import org.apache.camel.jsonpath.easypredicate.EasyPredicateParser;
@@ -43,9 +44,7 @@ public class JsonPathExpression extends ExpressionAdapter {
     private boolean allowEasyPredicate = true;
     private boolean writeAsString;
     private boolean unpackArray;
-    private String variableName;
-    private String headerName;
-    private String propertyName;
+    private Expression source;
     private Option[] options;
 
     public JsonPathExpression(String expression) {
@@ -130,39 +129,12 @@ public class JsonPathExpression extends ExpressionAdapter {
         this.unpackArray = unpackArray;
     }
 
-    public String getVariableName() {
-        return variableName;
+    public Expression getSource() {
+        return source;
     }
 
-    /**
-     * Name of variable to use as input, instead of the message body
-     */
-    public void setVariableName(String variableName) {
-        this.variableName = variableName;
-    }
-
-    public String getHeaderName() {
-        return headerName;
-    }
-
-    /**
-     * Name of header to use as input, instead of the message body
-     */
-    public void setHeaderName(String headerName) {
-        this.headerName = headerName;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
-    }
-
-    /**
-     * Name of property to use as input, instead of the message body.
-     * <p>
-     * It has a lower precedent than the name of header if both are set.
-     */
-    public void setPropertyName(String propertyName) {
-        this.propertyName = propertyName;
+    public void setSource(Expression source) {
+        this.source = source;
     }
 
     public Option[] getOptions() {
@@ -217,7 +189,7 @@ public class JsonPathExpression extends ExpressionAdapter {
         LOG.debug("Initializing {} using: {}", predicate ? "predicate" : "expression", exp);
         try {
             engine = new JsonPathEngine(
-                    exp, writeAsString, suppressExceptions, allowSimple, headerName, propertyName, options, context);
+                    exp, source, writeAsString, suppressExceptions, allowSimple, options, context);
         } catch (Exception e) {
             throw new ExpressionIllegalSyntaxException(exp, e);
         }
diff --git a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathLanguage.java b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathLanguage.java
index 5819b8f8485..c370359cb3a 100644
--- a/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathLanguage.java
+++ b/components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathLanguage.java
@@ -27,7 +27,7 @@ import org.apache.camel.Predicate;
 import org.apache.camel.jsonpath.easypredicate.EasyPredicateParser;
 import org.apache.camel.spi.PropertyConfigurer;
 import org.apache.camel.spi.annotations.Language;
-import org.apache.camel.support.ExpressionToPredicateAdapter;
+import org.apache.camel.support.ExpressionAdapter;
 import org.apache.camel.support.SingleInputTypedLanguageSupport;
 import org.apache.camel.support.component.PropertyConfigurerSupport;
 
@@ -90,36 +90,27 @@ public class JsonPathLanguage extends SingleInputTypedLanguageSupport implements
     }
 
     @Override
-    public Predicate createPredicate(String expression) {
-        return ExpressionToPredicateAdapter.toPredicate(createExpression(expression));
+    public Predicate createPredicate(Expression source, String expression, Object[] properties) {
+        return doCreateJsonPathExpression(source, expression, properties, true);
     }
 
     @Override
-    public Expression createExpression(String expression) {
-        return createExpression(expression, null);
+    public Expression createExpression(Expression source, String expression, Object[] properties) {
+        return doCreateJsonPathExpression(source, expression, properties, false);
     }
 
-    @Override
-    public Predicate createPredicate(String expression, Object[] properties) {
-        return ExpressionToPredicateAdapter.toPredicate(doCreateJsonPathExpression(expression, properties, true));
-    }
-
-    @Override
-    public Expression createExpression(String expression, Object[] properties) {
-        return doCreateJsonPathExpression(expression, properties, false);
-    }
-
-    protected Expression doCreateJsonPathExpression(String expression, Object[] properties, boolean predicate) {
+    protected ExpressionAdapter doCreateJsonPathExpression(
+            Expression source, String expression, Object[] properties, boolean predicate) {
         JsonPathExpression answer = new JsonPathExpression(expression);
+        answer.setSource(source);
         answer.setPredicate(predicate);
         answer.setResultType(property(Class.class, properties, 0, getResultType()));
-        answer.setSuppressExceptions(property(boolean.class, properties, 1, isSuppressExceptions()));
-        answer.setAllowSimple(property(boolean.class, properties, 2, isAllowSimple()));
-        answer.setAllowEasyPredicate(property(boolean.class, properties, 3, isAllowEasyPredicate()));
-        answer.setWriteAsString(property(boolean.class, properties, 4, isWriteAsString()));
-        answer.setUnpackArray(property(boolean.class, properties, 5, isUnpackArray()));
-        answer.setHeaderName(property(String.class, properties, 6, getHeaderName()));
-        Object option = property(Object.class, properties, 7, null);
+        answer.setSuppressExceptions(property(boolean.class, properties, 4, isSuppressExceptions()));
+        answer.setAllowSimple(property(boolean.class, properties, 5, isAllowSimple()));
+        answer.setAllowEasyPredicate(property(boolean.class, properties, 6, isAllowEasyPredicate()));
+        answer.setWriteAsString(property(boolean.class, properties, 7, isWriteAsString()));
+        answer.setUnpackArray(property(boolean.class, properties, 8, isUnpackArray()));
+        Object option = property(Object.class, properties, 9, null);
         if (option != null) {
             List<Option> list = new ArrayList<>();
             if (option instanceof String str) {
@@ -133,8 +124,6 @@ public class JsonPathLanguage extends SingleInputTypedLanguageSupport implements
         } else if (options != null) {
             answer.setOptions(options);
         }
-        answer.setPropertyName(property(String.class, properties, 8, getPropertyName()));
-        answer.setVariableName(property(String.class, properties, 9, getVariableName()));
         if (getCamelContext() != null) {
             answer.init(getCamelContext());
         }
@@ -178,14 +167,6 @@ public class JsonPathLanguage extends SingleInputTypedLanguageSupport implements
             case "allowEasyPredicate":
                 setAllowEasyPredicate(PropertyConfigurerSupport.property(camelContext, boolean.class, value));
                 return true;
-            case "headername":
-            case "headerName":
-                setHeaderName(PropertyConfigurerSupport.property(camelContext, String.class, value));
-                return true;
-            case "propertyname":
-            case "propertyName":
-                setPropertyName(PropertyConfigurerSupport.property(camelContext, String.class, value));
-                return true;
             case "writeasstring":
             case "writeAsString":
                 setWriteAsString(PropertyConfigurerSupport.property(camelContext, boolean.class, value));
diff --git a/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathLanguageTest.java b/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathLanguageTest.java
index 7ae9fea32d0..16c4665abf1 100644
--- a/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathLanguageTest.java
+++ b/components/camel-jsonpath/src/test/java/org/apache/camel/jsonpath/JsonPathLanguageTest.java
@@ -131,7 +131,7 @@ public class JsonPathLanguageTest extends CamelTestSupport {
         JsonPathLanguage lan = (JsonPathLanguage) context.resolveLanguage("jsonpath");
 
         Expression exp = lan.createExpression("$.foo",
-                new Object[] { null, null, null, null, null, null, null, Option.SUPPRESS_EXCEPTIONS });
+                new Object[] { null, null, null, null, null, null, null, null, null, Option.SUPPRESS_EXCEPTIONS });
         String nofoo = exp.evaluate(exchange, String.class);
 
         assertNull(nofoo);
@@ -144,9 +144,9 @@ public class JsonPathLanguageTest extends CamelTestSupport {
 
         JsonPathLanguage language = (JsonPathLanguage) context.resolveLanguage("jsonpath");
 
-        JsonPathExpression expression = (JsonPathExpression) language.createExpression("$.store.book",
-                new Object[] { String.class, null, null, null, null, true });
-        String json = (String) expression.evaluate(exchange);
+        Expression expression = language.createExpression("$.store.book",
+                new Object[] { String.class, null, null, null, null, null, null, null, true });
+        String json = expression.evaluate(exchange, String.class);
 
         // check that a single json object is returned, not an array
         assertTrue(json.startsWith("{") && json.endsWith("}"));
@@ -159,9 +159,9 @@ public class JsonPathLanguageTest extends CamelTestSupport {
 
         JsonPathLanguage language = (JsonPathLanguage) context.resolveLanguage("jsonpath");
 
-        JsonPathExpression expression = (JsonPathExpression) language.createExpression("$.store.book",
-                new Object[] { String.class, null, null, null, false });
-        String json = (String) expression.evaluate(exchange);
+        Expression expression = language.createExpression("$.store.book",
+                new Object[] { String.class, null, null, null, null, null, false });
+        String json = expression.evaluate(exchange, String.class);
 
         // check that an array is returned, not a single object
         assertTrue(json.startsWith("[") && json.endsWith("]"));
diff --git a/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointConfigurer.java b/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointConfigurer.java
index 4280bb380d8..0dfe66d086a 100644
--- a/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointConfigurer.java
+++ b/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointConfigurer.java
@@ -81,6 +81,8 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "timeUnit": target.setTimeUnit(property(camelContext, java.util.concurrent.TimeUnit.class, value)); return true;
         case "usefixeddelay":
         case "useFixedDelay": target.setUseFixedDelay(property(camelContext, boolean.class, value)); return true;
+        case "variablename":
+        case "variableName": target.setVariableName(property(camelContext, java.lang.String.class, value)); return true;
         default: return false;
         }
     }
@@ -148,6 +150,8 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "timeUnit": return java.util.concurrent.TimeUnit.class;
         case "usefixeddelay":
         case "useFixedDelay": return boolean.class;
+        case "variablename":
+        case "variableName": return java.lang.String.class;
         default: return null;
         }
     }
@@ -216,6 +220,8 @@ public class XQueryEndpointConfigurer extends PropertyConfigurerSupport implemen
         case "timeUnit": return target.getTimeUnit();
         case "usefixeddelay":
         case "useFixedDelay": return target.isUseFixedDelay();
+        case "variablename":
+        case "variableName": return target.getVariableName();
         default: return null;
         }
     }
diff --git a/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointUriFactory.java b/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointUriFactory.java
index 38a3973ed41..88348ef2a12 100644
--- a/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointUriFactory.java
+++ b/components/camel-saxon/src/generated/java/org/apache/camel/component/xquery/XQueryEndpointUriFactory.java
@@ -21,7 +21,7 @@ public class XQueryEndpointUriFactory extends org.apache.camel.support.component
     private static final Set<String> SECRET_PROPERTY_NAMES;
     private static final Set<String> MULTI_VALUE_PREFIXES;
     static {
-        Set<String> props = new HashSet<>(34);
+        Set<String> props = new HashSet<>(35);
         props.add("allowStAX");
         props.add("backoffErrorThreshold");
         props.add("backoffIdleThreshold");
@@ -56,6 +56,7 @@ public class XQueryEndpointUriFactory extends org.apache.camel.support.component
         props.add("stripsAllWhiteSpace");
         props.add("timeUnit");
         props.add("useFixedDelay");
+        props.add("variableName");
         PROPERTY_NAMES = Collections.unmodifiableSet(props);
         SECRET_PROPERTY_NAMES = Collections.emptySet();
         Set<String> prefixes = new HashSet<>(1);
diff --git a/components/camel-saxon/src/generated/resources/org/apache/camel/component/xquery/xquery.json b/components/camel-saxon/src/generated/resources/org/apache/camel/component/xquery/xquery.json
index 7f8340f892a..5df5016f9a4 100644
--- a/components/camel-saxon/src/generated/resources/org/apache/camel/component/xquery/xquery.json
+++ b/components/camel-saxon/src/generated/resources/org/apache/camel/component/xquery/xquery.json
@@ -35,35 +35,36 @@
     "allowStAX": { "index": 1, "kind": "parameter", "displayName": "Allow St AX", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether to allow using StAX mode" },
     "headerName": { "index": 2, "kind": "parameter", "displayName": "Header Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Message header as the input source instead of Message body." },
     "namespacePrefixes": { "index": 3, "kind": "parameter", "displayName": "Namespace Prefixes", "group": "common", "label": "", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.String>", "deprecated": false, "autowired": false, "secret": false, "description": "Allows to control which namespace prefixes to use for a set of namespace mappings" },
-    "propertyName": { "index": 4, "kind": "parameter", "displayName": "Property Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Exchange property as the input source instead of Message body. It has a lower precedent than the name of header if both are set." },
+    "propertyName": { "index": 4, "kind": "parameter", "displayName": "Property Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a Camel Exchange property as the input source instead of Message body." },
     "resultsFormat": { "index": 5, "kind": "parameter", "displayName": "Results Format", "group": "common", "label": "", "required": false, "type": "object", "javaType": "org.apache.camel.component.xquery.ResultFormat", "enum": [ "Bytes", "BytesSource", "DOM", "DOMSource", "List", "String", "StringSource" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "DOM", "description": "What output result to use" },
     "resultType": { "index": 6, "kind": "parameter", "displayName": "Result Type", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.Class<java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "What output result to use defined as a class" },
     "stripsAllWhiteSpace": { "index": 7, "kind": "parameter", "displayName": "Strips All White Space", "group": "common", "label": "", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether to strip all whitespaces" },
-    "sendEmptyMessageWhenIdle": { "index": 8, "kind": "parameter", "displayName": "Send Empty Message When Idle", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead." },
-    "bridgeErrorHandler": { "index": 9, "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
-    "exceptionHandler": { "index": 10, "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
-    "exchangePattern": { "index": 11, "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
-    "pollStrategy": { "index": 12, "kind": "parameter", "displayName": "Poll Strategy", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.PollingConsumerPollStrategy", "deprecated": false, "autowired": false, "secret": false, "description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel." },
-    "lazyStartProducer": { "index": 13, "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
-    "configuration": { "index": 14, "kind": "parameter", "displayName": "Configuration", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.Configuration", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon configuration" },
-    "configurationProperties": { "index": 15, "kind": "parameter", "displayName": "Configuration Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "To set custom Saxon configuration properties" },
-    "moduleURIResolver": { "index": 16, "kind": "parameter", "displayName": "Module URIResolver", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.lib.ModuleURIResolver", "deprecated": false, "autowired": false, "secret": false, "description": "To use the custom ModuleURIResolver" },
-    "parameters": { "index": 17, "kind": "parameter", "displayName": "Parameters", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Additional parameters" },
-    "properties": { "index": 18, "kind": "parameter", "displayName": "Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Properties", "deprecated": false, "autowired": false, "secret": false, "description": "Properties to configure the serialization parameters" },
-    "staticQueryContext": { "index": 19, "kind": "parameter", "displayName": "Static Query Context", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.query.StaticQueryContext", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon StaticQueryContext" },
-    "backoffErrorThreshold": { "index": 20, "kind": "parameter", "displayName": "Backoff Error Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in." },
-    "backoffIdleThreshold": { "index": 21, "kind": "parameter", "displayName": "Backoff Idle Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in." },
-    "backoffMultiplier": { "index": 22, "kind": "parameter", "displayName": "Backoff Multiplier", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles\/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and\/or backoffErrorThreshold must also be configured." },
-    "delay": { "index": 23, "kind": "parameter", "displayName": "Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 500, "description": "Milliseconds before the next poll." },
-    "greedy": { "index": 24, "kind": "parameter", "displayName": "Greedy", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages." },
-    "initialDelay": { "index": 25, "kind": "parameter", "displayName": "Initial Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Milliseconds before the first poll starts." },
-    "repeatCount": { "index": 26, "kind": "parameter", "displayName": "Repeat Count", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever." },
-    "runLoggingLevel": { "index": 27, "kind": "parameter", "displayName": "Run Logging Level", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "org.apache.camel.LoggingLevel", "enum": [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "TRACE", "description": "The consumer logs a start\/complete log line when it polls. This option allows you to configure the logging level for that." },
-    "scheduledExecutorService": { "index": 28, "kind": "parameter", "displayName": "Scheduled Executor Service", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.ScheduledExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "Allows for configuring a custom\/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool." },
-    "scheduler": { "index": 29, "kind": "parameter", "displayName": "Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.lang.Object", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "none", "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler" },
-    "schedulerProperties": { "index": 30, "kind": "parameter", "displayName": "Scheduler Properties", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "prefix": "scheduler.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler." },
-    "startScheduler": { "index": 31, "kind": "parameter", "displayName": "Start Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether the scheduler should be auto started." },
-    "timeUnit": { "index": 32, "kind": "parameter", "displayName": "Time Unit", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.TimeUnit", "enum": [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "MILLISECONDS", "description": "Time unit for initialDelay and delay options." },
-    "useFixedDelay": { "index": 33, "kind": "parameter", "displayName": "Use Fixed Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details." }
+    "variableName": { "index": 8, "kind": "parameter", "displayName": "Variable Name", "group": "common", "label": "", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "description": "To use a variable as the input source instead of Message body." },
+    "sendEmptyMessageWhenIdle": { "index": 9, "kind": "parameter", "displayName": "Send Empty Message When Idle", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead." },
+    "bridgeErrorHandler": { "index": 10, "kind": "parameter", "displayName": "Bridge Error Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
+    "exceptionHandler": { "index": 11, "kind": "parameter", "displayName": "Exception Handler", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.ExceptionHandler", "optionalPrefix": "consumer.", "deprecated": false, "autowired": false, "secret": false, "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
+    "exchangePattern": { "index": 12, "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
+    "pollStrategy": { "index": 13, "kind": "parameter", "displayName": "Poll Strategy", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.spi.PollingConsumerPollStrategy", "deprecated": false, "autowired": false, "secret": false, "description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel." },
+    "lazyStartProducer": { "index": 14, "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
+    "configuration": { "index": 15, "kind": "parameter", "displayName": "Configuration", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.Configuration", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon configuration" },
+    "configurationProperties": { "index": 16, "kind": "parameter", "displayName": "Configuration Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "To set custom Saxon configuration properties" },
+    "moduleURIResolver": { "index": 17, "kind": "parameter", "displayName": "Module URIResolver", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.lib.ModuleURIResolver", "deprecated": false, "autowired": false, "secret": false, "description": "To use the custom ModuleURIResolver" },
+    "parameters": { "index": 18, "kind": "parameter", "displayName": "Parameters", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "deprecated": false, "autowired": false, "secret": false, "description": "Additional parameters" },
+    "properties": { "index": 19, "kind": "parameter", "displayName": "Properties", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "java.util.Properties", "deprecated": false, "autowired": false, "secret": false, "description": "Properties to configure the serialization parameters" },
+    "staticQueryContext": { "index": 20, "kind": "parameter", "displayName": "Static Query Context", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "net.sf.saxon.query.StaticQueryContext", "deprecated": false, "autowired": false, "secret": false, "description": "To use a custom Saxon StaticQueryContext" },
+    "backoffErrorThreshold": { "index": 21, "kind": "parameter", "displayName": "Backoff Error Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in." },
+    "backoffIdleThreshold": { "index": 22, "kind": "parameter", "displayName": "Backoff Idle Threshold", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in." },
+    "backoffMultiplier": { "index": 23, "kind": "parameter", "displayName": "Backoff Multiplier", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles\/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and\/or backoffErrorThreshold must also be configured." },
+    "delay": { "index": 24, "kind": "parameter", "displayName": "Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 500, "description": "Milliseconds before the next poll." },
+    "greedy": { "index": 25, "kind": "parameter", "displayName": "Greedy", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages." },
+    "initialDelay": { "index": 26, "kind": "parameter", "displayName": "Initial Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 1000, "description": "Milliseconds before the first poll starts." },
+    "repeatCount": { "index": 27, "kind": "parameter", "displayName": "Repeat Count", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "integer", "javaType": "long", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever." },
+    "runLoggingLevel": { "index": 28, "kind": "parameter", "displayName": "Run Logging Level", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "org.apache.camel.LoggingLevel", "enum": [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "TRACE", "description": "The consumer logs a start\/complete log line when it polls. This option allows you to configure the logging level for that." },
+    "scheduledExecutorService": { "index": 29, "kind": "parameter", "displayName": "Scheduled Executor Service", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.ScheduledExecutorService", "deprecated": false, "autowired": false, "secret": false, "description": "Allows for configuring a custom\/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool." },
+    "scheduler": { "index": 30, "kind": "parameter", "displayName": "Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.lang.Object", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "none", "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler" },
+    "schedulerProperties": { "index": 31, "kind": "parameter", "displayName": "Scheduler Properties", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.Map<java.lang.String, java.lang.Object>", "prefix": "scheduler.", "multiValue": true, "deprecated": false, "autowired": false, "secret": false, "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler." },
+    "startScheduler": { "index": 32, "kind": "parameter", "displayName": "Start Scheduler", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether the scheduler should be auto started." },
+    "timeUnit": { "index": 33, "kind": "parameter", "displayName": "Time Unit", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "object", "javaType": "java.util.concurrent.TimeUnit", "enum": [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ], "deprecated": false, "autowired": false, "secret": false, "defaultValue": "MILLISECONDS", "description": "Time unit for initialDelay and delay options." },
+    "useFixedDelay": { "index": 34, "kind": "parameter", "displayName": "Use Fixed Delay", "group": "scheduler", "label": "consumer,scheduler", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details." }
   }
 }
diff --git a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQuery.java b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQuery.java
index 6d160dd7298..43631161df5 100644
--- a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQuery.java
+++ b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQuery.java
@@ -49,14 +49,17 @@ public @interface XQuery {
     Class<?> resultType() default Object.class;
 
     /**
-     * @return The name of the header we want to apply the XQuery expression to. If this is empty then the Xquery
-     *         expression will be applied to the value of the exchange property or the body instead.
+     * The name of the variable we want to apply the expression to.
+     */
+    String variableName() default "";
+
+    /**
+     * The name of the header we want to apply the expression to.
      */
     String headerName() default "";
 
     /**
-     * @return The name of the property we want to apply the XQuery expression to. If this is empty then the Xquery
-     *         expression will be applied to the body instead.
+     * The name of the exchange property we want to apply the expression to.
      */
     String propertyName() default "";
 }
diff --git a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryAnnotationExpressionFactory.java b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryAnnotationExpressionFactory.java
index 12cbd2be1dd..cfe3156ce37 100644
--- a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryAnnotationExpressionFactory.java
+++ b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryAnnotationExpressionFactory.java
@@ -23,6 +23,7 @@ import org.w3c.dom.Node;
 import net.sf.saxon.functions.CollectionFn;
 import org.apache.camel.CamelContext;
 import org.apache.camel.Expression;
+import org.apache.camel.support.builder.ExpressionBuilder;
 import org.apache.camel.support.language.DefaultAnnotationExpressionFactory;
 import org.apache.camel.support.language.LanguageAnnotation;
 import org.apache.camel.support.language.NamespacePrefix;
@@ -39,12 +40,23 @@ public class XQueryAnnotationExpressionFactory extends DefaultAnnotationExpressi
         if (annotation instanceof XQuery) {
             XQuery xQueryAnnotation = (XQuery) annotation;
             builder.setStripsAllWhiteSpace(xQueryAnnotation.stripsAllWhiteSpace());
+
+            String variableName = null;
+            String headerName = null;
+            String propertyName = null;
+            if (ObjectHelper.isNotEmpty(xQueryAnnotation.variableName())) {
+                variableName = xQueryAnnotation.variableName();
+            }
             if (ObjectHelper.isNotEmpty(xQueryAnnotation.headerName())) {
-                builder.setHeaderName(xQueryAnnotation.headerName());
+                headerName = xQueryAnnotation.headerName();
             }
             if (ObjectHelper.isNotEmpty(xQueryAnnotation.propertyName())) {
-                builder.setPropertyName(xQueryAnnotation.propertyName());
+                propertyName = xQueryAnnotation.propertyName();
             }
+            if (variableName != null || headerName != null || propertyName != null) {
+                builder.setSource(ExpressionBuilder.singleInputExpression(variableName, headerName, propertyName));
+            }
+
             NamespacePrefix[] namespaces = xQueryAnnotation.namespaces();
             if (namespaces != null) {
                 for (NamespacePrefix namespacePrefix : namespaces) {
diff --git a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryBuilder.java b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryBuilder.java
index f4d2af3bcfa..ce7acd33e60 100644
--- a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryBuilder.java
+++ b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryBuilder.java
@@ -65,7 +65,6 @@ import net.sf.saxon.value.StringValue;
 import org.apache.camel.CamelContext;
 import org.apache.camel.Exchange;
 import org.apache.camel.Expression;
-import org.apache.camel.Message;
 import org.apache.camel.NoTypeConversionAvailableException;
 import org.apache.camel.Predicate;
 import org.apache.camel.Processor;
@@ -100,9 +99,7 @@ public abstract class XQueryBuilder implements Expression, Predicate, NamespaceA
     private boolean stripsAllWhiteSpace = true;
     private ModuleURIResolver moduleURIResolver;
     private boolean allowStAX;
-    private String headerName;
-    private String propertyName;
-    private String variableName;
+    private Expression source;
 
     @Override
     public String toString() {
@@ -518,41 +515,6 @@ public abstract class XQueryBuilder implements Expression, Predicate, NamespaceA
         this.stripsAllWhiteSpace = stripsAllWhiteSpace;
     }
 
-    public String getHeaderName() {
-        return headerName;
-    }
-
-    /**
-     * Name of header to use as input, instead of the message body
-     */
-    public void setHeaderName(String headerName) {
-        this.headerName = headerName;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
-    }
-
-    /**
-     * Name of property to use as input, instead of the message body.
-     * <p>
-     * It has a lower precedent than the name of header if both are set.
-     */
-    public void setPropertyName(String propertyName) {
-        this.propertyName = propertyName;
-    }
-
-    public String getVariableName() {
-        return variableName;
-    }
-
-    /**
-     * Name of variable to use as input, instead of the message body
-     */
-    public void setVariableName(String variableName) {
-        this.variableName = variableName;
-    }
-
     public boolean isAllowStAX() {
         return allowStAX;
     }
@@ -561,6 +523,14 @@ public abstract class XQueryBuilder implements Expression, Predicate, NamespaceA
         this.allowStAX = allowStAX;
     }
 
+    public Expression getSource() {
+        return source;
+    }
+
+    public void setSource(Expression source) {
+        this.source = source;
+    }
+
     // Implementation methods
     // -------------------------------------------------------------------------
 
@@ -577,56 +547,26 @@ public abstract class XQueryBuilder implements Expression, Predicate, NamespaceA
         Configuration config = getConfiguration();
         DynamicQueryContext dynamicQueryContext = new DynamicQueryContext(config);
 
-        Message in = exchange.getIn();
-        Item item;
-        if (ObjectHelper.isNotEmpty(getHeaderName())) {
-            item = in.getHeader(getHeaderName(), Item.class);
-        } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
-            item = exchange.getProperty(getPropertyName(), Item.class);
-        } else if (ObjectHelper.isNotEmpty(getVariableName())) {
-            item = exchange.getVariable(getVariableName(), Item.class);
-        } else {
-            item = in.getBody(Item.class);
-        }
+        Object payload = source != null ? source.evaluate(exchange, Object.class) : exchange.getMessage().getBody();
+        Item item = exchange.getContext().getTypeConverter().tryConvertTo(Item.class, exchange, payload);
         if (item != null) {
             dynamicQueryContext.setContextItem(item);
         } else {
-            Object body;
-            if (ObjectHelper.isNotEmpty(getHeaderName())) {
-                body = in.getHeader(getHeaderName());
-            } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
-                body = exchange.getProperty(getPropertyName());
-            } else if (ObjectHelper.isNotEmpty(getVariableName())) {
-                body = exchange.getVariable(getVariableName());
-            } else {
-                body = in.getBody();
-            }
-
             // the underlying input stream, which we need to close to avoid locking files or other resources
             InputStream is = null;
             try {
                 Source source;
                 // only convert to input stream if really needed
-                if (isInputStreamNeeded(exchange)) {
-                    if (ObjectHelper.isNotEmpty(getHeaderName())) {
-                        is = exchange.getIn().getHeader(getHeaderName(), InputStream.class);
-                    } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
-                        is = exchange.getProperty(getPropertyName(), InputStream.class);
-                    } else if (ObjectHelper.isNotEmpty(getVariableName())) {
-                        is = exchange.getVariable(getVariableName(), InputStream.class);
-                    } else {
-                        is = exchange.getIn().getBody(InputStream.class);
-                    }
+                if (isInputStreamNeeded(payload)) {
+                    is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, payload);
                     source = getSource(exchange, is);
                 } else {
-                    source = getSource(exchange, body);
+                    source = getSource(exchange, payload);
                 }
-
                 if (source == null) {
                     // indicate it was not possible to convert to a Source type
-                    throw new NoTypeConversionAvailableException(body, Source.class);
+                    throw new NoTypeConversionAvailableException(payload, Source.class);
                 }
-
                 TreeInfo doc = config.buildDocumentTree(source);
                 dynamicQueryContext.setContextItem(doc.getRootNode());
             } finally {
@@ -646,23 +586,20 @@ public abstract class XQueryBuilder implements Expression, Predicate, NamespaceA
      * <p/>
      * Depending on the content in the message body, we may not need to convert to {@link InputStream}.
      *
-     * @param  exchange the current exchange
-     * @return          <tt>true</tt> to convert to {@link InputStream} beforehand converting to {@link Source}
-     *                  afterwards.
+     * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting to {@link Source} afterwards.
      */
-    protected boolean isInputStreamNeeded(Exchange exchange) {
-        Object body = exchange.getIn().getBody();
-        if (body == null) {
+    protected boolean isInputStreamNeeded(Object payload) {
+        if (payload == null) {
             return false;
         }
 
-        if (body instanceof Source) {
+        if (payload instanceof Source) {
             return false;
-        } else if (body instanceof String) {
+        } else if (payload instanceof String) {
             return false;
-        } else if (body instanceof byte[]) {
+        } else if (payload instanceof byte[]) {
             return false;
-        } else if (body instanceof Node) {
+        } else if (payload instanceof Node) {
             return false;
         }
 
diff --git a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryEndpoint.java b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryEndpoint.java
index 90c18106b1b..fb5daf6edbd 100644
--- a/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryEndpoint.java
+++ b/components/camel-saxon/src/main/java/org/apache/camel/component/xquery/XQueryEndpoint.java
@@ -32,6 +32,7 @@ import org.apache.camel.spi.UriParam;
 import org.apache.camel.spi.UriPath;
 import org.apache.camel.support.ProcessorEndpoint;
 import org.apache.camel.support.ResourceHelper;
+import org.apache.camel.support.builder.ExpressionBuilder;
 import org.apache.camel.support.service.ServiceHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -73,6 +74,8 @@ public class XQueryEndpoint extends ProcessorEndpoint {
     @UriParam
     private boolean allowStAX;
     @UriParam
+    private String variableName;
+    @UriParam
     private String headerName;
     @UriParam
     private String propertyName;
@@ -213,6 +216,17 @@ public class XQueryEndpoint extends ProcessorEndpoint {
         this.allowStAX = allowStAX;
     }
 
+    public String getVariableName() {
+        return variableName;
+    }
+
+    /**
+     * To use a variable as the input source instead of Message body.
+     */
+    public void setVariableName(String variableName) {
+        this.variableName = variableName;
+    }
+
     public String getHeaderName() {
         return headerName;
     }
@@ -230,8 +244,6 @@ public class XQueryEndpoint extends ProcessorEndpoint {
 
     /**
      * To use a Camel Exchange property as the input source instead of Message body.
-     * <p>
-     * It has a lower precedent than the name of header if both are set.
      */
     public void setPropertyName(String propertyName) {
         this.propertyName = propertyName;
@@ -269,9 +281,8 @@ public class XQueryEndpoint extends ProcessorEndpoint {
         this.xquery.setResultType(getResultType());
         this.xquery.setStripsAllWhiteSpace(isStripsAllWhiteSpace());
         this.xquery.setAllowStAX(isAllowStAX());
-        this.xquery.setHeaderName(getHeaderName());
-        this.xquery.setPropertyName(getPropertyName());
         this.xquery.setModuleURIResolver(getModuleURIResolver());
+        this.xquery.setSource(ExpressionBuilder.singleInputExpression(getVariableName(), getHeaderName(), getPropertyName()));
         this.xquery.init(getCamelContext());
 
         setProcessor(xquery);
diff --git a/components/camel-saxon/src/main/java/org/apache/camel/language/xquery/XQueryLanguage.java b/components/camel-saxon/src/main/java/org/apache/camel/language/xquery/XQueryLanguage.java
index 219b29111fc..6fd03362817 100644
--- a/components/camel-saxon/src/main/java/org/apache/camel/language/xquery/XQueryLanguage.java
+++ b/components/camel-saxon/src/main/java/org/apache/camel/language/xquery/XQueryLanguage.java
@@ -19,7 +19,6 @@ package org.apache.camel.language.xquery;
 import net.sf.saxon.Configuration;
 import org.apache.camel.CamelContext;
 import org.apache.camel.Expression;
-import org.apache.camel.Predicate;
 import org.apache.camel.component.xquery.XQueryBuilder;
 import org.apache.camel.spi.PropertyConfigurer;
 import org.apache.camel.spi.annotations.Language;
@@ -43,46 +42,21 @@ public class XQueryLanguage extends SingleInputTypedLanguageSupport implements P
     }
 
     @Override
-    public Predicate createPredicate(String expression) {
-        return (Predicate) createExpression(expression, null);
-    }
-
-    @Override
-    public Expression createExpression(String expression) {
-        return createExpression(expression, null);
-    }
-
-    @Override
-    public Predicate createPredicate(String expression, Object[] properties) {
-        return (Predicate) createExpression(expression, properties);
-    }
-
-    @Override
-    public Expression createExpression(String expression, Object[] properties) {
+    public Expression createExpression(Expression source, String expression, Object[] properties) {
         expression = loadResource(expression);
 
         XQueryBuilder builder = XQueryBuilder.xquery(expression);
-        configureBuilder(builder, properties);
+        configureBuilder(builder, properties, source);
         return builder;
     }
 
-    protected void configureBuilder(XQueryBuilder builder, Object[] properties) {
+    protected void configureBuilder(XQueryBuilder builder, Object[] properties, Expression source) {
+        builder.setSource(source);
+
         Class<?> clazz = property(Class.class, properties, 0, getResultType());
         if (clazz != null) {
             builder.setResultType(clazz);
         }
-        String str = property(String.class, properties, 1, getHeaderName());
-        if (str != null) {
-            builder.setHeaderName(str);
-        }
-        str = property(String.class, properties, 2, getPropertyName());
-        if (str != null) {
-            builder.setPropertyName(str);
-        }
-        str = property(String.class, properties, 3, getVariableName());
-        if (str != null) {
-            builder.setVariableName(str);
-        }
         if (configuration != null) {
             builder.setConfiguration(configuration);
         }
@@ -98,18 +72,6 @@ public class XQueryLanguage extends SingleInputTypedLanguageSupport implements P
             case "resultType":
                 setResultType(PropertyConfigurerSupport.property(camelContext, Class.class, value));
                 return true;
-            case "headername":
-            case "headerName":
-                setHeaderName(PropertyConfigurerSupport.property(camelContext, String.class, value));
-                return true;
-            case "propertyname":
-            case "propertyName":
-                setPropertyName(PropertyConfigurerSupport.property(camelContext, String.class, value));
-                return true;
-            case "variablename":
-            case "variableName":
-                setVariableName(PropertyConfigurerSupport.property(camelContext, String.class, value));
-                return true;
             case "configuration":
             case "Configuration":
                 setConfiguration(PropertyConfigurerSupport.property(camelContext, Configuration.class, value));
diff --git a/components/camel-stax/src/main/java/org/apache/camel/language/xtokenizer/XMLTokenizeLanguage.java b/components/camel-stax/src/main/java/org/apache/camel/language/xtokenizer/XMLTokenizeLanguage.java
index dca18770abf..73ef1d1fc21 100644
--- a/components/camel-stax/src/main/java/org/apache/camel/language/xtokenizer/XMLTokenizeLanguage.java
+++ b/components/camel-stax/src/main/java/org/apache/camel/language/xtokenizer/XMLTokenizeLanguage.java
@@ -22,7 +22,7 @@ import org.apache.camel.Expression;
 import org.apache.camel.Predicate;
 import org.apache.camel.spi.annotations.Language;
 import org.apache.camel.support.ExpressionToPredicateAdapter;
-import org.apache.camel.support.SingleInputLanguageSupport;
+import org.apache.camel.support.LanguageSupport;
 import org.apache.camel.support.builder.Namespaces;
 
 /**
@@ -37,7 +37,7 @@ import org.apache.camel.support.builder.Namespaces;
  * </ul>
  */
 @Language("xtokenize")
-public class XMLTokenizeLanguage extends SingleInputLanguageSupport {
+public class XMLTokenizeLanguage extends LanguageSupport {
 
     @Override
     public Predicate createPredicate(String expression) {
@@ -59,7 +59,7 @@ public class XMLTokenizeLanguage extends SingleInputLanguageSupport {
         Character mode = property(Character.class, properties, 1, "i");
 
         XMLTokenExpressionIterator answer = new XMLTokenExpressionIterator(expression, mode);
-        answer.setHeaderName(property(String.class, properties, 0, getHeaderName()));
+        answer.setHeaderName(property(String.class, properties, 0, null));
         answer.setGroup(property(int.class, properties, 2, 1));
         Object obj = properties[3];
         if (obj != null) {
diff --git a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPath.java b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPath.java
index 1235f488ecd..74165579346 100644
--- a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPath.java
+++ b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPath.java
@@ -54,16 +54,17 @@ public @interface XPath {
     Class<?> resultType() default Object.class;
 
     /**
-     * The name of the header we want to apply the XPath expression to. If this is empty then the XPath expression will
-     * be applied to the exchange property or the body instead.
+     * The name of the variable we want to apply the XPath expression to.
+     */
+    String variableName() default "";
+
+    /**
+     * The name of the message header we want to apply the XPath expression to.
      */
     String headerName() default "";
 
     /**
-     * The name of the header we want to apply the XPath expression to. If this is empty then the XPath expression will
-     * be applied to the body instead.
-     * <p>
-     * It has a lower precedent than the name of header if both are set.
+     * The name of the exchange propery we want to apply the XPath expression to.
      */
     String propertyName() default "";
 
diff --git a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathAnnotationExpressionFactory.java b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathAnnotationExpressionFactory.java
index ff69b075d4b..f31bc1a3bc4 100644
--- a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathAnnotationExpressionFactory.java
+++ b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathAnnotationExpressionFactory.java
@@ -20,10 +20,10 @@ import java.lang.annotation.Annotation;
 
 import org.apache.camel.CamelContext;
 import org.apache.camel.Expression;
+import org.apache.camel.support.builder.ExpressionBuilder;
 import org.apache.camel.support.language.DefaultAnnotationExpressionFactory;
 import org.apache.camel.support.language.LanguageAnnotation;
 import org.apache.camel.support.language.NamespacePrefix;
-import org.apache.camel.util.ObjectHelper;
 
 /**
  * Factory for the XPath expression annotations.
@@ -51,14 +51,12 @@ public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressio
             }
         }
 
-        // Set the header name that we want the XPathBuilder to apply the XPath expression to
+        String variableName = getVariableName(annotation);
         String headerName = getHeaderName(annotation);
-        if (ObjectHelper.isNotEmpty(headerName)) {
-            builder.setHeaderName(headerName);
-        }
         String propertyName = getPropertyName(annotation);
-        if (ObjectHelper.isNotEmpty(propertyName)) {
-            builder.setPropertyName(propertyName);
+        if (variableName != null || headerName != null || propertyName != null) {
+            Expression source = ExpressionBuilder.singleInputExpression(variableName, headerName, propertyName);
+            builder.setSource(source);
         }
 
         return builder;
@@ -80,13 +78,16 @@ public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressio
      *         expression to. Otherwise, null will be returned
      */
     protected String getHeaderName(Annotation annotation) {
-        String headerValue = null;
+        String answer = null;
         try {
-            headerValue = (String) getAnnotationObjectValue(annotation, "headerName");
+            answer = (String) getAnnotationObjectValue(annotation, "headerName");
         } catch (Exception e) {
             // Do Nothing
         }
-        return headerValue;
+        if (answer != null && answer.isBlank()) {
+            return null;
+        }
+        return answer;
     }
 
     /**
@@ -97,13 +98,36 @@ public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressio
      *         expression to. Otherwise, null will be returned
      */
     protected String getPropertyName(Annotation annotation) {
-        String propertyValue = null;
+        String answer = null;
+        try {
+            answer = (String) getAnnotationObjectValue(annotation, "propertyName");
+        } catch (Exception e) {
+            // Do Nothing
+        }
+        if (answer != null && answer.isBlank()) {
+            return null;
+        }
+        return answer;
+    }
+
+    /**
+     * Extracts the value of the property method in the Annotation. For backwards compatibility this method will return
+     * null if the annotation's method is not found.
+     *
+     * @return If the annotation has the method 'variableName' then the name of the property we want to apply the XPath
+     *         expression to. Otherwise, null will be returned
+     */
+    protected String getVariableName(Annotation annotation) {
+        String answer = null;
         try {
-            propertyValue = (String) getAnnotationObjectValue(annotation, "propertyName");
+            answer = (String) getAnnotationObjectValue(annotation, "variableName");
         } catch (Exception e) {
             // Do Nothing
         }
-        return propertyValue;
+        if (answer != null && answer.isBlank()) {
+            return null;
+        }
+        return answer;
     }
 
     protected boolean isLogNamespaces(Annotation annotation) {
diff --git a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathBuilder.java b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathBuilder.java
index e1e2d4e3312..8dbc7087b32 100644
--- a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathBuilder.java
+++ b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathBuilder.java
@@ -127,18 +127,7 @@ public class XPathBuilder extends ServiceSupport
     private volatile XPathFunction outHeaderFunction;
     private volatile XPathFunction propertiesFunction;
     private volatile XPathFunction simpleFunction;
-    /**
-     * The name of the header we want to apply the XPath expression to, which when set will cause the xpath to be
-     * evaluated on the required header, otherwise it will be applied to the value of the property or the body
-     */
-    private volatile String headerName;
-    /**
-     * The name of the property we want to apply the XPath expression to, which when set will cause the xpath to be
-     * evaluated on the required property, otherwise it will be applied to the body
-     * <p>
-     * It has a lower precedent than the name of header if both are set.
-     */
-    private volatile String propertyName;
+    private volatile Expression source;
 
     /**
      * @param text The XPath expression
@@ -563,22 +552,6 @@ public class XPathBuilder extends ServiceSupport
         this.resultQName = resultQName;
     }
 
-    public String getHeaderName() {
-        return headerName;
-    }
-
-    public void setHeaderName(String headerName) {
-        this.headerName = headerName;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
-    }
-
-    public void setPropertyName(String propertyName) {
-        this.propertyName = propertyName;
-    }
-
     public boolean isThreadSafety() {
         return threadSafety;
     }
@@ -820,6 +793,14 @@ public class XPathBuilder extends ServiceSupport
         this.simpleFunction = simpleFunction;
     }
 
+    public Expression getSource() {
+        return source;
+    }
+
+    public void setSource(Expression source) {
+        this.source = source;
+    }
+
     @Override
     public String getExpressionText() {
         return text;
@@ -1017,42 +998,16 @@ public class XPathBuilder extends ServiceSupport
         // set exchange and variable resolver as thread locals for concurrency
         this.exchange.set(exchange);
 
-        // the underlying input stream, which we need to close to avoid locking
-        // files or other resources
+        Object payload = source != null ? source.evaluate(exchange, Object.class) : exchange.getMessage().getBody();
+        Object document;
         InputStream is = null;
+        if (isInputStreamNeededForObject(payload)) {
+            is = exchange.getContext().getTypeConverter().tryConvertTo(InputStream.class, exchange, payload);
+            document = getDocument(exchange, is);
+        } else {
+            document = getDocument(exchange, payload);
+        }
         try {
-            Object document;
-
-            // Check if we need to apply the XPath expression to a header
-            if (ObjectHelper.isNotEmpty(getHeaderName())) {
-                // only convert to input stream if really needed
-                if (isInputStreamNeeded(exchange, headerName)) {
-                    is = exchange.getIn().getHeader(headerName, InputStream.class);
-                    document = getDocument(exchange, is);
-                } else {
-                    Object headerObject = exchange.getIn().getHeader(getHeaderName());
-                    document = getDocument(exchange, headerObject);
-                }
-            } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
-                // only convert to input stream if really needed
-                if (isInputStreamNeededForProperty(exchange, propertyName)) {
-                    is = exchange.getProperty(propertyName, InputStream.class);
-                    document = getDocument(exchange, is);
-                } else {
-                    Object headerObject = exchange.getProperty(propertyName);
-                    document = getDocument(exchange, headerObject);
-                }
-            } else {
-                // only convert to input stream if really needed
-                if (isInputStreamNeeded(exchange)) {
-                    is = exchange.getIn().getBody(InputStream.class);
-                    document = getDocument(exchange, is);
-                } else {
-                    Object body = exchange.getIn().getBody();
-                    document = getDocument(exchange, body);
-                }
-            }
-
             if (resultQName != null) {
                 if (document == null) {
                     document = new XMLConverterHelper().createDocument();
@@ -1079,22 +1034,11 @@ public class XPathBuilder extends ServiceSupport
             }
         } catch (ParserConfigurationException e) {
             String message = getText();
-            if (ObjectHelper.isNotEmpty(getHeaderName())) {
-                message = message + " with headerName " + getHeaderName();
-            } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
-                message = message + " with propertyName " + getPropertyName();
-            }
             throw new RuntimeCamelException(message, e);
         } catch (XPathExpressionException e) {
             String message = getText();
-            if (ObjectHelper.isNotEmpty(getHeaderName())) {
-                message = message + " with headerName " + getHeaderName();
-            } else if (ObjectHelper.isNotEmpty(getPropertyName())) {
-                message = message + " with propertyName " + getPropertyName();
-            }
             throw new InvalidXPathException(message, e);
         } finally {
-            // IOHelper can handle if is is null
             IOHelper.close(is);
         }
 
@@ -1102,7 +1046,7 @@ public class XPathBuilder extends ServiceSupport
             try {
                 NodeList list = (NodeList) answer;
 
-                // when the result is NodeList and it has 1 or more elements then its not thread-safe to use concurrently
+                // when the result is NodeList and has 1 or more elements, then it is not thread-safe to use concurrently,
                 // and we need to clone each node and build a thread-safe list to be used instead
                 boolean threadSafetyNeeded = list.getLength() >= 1;
                 if (threadSafetyNeeded) {
@@ -1242,33 +1186,7 @@ public class XPathBuilder extends ServiceSupport
      */
     protected boolean isInputStreamNeeded(Exchange exchange) {
         Object body = exchange.getIn().getBody();
-        return isInputStreamNeededForObject(exchange, body);
-    }
-
-    /**
-     * Checks whether we need an {@link InputStream} to access the message header.
-     * <p/>
-     * Depending on the content in the message header, we may not need to convert to {@link InputStream}.
-     *
-     * @param  exchange the current exchange
-     * @return          <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.
-     */
-    protected boolean isInputStreamNeeded(Exchange exchange, String headerName) {
-        Object header = exchange.getIn().getHeader(headerName);
-        return isInputStreamNeededForObject(exchange, header);
-    }
-
-    /**
-     * Checks whether we need an {@link InputStream} to access the exchange property.
-     * <p/>
-     * Depending on the content in the exchange property, we may not need to convert to {@link InputStream}.
-     *
-     * @param  exchange the current exchange
-     * @return          <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.
-     */
-    protected boolean isInputStreamNeededForProperty(Exchange exchange, String propertyName) {
-        Object property = exchange.getProperty(propertyName);
-        return isInputStreamNeededForObject(exchange, property);
+        return isInputStreamNeededForObject(body);
     }
 
     /**
@@ -1276,10 +1194,10 @@ public class XPathBuilder extends ServiceSupport
      * <p/>
      * Depending on the content in the object, we may not need to convert to {@link InputStream}.
      *
-     * @param  exchange the current exchange
-     * @return          <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.
+     * @param  obj the object
+     * @return     <tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.
      */
-    protected boolean isInputStreamNeededForObject(Exchange exchange, Object obj) {
+    protected boolean isInputStreamNeededForObject(Object obj) {
         if (obj == null) {
             return false;
         }
diff --git a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathLanguage.java b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathLanguage.java
index b41cde8862d..a0e158f5010 100644
--- a/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathLanguage.java
+++ b/components/camel-xpath/src/main/java/org/apache/camel/language/xpath/XPathLanguage.java
@@ -16,7 +16,10 @@
  */
 package org.apache.camel.language.xpath;
 
+import java.util.Map;
+
 import javax.xml.namespace.QName;
+import javax.xml.xpath.XPathConstants;
 import javax.xml.xpath.XPathFactory;
 
 import org.apache.camel.CamelContext;
@@ -42,34 +45,21 @@ public class XPathLanguage extends SingleInputTypedLanguageSupport implements Pr
     private Boolean preCompile;
 
     @Override
-    public Predicate createPredicate(String expression) {
+    public Predicate createPredicate(Expression source, String expression, Object[] properties) {
         expression = loadResource(expression);
 
         XPathBuilder builder = XPathBuilder.xpath(expression);
-        configureBuilder(builder, null);
+        configureBuilder(builder, properties, source);
+        builder.setResultQName(XPathConstants.BOOLEAN); // use boolean for predicate mode
         return builder;
     }
 
     @Override
-    public Expression createExpression(String expression) {
+    public Expression createExpression(Expression source, String expression, Object[] properties) {
         expression = loadResource(expression);
 
         XPathBuilder builder = XPathBuilder.xpath(expression);
-        configureBuilder(builder, null);
-        return builder;
-    }
-
-    @Override
-    public Predicate createPredicate(String expression, Object[] properties) {
-        return (Predicate) createExpression(expression, properties);
-    }
-
-    @Override
-    public Expression createExpression(String expression, Object[] properties) {
-        expression = loadResource(expression);
-
-        XPathBuilder builder = XPathBuilder.xpath(expression);
-        configureBuilder(builder, properties);
+        configureBuilder(builder, properties, source);
         return builder;
     }
 
@@ -137,20 +127,22 @@ public class XPathLanguage extends SingleInputTypedLanguageSupport implements Pr
         this.preCompile = preCompile;
     }
 
-    protected void configureBuilder(XPathBuilder builder, Object[] properties) {
-        Class<?> clazz = property(Class.class, properties, 0, documentType);
+    protected void configureBuilder(XPathBuilder builder, Object[] properties, Expression source) {
+        builder.setSource(source);
+
+        Class<?> clazz = property(Class.class, properties, 4, documentType);
         if (clazz != null) {
             builder.setDocumentType(clazz);
         }
-        QName qname = property(QName.class, properties, 1, resultQName);
+        QName qname = property(QName.class, properties, 5, resultQName);
         if (qname != null) {
             builder.setResultQName(qname);
         }
-        clazz = property(Class.class, properties, 2, getResultType());
+        clazz = property(Class.class, properties, 0, getResultType());
         if (clazz != null) {
             builder.setResultType(clazz);
         }
-        Boolean bool = property(Boolean.class, properties, 3, saxon);
+        Boolean bool = property(Boolean.class, properties, 6, saxon);
         if (bool != null) {
             builder.setUseSaxon(bool);
             if (bool) {
@@ -159,34 +151,30 @@ public class XPathLanguage extends SingleInputTypedLanguageSupport implements Pr
         }
         if (!builder.isUseSaxon()) {
             // xpath factory can only be set if not saxon is enabled as saxon has its own factory and object model
-            XPathFactory fac = property(XPathFactory.class, properties, 4, xpathFactory);
+            XPathFactory fac = property(XPathFactory.class, properties, 7, xpathFactory);
             if (fac != null) {
                 builder.setXPathFactory(fac);
             }
-            String str = property(String.class, properties, 5, objectModelUri);
+            String str = property(String.class, properties, 8, objectModelUri);
             if (str != null) {
                 builder.setObjectModelUri(str);
             }
         }
-        bool = property(Boolean.class, properties, 6, threadSafety);
+        bool = property(Boolean.class, properties, 9, threadSafety);
         if (bool != null) {
             builder.setThreadSafety(bool);
         }
-        bool = property(Boolean.class, properties, 7, preCompile);
+        bool = property(Boolean.class, properties, 10, preCompile);
         if (bool != null) {
             builder.setPreCompile(bool);
         }
-        bool = property(Boolean.class, properties, 8, logNamespaces);
+        bool = property(Boolean.class, properties, 11, logNamespaces);
         if (bool != null) {
             builder.setLogNamespaces(bool);
         }
-        String str = property(String.class, properties, 9, getHeaderName());
-        if (str != null) {
-            builder.setHeaderName(str);
-        }
-        str = property(String.class, properties, 10, getPropertyName());
-        if (str != null) {
-            builder.setPropertyName(str);
+        Map<String, String> ns = property(Map.class, properties, 12, null);
+        if (ns != null && !ns.isEmpty()) {
+            builder.setNamespaces(ns);
         }
     }
 
@@ -227,14 +215,6 @@ public class XPathLanguage extends SingleInputTypedLanguageSupport implements Pr
             case "logNamespaces":
                 setLogNamespaces(PropertyConfigurerSupport.property(camelContext, Boolean.class, value));
                 return true;
-            case "headername":
-            case "headerName":
-                setHeaderName(PropertyConfigurerSupport.property(camelContext, String.class, value));
-                return true;
-            case "propertyname":
-            case "propertyName":
-                setPropertyName(PropertyConfigurerSupport.property(camelContext, String.class, value));
-                return true;
             case "preCompile":
             case "precompile":
                 setPreCompile(PropertyConfigurerSupport.property(camelContext, Boolean.class, value));
diff --git a/core/camel-api/src/main/java/org/apache/camel/NoSuchHeaderException.java b/core/camel-api/src/main/java/org/apache/camel/NoSuchHeaderException.java
index 39a2d0e8e53..b3bdfd5d8a0 100644
--- a/core/camel-api/src/main/java/org/apache/camel/NoSuchHeaderException.java
+++ b/core/camel-api/src/main/java/org/apache/camel/NoSuchHeaderException.java
@@ -26,8 +26,14 @@ public class NoSuchHeaderException extends CamelExchangeException {
     private final String headerName;
     private final transient Class<?> type;
 
+    public NoSuchHeaderException(String message, Exchange exchange, String headerName) {
+        super(message, exchange);
+        this.headerName = headerName;
+        this.type = null;
+    }
+
     public NoSuchHeaderException(Exchange exchange, String headerName, Class<?> type) {
-        super("No '" + headerName + "' header available of type: " + type.getName()
+        super("No '" + headerName + "' header available" + (type != null ? " of type: " + type.getName() : "")
               + reason(exchange, headerName), exchange);
         this.headerName = headerName;
         this.type = type;
@@ -41,8 +47,8 @@ public class NoSuchHeaderException extends CamelExchangeException {
         return type;
     }
 
-    protected static String reason(Exchange exchange, String propertyName) {
-        Object value = exchange.getProperty(propertyName);
+    protected static String reason(Exchange exchange, String headerName) {
+        Object value = exchange.getMessage().getHeader(headerName);
         return valueDescription(value);
     }
 
diff --git a/core/camel-api/src/main/java/org/apache/camel/NoSuchPropertyException.java b/core/camel-api/src/main/java/org/apache/camel/NoSuchPropertyException.java
index 527c4eb6fcb..30a242ed51b 100644
--- a/core/camel-api/src/main/java/org/apache/camel/NoSuchPropertyException.java
+++ b/core/camel-api/src/main/java/org/apache/camel/NoSuchPropertyException.java
@@ -20,15 +20,18 @@ package org.apache.camel;
  * An exception caused when a mandatory property is not available on a message {@link Exchange}
  *
  * @see org.apache.camel.support.ExchangeHelper#getMandatoryProperty(Exchange, String, Class)
- *
  */
 public class NoSuchPropertyException extends CamelExchangeException {
 
     private final String propertyName;
     private final transient Class<?> type;
 
+    public NoSuchPropertyException(Exchange exchange, String propertyName) {
+        this(exchange, propertyName, null);
+    }
+
     public NoSuchPropertyException(Exchange exchange, String propertyName, Class<?> type) {
-        super("No '" + propertyName + "' property available of type: " + type.getName()
+        super("No '" + propertyName + "' exchange property available" + (type != null ? " of type: " + type.getName() : "")
               + reason(exchange, propertyName), exchange);
         this.propertyName = propertyName;
         this.type = type;
diff --git a/core/camel-api/src/main/java/org/apache/camel/NoSuchVariableException.java b/core/camel-api/src/main/java/org/apache/camel/NoSuchVariableException.java
index 8521c7d768f..25dc319d8b4 100644
--- a/core/camel-api/src/main/java/org/apache/camel/NoSuchVariableException.java
+++ b/core/camel-api/src/main/java/org/apache/camel/NoSuchVariableException.java
@@ -16,6 +16,9 @@
  */
 package org.apache.camel;
 
+/**
+ * An exception caused when a mandatory variable is not available
+ */
 public class NoSuchVariableException extends CamelExchangeException {
 
     private final String variableName;
diff --git a/core/camel-core-catalog/src/main/java/org/apache/camel/catalog/impl/AbstractCamelCatalog.java b/core/camel-core-catalog/src/main/java/org/apache/camel/catalog/impl/AbstractCamelCatalog.java
index 93ed919158a..0a6126ac729 100644
--- a/core/camel-core-catalog/src/main/java/org/apache/camel/catalog/impl/AbstractCamelCatalog.java
+++ b/core/camel-core-catalog/src/main/java/org/apache/camel/catalog/impl/AbstractCamelCatalog.java
@@ -1455,10 +1455,10 @@ public abstract class AbstractCamelCatalog {
                     } else {
                         instance.getClass().getMethod("validateExpression", String.class).invoke(instance, text);
                     }
+                    return answer;
                 } catch (NoSuchMethodException e) {
-                    // ignore
+                     // ignore
                 }
-                // optional validate
                 if (predicate) {
                     instance.getClass().getMethod("createPredicate", String.class).invoke(instance, text);
                 } else {
diff --git a/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClauseSupport.java b/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClauseSupport.java
index 1054eec3ed6..5acd7b97e3e 100644
--- a/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClauseSupport.java
+++ b/core/camel-core-model/src/main/java/org/apache/camel/builder/ExpressionClauseSupport.java
@@ -458,14 +458,13 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
     /**
      * Evaluates <a href="http://camel.apache.org/jq.html">JQ expression</a>
      *
-     * @param  text                 the expression to be evaluated
-     * @param  headerOrPropertyName the name of the header or the property to apply the expression to
-     * @return                      the builder to continue processing the DSL
+     * @param  text       the expression to be evaluated
+     * @param  headerName the name of the header to apply the expression to
+     * @return            the builder to continue processing the DSL
      */
-    public T jq(String text, String headerOrPropertyName) {
+    public T jq(String text, String headerName) {
         JqExpression exp = new JqExpression(text);
-        exp.setHeaderName(headerOrPropertyName);
-        exp.setPropertyName(headerOrPropertyName);
+        exp.setHeaderName(headerName);
         return expression(exp);
     }
 
@@ -487,16 +486,15 @@ public class ExpressionClauseSupport<T> implements ExpressionFactoryAware, Predi
     /**
      * Evaluates <a href="http://camel.apache.org/jq.html">JQ expression</a>
      *
-     * @param  text                 the expression to be evaluated
-     * @param  resultType           the return type expected by the expression
-     * @param  headerOrPropertyName the name of the header or the property to apply the expression to
-     * @return                      the builder to continue processing the DSL
+     * @param  text       the expression to be evaluated
+     * @param  resultType the return type expected by the expression
+     * @param  headerName the name of the header or the property to apply the expression to
+     * @return            the builder to continue processing the DSL
      */
-    public T jq(String text, Class<?> resultType, String headerOrPropertyName) {
+    public T jq(String text, Class<?> resultType, String headerName) {
         JqExpression exp = new JqExpression(text);
         exp.setResultType(resultType);
-        exp.setHeaderName(headerOrPropertyName);
-        exp.setPropertyName(headerOrPropertyName);
+        exp.setHeaderName(headerName);
         return expression(exp);
     }
 
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/JsonPathExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/JsonPathExpressionReifier.java
index 270c7364273..3ee13662e94 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/JsonPathExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/JsonPathExpressionReifier.java
@@ -30,15 +30,15 @@ public class JsonPathExpressionReifier extends SingleInputTypedExpressionReifier
     protected Object[] createProperties() {
         Object[] properties = new Object[10];
         properties[0] = definition.getResultType();
-        properties[1] = parseBoolean(definition.getSuppressExceptions());
-        properties[2] = parseBoolean(definition.getAllowSimple());
-        properties[3] = parseBoolean(definition.getAllowEasyPredicate());
-        properties[4] = parseBoolean(definition.getWriteAsString());
-        properties[5] = parseBoolean(definition.getUnpackArray());
-        properties[6] = parseString(definition.getHeaderName());
-        properties[7] = parseString(definition.getOption());
-        properties[8] = parseString(definition.getPropertyName());
-        properties[9] = parseString(definition.getVariableName());
+        properties[1] = parseString(definition.getVariableName());
+        properties[2] = parseString(definition.getHeaderName());
+        properties[3] = parseString(definition.getPropertyName());
+        properties[4] = parseBoolean(definition.getSuppressExceptions());
+        properties[5] = parseBoolean(definition.getAllowSimple());
+        properties[6] = parseBoolean(definition.getAllowEasyPredicate());
+        properties[7] = parseBoolean(definition.getWriteAsString());
+        properties[8] = parseBoolean(definition.getUnpackArray());
+        properties[9] = parseString(definition.getOption());
         return properties;
     }
 
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XPathExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XPathExpressionReifier.java
index 8e0c852df60..c5907b6ad2b 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XPathExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XPathExpressionReifier.java
@@ -62,26 +62,27 @@ public class XPathExpressionReifier extends ExpressionReifier<XPathExpression> {
     }
 
     protected Object[] createProperties() {
-        Object[] properties = new Object[12];
-        properties[0] = definition.getDocumentType();
+        Object[] properties = new Object[13];
         // resultType can either point to a QName or it can be a regular class that influence the qname
         // so we need this special logic to set resultQName and resultType accordingly
         Object qname = asQName(definition.getResultTypeName());
-        properties[1] = qname;
         if (definition.getResultType() == null && qname == null && definition.getResultTypeName() != null) {
-            properties[2] = definition.getResultTypeName();
+            properties[0] = definition.getResultTypeName();
         } else {
-            properties[2] = definition.getResultType();
+            properties[0] = definition.getResultType();
         }
-        properties[3] = parseBoolean(definition.getSaxon());
-        properties[4] = definition.getXPathFactory();
-        properties[5] = parseString(definition.getObjectModel());
-        properties[6] = parseBoolean(definition.getThreadSafety());
-        properties[7] = parseBoolean(definition.getPreCompile());
-        properties[8] = parseBoolean(definition.getLogNamespaces());
-        properties[9] = parseString(definition.getHeaderName());
-        properties[10] = parseString(definition.getPropertyName());
-        properties[11] = parseString(definition.getVariableName());
+        properties[1] = parseString(definition.getVariableName());
+        properties[2] = parseString(definition.getHeaderName());
+        properties[3] = parseString(definition.getPropertyName());
+        properties[4] = definition.getDocumentType();
+        properties[5] = qname;
+        properties[6] = parseBoolean(definition.getSaxon());
+        properties[7] = definition.getXPathFactory();
+        properties[8] = parseString(definition.getObjectModel());
+        properties[9] = parseBoolean(definition.getThreadSafety());
+        properties[10] = parseBoolean(definition.getPreCompile());
+        properties[11] = parseBoolean(definition.getLogNamespaces());
+        properties[12] = definition.getNamespaces();
         return properties;
     }
 
diff --git a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XQueryExpressionReifier.java b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XQueryExpressionReifier.java
index 48726d3e5d0..0ee0dbf4ab8 100644
--- a/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XQueryExpressionReifier.java
+++ b/core/camel-core-reifier/src/main/java/org/apache/camel/reifier/language/XQueryExpressionReifier.java
@@ -61,9 +61,9 @@ public class XQueryExpressionReifier extends ExpressionReifier<XQueryExpression>
     protected Object[] createProperties() {
         Object[] properties = new Object[4];
         properties[0] = definition.getResultType();
-        properties[1] = parseString(definition.getHeaderName());
-        properties[2] = parseString(definition.getPropertyName());
-        properties[3] = parseString(definition.getVariableName());
+        properties[1] = parseString(definition.getVariableName());
+        properties[2] = parseString(definition.getHeaderName());
+        properties[3] = parseString(definition.getPropertyName());
         return properties;
     }
 
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/LanguageSupport.java b/core/camel-support/src/main/java/org/apache/camel/support/LanguageSupport.java
index 5fc48b1fbb9..63a492326cb 100644
--- a/core/camel-support/src/main/java/org/apache/camel/support/LanguageSupport.java
+++ b/core/camel-support/src/main/java/org/apache/camel/support/LanguageSupport.java
@@ -124,7 +124,7 @@ public abstract class LanguageSupport implements Language, IsSingleton, CamelCon
             value = defaultValue;
         }
 
-        if (value instanceof String) {
+        if (camelContext != null && value instanceof String) {
             value = getCamelContext().resolvePropertyPlaceholders(value.toString());
         }
 
@@ -133,7 +133,7 @@ public abstract class LanguageSupport implements Language, IsSingleton, CamelCon
         if (value instanceof String && String.class != type) {
             String text = value.toString();
 
-            if (EndpointHelper.isReferenceParameter(text)) {
+            if (camelContext != null && EndpointHelper.isReferenceParameter(text)) {
                 Object obj;
                 // special for a list where we refer to beans which can be either a list or a single element
                 // so use Object.class as type
@@ -177,7 +177,14 @@ public abstract class LanguageSupport implements Language, IsSingleton, CamelCon
                                                    + " as the value is not true or false");
             }
         }
-        return value == null ? null : getCamelContext().getTypeConverter().convertTo(type, value);
+        if (value == null) {
+            return null;
+        }
+        if (camelContext != null) {
+            return camelContext.getTypeConverter().convertTo(type, value);
+        } else {
+            return (T) value;
+        }
     }
 
 }
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/SingleInputLanguageSupport.java b/core/camel-support/src/main/java/org/apache/camel/support/SingleInputLanguageSupport.java
deleted file mode 100644
index 4b84833105d..00000000000
--- a/core/camel-support/src/main/java/org/apache/camel/support/SingleInputLanguageSupport.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.camel.support;
-
-import org.apache.camel.spi.Language;
-
-/**
- * Base class for {@link Language} implementations that support different sources of input data.
- */
-@Deprecated
-public abstract class SingleInputLanguageSupport extends LanguageSupport {
-
-    private String variableName;
-    private String headerName;
-    private String propertyName;
-
-    public String getVariableName() {
-        return variableName;
-    }
-
-    /**
-     * Name of variable to use as input, instead of the message body
-     */
-    public void setVariableName(String variableName) {
-        this.variableName = variableName;
-    }
-
-    public String getHeaderName() {
-        return headerName;
-    }
-
-    /**
-     * Name of header to use as input, instead of the message body
-     */
-    public void setHeaderName(String headerName) {
-        this.headerName = headerName;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
-    }
-
-    /**
-     * Name of property to use as input, instead of the message body.
-     * <p>
-     * It has a lower precedent than the name of header if both are set.
-     */
-    public void setPropertyName(String propertyName) {
-        this.propertyName = propertyName;
-    }
-}
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/SingleInputTypedLanguageSupport.java b/core/camel-support/src/main/java/org/apache/camel/support/SingleInputTypedLanguageSupport.java
index 9e1f98a8805..c57f2055344 100644
--- a/core/camel-support/src/main/java/org/apache/camel/support/SingleInputTypedLanguageSupport.java
+++ b/core/camel-support/src/main/java/org/apache/camel/support/SingleInputTypedLanguageSupport.java
@@ -17,61 +17,32 @@
 package org.apache.camel.support;
 
 import org.apache.camel.Expression;
+import org.apache.camel.Predicate;
 import org.apache.camel.spi.Language;
 import org.apache.camel.support.builder.ExpressionBuilder;
+import org.apache.camel.support.builder.PredicateBuilder;
 
 /**
  * Base class for {@link Language} implementations that support a result type and different sources of input data.
  */
 public abstract class SingleInputTypedLanguageSupport extends TypedLanguageSupport {
 
-    private String variableName;
-    private String headerName;
-    private String propertyName;
-
-    public String getVariableName() {
-        return variableName;
-    }
-
-    /**
-     * Name of variable to use as input, instead of the message body
-     * </p>
-     * It has as higher precedent if other are set.
-     */
-    public void setVariableName(String variableName) {
-        this.variableName = variableName;
-    }
-
-    public String getHeaderName() {
-        return headerName;
-    }
-
-    /**
-     * Name of header to use as input, instead of the message body
-     */
-    public void setHeaderName(String headerName) {
-        this.headerName = headerName;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
+    @Override
+    public Predicate createPredicate(String expression) {
+        return createPredicate(expression, null);
     }
 
-    /**
-     * Name of property to use as input, instead of the message body.
-     * <p>
-     * It has a lower precedent than the name of header if both are set.
-     */
-    public void setPropertyName(String propertyName) {
-        this.propertyName = propertyName;
+    @Override
+    public Expression createExpression(String expression) {
+        return createExpression(expression, null);
     }
 
     @Override
     public Expression createExpression(String expression, Object[] properties) {
         Class<?> type = property(Class.class, properties, 0, getResultType());
-        String variable = property(String.class, properties, 1, getVariableName());
-        String header = property(String.class, properties, 2, getHeaderName());
-        String property = property(String.class, properties, 3, getPropertyName());
+        String variable = property(String.class, properties, 1, null);
+        String header = property(String.class, properties, 2, null);
+        String property = property(String.class, properties, 3, null);
         Expression source = ExpressionBuilder.singleInputExpression(variable, header, property);
         if (type == null || type == Object.class) {
             return createExpression(source, expression, properties);
@@ -79,6 +50,16 @@ public abstract class SingleInputTypedLanguageSupport extends TypedLanguageSuppo
         return ExpressionBuilder.convertToExpression(createExpression(source, expression, properties), type);
     }
 
+    @Override
+    public Predicate createPredicate(String expression, Object[] properties) {
+        Class<?> type = property(Class.class, properties, 0, getResultType());
+        String variable = property(String.class, properties, 1, null);
+        String header = property(String.class, properties, 2, null);
+        String property = property(String.class, properties, 3, null);
+        Expression source = ExpressionBuilder.singleInputExpression(variable, header, property);
+        return createPredicate(source, expression, properties);
+    }
+
     /**
      * Creates an expression based on the input with properties.
      *
@@ -87,7 +68,19 @@ public abstract class SingleInputTypedLanguageSupport extends TypedLanguageSuppo
      * @param  properties configuration properties (optimized as object array with hardcoded positions for properties)
      * @return            the created expression
      */
-    protected Expression createExpression(Expression source, String expression, Object[] properties) {
+    public Expression createExpression(Expression source, String expression, Object[] properties) {
         throw new UnsupportedOperationException();
     }
+
+    /**
+     * Creates a predicate based on the input with properties.
+     *
+     * @param  source     the expression allowing to retrieve the input data of the main expression.
+     * @param  expression the main expression to evaluate as predicate.
+     * @param  properties configuration properties (optimized as object array with hardcoded positions for properties)
+     * @return            the created predicate
+     */
+    public Predicate createPredicate(Expression source, String expression, Object[] properties) {
+        return PredicateBuilder.toPredicate(createExpression(source, expression, properties));
+    }
 }
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java b/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java
index 0f3bb477721..47cef3ba81c 100644
--- a/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java
+++ b/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java
@@ -34,7 +34,10 @@ import org.apache.camel.ExchangePropertyKey;
 import org.apache.camel.Expression;
 import org.apache.camel.InvalidPayloadException;
 import org.apache.camel.Message;
+import org.apache.camel.NoSuchHeaderException;
 import org.apache.camel.NoSuchLanguageException;
+import org.apache.camel.NoSuchPropertyException;
+import org.apache.camel.NoSuchVariableException;
 import org.apache.camel.Predicate;
 import org.apache.camel.RuntimeCamelException;
 import org.apache.camel.RuntimeExchangeException;
@@ -77,6 +80,19 @@ public class ExpressionBuilder {
         return headerExpression(simpleExpression(headerName));
     }
 
+    /**
+     * Returns an expression for the header value with the given name
+     * <p/>
+     * Will fallback and look in properties if not found in headers.
+     *
+     * @param  headerName the name of the header the expression will return
+     * @param  mandatory  whether the header is mandatory and if not present an exception is thrown
+     * @return            an expression object which will return the header value
+     */
+    public static Expression headerExpression(final String headerName, boolean mandatory) {
+        return headerExpression(simpleExpression(headerName), mandatory);
+    }
+
     /**
      * Returns an expression for the header value with the given name
      * <p/>
@@ -86,16 +102,32 @@ public class ExpressionBuilder {
      * @return            an expression object which will return the header value
      */
     public static Expression headerExpression(final Expression headerName) {
+        return headerExpression(headerName, false);
+    }
+
+    /**
+     * Returns an expression for the header value with the given name
+     * <p/>
+     * Will fallback and look in properties if not found in headers.
+     *
+     * @param  headerName the name of the header the expression will return
+     * @param  mandatory  whether the header is mandatory and if not present an exception is thrown
+     * @return            an expression object which will return the header value
+     */
+    public static Expression headerExpression(final Expression headerName, final boolean mandatory) {
         return new ExpressionAdapter() {
             @Override
             public Object evaluate(Exchange exchange) {
-                String name = headerName.evaluate(exchange, String.class);
-                Object header = exchange.getIn().getHeader(name);
-                if (header == null) {
+                String key = headerName.evaluate(exchange, String.class);
+                Object answer = exchange.getIn().getHeader(key);
+                if (answer == null) {
                     // fall back on a property
-                    header = exchange.getProperty(name);
+                    answer = exchange.getProperty(key);
                 }
-                return header;
+                if (mandatory && answer == null) {
+                    throw RuntimeCamelException.wrapRuntimeCamelException(new NoSuchHeaderException(exchange, key, null));
+                }
+                return answer;
             }
 
             @Override
@@ -193,6 +225,17 @@ public class ExpressionBuilder {
         return variableExpression(simpleExpression(variableName));
     }
 
+    /**
+     * Returns an expression for the variable with the given name
+     *
+     * @param  variableName the name of the variable the expression will return
+     * @param  mandatory    whether the variable is mandatory and if not present an exception is thrown
+     * @return              an expression object which will return the variable value
+     */
+    public static Expression variableExpression(final String variableName, boolean mandatory) {
+        return variableExpression(simpleExpression(variableName), mandatory);
+    }
+
     /**
      * Returns an expression for the variable with the given name
      *
@@ -200,6 +243,17 @@ public class ExpressionBuilder {
      * @return              an expression object which will return the variable value
      */
     public static Expression variableExpression(final Expression variableName) {
+        return variableExpression(variableName, false);
+    }
+
+    /**
+     * Returns an expression for the variable with the given name
+     *
+     * @param  variableName the name of the variable the expression will return
+     * @param  mandatory    whether the variable is mandatory and if not present an exception is thrown
+     * @return              an expression object which will return the variable value
+     */
+    public static Expression variableExpression(final Expression variableName, final boolean mandatory) {
         return new ExpressionAdapter() {
             private VariableRepositoryFactory factory;
 
@@ -207,17 +261,22 @@ public class ExpressionBuilder {
             public Object evaluate(Exchange exchange) {
                 String key = variableName.evaluate(exchange, String.class);
                 String id = StringHelper.before(key, ":");
+                Object answer;
                 if (id != null) {
                     VariableRepository repo = factory.getVariableRepository(id);
                     if (repo != null) {
                         key = StringHelper.after(key, ":");
-                        return repo.getVariable(key);
+                        answer = repo.getVariable(key);
                     } else {
                         throw new IllegalArgumentException("VariableRepository with id: " + id + " does not exist");
                     }
                 } else {
-                    return exchange.getVariable(key);
+                    answer = exchange.getVariable(key);
                 }
+                if (mandatory && answer == null) {
+                    throw RuntimeCamelException.wrapRuntimeCamelException(new NoSuchVariableException(exchange, key));
+                }
+                return answer;
             }
 
             @Override
@@ -631,6 +690,17 @@ public class ExpressionBuilder {
         return exchangePropertyExpression(simpleExpression(propertyName));
     }
 
+    /**
+     * Returns an expression for the property value of exchange with the given name
+     *
+     * @param  propertyName the name of the property the expression will return
+     * @param  mandatory    whether the property is mandatory and if not present an exception is thrown
+     * @return              an expression object which will return the property value
+     */
+    public static Expression exchangePropertyExpression(final String propertyName, boolean mandatory) {
+        return exchangePropertyExpression(simpleExpression(propertyName), mandatory);
+    }
+
     /**
      * Returns an expression for the property value of exchange with the given name
      *
@@ -638,11 +708,26 @@ public class ExpressionBuilder {
      * @return              an expression object which will return the property value
      */
     public static Expression exchangePropertyExpression(final Expression propertyName) {
+        return exchangePropertyExpression(propertyName, false);
+    }
+
+    /**
+     * Returns an expression for the property value of exchange with the given name
+     *
+     * @param  propertyName the name of the property the expression will return
+     * @param  mandatory    whether the property is mandatory and if not present an exception is thrown
+     * @return              an expression object which will return the property value
+     */
+    public static Expression exchangePropertyExpression(final Expression propertyName, final boolean mandatory) {
         return new ExpressionAdapter() {
             @Override
             public Object evaluate(Exchange exchange) {
-                String text = propertyName.evaluate(exchange, String.class);
-                return exchange.getProperty(text);
+                String key = propertyName.evaluate(exchange, String.class);
+                Object answer = exchange.getProperty(key);
+                if (mandatory && answer == null) {
+                    throw RuntimeCamelException.wrapRuntimeCamelException(new NoSuchPropertyException(exchange, key));
+                }
+                return answer;
             }
 
             @Override
@@ -987,29 +1072,38 @@ public class ExpressionBuilder {
                 if (lan != null) {
                     if (input != null && lan instanceof SingleInputTypedLanguageSupport sil) {
                         String prefix = StringHelper.before(input, ":");
-                        String source = StringHelper.after(input, ":");
+                        String name = StringHelper.after(input, ":");
                         if (prefix != null) {
                             prefix = prefix.trim();
                         }
-                        if (source != null) {
-                            source = source.trim();
+                        if (name != null) {
+                            name = name.trim();
                         }
+                        String header = null;
+                        String property = null;
+                        String variable = null;
                         if ("header".equals(prefix)) {
-                            sil.setHeaderName(source);
+                            header = name;
                         } else if ("property".equals(prefix) || "exchangeProperty".equals(prefix)) {
-                            sil.setPropertyName(source);
+                            property = name;
                         } else if ("variable".equals(prefix)) {
-                            sil.setVariableName(source);
+                            variable = name;
                         } else {
                             throw new IllegalArgumentException(
                                     "Invalid input source for language. Should either be header:key, exchangeProperty:key, or variable:key, was: "
                                                                + input);
                         }
+                        Expression source = ExpressionBuilder.singleInputExpression(variable, header, property);
+                        expr = sil.createExpression(source, expression, null);
+                        expr.init(context);
+                        pred = PredicateBuilder.toPredicate(expr);
+                        pred.init(context);
+                    } else {
+                        pred = lan.createPredicate(expression);
+                        pred.init(context);
+                        expr = lan.createExpression(expression);
+                        expr.init(context);
                     }
-                    pred = lan.createPredicate(expression);
-                    pred.init(context);
-                    expr = lan.createExpression(expression);
-                    expr.init(context);
                 } else {
                     throw new NoSuchLanguageException(language);
                 }
@@ -1207,6 +1301,8 @@ public class ExpressionBuilder {
     }
 
     /**
+     * Creates a source {@link Expression} for languages that can accept input from other sources than the message body.
+     *
      * @param  variableName the name of the variable from which the input data must be extracted if not empty.
      * @param  headerName   the name of the header from which the input data must be extracted if not empty.
      * @param  propertyName the name of the property from which the input data must be extracted if not empty and
@@ -1218,11 +1314,11 @@ public class ExpressionBuilder {
     public static Expression singleInputExpression(String variableName, String headerName, String propertyName) {
         final Expression exp;
         if (ObjectHelper.isNotEmpty(variableName)) {
-            exp = variableExpression(variableName);
+            exp = variableExpression(variableName, true);
         } else if (ObjectHelper.isNotEmpty(headerName)) {
-            exp = headerExpression(headerName);
+            exp = headerExpression(headerName, true);
         } else if (ObjectHelper.isNotEmpty(propertyName)) {
-            exp = exchangePropertyExpression(propertyName);
+            exp = exchangePropertyExpression(propertyName, true);
         } else {
             exp = bodyExpression();
         }
diff --git a/dsl/camel-groovy-dsl/camel-groovy-dsl-test/src/test/groovy/org/apache/camel/dsl/groovy/GroovyRouteBuilderLoaderTest.groovy b/dsl/camel-groovy-dsl/camel-groovy-dsl-test/src/test/groovy/org/apache/camel/dsl/groovy/GroovyRouteBuilderLoaderTest.groovy
index 27eddc62a5f..107f1452e18 100644
--- a/dsl/camel-groovy-dsl/camel-groovy-dsl-test/src/test/groovy/org/apache/camel/dsl/groovy/GroovyRouteBuilderLoaderTest.groovy
+++ b/dsl/camel-groovy-dsl/camel-groovy-dsl-test/src/test/groovy/org/apache/camel/dsl/groovy/GroovyRouteBuilderLoaderTest.groovy
@@ -147,13 +147,8 @@ class GroovyRouteBuilderLoaderTest extends Specification {
             loadRoute('/routes/routes-with-languages-configuration.groovy')
 
         then:
-            with(context.resolveLanguage('bean'), BeanLanguage) {
-                beanType == String.class
-                method == "toUpperCase"
-            }
             with(context.resolveLanguage('myBean'), BeanLanguage) {
-                beanType == String.class
-                method == "toLowerCase"
+                (!isValidate());
             }
     }
 
diff --git a/dsl/camel-groovy-dsl/camel-groovy-dsl-test/src/test/resources/routes/routes-with-languages-configuration.groovy b/dsl/camel-groovy-dsl/camel-groovy-dsl-test/src/test/resources/routes/routes-with-languages-configuration.groovy
index 707e057bcb7..feeba851b73 100644
--- a/dsl/camel-groovy-dsl/camel-groovy-dsl-test/src/test/resources/routes/routes-with-languages-configuration.groovy
+++ b/dsl/camel-groovy-dsl/camel-groovy-dsl-test/src/test/resources/routes/routes-with-languages-configuration.groovy
@@ -20,13 +20,8 @@ import org.apache.camel.language.bean.BeanLanguage
 camel {
 
     languages {
-        bean {
-            beanType = String.class
-            method = "toUpperCase"
-        }
         myBean(BeanLanguage) {
-            beanType = String.class
-            method = "toLowerCase"
+            validate = false;
         }
     }
 }
