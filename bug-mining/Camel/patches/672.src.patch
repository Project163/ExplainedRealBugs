diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultRouteNode.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultRouteNode.java
new file mode 100644
index 00000000000..ed02fb65b96
--- /dev/null
+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultRouteNode.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.impl;
+
+import org.apache.camel.Processor;
+import org.apache.camel.model.ProcessorDefinition;
+import org.apache.camel.model.RouteNode;
+
+/**
+ * A default implementation of the {@link org.apache.camel.model.RouteNode}
+ *
+ * @version $Revision$
+ */
+public class DefaultRouteNode implements RouteNode {
+
+    private Processor processor;
+    private ProcessorDefinition processorDefinition;
+
+    public DefaultRouteNode(Processor processor, ProcessorDefinition processorDefinition) {
+        this.processor = processor;
+        this.processorDefinition = processorDefinition;
+    }
+
+    public Processor getProcessor() {
+        return processor;
+    }
+
+    public ProcessorDefinition getProcessorDefinition() {
+        return processorDefinition;
+    }
+
+    @Override
+    public String toString() {
+        return "RouteNode[" + processorDefinition + "]";
+    }
+
+}
diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultUnitOfWork.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultUnitOfWork.java
index 7485043ae6f..eb00c1e20bc 100644
--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultUnitOfWork.java
+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultUnitOfWork.java
@@ -18,11 +18,15 @@ package org.apache.camel.impl;
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.camel.Exchange;
-import org.apache.camel.Processor;
 import org.apache.camel.Service;
+import org.apache.camel.model.InterceptDefinition;
+import org.apache.camel.model.RouteNode;
 import org.apache.camel.spi.Synchronization;
 import org.apache.camel.spi.TraceableUnitOfWork;
 import org.apache.camel.util.UuidGenerator;
@@ -40,7 +44,8 @@ public class DefaultUnitOfWork implements TraceableUnitOfWork, Service {
 
     private String id;
     private List<Synchronization> synchronizations;
-    private List<Processor> processorList;
+    private List<RouteNode> routeNodes;
+    private Map<InterceptDefinition, AtomicInteger> interceptIndex = new HashMap<InterceptDefinition, AtomicInteger>();
     private Object originalInBody;
 
     public DefaultUnitOfWork(Exchange exchange) {
@@ -55,12 +60,11 @@ public class DefaultUnitOfWork implements TraceableUnitOfWork, Service {
         // need to clean up when we are stopping to not leak memory
         if (synchronizations != null) {
             synchronizations.clear();
-            synchronizations = null;
         }
-        if (processorList != null) {
-            processorList.clear();
-            processorList = null;
+        if (routeNodes != null) {
+            routeNodes.clear();
         }
+        interceptIndex.clear();
         originalInBody = null;
     }
 
@@ -115,32 +119,42 @@ public class DefaultUnitOfWork implements TraceableUnitOfWork, Service {
         return id;
     }
 
-    public void addInterceptedProcessor(Processor processor) {
-        if (processorList == null) {
-            processorList = new ArrayList<Processor>();
+    public void addTraced(RouteNode entry) {
+        if (routeNodes == null) {
+            routeNodes = new ArrayList<RouteNode>();
         }
-        processorList.add(processor);
+        routeNodes.add(entry);
     }
 
-    public Processor getLastInterceptedProcessor() {
-        if (processorList == null || processorList.isEmpty()) {
+    public RouteNode getLastNode() {
+        if (routeNodes == null || routeNodes.isEmpty()) {
             return null;
         }
-        return processorList.get(processorList.size() - 1);
+        return routeNodes.get(routeNodes.size() - 1);
     }
 
-    public Processor getSecondLastInterceptedProcessor() {
-        if (processorList == null || processorList.isEmpty() || processorList.size() == 1) {
+    public RouteNode getSecondLastNode() {
+        if (routeNodes == null || routeNodes.isEmpty() || routeNodes.size() == 1) {
             return null;
         }
-        return processorList.get(processorList.size() - 2);
+        return routeNodes.get(routeNodes.size() - 2);
     }
 
-    public List<Processor> getInterceptedProcessors() {
-        return Collections.unmodifiableList(processorList);
+    public List<RouteNode> getNodes() {
+        return Collections.unmodifiableList(routeNodes);
     }
 
     public Object getOriginalInBody() {
         return originalInBody;
     }
+
+    public int getAndIncrement(InterceptDefinition node) {
+        AtomicInteger count = interceptIndex.get(node);
+        if (count == null) {
+            count = new AtomicInteger();
+            interceptIndex.put(node, count);
+        }
+        return count.getAndIncrement();
+    }
+
 }
diff --git a/camel-core/src/main/java/org/apache/camel/model/InterceptDefinition.java b/camel-core/src/main/java/org/apache/camel/model/InterceptDefinition.java
index 631eba788e7..b7a67d2a641 100644
--- a/camel-core/src/main/java/org/apache/camel/model/InterceptDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/InterceptDefinition.java
@@ -43,6 +43,9 @@ public class InterceptDefinition extends OutputDefinition<ProcessorDefinition> {
     @XmlTransient
     protected Processor output;
 
+    @XmlTransient
+    protected final List<Processor> intercepted = new ArrayList<Processor>();
+
     public InterceptDefinition() {
     }
 
@@ -68,14 +71,20 @@ public class InterceptDefinition extends OutputDefinition<ProcessorDefinition> {
 
         // add the output as a intercept strategy to the route context so its invoked on each processing step
         routeContext.getInterceptStrategies().add(new InterceptStrategy() {
+            private Processor interceptedTarget;
+
             public Processor wrapProcessorInInterceptors(ProcessorDefinition processorDefinition, Processor target, Processor nextTarget) throws Exception {
                 // prefer next target over taget as next target is the real target
-                Processor processor = nextTarget != null ? nextTarget : target;
-                if (processor != null) {
+                interceptedTarget = nextTarget != null ? nextTarget : target;
+
+                // remember the target that was intercepted
+                intercepted.add(interceptedTarget);
+
+                if (interceptedTarget != null) {
                     // wrap in a pipeline so we continue routing to the next
                     List<Processor> list = new ArrayList<Processor>(2);
                     list.add(output);
-                    list.add(processor);
+                    list.add(interceptedTarget);
                     return new Pipeline(list);
                 } else {
                     return output;
@@ -84,7 +93,7 @@ public class InterceptDefinition extends OutputDefinition<ProcessorDefinition> {
 
             @Override
             public String toString() {
-                return "intercept[" + output + "]";
+                return "intercept[" +  (interceptedTarget != null ? interceptedTarget : output) + "]";
             }
         });
 
@@ -133,4 +142,13 @@ public class InterceptDefinition extends OutputDefinition<ProcessorDefinition> {
         }
     }
 
+    public Processor getInterceptedProcessor(int index) {
+        // avoid out of bounds
+        if (index <= intercepted.size() - 1) {
+            return intercepted.get(index);
+        } else {
+            return null;
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/camel-core/src/main/java/org/apache/camel/model/RouteNode.java b/camel-core/src/main/java/org/apache/camel/model/RouteNode.java
new file mode 100644
index 00000000000..ef406c3c4e1
--- /dev/null
+++ b/camel-core/src/main/java/org/apache/camel/model/RouteNode.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.model;
+
+import org.apache.camel.Processor;
+
+/**
+ * Represents a model of a node in the runtime route path.
+ *
+ * @version $Revision$
+ */
+public interface RouteNode {
+
+    /**
+     * Gets the actual processor this node represents.
+     *
+     * @return the processor, can be <tt>null</tt> in special cases such as an intercepted node
+     */
+    Processor getProcessor();
+
+    /**
+     * Gets the model definition that represents this node
+     *
+     * @return the definition, is newer <tt>null</tt>
+     */
+    ProcessorDefinition getProcessorDefinition();
+}
diff --git a/camel-core/src/main/java/org/apache/camel/model/RoutesDefinition.java b/camel-core/src/main/java/org/apache/camel/model/RoutesDefinition.java
index 5daac27e379..580852002a2 100644
--- a/camel-core/src/main/java/org/apache/camel/model/RoutesDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/RoutesDefinition.java
@@ -255,7 +255,7 @@ public class RoutesDefinition extends OptionalIdentifiedType<RoutesDefinition> i
      */
     public InterceptDefinition intercept() {
         InterceptDefinition answer = new InterceptDefinition();
-        getIntercepts().add(answer);
+        getIntercepts().add(0, answer);
         return answer;
     }
 
diff --git a/camel-core/src/main/java/org/apache/camel/processor/Traceable.java b/camel-core/src/main/java/org/apache/camel/processor/Traceable.java
index 40e08a760a0..164a26a7f22 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/Traceable.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/Traceable.java
@@ -31,6 +31,6 @@ public interface Traceable {
      *
      * @return  the label
      */
-    public String getTraceLabel();
+    String getTraceLabel();
 
 }
diff --git a/camel-core/src/main/java/org/apache/camel/processor/interceptor/DefaultTraceEventMessage.java b/camel-core/src/main/java/org/apache/camel/processor/interceptor/DefaultTraceEventMessage.java
index b5a25dad14a..50be008f504 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/interceptor/DefaultTraceEventMessage.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/interceptor/DefaultTraceEventMessage.java
@@ -22,8 +22,9 @@ import java.util.Date;
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.Processor;
-import org.apache.camel.processor.Traceable;
 import org.apache.camel.model.ProcessorDefinition;
+import org.apache.camel.model.RouteNode;
+import org.apache.camel.processor.Traceable;
 import org.apache.camel.spi.TraceableUnitOfWork;
 import org.apache.camel.util.MessageHelper;
 
@@ -81,7 +82,8 @@ public final class DefaultTraceEventMessage implements Serializable, TraceEventM
 
     // Implementation
     //---------------------------------------------------------------
-    private String extractTraceLabel(Processor processor) {
+    private String extractTraceLabel(RouteNode entry) {
+        Processor processor = entry.getProcessor();
         if (processor instanceof Traceable) {
             Traceable trace = (Traceable) processor;
             return trace.getTraceLabel();
@@ -96,7 +98,7 @@ public final class DefaultTraceEventMessage implements Serializable, TraceEventM
     private String extractFromNode(Exchange exchange) {
         if (exchange.getUnitOfWork() instanceof TraceableUnitOfWork) {
             TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork();
-            Processor last = tuow.getSecondLastInterceptedProcessor();
+            RouteNode last = tuow.getSecondLastNode();
             return last != null ? extractTraceLabel(last) : null;
         }
         return null;
@@ -105,7 +107,7 @@ public final class DefaultTraceEventMessage implements Serializable, TraceEventM
     private String extractToNode(Exchange exchange) {
         if (exchange.getUnitOfWork() instanceof TraceableUnitOfWork) {
             TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork();
-            Processor last = tuow.getLastInterceptedProcessor();
+            RouteNode last = tuow.getLastNode();
             return last != null ? extractTraceLabel(last) : null;
         }
         return null;
diff --git a/camel-core/src/main/java/org/apache/camel/processor/interceptor/DefaultTraceFormatter.java b/camel-core/src/main/java/org/apache/camel/processor/interceptor/DefaultTraceFormatter.java
index cd97cadbea0..c838bd3e06e 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/interceptor/DefaultTraceFormatter.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/interceptor/DefaultTraceFormatter.java
@@ -19,8 +19,9 @@ package org.apache.camel.processor.interceptor;
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.Processor;
-import org.apache.camel.processor.Traceable;
 import org.apache.camel.model.ProcessorDefinition;
+import org.apache.camel.model.RouteNode;
+import org.apache.camel.processor.Traceable;
 import org.apache.camel.spi.TraceableUnitOfWork;
 import org.apache.camel.spi.UnitOfWork;
 import org.apache.camel.util.MessageHelper;
@@ -236,7 +237,13 @@ public class DefaultTraceFormatter implements TraceFormatter {
         }
     }
 
-    protected String getNodeMessage(Processor processor) {
+    protected String getNodeMessage(RouteNode entry) {
+        Processor processor = entry.getProcessor();
+
+        if (processor == null) {
+            return "";
+        }
+
         String message;
         if (processor instanceof Traceable) {
             Traceable trace = (Traceable) processor;
@@ -284,16 +291,16 @@ public class DefaultTraceFormatter implements TraceFormatter {
         if (showNode && exchange.getUnitOfWork() instanceof TraceableUnitOfWork) {
             TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork();
 
-            Processor fromProcessor = tuow.getSecondLastInterceptedProcessor();
-            if (fromProcessor != null) {
-                from = getNodeMessage(fromProcessor);
+            RouteNode traceFrom = tuow.getSecondLastNode();
+            if (traceFrom != null) {
+                from = getNodeMessage(traceFrom);
             } else if (exchange.getFromEndpoint() != null) {
                 from = "from(" + exchange.getFromEndpoint().getEndpointUri() + ")";
             }
 
-            Processor toProcessor = tuow.getLastInterceptedProcessor();
-            if (toProcessor != null) {
-                to = getNodeMessage(toProcessor);
+            RouteNode traceTo = tuow.getLastNode();
+            if (traceTo != null) {
+                to = getNodeMessage(traceTo);
             }
         }
 
diff --git a/camel-core/src/main/java/org/apache/camel/processor/interceptor/TraceInterceptor.java b/camel-core/src/main/java/org/apache/camel/processor/interceptor/TraceInterceptor.java
index eeff647bb58..3e0359bcf5e 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/interceptor/TraceInterceptor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/interceptor/TraceInterceptor.java
@@ -24,11 +24,12 @@ import org.apache.camel.Endpoint;
 import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
 import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultRouteNode;
+import org.apache.camel.model.InterceptDefinition;
+import org.apache.camel.model.OnExceptionDefinition;
 import org.apache.camel.model.ProcessorDefinition;
 import org.apache.camel.processor.DelegateProcessor;
 import org.apache.camel.processor.Logger;
-import org.apache.camel.processor.Pipeline;
-import org.apache.camel.processor.MulticastProcessor;
 import org.apache.camel.spi.ExchangeFormatter;
 import org.apache.camel.spi.InterceptStrategy;
 import org.apache.camel.spi.TraceableUnitOfWork;
@@ -106,11 +107,59 @@ public class TraceInterceptor extends DelegateProcessor implements ExchangeForma
                 // if traceable then register this as the previous node, now it has been logged
                 if (exchange.getUnitOfWork() instanceof TraceableUnitOfWork) {
                     TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork();
-                    tuow.addInterceptedProcessor(super.getProcessor());
+
+                    // special for on exception so we can see it in the trace logs
+                    if (node instanceof OnExceptionDefinition) {
+                        Processor pseudo = new Processor() {
+                            public void process(Exchange exchange) throws Exception {
+                            }
+
+                            public String toString() {
+                                String name = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class).getClass().getSimpleName();
+                                return "onException[" + name + "]";
+                            }
+                        };
+                        tuow.addTraced(new DefaultRouteNode(pseudo, node));
+
+                        // log and trace the processor that was onException so we can see it
+                        logExchange(exchange);
+                        traceExchange(exchange);
+                    }
+
+                    // register the processor that was traced
+                    tuow.addTraced(new DefaultRouteNode(super.getProcessor(), node));
                 }
 
+                // TODO: just a little more to avoid logging the last intercepted step
+
+                // log and trace the processor
                 logExchange(exchange);
                 traceExchange(exchange);
+
+                // some nodes need extra work to trace it
+                if (exchange.getUnitOfWork() instanceof TraceableUnitOfWork) {
+                    TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork();
+
+                    // special for intercept() as we would like to trace the processor that was intercepted
+                    // as well, otherwise we only see the intercepted route, but we need the both to be logged/traced
+                    if (node instanceof InterceptDefinition) {
+
+                        // get the intercepted processor from the definition
+                        // we need to use the UoW to have its own index of how far we got into the list
+                        // of intercepted processors the intercept definition holds as the intercept
+                        // definition is a single object that is shared by concurrent thread being routed
+                        // so each exchange has its own private counter
+                        InterceptDefinition intercept = (InterceptDefinition) node;
+                        Processor last = intercept.getInterceptedProcessor(tuow.getAndIncrement(intercept));
+                        if (last != null) {
+                            tuow.addTraced(new DefaultRouteNode(last, node));
+
+                            // log and trace the processor that was intercepted so we can see it
+                            logExchange(exchange);
+                            traceExchange(exchange);
+                        }
+                    }
+                }
             }
 
             // process the exchange
diff --git a/camel-core/src/main/java/org/apache/camel/spi/TraceableUnitOfWork.java b/camel-core/src/main/java/org/apache/camel/spi/TraceableUnitOfWork.java
index da6cc3c0046..05d80c0184a 100644
--- a/camel-core/src/main/java/org/apache/camel/spi/TraceableUnitOfWork.java
+++ b/camel-core/src/main/java/org/apache/camel/spi/TraceableUnitOfWork.java
@@ -18,7 +18,8 @@ package org.apache.camel.spi;
 
 import java.util.List;
 
-import org.apache.camel.Processor;
+import org.apache.camel.model.InterceptDefinition;
+import org.apache.camel.model.RouteNode;
 
 /**
  * A Unit of work that is also traceable with the
@@ -30,26 +31,38 @@ import org.apache.camel.Processor;
 public interface TraceableUnitOfWork extends UnitOfWork {
 
     /**
-     * Adds the given processor that was intercepted
+     * Adds the entry that was intercepted
      *
-     * @param processor the processor
+     * @param entry the entry
      */
-    void addInterceptedProcessor(Processor processor);
+    void addTraced(RouteNode entry);
 
     /**
-     * Gets the last intercepted processor, is <tt>null</tt> if no last exists.
+     * Gets the last node, is <tt>null</tt> if no last exists.
      */
-    Processor getLastInterceptedProcessor();
+    RouteNode getLastNode();
 
     /**
-     * Gets the 2nd last intercepted processor, is <tt>null</tt> if no last exists.
+     * Gets the 2nd last node, is <tt>null</tt> if no last exists.
      */
-    Processor getSecondLastInterceptedProcessor();
+    RouteNode getSecondLastNode();
 
     /**
-     * Gets the current list of intercepted processors, representing the route path the
-     * current {@link org.apache.camel.Exchange} has taken.
+     * Gets the current list of nodes, representing the route path the
+     * current {@link org.apache.camel.Exchange} has currently taken.
      */
-    List<Processor> getInterceptedProcessors();
+    List<RouteNode> getNodes();
+
+    /**
+     * A private counter that increments, is used to as book keeping how far this
+     * exchange have been intercepted by the general intercept().
+     * <p/>
+     * We need this special book keeping to keep correct order when dealing
+     * with concurrent exchanges being routed in the same route path.
+     *
+     * @param node the intercept node
+     * @return the current count
+     */
+    int getAndIncrement(InterceptDefinition node);
 
 }
diff --git a/camel-core/src/test/java/org/apache/camel/issues/MultipleFromTest.java b/camel-core/src/test/java/org/apache/camel/issues/MultipleFromTest.java
index 71bfad66650..9b69ad4f806 100644
--- a/camel-core/src/test/java/org/apache/camel/issues/MultipleFromTest.java
+++ b/camel-core/src/test/java/org/apache/camel/issues/MultipleFromTest.java
@@ -40,7 +40,7 @@ public class MultipleFromTest extends ContextTestSupport {
     protected RouteBuilder createRouteBuilder() throws Exception {
         return new RouteBuilder() {
             public void configure() throws Exception {
-                from("direct:start").from("seda:in").to("mock:result");
+                from("direct:start", "seda:in").to("mock:result");
             }
         };
     }
diff --git a/camel-core/src/test/java/org/apache/camel/processor/TraceableUnitOfWorkTest.java b/camel-core/src/test/java/org/apache/camel/processor/TraceableUnitOfWorkTest.java
index 0037dd7b11f..a8dfd2cf868 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/TraceableUnitOfWorkTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/TraceableUnitOfWorkTest.java
@@ -23,7 +23,7 @@ import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.impl.JndiRegistry;
-import org.apache.camel.model.ProcessorDefinition;
+import org.apache.camel.model.RouteNode;
 import org.apache.camel.spi.TraceableUnitOfWork;
 
 /**
@@ -72,9 +72,9 @@ public class TraceableUnitOfWorkTest extends ContextTestSupport {
             TraceableUnitOfWork tuow = (TraceableUnitOfWork) exchange.getUnitOfWork();
 
             // get the list of intercepted nodes
-            List<Processor> list = tuow.getInterceptedProcessors();
-            // get the 2nd last as the last is me (MyErrorProcessor)
-            Processor last = list.get(list.size() - 2);
+            List<RouteNode> list = tuow.getNodes();
+            // get the 3rd last as its the bean
+            Processor last = list.get(list.size() - 3).getProcessor();
 
             // set error message
             exchange.getFault().setBody("Failed at: " + last.toString());
diff --git a/camel-core/src/test/java/org/apache/camel/processor/intercept/DualInterceptSimpleRouteTest.java b/camel-core/src/test/java/org/apache/camel/processor/intercept/DualInterceptSimpleRouteTest.java
new file mode 100644
index 00000000000..9b077adf9f1
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/intercept/DualInterceptSimpleRouteTest.java
@@ -0,0 +1,59 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.intercept;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision$
+ */
+public class DualInterceptSimpleRouteTest extends ContextTestSupport {
+
+    public void testDualIntercept() throws Exception {
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:result").expectedMessageCount(1);
+
+        getMockEndpoint("mock:intercepted").expectedMessageCount(6);
+        getMockEndpoint("mock:a").expectedMessageCount(3);
+        getMockEndpoint("mock:b").expectedMessageCount(3);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                context.setTracing(true);
+
+                // it should genereally be avoid to have dual interceptors as its a bit confusing
+                // but you can do it anyway
+                intercept().to("mock:intercepted");
+
+                intercept().to("mock:a").to("mock:b");
+
+                from("direct:start")
+                    .to("mock:foo").to("mock:bar").to("mock:result");
+            }
+        };
+    }
+}
\ No newline at end of file
