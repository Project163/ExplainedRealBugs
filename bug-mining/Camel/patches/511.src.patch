diff --git a/camel-core/src/main/java/org/apache/camel/impl/MessageSupport.java b/camel-core/src/main/java/org/apache/camel/impl/MessageSupport.java
index 9ab1efd44f0..16e638bf1b5 100644
--- a/camel-core/src/main/java/org/apache/camel/impl/MessageSupport.java
+++ b/camel-core/src/main/java/org/apache/camel/impl/MessageSupport.java
@@ -21,6 +21,7 @@ import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.NoTypeConversionAvailableException;
 import org.apache.camel.TypeConverter;
+import org.apache.camel.impl.converter.DefaultTypeConverter;
 import org.apache.camel.util.UuidGenerator;
 
 /**
@@ -57,16 +58,31 @@ public abstract class MessageSupport implements Message {
         if (e != null) {
             CamelContext camelContext = e.getContext();
             if (camelContext != null) {
+                boolean tryConvert = true;
                 TypeConverter converter = camelContext.getTypeConverter();
-                try {
-                    // lets first try converting the message itself first
-                    // as for some types like InputStream v Reader its more efficient to do the transformation
-                    // from the Message itself as its got efficient implementations of them, before trying the
-                    // payload
-                    return converter.convertTo(type, e, body);
-                } catch (NoTypeConversionAvailableException ex) {
-                    // ignore
+                // if its the default type converter then use a performance shortcut to check if it can convert it
+                // this is faster than getting throwing and catching NoTypeConversionAvailableException
+                // the StreamCachingInterceptor will attempt to convert the payload to a StremCache for caching purpose
+                // so we get invoked on each node the exchange passes. So this is a little performance optimization
+                // to avoid the excessive exception handling
+                if (body != null && converter instanceof DefaultTypeConverter) {
+                    DefaultTypeConverter defaultTypeConverter = (DefaultTypeConverter) converter;
+                    // we can only check if there is no converter meaning we have tried to convert it beforehand
+                    // and then knows for sure there is no converter possible
+                    tryConvert = !defaultTypeConverter.hasNoConverterFor(type, body.getClass());
                 }
+                if (tryConvert) {
+                    try {
+                        // lets first try converting the body itself first
+                        // as for some types like InputStream v Reader its more efficient to do the transformation
+                        // from the body itself as its got efficient implementations of them, before trying the
+                        // message
+                        return converter.convertTo(type, e, body);
+                    } catch (NoTypeConversionAvailableException ex) {
+                        // ignore
+                    }
+                }
+                // fallback to the message itself
                 return converter.convertTo(type, this);
             }
         }
diff --git a/camel-core/src/main/java/org/apache/camel/impl/converter/DefaultTypeConverter.java b/camel-core/src/main/java/org/apache/camel/impl/converter/DefaultTypeConverter.java
index 05354e12010..c4e3ce0d42a 100644
--- a/camel-core/src/main/java/org/apache/camel/impl/converter/DefaultTypeConverter.java
+++ b/camel-core/src/main/java/org/apache/camel/impl/converter/DefaultTypeConverter.java
@@ -50,6 +50,7 @@ import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
 public class DefaultTypeConverter implements TypeConverter, TypeConverterRegistry {
     private static final transient Log LOG = LogFactory.getLog(DefaultTypeConverter.class);
     private final Map<TypeMapping, TypeConverter> typeMappings = new ConcurrentHashMap<TypeMapping, TypeConverter>();
+    private final Map<TypeMapping, TypeMapping> misses = new ConcurrentHashMap<TypeMapping, TypeMapping>();
     private Injector injector;
     private List<TypeConverterLoader> typeConverterLoaders = new ArrayList<TypeConverterLoader>();
     private List<TypeConverter> fallbackConverters = new ArrayList<TypeConverter>();
@@ -71,14 +72,34 @@ public class DefaultTypeConverter implements TypeConverter, TypeConverterRegistr
 
     public List<TypeConverterLoader> getTypeConverterLoaders() {
         return typeConverterLoaders;
-    }  
-    
+    }
+
+    /**
+     * Is there <b>NOT</b> a type converter registered being able to converter the
+     * given value to the type
+     * @param toType  the type to convert to
+     * @param fromType  the type to convert from
+     * @return <tt>true</tt> if there is <b>NOT</b> a converter, <tt>false</tt> if there is
+     */
+    @SuppressWarnings("unchecked")
+    public boolean hasNoConverterFor(Class toType, Class fromType) {
+        TypeMapping key = new TypeMapping(toType, fromType);
+        // we must only look in misses and not do the acutal convertions
+        // as for stream it can be impossible to re-read them and this
+        // method should not cause any overhead
+        return misses.containsKey(key);
+    }
+
     public <T> T convertTo(Class<T> type, Object value) {
         return convertTo(type, null, value);
     }
 
-    @SuppressWarnings("unchecked")
     public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
+        return doConvertTo(type, exchange, value);
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T> T doConvertTo(Class<T> type, Exchange exchange, Object value) {
         if (LOG.isTraceEnabled()) {
             LOG.trace("Converting " + (value == null ? "null" : value.getClass().getCanonicalName())
                 + " -> " + type.getCanonicalName() + " with value: " + value);
@@ -125,6 +146,11 @@ public class DefaultTypeConverter implements TypeConverter, TypeConverterRegistr
             }
         }
 
+        synchronized (misses) {
+            TypeMapping key = new TypeMapping(type, value.getClass());
+            misses.put(key, key);
+        }
+
         // Could not find suitable conversion
         throw new NoTypeConversionAvailableException(value, type);
     }
@@ -313,8 +339,7 @@ public class DefaultTypeConverter implements TypeConverter, TypeConverterRegistr
 
     protected void loadFallbackTypeConverters() throws IOException, ClassNotFoundException {
         FactoryFinder finder = new FactoryFinder();
-        List<TypeConverter> converters = finder.newInstances("FallbackTypeConverter", getInjector(),
-                                                             TypeConverter.class);
+        List<TypeConverter> converters = finder.newInstances("FallbackTypeConverter", getInjector(), TypeConverter.class);
         for (TypeConverter converter : converters) {
             addFallbackTypeConverter(converter);
         }
diff --git a/camel-core/src/main/java/org/apache/camel/processor/interceptor/StreamCachingInterceptor.java b/camel-core/src/main/java/org/apache/camel/processor/interceptor/StreamCachingInterceptor.java
index e03079efb0e..04901acea4d 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/interceptor/StreamCachingInterceptor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/interceptor/StreamCachingInterceptor.java
@@ -24,6 +24,7 @@ import org.apache.camel.Exchange;
 import org.apache.camel.NoTypeConversionAvailableException;
 import org.apache.camel.Processor;
 import org.apache.camel.StreamCache;
+import org.apache.camel.TypeConverter;
 import org.apache.camel.model.InterceptorRef;
 import org.apache.camel.model.InterceptorType;
 import org.apache.camel.processor.DelegateProcessor;
@@ -70,17 +71,29 @@ public class StreamCachingInterceptor extends DelegateProcessor implements Async
     }
 
     public boolean process(Exchange exchange, AsyncCallback callback) {
-        try {
-            StreamCache newBody = exchange.getIn().getBody(StreamCache.class);
-            if (newBody != null) {
-                exchange.getIn().setBody(newBody);
+        // Change the body to StreamCache if possible
+        // important to lookup for the type converter to avoid excessive overhead of trying to covnert if not possible
+        // as Camel will throw NoTypeConversionAvailableException that we just ignores. So we want to avoid this
+        // exception handling as it hurts performance dramatically for high throughput
+        // See also MessageSupport#getBody and CAMEL-1417
+        Object body = exchange.getIn().getBody();
+        if (body != null) {
+            TypeConverter tc = exchange.getContext().getTypeConverterRegistry().lookup(StreamCache.class, body.getClass());
+            if (tc != null) {
+                try {
+                    StreamCache newBody = tc.convertTo(StreamCache.class, exchange, body);
+                    if (newBody != null) {
+                        exchange.getIn().setBody(newBody);
+                    }
+                    MessageHelper.resetStreamCache(exchange.getIn());
+                } catch (NoTypeConversionAvailableException ex) {
+                    // ignore if in is not of StreamCache type
+                }
             }
-            MessageHelper.resetStreamCache(exchange.getIn());
-        } catch (NoTypeConversionAvailableException ex) {
-            // ignore if in is not of StreamCache type
         }
+
         return proceed(exchange, callback);
-    } 
+    }
 
     public boolean proceed(Exchange exchange, AsyncCallback callback) {        
         if (getProcessor() instanceof AsyncProcessor) {            
diff --git a/camel-core/src/test/java/org/apache/camel/processor/Camel715ThreadProcessorTest.java b/camel-core/src/test/java/org/apache/camel/processor/Camel715ThreadProcessorTest.java
index 27c98c2e3f0..abd65b71c67 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/Camel715ThreadProcessorTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/Camel715ThreadProcessorTest.java
@@ -30,7 +30,7 @@ import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.impl.DefaultCamelContext;
 
 public class Camel715ThreadProcessorTest extends TestCase {
-    private static final int ITERS = 20000;
+    private static final int ITERS = 50000;
 
     class SendingProcessor implements Processor {
         int iterationNumber;
diff --git a/camel-core/src/test/java/org/apache/camel/processor/RoutePerformanceTest.java b/camel-core/src/test/java/org/apache/camel/processor/RoutePerformanceTest.java
new file mode 100644
index 00000000000..f3ed8ded32b
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/RoutePerformanceTest.java
@@ -0,0 +1,77 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import java.util.HashMap;
+import java.util.Map;
+import javax.naming.Context;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.dataset.SimpleDataSet;
+import org.apache.camel.component.mock.MockEndpoint;
+
+/**
+ * A route for simple performance testing that can be used when we suspect
+ * something is wrong. Inspired by end user on forum doing this as proof of concept.
+ */
+public class RoutePerformanceTest extends ContextTestSupport {
+
+    protected SimpleDataSet dataSet = new SimpleDataSet(1000);
+
+    public void testPerformance() throws Exception {
+        long start = System.nanoTime();
+
+        MockEndpoint endpoint = getMockEndpoint("mock:results");
+        endpoint.expectedMessageCount((int) dataSet.getSize());
+
+        assertMockEndpointsSatisfied();
+
+        long delta = System.nanoTime() - start;
+
+        System.out.println("Took: " + delta + " ns");
+        System.out.println("Took: " + delta / 1000000 + " millis");
+    }
+
+    @Override
+    protected Context createJndiContext() throws Exception {
+        Map<String, Object> headers = new HashMap<String, Object>();
+        headers.put("foo", 123);
+        dataSet.setDefaultHeaders(headers);
+
+        Context context = super.createJndiContext();
+        context.bind("foo", dataSet);
+        return context;
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("dataset:foo").to("direct:start");
+
+                from("direct:start").to("direct:a", "direct:b", "direct:c");
+                from("direct:c")
+                    .choice()
+                        .when().header("foo").to("mock:results", "dataset:foo")
+                        .otherwise().to("mock:results", "dataset:foo")
+                    .end();
+            }
+        };
+    }
+}
