diff --git a/dsl/camel-kamelet-main/src/main/java/org/apache/camel/main/KameletMain.java b/dsl/camel-kamelet-main/src/main/java/org/apache/camel/main/KameletMain.java
index 75e5416ae1f..75a0aab4e49 100644
--- a/dsl/camel-kamelet-main/src/main/java/org/apache/camel/main/KameletMain.java
+++ b/dsl/camel-kamelet-main/src/main/java/org/apache/camel/main/KameletMain.java
@@ -32,6 +32,7 @@ import org.apache.camel.CamelContext;
 import org.apache.camel.ExtendedCamelContext;
 import org.apache.camel.ProducerTemplate;
 import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.TypeConverterExists;
 import org.apache.camel.component.properties.PropertiesComponent;
 import org.apache.camel.dsl.support.SourceLoader;
 import org.apache.camel.impl.DefaultCamelContext;
@@ -410,7 +411,17 @@ public class KameletMain extends MainCommandLineSupport {
             addInitialProperty("camel.component.properties.ignore-missing-location", "true");
             PropertiesComponent pc = (PropertiesComponent) answer.getPropertiesComponent();
             pc.setPropertiesParser(new ExportPropertiesParser());
-            answer.getTypeConverterRegistry().addFallbackTypeConverter(new ExportTypeConverter(), false);
+
+            // override default type converters with our export converter that is more flexible during exporting
+            ExportTypeConverter ec = new ExportTypeConverter();
+            answer.getTypeConverterRegistry().setTypeConverterExists(TypeConverterExists.Override);
+            answer.getTypeConverterRegistry().addTypeConverter(Integer.class, String.class, ec);
+            answer.getTypeConverterRegistry().addTypeConverter(Long.class, String.class, ec);
+            answer.getTypeConverterRegistry().addTypeConverter(Double.class, String.class, ec);
+            answer.getTypeConverterRegistry().addTypeConverter(Float.class, String.class, ec);
+            answer.getTypeConverterRegistry().addTypeConverter(Byte.class, String.class, ec);
+            answer.getTypeConverterRegistry().addTypeConverter(Boolean.class, String.class, ec);
+            answer.getTypeConverterRegistry().addFallbackTypeConverter(ec, false);
         }
 
         boolean prompt = "true".equals(getInitialProperties().get("camel.jbang.prompt"));
diff --git a/dsl/camel-kamelet-main/src/main/java/org/apache/camel/main/download/ExportTypeConverter.java b/dsl/camel-kamelet-main/src/main/java/org/apache/camel/main/download/ExportTypeConverter.java
index b1f3c23976c..02170dc893d 100644
--- a/dsl/camel-kamelet-main/src/main/java/org/apache/camel/main/download/ExportTypeConverter.java
+++ b/dsl/camel-kamelet-main/src/main/java/org/apache/camel/main/download/ExportTypeConverter.java
@@ -20,7 +20,6 @@ import org.apache.camel.Exchange;
 import org.apache.camel.TypeConversionException;
 import org.apache.camel.support.TypeConverterSupport;
 import org.apache.camel.support.component.PropertyConfigurerSupport;
-import org.apache.camel.util.ObjectHelper;
 
 /**
  * During export then we can be more flexible and allow missing property placeholders to resolve to a hardcoded value,
@@ -32,18 +31,23 @@ public class ExportTypeConverter extends TypeConverterSupport {
     public <T> T convertTo(Class<T> type, Exchange exchange, Object value) throws TypeConversionException {
         if (PropertyConfigurerSupport.MAGIC_VALUE.equals(value)) {
             // attempt to convert to the given type using different common inputs (boolean, numeric, string)
-            T answer = null;
             if (boolean.class == type || Boolean.class == type) {
-                answer = exchange.getContext().getTypeConverter().tryConvertTo(type, exchange, "true");
+                return (T) Boolean.TRUE;
+            } else if (type == int.class || type == Integer.class) {
+                return (T) Integer.valueOf("1");
+            } else if (type == long.class || type == Long.class) {
+                return (T) Long.valueOf("1");
+            } else if (type == double.class || type == Double.class) {
+                return (T) Double.valueOf("1");
+            } else if (type == float.class || type == Float.class) {
+                return (T) Float.valueOf("1");
+            } else if (type == short.class || type == Short.class) {
+                return (T) Short.valueOf("1");
+            } else if (type == byte.class || type == Byte.class) {
+                return (T) Byte.valueOf("0");
+            } else if (type == String.class) {
+                return (T) PropertyConfigurerSupport.MAGIC_VALUE;
             }
-            if (answer == null && ObjectHelper.isNumericType(type)) {
-                answer = exchange.getContext().getTypeConverter().tryConvertTo(type, exchange, "1");
-            }
-            if (answer == null && type == String.class) {
-                answer = exchange.getContext().getTypeConverter().tryConvertTo(type, exchange,
-                        PropertyConfigurerSupport.MAGIC_VALUE);
-            }
-            return answer;
         }
         return null;
     }
