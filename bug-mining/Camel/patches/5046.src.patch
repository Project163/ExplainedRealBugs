diff --git a/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultConsumerTemplate.java b/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultConsumerTemplate.java
index b23547bbe68..9869699a8b7 100644
--- a/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultConsumerTemplate.java
+++ b/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultConsumerTemplate.java
@@ -109,7 +109,7 @@ public class DefaultConsumerTemplate extends ServiceSupport implements ConsumerT
 
     @Override
     public Object receiveBody(String endpointUri) {
-        Object answer = null;
+        Object answer;
         Exchange exchange = receive(endpointUri);
         try {
             answer = extractResultBody(exchange);
@@ -259,6 +259,12 @@ public class DefaultConsumerTemplate extends ServiceSupport implements ConsumerT
 
             // okay no fault then return the response
             answer = result.getMessage().getBody();
+
+            // in a very seldom situation then getBody can cause an exception to be set on the exchange
+            // rethrow if there was an exception during execution
+            if (result.getException() != null) {
+                throw wrapRuntimeCamelException(result.getException());
+            }
         }
         return answer;
     }
diff --git a/core/camel-core/src/test/java/org/apache/camel/component/bean/BeanCreateBodyExceptionTest.java b/core/camel-core/src/test/java/org/apache/camel/component/bean/BeanCreateBodyExceptionTest.java
new file mode 100644
index 00000000000..ecd8bcfe401
--- /dev/null
+++ b/core/camel-core/src/test/java/org/apache/camel/component/bean/BeanCreateBodyExceptionTest.java
@@ -0,0 +1,146 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.bean;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.support.DefaultMessage;
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class BeanCreateBodyExceptionTest extends ContextTestSupport {
+
+    @Test
+    public void testCreateBodyFirstTimeException() throws Exception {
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:dead").expectedMessageCount(1);
+
+        template.send("direct:start", e -> {
+            e.setIn(new DefaultMessage(e) {
+
+                private boolean created;
+
+                @Override
+                protected Object createBody() {
+                    if (!created) {
+                        created = true;
+                        throw new IllegalArgumentException("Forced internal error");
+                    } else {
+                        return "Hello World";
+                    }
+                }
+            });
+        });
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Test
+    public void testCreateBodyAlwaysException() throws Exception {
+        getMockEndpoint("mock:result").expectedMessageCount(0);
+        getMockEndpoint("mock:dead").expectedMessageCount(1);
+
+        template.send("direct:start", e -> {
+            e.setIn(new DefaultMessage(e) {
+                @Override
+                protected Object createBody() {
+                    throw new IllegalArgumentException("Forced internal error");
+                }
+            });
+        });
+
+        try {
+            assertMockEndpointsSatisfied();
+            fail("Should fail");
+        } catch (Throwable e) {
+            // ignore
+        }
+
+        // mock:dead should have as failure as createBody fails so cannot do defensive copy in mock
+        assertEquals(1, getMockEndpoint("mock:dead").getFailures().size());
+        Throwable e = getMockEndpoint("mock:dead").getFailures().get(0);
+        assertNotNull(e);
+        assertEquals("Forced internal error", e.getMessage());
+    }
+
+    @Test
+    public void testProducerTemplateCreateBodyAlwaysException() throws Exception {
+        template.send("seda:empty", e -> {
+            e.setIn(new DefaultMessage(e) {
+                @Override
+                protected Object createBody() {
+                    throw new IllegalArgumentException("Forced internal error");
+                }
+            });
+        });
+    }
+
+    @Test
+    public void testConsumerTemplateCreateBodyAlwaysException() throws Exception {
+        final AtomicBoolean fail = new AtomicBoolean();
+
+        template.send("seda:empty", e -> {
+            e.setIn(new DefaultMessage(e) {
+
+                @Override
+                protected Object createBody() {
+                    if (fail.get()) {
+                        throw new IllegalArgumentException("Forced internal error");
+                    } else {
+                        return null;
+                    }
+                }
+
+                @Override
+                public DefaultMessage newInstance() {
+                    // dont copy so we can preserve this message instance that has the fail mode in createBody
+                    return this;
+                }
+            });
+        });
+
+        try {
+            // turn on fail mode
+            fail.set(true);
+
+            consumer.receiveBody("seda:empty", 10000);
+            fail("Should throw exception");
+        } catch (Exception e) {
+            assertIsInstanceOf(IllegalArgumentException.class, e);
+            assertEquals("Forced internal error", e.getMessage());
+        }
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                    .errorHandler(deadLetterChannel("mock:dead"))
+                    .bean(BeanCreateBodyExceptionTest.class, "callMe")
+                    .to("mock:result");
+            }
+        };
+    }
+
+    public String callMe(String body) {
+        return "Hello " + body;
+    }
+}
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/ExchangeHelper.java b/core/camel-support/src/main/java/org/apache/camel/support/ExchangeHelper.java
index 79d842ec333..52568cb6a04 100644
--- a/core/camel-support/src/main/java/org/apache/camel/support/ExchangeHelper.java
+++ b/core/camel-support/src/main/java/org/apache/camel/support/ExchangeHelper.java
@@ -661,7 +661,14 @@ public final class ExchangeHelper {
                 // use IN as the response
                 answer = exchange.getIn().getBody();
             }
+
+            // in a very seldom situation then getBody can cause an exception to be set on the exchange
+            // rethrow if there was an exception during execution
+            if (exchange.getException() != null) {
+                throw CamelExecutionException.wrapCamelExecutionException(exchange, exchange.getException());
+            }
         }
+
         return answer;
     }
 
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/MessageHelper.java b/core/camel-support/src/main/java/org/apache/camel/support/MessageHelper.java
index 275b0fe03a7..8bbb5a4e332 100644
--- a/core/camel-support/src/main/java/org/apache/camel/support/MessageHelper.java
+++ b/core/camel-support/src/main/java/org/apache/camel/support/MessageHelper.java
@@ -126,7 +126,12 @@ public final class MessageHelper {
         if (message == null) {
             return;
         }
-        Object body = message.getBody();
+        Object body = null;
+        try {
+            body = message.getBody();
+        } catch (Throwable e) {
+            // ignore
+        }
         if (body instanceof StreamCache) {
             ((StreamCache) body).reset();
         }
