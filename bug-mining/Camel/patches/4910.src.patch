diff --git a/core/camel-base/src/main/java/org/apache/camel/impl/engine/AbstractCamelContext.java b/core/camel-base/src/main/java/org/apache/camel/impl/engine/AbstractCamelContext.java
index f266eb14bb9..6191b73392c 100644
--- a/core/camel-base/src/main/java/org/apache/camel/impl/engine/AbstractCamelContext.java
+++ b/core/camel-base/src/main/java/org/apache/camel/impl/engine/AbstractCamelContext.java
@@ -3406,9 +3406,18 @@ public abstract class AbstractCamelContext extends ServiceSupport implements Ext
             }
         }
 
+        // preserve any existing event notifiers that may have been already added
+        List<EventNotifier> notifiers = null;
+        if (managementStrategy != null) {
+            notifiers = managementStrategy.getEventNotifiers();
+        }
+
         log.debug("Setting up management with factory: {}", factory);
         try {
             ManagementStrategy strategy = factory.create(this, options);
+            if (notifiers != null) {
+                notifiers.forEach(strategy::addEventNotifier);
+            }
             LifecycleStrategy lifecycle = factory.createLifecycle(this);
             factory.setupManagement(this, strategy, lifecycle);
         } catch (Exception e) {
diff --git a/core/camel-core/src/main/java/org/apache/camel/main/MainDurationEventNotifier.java b/core/camel-core/src/main/java/org/apache/camel/main/MainDurationEventNotifier.java
index 4c8bd846570..cc7c5bf1f49 100644
--- a/core/camel-core/src/main/java/org/apache/camel/main/MainDurationEventNotifier.java
+++ b/core/camel-core/src/main/java/org/apache/camel/main/MainDurationEventNotifier.java
@@ -48,7 +48,7 @@ public class MainDurationEventNotifier extends EventNotifierSupport {
 
     private volatile int doneMessages;
     private volatile StopWatch watch;
-    private volatile ScheduledExecutorService executorService;
+    private volatile ScheduledExecutorService idleExecutorService;
 
     public MainDurationEventNotifier(CamelContext camelContext, int maxMessages, long maxIdleSeconds,
                                      AtomicBoolean completed, CountDownLatch latch, boolean stopCamelContext) {
@@ -74,16 +74,12 @@ public class MainDurationEventNotifier extends EventNotifierSupport {
             if (result) {
                 if (completed.compareAndSet(false, true)) {
                     LOG.info("Duration max messages triggering shutdown of the JVM.");
-                    try {
-                        // shutting down CamelContext
-                        if (stopCamelContext) {
-                            camelContext.stop();
-                        }
-                    } catch (Exception e) {
-                        LOG.warn("Error during stopping CamelContext. This exception is ignored.", e);
-                    } finally {
-                        // trigger stopping the Main
-                        latch.countDown();
+                    // use thread to stop Camel as otherwise we would block current thread
+                    Thread thread = camelContext.getExecutorServiceManager().newThread("CamelMainShutdownCamelContext", new ShutdownTask());
+                    thread.start();
+                    // shutdown idle checker if in use as we are stopping
+                    if (idleExecutorService != null) {
+                        idleExecutorService.shutdownNow();
                     }
                 }
             }
@@ -98,7 +94,7 @@ public class MainDurationEventNotifier extends EventNotifierSupport {
 
     @Override
     public boolean isEnabled(CamelEvent event) {
-        return event instanceof ExchangeCompletedEvent || event instanceof ExchangeFailedEvent;
+        return event instanceof ExchangeCreatedEvent || event instanceof ExchangeCompletedEvent || event instanceof ExchangeFailedEvent;
     }
 
     @Override
@@ -114,7 +110,7 @@ public class MainDurationEventNotifier extends EventNotifierSupport {
             camelContext.addStartupListener((context, alreadyStarted) -> watch = new StopWatch());
 
             // okay we need to trigger on idle after X period, and therefore we need a background task that checks this
-            executorService = Executors.newSingleThreadScheduledExecutor();
+            idleExecutorService = Executors.newSingleThreadScheduledExecutor();
             Runnable task = () -> {
                 if (watch == null) {
                     // camel has not been started yet
@@ -135,23 +131,31 @@ public class MainDurationEventNotifier extends EventNotifierSupport {
                 if (result) {
                     if (completed.compareAndSet(false, true)) {
                         LOG.info("Duration max idle triggering shutdown of the JVM.");
-                        try {
-                            // shutting down CamelContext
-                            if (stopCamelContext) {
-                                camelContext.stop();
-                            }
-                        } catch (Exception e) {
-                            LOG.warn("Error during stopping CamelContext. This exception is ignored.", e);
-                        } finally {
-                            // trigger stopping the Main
-                            latch.countDown();
-                            // shutdown the pool
-                            executorService.shutdownNow();
-                        }
+                        // use thread to stop Camel as otherwise we would block current thread
+                        Thread thread = camelContext.getExecutorServiceManager().newThread("CamelMainShutdownCamelContext", new ShutdownTask());
+                        thread.start();
                     }
                 }
             };
-            executorService.scheduleAtFixedRate(task, 1, 1, TimeUnit.SECONDS);
+            idleExecutorService.scheduleAtFixedRate(task, 1, 1, TimeUnit.SECONDS);
+        }
+    }
+
+    private class ShutdownTask implements Runnable {
+
+        @Override
+        public void run() {
+            try {
+                // shutting down CamelContext
+                if (stopCamelContext) {
+                    camelContext.stop();
+                }
+            } catch (Exception e) {
+                LOG.warn("Error during stopping CamelContext. This exception is ignored.", e);
+            } finally {
+                // trigger stopping the Main
+                latch.countDown();
+            }
         }
     }
 
diff --git a/core/camel-core/src/main/java/org/apache/camel/main/MainSupport.java b/core/camel-core/src/main/java/org/apache/camel/main/MainSupport.java
index a7869dd9f2c..0f3570e9a78 100644
--- a/core/camel-core/src/main/java/org/apache/camel/main/MainSupport.java
+++ b/core/camel-core/src/main/java/org/apache/camel/main/MainSupport.java
@@ -639,18 +639,21 @@ public abstract class MainSupport extends ServiceSupport {
     protected void waitUntilCompleted() {
         while (!completed.get()) {
             try {
+                int idle = mainConfigurationProperties.getDurationMaxIdleSeconds();
+                int max = mainConfigurationProperties.getDurationMaxMessages();
                 if (mainConfigurationProperties.getDuration() > 0) {
                     LOG.info("Waiting for: {} seconds", mainConfigurationProperties.getDuration());
                     latch.await(mainConfigurationProperties.getDuration(), TimeUnit.SECONDS);
                     exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, mainConfigurationProperties.getDurationHitExitCode());
                     completed.set(true);
-                } else if (mainConfigurationProperties.getDurationMaxIdleSeconds() > 0) {
-                    LOG.info("Waiting to be idle for: {} seconds", mainConfigurationProperties.getDurationMaxIdleSeconds());
-                    exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, mainConfigurationProperties.getDurationHitExitCode());
-                    latch.await();
-                    completed.set(true);
-                } else if (mainConfigurationProperties.getDurationMaxMessages() > 0) {
-                    LOG.info("Waiting until: {} messages has been processed", mainConfigurationProperties.getDurationMaxMessages());
+                } else if (idle > 0 || max > 0) {
+                    if (idle > 0 && max > 0) {
+                        LOG.info("Waiting to be idle for: {} seconds or until: {} messages has been processed", idle, max);
+                    } else if (idle > 0) {
+                        LOG.info("Waiting to be idle for: {} seconds", idle);
+                    } else {
+                        LOG.info("Waiting until: {} messages has been processed", max);
+                    }
                     exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, mainConfigurationProperties.getDurationHitExitCode());
                     latch.await();
                     completed.set(true);
@@ -658,6 +661,9 @@ public abstract class MainSupport extends ServiceSupport {
                     latch.await();
                 }
             } catch (InterruptedException e) {
+                // okay something interrupted us so terminate
+                completed.set(true);
+                latch.countDown();
                 Thread.currentThread().interrupt();
             }
         }
