diff --git a/camel-core/src/main/java/org/apache/camel/impl/EventDrivenPollingConsumer.java b/camel-core/src/main/java/org/apache/camel/impl/EventDrivenPollingConsumer.java
index aebe538f8b0..1e2ffcd94f6 100644
--- a/camel-core/src/main/java/org/apache/camel/impl/EventDrivenPollingConsumer.java
+++ b/camel-core/src/main/java/org/apache/camel/impl/EventDrivenPollingConsumer.java
@@ -114,14 +114,17 @@ public class EventDrivenPollingConsumer extends PollingConsumerSupport implement
         }
 
         while (isRunAllowed()) {
-            try {
-                beforePoll(0);
-                // take will block waiting for message
-                return queue.take();
-            } catch (InterruptedException e) {
-                handleInterruptedException(e);
-            } finally {
-                afterPoll();
+            // CAMEL-10215 - Synchronizing the ordering of beforePoll, poll and afterPoll as an atomic activity
+            synchronized(this) {
+                try {
+                    beforePoll(0);
+                    // take will block waiting for message
+                    return queue.take();
+                } catch (InterruptedException e) {
+                    handleInterruptedException(e);
+                } finally {
+                    afterPoll();
+                }
             }
         }
         LOG.trace("Consumer is not running, so returning null");
@@ -134,15 +137,18 @@ public class EventDrivenPollingConsumer extends PollingConsumerSupport implement
             throw new RejectedExecutionException(this + " is not started, but in state: " + getStatus().name());
         }
 
-        try {
-            // use the timeout value returned from beforePoll
-            timeout = beforePoll(timeout);
-            return queue.poll(timeout, TimeUnit.MILLISECONDS);
-        } catch (InterruptedException e) {
-            handleInterruptedException(e);
-            return null;
-        } finally {
-            afterPoll();
+        // CAMEL-10215 - Synchronizing the ordering of beforePoll, poll and afterPoll as an atomic activity
+        synchronized(this) {
+            try {
+                // use the timeout value returned from beforePoll
+                timeout = beforePoll(timeout);
+                return queue.poll(timeout, TimeUnit.MILLISECONDS);
+            } catch (InterruptedException e) {
+                handleInterruptedException(e);
+                return null;
+            } finally {
+                afterPoll();
+            }
         }
     }
 
