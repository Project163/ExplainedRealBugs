diff --git a/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/EndpointSchemaGeneratorMojo.java b/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/EndpointSchemaGeneratorMojo.java
index 1789e8ecb07..8a3a88f819d 100644
--- a/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/EndpointSchemaGeneratorMojo.java
+++ b/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/EndpointSchemaGeneratorMojo.java
@@ -262,7 +262,6 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
                     .filter(option -> !endpointOptionNames.contains(option.getName()))
                     .forEach(option -> componentModel.getEndpointOptions().add(option));
         }
-
     }
 
     private void fixDoc(BaseOptionModel option, List<? extends BaseOptionModel> parentOptions) {
@@ -494,11 +493,13 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
             // We order the methods according to the source code to keep compatibility
             // with the old apt processing tool, however, we could get rid of that
             JavaClassSource source = javaClassSource(classElement.getName());
-            List<MethodSource<JavaClassSource>> methodSources = source.getMethods().stream()
+            List<MethodSource<JavaClassSource>> methodSources = source != null ?
+                    source.getMethods().stream()
                     .filter(method -> method.isPublic()
                             && method.getName().startsWith("set")
                             && method.getParameters().size() == 1
-                            && method.getReturnType().getName().equals("void")).collect(Collectors.toList());
+                            && method.getReturnType().getName().equals("void")).collect(Collectors.toList()) :
+                    Collections.EMPTY_LIST;
 
             List<Method> methods = Stream.of(classElement.getDeclaredMethods()).filter(method -> {
                 Metadata metadata = method.getAnnotation(Metadata.class);
@@ -528,6 +529,9 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
                 }
                 return true;
             }).sorted(Comparator.comparing(m -> {
+                if (methodSources.isEmpty()) {
+                    return 0;
+                }
                 int index = -1;
                 for (int i = 0; i < methodSources.size(); i++) {
                     MethodSource<?> ms = methodSources.get(i);
@@ -535,8 +539,7 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
                             && ms.getReturnType().getName().equals("void")
                             && ms.getParameters().size() == 1
                             && getSimpleName(ms.getParameters().get(0).getType())
-                                    .equals(m.getParameters()[0].getType().getSimpleName())
-                    ) {
+                                    .equals(m.getParameters()[0].getType().getSimpleName())) {
                         index = i;
                     }
                 }
@@ -734,6 +737,7 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
                     if ("".equals(defaultValue) && metadata != null) {
                         defaultValue = metadata.defaultValue();
                     }
+                    String defaultValueNote = path.defaultValueNote();
                     boolean required = metadata != null && metadata.required();
                     String label = path.label();
                     if (Strings.isNullOrEmpty(label) && metadata != null) {
@@ -790,7 +794,7 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
                     option.setJavaType(fieldTypeName);
                     option.setRequired(required);
                     option.setDefaultValue(defaultValue);
-//                    option.setDefaultValueNote(defaultValueNote);
+                    option.setDefaultValueNote(defaultValueNote);
                     option.setDescription(docComment.trim());
                     option.setDeprecated(deprecated);
                     option.setDeprecationNote(deprecationNote);
@@ -1232,6 +1236,9 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
     }
 
     static String getJavaDocText(String source, JavaDocCapable<?> member) {
+        if (member == null) {
+            return null;
+        }
         JavaDoc<?> javaDoc = member.getJavaDoc();
         Javadoc jd = (Javadoc) javaDoc.getInternal();
         if (source != null && jd.tags().size() > 0) {
@@ -1259,8 +1266,10 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
                 sourceRoots = project.getCompileSourceRoots().stream()
                         .map(Paths::get)
                         .collect(Collectors.toList());
-                Path camelRoot = PackageHelper.findCamelCoreDirectory(project.getBasedir())
-                        .toPath().getParent().getParent();
+                // we can only find camel root folder if its the apache camel project itself
+                // 3rd party projects then this will be null
+                File camelRootFile = PackageHelper.findCamelCoreDirectory(project.getBasedir());
+                final Path camelRoot = camelRootFile != null ? camelRootFile.toPath().getParent().getParent() : project.getBasedir().toPath();
                 project.getCompileClasspathElements().stream()
                         .flatMap(dep -> {
                             // m2 repo dependency
@@ -1268,7 +1277,7 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
                                 String name = Strings.before(Strings.after(dep, "/org/apache/camel/"), "/");
                                 return Stream.of(name);
                             // reactor dependency
-                            } else if (dep.startsWith(camelRoot.toString() + "/")) {
+                            } else if (camelRootFile != null && dep.startsWith(camelRoot.toString() + "/")) {
                                 String name = Strings.before(Strings.after(dep, camelRoot.toString() + "/"), "/target");
                                 int idx = name.lastIndexOf("/");
                                 if (idx > 0) {
@@ -1306,7 +1315,11 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
     private JavaClassSource doParseJavaClassSource(String className) {
         try {
             String source = loadJavaSource(className);
-            return (JavaClassSource) Roaster.parse(source);
+            if (source != null) {
+                return (JavaClassSource) Roaster.parse(source);
+            } else {
+                return null;
+            }
         } catch (Exception e) {
             throw new RuntimeException("Unable to parse java class " + className, e);
         }
@@ -1317,6 +1330,11 @@ public class EndpointSchemaGeneratorMojo extends AbstractGeneratorMojo {
     }
 
     private String doLoadJavaSource(String className) {
+        // skip default
+        if (className.startsWith("org.apache.camel.support.")) {
+            return null;
+        }
+
         try {
             Path file = getSourceRoots().stream()
                     .map(d -> d.resolve(className.replace('.', '/') + ".java"))
