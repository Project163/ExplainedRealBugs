diff --git a/camel-core/src/main/java/org/apache/camel/CamelExchangeException.java b/camel-core/src/main/java/org/apache/camel/CamelExchangeException.java
index ffdb53f7862..9afbe1f1661 100644
--- a/camel-core/src/main/java/org/apache/camel/CamelExchangeException.java
+++ b/camel-core/src/main/java/org/apache/camel/CamelExchangeException.java
@@ -32,7 +32,7 @@ public class CamelExchangeException extends CamelException {
     }
 
     public CamelExchangeException(String message, Exchange exchange, Throwable cause) {
-        super(createMessage(message, exchange), cause);
+        super(createMessage(message, exchange, cause), cause);
         this.exchange = exchange;
     }
 
@@ -46,4 +46,8 @@ public class CamelExchangeException extends CamelException {
     protected static String createMessage(String message, Exchange exchange) {
         return message + " on the exchange: " + exchange;
     }
+
+    protected static String createMessage(String message, Exchange exchange, Throwable cause) {
+        return createMessage(message, exchange) + ". Cause by: [" + cause.getClass().getName() + " - " + cause.getMessage() + "]";
+    }
 }
diff --git a/camel-core/src/main/java/org/apache/camel/Channel.java b/camel-core/src/main/java/org/apache/camel/Channel.java
index bf523995921..248e134a5c1 100644
--- a/camel-core/src/main/java/org/apache/camel/Channel.java
+++ b/camel-core/src/main/java/org/apache/camel/Channel.java
@@ -114,9 +114,16 @@ public interface Channel extends Processor, Navigate<Processor> {
     Processor getNextProcessor();
 
     /**
-     * Gets the defintion of the next processor
+     * Gets the definition of the next processor
      *
      * @return the processor definition
      */
     ProcessorDefinition<?> getProcessorDefinition();
+
+    /**
+     * Gets the {@link RouteContext}
+     *
+     * @return the route context
+     */
+    RouteContext getRouteContext();
 }
diff --git a/camel-core/src/main/java/org/apache/camel/Exchange.java b/camel-core/src/main/java/org/apache/camel/Exchange.java
index 8832992ca5c..c825a63361c 100644
--- a/camel-core/src/main/java/org/apache/camel/Exchange.java
+++ b/camel-core/src/main/java/org/apache/camel/Exchange.java
@@ -94,6 +94,7 @@ public interface Exchange {
     String ROUTE_STOP         = "CamelRouteStop";
     String REDELIVERED        = "CamelRedelivered";
     String REDELIVERY_COUNTER = "CamelRedeliveryCounter";
+    String REDELIVERY_EXHAUSTED = "CamelRedeliveryExhausted";
     String ROLLBACK_ONLY      = "CamelRollbackOnly";
     String ROLLBACK_ONLY_LAST = "CamelRollbackOnlyLast";
 
diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultRouteContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultRouteContext.java
index d8359aef274..7775397dc6e 100644
--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultRouteContext.java
+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultRouteContext.java
@@ -144,7 +144,7 @@ public class DefaultRouteContext implements RouteContext {
             Processor processor = Pipeline.newInstance(eventDrivenProcessors);
 
             // and wrap it in a unit of work so the UoW is on the top, so the entire route will be in the same UoW
-            Processor unitOfWorkProcessor = new UnitOfWorkProcessor(processor);
+            Processor unitOfWorkProcessor = new UnitOfWorkProcessor(this, processor);
             Processor target = unitOfWorkProcessor;
 
             // and then optionally add route policy processor if a custom policy is set
diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultUnitOfWork.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultUnitOfWork.java
index fec0018d916..7e8d0ab63af 100644
--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultUnitOfWork.java
+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultUnitOfWork.java
@@ -24,6 +24,7 @@ import java.util.Set;
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.Service;
+import org.apache.camel.spi.RouteContext;
 import org.apache.camel.spi.Synchronization;
 import org.apache.camel.spi.TracedRouteNodes;
 import org.apache.camel.spi.UnitOfWork;
@@ -45,6 +46,7 @@ public class DefaultUnitOfWork implements UnitOfWork, Service {
     private Message originalInMessage;
     private final TracedRouteNodes tracedRouteNodes;
     private Set<Object> transactedBy;
+    private RouteContext routeContext;
 
     public DefaultUnitOfWork(Exchange exchange) {
         tracedRouteNodes = new DefaultTracedRouteNodes();
@@ -85,6 +87,7 @@ public class DefaultUnitOfWork implements UnitOfWork, Service {
             transactedBy.clear();
         }
         originalInMessage = null;
+        routeContext = null;
     }
 
     public synchronized void addSynchronization(Synchronization synchronization) {
@@ -177,6 +180,14 @@ public class DefaultUnitOfWork implements UnitOfWork, Service {
         getTransactedBy().remove(transactionDefinition);
     }
 
+    public RouteContext getRouteContext() {
+        return routeContext;
+    }
+
+    public void setRouteContext(RouteContext routeContext) {
+        this.routeContext = routeContext;
+    }
+
     private Set<Object> getTransactedBy() {
         if (transactedBy == null) {
             transactedBy = new LinkedHashSet<Object>();
diff --git a/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java b/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java
index c5b05d46ba7..38178324d39 100644
--- a/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java
@@ -16,10 +16,8 @@
  */
 package org.apache.camel.model;
 
-import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
-
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -27,11 +25,9 @@ import javax.xml.bind.annotation.XmlRootElement;
 import javax.xml.bind.annotation.XmlTransient;
 
 import org.apache.camel.Processor;
-import org.apache.camel.builder.ErrorHandlerBuilder;
 import org.apache.camel.processor.MulticastProcessor;
 import org.apache.camel.processor.aggregate.AggregationStrategy;
 import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
-import org.apache.camel.spi.LifecycleStrategy;
 import org.apache.camel.spi.RouteContext;
 
 /**
@@ -141,14 +137,7 @@ public class MulticastDefinition extends OutputDefinition<ProcessorDefinition> {
             executorService = routeContext.lookup(executorServiceRef, ExecutorService.class);
         }
 
-        // wrap list of processors in error handlers so we have fine grained error handling
-        List<Processor> processors = new ArrayList<Processor>(list.size());
-        for (Processor output : list) {
-            Processor errorHandler = wrapInErrorHandler(routeContext, output);
-            processors.add(errorHandler);
-        }
-
-        return new MulticastProcessor(processors, aggregationStrategy, isParallelProcessing(), executorService,
+        return new MulticastProcessor(list, aggregationStrategy, isParallelProcessing(), executorService,
                                       isStreaming(), isStopOnException());
     }
 
@@ -193,4 +182,4 @@ public class MulticastDefinition extends OutputDefinition<ProcessorDefinition> {
         this.executorService = executorService;
     }
 
-}
\ No newline at end of file
+}
diff --git a/camel-core/src/main/java/org/apache/camel/model/OnCompletionDefinition.java b/camel-core/src/main/java/org/apache/camel/model/OnCompletionDefinition.java
index fe277dc68a1..e3f512c5125 100644
--- a/camel-core/src/main/java/org/apache/camel/model/OnCompletionDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/OnCompletionDefinition.java
@@ -74,7 +74,7 @@ public class OnCompletionDefinition extends ProcessorDefinition<ProcessorDefinit
         Processor childProcessor = createOutputsProcessor(routeContext);
 
         // wrap the on completion route in a unit of work processor
-        childProcessor = new UnitOfWorkProcessor(childProcessor);
+        childProcessor = new UnitOfWorkProcessor(routeContext, childProcessor);
 
         Predicate when = null;
         if (onWhen != null) {
diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java
index bc12ea6e059..87d76d8e7fe 100644
--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java
@@ -180,13 +180,13 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition> exte
         if (defn instanceof TryDefinition || defn instanceof CatchDefinition || defn instanceof FinallyDefinition) {
             // do not use error handler for try .. catch .. finally blocks as it will handle errors itself
             return channel;
-        } else if (defn instanceof MulticastDefinition) {
-            // do not use error handler for multicast based as it offers fine grained error handlers for its outputs
+        } else if (defn instanceof MulticastDefinition || defn instanceof RecipientListDefinition) {
+            // do not use error handler for multicast or recipientlist based as it offers fine grained error handlers for its outputs
             return channel;
         } else {
             // regular definition so add the error handler
             Processor output = channel.getOutput();
-            Processor errorHandler = wrapInErrorHandler(routeContext, output);
+            Processor errorHandler = wrapInErrorHandler(routeContext, getErrorHandlerBuilder(), output);
             // set error handler on channel
             channel.setErrorHandler(errorHandler);
 
@@ -200,11 +200,10 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition> exte
      * @param routeContext the route context
      * @param output the output
      * @return the output wrapped with the error handler
-     * @throws Exception can be thrown
+     * @throws Exception can be thrown if failed to create error handler builder
      */
-    protected Processor wrapInErrorHandler(RouteContext routeContext, Processor output) throws Exception {
+    protected Processor wrapInErrorHandler(RouteContext routeContext, ErrorHandlerBuilder builder, Processor output) throws Exception {
         // create error handler
-        ErrorHandlerBuilder builder = getErrorHandlerBuilder();
         Processor errorHandler = builder.createErrorHandler(routeContext, output);
 
         // invoke lifecycles so we can manage this error handler builder
@@ -215,6 +214,8 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition> exte
         return errorHandler;
     }
 
+
+
     /**
      * Adds the given list of interceptors to the channel.
      *
diff --git a/camel-core/src/main/java/org/apache/camel/model/ThreadsDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ThreadsDefinition.java
index 47b6c42aaca..95cb017c074 100644
--- a/camel-core/src/main/java/org/apache/camel/model/ThreadsDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/ThreadsDefinition.java
@@ -59,7 +59,7 @@ public class ThreadsDefinition extends OutputDefinition<ProcessorDefinition> {
         Processor childProcessor = routeContext.createProcessor(this);
 
         // wrap it in a unit of work so the route that comes next is also done in a unit of work
-        UnitOfWorkProcessor uow = new UnitOfWorkProcessor(childProcessor);
+        UnitOfWorkProcessor uow = new UnitOfWorkProcessor(routeContext, childProcessor);
 
         return new ThreadsProcessor(uow, executorService, waitForTaskToComplete);
     }
diff --git a/camel-core/src/main/java/org/apache/camel/model/ToDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ToDefinition.java
index 9315951f10b..2ecae8d2201 100644
--- a/camel-core/src/main/java/org/apache/camel/model/ToDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/ToDefinition.java
@@ -98,7 +98,7 @@ public class ToDefinition extends SendDefinition<ToDefinition> {
         Processor childProcessor = routeContext.createProcessor(this);
 
         // wrap it in a unit of work so the route that comes next is also done in a unit of work
-        UnitOfWorkProcessor uow = new UnitOfWorkProcessor(childProcessor);
+        UnitOfWorkProcessor uow = new UnitOfWorkProcessor(routeContext, childProcessor);
 
         // create async processor
         Endpoint endpoint = resolveEndpoint(routeContext);
diff --git a/camel-core/src/main/java/org/apache/camel/processor/DefaultChannel.java b/camel-core/src/main/java/org/apache/camel/processor/DefaultChannel.java
index 5f2d214ecb8..9e6c17d6327 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/DefaultChannel.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/DefaultChannel.java
@@ -61,6 +61,7 @@ public class DefaultChannel extends ServiceSupport implements Processor, Channel
     private ProcessorDefinition<?> definition;
     private ProcessorDefinition<?> childDefinition;
     private CamelContext camelContext;
+    private RouteContext routeContext;
 
     public List<Processor> next() {
         List<Processor> answer = new ArrayList<Processor>(1);
@@ -128,6 +129,10 @@ public class DefaultChannel extends ServiceSupport implements Processor, Channel
         this.childDefinition = childDefinition;
     }
 
+    public RouteContext getRouteContext() {
+        return routeContext;
+    }
+
     @Override
     protected void doStart() throws Exception {
         ServiceHelper.startServices(errorHandler, output);
@@ -139,6 +144,7 @@ public class DefaultChannel extends ServiceSupport implements Processor, Channel
     }
 
     public void initChannel(ProcessorDefinition<?> outputDefinition, RouteContext routeContext) throws Exception {
+        this.routeContext = routeContext;
         this.definition = outputDefinition;
         this.camelContext = routeContext.getCamelContext();
 
@@ -201,6 +207,11 @@ public class DefaultChannel extends ServiceSupport implements Processor, Channel
     }
 
     public void process(Exchange exchange) throws Exception {
+        if (exchange.getUnitOfWork() != null) {
+            // keep route context up to date
+            exchange.getUnitOfWork().setRouteContext(routeContext);
+        }
+
         Processor processor = getOutput();
         if (processor != null && continueProcessing(exchange)) {
             processor.process(exchange);
diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java
index 654b08a4a81..0ac34b67e59 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java
@@ -30,12 +30,15 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.camel.CamelExchangeException;
+import org.apache.camel.Channel;
 import org.apache.camel.Exchange;
 import org.apache.camel.Navigate;
 import org.apache.camel.Processor;
 import org.apache.camel.Producer;
+import org.apache.camel.builder.ErrorHandlerBuilder;
 import org.apache.camel.impl.ServiceSupport;
 import org.apache.camel.processor.aggregate.AggregationStrategy;
+import org.apache.camel.spi.RouteContext;
 import org.apache.camel.spi.TracedRouteNodes;
 import org.apache.camel.util.ExchangeHelper;
 import org.apache.camel.util.ServiceHelper;
@@ -80,12 +83,13 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
         }
     }
 
-    private final Collection<Processor> processors;
+    private Collection<Processor> processors;
     private final AggregationStrategy aggregationStrategy;
     private final boolean isParallelProcessing;
     private final boolean streaming;
     private final boolean stopOnException;
     private ExecutorService executorService;
+    private Channel channel;
 
     public MulticastProcessor(Collection<Processor> processors) {
         this(processors, null);
@@ -122,18 +126,36 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
         return "multicast";
     }
 
+    public Channel getChannel() {
+        return channel;
+    }
+
+    public void setChannel(Channel channel) {
+        this.channel = channel;
+    }
+
     public void process(Exchange exchange) throws Exception {
         final AtomicExchange result = new AtomicExchange();
         final Iterable<ProcessorExchangePair> pairs = createProcessorExchangePairs(exchange);
 
-        if (isParallelProcessing()) {
-            doProcessParallel(result, pairs, isStreaming());
-        } else {
-            doProcessSequential(result, pairs);
-        }
+        // multicast uses fine grained error handling on the output processors
+        // so use try .. catch to cater for this
+        try {
+            if (isParallelProcessing()) {
+                doProcessParallel(result, pairs, isStreaming());
+            } else {
+                doProcessSequential(result, pairs);
+            }
 
-        if (result.get() != null) {
-            ExchangeHelper.copyResults(exchange, result.get());
+            if (result.get() != null) {
+                ExchangeHelper.copyResults(exchange, result.get());
+            }
+        } catch (Exception e) {
+            // multicast uses error handling on its output processors and they have tried to redeliver
+            // so we shall signal back to the other error handlers that we are exhausted and they should not
+            // also try to redeliver as we will then do that twice
+            exchange.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE);
+            exchange.setException(e);
         }
     }
 
@@ -237,6 +259,19 @@ public class MulticastProcessor extends ServiceSupport implements Processor, Nav
             // set property which endpoint we send to
             setToEndpoint(exchange, producer);
 
+            if (exchange.getUnitOfWork() != null && exchange.getUnitOfWork().getRouteContext() != null) {
+                // wrap the producer in error handler so we have fine grained error handling on
+                // the output side instead of the input side
+                // this is needed to support redelivery on that output alone and not doing redelivery
+                // for the entire multicast block again which will start from scratch again
+                RouteContext routeContext = exchange.getUnitOfWork().getRouteContext();
+                ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder();
+
+                // create error handler (create error handler directly to keep it light weight,
+                // instead of using ProcessorDefinitionHelper.wrapInErrorHandler)
+                producer = builder.createErrorHandler(routeContext, producer);
+            }
+
             // let the producer process it
             producer.process(exchange);
         } catch (Exception e) {
diff --git a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java
index 9aa149afe5d..c5376efda81 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java
@@ -231,7 +231,10 @@ public abstract class RedeliveryErrorHandler extends ErrorHandlerSupport impleme
     protected boolean isDone(Exchange exchange) throws Exception {
         // only done if the exchange hasn't failed
         // and it has not been handled by the failure processor
-        return exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange);
+        // or we are exhausted
+        return exchange.getException() == null
+            || ExchangeHelper.isFailureHandled(exchange)
+            || ExchangeHelper.isRedelieryExhausted(exchange);
     }
 
     /**
diff --git a/camel-core/src/main/java/org/apache/camel/processor/UnitOfWorkProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/UnitOfWorkProcessor.java
index f73fccda964..64718b20568 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/UnitOfWorkProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/UnitOfWorkProcessor.java
@@ -19,6 +19,8 @@ package org.apache.camel.processor;
 import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
 import org.apache.camel.impl.DefaultUnitOfWork;
+import org.apache.camel.spi.RouteContext;
+
 import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
 
 /** 
@@ -27,10 +29,17 @@ import static org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException;
  */
 public final class UnitOfWorkProcessor extends DelegateProcessor {
 
+    private final RouteContext routeContext;
+
     public UnitOfWorkProcessor(Processor processor) {
+        this(null, processor);
+    }
+
+    public UnitOfWorkProcessor(RouteContext routeContext, Processor processor) {
         super(processor);
+        this.routeContext = routeContext;
     }
-    
+
     @Override
     public String toString() {
         return "UnitOfWork(" + processor + ")";
diff --git a/camel-core/src/main/java/org/apache/camel/processor/interceptor/TraceInterceptor.java b/camel-core/src/main/java/org/apache/camel/processor/interceptor/TraceInterceptor.java
index e09ae2e961b..eda70c7cd48 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/interceptor/TraceInterceptor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/interceptor/TraceInterceptor.java
@@ -94,7 +94,6 @@ public class TraceInterceptor extends DelegateProcessor implements ExchangeForma
             return;
         }
 
-
         // interceptor will also trace routes supposed only for TraceEvents so we need to skip
         // logging TraceEvents to avoid infinite looping
         if (exchange.getProperty(Exchange.TRACE_EVENT, Boolean.class) != null) {
diff --git a/camel-core/src/main/java/org/apache/camel/spi/UnitOfWork.java b/camel-core/src/main/java/org/apache/camel/spi/UnitOfWork.java
index 14d6b5c507a..6d25d688fe2 100644
--- a/camel-core/src/main/java/org/apache/camel/spi/UnitOfWork.java
+++ b/camel-core/src/main/java/org/apache/camel/spi/UnitOfWork.java
@@ -110,4 +110,24 @@ public interface UnitOfWork {
      * @param transactionDefinition the transaction definition
      */
     void endTransactedBy(Object transactionDefinition);
+
+    /**
+     * Gets the {@link RouteContext} that this {@link UnitOfWork} currently is being routed through.
+     * <p/>
+     * Notice that an {@link Exchange} can be routed through multiple routes and thus the
+     * {@link org.apache.camel.spi.RouteContext} can change over time.
+     *
+     * @return the route context
+     */
+    RouteContext getRouteContext();
+
+    /**
+     * Gets the {@link RouteContext} that this {@link UnitOfWork} currently is being routed through.
+     * <p/>
+     * Notice that an {@link Exchange} can be routed through multiple routes and thus the
+     * {@link org.apache.camel.spi.RouteContext} can change over time.
+     *
+     * @param routeContext the route context
+     */
+    void setRouteContext(RouteContext routeContext);
 }
diff --git a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java
index 88b62715356..1249ddfbe08 100644
--- a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java
+++ b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java
@@ -426,6 +426,11 @@ public final class ExchangeHelper {
         exchange.setException(null);
     }
 
+    public static boolean isRedelieryExhausted(Exchange exchange) {
+        Boolean exhausted = exchange.getProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.class);
+        return exhausted != null && exhausted;
+    }
+
     /**
      * Extracts the body from the given exchange.
      * <p/>
diff --git a/camel-core/src/test/java/org/apache/camel/issues/CharlesSplitAndTryCatchRollbackIssueTest.java b/camel-core/src/test/java/org/apache/camel/issues/CharlesSplitAndTryCatchRollbackIssueTest.java
index 8be2b4f4037..9fd37b681a9 100644
--- a/camel-core/src/test/java/org/apache/camel/issues/CharlesSplitAndTryCatchRollbackIssueTest.java
+++ b/camel-core/src/test/java/org/apache/camel/issues/CharlesSplitAndTryCatchRollbackIssueTest.java
@@ -72,7 +72,7 @@ public class CharlesSplitAndTryCatchRollbackIssueTest extends ContextTestSupport
             fail("Should thrown an exception");
         } catch (CamelExecutionException e) {
             CamelExchangeException ee = assertIsInstanceOf(CamelExchangeException.class, e.getCause());
-            assertEquals("Sequential processing failed for number 2 on the exchange: Exchange[Message: Kaboom]", ee.getMessage());
+            assertTrue(ee.getMessage().startsWith("Sequential processing failed for number 2 on the exchange: Exchange[Message: Kaboom]"));
             RollbackExchangeException re = assertIsInstanceOf(RollbackExchangeException.class, ee.getCause());
             assertEquals("Intended rollback on the exchange: Exchange[Message: Kaboom]", re.getMessage());
         }
@@ -94,7 +94,7 @@ public class CharlesSplitAndTryCatchRollbackIssueTest extends ContextTestSupport
             fail("Should thrown an exception");
         } catch (CamelExecutionException e) {
             CamelExchangeException ee = assertIsInstanceOf(CamelExchangeException.class, e.getCause());
-            assertEquals("Sequential processing failed for number 3 on the exchange: Exchange[Message: Kaboom]", ee.getMessage());
+            assertTrue(ee.getMessage().startsWith("Sequential processing failed for number 3 on the exchange: Exchange[Message: Kaboom]"));
             RollbackExchangeException re = assertIsInstanceOf(RollbackExchangeException.class, ee.getCause());
             assertEquals("Intended rollback on the exchange: Exchange[Message: Kaboom]", re.getMessage());
         }
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastFineGrainedErrorHandlingTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastFineGrainedErrorHandlingTest.java
index 2c642a803e5..5b63da55c90 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/MulticastFineGrainedErrorHandlingTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastFineGrainedErrorHandlingTest.java
@@ -31,12 +31,14 @@ public class MulticastFineGrainedErrorHandlingTest extends ContextTestSupport {
                 onException(Exception.class).maximumRedeliveries(2);
 
                 from("direct:start")
+                    .to("mock:a")
                     .multicast().stopOnException()
                     .to("mock:foo", "mock:bar", "mock:baz");
             }
         });
         context.start();
 
+        getMockEndpoint("mock:a").expectedMessageCount(1);
         getMockEndpoint("mock:foo").expectedMessageCount(1);
         getMockEndpoint("mock:bar").expectedMessageCount(1);
         getMockEndpoint("mock:baz").expectedMessageCount(1);
@@ -53,12 +55,14 @@ public class MulticastFineGrainedErrorHandlingTest extends ContextTestSupport {
                 onException(Exception.class).maximumRedeliveries(2);
 
                 from("direct:start")
+                    .to("mock:a")
                     .multicast().stopOnException()
                     .to("mock:foo", "mock:bar").throwException(new IllegalArgumentException("Damn")).to("mock:baz");
             }
         });
         context.start();
 
+        getMockEndpoint("mock:a").expectedMessageCount(1);
         getMockEndpoint("mock:foo").expectedMessageCount(1);
         getMockEndpoint("mock:bar").expectedMessageCount(1);
         getMockEndpoint("mock:baz").expectedMessageCount(0);
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastParallelFineGrainedErrorHandlingTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastParallelFineGrainedErrorHandlingTest.java
new file mode 100644
index 00000000000..b4edf2bd133
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastParallelFineGrainedErrorHandlingTest.java
@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision$
+ */
+public class MulticastParallelFineGrainedErrorHandlingTest extends ContextTestSupport {
+
+    public void testMulticastOk() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .to("mock:a")
+                    .multicast().stopOnException().parallelProcessing()
+                    .to("mock:foo", "mock:bar", "mock:baz");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(1);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testMulticastError() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .to("mock:a")
+                    .multicast().stopOnException().parallelProcessing()
+                    .to("mock:foo", "mock:bar").throwException(new IllegalArgumentException("Damn")).to("mock:baz");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(1);
+
+        try {
+            template.sendBody("direct:start", "Hello World");
+            fail("Should throw exception");
+        } catch (Exception e) {
+            // expected
+        }
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastParallelStopOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastParallelStopOnExceptionTest.java
index f048c28c0d2..130c0ccbdb6 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/MulticastParallelStopOnExceptionTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastParallelStopOnExceptionTest.java
@@ -57,7 +57,7 @@ public class MulticastParallelStopOnExceptionTest extends ContextTestSupport {
             ExecutionException ee = assertIsInstanceOf(ExecutionException.class, e.getCause());
             CamelExchangeException cause = assertIsInstanceOf(CamelExchangeException.class, ee.getCause());
             assertTrue(cause.getMessage().startsWith("Parallel processing failed for number "));
-            assertTrue(cause.getMessage().endsWith("on the exchange: Exchange[Message: Kaboom]"));
+            assertTrue(cause.getMessage().contains("on the exchange: Exchange[Message: Kaboom]"));
             assertEquals("Forced", cause.getCause().getMessage());
         }
 
@@ -96,4 +96,4 @@ public class MulticastParallelStopOnExceptionTest extends ContextTestSupport {
             }
         };
     }
-}
\ No newline at end of file
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionTest.java
index e131898abbd..cb48f9c0833 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastStopOnExceptionTest.java
@@ -51,7 +51,7 @@ public class MulticastStopOnExceptionTest extends ContextTestSupport {
             fail("Should thrown an exception");
         } catch (CamelExecutionException e) {
             CamelExchangeException cause = assertIsInstanceOf(CamelExchangeException.class, e.getCause());
-            assertEquals("Sequential processing failed for number 1 on the exchange: Exchange[Message: Kaboom]", cause.getMessage());
+            assertTrue(cause.getMessage().startsWith("Sequential processing failed for number 1 on the exchange: Exchange[Message: Kaboom]"));
             assertEquals("Forced", cause.getCause().getMessage());
         }
 
@@ -87,4 +87,4 @@ public class MulticastStopOnExceptionTest extends ContextTestSupport {
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/RecipientListFineGrainedErrorHandlingTest.java b/camel-core/src/test/java/org/apache/camel/processor/RecipientListFineGrainedErrorHandlingTest.java
new file mode 100644
index 00000000000..87fc19b06b3
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/RecipientListFineGrainedErrorHandlingTest.java
@@ -0,0 +1,153 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.CamelExchangeException;
+import org.apache.camel.CamelExecutionException;
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.impl.JndiRegistry;
+
+/**
+ * @version $Revision$
+ */
+public class RecipientListFineGrainedErrorHandlingTest extends ContextTestSupport {
+
+    private static int counter;
+
+    @Override
+    protected JndiRegistry createRegistry() throws Exception {
+        JndiRegistry jndi = super.createRegistry();
+        jndi.bind("fail", new MyFailBean());
+        return jndi;
+    }
+
+    public void testRecipientListOk() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .to("mock:a")
+                    .recipientList(header("foo")).stopOnException();
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(1);
+
+        template.sendBodyAndHeader("direct:start", "Hello World", "foo", "mock:foo,mock:bar,mock:baz");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testRecipientListError() throws Exception {
+        counter = 0;
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .to("mock:a")
+                    .recipientList(header("foo")).stopOnException();
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(0);
+
+        try {
+            template.sendBodyAndHeader("direct:start", "Hello World", "foo", "mock:foo,mock:bar,bean:fail,mock:baz");
+            fail("Should throw exception");
+        } catch (Exception e) {
+            // expected
+        }
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals(3, counter);
+    }
+
+    public void testRecipientListAsBeanError() throws Exception {
+        counter = 0;
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                context.setTracing(true);
+
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .to("mock:a")
+                    .bean(MyRecipientBean.class);
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(0);
+
+        try {
+            template.sendBody("direct:start", "Hello World");
+            fail("Should throw exception");
+        } catch (CamelExecutionException e) {
+            // expected
+            assertIsInstanceOf(CamelExchangeException.class, e.getCause());
+            assertIsInstanceOf(IllegalArgumentException.class, e.getCause().getCause());
+            assertEquals("Damn", e.getCause().getCause().getMessage());
+        }
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals(3, counter);
+    }
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+
+    public static class MyRecipientBean {
+
+        @org.apache.camel.RecipientList(stopOnException = true)
+        public String sendSomewhere(Exchange exchange) {
+            return "mock:foo,mock:bar,bean:fail,mock:baz";
+        }
+    }
+
+    public static class MyFailBean {
+
+        public String doSomething(Exchange exchange) throws Exception {
+            counter++;
+            assertEquals("bean://fail", exchange.getProperty(Exchange.TO_ENDPOINT, String.class));
+            throw new IllegalArgumentException("Damn");
+        }
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/RecipientListParallelFineGrainedErrorHandlingTest.java b/camel-core/src/test/java/org/apache/camel/processor/RecipientListParallelFineGrainedErrorHandlingTest.java
new file mode 100644
index 00000000000..661ebfd73a6
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/RecipientListParallelFineGrainedErrorHandlingTest.java
@@ -0,0 +1,156 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import java.util.concurrent.ExecutionException;
+
+import org.apache.camel.CamelExchangeException;
+import org.apache.camel.CamelExecutionException;
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.impl.JndiRegistry;
+
+/**
+ * @version $Revision$
+ */
+public class RecipientListParallelFineGrainedErrorHandlingTest extends ContextTestSupport {
+
+    private static int counter;
+
+    @Override
+    protected JndiRegistry createRegistry() throws Exception {
+        JndiRegistry jndi = super.createRegistry();
+        jndi.bind("fail", new MyFailBean());
+        return jndi;
+    }
+
+    public void testRecipientListOk() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .to("mock:a")
+                    .recipientList(header("foo")).stopOnException().parallelProcessing();
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(1);
+
+        template.sendBodyAndHeader("direct:start", "Hello World", "foo", "mock:foo,mock:bar,mock:baz");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testRecipientListError() throws Exception {
+        counter = 0;
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .to("mock:a")
+                    .recipientList(header("foo")).stopOnException().parallelProcessing();
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(1);
+
+        try {
+            template.sendBodyAndHeader("direct:start", "Hello World", "foo", "mock:foo,mock:bar,bean:fail,mock:baz");
+            fail("Should throw exception");
+        } catch (Exception e) {
+            // expected
+        }
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals(3, counter);
+    }
+
+    public void testRecipientListAsBeanError() throws Exception {
+        counter = 0;
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                context.setTracing(true);
+
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .to("mock:a")
+                    .bean(MyRecipientBean.class);
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:a").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(1);
+
+        try {
+            template.sendBody("direct:start", "Hello World");
+            fail("Should throw exception");
+        } catch (CamelExecutionException e) {
+            // expected
+            assertIsInstanceOf(ExecutionException.class, e.getCause());
+            assertIsInstanceOf(CamelExchangeException.class, e.getCause().getCause());
+            assertIsInstanceOf(IllegalArgumentException.class, e.getCause().getCause().getCause());
+            assertEquals("Damn", e.getCause().getCause().getCause().getMessage());
+        }
+
+        assertMockEndpointsSatisfied();
+
+        assertEquals(3, counter);
+    }
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+
+    public static class MyRecipientBean {
+
+        @org.apache.camel.RecipientList(stopOnException = true, parallelProcessoing = true)
+        public String sendSomewhere(Exchange exchange) {
+            return "mock:foo,mock:bar,bean:fail,mock:baz";
+        }
+    }
+
+    public static class MyFailBean {
+
+        public String doSomething(Exchange exchange) throws Exception {
+            counter++;
+            assertEquals("bean://fail", exchange.getProperty(Exchange.TO_ENDPOINT, String.class));
+            throw new IllegalArgumentException("Damn");
+        }
+    }
+}
\ No newline at end of file
diff --git a/camel-core/src/test/java/org/apache/camel/processor/SplitterParallelStopOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/SplitterParallelStopOnExceptionTest.java
index d66b414e392..344720ecd74 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/SplitterParallelStopOnExceptionTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/SplitterParallelStopOnExceptionTest.java
@@ -53,7 +53,7 @@ public class SplitterParallelStopOnExceptionTest extends ContextTestSupport {
             ExecutionException ee = assertIsInstanceOf(ExecutionException.class, e.getCause());
             CamelExchangeException cause = assertIsInstanceOf(CamelExchangeException.class, ee.getCause());
             assertTrue(cause.getMessage().startsWith("Parallel processing failed for number "));
-            assertTrue(cause.getMessage().endsWith("on the exchange: Exchange[Message: Kaboom]"));
+            assertTrue(cause.getMessage().contains("on the exchange: Exchange[Message: Kaboom]"));
             assertEquals("Forced", cause.getCause().getMessage());
         }
 
diff --git a/camel-core/src/test/java/org/apache/camel/processor/SplitterStopOnExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/SplitterStopOnExceptionTest.java
index d78b6dc36eb..e1f41ecea4b 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/SplitterStopOnExceptionTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/SplitterStopOnExceptionTest.java
@@ -48,7 +48,7 @@ public class SplitterStopOnExceptionTest extends ContextTestSupport {
             fail("Should thrown an exception");
         } catch (CamelExecutionException e) {
             CamelExchangeException cause = assertIsInstanceOf(CamelExchangeException.class, e.getCause());
-            assertEquals("Sequential processing failed for number 1 on the exchange: Exchange[Message: Kaboom]", cause.getMessage());
+            assertTrue(cause.getMessage().startsWith("Sequential processing failed for number 1 on the exchange: Exchange[Message: Kaboom]"));
             assertEquals("Forced", cause.getCause().getMessage());
         }
 
