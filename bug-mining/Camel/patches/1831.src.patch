diff --git a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java
index 717a6d39063..10ae4aa581c 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java
@@ -712,9 +712,12 @@ public abstract class RedeliveryErrorHandler extends ErrorHandlerSupport impleme
         // clear exception as we let the failure processor handle it
         exchange.setException(null);
 
-        boolean handled = false;
+        final boolean shouldHandle = shouldHandled(exchange, data);
+        final boolean shouldContinue = shouldContinue(exchange, data);
         // regard both handled or continued as being handled
-        if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) {
+        boolean handled = false;
+
+        if (shouldHandle || shouldContinue) {
             // its handled then remove traces of redelivery attempted
             exchange.getIn().removeHeader(Exchange.REDELIVERED);
             exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);
@@ -759,7 +762,7 @@ public abstract class RedeliveryErrorHandler extends ErrorHandlerSupport impleme
                 public void done(boolean sync) {
                     log.trace("Failure processor done: {} processing Exchange: {}", processor, exchange);
                     try {
-                        prepareExchangeAfterFailure(exchange, data);
+                        prepareExchangeAfterFailure(exchange, data, shouldHandle, shouldContinue);
                         // fire event as we had a failure processor to handle it, which there is a event for
                         boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;
                         EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);
@@ -773,7 +776,7 @@ public abstract class RedeliveryErrorHandler extends ErrorHandlerSupport impleme
         } else {
             try {
                 // no processor but we need to prepare after failure as well
-                prepareExchangeAfterFailure(exchange, data);
+                prepareExchangeAfterFailure(exchange, data, shouldHandle, shouldContinue);
             } finally {
                 // callback we are done
                 callback.done(data.sync);
@@ -793,7 +796,8 @@ public abstract class RedeliveryErrorHandler extends ErrorHandlerSupport impleme
         return sync;
     }
 
-    protected void prepareExchangeAfterFailure(final Exchange exchange, final RedeliveryData data) {
+    protected void prepareExchangeAfterFailure(final Exchange exchange, final RedeliveryData data,
+                                               final boolean shouldHandle, final boolean shouldContinue) {
         // we could not process the exchange so we let the failure processor handled it
         ExchangeHelper.setFailureHandled(exchange);
 
@@ -813,10 +817,10 @@ public abstract class RedeliveryErrorHandler extends ErrorHandlerSupport impleme
             return;
         }
 
-        if (shouldHandled(exchange, data)) {
+        if (shouldHandle) {
             log.trace("This exchange is handled so its marked as not failed: {}", exchange);
             exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.TRUE);
-        } else if (shouldContinue(exchange, data)) {
+        } else if (shouldContinue) {
             log.trace("This exchange is continued: {}", exchange);
             // okay we want to continue then prepare the exchange for that as well
             prepareExchangeForContinue(exchange, data);
diff --git a/camel-core/src/test/java/org/apache/camel/processor/onexception/OnExceptionContinuePredicateTest.java b/camel-core/src/test/java/org/apache/camel/processor/onexception/OnExceptionContinuePredicateTest.java
new file mode 100644
index 00000000000..a66398a6ca5
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/onexception/OnExceptionContinuePredicateTest.java
@@ -0,0 +1,76 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.onexception;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Predicate;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version 
+ */
+public class OnExceptionContinuePredicateTest extends OnExceptionContinueTest {
+
+    private final AtomicInteger predicateInvoked = new AtomicInteger();
+    private final AtomicInteger processorInvoked = new AtomicInteger();
+
+    @Override
+    public void testContinued() throws Exception {
+        getMockEndpoint("mock:me").expectedMessageCount(1);
+
+        super.testContinued();
+
+        assertEquals(1, predicateInvoked.get());
+        assertEquals(1, processorInvoked.get());
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // use a predicate instance
+                Predicate predicate = new Predicate() {
+                    @Override
+                    public boolean matches(Exchange exchange) {
+                        predicateInvoked.incrementAndGet();
+                        return true;
+                    }
+                };
+
+                // tell Camel to handle and continue when this exception is thrown
+                onException(IllegalArgumentException.class)
+                    .continued(predicate)
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            processorInvoked.incrementAndGet();
+                        }
+                    })
+                    .to("mock:me");
+
+                from("direct:start")
+                    .to("mock:start")
+                    .throwException(new IllegalArgumentException("Forced"))
+                    .to("mock:result");
+            }
+        };
+    }
+}
\ No newline at end of file
diff --git a/camel-core/src/test/java/org/apache/camel/processor/onexception/OnExceptionContinueTwoPredicateTest.java b/camel-core/src/test/java/org/apache/camel/processor/onexception/OnExceptionContinueTwoPredicateTest.java
new file mode 100644
index 00000000000..3ba19f63689
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/onexception/OnExceptionContinueTwoPredicateTest.java
@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.onexception;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Predicate;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version
+ */
+public class OnExceptionContinueTwoPredicateTest extends OnExceptionContinueTwoTest {
+
+    private final AtomicInteger predicateInvoked = new AtomicInteger();
+    private final AtomicInteger processorInvoked = new AtomicInteger();
+
+    @Override
+    public void testContinuedTwo() throws Exception {
+        getMockEndpoint("mock:me").expectedMessageCount(2);
+
+        super.testContinuedTwo();
+
+        assertEquals(2, predicateInvoked.get());
+        assertEquals(2, processorInvoked.get());
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                // use a predicate instance
+                Predicate predicate = new Predicate() {
+                    @Override
+                    public boolean matches(Exchange exchange) {
+                        predicateInvoked.incrementAndGet();
+                        return true;
+                    }
+                };
+
+                // tell Camel to handle and continue when this exception is thrown
+                onException(IllegalArgumentException.class)
+                    .continued(predicate)
+                    .process(new Processor() {
+                        @Override
+                        public void process(Exchange exchange) throws Exception {
+                            processorInvoked.incrementAndGet();
+                        }
+                    })
+                    .to("mock:me");
+
+                from("direct:start")
+                        .to("mock:start")
+                        .throwException(new IllegalArgumentException("Forced"))
+                        .to("mock:middle")
+                                //throw a second time to validate that the exchange is reset appropriately
+                        .throwException(new IllegalArgumentException("Forced Again"))
+                        .to("mock:result");
+            }
+        };
+    }
+}
\ No newline at end of file
