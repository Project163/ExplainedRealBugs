diff --git a/core/camel-core/src/test/java/org/apache/camel/builder/ExpressionBuilderConcurrencyTest.java b/core/camel-core/src/test/java/org/apache/camel/builder/ExpressionBuilderConcurrencyTest.java
new file mode 100644
index 00000000000..f800d19705d
--- /dev/null
+++ b/core/camel-core/src/test/java/org/apache/camel/builder/ExpressionBuilderConcurrencyTest.java
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.builder;
+
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.model.language.SimpleExpression;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+public class ExpressionBuilderConcurrencyTest extends ContextTestSupport {
+
+    @Test
+    public void testConcatExpressionConcurrency() throws Exception {
+        MockEndpoint mockWithFailure = getMockEndpoint("mock:result");
+        mockWithFailure.expectedMinimumMessageCount(100);
+        mockWithFailure.assertIsSatisfied();
+        List<Exchange> exchanges = mockWithFailure.getExchanges();
+        exchanges.stream()
+                .forEach(exchange -> Assertions
+                        .assertEquals(
+                                "This is a test a with startLabel: `Document` endLabel: `Document` and label: `ALabel`",
+                                exchange.getMessage().getHeader("#CustomHeader", String.class)));
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+
+        return new RouteBuilder() {
+            Map body = Map.of("label", "ALabel", "startLabel", "Document", "endLabel", "Document");
+            String simpleTemplate
+                    = "This is a test a with startLabel: `${body.get('startLabel')}` endLabel: `${body.get('endLabel')}` and label: `${body.get('label')}`";
+
+            @Override
+            public void configure() throws Exception {
+
+                from("timer://test-timer3?fixedRate=true&period=10&delay=1")
+                        .process(new Processor() {
+                            @Override
+                            public void process(Exchange exchange) throws Exception {
+                                exchange.getMessage().setBody(body);
+                                exchange.getMessage().setHeader("#CustomHeader", resolveTemplate(simpleTemplate, exchange));
+                            }
+                        })
+                        .to("mock:result");
+
+                from("timer://test-timer4?fixedRate=true&period=10&delay=1")
+
+                        .process(new Processor() {
+                            @Override
+                            public void process(Exchange exchange) throws Exception {
+                                exchange.getMessage().setBody(body);
+                                exchange.getMessage().setHeader("#CustomHeader", resolveTemplate(simpleTemplate, exchange));
+                            }
+                        })
+                        .to("mock:result");
+
+                from("timer://test-timer5?fixedRate=true&period=10&delay=1")
+                        .process(new Processor() {
+                            @Override
+                            public void process(Exchange exchange) throws Exception {
+                                exchange.getMessage().setBody(body);
+                                exchange.getMessage().setHeader("#CustomHeader", resolveTemplate(simpleTemplate, exchange));
+                            }
+                        })
+                        .to("mock:result");
+            }
+
+        };
+    }
+
+    public String resolveTemplate(String template, Exchange exchange) {
+        var simpleExpression = new SimpleExpression();
+        simpleExpression.setExpression(template);
+        return simpleExpression.evaluate(exchange, String.class);
+    }
+
+}
\ No newline at end of file
diff --git a/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java b/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java
index 73b4b20cea3..312dfbf6aee 100644
--- a/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java
+++ b/core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java
@@ -20,6 +20,7 @@ import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
@@ -1640,32 +1641,83 @@ public class ExpressionBuilder {
      * @return an expression which when evaluated will return the concatenated values
      */
     public static Expression concatExpression(final Collection<Expression> expressions, final String description) {
-        return new ExpressionAdapter() {
+        for (Expression expression : expressions) {
+            if(expression instanceof ConstantExpressionAdapter){
+                return concatExpressionOptimized(expressions, description);
+            }
+        }
 
-            private Collection<Object> col;
+        return concatExpressionUnoptimized(expressions,description);
+    }
+
+    /**
+     * Returns an expression which returns the string concatenation value of the various
+     * expressions
+     *
+     * @param expressions the expression to be concatenated dynamically
+     * @param description the text description of the expression
+     * @return an expression which when evaluated will return the concatenated values
+     */
+    private static Expression concatExpressionUnoptimized(final Collection<Expression> expressions, final String description) {
+        return new ExpressionAdapter() {
 
             @Override
             public Object evaluate(Exchange exchange) {
                 StringBuilder buffer = new StringBuilder();
-                if (col != null) {
-                    // optimize for constant expressions so we can do this a bit faster
-                    for (Object obj : col) {
-                        if (obj instanceof Expression) {
-                            Expression expression = (Expression) obj;
-                            String text = expression.evaluate(exchange, String.class);
-                            if (text != null) {
-                                buffer.append(text);
-                            }
-                        } else {
-                            buffer.append((String) obj);
-                        }
+                for (Expression expression : expressions) {
+                    String text = expression.evaluate(exchange, String.class);
+                    if (text != null) {
+                        buffer.append(text);
                     }
+                }
+                return buffer.toString();
+            }
+
+            @Override
+            public void init(CamelContext context) {
+                for (Expression expression : expressions) {
+                    expression.init(context);
+                }
+            }
+
+            @Override
+            public String toString() {
+                if (description != null) {
+                    return description;
                 } else {
-                    for (Expression expression : expressions) {
+                    return "concat(" + expressions + ")";
+                }
+            }
+        };
+    }
+
+    /**
+     * Returns an optimized expression which returns the string concatenation value of the various.
+     * expressions
+     *
+     * @param expressions the expression to be concatenated dynamically
+     * @param description the text description of the expression
+     * @return an expression which when evaluated will return the concatenated values
+     */
+    private static Expression concatExpressionOptimized(final Collection<Expression> expressions, final String description) {
+
+
+        return new ExpressionAdapter() {
+
+            private Collection<Object> col;
+
+            @Override
+            public Object evaluate(Exchange exchange) {
+                StringBuilder buffer = new StringBuilder();
+                for (Object obj : col) {
+                    if (obj instanceof Expression) {
+                        Expression expression = (Expression) obj;
                         String text = expression.evaluate(exchange, String.class);
                         if (text != null) {
                             buffer.append(text);
                         }
+                    } else {
+                        buffer.append((String) obj);
                     }
                 }
                 return buffer.toString();
@@ -1673,26 +1725,25 @@ public class ExpressionBuilder {
 
             @Override
             public void init(CamelContext context) {
-                boolean constant = false;
-                for (Expression expression : expressions) {
-                    expression.init(context);
-                    constant |= expression instanceof ConstantExpressionAdapter;
-                }
-                if (constant) {
-                    // okay some of the expressions are constant so we can optimize and avoid
-                    // evaluate them but use their constant value as-is directly
-                    // this can be common with the simple language where you use it for templating
-                    // by mixing string text and simple functions together (or via the log EIP)
-                    col = new ArrayList<>(expressions.size());
+                if(col == null) {
+                    Collection<Object> preprocessedExpression = new ArrayList<>(expressions.size());
                     for (Expression expression : expressions) {
+                        expression.init(context);
                         if (expression instanceof ConstantExpressionAdapter) {
                             Object value = ((ConstantExpressionAdapter) expression).getValue();
-                            col.add(value.toString());
+                            preprocessedExpression.add(value.toString());
                         } else {
-                            col.add(expression);
+                            preprocessedExpression.add(expression);
                         }
                     }
+                    col = Collections.unmodifiableCollection(preprocessedExpression);
+                }
+                else{
+                    for (Expression expression : expressions) {
+                        expression.init(context);
+                    }
                 }
+
             }
 
             @Override
@@ -1706,6 +1757,7 @@ public class ExpressionBuilder {
         };
     }
 
+
     /**
      * Returns an Expression for the inbound message id
      */
