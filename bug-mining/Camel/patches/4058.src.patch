diff --git a/camel-core/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java
index 7135400eea4..6511eff04fc 100644
--- a/camel-core/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java
+++ b/camel-core/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java
@@ -913,97 +913,117 @@ public abstract class AbstractCamelCatalog {
             }
         }
 
-        
+        // do we have all the options the original syntax needs (easy way)
+        String[] keys = syntaxKeys(originalSyntax);
+        boolean hasAllKeys = properties.keySet().containsAll(Arrays.asList(keys));
 
-        // the tokens between the options in the path
-        String[] oldTokens = syntax.split("\\w+");
-        String[] tokens = syntaxTokens(syntax);
-
-        // parse the syntax into each options
-        Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);
-        List<String> options = new ArrayList<String>();
-        while (matcher.find()) {
-            String s = matcher.group(1);
-            options.add(s);
-        }
-
-        // need to preserve {{ and }} from the syntax
-        // (we need to use words only as its provisional placeholders)
-        syntax = syntax.replaceAll("\\{\\{", "BEGINCAMELPLACEHOLDER");
-        syntax = syntax.replaceAll("\\}\\}", "ENDCAMELPLACEHOLDER");
-
-        // parse the syntax into each options
-        Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);
-        List<String> options2 = new ArrayList<String>();
-        while (matcher2.find()) {
-            String s = matcher2.group(1);
-            s = s.replaceAll("BEGINCAMELPLACEHOLDER", "\\{\\{");
-            s = s.replaceAll("ENDCAMELPLACEHOLDER", "\\}\\}");
-            options2.add(s);
-        }
-
-        // build the endpoint
+        // build endpoint uri
         StringBuilder sb = new StringBuilder();
         sb.append(scheme);
         sb.append(":");
 
-        int range = 0;
-        boolean first = true;
-        boolean hasQuestionmark = false;
-        for (int i = 0; i < options.size(); i++) {
-            String key = options.get(i);
-            String key2 = options2.get(i);
-            String token = null;
-            if (tokens.length > i) {
-                token = tokens[i];
+        if (hasAllKeys) {
+            // we have all the keys for the syntax so we can build the uri the easy way
+            sb.append(syntax);
+
+            if (!copy.isEmpty()) {
+                boolean hasQuestionmark = sb.toString().contains("?");
+                // the last option may already contain a ? char, if so we should use & instead of ?
+                sb.append(hasQuestionmark ? ampersand : '?');
+                String query = createQueryString(copy, ampersand, encode);
+                sb.append(query);
+            }
+        } else {
+            // TODO: revisit this and see if we can do this in another way
+            // oh darn some options is missing, so we need a complex way of building the uri
+
+            // the tokens between the options in the path
+            String[] tokens = syntax.split("\\w+");
+
+            // parse the syntax into each options
+            Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);
+            List<String> options = new ArrayList<String>();
+            while (matcher.find()) {
+                String s = matcher.group(1);
+                options.add(s);
+            }
+
+            // need to preserve {{ and }} from the syntax
+            // (we need to use words only as its provisional placeholders)
+            syntax = syntax.replaceAll("\\{\\{", "BEGINCAMELPLACEHOLDER");
+            syntax = syntax.replaceAll("\\}\\}", "ENDCAMELPLACEHOLDER");
+
+            // parse the syntax into each options
+            Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);
+            List<String> options2 = new ArrayList<String>();
+            while (matcher2.find()) {
+                String s = matcher2.group(1);
+                s = s.replaceAll("BEGINCAMELPLACEHOLDER", "\\{\\{");
+                s = s.replaceAll("ENDCAMELPLACEHOLDER", "\\}\\}");
+                options2.add(s);
             }
 
-            boolean contains = properties.containsKey(key);
-            if (!contains) {
-                // if the key are similar we have no explicit value and can try to find a default value if the option is required
-                if (isPropertyRequired(rows, key)) {
-                    String value = getPropertyDefaultValue(rows, key);
-                    if (value != null) {
-                        properties.put(key, value);
-                        key2 = value;
+            // build the endpoint
+            int range = 0;
+            boolean first = true;
+            boolean hasQuestionmark = false;
+            for (int i = 0; i < options.size(); i++) {
+                String key = options.get(i);
+                String key2 = options2.get(i);
+                String token = null;
+                if (tokens.length > i) {
+                    token = tokens[i];
+                }
+
+                boolean contains = properties.containsKey(key);
+                if (!contains) {
+                    // if the key are similar we have no explicit value and can try to find a default value if the option is required
+                    if (isPropertyRequired(rows, key)) {
+                        String value = getPropertyDefaultValue(rows, key);
+                        if (value != null) {
+                            properties.put(key, value);
+                            key2 = value;
+                        }
                     }
                 }
-            }
 
-            // was the option provided?
-            if (properties.containsKey(key)) {
-                if (!first && token != null) {
-                    sb.append(token);
+                // was the option provided?
+                if (properties.containsKey(key)) {
+                    if (!first && token != null) {
+                        sb.append(token);
+                    }
+                    hasQuestionmark |= key.contains("?") || (token != null && token.contains("?"));
+                    sb.append(key2);
+                    first = false;
                 }
-                hasQuestionmark |= key.contains("?") || (token != null && token.contains("?"));
-                sb.append(key2);
-                first = false;
+                range++;
             }
-            range++;
-        }
-        // append any extra options that was in surplus for the last
-        while (range < options2.size()) {
-            String token = null;
-            if (tokens.length > range) {
-                token = tokens[range];
+            // append any extra options that was in surplus for the last
+            while (range < options2.size()) {
+                String token = null;
+                if (tokens.length > range) {
+                    token = tokens[range];
+                }
+                String key2 = options2.get(range);
+                sb.append(token);
+                sb.append(key2);
+                hasQuestionmark |= key2.contains("?") || (token != null && token.contains("?"));
+                range++;
             }
-            String key2 = options2.get(range);
-            sb.append(token);
-            sb.append(key2);
-            hasQuestionmark |= key2.contains("?") || (token != null && token.contains("?"));
-            range++;
-        }
 
-        if (!copy.isEmpty()) {
-            // the last option may already contain a ? char, if so we should use & instead of ?
-            sb.append(hasQuestionmark ? ampersand : '?');
-            String query = createQueryString(copy, ampersand, encode);
-            sb.append(query);
+
+            if (!copy.isEmpty()) {
+                // the last option may already contain a ? char, if so we should use & instead of ?
+                sb.append(hasQuestionmark ? ampersand : '?');
+                String query = createQueryString(copy, ampersand, encode);
+                sb.append(query);
+            }
         }
 
         return sb.toString();
     }
 
+    @Deprecated
     private static String[] syntaxTokens(String syntax) {
         // build tokens between the words
         List<String> tokens = new ArrayList<>();
@@ -1031,6 +1051,31 @@ public abstract class AbstractCamelCatalog {
         return tokens.toArray(new String[tokens.size()]);
     }
 
+    private static String[] syntaxKeys(String syntax) {
+        // build tokens between the separators
+        List<String> tokens = new ArrayList<>();
+
+        String current = "";
+        for (int i = 0; i < syntax.length(); i++) {
+            char ch = syntax.charAt(i);
+            if (Character.isLetterOrDigit(ch)) {
+                current += ch;
+            } else {
+                // reset for new current tokens
+                if (current.length() > 0) {
+                    tokens.add(current);
+                    current = "";
+                }
+            }
+        }
+        // anything left over?
+        if (current.length() > 0) {
+            tokens.add(current);
+        }
+
+        return tokens.toArray(new String[tokens.size()]);
+    }
+
     public SimpleValidationResult validateSimpleExpression(String simple) {
         return doValidateSimple(null, simple, false);
     }
diff --git a/platforms/camel-catalog/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java b/platforms/camel-catalog/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java
index 7fd25c859a6..6511eff04fc 100644
--- a/platforms/camel-catalog/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java
+++ b/platforms/camel-catalog/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java
@@ -913,92 +913,167 @@ public abstract class AbstractCamelCatalog {
             }
         }
 
-        // the tokens between the options in the path
-        String[] tokens = syntax.split("\\w+");
+        // do we have all the options the original syntax needs (easy way)
+        String[] keys = syntaxKeys(originalSyntax);
+        boolean hasAllKeys = properties.keySet().containsAll(Arrays.asList(keys));
 
-        // parse the syntax into each options
-        Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);
-        List<String> options = new ArrayList<String>();
-        while (matcher.find()) {
-            String s = matcher.group(1);
-            options.add(s);
-        }
-
-        // need to preserve {{ and }} from the syntax
-        // (we need to use words only as its provisional placeholders)
-        syntax = syntax.replaceAll("\\{\\{", "BEGINCAMELPLACEHOLDER");
-        syntax = syntax.replaceAll("\\}\\}", "ENDCAMELPLACEHOLDER");
-
-        // parse the syntax into each options
-        Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);
-        List<String> options2 = new ArrayList<String>();
-        while (matcher2.find()) {
-            String s = matcher2.group(1);
-            s = s.replaceAll("BEGINCAMELPLACEHOLDER", "\\{\\{");
-            s = s.replaceAll("ENDCAMELPLACEHOLDER", "\\}\\}");
-            options2.add(s);
-        }
-
-        // build the endpoint
+        // build endpoint uri
         StringBuilder sb = new StringBuilder();
         sb.append(scheme);
         sb.append(":");
 
-        int range = 0;
-        boolean first = true;
-        boolean hasQuestionmark = false;
-        for (int i = 0; i < options.size(); i++) {
-            String key = options.get(i);
-            String key2 = options2.get(i);
-            String token = null;
-            if (tokens.length > i) {
-                token = tokens[i];
+        if (hasAllKeys) {
+            // we have all the keys for the syntax so we can build the uri the easy way
+            sb.append(syntax);
+
+            if (!copy.isEmpty()) {
+                boolean hasQuestionmark = sb.toString().contains("?");
+                // the last option may already contain a ? char, if so we should use & instead of ?
+                sb.append(hasQuestionmark ? ampersand : '?');
+                String query = createQueryString(copy, ampersand, encode);
+                sb.append(query);
+            }
+        } else {
+            // TODO: revisit this and see if we can do this in another way
+            // oh darn some options is missing, so we need a complex way of building the uri
+
+            // the tokens between the options in the path
+            String[] tokens = syntax.split("\\w+");
+
+            // parse the syntax into each options
+            Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);
+            List<String> options = new ArrayList<String>();
+            while (matcher.find()) {
+                String s = matcher.group(1);
+                options.add(s);
             }
 
-            boolean contains = properties.containsKey(key);
-            if (!contains) {
-                // if the key are similar we have no explicit value and can try to find a default value if the option is required
-                if (isPropertyRequired(rows, key)) {
-                    String value = getPropertyDefaultValue(rows, key);
-                    if (value != null) {
-                        properties.put(key, value);
-                        key2 = value;
+            // need to preserve {{ and }} from the syntax
+            // (we need to use words only as its provisional placeholders)
+            syntax = syntax.replaceAll("\\{\\{", "BEGINCAMELPLACEHOLDER");
+            syntax = syntax.replaceAll("\\}\\}", "ENDCAMELPLACEHOLDER");
+
+            // parse the syntax into each options
+            Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);
+            List<String> options2 = new ArrayList<String>();
+            while (matcher2.find()) {
+                String s = matcher2.group(1);
+                s = s.replaceAll("BEGINCAMELPLACEHOLDER", "\\{\\{");
+                s = s.replaceAll("ENDCAMELPLACEHOLDER", "\\}\\}");
+                options2.add(s);
+            }
+
+            // build the endpoint
+            int range = 0;
+            boolean first = true;
+            boolean hasQuestionmark = false;
+            for (int i = 0; i < options.size(); i++) {
+                String key = options.get(i);
+                String key2 = options2.get(i);
+                String token = null;
+                if (tokens.length > i) {
+                    token = tokens[i];
+                }
+
+                boolean contains = properties.containsKey(key);
+                if (!contains) {
+                    // if the key are similar we have no explicit value and can try to find a default value if the option is required
+                    if (isPropertyRequired(rows, key)) {
+                        String value = getPropertyDefaultValue(rows, key);
+                        if (value != null) {
+                            properties.put(key, value);
+                            key2 = value;
+                        }
                     }
                 }
-            }
 
-            // was the option provided?
-            if (properties.containsKey(key)) {
-                if (!first && token != null) {
-                    sb.append(token);
+                // was the option provided?
+                if (properties.containsKey(key)) {
+                    if (!first && token != null) {
+                        sb.append(token);
+                    }
+                    hasQuestionmark |= key.contains("?") || (token != null && token.contains("?"));
+                    sb.append(key2);
+                    first = false;
+                }
+                range++;
+            }
+            // append any extra options that was in surplus for the last
+            while (range < options2.size()) {
+                String token = null;
+                if (tokens.length > range) {
+                    token = tokens[range];
                 }
-                hasQuestionmark |= key.contains("?") || (token != null && token.contains("?"));
+                String key2 = options2.get(range);
+                sb.append(token);
                 sb.append(key2);
-                first = false;
+                hasQuestionmark |= key2.contains("?") || (token != null && token.contains("?"));
+                range++;
+            }
+
+
+            if (!copy.isEmpty()) {
+                // the last option may already contain a ? char, if so we should use & instead of ?
+                sb.append(hasQuestionmark ? ampersand : '?');
+                String query = createQueryString(copy, ampersand, encode);
+                sb.append(query);
             }
-            range++;
         }
-        // append any extra options that was in surplus for the last
-        while (range < options2.size()) {
-            String token = null;
-            if (tokens.length > range) {
-                token = tokens[range];
+
+        return sb.toString();
+    }
+
+    @Deprecated
+    private static String[] syntaxTokens(String syntax) {
+        // build tokens between the words
+        List<String> tokens = new ArrayList<>();
+        // preserve backwards behavior which had an empty token first
+        tokens.add("");
+
+        String current = "";
+        for (int i = 0; i < syntax.length(); i++) {
+            char ch = syntax.charAt(i);
+            if (Character.isLetterOrDigit(ch)) {
+                // reset for new current tokens
+                if (current.length() > 0) {
+                    tokens.add(current);
+                    current = "";
+                }
+            } else {
+                current += ch;
             }
-            String key2 = options2.get(range);
-            sb.append(token);
-            sb.append(key2);
-            hasQuestionmark |= key2.contains("?") || (token != null && token.contains("?"));
-            range++;
         }
+        // anything left over?
+        if (current.length() > 0) {
+            tokens.add(current);
+        }
+
+        return tokens.toArray(new String[tokens.size()]);
+    }
 
-        if (!copy.isEmpty()) {
-            // the last option may already contain a ? char, if so we should use & instead of ?
-            sb.append(hasQuestionmark ? ampersand : '?');
-            String query = createQueryString(copy, ampersand, encode);
-            sb.append(query);
+    private static String[] syntaxKeys(String syntax) {
+        // build tokens between the separators
+        List<String> tokens = new ArrayList<>();
+
+        String current = "";
+        for (int i = 0; i < syntax.length(); i++) {
+            char ch = syntax.charAt(i);
+            if (Character.isLetterOrDigit(ch)) {
+                current += ch;
+            } else {
+                // reset for new current tokens
+                if (current.length() > 0) {
+                    tokens.add(current);
+                    current = "";
+                }
+            }
+        }
+        // anything left over?
+        if (current.length() > 0) {
+            tokens.add(current);
         }
 
-        return sb.toString();
+        return tokens.toArray(new String[tokens.size()]);
     }
 
     public SimpleValidationResult validateSimpleExpression(String simple) {
diff --git a/platforms/camel-catalog/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java b/platforms/camel-catalog/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java
index e992f95975f..9bf09cc8f13 100644
--- a/platforms/camel-catalog/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java
+++ b/platforms/camel-catalog/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java
@@ -17,7 +17,7 @@
 package org.apache.camel.catalog;
 
 /**
- * Pluggable resolver to load JSon schmea files for components, data formats, languages etc.
+ * Pluggable resolver to load JSon schema files for components, data formats, languages etc.
  */
 public interface JSonSchemaResolver {
 
diff --git a/platforms/camel-catalog/src/test/java/org/apache/camel/catalog/CamelCatalogTest.java b/platforms/camel-catalog/src/test/java/org/apache/camel/catalog/CamelCatalogTest.java
index 3494c62ced2..3b9952c4e1c 100644
--- a/platforms/camel-catalog/src/test/java/org/apache/camel/catalog/CamelCatalogTest.java
+++ b/platforms/camel-catalog/src/test/java/org/apache/camel/catalog/CamelCatalogTest.java
@@ -18,6 +18,7 @@ package org.apache.camel.catalog;
 
 import java.io.FileInputStream;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -298,6 +299,17 @@ public class CamelCatalogTest {
         assertEquals("jms:foo?allowNullBody=true&amp;deliveryPersistent=false", uri2);
     }
 
+    @Test
+    public void testAsEndpointUriRestUriTemplate() throws Exception {
+        Map<String, String> map = new LinkedHashMap<>();
+        map.put("method", "get");
+        map.put("path", "api");
+        map.put("uriTemplate", "user/{id}");
+        String uri = catalog.asEndpointUri("rest", map, true);
+
+        assertEquals("rest:get:api:user/{id}", uri);
+    }
+
     @Test
     public void testAsEndpointUriJson() throws Exception {
         String json = loadText(CamelCatalogTest.class.getClassLoader().getResourceAsStream("sample.json"));
