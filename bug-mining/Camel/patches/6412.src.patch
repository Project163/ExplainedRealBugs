diff --git a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/vertx-websocket.json b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/vertx-websocket.json
index ce1a6c6b1ab..b1625f2d911 100644
--- a/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/vertx-websocket.json
+++ b/catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/vertx-websocket.json
@@ -25,6 +25,8 @@
     "bridgeErrorHandler": { "kind": "property", "displayName": "Bridge Error Handler", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
     "lazyStartProducer": { "kind": "property", "displayName": "Lazy Start Producer", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
     "autowiredEnabled": { "kind": "property", "displayName": "Autowired Enabled", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether autowiring is enabled. This is used for automatic autowiring options (the option must be marked as autowired) by looking up in the registry to find if there is a single instance of matching type, which then gets configured on the component. This can be used for automatic configuring JDBC data sources, JMS connection factories, AWS Clients, etc." },
+    "defaultHost": { "kind": "property", "displayName": "Default Host", "group": "advanced", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "0.0.0.0", "description": "Default value for host name that the WebSocket should bind to" },
+    "defaultPort": { "kind": "property", "displayName": "Default Port", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Default value for the port that the WebSocket should bind to" },
     "router": { "kind": "property", "displayName": "Router", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "io.vertx.ext.web.Router", "deprecated": false, "autowired": false, "secret": false, "description": "To provide a custom vertx router to use on the WebSocket server" },
     "vertx": { "kind": "property", "displayName": "Vertx", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "io.vertx.core.Vertx", "deprecated": false, "autowired": false, "secret": false, "description": "To use an existing vertx instead of creating a new instance" },
     "vertxOptions": { "kind": "property", "displayName": "Vertx Options", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "io.vertx.core.VertxOptions", "deprecated": false, "autowired": false, "secret": false, "description": "To provide a custom set of vertx options for configuring vertx" },
@@ -53,7 +55,7 @@
     "exchangePattern": { "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
     "clientOptions": { "kind": "parameter", "displayName": "Client Options", "group": "producer", "label": "producer", "required": false, "type": "object", "javaType": "io.vertx.core.http.HttpClientOptions", "deprecated": false, "autowired": false, "secret": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "Sets customized options for configuring the WebSocket client used in the producer" },
     "clientSubProtocols": { "kind": "parameter", "displayName": "Client Sub Protocols", "group": "producer", "label": "producer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "Comma separated list of WebSocket subprotocols that the client should use for the Sec-WebSocket-Protocol header" },
-    "sendToAll": { "kind": "parameter", "displayName": "Send To All", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "To send to all websocket subscribers. Can be used to configure on endpoint level, instead of having to use the VertxWebsocketConstants.SEND_TO_ALL header on the message." },
+    "sendToAll": { "kind": "parameter", "displayName": "Send To All", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "To send to all websocket subscribers. Can be used to configure at the endpoint level, instead of providing the VertxWebsocketConstants.SEND_TO_ALL header on the message. Note that when using this option, the host name specified for the vertx-websocket producer URI must match one used for an existing vertx-websocket consumer." },
     "lazyStartProducer": { "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
     "sslContextParameters": { "kind": "parameter", "displayName": "Ssl Context Parameters", "group": "security", "label": "security", "required": false, "type": "object", "javaType": "org.apache.camel.support.jsse.SSLContextParameters", "deprecated": false, "autowired": false, "secret": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "To configure security using SSLContextParameters" }
   }
diff --git a/components/camel-vertx/camel-vertx-websocket/src/generated/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponentConfigurer.java b/components/camel-vertx/camel-vertx-websocket/src/generated/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponentConfigurer.java
index e1b8a4ca3ca..f97f11b39fc 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/generated/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponentConfigurer.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/generated/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponentConfigurer.java
@@ -25,6 +25,10 @@ public class VertxWebsocketComponentConfigurer extends PropertyConfigurerSupport
         case "autowiredEnabled": target.setAutowiredEnabled(property(camelContext, boolean.class, value)); return true;
         case "bridgeerrorhandler":
         case "bridgeErrorHandler": target.setBridgeErrorHandler(property(camelContext, boolean.class, value)); return true;
+        case "defaulthost":
+        case "defaultHost": target.setDefaultHost(property(camelContext, java.lang.String.class, value)); return true;
+        case "defaultport":
+        case "defaultPort": target.setDefaultPort(property(camelContext, int.class, value)); return true;
         case "lazystartproducer":
         case "lazyStartProducer": target.setLazyStartProducer(property(camelContext, boolean.class, value)); return true;
         case "router": target.setRouter(property(camelContext, io.vertx.ext.web.Router.class, value)); return true;
@@ -44,6 +48,10 @@ public class VertxWebsocketComponentConfigurer extends PropertyConfigurerSupport
         case "autowiredEnabled": return boolean.class;
         case "bridgeerrorhandler":
         case "bridgeErrorHandler": return boolean.class;
+        case "defaulthost":
+        case "defaultHost": return java.lang.String.class;
+        case "defaultport":
+        case "defaultPort": return int.class;
         case "lazystartproducer":
         case "lazyStartProducer": return boolean.class;
         case "router": return io.vertx.ext.web.Router.class;
@@ -64,6 +72,10 @@ public class VertxWebsocketComponentConfigurer extends PropertyConfigurerSupport
         case "autowiredEnabled": return target.isAutowiredEnabled();
         case "bridgeerrorhandler":
         case "bridgeErrorHandler": return target.isBridgeErrorHandler();
+        case "defaulthost":
+        case "defaultHost": return target.getDefaultHost();
+        case "defaultport":
+        case "defaultPort": return target.getDefaultPort();
         case "lazystartproducer":
         case "lazyStartProducer": return target.isLazyStartProducer();
         case "router": return target.getRouter();
diff --git a/components/camel-vertx/camel-vertx-websocket/src/generated/resources/org/apache/camel/component/vertx/websocket/vertx-websocket.json b/components/camel-vertx/camel-vertx-websocket/src/generated/resources/org/apache/camel/component/vertx/websocket/vertx-websocket.json
index ce1a6c6b1ab..b1625f2d911 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/generated/resources/org/apache/camel/component/vertx/websocket/vertx-websocket.json
+++ b/components/camel-vertx/camel-vertx-websocket/src/generated/resources/org/apache/camel/component/vertx/websocket/vertx-websocket.json
@@ -25,6 +25,8 @@
     "bridgeErrorHandler": { "kind": "property", "displayName": "Bridge Error Handler", "group": "consumer", "label": "consumer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored." },
     "lazyStartProducer": { "kind": "property", "displayName": "Lazy Start Producer", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
     "autowiredEnabled": { "kind": "property", "displayName": "Autowired Enabled", "group": "advanced", "label": "advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": true, "description": "Whether autowiring is enabled. This is used for automatic autowiring options (the option must be marked as autowired) by looking up in the registry to find if there is a single instance of matching type, which then gets configured on the component. This can be used for automatic configuring JDBC data sources, JMS connection factories, AWS Clients, etc." },
+    "defaultHost": { "kind": "property", "displayName": "Default Host", "group": "advanced", "label": "advanced", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "defaultValue": "0.0.0.0", "description": "Default value for host name that the WebSocket should bind to" },
+    "defaultPort": { "kind": "property", "displayName": "Default Port", "group": "advanced", "label": "advanced", "required": false, "type": "integer", "javaType": "int", "deprecated": false, "autowired": false, "secret": false, "defaultValue": 0, "description": "Default value for the port that the WebSocket should bind to" },
     "router": { "kind": "property", "displayName": "Router", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "io.vertx.ext.web.Router", "deprecated": false, "autowired": false, "secret": false, "description": "To provide a custom vertx router to use on the WebSocket server" },
     "vertx": { "kind": "property", "displayName": "Vertx", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "io.vertx.core.Vertx", "deprecated": false, "autowired": false, "secret": false, "description": "To use an existing vertx instead of creating a new instance" },
     "vertxOptions": { "kind": "property", "displayName": "Vertx Options", "group": "advanced", "label": "advanced", "required": false, "type": "object", "javaType": "io.vertx.core.VertxOptions", "deprecated": false, "autowired": false, "secret": false, "description": "To provide a custom set of vertx options for configuring vertx" },
@@ -53,7 +55,7 @@
     "exchangePattern": { "kind": "parameter", "displayName": "Exchange Pattern", "group": "consumer (advanced)", "label": "consumer,advanced", "required": false, "type": "object", "javaType": "org.apache.camel.ExchangePattern", "enum": [ "InOnly", "InOut" ], "deprecated": false, "autowired": false, "secret": false, "description": "Sets the exchange pattern when the consumer creates an exchange." },
     "clientOptions": { "kind": "parameter", "displayName": "Client Options", "group": "producer", "label": "producer", "required": false, "type": "object", "javaType": "io.vertx.core.http.HttpClientOptions", "deprecated": false, "autowired": false, "secret": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "Sets customized options for configuring the WebSocket client used in the producer" },
     "clientSubProtocols": { "kind": "parameter", "displayName": "Client Sub Protocols", "group": "producer", "label": "producer", "required": false, "type": "string", "javaType": "java.lang.String", "deprecated": false, "autowired": false, "secret": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "Comma separated list of WebSocket subprotocols that the client should use for the Sec-WebSocket-Protocol header" },
-    "sendToAll": { "kind": "parameter", "displayName": "Send To All", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "To send to all websocket subscribers. Can be used to configure on endpoint level, instead of having to use the VertxWebsocketConstants.SEND_TO_ALL header on the message." },
+    "sendToAll": { "kind": "parameter", "displayName": "Send To All", "group": "producer", "label": "producer", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "To send to all websocket subscribers. Can be used to configure at the endpoint level, instead of providing the VertxWebsocketConstants.SEND_TO_ALL header on the message. Note that when using this option, the host name specified for the vertx-websocket producer URI must match one used for an existing vertx-websocket consumer." },
     "lazyStartProducer": { "kind": "parameter", "displayName": "Lazy Start Producer", "group": "producer (advanced)", "label": "producer,advanced", "required": false, "type": "boolean", "javaType": "boolean", "deprecated": false, "autowired": false, "secret": false, "defaultValue": false, "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing." },
     "sslContextParameters": { "kind": "parameter", "displayName": "Ssl Context Parameters", "group": "security", "label": "security", "required": false, "type": "object", "javaType": "org.apache.camel.support.jsse.SSLContextParameters", "deprecated": false, "autowired": false, "secret": false, "configurationClass": "org.apache.camel.component.vertx.websocket.VertxWebsocketConfiguration", "configurationField": "configuration", "description": "To configure security using SSLContextParameters" }
   }
diff --git a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponent.java b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponent.java
index c7dad0cb573..3a487874117 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponent.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponent.java
@@ -29,6 +29,7 @@ import org.apache.camel.SSLContextParametersAware;
 import org.apache.camel.spi.Metadata;
 import org.apache.camel.spi.annotations.Component;
 import org.apache.camel.support.DefaultComponent;
+import org.apache.camel.util.ObjectHelper;
 import org.apache.camel.util.URISupport;
 import org.apache.camel.util.UnsafeUriCharactersEncoder;
 
@@ -48,6 +49,10 @@ public class VertxWebsocketComponent extends DefaultComponent implements SSLCont
     private Router router;
     @Metadata(label = "security", defaultValue = "false")
     private boolean useGlobalSslContextParameters;
+    @Metadata(label = "advanced", defaultValue = VertxWebsocketConstants.DEFAULT_VERTX_SERVER_HOST)
+    private String defaultHost = VertxWebsocketConstants.DEFAULT_VERTX_SERVER_HOST;
+    @Metadata(label = "advanced", defaultValue = "" + VertxWebsocketConstants.DEFAULT_VERTX_SERVER_PORT)
+    private int defaultPort = VertxWebsocketConstants.DEFAULT_VERTX_SERVER_PORT;
 
     @Override
     protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
@@ -70,20 +75,26 @@ public class VertxWebsocketComponent extends DefaultComponent implements SSLCont
         URI endpointUri = new URI(UnsafeUriCharactersEncoder.encodeHttpURI(wsUri));
         URI websocketURI = URISupport.createRemainingURI(endpointUri, parameters);
 
-        if (websocketURI.getHost() == null || websocketURI.getPort() == -1) {
+        if (websocketURI.getHost() == null || websocketURI.getPort() == -1 || ObjectHelper.isEmpty(websocketURI.getPath())) {
+            String path = websocketURI.getPath();
             String host = websocketURI.getHost();
             int port = websocketURI.getPort();
+
             if (websocketURI.getHost() == null) {
-                host = VertxWebsocketConstants.DEFAULT_VERTX_SERVER_HOST;
+                host = getDefaultHost();
             }
 
             if (websocketURI.getPort() == -1) {
-                port = VertxWebsocketConstants.DEFAULT_VERTX_SERVER_PORT;
+                port = getDefaultPort();
+            }
+
+            if (ObjectHelper.isEmpty(path)) {
+                path = "/";
             }
 
             websocketURI = new URI(
                     websocketURI.getScheme(), websocketURI.getUserInfo(),
-                    host, port, websocketURI.getPath(), websocketURI.getQuery(),
+                    host, port, path, websocketURI.getQuery(),
                     websocketURI.getFragment());
         }
 
@@ -237,4 +248,26 @@ public class VertxWebsocketComponent extends DefaultComponent implements SSLCont
             VertxWebsocketHostConfiguration hostConfiguration, VertxWebsocketHostKey hostKey) {
         return new VertxWebsocketHost(getCamelContext(), hostConfiguration, hostKey);
     }
+
+    /**
+     * Default value for host name that the WebSocket should bind to
+     */
+    public void setDefaultHost(String defaultHost) {
+        this.defaultHost = defaultHost;
+    }
+
+    public String getDefaultHost() {
+        return this.defaultHost;
+    }
+
+    /**
+     * Default value for the port that the WebSocket should bind to
+     */
+    public void setDefaultPort(int defaultPort) {
+        this.defaultPort = defaultPort;
+    }
+
+    public int getDefaultPort() {
+        return this.defaultPort;
+    }
 }
diff --git a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketConfiguration.java b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketConfiguration.java
index 517db2dc311..6bd6025036b 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketConfiguration.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketConfiguration.java
@@ -182,8 +182,9 @@ public class VertxWebsocketConfiguration {
     }
 
     /**
-     * To send to all websocket subscribers. Can be used to configure on endpoint level, instead of having to use the
-     * {@code VertxWebsocketConstants.SEND_TO_ALL} header on the message.
+     * To send to all websocket subscribers. Can be used to configure at the endpoint level, instead of providing the
+     * {@code VertxWebsocketConstants.SEND_TO_ALL} header on the message. Note that when using this option, the host
+     * name specified for the vertx-websocket producer URI must match one used for an existing vertx-websocket consumer.
      */
     public void setSendToAll(boolean sendToAll) {
         this.sendToAll = sendToAll;
diff --git a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketEndpoint.java b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketEndpoint.java
index 473192fad52..5f9dda8930a 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketEndpoint.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketEndpoint.java
@@ -184,7 +184,8 @@ public class VertxWebsocketEndpoint extends DefaultEndpoint {
         Map<VertxWebsocketHostKey, VertxWebsocketHost> registry = getVertxHostRegistry();
         for (VertxWebsocketHost host : registry.values()) {
             Map<String, ServerWebSocket> hostPeers = host.getConnectedPeers();
-            if (hostPeers.containsKey(connectionKey) && host.getPort() == getConfiguration().getWebsocketURI().getPort()) {
+            if (hostPeers.containsKey(connectionKey) && host.isManagedHost(getConfiguration().getWebsocketURI().getHost())
+                    && host.isManagedPort(getConfiguration().getWebsocketURI().getPort())) {
                 return hostPeers.get(connectionKey);
             }
         }
@@ -198,15 +199,11 @@ public class VertxWebsocketEndpoint extends DefaultEndpoint {
         return getVertxHostRegistry()
                 .values()
                 .stream()
-                .filter(host -> host.getPort() == getConfiguration().getWebsocketURI().getPort())
+                .filter(host -> host.isManagedHost(getConfiguration().getWebsocketURI().getHost()))
+                .filter(host -> host.isManagedPort(getConfiguration().getWebsocketURI().getPort()))
                 .flatMap(host -> host.getConnectedPeers().entrySet().stream())
-                .filter(entry -> entry.getValue().path().equals(getConfiguration().getWebsocketURI().getPath()))
+                .filter(entry -> VertxWebsocketHelper.webSocketHostPathMatches(entry.getValue().path(),
+                        getConfiguration().getWebsocketURI().getPath()))
                 .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
     }
-
-    protected boolean isManagedPort() {
-        return getVertxHostRegistry().values()
-                .stream()
-                .anyMatch(host -> host.getPort() == getConfiguration().getWebsocketURI().getPort());
-    }
 }
diff --git a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHelper.java b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHelper.java
index 8be25ffdde1..27f61c5b483 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHelper.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHelper.java
@@ -21,6 +21,9 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
+import io.vertx.core.http.impl.HttpUtils;
+import org.apache.camel.util.ObjectHelper;
+
 public final class VertxWebsocketHelper {
 
     private VertxWebsocketHelper() {
@@ -53,4 +56,52 @@ public final class VertxWebsocketHelper {
         }
         headers.put(key, value);
     }
+
+    /**
+     * Determines whether the path of a WebSocket host (the vertx-websocket consumer) matches a target path (the
+     * vertx-websocket producer), taking path parameters and wildcard paths into consideration.
+     */
+    public static boolean webSocketHostPathMatches(String hostPath, String targetPath) {
+        boolean exactPathMatch = true;
+
+        if (ObjectHelper.isEmpty(hostPath) || ObjectHelper.isEmpty(targetPath)) {
+            // This scenario should not really be possible as the input args come from the vertx-websocket consumer / producer URI
+            return false;
+        }
+
+        // Paths ending with '*' are Vert.x wildcard routes so match on the path prefix
+        if (hostPath.endsWith("*")) {
+            exactPathMatch = false;
+            hostPath = hostPath.substring(0, hostPath.lastIndexOf('*'));
+        }
+
+        String normalizedHostPath = HttpUtils.normalizePath(hostPath + "/");
+        String normalizedTargetPath = HttpUtils.normalizePath(targetPath + "/");
+        String[] hostPathElements = normalizedHostPath.split("/");
+        String[] targetPathElements = normalizedTargetPath.split("/");
+
+        if (exactPathMatch && hostPathElements.length != targetPathElements.length) {
+            return false;
+        }
+
+        if (normalizedHostPath.contains("{")) {
+            // For a parameterized paths verify the non-parameterized elements match
+            for (int i = 0; i < hostPathElements.length; i++) {
+                String hostPathElement = hostPathElements[i];
+                String targetPathElement = targetPathElements[i];
+                if (!hostPathElement.startsWith("{") && !hostPathElement.endsWith("}")
+                        && !hostPathElement.equals(targetPathElement)) {
+                    return false;
+                }
+            }
+        } else {
+            if (exactPathMatch) {
+                return normalizedHostPath.equals(normalizedTargetPath);
+            } else {
+                return normalizedTargetPath.startsWith(normalizedHostPath);
+            }
+        }
+
+        return true;
+    }
 }
diff --git a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHost.java b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHost.java
index 411e32c4090..3386bc7d1b5 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHost.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHost.java
@@ -210,7 +210,7 @@ public class VertxWebsocketHost {
     }
 
     /**
-     * Starts a previously started Vert.x HTTP server
+     * Stops a previously started Vert.x HTTP server
      */
     public void stop() throws ExecutionException, InterruptedException {
         if (server != null) {
@@ -249,4 +249,18 @@ public class VertxWebsocketHost {
     public int getPort() {
         return port;
     }
+
+    /**
+     * Determines whether the specified host name is one that is managed by this host.
+     */
+    public boolean isManagedHost(String host) {
+        return hostKey.getHost().equals(host);
+    }
+
+    /**
+     * Determines whether the specified port is one that is managed by this host.
+     */
+    public boolean isManagedPort(int port) {
+        return getPort() == port;
+    }
 }
diff --git a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketProducer.java b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketProducer.java
index 28bfd8b106b..a6680c5ed8e 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketProducer.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/main/java/org/apache/camel/component/vertx/websocket/VertxWebsocketProducer.java
@@ -105,22 +105,23 @@ public class VertxWebsocketProducer extends DefaultAsyncProducer {
     }
 
     private Map<String, WebSocketBase> getConnectedPeers(Exchange exchange) throws Exception {
-        Map<String, WebSocketBase> connectedPeers = new HashMap<>();
         VertxWebsocketEndpoint endpoint = getEndpoint();
+        Map<String, ServerWebSocket> peers = endpoint.findPeersForHostPort();
+        Map<String, WebSocketBase> connectedPeers = new HashMap<>();
         Message message = exchange.getMessage();
 
         boolean isSendToAll = message.getHeader(VertxWebsocketConstants.SEND_TO_ALL,
                 endpoint.getConfiguration().isSendToAll(), boolean.class);
         if (isSendToAll) {
             // Try to find all peers connected to an existing vertx-websocket consumer
-            Map<String, ServerWebSocket> peers = endpoint.findPeersForHostPort();
             if (ObjectHelper.isNotEmpty(peers)) {
                 connectedPeers.putAll(peers);
             }
         } else {
             String connectionKey = message.getHeader(VertxWebsocketConstants.CONNECTION_KEY, String.class);
-            if (connectionKey != null && endpoint.isManagedPort()) {
+            if (connectionKey != null && ObjectHelper.isNotEmpty(peers)) {
                 Stream.of(connectionKey.split(","))
+                        .filter(peers::containsKey)
                         .forEach(key -> connectedPeers.put(key, endpoint.findPeerForConnectionKey(key)));
             } else {
                 // The producer is invoking an external server not managed by camel
diff --git a/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebSocketTestSupport.java b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebSocketTestSupport.java
index f695197d6e5..eec662eabf1 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebSocketTestSupport.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebSocketTestSupport.java
@@ -39,6 +39,7 @@ import org.apache.camel.test.junit5.CamelTestSupport;
 public class VertxWebSocketTestSupport extends CamelTestSupport {
 
     protected final int port = AvailablePortFinder.getNextAvailable();
+    protected final int port2 = AvailablePortFinder.getNextAvailable();
 
     /**
      * Returns the randomized port used for the Vert.x server if no port was provided to the consumer.
@@ -49,6 +50,7 @@ public class VertxWebSocketTestSupport extends CamelTestSupport {
         return registry.values()
                 .stream()
                 .filter(wsHost -> wsHost.getPort() != port)
+                .filter(wsHost -> wsHost.getPort() != port2)
                 .findFirst()
                 .get()
                 .getPort();
diff --git a/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponentConfigurationTest.java b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponentConfigurationTest.java
index ee67fb4da40..f2b81317049 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponentConfigurationTest.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketComponentConfigurationTest.java
@@ -16,6 +16,8 @@
  */
 package org.apache.camel.component.vertx.websocket;
 
+import java.net.URI;
+
 import io.vertx.core.Vertx;
 import io.vertx.core.VertxOptions;
 import io.vertx.core.metrics.MetricsOptions;
@@ -24,6 +26,7 @@ import org.apache.camel.CamelContext;
 import org.apache.camel.impl.DefaultCamelContext;
 import org.junit.jupiter.api.Test;
 
+import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
@@ -82,4 +85,37 @@ public class VertxWebsocketComponentConfigurationTest {
             context.stop();
         }
     }
+
+    @Test
+    void testDefaultHost() throws Exception {
+        try (CamelContext context = new DefaultCamelContext()) {
+            String defaultHostName = "foo.bar.com";
+
+            VertxWebsocketComponent component = new VertxWebsocketComponent();
+            component.setDefaultHost(defaultHostName);
+            context.addComponent("vertx-websocket", component);
+            context.start();
+
+            VertxWebsocketEndpoint endpoint = context.getEndpoint("vertx-websocket:/test", VertxWebsocketEndpoint.class);
+            URI websocketURI = endpoint.getConfiguration().getWebsocketURI();
+            assertEquals(defaultHostName, websocketURI.getHost());
+        }
+    }
+
+    @Test
+    void testDefaultPort() throws Exception {
+        try (CamelContext context = new DefaultCamelContext()) {
+            int defaultPort = 8888;
+
+            VertxWebsocketComponent component = new VertxWebsocketComponent();
+            component.setDefaultPort(defaultPort);
+            context.addComponent("vertx-websocket", component);
+            context.start();
+
+            VertxWebsocketEndpoint endpoint
+                    = context.getEndpoint("vertx-websocket:foo.bar.com/test", VertxWebsocketEndpoint.class);
+            URI websocketURI = endpoint.getConfiguration().getWebsocketURI();
+            assertEquals(defaultPort, websocketURI.getPort());
+        }
+    }
 }
diff --git a/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHelperTest.java b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHelperTest.java
new file mode 100644
index 00000000000..4af16a6f68a
--- /dev/null
+++ b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketHelperTest.java
@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.vertx.websocket;
+
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+public class VertxWebsocketHelperTest {
+
+    @Test
+    void webSocketHostExactPathMatches() {
+        String hostPath = "/foo/bar/cheese/wine";
+        String targetPath = "/foo/bar/cheese/wine";
+        assertTrue(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostExactPathNotMatches() {
+        String hostPath = "/foo/bar/cheese/wine";
+        String targetPath = "/foo/bar/wine/cheese";
+        assertFalse(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostExactPathNotEnoughElementsNotMatches() {
+        String hostPath = "/foo/bar/cheese/wine";
+        String targetPath = "/foo/bar";
+        assertFalse(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostExactPathWithParamsMatches() {
+        String hostPath = "/foo/{bar}/cheese/{wine}";
+        String targetPath = "/foo/bar/cheese/wine";
+        assertTrue(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostExactPathWithParamsNotMatches() {
+        String hostPath = "/foo/{bar}/cheese/{wine}";
+        String targetPath = "/bad/bar/path/wine";
+        assertFalse(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostWildcardPathMatches() {
+        String hostPath = "/foo/bar/cheese/wine*";
+        String targetPath = "/foo/bar/cheese/wine/beer/additional/path";
+        assertTrue(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostWildcardPathNotMatches() {
+        String hostPath = "/foo/bar/cheese/wine*";
+        String targetPath = "/foo/bar/cheese/win";
+        assertFalse(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostWildcardPathWithParamsMatches() {
+        String hostPath = "/foo/{bar}/cheese/{wine}*";
+        String targetPath = "/foo/bar/cheese/wine/beer/additional/path";
+        assertTrue(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostWildcardPathWithParamsNotMatches() {
+        String hostPath = "/foo/{bar}/cheese/{wine}*";
+        String targetPath = "/foo/bar/invalid/wine/beer/additional/path";
+        assertFalse(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostWithTrailingSlashPathMatches() {
+        String hostPath = "/foo/bar/cheese/wine";
+        String targetPath = "/foo/bar/cheese/wine/";
+        assertTrue(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostWithTrailingMultipleSlashPathMatches() {
+        String hostPath = "/foo/bar/cheese/wine";
+        String targetPath = "/foo/bar/cheese/wine//";
+        assertTrue(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostWildcardPathWithTrailingSlashStarMatches() {
+        String hostPath = "/foo/{bar}/cheese/{wine}/*";
+        String targetPath = "/foo/bar/cheese/wine/beer/additional/path";
+        assertTrue(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostDefaultPathMatches() {
+        String hostPath = "/";
+        String targetPath = "/";
+        assertTrue(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostEmptyPathNotMatches() {
+        String hostPath = "";
+        String targetPath = "";
+        assertFalse(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+
+    @Test
+    void webSocketHostNullPathNotMatches() {
+        String hostPath = null;
+        String targetPath = null;
+        assertFalse(VertxWebsocketHelper.webSocketHostPathMatches(hostPath, targetPath));
+    }
+}
diff --git a/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketMultiConsumerTest.java b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketMultiConsumerTest.java
index 77563066829..2c228a03171 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketMultiConsumerTest.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketMultiConsumerTest.java
@@ -37,6 +37,16 @@ public class VertxWebsocketMultiConsumerTest extends VertxWebSocketTestSupport {
         mockEndpoint.assertIsSatisfied();
     }
 
+    @Test
+    void testConsumerOnAlternativePort() throws Exception {
+        MockEndpoint mockEndpoint = getMockEndpoint("mock:result2");
+        mockEndpoint.expectedBodiesReceived("Hello World");
+
+        template.sendBody("vertx-websocket:localhost:" + port2 + "/test", "World");
+
+        mockEndpoint.assertIsSatisfied();
+    }
+
     @Override
     protected RoutesBuilder createRouteBuilder() {
         return new RouteBuilder() {
@@ -53,6 +63,10 @@ public class VertxWebsocketMultiConsumerTest extends VertxWebSocketTestSupport {
                 fromF("vertx-websocket:localhost:%d/test/c", port)
                         .setBody(simple("Hello ${body}"))
                         .to("mock:result");
+
+                fromF("vertx-websocket:localhost:%d/test", port2)
+                        .setBody(simple("Hello ${body}"))
+                        .to("mock:result2");
             }
         };
     }
diff --git a/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketTest.java b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketTest.java
index 95a46387204..fd055af6263 100644
--- a/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketTest.java
+++ b/components/camel-vertx/camel-vertx-websocket/src/test/java/org/apache/camel/component/vertx/websocket/VertxWebsocketTest.java
@@ -28,6 +28,7 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 import io.vertx.core.http.ServerWebSocket;
+import io.vertx.core.http.UpgradeRejectedException;
 import io.vertx.core.http.WebSocket;
 import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
@@ -37,6 +38,8 @@ import org.apache.camel.component.mock.MockEndpoint;
 import org.junit.jupiter.api.Test;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class VertxWebsocketTest extends VertxWebSocketTestSupport {
@@ -179,13 +182,16 @@ public class VertxWebsocketTest extends VertxWebSocketTestSupport {
             });
         }
 
+        // Open a connection on path /test on another port to ensure the 'send to all' operation
+        // only targeted peers connected on path /test
+        openWebSocketConnection("localhost", port2, "/test", message -> {
+            results.add("/test on port " + port2 + " should not have been called");
+        });
+
         // Open a connection on path /test-other to ensure the 'send to all' operation
         // only targeted peers connected on path /test
         openWebSocketConnection("localhost", port, "/test-other", message -> {
-            synchronized (latch) {
-                results.add(message + " " + latch.getCount());
-                latch.countDown();
-            }
+            results.add("/test-other should not have been called");
         });
 
         template.sendBody("vertx-websocket:localhost:" + port + "/test?sendToAll=true", "Hello World");
@@ -218,13 +224,16 @@ public class VertxWebsocketTest extends VertxWebSocketTestSupport {
             });
         }
 
+        // Open a connection on path /test on another port to ensure the 'send to all' operation
+        // only targeted peers connected on path /test
+        openWebSocketConnection("localhost", port2, "/test", message -> {
+            results.add("/test on port " + port2 + " should not have been called");
+        });
+
         // Open a connection on path /test-other to ensure the 'send to all' operation
         // only targeted peers connected on path /test
         openWebSocketConnection("localhost", port, "/test-other", message -> {
-            synchronized (latch) {
-                results.add(message + " " + latch.getCount());
-                latch.countDown();
-            }
+            results.add("/test-other should not have been called");
         });
 
         template.sendBodyAndHeader("vertx-websocket:localhost:" + port + "/test", "Hello World",
@@ -244,16 +253,9 @@ public class VertxWebsocketTest extends VertxWebSocketTestSupport {
     public void testEchoRoute() throws Exception {
         CountDownLatch latch = new CountDownLatch(1);
         List<String> results = new ArrayList<>();
+        int wsPort = getVertxServerRandomPort();
 
-        VertxWebsocketComponent component = context.getComponent("vertx-websocket", VertxWebsocketComponent.class);
-        Map<VertxWebsocketHostKey, VertxWebsocketHost> registry = component.getVertxHostRegistry();
-        VertxWebsocketHost host = registry.values()
-                .stream()
-                .filter(wsHost -> wsHost.getPort() != port)
-                .findFirst()
-                .get();
-
-        WebSocket webSocket = openWebSocketConnection("localhost", host.getPort(), "/greeting", message -> {
+        WebSocket webSocket = openWebSocketConnection("localhost", wsPort, "/greeting", message -> {
             synchronized (latch) {
                 results.add(message);
                 latch.countDown();
@@ -267,6 +269,42 @@ public class VertxWebsocketTest extends VertxWebSocketTestSupport {
         assertEquals("Hello Camel", results.get(0));
     }
 
+    @Test
+    void echoRouteWithPathParams() throws Exception {
+        CountDownLatch latch = new CountDownLatch(1);
+        List<String> results = new ArrayList<>();
+
+        WebSocket webSocket = openWebSocketConnection("localhost", port, "/testA/echo/testB", message -> {
+            synchronized (latch) {
+                results.add(message);
+                latch.countDown();
+            }
+        });
+        webSocket.writeTextMessage("Hello");
+
+        assertTrue(latch.await(10, TimeUnit.SECONDS));
+        assertEquals(1, results.size());
+        assertEquals("Hello testA testB", results.get(0));
+    }
+
+    @Test
+    void echoRouteWithWildcardPath() throws Exception {
+        CountDownLatch latch = new CountDownLatch(1);
+        List<String> results = new ArrayList<>();
+
+        WebSocket webSocket = openWebSocketConnection("localhost", port, "/wildcard/echo/foo/bar", message -> {
+            synchronized (latch) {
+                results.add(message);
+                latch.countDown();
+            }
+        });
+        webSocket.writeTextMessage("Hello");
+
+        assertTrue(latch.await(10, TimeUnit.SECONDS));
+        assertEquals(1, results.size());
+        assertEquals("Hello World", results.get(0));
+    }
+
     @Test
     void testWsSchemeUriPrefix() throws InterruptedException {
         MockEndpoint mockEndpoint = getMockEndpoint("mock:result");
@@ -317,6 +355,45 @@ public class VertxWebsocketTest extends VertxWebSocketTestSupport {
         mockEndpoint.assertIsSatisfied(5000);
     }
 
+    @Test
+    void defaultPath() throws InterruptedException {
+        MockEndpoint mockEndpoint = getMockEndpoint("mock:defaultPath");
+        mockEndpoint.expectedBodiesReceived("Hello World from the default path");
+
+        template.sendBody("vertx-websocket:localhost:" + port, "World");
+
+        mockEndpoint.assertIsSatisfied(5000);
+    }
+
+    @Test
+    void wildcardPath() throws InterruptedException {
+        MockEndpoint mockEndpoint = getMockEndpoint("mock:wildcardPath");
+        mockEndpoint.expectedBodiesReceived("Hello World from the wildcard path");
+
+        template.sendBody("vertx-websocket:localhost:" + port + "/wild/card/foo/bar", "World");
+
+        mockEndpoint.assertIsSatisfied(5000);
+    }
+
+    @Test
+    void nonManagedPathReturns404() {
+        Exchange exchange = template.request("vertx-websocket:localhost:" + port + "/invalid", new Processor() {
+            @Override
+            public void process(Exchange exchange) throws Exception {
+                exchange.getMessage().setBody("Test");
+            }
+        });
+
+        Exception exception = exchange.getException();
+        assertNotNull(exception);
+
+        Throwable cause = exception.getCause();
+        assertNotNull(exception);
+        assertInstanceOf(UpgradeRejectedException.class, cause);
+
+        assertEquals(404, ((UpgradeRejectedException) cause).getStatus());
+    }
+
     @Override
     protected RoutesBuilder createRouteBuilder() {
         return new RouteBuilder() {
@@ -329,13 +406,22 @@ public class VertxWebsocketTest extends VertxWebSocketTestSupport {
                         .setBody(simple("Hello ${body}"))
                         .to("mock:result");
 
+                fromF("vertx-websocket:localhost:%d/test", port2)
+                        .setBody(simple("Hello ${body}"))
+                        .to("mock:result");
+
                 fromF("vertx-websocket:localhost:%d/test-other", port)
-                        .setBody(simple("Hello ${body}"));
+                        .setBody(simple("Hello ${body}"))
+                        .to("mock:result");
 
                 fromF("vertx-websocket:localhost:%d/path/params/{firstParam}/{secondParam}", port)
                         .setBody(simple("${header.firstParam} ${header.secondParam}"))
                         .to("mock:pathParamResult");
 
+                fromF("vertx-websocket:localhost:%d/{firstParam}/echo/{secondParam}", port)
+                        .setBody(simple("${body} ${header.firstParam} ${header.secondParam}"))
+                        .toF("vertx-websocket:localhost:%d/testA/echo/testB", port);
+
                 fromF("vertx-websocket:localhost:%d/query/params", port)
                         .setBody(simple("${header.firstParam} ${header.secondParam}"))
                         .to("mock:queryParamResult");
@@ -350,6 +436,18 @@ public class VertxWebsocketTest extends VertxWebSocketTestSupport {
                             }
                         })
                         .toD("vertx-websocket:localhost:${header.port}/greeting");
+
+                fromF("vertx-websocket:localhost:%d", port)
+                        .setBody().simple("Hello ${body} from the default path")
+                        .to("mock:defaultPath");
+
+                fromF("vertx-websocket:localhost:%d/wild/card*", port)
+                        .setBody().simple("Hello ${body} from the wildcard path")
+                        .to("mock:wildcardPath");
+
+                fromF("vertx-websocket:localhost:%d/wildcard/echo*", port)
+                        .setBody().simple("${body} World")
+                        .toF("vertx-websocket:localhost:%d/wildcard/echo/foo/bar", port);
             }
         };
     }
diff --git a/dsl/camel-componentdsl/src/generated/java/org/apache/camel/builder/component/dsl/VertxWebsocketComponentBuilderFactory.java b/dsl/camel-componentdsl/src/generated/java/org/apache/camel/builder/component/dsl/VertxWebsocketComponentBuilderFactory.java
index 18896ce1f56..03eed8de59b 100644
--- a/dsl/camel-componentdsl/src/generated/java/org/apache/camel/builder/component/dsl/VertxWebsocketComponentBuilderFactory.java
+++ b/dsl/camel-componentdsl/src/generated/java/org/apache/camel/builder/component/dsl/VertxWebsocketComponentBuilderFactory.java
@@ -119,6 +119,37 @@ public interface VertxWebsocketComponentBuilderFactory {
             doSetProperty("autowiredEnabled", autowiredEnabled);
             return this;
         }
+        /**
+         * Default value for host name that the WebSocket should bind to.
+         * 
+         * The option is a: &lt;code&gt;java.lang.String&lt;/code&gt; type.
+         * 
+         * Default: 0.0.0.0
+         * Group: advanced
+         * 
+         * @param defaultHost the value to set
+         * @return the dsl builder
+         */
+        default VertxWebsocketComponentBuilder defaultHost(
+                java.lang.String defaultHost) {
+            doSetProperty("defaultHost", defaultHost);
+            return this;
+        }
+        /**
+         * Default value for the port that the WebSocket should bind to.
+         * 
+         * The option is a: &lt;code&gt;int&lt;/code&gt; type.
+         * 
+         * Default: 0
+         * Group: advanced
+         * 
+         * @param defaultPort the value to set
+         * @return the dsl builder
+         */
+        default VertxWebsocketComponentBuilder defaultPort(int defaultPort) {
+            doSetProperty("defaultPort", defaultPort);
+            return this;
+        }
         /**
          * To provide a custom vertx router to use on the WebSocket server.
          * 
@@ -201,6 +232,8 @@ public interface VertxWebsocketComponentBuilderFactory {
             case "bridgeErrorHandler": ((VertxWebsocketComponent) component).setBridgeErrorHandler((boolean) value); return true;
             case "lazyStartProducer": ((VertxWebsocketComponent) component).setLazyStartProducer((boolean) value); return true;
             case "autowiredEnabled": ((VertxWebsocketComponent) component).setAutowiredEnabled((boolean) value); return true;
+            case "defaultHost": ((VertxWebsocketComponent) component).setDefaultHost((java.lang.String) value); return true;
+            case "defaultPort": ((VertxWebsocketComponent) component).setDefaultPort((int) value); return true;
             case "router": ((VertxWebsocketComponent) component).setRouter((io.vertx.ext.web.Router) value); return true;
             case "vertx": ((VertxWebsocketComponent) component).setVertx((io.vertx.core.Vertx) value); return true;
             case "vertxOptions": ((VertxWebsocketComponent) component).setVertxOptions((io.vertx.core.VertxOptions) value); return true;
diff --git a/dsl/camel-endpointdsl/src/generated/java/org/apache/camel/builder/endpoint/dsl/VertxWebsocketEndpointBuilderFactory.java b/dsl/camel-endpointdsl/src/generated/java/org/apache/camel/builder/endpoint/dsl/VertxWebsocketEndpointBuilderFactory.java
index fcb176ec9e5..59e1113aa94 100644
--- a/dsl/camel-endpointdsl/src/generated/java/org/apache/camel/builder/endpoint/dsl/VertxWebsocketEndpointBuilderFactory.java
+++ b/dsl/camel-endpointdsl/src/generated/java/org/apache/camel/builder/endpoint/dsl/VertxWebsocketEndpointBuilderFactory.java
@@ -523,9 +523,12 @@ public interface VertxWebsocketEndpointBuilderFactory {
             return this;
         }
         /**
-         * To send to all websocket subscribers. Can be used to configure on
-         * endpoint level, instead of having to use the
-         * VertxWebsocketConstants.SEND_TO_ALL header on the message.
+         * To send to all websocket subscribers. Can be used to configure at the
+         * endpoint level, instead of providing the
+         * VertxWebsocketConstants.SEND_TO_ALL header on the message. Note that
+         * when using this option, the host name specified for the
+         * vertx-websocket producer URI must match one used for an existing
+         * vertx-websocket consumer.
          * 
          * The option is a: &lt;code&gt;boolean&lt;/code&gt; type.
          * 
@@ -541,9 +544,12 @@ public interface VertxWebsocketEndpointBuilderFactory {
             return this;
         }
         /**
-         * To send to all websocket subscribers. Can be used to configure on
-         * endpoint level, instead of having to use the
-         * VertxWebsocketConstants.SEND_TO_ALL header on the message.
+         * To send to all websocket subscribers. Can be used to configure at the
+         * endpoint level, instead of providing the
+         * VertxWebsocketConstants.SEND_TO_ALL header on the message. Note that
+         * when using this option, the host name specified for the
+         * vertx-websocket producer URI must match one used for an existing
+         * vertx-websocket consumer.
          * 
          * The option will be converted to a &lt;code&gt;boolean&lt;/code&gt;
          * type.
