diff --git a/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java b/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java
index 48a8f60d30b..c5b05d46ba7 100644
--- a/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/MulticastDefinition.java
@@ -16,6 +16,7 @@
  */
 package org.apache.camel.model;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 
@@ -26,9 +27,11 @@ import javax.xml.bind.annotation.XmlRootElement;
 import javax.xml.bind.annotation.XmlTransient;
 
 import org.apache.camel.Processor;
+import org.apache.camel.builder.ErrorHandlerBuilder;
 import org.apache.camel.processor.MulticastProcessor;
 import org.apache.camel.processor.aggregate.AggregationStrategy;
 import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
+import org.apache.camel.spi.LifecycleStrategy;
 import org.apache.camel.spi.RouteContext;
 
 /**
@@ -126,7 +129,7 @@ public class MulticastDefinition extends OutputDefinition<ProcessorDefinition> {
         return this;
     }    
         
-    protected Processor createCompositeProcessor(RouteContext routeContext, List<Processor> list) {
+    protected Processor createCompositeProcessor(RouteContext routeContext, List<Processor> list) throws Exception {
         if (strategyRef != null) {
             aggregationStrategy = routeContext.lookup(strategyRef, AggregationStrategy.class);
         }
@@ -137,8 +140,16 @@ public class MulticastDefinition extends OutputDefinition<ProcessorDefinition> {
         if (executorServiceRef != null) {
             executorService = routeContext.lookup(executorServiceRef, ExecutorService.class);
         }
-        return new MulticastProcessor(list, aggregationStrategy, isParallelProcessing(), executorService,
-                isStreaming(), isStopOnException());
+
+        // wrap list of processors in error handlers so we have fine grained error handling
+        List<Processor> processors = new ArrayList<Processor>(list.size());
+        for (Processor output : list) {
+            Processor errorHandler = wrapInErrorHandler(routeContext, output);
+            processors.add(errorHandler);
+        }
+
+        return new MulticastProcessor(processors, aggregationStrategy, isParallelProcessing(), executorService,
+                                      isStreaming(), isStopOnException());
     }
 
     public AggregationStrategy getAggregationStrategy() {
diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java
index fb89d958a9b..bc12ea6e059 100644
--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java
@@ -180,24 +180,41 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition> exte
         if (defn instanceof TryDefinition || defn instanceof CatchDefinition || defn instanceof FinallyDefinition) {
             // do not use error handler for try .. catch .. finally blocks as it will handle errors itself
             return channel;
+        } else if (defn instanceof MulticastDefinition) {
+            // do not use error handler for multicast based as it offers fine grained error handlers for its outputs
+            return channel;
         } else {
             // regular definition so add the error handler
             Processor output = channel.getOutput();
-            // create error handler
-            ErrorHandlerBuilder builder = getErrorHandlerBuilder();
-            Processor errorHandler = builder.createErrorHandler(routeContext, output);
+            Processor errorHandler = wrapInErrorHandler(routeContext, output);
             // set error handler on channel
             channel.setErrorHandler(errorHandler);
 
-            // invoke lifecycles so we can manage this error handler builder
-            for (LifecycleStrategy strategy : routeContext.getCamelContext().getLifecycleStrategies()) {
-                strategy.onErrorHandlerAdd(routeContext, errorHandler, builder);
-            }
-
             return channel;
         }
     }
 
+    /**
+     * Wraps the given output in an error handler
+     *
+     * @param routeContext the route context
+     * @param output the output
+     * @return the output wrapped with the error handler
+     * @throws Exception can be thrown
+     */
+    protected Processor wrapInErrorHandler(RouteContext routeContext, Processor output) throws Exception {
+        // create error handler
+        ErrorHandlerBuilder builder = getErrorHandlerBuilder();
+        Processor errorHandler = builder.createErrorHandler(routeContext, output);
+
+        // invoke lifecycles so we can manage this error handler builder
+        for (LifecycleStrategy strategy : routeContext.getCamelContext().getLifecycleStrategies()) {
+            strategy.onErrorHandlerAdd(routeContext, errorHandler, builder);
+        }
+
+        return errorHandler;
+    }
+
     /**
      * Adds the given list of interceptors to the channel.
      *
@@ -243,14 +260,14 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition> exte
      * Creates a new instance of some kind of composite processor which defaults
      * to using a {@link Pipeline} but derived classes could change the behaviour
      */
-    protected Processor createCompositeProcessor(RouteContext routeContext, List<Processor> list) {
+    protected Processor createCompositeProcessor(RouteContext routeContext, List<Processor> list) throws Exception {
         return new Pipeline(list);
     }
 
     /**
      * Creates a new instance of the {@link Channel}.
      */
-    protected Channel createChannel(RouteContext routeContext) {
+    protected Channel createChannel(RouteContext routeContext) throws Exception {
         return new DefaultChannel();
     }
 
diff --git a/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java b/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java
index 334b1b26dfb..aa00fbb1eb3 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java
@@ -104,4 +104,9 @@ public abstract class ErrorHandlerSupport extends ServiceSupport implements Erro
      */
     public abstract boolean supportTransacted();
 
+    /**
+     * Gets the output
+     */
+    public abstract Processor getOutput();
+
 }
diff --git a/camel-core/src/test/java/org/apache/camel/TestSupport.java b/camel-core/src/test/java/org/apache/camel/TestSupport.java
index 568fe5ceef5..0c74308d42c 100644
--- a/camel-core/src/test/java/org/apache/camel/TestSupport.java
+++ b/camel-core/src/test/java/org/apache/camel/TestSupport.java
@@ -27,6 +27,7 @@ import org.apache.camel.builder.ValueBuilder;
 import org.apache.camel.impl.DefaultCamelContext;
 import org.apache.camel.impl.DefaultExchange;
 import org.apache.camel.processor.DelegateProcessor;
+import org.apache.camel.processor.ErrorHandlerSupport;
 import org.apache.camel.util.ExchangeHelper;
 import org.apache.camel.util.PredicateAssertHelper;
 import org.apache.commons.logging.Log;
@@ -377,6 +378,8 @@ public abstract class TestSupport extends TestCase {
                 return (Channel) processor;
             } else if (processor instanceof DelegateProcessor) {
                 processor = ((DelegateProcessor)processor).getProcessor();
+            } else if (processor instanceof ErrorHandlerSupport) {
+                processor = ((ErrorHandlerSupport)processor).getOutput();
             } else {
                 return null;
             }
diff --git a/camel-core/src/test/java/org/apache/camel/processor/ErrorHandlerSupportTest.java b/camel-core/src/test/java/org/apache/camel/processor/ErrorHandlerSupportTest.java
index ff8f21574c6..3155971fa9c 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/ErrorHandlerSupportTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/ErrorHandlerSupportTest.java
@@ -22,6 +22,7 @@ import java.util.List;
 import junit.framework.TestCase;
 
 import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
 import org.apache.camel.model.OnExceptionDefinition;
 
 public class ErrorHandlerSupportTest extends TestCase {
@@ -91,6 +92,10 @@ public class ErrorHandlerSupportTest extends TestCase {
             return false;
         }
 
+        public Processor getOutput() {
+            return null;
+        }
+
         public void process(Exchange exchange) throws Exception {
         }
     }
diff --git a/camel-core/src/test/java/org/apache/camel/processor/MulticastFineGrainedErrorHandlingTest.java b/camel-core/src/test/java/org/apache/camel/processor/MulticastFineGrainedErrorHandlingTest.java
new file mode 100644
index 00000000000..2c642a803e5
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/MulticastFineGrainedErrorHandlingTest.java
@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision$
+ */
+public class MulticastFineGrainedErrorHandlingTest extends ContextTestSupport {
+
+    public void testMulticastOk() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .multicast().stopOnException()
+                    .to("mock:foo", "mock:bar", "mock:baz");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(1);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testMulticastError() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(Exception.class).maximumRedeliveries(2);
+
+                from("direct:start")
+                    .multicast().stopOnException()
+                    .to("mock:foo", "mock:bar").throwException(new IllegalArgumentException("Damn")).to("mock:baz");
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:baz").expectedMessageCount(0);
+
+        try {
+            template.sendBody("direct:start", "Hello World");
+            fail("Should throw exception");
+        } catch (Exception e) {
+            // expected
+        }
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+}
