diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyAbstractFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyAbstractFactory.java
index d426bd9a808..3aef7aa7303 100644
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyAbstractFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyAbstractFactory.java
@@ -104,7 +104,7 @@ public abstract class BindyAbstractFactory implements BindyFactory {
                 String toClassName = field.getType().getName();
                 Object to = model.get(toClassName);
 
-                ObjectHelper.notNull(to, "No @link annotation has been defined for the oject to link");
+                ObjectHelper.notNull(to, "No @link annotation has been defined for the object to link");
                 field.set(model.get(field.getDeclaringClass().getName()), to);
             }
         }
@@ -139,15 +139,15 @@ public abstract class BindyAbstractFactory implements BindyFactory {
      * @return the key generated
      */
     protected static Integer generateKey(Integer key1, Integer key2) {
-        String key2Formated;
+        String key2Formatted;
         String keyGenerated;
 
         // Test added for ticket - camel-2773
         if ((key1 != null) && (key2 != null)) {
-            key2Formated = getNumberFormat().format((long) key2);
-            keyGenerated = String.valueOf(key1) + key2Formated;
+            key2Formatted = getNumberFormat().format((long) key2);
+            keyGenerated = String.valueOf(key1) + key2Formatted;
         } else {
-            throw new IllegalArgumentException("@Section and/or @KeyValuePairDataField have not been defined!");
+            throw new IllegalArgumentException("@Section and/or @KeyValuePairDataField have not been defined");
         }
 
         return Integer.valueOf(keyGenerated);
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java
index c2d6e413126..5155c7be784 100755
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java
@@ -52,7 +52,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
     boolean isOneToMany;
 
     private Map<Integer, DataField> dataFields = new LinkedHashMap<Integer, DataField>();
-    private Map<Integer, Field> annotedFields = new LinkedHashMap<Integer, Field>();
+    private Map<Integer, Field> annotatedFields = new LinkedHashMap<Integer, Field>();
     private Map<String, Integer> sections = new HashMap<String, Integer>();
 
     private Map<Integer, List<String>> results;
@@ -98,14 +98,14 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
             List<Field> linkFields = new ArrayList<Field>();
 
             if (LOG.isDebugEnabled()) {
-                LOG.debug("Class retrieved : {}", cl.getName());
+                LOG.debug("Class retrieved: {}", cl.getName());
             }
 
             for (Field field : cl.getDeclaredFields()) {
                 DataField dataField = field.getAnnotation(DataField.class);
                 if (dataField != null) {
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Position defined in the class : {}, position : {}, Field : {}",
+                        LOG.debug("Position defined in the class: {}, position: {}, Field: {}",
                                 new Object[]{cl.getName(), dataField.pos(), dataField});
                     }
 
@@ -116,14 +116,14 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
                     }
 
                     dataFields.put(dataField.pos(), dataField);
-                    annotedFields.put(dataField.pos(), field);
+                    annotatedFields.put(dataField.pos(), field);
                 }
 
                 Link linkField = field.getAnnotation(Link.class);
 
                 if (linkField != null) {
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Class linked  : {}, Field {}", cl.getName(), field);
+                        LOG.debug("Class linked: {}, Field: {}", cl.getName(), field);
                     }
                     linkFields.add(field);
                 }
@@ -137,9 +137,9 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
             totalFields = numberMandatoryFields + numberOptionalFields;
 
             if (LOG.isDebugEnabled()) {
-                LOG.debug("Number of optional fields : {}", numberOptionalFields);
-                LOG.debug("Number of mandatory fields : {}", numberMandatoryFields);
-                LOG.debug("Total : {}", totalFields);
+                LOG.debug("Number of optional fields: {}", numberOptionalFields);
+                LOG.debug("Number of mandatory fields: {}", numberMandatoryFields);
+                LOG.debug("Total: {}", totalFields);
             }
         }
     }
@@ -153,7 +153,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
 
             // Get DataField from model
             DataField dataField = dataFields.get(pos);
-            ObjectHelper.notNull(dataField, "No position " + pos + " defined for the field : " + data + ", line : " + line);
+            ObjectHelper.notNull(dataField, "No position " + pos + " defined for the field: " + data + ", line: " + line);
 
             if (dataField.trim()) {
                 data = data.trim();
@@ -166,16 +166,16 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
                 // Check if content of the field is empty
                 // This is not possible for mandatory fields
                 if (data.equals("")) {
-                    throw new IllegalArgumentException("The mandatory field defined at the position " + pos + " is empty for the line : " + line);
+                    throw new IllegalArgumentException("The mandatory field defined at the position " + pos + " is empty for the line: " + line);
                 }
             }
 
             // Get Field to be setted
-            Field field = annotedFields.get(pos);
+            Field field = annotatedFields.get(pos);
             field.setAccessible(true);
 
             if (LOG.isDebugEnabled()) {
-                LOG.debug("Pos : {}, Data : {}, Field type : {}", new Object[]{pos, data, field.getType()});
+                LOG.debug("Pos: {}, Data: {}, Field type: {}", new Object[]{pos, data, field.getType()});
             }
 
             Format<?> format;
@@ -196,9 +196,9 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
                 try {
                     value = format.parse(data);
                 } catch (FormatException ie) {
-                    throw new IllegalArgumentException(ie.getMessage() + ", position : " + pos + ", line : " + line, ie);
+                    throw new IllegalArgumentException(ie.getMessage() + ", position: " + pos + ", line: " + line, ie);
                 } catch (Exception e) {
-                    throw new IllegalArgumentException("Parsing error detected for field defined at the position : " + pos + ", line : " + line, e);
+                    throw new IllegalArgumentException("Parsing error detected for field defined at the position: " + pos + ", line: " + line, e);
                 }
             } else {
                 value = getDefaultValueForPrimitive(field.getType());
@@ -210,14 +210,14 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
 
         }
 
-        LOG.debug("Counter mandatory fields : {}", counterMandatoryFields);
+        LOG.debug("Counter mandatory fields: {}", counterMandatoryFields);
 
         if (pos < totalFields) {
-            throw new IllegalArgumentException("Some fields are missing (optional or mandatory), line : " + line);
+            throw new IllegalArgumentException("Some fields are missing (optional or mandatory), line: " + line);
         }
 
         if (counterMandatoryFields < numberMandatoryFields) {
-            throw new IllegalArgumentException("Some mandatory fields are missing, line : " + line);
+            throw new IllegalArgumentException("Some mandatory fields are missing, line: " + line);
         }
 
     }
@@ -234,7 +234,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
         char separator = Converter.getCharDelimitor(this.getSeparator());
 
         if (LOG.isDebugEnabled()) {
-            LOG.debug("Separator converted : '0x{}', from : {}", Integer.toHexString(separator), this.getSeparator());
+            LOG.debug("Separator converted: '0x{}', from: {}", Integer.toHexString(separator), this.getSeparator());
         }
 
         for (Class clazz : models) {
@@ -242,7 +242,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
 
                 Object obj = model.get(clazz.getName());
                 if (LOG.isDebugEnabled()) {
-                    LOG.debug("Model object : {}, class : {}", obj, obj.getClass().getName());
+                    LOG.debug("Model object: {}, class: {}", obj, obj.getClass().getName());
                 }
                 if (obj != null) {
 
@@ -268,7 +268,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
 
                 // For one to one relation
                 // There is only one item in the list
-                String value = (String)val.get(0);
+                String value = val.get(0);
 
                 // Add the value to the temp array
                 if (value != null) {
@@ -331,14 +331,14 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
                     v.add(l.get(idx));
                     index.put(ii, idx);
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Value : {}, pos : {}, at : {}", new Object[]{l.get(idx), ii, idx});
+                        LOG.debug("Value: {}, pos: {}, at: {}", new Object[]{l.get(idx), ii, idx});
                     }
                 } else {
                     v.add(l.get(0));
                     index.put(ii, 0);
                     ++idxSize;
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Value : {}, pos : {}, at index : {}", new Object[]{l.get(0), ii, 0});
+                        LOG.debug("Value: {}, pos: {}, at index: {}", new Object[]{l.get(0), ii, 0});
                     }
                 }
             }
@@ -355,14 +355,10 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
 
     /**
      * 
-     * Generate a table containing the data formated and sorted with their position/offset
+     * Generate a table containing the data formatted and sorted with their position/offset
      * If the model is Ordered than a key is created combining the annotation @Section and Position of the field
-     * If a relation @OneToMany is defined, than we iterate recursivelu through this function
+     * If a relation @OneToMany is defined, than we iterate recursively through this function
      * The result is placed in the Map<Integer, List> results
-     * 
-     * @param clazz
-     * @param obj
-     * @throws Exception
      */
     private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {
 
@@ -393,7 +389,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
                     result = formatString(format, value);
 
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Value to be formatted : {}, position : {}, and its formated value : {}", new Object[]{value, datafield.pos(), result});
+                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result});
                     }
 
                 } else {
@@ -402,7 +398,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
 
                 Integer key;
 
-                if (isMessageOrdered()) {
+                if (isMessageOrdered() && obj != null) {
 
                     // Generate a key using the number of the section
                     // and the position of the field
@@ -411,24 +407,20 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
                     Integer keyGenerated = generateKey(key1, key2);
 
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Key generated : {}, for section : {}", String.valueOf(keyGenerated), key1);
+                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1);
                     }
 
                     key = keyGenerated;
 
                 } else {
-
                     key = datafield.pos();
                 }
 
                 if (!results.containsKey(key)) {
-
                     List<String> list = new LinkedList<String>();
                     list.add(result);
                     results.put(key, list);
-
                 } else {
-
                     List<String> list = results.get(key);
                     list.add(result);
                 }
@@ -443,16 +435,12 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
                 isOneToMany = true;
 
                 ArrayList list = (ArrayList)field.get(obj);
-
                 if (list != null) {
 
                     Iterator it = list.iterator();
-
                     while (it.hasNext()) {
-
                         Object target = it.next();
                         generateCsvPositionMap(target.getClass(), target);
-
                     }
 
                 } else {
@@ -484,7 +472,7 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
             DataField dataField = dataFieldsSorted.get(it.next());
 
             // Retrieve the field
-            Field field = annotedFields.get(dataField.pos());
+            Field field = annotatedFields.get(dataField.pos());
             // Change accessibility to allow to read protected/private fields
             field.setAccessible(true);
 
@@ -518,33 +506,33 @@ public class BindyCsvFactory extends BindyAbstractFactory implements BindyFactor
                 Section section = cl.getAnnotation(Section.class);
 
                 if (record != null) {
-                    LOG.debug("Csv record : {}", record);
+                    LOG.debug("Csv record: {}", record);
 
                     // Get skipFirstLine parameter
                     skipFirstLine = record.skipFirstLine();
-                    LOG.debug("Skip First Line parameter of the CSV : {}" + skipFirstLine);
+                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine);
 
                     // Get generateHeaderColumnNames parameter
                     generateHeaderColumnNames = record.generateHeaderColumns();
-                    LOG.debug("Generate header column names parameter of the CSV : {}", generateHeaderColumnNames);
+                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames);
 
                     // Get Separator parameter
-                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !");
+                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation");
                     separator = record.separator();
-                    LOG.debug("Separator defined for the CSV : {}", separator);
+                    LOG.debug("Separator defined for the CSV: {}", separator);
 
                     // Get carriage return parameter
                     crlf = record.crlf();
-                    LOG.debug("Carriage return defined for the CSV : {}", crlf);
+                    LOG.debug("Carriage return defined for the CSV: {}", crlf);
 
                     // Get isOrdered parameter
                     messageOrdered = record.isOrdered();
-                    LOG.debug("Must CSV record be ordered ? {}", messageOrdered);
+                    LOG.debug("Must CSV record be ordered: {}", messageOrdered);
                 }
 
                 if (section != null) {
                     // Test if section number is not null
-                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !");
+                    ObjectHelper.notNull(section.number(), "No number has been defined for the section");
 
                     // Get section number and add it to the sections
                     sections.put(cl.getName(), section.number());
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyFixedLengthFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyFixedLengthFactory.java
index eec7e1e5e47..e465749fdcd 100644
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyFixedLengthFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyFixedLengthFactory.java
@@ -173,7 +173,7 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
 
             if (offset - 1 <= -1) {
                 throw new IllegalArgumentException("Offset/Position of the field " + dataField.toString()
-                                                   + " cannot be negative!");
+                                                   + " cannot be negative");
             }
 
             token = record.substring(offset - 1, offset + length - 1);
@@ -358,7 +358,7 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
                                 temp.append(generatePaddingChars(padChar, fieldLength, result.length()));
                             } else {
                                 throw new IllegalArgumentException("Alignment for the field: " + field.getName()
-                                        + " must be equal to R for RIGHT or L for LEFT !");
+                                        + " must be equal to R for RIGHT or L for LEFT");
                             }
 
                             result = temp.toString();
@@ -376,7 +376,7 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
 
                     } else {
                         throw new IllegalArgumentException("Length of the field: " + field.getName()
-                                + " is a mandatory field and cannot be equal to zero or to be negative !");
+                                + " is a mandatory field and cannot be equal to zero or to be negative, was: " + fieldLength);
                     }
 
                     if (LOG.isDebugEnabled()) {
@@ -426,31 +426,31 @@ public class BindyFixedLengthFactory extends BindyAbstractFactory implements Bin
             FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);
 
             if (record != null) {
-                LOG.debug("Fixed length record : {}", record);
+                LOG.debug("Fixed length record: {}", record);
 
                 // Get carriage return parameter
                 crlf = record.crlf();
-                LOG.debug("Carriage return defined for the CSV : {}", crlf);
+                LOG.debug("Carriage return defined for the CSV: {}", crlf);
 
                 // Get hasHeader parameter
                 hasHeader = record.hasHeader();
-                LOG.debug("Has Header :  {}", hasHeader);
+                LOG.debug("Has Header: {}", hasHeader);
 
                 // Get hasFooter parameter
                 hasFooter = record.hasFooter();
-                LOG.debug("Has Footer :  {}", hasFooter);
+                LOG.debug("Has Footer: {}", hasFooter);
 
                 // Get padding character
                 paddingChar = record.paddingChar();
-                LOG.debug("Padding char :  {}", paddingChar);
+                LOG.debug("Padding char: {}", paddingChar);
 
                 // Get length of the record
                 recordLength = record.length();
-                LOG.debug("Length of the record : {}", recordLength);
+                LOG.debug("Length of the record: {}", recordLength);
 
                 // Get length of the record
                 recordLength = record.length();
-                LOG.debug("Length of the record : {}", recordLength);
+                LOG.debug("Length of the record: {}", recordLength);
             }
         }
     }
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyKeyValuePairFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyKeyValuePairFactory.java
index d3cc9c57183..ad407364c5b 100644
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyKeyValuePairFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyKeyValuePairFactory.java
@@ -49,7 +49,7 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
     private static final transient Logger LOG = LoggerFactory.getLogger(BindyKeyValuePairFactory.class);
 
     private Map<Integer, KeyValuePairField> keyValuePairFields = new LinkedHashMap<Integer, KeyValuePairField>();
-    private Map<Integer, Field> annotedFields = new LinkedHashMap<Integer, Field>();
+    private Map<Integer, Field> annotatedFields = new LinkedHashMap<Integer, Field>();
     private Map<String, Integer> sections = new HashMap<String, Integer>();
 
     private Map<String, List<Object>> lists = new HashMap<String, List<Object>>();
@@ -97,7 +97,7 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
                         LOG.debug("Key declared in the class : {}, key : {}, Field : {}", new Object[]{cl.getName(), keyValuePairField.tag(), keyValuePairField});
                     }
                     keyValuePairFields.put(keyValuePairField.tag(), keyValuePairField);
-                    annotedFields.put(keyValuePairField.tag(), field);
+                    annotatedFields.put(keyValuePairField.tag(), field);
                 }
 
                 Link linkField = field.getAnnotation(Link.class);
@@ -138,25 +138,25 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
             // Get KeyValuePair
             String[] keyValuePair = s.split(getKeyValuePairSeparator());
 
-            // Extract Key
-            int key = Integer.parseInt(keyValuePair[0]);
+            // Extract only if value is populated in key:value pair in incoming message.
+            if (keyValuePair.length > 1) {
+                // Extract Key
+                int key = Integer.parseInt(keyValuePair[0]);
 
-            // Extract key value
-            String value = keyValuePair[1];
+                // Extract key value
+                String value = keyValuePair[1];
 
-            LOG.debug("Key : {}, value : {}", key, value);
+                LOG.debug("Key: {}, value: {}", key, value);
 
-            // Add value to the Map using key value as key
-            if (!results.containsKey(key)) {
-
-                List<String> list = new LinkedList<String>();
-                list.add(value);
-                results.put(key, list);
-
-            } else {
-
-                List<String> list = results.get(key);
-                list.add(value);
+                // Add value to the Map using key value as key
+                if (!results.containsKey(key)) {
+                    List<String> list = new LinkedList<String>();
+                    list.add(value);
+                    results.put(key, list);
+                } else {
+                    List<String> list = results.get(key);
+                    list.add(value);
+                }
             }
 
         }
@@ -176,13 +176,6 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
 
     }
 
-    /**
-     * @param clazz
-     * @param obj
-     * @param results
-     * @param line
-     * @throws Exception
-     */
     private void generateModelFromKeyValueMap(Class clazz, Object obj, Map<Integer, List<String>> results, int line) throws Exception {
 
         for (Field field : clazz.getDeclaredFields()) {
@@ -339,7 +332,7 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
                                             field.set(obj, getDefaultValueForPrimitive(field.getType()));
                                         }
                                     } catch (Exception e) {
-                                        throw new IllegalArgumentException("Setting of field " + field + " failed for object : " + obj + " and result : " + result);
+                                        throw new IllegalArgumentException("Setting of field " + field + " failed for object: " + obj + " and result: " + result);
                                     }
 
                                     // Add object created to the list
@@ -357,7 +350,7 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
                                 }
 
                             } else {
-                                throw new IllegalArgumentException("The list of values is empty for the following key : " + key + " defined in the class : " + clazz.getName());
+                                throw new IllegalArgumentException("The list of values is empty for the following key: " + key + " defined in the class: " + clazz.getName());
                             }
                         }
 
@@ -369,7 +362,7 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
                         try {
                             field.set(obj, result);
                         } catch (Exception e) {
-                            throw new IllegalArgumentException("Setting of field " + field + " failed for object : " + obj + " and result : " + result);
+                            throw new IllegalArgumentException("Setting of field " + field + " failed for object: " + obj + " and result: " + result);
                         }
                     }
                 }
@@ -401,7 +394,7 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
                     field.set(obj, lists.get(cl.getName()));
 
                 } else {
-                    throw new IllegalArgumentException("No target class has been defined in @OneToMany annotation !");
+                    throw new IllegalArgumentException("No target class has been defined in @OneToMany annotation");
                 }
 
             }
@@ -431,21 +424,21 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
         char separator = Converter.getCharDelimitor(this.getPairSeparator());
 
         if (LOG.isDebugEnabled()) {
-            LOG.debug("Separator converted : '0x{}', from : {}", Integer.toHexString(separator), this.getPairSeparator());
+            LOG.debug("Separator converted: '0x{}', from: {}", Integer.toHexString(separator), this.getPairSeparator());
         }
 
         while (it.hasNext()) {
 
             KeyValuePairField keyValuePairField = keyValuePairFieldsSorted.get(it.next());
-            ObjectHelper.notNull(keyValuePairField, "KeyValuePair is null !");
+            ObjectHelper.notNull(keyValuePairField, "KeyValuePair");
 
             // Retrieve the field
-            Field field = annotedFields.get(keyValuePairField.tag());
+            Field field = annotatedFields.get(keyValuePairField.tag());
             // Change accessibility to allow to read protected/private fields
             field.setAccessible(true);
 
             if (LOG.isDebugEnabled()) {
-                LOG.debug("Tag : {}, Field type : {}, class : {}", new Object[]{keyValuePairField.tag(), field.getType(), field.getDeclaringClass().getName()});
+                LOG.debug("Tag: {}, Field type: {}, class: {}", new Object[]{keyValuePairField.tag(), field.getType(), field.getDeclaringClass().getName()});
             }
 
             // Retrieve the format, pattern and precision associated to the type
@@ -471,31 +464,31 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
                     Integer key1 = sections.get(obj.getClass().getName());
                     Integer key2 = keyValuePairField.position();
                     
-                    LOG.debug("Key of the section : {}, and the field  : {}", key1, key2);
+                    LOG.debug("Key of the section: {}, and the field: {}", key1, key2);
                  
                     Integer keyGenerated = generateKey(key1, key2);
 
                     if (LOG.isDebugEnabled()) {
-                        LOG.debug("Key generated : {}, for section : {}", String.valueOf(keyGenerated), key1);
+                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1);
                     }
 
                     // Add value to the list if not null
                     if (keyValue != null) {
 
                         // Format field value
-                        String valueFormated;
+                        String valueFormatted;
 
                         try {
-                            valueFormated = format.format(keyValue);
+                            valueFormatted = format.format(keyValue);
                         } catch (Exception e) {
-                            throw new IllegalArgumentException("Formating error detected for the tag : " + keyValuePairField.tag(), e);
+                            throw new IllegalArgumentException("Formatting error detected for the tag: " + keyValuePairField.tag(), e);
                         }
 
                         // Create the key value string
-                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormated;
+                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted;
 
                         if (LOG.isDebugEnabled()) {
-                            LOG.debug("Value to be formatted : {}, for the tag : {}, and its formated value : {}", new Object[]{keyValue, keyValuePairField.tag(), valueFormated});
+                            LOG.debug("Value to be formatted: {}, for the tag: {}, and its formatted value: {}", new Object[]{keyValue, keyValuePairField.tag(), valueFormatted});
                         }
 
                         // Add the content to the TreeMap according to the
@@ -503,7 +496,7 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
                         positions.put(keyGenerated, value);
 
                         if (LOG.isDebugEnabled()) {
-                            LOG.debug("Positions size : {}", positions.size());
+                            LOG.debug("Positions size: {}", positions.size());
                         }
                     }
                 } else {
@@ -512,22 +505,22 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
                     if (keyValue != null) {
 
                         // Format field value
-                        String valueFormated;
+                        String valueFormatted;
 
                         try {
-                            valueFormated = format.format(keyValue);
+                            valueFormatted = format.format(keyValue);
                         } catch (Exception e) {
-                            throw new IllegalArgumentException("Formating error detected for the tag : " + keyValuePairField.tag(), e);
+                            throw new IllegalArgumentException("Formatting error detected for the tag: " + keyValuePairField.tag(), e);
                         }
 
                         // Create the key value string
-                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormated + separator;
+                        String value = keyValuePairField.tag() + this.getKeyValuePairSeparator() + valueFormatted + separator;
 
                         // Add content to the stringBuilder
                         builder.append(value);
 
                         if (LOG.isDebugEnabled()) {
-                            LOG.debug("Value added : {}{}{}{}", new Object[]{keyValuePairField.tag(), this.getKeyValuePairSeparator(), valueFormated, separator});
+                            LOG.debug("Value added: {}{}{}{}", new Object[]{keyValuePairField.tag(), this.getKeyValuePairSeparator(), valueFormatted, separator});
                         }
                     }
                 }
@@ -564,7 +557,7 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
             try {
                 obj = format.parse(value);
             } catch (Exception e) {
-                throw new IllegalArgumentException("Parsing error detected for field defined at the tag : " + tag + ", line : " + line, e);
+                throw new IllegalArgumentException("Parsing error detected for field defined at the tag: " + tag + ", line: " + line, e);
             }
 
         }
@@ -610,27 +603,27 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
 
                 if (message != null) {
                     // Get Pair Separator parameter
-                    ObjectHelper.notNull(message.pairSeparator(), "No Pair Separator has been defined in the @Message annotation !");
+                    ObjectHelper.notNull(message.pairSeparator(), "No Pair Separator has been defined in the @Message annotation");
                     pairSeparator = message.pairSeparator();
-                    LOG.debug("Pair Separator defined for the message : {}", pairSeparator);
+                    LOG.debug("Pair Separator defined for the message: {}", pairSeparator);
 
                     // Get KeyValuePair Separator parameter
-                    ObjectHelper.notNull(message.keyValuePairSeparator(), "No Key Value Pair Separator has been defined in the @Message annotation !");
+                    ObjectHelper.notNull(message.keyValuePairSeparator(), "No Key Value Pair Separator has been defined in the @Message annotation");
                     keyValuePairSeparator = message.keyValuePairSeparator();
-                    LOG.debug("Key Value Pair Separator defined for the message : {}", keyValuePairSeparator);
+                    LOG.debug("Key Value Pair Separator defined for the message: {}", keyValuePairSeparator);
 
                     // Get carriage return parameter
                     crlf = message.crlf();
-                    LOG.debug("Carriage return defined for the message : {}", crlf);
+                    LOG.debug("Carriage return defined for the message: {}", crlf);
 
-                    // Get isOrderer parameter
+                    // Get isOrdered parameter
                     messageOrdered = message.isOrdered();
-                    LOG.debug("Is the message ordered in output : {}", messageOrdered);
+                    LOG.debug("Is the message ordered in output: {}", messageOrdered);
                 }
 
                 if (section != null) {
                     // Test if section number is not null
-                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !");
+                    ObjectHelper.notNull(section.number(), "No number has been defined for the section");
 
                     // Get section number and add it to the sections
                     sections.put(cl.getName(), section.number());
@@ -638,4 +631,5 @@ public class BindyKeyValuePairFactory extends BindyAbstractFactory implements Bi
             }
         }
     }
+
 }
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/FormatFactory.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/FormatFactory.java
index 6cfe5142490..8f3780d0e55 100755
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/FormatFactory.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/FormatFactory.java
@@ -51,7 +51,7 @@ public final class FormatFactory {
      * Retrieves the format to use for the given type
      * 
      * @param clazz represents the type of the format (String, Integer, Byte)
-     * @param pattern is the pattern to be used during the formating of the data
+     * @param pattern is the pattern to be used during the formatting of the data
      * @param locale optional locale for NumberFormat and DateFormat parsing.
      * @param precision optional scale for BigDecimal parsing.
      * @return Format the formatter
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/csv/BindyCsvDataFormat.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/csv/BindyCsvDataFormat.java
index 00d0b1e25fd..426df3ac3aa 100755
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/csv/BindyCsvDataFormat.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/csv/BindyCsvDataFormat.java
@@ -156,7 +156,7 @@ public class BindyCsvDataFormat extends BindyAbstractDataFormat {
                 result = unquoteTokens(result);
 
                 if (result.size() == 0 || result.isEmpty()) {
-                    throw new java.lang.IllegalArgumentException("No records have been defined in the CSV !");
+                    throw new java.lang.IllegalArgumentException("No records have been defined in the CSV");
                 }
 
                 if (result.size() > 0) {
@@ -173,14 +173,14 @@ public class BindyCsvDataFormat extends BindyAbstractDataFormat {
                     // Add objects graph to the list
                     models.add(model);
 
-                    LOG.debug("Graph of objects created : {}", model);
+                    LOG.debug("Graph of objects created: {}", model);
                 }
             }
 
             // Test if models list is empty or not
             // If this is the case (correspond to an empty stream, ...)
             if (models.size() == 0) {
-                throw new java.lang.IllegalArgumentException("No records have been defined in the CSV !");
+                throw new java.lang.IllegalArgumentException("No records have been defined in the CSV");
             } else {
                 return models;
             }
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/fixed/BindyFixedLengthDataFormat.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/fixed/BindyFixedLengthDataFormat.java
index 2e4a106561e..ddbf521c9df 100644
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/fixed/BindyFixedLengthDataFormat.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/fixed/BindyFixedLengthDataFormat.java
@@ -131,7 +131,7 @@ public class BindyFixedLengthDataFormat implements DataFormat {
                 // Check if the record length corresponds to the parameter
                 // provided in the @FixedLengthRecord
                 if ((line.length() < factory.recordLength()) || (line.length() > factory.recordLength())) {
-                    throw new java.lang.IllegalArgumentException("Size of the record : " + line.length() + " is not equal to the value provided in the model : " + factory.recordLength() + " !");
+                    throw new java.lang.IllegalArgumentException("Size of the record: " + line.length() + " is not equal to the value provided in the model: " + factory.recordLength());
                 }
 
                 // Create POJO where Fixed data will be stored
@@ -146,13 +146,13 @@ public class BindyFixedLengthDataFormat implements DataFormat {
                 // Add objects graph to the list
                 models.add(model);
 
-                LOG.debug("Graph of objects created : {}", model);
+                LOG.debug("Graph of objects created: {}", model);
             }
 
             // Test if models list is empty or not
             // If this is the case (correspond to an empty stream, ...)
             if (models.size() == 0) {
-                throw new java.lang.IllegalArgumentException("No records have been defined in the message !");
+                throw new java.lang.IllegalArgumentException("No records have been defined in the message");
             } else {
                 return models;
             }
diff --git a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/kvp/BindyKeyValuePairDataFormat.java b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/kvp/BindyKeyValuePairDataFormat.java
index a12d8bedf26..e28848dccba 100644
--- a/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/kvp/BindyKeyValuePairDataFormat.java
+++ b/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/kvp/BindyKeyValuePairDataFormat.java
@@ -111,7 +111,7 @@ public class BindyKeyValuePairDataFormat extends BindyAbstractDataFormat {
                 List<String> result = Arrays.asList(line.split(separator));
 
                 if (result.size() == 0 || result.isEmpty()) {
-                    throw new java.lang.IllegalArgumentException("No records have been defined in the KVP !");
+                    throw new java.lang.IllegalArgumentException("No records have been defined in the KVP");
                 }
 
                 if (result.size() > 0) {
@@ -125,14 +125,14 @@ public class BindyKeyValuePairDataFormat extends BindyAbstractDataFormat {
                     // Add objects graph to the list
                     models.add(model);
 
-                    LOG.debug("Graph of objects created : {}", model);
+                    LOG.debug("Graph of objects created: {}", model);
                 }
             }
 
             // Test if models list is empty or not
             // If this is the case (correspond to an empty stream, ...)
             if (models.size() == 0) {
-                throw new java.lang.IllegalArgumentException("No records have been defined in the KVP !");
+                throw new java.lang.IllegalArgumentException("No records have been defined in the KVP");
             } else {
                 return models;
             }
diff --git a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallBadIntegerTest.java b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallBadIntegerTest.java
index 6581017cb28..168424c71fa 100644
--- a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallBadIntegerTest.java
+++ b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallBadIntegerTest.java
@@ -95,7 +95,7 @@ public class BindySimpleCsvUnmarshallBadIntegerTest extends AbstractJUnit4Spring
         // and check that we have the caused exception stored
         Exception cause = error.getReceivedExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);
         TestSupport.assertIsInstanceOf(Exception.class, cause.getCause());
-        assertEquals("String provided does not fit the Integer pattern defined or is not parseable, position : 1, line : 1", cause.getMessage());
+        assertEquals("String provided does not fit the Integer pattern defined or is not parseable, position: 1, line: 1", cause.getMessage());
 
     }
 
diff --git a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallPositionModifiedTest.java b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallPositionModifiedTest.java
index 8cd02853f75..4e0b613b60c 100644
--- a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallPositionModifiedTest.java
+++ b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallPositionModifiedTest.java
@@ -83,7 +83,7 @@ public class BindySimpleCsvUnmarshallPositionModifiedTest extends AbstractJUnit4
         // and check that we have the caused exception stored
         Exception cause = error.getReceivedExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);
         TestSupport.assertIsInstanceOf(FormatException.class, cause.getCause());
-        assertEquals("Date provided does not fit the pattern defined, position : 11, line : 1", cause.getMessage());
+        assertEquals("Date provided does not fit the pattern defined, position: 11, line: 1", cause.getMessage());
 
     }
 
diff --git a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallTest.java b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallTest.java
index 30b8bf39be8..962ed520dff 100755
--- a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallTest.java
+++ b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallTest.java
@@ -96,7 +96,7 @@ public class BindySimpleCsvUnmarshallTest extends AbstractJUnit4SpringContextTes
         // and check that we have the caused exception stored
         Exception cause = error.getReceivedExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);
         TestSupport.assertIsInstanceOf(FormatException.class, cause.getCause());
-        assertEquals("Date provided does not fit the pattern defined, position : 11, line : 1", cause.getMessage());
+        assertEquals("Date provided does not fit the pattern defined, position: 11, line: 1", cause.getMessage());
 
     }
     
diff --git a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fix/BindySimpleKeyValuePairWithoutSectionMarshallDslTest.java b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fix/BindySimpleKeyValuePairWithoutSectionMarshallDslTest.java
index d0b549a0659..2c259981d4f 100644
--- a/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fix/BindySimpleKeyValuePairWithoutSectionMarshallDslTest.java
+++ b/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/fix/BindySimpleKeyValuePairWithoutSectionMarshallDslTest.java
@@ -74,7 +74,7 @@ public class BindySimpleKeyValuePairWithoutSectionMarshallDslTest extends Abstra
         Exchange exch = error.getReceivedExchanges().get(0);
         Exception cause = exch.getProperty(Exchange.EXCEPTION_CAUGHT, IllegalArgumentException.class);
         assertNotNull(cause);
-        assertEquals("@Section and/or @KeyValuePairDataField have not been defined!", cause.getMessage());
+        assertEquals("@Section and/or @KeyValuePairDataField have not been defined", cause.getMessage());
     }
 
     public List<Map<String, Object>> generateModel() {
