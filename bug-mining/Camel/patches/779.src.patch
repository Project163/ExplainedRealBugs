diff --git a/camel-core/src/main/java/org/apache/camel/builder/xml/MessageVariableResolver.java b/camel-core/src/main/java/org/apache/camel/builder/xml/MessageVariableResolver.java
index 89dccfddcb9..41b92e26012 100644
--- a/camel-core/src/main/java/org/apache/camel/builder/xml/MessageVariableResolver.java
+++ b/camel-core/src/main/java/org/apache/camel/builder/xml/MessageVariableResolver.java
@@ -35,22 +35,20 @@ import static org.apache.camel.builder.xml.Namespaces.SYSTEM_PROPERTIES_NAMESPAC
 
 /**
  * A variable resolver for XPath expressions which support properties on the
- * messge, exchange as well as making system properties and environment
+ * message, exchange as well as making system properties and environment
  * properties available.
+ * <p/>
+ * Implementations of this resolver must be thread safe
  *
  * @version $Revision$
  */
 public class MessageVariableResolver implements XPathVariableResolver {
     private static final transient Log LOG = LogFactory.getLog(MessageVariableResolver.class);
 
-    private Exchange exchange;
     private Map<String, Object> variables = new HashMap<String, Object>();
+    private final ThreadLocal<Exchange> exchange;
 
-    public Exchange getExchange() {
-        return exchange;
-    }
-
-    public void setExchange(Exchange exchange) {
+    public MessageVariableResolver(ThreadLocal<Exchange> exchange) {
         this.exchange = exchange;
     }
 
@@ -59,7 +57,7 @@ public class MessageVariableResolver implements XPathVariableResolver {
         String localPart = name.getLocalPart();
         Object answer = null;
 
-        Message in = exchange.getIn();
+        Message in = exchange.get().getIn();
         if (uri == null || uri.length() == 0) {
             answer = variables.get(localPart);
             if (answer == null) {
@@ -68,28 +66,27 @@ public class MessageVariableResolver implements XPathVariableResolver {
                     answer = message.getHeader(localPart);
                 }
                 if (answer == null) {
-                    answer = exchange.getProperty(localPart);
+                    answer = exchange.get().getProperty(localPart);
                 }
             }
         } else if (uri.equals(SYSTEM_PROPERTIES_NAMESPACE)) {
             try {
                 answer = System.getProperty(localPart);
             } catch (Exception e) {
-                LOG.debug("Security exception evaluating system property: " + localPart
-                          + ". Reason: " + e, e);
+                LOG.debug("Security exception evaluating system property: " + localPart + ". Reason: " + e, e);
             }
         } else if (uri.equals(ENVIRONMENT_VARIABLES)) {
             answer = System.getenv().get(localPart);
         } else if (uri.equals(EXCHANGE_PROPERTY)) {
-            answer = exchange.getProperty(localPart);
+            answer = exchange.get().getProperty(localPart);
         } else if (uri.equals(IN_NAMESPACE)) {
             answer = in.getHeader(localPart);
             if (answer == null && localPart.equals("body")) {
                 answer = in.getBody();
             }
         } else if (uri.equals(OUT_NAMESPACE)) {
-            if (exchange.hasOut()) {
-                Message out = exchange.getOut();
+            if (exchange.get().hasOut()) {
+                Message out = exchange.get().getOut();
                 answer = out.getHeader(localPart);
                 if (answer == null && localPart.equals("body")) {
                     answer = out.getBody();
diff --git a/camel-core/src/main/java/org/apache/camel/builder/xml/XPathBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/xml/XPathBuilder.java
index abf1b3df73a..3ada715e0b5 100644
--- a/camel-core/src/main/java/org/apache/camel/builder/xml/XPathBuilder.java
+++ b/camel-core/src/main/java/org/apache/camel/builder/xml/XPathBuilder.java
@@ -19,6 +19,8 @@ package org.apache.camel.builder.xml;
 import java.io.StringReader;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 import javax.xml.namespace.QName;
 import javax.xml.transform.dom.DOMSource;
@@ -43,10 +45,14 @@ import org.apache.camel.Expression;
 import org.apache.camel.Message;
 import org.apache.camel.Predicate;
 import org.apache.camel.RuntimeExpressionException;
+import org.apache.camel.Service;
 import org.apache.camel.spi.NamespaceAware;
 import org.apache.camel.util.ExchangeHelper;
 import org.apache.camel.util.MessageHelper;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
 import static org.apache.camel.builder.xml.Namespaces.DEFAULT_NAMESPACE;
 import static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;
 import static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;
@@ -55,13 +61,24 @@ import static org.apache.camel.builder.xml.Namespaces.isMatchingNamespaceOrEmpty
 /**
  * Creates an XPath expression builder which creates a nodeset result by default.
  * If you want to evaluate a String expression then call {@link #stringResult()}
+ * <p/>
+ * An XPath object is not thread-safe and not reentrant. In other words, it is the application's responsibility to make
+ * sure that one XPath object is not used from more than one thread at any given time, and while the evaluate method
+ * is invoked, applications may not recursively call the evaluate method.
+ * <p/>
+ * This implementation is thread safe by using thread locals and pooling to allow concurrency
  *
  * @see XPathConstants#NODESET
  *
  * @version $Revision$
  */
-public class XPathBuilder implements Expression, Predicate, NamespaceAware {
+public class XPathBuilder implements Expression, Predicate, NamespaceAware, Service {
+    private static final transient Log LOG = LogFactory.getLog(XPathBuilder.class);
+    private final Queue<XPathExpression> pool = new ConcurrentLinkedQueue<XPathExpression>();
     private final String text;
+    private final ThreadLocal<MessageVariableResolver> variableResolver = new ThreadLocal<MessageVariableResolver>();
+    private final ThreadLocal<Exchange> exchange = new ThreadLocal<Exchange>();
+
     private XPathFactory xpathFactory;
     private Class<?> documentType = Document.class;
     // For some reason the default expression of "a/b" on a document such as
@@ -73,9 +90,6 @@ public class XPathBuilder implements Expression, Predicate, NamespaceAware {
     private String objectModelUri;
     private DefaultNamespaceContext namespaceContext;
     private XPathFunctionResolver functionResolver;
-    private XPathExpression expression;
-    private MessageVariableResolver variableResolver = new MessageVariableResolver();
-    private Exchange exchange;
     private XPathFunction bodyFunction;
     private XPathFunction headerFunction;
     private XPathFunction outBodyFunction;
@@ -242,7 +256,7 @@ public class XPathBuilder implements Expression, Predicate, NamespaceAware {
      * from XPath expressions
      */
     public XPathBuilder variable(String name, Object value) {
-        variableResolver.addVariable(name, value);
+        getVariableResolver().addVariable(name, value);
         return this;
     }
 
@@ -307,14 +321,6 @@ public class XPathBuilder implements Expression, Predicate, NamespaceAware {
         this.functionResolver = functionResolver;
     }
 
-    public XPathExpression getExpression() throws XPathFactoryConfigurationException,
-        XPathExpressionException {
-        if (expression == null) {
-            expression = createXPathExpression();
-        }
-        return expression;
-    }
-
     public void setNamespaces(Map<String, String> namespaces) {
         getNamespaceContext().setNamespaces(namespaces);
     }
@@ -326,7 +332,7 @@ public class XPathBuilder implements Expression, Predicate, NamespaceAware {
                     if (exchange == null) {
                         return null;
                     }
-                    return exchange.getIn().getBody();
+                    return exchange.get().getIn().getBody();
                 }
             };
         }
@@ -344,7 +350,7 @@ public class XPathBuilder implements Expression, Predicate, NamespaceAware {
                     if (exchange != null && !list.isEmpty()) {
                         Object value = list.get(0);
                         if (value != null) {
-                            return exchange.getIn().getHeader(value.toString());
+                            return exchange.get().getIn().getHeader(value.toString());
                         }
                     }
                     return null;
@@ -362,8 +368,8 @@ public class XPathBuilder implements Expression, Predicate, NamespaceAware {
         if (outBodyFunction == null) {
             outBodyFunction = new XPathFunction() {
                 public Object evaluate(List list) throws XPathFunctionException {
-                    if (exchange != null && exchange.hasOut()) {
-                        return exchange.getOut().getBody();
+                    if (exchange.get() != null && exchange.get().hasOut()) {
+                        return exchange.get().getOut().getBody();
                     }
                     return null;
                 }
@@ -380,10 +386,10 @@ public class XPathBuilder implements Expression, Predicate, NamespaceAware {
         if (outHeaderFunction == null) {
             outHeaderFunction = new XPathFunction() {
                 public Object evaluate(List list) throws XPathFunctionException {
-                    if (exchange != null && !list.isEmpty()) {
+                    if (exchange.get() != null && !list.isEmpty()) {
                         Object value = list.get(0);
                         if (value != null) {
-                            return exchange.getOut().getHeader(value.toString());
+                            return exchange.get().getOut().getHeader(value.toString());
                         }
                     }
                     return null;
@@ -422,49 +428,77 @@ public class XPathBuilder implements Expression, Predicate, NamespaceAware {
     /**
      * Evaluates the expression as the given result type
      */
-    protected synchronized Object evaluateAs(Exchange exchange, QName resultQName) {
-        this.exchange = exchange;
-        variableResolver.setExchange(exchange);
+    protected Object evaluateAs(Exchange exchange, QName resultQName) {
+        // pool a pre compiled expression from pool
+        XPathExpression xpathExpression = pool.poll();
+        if (xpathExpression == null) {
+            LOG.trace("Creating new XPathExpression as none was available from pool");
+            // no avail in pool then create one
+            try {
+                xpathExpression = createXPathExpression();
+            } catch (Exception e) {
+                throw new RuntimeExpressionException("Cannot create xpath expression", e);
+            }
+        } else {
+            LOG.trace("Acquired XPathExpression from pool");
+        }
+        try {
+            return doInEvaluateAs(xpathExpression, exchange, resultQName);
+        } finally {
+            // release it back to the pool
+            pool.add(xpathExpression);
+            LOG.trace("Released XPathExpression back to pool");
+        }
+    }
+
+    protected Object doInEvaluateAs(XPathExpression xpathExpression, Exchange exchange, QName resultQName) {
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Evaluating exchange: " + exchange + " as: " + resultQName);
+        }
+
+        Object answer;
+
+        // set exchange and variable resolver as thread locals for concurrency
+        this.exchange.set(exchange);
+
         try {
             Object document = getDocument(exchange);
             if (resultQName != null) {
                 if (document instanceof InputSource) {
-                    InputSource inputSource = (InputSource)document;
-                    return getExpression().evaluate(inputSource, resultQName);
+                    InputSource inputSource = (InputSource) document;
+                    answer = xpathExpression.evaluate(inputSource, resultQName);
                 } else if (document instanceof DOMSource) {
                     DOMSource source = (DOMSource) document;
-                    return getExpression().evaluate(source.getNode(), resultQName);
+                    answer = xpathExpression.evaluate(source.getNode(), resultQName);
                 } else {
-                    return getExpression().evaluate(document, resultQName);
+                    answer = xpathExpression.evaluate(document, resultQName);
                 }
             } else {
                 if (document instanceof InputSource) {
-                    InputSource inputSource = (InputSource)document;
-                    return getExpression().evaluate(inputSource);
+                    InputSource inputSource = (InputSource) document;
+                    answer = xpathExpression.evaluate(inputSource);
                 } else if (document instanceof DOMSource) {
-                    DOMSource source = (DOMSource)document;
-                    return getExpression().evaluate(source.getNode());
+                    DOMSource source = (DOMSource) document;
+                    answer = xpathExpression.evaluate(source.getNode());
                 } else {
-                    return getExpression().evaluate(document);
+                    answer = xpathExpression.evaluate(document);
                 }
             }
         } catch (XPathExpressionException e) {
             throw new InvalidXPathExpression(getText(), e);
-        } catch (XPathFactoryConfigurationException e) {
-            throw new InvalidXPathExpression(getText(), e);
         }
+
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Done evaluating exchange: " + exchange + " as: " + resultQName + " with result: " + answer);
+        }
+        return answer;
     }
 
-    protected XPathExpression createXPathExpression() throws XPathExpressionException,
-        XPathFactoryConfigurationException {
+    protected XPathExpression createXPathExpression() throws XPathExpressionException, XPathFactoryConfigurationException {
         XPath xPath = getXPathFactory().newXPath();
 
-        // lets now clear any factory references to avoid keeping them around
-        xpathFactory = null;
-
         xPath.setNamespaceContext(getNamespaceContext());
-
-        xPath.setXPathVariableResolver(variableResolver);
+        xPath.setXPathVariableResolver(getVariableResolver());
 
         XPathFunctionResolver parentResolver = getFunctionResolver();
         if (parentResolver == null) {
@@ -545,9 +579,25 @@ public class XPathBuilder implements Expression, Predicate, NamespaceAware {
         if (answer instanceof String) {
             answer = new InputSource(new StringReader(answer.toString()));
         }
-        
+
         // call the reset if the in message body is StreamCache
         MessageHelper.resetStreamCache(exchange.getIn());
         return answer;
     }
+
+    private MessageVariableResolver getVariableResolver() {
+        MessageVariableResolver resolver = variableResolver.get();
+        if (resolver == null) {
+            resolver = new MessageVariableResolver(exchange);
+            variableResolver.set(resolver);
+        }
+        return resolver;
+    }
+
+    public void start() throws Exception {
+    }
+
+    public void stop() throws Exception {
+        pool.clear();
+    }
 }
diff --git a/camel-core/src/test/java/org/apache/camel/language/XPathRouteConcurrentBigTest.java b/camel-core/src/test/java/org/apache/camel/language/XPathRouteConcurrentBigTest.java
new file mode 100644
index 00000000000..2022a2674b5
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/language/XPathRouteConcurrentBigTest.java
@@ -0,0 +1,126 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.language;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * @version $Revision$
+ */
+public class XPathRouteConcurrentBigTest extends ContextTestSupport {
+
+    private static final transient Log LOG = LogFactory.getLog(XPathRouteConcurrentBigTest.class);
+
+    private static final String XMLTEST1 =
+            "<message><messageType>AAA</messageType><sender>0123456789101112131415</sender>"
+            + "<rawData>Uyw7TSVkUMxUyw7TSgGUMQAyw7TSVkUMxUyA7TSgGUMQAyw7TSVkUMxUyA</rawData>"
+            + "<sentDate>2009-10-12T12:22:02+02:00</sentDate> <receivedDate>2009-10-12T12:23:31.248+02:00</receivedDate>"
+            + "<intproperty>1</intproperty><stringproperty>aaaaaaabbbbbbbccccccccdddddddd</stringproperty></message>";
+    private static final String XMLTEST2 =
+            "<message><messageType>AAB</messageType><sender>0123456789101112131415</sender>"
+            + "<rawData>Uyw7TSVkUMxUyw7TSgGUMQAyw7TSVkUMxUyA7TSgGUMQAyw7TSVkUMxUyA</rawData>"
+            + "<sentDate>2009-10-12T12:22:02+02:00</sentDate> <receivedDate>2009-10-12T12:23:31.248+02:00</receivedDate>"
+            + "<intproperty>1</intproperty><stringproperty>aaaaaaabbbbbbbccccccccdddddddd</stringproperty></message>";
+    private static final String XMLTEST3 =
+            "<message><messageType>ZZZ</messageType><sender>0123456789101112131415</sender>"
+            + "<rawData>Uyw7TSVkUMxUyw7TSgGUMQAyw7TSVkUMxUyA7TSgGUMQAyw7TSVkUMxUyA</rawData>"
+            + "<sentDate>2009-10-12T12:22:02+02:00</sentDate> <receivedDate>2009-10-12T12:23:31.248+02:00</receivedDate>"
+            + "<intproperty>1</intproperty><stringproperty>aaaaaaabbbbbbbccccccccdddddddd</stringproperty></message>";
+
+    public void testConcurrent() throws Exception {
+        doSendMessages(999);
+    }
+
+    private void doSendMessages(int messageCount) throws Exception {
+        LOG.info("Sending " + messageCount + " messages");
+
+        int forResult = (messageCount * 2 / 3) + messageCount % 3;
+        int forOther = messageCount - forResult;
+
+        long now = System.currentTimeMillis();
+
+        getMockEndpoint("mock:result").expectedMessageCount(forResult);
+        getMockEndpoint("mock:other").expectedMessageCount(forOther);
+
+        for (int i = 0; i < messageCount; i++) {
+            switch (i % 3) {
+            case 0:
+                template.sendBody("seda:foo", XMLTEST1);
+                break;
+            case 1:
+                template.sendBody("seda:foo", XMLTEST2);
+                break;
+            case 2:
+                template.sendBody("seda:foo", XMLTEST3);
+                break;
+            default:
+                break;
+            }
+        }
+
+        LOG.info("Sent " + messageCount + " messages in " + (System.currentTimeMillis() - now) + " ms");
+
+        assertMockEndpointsSatisfied();
+
+        LOG.info("Processed " + messageCount + " messages in " + (System.currentTimeMillis() - now) + " ms");
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("seda:foo?concurrentConsumers=50&size=250000").choice()
+                    .when()
+                        .xpath("//messageType = 'AAA' or "
+                                + "//messageType = 'AAB' or "
+                                + "//messageType = 'AAC' or "
+                                + "//messageType = 'AAD' or "
+                                + "//messageType = 'AAE' or "
+                                + "//messageType = 'AAF' or "
+                                + "//messageType = 'AAG' or "
+                                + "//messageType = 'AAH' or "
+                                + "//messageType = 'AAI' or "
+                                + "//messageType = 'AAJ' or "
+                                + "//messageType = 'AAK' or "
+                                + "//messageType = 'AAL' or "
+                                + "//messageType = 'AAM' or "
+                                + "//messageType = 'AAN' or "
+                                + "//messageType = 'AAO' or "
+                                + "//messageType = 'AAP' or "
+                                + "//messageType = 'AAQ' or "
+                                + "//messageType = 'AAR' or "
+                                + "//messageType = 'AAS' or "
+                                + "//messageType = 'AAT' or "
+                                + "//messageType = 'AAU' or "
+                                + "//messageType = 'AAV' or "
+                                + "//messageType = 'AAW' or "
+                                + "//messageType = 'AAX' or "
+                                + "//messageType = 'AAY' or "
+                                + "//messageType = 'AAZ'")
+                        .to("mock:result")
+                    .otherwise()
+                        .to("mock:other")
+                    .end();
+            }
+        };
+    }
+
+}
\ No newline at end of file
