diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java
index 90ea447bfa5..134360e0e19 100644
--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java
+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java
@@ -694,11 +694,12 @@ public class DefaultCamelContext extends ServiceSupport implements CamelContext,
     }
 
     public void startRoute(RouteDefinition route) throws Exception {
+        // must ensure route is prepared, before we can start it
+        route.prepare();
+
         List<Route> routes = new ArrayList<Route>();
         List<RouteContext> routeContexts = route.addRoutes(this, routes);
         RouteService routeService = new RouteService(this, route, routeContexts, routes);
-        // must ensure route is prepared, before we can start it 
-        route.prepare();
         startRouteService(routeService, true);
     }
 
diff --git a/camel-core/src/main/java/org/apache/camel/model/RouteDefinitionHelper.java b/camel-core/src/main/java/org/apache/camel/model/RouteDefinitionHelper.java
index 6e07b583be7..aa23f84cfc7 100644
--- a/camel-core/src/main/java/org/apache/camel/model/RouteDefinitionHelper.java
+++ b/camel-core/src/main/java/org/apache/camel/model/RouteDefinitionHelper.java
@@ -19,6 +19,7 @@ package org.apache.camel.model;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.camel.impl.InterceptSendToEndpoint;
 import org.apache.camel.util.EndpointHelper;
 
 /**
@@ -113,7 +114,7 @@ public final class RouteDefinitionHelper {
         RouteDefinitionHelper.prepareRouteForInit(route, abstracts, lower);
 
         // interceptors should be first for the cross cutting concerns
-        initInterceptors(route, upper, intercepts, interceptFromDefinitions, interceptSendToEndpointDefinitions);
+        initInterceptors(route, abstracts, upper, intercepts, interceptFromDefinitions, interceptSendToEndpointDefinitions);
         // then on completion
         initOnCompletions(abstracts, upper, onCompletions);
         // then transactions
@@ -148,10 +149,39 @@ public final class RouteDefinitionHelper {
         }
     }
 
-    private static void initInterceptors(RouteDefinition route, List<ProcessorDefinition> upper,
+    private static void initInterceptors(RouteDefinition route, List<ProcessorDefinition> abstracts, List<ProcessorDefinition> upper,
                                          List<InterceptDefinition> intercepts,
                                          List<InterceptFromDefinition> interceptFromDefinitions,
                                          List<InterceptSendToEndpointDefinition> interceptSendToEndpointDefinitions) {
+
+        // move the abstracts interceptors into the dedicated list
+        for (ProcessorDefinition processor : abstracts) {
+            if (processor instanceof InterceptSendToEndpointDefinition) {
+                if (interceptSendToEndpointDefinitions == null) {
+                    interceptSendToEndpointDefinitions = new ArrayList<InterceptSendToEndpointDefinition>();
+                }
+                interceptSendToEndpointDefinitions.add((InterceptSendToEndpointDefinition) processor);
+            } else if (processor instanceof InterceptFromDefinition) {
+                if (interceptFromDefinitions == null) {
+                    interceptFromDefinitions = new ArrayList<InterceptFromDefinition>();
+                }
+                interceptFromDefinitions.add((InterceptFromDefinition) processor);
+            } else if (processor instanceof InterceptDefinition) {
+                if (intercepts == null) {
+                    intercepts = new ArrayList<InterceptDefinition>();
+                }
+                intercepts.add((InterceptDefinition) processor);
+            }
+        }
+
+        doInitInterceptors(route, upper, intercepts, interceptFromDefinitions, interceptSendToEndpointDefinitions);
+    }
+
+    private static void doInitInterceptors(RouteDefinition route, List<ProcessorDefinition> upper,
+                                         List<InterceptDefinition> intercepts,
+                                         List<InterceptFromDefinition> interceptFromDefinitions,
+                                         List<InterceptSendToEndpointDefinition> interceptSendToEndpointDefinitions) {
+
         // configure intercept
         if (intercepts != null && !intercepts.isEmpty()) {
             for (InterceptDefinition intercept : intercepts) {
diff --git a/camel-core/src/test/java/org/apache/camel/model/LoadRouteFromXmlWithPolicyTest.java b/camel-core/src/test/java/org/apache/camel/model/LoadRouteFromXmlWithPolicyTest.java
new file mode 100644
index 00000000000..6ec5b714e4a
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/model/LoadRouteFromXmlWithPolicyTest.java
@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.model;
+
+import java.io.InputStream;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.impl.JndiRegistry;
+import org.apache.camel.spi.Policy;
+import org.apache.camel.spi.RouteContext;
+
+/**
+ * @version $Revision$
+ */
+public class LoadRouteFromXmlWithPolicyTest extends ContextTestSupport {
+
+    @Override
+    protected JndiRegistry createRegistry() throws Exception {
+        JndiRegistry jndi = super.createRegistry();
+        jndi.bind("foo", new MyPolicy("foo"));
+        return jndi;
+    }
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+
+    public void testLoadRouteFromXmlWitPolicy() throws Exception {
+        InputStream is = getClass().getResourceAsStream("barPolicyRoute.xml");
+        RoutesDefinition routes = context.loadRoutesDefinition(is);
+        context.addRouteDefinitions(routes.getRoutes());
+        context.start();
+
+        assertNotNull("Loaded foo route should be there", context.getRoute("foo"));
+        assertNotNull("Loaded bar route should be there", context.getRoute("bar"));
+        assertEquals(2, context.getRoutes().size());
+
+        // test that loaded route works
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedHeaderReceived("foo", "was wrapped");
+        getMockEndpoint("mock:bar").expectedMessageCount(1);
+        getMockEndpoint("mock:bar").expectedHeaderReceived("foo", "was wrapped");
+        getMockEndpoint("mock:result").expectedMessageCount(1);
+        getMockEndpoint("mock:result").expectedHeaderReceived("foo", "was wrapped");
+
+        getMockEndpoint("mock:response").expectedMessageCount(1);
+        getMockEndpoint("mock:response").expectedHeaderReceived("foo", "policy finished execution");
+        template.sendBody("direct:send", "Hello World");
+
+        assertMockEndpointsSatisfied();
+
+        MyPolicy foo = context.getRegistry().lookup("foo", MyPolicy.class);
+
+        assertEquals("Should only be invoked 1 time", 1, foo.getInvoked());
+    }
+
+    public static class MyPolicy implements Policy {
+
+        private final String name;
+        private int invoked;
+
+        public MyPolicy(String name) {
+            this.name = name;
+        }
+
+        public void beforeWrap(RouteContext routeContext,
+                               ProcessorDefinition<?> definition) {
+            // no need to modify the route
+        }
+
+        public Processor wrap(RouteContext routeContext, final Processor processor) {
+            return new Processor() {
+                public void process(Exchange exchange) throws Exception {
+                    invoked++;
+                    // let the original processor continue routing
+                    exchange.getIn().setHeader(name, "was wrapped");
+                    processor.process(exchange);
+                    exchange.getIn().setHeader(name, "policy finished execution");
+                }
+            };
+        }
+
+        public int getInvoked() {
+            return invoked;
+        }
+    }
+
+}
diff --git a/camel-core/src/test/resources/org/apache/camel/model/barPolicyRoute.xml b/camel-core/src/test/resources/org/apache/camel/model/barPolicyRoute.xml
new file mode 100644
index 00000000000..aa1d7d73e2d
--- /dev/null
+++ b/camel-core/src/test/resources/org/apache/camel/model/barPolicyRoute.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<routes xmlns="http://camel.apache.org/schema/spring">
+
+    <route id="foo">
+        <from uri="direct:start"/>
+        <policy ref="foo">
+            <to uri="mock:foo"/>
+            <to uri="mock:bar"/>
+            <to uri="mock:result"/>
+        </policy>
+    </route>
+
+    <route id="bar">
+        <from uri="direct:send"/>
+        <to uri="direct:start"/>
+        <to uri="mock:response"/>
+    </route>
+
+</routes>
