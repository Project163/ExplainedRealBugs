diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java
index c16f576dd6e..cfa8158c416 100644
--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java
+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java
@@ -120,14 +120,17 @@ public abstract class GenericFileConsumer<T> extends ScheduledPollConsumer imple
 
             // process the current exchange
             processExchange(exchange);
+            
+            
         }
-
+        
         // remove the file from the in progress list in case the batch was limited by max messages per poll
         for (int index = 0; index < exchanges.size() && isRunAllowed(); index++) {
             GenericFileExchange<T> exchange = (GenericFileExchange<T>) exchanges.poll();
             String key = exchange.getGenericFile().getFileName();
             endpoint.getInProgressRepository().remove(key);
         }
+        
     }
 
     /**
@@ -164,6 +167,8 @@ public abstract class GenericFileConsumer<T> extends ScheduledPollConsumer imple
             boolean begin = processStrategy.begin(operations, endpoint, exchange, exchange.getGenericFile());
             if (!begin) {
                 log.warn(endpoint + " cannot begin processing file: " + exchange.getGenericFile());
+                // remove file from the in progress list as its no longer in progress
+                endpoint.getInProgressRepository().remove(exchange.getGenericFile().getFileName());
                 return;
             }
 
diff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java
index 80c211f2647..a5fd5615f23 100644
--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java
+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java
@@ -71,7 +71,7 @@ public class FileLockExclusiveReadLockStrategy implements GenericFileExclusiveRe
                 try {
                     lock = timeout > 0 ? channel.tryLock() : channel.lock();
                 } catch (IllegalStateException ex) {
-                    // Also catch the OverlappingFileLockException here. Do nothing here
+                    // Also catch the OverlappingFileLockException here. Do nothing here                    
                 }
                 if (lock != null) {
                     if (LOG.isTraceEnabled()) {
@@ -86,7 +86,7 @@ public class FileLockExclusiveReadLockStrategy implements GenericFileExclusiveRe
                 } else {
                     boolean interrupted = sleep();
                     if (interrupted) {
-                        // we were interrputed while sleeping, we are likely being shutdown so return false
+                        // we were interrupted while sleeping, we are likely being shutdown so return false
                         return false;
                     }
                 }
@@ -103,7 +103,7 @@ public class FileLockExclusiveReadLockStrategy implements GenericFileExclusiveRe
             }
             boolean interrupted = sleep();
             if (interrupted) {
-                // we were interrputed while sleeping, we are likely being shutdown so return false
+                // we were interrupted while sleeping, we are likely being shutdown so return false
                 return false;
             }
         }
@@ -128,10 +128,10 @@ public class FileLockExclusiveReadLockStrategy implements GenericFileExclusiveRe
         LOG.trace("Exclusive read lock not granted. Sleeping for 1000 millis.");
         try {
             Thread.sleep(1000);
-            return true;
+            return false;
         } catch (InterruptedException e) {
             LOG.debug("Sleep interrupted while waiting for exclusive read lock, so breaking out");
-            return false;
+            return true;
         }
     }
 
diff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameExclusiveReadLockStrategy.java
index d6ef9d80750..63aec119020 100644
--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameExclusiveReadLockStrategy.java
+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameExclusiveReadLockStrategy.java
@@ -60,7 +60,7 @@ public class GenericFileRenameExclusiveReadLockStrategy<T> implements GenericFil
                 }
             }
             
-            exclusive = operations.renameFile(file.getAbsoluteFilePath(), newFile.getAbsoluteFilePath());
+            exclusive = operations.renameFile(file.getAbsoluteFilePath(), newFile.getAbsoluteFilePath());           
             if (exclusive) {
                 if (LOG.isTraceEnabled()) {
                     LOG.trace("Acquired exclusive read lock to file: " + file);
@@ -70,7 +70,7 @@ public class GenericFileRenameExclusiveReadLockStrategy<T> implements GenericFil
             } else {
                 boolean interrupted = sleep();
                 if (interrupted) {
-                    // we were interrputed while sleeping, we are likely being shutdown so return false
+                    // we were interrupted while sleeping, we are likely being shutdown so return false
                     return false;
                 }
             }
@@ -84,14 +84,14 @@ public class GenericFileRenameExclusiveReadLockStrategy<T> implements GenericFil
         // noop
     }
 
-    private boolean sleep() {
+    private boolean sleep() {        
         LOG.trace("Exclusive read lock not granted. Sleeping for 1000 millis.");
         try {
             Thread.sleep(1000);
-            return true;
-        } catch (InterruptedException e) {
-            LOG.debug("Sleep interrupted while waiting for exclusive read lock, so breaking out");
             return false;
+        } catch (InterruptedException e) {            
+            LOG.debug("Sleep interrupted while waiting for exclusive read lock, so breaking out");
+            return true;
         }
     }
 
diff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java
index 60684112ed7..c381764c75b 100644
--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java
+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java
@@ -34,7 +34,7 @@ import org.apache.commons.logging.LogFactory;
 
 /**
  * Acquires read lock to the given file using a marker file so other Camel consumers wont acquire the same file.
- * This is the default behaviour in Camel 1.x.
+ * This is the default behavior in Camel 1.x.
  */
 public class MarkerFileExclusiveReadLockStrategy implements GenericFileExclusiveReadLockStrategy<File> {
     private static final transient Log LOG = LogFactory.getLog(MarkerFileExclusiveReadLockStrategy.class);
diff --git a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentOnCompletion.java b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentOnCompletion.java
index 7156e23e907..447d81b7cf5 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentOnCompletion.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentOnCompletion.java
@@ -45,7 +45,7 @@ public class IdempotentOnCompletion implements Synchronization {
 
     public void onComplete(Exchange exchange) {
         if (ExchangeHelper.isFailureHandled(exchange)) {
-            // the exchange did not process succesfully but was failure handled by the dead letter channel
+            // the exchange did not process successfully but was failure handled by the dead letter channel
             // and thus moved to the dead letter queue. We should thus not consider it as complete.
             onFailedMessage(exchange, messageId);
         } else {
@@ -58,7 +58,7 @@ public class IdempotentOnCompletion implements Synchronization {
     }
 
     /**
-     * A strategy method to allow derived classes to overload the behaviour of
+     * A strategy method to allow derived classes to overload the behavior of
      * processing a completed message
      *
      * @param exchange the exchange
@@ -74,7 +74,7 @@ public class IdempotentOnCompletion implements Synchronization {
     }
 
     /**
-     * A strategy method to allow derived classes to overload the behaviour of
+     * A strategy method to allow derived classes to overload the behavior of
      * processing a failed message
      *
      * @param exchange the exchange
diff --git a/camel-core/src/test/java/org/apache/camel/component/file/FileConsumeMaxMessagesPerPollTest.java b/camel-core/src/test/java/org/apache/camel/component/file/FileConsumeMaxMessagesPerPollTest.java
index d6baecb4c0c..a1dc0c88476 100644
--- a/camel-core/src/test/java/org/apache/camel/component/file/FileConsumeMaxMessagesPerPollTest.java
+++ b/camel-core/src/test/java/org/apache/camel/component/file/FileConsumeMaxMessagesPerPollTest.java
@@ -26,7 +26,7 @@ import org.apache.camel.component.mock.MockEndpoint;
  */
 public class FileConsumeMaxMessagesPerPollTest extends ContextTestSupport {
 
-    private String fileUrl = "file://target/poll/?consumer.delay=3000&sortBy=file:name&maxMessagesPerPoll=2";
+    private String fileUrl = "file://target/poll/?consumer.delay=2500&consumer.delay=2000&sortBy=file:name&maxMessagesPerPoll=2";
 
     @Override
     protected void setUp() throws Exception {
@@ -40,7 +40,7 @@ public class FileConsumeMaxMessagesPerPollTest extends ContextTestSupport {
     public void testMaxMessagesPerPoll() throws Exception {
         MockEndpoint mock = getMockEndpoint("mock:result");
         mock.expectedBodiesReceived("Bye World", "Godday World");
-        mock.setResultWaitTime(2000);
+        mock.setResultWaitTime(3000);
         mock.expectedPropertyReceived(Exchange.BATCH_SIZE, 2);
 
         assertMockEndpointsSatisfied();
diff --git a/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutOnlyTest.java b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutOnlyTest.java
index 06061af8c19..41f46d6f81c 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutOnlyTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateTimeoutOnlyTest.java
@@ -32,7 +32,7 @@ public class AggregateTimeoutOnlyTest extends ContextTestSupport {
         // by default the use latest aggregatation strategy is used so we get message 9
         result.expectedBodiesReceived("Message 9");
         // should take 3 seconds to complete this one
-        result.setMinimumResultWaitTime(3000);
+        result.setMinimumResultWaitTime(2900);
 
         for (int i = 0; i < 10; i++) {
             template.sendBodyAndHeader("direct:start", "Message " + i, "id", "1");
