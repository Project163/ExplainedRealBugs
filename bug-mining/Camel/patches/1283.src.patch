diff --git a/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java b/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java
index aa00fbb1eb3..a7904e8b634 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java
@@ -24,6 +24,8 @@ import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
 import org.apache.camel.impl.ServiceSupport;
 import org.apache.camel.model.OnExceptionDefinition;
+import org.apache.camel.model.ProcessorDefinitionHelper;
+import org.apache.camel.model.RouteDefinition;
 import org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy;
 import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyKey;
 import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
@@ -49,7 +51,9 @@ public abstract class ErrorHandlerSupport extends ServiceSupport implements Erro
         List<Class> list = exceptionType.getExceptionClasses();
 
         for (Class clazz : list) {
-            ExceptionPolicyKey key = new ExceptionPolicyKey(clazz, exceptionType.getOnWhen());
+            RouteDefinition route = ProcessorDefinitionHelper.getRoute(exceptionType);
+            String routeId = route != null ? route.getId() : null;
+            ExceptionPolicyKey key = new ExceptionPolicyKey(routeId, clazz, exceptionType.getOnWhen());
             exceptionPolicies.put(key, exceptionType);
         }
     }
diff --git a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java
index 01d86e31277..d727e1745fb 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java
@@ -17,6 +17,7 @@
 package org.apache.camel.processor.exceptionpolicy;
 
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
@@ -61,17 +62,29 @@ public class DefaultExceptionPolicyStrategy implements ExceptionPolicyStrategy {
                                                     Exchange exchange, Throwable exception) {
 
         Map<Integer, OnExceptionDefinition> candidates = new TreeMap<Integer, OnExceptionDefinition>();
+        Map<ExceptionPolicyKey, OnExceptionDefinition> routeScoped = new LinkedHashMap<ExceptionPolicyKey, OnExceptionDefinition>();
+        Map<ExceptionPolicyKey, OnExceptionDefinition> contextScoped = new LinkedHashMap<ExceptionPolicyKey, OnExceptionDefinition>();
 
+        // split policies into route and context scoped
+        initRouteAndContextScopedExceptionPolicies(exceptionPolicies, routeScoped, contextScoped);
+
+        // at first check route scoped as we prefer them over context scoped
         // recursive up the tree using the iterator
         boolean exactMatch = false;
         Iterator<Throwable> it = createExceptionIterator(exception);
         while (!exactMatch && it.hasNext()) {
             // we should stop looking if we have found an exact match
-            exactMatch = findMatchedExceptionPolicy(exceptionPolicies, exchange, it.next(), candidates);
+            exactMatch = findMatchedExceptionPolicy(routeScoped, exchange, it.next(), candidates);
         }
 
-        // now go through the candidates and find the best
+        // fallback to check context scoped (only do this if there was no exact match)
+        it = createExceptionIterator(exception);
+        while (!exactMatch && it.hasNext()) {
+            // we should stop looking if we have found an exact match
+            exactMatch = findMatchedExceptionPolicy(contextScoped, exchange, it.next(), candidates);
+        }
 
+        // now go through the candidates and find the best
         if (LOG.isTraceEnabled()) {
             LOG.trace("Found " + candidates.size() + " candidates");
         }
@@ -80,11 +93,26 @@ public class DefaultExceptionPolicyStrategy implements ExceptionPolicyStrategy {
             // no type found
             return null;
         } else {
-            // return the first in the map as its sorted and
+            // return the first in the map as its sorted and we checked route scoped first, which we prefer
             return candidates.values().iterator().next();
         }
     }
 
+    private void initRouteAndContextScopedExceptionPolicies(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies,
+                                                            Map<ExceptionPolicyKey, OnExceptionDefinition> routeScoped,
+                                                            Map<ExceptionPolicyKey, OnExceptionDefinition> contextScoped) {
+
+        // loop through all the entries and split into route and context scoped
+        Set<Map.Entry<ExceptionPolicyKey, OnExceptionDefinition>> entries = exceptionPolicies.entrySet();
+        for (Map.Entry<ExceptionPolicyKey, OnExceptionDefinition> entry : entries) {
+            if (entry.getKey().getRouteId() != null) {
+                routeScoped.put(entry.getKey(), entry.getValue());
+            } else {
+                contextScoped.put(entry.getKey(), entry.getValue());
+            }
+        }
+    }
+
 
     private boolean findMatchedExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies,
                                                Exchange exchange, Throwable exception,
diff --git a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java
index cbd1fa16fee..3c79baa7a0f 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java
@@ -20,16 +20,30 @@ import org.apache.camel.model.WhenDefinition;
 
 /**
  * Exception policy key is a compound key for storing:
- * <b>exception class</b> + <b>when</b> => <b>exception type</b>.
+ * <b>route id </b> + <b>exception class</b> + <b>when</b> => <b>exception type</b>.
  * <p/>
  * This is used by Camel to store the onException types configured that has or has not predicates attached (when).
  */
 public final class ExceptionPolicyKey {
 
+    private final String routeId;
     private final Class exceptionClass;
     private final WhenDefinition when;
 
+    @Deprecated
     public ExceptionPolicyKey(Class exceptionClass, WhenDefinition when) {
+        this(null, exceptionClass, when);
+    }
+
+    /**
+     * Key for exception clause
+     *
+     * @param routeId          the route, or use <tt>null</tt> for a global scoped
+     * @param exceptionClass   the exception class
+     * @param when             optional predicate when the exception clause should trigger
+     */
+    public ExceptionPolicyKey(String routeId, Class exceptionClass, WhenDefinition when) {
+        this.routeId = routeId;
         this.exceptionClass = exceptionClass;
         this.when = when;
     }
@@ -42,10 +56,16 @@ public final class ExceptionPolicyKey {
         return when;
     }
 
+    public String getRouteId() {
+        return routeId;
+    }
+
+    @Deprecated
     public static ExceptionPolicyKey newInstance(Class exceptionClass) {
         return new ExceptionPolicyKey(exceptionClass, null);
     }
 
+    @Deprecated
     public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {
         return new ExceptionPolicyKey(exceptionClass, when);
     }
@@ -61,7 +81,10 @@ public final class ExceptionPolicyKey {
 
         ExceptionPolicyKey that = (ExceptionPolicyKey) o;
 
-        if (!exceptionClass.equals(that.exceptionClass)) {
+        if (exceptionClass != null ? !exceptionClass.equals(that.exceptionClass) : that.exceptionClass != null) {
+            return false;
+        }
+        if (routeId != null ? !routeId.equals(that.routeId) : that.routeId != null) {
             return false;
         }
         if (when != null ? !when.equals(that.when) : that.when != null) {
@@ -73,13 +96,14 @@ public final class ExceptionPolicyKey {
 
     @Override
     public int hashCode() {
-        int result = exceptionClass.hashCode();
+        int result = routeId != null ? routeId.hashCode() : 0;
+        result = 31 * result + (exceptionClass != null ? exceptionClass.hashCode() : 0);
         result = 31 * result + (when != null ? when.hashCode() : 0);
         return result;
     }
 
     @Override
     public String toString() {
-        return "ExceptionPolicyKey[" + exceptionClass + (when != null ? " " + when : "") + "]";
+        return "ExceptionPolicyKey[route: " + (routeId != null ? routeId : "<global>") + ", " + exceptionClass + (when != null ? " " + when : "") + "]";
     }
 }
diff --git a/camel-core/src/test/java/org/apache/camel/issues/TwoRouteScopedOnExceptionWithInterceptSendToEndpointIssueWithPredicateTest.java b/camel-core/src/test/java/org/apache/camel/issues/TwoRouteScopedOnExceptionWithInterceptSendToEndpointIssueWithPredicateTest.java
new file mode 100644
index 00000000000..d3746104090
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/issues/TwoRouteScopedOnExceptionWithInterceptSendToEndpointIssueWithPredicateTest.java
@@ -0,0 +1,104 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.issues;
+
+import java.net.ConnectException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Predicate;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.PredicateBuilder;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.model.RouteDefinition;
+
+/**
+ * Based on user forum issue
+ *
+ * @version $Revision$
+ */
+public class TwoRouteScopedOnExceptionWithInterceptSendToEndpointIssueWithPredicateTest extends ContextTestSupport {
+
+    private final AtomicInteger invoked = new AtomicInteger();
+
+    public void testIssue() throws Exception {
+        final Predicate fail = PredicateBuilder.or(
+            header(Exchange.REDELIVERY_COUNTER).isNull(),
+            header(Exchange.REDELIVERY_COUNTER).isLessThan(5));
+
+        RouteDefinition route = context.getRouteDefinitions().get(0);
+        route.adviceWith(context, new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                interceptSendToEndpoint("seda:*")
+                    .skipSendToOriginalEndpoint()
+                    .process(new Processor() {
+                        public void process(Exchange exchange) throws Exception {
+                            invoked.incrementAndGet();
+
+                            if (fail.matches(exchange)) {
+                                throw new ConnectException("Forced");
+                            }
+                        }
+                    }).to("mock:ok");
+            }
+        });
+
+        getMockEndpoint("mock:global").expectedMessageCount(0);
+        getMockEndpoint("mock:ok").expectedMessageCount(1);
+        getMockEndpoint("mock:exhausted").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+
+        // 5 retry + 1 ok
+        assertEquals(6, invoked.get());
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                errorHandler(deadLetterChannel("mock:global")
+                        .maximumRedeliveries(2)
+                        .redeliveryDelay(5000));
+
+                from("direct:start")
+                        // no redelivery delay for faster unit tests
+                        .onException(ConnectException.class).maximumRedeliveries(5).redeliveryDelay(0)
+                            .logRetryAttempted(true).retryAttemptedLogLevel(LoggingLevel.WARN)
+                            // send to mock when we are exhausted
+                            .to("mock:exhausted")
+                        .end()
+                        .to("seda:foo");
+
+                from("direct:start2")
+                        // no redelivery delay for faster unit tests
+                        .onException(ConnectException.class).maximumRedeliveries(3).redeliveryDelay(0)
+                            .logRetryAttempted(true).retryAttemptedLogLevel(LoggingLevel.FATAL)
+                            // send to mock when we are exhausted
+                            .to("mock:exhausted2")
+                        .end()
+                        .to("seda:foo2");
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/onexception/RouteScopedOnExceptionSameTypeTest.java b/camel-core/src/test/java/org/apache/camel/processor/onexception/RouteScopedOnExceptionSameTypeTest.java
new file mode 100644
index 00000000000..0e64eb79cc7
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/onexception/RouteScopedOnExceptionSameTypeTest.java
@@ -0,0 +1,300 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.onexception;
+
+import java.io.IOException;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+
+/**
+ * @version $Revision$
+ */
+public class RouteScopedOnExceptionSameTypeTest extends ContextTestSupport {
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+
+    public void testOnExceptionExactType() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:damn")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+
+                from("direct:foo")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:foo")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:damn").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOnExceptionDifferentType() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:damn")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+
+                from("direct:foo")
+                    .onException(IOException.class)
+                        .handled(true)
+                        .to("mock:foo")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:damn").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOnExceptionSameTypeRouteLast() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:foo")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:foo")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+
+                from("direct:start")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:damn")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:damn").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOnExceptionDifferentTypeRouteLast() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:foo")
+                    .onException(IOException.class)
+                        .handled(true)
+                        .to("mock:foo")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+
+                from("direct:start")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:damn")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:damn").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOnExceptionExactTypeDLC() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                errorHandler(deadLetterChannel("mock:dead"));
+
+                from("direct:start")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:damn")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+
+                from("direct:foo")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:foo")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:damn").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(0);
+        getMockEndpoint("mock:dlc").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testTwoOnExceptionExactType() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start")
+                    .onException(IOException.class)
+                        .handled(true)
+                        .to("mock:io")
+                    .end()
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:damn")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+
+                from("direct:foo")
+                    .onException(IOException.class)
+                        .handled(true)
+                        .to("mock:io")
+                    .end()
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:foo")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:damn").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(0);
+        getMockEndpoint("mock:io").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOnExceptionRouteAndGlobalExactType() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(IllegalArgumentException.class)
+                    .handled(true)
+                    .to("mock:foo");
+
+                from("direct:start")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:damn")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:damn").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOnExceptionRouteAndGlobalDifferentType() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(IOException.class)
+                    .handled(true)
+                    .to("mock:foo");
+
+                from("direct:start")
+                    .onException(IllegalArgumentException.class)
+                        .handled(true)
+                        .to("mock:damn")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+            }
+        });
+        context.start();
+
+        getMockEndpoint("mock:damn").expectedMessageCount(1);
+        getMockEndpoint("mock:foo").expectedMessageCount(0);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testOnExceptionRouteAndOnlyGlobalExactType() throws Exception {
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                onException(IllegalArgumentException.class)
+                    .handled(true)
+                    .to("mock:foo");
+
+                from("direct:start")
+                    .onException(IOException.class)
+                        .handled(true)
+                        .to("mock:damn")
+                    .end()
+                    .throwException(new IllegalArgumentException("Damn"));
+            }
+        });
+        context.start();
+
+        // this time we pick global scoped as its an exact match, so foo should get the message
+        getMockEndpoint("mock:damn").expectedMessageCount(0);
+        getMockEndpoint("mock:foo").expectedMessageCount(1);
+
+        template.sendBody("direct:start", "Hello World");
+
+        assertMockEndpointsSatisfied();
+    }
+
+}
