diff --git a/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java b/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java
index 8f39c14d2f6..b0606bfb533 100644
--- a/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java
+++ b/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java
@@ -127,23 +127,12 @@ public class MailBinding {
         // fix content type to include a space after semi colon if missing
         if (contentType != null && contentType.contains(";")) {
             String before = ObjectHelper.before(contentType, ";");
-            String after = ObjectHelper.after(contentType, ";");
+            String charset = determineCharSet(configuration, exchange);
 
-            // after is the charset lets see if its given and a valid charset
-            if (after != null) {
-                String charset = ObjectHelper.after(after, "=");
-                charset = determineCharSet(configuration, charset);
-                if (charset != null) {
-                    after = "charset=" + charset;
-                } else {
-                    after = null;
-                }
-            }
-
-            if (before != null && after == null) {
+            if (before != null && charset == null) {
                 contentType = before.trim();
-            } else if (before != null && after != null) {
-                contentType = before.trim() + "; " + after;
+            } else if (before != null && charset != null) {
+                contentType = before.trim() + "; charset=" + charset;
             }
         }
 
@@ -154,26 +143,42 @@ public class MailBinding {
         return contentType;
     }
 
-    protected String determineCharSet(MailConfiguration configuration, String charset) {
-        if (charset == null) {
-            return null;
-        }
+    protected String determineCharSet(MailConfiguration configuration, Exchange exchange) {
 
-        boolean supported;
-        try {
-            supported = Charset.isSupported(charset);
-        } catch (IllegalCharsetNameException e) {
-            supported = false;
+         // see if we got any content type set
+        String contentType = configuration.getContentType();
+        if (exchange.getIn().getHeader("contentType") != null) {
+            contentType = exchange.getIn().getHeader("contentType", String.class);
+        } else if (exchange.getIn().getHeader(Exchange.CONTENT_TYPE) != null) {
+            contentType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, String.class);
         }
 
-        if (supported) {
-            return charset;
-        } else if (configuration.isIgnoreUnsupportedCharset()) {
-            LOG.warn("Charset: " + charset + " is not supported, will fallback to use platform default instead.");
-            return null;
-        }
+        // fix content type to include a space after semi colon if missing
+        if (contentType != null && contentType.contains(";")) {
+            String after = ObjectHelper.after(contentType, ";");
 
-        return charset;
+            // after is the charset lets see if its given and a valid charset
+            if (after != null) {
+                String charset = ObjectHelper.after(after, "=");
+                if (charset != null) {
+                    boolean supported;
+                    try {
+                        supported = Charset.isSupported(charset);
+                    } catch (IllegalCharsetNameException e) {
+                        supported = false;
+                    }
+                    if (supported) {
+                        return charset;
+                    } else if (!configuration.isIgnoreUnsupportedCharset()) {
+                        return charset;
+                    } else if (configuration.isIgnoreUnsupportedCharset()) {
+                        LOG.warn("Charset: " + charset + " is not supported, will fallback to use platform default instead.");
+                        return null;
+                    }
+                }
+            }
+        }
+        return null;
     }
 
     protected String populateContentOnMimeMessage(MimeMessage part, MailConfiguration configuration, Exchange exchange)
@@ -469,8 +474,8 @@ public class MailBinding {
         MimeMultipart multipartAlternative = new MimeMultipart("alternative");
         mimeMessage.setContent(multipartAlternative);
 
-        BodyPart plainText = new MimeBodyPart();
-        plainText.setText(getAlternativeBody(configuration, exchange));
+        MimeBodyPart plainText = new MimeBodyPart();
+        plainText.setText(getAlternativeBody(configuration, exchange), determineCharSet(configuration, exchange));
         // remove the header with the alternative mail now that we got it
         // otherwise it might end up twice in the mail reader
         exchange.getIn().removeHeader(configuration.getAlternativeBodyHeader());
diff --git a/components/camel-mail/src/test/java/org/apache/camel/component/mail/MimeMultipartAlternativeWithContentTypeTest.java b/components/camel-mail/src/test/java/org/apache/camel/component/mail/MimeMultipartAlternativeWithContentTypeTest.java
new file mode 100644
index 00000000000..1e0f34adfbc
--- /dev/null
+++ b/components/camel-mail/src/test/java/org/apache/camel/component/mail/MimeMultipartAlternativeWithContentTypeTest.java
@@ -0,0 +1,92 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.mail;
+
+import java.io.ByteArrayOutputStream;
+
+import javax.mail.internet.MimeMultipart;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+import org.jvnet.mock_javamail.Mailbox;
+
+import static org.apache.camel.component.mail.MailConstants.MAIL_ALTERNATIVE_BODY;
+
+public class MimeMultipartAlternativeWithContentTypeTest extends CamelTestSupport {
+    private String alternativeBody = "hello world! (plain text)";
+    private String htmlBody = "<html><body><h1>Hello</h1>World</body></html>";
+
+    private void sendMultipartEmail() throws Exception {
+        Mailbox.clearAll();
+
+        // create an exchange with a normal body and attachment to be produced as email
+        MailEndpoint endpoint = context.getEndpoint("smtp://sachin@mymailserver.com?password=secret&contentType=text/html; charset=UTF-8", MailEndpoint.class);
+        endpoint.getConfiguration().setAlternativeBodyHeader(MailConstants.MAIL_ALTERNATIVE_BODY);
+
+        // create the exchange with the mail message that is multipart with a file and a Hello World text/plain message.
+        Exchange exchange = endpoint.createExchange();
+        Message in = exchange.getIn();
+        in.setBody(htmlBody);
+        in.setHeader(MAIL_ALTERNATIVE_BODY, alternativeBody);
+        
+        // create a producer that can produce the exchange (= send the mail)
+        MockEndpoint mock = getMockEndpoint("mock:result");
+        mock.expectedMessageCount(1);
+        mock.message(0).header(MailConstants.MAIL_ALTERNATIVE_BODY).isNull();
+
+        context.createProducerTemplate().send(endpoint, exchange);
+    }
+
+    private void verifyTheRecivedEmail(String expectString) throws Exception {
+
+        MockEndpoint mock = getMockEndpoint("mock:result");
+        mock.assertIsSatisfied();
+
+        Exchange out = mock.assertExchangeReceived(0);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream(((MailMessage)out.getIn()).getMessage().getSize());
+        ((MailMessage)out.getIn()).getMessage().writeTo(baos);
+        String dumpedMessage = baos.toString();
+        assertTrue("There should have the " + expectString, dumpedMessage.indexOf(expectString) > 0);
+        if (log.isTraceEnabled()) {
+            log.trace("multipart alternative: \n" + dumpedMessage);
+        }
+
+        // plain text
+        assertEquals(alternativeBody, out.getIn().getBody(String.class));
+
+        assertEquals("multipart body should have 2 parts", 2, out.getIn().getBody(MimeMultipart.class).getCount());
+    }
+
+    @Test
+    public void testMultipartEmailContentType() throws Exception {
+        sendMultipartEmail();
+        verifyTheRecivedEmail("Content-Type: text/plain; charset=UTF-8");
+        verifyTheRecivedEmail("Content-Type: text/html; charset=UTF-8");
+    }
+
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            public void configure() throws Exception {
+                from("pop3://sachin@mymailserver.com?password=secret&consumer.delay=1000&contentType=text/html; charset=UTF-8").to("mock:result");
+            }
+        };
+    }
+}
\ No newline at end of file
