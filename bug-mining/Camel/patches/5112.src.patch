diff --git a/components/camel-websocket/src/main/java/org/apache/camel/component/websocket/WebsocketProducer.java b/components/camel-websocket/src/main/java/org/apache/camel/component/websocket/WebsocketProducer.java
index 895a0dbf1d0..8b47d1649aa 100644
--- a/components/camel-websocket/src/main/java/org/apache/camel/component/websocket/WebsocketProducer.java
+++ b/components/camel-websocket/src/main/java/org/apache/camel/component/websocket/WebsocketProducer.java
@@ -129,22 +129,17 @@ public class WebsocketProducer extends DefaultProducer implements WebsocketProdu
         int timeout = endpoint.getSendTimeout();
         while (!futures.isEmpty() && watch.taken() < timeout) {
             // remove all that are done/cancelled
-            for (Future future : futures) {
-                if (future.isDone() || future.isCancelled()) {
-                    futures.remove(future);
-                }
-                // if there are still more then we need to wait a little bit before checking again, to avoid burning cpu cycles in the while loop
-                if (!futures.isEmpty()) {
-                    long interval = Math.min(1000, timeout);
-                    log.debug("Sleeping {} millis waiting for sendToAll to complete sending with timeout {} millis", interval, timeout);
-                    try {
-                        Thread.sleep(interval);
-                    } catch (InterruptedException e) {
-                        handleSleepInterruptedException(e, exchange);
-                    }
+            futures.removeIf(future -> future.isDone() || future.isCancelled());
+            // if there are still more then we need to wait a little bit before checking again, to avoid burning cpu cycles in the while loop
+            if (!futures.isEmpty()) {
+                long interval = Math.min(1000, timeout);
+                log.debug("Sleeping {} millis waiting for sendToAll to complete sending with timeout {} millis", interval, timeout);
+                try {
+                    Thread.sleep(interval);
+                } catch (InterruptedException e) {
+                    handleSleepInterruptedException(e, exchange);
                 }
             }
-
         }
         if (!futures.isEmpty()) {
             exception = new WebsocketSendException("Failed to deliver message within " + endpoint.getSendTimeout() + " millis to one or more recipients.", exchange);
