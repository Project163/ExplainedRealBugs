diff --git a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java
index 4bb58241916..171858e0b69 100644
--- a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java
+++ b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java
@@ -74,7 +74,7 @@ public class ZipFileDataFormat extends ServiceSupport implements DataFormat, Dat
     @Override
     public Object unmarshal(final Exchange exchange, final InputStream inputStream) throws Exception {
         if (usingIterator) {
-            ZipIterator zipIterator = new ZipIterator(exchange.getIn());
+            ZipIterator zipIterator = new ZipIterator(exchange, inputStream);
             zipIterator.setAllowEmptyDirectory(allowEmptyDirectory);
             return zipIterator;
         } else {
@@ -107,7 +107,7 @@ public class ZipFileDataFormat extends ServiceSupport implements DataFormat, Dat
     public void setUsingIterator(boolean usingIterator) {
         this.usingIterator = usingIterator;
     }
-    
+
     public boolean isAllowEmptyDirectory() {
         return allowEmptyDirectory;
     }
diff --git a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipIterator.java b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipIterator.java
index 8d448c6de6d..2e41318a3d5 100644
--- a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipIterator.java
+++ b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipIterator.java
@@ -38,24 +38,23 @@ import org.slf4j.LoggerFactory;
  */
 public class ZipIterator implements Iterator<Message>, Closeable {
     static final Logger LOGGER = LoggerFactory.getLogger(ZipIterator.class);
-    
-    private final Message inputMessage;
+
+    private final Exchange exchange;
     private boolean allowEmptyDirectory;
     private volatile ZipInputStream zipInputStream;
     private volatile Message parent;
-    
-    public ZipIterator(Message inputMessage) {
-        this.inputMessage = inputMessage;
+
+    public ZipIterator(Exchange exchange, InputStream inputStream) {
+        this.exchange = exchange;
         this.allowEmptyDirectory = false;
-        InputStream inputStream = inputMessage.getBody(InputStream.class);
         if (inputStream instanceof ZipInputStream) {
-            zipInputStream = (ZipInputStream)inputStream;
+            zipInputStream = (ZipInputStream) inputStream;
         } else {
             zipInputStream = new ZipInputStream(new BufferedInputStream(inputStream));
         }
         parent = null;
     }
-    
+
     @Override
     public boolean hasNext() {
         try {
@@ -73,10 +72,10 @@ public class ZipIterator implements Iterator<Message>, Closeable {
                     availableDataInCurrentEntry = true;
                 }
             }
-            return availableDataInCurrentEntry;            
+            return availableDataInCurrentEntry;
         } catch (IOException exception) {
             //Just wrap the IOException as CamelRuntimeException
-            throw new RuntimeCamelException(exception);      
+            throw new RuntimeCamelException(exception);
         }
     }
 
@@ -91,19 +90,19 @@ public class ZipIterator implements Iterator<Message>, Closeable {
 
         return answer;
     }
-    
+
     private Message getNextElement() {
         if (zipInputStream == null) {
             return null;
         }
-        
+
         try {
             ZipEntry current = getNextEntry();
 
             if (current != null) {
                 LOGGER.debug("read zipEntry {}", current.getName());
-                Message answer = new DefaultMessage(inputMessage.getExchange().getContext());
-                answer.getHeaders().putAll(inputMessage.getHeaders());
+                Message answer = new DefaultMessage(exchange.getContext());
+                answer.getHeaders().putAll(exchange.getIn().getHeaders());
                 answer.setHeader("zipFileName", current.getName());
                 answer.setHeader(Exchange.FILE_NAME, current.getName());
                 answer.setBody(new ZipInputStreamWrapper(zipInputStream));
@@ -151,7 +150,7 @@ public class ZipIterator implements Iterator<Message>, Closeable {
         IOHelper.close(zipInputStream);
         zipInputStream = null;
     }
-    
+
     public boolean isSupportIteratorForEmptyDirectory() {
         return allowEmptyDirectory;
     }
diff --git a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipSplitter.java b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipSplitter.java
index 04e7ec68e8e..0a7393a2aa0 100644
--- a/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipSplitter.java
+++ b/components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipSplitter.java
@@ -16,6 +16,8 @@
  */
 package org.apache.camel.dataformat.zipfile;
 
+import java.io.InputStream;
+
 import org.apache.camel.Exchange;
 import org.apache.camel.Expression;
 import org.apache.camel.Message;
@@ -30,12 +32,13 @@ public class ZipSplitter implements Expression {
 
     public ZipSplitter() {
     }
-    
+
     public Object evaluate(Exchange exchange) {
         Message inputMessage = exchange.getIn();
-        return new ZipIterator(inputMessage);
+        InputStream inputStream = inputMessage.getBody(InputStream.class);
+        return new ZipIterator(exchange, inputStream);
     }
-    
+
     @Override
     public <T> T evaluate(Exchange exchange, Class<T> type) {
         Object result = evaluate(exchange);
diff --git a/components/camel-zipfile/src/test/java/org/apache/camel/dataformat/zipfile/ZipFileSplitAndDeleteTest.java b/components/camel-zipfile/src/test/java/org/apache/camel/dataformat/zipfile/ZipFileSplitAndDeleteTest.java
new file mode 100644
index 00000000000..cc8c999a9af
--- /dev/null
+++ b/components/camel-zipfile/src/test/java/org/apache/camel/dataformat/zipfile/ZipFileSplitAndDeleteTest.java
@@ -0,0 +1,103 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.zipfile;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.StandardCopyOption;
+import java.util.Iterator;
+
+import org.apache.camel.RoutesBuilder;
+import org.apache.camel.builder.NotifyBuilder;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+public class ZipFileSplitAndDeleteTest extends CamelTestSupport {
+
+
+    @Override
+    public void setUp() throws Exception {
+        deleteDirectory("target/testDeleteZipFileWhenUnmarshalWithDataFormat");
+        deleteDirectory("target/testDeleteZipFileWhenUnmarshalWithSplitter");
+        super.setUp();
+    }
+
+    @Test
+    public void testDeleteZipFileWhenUnmarshalWithDataFormat() throws Exception {
+        NotifyBuilder notify = new NotifyBuilder(context).from("file://target/" + "testDeleteZipFileWhenUnmarshalWithDataFormat").whenDone(1).create();
+        getMockEndpoint("mock:end").expectedMessageCount(2);
+        String zipFile = createZipFile("testDeleteZipFileWhenUnmarshalWithDataFormat");
+
+        assertMockEndpointsSatisfied();
+
+        notify.matchesMockWaitTime();
+
+        // the original file should have been deleted
+        assertFalse("File should been deleted", new File(zipFile).exists());
+    }
+
+    @Test
+    public void testDeleteZipFileWhenUnmarshalWithSplitter() throws Exception {
+        NotifyBuilder notify = new NotifyBuilder(context).from("file://target/" + "testDeleteZipFileWhenUnmarshalWithSplitter").whenDone(1).create();
+        getMockEndpoint("mock:end").expectedMessageCount(2);
+        String zipFile = createZipFile("testDeleteZipFileWhenUnmarshalWithSplitter");
+
+        assertMockEndpointsSatisfied();
+
+        notify.matchesMockWaitTime();
+
+        // the original file should have been deleted,
+        assertFalse("File should been deleted", new File(zipFile).exists());
+    }
+
+
+    @Override
+    protected RoutesBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                ZipFileDataFormat dataFormat = new ZipFileDataFormat();
+                dataFormat.setUsingIterator(true);
+
+                from("file://target/testDeleteZipFileWhenUnmarshalWithDataFormat?delete=true")
+                        .unmarshal(dataFormat)
+                        .split(bodyAs(Iterator.class)).streaming()
+                        .convertBodyTo(String.class)
+                        .to("mock:end")
+                        .end();
+
+                from("file://target/testDeleteZipFileWhenUnmarshalWithSplitter?delete=true")
+                        .split(new ZipSplitter()).streaming()
+                        .convertBodyTo(String.class)
+                        .to("mock:end")
+                        .end();
+            }
+        };
+    }
+
+    private String createZipFile(String folder) throws IOException {
+        Path source = Paths.get("src/test/resources/data.zip");
+        Path target = Paths.get("target" + File.separator + folder + File.separator + "data.zip");
+        target.toFile().getParentFile().mkdirs();
+        Path copy = Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
+        return copy.toAbsolutePath().toString();
+    }
+}
