diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java
index 713533163de..f43ea94a281 100644
--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java
+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java
@@ -126,7 +126,7 @@ public class BeanInfo {
             Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType,
                                                                        parameterAnnotations);
             if (expression == null) {
-                if (parameterTypes.length == 1 && bodyParameters.isEmpty()) {
+                if (bodyParameters.isEmpty()) {
                     // lets assume its the body
                     expression = ExpressionBuilder.bodyExpression(parameterType);
                 } else {
diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java
index 1053668442f..8815cc70ad9 100644
--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java
@@ -16,18 +16,18 @@
  */
 package org.apache.camel.component.bean;
 
-import java.lang.reflect.Method;
-
 import org.apache.camel.CamelContext;
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.Processor;
 import org.apache.camel.spi.Registry;
 import org.apache.camel.util.ObjectHelper;
+import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
-import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 
 /**
  * A {@link Processor} which converts the inbound exchange to a method
@@ -96,13 +96,23 @@ public class BeanProcessor implements Processor {
             invocation = beanInfo.createInvocation(pojo, exchange);
         }
         if (invocation == null) {
-            throw new IllegalStateException("No method invocation could be created");
+            throw new IllegalStateException("No method invocation could be created, no maching method could be found on: " + pojo);
         }
         try {
             Object value = invocation.proceed();
             if (value != null) {
                 exchange.getIn().setBody(value);
             }
+        } catch (InvocationTargetException e) {
+            // lets unwrap the exception
+            Throwable cause = e.getTargetException();
+            if (cause instanceof Exception) {
+                throw (Exception) cause;
+            }
+            else {
+                // TODO deal with errors!
+                throw e;
+            }
         } catch (Exception e) {
             throw e;
         } catch (Throwable throwable) {
diff --git a/camel-core/src/main/java/org/apache/camel/model/BeanRef.java b/camel-core/src/main/java/org/apache/camel/model/BeanRef.java
index d852506f0e1..6eddbdd6e7d 100644
--- a/camel-core/src/main/java/org/apache/camel/model/BeanRef.java
+++ b/camel-core/src/main/java/org/apache/camel/model/BeanRef.java
@@ -42,8 +42,8 @@ public class BeanRef extends OutputType {
     public BeanRef() {
     }
 
-    public BeanRef(Object bean) {
-        this.bean = bean;
+    public BeanRef(String ref) {
+        this.ref = ref;
     }
 
     public BeanRef(String ref, String method) {
diff --git a/camel-core/src/test/java/org/apache/camel/ContextTestSupport.java b/camel-core/src/test/java/org/apache/camel/ContextTestSupport.java
index 2b975058337..511a6744f98 100644
--- a/camel-core/src/test/java/org/apache/camel/ContextTestSupport.java
+++ b/camel-core/src/test/java/org/apache/camel/ContextTestSupport.java
@@ -22,6 +22,8 @@ import org.apache.camel.impl.JndiRegistry;
 import org.apache.camel.spi.Language;
 import org.apache.camel.util.jndi.JndiTest;
 
+import javax.naming.Context;
+
 /**
  * A useful base class which creates a {@link CamelContext} with some routes
  * along with a {@link CamelTemplate} for use in the test case
@@ -89,7 +91,15 @@ public abstract class ContextTestSupport extends TestSupport {
     }
 
     protected CamelContext createCamelContext() throws Exception {
-        return new DefaultCamelContext(new JndiRegistry(JndiTest.createInitialContext()));
+        return new DefaultCamelContext(createRegistry());
+    }
+
+    protected JndiRegistry createRegistry() throws Exception {
+        return new JndiRegistry(createJndiContext());
+    }
+
+    protected Context createJndiContext() throws Exception {
+        return JndiTest.createInitialContext();
     }
 
     protected RouteBuilder createRouteBuilder() throws Exception {
diff --git a/camel-core/src/test/java/org/apache/camel/processor/BeanWithExceptionTest.java b/camel-core/src/test/java/org/apache/camel/processor/BeanWithExceptionTest.java
new file mode 100644
index 00000000000..5f7a2141fff
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/BeanWithExceptionTest.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Header;
+import org.apache.camel.Processor;
+import org.apache.camel.ValidationException;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.util.jndi.JndiContext;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import javax.naming.Context;
+
+/**
+ * @version $Revision: 1.1 $
+ */
+public class BeanWithExceptionTest extends ContextTestSupport {
+    protected Processor validator = new MyValidator();
+    protected MockEndpoint validEndpoint;
+    protected MockEndpoint invalidEndpoint;
+
+    public void testValidMessage() throws Exception {
+        validEndpoint.expectedMessageCount(1);
+
+        template.sendBodyAndHeader("direct:start", "<valid/>", "foo", "bar");
+
+        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
+    }
+
+    public void testInvalidMessage() throws Exception {
+        invalidEndpoint.expectedMessageCount(1);
+
+        template.sendBodyAndHeader("direct:start", "<invalid/>", "foo", "notMatchedHeaderValue");
+
+        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        validEndpoint = resolveMandatoryEndpoint("mock:valid", MockEndpoint.class);
+        invalidEndpoint = resolveMandatoryEndpoint("mock:invalid", MockEndpoint.class);
+    }
+
+    @Override
+    protected Context createJndiContext() throws Exception {
+        JndiContext answer = new JndiContext();
+        answer.bind("myBean", new ValidationBean());
+        return answer;
+    }
+
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            public void configure() {
+                exception(ValidationException.class).to("mock:invalid");
+
+                from("direct:start").
+                        beanRef("myBean").
+                        to("mock:valid");            }
+        };
+    }
+
+    public static class ValidationBean {
+        private static final transient Log LOG = LogFactory.getLog(ValidationBean.class);
+
+        public void someMethod(String body, @Header(name = "foo") String header) throws ValidationException {
+            if ("bar".equals(header)) {
+                LOG.info("someMethod() called with valid header and body: " + body);
+            }
+            else {
+                throw new ValidationException(null, "Invalid header foo: " + header);
+            }
+        }
+    }
+}
\ No newline at end of file
