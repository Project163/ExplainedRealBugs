diff --git a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java
index ef2ad9f9173..6280a915d10 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java
@@ -35,7 +35,9 @@ public class TryProcessor extends ServiceSupport implements Processor {
     private static final Log LOG = LogFactory.getLog(TryProcessor.class);
 
     private final Processor tryProcessor;
+
     private final List<CatchProcessor> catchClauses;
+
     private final Processor finallyProcessor;
 
     public TryProcessor(Processor tryProcessor, List<CatchProcessor> catchClauses, Processor finallyProcessor) {
@@ -54,7 +56,7 @@ public class TryProcessor extends ServiceSupport implements Processor {
         try {
             tryProcessor.process(exchange);
             e = exchange.getException();
-            
+
             // Ignore it if it was handled by the dead letter channel.
             if (e != null && DeadLetterChannel.isFailureHandled(exchange)) {
                 e = null;
@@ -63,7 +65,7 @@ public class TryProcessor extends ServiceSupport implements Processor {
             e = ex;
             exchange.setException(e);
         }
-        
+
         if (e != null) {
             try {
                 DeadLetterChannel.setFailureHandled(exchange, true);
@@ -72,13 +74,23 @@ public class TryProcessor extends ServiceSupport implements Processor {
                 throw ex;
             } catch (Throwable ex) {
                 throw new RuntimeCamelException(ex);
+            } finally {
+                handleAll(exchange);
             }
+        } else {
+            handleAll(exchange);
         }
-        
-        try {
-            finallyProcessor.process(exchange);
-        } catch (Exception e2) {
-            LOG.warn("Caught exception in finally block while handling other exception: " + e2, e2);
+
+    }
+
+    private void handleAll(Exchange exchange) {
+        if (finallyProcessor != null) {
+            DeadLetterChannel.setFailureHandled(exchange, true);
+            try {
+                finallyProcessor.process(exchange);
+            } catch (Exception e2) {
+                LOG.warn("Caught exception in finally block while handling other exception: " + e2, e2);
+            }
         }
     }
 
@@ -106,6 +118,8 @@ public class TryProcessor extends ServiceSupport implements Processor {
         }
 
         // unhandled exception
-        throw e;
+        if (finallyProcessor == null) {
+            throw e;
+        }
     }
 }
diff --git a/camel-core/src/test/java/org/apache/camel/processor/ValidationHandleAllNoCatchTest.java b/camel-core/src/test/java/org/apache/camel/processor/ValidationHandleAllNoCatchTest.java
new file mode 100644
index 00000000000..1fbceacea85
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/ValidationHandleAllNoCatchTest.java
@@ -0,0 +1,58 @@
+/**
+ *
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.model.TryType;
+
+/**
+ * No catch blocks but handle all should work
+ *
+ * @author <a href="mailto:nsandhu@raleys.com">nsandhu</a>
+ */
+public class ValidationHandleAllNoCatchTest extends ContextTestSupport {
+    protected Processor validator = new MyValidator();
+    protected MockEndpoint validEndpoint;
+    protected MockEndpoint allEndpoint;
+
+    public void testValidMessage() throws Exception {
+        validEndpoint.expectedMessageCount(1);
+        allEndpoint.expectedMessageCount(1);
+
+        template.sendBodyAndHeader("direct:start", "<valid/>", "foo", "bar");
+
+        MockEndpoint.assertIsSatisfied(validEndpoint, allEndpoint);
+    }
+
+    public void testInvalidMessage() throws Exception {
+        validEndpoint.expectedMessageCount(0);
+        allEndpoint.expectedMessageCount(1);
+
+        template.sendBodyAndHeader("direct:start", "<invalid/>", "foo", "notMatchedHeaderValue");
+
+        MockEndpoint.assertIsSatisfied(validEndpoint, allEndpoint);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        validEndpoint = resolveMandatoryEndpoint("mock:valid", MockEndpoint.class);
+        allEndpoint = resolveMandatoryEndpoint("mock:all", MockEndpoint.class);
+    }
+
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            public void configure() {
+                TryType tryType = from("direct:start").tryBlock().
+                        process(validator).
+                        to("mock:valid");
+                tryType.handleAll().to("mock:all");
+            }
+        };
+    }
+}
diff --git a/camel-core/src/test/java/org/apache/camel/processor/ValidationHandleAllTest.java b/camel-core/src/test/java/org/apache/camel/processor/ValidationHandleAllTest.java
new file mode 100644
index 00000000000..3ca64d7de3f
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/ValidationHandleAllTest.java
@@ -0,0 +1,64 @@
+/**
+ *
+ */
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Processor;
+import org.apache.camel.ValidationException;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.model.TryType;
+
+/**
+ * Test handleAll
+ *
+ * @author <a href="mailto:nsandhu@raleys.com">nsandhu</a>
+ */
+public class ValidationHandleAllTest extends ContextTestSupport {
+    protected Processor validator = new MyValidator();
+    protected MockEndpoint validEndpoint;
+    protected MockEndpoint invalidEndpoint;
+    protected MockEndpoint allEndpoint;
+
+    public void testValidMessage() throws Exception {
+        validEndpoint.expectedMessageCount(1);
+        invalidEndpoint.expectedMessageCount(0);
+        allEndpoint.expectedMessageCount(1);
+
+        template.sendBodyAndHeader("direct:start", "<valid/>", "foo", "bar");
+
+        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint, allEndpoint);
+    }
+
+    public void testInvalidMessage() throws Exception {
+        invalidEndpoint.expectedMessageCount(1);
+        validEndpoint.expectedMessageCount(0);
+        allEndpoint.expectedMessageCount(1);
+
+        template.sendBodyAndHeader("direct:start", "<invalid/>", "foo", "notMatchedHeaderValue");
+
+        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint, allEndpoint);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        validEndpoint = resolveMandatoryEndpoint("mock:valid", MockEndpoint.class);
+        invalidEndpoint = resolveMandatoryEndpoint("mock:invalid", MockEndpoint.class);
+        allEndpoint = resolveMandatoryEndpoint("mock:all", MockEndpoint.class);
+    }
+
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            public void configure() {
+                TryType tryType = from("direct:start").tryBlock().
+                        process(validator).
+                        to("mock:valid");
+                tryType.handle(ValidationException.class).to("mock:invalid");
+                tryType.handleAll().to("mock:all");
+            }
+        };
+    }
+}
