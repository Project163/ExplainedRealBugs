diff --git a/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java b/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java
index 4c6880c66ec..564818e72c0 100644
--- a/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java
+++ b/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java
@@ -64,6 +64,12 @@ import org.slf4j.LoggerFactory;
 public final class ObjectHelper {
     private static final transient Logger LOG = LoggerFactory.getLogger(ObjectHelper.class);
     private static final String DEFAULT_DELIMITER = ",";
+    @SuppressWarnings("unchecked")
+    private static final List<?> PRIMITIVE_TYPES = Arrays.asList(byte.class, short.class, int.class, long.class,
+                                                                 float.class, double.class, char.class, boolean.class, void.class);
+    @SuppressWarnings("unchecked")
+    private static final List<?> PRIMITIVE_ARRAY_TYPES = Arrays.asList(byte[].class, short[].class, int[].class, long[].class,
+                                                                       float[].class, double[].class, char[].class, boolean[].class);
 
     /**
      * Utility classes should not have a public constructor.
@@ -493,7 +499,12 @@ public final class ObjectHelper {
      * Object[], a String with values separated by the given delimiter,
      * or a primitive type array; otherwise to simplify the caller's
      * code, we just create a singleton collection iterator over a single value
-     *
+     * 
+     * </p> In case of primitive type arrays the returned {@code Iterator} iterates
+     * over the corresponding Java primitive wrapper objects of the given elements
+     * inside the {@code value} array. That's we get an autoboxing of the primitive
+     * types here for free as it's also the case in Java language itself.
+     * 
      * @param value             the value
      * @param delimiter         delimiter for separating String values
      * @param allowEmptyValues  whether to allow empty values
@@ -514,9 +525,79 @@ public final class ObjectHelper {
         } else if (value instanceof Iterable) {
             return ((Iterable<Object>)value).iterator();
         } else if (value.getClass().isArray()) {
-            // TODO we should handle primitive array types?
-            List<Object> list = Arrays.asList((Object[])value);
-            return list.iterator();
+            if (isPrimitiveArrayType(value.getClass())) {
+                final Object array = value;
+                return new Iterator<Object>() {
+                    int idx = -1;
+
+                    public boolean hasNext() {
+                        return (idx + 1) < length();
+                    }
+
+                    public Object next() {
+                        idx++;
+                        return current(idx);
+                    }
+
+                    public void remove() {
+                        throw new UnsupportedOperationException();
+                    }
+
+                    private int length() {
+                        int answer = 0;
+                        if (array instanceof byte[]) {
+                            answer = ((byte[]) array).length;
+                        } else if (array instanceof short[]) {
+                            answer = ((short[]) array).length;
+                        } else if (array instanceof int[]) {
+                            answer = ((int[]) array).length;
+                        } else if (array instanceof long[]) {
+                            answer = ((long[]) array).length;
+                        } else if (array instanceof float[]) {
+                            answer = ((float[]) array).length;
+                        } else if (array instanceof double[]) {
+                            answer = ((double[]) array).length;
+                        } else if (array instanceof char[]) {
+                            answer = ((char[]) array).length;
+                        } else if (array instanceof boolean[]) {
+                            answer = ((boolean[]) array).length;
+                        } else {
+                            throw new IllegalStateException("Unexpected type for " + array);
+                        }
+
+                        return answer;
+                    }
+
+                    private Object current(int index) {
+                        Object answer = 0;
+                        if (array instanceof byte[]) {
+                            answer = Byte.valueOf(((byte[]) array)[index]);
+                        } else if (array instanceof short[]) {
+                            answer = Short.valueOf(((short[]) array)[index]);
+                        } else if (array instanceof int[]) {
+                            answer = Integer.valueOf(((int[]) array)[index]);
+                        } else if (array instanceof long[]) {
+                            answer = Long.valueOf(((long[]) array)[index]);
+                        } else if (array instanceof float[]) {
+                            answer = Float.valueOf(((float[]) array)[index]);
+                        } else if (array instanceof double[]) {
+                            answer = Double.valueOf(((double[]) array)[index]);
+                        } else if (array instanceof char[]) {
+                            answer = Character.valueOf(((char[]) array)[index]);
+                        } else if (array instanceof boolean[]) {
+                            answer = Boolean.valueOf(((boolean[]) array)[index]);
+                        } else {
+                            throw new IllegalStateException("Unexpected type for " + array);
+                        }
+
+                        return answer;
+                    }
+
+                };
+            } else {
+                List<Object> list = Arrays.asList((Object[]) value);
+                return list.iterator();
+            }
         } else if (value instanceof NodeList) {
             // lets iterate through DOM results after performing XPaths
             final NodeList nodeList = (NodeList) value;
@@ -1053,6 +1134,26 @@ public final class ObjectHelper {
         return a.isAssignableFrom(b);
     }
 
+    /**
+     * Returns if the given {@code clazz} type is a Java primitive type.
+     * 
+     * @param clazz the Java type to be checked
+     * @return {@code true} if the given type is a Java primitive type
+     */
+    public static boolean isPrimitiveType(Class<?> clazz) {
+        return PRIMITIVE_TYPES.contains(clazz);
+    }
+
+    /**
+     * Returns if the given {@code clazz} type is a Java primitive array type.
+     * 
+     * @param clazz the Java type to be checked
+     * @return {@code true} if the given type is a Java primitive array type
+     */
+    public static boolean isPrimitiveArrayType(Class<?> clazz) {
+        return PRIMITIVE_ARRAY_TYPES.contains(clazz);
+    }
+
     /**
      * Converts primitive types such as int to its wrapper type like
      * {@link Integer}
diff --git a/camel-core/src/test/java/org/apache/camel/util/ObjectHelperTest.java b/camel-core/src/test/java/org/apache/camel/util/ObjectHelperTest.java
index 8162c937451..d8e17c64de8 100644
--- a/camel-core/src/test/java/org/apache/camel/util/ObjectHelperTest.java
+++ b/camel-core/src/test/java/org/apache/camel/util/ObjectHelperTest.java
@@ -25,6 +25,8 @@ import java.util.Iterator;
 import java.util.List;
 
 import junit.framework.TestCase;
+
+import org.apache.camel.CamelContext;
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.component.bean.MyStaticClass;
@@ -184,6 +186,173 @@ public class ObjectHelperTest extends TestCase {
         assertEquals("bean:bar?method=cool('A','Hello,World')", it.next());
     }
 
+    public void testCreateIteratorWithPrimitiveArrayTypes() {
+        Iterator<?> it = ObjectHelper.createIterator(new byte[] {13, Byte.MAX_VALUE, 7, Byte.MIN_VALUE}, null);
+        assertTrue(it.hasNext());
+        assertEquals(Byte.valueOf((byte) 13), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Byte.MAX_VALUE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Byte.valueOf((byte) 7), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Byte.MIN_VALUE, it.next());
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new byte[] {}, null);
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new short[] {13, Short.MAX_VALUE, 7, Short.MIN_VALUE}, null);
+        assertTrue(it.hasNext());
+        assertEquals(Short.valueOf((short) 13), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Short.MAX_VALUE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Short.valueOf((short) 7), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Short.MIN_VALUE, it.next());
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new short[] {}, null);
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new int[] {13, Integer.MAX_VALUE, 7, Integer.MIN_VALUE}, null);
+        assertTrue(it.hasNext());
+        assertEquals(Integer.valueOf(13), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Integer.MAX_VALUE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Integer.valueOf(7), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Integer.MIN_VALUE, it.next());
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new int[] {}, null);
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new long[] {13, Long.MAX_VALUE, 7, Long.MIN_VALUE}, null);
+        assertTrue(it.hasNext());
+        assertEquals(Long.valueOf(13), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Long.MAX_VALUE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Long.valueOf(7), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Long.MIN_VALUE, it.next());
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new long[] {}, null);
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new float[] {13.7F, Float.MAX_VALUE, 7.13F, Float.MIN_VALUE}, null);
+        assertTrue(it.hasNext());
+        assertEquals(Float.valueOf(13.7F), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Float.MAX_VALUE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Float.valueOf(7.13F), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Float.MIN_VALUE, it.next());
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new float[] {}, null);
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new double[] {13.7D, Double.MAX_VALUE, 7.13D, Double.MIN_VALUE}, null);
+        assertTrue(it.hasNext());
+        assertEquals(Double.valueOf(13.7D), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Double.MAX_VALUE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Double.valueOf(7.13D), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Double.MIN_VALUE, it.next());
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new double[] {}, null);
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new char[] {'C', 'a', 'm', 'e', 'l'}, null);
+        assertTrue(it.hasNext());
+        assertEquals(Character.valueOf('C'), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Character.valueOf('a'), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Character.valueOf('m'), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Character.valueOf('e'), it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Character.valueOf('l'), it.next());
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new char[] {}, null);
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new boolean[] {false, true, false, true, true}, null);
+        assertTrue(it.hasNext());
+        assertEquals(Boolean.FALSE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Boolean.TRUE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Boolean.FALSE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Boolean.TRUE, it.next());
+        assertTrue(it.hasNext());
+        assertEquals(Boolean.TRUE, it.next());
+        assertFalse(it.hasNext());
+
+        it = ObjectHelper.createIterator(new boolean[] {}, null);
+        assertFalse(it.hasNext());
+    }
+
+    public void testIsPrimitiveType() {
+        assertTrue(ObjectHelper.isPrimitiveType(byte.class));
+        assertTrue(ObjectHelper.isPrimitiveType(short.class));
+        assertTrue(ObjectHelper.isPrimitiveType(int.class));
+        assertTrue(ObjectHelper.isPrimitiveType(long.class));
+        assertTrue(ObjectHelper.isPrimitiveType(float.class));
+        assertTrue(ObjectHelper.isPrimitiveType(double.class));
+        assertTrue(ObjectHelper.isPrimitiveType(char.class));
+        assertTrue(ObjectHelper.isPrimitiveType(boolean.class));
+        assertTrue(ObjectHelper.isPrimitiveType(void.class));
+
+        assertFalse(ObjectHelper.isPrimitiveType(Object.class));
+        assertFalse(ObjectHelper.isPrimitiveType(Byte.class));
+        assertFalse(ObjectHelper.isPrimitiveType(Short.class));
+        assertFalse(ObjectHelper.isPrimitiveType(Integer.class));
+        assertFalse(ObjectHelper.isPrimitiveType(Long.class));
+        assertFalse(ObjectHelper.isPrimitiveType(Float.class));
+        assertFalse(ObjectHelper.isPrimitiveType(Double.class));
+        assertFalse(ObjectHelper.isPrimitiveType(Character.class));
+        assertFalse(ObjectHelper.isPrimitiveType(Boolean.class));
+        assertFalse(ObjectHelper.isPrimitiveType(Void.class));
+        assertFalse(ObjectHelper.isPrimitiveType(CamelContext.class));
+        assertFalse(ObjectHelper.isPrimitiveType(null));
+    }
+
+    public void testIsPrimitiveArrayType() {
+        assertTrue(ObjectHelper.isPrimitiveArrayType(byte[].class));
+        assertTrue(ObjectHelper.isPrimitiveArrayType(short[].class));
+        assertTrue(ObjectHelper.isPrimitiveArrayType(int[].class));
+        assertTrue(ObjectHelper.isPrimitiveArrayType(long[].class));
+        assertTrue(ObjectHelper.isPrimitiveArrayType(float[].class));
+        assertTrue(ObjectHelper.isPrimitiveArrayType(double[].class));
+        assertTrue(ObjectHelper.isPrimitiveArrayType(char[].class));
+        assertTrue(ObjectHelper.isPrimitiveArrayType(boolean[].class));
+
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Object[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Byte[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Short[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Integer[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Long[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Float[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Double[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Character[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Boolean[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(Void[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(CamelContext[].class));
+        assertFalse(ObjectHelper.isPrimitiveArrayType(null));
+    }
+
     public void testBefore() {
         assertEquals("Hello ", ObjectHelper.before("Hello World", "World"));
         assertEquals("Hello ", ObjectHelper.before("Hello World Again", "World"));
