diff --git a/components/camel-microprofile/camel-microprofile-fault-tolerance/src/main/java/org/apache/camel/component/microprofile/faulttolerance/FaultToleranceProcessor.java b/components/camel-microprofile/camel-microprofile-fault-tolerance/src/main/java/org/apache/camel/component/microprofile/faulttolerance/FaultToleranceProcessor.java
index 5e6c3a22df2..12b46714c15 100644
--- a/components/camel-microprofile/camel-microprofile-fault-tolerance/src/main/java/org/apache/camel/component/microprofile/faulttolerance/FaultToleranceProcessor.java
+++ b/components/camel-microprofile/camel-microprofile-fault-tolerance/src/main/java/org/apache/camel/component/microprofile/faulttolerance/FaultToleranceProcessor.java
@@ -231,34 +231,36 @@ public class FaultToleranceProcessor extends AsyncProcessorSupport
         exchange.setProperty(ExchangePropertyKey.TRY_ROUTE_BLOCK, true);
 
         CircuitBreakerFallbackTask fallbackTask = null;
-        CircuitBreakerTask task = (CircuitBreakerTask) taskFactory.acquire(exchange, callback);
+        CircuitBreakerTask task = null;
+        try {
+            task = (CircuitBreakerTask) taskFactory.acquire(exchange, callback);
 
-        // circuit breaker
-        FaultToleranceStrategy target = circuitBreaker;
+            // circuit breaker
+            FaultToleranceStrategy target = circuitBreaker;
 
-        // 1. bulkhead
-        if (config.isBulkheadEnabled()) {
-            target = new FutureThreadPoolBulkhead(
-                    target, "bulkhead", config.getBulkheadMaxConcurrentCalls(),
-                    config.getBulkheadWaitingTaskQueue());
-        }
-        // 2. timeout
-        if (config.isTimeoutEnabled()) {
-            TimeoutWatcher watcher = new ScheduledExecutorTimeoutWatcher(scheduledExecutorService);
-            target = new Timeout(target, "timeout", config.getTimeoutDuration(), watcher);
-        }
-        // 3. fallback
-        if (fallbackProcessor != null) {
-            fallbackTask = (CircuitBreakerFallbackTask) fallbackTaskFactory.acquire(exchange, callback);
-            final CircuitBreakerFallbackTask fFallbackTask = fallbackTask;
-            target = new Fallback(target, "fallback", fallbackContext -> {
-                exchange.setException(fallbackContext.failure);
-                return fFallbackTask.call();
-            }, ExceptionDecision.ALWAYS_FAILURE);
-        }
+            // 1. bulkhead
+            if (config.isBulkheadEnabled()) {
+                target = new FutureThreadPoolBulkhead(
+                        target, "bulkhead", config.getBulkheadMaxConcurrentCalls(),
+                        config.getBulkheadWaitingTaskQueue());
+            }
+            // 2. timeout
+            if (config.isTimeoutEnabled()) {
+                TimeoutWatcher watcher = new ScheduledExecutorTimeoutWatcher(scheduledExecutorService);
+                target = new Timeout(target, "timeout", config.getTimeoutDuration(), watcher);
+            }
+            // 3. fallback
+            if (fallbackProcessor != null) {
+                fallbackTask = (CircuitBreakerFallbackTask) fallbackTaskFactory.acquire(exchange, callback);
+                final CircuitBreakerFallbackTask fFallbackTask = fallbackTask;
+                target = new Fallback(target, "fallback", fallbackContext -> {
+                    exchange.setException(fallbackContext.failure);
+                    return fFallbackTask.call();
+                }, ExceptionDecision.ALWAYS_FAILURE);
+            }
 
-        try {
             target.apply(new InvocationContext(task));
+
         } catch (CircuitBreakerOpenException e) {
             // the circuit breaker triggered a call rejected
             exchange.setProperty(ExchangePropertyKey.CIRCUIT_BREAKER_RESPONSE_SUCCESSFUL_EXECUTION, false);
@@ -269,7 +271,9 @@ public class FaultToleranceProcessor extends AsyncProcessorSupport
             // some other kind of exception
             exchange.setException(e);
         } finally {
-            taskFactory.release(task);
+            if (task != null) {
+                taskFactory.release(task);
+            }
             if (fallbackTask != null) {
                 fallbackTaskFactory.release(fallbackTask);
             }
diff --git a/components/camel-resilience4j/src/main/java/org/apache/camel/component/resilience4j/ResilienceProcessor.java b/components/camel-resilience4j/src/main/java/org/apache/camel/component/resilience4j/ResilienceProcessor.java
index 1dda3242f63..5b52420f031 100644
--- a/components/camel-resilience4j/src/main/java/org/apache/camel/component/resilience4j/ResilienceProcessor.java
+++ b/components/camel-resilience4j/src/main/java/org/apache/camel/component/resilience4j/ResilienceProcessor.java
@@ -458,27 +458,30 @@ public class ResilienceProcessor extends AsyncProcessorSupport
         // Camel error handler
         exchange.setProperty(ExchangePropertyKey.TRY_ROUTE_BLOCK, true);
 
-        CircuitBreakerFallbackTask fallbackTask = (CircuitBreakerFallbackTask) fallbackTaskFactory.acquire(exchange, callback);
-        CircuitBreakerTask task = (CircuitBreakerTask) taskFactory.acquire(exchange, callback);
-        Callable<Exchange> callable;
-
-        if (timeLimiter != null) {
-            Supplier<CompletableFuture<Exchange>> futureSupplier;
-            if (executorService == null) {
-                futureSupplier = () -> CompletableFuture.supplyAsync(task);
+        CircuitBreakerFallbackTask fallbackTask = null;
+        CircuitBreakerTask task = null;
+        try {
+            fallbackTask = (CircuitBreakerFallbackTask) fallbackTaskFactory.acquire(exchange, callback);
+            task = (CircuitBreakerTask) taskFactory.acquire(exchange, callback);
+            final CircuitBreakerTask ftask = task; // annoying final java thingy!
+            Callable<Exchange> callable;
+
+            if (timeLimiter != null) {
+                Supplier<CompletableFuture<Exchange>> futureSupplier;
+                if (executorService == null) {
+                    futureSupplier = () -> CompletableFuture.supplyAsync(ftask);
+                } else {
+                    futureSupplier = () -> CompletableFuture.supplyAsync(ftask, executorService);
+                }
+                callable = TimeLimiter.decorateFutureSupplier(timeLimiter, futureSupplier);
             } else {
-                futureSupplier = () -> CompletableFuture.supplyAsync(task, executorService);
+                callable = task;
+            }
+            if (bulkhead != null) {
+                callable = Bulkhead.decorateCallable(bulkhead, callable);
             }
-            callable = TimeLimiter.decorateFutureSupplier(timeLimiter, futureSupplier);
-        } else {
-            callable = task;
-        }
-        if (bulkhead != null) {
-            callable = Bulkhead.decorateCallable(bulkhead, callable);
-        }
 
-        callable = CircuitBreaker.decorateCallable(circuitBreaker, callable);
-        try {
+            callable = CircuitBreaker.decorateCallable(circuitBreaker, callable);
             if (LOG.isTraceEnabled()) {
                 LOG.trace("Processing exchange: {} using circuit breaker: {}", exchange.getExchangeId(), id);
             }
@@ -486,8 +489,12 @@ public class ResilienceProcessor extends AsyncProcessorSupport
         } catch (Exception e) {
             exchange.setException(e);
         } finally {
-            taskFactory.release(task);
-            fallbackTaskFactory.release(fallbackTask);
+            if (task != null) {
+                taskFactory.release(task);
+            }
+            if (fallbackTask != null) {
+                fallbackTaskFactory.release(fallbackTask);
+            }
         }
 
         if (LOG.isTraceEnabled()) {
