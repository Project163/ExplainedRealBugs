diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultHeaderFilterStrategy.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultHeaderFilterStrategy.java
index 987c31e6a02..5b8e450fae4 100644
--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultHeaderFilterStrategy.java
+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultHeaderFilterStrategy.java
@@ -20,13 +20,14 @@ import java.util.HashSet;
 import java.util.Set;
 import java.util.regex.Pattern;
 
+import org.apache.camel.Exchange;
 import org.apache.camel.spi.HeaderFilterStrategy;
 
 /**
  * The default header filtering strategy.  Users can configure filter by 
  * setting filter set and/or setting a regular expression.  Subclass can 
  * add extended filter logic in 
- * {@link #extendedFilter(org.apache.camel.impl.DefaultHeaderFilterStrategy.Direction, String, Object)}
+ * {@link #extendedFilter(Direction, String, Object, Exchange)}
  * 
  * Filters are associated with directions (in or out).  "In" direction is 
  * referred to propagating headers "to" Camel message.  The "out" direction
@@ -38,8 +39,6 @@ import org.apache.camel.spi.HeaderFilterStrategy;
  * @version $Revision$
  */
 public class DefaultHeaderFilterStrategy implements HeaderFilterStrategy {
-
-    protected enum Direction { IN, OUT }
     
     private Set<String> inFilter;
     private Pattern inFilterPattern;
@@ -50,12 +49,12 @@ public class DefaultHeaderFilterStrategy implements HeaderFilterStrategy {
     private boolean lowerCase;
     private boolean allowNullValues;
     
-    public boolean applyFilterToCamelHeaders(String headerName, Object headerValue) {
-        return doFiltering(Direction.OUT, headerName, headerValue);
+    public boolean applyFilterToCamelHeaders(String headerName, Object headerValue, Exchange exchange) {
+        return doFiltering(Direction.OUT, headerName, headerValue, exchange);
     }
 
-    public boolean applyFilterToExternalHeaders(String headerName, Object headerValue) {
-        return doFiltering(Direction.IN, headerName, headerValue);
+    public boolean applyFilterToExternalHeaders(String headerName, Object headerValue, Exchange exchange) {
+        return doFiltering(Direction.IN, headerName, headerValue, exchange);
     }
 
     /**
@@ -190,11 +189,11 @@ public class DefaultHeaderFilterStrategy implements HeaderFilterStrategy {
         allowNullValues = value;
     }   
 
-    protected boolean extendedFilter(Direction direction, String key, Object value) {
+    protected boolean extendedFilter(Direction direction, String key, Object value, Exchange exchange) {
         return false;
     }
 
-    private boolean doFiltering(Direction direction, String headerName, Object headerValue) {
+    private boolean doFiltering(Direction direction, String headerName, Object headerValue, Exchange exchange) {
         if (headerName == null) {
             return true;
         }
@@ -230,7 +229,7 @@ public class DefaultHeaderFilterStrategy implements HeaderFilterStrategy {
             }
         }
             
-        if (extendedFilter(direction, headerName, headerValue)) {
+        if (extendedFilter(direction, headerName, headerValue, exchange)) {
             return true;
         }
             
diff --git a/camel-core/src/main/java/org/apache/camel/spi/HeaderFilterStrategy.java b/camel-core/src/main/java/org/apache/camel/spi/HeaderFilterStrategy.java
index 490d2b4f4b9..28fad9ce095 100644
--- a/camel-core/src/main/java/org/apache/camel/spi/HeaderFilterStrategy.java
+++ b/camel-core/src/main/java/org/apache/camel/spi/HeaderFilterStrategy.java
@@ -16,6 +16,8 @@
  */
 package org.apache.camel.spi;
 
+import org.apache.camel.Exchange;
+
  /**
   * Interface to allow plug-able implementation to filter header
   * to and from Camel message.
@@ -25,6 +27,8 @@ package org.apache.camel.spi;
   */
 public interface HeaderFilterStrategy {
 
+    public enum Direction { IN, OUT }
+
     /**
      * Applies filtering logic to Camel Message header that is
      * going to be copied to target message such as CXF and JMS message.
@@ -33,9 +37,10 @@ public interface HeaderFilterStrategy {
      * 
      * @param headerName  the header name
      * @param headerValue the header value
+     * @param exchange the context to perform filtering
      * @return <tt>true</tt> if this header should be filtered out.
      */
-    boolean applyFilterToCamelHeaders(String headerName, Object headerValue);
+    boolean applyFilterToCamelHeaders(String headerName, Object headerValue, Exchange exchange);
 
     
     /**
@@ -47,8 +52,9 @@ public interface HeaderFilterStrategy {
      *  
      * @param headerName  the header name
      * @param headerValue the header value
+     * @param exchange the context to perform filtering
      * @return <tt>true</tt> if this header should be filtered out.
      */
-    boolean applyFilterToExternalHeaders(String headerName, Object headerValue);
+    boolean applyFilterToExternalHeaders(String headerName, Object headerValue, Exchange exchange);
     
 }
diff --git a/components/camel-cxf/pom.xml b/components/camel-cxf/pom.xml
index bec23d01ac9..13c7bb2583e 100644
--- a/components/camel-cxf/pom.xml
+++ b/components/camel-cxf/pom.xml
@@ -325,6 +325,12 @@
       							<extraarg>${basedir}/src/test/resources/person-non-wrapper-binding.xml</extraarg>
       						</extraargs>
       					</wsdlOption>
+      					<wsdlOption>
+      						<wsdl>${basedir}/src/test/resources/soap_header.wsdl</wsdl>
+      						<extraargs>
+      							<extraarg>-verbose</extraarg>
+      						</extraargs>
+      					</wsdlOption>
       					<wsdlOption>
       						<wsdl>${basedir}/src/test/resources/pizza_service.wsdl</wsdl>
       						<extraargs>
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfBinding.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfBinding.java
index b7e3dc93334..aeefbc288ee 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfBinding.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfBinding.java
@@ -24,6 +24,10 @@ import org.apache.cxf.message.Exchange;
  * An strategy interface for implementing binding between CXF {@link Exchange} 
  * and Camel {@link org.apache.camel.Exchange}.  
  * 
+ * Assumptions: CxfProducer and CxfConsumer set {@link #DataFormat} and 
+ * {@link org.apache.cxf.service.model.BindingOperationInfo} 
+ * in Camel Exchange property before calling into these methods.  
+ * 
  * @version $Revision$
  * @since 2.0
  */
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfConsumer.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfConsumer.java
index 06005797947..df536a02954 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfConsumer.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfConsumer.java
@@ -26,6 +26,7 @@ import org.apache.cxf.frontend.ServerFactoryBean;
 import org.apache.cxf.interceptor.Fault;
 import org.apache.cxf.message.Exchange;
 import org.apache.cxf.service.invoker.Invoker;
+import org.apache.cxf.service.model.BindingOperationInfo;
 
 /**
  * A Consumer of exchanges for a service in CXF.  CxfConsumer acts a CXF
@@ -60,6 +61,14 @@ public class CxfConsumer extends DefaultConsumer {
                 // create a Camel exchange
                 org.apache.camel.Exchange camelExchange = endpoint.createExchange();
                 
+                BindingOperationInfo boi = cxfExchange.get(BindingOperationInfo.class);
+                if (boi != null) {
+                    camelExchange.setProperty(BindingOperationInfo.class.getName(), boi);
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace("Set exchange property: BindingOperationInfo: " + boi);
+                    }
+                }
+                
                 // set data format mode in Camel exchange
                 DataFormat dataFormat = endpoint.getDataFormat();
                 camelExchange.setProperty(CxfConstants.DATA_FORMAT_PROPERTY, dataFormat);   
@@ -117,4 +126,5 @@ public class CxfConsumer extends DefaultConsumer {
     public Server getServer() {
         return server;
     }
+    
 }
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfHeaderFilterStrategy.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfHeaderFilterStrategy.java
index 5d413dce306..b3cf206d1c7 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfHeaderFilterStrategy.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfHeaderFilterStrategy.java
@@ -16,9 +16,19 @@
  */
 package org.apache.camel.component.cxf;
 
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.Exchange;
 import org.apache.camel.impl.DefaultHeaderFilterStrategy;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.cxf.endpoint.Client;
+import org.apache.cxf.headers.Header;
 import org.apache.cxf.message.Message;
+import org.apache.cxf.service.model.BindingInfo;
+import org.apache.cxf.service.model.BindingOperationInfo;
 
 /**
  * The default CXF header filter strategy.
@@ -26,6 +36,14 @@ import org.apache.cxf.message.Message;
  * @version $Revision$
  */
 public class CxfHeaderFilterStrategy extends DefaultHeaderFilterStrategy {
+    private static final Log LOG = LogFactory.getLog(CxfHeaderFilterStrategy.class);
+    private Map<String, MessageHeaderFilter> messageHeaderFiltersMap;
+ 
+    private List<MessageHeaderFilter> messageHeaderFilters;
+
+    private boolean relayHeaders = true;
+    private boolean allowFilterNamespaceClash;
+    private boolean relayAllMessageHeaders;
 
     public CxfHeaderFilterStrategy() {
         initialize();  
@@ -44,6 +62,151 @@ public class CxfHeaderFilterStrategy extends DefaultHeaderFilterStrategy {
         // we need to filter the header of this name.
         getOutFilter().add(Message.PROTOCOL_HEADERS);
         getInFilter().add(Message.PROTOCOL_HEADERS);
+        
+        // initialize message header filter map with default SOAP filter
+        messageHeaderFiltersMap = new HashMap<String, MessageHeaderFilter>();
+        addToMessageHeaderFilterMap(new SoapMessageHeaderFilter());
+        
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    protected boolean extendedFilter(Direction direction, String key, Object value, Exchange exchange) {
+        // Currently only handles Header.HEADER_LIST message header relay/filter
+        if (!Header.HEADER_LIST.equals(key) || value == null) { 
+            return false;
+        }
+        
+        if (!relayHeaders) {
+            // not propagating Header.HEADER_LIST at all
+            return true;
+        }
+        
+        if (relayAllMessageHeaders) {
+            // all message headers will be relayed (no filtering)
+            return false;
+        }
+
+        // get filter
+        MessageHeaderFilter messageHeaderfilter = getMessageHeaderFilter(exchange);
+        if (messageHeaderfilter == null) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("No CXF Binding namespace can be resolved.  Message headers are intact.");
+            }
+            return false;
+        }
+        
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("messageHeaderfilter = " + messageHeaderfilter);
+        }
+
+        try {
+            messageHeaderfilter.filter(direction, (List<Header>)value);
+        } catch (Throwable t) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Failed to cast value to Header<List> due to " + t.toString(), t);
+            }
+        }
+        
+        // return false since the header list (which has been filtered) should be propagated
+        return false;
+    }
+
+    private void addToMessageHeaderFilterMap(MessageHeaderFilter filter) {
+        for (String ns : filter.getActivationNamespaces()) {
+            if (messageHeaderFiltersMap.containsKey(ns) && messageHeaderFiltersMap.get(ns) 
+                != messageHeaderFiltersMap && !allowFilterNamespaceClash) {
+                throw new IllegalArgumentException("More then one MessageHeaderRelay activates "
+                                                   + "for the same namespace: " + ns);
+            }
+            messageHeaderFiltersMap.put(ns, filter);
+        }
+    }
+    
+    private MessageHeaderFilter getMessageHeaderFilter(Exchange exchange) {
+        BindingOperationInfo boi = exchange.getProperty(BindingOperationInfo.class.getName(), 
+                                                        BindingOperationInfo.class);
+        String ns = null;
+        if (boi != null) {
+            BindingInfo b = boi.getBinding();
+            if (b != null) {
+                ns = b.getBindingId();
+            }
+        }
+        
+        MessageHeaderFilter answer = null;
+        if (ns != null) {
+            answer = messageHeaderFiltersMap.get(ns);
+        }
+        
+        return answer;
     }
 
+    /**
+     * @param messageHeaderFilters the messageHeaderFilters to set
+     */
+    public void setMessageHeaderFilters(List<MessageHeaderFilter> messageHeaderFilters) {
+        this.messageHeaderFilters = messageHeaderFilters;
+        // clear the amp to allow removal of default filter
+        messageHeaderFiltersMap.clear();
+        for (MessageHeaderFilter filter : messageHeaderFilters) {
+            addToMessageHeaderFilterMap(filter);
+        }
+    }
+
+    /**
+     * @return the messageHeaderFilters
+     */
+    public List<MessageHeaderFilter> getMessageHeaderFilters() {
+        return messageHeaderFilters;
+    }
+
+    /**
+     * @return the allowFilterNamespaceClash
+     */
+    public boolean isAllowFilterNamespaceClash() {
+        return allowFilterNamespaceClash;
+    }
+
+    /**
+     * @param allowFilterNamespaceClash the allowFilterNamespaceClash to set
+     */
+    public void setAllowFilterNamespaceClash(boolean allowFilterNamespaceClash) {
+        this.allowFilterNamespaceClash = allowFilterNamespaceClash;
+    }
+    
+    /**
+     * @return the messageHeaderFiltersMap
+     */
+    public Map<String, MessageHeaderFilter> getMessageHeaderFiltersMap() {
+        return messageHeaderFiltersMap;
+    }
+
+    /**
+     * @param relayHeaders the relayHeaders to set
+     */
+    public void setRelayHeaders(boolean relayHeaders) {
+        this.relayHeaders = relayHeaders;
+    }
+
+    /**
+     * @return the relayHeaders
+     */
+    public boolean isRelayHeaders() {
+        return relayHeaders;
+    }
+
+    /**
+     * @return the relayAllMessageHeaders
+     */
+    public boolean isRelayAllMessageHeaders() {
+        return relayAllMessageHeaders;
+    }
+
+    /**
+     * @param relayAllMessageHeaders the relayAllMessageHeaders to set
+     */
+    public void setRelayAllMessageHeaders(boolean relayAllMessageHeaders) {
+        this.relayAllMessageHeaders = relayAllMessageHeaders;
+    }
 }
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java
index 35ef6fcb854..77ea2475c04 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfProducer.java
@@ -104,10 +104,6 @@ public class CxfProducer extends DefaultProducer {
             }
         }
         
-        // bind the request CXF exchange
-        binding.populateCxfRequestFromExchange(cxfExchange, camelExchange, 
-                requestContext);
- 
         // get binding operation info
         BindingOperationInfo boi = getBindingOperationInfo(camelExchange);
         if (LOG.isTraceEnabled()) {
@@ -126,6 +122,15 @@ public class CxfProducer extends DefaultProducer {
             }
         }
         
+        camelExchange.setProperty(BindingOperationInfo.class.getName(), boi);
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Set exchange property: BindingOperationInfo: " + boi);
+        }
+        
+        // bind the request CXF exchange
+        binding.populateCxfRequestFromExchange(cxfExchange, camelExchange, 
+                requestContext);
+        
         // Remove protocol headers from scopes.  Otherwise, response headers can be
         // overwritten by request headers when SOAPHandlerInterceptor tries to create
         // a wrapped message context by the copyScoped() method.
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfSoapBinding.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfSoapBinding.java
index 14fc76a207a..0a1872cd309 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfSoapBinding.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/CxfSoapBinding.java
@@ -48,7 +48,7 @@ public final class CxfSoapBinding {
             exchange.setProperty(CxfConstants.CXF_EXCHANGE, cxfExchange);
         }
 
-        CxfHeaderHelper.propagateCamelToCxf(headerFilterStrategy, message.getHeaders(), answer);
+        CxfHeaderHelper.propagateCamelToCxf(headerFilterStrategy, message.getHeaders(), answer, exchange);
 
         InputStream body = null;
         try {
@@ -79,7 +79,7 @@ public final class CxfSoapBinding {
             message = exchange.getOut();
         }
 
-        CxfHeaderHelper.propagateCamelToCxf(headerFilterStrategy, message.getHeaders(), outMessage);
+        CxfHeaderHelper.propagateCamelToCxf(headerFilterStrategy, message.getHeaders(), outMessage, exchange);
 
         // send the body back
         Source body = null;
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/DefaultCxfBinding.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/DefaultCxfBinding.java
index 8f44aca6af0..2902ca15cb4 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/DefaultCxfBinding.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/DefaultCxfBinding.java
@@ -113,7 +113,7 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
         }
         
         // propagate protocol headers
-        propagateHeadersFromCxfToCamel(cxfMessage, camelExchange.getOut());
+        propagateHeadersFromCxfToCamel(cxfMessage, camelExchange.getOut(), camelExchange);
     }
     
     /**
@@ -127,40 +127,36 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
         ExchangePattern mep = ExchangePattern.InOut;
         
         // extract binding operation information
-        BindingOperationInfo bop = cxfExchange.get(BindingOperationInfo.class);
-        if (bop != null) {
-            camelExchange.setProperty(BindingOperationInfo.class.getName(), bop);
-            if (LOG.isTraceEnabled()) {
-                LOG.trace("Set exchange property: BindingOperationInfo: " + bop);
-            }
-
+        BindingOperationInfo boi = camelExchange.getProperty(BindingOperationInfo.class.getName(), 
+                                                             BindingOperationInfo.class);
+        if (boi != null) {
             Service service = (Service)cxfExchange.get(Service.class); 
             if (service != null) {
                 MethodDispatcher md = (MethodDispatcher)service
                     .get(MethodDispatcher.class.getName());
                 if (md != null) {
-                    method = md.getMethod(bop);
+                    method = md.getMethod(boi);
                 }
             }
             
-            if (bop.getOperationInfo().isOneWay()) {
+            if (boi.getOperationInfo().isOneWay()) {
                 mep = ExchangePattern.InOnly;
             }
                 
-            operationName = bop.getName();
+            operationName = boi.getName();
         }
         
         // set operation name in header
         if (operationName != null) {
             camelExchange.getIn().setHeader(CxfConstants.OPERATION_NAMESPACE, 
-                    bop.getName().getNamespaceURI());
+                    boi.getName().getNamespaceURI());
             camelExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, 
-                    bop.getName().getLocalPart());
+                    boi.getName().getLocalPart());
             if (LOG.isTraceEnabled()) {
                 LOG.trace("Set IN header: " + CxfConstants.OPERATION_NAMESPACE + "=" 
-                         + bop.getName().getNamespaceURI());
+                         + boi.getName().getNamespaceURI());
                 LOG.trace("Set IN header: " + CxfConstants.OPERATION_NAME + "=" 
-                        + bop.getName().getLocalPart());
+                        + boi.getName().getLocalPart());
             }
         } else if (method != null) {
             camelExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, method.getName());
@@ -169,7 +165,7 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
                         + method.getName());
             }
         }
-        
+                
         // set message exchange pattern
         camelExchange.setPattern(mep);
         if (LOG.isTraceEnabled()) {
@@ -178,7 +174,7 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
 
         // propagate headers
         Message cxfMessage = cxfExchange.getInMessage();
-        propagateHeadersFromCxfToCamel(cxfMessage, camelExchange.getIn());
+        propagateHeadersFromCxfToCamel(cxfMessage, camelExchange.getIn(), camelExchange);
         
         // Propagating properties from CXF Exchange to Camel Exchange has an  
         // side effect of copying reply side stuff when the producer is retried.
@@ -188,7 +184,7 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
         // propagate request context
         Object value = cxfMessage.get(Client.REQUEST_CONTEXT);
         if (value != null && !headerFilterStrategy.applyFilterToExternalHeaders(
-                Client.REQUEST_CONTEXT, value)) {
+                Client.REQUEST_CONTEXT, value, camelExchange)) {
             camelExchange.getIn().setHeader(Client.REQUEST_CONTEXT, value);
             if (LOG.isTraceEnabled()) {
                 LOG.trace("Populate context from CXF message " + Client.REQUEST_CONTEXT 
@@ -236,6 +232,10 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
         }
         outMessage.put(Client.RESPONSE_CONTEXT, responseContext);      
         
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Set out response context = " + responseContext);
+        }
+        
         // set body
         Object outBody = DefaultCxfBinding.getBodyFromCamel(camelExchange.getOut(), dataFormat);
         
@@ -245,6 +245,10 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
                 outMessage.put(List.class, payload.getBody());
                 outMessage.put(Header.HEADER_LIST, payload.getHeaders());
             } else {
+                if (responseContext.get(Header.HEADER_LIST) != null) {
+                    outMessage.put(Header.HEADER_LIST, responseContext.get(Header.HEADER_LIST));
+                }
+
                 MessageContentsList resList = null;
                 if (outBody instanceof MessageContentsList) {
                     resList = (MessageContentsList)outBody;
@@ -335,16 +339,18 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
     /**
      * @param cxfMessage
      * @param camelMessage
+     * @param exchange provides context for filtering
      */
     protected void propagateHeadersFromCxfToCamel(Message cxfMessage,
-            org.apache.camel.Message camelMessage) {
+            org.apache.camel.Message camelMessage, Exchange exchange) {
         
         Map<String, List<String>> cxfHeaders = (Map)cxfMessage.get(Message.PROTOCOL_HEADERS);
         Map<String, Object> camelHeaders = camelMessage.getHeaders();
 
         if (cxfHeaders != null) {
             for (Map.Entry<String, List<String>> entry : cxfHeaders.entrySet()) {
-                if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue())) {
+                if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), 
+                                                                       entry.getValue(), exchange)) {
                     camelHeaders.put(entry.getKey(), entry.getValue().get(0));
                     if (LOG.isTraceEnabled()) {
                         LOG.trace("Populate header from CXF header=" + entry.getKey() + " value="
@@ -357,12 +363,26 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
         // propagate content type
         String key = Message.CONTENT_TYPE;
         Object value = cxfMessage.get(key);
-        if (value != null && !headerFilterStrategy.applyFilterToExternalHeaders(key, value)) {
+        if (value != null && !headerFilterStrategy.applyFilterToExternalHeaders(key, value, exchange)) {
             camelHeaders.put(CamelTransportConstants.CONTENT_TYPE, value);
             if (LOG.isTraceEnabled()) {
                 LOG.trace("Populate header from CXF header=" + key + " value=" + value);
             }
         }
+        
+        // propagate SOAP/protocol header list
+        key = Header.HEADER_LIST;
+        value = cxfMessage.get(key);
+        if (value != null) {
+            if (!headerFilterStrategy.applyFilterToExternalHeaders(key, value, exchange)) {
+                camelHeaders.put(key, value);
+                if (LOG.isTraceEnabled()) {
+                    LOG.trace("Populate header from CXF header=" + key + " value=" + value);
+                }
+            } else {
+                ((List<?>)value).clear();
+            }
+        }
               
     }
 
@@ -386,10 +406,14 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
             
         for (Map.Entry<String, Object> entry : camelHeaders.entrySet()) {    
             // this header should be filtered, continue to the next header
-            if (headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue())) {
+            if (headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), camelExchange)) {
                 continue;
             }
             
+            if (LOG.isTraceEnabled()) {
+                LOG.trace("Propagate to CXF header: " + entry.getKey() + " value: " + entry.getValue());
+            }
+            
             // put content type in exchange
             if (CamelTransportConstants.CONTENT_TYPE.equals(entry.getKey())) {
                 cxfExchange.put(Message.CONTENT_TYPE, entry.getValue());
@@ -402,8 +426,19 @@ public class DefaultCxfBinding implements CxfBinding, HeaderFilterStrategyAware
                 continue;
             }
             
-            if (LOG.isTraceEnabled()) {
-                LOG.trace("Propagate to CXF header: " + entry.getKey() + " value: " + entry.getValue());
+            // put SOAP/protocol header list in exchange
+            if (Header.HEADER_LIST.equals(entry.getKey())) {
+                List<Header> headerList = (List<Header>)entry.getValue();
+                for (Header header : headerList) {
+                    header.setDirection(Header.Direction.DIRECTION_OUT);
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace("Propagate SOAP/protocol header: " + header.getName() + " : " + header.getObject());
+                    }
+                }
+                
+                //cxfExchange.put(Header.HEADER_LIST, headerList);
+                cxfContext.put(entry.getKey(), headerList);
+                continue;
             }
             
             // things that are not filtered and not specifically copied will be put in transport headers
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/MessageHeaderFilter.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/MessageHeaderFilter.java
new file mode 100644
index 00000000000..19a62778363
--- /dev/null
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/MessageHeaderFilter.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.cxf;
+
+import java.util.List;
+
+import org.apache.camel.spi.HeaderFilterStrategy.Direction;
+import org.apache.cxf.headers.Header;
+
+/**
+ * Filter the wire message headers from one CXF endpoint to another CXF endpoint
+ *
+ */
+public interface MessageHeaderFilter {
+
+    /**
+     * @return a list of binding name spaces that this relay can service
+     */
+    List<String> getActivationNamespaces();
+
+    /**
+     *  This method filters (removes) headers from the given header list. 
+     *  <i>Out</i> direction refers to processing headers from a Camel message to an 
+     *  CXF message.  <i>In</i> direction is the reverse direction.
+     *  
+     *  @param direction the direction of the processing
+     *  @param headers the origin list of headers
+     */
+    void filter(Direction direction, List<Header> headers);
+}
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/SoapMessageHeaderFilter.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/SoapMessageHeaderFilter.java
new file mode 100644
index 00000000000..275ec6ca61d
--- /dev/null
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/SoapMessageHeaderFilter.java
@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.cxf;
+
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.camel.spi.HeaderFilterStrategy.Direction;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.cxf.binding.soap.SoapBindingConstants;
+import org.apache.cxf.binding.soap.SoapBindingFactory;
+import org.apache.cxf.binding.soap.SoapHeader;
+import org.apache.cxf.binding.soap.SoapVersion;
+import org.apache.cxf.binding.soap.SoapVersionFactory;
+import org.apache.cxf.headers.Header;
+
+/**
+ * A {@link MessageHeaderFilter} to drop all SOAP headers.
+ *
+ * @version $Revision$
+ */
+public class SoapMessageHeaderFilter implements MessageHeaderFilter {
+    private static final Log LOG = LogFactory.getLog(SoapMessageHeaderFilter.class);
+
+    private static final List<String> ACTIVATION_NS = 
+        Arrays.asList(SoapBindingConstants.SOAP11_BINDING_ID, 
+                      SoapBindingFactory.SOAP_11_BINDING, 
+                      SoapBindingFactory.SOAP_12_BINDING);
+    
+    public List<String> getActivationNamespaces() {
+        return ACTIVATION_NS;
+    }
+
+    public void filter(Direction direction, List<Header> headers) {
+        // Treat both in and out direction the same
+        if (headers == null) {
+            return;
+        }
+        
+        Iterator<Header> iterator = headers.iterator();
+        while (iterator.hasNext()) {
+            Header header = iterator.next();
+            if (LOG.isTraceEnabled()) {
+                LOG.trace("Processing header: " + header);
+            }
+            
+            if (!(header instanceof SoapHeader)) {
+                if (LOG.isTraceEnabled()) {
+                    LOG.trace("Skipped header: " + header + " since it is not a SoapHeader");
+                }
+                continue;
+            }
+            
+            SoapHeader soapHeader = SoapHeader.class.cast(header);
+            for (Iterator<SoapVersion> itv = SoapVersionFactory.getInstance().getVersions(); itv.hasNext();) {
+                SoapVersion version = itv.next();
+
+                if (soapHeader.getActor() != null 
+                    && soapHeader.getActor().equals(version.getNextRole())) {
+                    // dropping headers if actor/role equals to {ns}/role|actor/next
+                    // cxf SoapHeader needs to have soap:header@relay attribute, 
+                    // then we can check for it here as well
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace("Filtered header: " + header);
+                    }
+                    iterator.remove();
+                    break;
+                }
+            }
+        }
+    }
+
+}
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelConduit.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelConduit.java
index 40030bf4843..04644f47008 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelConduit.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelConduit.java
@@ -171,7 +171,7 @@ public class CamelConduit extends AbstractConduit implements Configurable {
                 public void process(org.apache.camel.Exchange ex) throws IOException {
                     CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
                     // Send out the request message here, copy the protocolHeader back
-                    CxfHeaderHelper.propagateCxfToCamel(headerFilterStrategy, outMessage, ex.getIn().getHeaders());
+                    CxfHeaderHelper.propagateCxfToCamel(headerFilterStrategy, outMessage, ex.getIn().getHeaders(), ex);
  
                     // TODO support different encoding
                     ex.getIn().setBody(outputStream.getBytes());
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelDestination.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelDestination.java
index 1f02ab37927..e8808cdd54e 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelDestination.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelDestination.java
@@ -261,7 +261,8 @@ public class CamelDestination extends AbstractDestination implements Configurabl
         private void commitOutputMessage() throws IOException {
             Exchange camelExchange = (Exchange)outMessage.get(CxfConstants.CAMEL_EXCHANGE);
             
-            CxfHeaderHelper.propagateCxfToCamel(headerFilterStrategy, outMessage, camelExchange.getOut().getHeaders());
+            CxfHeaderHelper.propagateCxfToCamel(headerFilterStrategy, outMessage, 
+                                                camelExchange.getOut().getHeaders(), camelExchange);
             CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
             camelExchange.getOut().setBody(outputStream.getBytes());
             getLogger().log(Level.FINE, "send the response message: " + outputStream);
diff --git a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/util/CxfHeaderHelper.java b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/util/CxfHeaderHelper.java
index b2988f15150..66cb3eca7b4 100644
--- a/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/util/CxfHeaderHelper.java
+++ b/components/camel-cxf/src/main/java/org/apache/camel/component/cxf/util/CxfHeaderHelper.java
@@ -21,6 +21,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import org.apache.camel.Exchange;
 import org.apache.camel.component.cxf.transport.CamelTransportConstants;
 import org.apache.camel.spi.HeaderFilterStrategy;
 import org.apache.cxf.endpoint.Client;
@@ -46,9 +47,10 @@ public final class CxfHeaderHelper {
      * @param strategy header filter strategy
      * @param headers Camel header
      * @param message CXF meassage
+     * @param exchange provides context for filtering
      */
     public static void propagateCamelToCxf(HeaderFilterStrategy strategy,
-            Map<String, Object> headers, Message message) {
+            Map<String, Object> headers, Message message, Exchange exchange) {
 
         Map<String, List<String>> cxfHeaders =
             CastUtils.cast((Map)message.get(Message.PROTOCOL_HEADERS));
@@ -60,7 +62,7 @@ public final class CxfHeaderHelper {
 
         for (Map.Entry<String, Object> entry : headers.entrySet()) {
             if (strategy != null
-                    && !strategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue())) {
+                    && !strategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {
 
                 if (CamelTransportConstants.CONTENT_TYPE.equals(entry.getKey())) {
                     message.put(Message.CONTENT_TYPE, entry.getValue());
@@ -78,7 +80,7 @@ public final class CxfHeaderHelper {
     }
 
     public static void propagateCxfToCamel(HeaderFilterStrategy strategy,
-            Message message, Map<String, Object> headers) {
+            Message message, Map<String, Object> headers, Exchange exchange) {
 
         if (strategy == null) {
             return;
@@ -89,7 +91,7 @@ public final class CxfHeaderHelper {
 
         if (cxfHeaders != null) {
             for (Map.Entry<String, List<String>> entry : cxfHeaders.entrySet()) {
-                if (!strategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue())) {
+                if (!strategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {
                     headers.put(entry.getKey(), entry.getValue().get(0));
                 }
             }
@@ -98,21 +100,21 @@ public final class CxfHeaderHelper {
         // propagate content type
         String key = Message.CONTENT_TYPE;
         Object value = message.get(key);
-        if (value != null && !strategy.applyFilterToExternalHeaders(key, value)) {
+        if (value != null && !strategy.applyFilterToExternalHeaders(key, value, exchange)) {
             headers.put(CamelTransportConstants.CONTENT_TYPE, value);
         }
 
         // propagate request context
         key = Client.REQUEST_CONTEXT;
         value = message.get(key);
-        if (value != null && !strategy.applyFilterToExternalHeaders(key, value)) {
+        if (value != null && !strategy.applyFilterToExternalHeaders(key, value, exchange)) {
             headers.put(key, value);
         }
 
         // propagate response context
         key = Client.RESPONSE_CONTEXT;
         value = message.get(key);
-        if (value != null && !strategy.applyFilterToExternalHeaders(key, value)) {
+        if (value != null && !strategy.applyFilterToExternalHeaders(key, value, exchange)) {
             headers.put(key, value);
         }
     }
diff --git a/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/Constants.java b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/Constants.java
new file mode 100644
index 00000000000..41e0db3df16
--- /dev/null
+++ b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/Constants.java
@@ -0,0 +1,65 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.cxf.soap.headers;
+
+public final class Constants {
+
+    public static final String TEST_HDR_NS = "http://cxf.apache.org/outofband/Header";
+    public static final String TEST_HDR_REQUEST_ELEM = "outofbandHeader";
+    public static final String TEST_HDR_RESPONSE_ELEM = "outofbandHeader";
+    public static final SOAPHeaderData IN_HEADER_DATA = new SOAPHeaderData();
+    public static final SOAPHeaderData OUT_HEADER_DATA = new SOAPHeaderData();
+    public static final SOAPHeaderData IN_OUT_REQUEST_HEADER_DATA = new SOAPHeaderData();
+    public static final SOAPHeaderData IN_OUT_RESPONSE_HEADER_DATA = new SOAPHeaderData();
+    
+    static {
+        IN_HEADER_DATA.setOriginator("CxfSoapHeaderRoutePropagationTest.testInHeader");        
+        IN_HEADER_DATA.setMessage("Invoking CxfSoapHeaderRoutePropagationTest.testInHeader()");
+        OUT_HEADER_DATA.setOriginator("CxfSoapHeaderRoutePropagationTest.testOutHeader");        
+        OUT_HEADER_DATA.setMessage("Invoking CxfSoapHeaderRoutePropagationTest.testOutHeader()");
+        IN_OUT_REQUEST_HEADER_DATA.setOriginator("CxfSoapHeaderRoutePropagationTest.testInOutHeader Requestor");        
+        IN_OUT_REQUEST_HEADER_DATA.setMessage("Invoking CxfSoapHeaderRoutePropagationTest.testInOutHeader() Request");
+        IN_OUT_RESPONSE_HEADER_DATA.setOriginator("CxfSoapHeaderRoutePropagationTest.testInOutHeader Responser");        
+        IN_OUT_RESPONSE_HEADER_DATA.setMessage("Invoking CxfSoapHeaderRoutePropagationTest.testInOutHeader() Responser");
+    }
+    
+    private Constants() {
+    }
+    
+    public static boolean equals(SOAPHeaderData lhs, SOAPHeaderData rhs) {
+        if (compare(lhs, rhs)) {
+            return true;
+        }
+        if (compare(lhs.getMessage(), rhs.getMessage())) {
+            return true;
+        }
+        if (compare(lhs.getOriginator(), rhs.getOriginator())) {
+            return true;
+        }
+        return false;
+    }
+    
+    public static <L, R> boolean compare(L lhs, R rhs) {
+        if (lhs == rhs) {
+            return true;
+        }
+        if (lhs == null || rhs == null && lhs != rhs) {
+            return false;
+        }
+        return lhs.equals(rhs);        
+    }
+}
diff --git a/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CustomHeaderFilter.java b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CustomHeaderFilter.java
new file mode 100644
index 00000000000..035f462f535
--- /dev/null
+++ b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CustomHeaderFilter.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.cxf.soap.headers;
+
+import java.util.Arrays;
+import java.util.List;
+
+
+import org.apache.camel.component.cxf.MessageHeaderFilter;
+import org.apache.camel.spi.HeaderFilterStrategy.Direction;
+import org.apache.cxf.headers.Header;
+
+public class CustomHeaderFilter implements MessageHeaderFilter {
+
+    public static final String ACTIVATION_NAMESPACE = "http://cxf.apache.org/bindings/custom";
+    public static final List<String> ACTIVATION_NAMESPACES = Arrays.asList(ACTIVATION_NAMESPACE);
+
+
+    public List<String> getActivationNamespaces() {
+        return ACTIVATION_NAMESPACES;
+    }
+
+    public void filter(Direction direction, List<Header> headers) {        
+    }
+
+
+
+}
diff --git a/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java
new file mode 100644
index 00000000000..d64e3ab68ba
--- /dev/null
+++ b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java
@@ -0,0 +1,497 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.cxf.soap.headers;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Proxy;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.JAXBException;
+import javax.xml.namespace.QName;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.Endpoint;
+import javax.xml.ws.Holder;
+
+import org.w3c.dom.Node;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.component.cxf.CxfConstants;
+import org.apache.camel.component.cxf.CxfEndpoint;
+import org.apache.camel.component.cxf.CxfHeaderFilterStrategy;
+import org.apache.camel.component.cxf.MessageHeaderFilter;
+import org.apache.camel.impl.DefaultExchange;
+import org.apache.cxf.binding.soap.SoapHeader;
+import org.apache.cxf.endpoint.Client;
+import org.apache.cxf.headers.Header;
+import org.apache.cxf.helpers.CastUtils;
+import org.apache.cxf.jaxb.JAXBDataBinding;
+import org.apache.cxf.message.MessageContentsList;
+import org.apache.cxf.outofband.header.OutofBandHeader;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit38.AbstractJUnit38SpringContextTests;
+
+
+/**
+ * This test suite verifies message header filter features
+ *
+ * @version $Revision$
+ */
+@ContextConfiguration
+public class CxfMessageHeadersRelayTest extends AbstractJUnit38SpringContextTests {
+
+    @Autowired
+    protected CamelContext context;
+    protected ProducerTemplate template;
+
+    private Endpoint relayEndpoint;
+    private Endpoint noRelayEndpoint;
+    
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        template = context.createProducerTemplate();
+
+        relayEndpoint = Endpoint.publish("http://localhost:9090/HeaderService/", new HeaderTesterImpl());
+        noRelayEndpoint = Endpoint.publish("http://localhost:7070/HeaderService/", new HeaderTesterImpl(false));
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        
+        if (relayEndpoint != null) {
+            relayEndpoint.stop();
+            relayEndpoint = null;
+        }
+        
+        if (noRelayEndpoint != null) {
+            noRelayEndpoint.stop();
+            noRelayEndpoint = null;
+        }
+
+        super.tearDown();
+    }
+    
+    protected static void addOutOfBoundHeader(HeaderTester proxy, boolean invalid) throws JAXBException {
+        InvocationHandler handler  = Proxy.getInvocationHandler(proxy);
+        BindingProvider  bp = null;
+
+        try {
+            if (handler instanceof BindingProvider) {
+                bp = (BindingProvider)handler;
+                Map<String, Object> requestContext = bp.getRequestContext();
+                requestContext.put(Header.HEADER_LIST, buildOutOfBandHeaderList(invalid)); 
+            }
+        } catch (JAXBException ex) {
+            throw ex;
+        }
+        
+    }
+    
+    public void testInHeaderCXFClientRelay() throws Exception {
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortRelay();
+        InHeader me = new InHeader();
+        me.setRequestType("CXF user");
+        InHeaderResponse response = proxy.inHeader(me, Constants.IN_HEADER_DATA);
+        assertTrue("Expected in band header to propagate but it didn't", 
+                   response.getResponseType().equals("pass"));
+    }
+    
+   
+    public void testOutHeaderCXFClientRelay() throws Exception {
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortRelay();
+        OutHeader me = new OutHeader();
+        me.setRequestType("CXF user");
+        Holder<OutHeaderResponse> result = new Holder<OutHeaderResponse>(new OutHeaderResponse()); 
+        Holder<SOAPHeaderData> header = new Holder<SOAPHeaderData>(new SOAPHeaderData());
+        proxy.outHeader(me, result, header);
+        assertTrue("Expected in band header to propagate but it didn't", 
+                   result.value.getResponseType().equals("pass"));
+        assertTrue("Expected in band response header to propagate but it either didn't " 
+                   + " or its contents do not match",
+                   Constants.equals(Constants.OUT_HEADER_DATA, header.value));
+    }
+
+    public void testInOutHeaderCXFClientRelay() throws Exception {
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortRelay();
+        InoutHeader me = new InoutHeader();
+        me.setRequestType("CXF user");
+        Holder<SOAPHeaderData> header = new Holder<SOAPHeaderData>(Constants.IN_OUT_REQUEST_HEADER_DATA);
+        InoutHeaderResponse result = proxy.inoutHeader(me, header);
+        assertTrue("Expected in band header to propagate but it didn't", 
+                   result.getResponseType().equals("pass"));
+        assertTrue("Expected in band response header to propagate but it either didn't " 
+                   + " or its contents do not match",
+                   Constants.equals(Constants.IN_OUT_RESPONSE_HEADER_DATA, header.value));
+    }
+
+    public void testInOutOfBandHeaderCXFClientRelay() throws Exception {
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortRelay();
+        addOutOfBoundHeader(proxy, false);
+        Me me = new Me();
+        me.setFirstName("john");
+        me.setLastName("Doh");
+        Me response = proxy.inOutOfBandHeader(me);
+        assertTrue("Expected the out of band header to propagate but it didn't", 
+                   response.getFirstName().equals("pass"));
+    }
+    
+    public void testInoutOutOfBandHeaderCXFClientRelay() throws Exception {
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortRelay();
+        addOutOfBoundHeader(proxy, false);
+        Me me = new Me();
+        me.setFirstName("john");
+        me.setLastName("Doh");
+        Me response = proxy.inoutOutOfBandHeader(me);
+        assertTrue("Expected the out of band header to propagate but it didn't", 
+                   response.getFirstName().equals("pass"));
+        validateReturnedOutOfBandHeader(proxy);
+    }
+
+    public void testOutOutOfBandHeaderCXFClientRelay() throws Exception {
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortRelay();
+        Me me = new Me();
+        me.setFirstName("john");
+        me.setLastName("Doh");
+        Me response = proxy.outOutOfBandHeader(me);
+        assertTrue("Expected the out of band header to propagate but it didn't", 
+                   response.getFirstName().equals("pass"));
+        validateReturnedOutOfBandHeader(proxy);
+    }
+    
+    public void testInOutOfBandHeaderCXFClientNoRelay() throws Exception {
+
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortNoRelay();
+        addOutOfBoundHeader(proxy, false);
+        Me me = new Me();
+        me.setFirstName("john");
+        me.setLastName("Doh");
+        Me response = proxy.inOutOfBandHeader(me);
+        assertTrue("Expected the in out of band header *not* to propagate but it did", 
+                   response.getFirstName().equals("pass"));
+        
+    }
+    
+    public void testOutOutOfBandHeaderCXFClientNoRelay() throws Exception {
+        
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortNoRelay();
+        Me me = new Me();
+        me.setFirstName("john");
+        me.setLastName("Doh");
+        Thread.sleep(5000);
+        Me response = proxy.outOutOfBandHeader(me);
+        assertTrue("Expected the out out of band header *not* to propagate but it did", 
+                   response.getFirstName().equals("pass"));
+        validateReturnedOutOfBandHeader(proxy, false);
+    }
+
+    
+    public void testInoutOutOfBandHeaderCXFClientNoRelay() throws Exception {
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortNoRelay();
+        addOutOfBoundHeader(proxy, false);
+        Me me = new Me();
+        me.setFirstName("john");
+        me.setLastName("Doh");
+        Me response = proxy.inoutOutOfBandHeader(me);
+        assertTrue("Expected the in out of band header to *not* propagate but it did", 
+                   response.getFirstName().equals("pass"));
+        validateReturnedOutOfBandHeader(proxy, false);
+    }
+
+    public void testInHeaderCXFClientNoRelay() throws Exception {
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortNoRelay();
+        InHeader me = new InHeader();
+        me.setRequestType("CXF user");
+        InHeaderResponse response = null;
+        try {
+            response = proxy.inHeader(me, Constants.IN_HEADER_DATA);
+        } catch (Exception e) {
+            int i = 0;
+        }
+        assertTrue("Expected in in band header *not* to propagate but it did", 
+                   response.getResponseType().equals("pass"));
+    }
+    
+    public void testOutHeaderCXFClientNoRelay() throws Exception {
+        Thread.sleep(5000);
+
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortNoRelay();
+        OutHeader me = new OutHeader();
+        me.setRequestType("CXF user");
+        Holder<OutHeaderResponse> result = new Holder<OutHeaderResponse>(new OutHeaderResponse()); 
+        Holder<SOAPHeaderData> header = new Holder<SOAPHeaderData>(new SOAPHeaderData());
+        try {
+            proxy.outHeader(me, result, header);
+        } catch (Exception e) {
+            int i = 0;
+        }
+        assertTrue("Ultimate remote HeaderTester.outHeader() destination was not reached", 
+                   result.value.getResponseType().equals("pass"));
+        assertTrue("Expected in band response header *not* to propagate but it did",
+                   header.value == null);
+    }
+    
+    public void testInoutHeaderCXFClientNoRelay() throws Exception {
+        HeaderService s = new HeaderService(getClass().getClassLoader().getResource("soap_header.wsdl"),
+                                            HeaderService.SERVICE);
+        HeaderTester proxy = s.getSoapPortNoRelay();
+        InoutHeader me = new InoutHeader();
+        me.setRequestType("CXF user");
+        Holder<SOAPHeaderData> header = new Holder<SOAPHeaderData>(Constants.IN_OUT_REQUEST_HEADER_DATA);
+        InoutHeaderResponse result = null;
+        try {
+            result = proxy.inoutHeader(me, header);
+        } catch (Exception e) {
+            int i = 0;
+        }
+        assertTrue("Expected in band out header *not* to propagate but it did", 
+                   result.getResponseType().equals("pass"));
+        assertTrue("Expected in band response header *not* to propagate but did",
+                   header.value == null);
+    }
+
+    public void testMessageHeadersRelaysSpringContext() throws Exception {
+        CxfEndpoint endpoint = (CxfEndpoint)context
+            .getEndpoint("cxf:bean:serviceExtraRelays?headerFilterStrategy=#customMessageFilterStrategy");
+        CxfHeaderFilterStrategy strategy = (CxfHeaderFilterStrategy)endpoint.getHeaderFilterStrategy();
+        List<MessageHeaderFilter> filters = strategy.getMessageHeaderFilters();
+        assertEquals("Expected number of filters ", 2, filters.size());
+        Map<String, MessageHeaderFilter> messageHeaderFilterMap = strategy.getMessageHeaderFiltersMap();
+        for (String ns : new CustomHeaderFilter().getActivationNamespaces()) {
+            assertEquals("Expected a filter class for namespace: " + ns,
+                         CustomHeaderFilter.class, messageHeaderFilterMap.get(ns).getClass());
+        }
+    }
+    
+    public void testInOutOfBandHeaderCamelTemplateDirect() throws Exception {
+        doTestInOutOfBandHeaderCamelTemplate("direct:directProducer");
+    }
+
+    public void testOutOutOfBandHeaderCamelTemplateDirect() throws Exception {
+        doTestOutOutOfBandHeaderCamelTemplate("direct:directProducer");
+    }
+    
+    public void testInOutOutOfBandHeaderCamelTemplateDirect() throws Exception {
+        doTestInOutOutOfBandHeaderCamelTemplate("direct:directProducer");
+    }
+
+    public void testInOutOfBandHeaderCamelTemplateRelay() throws Exception {
+        doTestInOutOfBandHeaderCamelTemplate("direct:relayProducer");
+    }
+    
+    public void testOutOutOfBandHeaderCamelTemplateRelay() throws Exception {
+        doTestOutOutOfBandHeaderCamelTemplate("direct:relayProducer");
+    }
+
+    public void testInOutOutOfBandHeaderCamelTemplateRelay() throws Exception {
+        doTestInOutOutOfBandHeaderCamelTemplate("direct:relayProducer");
+    }
+    
+    protected void doTestInOutOfBandHeaderCamelTemplate(String producerUri) throws Exception {
+        // START SNIPPET: sending
+        Exchange senderExchange = new DefaultExchange(context, ExchangePattern.InOut);
+        final List<Object> params = new ArrayList<Object>();
+        Me me = new Me();
+        me.setFirstName("john");
+        me.setLastName("Doh");
+
+        params.add(me);
+        senderExchange.getIn().setBody(params);
+        senderExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, "inOutOfBandHeader");
+
+        List<Header> headers = buildOutOfBandHeaderList(false);
+        Map<String, Object> requestContext = new HashMap<String, Object>();
+        requestContext.put(Header.HEADER_LIST, headers);
+        senderExchange.getIn().setHeader(Client.REQUEST_CONTEXT, requestContext);
+
+        Exchange exchange = template.send(producerUri, senderExchange);
+
+        org.apache.camel.Message out = exchange.getOut();
+        MessageContentsList result = (MessageContentsList)out.getBody();
+        Map<String, Object> responseContext = CastUtils.cast((Map)out.getHeader(Client.RESPONSE_CONTEXT));
+        assertNotNull(responseContext);
+        assertTrue("Expected the out of band header to propagate but it didn't", 
+                   result.get(0) != null && ((Me)result.get(0)).getFirstName().equals("pass"));
+
+    }
+
+    protected void doTestOutOutOfBandHeaderCamelTemplate(String producerUri) throws Exception {
+        // START SNIPPET: sending
+        Exchange senderExchange = new DefaultExchange(context, ExchangePattern.InOut);
+        final List<Object> params = new ArrayList<Object>();
+        Me me = new Me();
+        me.setFirstName("john");
+        me.setLastName("Doh");
+
+        params.add(me);
+        senderExchange.getIn().setBody(params);
+        senderExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, "outOutOfBandHeader");
+
+        Exchange exchange = template.send(producerUri, senderExchange);
+
+        org.apache.camel.Message out = exchange.getOut();
+        MessageContentsList result = (MessageContentsList)out.getBody();
+        assertTrue("Expected the out of band header to propagate but it didn't", 
+                   result.get(0) != null && ((Me)result.get(0)).getFirstName().equals("pass"));
+        Map<String, Object> responseContext = CastUtils.cast((Map)out.getHeader(Client.RESPONSE_CONTEXT));
+        assertNotNull(responseContext);
+        validateReturnedOutOfBandHeader(responseContext);
+    }
+
+
+    public void doTestInOutOutOfBandHeaderCamelTemplate(String producerUri) throws Exception {
+        // START SNIPPET: sending
+        Exchange senderExchange = new DefaultExchange(context, ExchangePattern.InOut);
+        final List<Object> params = new ArrayList<Object>();
+        Me me = new Me();
+        me.setFirstName("john");
+        me.setLastName("Doh");
+
+        params.add(me);
+        senderExchange.getIn().setBody(params);
+        senderExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, "inoutOutOfBandHeader");
+
+        List<Header> inHeaders = buildOutOfBandHeaderList(false);
+        Map<String, Object> requestContext = new HashMap<String, Object>();
+        requestContext.put(Header.HEADER_LIST, inHeaders);
+        senderExchange.getIn().setHeader(Client.REQUEST_CONTEXT, requestContext);
+
+        Exchange exchange = template.send(producerUri, senderExchange);
+
+        org.apache.camel.Message out = exchange.getOut();
+        MessageContentsList result = (MessageContentsList)out.getBody();
+        assertTrue("Expected the out of band header to propagate but it didn't", 
+                   result.get(0) != null && ((Me)result.get(0)).getFirstName().equals("pass"));
+        Map<String, Object> responseContext = CastUtils.cast((Map)out.getHeader(Client.RESPONSE_CONTEXT));
+        assertNotNull(responseContext);
+        validateReturnedOutOfBandHeader(responseContext);
+    }
+
+    protected static void validateReturnedOutOfBandHeader(HeaderTester proxy) {
+        validateReturnedOutOfBandHeader(proxy, true);
+    }
+    
+    protected static void validateReturnedOutOfBandHeader(HeaderTester proxy, boolean expect) {
+        InvocationHandler handler  = Proxy.getInvocationHandler(proxy);
+        BindingProvider  bp = null;
+        if (!(handler instanceof BindingProvider)) {
+            fail("Unable to cast dynamic proxy InocationHandler to BindingProvider type");
+        }
+
+        bp = (BindingProvider)handler;
+        Map<String, Object> responseContext = bp.getResponseContext();
+        validateReturnedOutOfBandHeader(responseContext, expect);
+    }
+    
+    protected static void validateReturnedOutOfBandHeader(Map<String, Object> responseContext) {
+        validateReturnedOutOfBandHeader(responseContext, true);
+    }
+    
+    protected static void validateReturnedOutOfBandHeader(Map<String, Object> responseContext, boolean expect) {
+        OutofBandHeader hdrToTest = null;
+        List oobHdr = (List)responseContext.get(Header.HEADER_LIST);
+        if (!expect) {
+            if (oobHdr == null || (oobHdr != null && oobHdr.size() == 0)) {
+                return;
+            }
+            fail("Should have got *no* out-of-band headers, but some were found");
+        }
+        if (oobHdr == null) {
+            fail("Should have got List of out-of-band headers");
+        }
+
+        assertTrue("HeaderHolder list expected to conain 1 object received " + oobHdr.size(),
+                   oobHdr.size() == 1);
+
+        if (oobHdr != null & oobHdr instanceof List) {
+            Iterator iter = oobHdr.iterator();
+            while (iter.hasNext()) {
+                Object hdr = iter.next();
+                if (hdr instanceof Header) {
+                    Header hdr1 = (Header)hdr;
+                    if (hdr1.getObject() instanceof Node) {
+                        try {
+                            JAXBElement job = (JAXBElement)JAXBContext
+                                .newInstance(org.apache.cxf.outofband.header.ObjectFactory.class)
+                                .createUnmarshaller().unmarshal((Node)hdr1.getObject());
+                            hdrToTest = (OutofBandHeader)job.getValue();
+                        } catch (JAXBException ex) {
+                            ex.printStackTrace();
+                        }
+                    }
+                }
+            }
+        }
+
+        assertNotNull("out-of-band header should not be null", hdrToTest);
+        assertTrue("Expected out-of-band Header name testOobReturnHeaderName recevied :"
+                   + hdrToTest.getName(), "testOobReturnHeaderName".equals(hdrToTest.getName()));
+        assertTrue("Expected out-of-band Header value testOobReturnHeaderValue recevied :"
+                   + hdrToTest.getValue(), "testOobReturnHeaderValue".equals(hdrToTest.getValue()));
+        assertTrue("Expected out-of-band Header attribute testReturnHdrAttribute recevied :"
+                   + hdrToTest.getHdrAttribute(), "testReturnHdrAttribute"
+            .equals(hdrToTest.getHdrAttribute()));
+    }
+    
+    protected static List<Header> buildOutOfBandHeaderList(boolean invalid) throws JAXBException {
+        OutofBandHeader ob = new OutofBandHeader();
+        ob.setName("testOobHeader");
+        ob.setValue("testOobHeaderValue");
+        ob.setHdrAttribute(invalid ? "dontProcess" : "testHdrAttribute");
+
+        SoapHeader hdr = new SoapHeader(
+                new QName(Constants.TEST_HDR_NS, Constants.TEST_HDR_REQUEST_ELEM), 
+                ob, 
+                new JAXBDataBinding(ob.getClass()));
+        hdr.setMustUnderstand(true);
+
+        List<Header> headers = new ArrayList<Header>();
+        headers.add(hdr);
+        return headers;
+    }
+}
diff --git a/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/HeaderTesterImpl.java b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/HeaderTesterImpl.java
new file mode 100644
index 00000000000..0f8b51525b4
--- /dev/null
+++ b/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/HeaderTesterImpl.java
@@ -0,0 +1,237 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.cxf.soap.headers;
+
+import java.util.Iterator;
+import java.util.List;
+
+import javax.annotation.Resource;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.JAXBException;
+import javax.xml.namespace.QName;
+import javax.xml.ws.Holder;
+import javax.xml.ws.WebServiceContext;
+import javax.xml.ws.handler.MessageContext;
+
+import org.w3c.dom.Node;
+
+import org.apache.cxf.headers.Header;
+import org.apache.cxf.helpers.CastUtils;
+import org.apache.cxf.jaxb.JAXBDataBinding;
+import org.apache.cxf.outofband.header.OutofBandHeader;
+
+
+/**
+ * This class was generated by Apache CXF 2.1.3.4-fuse
+ * Tue Mar 10 17:40:07 GMT-05:00 2009
+ * Generated source version: 2.1.3.4-fuse
+ * 
+ */
+
+@javax.jws.WebService(serviceName = "HeaderService",
+                      targetNamespace = "http://apache.org/camel/cxf/soap/headers",
+                      endpointInterface = "org.apache.camel.component.cxf.soap.headers.HeaderTester")
+                      
+public class HeaderTesterImpl implements HeaderTester {
+    
+    @Resource
+    private WebServiceContext context;
+    private boolean relayHeaders = true;
+    
+    public HeaderTesterImpl() {
+    }
+    
+    public HeaderTesterImpl(boolean relayHeaders) {
+        this.relayHeaders = relayHeaders;
+    }
+    
+    public void outHeader(OutHeader me, Holder<OutHeaderResponse> theResponse, Holder<SOAPHeaderData> headerInfo) { 
+        try {
+            OutHeaderResponse theResponseValue = new OutHeaderResponse();
+            theResponseValue.setResponseType("pass");
+            theResponse.value = theResponseValue;
+            headerInfo.value = Constants.OUT_HEADER_DATA;
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public InHeaderResponse inHeader(InHeader me, SOAPHeaderData headerInfo) { 
+        try {
+            InHeaderResponse result = new InHeaderResponse();
+            if (!relayHeaders) {
+                if (headerInfo == null) {
+                    result.setResponseType("pass");
+                } else {
+                    result.setResponseType("fail");
+                }
+            } else if (Constants.equals(Constants.IN_HEADER_DATA, headerInfo)) {
+                result.setResponseType("pass");
+            } else {
+                result.setResponseType("fail");
+            }
+            return result;
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public InoutHeaderResponse inoutHeader(InoutHeader me, Holder<SOAPHeaderData> headerInfo) { 
+        try {
+            InoutHeaderResponse result = new InoutHeaderResponse();
+            if (!relayHeaders) {
+                if (headerInfo.value == null) {
+                    result.setResponseType("pass");
+                } else {
+                    result.setResponseType("fail");
+                }
+            } else if (Constants.equals(Constants.IN_OUT_REQUEST_HEADER_DATA, headerInfo.value)) {
+                result.setResponseType("pass");
+            } else {
+                result.setResponseType("fail");
+            }
+            headerInfo.value = Constants.IN_OUT_RESPONSE_HEADER_DATA;
+            return result;
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw new RuntimeException(ex);
+        }
+    }
+    
+    public Me inOutOfBandHeader(Me me) { 
+        try {
+            Me result = new Me();
+            if (validateOutOfBandHander()) {
+                result.setFirstName("pass");
+            } else {
+                result.setFirstName("fail");
+            }
+            return result;
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public Me inoutOutOfBandHeader(Me me) { 
+        try {
+            Me result = new Me();
+            if (validateOutOfBandHander()) {
+                addReplyOutOfBandHeader();
+                result.setFirstName("pass");
+            } else {
+                result.setFirstName("fail");
+            }
+            return result;
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public Me outOutOfBandHeader(Me me) { 
+        try {
+            Me result = new Me();
+            result.setFirstName("pass");
+            addReplyOutOfBandHeader();
+            return result;
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            throw new RuntimeException(ex);
+        }
+    }
+
+    private void addReplyOutOfBandHeader() {
+        if (context != null) {
+            MessageContext ctx = context.getMessageContext();
+            if (ctx != null) {
+                try {
+                    OutofBandHeader ob = new OutofBandHeader();
+                    ob.setName("testOobReturnHeaderName");
+                    ob.setValue("testOobReturnHeaderValue");
+                    ob.setHdrAttribute("testReturnHdrAttribute");
+                    JAXBElement<OutofBandHeader> job = new JAXBElement<OutofBandHeader>(
+                            new QName(Constants.TEST_HDR_NS, Constants.TEST_HDR_RESPONSE_ELEM), 
+                            OutofBandHeader.class, null, ob);
+                    Header hdr = new Header(
+                            new QName(Constants.TEST_HDR_NS, Constants.TEST_HDR_RESPONSE_ELEM), 
+                            job, 
+                            new JAXBDataBinding(ob.getClass()));
+                    List<Header> hdrList = CastUtils.cast((List<?>) ctx.get(Header.HEADER_LIST));
+                    hdrList.add(hdr);
+                } catch (Exception ex) {
+                    ex.printStackTrace();
+                }
+            }
+        }
+    }
+    
+    private boolean validateOutOfBandHander() {
+        MessageContext ctx = context == null ? null : context.getMessageContext();
+        if (!relayHeaders) {
+            if (ctx != null 
+                && !ctx.containsKey(Header.HEADER_LIST)
+                || (ctx.containsKey(Header.HEADER_LIST) 
+                    && ((List<?>)ctx.get(Header.HEADER_LIST)).size() == 0)) {
+                return true;
+            }
+            return false;
+        }
+        
+        boolean success = false;
+        if (ctx != null && ctx.containsKey(Header.HEADER_LIST)) {
+            List<?> oobHdr = (List<?>) ctx.get(Header.HEADER_LIST);
+            Iterator<?> iter = oobHdr.iterator();
+            while (iter.hasNext()) {
+                Object hdr = iter.next();
+                if (hdr instanceof Header && ((Header) hdr).getObject() instanceof Node) {
+                    Header hdr1 = (Header) hdr;
+                    try {
+                        JAXBElement<?> job = 
+                            (JAXBElement<?>)JAXBContext.newInstance(org.apache.cxf.outofband.header.ObjectFactory.class)
+                                .createUnmarshaller()
+                                .unmarshal((Node) hdr1.getObject());
+                        OutofBandHeader ob = (OutofBandHeader) job.getValue();
+                        if ("testOobHeader".equals(ob.getName())
+                            && "testOobHeaderValue".equals(ob.getValue())) { 
+                            if ("testHdrAttribute".equals(ob.getHdrAttribute())) {
+                                success = true;
+                                iter.remove(); //mark it processed
+                            } else if ("dontProcess".equals(ob.getHdrAttribute())) {
+                                //we won't remove it so we won't let the runtime know
+                                //it's processed.   It SHOULD throw an exception 
+                                //saying the mustunderstand wasn't processed
+                                success = true;
+                            }
+                        } else {
+                            throw new RuntimeException("test failed");
+                        }
+                    } catch (JAXBException ex) {
+                        ex.printStackTrace();
+                    }
+                }
+            }
+        } else {
+            throw new RuntimeException("MessageContext is null or doesnot contain OOBHeaders");
+        }
+        
+        return success;
+    }    
+}
diff --git a/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest-context.xml b/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest-context.xml
new file mode 100644
index 00000000000..4051fbf467f
--- /dev/null
+++ b/components/camel-cxf/src/test/resources/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest-context.xml
@@ -0,0 +1,121 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<beans xmlns="http://www.springframework.org/schema/beans"
+       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+       xmlns:cxf="http://camel.apache.org/schema/cxf"
+       xmlns:util="http://www.springframework.org/schema/util"
+       xsi:schemaLocation="
+       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
+       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd
+       http://camel.apache.org/schema/cxf http://camel.apache.org/schema/cxf/camel-cxf.xsd
+       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
+  ">
+
+  <cxf:cxfEndpoint id="routerRelayEndpoint" 
+                   address="http://localhost:9000/HeaderService/"
+                   serviceClass="org.apache.camel.component.cxf.soap.headers.HeaderTester"
+                   endpointName="tns:SoapPortRelay"
+                   serviceName="tns:HeaderService"
+                   wsdlURL="soap_header.wsdl"
+                   xmlns:tns="http://apache.org/camel/component/cxf/soap/headers">                
+  </cxf:cxfEndpoint> 
+
+  <cxf:cxfEndpoint id="routerNoRelayEndpoint" 
+                   address="http://localhost:7000/HeaderService"
+                   serviceClass="org.apache.camel.component.cxf.soap.headers.HeaderTester"
+                   endpointName="tns:SoapPortNoRelay"
+                   serviceName="tns:HeaderService"
+                   wsdlURL="soap_header.wsdl"
+                   xmlns:tns="http://apache.org/camel/component/cxf/soap/headers">              
+      <cxf:properties>
+          <!--  Set dataFormat to PAYLOAD so in-band message headers are dropped as well  -->
+          <entry key="dataFormat" value="PAYLOAD"/>
+      </cxf:properties>    
+  </cxf:cxfEndpoint> 
+
+  <cxf:cxfEndpoint id="serviceRelayEndpoint" 
+                   address="http://localhost:9090/HeaderService/"
+                   serviceClass="org.apache.camel.component.cxf.soap.headers.HeaderTester"
+                   endpointName="tns:SoapPortRelay"
+                   serviceName="tns:HeaderService"
+                   wsdlURL="soap_header.wsdl"
+                   xmlns:tns="http://apache.org/camel/component/cxf/soap/headers">
+  </cxf:cxfEndpoint>
+
+  <cxf:cxfEndpoint id="serviceNoRelayEndpoint" 
+                   address="http://localhost:7070/HeaderService/"
+                   serviceClass="org.apache.camel.component.cxf.soap.headers.HeaderTester"
+                   endpointName="tns:SoapPortNoRelay"
+                   serviceName="tns:HeaderService"
+                   wsdlURL="soap_header.wsdl"
+                   xmlns:tns="http://apache.org/camel/component/cxf/soap/headers">
+      <cxf:properties>
+          <!--  Set dataFormat to PAYLOAD so in-band message headers are dropped as well  -->
+          <entry key="dataFormat" value="PAYLOAD"/>
+      </cxf:properties>        
+  </cxf:cxfEndpoint>
+  
+  <cxf:cxfEndpoint id="serviceExtraRelays" 
+                   address="http://localhost:6060/HeaderService/"
+                   serviceClass="org.apache.camel.component.cxf.soap.headers.HeaderTester"
+                   endpointName="tns:SoapPortCustomRelay"
+                   serviceName="tns:HeaderService"
+                   wsdlURL="soap_header.wsdl"
+                   xmlns:tns="http://apache.org/camel/component/cxf/soap/headers">
+  </cxf:cxfEndpoint>
+  
+  <bean id="dropAllMessageHeadersStrategy" class="org.apache.camel.component.cxf.CxfHeaderFilterStrategy">
+      <!--  Set relayHeaders to false to drop all SOAP headers -->
+      <property name="relayHeaders" value="false"/>
+  </bean>
+  
+  <bean id="customMessageFilterStrategy" class="org.apache.camel.component.cxf.CxfHeaderFilterStrategy">
+      <property name="messageHeaderFilters">
+          <list>
+              <!--  SoapMessageHeaderFilter is the built in filter.  It can be removed by omitting it. -->
+              <bean class="org.apache.camel.component.cxf.SoapMessageHeaderFilter"/>          
+              
+              <!--  Add custom filter here -->    
+              <bean class="org.apache.camel.component.cxf.soap.headers.CustomHeaderFilter"/>
+          </list>
+      </property>
+  </bean>
+  
+  <camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
+      <route>
+          <from uri="cxf:bean:routerRelayEndpoint"/>
+          <to uri="cxf:bean:serviceRelayEndpoint"/>
+      </route>
+      <route>
+         <from uri="direct:directProducer" />
+         <to uri="cxf:bean:serviceRelayEndpoint" />
+      </route>
+      <route>
+         <from uri="direct:relayProducer" />
+         <to uri="cxf:bean:routerRelayEndpoint" />
+      </route>
+      <route>
+          <from uri="cxf:bean:routerNoRelayEndpoint?headerFilterStrategy=#dropAllMessageHeadersStrategy"/>          
+          <to uri="cxf:bean:serviceNoRelayEndpoint?headerFilterStrategy=#dropAllMessageHeadersStrategy"/>
+      </route>
+      <route>
+          <from uri="cxf:bean:serviceExtraRelays?headerFilterStrategy=#customMessageFilterStrategy"/>
+          <to uri="mock:result"/>
+      </route>
+    </camelContext>
+</beans>
diff --git a/components/camel-cxf/src/test/resources/soap_header.wsdl b/components/camel-cxf/src/test/resources/soap_header.wsdl
new file mode 100644
index 00000000000..6d9a311b721
--- /dev/null
+++ b/components/camel-cxf/src/test/resources/soap_header.wsdl
@@ -0,0 +1,283 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements. See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership. The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License. You may obtain a copy of the License at
+                                                                                                                                                             
+  http://www.apache.org/licenses/LICENSE-2.0
+                                                                                                                                                             
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied. See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+
+<definitions name="soap_header" 
+    targetNamespace="http://apache.org/camel/component/cxf/soap/headers" 
+    xmlns="http://schemas.xmlsoap.org/wsdl/" 
+    xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" 
+    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 
+    xmlns:tns="http://apache.org/camel/component/cxf/soap/headers" 
+    xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
+    xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+    <types>
+        <schema targetNamespace="http://apache.org/camel/component/cxf/soap/headers" 
+            xmlns="http://www.w3.org/2001/XMLSchema" 
+            xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
+            xmlns:tns="http://apache.org/camel/component/cxf/soap/headers">
+
+            <complexType name="SOAPHeaderData">
+                <sequence>
+                    <element maxOccurs="1" minOccurs="1" name="originator" type="string"/>
+                    <element maxOccurs="1" minOccurs="1" name="message" type="string"/>
+                </sequence>
+            </complexType>
+            <element name="SOAPHeaderInfo" type="tns:SOAPHeaderData"/>
+            
+			<complexType name="me">
+				<sequence>
+	                <element maxOccurs="1" minOccurs="1" name="firstName" type="string"/>
+	            	<element maxOccurs="1" minOccurs="1" name="lastName" type="string"/>
+	        	</sequence>
+			</complexType>
+	        
+	        <element name="inHeader">
+	           <complexType>
+	                    <sequence>
+	                        <element name="requestType" type="xsd:string"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="inHeaderResponse">
+	           <complexType>
+	                    <sequence>
+	                        <element name="responseType" type="xsd:string"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	
+	        <element name="outHeader">
+	           <complexType>
+	                    <sequence>
+	                        <element name="requestType" type="xsd:string"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="outHeaderResponse">
+	           <complexType>
+	                    <sequence>
+	                        <element name="responseType" type="xsd:string"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="inoutHeader">
+	           <complexType>
+	                    <sequence>
+	                        <element name="requestType" type="xsd:string"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="inoutHeaderResponse">
+	           <complexType>
+	                    <sequence>
+	                        <element name="responseType" type="xsd:string"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="inOutOfBandHeader">
+	           <complexType>
+	                    <sequence>
+	                        <element name="requestType" type="tns:me"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="inOutOfBandHeaderResponse">
+	           <complexType>
+	                    <sequence>
+	                        <element name="responseType" type="tns:me"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="inoutOutOfBandHeader">
+	           <complexType>
+	                    <sequence>
+	                        <element name="requestType" type="tns:me"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="inoutOutOfBandHeaderResponse">
+	           <complexType>
+	                    <sequence>
+	                        <element name="responseType" type="tns:me"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="outOutOfBandHeader">
+	           <complexType>
+	                    <sequence>
+	                        <element name="requestType" type="tns:me"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+	        <element name="outOutOfBandHeaderResponse">
+	           <complexType>
+	                    <sequence>
+	                        <element name="responseType" type="tns:me"/>
+	                    </sequence>
+	                </complexType>
+	        </element>
+      </schema>
+    </types>
+
+    <message name="inHeaderRequest">
+        <part element="tns:inHeader" name="me"/>
+        <part element="tns:SOAPHeaderInfo" name="header_info"/>
+    </message>
+    <message name="inHeaderResponse">
+        <part element="tns:inHeaderResponse" name="the_response"/>
+    </message>
+    <message name="outHeaderRequest">
+        <part element="tns:outHeader" name="me"/>
+    </message>
+    <message name="outHeaderResponse">
+        <part element="tns:outHeaderResponse" name="the_response"/>
+        <part element="tns:SOAPHeaderInfo" name="header_info"/>
+    </message>
+    <message name="inoutHeaderRequest">
+        <part element="tns:inoutHeader" name="me"/>
+        <part element="tns:SOAPHeaderInfo" name="header_info"/>
+    </message>
+    <message name="inoutHeaderResponse">
+        <part element="tns:inoutHeaderResponse" name="the_response"/>
+        <part element="tns:SOAPHeaderInfo" name="header_info"/>
+    </message>
+    <message name="inOutOfBandHeaderRequest">
+        <part element="tns:inOutOfBandHeader" name="me"/>
+    </message>
+    <message name="inOutOfBandHeaderResponse">
+        <part element="tns:inOutOfBandHeaderResponse" name="the_response"/>
+    </message>
+    <message name="inoutOutOfBandHeaderRequest">
+        <part element="tns:inoutOutOfBandHeader" name="me"/>
+    </message>
+    <message name="inoutOutOfBandHeaderResponse">
+        <part element="tns:inoutOutOfBandHeaderResponse" name="the_response"/>
+    </message>
+    <message name="outOutOfBandHeaderRequest">
+        <part element="tns:outOutOfBandHeader" name="me"/>
+    </message>
+    <message name="outOutOfBandHeaderResponse">
+        <part element="tns:outOutOfBandHeaderResponse" name="the_response"/>
+    </message>
+
+    <portType name="headerTester">
+        <operation name="inHeader">
+            <input message="tns:inHeaderRequest" name="inHeaderRequest"/>
+            <output message="tns:inHeaderResponse" name="inHeaderResponse"/>
+        </operation>
+        <operation name="outHeader">
+            <input message="tns:outHeaderRequest" name="outHeaderRequest"/>
+            <output message="tns:outHeaderResponse" name="outHeaderResponse"/>
+        </operation>
+        <operation name="inoutHeader">
+            <input message="tns:inoutHeaderRequest" name="inoutHeaderRequest"/>
+            <output message="tns:inoutHeaderResponse" name="inoutHeaderResponse"/>
+        </operation>
+        <operation name="inOutOfBandHeader">
+            <input message="tns:inOutOfBandHeaderRequest" name="inOutOfBandHeaderRequest"/>
+            <output message="tns:inOutOfBandHeaderResponse" name="inOutOfBandHeaderResponse"/>
+        </operation>
+        <operation name="outOutOfBandHeader">
+            <input message="tns:outOutOfBandHeaderRequest" name="outOutOfBandHeaderRequest"/>
+            <output message="tns:outOutOfBandHeaderResponse" name="outOutOfBandHeaderResponse"/>
+        </operation>
+        <operation name="inoutOutOfBandHeader">
+            <input message="tns:inoutOutOfBandHeaderRequest" name="inoutOutOfBandHeaderRequest"/>
+            <output message="tns:inoutOutOfBandHeaderResponse" name="inoutOutOfBandHeaderResponse"/>
+        </operation>
+    </portType>
+
+    <binding name="headerTesterSOAPBinding" type="tns:headerTester">
+        <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
+        <operation name="inHeader">
+            <soap:operation soapAction="" style="document"/>
+            <input name="inHeaderRequest">
+                <soap:body parts="me" use="literal"/>
+                <soap:header message="tns:inHeaderRequest" part="header_info" 
+                    use="literal"/>
+            </input>
+            <output name="inHeaderResponse">
+                <soap:body use="literal"/>
+            </output>
+        </operation>
+        <operation name="outHeader">
+            <soap:operation soapAction="" style="document"/>
+            <input name="outHeaderRequest">
+                <soap:body use="literal"/>
+            </input>
+            <output name="outHeaderResponse">
+                <soap:body parts="the_response" use="literal"/>
+                <soap:header message="tns:outHeaderResponse" part="header_info" 
+                    use="literal"/>
+            </output>
+        </operation>
+        <operation name="inoutHeader">
+            <soap:operation soapAction="" style="document"/>
+            <input name="inoutHeaderRequest">
+                <soap:body parts="me" use="literal"/>
+                <soap:header message="tns:inoutHeaderRequest" part="header_info" 
+                    use="literal"/>
+            </input>
+            <output name="inoutHeaderResponse">
+                <soap:body parts="the_response" use="literal"/>
+                <soap:header message="tns:inoutHeaderResponse" part="header_info" 
+                    use="literal"/>
+            </output>
+        </operation>
+        <operation name="inOutOfBandHeader">
+            <soap:operation soapAction="" style="document"/>
+            <input name="inOutOfBandHeaderRequest">
+                <soap:body parts="me" use="literal"/>
+            </input>
+            <output name="inOutOfBandHeaderResponse">
+                <soap:body use="literal"/>
+            </output>
+        </operation>
+        <operation name="outOutOfBandHeader">
+            <soap:operation soapAction="" style="document"/>
+            <input name="outOutOfBandHeaderRequest">
+                <soap:body parts="me" use="literal"/>
+            </input>
+            <output name="outOutOfBandHeaderResponse">
+                <soap:body use="literal"/>
+            </output>
+        </operation>
+        <operation name="inoutOutOfBandHeader">
+            <soap:operation soapAction="" style="document"/>
+            <input name="inoutOutOfBandHeaderRequest">
+                <soap:body parts="me" use="literal"/>
+            </input>
+            <output name="inoutOutOfBandHeaderResponse">
+                <soap:body use="literal"/>
+            </output>
+        </operation>
+    </binding>
+
+    <service name="HeaderService">
+        <port binding="tns:headerTesterSOAPBinding" name="SoapPortRelay">
+            <soap:address location="http://localhost:9000/HeaderService/"/>
+        </port>
+        <port binding="tns:headerTesterSOAPBinding" name="SoapPortNoRelay">
+            <soap:address location="http://localhost:7000/HeaderService/"/>
+        </port>        
+        <port binding="tns:headerTesterSOAPBinding" name="SoapPortCustomRelay">
+            <soap:address location="http://localhost:6000/HeaderService/"/>
+        </port>        
+    </service>
+</definitions>
diff --git a/components/camel-http/src/main/java/org/apache/camel/component/http/DefaultHttpBinding.java b/components/camel-http/src/main/java/org/apache/camel/component/http/DefaultHttpBinding.java
index 6f56863920c..9967e31bb96 100644
--- a/components/camel-http/src/main/java/org/apache/camel/component/http/DefaultHttpBinding.java
+++ b/components/camel-http/src/main/java/org/apache/camel/component/http/DefaultHttpBinding.java
@@ -25,6 +25,7 @@ import javax.servlet.ServletOutputStream;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.component.http.helper.GZIPHelper;
 import org.apache.camel.spi.HeaderFilterStrategy;
@@ -56,7 +57,7 @@ public class DefaultHttpBinding implements HttpBinding {
         if (exchange.isFailed()) {
             Message fault = exchange.getFault(false);
             if (fault != null) {
-                doWriteFaultResponse(fault, response);
+                doWriteFaultResponse(fault, response, exchange);
             } else {
                 doWriteExceptionResponse(exchange.getException(), response);
             }
@@ -65,7 +66,7 @@ public class DefaultHttpBinding implements HttpBinding {
             copyProtocolHeaders(exchange.getIn(), exchange.getOut());
             Message out = exchange.getOut();            
             if (out != null) {
-                doWriteResponse(out, response);
+                doWriteResponse(out, response, exchange);
             }
         }
     }
@@ -88,11 +89,11 @@ public class DefaultHttpBinding implements HttpBinding {
         pw.flush();
     }
 
-    public void doWriteFaultResponse(Message message, HttpServletResponse response) throws IOException {
-        doWriteResponse(message, response);
+    public void doWriteFaultResponse(Message message, HttpServletResponse response, Exchange exchange) throws IOException {
+        doWriteResponse(message, response, exchange);
     }
 
-    public void doWriteResponse(Message message, HttpServletResponse response) throws IOException {
+    public void doWriteResponse(Message message, HttpServletResponse response, Exchange exchange) throws IOException {
         // set the status code in the response. Default is 200.
         if (message.getHeader(HttpConstants.HTTP_RESPONSE_CODE) != null) {
             int code = message.getHeader(HttpConstants.HTTP_RESPONSE_CODE, Integer.class);
@@ -108,7 +109,7 @@ public class DefaultHttpBinding implements HttpBinding {
         for (String key : message.getHeaders().keySet()) {
             String value = message.getHeader(key, String.class);
             if (headerFilterStrategy != null
-                    && !headerFilterStrategy.applyFilterToCamelHeaders(key, value)) {
+                    && !headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {
                 response.setHeader(key, value);
             }
         }
@@ -186,4 +187,5 @@ public class DefaultHttpBinding implements HttpBinding {
     public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
         this.headerFilterStrategy = headerFilterStrategy;
     }
+
 }
diff --git a/components/camel-http/src/main/java/org/apache/camel/component/http/HttpBinding.java b/components/camel-http/src/main/java/org/apache/camel/component/http/HttpBinding.java
index b5734f3fa46..795d665554c 100644
--- a/components/camel-http/src/main/java/org/apache/camel/component/http/HttpBinding.java
+++ b/components/camel-http/src/main/java/org/apache/camel/component/http/HttpBinding.java
@@ -20,6 +20,7 @@ import java.io.IOException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.spi.HeaderFilterStrategy;
 
@@ -79,19 +80,21 @@ public interface HttpBinding {
      * Strategy method that writes the response to the http response stream for a fault message
      *
      * @param message  the fault message
-     * @param response   the http response
+     * @param response the http response
+     * @param exchange the exchange to provide context for header filtering
      * @throws java.io.IOException can be thrown from http response
      */
-    void doWriteFaultResponse(Message message, HttpServletResponse response) throws IOException;
+    void doWriteFaultResponse(Message message, HttpServletResponse response, Exchange exchange) throws IOException;
 
     /**
      * Strategy method that writes the response to the http response stream for an OUT message
      *
      * @param message  the OUT message
-     * @param response   the http response
+     * @param response the http response
+     * @param exchange the exchange to provide context for header filtering
      * @throws java.io.IOException can be thrown from http response
      */
-    void doWriteResponse(Message message, HttpServletResponse response) throws IOException;
+    void doWriteResponse(Message message, HttpServletResponse response, Exchange exchange) throws IOException;
 
     boolean isUseReaderForPayload();
 
diff --git a/components/camel-http/src/main/java/org/apache/camel/component/http/HttpPollingConsumer.java b/components/camel-http/src/main/java/org/apache/camel/component/http/HttpPollingConsumer.java
index c9100a40432..8ead1dea4e7 100644
--- a/components/camel-http/src/main/java/org/apache/camel/component/http/HttpPollingConsumer.java
+++ b/components/camel-http/src/main/java/org/apache/camel/component/http/HttpPollingConsumer.java
@@ -78,7 +78,7 @@ public class HttpPollingConsumer extends PollingConsumerSupport {
             for (Header header : headers) {
                 String name = header.getName();
                 String value = header.getValue();
-                if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value)) {
+                if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value, exchange)) {
                     message.setHeader(name, value);
                 }
             }
diff --git a/components/camel-http/src/main/java/org/apache/camel/component/http/HttpProducer.java b/components/camel-http/src/main/java/org/apache/camel/component/http/HttpProducer.java
index 36536efe482..e5a7c44db67 100644
--- a/components/camel-http/src/main/java/org/apache/camel/component/http/HttpProducer.java
+++ b/components/camel-http/src/main/java/org/apache/camel/component/http/HttpProducer.java
@@ -58,7 +58,7 @@ public class HttpProducer extends DefaultProducer {
         // propagate headers as HTTP headers
         for (String headerName : in.getHeaders().keySet()) {
             String headerValue = in.getHeader(headerName, String.class);
-            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue)) {
+            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue, exchange)) {
                 method.addRequestHeader(headerName, headerValue);
             }
         }
@@ -85,7 +85,7 @@ public class HttpProducer extends DefaultProducer {
                 for (Header header : headers) {
                     String name = header.getName();
                     String value = header.getValue();
-                    if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value)) {
+                    if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value, exchange)) {
                         answer.setHeader(name, value);
                     }
                 }
diff --git a/components/camel-jhc/src/main/java/org/apache/camel/component/jhc/JhcProducer.java b/components/camel-jhc/src/main/java/org/apache/camel/component/jhc/JhcProducer.java
index f50ebea3f65..26a8964e2b8 100644
--- a/components/camel-jhc/src/main/java/org/apache/camel/component/jhc/JhcProducer.java
+++ b/components/camel-jhc/src/main/java/org/apache/camel/component/jhc/JhcProducer.java
@@ -157,7 +157,7 @@ public class JhcProducer extends DefaultProducer implements AsyncProcessor {
         HeaderFilterStrategy strategy = ((JhcEndpoint)getEndpoint()).getHeaderFilterStrategy();
         for (String headerName : exchange.getIn().getHeaders().keySet()) {
             String headerValue = exchange.getIn().getHeader(headerName, String.class);
-            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue)) {
+            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue, exchange)) {
                 req.addHeader(headerName, headerValue);
             }
         }
@@ -251,7 +251,7 @@ public class JhcProducer extends DefaultProducer implements AsyncProcessor {
             HeaderFilterStrategy strategy = getEndpoint().getHeaderFilterStrategy();
             for (Iterator it = httpResponse.headerIterator(); it.hasNext();) {
                 Header h = (Header) it.next();
-                if (strategy != null && !strategy.applyFilterToExternalHeaders(h.getName(), h.getValue())) {
+                if (strategy != null && !strategy.applyFilterToExternalHeaders(h.getName(), h.getValue(), e)) {
                     e.getOut().setHeader(h.getName(), h.getValue());
                 }
             }
diff --git a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsBinding.java b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsBinding.java
index b6559a16219..a75a2a3af67 100644
--- a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsBinding.java
+++ b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsBinding.java
@@ -115,7 +115,7 @@ public class JmsBinding {
         }
     }
 
-    public Map<String, Object> extractHeadersFromJms(Message jmsMessage) {
+    public Map<String, Object> extractHeadersFromJms(Message jmsMessage, Exchange exchange) {
         Map<String, Object> map = new HashMap<String, Object>();
         if (jmsMessage != null) {
             // lets populate the standard JMS message headers
@@ -147,7 +147,8 @@ public class JmsBinding {
                 String name = names.nextElement().toString();
                 try {
                     Object value = jmsMessage.getObjectProperty(name);
-                    if (headerFilterStrategy != null && headerFilterStrategy.applyFilterToExternalHeaders(name, value)) {
+                    if (headerFilterStrategy != null && 
+                        headerFilterStrategy.applyFilterToExternalHeaders(name, value, exchange)) {
                         continue;
                     }
 
@@ -267,7 +268,7 @@ public class JmsBinding {
                 // JMSMessageID, JMSTimestamp, JMSRedelivered
                 LOG.debug("Ignoring JMS header: " + headerName + " with value: " + headerValue);
             }
-        } else if (shouldOutputHeader(in, headerName, headerValue)) {
+        } else if (shouldOutputHeader(in, headerName, headerValue, exchange)) {
             // only primitive headers and strings is allowed as properties
             // see message properties: http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html
             Object value = getValidJMSHeaderValue(headerName, headerValue);
@@ -436,10 +437,10 @@ public class JmsBinding {
      * <b>Note</b>: Currently only supports sending java identifiers as keys
      */
     protected boolean shouldOutputHeader(org.apache.camel.Message camelMessage, String headerName,
-                                         Object headerValue) {
+                                         Object headerValue, Exchange exchange) {
 
         return headerFilterStrategy == null
-            || !headerFilterStrategy.applyFilterToCamelHeaders(headerName, headerValue);
+            || !headerFilterStrategy.applyFilterToCamelHeaders(headerName, headerValue, exchange);
     }
 
 }
diff --git a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsMessage.java b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsMessage.java
index 84e5875417c..1c1f423a3f8 100644
--- a/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsMessage.java
+++ b/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsMessage.java
@@ -155,7 +155,7 @@ public class JmsMessage extends DefaultMessage {
     @Override
     protected void populateInitialHeaders(Map<String, Object> map) {
         if (jmsMessage != null && map != null) {
-            map.putAll(getBinding().extractHeadersFromJms(jmsMessage));
+            map.putAll(getBinding().extractHeadersFromJms(jmsMessage, getExchange()));
         }
     }
 
diff --git a/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java b/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java
index 9dc7de552ca..01f94a8ebcd 100644
--- a/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java
+++ b/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java
@@ -124,7 +124,7 @@ public class MailBinding {
             Object headerValue = entry.getValue();
             if (headerValue != null) {
                 if (headerFilterStrategy != null
-                        && !headerFilterStrategy.applyFilterToCamelHeaders(headerName, headerValue)) {
+                        && !headerFilterStrategy.applyFilterToCamelHeaders(headerName, headerValue, exchange)) {
 
                     if (isRecipientHeader(headerName)) {
                         // skip any recipients as they are handled specially
@@ -232,7 +232,7 @@ public class MailBinding {
         return true;
     }
 
-    protected Map<String, Object> extractHeadersFromMail(Message mailMessage) throws MessagingException {
+    protected Map<String, Object> extractHeadersFromMail(Message mailMessage, Exchange exchange) throws MessagingException {
         Map<String, Object> answer = new HashMap<String, Object>();
         Enumeration names = mailMessage.getAllHeaders();
 
@@ -240,7 +240,7 @@ public class MailBinding {
             Header header = (Header)names.nextElement();
             String[] value = mailMessage.getHeader(header.getName());
             if (headerFilterStrategy != null
-                    && !headerFilterStrategy.applyFilterToExternalHeaders(header.getName(), value)) {
+                    && !headerFilterStrategy.applyFilterToExternalHeaders(header.getName(), value, exchange)) {
                 // toLowerCase() for doing case insensitive search
                 if (value.length == 1) {
                     CollectionHelper.appendValue(answer, header.getName().toLowerCase(), value[0]);
diff --git a/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailMessage.java b/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailMessage.java
index 8c3ee5634cb..4ccb099720c 100644
--- a/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailMessage.java
+++ b/components/camel-mail/src/main/java/org/apache/camel/component/mail/MailMessage.java
@@ -103,7 +103,7 @@ public class MailMessage extends DefaultMessage {
     protected void populateInitialHeaders(Map<String, Object> map) {
         if (mailMessage != null) {
             try {
-                map.putAll(getExchange().getBinding().extractHeadersFromMail(mailMessage));
+                map.putAll(getExchange().getBinding().extractHeadersFromMail(mailMessage, getExchange()));
             } catch (MessagingException e) {
                 throw new RuntimeCamelException("Error accessing headers due to: " + e.getMessage(), e);
             }
diff --git a/components/camel-restlet/src/main/java/org/apache/camel/component/restlet/DefaultRestletBinding.java b/components/camel-restlet/src/main/java/org/apache/camel/component/restlet/DefaultRestletBinding.java
index 97c7f4a36f6..db7777d8e12 100644
--- a/components/camel-restlet/src/main/java/org/apache/camel/component/restlet/DefaultRestletBinding.java
+++ b/components/camel-restlet/src/main/java/org/apache/camel/component/restlet/DefaultRestletBinding.java
@@ -62,7 +62,7 @@ public class DefaultRestletBinding implements RestletBinding, HeaderFilterStrate
         // extract headers from restlet 
         for (Map.Entry<String, Object> entry : request.getAttributes().entrySet()) {
             if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), 
-                    entry.getValue())) {
+                    entry.getValue(), exchange)) {
                 
                 inMessage.setHeader(entry.getKey(), entry.getValue());
                 if (LOG.isDebugEnabled()) {
@@ -95,7 +95,7 @@ public class DefaultRestletBinding implements RestletBinding, HeaderFilterStrate
                     }
                 } else {
                     if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(),
-                            entry.getValue())) {
+                            entry.getValue(), exchange)) {
 
                         inMessage.setHeader(entry.getKey(), entry.getValue());
                         if (LOG.isDebugEnabled()) {
@@ -138,7 +138,7 @@ public class DefaultRestletBinding implements RestletBinding, HeaderFilterStrate
         }
         
         for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {
-            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue())) {
+            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {
                 if (entry.getKey().startsWith("org.restlet.")) {
                     // put the org.restlet headers in attributes
                     request.getAttributes().put(entry.getKey(), entry.getValue());
@@ -202,7 +202,7 @@ public class DefaultRestletBinding implements RestletBinding, HeaderFilterStrate
         }
 
         for (Map.Entry<String, Object> entry : out.getHeaders().entrySet()) {
-            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue())) {
+            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {
                 response.getAttributes().put(entry.getKey(), entry.getValue());
                 if (LOG.isDebugEnabled()) {
                     LOG.debug("Populate Restlet response from exchange header: " 
@@ -233,7 +233,7 @@ public class DefaultRestletBinding implements RestletBinding, HeaderFilterStrate
     public void populateExchangeFromRestletResponse(Exchange exchange, Response response) throws IOException {
         
         for (Map.Entry<String, Object> entry : response.getAttributes().entrySet()) {
-            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue())) {
+            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {
                 exchange.getOut().setHeader(entry.getKey(), entry.getValue());
                 if (LOG.isDebugEnabled()) {
                     LOG.debug("Populate exchange from Restlet response header: " 
diff --git a/components/camel-xmpp/src/main/java/org/apache/camel/component/xmpp/XmppBinding.java b/components/camel-xmpp/src/main/java/org/apache/camel/component/xmpp/XmppBinding.java
index 7787ac593f2..59ed0c6ea1b 100644
--- a/components/camel-xmpp/src/main/java/org/apache/camel/component/xmpp/XmppBinding.java
+++ b/components/camel-xmpp/src/main/java/org/apache/camel/component/xmpp/XmppBinding.java
@@ -55,7 +55,7 @@ public class XmppBinding {
         for (Map.Entry<String, Object> entry : entries) {
             String name = entry.getKey();
             Object value = entry.getValue();
-            if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value)) {
+            if (!headerFilterStrategy.applyFilterToCamelHeaders(name, value, exchange)) {
                 message.setProperty(name, value);
             }
         }
@@ -73,13 +73,13 @@ public class XmppBinding {
         return message.getBody();
     }
 
-    public Map<String, Object> extractHeadersFromXmpp(Message xmppMessage) {
+    public Map<String, Object> extractHeadersFromXmpp(Message xmppMessage, Exchange exchange) {
         Map<String, Object> answer = new HashMap<String, Object>();
 
         for (String name : xmppMessage.getPropertyNames()) {
             Object value = xmppMessage.getProperty(name);
 
-            if (!headerFilterStrategy.applyFilterToExternalHeaders(name, value)) {
+            if (!headerFilterStrategy.applyFilterToExternalHeaders(name, value, exchange)) {
                 answer.put(name, value);
             }
         }
diff --git a/components/camel-xmpp/src/main/java/org/apache/camel/component/xmpp/XmppMessage.java b/components/camel-xmpp/src/main/java/org/apache/camel/component/xmpp/XmppMessage.java
index f53ea04cffc..31ffe87cd6c 100644
--- a/components/camel-xmpp/src/main/java/org/apache/camel/component/xmpp/XmppMessage.java
+++ b/components/camel-xmpp/src/main/java/org/apache/camel/component/xmpp/XmppMessage.java
@@ -79,7 +79,7 @@ public class XmppMessage extends DefaultMessage {
     @Override
     protected void populateInitialHeaders(Map<String, Object> map) {
         if (xmppMessage != null) {
-            map.putAll(getExchange().getBinding().extractHeadersFromXmpp(xmppMessage));
+            map.putAll(getExchange().getBinding().extractHeadersFromXmpp(xmppMessage, getExchange()));
         }
     }
 }
