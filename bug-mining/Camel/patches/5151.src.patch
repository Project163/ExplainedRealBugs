diff --git a/core/camel-api/src/main/java/org/apache/camel/spi/ProducerCache.java b/core/camel-api/src/main/java/org/apache/camel/spi/ProducerCache.java
index 6402ad98545..0eca02f9a19 100644
--- a/core/camel-api/src/main/java/org/apache/camel/spi/ProducerCache.java
+++ b/core/camel-api/src/main/java/org/apache/camel/spi/ProducerCache.java
@@ -37,6 +37,9 @@ public interface ProducerCache extends Service {
     /**
      * Acquires a pooled producer which you <b>must</b> release back again after usage using the
      * {@link #releaseProducer(org.apache.camel.Endpoint, org.apache.camel.AsyncProducer)} method.
+     * <p/>
+     * If the producer is currently starting then the cache will wait at most 30 seconds for the producer
+     * to finish starting and be ready for use.
      *
      * @param endpoint the endpoint
      * @return the producer
diff --git a/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultConsumerCache.java b/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultConsumerCache.java
index e179d07aaa0..9167ef331ba 100644
--- a/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultConsumerCache.java
+++ b/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultConsumerCache.java
@@ -46,7 +46,7 @@ public class DefaultConsumerCache extends ServiceSupport implements ConsumerCach
     public DefaultConsumerCache(Object source, CamelContext camelContext, int cacheSize) {
         this.source = source;
         this.camelContext = camelContext;
-        this.maxCacheSize = cacheSize == 0 ? CamelContextHelper.getMaximumCachePoolSize(camelContext) : cacheSize;
+        this.maxCacheSize = cacheSize <= 0 ? CamelContextHelper.getMaximumCachePoolSize(camelContext) : cacheSize;
         this.consumers = new PollingConsumerServicePool(Endpoint::createPollingConsumer, Consumer::getEndpoint, maxCacheSize);
         // only if JMX is enabled
         if (camelContext.getManagementStrategy().getManagementAgent() != null) {
@@ -206,7 +206,7 @@ public class DefaultConsumerCache extends ServiceSupport implements ConsumerCach
 
     @Override
     public void cleanUp() {
-        // noop
+        consumers.cleanUp();
     }
 
     @Override
diff --git a/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultProducerCache.java b/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultProducerCache.java
index 313e6cd5476..f8405eb1368 100644
--- a/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultProducerCache.java
+++ b/core/camel-base/src/main/java/org/apache/camel/impl/engine/DefaultProducerCache.java
@@ -63,7 +63,7 @@ public class DefaultProducerCache extends ServiceSupport implements ProducerCach
     public DefaultProducerCache(Object source, CamelContext camelContext, int cacheSize) {
         this.source = source;
         this.camelContext = camelContext;
-        this.maxCacheSize = cacheSize == 0 ? CamelContextHelper.getMaximumCachePoolSize(camelContext) : cacheSize;
+        this.maxCacheSize = cacheSize <= 0 ? CamelContextHelper.getMaximumCachePoolSize(camelContext) : cacheSize;
         this.producers = new ProducerServicePool(Endpoint::createAsyncProducer, Producer::getEndpoint, maxCacheSize);
 
         // only if JMX is enabled
@@ -391,7 +391,7 @@ public class DefaultProducerCache extends ServiceSupport implements ProducerCach
 
     @Override
     public void cleanUp() {
-        // noop
+        producers.cleanUp();
     }
 
     @Override
diff --git a/core/camel-base/src/main/java/org/apache/camel/impl/engine/ServicePool.java b/core/camel-base/src/main/java/org/apache/camel/impl/engine/ServicePool.java
index 477f948184c..334df602d27 100644
--- a/core/camel-base/src/main/java/org/apache/camel/impl/engine/ServicePool.java
+++ b/core/camel-base/src/main/java/org/apache/camel/impl/engine/ServicePool.java
@@ -16,27 +16,30 @@
  */
 package org.apache.camel.impl.engine;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
 import java.util.function.Function;
 
 import org.apache.camel.Endpoint;
 import org.apache.camel.IsSingleton;
 import org.apache.camel.NonManagedService;
 import org.apache.camel.Service;
+import org.apache.camel.support.LRUCache;
 import org.apache.camel.support.LRUCacheFactory;
 import org.apache.camel.support.service.ServiceSupport;
 import org.apache.camel.util.function.ThrowingFunction;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-// TODO: Fix bug in multi-pool
-// TODO: Add unit test
-
 /**
- * A base class for a pool for either producers or consumers.
+ * A base class for a pool for either producers or consumers used by
+ * {@link org.apache.camel.spi.ProducerCache} and {@link org.apache.camel.spi.ConsumerCache}.
  */
 abstract class ServicePool<S extends Service> extends ServiceSupport implements NonManagedService {
 
@@ -44,17 +47,17 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
 
     private final ThrowingFunction<Endpoint, S, Exception> creator;
     private final Function<S, Endpoint> getEndpoint;
-    private final ConcurrentHashMap<Endpoint, Pool<S>> pool = new ConcurrentHashMap<>();
+    private final ConcurrentMap<Endpoint, Pool<S>> pool = new ConcurrentHashMap<>();
     private int capacity;
-    private Map<Key<S>, S> multiPoolCache;
+    private Map<Key<S>, S> cache;
 
     private interface Pool<S> {
         S acquire() throws Exception;
         void release(S s);
         int size();
         void stop();
-        // returns true if the pool is empty
-        boolean evict(S s);
+        void evict(S s);
+        void cleanUp();
     }
 
     private static class Key<S> {
@@ -76,17 +79,22 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
         this.creator = creator;
         this.getEndpoint = getEndpoint;
         this.capacity = capacity;
-        this.multiPoolCache = capacity > 1 ? LRUCacheFactory.newLRUCache(capacity, this::onEvict) : null;
+        // only use a LRU cache if capacity is more than one
+        this.cache = capacity > 1 ? LRUCacheFactory.newLRUCache(capacity, this::onEvict) : null;
     }
 
+    /**
+     * This callback is invoked by LRUCache from a separate background cleanup thread.
+     * Therefore we mark the entries to be evicted from this thread only,
+     * and then let SinglePool and MultiPool handle the evictions when they are acquiring/releases producers/consumers.
+     */
     private void onEvict(S s) {
         Endpoint e = getEndpoint.apply(s);
         Pool<S> p = pool.get(e);
         if (p != null) {
-            if (p.evict(s)) {
-                pool.remove(e);
-            }
+            p.evict(s);
         } else {
+            // service no longer in a pool (should not happen)
             ServicePool.stop(s);
             try {
                 e.getCamelContext().removeService(s);
@@ -107,8 +115,8 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
             return null;
         }
         S s = getPool(endpoint).acquire();
-        if (s != null && multiPoolCache != null) {
-            multiPoolCache.putIfAbsent(new Key<>(s), s);
+        if (s != null && cache != null) {
+            cache.putIfAbsent(new Key<>(s), s);
         }
         return s;
     }
@@ -137,7 +145,7 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
         } catch (Exception e) {
             // Ignore
         }
-        if (singleton && capacity > 0) {
+        if (singleton) {
             return new SinglePool(endpoint);
         } else {
             return new MultiplePool(endpoint);
@@ -151,6 +159,13 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
         return pool.values().stream().mapToInt(Pool::size).sum();
     }
 
+    public void cleanUp() {
+        if (cache instanceof LRUCache) {
+            ((LRUCache) cache).cleanUp();
+        }
+        pool.values().forEach(Pool::cleanUp);
+    }
+
     @Override
     protected void doStart() throws Exception {
         // noop
@@ -160,8 +175,8 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
     protected void doStop() throws Exception {
         pool.values().forEach(Pool::stop);
         pool.clear();
-        if (multiPoolCache != null) {
-            multiPoolCache.clear();
+        if (cache != null) {
+            cache.clear();
         }
     }
 
@@ -173,9 +188,14 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
         }
     }
 
+    /**
+     * Pool used for singleton producers or consumers which are thread-safe
+     * and can be shared by multiple worker threads at any given time.
+     */
     private class SinglePool implements Pool<S> {
         private final Endpoint endpoint;
         private volatile S s;
+        private volatile S toBeEvicted;
 
         SinglePool(Endpoint endpoint) {
             this.endpoint = endpoint;
@@ -183,21 +203,28 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
 
         @Override
         public S acquire() throws Exception {
+            cleanupEvicts();
+
             if (s == null) {
                 synchronized (this) {
                     if (s == null) {
+                        LOG.trace("Creating service from endpoint: {}", endpoint);
                         S tempS = creator.apply(endpoint);
                         endpoint.getCamelContext().addService(tempS, true, true);
                         s = tempS;
                     }
                 }
             }
+            LOG.trace("Acquired service: {}", s);
             return s;
         }
 
         @Override
         public void release(S s) {
+            cleanupEvicts();
+
             // noop
+            LOG.trace("Released service: {}", s);
         }
 
         @Override
@@ -213,17 +240,30 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
                 s = null;
             }
             doStop(toStop);
+            pool.remove(endpoint);
         }
 
         @Override
-        public boolean evict(S s) {
-            synchronized (this) {
-                if (this.s == s) {
-                    this.s = null;
+        public void evict(S s) {
+            // to be evicted
+            toBeEvicted = s;
+        }
+
+        @Override
+        public void cleanUp() {
+            cleanupEvicts();
+        }
+
+        private void cleanupEvicts() {
+            if (toBeEvicted != null) {
+                synchronized (this) {
+                    if (toBeEvicted != null) {
+                        doStop(toBeEvicted);
+                        pool.remove(endpoint);
+                        toBeEvicted = null;
+                    }
                 }
             }
-            doStop(s);
-            return true;
         }
 
         void doStop(S s) {
@@ -238,16 +278,40 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
         }
     }
 
+    /**
+     * Pool used for non-singleton producers or consumers which are not thread-safe
+     * and can only be used by one worker thread at any given time.
+     */
     private class MultiplePool implements Pool<S> {
         private final Endpoint endpoint;
-        private final ConcurrentLinkedQueue<S> queue = new ConcurrentLinkedQueue<>();
+        private final BlockingQueue<S> queue;
+        private final List<S> evicts;
 
         MultiplePool(Endpoint endpoint) {
             this.endpoint = endpoint;
+            this.queue = new ArrayBlockingQueue<>(capacity);
+            this.evicts = new ArrayList<>();
+        }
+
+        private void cleanupEvicts() {
+            if (!evicts.isEmpty()) {
+                synchronized (this) {
+                    if (!evicts.isEmpty()) {
+                        evicts.forEach(queue::remove);
+                        evicts.forEach(this::doStop);
+                        evicts.clear();
+                        if (queue.isEmpty()) {
+                            pool.remove(endpoint);
+                        }
+                    }
+                }
+            }
         }
 
         @Override
         public S acquire() throws Exception {
+            cleanupEvicts();
+
             S s = queue.poll();
             if (s == null) {
                 s = creator.apply(endpoint);
@@ -258,10 +322,11 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
 
         @Override
         public void release(S s) {
-            if (queue.size() < capacity) {
-                queue.add(s);
-            } else {
-                ServicePool.stop(s);
+            cleanupEvicts();
+
+            if (!queue.offer(s)) {
+                // there is no room so lets just stop and discard this
+                doStop(s);
             }
         }
 
@@ -272,15 +337,32 @@ abstract class ServicePool<S extends Service> extends ServiceSupport implements
 
         @Override
         public void stop() {
-            queue.forEach(ServicePool::stop);
+            queue.forEach(this::doStop);
             queue.clear();
+            evicts.clear();
+            pool.remove(endpoint);
         }
 
         @Override
-        public boolean evict(S s) {
-            queue.remove(s);
-            ServicePool.stop(s);
-            return queue.isEmpty();
+        public void evict(S s) {
+            // to be evicted
+            evicts.add(s);
+        }
+
+        @Override
+        public void cleanUp() {
+            cleanupEvicts();
+        }
+
+        void doStop(S s) {
+            if (s != null) {
+                ServicePool.stop(s);
+                try {
+                    endpoint.getCamelContext().removeService(s);
+                } catch (Exception e) {
+                    LOG.debug("Error removing service: {}", s, e);
+                }
+            }
         }
     }
 
diff --git a/core/camel-base/src/main/java/org/apache/camel/processor/SendProcessor.java b/core/camel-base/src/main/java/org/apache/camel/processor/SendProcessor.java
index 44bc3bd3b93..299592a411d 100644
--- a/core/camel-base/src/main/java/org/apache/camel/processor/SendProcessor.java
+++ b/core/camel-base/src/main/java/org/apache/camel/processor/SendProcessor.java
@@ -207,7 +207,7 @@ public class SendProcessor extends AsyncProcessorSupport implements Traceable, E
     }
 
     @Override
-    protected void doStart() throws Exception {
+    protected void doInit() throws Exception {
         if (producerCache == null) {
             // use a single producer cache as we need to only hold reference for one destination
             // and use a regular HashMap as we do not want a soft reference store that may get re-claimed when low on memory
@@ -216,6 +216,10 @@ public class SendProcessor extends AsyncProcessorSupport implements Traceable, E
             producerCache = new DefaultProducerCache(this, camelContext, 1);
             // do not add as service as we do not want to manage the producer cache
         }
+    }
+
+    @Override
+    protected void doStart() throws Exception {
         ServiceHelper.startService(producerCache);
 
         // warm up the producer by starting it so we can fail fast if there was a problem
diff --git a/core/camel-core/src/test/java/org/apache/camel/impl/ConsumerCacheZeroCapacityTest.java b/core/camel-core/src/test/java/org/apache/camel/impl/ConsumerCacheOneCapacityTest.java
similarity index 87%
rename from core/camel-core/src/test/java/org/apache/camel/impl/ConsumerCacheZeroCapacityTest.java
rename to core/camel-core/src/test/java/org/apache/camel/impl/ConsumerCacheOneCapacityTest.java
index ce032424097..94acb25f30e 100644
--- a/core/camel-core/src/test/java/org/apache/camel/impl/ConsumerCacheZeroCapacityTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/impl/ConsumerCacheOneCapacityTest.java
@@ -27,11 +27,11 @@ import org.junit.Test;
 
 import static org.awaitility.Awaitility.await;
 
-public class ConsumerCacheZeroCapacityTest extends ContextTestSupport {
+public class ConsumerCacheOneCapacityTest extends ContextTestSupport {
 
     @Test
-    public void testConsumerCacheZeroCapacity() throws Exception {
-        DefaultConsumerCache cache = new DefaultConsumerCache(this, context, -1);
+    public void testConsumerCacheOneCapacity() throws Exception {
+        DefaultConsumerCache cache = new DefaultConsumerCache(this, context, 1);
         cache.start();
 
         assertEquals("Size should be 0", 0, cache.size());
@@ -50,13 +50,16 @@ public class ConsumerCacheZeroCapacityTest extends ContextTestSupport {
         cache.releasePollingConsumer(endpoint, consumer);
 
         // takes a little to stop
-        await().atMost(1, TimeUnit.SECONDS).untilAsserted(() -> assertEquals("Stopped", ((ServiceSupport)consumer).getStatus().name()));
+        assertTrue("Should still be started", ((ServiceSupport)consumer).isStarted());
+
+        cache.stop();
+
+        // takes a little to stop
+        await().atMost(2, TimeUnit.SECONDS).untilAsserted(() -> assertEquals("Stopped", ((ServiceSupport)consumer).getStatus().name()));
 
         // should not be a file consumer thread
         found = Thread.getAllStackTraces().keySet().stream().anyMatch(t -> t.getName().contains("target/data/foo"));
         assertFalse("Should not find file consumer thread", found);
-
-        cache.stop();
     }
 
 }
diff --git a/core/camel-core/src/test/java/org/apache/camel/impl/DefaultConsumerCacheTest.java b/core/camel-core/src/test/java/org/apache/camel/impl/DefaultConsumerCacheTest.java
index 0f8296bf57a..92f9fdaaaad 100644
--- a/core/camel-core/src/test/java/org/apache/camel/impl/DefaultConsumerCacheTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/impl/DefaultConsumerCacheTest.java
@@ -35,8 +35,7 @@ public class DefaultConsumerCacheTest extends ContextTestSupport {
 
         assertEquals("Size should be 0", 0, cache.size());
 
-        // test that we cache at most 1000 consumers to avoid it eating to much
-        // memory
+        // test that we cache at most 1000 consumers to avoid it eating to much memory
         for (int i = 0; i < 1003; i++) {
             Endpoint e = context.getEndpoint("direct:queue:" + i);
             PollingConsumer p = cache.acquirePollingConsumer(e);
@@ -45,8 +44,10 @@ public class DefaultConsumerCacheTest extends ContextTestSupport {
 
         // the eviction is async so force cleanup
         cache.cleanUp();
-        await().atMost(1, TimeUnit.SECONDS).until(() -> cache.size() == 1000);
+
+        await().atMost(3, TimeUnit.SECONDS).until(() -> cache.size() == 1000);
         assertEquals("Size should be 1000", 1000, cache.size());
+
         cache.stop();
     }
 
diff --git a/core/camel-core/src/test/java/org/apache/camel/impl/DefaultProducerCacheTest.java b/core/camel-core/src/test/java/org/apache/camel/impl/DefaultProducerCacheTest.java
index 534a163933f..a80b67049b3 100644
--- a/core/camel-core/src/test/java/org/apache/camel/impl/DefaultProducerCacheTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/impl/DefaultProducerCacheTest.java
@@ -17,6 +17,7 @@
 package org.apache.camel.impl;
 
 import java.util.Map;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.camel.AsyncProducer;
@@ -32,8 +33,12 @@ import org.apache.camel.spi.EndpointUtilizationStatistics;
 import org.apache.camel.support.DefaultComponent;
 import org.apache.camel.support.DefaultEndpoint;
 import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.support.service.ServiceSupport;
 import org.junit.Test;
 
+
+import static org.awaitility.Awaitility.await;
+
 public class DefaultProducerCacheTest extends ContextTestSupport {
 
     private final AtomicInteger stopCounter = new AtomicInteger();
@@ -58,10 +63,12 @@ public class DefaultProducerCacheTest extends ContextTestSupport {
 
         // the eviction is async so force cleanup
         cache.cleanUp();
-        Thread.sleep(50);
 
-        assertEquals("Size should be 1000", 1000, cache.size());
+        await().atMost(1, TimeUnit.SECONDS).untilAsserted(() -> assertEquals("Size should be 1000", 1000, cache.size()));
+
         cache.stop();
+
+        assertEquals("Size should be 0", 0, cache.size());
     }
 
     @Test
@@ -80,15 +87,9 @@ public class DefaultProducerCacheTest extends ContextTestSupport {
 
         // the eviction is async so force cleanup
         cache.cleanUp();
-        Thread.sleep(50);
-
-        assertEquals("Size should be 5", 5, cache.size());
-
-        // the eviction listener is async so sleep a bit
-        Thread.sleep(1000);
 
-        // should have stopped the 3 evicted
-        assertEquals(3, stopCounter.get());
+        await().atMost(3, TimeUnit.SECONDS).untilAsserted(() -> assertEquals("Size should be 5", 5, cache.size()));
+        await().atMost(3, TimeUnit.SECONDS).untilAsserted(() -> assertEquals(3, stopCounter.get()));
 
         cache.stop();
 
diff --git a/core/camel-core/src/test/java/org/apache/camel/impl/EmptyProducerCacheTest.java b/core/camel-core/src/test/java/org/apache/camel/impl/EmptyProducerCacheTest.java
deleted file mode 100644
index b312d2bed8f..00000000000
--- a/core/camel-core/src/test/java/org/apache/camel/impl/EmptyProducerCacheTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.camel.impl;
-
-import org.apache.camel.AsyncProducer;
-import org.apache.camel.ContextTestSupport;
-import org.apache.camel.Endpoint;
-import org.apache.camel.impl.engine.DefaultProducerCache;
-import org.junit.Test;
-
-public class EmptyProducerCacheTest extends ContextTestSupport {
-
-    @Test
-    public void testEmptyCache() throws Exception {
-        DefaultProducerCache cache = new DefaultProducerCache(this, context, -1);
-        cache.start();
-
-        assertEquals("Size should be 0", 0, cache.size());
-
-        // we never cache any producers
-        Endpoint e = context.getEndpoint("direct:queue:1");
-        AsyncProducer p = cache.acquireProducer(e);
-
-        assertEquals("Size should be 0", 0, cache.size());
-
-        cache.releaseProducer(e, p);
-
-        assertEquals("Size should be 0", 0, cache.size());
-
-        cache.stop();
-    }
-
-    @Test
-    public void testCacheProducerAcquireAndRelease() throws Exception {
-        DefaultProducerCache cache = new DefaultProducerCache(this, context, -1);
-        cache.start();
-
-        assertEquals("Size should be 0", 0, cache.size());
-
-        // we never cache any producers
-        for (int i = 0; i < 1003; i++) {
-            Endpoint e = context.getEndpoint("direct:queue:" + i);
-            AsyncProducer p = cache.acquireProducer(e);
-            cache.releaseProducer(e, p);
-        }
-
-        assertEquals("Size should be 0", 0, cache.size());
-        cache.stop();
-    }
-
-}
diff --git a/core/camel-core/src/test/java/org/apache/camel/impl/ProducerCacheNonSingletonTest.java b/core/camel-core/src/test/java/org/apache/camel/impl/ProducerCacheNonSingletonTest.java
index 0ef0cdf222b..b8b43eb2c10 100644
--- a/core/camel-core/src/test/java/org/apache/camel/impl/ProducerCacheNonSingletonTest.java
+++ b/core/camel-core/src/test/java/org/apache/camel/impl/ProducerCacheNonSingletonTest.java
@@ -42,7 +42,7 @@ public class ProducerCacheNonSingletonTest extends ContextTestSupport {
     public void testNonSingleton() throws Exception {
         context.addComponent("dummy", new MyDummyComponent());
 
-        DefaultProducerCache cache = new DefaultProducerCache(this, context, -1);
+        DefaultProducerCache cache = new DefaultProducerCache(this, context, 100);
         cache.start();
 
         Endpoint endpoint = context.getEndpoint("dummy:foo");
@@ -54,9 +54,11 @@ public class ProducerCacheNonSingletonTest extends ContextTestSupport {
         assertNull("Should not store producer on CamelContext", found);
 
         cache.releaseProducer(endpoint, producer);
-        assertTrue("Should be stopped", producer.getStatus().isStopped());
+        assertTrue("Should still be started", producer.getStatus().isStarted());
 
         cache.stop();
+
+        assertTrue("Should be stopped", producer.getStatus().isStopped());
     }
 
     public class MyDummyComponent extends DefaultComponent {
diff --git a/core/camel-management/src/test/java/org/apache/camel/management/ManagedConsumerCacheHitsTest.java b/core/camel-management/src/test/java/org/apache/camel/management/ManagedConsumerCacheHitsTest.java
deleted file mode 100644
index 843e6e74542..00000000000
--- a/core/camel-management/src/test/java/org/apache/camel/management/ManagedConsumerCacheHitsTest.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.camel.management;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-
-import javax.management.MBeanServer;
-import javax.management.ObjectName;
-
-import org.apache.camel.Exchange;
-import org.apache.camel.builder.RouteBuilder;
-import org.apache.camel.impl.engine.DefaultConsumerCache;
-import org.junit.Test;
-
-public class ManagedConsumerCacheHitsTest extends ManagementTestSupport {
-
-    @Test
-    public void testManageConsumerCache() throws Exception {
-        // JMX tests dont work well on AIX CI servers (hangs them)
-        if (isPlatform("aix")) {
-            return;
-        }
-
-        // always register services in JMX so we can enlist our consumer template/cache
-        context.getManagementStrategy().getManagementAgent().setRegisterAlways(true);
-
-        DefaultConsumerCache cache = new DefaultConsumerCache(this, context, 0);
-        context.addService(cache);
-
-        template.sendBody("seda:a", "Hello World");
-
-        Exchange out = cache.acquirePollingConsumer(context.getEndpoint("seda:a")).receive(3000);
-        assertNotNull("Should got an exchange", out);
-        assertEquals("Hello World", out.getIn().getBody());
-
-        // get the stats for the route
-        MBeanServer mbeanServer = getMBeanServer();
-        Set<ObjectName> set = mbeanServer.queryNames(new ObjectName("*:type=services,*"), null);
-        List<ObjectName> list = new ArrayList<>(set);
-        ObjectName on = null;
-        for (ObjectName name : list) {
-            if (name.getCanonicalName().contains("ConsumerCache")) {
-                on = name;
-                break;
-            }
-        }
-
-        assertNotNull("Should have found ConsumerCache", on);
-
-        Integer max = (Integer) mbeanServer.getAttribute(on, "MaximumCacheSize");
-        assertEquals(1000, max.intValue());
-
-        Integer current = (Integer) mbeanServer.getAttribute(on, "Size");
-        assertEquals(1, current.intValue());
-
-        // since we only send 1 message we should have 0 hits and 1 miss
-        Long hits = (Long) mbeanServer.getAttribute(on, "Hits");
-        assertEquals(0, hits.longValue());
-        Long misses = (Long) mbeanServer.getAttribute(on, "Misses");
-        assertEquals(1, misses.longValue());
-
-
-        // send more
-        // ---------
-
-        template.sendBody("seda:b", "Hello World");
-        template.sendBody("seda:c", "Hello World");
-        out = cache.acquirePollingConsumer(context.getEndpoint("seda:b")).receive(3000);
-        assertNotNull(out);
-        out = cache.acquirePollingConsumer(context.getEndpoint("seda:c")).receive(3000);
-        assertNotNull(out);
-
-        // we have only consumed from 3 different endpoints so all is misses
-        hits = (Long) mbeanServer.getAttribute(on, "Hits");
-        assertEquals(0, hits.longValue());
-        misses = (Long) mbeanServer.getAttribute(on, "Misses");
-        assertEquals(3, misses.longValue());
-
-
-        // send to same endpoints
-        // ----------------------
-
-        template.sendBody("seda:a", "Bye World");
-        template.sendBody("seda:b", "Bye World");
-        out = cache.acquirePollingConsumer(context.getEndpoint("seda:a")).receive(3000);
-        assertNotNull(out);
-        out = cache.acquirePollingConsumer(context.getEndpoint("seda:b")).receive(3000);
-        assertNotNull(out);
-
-        // we should have hits now
-        hits = (Long) mbeanServer.getAttribute(on, "Hits");
-        assertEquals(2, hits.longValue());
-        misses = (Long) mbeanServer.getAttribute(on, "Misses");
-        assertEquals(3, misses.longValue());
-
-
-        // reset statistics
-        // ----------------
-        mbeanServer.invoke(on, "resetStatistics", null, null);
-        hits = (Long) mbeanServer.getAttribute(on, "Hits");
-        assertEquals(0, hits.longValue());
-        misses = (Long) mbeanServer.getAttribute(on, "Misses");
-        assertEquals(0, misses.longValue());
-    }
-
-    @Override
-    protected RouteBuilder createRouteBuilder() throws Exception {
-        return new RouteBuilder() {
-            @Override
-            public void configure() throws Exception {
-                // note: this route is not used in the test
-                from("direct:start").to("mock:result");
-            }
-        };
-    }
-
-}
\ No newline at end of file
