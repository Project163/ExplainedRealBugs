diff --git a/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/SpringBootAutoConfigurationMojo.java b/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/SpringBootAutoConfigurationMojo.java
index e54a49ee9cc..cd24d7765b5 100644
--- a/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/SpringBootAutoConfigurationMojo.java
+++ b/tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/SpringBootAutoConfigurationMojo.java
@@ -39,11 +39,13 @@ import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
+
 import org.apache.camel.maven.packaging.model.ComponentModel;
 import org.apache.camel.maven.packaging.model.ComponentOptionModel;
 import org.apache.camel.maven.packaging.model.DataFormatModel;
@@ -132,6 +134,8 @@ public class SpringBootAutoConfigurationMojo extends AbstractMojo {
         PRIMITIVEMAP.put("float", "java.lang.Float");
     }
 
+    private static final List<String> JAVA_LANG_TYPES = Arrays.asList("Boolean", "Byte", "Character", "Class", "Double", "Float", "Integer", "Long", "Object", "Short", "String");
+
     private static final String[] IGNORE_MODULES = {/* Non-standard -> */ "camel-grape", "camel-connector"};
 
     /**
@@ -464,16 +468,20 @@ public class SpringBootAutoConfigurationMojo extends AbstractMojo {
                 }
 
                 String defaultValue = null;
+                String defaultValueLiteral = null;
                 if (sourceProp.hasAnnotation(UriParam.class)) {
                     defaultValue = sourceProp.getAnnotation(UriParam.class).getStringValue("defaultValue");
+                    defaultValueLiteral = sourceProp.getAnnotation(UriParam.class).getLiteralValue("defaultValue");
                 } else if (sourceProp.hasAnnotation(UriPath.class)) {
                     defaultValue = sourceProp.getAnnotation(UriPath.class).getStringValue("defaultValue");
+                    defaultValueLiteral = sourceProp.getAnnotation(UriPath.class).getLiteralValue("defaultValue");
                 }
+
+                defaultValueLiteral = makeFQ(nestedType, defaultValueLiteral);
+
                 if (!Strings.isBlank(defaultValue)) {
-                    if ("java.lang.String".equals(optionType)) {
-                        prop.getField().setStringInitializer(defaultValue);
-                    } else if ("integer".equals(optionType) || "boolean".equals(optionType)) {
-                        prop.getField().setLiteralInitializer(defaultValue);
+                    if ("integer".equals(optionType) || "boolean".equals(optionType) || "java.lang.String".equals(optionType)) {
+                        prop.getField().setLiteralInitializer(defaultValueLiteral);
                     } else if (anEnum) {
                         String enumShortName = optionClass.getSimpleName();
                         prop.getField().setLiteralInitializer(enumShortName + "." + defaultValue);
@@ -490,6 +498,59 @@ public class SpringBootAutoConfigurationMojo extends AbstractMojo {
         writeSourceIfChanged(javaClass, fileName);
     }
 
+    private String makeFQ(JavaClassSource source, String literal) {
+        if (literal == null) {
+            return null;
+        }
+
+        if (Pattern.matches("[A-Z][A-Z0-9_]*", literal)) {
+            return source.getQualifiedName() + "." + literal;
+        }
+
+        Map<String, String> fq = new HashMap<>();
+        List<String> classes = extractClasses(literal);
+        for (String cl : classes) {
+
+            boolean found = false;
+            for (Import im : source.getImports()) {
+                if (cl.equals(im.getSimpleName())) {
+                    fq.put(cl, im.getQualifiedName());
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found) {
+                // if it's not a java.lang object, then it's in the same package
+                if (!JAVA_LANG_TYPES.contains(cl)) {
+                    fq.put(cl, source.getPackage() + "." + cl);
+                }
+            }
+        }
+
+        if (fq.size() > 0) {
+            String res = literal;
+            for (Map.Entry<String, String> fqn : fq.entrySet()) {
+                res = res.replace(fqn.getKey(), fqn.getValue());
+            }
+            return res;
+        }
+        return literal;
+    }
+
+    private List<String> extractClasses(String literal) {
+        if (literal.startsWith("\"") && literal.endsWith("\"")) {
+            return Collections.emptyList();
+        }
+        List<String> classes = new LinkedList<>();
+        Pattern regex = Pattern.compile("[^A-Za-z0-9_.]*([A-Z][A-Za-z0-9]*)[.][A-Za-z0-9_.-]+");
+        Matcher m = regex.matcher(literal);
+        while (m.find()) {
+            classes.add(m.group(1));
+        }
+        return classes;
+    }
+
     // resolved property type name and property source, Roaster doesn't resolve inner classes correctly
     private class ResolvedProperty {
         private String propertyType;
