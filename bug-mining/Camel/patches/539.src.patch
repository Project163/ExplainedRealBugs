diff --git a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java
index e00a5d5112d..c3fbae4f412 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java
@@ -21,6 +21,7 @@ import org.apache.camel.AsyncProcessor;
 import org.apache.camel.Endpoint;
 import org.apache.camel.Exchange;
 import org.apache.camel.ExchangePattern;
+import org.apache.camel.Processor;
 import org.apache.camel.Producer;
 import org.apache.camel.Service;
 import org.apache.camel.impl.ServiceSupport;
@@ -112,4 +113,8 @@ public class SendProcessor extends ServiceSupport implements AsyncProcessor, Ser
         return exchange;
     }
 
+    public Processor getProcessor() {
+        return processor;
+    }
+
 }
diff --git a/camel-core/src/main/java/org/apache/camel/util/ProcessorTypeHelper.java b/camel-core/src/main/java/org/apache/camel/util/ProcessorDefinitionHelper.java
similarity index 85%
rename from camel-core/src/main/java/org/apache/camel/util/ProcessorTypeHelper.java
rename to camel-core/src/main/java/org/apache/camel/util/ProcessorDefinitionHelper.java
index 1dee11c134e..47918f18dd1 100644
--- a/camel-core/src/main/java/org/apache/camel/util/ProcessorTypeHelper.java
+++ b/camel-core/src/main/java/org/apache/camel/util/ProcessorDefinitionHelper.java
@@ -25,9 +25,9 @@ import org.apache.camel.model.WhenDefinition;
 /**
  * Helper class for ProcessorType and the other model classes.
  */
-public final class ProcessorTypeHelper {
+public final class ProcessorDefinitionHelper {
 
-    private ProcessorTypeHelper() {
+    private ProcessorDefinitionHelper() {
     }
 
     /**
@@ -60,10 +60,13 @@ public final class ProcessorTypeHelper {
                     }
                 }
 
-                List<ProcessorDefinition> children = choice.getOtherwise().getOutputs();
-                T child = findFirstTypeInOutputs(children, type);
-                if (child != null) {
-                    return child;
+                // otherwise is optional
+                if (choice.getOtherwise() != null) {
+                    List<ProcessorDefinition> children = choice.getOtherwise().getOutputs();
+                    T child = findFirstTypeInOutputs(children, type);
+                    if (child != null) {
+                        return child;
+                    }
                 }
             }
 
diff --git a/camel-core/src/test/java/org/apache/camel/processor/ChoiceNoErrorHandlerTest.java b/camel-core/src/test/java/org/apache/camel/processor/ChoiceNoErrorHandlerTest.java
new file mode 100644
index 00000000000..5e4f50ac5c9
--- /dev/null
+++ b/camel-core/src/test/java/org/apache/camel/processor/ChoiceNoErrorHandlerTest.java
@@ -0,0 +1,164 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor;
+
+import java.lang.reflect.Method;
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Route;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.impl.EventDrivenConsumerRoute;
+import org.apache.camel.model.RouteDefinition;
+import org.apache.camel.processor.interceptor.StreamCachingInterceptor;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.ProcessorDefinitionHelper;
+
+/**
+ * Unit test based on user forum problem.
+ *
+ * @version $Revision$
+ */
+public class ChoiceNoErrorHandlerTest extends ContextTestSupport {
+
+    @Override
+    protected void setUp() throws Exception {
+        // TODO: disable JMX and you get the bug
+        //disableJMX();
+        super.setUp();
+    }
+
+    public void testNoErrorHandler() throws Exception {
+        MockEndpoint mock = getMockEndpoint("mock:result");
+        mock.expectedBodiesReceived("Hello World");
+
+        template.sendBodyAndHeader("direct:start", "Hello World", "foo", "bar");
+
+        assertMockEndpointsSatisfied();
+
+        // there should be no error handlers and no stream cache
+        for (RouteDefinition route : context.getRouteDefinitions()) {
+            assertNull("StreamCache should be disabled", route.getStreamCaching());
+
+            ErrorHandler error = ProcessorDefinitionHelper.findFirstTypeInOutputs(route.getOutputs(), DeadLetterChannel.class);
+            assertNull("There should be no error handler", error);
+        }
+
+        // there should be no error handlers and no stream cache
+        for (Route route : context.getRoutes()) {
+            if (route instanceof EventDrivenConsumerRoute) {
+                EventDrivenConsumerRoute consumer = (EventDrivenConsumerRoute) route;
+
+                StreamCachingInterceptor cache = findProceesorInRoute(consumer.getProcessor(), StreamCachingInterceptor.class);
+                assertNull("There should be no stream cache found: " + cache, cache);
+
+                ErrorHandler error = findProceesorInRoute(consumer.getProcessor(), ErrorHandler.class);
+                assertNull("There should be no error handler found: " + error, error);
+            }
+        }
+    }
+
+
+    // TODO: We need a better solution to traverse a route than using reflection
+    private <T> T findProceesorInRoute(Processor route, Class<T> type) {
+        if (route == null) {
+            return null;
+        }
+        
+        if (type.isInstance(route)) {
+            return type.cast(route);
+        }
+
+        try {
+            Method m = route.getClass().getMethod("getProcessor");
+
+            Processor child = (Processor) ObjectHelper.invokeMethod(m, route);
+            // look its children
+            return findProceesorInRoute(child, type);
+        } catch (NoSuchMethodException e) {
+            // ignore
+        }
+
+        try {
+            Method m = route.getClass().getMethod("getProcessors");
+
+            // look its children
+            Collection<Processor> children = (Collection<Processor>) ObjectHelper.invokeMethod(m, route);
+            for (Processor child : children) {
+                T out = findProceesorInRoute(child, type);
+                if (out != null) {
+                    return out;
+                }
+            }
+        } catch (NoSuchMethodException e) {
+            // ignore
+        }
+
+        try {
+            Method m = route.getClass().getMethod("getFilters");
+
+            // look its children
+            List<FilterProcessor> children = (List<FilterProcessor>) ObjectHelper.invokeMethod(m, route);
+            for (Processor child : children) {
+                T out = findProceesorInRoute(child, type);
+                if (out != null) {
+                    return out;
+                }
+            }
+        } catch (NoSuchMethodException e) {
+            // ignore
+        }
+
+        try {
+            Method m = route.getClass().getMethod("getOtherwise");
+
+            Processor child = (Processor) ObjectHelper.invokeMethod(m, route);
+            // look its children
+            return findProceesorInRoute(child, type);
+        } catch (NoSuchMethodException e) {
+            // ignore
+        }
+
+        return null;
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                errorHandler(noErrorHandler());
+
+                from("direct:start")
+                        .choice()
+                        .when(header("foo").isEqualTo("bar")).to("direct:end")
+                        .otherwise().end();
+
+                from("direct:end")
+                        .process(new Processor() {
+                            public void process(Exchange exchange) {
+                                assertEquals("Hello World", exchange.getIn().getBody(String.class));
+                            }
+                        }).to("mock:result");
+            }
+        };
+    }
+}
diff --git a/components/camel-spring/src/main/java/org/apache/camel/spring/CamelContextFactoryBean.java b/components/camel-spring/src/main/java/org/apache/camel/spring/CamelContextFactoryBean.java
index 322c459ef32..365082445ba 100644
--- a/components/camel-spring/src/main/java/org/apache/camel/spring/CamelContextFactoryBean.java
+++ b/components/camel-spring/src/main/java/org/apache/camel/spring/CamelContextFactoryBean.java
@@ -53,7 +53,7 @@ import org.apache.camel.spi.FactoryFinderResolver;
 import org.apache.camel.spi.LifecycleStrategy;
 import org.apache.camel.spi.PackageScanClassResolver;
 import org.apache.camel.spi.Registry;
-import org.apache.camel.util.ProcessorTypeHelper;
+import org.apache.camel.util.ProcessorDefinitionHelper;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.springframework.beans.factory.DisposableBean;
@@ -246,7 +246,7 @@ public class CamelContextFactoryBean extends IdentifiedType implements RouteCont
 
                 // if there is a proceed in the interceptor proxy then we should add
                 // the current outputs to out route so we will proceed and continue to route to them
-                ProceedDefinition proceed = ProcessorTypeHelper.findFirstTypeInOutputs(proxy.getOutputs(), ProceedDefinition.class);
+                ProceedDefinition proceed = ProcessorDefinitionHelper.findFirstTypeInOutputs(proxy.getOutputs(), ProceedDefinition.class);
                 if (proceed != null) {
                     proceed.getOutputs().addAll(outputs);
                 }
