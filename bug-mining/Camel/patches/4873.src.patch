diff --git a/components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/JBPMConstants.java b/components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/JBPMConstants.java
index 26bd7709284..c16e5fc3bea 100644
--- a/components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/JBPMConstants.java
+++ b/components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/JBPMConstants.java
@@ -37,16 +37,16 @@ public interface JBPMConstants {
     String STATUS_LIST = "CamelJBPMStatusList";
     String RESULT_PAGE = "CamelJBPMResultPage";
     String RESULT_PAGE_SIZE = "CamelJBPMResultPageSize";
-    
-    
+
     String JBPM_PROCESS_EVENT_LISTENER = "process";
     String JBPM_TASK_EVENT_LISTENER = "task";
     String JBPM_CASE_EVENT_LISTENER = "case";
     String JBPM_EVENT_EMITTER = "emitter";
-    
+
     String GLOBAL_CAMEL_CONTEXT_SERVICE_KEY = "GlobalCamelService";
     String DEPLOYMENT_CAMEL_CONTEXT_SERVICE_KEY_POSTFIX = "_CamelService";
     String CAMEL_ENDPOINT_ID_WI_PARAM = "CamelEndpointId";
+    String HANDLE_EXCEPTION_WI_PARAM = "HandleExceptions";
     String RESPONSE_WI_PARAM = "Response";
     String MESSAGE_WI_PARAM = "Message";
     
diff --git a/components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/workitem/AbstractCamelWorkItemHandler.java b/components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/workitem/AbstractCamelWorkItemHandler.java
index 29dfaf7bb78..cae1e1baafe 100644
--- a/components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/workitem/AbstractCamelWorkItemHandler.java
+++ b/components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/workitem/AbstractCamelWorkItemHandler.java
@@ -21,6 +21,7 @@ import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.ProducerTemplate;
 import org.apache.camel.component.jbpm.JBPMConstants;
+import org.jbpm.bpmn2.handler.WorkItemHandlerRuntimeException;
 import org.jbpm.process.workitem.core.AbstractLogOrThrowWorkItemHandler;
 import org.jbpm.services.api.service.ServiceRegistry;
 import org.kie.api.runtime.manager.RuntimeManager;
@@ -43,6 +44,11 @@ import org.slf4j.LoggerFactory;
  * {@link Message} is provided via the <code>Message</code> parameter. This gives the user access to more advanced fields like message
  * headers and attachments.
  * <p/>
+ * The handler can be configured to always wrap exceptions coming from Camel in a {@link WorkItemHandlerRuntimeException}. This is the default behaviour, but
+ * can also be explicitly configured by setting the <code>HandleExceptions</code> workitem parameter to <code>true</code>/ When
+ * the <code>HandleExceptions</code> workitem parameter is set to <code>false</code>, any exceptions coming from the Camel route will simply be
+ * re-thrown. This makes the Camel route's exception handling logic responsible for correctly handling any exceptions.
+ * <p/>
  * This handler can be constructed in multiple ways. When you don't pass a {@link RuntimeManager} to the constructor, the handler will try
  * to find the global KIE {@link CamelContext} from the <code>jBPM</code> {@link ServiceRegistry}. When the {@link RuntimeManager} is passed
  * to the constructor, the handler will retrieve and use the {@link CamelContext} bound to the {@link RuntimeManage} from the
@@ -58,11 +64,11 @@ public abstract class AbstractCamelWorkItemHandler extends AbstractLogOrThrowWor
     private ProducerTemplate producerTemplate;
 
     private final String camelEndpointId;
-    
+
     private final String camelContextKey;
-    
+
     private boolean initialized;
-    
+
     /**
      * Default Constructor. This creates a {@link ProducerTemplate} for the global {@link CamelContext}.
      */
@@ -107,14 +113,33 @@ public abstract class AbstractCamelWorkItemHandler extends AbstractLogOrThrowWor
         CamelContext camelContext = (CamelContext) ServiceRegistry.get().service(key);
         return this.producerTemplate = camelContext.createProducerTemplate();
     }
-    
-    
+
+
     public void executeWorkItem(WorkItem workItem, final WorkItemManager manager) {
         if (!initialized) {
             this.producerTemplate = buildProducerTemplate(camelContextKey);
             initialized = true;
         }
 
+        /*
+         * By default we handle exceptions via the AbstractLogOrThrow superclass.
+         * However, the user can specify not to handle exceptions. This makes the Camel
+         * route responsible for implementing the handler logic and passing the {@link
+         * RuntimeExceotion) to be handled by the process.
+         */
+        Object isHandleExceptionParamValue = workItem.getParameter(JBPMConstants.HANDLE_EXCEPTION_WI_PARAM);
+        boolean isHandleException;
+        if (isHandleExceptionParamValue == null) {
+            isHandleException = true;
+        } else if (isHandleExceptionParamValue instanceof String) {
+            isHandleException = Boolean.parseBoolean((String)isHandleExceptionParamValue);
+        } else if (isHandleExceptionParamValue instanceof Boolean) {
+            isHandleException = ((Boolean)isHandleExceptionParamValue).booleanValue();
+        } else {
+            throw new IllegalArgumentException("Unsupported type '" + isHandleExceptionParamValue.getClass().getCanonicalName() + "' for workitem parameter '"
+                + JBPMConstants.HANDLE_EXCEPTION_WI_PARAM + "'.");
+        }
+
         String workItemCamelEndpointId = getCamelEndpointId(workItem);
 
         // We only support direct. We don't need to support more, as direct simply gives us the entrypoint into the actual Camel Routes.
@@ -130,7 +155,16 @@ public abstract class AbstractCamelWorkItemHandler extends AbstractLogOrThrowWor
             }
             handleResponse(responseExchange, workItem, manager);
         } catch (Exception e) {
-            handleException(e);
+            /*
+             * Handle the exception if 'HandleException' is enabled (which is the default).
+             * If it's not enabled, simply throw the exception. Note that in that case, the
+             * exception needs to be a RuntimeException.
+             */
+            if (isHandleException) {
+                handleException(e);
+            } else {
+                throw (RuntimeException)e;
+            }
         }
     }
 
diff --git a/components/camel-jbpm/src/test/java/org/apache/camel/component/jbpm/workitem/CamelWorkItemHandlerIntegrationTests.java b/components/camel-jbpm/src/test/java/org/apache/camel/component/jbpm/workitem/CamelWorkItemHandlerIntegrationTests.java
index be652d5de03..125b50b31de 100644
--- a/components/camel-jbpm/src/test/java/org/apache/camel/component/jbpm/workitem/CamelWorkItemHandlerIntegrationTests.java
+++ b/components/camel-jbpm/src/test/java/org/apache/camel/component/jbpm/workitem/CamelWorkItemHandlerIntegrationTests.java
@@ -17,8 +17,11 @@
 package org.apache.camel.component.jbpm.workitem;
 
 import org.apache.camel.EndpointInject;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
 import org.apache.camel.Produce;
 import org.apache.camel.ProducerTemplate;
+import org.apache.camel.RuntimeCamelException;
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.component.jbpm.JBPMConstants;
 import org.apache.camel.component.mock.MockEndpoint;
@@ -205,4 +208,94 @@ public class CamelWorkItemHandlerIntegrationTests extends CamelTestSupport {
         }
     }
 
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testSyncInOutDontHandleException() throws Exception {
+        // Setup
+        String routeId = "testSyncInOutExceptionRoute";
+        RouteBuilder builder = new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start").routeId(routeId)
+                        .setBody(simple("${body.getParameter(\"Request\")}"))
+                        .throwException(new IllegalArgumentException("Illegal contennt!"))
+                        .to("mock:result");
+            }
+        };
+        context.addRoutes(builder);
+        try {
+            // Register the Camel Context with the jBPM ServiceRegistry.
+            ServiceRegistry.get().register(JBPMConstants.GLOBAL_CAMEL_CONTEXT_SERVICE_KEY, context);
+
+            // Test
+            String expectedBody = "helloRequest";
+            resultEndpoint.expectedBodiesReceived(expectedBody);
+
+            WorkItemImpl workItem = new WorkItemImpl();
+            workItem.setParameter(JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM, "start");
+            workItem.setParameter("Request", expectedBody);
+            workItem.setParameter("HandleExceptions", false);
+
+            TestWorkItemManager manager = new TestWorkItemManager();
+
+            WorkItemHandler handler = new InOutCamelWorkItemHandler();
+
+            handler.executeWorkItem(workItem, manager);
+        } finally {
+            // Cleanup
+            context.removeRoute(routeId);
+            ServiceRegistry.get().remove(JBPMConstants.GLOBAL_CAMEL_CONTEXT_SERVICE_KEY);
+        }
+    }
+
+    @Test(expected = RuntimeCamelException.class)
+    public void testSyncInOutCamelHandleException() throws Exception {
+        // Setup
+        String routeId = "testSyncInOutExceptionRoute";
+        RouteBuilder builder = new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from("direct:start").routeId(routeId)
+                        .setBody(simple("${body.getParameter(\"Request\")}"))
+                        .doTry()
+                            .throwException(new IllegalArgumentException("Illegal contennt!"))
+                        .doCatch(IllegalArgumentException.class)
+                            .process(new Processor(){
+                            
+                                @Override
+                                public void process(Exchange exchange) throws Exception {
+                                    RuntimeCamelException exceptionWrapper = new RuntimeCamelException(exchange.EXCEPTION_CAUGHT);        
+                                    throw exceptionWrapper;
+                                }
+                            })
+                        .end()
+                        .to("mock:result");
+            }
+        };
+        context.addRoutes(builder);
+        try {
+            // Register the Camel Context with the jBPM ServiceRegistry.
+            ServiceRegistry.get().register(JBPMConstants.GLOBAL_CAMEL_CONTEXT_SERVICE_KEY, context);
+
+            // Test
+            String expectedBody = "helloRequest";
+            resultEndpoint.expectedBodiesReceived(expectedBody);
+
+            WorkItemImpl workItem = new WorkItemImpl();
+            workItem.setParameter(JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM, "start");
+            workItem.setParameter("Request", expectedBody);
+            workItem.setParameter("HandleExceptions", false);
+
+            TestWorkItemManager manager = new TestWorkItemManager();
+
+            WorkItemHandler handler = new InOutCamelWorkItemHandler();
+
+            handler.executeWorkItem(workItem, manager);
+        } finally {
+            // Cleanup
+            context.removeRoute(routeId);
+            ServiceRegistry.get().remove(JBPMConstants.GLOBAL_CAMEL_CONTEXT_SERVICE_KEY);
+        }
+    }
+
 }
diff --git a/components/camel-jbpm/src/test/java/org/apache/camel/component/jbpm/workitem/InOutCamelWorkItemHandlerTest.java b/components/camel-jbpm/src/test/java/org/apache/camel/component/jbpm/workitem/InOutCamelWorkItemHandlerTest.java
index 5d785b12188..6e45ac17b62 100644
--- a/components/camel-jbpm/src/test/java/org/apache/camel/component/jbpm/workitem/InOutCamelWorkItemHandlerTest.java
+++ b/components/camel-jbpm/src/test/java/org/apache/camel/component/jbpm/workitem/InOutCamelWorkItemHandlerTest.java
@@ -26,6 +26,7 @@ import org.apache.camel.component.jbpm.JBPMConstants;
 import org.apache.camel.impl.DefaultHeadersMapFactory;
 import org.apache.camel.spi.HeadersMapFactory;
 import org.drools.core.process.instance.impl.WorkItemImpl;
+import org.jbpm.bpmn2.handler.WorkItemHandlerRuntimeException;
 import org.jbpm.process.workitem.core.TestWorkItemManager;
 import org.jbpm.services.api.service.ServiceRegistry;
 import org.junit.Test;
@@ -36,6 +37,7 @@ import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
 
 import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.CoreMatchers.isA;
 import static org.junit.Assert.*;
 import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
@@ -227,5 +229,155 @@ public class InOutCamelWorkItemHandlerTest {
         handler.executeWorkItem(workItem, manager);
 
     }
+    
+    @Test
+    public void testExecuteInOutLocalCamelContextDefaultHandleException() throws Exception {
+
+        String camelEndpointId = "testCamelRoute";
+        String camelRouteUri = "direct:" + camelEndpointId;
+
+        String testReponse = "testResponse";
+
+        String runtimeManagerId = "testRuntimeManager";
+        
+
+        when(runtimeManager.getIdentifier()).thenReturn(runtimeManagerId);
+
+        //Throw an error back to the WIH
+        when(producerTemplate.send(eq(camelRouteUri), ArgumentMatchers.any(Exchange.class))).thenThrow(new ToBeHandledException());
+        when(producerTemplate.getCamelContext()).thenReturn(camelContext);
+
+        when(camelContext.createProducerTemplate()).thenReturn(producerTemplate);
+        HeadersMapFactory hmf = new DefaultHeadersMapFactory();
+        when(camelContext.getHeadersMapFactory()).thenReturn(hmf);
+
+        // Register the RuntimeManager bound camelcontext.
+        try {
+            ServiceRegistry.get().register(runtimeManagerId + "_CamelService", camelContext);
+
+            WorkItemImpl workItem = new WorkItemImpl();
+            workItem.setParameter(JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM, camelEndpointId);
+            workItem.setParameter("Request", "someRequest");
+            workItem.setDeploymentId("testDeploymentId");
+            workItem.setProcessInstanceId(1L);
+            workItem.setId(1L);
+
+            AbstractCamelWorkItemHandler handler = new InOutCamelWorkItemHandler(runtimeManager);
+
+            TestWorkItemManager manager = new TestWorkItemManager();
+            try {
+            	handler.executeWorkItem(workItem, manager);
+            	throw new RuntimeException("The test expects an exception. This code should never be reached.");
+            } catch (Throwable wihRe) {
+            	assertThat(wihRe, is(instanceOf(WorkItemHandlerRuntimeException.class)));
+            	assertThat(wihRe.getCause(), is(instanceOf(ToBeHandledException.class)));
+            }
+
+        } finally {
+            ServiceRegistry.get().remove(runtimeManagerId + "_CamelService");
+        }
+    }
+
+    @Test
+    public void testExecuteInOutLocalCamelContextExplicitHandleException() throws Exception {
+
+        String camelEndpointId = "testCamelRoute";
+        String camelRouteUri = "direct:" + camelEndpointId;
+
+        String testReponse = "testResponse";
+
+        String runtimeManagerId = "testRuntimeManager";
+        
+
+        when(runtimeManager.getIdentifier()).thenReturn(runtimeManagerId);
+
+        //Throw an error back to the WIH
+        when(producerTemplate.send(eq(camelRouteUri), ArgumentMatchers.any(Exchange.class))).thenThrow(new ToBeHandledException());
+        when(producerTemplate.getCamelContext()).thenReturn(camelContext);
+
+        when(camelContext.createProducerTemplate()).thenReturn(producerTemplate);
+        HeadersMapFactory hmf = new DefaultHeadersMapFactory();
+        when(camelContext.getHeadersMapFactory()).thenReturn(hmf);
+
+        // Register the RuntimeManager bound camelcontext.
+        try {
+            ServiceRegistry.get().register(runtimeManagerId + "_CamelService", camelContext);
+
+            WorkItemImpl workItem = new WorkItemImpl();
+            workItem.setParameter(JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM, camelEndpointId);
+            workItem.setParameter("Request", "someRequest");
+            workItem.setParameter("HandleExceptions", true);
+            workItem.setDeploymentId("testDeploymentId");
+            workItem.setProcessInstanceId(1L);
+            workItem.setId(1L);
+
+            AbstractCamelWorkItemHandler handler = new InOutCamelWorkItemHandler(runtimeManager);
+
+            TestWorkItemManager manager = new TestWorkItemManager();
+            try {
+            	handler.executeWorkItem(workItem, manager);
+            	throw new RuntimeException("The test expects an exception. This code should never be reached.");
+            } catch (Throwable wihRe) {
+            	assertThat(wihRe, is(instanceOf(WorkItemHandlerRuntimeException.class)));
+            	assertThat(wihRe.getCause(), is(instanceOf(ToBeHandledException.class)));
+            }
+
+        } finally {
+            ServiceRegistry.get().remove(runtimeManagerId + "_CamelService");
+        }
+    }
+    
+    @Test
+    public void testExecuteInOutLocalCamelContextNotHandleException() throws Exception {
+
+        String camelEndpointId = "testCamelRoute";
+        String camelRouteUri = "direct:" + camelEndpointId;
+
+        String testReponse = "testResponse";
+
+        String runtimeManagerId = "testRuntimeManager";
+
+        when(runtimeManager.getIdentifier()).thenReturn(runtimeManagerId);
+
+        //Throw an error back to the WIH
+        when(producerTemplate.send(eq(camelRouteUri), ArgumentMatchers.any(Exchange.class))).thenThrow(new NotToBeHandledException());
+        when(producerTemplate.getCamelContext()).thenReturn(camelContext);
+
+        when(camelContext.createProducerTemplate()).thenReturn(producerTemplate);
+        HeadersMapFactory hmf = new DefaultHeadersMapFactory();
+        when(camelContext.getHeadersMapFactory()).thenReturn(hmf);
+
+        // Register the RuntimeManager bound camelcontext.
+        try {
+            ServiceRegistry.get().register(runtimeManagerId + "_CamelService", camelContext);
+
+            WorkItemImpl workItem = new WorkItemImpl();
+            workItem.setParameter(JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM, camelEndpointId);
+            workItem.setParameter("Request", "someRequest");
+            workItem.setParameter("HandleExceptions", false);
+            workItem.setDeploymentId("testDeploymentId");
+            workItem.setProcessInstanceId(1L);
+            workItem.setId(1L);
+
+            AbstractCamelWorkItemHandler handler = new InOutCamelWorkItemHandler(runtimeManager);
+
+            TestWorkItemManager manager = new TestWorkItemManager();
+            try {
+            	handler.executeWorkItem(workItem, manager);
+            	throw new RuntimeException("The test expects an exception. This code should never be reached.");
+            } catch (Throwable wihRe) {
+            	assertThat(wihRe, is(instanceOf(NotToBeHandledException.class)));
+            }
+
+        } finally {
+            ServiceRegistry.get().remove(runtimeManagerId + "_CamelService");
+        }
+    }
+    
+    public static class ToBeHandledException extends RuntimeException {
+    }
+    
+    public static class NotToBeHandledException extends RuntimeException {
+    }
 
 }
