diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
index f2f09c00af0..78ab290e0d0 100644
--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
@@ -177,12 +177,16 @@ public class AggregateProcessor extends ServiceSupport implements Processor, Nav
             throw new ClosedCorrelationKeyException(key, exchange);
         }
 
+        // copy exchange, and do not share the unit of work
+        // the aggregated output runs in another unit of work
+        Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);
+
         // when memory based then its fast using synchronized, but if the aggregation repository is IO
         // bound such as JPA etc then concurrent aggregation per correlation key could
         // improve performance as we can run aggregation repository get/add in parallel
         lock.lock();
         try {
-            doAggregation(key, exchange);
+            doAggregation(key, copy);
         } finally {
             lock.unlock();
         }
diff --git a/camel-core/src/test/java/org/apache/camel/processor/aggregator/BeanBeforeAggregateIssueTest.java b/camel-core/src/test/java/org/apache/camel/processor/aggregator/BeanBeforeAggregateIssueTest.java
index 71faa304de6..306cfedd860 100644
--- a/camel-core/src/test/java/org/apache/camel/processor/aggregator/BeanBeforeAggregateIssueTest.java
+++ b/camel-core/src/test/java/org/apache/camel/processor/aggregator/BeanBeforeAggregateIssueTest.java
@@ -16,22 +16,37 @@
  */
 package org.apache.camel.processor.aggregator;
 
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
 import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.NotifyBuilder;
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.processor.BodyInAggregatingStrategy;
+import org.apache.camel.processor.aggregate.MemoryAggregationRepository;
 
 /**
  * @version $Revision$
  */
 public class BeanBeforeAggregateIssueTest extends ContextTestSupport {
 
+    private MyAggRepo myRepo = new MyAggRepo();
+
     public void testBeanBeforeAggregation() throws Exception {
+        NotifyBuilder notify = new NotifyBuilder(context).whenDone(3).create();
+
         getMockEndpoint("mock:result").expectedBodiesReceived("A+B");
 
         template.sendBody("seda:start", "A");
         template.sendBody("seda:start", "B");
 
         assertMockEndpointsSatisfied();
+
+        // wait for all exchanges to be done (2 input + 1 aggregated)
+        notify.matches(5, TimeUnit.SECONDS);
+
+        // should have confirmed
+        assertTrue("Should have confirmed", myRepo.isConfirm());
     }
 
     @Override
@@ -42,6 +57,7 @@ public class BeanBeforeAggregateIssueTest extends ContextTestSupport {
                 from("seda:start")
                     .bean(TestBean.class)
                     .aggregate(constant("true"), new BodyInAggregatingStrategy())
+                        .aggregationRepository(myRepo)
                         .completionSize(2)
                         .to("mock:result");
             }
@@ -54,4 +70,20 @@ public class BeanBeforeAggregateIssueTest extends ContextTestSupport {
             return foo;
         }
     }
+
+    private final class MyAggRepo extends MemoryAggregationRepository {
+
+        private volatile boolean confirm;
+
+        @Override
+        public void confirm(CamelContext camelContext, String exchangeId) {
+            // test that confirm is invoked
+            super.confirm(camelContext, exchangeId);
+            confirm = true;
+        }
+
+        public boolean isConfirm() {
+            return confirm;
+        }
+    }
 }
