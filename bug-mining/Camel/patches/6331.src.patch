diff --git a/components/camel-zipfile/src/main/java/org/apache/camel/processor/aggregate/zipfile/ZipAggregationStrategy.java b/components/camel-zipfile/src/main/java/org/apache/camel/processor/aggregate/zipfile/ZipAggregationStrategy.java
index e2a5880b9f7..4d9a0448a93 100644
--- a/components/camel-zipfile/src/main/java/org/apache/camel/processor/aggregate/zipfile/ZipAggregationStrategy.java
+++ b/components/camel-zipfile/src/main/java/org/apache/camel/processor/aggregate/zipfile/ZipAggregationStrategy.java
@@ -216,6 +216,14 @@ public class ZipAggregationStrategy implements AggregationStrategy {
         return answer;
     }
 
+    @Override
+    public void onCompletion(Exchange exchange, Exchange inputExchange) {
+        // this aggregation strategy added onCompletion which we should handover when we are complete
+        if (inputExchange != null) {
+            exchange.adapt(ExtendedExchange.class).handoverCompletions(inputExchange);
+        }
+    }
+
     private static void newZipFile(File zipFile) throws URISyntaxException, IOException {
         if (zipFile.exists() && !zipFile.delete()) { //Delete, because ZipFileSystem needs to create file on its own (with correct END bytes in the file)
             throw new IOException("Cannot delete file " + zipFile);
diff --git a/core/camel-core-processor/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/core/camel-core-processor/src/main/java/org/apache/camel/processor/MulticastProcessor.java
index e7f5c2d2fc2..af740f9b1c2 100644
--- a/core/camel-core-processor/src/main/java/org/apache/camel/processor/MulticastProcessor.java
+++ b/core/camel-core-processor/src/main/java/org/apache/camel/processor/MulticastProcessor.java
@@ -767,7 +767,7 @@ public class MulticastProcessor extends AsyncProcessorSupport
      * @param pairs        the pairs with the exchanges to process
      * @param callback     the callback
      * @param doneSync     the <tt>doneSync</tt> parameter to call on callback
-     * @param forceExhaust whether or not error handling is exhausted
+     * @param forceExhaust whether error handling is exhausted
      */
     protected void doDone(
             Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs,
@@ -800,9 +800,8 @@ public class MulticastProcessor extends AsyncProcessorSupport
                 // if we stopped due an exception then only propagate the exception
                 original.setException(subExchange.getException());
             } else {
-                // copy the current result to original so it will contain this result of this eip
+                // copy the current result to original, so it will contain this result of this eip
                 ExchangeHelper.copyResults(original, subExchange);
-                subExchange.adapt(ExtendedExchange.class).handoverCompletions(original);
             }
         }
 
