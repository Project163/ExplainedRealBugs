diff --git a/components/camel-sql/src/test/java/org/apache/camel/processor/aggregate/jdbc/JdbcLoopTransactedSplitterTest.java b/components/camel-sql/src/test/java/org/apache/camel/processor/aggregate/jdbc/JdbcLoopTransactedSplitterStackSizeTest.java
similarity index 60%
rename from components/camel-sql/src/test/java/org/apache/camel/processor/aggregate/jdbc/JdbcLoopTransactedSplitterTest.java
rename to components/camel-sql/src/test/java/org/apache/camel/processor/aggregate/jdbc/JdbcLoopTransactedSplitterStackSizeTest.java
index 2983f800c91..0222eec494e 100644
--- a/components/camel-sql/src/test/java/org/apache/camel/processor/aggregate/jdbc/JdbcLoopTransactedSplitterTest.java
+++ b/components/camel-sql/src/test/java/org/apache/camel/processor/aggregate/jdbc/JdbcLoopTransactedSplitterStackSizeTest.java
@@ -20,14 +20,16 @@ import java.io.File;
 import java.sql.DriverManager;
 
 import org.apache.camel.builder.RouteBuilder;
-import org.apache.camel.component.mock.MockEndpoint;
 import org.apache.camel.spi.Registry;
 import org.apache.camel.spring.spi.SpringTransactionPolicy;
 import org.apache.camel.util.FileUtil;
 import org.apache.derby.jdbc.EmbeddedDataSource;
 import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.parallel.Isolated;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.jdbc.datasource.DataSourceTransactionManager;
 import org.springframework.transaction.PlatformTransactionManager;
 import org.springframework.transaction.support.TransactionTemplate;
@@ -35,17 +37,27 @@ import org.springframework.transaction.support.TransactionTemplate;
 import static org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied;
 
 @Isolated
-public class JdbcLoopTransactedSplitterTest extends AbstractJdbcAggregationTestSupport {
+public class JdbcLoopTransactedSplitterStackSizeTest extends AbstractJdbcAggregationTestSupport {
+
+    private static final Logger LOG = LoggerFactory.getLogger(JdbcLoopTransactedSplitterStackSizeTest.class);
+
+    private static final boolean PRINT_STACK_TRACE = false;
+    private int total = 500;
 
     private static final String DSNAME = "ds";
     private static EmbeddedDataSource ds;
     private static PlatformTransactionManager txManager;
     private static SpringTransactionPolicy txPolicy;
 
-    private final String xmlBody
-            = "<messages>" + "<message><name>John</name></message>" + "<message><name>Jane</name></message>"
-              + "<message><name>Jim</name></message>" + "<message><name>Jack</name></message>"
-              + "<message><name>Jill</name></message>" + "</messages>";
+    private final String xmlBody = """
+            <messages>
+                <message><name>John</name></message>
+                <message><name>Jane</name></message>
+                <message><name>Jim</name></message>
+                <message><name>Jack</name></message>
+                <message><name>Jill</name></message>
+            </messages>
+            """;
 
     @Override
     protected void bindToRegistry(Registry registry) throws Exception {
@@ -72,12 +84,31 @@ public class JdbcLoopTransactedSplitterTest extends AbstractJdbcAggregationTestS
 
     @Test
     public void testIfLoopCompleted() throws Exception {
-        MockEndpoint mock = getMockEndpoint("mock:out");
-        mock.expectedMessageCount(1);
+        getMockEndpoint("mock:line").expectedMessageCount(total);
+        getMockEndpoint("mock:result").expectedMessageCount(1);
 
         template.sendBody("direct:start", "");
 
         assertIsSatisfied(context);
+
+        int[] sizes = new int[total + 1];
+        for (int i = 0; i < total; i++) {
+            int size = getMockEndpoint("mock:line").getReceivedExchanges().get(i).getMessage().getHeader("stackSize",
+                    int.class);
+            sizes[i] = size;
+            Assertions.assertTrue(size < 180, "Stackframe should be < 180, was: " + size);
+            LOG.debug("#{} size {}", i, size);
+        }
+        int size = getMockEndpoint("mock:result").getReceivedExchanges().get(0).getMessage().getHeader("stackSize", int.class);
+        sizes[total] = size;
+        LOG.debug("#{} size {}", total, size);
+
+        int prev = sizes[0];
+        // last may be shorter, so use total - 1
+        for (int i = 1; i < total - 1; i++) {
+            size = sizes[i];
+            Assertions.assertEquals(prev, size, "Stackframe should be same size");
+        }
     }
 
     @Override
@@ -86,23 +117,34 @@ public class JdbcLoopTransactedSplitterTest extends AbstractJdbcAggregationTestS
             @Override
             public void configure() {
                 from("direct:start")
-                    .loop(2000)
+                        .loop(total / 5)
                         .log("Loop ${exchangeProperty.CamelLoopIndex}")
                         .setBody(simple(xmlBody))
                         .to("direct:subroute")
-                    .end()
-                    .log("Completed successfully ${exchangeId}")
-                    .to("mock:out");
+                        .end()
+                        .log("Completed successfully ${exchangeId}")
+                        .setHeader("stackSize", JdbcLoopTransactedSplitterStackSizeTest::currentStackSize)
+                        .to("mock:result");
 
                 from("direct:subroute")
-                    .transacted("txPolicy")
-                    .split(xpath("/messages/message")).streaming().stopOnException()
+                        .transacted("txPolicy")
+                        .split(xpath("/messages/message")).streaming().stopOnException()
+                        .setHeader("stackSize", JdbcLoopTransactedSplitterStackSizeTest::currentStackSize)
                         .log("Body === ${body}")
-                    .end();
+                        .to("mock:line")
+                        .end();
             }
         };
     }
 
+    public static int currentStackSize() {
+        int depth = Thread.currentThread().getStackTrace().length;
+        if (PRINT_STACK_TRACE) {
+            new Throwable("Printing Stacktrace depth: " + depth).printStackTrace(System.err);
+        }
+        return depth;
+    }
+
     private static class Derby {
 
         public static EmbeddedDataSource init(String db) {
diff --git a/core/camel-core-processor/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/core/camel-core-processor/src/main/java/org/apache/camel/processor/MulticastProcessor.java
index 0b3e6e8797d..dbaf06d26f3 100644
--- a/core/camel-core-processor/src/main/java/org/apache/camel/processor/MulticastProcessor.java
+++ b/core/camel-core-processor/src/main/java/org/apache/camel/processor/MulticastProcessor.java
@@ -150,7 +150,7 @@ public class MulticastProcessor extends AsyncProcessorSupport
         }
     }
 
-    private final class SyncScheduler implements Executor {
+    private final class TransactedScheduler implements Executor {
 
         @Override
         public void execute(Runnable command) {
@@ -179,7 +179,7 @@ public class MulticastProcessor extends AsyncProcessorSupport
     private final ExecutorService executorService;
     private final boolean shutdownExecutorService;
     private final Scheduler scheduler = new Scheduler();
-    private final SyncScheduler syncScheduler = new SyncScheduler();
+    private final TransactedScheduler txScheduler = new TransactedScheduler();
     private ExecutorService aggregateExecutorService;
     private boolean shutdownAggregateExecutorService;
     private final long timeout;
@@ -381,7 +381,7 @@ public class MulticastProcessor extends AsyncProcessorSupport
         schedule(runnable, false);
     }
 
-    protected void schedule(final Runnable runnable, boolean sync) {
+    protected void schedule(final Runnable runnable, boolean transacted) {
         if (isParallelProcessing()) {
             Runnable task = prepareMDCParallelTask(camelContext, runnable);
             try {
@@ -391,8 +391,8 @@ public class MulticastProcessor extends AsyncProcessorSupport
                     rej.reject();
                 }
             }
-        } else if (sync) {
-            reactiveExecutor.scheduleSync(runnable);
+        } else if (transacted) {
+            reactiveExecutor.scheduleQueue(runnable);
         } else {
             reactiveExecutor.schedule(runnable);
         }
@@ -415,7 +415,7 @@ public class MulticastProcessor extends AsyncProcessorSupport
         final ScheduledFuture<?> timeoutTask;
 
         MulticastTask(Exchange original, Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, int capacity,
-                      boolean sync) {
+                      boolean transacted) {
             this.original = original;
             this.pairs = pairs;
             this.callback = callback;
@@ -435,9 +435,9 @@ public class MulticastProcessor extends AsyncProcessorSupport
             }
             if (capacity > 0) {
                 this.completion
-                        = new AsyncCompletionService<>(sync ? syncScheduler : scheduler, !isStreaming(), lock, capacity);
+                        = new AsyncCompletionService<>(transacted ? txScheduler : scheduler, !isStreaming(), lock, capacity);
             } else {
-                this.completion = new AsyncCompletionService<>(sync ? syncScheduler : scheduler, !isStreaming(), lock);
+                this.completion = new AsyncCompletionService<>(transacted ? txScheduler : scheduler, !isStreaming(), lock);
             }
         }
 
diff --git a/core/camel-core-processor/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/core/camel-core-processor/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
index 6e8afe0fecf..8e467138b4c 100644
--- a/core/camel-core-processor/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
+++ b/core/camel-core-processor/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java
@@ -869,7 +869,11 @@ public class AggregateProcessor extends AsyncProcessorSupport
                 }
             });
             // execute the task using this thread sync (similar to multicast eip in parallel mode)
-            reactiveExecutor.scheduleSync(task);
+            if (exchange.isTransacted()) {
+                reactiveExecutor.scheduleQueue(task);
+            } else {
+                reactiveExecutor.scheduleSync(task);
+            }
         });
     }
 
