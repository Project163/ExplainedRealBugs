diff --git a/components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/DefaultNettyHttpBinding.java b/components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/DefaultNettyHttpBinding.java
index f8cf4a344e4..9f94ea08709 100644
--- a/components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/DefaultNettyHttpBinding.java
+++ b/components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/DefaultNettyHttpBinding.java
@@ -16,6 +16,7 @@
  */
 package org.apache.camel.component.netty4.http;
 
+import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
 import java.io.ObjectOutputStream;
@@ -49,6 +50,7 @@ import org.apache.camel.StreamCache;
 import org.apache.camel.TypeConverter;
 import org.apache.camel.component.netty4.NettyConstants;
 import org.apache.camel.component.netty4.NettyConverter;
+import org.apache.camel.converter.stream.ByteArrayInputStreamCache;
 import org.apache.camel.spi.HeaderFilterStrategy;
 import org.apache.camel.util.ExchangeHelper;
 import org.apache.camel.util.IOHelper;
@@ -95,7 +97,7 @@ public class DefaultNettyHttpBinding implements NettyHttpBinding, Cloneable {
             // keep the body as is, and use type converters
             answer.setBody(request.content());
         } else {
-            // turn the body into stream cached
+            // turn the body into stream cached (on the client/consumer side we can facade the netty stream instead of converting to byte array)
             NettyChannelBufferStreamCache cache = new NettyChannelBufferStreamCache(request.content());
             // add on completion to the cache which is needed for Camel to keep track of the lifecycle of the cache
             exchange.addOnCompletion(new NettyChannelBufferStreamCacheOnCompletion(cache));
@@ -274,13 +276,12 @@ public class DefaultNettyHttpBinding implements NettyHttpBinding, Cloneable {
             // keep the body as is, and use type converters
             answer.setBody(response.content());
         } else {
-            // stores as byte array as the netty ByteBuf will be freedy when the producer is done, and then we
-            // can no longer access the message body
+            // stores as byte array as the netty ByteBuf will be freed when the producer is done,
+            // and then we can no longer access the message body
             response.retain();
             try {
                 byte[] bytes = exchange.getContext().getTypeConverter().convertTo(byte[].class, exchange, response.content());
-                answer.setBody(bytes);
-                // TODO: use stream caching
+                answer.setBody(new ByteArrayInputStreamCache(new ByteArrayInputStream(bytes)));
             } finally {
                 response.release();
             }
diff --git a/components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/NettyHttpConfiguration.java b/components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/NettyHttpConfiguration.java
index 784d007c21e..82024188059 100644
--- a/components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/NettyHttpConfiguration.java
+++ b/components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/NettyHttpConfiguration.java
@@ -55,7 +55,7 @@ public class NettyHttpConfiguration extends NettyConfiguration {
     private boolean matchOnUriPrefix;
     @UriParam
     private boolean bridgeEndpoint;
-    @UriParam(label = "consumer,advanced")
+    @UriParam(label = "advanced")
     private boolean disableStreamCache;
     @UriParam(label = "consumer", defaultValue = "true")
     private boolean send503whenSuspended = true;
@@ -243,14 +243,14 @@ public class NettyHttpConfiguration extends NettyConfiguration {
     }
 
     /**
-     * Determines whether or not the raw input stream from Netty HttpRequest#getContent() is cached or not
-     * (Camel will read the stream into a in light-weight memory based Stream caching) cache.
+     * Determines whether or not the raw input stream from Netty HttpRequest#getContent() or HttpResponset#getContent()
+     * is cached or not (Camel will read the stream into a in light-weight memory based Stream caching) cache.
      * By default Camel will cache the Netty input stream to support reading it multiple times to ensure it Camel
      * can retrieve all data from the stream. However you can set this option to true when you for example need to
      * access the raw stream, such as streaming it directly to a file or other persistent store. Mind that
      * if you enable this option, then you cannot read the Netty stream multiple times out of the box, and you would
      * need manually to reset the reader index on the Netty raw stream. Also Netty will auto-close the Netty stream
-     * when the Netty HTTP server is done processing, which means that if the asynchronous routing engine is in
+     * when the Netty HTTP server/HTTP client is done processing, which means that if the asynchronous routing engine is in
      * use then any asynchronous thread that may continue routing the {@link org.apache.camel.Exchange} may not
      * be able to read the Netty stream, because Netty has closed it.
      */
diff --git a/components/camel-netty4/src/main/java/org/apache/camel/component/netty4/handlers/ClientChannelHandler.java b/components/camel-netty4/src/main/java/org/apache/camel/component/netty4/handlers/ClientChannelHandler.java
index 60db52f5984..b9a2a175135 100644
--- a/components/camel-netty4/src/main/java/org/apache/camel/component/netty4/handlers/ClientChannelHandler.java
+++ b/components/camel-netty4/src/main/java/org/apache/camel/component/netty4/handlers/ClientChannelHandler.java
@@ -94,8 +94,6 @@ public class ClientChannelHandler extends SimpleChannelInboundHandler<Object> {
             // signal callback
             callback.done(false);
         }
-
-        super.exceptionCaught(ctx, cause);
     }
 
     @Override
