diff --git a/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java
index a5cd8d12660..e87682b65fd 100644
--- a/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java
+++ b/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java
@@ -319,7 +319,7 @@ public abstract class RouteBuilder extends BuilderSupport implements RoutesBuild
             // mark all route definitions as custom prepared because
             // a route builder prepares the route definitions correctly already
             for (RouteDefinition route : getRouteCollection().getRoutes()) {
-                route.customPrepared();
+                route.markPrepared();
             }
         }
     }
diff --git a/camel-core/src/main/java/org/apache/camel/model/RouteDefinition.java b/camel-core/src/main/java/org/apache/camel/model/RouteDefinition.java
index 8359e456c71..a075cf8ee7d 100644
--- a/camel-core/src/main/java/org/apache/camel/model/RouteDefinition.java
+++ b/camel-core/src/main/java/org/apache/camel/model/RouteDefinition.java
@@ -89,32 +89,18 @@ public class RouteDefinition extends ProcessorDefinition<RouteDefinition> {
      */
     public void prepare() {
         if (prepared.compareAndSet(false, true)) {
-            // at first init the parent
-            RouteDefinitionHelper.initParent(this);
-
-            // abstracts is the cross cutting concerns
-            List<ProcessorDefinition> abstracts = new ArrayList<ProcessorDefinition>();
-
-            // upper is the cross cutting concerns such as interceptors, error handlers etc
-            List<ProcessorDefinition> upper = new ArrayList<ProcessorDefinition>();
-
-            // lower is the regular route
-            List<ProcessorDefinition> lower = new ArrayList<ProcessorDefinition>();
-
-            RouteDefinitionHelper.prepareRouteForInit(this, abstracts, lower);
-
-            // rebuild route as upper + lower
-            this.clearOutput();
-            this.getOutputs().addAll(lower);
-            this.getOutputs().addAll(0, upper);
+            RouteDefinitionHelper.prepareRoute(this);
         }
     }
 
     /**
-     * Marks the route definition as already prepared, for example using custom logic
-     * such as a {@link RouteBuilder} or from <tt>camel-core-xml</tt> component.
+     * Marks the route definition as prepared.
+     * <p/>
+     * This is needed if routes have been created by components such as
+     * <tt>camel-spring</tt> or <tt>camel-blueprint</tt>.
+     * Usually they share logic in the <tt>camel-core-xml</tt> module which prepares the routes.
      */
-    public void customPrepared() {
+    public void markPrepared() {
         prepared.set(true);
     }
 
diff --git a/camel-core/src/main/java/org/apache/camel/model/RouteDefinitionHelper.java b/camel-core/src/main/java/org/apache/camel/model/RouteDefinitionHelper.java
index 4e84d588136..6e07b583be7 100644
--- a/camel-core/src/main/java/org/apache/camel/model/RouteDefinitionHelper.java
+++ b/camel-core/src/main/java/org/apache/camel/model/RouteDefinitionHelper.java
@@ -16,8 +16,11 @@
  */
 package org.apache.camel.model;
 
+import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.camel.util.EndpointHelper;
+
 /**
  * Helper for {@link RouteDefinition}
  * <p/>
@@ -54,7 +57,7 @@ public final class RouteDefinitionHelper {
     }
 
     public static void prepareRouteForInit(RouteDefinition route, List<ProcessorDefinition> abstracts,
-                                     List<ProcessorDefinition> lower) {
+                                           List<ProcessorDefinition> lower) {
         // filter the route into abstracts and lower
         for (ProcessorDefinition output : route.getOutputs()) {
             if (output.isAbstract()) {
@@ -65,4 +68,191 @@ public final class RouteDefinitionHelper {
         }
     }
 
+    /**
+     * Prepares the route.
+     * <p/>
+     * This method does <b>not</b> mark the route as prepared afterwards.
+     *
+     * @param route the route
+     */
+    public static void prepareRoute(RouteDefinition route) {
+        prepareRoute(route, null, null, null, null, null);
+    }
+
+    /**
+     * Prepares the route which supports context scoped features such as onException, interceptors and onCompletions
+     * <p/>
+     * This method does <b>not</b> mark the route as prepared afterwards.
+     *
+     * @param route                              the route
+     * @param onExceptions                       optional list of onExceptions
+     * @param intercepts                         optional list of interceptors
+     * @param interceptFromDefinitions           optional list of interceptFroms
+     * @param interceptSendToEndpointDefinitions optional list of interceptSendToEndpoints
+     * @param onCompletions                      optional list onCompletions
+     */
+    public static void prepareRoute(RouteDefinition route,
+                                    List<OnExceptionDefinition> onExceptions,
+                                    List<InterceptDefinition> intercepts,
+                                    List<InterceptFromDefinition> interceptFromDefinitions,
+                                    List<InterceptSendToEndpointDefinition> interceptSendToEndpointDefinitions,
+                                    List<OnCompletionDefinition> onCompletions) {
+
+        // at first init the parent
+        RouteDefinitionHelper.initParent(route);
+
+        // abstracts is the cross cutting concerns
+        List<ProcessorDefinition> abstracts = new ArrayList<ProcessorDefinition>();
+
+        // upper is the cross cutting concerns such as interceptors, error handlers etc
+        List<ProcessorDefinition> upper = new ArrayList<ProcessorDefinition>();
+
+        // lower is the regular route
+        List<ProcessorDefinition> lower = new ArrayList<ProcessorDefinition>();
+
+        RouteDefinitionHelper.prepareRouteForInit(route, abstracts, lower);
+
+        // interceptors should be first for the cross cutting concerns
+        initInterceptors(route, upper, intercepts, interceptFromDefinitions, interceptSendToEndpointDefinitions);
+        // then on completion
+        initOnCompletions(abstracts, upper, onCompletions);
+        // then transactions
+        initTransacted(abstracts, lower);
+        // then on exception
+        initOnExceptions(abstracts, upper, onExceptions);
+
+        // rebuild route as upper + lower
+        route.clearOutput();
+        route.getOutputs().addAll(lower);
+        route.getOutputs().addAll(0, upper);
+    }
+
+    private static void initOnExceptions(List<ProcessorDefinition> abstracts, List<ProcessorDefinition> upper,
+                                         List<OnExceptionDefinition> onExceptions) {
+        // add global on exceptions if any
+        if (onExceptions != null && !onExceptions.isEmpty()) {
+            // init the parent
+            for (OnExceptionDefinition global : onExceptions) {
+                RouteDefinitionHelper.initParent(global);
+            }
+            abstracts.addAll(onExceptions);
+        }
+
+        // now add onExceptions to the route
+        for (ProcessorDefinition output : abstracts) {
+            if (output instanceof OnExceptionDefinition) {
+                // on exceptions must be added at top, so the route flow is correct as
+                // on exceptions should be the first outputs
+                upper.add(0, output);
+            }
+        }
+    }
+
+    private static void initInterceptors(RouteDefinition route, List<ProcessorDefinition> upper,
+                                         List<InterceptDefinition> intercepts,
+                                         List<InterceptFromDefinition> interceptFromDefinitions,
+                                         List<InterceptSendToEndpointDefinition> interceptSendToEndpointDefinitions) {
+        // configure intercept
+        if (intercepts != null && !intercepts.isEmpty()) {
+            for (InterceptDefinition intercept : intercepts) {
+                intercept.afterPropertiesSet();
+                // init the parent
+                RouteDefinitionHelper.initParent(intercept);
+                // add as first output so intercept is handled before the actual route and that gives
+                // us the needed head start to init and be able to intercept all the remaining processing steps
+                upper.add(0, intercept);
+            }
+        }
+
+        // configure intercept from
+        if (interceptFromDefinitions != null && !interceptFromDefinitions.isEmpty()) {
+            for (InterceptFromDefinition intercept : interceptFromDefinitions) {
+
+                // should we only apply interceptor for a given endpoint uri
+                boolean match = true;
+                if (intercept.getUri() != null) {
+                    match = false;
+                    for (FromDefinition input : route.getInputs()) {
+                        if (EndpointHelper.matchEndpoint(input.getUri(), intercept.getUri())) {
+                            match = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (match) {
+                    intercept.afterPropertiesSet();
+                    // init the parent
+                    RouteDefinitionHelper.initParent(intercept);
+                    // add as first output so intercept is handled before the actual route and that gives
+                    // us the needed head start to init and be able to intercept all the remaining processing steps
+                    upper.add(0, intercept);
+                }
+            }
+        }
+
+        // configure intercept send to endpoint
+        if (interceptSendToEndpointDefinitions != null && !interceptSendToEndpointDefinitions.isEmpty()) {
+            for (InterceptSendToEndpointDefinition intercept : interceptSendToEndpointDefinitions) {
+                intercept.afterPropertiesSet();
+                // init the parent
+                RouteDefinitionHelper.initParent(intercept);
+                // add as first output so intercept is handled before the actual route and that gives
+                // us the needed head start to init and be able to intercept all the remaining processing steps
+                upper.add(0, intercept);
+            }
+        }
+    }
+
+    private static void initOnCompletions(List<ProcessorDefinition> abstracts, List<ProcessorDefinition> upper,
+                                          List<OnCompletionDefinition> onCompletions) {
+        List<OnCompletionDefinition> completions = new ArrayList<OnCompletionDefinition>();
+
+        // find the route scoped onCompletions
+        for (ProcessorDefinition out : abstracts) {
+            if (out instanceof OnCompletionDefinition) {
+                completions.add((OnCompletionDefinition) out);
+            }
+        }
+
+        // only add global onCompletion if there are no route already
+        if (completions.isEmpty() && onCompletions != null) {
+            completions = onCompletions;
+            // init the parent
+            for (OnCompletionDefinition global : completions) {
+                RouteDefinitionHelper.initParent(global);
+            }
+        }
+
+        // are there any completions to init at all?
+        if (completions.isEmpty()) {
+            return;
+        }
+
+        upper.addAll(completions);
+    }
+
+    private static void initTransacted(List<ProcessorDefinition> abstracts, List<ProcessorDefinition> lower) {
+        TransactedDefinition transacted = null;
+
+        // add to correct type
+        for (ProcessorDefinition type : abstracts) {
+            if (type instanceof TransactedDefinition) {
+                if (transacted == null) {
+                    transacted = (TransactedDefinition) type;
+                } else {
+                    throw new IllegalArgumentException("The route can only have one transacted defined");
+                }
+            }
+        }
+
+        if (transacted != null) {
+            // the outputs should be moved to the transacted policy
+            transacted.getOutputs().addAll(lower);
+            // and add it as the single output
+            lower.clear();
+            lower.add(transacted);
+        }
+    }
+
 }
diff --git a/camel-core/src/test/resources/org/apache/camel/model/barOnExceptionRoute.xml b/camel-core/src/test/resources/org/apache/camel/model/barOnExceptionRoute.xml
index 90570f2c363..0beca419cf9 100644
--- a/camel-core/src/test/resources/org/apache/camel/model/barOnExceptionRoute.xml
+++ b/camel-core/src/test/resources/org/apache/camel/model/barOnExceptionRoute.xml
@@ -24,9 +24,11 @@
             <handled>
                 <constant>true</constant>
             </handled>
+            <to uri="log:error"/>
             <to uri="mock:error"/>
         </onException>
         <process ref="myProcessor"/>
+        <to uri="log:bar"/>
         <to uri="mock:bar"/>
     </route>
 
diff --git a/components/camel-core-xml/src/main/java/org/apache/camel/core/xml/AbstractCamelContextFactoryBean.java b/components/camel-core-xml/src/main/java/org/apache/camel/core/xml/AbstractCamelContextFactoryBean.java
index a7919e41854..99cb31d8aa3 100644
--- a/components/camel-core-xml/src/main/java/org/apache/camel/core/xml/AbstractCamelContextFactoryBean.java
+++ b/components/camel-core-xml/src/main/java/org/apache/camel/core/xml/AbstractCamelContextFactoryBean.java
@@ -298,160 +298,17 @@ public abstract class AbstractCamelContextFactoryBean<T extends CamelContext> ex
      */
     private void prepareRoutes() {
         for (RouteDefinition route : getRoutes()) {
+            // leverage logic from route definition helper to prepare the route
+            RouteDefinitionHelper.prepareRoute(route, getOnExceptions(), getIntercepts(), getInterceptFroms(),
+                    getInterceptSendToEndpoints(), getOnCompletions());
 
-            // at first init the parent
-            RouteDefinitionHelper.initParent(route);
-
-            // abstracts is the cross cutting concerns
-            List<ProcessorDefinition> abstracts = new ArrayList<ProcessorDefinition>();
-
-            // upper is the cross cutting concerns such as interceptors, error handlers etc
-            List<ProcessorDefinition> upper = new ArrayList<ProcessorDefinition>();
-
-            // lower is the regular route
-            List<ProcessorDefinition> lower = new ArrayList<ProcessorDefinition>();
-
-            RouteDefinitionHelper.prepareRouteForInit(route, abstracts, lower);
-
-            // interceptors should be first for the cross cutting concerns
-            initInterceptors(route, upper);
-            // then on completion
-            initOnCompletions(abstracts, upper);
-            // then transactions
-            initTransacted(abstracts, lower);
-            // then on exception
-            initOnExceptions(abstracts, upper);
-
-            // rebuild route as upper + lower
-            route.clearOutput();
-            route.getOutputs().addAll(lower);
-            route.getOutputs().addAll(0, upper);
-
-            // mark as custom prepared
-            route.customPrepared();
+            // mark the route as prepared now
+            route.markPrepared();
         }
     }
 
     protected abstract void initCustomRegistry(T context);
 
-    private void initOnExceptions(List<ProcessorDefinition> abstracts, List<ProcessorDefinition> upper) {
-        // add global on exceptions if any
-        List<OnExceptionDefinition> onExceptions = getOnExceptions();
-        if (onExceptions != null && !onExceptions.isEmpty()) {
-            // init the parent
-            for (OnExceptionDefinition global : onExceptions) {
-                RouteDefinitionHelper.initParent(global);
-            }
-            abstracts.addAll(onExceptions);
-        }
-
-        // now add onExceptions to the route
-        for (ProcessorDefinition output : abstracts) {
-            if (output instanceof OnExceptionDefinition) {
-                // on exceptions must be added at top, so the route flow is correct as
-                // on exceptions should be the first outputs
-                upper.add(0, output);
-            }
-        }
-    }
-
-    private void initInterceptors(RouteDefinition route, List<ProcessorDefinition> upper) {
-        // configure intercept
-        for (InterceptDefinition intercept : getIntercepts()) {
-            intercept.afterPropertiesSet();
-            // init the parent
-            RouteDefinitionHelper.initParent(intercept);
-            // add as first output so intercept is handled before the actual route and that gives
-            // us the needed head start to init and be able to intercept all the remaining processing steps
-            upper.add(0, intercept);
-        }
-
-        // configure intercept from
-        for (InterceptFromDefinition intercept : getInterceptFroms()) {
-
-            // should we only apply interceptor for a given endpoint uri
-            boolean match = true;
-            if (intercept.getUri() != null) {
-                match = false;
-                for (FromDefinition input : route.getInputs()) {
-                    if (EndpointHelper.matchEndpoint(input.getUri(), intercept.getUri())) {
-                        match = true;
-                        break;
-                    }
-                }
-            }
-
-            if (match) {
-                intercept.afterPropertiesSet();
-                // init the parent
-                RouteDefinitionHelper.initParent(intercept);
-                // add as first output so intercept is handled before the actual route and that gives
-                // us the needed head start to init and be able to intercept all the remaining processing steps
-                upper.add(0, intercept);
-            }
-        }
-
-        // configure intercept send to endpoint
-        for (InterceptSendToEndpointDefinition intercept : getInterceptSendToEndpoints()) {
-            intercept.afterPropertiesSet();
-            // init the parent
-            RouteDefinitionHelper.initParent(intercept);
-            // add as first output so intercept is handled before the actual route and that gives
-            // us the needed head start to init and be able to intercept all the remaining processing steps
-            upper.add(0, intercept);
-        }
-    }
-
-    private void initOnCompletions(List<ProcessorDefinition> abstracts, List<ProcessorDefinition> upper) {
-        List<OnCompletionDefinition> completions = new ArrayList<OnCompletionDefinition>();
-
-        // find the route scoped onCompletions
-        for (ProcessorDefinition out : abstracts) {
-            if (out instanceof OnCompletionDefinition) {
-                completions.add((OnCompletionDefinition) out);
-            }
-        }
-
-        // only add global onCompletion if there are no route already
-        if (completions.isEmpty()) {
-            completions = getOnCompletions();
-            // init the parent
-            for (OnCompletionDefinition global : completions) {
-                RouteDefinitionHelper.initParent(global);
-            }
-        }
-
-        // are there any completions to init at all?
-        if (completions.isEmpty()) {
-            return;
-        }
-
-        upper.addAll(completions);
-    }
-
-    private void initTransacted(List<ProcessorDefinition> abstracts, List<ProcessorDefinition> lower) {
-        TransactedDefinition transacted = null;
-
-        // add to correct type
-        for (ProcessorDefinition type : abstracts) {
-            if (type instanceof TransactedDefinition) {
-                if (transacted == null) {
-                    transacted = (TransactedDefinition) type;
-                } else {
-                    throw new IllegalArgumentException("The route can only have one transacted defined");
-                }
-            }
-        }
-
-        if (transacted != null) {
-            // the outputs should be moved to the transacted policy
-            transacted.getOutputs().addAll(lower);
-            // and add it as the single output
-            lower.clear();
-            lower.add(transacted);
-        }
-    }
-
     private void initJMXAgent() throws Exception {
         CamelJMXAgentDefinition camelJMXAgent = getCamelJMXAgent();
         if (camelJMXAgent != null && camelJMXAgent.isAgentDisabled()) {
