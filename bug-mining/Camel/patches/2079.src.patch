diff --git a/components/camel-xmlrpc/src/main/java/org/apache/camel/dataformat/xmlrpc/XmlRpcDataFormat.java b/components/camel-xmlrpc/src/main/java/org/apache/camel/dataformat/xmlrpc/XmlRpcDataFormat.java
new file mode 100644
index 00000000000..471ea38e66d
--- /dev/null
+++ b/components/camel-xmlrpc/src/main/java/org/apache/camel/dataformat/xmlrpc/XmlRpcDataFormat.java
@@ -0,0 +1,155 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.xmlrpc;
+
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.component.xmlrpc.XmlRpcConstants;
+import org.apache.camel.component.xmlrpc.XmlRpcRequestImpl;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.util.IOHelper;
+import org.apache.ws.commons.serialize.CharSetXMLWriter;
+import org.apache.ws.commons.serialize.XMLWriter;
+import org.apache.xmlrpc.XmlRpcException;
+import org.apache.xmlrpc.XmlRpcRequest;
+import org.apache.xmlrpc.client.XmlRpcClientException;
+import org.apache.xmlrpc.common.TypeFactory;
+import org.apache.xmlrpc.common.TypeFactoryImpl;
+import org.apache.xmlrpc.common.XmlRpcHttpRequestConfigImpl;
+import org.apache.xmlrpc.common.XmlRpcStreamRequestConfig;
+import org.apache.xmlrpc.parser.XmlRpcRequestParser;
+import org.apache.xmlrpc.parser.XmlRpcResponseParser;
+import org.apache.xmlrpc.util.SAXParsers;
+
+public class XmlRpcDataFormat implements DataFormat {
+    private XmlRpcStreamRequestConfig config = new XmlRpcHttpRequestConfigImpl();
+    private TypeFactory typeFactory = new TypeFactoryImpl(null);
+    private boolean isRequest;
+    
+
+    protected XMLWriter getXMLWriter(Exchange exchange, OutputStream outputStream) throws XmlRpcException {
+        XMLWriter writer = new CharSetXMLWriter();
+        String encoding = IOHelper.getCharsetName(exchange);
+        writer.setEncoding(encoding);
+        writer.setIndenting(false);
+        writer.setFlushing(true);
+        try {
+            writer.setWriter(new BufferedWriter(new OutputStreamWriter(outputStream, encoding)));
+        } catch (UnsupportedEncodingException e) {
+            throw new XmlRpcException("Unsupported encoding: " + encoding, e);
+        }
+        return writer;
+    }
+
+    @Override
+    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {
+        // need to check the object type
+        XMLWriter control = getXMLWriter(exchange, stream);
+        XmlRpcWriter writer = new XmlRpcWriter(config, control, typeFactory);
+        if (graph instanceof XmlRpcRequest) {
+            writer.writeRequest(config, (XmlRpcRequest)graph);
+        } else {
+            // write the result here directly
+            // TODO write the fault message here
+            writer.write(config, graph);
+        }
+        
+    }
+
+    protected int getErrorCode(Exchange exchange) {
+        return exchange.getIn().getHeader(XmlRpcConstants.ERROR_CODE, int.class);
+    }
+
+    @Override
+    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
+        if (isRequest) {
+            return unmarshalRequest(exchange, stream);
+        } else {
+            return unmarshalResponse(exchange, stream);
+        }
+    }
+    
+    protected Object unmarshalResponse(Exchange exchange, InputStream stream) throws Exception {
+        InputSource isource = new InputSource(stream);
+        XMLReader xr = newXMLReader();
+        XmlRpcResponseParser xp;
+        try {
+            xp = new XmlRpcResponseParser(config, typeFactory);
+            xr.setContentHandler(xp);
+            xr.parse(isource);
+        } catch (SAXException e) {
+            throw new XmlRpcClientException("Failed to parse server's response: " + e.getMessage(), e);
+        } catch (IOException e) {
+            throw new XmlRpcClientException("Failed to read server's response: " + e.getMessage(), e);
+        }
+        if (xp.isSuccess()) {
+            return xp.getResult();
+        }
+        Throwable t = xp.getErrorCause();
+        if (t == null) {
+            throw new XmlRpcException(xp.getErrorCode(), xp.getErrorMessage());
+        }
+        if (t instanceof XmlRpcException) {
+            throw (XmlRpcException)t;
+        }
+        if (t instanceof RuntimeException) {
+            throw (RuntimeException)t;
+        }
+        throw new XmlRpcException(xp.getErrorCode(), xp.getErrorMessage(), t);
+
+    }
+    
+    protected Object unmarshalRequest(Exchange exchange, InputStream stream) throws Exception {
+        InputSource isource = new InputSource(stream);
+        XMLReader xr = newXMLReader();
+        XmlRpcRequestParser xp;
+        try {
+            xp = new XmlRpcRequestParser(config, typeFactory);
+            xr.setContentHandler(xp);
+            xr.parse(isource);
+        } catch (SAXException e) {
+            throw new XmlRpcClientException("Failed to parse server's response: " + e.getMessage(), e);
+        } catch (IOException e) {
+            throw new XmlRpcClientException("Failed to read server's response: " + e.getMessage(), e);
+        }
+        return new XmlRpcRequestImpl(xp.getMethodName(), xp.getParams());
+
+    }
+    
+    protected XMLReader newXMLReader() throws XmlRpcException {
+        return SAXParsers.newXMLReader();
+    }
+
+    public boolean isRequest() {
+        return isRequest;
+    }
+
+    public void setRequest(boolean isRequest) {
+        this.isRequest = isRequest;
+    }
+
+}
diff --git a/components/camel-xmlrpc/src/main/java/org/apache/camel/dataformat/xmlrpc/XmlRpcWriter.java b/components/camel-xmlrpc/src/main/java/org/apache/camel/dataformat/xmlrpc/XmlRpcWriter.java
new file mode 100644
index 00000000000..db3b10a0b26
--- /dev/null
+++ b/components/camel-xmlrpc/src/main/java/org/apache/camel/dataformat/xmlrpc/XmlRpcWriter.java
@@ -0,0 +1,64 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.xmlrpc;
+
+import org.xml.sax.Attributes;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.SAXException;
+import org.xml.sax.helpers.AttributesImpl;
+
+import org.apache.xmlrpc.XmlRpcRequest;
+import org.apache.xmlrpc.common.TypeFactory;
+import org.apache.xmlrpc.common.XmlRpcStreamConfig;
+
+
+public class XmlRpcWriter extends org.apache.xmlrpc.serializer.XmlRpcWriter {
+    private static final Attributes ZERO_ATTRIBUTES = new AttributesImpl();
+    private final ContentHandler handler;
+
+    public XmlRpcWriter(XmlRpcStreamConfig pConfig, ContentHandler pHandler, TypeFactory pTypeFactory) {
+        super(pConfig, pHandler, pTypeFactory);
+        handler = pHandler;
+    }
+    
+    public void writeRequest(XmlRpcStreamConfig config, XmlRpcRequest request) throws SAXException {
+        handler.startDocument();
+        boolean extensions = config.isEnabledForExtensions();
+        if (extensions) {
+            handler.startPrefixMapping("ex", XmlRpcWriter.EXTENSIONS_URI);
+        }
+        handler.startElement("", "methodCall", "methodCall", ZERO_ATTRIBUTES);
+        handler.startElement("", "methodName", "methodName", ZERO_ATTRIBUTES);
+        String s = request.getMethodName();
+        handler.characters(s.toCharArray(), 0, s.length());
+        handler.endElement("", "methodName", "methodName");
+        handler.startElement("", "params", "params", ZERO_ATTRIBUTES);
+        int num = request.getParameterCount();
+        for (int i = 0; i < num; i++) {
+            handler.startElement("", "param", "param", ZERO_ATTRIBUTES);
+            writeValue(request.getParameter(i));
+            handler.endElement("", "param", "param");
+        }
+        handler.endElement("", "params", "params");
+        handler.endElement("", "methodCall", "methodCall");
+        if (extensions) {
+            handler.endPrefixMapping("ex");
+        }
+        handler.endDocument();
+    }
+
+}
diff --git a/components/camel-xmlrpc/src/main/resources/META-INF/services/org/apache/camel/dataformat/xmlrpc b/components/camel-xmlrpc/src/main/resources/META-INF/services/org/apache/camel/dataformat/xmlrpc
new file mode 100644
index 00000000000..48dbe02ed30
--- /dev/null
+++ b/components/camel-xmlrpc/src/main/resources/META-INF/services/org/apache/camel/dataformat/xmlrpc
@@ -0,0 +1,18 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+class=org.apache.camel.dataformat.xmlrpc.XmlRpcDataFormat
diff --git a/components/camel-xmlrpc/src/test/java/org/apache/camel/dataformat/xmlrpc/XmlRpcDataFormatTest.java b/components/camel-xmlrpc/src/test/java/org/apache/camel/dataformat/xmlrpc/XmlRpcDataFormatTest.java
new file mode 100644
index 00000000000..d2345d76577
--- /dev/null
+++ b/components/camel-xmlrpc/src/test/java/org/apache/camel/dataformat/xmlrpc/XmlRpcDataFormatTest.java
@@ -0,0 +1,77 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.xmlrpc;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.xmlrpc.XmlRpcRequestImpl;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.apache.xmlrpc.XmlRpcRequest;
+import org.junit.Test;
+
+public class XmlRpcDataFormatTest extends CamelTestSupport {
+    
+    @Test
+    public void testRequestMessage() throws Exception {
+        MockEndpoint mock = getMockEndpoint("mock:request");
+        mock.expectedMessageCount(1);
+        XmlRpcRequest result = template.requestBody("direct:request", new XmlRpcRequestImpl("greet", new Object[]{"you", 2}), XmlRpcRequest.class);
+        assertNotNull(result);
+        assertEquals("Get a wrong request operation name", "greet", result.getMethodName());
+        assertEquals("Get a wrong request parameter size", 2, result.getParameterCount());
+        assertEquals("Get a wrong request parameter", 2, result.getParameter(1));
+        assertMockEndpointsSatisfied();
+        
+    }
+    
+    @Test
+    public void testResponseMessage() throws Exception {
+        MockEndpoint mock = getMockEndpoint("mock:response");
+        mock.expectedBodiesReceived("GreetMe from XmlRPC");
+        template.sendBody("direct:response", "GreetMe from XmlRPC");
+        assertMockEndpointsSatisfied();
+    }
+    
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+
+            public void configure() {
+                XmlRpcDataFormat request = new XmlRpcDataFormat();
+                request.setRequest(true);
+                
+                XmlRpcDataFormat response = new XmlRpcDataFormat();
+                response.setRequest(false);
+                from("direct:request")
+                    .marshal(request)
+                    .to("log:marshalRequestMessage")
+                    .unmarshal(request)
+                    .to("log:unmarshaRequestMessage")
+                    .to("mock:request");
+                
+                from("direct:response")
+                    .marshal(response)
+                    .to("log:marshalResponseMessage")
+                    .unmarshal(response)
+                    .to("log:unmarshalResonseMessage")
+                    .to("mock:response");
+                    
+                
+            }
+        };
+    }
+
+}
