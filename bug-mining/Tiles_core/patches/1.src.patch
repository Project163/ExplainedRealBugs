diff --git a/tiles-core/src/main/java/org/apache/tiles/definition/dao/CachingLocaleUrlDefinitionDAO.java b/tiles-core/src/main/java/org/apache/tiles/definition/dao/CachingLocaleUrlDefinitionDAO.java
index 542d8d74..cee95a3b 100644
--- a/tiles-core/src/main/java/org/apache/tiles/definition/dao/CachingLocaleUrlDefinitionDAO.java
+++ b/tiles-core/src/main/java/org/apache/tiles/definition/dao/CachingLocaleUrlDefinitionDAO.java
@@ -166,10 +166,10 @@ public class CachingLocaleUrlDefinitionDAO extends BaseLocaleUrlDefinitionDAO
      * @return The loaded definitions.
      * @since 2.1.0
      */
-    protected synchronized Map<String, Definition> checkAndloadDefinitions(
-            Locale customizationKey) {
+    protected synchronized Map<String, Definition> checkAndloadDefinitions(Locale customizationKey) {
         if (checkRefresh && refreshRequired()) {
             locale2definitionMap.clear();
+            definitionResolver.clearPatternPaths(customizationKey);
         }
         loadDefinitions(customizationKey);
         return locale2definitionMap.get(customizationKey);
diff --git a/tiles-core/src/main/java/org/apache/tiles/definition/pattern/AbstractPatternDefinitionResolver.java b/tiles-core/src/main/java/org/apache/tiles/definition/pattern/AbstractPatternDefinitionResolver.java
index 65ff73d0..50bc8f74 100644
--- a/tiles-core/src/main/java/org/apache/tiles/definition/pattern/AbstractPatternDefinitionResolver.java
+++ b/tiles-core/src/main/java/org/apache/tiles/definition/pattern/AbstractPatternDefinitionResolver.java
@@ -106,4 +106,17 @@ public abstract class AbstractPatternDefinitionResolver<T> implements
 
         return d;
     }
+    
+    
+    /**
+     * Used to clear all entries in the localePatternPaths for a specific locale. Necessary when reloading definition
+     * files to ensure that the list is cleared first
+     * 
+     * @param customizationKey
+     */
+    @Override
+    public void clearPatternPaths(T customizationKey) {
+        if (localePatternPaths.get(customizationKey) != null)
+            localePatternPaths.get(customizationKey).clear();
+    }
 }
diff --git a/tiles-core/src/main/java/org/apache/tiles/definition/pattern/PatternDefinitionResolver.java b/tiles-core/src/main/java/org/apache/tiles/definition/pattern/PatternDefinitionResolver.java
index 539f8dde..2cf3d4b9 100644
--- a/tiles-core/src/main/java/org/apache/tiles/definition/pattern/PatternDefinitionResolver.java
+++ b/tiles-core/src/main/java/org/apache/tiles/definition/pattern/PatternDefinitionResolver.java
@@ -57,4 +57,12 @@ public interface PatternDefinitionResolver<T> {
      * @since 2.2.0
      */
     Definition resolveDefinition(String name, T customizationKey);
+
+    /**
+     * Used to clear all entries in the localePatternPaths for a specific locale. Necessary when reloading definition
+     * files to ensure that the list is cleared first
+     * 
+     * @param customizationKey
+     */
+    public void clearPatternPaths(T customizationKey);
 }
diff --git a/tiles-core/src/test/java/org/apache/tiles/definition/pattern/AbstractPatternDefinitionResolverTest.java b/tiles-core/src/test/java/org/apache/tiles/definition/pattern/AbstractPatternDefinitionResolverTest.java
index 10a39a80..a564e375 100644
--- a/tiles-core/src/test/java/org/apache/tiles/definition/pattern/AbstractPatternDefinitionResolverTest.java
+++ b/tiles-core/src/test/java/org/apache/tiles/definition/pattern/AbstractPatternDefinitionResolverTest.java
@@ -40,60 +40,70 @@ import org.junit.Test;
  */
 public class AbstractPatternDefinitionResolverTest {
 
+    private DefinitionPatternMatcher firstMatcher;
+    private DefinitionPatternMatcher thirdMatcher;
+
+    private final PatternDefinitionResolver<Integer> resolver = new AbstractPatternDefinitionResolver<Integer>() {
+        @Override
+        protected Map<String, Definition> addDefinitionsAsPatternMatchers(
+                List<DefinitionPatternMatcher> matchers,
+                Map<String, Definition> defsMap) {
+
+            if (defsMap.containsKey("first")) {
+                matchers.add(firstMatcher);
+            }
+            if (defsMap.containsKey("third")) {
+                matchers.add(thirdMatcher);
+            }
+            Map<String, Definition> retValue = new HashMap<String, Definition>(defsMap);
+            retValue.remove("first");
+            retValue.remove("third");
+            return retValue;
+        }
+    };
+
     /**
      * Test method for
      * {@link BasicPatternDefinitionResolver#resolveDefinition(String, Object)}.
      */
     @Test
     public void testResolveDefinition() {
-        final DefinitionPatternMatcher firstMatcher = createMock(DefinitionPatternMatcher.class);
-        final DefinitionPatternMatcher thirdMatcher = createMock(DefinitionPatternMatcher.class);
-
-        Definition firstDefinition = new Definition("first", (Attribute) null,
-                null);
-        Definition secondDefinition = new Definition("second",
-                (Attribute) null, null);
-        Definition thirdDefinition = new Definition("third", (Attribute) null,
-                null);
-
-        Definition firstTransformedDefinition = new Definition(
-                "firstTransformed", (Attribute) null, null);
-        Definition thirdTransformedDefinition = new Definition(
-                "thirdTransformed", (Attribute) null, null);
-
-        expect(firstMatcher.createDefinition("firstTransformed")).andReturn(
-                firstTransformedDefinition);
-        expect(firstMatcher.createDefinition("secondTransformed")).andReturn(
-                null);
-        expect(firstMatcher.createDefinition("thirdTransformed")).andReturn(
-                null);
-        expect(thirdMatcher.createDefinition("thirdTransformed")).andReturn(
-                thirdTransformedDefinition).times(2);
-        expect(thirdMatcher.createDefinition("firstTransformed")).andReturn(
-                null);
-        expect(thirdMatcher.createDefinition("secondTransformed")).andReturn(
-                null).times(2);
+        testResolveDefinitionImpl();
+    }
+
+    /**
+     * Test method for
+     * {@link BasicPatternDefinitionResolver#clearPatternPaths(Object)}.
+     */
+    @Test
+    public void testClearPatternPaths() {
+        testResolveDefinitionImpl();
+        resolver.clearPatternPaths(1);
+        resolver.clearPatternPaths(2);
+        testResolveDefinitionImpl();
+    }
+
+    private void testResolveDefinitionImpl() {
+
+        firstMatcher = createMock(DefinitionPatternMatcher.class);
+        thirdMatcher = createMock(DefinitionPatternMatcher.class);
+
+        Definition firstDefinition = new Definition("first", (Attribute) null, null);
+        Definition secondDefinition = new Definition("second", (Attribute) null, null);
+        Definition thirdDefinition = new Definition("third", (Attribute) null, null);
+
+        Definition firstTransformedDefinition = new Definition("firstTransformed", (Attribute) null, null);
+        Definition thirdTransformedDefinition = new Definition("thirdTransformed", (Attribute) null, null);
+
+        expect(firstMatcher.createDefinition("firstTransformed")).andReturn(firstTransformedDefinition);
+        expect(firstMatcher.createDefinition("secondTransformed")).andReturn(null);
+        expect(firstMatcher.createDefinition("thirdTransformed")).andReturn(null);
+        expect(thirdMatcher.createDefinition("thirdTransformed")).andReturn(thirdTransformedDefinition).times(2);
+        expect(thirdMatcher.createDefinition("firstTransformed")).andReturn(null);
+        expect(thirdMatcher.createDefinition("secondTransformed")).andReturn(null).times(2);
 
         replay(firstMatcher, thirdMatcher);
-        PatternDefinitionResolver<Integer> resolver = new AbstractPatternDefinitionResolver<Integer>() {
-
-            @Override
-            protected Map<String, Definition> addDefinitionsAsPatternMatchers(
-                    List<DefinitionPatternMatcher> matchers,
-                    Map<String, Definition> defsMap) {
-                if (defsMap.containsKey("first")) {
-                    matchers.add(firstMatcher);
-                }
-                if (defsMap.containsKey("third")) {
-                    matchers.add(thirdMatcher);
-                }
-                Map<String, Definition> retValue = new HashMap<String, Definition>(defsMap);
-                retValue.remove("first");
-                retValue.remove("third");
-                return retValue;
-            }
 
-        };
         Map<String, Definition> localeDefsMap = new LinkedHashMap<String, Definition>();
         localeDefsMap.put("first", firstDefinition);
         localeDefsMap.put("second", secondDefinition);
