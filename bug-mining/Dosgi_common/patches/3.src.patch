diff --git a/common/bnd.bnd b/common/bnd.bnd
index b5ec91c6..5bee711d 100644
--- a/common/bnd.bnd
+++ b/common/bnd.bnd
@@ -2,5 +2,6 @@ Import-Package: javax.servlet;version='[2,4)', javax.servlet.http;version='[2,4)
 Export-Package: \
 	org.apache.cxf.dosgi.common.httpservice,\
 	org.apache.cxf.dosgi.common.util,\
-	org.apache.cxf.dosgi.common.intent
+	org.apache.cxf.dosgi.common.intent,\
+	org.apache.cxf.dosgi.common.proxy
 
diff --git a/common/pom.xml b/common/pom.xml
index dd5ea464..952f2c1f 100644
--- a/common/pom.xml
+++ b/common/pom.xml
@@ -44,30 +44,14 @@
         </dependency>
         <dependency>
             <groupId>org.apache.cxf</groupId>
-            <artifactId>cxf-rt-frontend-jaxws</artifactId>
-            <version>${cxf.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>org.apache.cxf</groupId>
-            <artifactId>cxf-rt-frontend-jaxrs</artifactId>
-            <version>${cxf.version}</version>
-        </dependency>
-		<dependency>
-            <groupId>org.apache.cxf</groupId>
-            <artifactId>cxf-rt-rs-client</artifactId>
+            <artifactId>cxf-rt-transports-http</artifactId>
             <version>${cxf.version}</version>
         </dependency>
         <dependency>
             <groupId>org.apache.cxf</groupId>
-            <artifactId>cxf-rt-databinding-aegis</artifactId>
-            <version>${cxf.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>org.apache.cxf</groupId>
-            <artifactId>cxf-rt-rs-extension-providers</artifactId>
+            <artifactId>cxf-rt-frontend-jaxws</artifactId>
             <version>${cxf.version}</version>
         </dependency>
-
         <dependency>
             <groupId>org.apache.geronimo.specs</groupId>
             <artifactId>geronimo-servlet_${servlet.version}_spec</artifactId>
diff --git a/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ProxyFactory.java b/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ProxyFactory.java
new file mode 100644
index 00000000..ec10f6ee
--- /dev/null
+++ b/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ProxyFactory.java
@@ -0,0 +1,32 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.dosgi.common.proxy;
+
+import java.lang.reflect.Proxy;
+
+public final class ProxyFactory {
+    private ProxyFactory() {
+    }
+    
+    public static Object create(Object serviceProxy, Class<?> iType) {
+        return Proxy.newProxyInstance(iType.getClassLoader(), new Class[] {
+            iType
+        }, new ServiceInvocationHandler(serviceProxy, iType));
+    }
+}
diff --git a/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandler.java b/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandler.java
new file mode 100644
index 00000000..c86b7001
--- /dev/null
+++ b/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandler.java
@@ -0,0 +1,102 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.dosgi.common.proxy;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.security.AccessController;
+import java.security.PrivilegedExceptionAction;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.osgi.framework.ServiceException;
+
+public class ServiceInvocationHandler implements InvocationHandler {
+
+    private static final String REMOTE_EXCEPTION_TYPE = "REMOTE";
+    private static final Collection<Method> OBJECT_METHODS = Arrays.asList(Object.class.getMethods());
+
+    private Map<Method, List<Class<?>>> exceptionsMap = new HashMap<Method, List<Class<?>>>();
+    private Object serviceObject;
+
+    ServiceInvocationHandler(Object serviceObject, Class<?> iType) {
+        this.serviceObject = serviceObject;
+        introspectType(iType);
+    }
+    
+
+
+    public Object invoke(Object proxy, final Method m, Object[] params) throws Throwable {
+        if (OBJECT_METHODS.contains(m)) {
+            if (m.getName().equals("equals")) {
+                params = new Object[] {Proxy.getInvocationHandler(params[0])};
+            }
+            return m.invoke(this, params);
+        }
+
+        ClassLoader oldCl = Thread.currentThread().getContextClassLoader();
+        try {
+            Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
+            final Object[] paramsFinal = params;
+            return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
+                public Object run() throws Exception {
+                    return m.invoke(serviceObject, paramsFinal);
+                }
+            });
+        } catch (Throwable ex) {
+            Throwable theCause = ex.getCause() == null ? ex : ex.getCause();
+            Throwable theCauseCause = theCause.getCause() == null ? theCause : theCause.getCause();
+            List<Class<?>> excTypes = exceptionsMap.get(m);
+            if (excTypes != null) {
+                for (Class<?> type : excTypes) {
+                    if (type.isAssignableFrom(theCause.getClass())) {
+                        throw theCause;
+                    }
+                    if (type.isAssignableFrom(theCauseCause.getClass())) {
+                        throw theCauseCause;
+                    }
+                }
+            }
+
+            throw new ServiceException(REMOTE_EXCEPTION_TYPE, theCause);
+        } finally {
+            Thread.currentThread().setContextClassLoader(oldCl);
+        }
+    }
+
+    private void introspectType(Class<?> iType) {
+        for (Method m : iType.getDeclaredMethods()) {
+            for (Class<?> excType : m.getExceptionTypes()) {
+                if (Exception.class.isAssignableFrom(excType)) {
+                    List<Class<?>> types = exceptionsMap.get(m);
+                    if (types == null) {
+                        types = new ArrayList<Class<?>>();
+                        exceptionsMap.put(m, types);
+                    }
+                    types.add(excType);
+                }
+            }
+        }
+    }
+}
diff --git a/common/src/test/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandlerTest.java b/common/src/test/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandlerTest.java
new file mode 100644
index 00000000..92cdc75c
--- /dev/null
+++ b/common/src/test/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandlerTest.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.dosgi.common.proxy;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import junit.framework.TestCase;
+
+public class ServiceInvocationHandlerTest extends TestCase {
+
+    private static final Map<String, Method> OBJECT_METHODS = new HashMap<String, Method>(); {
+        for (Method m : Object.class.getMethods()) {
+            OBJECT_METHODS.put(m.getName(), m);
+        }
+    }
+
+    public void testInvoke() throws Throwable {
+        ServiceInvocationHandler sih = new ServiceInvocationHandler("hello", String.class);
+        Method m = String.class.getMethod("length", new Class[] {});
+        assertEquals(5, sih.invoke(null, m, new Object[] {}));
+    }
+
+    public void testInvokeObjectMethod() throws Throwable {
+        final List<String> called = new ArrayList<String>();
+        ServiceInvocationHandler sih = new ServiceInvocationHandler("hi", String.class) {
+            public boolean equals(Object obj) {
+                called.add("equals");
+                return super.equals(obj);
+            }
+
+            public int hashCode() {
+                called.add("hashCode");
+                return super.hashCode();
+            }
+
+            public String toString() {
+                called.add("toString");
+                return "somestring";
+            }
+        };
+
+        Object proxy = Proxy.newProxyInstance(
+                getClass().getClassLoader(), new Class[] {Runnable.class}, sih);
+
+        assertEquals(true,
+                sih.invoke(null, OBJECT_METHODS.get("equals"), new Object[] {proxy}));
+        assertEquals(System.identityHashCode(sih),
+                sih.invoke(null, OBJECT_METHODS.get("hashCode"), new Object[] {}));
+        assertEquals("somestring",
+                sih.invoke(null, OBJECT_METHODS.get("toString"), new Object[] {}));
+        assertEquals(Arrays.asList("equals", "hashCode", "toString"), called);
+    }
+}
