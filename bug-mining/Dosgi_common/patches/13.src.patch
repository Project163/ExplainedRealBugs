diff --git a/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ExceptionMapper.java b/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ExceptionMapper.java
new file mode 100644
index 00000000..77c72b29
--- /dev/null
+++ b/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ExceptionMapper.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.cxf.dosgi.common.proxy;
+
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.osgi.framework.ServiceException;
+
+public class ExceptionMapper {
+    private static final String REMOTE_EXCEPTION_TYPE = "REMOTE";
+    private Map<Method, Set<Class<?>>> exceptionsMap = new HashMap<Method, Set<Class<?>>>();
+    
+    public ExceptionMapper(Class<?> iType) {
+        introspectTypeForExceptions(iType);
+    }
+    
+    public Throwable mapException(Method m, Throwable ex) throws Throwable {
+        Throwable cause = ex.getCause() == null ? ex : ex.getCause();
+        Set<Class<?>> excTypes = exceptionsMap.get(m);
+        if (excTypes != null) {
+            for (Class<?> type : excTypes) {
+                if (type.isAssignableFrom(ex.getClass())) {
+                    return ex;
+                }
+                if (type.isAssignableFrom(cause.getClass())) {
+                    return cause;
+                }
+            }
+        }
+        return new ServiceException(REMOTE_EXCEPTION_TYPE, ex);
+    }
+    
+    private void introspectTypeForExceptions(Class<?> iType) {
+        for (Method m : iType.getDeclaredMethods()) {
+            addExceptions(m);
+        }
+    }
+
+    private void addExceptions(Method m) {
+        for (Class<?> excType : m.getExceptionTypes()) {
+            if (Exception.class.isAssignableFrom(excType)) {
+                getCurrentExTypes(m).add(excType);
+            }
+        }
+    }
+
+    private Set<Class<?>> getCurrentExTypes(Method m) {
+        Set<Class<?>> types = exceptionsMap.get(m);
+        if (types == null) {
+            types = new HashSet<Class<?>>();
+            exceptionsMap.put(m, types);
+        }
+        return types;
+    }
+}
diff --git a/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandler.java b/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandler.java
index 51a1e245..6f9e7e9e 100644
--- a/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandler.java
+++ b/common/src/main/java/org/apache/cxf/dosgi/common/proxy/ServiceInvocationHandler.java
@@ -23,26 +23,18 @@ import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.security.AccessController;
 import java.security.PrivilegedExceptionAction;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.osgi.framework.ServiceException;
 
 public class ServiceInvocationHandler implements InvocationHandler {
-
-    private static final String REMOTE_EXCEPTION_TYPE = "REMOTE";
     private static final Collection<Method> OBJECT_METHODS = Arrays.asList(Object.class.getMethods());
-
-    private Map<Method, List<Class<?>>> exceptionsMap = new HashMap<Method, List<Class<?>>>();
     private Object serviceObject;
+    private ExceptionMapper exceptionMapper;
 
     ServiceInvocationHandler(Object serviceObject, Class<?> iType) {
         this.serviceObject = serviceObject;
-        introspectType(iType);
+        this.exceptionMapper = new ExceptionMapper(iType);
+
     }
 
     public Object invoke(Object proxy, final Method m, Object[] params) throws Throwable {
@@ -64,37 +56,11 @@ public class ServiceInvocationHandler implements InvocationHandler {
             });
         } catch (Throwable ex) {
             Throwable theCause = ex.getCause() == null ? ex : ex.getCause();
-            Throwable theCauseCause = theCause.getCause() == null ? theCause : theCause.getCause();
-            List<Class<?>> excTypes = exceptionsMap.get(m);
-            if (excTypes != null) {
-                for (Class<?> type : excTypes) {
-                    if (type.isAssignableFrom(theCause.getClass())) {
-                        throw theCause;
-                    }
-                    if (type.isAssignableFrom(theCauseCause.getClass())) {
-                        throw theCauseCause;
-                    }
-                }
-            }
-
-            throw new ServiceException(REMOTE_EXCEPTION_TYPE, theCause);
+            throw exceptionMapper.mapException(m, theCause);
         } finally {
             Thread.currentThread().setContextClassLoader(oldCl);
         }
     }
 
-    private void introspectType(Class<?> iType) {
-        for (Method m : iType.getDeclaredMethods()) {
-            for (Class<?> excType : m.getExceptionTypes()) {
-                if (Exception.class.isAssignableFrom(excType)) {
-                    List<Class<?>> types = exceptionsMap.get(m);
-                    if (types == null) {
-                        types = new ArrayList<Class<?>>();
-                        exceptionsMap.put(m, types);
-                    }
-                    types.add(excType);
-                }
-            }
-        }
-    }
+
 }
