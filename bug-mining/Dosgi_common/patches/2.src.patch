diff --git a/common/bnd.bnd b/common/bnd.bnd
index 9fc9a8c1..b5ec91c6 100644
--- a/common/bnd.bnd
+++ b/common/bnd.bnd
@@ -3,4 +3,4 @@ Export-Package: \
 	org.apache.cxf.dosgi.common.httpservice,\
 	org.apache.cxf.dosgi.common.util,\
 	org.apache.cxf.dosgi.common.intent
-Private-Package: org.apache.cxf.dosgi.common.osgi
+
diff --git a/common/src/main/java/org/apache/cxf/dosgi/common/httpservice/HttpServiceManager.java b/common/src/main/java/org/apache/cxf/dosgi/common/httpservice/HttpServiceManager.java
index b129514c..e5015c9f 100644
--- a/common/src/main/java/org/apache/cxf/dosgi/common/httpservice/HttpServiceManager.java
+++ b/common/src/main/java/org/apache/cxf/dosgi/common/httpservice/HttpServiceManager.java
@@ -66,24 +66,23 @@ public class HttpServiceManager {
     private HttpService httpService;
     private BundleContext context;
 
-    @SuppressWarnings("unchecked")
     @Activate
     public void activate(ComponentContext compContext) {
-        Dictionary<String, String> config = compContext.getProperties();
+        Dictionary<String, Object> config = compContext.getProperties();
         initFromConfig(config);
         this.context = compContext.getBundleContext();
     }
 
-    void initFromConfig(Dictionary<String, String> config) {
+    void initFromConfig(Dictionary<String, Object> config) {
         if (config == null) {
-            config = new Hashtable<String, String>();
+            config = new Hashtable<String, Object>();
         }
         this.httpBase = getWithDefault(config.get(KEY_HTTP_BASE), "http://" + LocalHostUtil.getLocalIp() + ":8181");
         this.cxfServletAlias = getWithDefault(config.get(KEY_CXF_SERVLET_ALIAS), "/cxf");
     }
 
-    private String getWithDefault(String value, String defaultValue) {
-        return value == null ? defaultValue : value;
+    private String getWithDefault(Object value, String defaultValue) {
+        return value == null ? defaultValue : value.toString();
     }
 
     public Bus registerServlet(Bus bus, String contextRoot, BundleContext callingContext, Long sid) {
diff --git a/common/src/main/java/org/apache/cxf/dosgi/common/intent/DefaultIntentMapFactory.java b/common/src/main/java/org/apache/cxf/dosgi/common/intent/DefaultIntentMapFactory.java
deleted file mode 100644
index 395fe463..00000000
--- a/common/src/main/java/org/apache/cxf/dosgi/common/intent/DefaultIntentMapFactory.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.cxf.dosgi.common.intent;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.cxf.binding.soap.Soap11;
-import org.apache.cxf.binding.soap.Soap12;
-import org.apache.cxf.binding.soap.SoapBindingConfiguration;
-import org.apache.cxf.binding.soap.SoapVersion;
-import org.apache.cxf.feature.LoggingFeature;
-
-public class DefaultIntentMapFactory {
-
-    public Map<String, Object> create() {
-        Map<String, Object> intentMap = new HashMap<String, Object>();
-        intentMap.put("logging", getLoggingFeature());
-        Object soap11 = getSoapBinding(Soap11.getInstance());
-        intentMap.put("SOAP", soap11);
-        intentMap.put("SOAP.1_1", soap11);
-        intentMap.put("SOAP.1_2", getSoapBinding(Soap12.getInstance()));
-        intentMap.put("HTTP", "PROVIDED");
-        return intentMap;
-    }
-
-    private Object getLoggingFeature() {
-        return new LoggingFeature();
-    }
-
-    private Object getSoapBinding(SoapVersion soapVersion) {
-        SoapBindingConfiguration soapBindingConfig = new SoapBindingConfiguration();
-        soapBindingConfig.setVersion(soapVersion);
-        return soapBindingConfig;
-    }
-}
diff --git a/common/src/main/java/org/apache/cxf/dosgi/common/intent/IntentManagerImpl.java b/common/src/main/java/org/apache/cxf/dosgi/common/intent/IntentManagerImpl.java
index 2775086f..3bbfaabb 100644
--- a/common/src/main/java/org/apache/cxf/dosgi/common/intent/IntentManagerImpl.java
+++ b/common/src/main/java/org/apache/cxf/dosgi/common/intent/IntentManagerImpl.java
@@ -18,10 +18,13 @@
  */
 package org.apache.cxf.dosgi.common.intent;
 
+import static org.osgi.service.component.annotations.ReferenceCardinality.MULTIPLE;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -29,13 +32,18 @@ import java.util.Set;
 
 import org.apache.aries.rsa.spi.IntentUnsatisfiedException;
 import org.apache.cxf.binding.BindingConfiguration;
+import org.apache.cxf.binding.soap.Soap11;
+import org.apache.cxf.binding.soap.Soap12;
+import org.apache.cxf.binding.soap.SoapBindingConfiguration;
+import org.apache.cxf.binding.soap.SoapVersion;
 import org.apache.cxf.dosgi.common.util.OsgiUtils;
 import org.apache.cxf.endpoint.AbstractEndpointFactory;
 import org.apache.cxf.feature.Feature;
-import org.osgi.framework.BundleContext;
-import org.osgi.service.component.annotations.Activate;
+import org.apache.cxf.feature.LoggingFeature;
 import org.osgi.service.component.annotations.Component;
-import org.osgi.service.component.annotations.Deactivate;
+import org.osgi.service.component.annotations.Reference;
+import org.osgi.service.component.annotations.ReferencePolicy;
+import org.osgi.service.component.annotations.ReferencePolicyOption;
 import org.osgi.service.remoteserviceadmin.RemoteConstants;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -48,41 +56,58 @@ public class IntentManagerImpl implements IntentManager {
     private static final int DEFAULT_INTENT_TIMEOUT = 30000;
 
     private final IntentMap intentMap;
-    private final long maxIntentWaitTime;
-    private IntentTracker tracker;
+    private final long maxIntentWaitTime = DEFAULT_INTENT_TIMEOUT;
 
     public IntentManagerImpl() {
-        this(DEFAULT_INTENT_TIMEOUT);
+        this(new IntentMap(create()));
     }
 
-    public IntentManagerImpl(int maxIntentWaitTime) {
-        this(new IntentMap(new DefaultIntentMapFactory().create()), maxIntentWaitTime);
+    public IntentManagerImpl(IntentMap intentMap) {
+        this.intentMap = intentMap;
     }
     
-    public IntentManagerImpl(IntentMap intentMap) {
-        this(intentMap, DEFAULT_INTENT_TIMEOUT);
+    public static Map<String, Object> create() {
+        Map<String, Object> defaults = new HashMap<String, Object>();
+        defaults.put("logging", getLoggingFeature());
+        Object soap11 = getSoapBinding(Soap11.getInstance());
+        defaults.put("SOAP", soap11);
+        defaults.put("SOAP.1_1", soap11);
+        defaults.put("SOAP.1_2", getSoapBinding(Soap12.getInstance()));
+        defaults.put("HTTP", "PROVIDED");
+        return defaults;
     }
 
-    // For test
-    public IntentManagerImpl(IntentMap intentMap, int maxIntentWaitTime) {
-        this.maxIntentWaitTime = maxIntentWaitTime;
-        this.intentMap = intentMap;
+    private static Object getLoggingFeature() {
+        return new LoggingFeature();
     }
 
-    
-    @Activate
-    public void activate(BundleContext context) {
-        tracker = new IntentTracker(context, this.intentMap);
-        tracker.open();
+    private static Object getSoapBinding(SoapVersion soapVersion) {
+        SoapBindingConfiguration soapBindingConfig = new SoapBindingConfiguration();
+        soapBindingConfig.setVersion(soapVersion);
+        return soapBindingConfig;
     }
-    
-    @Deactivate
-    public void deactivate() {
-        tracker.close();
+
+    @Reference //
+    (//
+        cardinality = MULTIPLE, //
+        policy = ReferencePolicy.DYNAMIC, //
+        target = "(" + IntentManager.INTENT_NAME_PROP + "=*)", //
+        policyOption = ReferencePolicyOption.GREEDY
+    )
+    public void addIntent(Object intent, Map<String, ?> props) {
+        String intentName = (String)props.get(INTENT_NAME_PROP);
+        LOG.info("Adding custom intent " + intentName);
+        intentMap.put(intentName, intent);
+    }
+
+    public void removeIntent(Object intent, Map<String, ?> props) {
+        String intentName = (String)props.get(INTENT_NAME_PROP);
+        intentMap.remove(intentName);
     }
 
     public String[] applyIntents(List<Feature> features, AbstractEndpointFactory factory,
-                                 Map<String, Object> props) throws IntentUnsatisfiedException {
+                                 Map<String, Object> props)
+        throws IntentUnsatisfiedException {
         Set<String> requestedIntents = IntentManagerImpl.getRequestedIntents(props);
         Set<String> appliedIntents = new HashSet<String>();
         appliedIntents.addAll(reverseLookup(intentMap, PROVIDED_INTENT_VALUE));
@@ -99,13 +124,15 @@ public class IntentManagerImpl implements IntentManager {
         appliedIntents.addAll(addSynonymIntents(appliedIntents, intentMap));
         return appliedIntents.toArray(new String[appliedIntents.size()]);
     }
-    
+
     private static Set<String> getRequestedIntents(Map<String, Object> sd) {
-        Collection<String> intents = OsgiUtils.getMultiValueProperty(sd.get(RemoteConstants.SERVICE_EXPORTED_INTENTS));
-        Collection<String> intents2
-            = OsgiUtils.getMultiValueProperty(sd.get(RemoteConstants.SERVICE_EXPORTED_INTENTS_EXTRA));
+        Collection<String> intents = OsgiUtils
+            .getMultiValueProperty(sd.get(RemoteConstants.SERVICE_EXPORTED_INTENTS));
+        Collection<String> intents2 = OsgiUtils
+            .getMultiValueProperty(sd.get(RemoteConstants.SERVICE_EXPORTED_INTENTS_EXTRA));
         @SuppressWarnings("deprecation")
-        Collection<String> oldIntents = OsgiUtils.getMultiValueProperty(sd.get(IntentManager.EXPORTED_INTENTS_OLD));
+        Collection<String> oldIntents = OsgiUtils
+            .getMultiValueProperty(sd.get(IntentManager.EXPORTED_INTENTS_OLD));
         Set<String> allIntents = new HashSet<String>();
         if (intents != null) {
             allIntents.addAll(parseIntents(intents));
@@ -128,10 +155,11 @@ public class IntentManagerImpl implements IntentManager {
         return parsed;
     }
 
-    private boolean processIntent(List<Feature> features, AbstractEndpointFactory factory,
-                                  String intentName, Object intent) throws IntentUnsatisfiedException {
+    private boolean processIntent(List<Feature> features, AbstractEndpointFactory factory, String intentName,
+                                  Object intent)
+        throws IntentUnsatisfiedException {
         if (intent instanceof String) {
-            if (PROVIDED_INTENT_VALUE.equalsIgnoreCase((String) intent)) {
+            if (PROVIDED_INTENT_VALUE.equalsIgnoreCase((String)intent)) {
                 return false;
             }
         } else if (intent instanceof BindingConfiguration) {
@@ -140,7 +168,7 @@ public class IntentManagerImpl implements IntentManager {
             factory.setBindingConfig(bindingCfg);
             return true;
         } else if (intent instanceof Feature) {
-            Feature feature = (Feature) intent;
+            Feature feature = (Feature)intent;
             LOG.info("Applying intent: " + intentName + " via feature: " + feature);
             features.add(feature);
             return false;
@@ -151,8 +179,7 @@ public class IntentManagerImpl implements IntentManager {
         return false;
     }
 
-    private static Collection<String> addSynonymIntents(Collection<String> appliedIntents,
-                                                 IntentMap map) {
+    private static Collection<String> addSynonymIntents(Collection<String> appliedIntents, IntentMap map) {
         // E.g. SOAP and SOAP.1_1 are synonyms
         List<Object> values = new ArrayList<Object>();
         for (String key : appliedIntents) {
@@ -195,7 +222,8 @@ public class IntentManagerImpl implements IntentManager {
             }
             long remainingSeconds = (endTime - System.currentTimeMillis()) / 1000;
             if (!unsupportedIntents.isEmpty() && remainingSeconds > 0) {
-                LOG.debug("Waiting for custom intents " + unsupportedIntents + " timeout in " + remainingSeconds);
+                LOG.debug("Waiting for custom intents " + unsupportedIntents + " timeout in "
+                          + remainingSeconds);
                 try {
                     synchronized (intentMap) {
                         intentMap.wait(1000);
diff --git a/common/src/main/java/org/apache/cxf/dosgi/common/intent/IntentTracker.java b/common/src/main/java/org/apache/cxf/dosgi/common/intent/IntentTracker.java
deleted file mode 100644
index 678e9e50..00000000
--- a/common/src/main/java/org/apache/cxf/dosgi/common/intent/IntentTracker.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.cxf.dosgi.common.intent;
-
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.Filter;
-import org.osgi.framework.InvalidSyntaxException;
-import org.osgi.framework.ServiceReference;
-import org.osgi.util.tracker.ServiceTracker;
-
-@SuppressWarnings({"rawtypes", "unchecked"})
-public class IntentTracker extends ServiceTracker {
-
-    private final IntentMap intentMap;
-
-    
-    public IntentTracker(BundleContext context, IntentMap intentMap) {
-        super(context, getFilter(context), null);
-        this.intentMap = intentMap;
-    }
-
-    static Filter getFilter(BundleContext context) {
-        try {
-            return context.createFilter("(" + IntentManager.INTENT_NAME_PROP + "=*)");
-        } catch (InvalidSyntaxException e) {
-            throw new RuntimeException(e.getMessage(), e);
-        }
-    }
-
-    @Override
-    public Object addingService(ServiceReference reference) {
-        String intentName = (String) reference.getProperty(IntentManager.INTENT_NAME_PROP);
-        Object intent = super.addingService(reference);
-        IntentManagerImpl.LOG.info("Adding custom intent " + intentName);
-        intentMap.put(intentName, intent);
-        return intent;
-    }
-
-    @Override
-    public void removedService(ServiceReference reference, Object service) {
-        String intentName = (String) reference.getProperty(IntentManager.INTENT_NAME_PROP);
-        intentMap.remove(intentName);
-        super.removedService(reference, service);
-    }
-}
\ No newline at end of file
diff --git a/common/src/test/java/org/apache/cxf/dosgi/common/qos/IntentManagerImplTest.java b/common/src/test/java/org/apache/cxf/dosgi/common/qos/IntentManagerImplTest.java
index 63a2fef1..15fe952a 100644
--- a/common/src/test/java/org/apache/cxf/dosgi/common/qos/IntentManagerImplTest.java
+++ b/common/src/test/java/org/apache/cxf/dosgi/common/qos/IntentManagerImplTest.java
@@ -28,7 +28,6 @@ import java.util.Set;
 
 import org.apache.aries.rsa.spi.IntentUnsatisfiedException;
 import org.apache.cxf.binding.BindingConfiguration;
-import org.apache.cxf.dosgi.common.intent.DefaultIntentMapFactory;
 import org.apache.cxf.dosgi.common.intent.IntentManager;
 import org.apache.cxf.dosgi.common.intent.IntentManagerImpl;
 import org.apache.cxf.dosgi.common.intent.IntentMap;
@@ -54,7 +53,7 @@ public class IntentManagerImplTest extends Assert {
         AbstractEndpointFactory factory = control.createMock(AbstractEndpointFactory.class);
         control.replay();
 
-        IntentManager intentManager = new IntentManagerImpl(intentMap, 10000);
+        IntentManager intentManager = new IntentManagerImpl(intentMap);
 
         Map<String, Object> props = new HashMap<String, Object>();
         props.put("osgi.remote.requires.intents", "A");
@@ -65,7 +64,7 @@ public class IntentManagerImplTest extends Assert {
 
     @Test
     public void testMultiIntents() {
-        final IntentMap intentMap = new IntentMap(new DefaultIntentMapFactory().create());
+        final IntentMap intentMap = new IntentMap(IntentManagerImpl.create());
         intentMap.put("confidentiality.message", new TestFeature("confidentiality.message"));
         intentMap.put("transactionality", new TestFeature("transactionality"));
 
diff --git a/common/src/test/java/org/apache/cxf/dosgi/common/qos/IntentTrackerTest.java b/common/src/test/java/org/apache/cxf/dosgi/common/qos/IntentTrackerTest.java
deleted file mode 100644
index b1efd626..00000000
--- a/common/src/test/java/org/apache/cxf/dosgi/common/qos/IntentTrackerTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.cxf.dosgi.common.qos;
-
-import static org.easymock.EasyMock.expect;
-
-import org.apache.cxf.dosgi.common.intent.IntentManager;
-import org.apache.cxf.dosgi.common.intent.IntentMap;
-import org.apache.cxf.dosgi.common.intent.IntentTracker;
-import org.apache.cxf.feature.AbstractFeature;
-import org.easymock.Capture;
-import org.easymock.EasyMock;
-import org.easymock.IMocksControl;
-import org.junit.Assert;
-import org.junit.Test;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.Filter;
-import org.osgi.framework.InvalidSyntaxException;
-import org.osgi.framework.ServiceEvent;
-import org.osgi.framework.ServiceListener;
-import org.osgi.framework.ServiceReference;
-
-public class IntentTrackerTest {
-
-    private static final String MY_INTENT_NAME = "myIntent";
-
-    @Test
-    public void testIntentAsService() throws InvalidSyntaxException {
-        IMocksControl c = EasyMock.createControl();
-        BundleContext bc = c.createMock(BundleContext.class);
-        Filter filter = c.createMock(Filter.class);
-        expect(bc.createFilter(EasyMock.<String>anyObject())).andReturn(filter);
-        final Capture<ServiceListener> capturedListener = EasyMock.newCapture();
-        bc.addServiceListener(EasyMock.capture(capturedListener), EasyMock.<String>anyObject());
-        EasyMock.expectLastCall().atLeastOnce();
-        expect(bc.getServiceReferences(EasyMock.<String>anyObject(),
-                                       EasyMock.<String>anyObject())).andReturn(new ServiceReference[]{});
-        IntentMap intentMap = new IntentMap();
-
-        // Create a custom intent
-        @SuppressWarnings("unchecked")
-        ServiceReference<AbstractFeature> reference = c.createMock(ServiceReference.class);
-        expect(reference.getProperty(IntentManager.INTENT_NAME_PROP)).andReturn(MY_INTENT_NAME);
-        AbstractFeature testIntent = new AbstractFeature() {
-        };
-        expect(bc.getService(reference)).andReturn(testIntent).atLeastOnce();
-
-        c.replay();
-
-        IntentTracker tracker = new IntentTracker(bc, intentMap);
-        tracker.open();
-
-        Assert.assertFalse("IntentMap should not contain " + MY_INTENT_NAME, intentMap.containsKey(MY_INTENT_NAME));
-        ServiceListener listener = capturedListener.getValue();
-
-        // Simulate adding custom intent service
-        ServiceEvent event = new ServiceEvent(ServiceEvent.REGISTERED, reference);
-        listener.serviceChanged(event);
-
-        // our custom intent should now be available
-        Assert.assertTrue("IntentMap should contain " + MY_INTENT_NAME, intentMap.containsKey(MY_INTENT_NAME));
-        Assert.assertEquals(testIntent, intentMap.get(MY_INTENT_NAME));
-
-        c.verify();
-    }
-}
