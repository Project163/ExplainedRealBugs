diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java
index ac53f518e..378b85063 100644
--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java
+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java
@@ -69,8 +69,7 @@ public class DefaultArtifactCollector
 
         root.addDependencies( artifacts, remoteRepositories, filter );
 
-        ManagedVersionMap versionMap = (managedVersions != null && managedVersions instanceof ManagedVersionMap) ?
-            (ManagedVersionMap)managedVersions : new ManagedVersionMap(managedVersions);
+        ManagedVersionMap versionMap = getManagedVersionsMap( originatingArtifact, managedVersions );
 
         recurse( root, resolvedArtifacts, versionMap, localRepository, remoteRepositories, source, filter,
                  listeners );
@@ -107,6 +106,45 @@ public class DefaultArtifactCollector
         return result;
     }
 
+    /**
+     * Get the map of managed versions, removing the originating artifact if it is also in managed versions
+     * @param originatingArtifact artifact we are processing
+     * @param managedVersions original managed versions
+     */
+    private ManagedVersionMap getManagedVersionsMap( Artifact originatingArtifact, Map managedVersions )
+    {
+        ManagedVersionMap versionMap;
+        if ( managedVersions != null && managedVersions instanceof ManagedVersionMap )
+        {
+            versionMap = (ManagedVersionMap) managedVersions;
+        }
+        else
+        {
+            versionMap = new ManagedVersionMap( managedVersions );
+        }
+
+        /* remove the originating artifact if it is also in managed versions to avoid being modified during resolution */
+        Artifact managedOriginatingArtifact = (Artifact) versionMap.get( originatingArtifact.getDependencyConflictId() );
+        if ( managedOriginatingArtifact != null )
+        {
+            String managedVersion = managedOriginatingArtifact.getVersion();
+            String version = originatingArtifact.getVersion();
+            if ( !managedVersion.equals( version ) )
+            {
+                // TODO we probably want to warn the user that he is building and artifact with a
+                // different version than in dependencyManagement 
+                if ( managedVersions instanceof ManagedVersionMap )
+                {
+                    /* avoid modifying the managedVersions parameter creating a new map */
+                    versionMap = new ManagedVersionMap( managedVersions );
+                }
+                versionMap.remove( originatingArtifact.getDependencyConflictId() );
+            }
+        }
+
+        return versionMap;
+    }
+
     private void recurse( ResolutionNode node, Map resolvedArtifacts, ManagedVersionMap managedVersions,
                           ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,
                           ArtifactFilter filter, List listeners )
diff --git a/maven-artifact/src/test/java/org/apache/maven/artifact/resolver/DefaultArtifactCollectorTest.java b/maven-artifact/src/test/java/org/apache/maven/artifact/resolver/DefaultArtifactCollectorTest.java
index fbd354ebb..09b66e739 100644
--- a/maven-artifact/src/test/java/org/apache/maven/artifact/resolver/DefaultArtifactCollectorTest.java
+++ b/maven-artifact/src/test/java/org/apache/maven/artifact/resolver/DefaultArtifactCollectorTest.java
@@ -19,6 +19,17 @@ package org.apache.maven.artifact.resolver;
  * under the License.
  */
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.maven.artifact.Artifact;
 import org.apache.maven.artifact.factory.ArtifactFactory;
 import org.apache.maven.artifact.metadata.ArtifactMetadataRetrievalException;
@@ -31,20 +42,8 @@ import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
 import org.apache.maven.artifact.versioning.DefaultArtifactVersion;
 import org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;
 import org.apache.maven.artifact.versioning.VersionRange;
-import org.apache.maven.artifact.versioning.ManagedVersionMap;
 import org.codehaus.plexus.PlexusTestCase;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
 /**
  * Test the default artifact collector.
  *
@@ -386,6 +385,23 @@ public class DefaultArtifactCollectorTest
         assertEquals( "Check artifact list", createSet( new Object[]{a.artifact, modifiedB} ), res.getArtifacts() );
     }
 
+    public void testCollectChangesVersionOfOriginatingArtifactIfInDependencyManagementHasDifferentVersion()
+        throws ArtifactResolutionException, InvalidVersionSpecificationException
+    {
+        ArtifactSpec a = createArtifact( "a", "1.0" );
+
+        Artifact artifact = projectArtifact.artifact;
+        Artifact managedVersion = createArtifact( artifact.getArtifactId(), "2.0" ).artifact;
+
+        ArtifactResolutionResult result = collect( a, managedVersion );
+
+        assertEquals( "collect has modified version in originating artifact", "1.0", artifact.getVersion() );
+
+        Artifact resolvedArtifact = (Artifact) result.getArtifacts().iterator().next();
+
+        assertEquals( "Resolved version don't match original artifact version", "1.0", resolvedArtifact.getVersion() );
+    }
+
     public void testResolveCompileScopeOverTestScope()
         throws ArtifactResolutionException, InvalidVersionSpecificationException
     {
