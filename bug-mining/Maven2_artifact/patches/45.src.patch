diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java
index 3d62b7fc9..ac53f518e 100644
--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java
+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java
@@ -25,9 +25,11 @@ import org.apache.maven.artifact.metadata.ArtifactMetadataSource;
 import org.apache.maven.artifact.metadata.ResolutionGroup;
 import org.apache.maven.artifact.repository.ArtifactRepository;
 import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
+import org.apache.maven.artifact.resolver.filter.AndArtifactFilter;
 import org.apache.maven.artifact.versioning.ArtifactVersion;
 import org.apache.maven.artifact.versioning.OverConstrainedVersionException;
 import org.apache.maven.artifact.versioning.VersionRange;
+import org.apache.maven.artifact.versioning.ManagedVersionMap;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -67,7 +69,10 @@ public class DefaultArtifactCollector
 
         root.addDependencies( artifacts, remoteRepositories, filter );
 
-        recurse( root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter,
+        ManagedVersionMap versionMap = (managedVersions != null && managedVersions instanceof ManagedVersionMap) ?
+            (ManagedVersionMap)managedVersions : new ManagedVersionMap(managedVersions);
+
+        recurse( root, resolvedArtifacts, versionMap, localRepository, remoteRepositories, source, filter,
                  listeners );
 
         Set set = new HashSet();
@@ -102,29 +107,20 @@ public class DefaultArtifactCollector
         return result;
     }
 
-    private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,
+    private void recurse( ResolutionNode node, Map resolvedArtifacts, ManagedVersionMap managedVersions,
                           ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,
                           ArtifactFilter filter, List listeners )
         throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException
     {
         fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );
 
-        // TODO: use as a conflict resolver
         Object key = node.getKey();
-        if ( managedVersions.containsKey( key ) )
+        
+        // TODO: Does this check need to happen here?  Had to add the same call
+        // below when we iterate on child nodes -- will that suffice?
+        if ( managedVersions.containsKey( key ))
         {
-            Artifact artifact = (Artifact) managedVersions.get( key );
-
-            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );
-
-            if ( artifact.getVersion() != null )
-            {
-                node.getArtifact().setVersion( artifact.getVersion() );
-            }
-            if ( artifact.getScope() != null )
-            {
-                node.getArtifact().setScope( artifact.getScope() );
-            }
+            manageArtifact( node, managedVersions, listeners );
         }
 
         List previousNodes = (List) resolvedArtifacts.get( key );
@@ -274,6 +270,38 @@ public class DefaultArtifactCollector
                             fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );
                         }
 
+                        Object childKey = child.getKey();
+                        if ( managedVersions.containsKey( childKey ) )
+                        {
+                            // If this child node is a managed dependency, ensure
+                            // we are using the dependency management version
+                            // of this child if applicable b/c we want to use the
+                            // managed version's POM, *not* any other version's POM.
+                            // We retrieve the POM below in the retrieval step.
+                            manageArtifact( child, managedVersions, listeners );
+                            
+                            // Also, we need to ensure that any exclusions it presents are
+                            // added to the artifact before we retrive the metadata
+                            // for the artifact; otherwise we may end up with unwanted
+                            // dependencies.
+                            Artifact ma = (Artifact) managedVersions.get( childKey );
+                            ArtifactFilter managedExclusionFilter = ma.getDependencyFilter();
+                            if ( null != managedExclusionFilter )
+                            {
+                                if ( null != artifact.getDependencyFilter() )
+                                {
+                                    AndArtifactFilter aaf = new AndArtifactFilter();
+                                    aaf.add( artifact.getDependencyFilter() );
+                                    aaf.add( managedExclusionFilter );
+                                    artifact.setDependencyFilter( aaf );
+                                }
+                                else
+                                {
+                                    artifact.setDependencyFilter( managedExclusionFilter );
+                                }
+                            }
+                        }
+
                         artifact.setDependencyTrail( node.getDependencyTrail() );
                         ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );
 
@@ -286,6 +314,7 @@ public class DefaultArtifactCollector
                         }
 
                         child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );
+
                     }
                     catch ( CyclicDependencyException e )
                     {
@@ -311,6 +340,32 @@ public class DefaultArtifactCollector
         }
     }
 
+    private void manageArtifact( ResolutionNode node, ManagedVersionMap managedVersions, List listeners )
+    {
+        Artifact artifact = (Artifact) managedVersions.get( node.getKey() );
+
+        // Before we update the version of the artifact, we need to know
+        // whether we are working on a transitive dependency or not.  This
+        // allows depMgmt to always override transitive dependencies, while
+        // explicit child override depMgmt (viz. depMgmt should only
+        // provide defaults to children, but should override transitives).
+        // We can do this by calling isChildOfRootNode on the current node.
+
+        if ( artifact.getVersion() != null
+                        && ( node.isChildOfRootNode() ? node.getArtifact().getVersion() == null : true ) )
+        {
+            fireEvent( ResolutionListener.MANAGE_ARTIFACT_VERSION, listeners, node, artifact );
+            node.getArtifact().setVersion( artifact.getVersion() );
+        }
+
+        if ( artifact.getScope() != null
+                        && ( node.isChildOfRootNode() ? node.getArtifact().getScope() == null : true ) )
+        {
+            fireEvent( ResolutionListener.MANAGE_ARTIFACT_SCOPE, listeners, node, artifact );
+            node.getArtifact().setScope( artifact.getScope() );
+        }
+    }
+
     /**
      * Check if the scope needs to be updated.
      * <a href="http://docs.codehaus.org/x/IGU#DependencyMediationandConflictResolution-Scoperesolution">More info</a>.
@@ -407,8 +462,21 @@ public class DefaultArtifactCollector
                 case ResolutionListener.UPDATE_SCOPE_CURRENT_POM:
                     listener.updateScopeCurrentPom( node.getArtifact(), replacement.getScope() );
                     break;
-                case ResolutionListener.MANAGE_ARTIFACT:
-                    listener.manageArtifact( node.getArtifact(), replacement );
+                case ResolutionListener.MANAGE_ARTIFACT_VERSION:
+                    if (listener instanceof ResolutionListenerForDepMgmt) {
+                        ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;
+                        asImpl.manageArtifactVersion( node.getArtifact(), replacement );
+                    } else {
+                        listener.manageArtifact( node.getArtifact(), replacement );
+                    }
+                    break;
+                case ResolutionListener.MANAGE_ARTIFACT_SCOPE:
+                    if (listener instanceof ResolutionListenerForDepMgmt) {
+                        ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;
+                        asImpl.manageArtifactScope( node.getArtifact(), replacement );
+                    } else {
+                        listener.manageArtifact( node.getArtifact(), replacement );
+                    }
                     break;
                 case ResolutionListener.SELECT_VERSION_FROM_RANGE:
                     listener.selectVersionFromRange( node.getArtifact() );
diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionListener.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionListener.java
index 72069f96f..05677224c 100644
--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionListener.java
+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionListener.java
@@ -44,6 +44,9 @@ public interface ResolutionListener
 
     int UPDATE_SCOPE = 6;
 
+    /**
+     * @deprecated
+     */
     int MANAGE_ARTIFACT = 7;
 
     int OMIT_FOR_CYCLE = 8;
@@ -53,6 +56,10 @@ public interface ResolutionListener
     int SELECT_VERSION_FROM_RANGE = 10;
 
     int RESTRICT_RANGE = 11;
+    
+    int MANAGE_ARTIFACT_VERSION = 12;
+    
+    int MANAGE_ARTIFACT_SCOPE = 13;
 
     void testArtifact( Artifact node );
 
@@ -66,7 +73,17 @@ public interface ResolutionListener
 
     void updateScope( Artifact artifact, String scope );
 
+    /**
+     * @deprecated
+     */
     void manageArtifact( Artifact artifact, Artifact replacement );
+    
+    // TODO Use the following two instead of manageArtifact
+    // TODO Remove ResolutionListenerDM interface
+
+    //void manageArtifactVersion( Artifact artifact, Artifact replacement );
+    
+    //void manageArtifactScope( Artifact artifact, Artifact replacement );
 
     void omitForCycle( Artifact artifact );
 
diff --git a/maven-artifact/src/test/java/org/apache/maven/artifact/resolver/DefaultArtifactCollectorTest.java b/maven-artifact/src/test/java/org/apache/maven/artifact/resolver/DefaultArtifactCollectorTest.java
index 5ac2f20ec..fbd354ebb 100644
--- a/maven-artifact/src/test/java/org/apache/maven/artifact/resolver/DefaultArtifactCollectorTest.java
+++ b/maven-artifact/src/test/java/org/apache/maven/artifact/resolver/DefaultArtifactCollectorTest.java
@@ -31,6 +31,7 @@ import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
 import org.apache.maven.artifact.versioning.DefaultArtifactVersion;
 import org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;
 import org.apache.maven.artifact.versioning.VersionRange;
+import org.apache.maven.artifact.versioning.ManagedVersionMap;
 import org.codehaus.plexus.PlexusTestCase;
 
 import java.util.ArrayList;
@@ -809,7 +810,8 @@ public class DefaultArtifactCollectorTest
 
         private String getKey( Artifact artifact )
         {
-            return artifact.getDependencyConflictId() + ":" + artifact.getVersionRange();
+            //return artifact.getDependencyConflictId() + ":" + artifact.getVersionRange();
+            return artifact.getDependencyConflictId();
         }
 
         private Set createArtifacts( ArtifactFactory artifactFactory, Set dependencies, String inheritedScope,
