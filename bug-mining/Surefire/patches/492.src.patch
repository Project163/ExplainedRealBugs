diff --git a/maven-surefire-plugin/src/site/apt/examples/shutdown.apt.vm b/maven-surefire-plugin/src/site/apt/examples/shutdown.apt.vm
index 477dd8543..b9c3fd3a7 100644
--- a/maven-surefire-plugin/src/site/apt/examples/shutdown.apt.vm
+++ b/maven-surefire-plugin/src/site/apt/examples/shutdown.apt.vm
@@ -49,8 +49,10 @@ Shutdown of Forked JVM
   After the master process of the build is shutdown by sending SIGTERM signal
   or pressing CTRL+C, the master process immediately sends SHUTDOWN command to
   every forked JVM. By default (configuration parameter <<<shutdown=testset>>>)
-  forked JVM would not continue with new test which means that the current
-  test may still continue to run.
+  forked JVM would not pick up a new test which means that the current
+  test may still continue to run. The SIGTERM signal triggers Java shutdownhook
+  which executes <<<java.lang.Process.destroy()>>> in the forked JVM (not always
+  reliable depending on VM and OS).
   The parameter <<<shutdown>>> can be configured with other two values
   <<<exit>>> and <<<kill>>>. Using <<<exit>>> forked JVM executes
   <<<java.lang.System.exit(1)>>> after the master process has received SIGTERM.
diff --git a/surefire-api/src/main/java/org/apache/maven/surefire/util/CloseableIterator.java b/surefire-api/src/main/java/org/apache/maven/surefire/util/CloseableIterator.java
new file mode 100644
index 000000000..52b5b65d5
--- /dev/null
+++ b/surefire-api/src/main/java/org/apache/maven/surefire/util/CloseableIterator.java
@@ -0,0 +1 @@
+package org.apache.maven.surefire.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * This iterator is marked as stopped if {@link #isClosed()} returns {@code true}.
 * If the iterator has been closed before calling {@link #hasNext()} then the method returns {@code false}.
 * If the iterator was closed after {@link #hasNext() hasNext returns true} but before {@link #next()}, the
 * method {@link #next()} throws {@link java.util.NoSuchElementException}.
 * The method {@link #remove()} throws {@link IllegalStateException} if the iterator has been closed.
 *
 * @param <T> the type of elements returned by this iterator
 *
 * @author <a href="mailto:tibordigana@apache.org">Tibor Digana (tibor17)</a>
 * @since 2.19.1
 */
public abstract class CloseableIterator<T>
        implements Iterator<T>
{
    private Boolean finishCurrentIteration;

    protected abstract boolean isClosed();
    protected abstract boolean doHasNext();
    protected abstract T doNext();
    protected abstract void doRemove();

    public boolean hasNext()
    {
        popMarker();
        return !finishCurrentIteration && doHasNext();
    }

    public T next()
    {
        try
        {
            if ( popMarker() && finishCurrentIteration )
            {
                throw new NoSuchElementException( "iterator closed" );
            }
            return doNext();
        }
        finally
        {
            finishCurrentIteration = null;
        }
    }

    public void remove()
    {
        try
        {
            if ( popMarker() && finishCurrentIteration )
            {
                throw new IllegalStateException( "iterator closed" );
            }
            doRemove();
        }
        finally
        {
            finishCurrentIteration = null;
        }
    }

    /**
     * @return {@code true} if marker changed from NULL to anything
     */
    private boolean popMarker()
    {
        if ( finishCurrentIteration == null )
        {
            finishCurrentIteration = isClosed();
            return true;
        }
        return false;
    }
}
\ No newline at end of file
diff --git a/surefire-api/src/main/java/org/apache/maven/surefire/util/TestsToRun.java b/surefire-api/src/main/java/org/apache/maven/surefire/util/TestsToRun.java
index 0255645ae..a8982d428 100644
--- a/surefire-api/src/main/java/org/apache/maven/surefire/util/TestsToRun.java
+++ b/surefire-api/src/main/java/org/apache/maven/surefire/util/TestsToRun.java
@@ -24,8 +24,8 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import java.util.NoSuchElementException;
 import java.util.Set;
+
 import org.apache.maven.surefire.testset.TestSetFailedException;
 
 import static java.lang.Math.max;
@@ -65,7 +65,7 @@ public static TestsToRun fromClass( Class<?> clazz )
      */
     public Iterator<Class<?>> iterated()
     {
-        return locatedClasses.subList( 0, iteratedCount ).iterator();
+        return newWeakIterator();
     }
 
     /**
@@ -79,54 +79,41 @@ public Iterator<Class<?>> iterator()
     }
 
     private final class ClassesIterator
-        implements Iterator<Class<?>>
+        extends CloseableIterator<Class<?>>
     {
         private final Iterator<Class<?>> it = TestsToRun.this.locatedClasses.iterator();
 
-        private Boolean finishCurrentIteration;
-
         private int iteratedCount;
 
-        public boolean hasNext()
+        @Override
+        protected boolean isClosed()
         {
-            popMarker();
-            return !finishCurrentIteration && it.hasNext();
+            return TestsToRun.this.isFinished();
         }
 
-        public Class<?> next()
+        @Override
+        protected boolean doHasNext()
         {
-            try
-            {
-                if ( popMarker() && finishCurrentIteration )
-                {
-                    throw new NoSuchElementException();
-                }
-                Class<?> nextTest = it.next();
-                TestsToRun.this.iteratedCount = max( ++iteratedCount, TestsToRun.this.iteratedCount );
-                return nextTest;
-            }
-            finally
-            {
-                finishCurrentIteration = null;
-            }
+            return it.hasNext();
         }
 
-        public void remove()
+        @Override
+        protected Class<?> doNext()
         {
-            throw new UnsupportedOperationException();
+            Class<?> nextTest = it.next();
+            TestsToRun.this.iteratedCount = max( ++iteratedCount, TestsToRun.this.iteratedCount );
+            return nextTest;
         }
 
-        /**
-         * @return {@code true} if marker changed from NULL to anything
-         */
-        private boolean popMarker()
+        @Override
+        protected void doRemove()
         {
-            if ( finishCurrentIteration == null )
-            {
-                finishCurrentIteration = TestsToRun.this.finished;
-                return true;
-            }
-            return false;
+        }
+
+        @Override
+        public void remove()
+        {
+            throw new UnsupportedOperationException( "unsupported remove" );
         }
     }
 
@@ -135,6 +122,11 @@ public final void markTestSetFinished()
         finished = true;
     }
 
+    public final boolean isFinished()
+    {
+        return finished;
+    }
+
     public String toString()
     {
         StringBuilder sb = new StringBuilder();
@@ -214,4 +206,44 @@ public Class<?> getClassByName( String className )
         }
         return null;
     }
+
+    /**
+     * @return snapshot of tests upon constructs of internal iterator.
+     * Therefore weakly consistent while {@link TestsToRun#iterator()} is being iterated.
+     */
+    private Iterator<Class<?>> newWeakIterator()
+    {
+        final Iterator<Class<?>> it = locatedClasses.subList( 0, iteratedCount ).iterator();
+        return new CloseableIterator<Class<?>>()
+        {
+            @Override
+            protected boolean isClosed()
+            {
+                return TestsToRun.this.isFinished();
+            }
+
+            @Override
+            protected boolean doHasNext()
+            {
+                return it.hasNext();
+            }
+
+            @Override
+            protected Class<?> doNext()
+            {
+                return it.next();
+            }
+
+            @Override
+            protected void doRemove()
+            {
+            }
+
+            @Override
+            public void remove()
+            {
+                throw new UnsupportedOperationException( "unsupported remove" );
+            }
+        };
+    }
 }
diff --git a/surefire-booter/src/main/java/org/apache/maven/surefire/booter/LazyTestsToRun.java b/surefire-booter/src/main/java/org/apache/maven/surefire/booter/LazyTestsToRun.java
index bccb44c0d..29a59b67c 100644
--- a/surefire-booter/src/main/java/org/apache/maven/surefire/booter/LazyTestsToRun.java
+++ b/surefire-booter/src/main/java/org/apache/maven/surefire/booter/LazyTestsToRun.java
@@ -23,6 +23,7 @@
 import java.util.Collections;
 import java.util.Iterator;
 
+import org.apache.maven.surefire.util.CloseableIterator;
 import org.apache.maven.surefire.util.TestsToRun;
 
 import static org.apache.maven.surefire.booter.CommandReader.getReader;
@@ -79,7 +80,7 @@ public void remove()
     }
 
     /**
-     * @return test classes which have been retrieved by {@link TestsToRun#iterator()}.
+     * @return test classes which have been retrieved by {@link LazyTestsToRun#iterator()}.
      */
     @Override
     public Iterator<Class<?>> iterated()
@@ -124,24 +125,37 @@ private static Class<?> findClass( String clazz )
      * @return snapshot of tests upon constructs of {@link CommandReader#iterated() iterator}.
      * Therefore weakly consistent while {@link LazyTestsToRun#iterator()} is being iterated.
      */
-    private static Iterator<Class<?>> newWeakIterator()
+    private Iterator<Class<?>> newWeakIterator()
     {
         final Iterator<String> it = getReader().iterated();
-        return new Iterator<Class<?>>()
+        return new CloseableIterator<Class<?>>()
         {
-            public boolean hasNext()
+            @Override
+            protected boolean isClosed()
+            {
+                return LazyTestsToRun.this.isFinished();
+            }
+
+            @Override
+            protected boolean doHasNext()
             {
                 return it.hasNext();
             }
 
-            public Class<?> next()
+            @Override
+            protected Class<?> doNext()
             {
                 return findClass( it.next() );
             }
 
+            @Override
+            protected void doRemove()
+            {
+            }
+
             public void remove()
             {
-                throw new UnsupportedOperationException( "remove" );
+                throw new UnsupportedOperationException( "unsupported remove" );
             }
         };
     }
