diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/Utilities.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/Utilities.java
index b1e9701252..b2eeb4f323 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/Utilities.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/Utilities.java
@@ -4487,15 +4487,7 @@ public static void handleDirectInsertTableFinalPath(Path specPath, String unionS
     List<Path> manifests = new ArrayList<>();
     if (fs.exists(manifestDir)) {
       FileStatus[] manifestFiles = fs.listStatus(manifestDir);
-      if (manifestFiles != null) {
-        for (FileStatus status : manifestFiles) {
-          Path path = status.getPath();
-          if (path.getName().endsWith(MANIFEST_EXTENSION)) {
-            Utilities.FILE_OP_LOGGER.info("Reading manifest {}", path);
-            manifests.add(path);
-          }
-        }
-      }
+      manifests = selectManifestFiles(manifestFiles);
     } else {
       Utilities.FILE_OP_LOGGER.info("No manifests found in directory {} - query produced no output", manifestDir);
       manifestDir = null;
@@ -4601,6 +4593,67 @@ public static void handleDirectInsertTableFinalPath(Path specPath, String unionS
     }
   }
 
+  /**
+   * The name of a manifest file consists of the task ID and a .manifest extension, where
+   * the task ID includes the attempt ID as well. It can happen that a task attempt already
+   * wrote out the manifest file, and then fails, so Tez restarts it. If the next attempt
+   * successfully finishes, the query won't fail but there could be multiple manifest files with
+   * the same task ID, but different attempt IDs. In this case the manifest file which has
+   * the highest attempt ID, and not empty, has to be considered.
+   * The empty manifest files and the ones with the same task ID but lower attempt ID has to be ignored.
+   * @param manifestFiles All the files listed in the manifest directory
+   * @return The list of manifest files which have the highest attempt ID and are not empty
+   */
+  @VisibleForTesting
+  static List<Path> selectManifestFiles(FileStatus[] manifestFiles) {
+    List<Path> manifests = new ArrayList<>();
+    if (manifestFiles != null) {
+      Map<String, Integer> fileNameToAttempId = new HashMap<>();
+      Map<String, Path> fileNameToPath = new HashMap<>();
+
+      for (FileStatus manifestFile : manifestFiles) {
+        Path path = manifestFile.getPath();
+        if (manifestFile.getLen() == 0L) {
+          Utilities.FILE_OP_LOGGER.info("Found manifest file {}, but it is empty.", path);
+          continue;
+        }
+        String fileName = path.getName();
+        if (fileName.endsWith(MANIFEST_EXTENSION)) {
+          Pattern pattern = Pattern.compile("([0-9]+)_([0-9]+).manifest");
+          Matcher matcher = pattern.matcher(fileName);
+          if (matcher.matches()) {
+            String taskId = matcher.group(1);
+            int attemptId = Integer.parseInt(matcher.group(2));
+            Integer maxAttemptId = fileNameToAttempId.get(taskId);
+            if (maxAttemptId == null) {
+              fileNameToAttempId.put(taskId, attemptId);
+              fileNameToPath.put(taskId, path);
+              Utilities.FILE_OP_LOGGER.info("Found manifest file {} with attemptId {}.", path, attemptId);
+            } else if (attemptId > maxAttemptId) {
+              fileNameToAttempId.put(taskId, attemptId);
+              fileNameToPath.put(taskId, path);
+              Utilities.FILE_OP_LOGGER.info(
+                  "Found manifest file {} which has higher attemptId than {}. Ignore the manifest files with attemptId below {}.",
+                  path, maxAttemptId, attemptId);
+            } else {
+              Utilities.FILE_OP_LOGGER.info(
+                  "Found manifest file {} with attemptId {}, but already have a manifest file with attemptId {}. Ignore this manifest file.",
+                  path, attemptId, maxAttemptId);
+            }
+          } else {
+            Utilities.FILE_OP_LOGGER.info("Found manifest file {}", path);
+            manifests.add(path);
+          }
+        }
+      }
+
+      if (!fileNameToPath.isEmpty()) {
+        manifests.addAll(fileNameToPath.values());
+      }
+    }
+    return manifests;
+  }
+
   private static void cleanDirectInsertDirectoriesConcurrently(
           List<Path> directInsertDirectories, Set<Path> committed, FileSystem fs, Configuration hconf, String unionSuffix, int lbLevels)
           throws IOException, HiveException {
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/exec/TestUtilities.java b/ql/src/test/org/apache/hadoop/hive/ql/exec/TestUtilities.java
index 04cfd9e897..3361f06cdb 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/exec/TestUtilities.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/exec/TestUtilities.java
@@ -36,10 +36,13 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
+import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
@@ -47,6 +50,7 @@
 import java.util.concurrent.Future;
 
 import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileStatus;
 import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hive.common.type.Timestamp;
@@ -719,4 +723,81 @@ public void testGetTasksRecursion() {
         Utilities.getMRTasks(getTestDiamondTaskGraph(rootTask)));
 
   }
+
+  @Test
+  public void testSelectManifestFilesOnlyOneAttemptId() {
+    FileStatus[] manifestFiles = generateTestNotEmptyFileStatuses("000000_0.manifest", "000001_0.manifest",
+        "000002_0.manifest", "000003_0.manifest");
+    Set<String> expectedPathes =
+        getExpectedPathes("000000_0.manifest", "000001_0.manifest", "000002_0.manifest", "000003_0.manifest");
+    List<Path> foundManifestFiles = Utilities.selectManifestFiles(manifestFiles);
+    Set<String> resultPathes = getResultPathes(foundManifestFiles);
+    assertEquals(expectedPathes, resultPathes);
+  }
+
+  @Test
+  public void testSelectManifestFilesMultipleAttemptIds() {
+    FileStatus[] manifestFiles = generateTestNotEmptyFileStatuses("000000_1.manifest", "000000_0.manifest",
+        "000000_3.manifest", "000000_2.manifest", "000003_0.manifest", "000003_1.manifest", "000003_2.manifest");
+    Set<String> expectedPathes = getExpectedPathes("000000_3.manifest", "000003_2.manifest");
+    List<Path> foundManifestFiles = Utilities.selectManifestFiles(manifestFiles);
+    Set<String> resultPathes = getResultPathes(foundManifestFiles);
+    assertEquals(expectedPathes, resultPathes);
+  }
+
+  @Test
+  public void testSelectManifestFilesWithEmptyManifests() {
+    Set<String> emptyFiles = new HashSet<>();
+    emptyFiles.add("000001_0.manifest");
+    emptyFiles.add("000001_2.manifest");
+    emptyFiles.add("000002_2.manifest");
+    FileStatus[] manifestFiles = generateTestNotEmptyFileStatuses(emptyFiles, "000001_1.manifest", "000001_0.manifest",
+        "000001_3.manifest", "000001_2.manifest", "000002_0.manifest", "000002_1.manifest", "000002_2.manifest");
+    Set<String> expectedPathes = getExpectedPathes("000001_3.manifest", "000002_1.manifest");
+    List<Path> foundManifestFiles = Utilities.selectManifestFiles(manifestFiles);
+    Set<String> resultPathes = getResultPathes(foundManifestFiles);
+    assertEquals(expectedPathes, resultPathes);
+  }
+
+  @Test
+  public void testSelectManifestFilesWithWrongManifestNames() {
+    FileStatus[] manifestFiles = generateTestNotEmptyFileStatuses("000004_0.manifest", "000005.manifest",
+        "000004_1.manifest", "000006.manifest", "000007_0.wrong", "000008_1", "000004_2.manifest");
+    Set<String> expectedPathes = getExpectedPathes("000005.manifest", "000006.manifest", "000004_2.manifest");
+    List<Path> foundManifestFiles = Utilities.selectManifestFiles(manifestFiles);
+    Set<String> resultPathes = getResultPathes(foundManifestFiles);
+    assertEquals(expectedPathes, resultPathes);
+  }
+
+  private FileStatus[] generateTestNotEmptyFileStatuses(String... fileNames) {
+    return generateTestNotEmptyFileStatuses(null, fileNames);
+  }
+
+  private FileStatus[] generateTestNotEmptyFileStatuses(Set<String> emptyFiles, String... fileNames) {
+    FileStatus[] manifestFiles = new FileStatus[fileNames.length];
+    for (int i = 0; i < fileNames.length; i++) {
+      long len = 10000L;
+      if (emptyFiles != null && emptyFiles.contains(fileNames[i])) {
+        len = 0L;
+      }
+      manifestFiles[i] = new FileStatus(len, false, 0, 250L, 123456L, new Path("/sometestpath/" + fileNames[i]));
+    }
+    return manifestFiles;
+  }
+
+  private Set<String> getExpectedPathes(String... fileNames) {
+    Set<String> expectedPathes = new HashSet<>();
+    for (String fileName : fileNames) {
+      expectedPathes.add("/sometestpath/" + fileName);
+    }
+    return expectedPathes;
+  }
+
+  private Set<String> getResultPathes(List<Path> foundManifestFiles) {
+    Set<String> resultPathes = new HashSet<>();
+    for (Path path : foundManifestFiles) {
+      resultPathes.add(path.toString());
+    }
+    return resultPathes;
+  }
 }
