diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/optiq/HiveOptiqUtil.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/optiq/HiveOptiqUtil.java
index dca1949275..2ad5c34587 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/optiq/HiveOptiqUtil.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/optiq/HiveOptiqUtil.java
@@ -27,6 +27,8 @@
 import java.util.Map.Entry;
 
 import org.apache.hadoop.hive.ql.optimizer.optiq.reloperators.HiveJoinRel;
+import org.apache.hadoop.hive.ql.parse.ASTNode;
+import org.apache.hadoop.hive.ql.parse.HiveParser;
 import org.eigenbase.rel.RelFactories.ProjectFactory;
 import org.eigenbase.rel.RelNode;
 import org.eigenbase.relopt.RelOptUtil;
@@ -55,7 +57,7 @@ public class HiveOptiqUtil {
   /**
    * Get list of virtual columns from the given list of projections.
    * <p>
-   * 
+   *
    * @param exps
    *          list of rex nodes representing projections
    * @return List of Virtual Columns, will not be null.
@@ -72,6 +74,17 @@ public static List<Integer> getVirtualCols(List<? extends RexNode> exps) {
     return vCols;
   }
 
+  public static boolean validateASTForCBO (ASTNode ast) {
+    String astTree = ast.toStringTree();
+    String [] tokens = {"TOK_CHARSETLITERAL"};
+    for (String token : tokens) {
+      if (astTree.contains(token)) {
+         return false;
+      }
+    }
+    return true;
+  }
+
   public static List<RexNode> getProjsFromBelowAsInputRef(final RelNode rel) {
     List<RexNode> projectList = Lists.transform(rel.getRowType().getFieldList(),
         new Function<RelDataTypeField, RexNode>() {
@@ -98,7 +111,7 @@ public static List<Integer> translateBitSetToProjIndx(BitSet projBitSet) {
   /**
    * Push any equi join conditions that are not column references as Projections
    * on top of the children.
-   * 
+   *
    * @param factory
    *          Project factory to use.
    * @param inputRels
@@ -232,7 +245,7 @@ public static RexNode projectNonColumnEquiConditions(ProjectFactory factory, Rel
    * of equi join keys; the indexes are both in child and Join node schema.<br>
    * 3. Keeps a map of projection indexes that are part of join keys to list of
    * conjuctive elements(JoinLeafPredicateInfo) that uses them.
-   * 
+   *
    */
   public static class JoinPredicateInfo {
     private final ImmutableList<JoinLeafPredicateInfo>                        nonEquiJoinPredicateElements;
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
index d382ab1923..4b1a0339f4 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
@@ -9581,7 +9581,7 @@ public void analyzeInternal(ASTNode ast) throws SemanticException {
           || ast.getToken().getType() == HiveParser.TOK_EXPLAIN;
       if (!tokenTypeIsQuery || createVwDesc != null
           || !HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVE_CBO_ENABLED)
-          || !canHandleQuery(qb, true)) {
+          || !canHandleQuery(qb, true) || !HiveOptiqUtil.validateASTForCBO(ast)) {
         runCBO = false;
       }
 
@@ -12351,7 +12351,7 @@ private RelNode genTableLogicalPlan(String tableAlias, QB qb) throws SemanticExc
       HiveTableScanRel tableRel = null;
 
       try {
-        
+
         // 0. If the table has a Sample specified, bail from Optiq path.
         if ( qb.getParseInfo().getTabSample(tableAlias) != null ||
             SemanticAnalyzer.this.nameToSplitSample.containsKey(tableAlias)) {
@@ -12361,7 +12361,7 @@ private RelNode genTableLogicalPlan(String tableAlias, QB qb) throws SemanticExc
           LOG.debug(msg);
           throw new OptiqSemanticException(msg);
         }
-        
+
         // 1. Get Table Alias
         String alias_id = getAliasId(tableAlias, qb);
 
