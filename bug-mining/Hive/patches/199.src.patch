diff --git a/CHANGES.txt b/CHANGES.txt
index 3e3dbdbb92..593eba6cea 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -331,6 +331,9 @@ Trunk - Unreleased
     HIVE-473. Clean up after tests.
     (Johan Oskarsson via namit)
 
+    HIVE-616. Bug in TypeConvertor
+    (Zheng Shao via namit)
+
 Release 0.3.1 - Unreleased
 
   INCOMPATIBLE CHANGES
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java
index 02a1cd792c..0fd7fd439c 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java
@@ -26,7 +26,6 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Stack;
-import java.util.Vector;
 import java.util.Map.Entry;
 
 import org.apache.commons.logging.Log;
@@ -97,7 +96,7 @@ public void popObj() {
   transient private Object[] dummyObj; // for outer joins, contains the
                                        // potential nulls for the concerned
                                        // aliases
-  transient private Vector<ArrayList<Object>>[] dummyObjVectors;
+  transient private ArrayList<ArrayList<Object>>[] dummyObjVectors;
   transient private Stack<Iterator<ArrayList<Object>>> iterators;
   transient protected int totalSz; // total size of the composite object
   transient ObjectInspector joinOutputObjectInspector;  // The OI for the output row 
@@ -106,7 +105,7 @@ public void popObj() {
   // the output of the CommonJoinOperator to the input columnInfo.
   transient private Map<Integer, Set<String>> posToAliasMap;
 
-  HashMap<Byte, Vector<ArrayList<Object>>> storage;
+  HashMap<Byte, ArrayList<ArrayList<Object>>> storage;
   int joinEmitInterval = -1;
   int nextSz = 0;
   transient Byte lastAlias = null;
@@ -186,7 +185,7 @@ public void initializeOp(Configuration hconf, Reporter reporter, ObjectInspector
     LOG.info("COMMONJOIN " + ((StructObjectInspector)inputObjInspector[0]).getTypeName());   
     totalSz = 0;
     // Map that contains the rows for each alias
-    storage = new HashMap<Byte, Vector<ArrayList<Object>>>();
+    storage = new HashMap<Byte, ArrayList<ArrayList<Object>>>();
 
     numAliases = conf.getExprs().size();
     
@@ -206,7 +205,7 @@ public void initializeOp(Configuration hconf, Reporter reporter, ObjectInspector
     joinValuesStandardObjectInspectors = getStandardObjectInspectors(joinValuesObjectInspectors);
       
     dummyObj = new Object[numAliases];
-    dummyObjVectors = new Vector[numAliases];
+    dummyObjVectors = new ArrayList[numAliases];
 
     int pos = 0;
     for (Byte alias : order) {
@@ -216,7 +215,7 @@ public void initializeOp(Configuration hconf, Reporter reporter, ObjectInspector
       for (int j = 0; j < sz; j++)
         nr.add(null);
       dummyObj[pos] = nr;
-      Vector<ArrayList<Object>> values = new Vector<ArrayList<Object>>();
+      ArrayList<ArrayList<Object>> values = new ArrayList<ArrayList<Object>>();
       values.add((ArrayList<Object>) dummyObj[pos]);
       dummyObjVectors[pos] = values;
       pos++;
@@ -236,7 +235,7 @@ public void startGroup() throws HiveException {
     LOG.trace("Join: Starting new group");
     storage.clear();
     for (Byte alias : order)
-      storage.put(alias, new Vector<ArrayList<Object>>());
+      storage.put(alias, new ArrayList<ArrayList<Object>>());
   }
 
   protected int getNextSize(int sz) {
@@ -295,8 +294,8 @@ private void copyOldArray(boolean[] src, boolean[] dest) {
       dest[i] = src[i];
   }
 
-  private Vector<boolean[]> joinObjectsInnerJoin(Vector<boolean[]> resNulls,
-      Vector<boolean[]> inputNulls, ArrayList<Object> newObj,
+  private ArrayList<boolean[]> joinObjectsInnerJoin(ArrayList<boolean[]> resNulls,
+      ArrayList<boolean[]> inputNulls, ArrayList<Object> newObj,
       IntermediateObject intObj, int left, boolean newObjNull) {
     if (newObjNull)
       return resNulls;
@@ -314,8 +313,8 @@ private Vector<boolean[]> joinObjectsInnerJoin(Vector<boolean[]> resNulls,
     return resNulls;
   }
 
-  private Vector<boolean[]> joinObjectsLeftOuterJoin(
-      Vector<boolean[]> resNulls, Vector<boolean[]> inputNulls,
+  private ArrayList<boolean[]> joinObjectsLeftOuterJoin(
+      ArrayList<boolean[]> resNulls, ArrayList<boolean[]> inputNulls,
       ArrayList<Object> newObj, IntermediateObject intObj, int left,
       boolean newObjNull) {
     Iterator<boolean[]> nullsIter = inputNulls.iterator();
@@ -333,8 +332,8 @@ private Vector<boolean[]> joinObjectsLeftOuterJoin(
     return resNulls;
   }
 
-  private Vector<boolean[]> joinObjectsRightOuterJoin(
-      Vector<boolean[]> resNulls, Vector<boolean[]> inputNulls,
+  private ArrayList<boolean[]> joinObjectsRightOuterJoin(
+      ArrayList<boolean[]> resNulls, ArrayList<boolean[]> inputNulls,
       ArrayList<Object> newObj, IntermediateObject intObj, int left,
       boolean newObjNull, boolean firstRow) {
     if (newObjNull)
@@ -382,8 +381,8 @@ private Vector<boolean[]> joinObjectsRightOuterJoin(
     return resNulls;
   }
 
-  private Vector<boolean[]> joinObjectsFullOuterJoin(
-      Vector<boolean[]> resNulls, Vector<boolean[]> inputNulls,
+  private ArrayList<boolean[]> joinObjectsFullOuterJoin(
+      ArrayList<boolean[]> resNulls, ArrayList<boolean[]> inputNulls,
       ArrayList<Object> newObj, IntermediateObject intObj, int left,
       boolean newObjNull, boolean firstRow) {
     if (newObjNull) {
@@ -455,10 +454,10 @@ private Vector<boolean[]> joinObjectsFullOuterJoin(
    * nulls is changed appropriately. The list will contain all non-nulls for a
    * inner join. The outer joins are processed appropriately.
    */
-  private Vector<boolean[]> joinObjects(Vector<boolean[]> inputNulls,
+  private ArrayList<boolean[]> joinObjects(ArrayList<boolean[]> inputNulls,
                                         ArrayList<Object> newObj, IntermediateObject intObj, 
                                         int joinPos, boolean firstRow) {
-    Vector<boolean[]> resNulls = new Vector<boolean[]>();
+    ArrayList<boolean[]> resNulls = new ArrayList<boolean[]>();
     boolean newObjNull = newObj == dummyObj[joinPos] ? true : false;
     if (joinPos == 0) {
       if (newObjNull)
@@ -507,7 +506,7 @@ else if (type == joinDesc.RIGHT_OUTER_JOIN)
    * same as the number of inputs under consideration currently. When all inputs
    * are accounted for, the output is forwared appropriately.
    */
-  private void genObject(Vector<boolean[]> inputNulls, int aliasNum,
+  private void genObject(ArrayList<boolean[]> inputNulls, int aliasNum,
                          IntermediateObject intObj, boolean firstRow) throws HiveException {
     boolean childFirstRow = firstRow;
     if (aliasNum < numAliases) {
@@ -517,7 +516,7 @@ private void genObject(Vector<boolean[]> inputNulls, int aliasNum,
       while (aliasRes.hasNext()) {
         ArrayList<Object> newObj = aliasRes.next();
         intObj.pushObj(newObj);
-        Vector<boolean[]> newNulls = joinObjects(inputNulls, newObj, intObj,
+        ArrayList<boolean[]> newNulls = joinObjects(inputNulls, newObj, intObj,
                                                  aliasNum, childFirstRow);
         genObject(newNulls, aliasNum + 1, intObj, firstRow);
         intObj.popObj();
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinObjectValue.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinObjectValue.java
index 0d805463fe..2729ef921d 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinObjectValue.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinObjectValue.java
@@ -23,18 +23,12 @@
 import java.io.ObjectInput;
 import java.io.ObjectOutput;
 import java.util.ArrayList;
-import java.util.List;
-import java.util.Vector;
 
 import org.apache.hadoop.hive.ql.exec.MapJoinOperator.MapJoinObjectCtx;
 import org.apache.hadoop.io.Text;
 import org.apache.hadoop.io.Writable;
 import org.apache.hadoop.hive.serde2.SerDeException;
-import org.apache.hadoop.hive.serde2.lazy.LazyObject;
-import org.apache.hadoop.hive.serde2.lazy.LazyStruct;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;
-import org.apache.hadoop.hive.serde2.objectinspector.StructField;
-import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils.ObjectInspectorCopyOption;
 
 /**
@@ -43,7 +37,7 @@
 public class MapJoinObjectValue implements Externalizable {
 
   transient protected int     metadataTag;
-  transient protected Vector<ArrayList<Object>>  obj;
+  transient protected ArrayList<ArrayList<Object>>  obj;
   transient Writable val;
 
 
@@ -56,7 +50,7 @@ public MapJoinObjectValue() {
    * @param objectTypeTag
    * @param obj
    */
-  public MapJoinObjectValue(int metadataTag, Vector<ArrayList<Object>> obj) {
+  public MapJoinObjectValue(int metadataTag, ArrayList<ArrayList<Object>> obj) {
     val = new Text();
     this.metadataTag = metadataTag;
     this.obj = obj;
@@ -90,7 +84,7 @@ public void readExternal(ObjectInput in) throws IOException,
       MapJoinObjectCtx ctx = MapJoinOperator.getMapMetadata().get(Integer.valueOf(metadataTag));
       int sz = in.readInt();
 
-      Vector<ArrayList<Object>> res = new Vector<ArrayList<Object>>();
+      ArrayList<ArrayList<Object>> res = new ArrayList<ArrayList<Object>>();
       for (int pos = 0; pos < sz; pos++) {
         ArrayList<Object> memObj =
           (ArrayList<Object>)
@@ -117,7 +111,7 @@ public void writeExternal(ObjectOutput out) throws IOException {
       MapJoinObjectCtx ctx = MapJoinOperator.getMapMetadata().get(Integer.valueOf(metadataTag));
 
       // Different processing for key and value
-      Vector<ArrayList<Object>> v = (Vector<ArrayList<Object>>) obj;
+      ArrayList<ArrayList<Object>> v = (ArrayList<ArrayList<Object>>) obj;
       out.writeInt(v.size());
 
       for (int pos = 0; pos < v.size(); pos++) {
@@ -147,14 +141,14 @@ public void setMetadataTag(int metadataTag) {
   /**
    * @return the obj
    */
-  public Vector<ArrayList<Object>> getObj() {
+  public ArrayList<ArrayList<Object>> getObj() {
     return obj;
   }
 
   /**
    * @param obj the obj to set
    */
-  public void setObj(Vector<ArrayList<Object>> obj) {
+  public void setObj(ArrayList<ArrayList<Object>> obj) {
     this.obj = obj;
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java
index ef7462aec7..f5ab40c6d2 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java
@@ -26,7 +26,7 @@
 import java.util.Map;
 import java.util.List;
 import java.util.Random;
-import java.util.Vector;
+import java.util.ArrayList;
 import java.util.ArrayList;
 import java.util.Properties;
 
@@ -175,7 +175,7 @@ public void initializeOp(Configuration hconf, Reporter reporter, ObjectInspector
         mapJoinTables.put(Byte.valueOf((byte)pos), hashTable);
       }
 
-      storage.put((byte)posBigTable, new Vector<ArrayList<Object>>());
+      storage.put((byte)posBigTable, new ArrayList<ArrayList<Object>>());
       
       mapJoinRowsKey = HiveConf.getIntVar(hconf, HiveConf.ConfVars.HIVEMAPJOINROWSIZE);
       
@@ -243,10 +243,10 @@ public void process(Object row, ObjectInspector rowInspector, int tag) throws Hi
         HTree hashTable = mapJoinTables.get(alias);
         MapJoinObjectKey keyMap = new MapJoinObjectKey(metadataKeyTag, key);
         MapJoinObjectValue o = (MapJoinObjectValue)hashTable.get(keyMap);
-        Vector<ArrayList<Object>> res = null;
+        ArrayList<ArrayList<Object>> res = null;
         
         if (o == null) {
-          res = new Vector<ArrayList<Object>>();
+          res = new ArrayList<ArrayList<Object>>();
         }
         else {
           res = o.getObj();
@@ -285,7 +285,7 @@ public void process(Object row, ObjectInspector rowInspector, int tag) throws Hi
         return;
       }
 
-      // Add the value to the vector
+      // Add the value to the ArrayList
       storage.get(alias).add(value);
 
       for (Byte pos : order) {
@@ -294,7 +294,7 @@ public void process(Object row, ObjectInspector rowInspector, int tag) throws Hi
           MapJoinObjectValue o = (MapJoinObjectValue)mapJoinTables.get(pos).get(keyMap);
 
           if (o == null) {
-            storage.put(pos, new Vector<ArrayList<Object>>());
+            storage.put(pos, new ArrayList<ArrayList<Object>>());
           }
           else {
             storage.put(pos, o.getObj());
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/SelectOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/SelectOperator.java
index a31fbbd418..a5db74c69b 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/SelectOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/SelectOperator.java
@@ -72,7 +72,14 @@ public void process(Object row, ObjectInspector rowInspector, int tag)
     }
     
     for(int i=0; i<eval.length; i++) {
-      output[i] = eval[i].evaluate(row);
+      try {
+        output[i] = eval[i].evaluate(row);
+      } catch (HiveException e) {
+        throw e;
+      } catch (RuntimeException e) {
+        throw new HiveException("Error evaluating "
+            + conf.getColList().get(i).getExprString(), e);
+      }
     }
     forward(output, outputObjectInspector);
   }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFUtils.java b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFUtils.java
index 4096af4158..8cc8fc111c 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFUtils.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFUtils.java
@@ -25,8 +25,9 @@
 import org.apache.hadoop.hive.ql.exec.FunctionRegistry;
 import org.apache.hadoop.hive.ql.exec.UDFArgumentTypeException;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorConverters;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;
-import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils.Converter;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorConverters.Converter;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils.ObjectInspectorCopyOption;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.VoidObjectInspector;
 import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
@@ -61,7 +62,7 @@ public static class ReturnObjectInspectorResolver {
     
     // We create converters beforehand, so that the converters can reuse the 
     // same object for returning conversion results. 
-    HashMap<ObjectInspector, ObjectInspectorUtils.Converter> converters;
+    HashMap<ObjectInspector, Converter> converters;
     
     public ReturnObjectInspectorResolver() {
       this(false);
@@ -130,8 +131,9 @@ public ObjectInspector get() {
      * different possibilities are not all the same).
      */
     public Object convertIfNecessary(Object o, ObjectInspector oi) {
+      Object converted = null;
       if (oi == returnObjectInspector) {
-        return o;
+        converted = o;
       } else {
 
         if (o == null) {
@@ -139,20 +141,19 @@ public Object convertIfNecessary(Object o, ObjectInspector oi) {
         }
         
         if (converters == null) {
-          converters = new HashMap<ObjectInspector, ObjectInspectorUtils.Converter>();
+          converters = new HashMap<ObjectInspector, Converter>();
         }
         
         Converter converter = converters.get(oi);
         if (converter == null) {
-          converter = ObjectInspectorUtils.getConverter(oi, returnObjectInspector);
+          converter = ObjectInspectorConverters.getConverter(oi, returnObjectInspector);
           converters.put(oi, converter);
         }
-
-        return converter.convert(o);
-      }   
+        converted = converter.convert(o);
+      }
+      return converted;
     }
     
   }
   
-  
 }
diff --git a/ql/src/test/queries/clientpositive/type_cast_1.q b/ql/src/test/queries/clientpositive/type_cast_1.q
new file mode 100644
index 0000000000..a1607320c7
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/type_cast_1.q
@@ -0,0 +1,4 @@
+EXPLAIN
+SELECT IF(false, 1, cast(2 as smallint)) + 3 FROM src LIMIT 1;
+
+SELECT IF(false, 1, cast(2 as smallint)) + 3 FROM src LIMIT 1;
diff --git a/ql/src/test/results/clientpositive/type_cast_1.q.out b/ql/src/test/results/clientpositive/type_cast_1.q.out
new file mode 100644
index 0000000000..fd3c4fda3e
--- /dev/null
+++ b/ql/src/test/results/clientpositive/type_cast_1.q.out
@@ -0,0 +1,35 @@
+query: EXPLAIN
+SELECT IF(false, 1, cast(2 as smallint)) + 3 FROM src LIMIT 1
+ABSTRACT SYNTAX TREE:
+  (TOK_QUERY (TOK_FROM (TOK_TABREF src)) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR (+ (TOK_FUNCTION IF false 1 (TOK_FUNCTION TOK_SMALLINT 2)) 3))) (TOK_LIMIT 1)))
+
+STAGE DEPENDENCIES:
+  Stage-1 is a root stage
+  Stage-0 is a root stage
+
+STAGE PLANS:
+  Stage: Stage-1
+    Map Reduce
+      Alias -> Map Operator Tree:
+        src 
+            Select Operator
+              expressions:
+                    expr: (if(false, 1, UDFToShort(2)) + 3)
+                    type: int
+              Limit
+                File Output Operator
+                  compressed: false
+                  GlobalTableId: 0
+                  table:
+                      input format: org.apache.hadoop.mapred.TextInputFormat
+                      output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
+
+  Stage: Stage-0
+    Fetch Operator
+      limit: 1
+
+
+query: SELECT IF(false, 1, cast(2 as smallint)) + 3 FROM src LIMIT 1
+Input: default/src
+Output: file:/data/users/zshao/tools/deploy-trunk-apache-hive/build/ql/tmp/1077571356/10000
+5
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/binarysortable/BinarySortableSerDe.java b/serde/src/java/org/apache/hadoop/hive/serde2/binarysortable/BinarySortableSerDe.java
index 8e33d6aaab..b0ff61e9f4 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/binarysortable/BinarySortableSerDe.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/binarysortable/BinarySortableSerDe.java
@@ -136,7 +136,6 @@ public void initialize(Configuration conf, Properties tbl)
     for (int i=0; i<columnSortOrderIsDesc.length; i++) {
       columnSortOrderIsDesc[i] = (columnSortOrder != null && columnSortOrder.charAt(i) == '-');
     }
-    System.out.println("Column sort order = " + columnSortOrder);
   }
   
   @Override
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorConverters.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorConverters.java
new file mode 100644
index 0000000000..c5b965c95b
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorConverters.java
@@ -0,0 +1,100 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.serde2.objectinspector;
+
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorConverter;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.SettableBooleanObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.SettableByteObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.SettableDoubleObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.SettableFloatObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.SettableIntObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.SettableLongObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.SettableShortObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableStringObjectInspector;
+
+
+public class ObjectInspectorConverters {
+
+  /**
+   * A converter which will convert objects with one ObjectInspector to another.
+   */
+  public static interface Converter {
+    public Object convert(Object o);
+  }
+  
+  /**
+   * Returns a converter that converts objects from one OI to another OI.
+   * The returned (converted) object belongs to this converter, so that it can be reused
+   * across different calls.
+   */
+  public static Converter getConverter(ObjectInspector inputOI, ObjectInspector outputOI) {
+    switch (outputOI.getCategory()) {
+      case PRIMITIVE:
+        switch (((PrimitiveObjectInspector)outputOI).getPrimitiveCategory()) {
+          case BOOLEAN: 
+            return new PrimitiveObjectInspectorConverter.BooleanConverter(
+                (PrimitiveObjectInspector)inputOI, 
+                (SettableBooleanObjectInspector)outputOI);
+          case BYTE: 
+            return new PrimitiveObjectInspectorConverter.ByteConverter(
+                (PrimitiveObjectInspector)inputOI, 
+                (SettableByteObjectInspector)outputOI);
+          case SHORT: 
+            return new PrimitiveObjectInspectorConverter.ShortConverter(
+                (PrimitiveObjectInspector)inputOI, 
+                (SettableShortObjectInspector)outputOI);
+          case INT: 
+            return new PrimitiveObjectInspectorConverter.IntConverter(
+                (PrimitiveObjectInspector)inputOI, 
+                (SettableIntObjectInspector)outputOI);
+          case LONG: 
+            return new PrimitiveObjectInspectorConverter.LongConverter(
+                (PrimitiveObjectInspector)inputOI, 
+                (SettableLongObjectInspector)outputOI);
+          case FLOAT: 
+            return new PrimitiveObjectInspectorConverter.FloatConverter(
+                (PrimitiveObjectInspector)inputOI, 
+                (SettableFloatObjectInspector)outputOI);
+          case DOUBLE: 
+            return new PrimitiveObjectInspectorConverter.DoubleConverter(
+                (PrimitiveObjectInspector)inputOI, 
+                (SettableDoubleObjectInspector)outputOI);
+          case STRING:
+            if (outputOI instanceof WritableStringObjectInspector) {
+              return new PrimitiveObjectInspectorConverter.TextConverter(
+                  (PrimitiveObjectInspector)inputOI);
+            } else if  (outputOI instanceof WritableStringObjectInspector) {
+              return new PrimitiveObjectInspectorConverter.TextConverter(
+                  (PrimitiveObjectInspector)inputOI);
+            }
+          default: 
+            throw new RuntimeException("Hive internal error: conversion of "
+                + inputOI.getTypeName() + " to " + outputOI.getTypeName() + " not supported yet.");
+        }
+      case STRUCT:
+      case LIST:
+      case MAP:
+      default:
+        throw new RuntimeException("Hive internal error: conversion of "
+            + inputOI.getTypeName() + " to " + outputOI.getTypeName() + " not supported yet.");
+    }
+  }
+  
+  
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorUtils.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorUtils.java
index 1783d05e11..e5cb1a1b26 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorUtils.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorUtils.java
@@ -20,11 +20,8 @@
 
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-import java.util.Map.Entry;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -35,10 +32,8 @@
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.IntObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.LongObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
-import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.ShortObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.StringObjectInspector;
-import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils.TextConverter;
 import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoUtils;
 import org.apache.hadoop.io.Text;
 
@@ -51,28 +46,6 @@
 public class ObjectInspectorUtils {
 
   private static Log LOG = LogFactory.getLog(ObjectInspectorUtils.class.getName());
-  
-  
-  static ArrayList<ArrayList<String>> integerArrayCache = new ArrayList<ArrayList<String>>();
-
-  static ArrayList<String> integerCSVCache = new ArrayList<String>(); 
-  public static String getIntegerCSV(int size) {
-    while (integerCSVCache.size() <= size) {
-      integerCSVCache.add(null);
-    }
-    String result = integerCSVCache.get(size);
-    if (result == null) {
-      StringBuilder sb = new StringBuilder();
-      for(int i=0; i<size; i++) {
-        if (i>0) sb.append(",");
-        sb.append("" + i);
-      }
-      result = sb.toString();
-      integerCSVCache.set(size, result);
-    }
-    return result;
-  }
-  
 
   /**
    * This enum controls how we copy primitive objects.
@@ -467,94 +440,6 @@ public static int compare(Object o1, ObjectInspector oi1, Object o2, ObjectInspe
     }
   }
 
-  /**
-   * A converter which will convert objects with one ObjectInspector to another.
-   * We can optimize this class by reusing the same returning object, etc, in the future.
-   *
-   * Note that the outputOI has to be a standard Writable ObjectInspector for now.
-   * In the future, we can allow standard Java ObjectInspector as well.
-   */
-  public static class Converter {
-    boolean typeConversionNeeded;
-    ObjectInspector inputOI;
-    ObjectInspector outputOI;
-    TextConverter textConverter;
-    
-    Converter(ObjectInspector inputOI, ObjectInspector outputOI) {
-      this.inputOI = inputOI;
-      this.outputOI = outputOI;
-      
-      if (outputOI != 
-        TypeInfoUtils.getStandardObjectInspectorFromTypeInfo(
-            TypeInfoUtils.getTypeInfoFromObjectInspector(outputOI))) {
-        throw new RuntimeException("Hive internal error: ObjectInspectorUtils.Converter"
-           + " is called with non writable outputOI!");
-      }
-      
-      typeConversionNeeded = 
-        !TypeInfoUtils.getTypeInfoFromObjectInspector(inputOI)
-          .equals(TypeInfoUtils.getTypeInfoFromObjectInspector(outputOI));
-      
-      if (outputOI instanceof StringObjectInspector) {
-        textConverter = new TextConverter();
-      }
-    }
-    
-    /**
-     * Returns an object that can be inspected by outputOI.
-     * @param o  an object that can be inspected by inputOI.
-     */
-    public Object convert(Object o) {
-
-      if (o == null) {
-        return null;
-      }
-      
-      if (!typeConversionNeeded) {
-        return ObjectInspectorUtils.copyToStandardObject(
-            o, inputOI, ObjectInspectorCopyOption.WRITABLE);
-      }
-      
-      PrimitiveObjectInspector pInputOI = (PrimitiveObjectInspector)inputOI;
-      PrimitiveObjectInspector pOutputOI = (PrimitiveObjectInspector)outputOI;
-      
-      try {
-        switch (pOutputOI.getPrimitiveCategory()) {
-          case VOID:
-          case BOOLEAN:
-          case BYTE:
-            return PrimitiveObjectInspectorUtils.getByte(o, pInputOI);
-          case SHORT:
-            return PrimitiveObjectInspectorUtils.getShort(o, pInputOI);
-          case INT:
-            return PrimitiveObjectInspectorUtils.getInt(o, pInputOI);
-          case LONG:
-            return PrimitiveObjectInspectorUtils.getLong(o, pInputOI);
-          case FLOAT:
-            return PrimitiveObjectInspectorUtils.getFloat(o, pInputOI);
-          case DOUBLE:
-            return PrimitiveObjectInspectorUtils.getDouble(o, pInputOI);
-          case STRING:
-            return textConverter.convert(o, pInputOI);
-          default: throw new RuntimeException("Hive internal error: unknown category:"
-              + pOutputOI.getPrimitiveCategory());
-        }
-      } catch (NumberFormatException e) {
-        return null;
-      } 
-      
-    }
-  }
-
-  /**
-   * Returns a converter that converts objects from one OI to another OI.
-   * The returned (converted) object belongs to this converter, so that it can be reused
-   * across different calls.
-   */
-  public static Converter getConverter(ObjectInspector inputOI, ObjectInspector outputOI) {
-    return new Converter(inputOI, outputOI);
-  }
-  
   /**
    * Get the list of field names as csv from a StructObjectInspector.
    */
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/ByteObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/ByteObjectInspector.java
index 17783a271b..d66d40db1f 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/ByteObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/ByteObjectInspector.java
@@ -29,4 +29,5 @@ public interface ByteObjectInspector extends PrimitiveObjectInspector {
    * Get the byte data.
    */
   byte get(Object o);
+  
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorConverter.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorConverter.java
new file mode 100644
index 0000000000..f09038235e
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorConverter.java
@@ -0,0 +1,297 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.serde2.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.ByteStream;
+import org.apache.hadoop.hive.serde2.lazy.LazyInteger;
+import org.apache.hadoop.hive.serde2.lazy.LazyLong;
+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorConverters.Converter;
+import org.apache.hadoop.io.Text;
+
+public class PrimitiveObjectInspectorConverter {
+
+  /**
+   * A converter for the byte type.
+   */
+  public static class BooleanConverter implements Converter {
+    PrimitiveObjectInspector inputOI;
+    SettableBooleanObjectInspector outputOI;
+    Object r;
+    
+    public BooleanConverter(PrimitiveObjectInspector inputOI, SettableBooleanObjectInspector outputOI) {
+      this.inputOI = inputOI;
+      this.outputOI = outputOI;
+      r = outputOI.create(false);
+    }
+
+    @Override
+    public Object convert(Object o) {
+      if (o == null) {
+        return null;
+      }
+      try {
+        outputOI.set(r, PrimitiveObjectInspectorUtils.getBoolean(o, inputOI));
+        return r;
+      } catch (NumberFormatException e) {
+        return null;
+      }
+    }
+  }
+
+  /**
+   * A converter for the byte type.
+   */
+  public static class ByteConverter implements Converter {
+    PrimitiveObjectInspector inputOI;
+    SettableByteObjectInspector outputOI;
+    Object r;
+    
+    public ByteConverter(PrimitiveObjectInspector inputOI, SettableByteObjectInspector outputOI) {
+      this.inputOI = inputOI;
+      this.outputOI = outputOI;
+      r = outputOI.create((byte)0);
+    }
+
+    @Override
+    public Object convert(Object o) {
+      if (o == null) {
+        return null;
+      }
+      try {
+        outputOI.set(r, PrimitiveObjectInspectorUtils.getByte(o, inputOI));
+        return r;
+      } catch (NumberFormatException e) {
+        return null;
+      }
+    }
+  }
+
+  /**
+   * A converter for the short type.
+   */
+  public static class ShortConverter implements Converter {
+    PrimitiveObjectInspector inputOI;
+    SettableShortObjectInspector outputOI;
+    Object r;
+    
+    public ShortConverter(PrimitiveObjectInspector inputOI, SettableShortObjectInspector outputOI) {
+      this.inputOI = inputOI;
+      this.outputOI = outputOI;
+      r = outputOI.create((short)0);
+    }
+
+    @Override
+    public Object convert(Object o) {
+      if (o == null) {
+        return null;
+      }
+      try {
+        outputOI.set(r, PrimitiveObjectInspectorUtils.getShort(o, inputOI));
+        return r;
+      } catch (NumberFormatException e) {
+        return null;
+      }
+    }
+  }
+
+  /**
+   * A converter for the int type.
+   */
+  public static class IntConverter implements Converter {
+    PrimitiveObjectInspector inputOI;
+    SettableIntObjectInspector outputOI;
+    Object r;
+    
+    public IntConverter(PrimitiveObjectInspector inputOI, SettableIntObjectInspector outputOI) {
+      this.inputOI = inputOI;
+      this.outputOI = outputOI;
+      r = outputOI.create((int)0);
+    }
+
+    @Override
+    public Object convert(Object o) {
+      if (o == null) {
+        return null;
+      }
+      try {
+        outputOI.set(r, PrimitiveObjectInspectorUtils.getInt(o, inputOI));
+        return r;
+      } catch (NumberFormatException e) {
+        return null;
+      }
+    }
+  }
+
+  /**
+   * A converter for the long type.
+   */
+  public static class LongConverter implements Converter {
+    PrimitiveObjectInspector inputOI;
+    SettableLongObjectInspector outputOI;
+    Object r;
+    
+    public LongConverter(PrimitiveObjectInspector inputOI, SettableLongObjectInspector outputOI) {
+      this.inputOI = inputOI;
+      this.outputOI = outputOI;
+      r = outputOI.create((long)0);
+    }
+
+    @Override
+    public Object convert(Object o) {
+      if (o == null) {
+        return null;
+      }
+      try {
+        outputOI.set(r, PrimitiveObjectInspectorUtils.getLong(o, inputOI));
+        return r;
+      } catch (NumberFormatException e) {
+        return null;
+      }
+    }
+  }
+  
+  /**
+   * A converter for the float type.
+   */
+  public static class FloatConverter implements Converter {
+    PrimitiveObjectInspector inputOI;
+    SettableFloatObjectInspector outputOI;
+    Object r;
+    
+    public FloatConverter(PrimitiveObjectInspector inputOI, SettableFloatObjectInspector outputOI) {
+      this.inputOI = inputOI;
+      this.outputOI = outputOI;
+      r = outputOI.create((float)0);
+    }
+
+    @Override
+    public Object convert(Object o) {
+      if (o == null) {
+        return null;
+      }
+      try {
+        outputOI.set(r, PrimitiveObjectInspectorUtils.getFloat(o, inputOI));
+        return r;
+      } catch (NumberFormatException e) {
+        return null;
+      }
+    }
+  }
+  
+  /**
+   * A converter for the double type.
+   */
+  public static class DoubleConverter implements Converter {
+    PrimitiveObjectInspector inputOI;
+    SettableDoubleObjectInspector outputOI;
+    Object r;
+    
+    public DoubleConverter(PrimitiveObjectInspector inputOI, SettableDoubleObjectInspector outputOI) {
+      this.inputOI = inputOI;
+      this.outputOI = outputOI;
+      r = outputOI.create((double)0);
+    }
+
+    @Override
+    public Object convert(Object o) {
+      if (o == null) {
+        return null;
+      }
+      try {
+        outputOI.set(r, PrimitiveObjectInspectorUtils.getDouble(o, inputOI));
+        return r;
+      } catch (NumberFormatException e) {
+        return null;
+      }
+    }
+  }
+  
+  /**
+   * A helper class to convert any primitive to Text. 
+   */
+  public static class TextConverter implements Converter {
+    PrimitiveObjectInspector inputOI;
+    Text t = new Text();
+    ByteStream.Output out = new ByteStream.Output();
+    
+    static byte[] trueBytes = {'T', 'R', 'U', 'E'};
+    static byte[] falseBytes = {'F', 'A', 'L', 'S', 'E'};
+    
+    public TextConverter(PrimitiveObjectInspector inputOI) {
+      this.inputOI = inputOI;
+    }
+    
+    public Text convert(Object o)  {
+      if (o == null) {
+        return null;
+      }
+      
+      switch(inputOI.getPrimitiveCategory()) {
+        case VOID: {
+          return null;
+        }
+        case BOOLEAN: {
+          t.set(((BooleanObjectInspector)inputOI).get(o) ? trueBytes : falseBytes);
+          return t;
+        }
+        case BYTE: {
+          out.reset();
+          LazyInteger.writeUTF8NoException(out, ((ByteObjectInspector)inputOI).get(o));
+          t.set(out.getData(), 0, out.getCount());
+          return t;
+        }
+        case SHORT: {
+          out.reset();
+          LazyInteger.writeUTF8NoException(out, ((ShortObjectInspector)inputOI).get(o));
+          t.set(out.getData(), 0, out.getCount());
+          return t;
+        }
+        case INT: {
+          out.reset();
+          LazyInteger.writeUTF8NoException(out, ((IntObjectInspector)inputOI).get(o));
+          t.set(out.getData(), 0, out.getCount());
+          return t;
+        }
+        case LONG:{
+          out.reset();
+          LazyLong.writeUTF8NoException(out, ((LongObjectInspector)inputOI).get(o));
+          t.set(out.getData(), 0, out.getCount());
+          return t;
+        }
+        case FLOAT: {
+          t.set(String.valueOf(((FloatObjectInspector)inputOI).get(o)));
+          return t;
+        }
+        case DOUBLE: {
+          t.set(String.valueOf(((DoubleObjectInspector)inputOI).get(o)));
+          return t;
+        }
+        case STRING: {
+          t.set(((StringObjectInspector)inputOI).getPrimitiveJavaObject(o));
+          return t;
+        }
+        default: {
+          throw new RuntimeException("Hive 2 Internal error: type = "
+              + inputOI.getTypeName());
+        }
+      }
+    }
+  }  
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorUtils.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorUtils.java
index 01645ec48e..a6cc4ff874 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorUtils.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorUtils.java
@@ -25,7 +25,6 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hive.serde.Constants;
-import org.apache.hadoop.hive.serde2.ByteStream;
 import org.apache.hadoop.hive.serde2.io.ByteWritable;
 import org.apache.hadoop.hive.serde2.io.DoubleWritable;
 import org.apache.hadoop.hive.serde2.io.ShortWritable;
@@ -345,7 +344,66 @@ public static boolean comparePrimitiveObjectsWithConversion(Object o1, Primitive
   }
   
   /**
-   * Get the integer number out of a primitive object. 
+   * Get the boolean value out of a primitive object.
+   * Note that NullPointerException will be thrown if o is null.
+   * Note that NumberFormatException will be thrown if o is not a valid number.
+   */
+  public static boolean getBoolean(Object o, PrimitiveObjectInspector oi) throws NumberFormatException {
+    boolean result = false;
+    switch (oi.getPrimitiveCategory()) {
+      case VOID: {
+        result = false;
+        break;
+      }
+      case BOOLEAN: {
+        result = ((BooleanObjectInspector)oi).get(o);
+        break;
+      }
+      case BYTE: {
+        result = ((ByteObjectInspector)oi).get(o) != 0;
+        break;
+      }
+      case SHORT: {
+        result = ((ShortObjectInspector)oi).get(o) != 0;
+        break;
+      }
+      case INT: {
+        result = ((IntObjectInspector)oi).get(o) != 0;
+        break;
+      }
+      case LONG: {
+        result = (int)((LongObjectInspector)oi).get(o) != 0;
+        break;
+      }
+      case FLOAT: {
+        result = (int)((FloatObjectInspector)oi).get(o) != 0;
+        break;
+      }
+      case DOUBLE: {
+        result = (int)((DoubleObjectInspector)oi).get(o) != 0;
+        break;
+      }
+      case STRING: {
+        StringObjectInspector soi = (StringObjectInspector)oi;
+        if (soi.preferWritable()) {
+          Text t = soi.getPrimitiveWritableObject(o);
+          result = t.getLength() != 0;
+        } else {
+          String s = soi.getPrimitiveJavaObject(o);
+          result = s.length() != 0;
+        }
+        break;
+      }
+      default: {
+        throw new RuntimeException("Hive 2 Internal error: unknown type: "
+            + oi.getTypeName());
+      }
+    }
+    return result;
+  }
+  
+  /**
+   * Get the byte value out of a primitive object. 
    * Note that NullPointerException will be thrown if o is null.
    * Note that NumberFormatException will be thrown if o is not a valid number.
    */
@@ -354,7 +412,7 @@ public static byte getByte(Object o, PrimitiveObjectInspector oi) throws NumberF
   }
   
   /**
-   * Get the integer number out of a primitive object. 
+   * Get the short value out of a primitive object. 
    * Note that NullPointerException will be thrown if o is null.
    * Note that NumberFormatException will be thrown if o is not a valid number.
    */
@@ -363,7 +421,7 @@ public static short getShort(Object o, PrimitiveObjectInspector oi) throws Numbe
   }
   
   /**
-   * Get the integer number out of a primitive object.
+   * Get the integer value out of a primitive object.
    * Note that NullPointerException will be thrown if o is null.
    * Note that NumberFormatException will be thrown if o is not a valid number.
    */
@@ -414,8 +472,7 @@ public static int getInt(Object o, PrimitiveObjectInspector oi) throws NumberFor
         break;
       }
       default: {
-        // Should never happen because we checked this in SemanticAnalyzer.getXpathOrFuncExprNodeDesc
-        throw new RuntimeException("Hive 2 Internal error: index expression is not ordinal types: "
+        throw new RuntimeException("Hive 2 Internal error: unknown type: "
             + oi.getTypeName());
       }
     }
@@ -423,7 +480,7 @@ public static int getInt(Object o, PrimitiveObjectInspector oi) throws NumberFor
   }
   
   /**
-   * Get the long number out of a primitive object. 
+   * Get the long value out of a primitive object. 
    * Note that NullPointerException will be thrown if o is null.
    * Note that NumberFormatException will be thrown if o is not a valid number.
    */
@@ -474,8 +531,7 @@ public static long getLong(Object o, PrimitiveObjectInspector oi) throws NumberF
         break;
       }
       default: {
-        // Should never happen because we checked this in SemanticAnalyzer.getXpathOrFuncExprNodeDesc
-        throw new RuntimeException("Hive 2 Internal error: index expression is not ordinal types: "
+        throw new RuntimeException("Hive 2 Internal error: unknown type: "
             + oi.getTypeName());
       }
     }
@@ -483,7 +539,7 @@ public static long getLong(Object o, PrimitiveObjectInspector oi) throws NumberF
   }
   
   /**
-   * Get the double number out of a primitive object. 
+   * Get the double value out of a primitive object. 
    * Note that NullPointerException will be thrown if o is null.
    * Note that NumberFormatException will be thrown if o is not a valid number.
    */
@@ -529,8 +585,7 @@ public static double getDouble(Object o, PrimitiveObjectInspector oi) throws Num
         break;
       }
       default: {
-        // Should never happen because we checked this in SemanticAnalyzer.getXpathOrFuncExprNodeDesc
-        throw new RuntimeException("Hive 2 Internal error: index expression is not ordinal types: "
+        throw new RuntimeException("Hive 2 Internal error: unknown type: "
             + oi.getTypeName());
       }
     }
@@ -538,98 +593,12 @@ public static double getDouble(Object o, PrimitiveObjectInspector oi) throws Num
   }    
 
   /**
-   * Get the float number out of a primitive object. 
+   * Get the float value out of a primitive object. 
    * Note that NullPointerException will be thrown if o is null.
    * Note that NumberFormatException will be thrown if o is not a valid number.
    */
   public static float getFloat(Object o, PrimitiveObjectInspector oi) throws NumberFormatException {
     return (float)getDouble(o, oi);
   }
-  
-  /**
-   * A helper class to convert any primitive to Text. 
-   */
-  public static class TextConverter {
-    Text t = new Text();
-    ByteStream.Output out = new ByteStream.Output();
-    
-    static byte[] trueBytes = {'T', 'R', 'U', 'E'};
-    static byte[] falseBytes = {'F', 'A', 'L', 'S', 'E'};
-    
-    
-    public Text convert(Object o, PrimitiveObjectInspector oi)  {
-      if (o == null) {
-        return null;
-      }
-      
-      switch(oi.getPrimitiveCategory()) {
-        case VOID: {
-          return null;
-        }
-        case BOOLEAN: {
-          t.set(((BooleanObjectInspector)oi).get(o) ? trueBytes : falseBytes);
-          return t;
-        }
-        case BYTE: {
-          out.reset();
-          LazyInteger.writeUTF8NoException(out, ((ByteObjectInspector)oi).get(o));
-          t.set(out.getData(), 0, out.getCount());
-          return t;
-        }
-        case SHORT: {
-          out.reset();
-          LazyInteger.writeUTF8NoException(out, ((ShortObjectInspector)oi).get(o));
-          t.set(out.getData(), 0, out.getCount());
-          return t;
-        }
-        case INT: {
-          out.reset();
-          LazyInteger.writeUTF8NoException(out, ((IntObjectInspector)oi).get(o));
-          t.set(out.getData(), 0, out.getCount());
-          return t;
-        }
-        case LONG:{
-          out.reset();
-          LazyLong.writeUTF8NoException(out, ((LongObjectInspector)oi).get(o));
-          t.set(out.getData(), 0, out.getCount());
-          return t;
-        }
-        case FLOAT: {
-          t.set(String.valueOf(((FloatObjectInspector)oi).get(o)));
-          return t;
-        }
-        case DOUBLE: {
-          t.set(String.valueOf(((DoubleObjectInspector)oi).get(o)));
-          return t;
-        }
-        case STRING: {
-          t.set(((StringObjectInspector)oi).getPrimitiveJavaObject(o));
-          return t;
-        }
-        default: {
-          throw new RuntimeException("Hive 2 Internal error: type = "
-              + oi.getTypeName());
-        }
-      }
-    }
-
-    public Text evaluate(FloatWritable i)  {
-      if (i == null) {
-        return null;
-      } else {
-        t.set(i.toString());
-        return t;
-      }
-    }
-    
-    public Text evaluate(DoubleWritable i)  {
-      if (i == null) {
-        return null;
-      } else {
-        t.set(i.toString());
-        return t;
-      }
-    }
 
-  }
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableBooleanObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableBooleanObjectInspector.java
new file mode 100644
index 0000000000..c8fd2ecd6c
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableBooleanObjectInspector.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.objectinspector.primitive;
+
+
+/**
+ * A SettableBooleanObjectInspector can set a boolean value to an object.
+ */
+public interface SettableBooleanObjectInspector extends BooleanObjectInspector {
+
+  /**
+   * Set the object with the value. 
+   */
+  public void set(Object o, boolean value);
+  
+  /**
+   * Create an object with the value.
+   */
+  public Object create(boolean value);
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableByteObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableByteObjectInspector.java
new file mode 100644
index 0000000000..a70f5b53fe
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableByteObjectInspector.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.objectinspector.primitive;
+
+
+/**
+ * A SettableByteObjectInspector can set a byte value to an object.
+ */
+public interface SettableByteObjectInspector extends ByteObjectInspector {
+
+  /**
+   * Set the object with the value. 
+   */
+  public void set(Object o, byte value);
+  
+  /**
+   * Create an object with the value.
+   */
+  public Object create(byte value);
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableDoubleObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableDoubleObjectInspector.java
new file mode 100644
index 0000000000..62fddc2174
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableDoubleObjectInspector.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.objectinspector.primitive;
+
+
+/**
+ * A SettableDoubleObjectInspector can set a double value to an object.
+ */
+public interface SettableDoubleObjectInspector extends DoubleObjectInspector {
+
+  /**
+   * Set the object with the value. 
+   */
+  public void set(Object o, double value);
+  
+  /**
+   * Create an object with the value.
+   */
+  public Object create(double value);
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableFloatObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableFloatObjectInspector.java
new file mode 100644
index 0000000000..331e58c839
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableFloatObjectInspector.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.objectinspector.primitive;
+
+
+/**
+ * A SettableFloatObjectInspector can set a float value to an object.
+ */
+public interface SettableFloatObjectInspector extends FloatObjectInspector {
+
+  /**
+   * Set the object with the value. 
+   */
+  public void set(Object o, float value);
+  
+  /**
+   * Create an object with the value.
+   */
+  public Object create(float value);
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableIntObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableIntObjectInspector.java
new file mode 100644
index 0000000000..85e606b641
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableIntObjectInspector.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.objectinspector.primitive;
+
+
+/**
+ * A SettableIntObjectInspector can set an int value to an object.
+ */
+public interface SettableIntObjectInspector extends IntObjectInspector {
+
+  /**
+   * Set the object with the value. 
+   */
+  public void set(Object o, int value);
+  
+  /**
+   * Create an object with the value.
+   */
+  public Object create(int value);
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableLongObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableLongObjectInspector.java
new file mode 100644
index 0000000000..ba50636cea
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableLongObjectInspector.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.objectinspector.primitive;
+
+
+/**
+ * A SettableLongObjectInspector can set a long value to an object.
+ */
+public interface SettableLongObjectInspector extends LongObjectInspector {
+
+  /**
+   * Set the object with the value. 
+   */
+  public void set(Object o, long value);
+  
+  /**
+   * Create an object with the value.
+   */
+  public Object create(long value);
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableShortObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableShortObjectInspector.java
new file mode 100644
index 0000000000..0c3412adcd
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableShortObjectInspector.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.objectinspector.primitive;
+
+
+/**
+ * A SettableShortObjectInspector can set a short value to an object.
+ */
+public interface SettableShortObjectInspector extends ShortObjectInspector {
+
+  /**
+   * Set the object with the value. 
+   */
+  public void set(Object o, short value);
+  
+  /**
+   * Create an object with the value.
+   */
+  public Object create(short value);
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableStringObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableStringObjectInspector.java
new file mode 100644
index 0000000000..485844b974
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/SettableStringObjectInspector.java
@@ -0,0 +1,47 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.objectinspector.primitive;
+
+import org.apache.hadoop.io.Text;
+
+
+/**
+ * A SettableStringObjectInspector can set a string value to an object.
+ */
+public interface SettableStringObjectInspector extends StringObjectInspector {
+
+  /**
+   * Set the object with the value. 
+   */
+  public void set(Object o, Text value);
+  
+  /**
+   * Set the object with the value. 
+   */
+  public void set(Object o, String value);
+  
+  /**
+   * Create an object with the value.
+   */
+  public Object create(Text value);
+
+  /**
+   * Create an object with the value.
+   */
+  public Object create(String value);
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableBooleanObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableBooleanObjectInspector.java
index 2a4b4ca373..9d02c14133 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableBooleanObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableBooleanObjectInspector.java
@@ -24,7 +24,7 @@
  * A WritableBooleanObjectInspector inspects a BooleanWritable Object.
  */
 public class WritableBooleanObjectInspector extends AbstractPrimitiveWritableObjectInspector 
-implements BooleanObjectInspector{
+implements SettableBooleanObjectInspector{
 
   WritableBooleanObjectInspector() {
     super(PrimitiveObjectInspectorUtils.booleanTypeEntry);
@@ -44,4 +44,14 @@ public Object copyObject(Object o) {
   public Object getPrimitiveJavaObject(Object o) {
     return o == null ? null : Boolean.valueOf(((BooleanWritable)o).get());
   }
+
+  @Override
+  public Object create(boolean value) {
+    return new BooleanWritable(value);
+  }
+
+  @Override
+  public void set(Object o, boolean value) {
+    ((BooleanWritable)o).set(value);
+  }
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableByteObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableByteObjectInspector.java
index 603d220efa..ce7c08e4d0 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableByteObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableByteObjectInspector.java
@@ -18,13 +18,14 @@
 package org.apache.hadoop.hive.serde2.objectinspector.primitive;
 
 import org.apache.hadoop.hive.serde2.io.ByteWritable;
+import org.apache.hadoop.io.BooleanWritable;
 
 
 /**
  * A WritableByteObjectInspector inspects a ByteWritable Object.
  */
 public class WritableByteObjectInspector extends AbstractPrimitiveWritableObjectInspector 
-implements ByteObjectInspector{
+implements SettableByteObjectInspector{
 
   WritableByteObjectInspector() {
     super(PrimitiveObjectInspectorUtils.byteTypeEntry);
@@ -44,4 +45,14 @@ public Object copyObject(Object o) {
   public Object getPrimitiveJavaObject(Object o) {
     return o == null ? null : Byte.valueOf(((ByteWritable)o).get());
   }
+  
+  @Override
+  public Object create(byte value) {
+    return new ByteWritable(value);
+  }
+
+  @Override
+  public void set(Object o, byte value) {
+    ((ByteWritable)o).set(value);
+  }
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableDoubleObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableDoubleObjectInspector.java
index 7bd96c6a50..0d99647cc6 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableDoubleObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableDoubleObjectInspector.java
@@ -17,6 +17,7 @@
  */
 package org.apache.hadoop.hive.serde2.objectinspector.primitive;
 
+import org.apache.hadoop.hive.serde2.io.ByteWritable;
 import org.apache.hadoop.hive.serde2.io.DoubleWritable;
 
 
@@ -24,7 +25,7 @@
  * A WritableDoubleObjectInspector inspects a DoubleWritable Object.
  */
 public class WritableDoubleObjectInspector extends AbstractPrimitiveWritableObjectInspector 
-implements DoubleObjectInspector{
+implements SettableDoubleObjectInspector{
 
   WritableDoubleObjectInspector() {
     super(PrimitiveObjectInspectorUtils.doubleTypeEntry);
@@ -44,4 +45,15 @@ public Object copyObject(Object o) {
   public Object getPrimitiveJavaObject(Object o) {
     return o == null ? null : Double.valueOf(((DoubleWritable)o).get());
   }
+
+  @Override
+  public Object create(double value) {
+    return new DoubleWritable(value);
+  }
+
+  @Override
+  public void set(Object o, double value) {
+    ((DoubleWritable)o).set(value);
+  }
+  
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableFloatObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableFloatObjectInspector.java
index d2c76391ff..26f0016283 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableFloatObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableFloatObjectInspector.java
@@ -17,13 +17,14 @@
  */
 package org.apache.hadoop.hive.serde2.objectinspector.primitive;
 
+import org.apache.hadoop.hive.serde2.io.DoubleWritable;
 import org.apache.hadoop.io.FloatWritable;
 
 /**
  * A FloatObjectInspector inspects a FloatWritable Object.
  */
 public class WritableFloatObjectInspector extends AbstractPrimitiveWritableObjectInspector 
-implements FloatObjectInspector{
+implements SettableFloatObjectInspector{
 
   WritableFloatObjectInspector() {
     super(PrimitiveObjectInspectorUtils.floatTypeEntry);
@@ -43,4 +44,14 @@ public Object copyObject(Object o) {
   public Object getPrimitiveJavaObject(Object o) {
     return o == null ? null : Float.valueOf(((FloatWritable)o).get());
   }
+
+  @Override
+  public Object create(float value) {
+    return new FloatWritable(value);
+  }
+
+  @Override
+  public void set(Object o, float value) {
+    ((FloatWritable)o).set(value);
+  }
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableIntObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableIntObjectInspector.java
index efb430102c..944359d184 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableIntObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableIntObjectInspector.java
@@ -17,6 +17,7 @@
  */
 package org.apache.hadoop.hive.serde2.objectinspector.primitive;
 
+import org.apache.hadoop.io.FloatWritable;
 import org.apache.hadoop.io.IntWritable;
 
 
@@ -24,7 +25,7 @@
  * A WritableIntObjectInspector inspects a IntWritable Object.
  */
 public class WritableIntObjectInspector extends AbstractPrimitiveWritableObjectInspector 
-implements IntObjectInspector{
+implements SettableIntObjectInspector{
 
   WritableIntObjectInspector() {
     super(PrimitiveObjectInspectorUtils.intTypeEntry);
@@ -44,4 +45,14 @@ public Object copyObject(Object o) {
   public Object getPrimitiveJavaObject(Object o) {
     return o == null ? null : Integer.valueOf(((IntWritable)o).get());
   }
+  
+  @Override
+  public Object create(int value) {
+    return new IntWritable(value);
+  }
+
+  @Override
+  public void set(Object o, int value) {
+    ((IntWritable)o).set(value);
+  }
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableLongObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableLongObjectInspector.java
index cf217a3f1d..0ef643f219 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableLongObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableLongObjectInspector.java
@@ -17,6 +17,7 @@
  */
 package org.apache.hadoop.hive.serde2.objectinspector.primitive;
 
+import org.apache.hadoop.io.IntWritable;
 import org.apache.hadoop.io.LongWritable;
 
 
@@ -24,7 +25,7 @@
  * A WritableLongObjectInspector inspects a LongWritable Object.
  */
 public class WritableLongObjectInspector extends AbstractPrimitiveWritableObjectInspector 
-implements LongObjectInspector{
+implements SettableLongObjectInspector{
 
   WritableLongObjectInspector() {
     super(PrimitiveObjectInspectorUtils.longTypeEntry);
@@ -44,4 +45,15 @@ public Object copyObject(Object o) {
   public Object getPrimitiveJavaObject(Object o) {
     return o == null ? null : Long.valueOf(((LongWritable)o).get());
   }
+  
+  @Override
+  public Object create(long value) {
+    return new LongWritable(value);
+  }
+
+  @Override
+  public void set(Object o, long value) {
+    ((LongWritable)o).set(value);
+  }
+  
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableShortObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableShortObjectInspector.java
index d92c2c94c9..dafe17f9d5 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableShortObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableShortObjectInspector.java
@@ -18,13 +18,14 @@
 package org.apache.hadoop.hive.serde2.objectinspector.primitive;
 
 import org.apache.hadoop.hive.serde2.io.ShortWritable;
+import org.apache.hadoop.io.LongWritable;
 
 
 /**
  * A WritableShortObjectInspector inspects a ShortWritable Object.
  */
 public class WritableShortObjectInspector extends AbstractPrimitiveWritableObjectInspector 
-implements ShortObjectInspector{
+implements SettableShortObjectInspector{
 
   WritableShortObjectInspector() {
     super(PrimitiveObjectInspectorUtils.shortTypeEntry);
@@ -44,4 +45,15 @@ public Object copyObject(Object o) {
   public Object getPrimitiveJavaObject(Object o) {
     return o == null ? null : Short.valueOf(((ShortWritable)o).get());
   }
+  
+  @Override
+  public Object create(short value) {
+    return new ShortWritable(value);
+  }
+
+  @Override
+  public void set(Object o, short value) {
+    ((ShortWritable)o).set(value);
+  }
+  
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableStringObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableStringObjectInspector.java
index 62a63bdf3e..2b82229cbf 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableStringObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableStringObjectInspector.java
@@ -24,7 +24,7 @@
  * A WritableStringObjectInspector inspects a Text Object.
  */
 public class WritableStringObjectInspector extends AbstractPrimitiveWritableObjectInspector 
-implements StringObjectInspector{
+implements SettableStringObjectInspector{
 
   WritableStringObjectInspector() {
     super(PrimitiveObjectInspectorUtils.stringTypeEntry);
@@ -45,4 +45,38 @@ public String getPrimitiveJavaObject(Object o) {
     return o == null ? null : ((Text)o).toString();
   }
 
+  @Override
+  public Object create(Text value) {
+    Text r = new Text();
+    if (value != null) {
+      r.set(value);
+    }
+    return r;
+  }
+
+  @Override
+  public Object create(String value) {
+    Text r = new Text();
+    if (value != null) {
+      r.set(value);
+    }
+    return r;
+  }
+
+  @Override
+  public void set(Object o, Text value) {
+    Text r = (Text)o;
+    if (value != null) {
+      r.set(value);
+    }
+  }
+
+  @Override
+  public void set(Object o, String value) {
+    Text r = (Text)o;
+    if (value != null) {
+      r.set(value);
+    }
+  }
+
 }
diff --git a/serde/src/test/org/apache/hadoop/hive/serde2/objectinspector/TestObjectInspectorConverters.java b/serde/src/test/org/apache/hadoop/hive/serde2/objectinspector/TestObjectInspectorConverters.java
new file mode 100644
index 0000000000..82bbd6e3ff
--- /dev/null
+++ b/serde/src/test/org/apache/hadoop/hive/serde2/objectinspector/TestObjectInspectorConverters.java
@@ -0,0 +1,154 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.objectinspector;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.hadoop.hive.serde2.io.ByteWritable;
+import org.apache.hadoop.hive.serde2.io.DoubleWritable;
+import org.apache.hadoop.hive.serde2.io.ShortWritable;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorConverters.Converter;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
+import org.apache.hadoop.hive.serde2.thrift.test.Complex;
+import org.apache.hadoop.hive.serde2.thrift.test.IntString;
+import org.apache.hadoop.io.BooleanWritable;
+import org.apache.hadoop.io.FloatWritable;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.LongWritable;
+import org.apache.hadoop.io.Text;
+
+import junit.framework.TestCase;
+
+public class TestObjectInspectorConverters extends TestCase {
+
+  public void testObjectInspectorConverters() throws Throwable {
+    try {
+      // Boolean
+      Converter booleanConverter = ObjectInspectorConverters.getConverter(
+          PrimitiveObjectInspectorFactory.javaIntObjectInspector,
+          PrimitiveObjectInspectorFactory.writableBooleanObjectInspector);
+      assertEquals("BooleanConverter", 
+          new BooleanWritable(false),
+          booleanConverter.convert(Integer.valueOf(0))
+          );
+      assertEquals("BooleanConverter", 
+          new BooleanWritable(true),
+          booleanConverter.convert(Integer.valueOf(1))
+          );
+      
+      // Byte
+      Converter byteConverter = ObjectInspectorConverters.getConverter(
+          PrimitiveObjectInspectorFactory.javaIntObjectInspector,
+          PrimitiveObjectInspectorFactory.writableByteObjectInspector);
+      assertEquals("ByteConverter", 
+          new ByteWritable((byte)0),
+          byteConverter.convert(Integer.valueOf(0))
+          );
+      assertEquals("ByteConverter", 
+          new ByteWritable((byte)1),
+          byteConverter.convert(Integer.valueOf(1))
+          );
+      
+      // Short
+      Converter shortConverter = ObjectInspectorConverters.getConverter(
+          PrimitiveObjectInspectorFactory.javaIntObjectInspector,
+          PrimitiveObjectInspectorFactory.writableShortObjectInspector);
+      assertEquals("ShortConverter", 
+          new ShortWritable((short)0),
+          shortConverter.convert(Integer.valueOf(0))
+          );
+      assertEquals("ShortConverter", 
+          new ShortWritable((short)1),
+          shortConverter.convert(Integer.valueOf(1))
+          );
+      
+      // Int
+      Converter intConverter = ObjectInspectorConverters.getConverter(
+          PrimitiveObjectInspectorFactory.javaIntObjectInspector,
+          PrimitiveObjectInspectorFactory.writableIntObjectInspector);
+      assertEquals("IntConverter", 
+          new IntWritable((int)0),
+          intConverter.convert(Integer.valueOf(0))
+          );
+      assertEquals("IntConverter", 
+          new IntWritable((int)1),
+          intConverter.convert(Integer.valueOf(1))
+          );
+      
+      // Long
+      Converter longConverter = ObjectInspectorConverters.getConverter(
+          PrimitiveObjectInspectorFactory.javaIntObjectInspector,
+          PrimitiveObjectInspectorFactory.writableLongObjectInspector);
+      assertEquals("LongConverter", 
+          new LongWritable((long)0),
+          longConverter.convert(Integer.valueOf(0))
+          );
+      assertEquals("LongConverter", 
+          new LongWritable((long)1),
+          longConverter.convert(Integer.valueOf(1))
+          );
+      
+      // Float
+      Converter floatConverter = ObjectInspectorConverters.getConverter(
+          PrimitiveObjectInspectorFactory.javaIntObjectInspector,
+          PrimitiveObjectInspectorFactory.writableFloatObjectInspector);
+      assertEquals("LongConverter", 
+          new FloatWritable((float)0),
+          floatConverter.convert(Integer.valueOf(0))
+          );
+      assertEquals("LongConverter", 
+          new FloatWritable((float)1),
+          floatConverter.convert(Integer.valueOf(1))
+          );
+      
+      // Double
+      Converter doubleConverter = ObjectInspectorConverters.getConverter(
+          PrimitiveObjectInspectorFactory.javaIntObjectInspector,
+          PrimitiveObjectInspectorFactory.writableDoubleObjectInspector);
+      assertEquals("DoubleConverter", 
+          new DoubleWritable((double)0),
+          doubleConverter.convert(Integer.valueOf(0))
+          );
+      assertEquals("DoubleConverter", 
+          new DoubleWritable((double)1),
+          doubleConverter.convert(Integer.valueOf(1))
+          );
+      
+      // Text
+      Converter textConverter = ObjectInspectorConverters.getConverter(
+          PrimitiveObjectInspectorFactory.javaIntObjectInspector,
+          PrimitiveObjectInspectorFactory.writableStringObjectInspector);
+      assertEquals("TextConverter", 
+          new Text("0"),
+          textConverter.convert(Integer.valueOf(0))
+          );
+      assertEquals("TextConverter", 
+          new Text("1"),
+          textConverter.convert(Integer.valueOf(1))
+          );
+      
+    } catch (Throwable e) {
+      e.printStackTrace();
+      throw e;
+    }
+    
+  }  
+}
