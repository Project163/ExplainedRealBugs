diff --git a/ql/src/java/org/apache/hadoop/hive/ql/io/CombineHiveInputFormat.java b/ql/src/java/org/apache/hadoop/hive/ql/io/CombineHiveInputFormat.java
index a4c56a1787..6eb51dd41d 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/io/CombineHiveInputFormat.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/io/CombineHiveInputFormat.java
@@ -435,14 +435,16 @@ private List<InputSplitShim> sampleSplits(List<InputSplitShim> splits) {
     List<InputSplitShim> retLists = new ArrayList<InputSplitShim>();
     Map<String, ArrayList<InputSplitShim>> aliasToSplitList = new HashMap<String, ArrayList<InputSplitShim>>();
     Map<String, ArrayList<String>> pathToAliases = mrwork.getPathToAliases();
+    Map<String, ArrayList<String>> pathToAliasesNoScheme = removeScheme(pathToAliases);
 
     // Populate list of exclusive splits for every sampled alias
     //
     for (InputSplitShim split : splits) {
       String alias = null;
       for (Path path : split.getPaths()) {
+        boolean schemeless = path.toUri().getScheme() == null;
         List<String> l = HiveFileFormatUtils.doGetAliasesFromPath(
-            pathToAliases, path);
+            schemeless ? pathToAliasesNoScheme : pathToAliases, path);
         // a path for a split unqualified the split from being sampled if:
         // 1. it serves more than one alias
         // 2. the alias it serves is not sampled
@@ -500,6 +502,15 @@ private List<InputSplitShim> sampleSplits(List<InputSplitShim> splits) {
     return retLists;
   }
 
+  Map<String, ArrayList<String>> removeScheme(Map<String, ArrayList<String>> pathToAliases) {
+    Map<String, ArrayList<String>> result = new HashMap<String, ArrayList<String>>();
+    for (Map.Entry <String, ArrayList<String>> entry : pathToAliases.entrySet()) {
+      String newKey = new Path(entry.getKey()).toUri().getPath();
+      result.put(newKey, entry.getValue());
+    }
+    return result;
+  }
+
   /**
    * Create a generic Hive RecordReader than can iterate over all chunks in a
    * CombinedFileSplit.
