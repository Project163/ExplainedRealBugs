diff --git a/jdbc/src/java/org/apache/hadoop/hive/jdbc/HiveDatabaseMetaData.java b/jdbc/src/java/org/apache/hadoop/hive/jdbc/HiveDatabaseMetaData.java
index d1ff50904e..0e106beea1 100644
--- a/jdbc/src/java/org/apache/hadoop/hive/jdbc/HiveDatabaseMetaData.java
+++ b/jdbc/src/java/org/apache/hadoop/hive/jdbc/HiveDatabaseMetaData.java
@@ -18,8 +18,6 @@
 
 package org.apache.hadoop.hive.jdbc;
 
-import java.io.IOException;
-import java.net.URL;
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.ResultSet;
@@ -31,7 +29,6 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.jar.Attributes;
-import java.util.jar.Manifest;
 
 import org.apache.hadoop.hive.metastore.TableType;
 import org.apache.hadoop.hive.metastore.api.FieldSchema;
@@ -48,6 +45,8 @@ public class HiveDatabaseMetaData implements java.sql.DatabaseMetaData {
   private final HiveInterface client;
   private static final String CATALOG_SEPARATOR = ".";
 
+  private static final char SEARCH_STRING_ESCAPE = '\\';
+
   //  The maximum column length = MFieldSchema.FNAME in metastore/src/model/package.jdo
   private static final int maxColumnNameLength = 128;
 
@@ -140,11 +139,44 @@ public ResultSet getColumnPrivileges(String catalog, String schema,
     throw new SQLException("Method not supported");
   }
 
+  /**
+   * Convert a pattern containing JDBC catalog search wildcards into
+   * Java regex patterns.
+   *
+   * @param pattern input which may contain '%' or '_' wildcard characters, or
+   * these characters escaped using {@link #getSearchStringEscape()}.
+   * @return replace %/_ with regex search characters, also handle escaped
+   * characters.
+   */
   private String convertPattern(final String pattern) {
     if (pattern==null) {
       return ".*";
     } else {
-      return pattern.replace("%", ".*").replace("_", ".");
+      StringBuilder result = new StringBuilder(pattern.length());
+
+      boolean escaped = false;
+      for (int i = 0, len = pattern.length(); i < len; i++) {
+        char c = pattern.charAt(i);
+        if (escaped) {
+          if (c != SEARCH_STRING_ESCAPE) {
+            escaped = false;
+          }
+          result.append(c);
+        } else {
+          if (c == SEARCH_STRING_ESCAPE) {
+            escaped = true;
+            continue;
+          } else if (c == '%') {
+            result.append(".*");
+          } else if (c == '_') {
+            result.append('.');
+          } else {
+            result.append(c);
+          }
+        }
+      }
+
+      return result.toString();
     }
   }
 
@@ -488,7 +520,7 @@ public boolean next() throws SQLException {
   }
 
   public String getSearchStringEscape() throws SQLException {
-    throw new SQLException("Method not supported");
+    return String.valueOf(SEARCH_STRING_ESCAPE);
   }
 
   public String getStringFunctions() throws SQLException {
diff --git a/jdbc/src/test/org/apache/hadoop/hive/jdbc/TestJdbcDriver.java b/jdbc/src/test/org/apache/hadoop/hive/jdbc/TestJdbcDriver.java
index 591fa1fabd..91af351c89 100644
--- a/jdbc/src/test/org/apache/hadoop/hive/jdbc/TestJdbcDriver.java
+++ b/jdbc/src/test/org/apache/hadoop/hive/jdbc/TestJdbcDriver.java
@@ -44,15 +44,15 @@
  *
  */
 public class TestJdbcDriver extends TestCase {
-  private static String driverName = "org.apache.hadoop.hive.jdbc.HiveDriver";
-  private static String tableName = "testHiveJdbcDriverTable";
-  private static String tableComment = "Simple table";
-  private static String viewName = "testHiveJdbcDriverView";
-  private static String viewComment = "Simple view";
-  private static String partitionedTableName = "testHiveJdbcDriverPartitionedTable";
-  private static String partitionedTableComment = "Partitioned table";
-  private static String dataTypeTableName = "testDataTypeTable";
-  private static String dataTypeTableComment = "Table with many column data types";
+  private static final String driverName = "org.apache.hadoop.hive.jdbc.HiveDriver";
+  private static final String tableName = "testHiveJdbcDriver_Table";
+  private static final String tableComment = "Simple table";
+  private static final String viewName = "testHiveJdbcDriverView";
+  private static final String viewComment = "Simple view";
+  private static final String partitionedTableName = "testHiveJdbcDriverPartitionedTable";
+  private static final String partitionedTableComment = "Partitioned table";
+  private static final String dataTypeTableName = "testDataTypeTable";
+  private static final String dataTypeTableComment = "Table with many column data types";
   private final HiveConf conf;
   private final Path dataFilePath;
   private final Path dataTypeDataFilePath;
@@ -97,7 +97,8 @@ protected void setUp() throws Exception {
 
     // create table
     ResultSet res = stmt.executeQuery("create table " + tableName
-        + " (key int comment 'the key', value string) comment '"+tableComment+"'");
+        + " (under_col int comment 'the under column', value string) comment '"
+        + tableComment + "'");
     assertFalse(res.next());
 
     // load data
@@ -115,7 +116,7 @@ protected void setUp() throws Exception {
     }
 
     res = stmt.executeQuery("create table " + partitionedTableName
-        + " (key int, value string) comment '"+partitionedTableComment
+        + " (under_col int, value string) comment '"+partitionedTableComment
             +"' partitioned by (dt STRING)");
     assertFalse(res.next());
 
@@ -421,8 +422,8 @@ private void doTestSelectAll(String tableName, int maxRows, int fetchSize) throw
     while (moreRow) {
       try {
         i++;
-        assertEquals(res.getInt(1), res.getInt("key"));
-        assertEquals(res.getString(1), res.getString("key"));
+        assertEquals(res.getInt(1), res.getInt("under_col"));
+        assertEquals(res.getString(1), res.getString("under_col"));
         assertEquals(res.getString(2), res.getString("value"));
         assertFalse("Last result value was not null", res.wasNull());
         assertNull("No warnings should be found on ResultSet", res
@@ -478,7 +479,7 @@ public void testErrorMessages() throws SQLException {
     doTestErrorCase("SELECT invalid_column FROM " + tableName,
         "Invalid table alias or column reference", invalidSyntaxSQLState,
         parseErrorCode);
-    doTestErrorCase("SELECT invalid_function(key) FROM " + tableName,
+    doTestErrorCase("SELECT invalid_function(under_col) FROM " + tableName,
         "Invalid function", invalidSyntaxSQLState, parseErrorCode);
 
     // TODO: execute errors like this currently don't return good messages (i.e.
@@ -533,14 +534,17 @@ public void testShowTables() throws SQLException {
 
   public void testMetaDataGetTables() throws SQLException {
     Map<String, Object[]> tests = new HashMap<String, Object[]>();
-    tests.put("test%jdbc%", new Object[]{"testhivejdbcdriverpartitionedtable"
-            , "testhivejdbcdrivertable"
+    tests.put("test%jdbc%", new Object[]{"testhivejdbcdriver_table"
+            , "testhivejdbcdriverpartitionedtable"
             , "testhivejdbcdriverview"});
-    tests.put("%jdbcdrivertable", new Object[]{"testhivejdbcdrivertable"});
-    tests.put("testhivejdbcdrivertable", new Object[]{"testhivejdbcdrivertable"});
-    tests.put("test_ivejdbcdri_ertable", new Object[]{"testhivejdbcdrivertable"});
-    tests.put("%jdbc%", new Object[]{"testhivejdbcdriverpartitionedtable"
-            , "testhivejdbcdrivertable"
+    tests.put("%jdbcdriver\\_table", new Object[]{"testhivejdbcdriver_table"});
+    tests.put("testhivejdbcdriver\\_table", new Object[]{"testhivejdbcdriver_table"});
+    tests.put("test_ivejdbcdri_er\\_table", new Object[]{"testhivejdbcdriver_table"});
+    tests.put("test_ivejdbcdri_er_table", new Object[]{"testhivejdbcdriver_table"});
+    tests.put("test_ivejdbcdri_er%table", new Object[]{
+        "testhivejdbcdriver_table", "testhivejdbcdriverpartitionedtable" });
+    tests.put("%jdbc%", new Object[]{ "testhivejdbcdriver_table"
+            , "testhivejdbcdriverpartitionedtable"
             , "testhivejdbcdriverview"});
     tests.put("", new Object[]{});
 
@@ -625,12 +629,15 @@ public void testMetaDataGetTableTypes() throws SQLException {
 
   public void testMetaDataGetColumns() throws SQLException {
     Map<String[], Integer> tests = new HashMap<String[], Integer>();
-    tests.put(new String[]{"testhivejdbcdrivertable", null}, 2);
+    tests.put(new String[]{"testhivejdbcdriver\\_table", null}, 2);
     tests.put(new String[]{"testhivejdbc%", null}, 6);
-    tests.put(new String[]{"%jdbcdrivertable", null}, 2);
-    tests.put(new String[]{"%jdbcdrivertable%", "key"}, 1);
-    tests.put(new String[]{"%jdbcdrivertable%", "ke_"}, 1);
-    tests.put(new String[]{"%jdbcdrivertable%", "ke%"}, 1);
+    tests.put(new String[]{"%jdbcdriver\\_table", null}, 2);
+    tests.put(new String[]{"%jdbcdriver\\_table%", "under\\_col"}, 1);
+    tests.put(new String[]{"%jdbcdriver\\_table%", "under\\_co_"}, 1);
+    tests.put(new String[]{"%jdbcdriver\\_table%", "under_col"}, 1);
+    tests.put(new String[]{"%jdbcdriver\\_table%", "und%"}, 1);
+    tests.put(new String[]{"%jdbcdriver\\_table%", "%"}, 2);
+    tests.put(new String[]{"%jdbcdriver\\_table%", "_%"}, 2);
 
     for (String[] checkPattern: tests.keySet()) {
       ResultSet rs = (ResultSet)con.getMetaData().getColumns(null, null
@@ -641,7 +648,7 @@ public void testMetaDataGetColumns() throws SQLException {
         int ordinalPos = rs.getInt("ORDINAL_POSITION");
         switch(cnt) {
           case 0:
-            assertEquals("Wrong column name found", "key", columnname);
+            assertEquals("Wrong column name found", "under_col", columnname);
             assertEquals("Wrong ordinal position found", ordinalPos, 1);
             break;
           case 1:
@@ -705,8 +712,8 @@ public void testDescribeTable() throws SQLException {
     ResultSet res = stmt.executeQuery("describe " + tableName);
 
     res.next();
-    assertEquals("Column name 'key' not found", "key", res.getString(1));
-    assertEquals("Column type 'int' for column key not found", "int", res
+    assertEquals("Column name 'under_col' not found", "under_col", res.getString(1));
+    assertEquals("Column type 'under_col' for column under_col not found", "int", res
         .getString(2));
     res.next();
     assertEquals("Column name 'value' not found", "value", res.getString(1));
