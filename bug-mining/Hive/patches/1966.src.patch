diff --git a/common/src/java/org/apache/hadoop/hive/common/type/Decimal128.java b/common/src/java/org/apache/hadoop/hive/common/type/Decimal128.java
index 9d256209d1..9fe3dcf6ce 100644
--- a/common/src/java/org/apache/hadoop/hive/common/type/Decimal128.java
+++ b/common/src/java/org/apache/hadoop/hive/common/type/Decimal128.java
@@ -1724,6 +1724,67 @@ private static void checkScaleRange(short scale) {
     }
   }
 
+  /**
+   * Temporary array used in {@link #getHiveDecimalString}
+   */
+  private int [] tmpArray = new int[2];
+
+  /**
+   * Returns the string representation of this value. It discards the trailing zeros
+   * in the fractional part to match the HiveDecimal's string representation. However,
+   * don't use this string representation for the reconstruction of the object.
+   *
+   * @return string representation of this value
+   */
+  public String getHiveDecimalString() {
+    if (this.signum == 0) {
+      return "0";
+    }
+
+    StringBuilder buf = new StringBuilder(50);
+    if (this.signum < 0) {
+      buf.append('-');
+    }
+
+    char [] unscaled = this.unscaledValue.getDigitsArray(tmpArray);
+    int unscaledLength = tmpArray[0];
+    int trailingZeros = tmpArray[1];
+    int numIntegerDigits = unscaledLength - this.scale;
+    if (numIntegerDigits > 0) {
+
+      // write out integer part first
+      // then write out fractional part
+      for (int i=0; i < numIntegerDigits; i++) {
+        buf.append(unscaled[i]);
+      }
+
+      if (this.scale > trailingZeros) {
+        buf.append('.');
+        for (int i = numIntegerDigits; i < (unscaledLength - trailingZeros); i++) {
+          buf.append(unscaled[i]);
+        }
+      }
+    } else {
+
+      // no integer part
+      buf.append('0');
+
+      if (this.scale > trailingZeros) {
+
+        // fractional part has, starting with zeros
+        buf.append('.');
+        for (int i = unscaledLength; i < this.scale; ++i) {
+          buf.append('0');
+        }
+        for (int i = 0; i < (unscaledLength - trailingZeros); i++) {
+          buf.append(unscaled[i]);
+        }
+      }
+    }
+
+    return new String(buf);
+  }
+
   /**
    * Returns the formal string representation of this value. Unlike the debug
    * string returned by {@link #toString()}, this method returns a string that
diff --git a/common/src/java/org/apache/hadoop/hive/common/type/UnsignedInt128.java b/common/src/java/org/apache/hadoop/hive/common/type/UnsignedInt128.java
index de747e4747..7fbf77c39a 100644
--- a/common/src/java/org/apache/hadoop/hive/common/type/UnsignedInt128.java
+++ b/common/src/java/org/apache/hadoop/hive/common/type/UnsignedInt128.java
@@ -982,6 +982,63 @@ public String toFormalString() {
     }
   }
 
+  /**
+   * Similar to {@link #toFormalString()} but returns an array of digits
+   * instead of string. The length of the array and the count of trailing
+   * zeros are returned in the array passed at first and second positions
+   * respectively.
+   * @param meta Array of size two that is populated with length of the returned array
+   *             and the count of trailing zeros.
+   * @return Digits of the this value
+   * @throws NullPointerException if meta is null.
+   * @throws ArrayIndexOutOfBoundsException if meta is less than size two.
+   */
+  public char [] getDigitsArray(int [] meta) {
+    char[] buf = new char[MAX_DIGITS + 1];
+    int bufCount = 0;
+    int nonZeroBufCount = 0;
+    int trailingZeros = 0;
+
+    final int tenScale = SqlMathUtil.MAX_POWER_TEN_INT31;
+    final int tenPower = SqlMathUtil.POWER_TENS_INT31[tenScale];
+    UnsignedInt128 tmp = new UnsignedInt128(this);
+
+    while (!tmp.isZero()) {
+      int remainder = tmp.divideDestructive(tenPower);
+      for (int i = 0; i < tenScale && bufCount < buf.length; ++i) {
+        int digit = remainder % 10;
+        remainder /= 10;
+        buf[bufCount] = (char) (digit + '0');
+        ++bufCount;
+        if (digit != 0) {
+          nonZeroBufCount = bufCount;
+        }
+        if (nonZeroBufCount == 0) {
+
+          // Count zeros until first non-zero digit is encountered.
+          trailingZeros++;
+        }
+      }
+    }
+
+    if (bufCount == 0) {
+      meta[0] = 1;
+      meta[1] = 1;
+      buf[0] = '0';
+      return buf;
+    } else {
+      // Reverse in place
+      for (int i = 0, j = nonZeroBufCount - 1; i < j; i++, j--) {
+        char t = buf[i];
+        buf[i] = buf[j];
+        buf[j] = t;
+      }
+      meta[0] = nonZeroBufCount;
+      meta[1] = trailingZeros;
+      return buf;
+    }
+  }
+
   @Override
   public String toString() {
     StringBuilder str = new StringBuilder();
diff --git a/common/src/test/org/apache/hadoop/hive/common/type/TestDecimal128.java b/common/src/test/org/apache/hadoop/hive/common/type/TestDecimal128.java
index debc2707a7..409a13aa5c 100644
--- a/common/src/test/org/apache/hadoop/hive/common/type/TestDecimal128.java
+++ b/common/src/test/org/apache/hadoop/hive/common/type/TestDecimal128.java
@@ -18,7 +18,7 @@
 import static org.junit.Assert.*;
 
 import java.math.BigDecimal;
-import java.math.MathContext;
+import java.math.BigInteger;
 import java.math.RoundingMode;
 import java.util.Random;
 
@@ -26,7 +26,6 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import org.apache.hadoop.hive.common.type.UnsignedInt128;
 
 /**
  * This code was originally written for Microsoft PolyBase.
@@ -803,4 +802,56 @@ public void testToLong() {
     assertEquals(hd.longValue(), d.longValue());
   }
 
+  @Test
+  public void testToHiveDecimalString() {
+    Decimal128 d1 = new Decimal128("4134.923076923077", (short) 15);
+    assertEquals("4134.923076923077", d1.getHiveDecimalString());
+
+    Decimal128 d2 = new Decimal128("0.00923076923", (short) 15);
+    assertEquals("0.00923076923", d2.getHiveDecimalString());
+
+    Decimal128 d3 = new Decimal128("0.00923076000", (short) 15);
+    assertEquals("0.00923076", d3.getHiveDecimalString());
+
+    Decimal128 d4 = new Decimal128("4294967296.01", (short) 15);
+    assertEquals("4294967296.01", d4.getHiveDecimalString());
+
+    Decimal128 d5 = new Decimal128("4294967296.01", (short) 2);
+    assertEquals("4294967296.01", d5.getHiveDecimalString());
+
+    Decimal128 d6 = new Decimal128();
+    HiveDecimal hd1 = HiveDecimal.create(new BigInteger("42949672"));
+    d6.update(hd1.bigDecimalValue());
+    assertEquals(hd1.toString(), d6.getHiveDecimalString());
+
+    Decimal128 d7 = new Decimal128();
+    HiveDecimal hd2 = HiveDecimal.create(new BigDecimal("0.0"));
+    d7.update(hd2.bigDecimalValue());
+    assertEquals(hd2.toString(), d7.getHiveDecimalString());
+
+    Decimal128 d8 = new Decimal128();
+    HiveDecimal hd3 = HiveDecimal.create(new BigDecimal("0.00023000"));
+    d8.update(hd3.bigDecimalValue());
+    assertEquals(hd3.toString(), d8.getHiveDecimalString());
+
+    Decimal128 d9 = new Decimal128();
+    HiveDecimal hd4 = HiveDecimal.create(new BigDecimal("0.1"));
+    d9.update(hd4.bigDecimalValue());
+    assertEquals(hd4.toString(), d9.getHiveDecimalString());
+
+    Decimal128 d10 = new Decimal128();
+    HiveDecimal hd5 = HiveDecimal.create(new BigDecimal("-00.100"));
+    d10.update(hd5.bigDecimalValue());
+    assertEquals(hd5.toString(), d10.getHiveDecimalString());
+
+    Decimal128 d11 = new Decimal128();
+    HiveDecimal hd6 = HiveDecimal.create(new BigDecimal("00.1"));
+    d11.update(hd6.bigDecimalValue());
+    assertEquals(hd6.toString(), d11.getHiveDecimalString());
+
+    Decimal128 d12 = new Decimal128(27.000, (short)3);
+    HiveDecimal hd7 = HiveDecimal.create(new BigDecimal("27.000"));
+    assertEquals(hd7.toString(), d12.getHiveDecimalString());
+    assertEquals("27", hd7.toString());
+  }
 }
diff --git a/common/src/test/org/apache/hadoop/hive/common/type/TestUnsignedInt128.java b/common/src/test/org/apache/hadoop/hive/common/type/TestUnsignedInt128.java
index 9ac68fedf8..e99782e713 100644
--- a/common/src/test/org/apache/hadoop/hive/common/type/TestUnsignedInt128.java
+++ b/common/src/test/org/apache/hadoop/hive/common/type/TestUnsignedInt128.java
@@ -552,8 +552,6 @@ public void testDivideDestructiveUnsignedInt128Again() {
   public void testBigIntConversion() {
     BigInteger bigInteger = BigInteger.valueOf(0x1ABCDEF0123456L);
     UnsignedInt128 uInt128 = new UnsignedInt128(bigInteger);
-    System.out.println("Out = "+uInt128.toString());
-    System.out.println("Out = "+bigInteger.toString());
     assertEquals(bigInteger, uInt128.toBigIntegerSlow());
   }
 }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/CastDecimalToString.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/CastDecimalToString.java
index 2e8c3a431d..c0a99b79e2 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/CastDecimalToString.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/CastDecimalToString.java
@@ -38,7 +38,7 @@ public CastDecimalToString(int inputColumn, int outputColumn) {
 
   @Override
   protected void func(BytesColumnVector outV, DecimalColumnVector inV, int i) {
-    String s = inV.vector[i].toFormalString();
+    String s = inV.vector[i].getHiveDecimalString();
     byte[] b = null;
     try {
       b = s.getBytes("UTF-8");
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/CastDecimalToTimestamp.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/CastDecimalToTimestamp.java
index df7e1ee6cc..32386fe51a 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/CastDecimalToTimestamp.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/CastDecimalToTimestamp.java
@@ -53,7 +53,8 @@ public CastDecimalToTimestamp() {
   @Override
   protected void func(LongColumnVector outV, DecimalColumnVector inV,  int i) {
     tmp.update(inV.vector[i]);
-    tmp.multiplyDestructive(tenE9, (short) 0);
+    int newScale = inV.scale > 9 ? (inV.scale - 9) : 0;
+    tmp.multiplyDestructive(tenE9, (short) newScale);
 
     // set output
     outV.vector[i] = tmp.longValue();
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/exec/vector/expressions/TestVectorTypeCasts.java b/ql/src/test/org/apache/hadoop/hive/ql/exec/vector/expressions/TestVectorTypeCasts.java
index 832463d771..2a871c58ce 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/exec/vector/expressions/TestVectorTypeCasts.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/exec/vector/expressions/TestVectorTypeCasts.java
@@ -322,17 +322,17 @@ public void testCastDecimalToString() {
     expr.evaluate(b);
     BytesColumnVector r = (BytesColumnVector) b.cols[1];
 
-    byte[] v = toBytes("1.10");
+    byte[] v = toBytes("1.1");
     Assert.assertEquals(0,
         StringExpr.compare(v, 0, v.length,
             r.vector[0], r.start[0], r.length[0]));
 
-    v = toBytes("-2.20");
+    v = toBytes("-2.2");
     Assert.assertEquals(0,
         StringExpr.compare(v, 0, v.length,
             r.vector[1], r.start[1], r.length[1]));
 
-    v = toBytes("9999999999999999.00");
+    v = toBytes("9999999999999999");
     Assert.assertEquals(0,
         StringExpr.compare(v, 0, v.length,
             r.vector[2], r.start[2], r.length[2]));
diff --git a/ql/src/test/queries/clientpositive/vector_decimal_expressions.q b/ql/src/test/queries/clientpositive/vector_decimal_expressions.q
index 38934d2c4b..a74b17bd12 100644
--- a/ql/src/test/queries/clientpositive/vector_decimal_expressions.q
+++ b/ql/src/test/queries/clientpositive/vector_decimal_expressions.q
@@ -1,5 +1,5 @@
 CREATE TABLE decimal_test STORED AS ORC AS SELECT cdouble, CAST (((cdouble*22.1)/37) AS DECIMAL(20,10)) AS cdecimal1, CAST (((cdouble*9.3)/13) AS DECIMAL(23,14)) AS cdecimal2 FROM alltypesorc;
 SET hive.vectorized.execution.enabled=true;
-EXPLAIN SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10;
+EXPLAIN SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT), CAST(cdecimal2 AS STRING), CAST(cdecimal1 AS TIMESTAMP) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10;
 
-SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10;
+SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT), CAST(cdecimal2 AS STRING), CAST(cdecimal1 AS TIMESTAMP) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10;
diff --git a/ql/src/test/results/clientpositive/vector_decimal_expressions.q.out b/ql/src/test/results/clientpositive/vector_decimal_expressions.q.out
index 629f5d56d1..6bff555ef3 100644
--- a/ql/src/test/results/clientpositive/vector_decimal_expressions.q.out
+++ b/ql/src/test/results/clientpositive/vector_decimal_expressions.q.out
@@ -5,9 +5,9 @@ POSTHOOK: query: CREATE TABLE decimal_test STORED AS ORC AS SELECT cdouble, CAST
 POSTHOOK: type: CREATETABLE_AS_SELECT
 POSTHOOK: Input: default@alltypesorc
 POSTHOOK: Output: default@decimal_test
-PREHOOK: query: EXPLAIN SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10
+PREHOOK: query: EXPLAIN SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT), CAST(cdecimal2 AS STRING), CAST(cdecimal1 AS TIMESTAMP) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10
 PREHOOK: type: QUERY
-POSTHOOK: query: EXPLAIN SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10
+POSTHOOK: query: EXPLAIN SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT), CAST(cdecimal2 AS STRING), CAST(cdecimal1 AS TIMESTAMP) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10
 POSTHOOK: type: QUERY
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
@@ -24,8 +24,8 @@ STAGE PLANS:
               predicate: (((((cdecimal1 > 0) and (cdecimal1 < 12345.5678)) and (cdecimal2 <> 0)) and (cdecimal2 > 1000)) and cdouble is not null) (type: boolean)
               Statistics: Num rows: 228 Data size: 39491 Basic stats: COMPLETE Column stats: NONE
               Select Operator
-                expressions: (cdecimal1 + cdecimal2) (type: decimal(25,14)), (cdecimal1 - (2 * cdecimal2)) (type: decimal(26,14)), ((cdecimal1 + 2.34) / cdecimal2) (type: double), (cdecimal1 * (cdecimal2 / 3.4)) (type: double), (cdecimal1 % 10) (type: decimal(12,10)), UDFToInteger(cdecimal1) (type: int), UDFToShort(cdecimal2) (type: smallint), UDFToByte(cdecimal2) (type: tinyint), UDFToLong(cdecimal1) (type: bigint), UDFToBoolean(cdecimal1) (type: boolean), UDFToDouble(cdecimal2) (type: double), UDFToFloat(cdecimal1) (type: float)
-                outputColumnNames: _col0, _col1, _col2, _col3, _col4, _col5, _col6, _col7, _col8, _col9, _col10, _col11
+                expressions: (cdecimal1 + cdecimal2) (type: decimal(25,14)), (cdecimal1 - (2 * cdecimal2)) (type: decimal(26,14)), ((cdecimal1 + 2.34) / cdecimal2) (type: double), (cdecimal1 * (cdecimal2 / 3.4)) (type: double), (cdecimal1 % 10) (type: decimal(12,10)), UDFToInteger(cdecimal1) (type: int), UDFToShort(cdecimal2) (type: smallint), UDFToByte(cdecimal2) (type: tinyint), UDFToLong(cdecimal1) (type: bigint), UDFToBoolean(cdecimal1) (type: boolean), UDFToDouble(cdecimal2) (type: double), UDFToFloat(cdecimal1) (type: float), UDFToString(cdecimal2) (type: string), CAST( cdecimal1 AS TIMESTAMP) (type: timestamp)
+                outputColumnNames: _col0, _col1, _col2, _col3, _col4, _col5, _col6, _col7, _col8, _col9, _col10, _col11, _col12, _col13
                 Statistics: Num rows: 228 Data size: 39491 Basic stats: COMPLETE Column stats: NONE
                 Limit
                   Number of rows: 10
@@ -43,21 +43,21 @@ STAGE PLANS:
     Fetch Operator
       limit: 10
 
-PREHOOK: query: SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10
+PREHOOK: query: SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT), CAST(cdecimal2 AS STRING), CAST(cdecimal1 AS TIMESTAMP) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10
 PREHOOK: type: QUERY
 PREHOOK: Input: default@decimal_test
 #### A masked pattern was here ####
-POSTHOOK: query: SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10
+POSTHOOK: query: SELECT cdecimal1 + cdecimal2, cdecimal1 - (2*cdecimal2), ((cdecimal1+2.34)/cdecimal2), (cdecimal1 * (cdecimal2/3.4)), cdecimal1 % 10, CAST(cdecimal1 AS INT), CAST(cdecimal2 AS SMALLINT), CAST(cdecimal2 AS TINYINT), CAST(cdecimal1 AS BIGINT), CAST (cdecimal1 AS BOOLEAN), CAST(cdecimal2 AS DOUBLE), CAST(cdecimal1 AS FLOAT), CAST(cdecimal2 AS STRING), CAST(cdecimal1 AS TIMESTAMP) FROM decimal_test WHERE cdecimal1 > 0 AND cdecimal1 < 12345.5678 AND cdecimal2 != 0 AND cdecimal2 > 1000 AND cdouble IS NOT NULL LIMIT 10
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@decimal_test
 #### A masked pattern was here ####
-19699.417463617423	-12507.913305613346	0.8351496686995997	2.8303425077026896E7	3.6405405405	8963	10735	-17	8963	true	10735.776923076923	8963.641
-9216.339708939685	-5851.80644490647	0.8353975893550668	6195112.1797296945	3.6243243243	4193	5022	-98	4193	true	5022.715384615385	4193.6245
-6514.8403326403464	-4136.5212058211928	0.8355907765708067	3095563.9418919063	4.3864864865	2964	3550	-34	2964	true	3550.4538461538464	2964.3865
-7587.301455301477	-4817.467775467754	0.8354976172734904	4198623.24324327	2.3783783784	3452	4134	38	3452	true	4134.923076923077	3452.3784
-19197.972972973	-12189.527027027	0.835155361813429	2.6880848817567654E7	5.472972973	8735	10462	-34	8735	true	10462.5	8735.473
-17098.9945945946	-10856.8054054054	0.8351828165813104	2.132423090270272E7	0.3945945946	7780	9318	102	7780	true	9318.6	7780.3945
-12433.723076923077	-7894.646153846154	0.8352770361086894	1.12754688E7	7.6	5657	6776	120	5657	true	6776.123076923077	5657.6
-7247.316839916862	-4601.598544698524	0.8355241651897876	3830775.6932432684	7.6783783784	3297	3949	109	3297	true	3949.638461538462	3297.6785
-14757.1700623700465	-9369.891476091493	0.8352226654922171	1.5883214124324286E7	4.8162162162	6714	8042	106	6714	true	8042.3538461538465	6714.8164
-10964.832016631993	-6961.991060291086	0.8353232978714221	8768719.779729689	9.2243243243	4989	5975	87	4989	true	5975.607692307693	4989.224
+19699.417463617423	-12507.913305613346	0.8351496686995997	2.8303425077026896E7	3.6405405405	8963	10735	-17	8963	true	10735.776923076923	8963.641	10735.776923076923	1969-12-31 18:29:23.64054054
+9216.339708939685	-5851.80644490647	0.8353975893550668	6195112.1797296945	3.6243243243	4193	5022	-98	4193	true	5022.715384615385	4193.6245	5022.715384615385	1969-12-31 17:09:53.624324324
+6514.8403326403464	-4136.5212058211928	0.8355907765708067	3095563.9418919063	4.3864864865	2964	3550	-34	2964	true	3550.4538461538464	2964.3865	3550.4538461538464	1969-12-31 16:49:24.386486486
+7587.301455301477	-4817.467775467754	0.8354976172734904	4198623.24324327	2.3783783784	3452	4134	38	3452	true	4134.923076923077	3452.3784	4134.923076923077	1969-12-31 16:57:32.378378378
+19197.972972973	-12189.527027027	0.835155361813429	2.6880848817567654E7	5.472972973	8735	10462	-34	8735	true	10462.5	8735.473	10462.5	1969-12-31 18:25:35.472972973
+17098.9945945946	-10856.8054054054	0.8351828165813104	2.132423090270272E7	0.3945945946	7780	9318	102	7780	true	9318.6	7780.3945	9318.6	1969-12-31 18:09:40.394594594
+12433.723076923077	-7894.646153846154	0.8352770361086894	1.12754688E7	7.6	5657	6776	120	5657	true	6776.123076923077	5657.6	6776.123076923077	1969-12-31 17:34:17.6
+7247.316839916862	-4601.598544698524	0.8355241651897876	3830775.6932432684	7.6783783784	3297	3949	109	3297	true	3949.638461538462	3297.6785	3949.638461538462	1969-12-31 16:54:57.678378378
+14757.1700623700465	-9369.891476091493	0.8352226654922171	1.5883214124324286E7	4.8162162162	6714	8042	106	6714	true	8042.3538461538465	6714.8164	8042.3538461538465	1969-12-31 17:51:54.816216216
+10964.832016631993	-6961.991060291086	0.8353232978714221	8768719.779729689	9.2243243243	4989	5975	87	4989	true	5975.607692307693	4989.224	5975.607692307693	1969-12-31 17:23:09.224324324
