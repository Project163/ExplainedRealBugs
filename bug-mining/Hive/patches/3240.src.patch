diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/MapJoinBytesTableContainer.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/MapJoinBytesTableContainer.java
index 28f6c63f08..52781aff06 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/MapJoinBytesTableContainer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/MapJoinBytesTableContainer.java
@@ -424,7 +424,7 @@ public ReusableRowContainer() {
 
     public void setFromOutput(Output output) {
       if (refs == null) {
-        refs = new ArrayList<WriteBuffers.ByteSegmentRef>(0);
+        refs = new ArrayList<WriteBuffers.ByteSegmentRef>();
       }
       byte aliasFilter = hashMap.getValueRefs(output.getData(), output.getLength(), refs);
       this.aliasFilter = refs.isEmpty() ? (byte) 0xff : aliasFilter;
@@ -472,12 +472,15 @@ public MapJoinRowContainer copy() throws HiveException {
     @Override
     public List<Object> first() throws HiveException {
       currentRow = 0;
-      return next();
+      return nextInternal();
     }
 
-
     @Override
     public List<Object> next() throws HiveException {
+      return nextInternal();
+    }
+
+    private List<Object> nextInternal() throws HiveException {
       if (dummyRow != null) {
         List<Object> result = dummyRow;
         dummyRow = null;
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorMapJoinOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorMapJoinOperator.java
index 2d1e29db26..2270a4d8f9 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorMapJoinOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorMapJoinOperator.java
@@ -30,6 +30,7 @@
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hive.ql.exec.ExprNodeEvaluator;
 import org.apache.hadoop.hive.ql.exec.MapJoinOperator;
+import org.apache.hadoop.hive.ql.exec.persistence.MapJoinTableContainer;
 import org.apache.hadoop.hive.ql.exec.persistence.MapJoinTableContainer.ReusableGetAdaptor;
 import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;
 import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpressionWriter;
@@ -211,6 +212,11 @@ private void flushOutput() throws HiveException {
 
   @Override
   public void closeOp(boolean aborted) throws HiveException {
+    for (MapJoinTableContainer tableContainer : mapJoinTables) {
+      if (tableContainer != null) {
+        tableContainer.dumpMetrics();
+      }
+    }
     if (!aborted && 0 < outputBatch.size) {
       flushOutput();
     }
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/exec/persistence/TestBytesBytesMultiHashMap.java b/ql/src/test/org/apache/hadoop/hive/ql/exec/persistence/TestBytesBytesMultiHashMap.java
index b3582b2f33..2291d95802 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/exec/persistence/TestBytesBytesMultiHashMap.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/exec/persistence/TestBytesBytesMultiHashMap.java
@@ -165,7 +165,7 @@ public UniqueKeysKvSource() {
 
     @Override
     public void writeKey(RandomAccessOutput dest) throws SerDeException {
-      lastKey += 465623573; // This number is certified to be random.
+      lastKey += 465623573;
       int len = LazyBinaryUtils.writeVLongToByteArray(buffer, lastKey);
       lastBuffer = Arrays.copyOf(buffer, len);
       keys.add(lastBuffer);
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/ByteStream.java b/serde/src/java/org/apache/hadoop/hive/serde2/ByteStream.java
index 390d9deb4a..fe7169ef6d 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/ByteStream.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/ByteStream.java
@@ -22,6 +22,8 @@
 
 import org.apache.hadoop.hive.common.io.NonSyncByteArrayInputStream;
 import org.apache.hadoop.hive.common.io.NonSyncByteArrayOutputStream;
+import org.apache.hadoop.hive.serde2.binarysortable.BinarySortableSerDe;
+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector.PrimitiveCategory;
 
 /**
  * Extensions to bytearrayinput/output streams.
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/WriteBuffers.java b/serde/src/java/org/apache/hadoop/hive/serde2/WriteBuffers.java
index bed4d0ade4..7edd09af6f 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/WriteBuffers.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/WriteBuffers.java
@@ -21,8 +21,11 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 
+import org.apache.hadoop.hive.serde2.ByteStream.Output;
 import org.apache.hadoop.hive.serde2.ByteStream.RandomAccessOutput;
+import org.apache.hadoop.hive.serde2.binarysortable.BinarySortableSerDe;
 import org.apache.hadoop.hive.serde2.lazybinary.LazyBinaryUtils;
+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector.PrimitiveCategory;
 import org.apache.hadoop.io.WritableUtils;
 import org.apache.hadoop.util.hash.MurmurHash;
 
@@ -35,6 +38,8 @@ public final class WriteBuffers implements RandomAccessOutput {
   private final ArrayList<byte[]> writeBuffers = new ArrayList<byte[]>(1);
   /** Buffer size in writeBuffers */
   private final int wbSize;
+  private final int wbSizeLog2;
+  private final long offsetMask;
   private final long maxSize;
 
   private byte[] currentWriteBuffer;
@@ -47,7 +52,9 @@ public final class WriteBuffers implements RandomAccessOutput {
   private int currentReadOffset = 0;
 
   public WriteBuffers(int wbSize, long maxSize) {
-    this.wbSize = wbSize;
+    this.wbSize = Integer.bitCount(wbSize) == 1 ? wbSize : (Integer.highestOneBit(wbSize) << 1);
+    this.wbSizeLog2 = 31 - Integer.numberOfLeadingZeros(this.wbSize);
+    this.offsetMask = this.wbSize - 1;
     this.maxSize = maxSize;
     currentWriteBufferIndex = -1;
     nextBufferToWrite();
@@ -142,7 +149,7 @@ private void setByte(long offset, byte value) {
 
   @Override
   public void reserve(int byteCount) {
-    if (byteCount < 0) throw new AssertionError("byteCount must be positive");
+    if (byteCount < 0) throw new AssertionError("byteCount must be non-negative");
     int currentWriteOffset = this.currentWriteOffset + byteCount;
     while (currentWriteOffset > wbSize) {
       nextBufferToWrite();
@@ -190,11 +197,11 @@ public int getLength() {
   }
 
   private int getOffset(long offset) {
-    return (int)(offset % wbSize);
+    return (int)(offset & offsetMask);
   }
 
   private int getBufferIndex(long offset) {
-    return (int)(offset / wbSize);
+    return (int)(offset >>> wbSizeLog2);
   }
 
   private void nextBufferToWrite() {
@@ -283,11 +290,11 @@ public void clear() {
   }
 
   public long getWritePoint() {
-    return (currentWriteBufferIndex * (long)wbSize) + currentWriteOffset;
+    return ((long)currentWriteBufferIndex << wbSizeLog2) + currentWriteOffset;
   }
 
   public long getReadPoint() {
-    return (currentReadBufferIndex * (long)wbSize) + currentReadOffset;
+    return ((long)currentReadBufferIndex << wbSizeLog2) + currentReadOffset;
   }
 
   public void writeVLong(long value) {
@@ -335,12 +342,17 @@ public void writeBytes(long offset, int length) {
    */
   public static class ByteSegmentRef {
     public ByteSegmentRef(long offset, int length) {
+      reset(offset, length);
+    }
+    public void reset(long offset, int length) {
       if (length < 0) {
         throw new AssertionError("Length is negative: " + length);
       }
       this.offset = offset;
       this.length = length;
     }
+    public ByteSegmentRef() {
+    }
     public byte[] getBytes() {
       return bytes;
     }
@@ -367,27 +379,29 @@ public ByteBuffer copy() {
    * spanning multiple internal buffers.
    */
   public void populateValue(WriteBuffers.ByteSegmentRef value) {
-    // At this point, we are going to make a copy if need to avoid array boundaries.
+    // At this point, we are going to make a copy if needed to avoid array boundaries.
     int index = getBufferIndex(value.getOffset());
     byte[] buffer = writeBuffers.get(index);
     int bufferOffset = getOffset(value.getOffset());
     int length = value.getLength();
     if (bufferOffset + length <= wbSize) {
+      // Common case - the segment is in one buffer.
       value.bytes = buffer;
       value.offset = bufferOffset;
-    } else {
-      value.bytes = new byte[length];
-      value.offset = 0;
-      int destOffset = 0;
-      while (destOffset < length) {
-        if (destOffset > 0) {
-          buffer = writeBuffers.get(++index);
-          bufferOffset = 0;
-        }
-        int toCopy = Math.min(length - destOffset, wbSize - bufferOffset);
-        System.arraycopy(buffer, bufferOffset, value.bytes, destOffset, toCopy);
-        destOffset += toCopy;
+      return;
+    }
+    // Special case (rare) - the segment is on buffer boundary.
+    value.bytes = new byte[length];
+    value.offset = 0;
+    int destOffset = 0;
+    while (destOffset < length) {
+      if (destOffset > 0) {
+        buffer = writeBuffers.get(++index);
+        bufferOffset = 0;
       }
+      int toCopy = Math.min(length - destOffset, wbSize - bufferOffset);
+      System.arraycopy(buffer, bufferOffset, value.bytes, destOffset, toCopy);
+      destOffset += toCopy;
     }
   }
 
@@ -437,11 +451,12 @@ public void writeFiveByteULong(long offset, long v) {
     int prevIndex = currentWriteBufferIndex, prevOffset = currentWriteOffset;
     setWritePoint(offset);
     if (isAllInOneWriteBuffer(5)) {
-      currentWriteBuffer[currentWriteOffset++] = (byte)(v >>> 32);
-      currentWriteBuffer[currentWriteOffset++] = (byte)(v >>> 24);
-      currentWriteBuffer[currentWriteOffset++] = (byte)(v >>> 16);
-      currentWriteBuffer[currentWriteOffset++] = (byte)(v >>> 8);
-      currentWriteBuffer[currentWriteOffset] = (byte)(v);
+      currentWriteBuffer[currentWriteOffset] = (byte)(v >>> 32);
+      currentWriteBuffer[currentWriteOffset + 1] = (byte)(v >>> 24);
+      currentWriteBuffer[currentWriteOffset + 2] = (byte)(v >>> 16);
+      currentWriteBuffer[currentWriteOffset + 3] = (byte)(v >>> 8);
+      currentWriteBuffer[currentWriteOffset + 4] = (byte)(v);
+      currentWriteOffset += 5;
     } else {
       setByte(offset++, (byte)(v >>> 32));
       setByte(offset++, (byte)(v >>> 24));
@@ -463,10 +478,11 @@ public void writeInt(long offset, int v) {
     int prevIndex = currentWriteBufferIndex, prevOffset = currentWriteOffset;
     setWritePoint(offset);
     if (isAllInOneWriteBuffer(4)) {
-      currentWriteBuffer[currentWriteOffset++] = (byte)(v >> 24);
-      currentWriteBuffer[currentWriteOffset++] = (byte)(v >> 16);
-      currentWriteBuffer[currentWriteOffset++] = (byte)(v >> 8);
-      currentWriteBuffer[currentWriteOffset] = (byte)(v);
+      currentWriteBuffer[currentWriteOffset] = (byte)(v >> 24);
+      currentWriteBuffer[currentWriteOffset + 1] = (byte)(v >> 16);
+      currentWriteBuffer[currentWriteOffset + 2] = (byte)(v >> 8);
+      currentWriteBuffer[currentWriteOffset + 3] = (byte)(v);
+      currentWriteOffset += 4;
     } else {
       setByte(offset++, (byte)(v >>> 24));
       setByte(offset++, (byte)(v >>> 16));
