diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java
index 8d7f0d3645..f1ae5b4b50 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/BuddyAllocator.java
@@ -122,10 +122,10 @@ public BuddyAllocator(boolean isDirectVal, boolean isMappedVal, int minAllocVal,
     int arenaSizeVal = (arenaCount == 0) ? MAX_ARENA_SIZE : (int)(maxSizeVal / arenaCount);
     arenaSizeVal = Math.max(maxAllocation, Math.min(arenaSizeVal, MAX_ARENA_SIZE));
     if (LlapIoImpl.LOG.isInfoEnabled()) {
-      LlapIoImpl.LOG.info("Buddy allocator with " + (isDirect ? "direct" : "byte") + " buffers;"
-          + (isMapped ? (" memory mapped off " + cacheDir.toString() + "; ") : "")
+      LlapIoImpl.LOG.info("Buddy allocator with " + (isDirect ? "direct" : "byte") + " buffers; "
+          + (isMapped ? ("memory mapped off " + cacheDir.toString() + "; ") : "")
           + "allocation sizes " + minAllocation + " - " + maxAllocation
-          + ", arena size " + arenaSizeVal + ". total size " + maxSizeVal);
+          + ", arena size " + arenaSizeVal + ", total size " + maxSizeVal);
     }
 
     String minName = ConfVars.LLAP_ALLOCATOR_MIN_ALLOC.varname,
@@ -241,38 +241,62 @@ public void allocateMultiple(MemoryBuffer[] dest, int size)
     // into some sort of queues that deallocate and split will examine), or having and "actor"
     // allocator thread (or threads per arena).
     // The 2nd one is probably much simpler and will allow us to get rid of a lot of sync code.
-    // But for now we will just retry 5 times 0_o
-    for (int attempt = 0; attempt < 5; ++attempt) {
-      // Try to split bigger blocks. TODO: again, ideally we would tryLock at least once
-      {
-        int startArenaIx = (int)((threadId + attempt) % arenaCount), arenaIx = startArenaIx;
-        do {
-          int newDestIx = arenas[arenaIx].allocateWithSplit(
-              arenaIx, freeListIx, dest, destAllocIx, allocationSize);
-          if (newDestIx == dest.length) return;
-          assert newDestIx != -1;
-          destAllocIx = newDestIx;
-          if ((++arenaIx) == arenaCount) {
-            arenaIx = 0;
-          }
-        } while (arenaIx != startArenaIx);
-      }
+    // But for now we will just retry. We will evict more each time.
+    long forceReserved = 0;
+    int attempt = 0;
+    try {
+      while (true) {
+        // Try to split bigger blocks. TODO: again, ideally we would tryLock at least once
+        {
+          int startArenaIx = (int)((threadId + attempt) % arenaCount), arenaIx = startArenaIx;
+          do {
+            int newDestIx = arenas[arenaIx].allocateWithSplit(
+                arenaIx, freeListIx, dest, destAllocIx, allocationSize);
+            if (newDestIx == dest.length) return;
+            assert newDestIx != -1;
+            destAllocIx = newDestIx;
+            if ((++arenaIx) == arenaCount) {
+              arenaIx = 0;
+            }
+          } while (arenaIx != startArenaIx);
+        }
 
-      if (attempt == 0) {
-        // Try to allocate memory if we haven't allocated all the way to maxSize yet; very rare.
-        for (int arenaIx = arenaCount; arenaIx < arenas.length; ++arenaIx) {
-          destAllocIx = arenas[arenaIx].allocateWithExpand(
-              arenaIx, freeListIx, dest, destAllocIx, allocationSize);
-          if (destAllocIx == dest.length) return;
+        if (attempt == 0) {
+          // Try to allocate memory if we haven't allocated all the way to maxSize yet; very rare.
+          for (int arenaIx = arenaCount; arenaIx < arenas.length; ++arenaIx) {
+            destAllocIx = arenas[arenaIx].allocateWithExpand(
+                arenaIx, freeListIx, dest, destAllocIx, allocationSize);
+            if (destAllocIx == dest.length) return;
+          }
         }
+        int numberToForce = (dest.length - destAllocIx) * attempt;
+        long newReserved = memoryManager.forceReservedMemory(allocationSize, numberToForce);
+        forceReserved += newReserved;
+        if (newReserved == 0) {
+          // Cannot force-evict anything, give up.
+          String msg = "Failed to allocate " + size + "; at " + destAllocIx + " out of "
+              + dest.length + " (entire cache is fragmented and locked, or an internal issue)";
+          LlapIoImpl.LOG.error(msg + "\nALLOCATOR STATE:\n" + debugDump()
+              + "\nPARENT STATE:\n" + memoryManager.debugDumpForOom());
+          throw new AllocatorOutOfMemoryException(msg);
+        }
+        if (attempt == 0) {
+          LlapIoImpl.LOG.warn("Failed to allocate despite reserved memory; will retry");
+        }
+      }
+    } finally {
+      if (attempt > 1) {
+        LlapIoImpl.LOG.warn("Allocation of " + dest.length + " buffers of size " + size
+            + " took " + attempt + " attempts to evict enough memory");
+      }
+      // After we succeed (or fail), release the force-evicted memory to memory manager. We have
+      // previously reserved enough to allocate all we need, so we don't take our allocation out
+      // of this - as per the comment above, we basically just wasted a bunch of cache (and CPU).
+      if (forceReserved > 0) {
+        memoryManager.releaseMemory(forceReserved);
       }
-      memoryManager.forceReservedMemory(allocationSize, dest.length - destAllocIx);
-      LlapIoImpl.LOG.warn("Failed to allocate despite reserved memory; will retry " + attempt);
     }
-    String msg = "Failed to allocate " + size + "; at " + destAllocIx + " out of " + dest.length;
-    LlapIoImpl.LOG.error(msg + "\nALLOCATOR STATE:\n" + debugDump()
-        + "\nPARENT STATE:\n" + memoryManager.debugDumpForOom());
-    throw new AllocatorOutOfMemoryException(msg);
+
   }
 
   @Override
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java
index 88bfa8b5d9..8e10fd4fe3 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCacheMemoryManager.java
@@ -114,13 +114,9 @@ public boolean reserveMemory(final long memoryToReserve, boolean waitForEviction
 
 
   @Override
-  public void forceReservedMemory(int allocationSize, int count) {
-    if (evictor == null) return;
-    while (count > 0) {
-      int evictedCount = evictor.tryEvictContiguousData(allocationSize, count);
-      if (evictedCount == 0) return;
-      count -= evictedCount;
-    }
+  public long forceReservedMemory(int allocationSize, int count) {
+    if (evictor == null) return 0;
+    return evictor.tryEvictContiguousData(allocationSize, count);
   }
 
   @Override
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCachePolicy.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCachePolicy.java
index bb1d1b0c69..fd9d9420b9 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCachePolicy.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCachePolicy.java
@@ -28,5 +28,5 @@ public interface LowLevelCachePolicy extends LlapOomDebugDump {
   void setEvictionListener(EvictionListener listener);
   void setParentDebugDumper(LlapOomDebugDump dumper);
   /** TODO: temporary method until we have a better allocator */
-  int tryEvictContiguousData(int allocationSize, int count);
+  long tryEvictContiguousData(int allocationSize, int count);
 }
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelFifoCachePolicy.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelFifoCachePolicy.java
index 430a5f80a9..715eba9a45 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelFifoCachePolicy.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelFifoCachePolicy.java
@@ -116,10 +116,12 @@ public String debugDumpForOom() {
   }
 
   @Override
-  public int tryEvictContiguousData(int allocationSize, int count) {
+  public long tryEvictContiguousData(int allocationSize, int count) {
     long evicted = evictInternal(allocationSize * count, allocationSize);
-    // This makes granularity assumptions.
-    assert evicted % allocationSize == 0;
-    return (int)(evicted / allocationSize);
+    int remainingCount = count - (int)(evicted / allocationSize);
+    if (remainingCount > 0) {
+      evicted += evictInternal(allocationSize * remainingCount, -1);
+    }
+    return evicted;
   }
 }
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java
index 4cd2c18ea2..14aa66d35d 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelLrfuCachePolicy.java
@@ -210,13 +210,14 @@ public long evictSomeBlocks(long memoryToReserve) {
   }
 
   @Override
-  public int tryEvictContiguousData(int allocationSize, int count) {
+  public long tryEvictContiguousData(int allocationSize, int count) {
     int evicted = evictDataFromList(allocationSize, count);
-    count -= evicted;
-    if (count > 0) {
-      evicted += evictDataFromHeap(timer.get(), count, allocationSize);
-    }
-    return evicted;
+    if (count <= evicted) return evicted * allocationSize;
+    evicted += evictDataFromHeap(timer.get(), count - evicted, allocationSize);
+    long evictedBytes = evicted * allocationSize;
+    if (count <= evicted) return evictedBytes;
+    evictedBytes += evictSomeBlocks(allocationSize * (count - evicted));
+    return evictedBytes;
   }
 
   private long evictFromList(long memoryToReserve) {
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/MemoryManager.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/MemoryManager.java
index ca41825656..05e901ffbf 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cache/MemoryManager.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cache/MemoryManager.java
@@ -23,5 +23,5 @@ public interface MemoryManager extends LlapOomDebugDump {
   void releaseMemory(long memUsage);
   void updateMaxSize(long maxSize);
   /** TODO: temporary method until we get a better allocator. */
-  void forceReservedMemory(int allocationSize, int count);
+  long forceReservedMemory(int allocationSize, int count);
 }
diff --git a/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestBuddyAllocator.java b/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestBuddyAllocator.java
index 04ba273691..3a8ca2e5f6 100644
--- a/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestBuddyAllocator.java
+++ b/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestBuddyAllocator.java
@@ -76,7 +76,8 @@ public void updateMaxSize(long maxSize) {
     }
 
     @Override
-    public void forceReservedMemory(int allocationSize, int count) {
+    public long forceReservedMemory(int allocationSize, int count) {
+      return allocationSize * count;
     }
   }
 
diff --git a/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestLowLevelCacheImpl.java b/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestLowLevelCacheImpl.java
index 6c3ec039d4..42c4c56558 100644
--- a/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestLowLevelCacheImpl.java
+++ b/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestLowLevelCacheImpl.java
@@ -116,8 +116,8 @@ public void setParentDebugDumper(LlapOomDebugDump dumper) {
     }
 
     @Override
-    public int tryEvictContiguousData(int allocationSize, int count) {
-      return count;
+    public long tryEvictContiguousData(int allocationSize, int count) {
+      return count * allocationSize;
     }
   }
 
diff --git a/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestLowLevelLrfuCachePolicy.java b/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestLowLevelLrfuCachePolicy.java
index f0de7c42a8..0cce624682 100644
--- a/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestLowLevelLrfuCachePolicy.java
+++ b/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestLowLevelLrfuCachePolicy.java
@@ -230,18 +230,25 @@ public void testForceEvictBySize() {
     // Now we should have two in the heap and two in the list, which is an implementation detail.
     // Evict only big blocks.
     et.evicted.clear();
-    assertEquals(4, lrfu.tryEvictContiguousData(2, 4));
+    assertEquals(8, lrfu.tryEvictContiguousData(2, 4));
     for (int i = 0; i < sizeTwo.size(); ++i) {
       LlapDataBuffer block = et.evicted.get(i);
       assertTrue(block.isInvalid());
       assertSame(sizeTwo.get(i), block);
     }
     et.evicted.clear();
-    // Cannot evict any more size 2.
-    assertEquals(0, lrfu.tryEvictContiguousData(2, 1));
-    assertEquals(4, lrfu.evictSomeBlocks(4));
-    for (int i = 0; i < sizeOne.size(); ++i) {
-      LlapDataBuffer block = et.evicted.get(i);
+    // Evict small blocks when no big ones are available.
+    assertEquals(2, lrfu.tryEvictContiguousData(2, 1));
+    for (int i = 0; i < 2; ++i) {
+	  LlapDataBuffer block = et.evicted.get(i);
+	  assertTrue(block.isInvalid());
+	  assertSame(sizeOne.get(i), block);
+	}
+    et.evicted.clear();
+    // Evict the rest.
+    assertEquals(2, lrfu.evictSomeBlocks(3));
+    for (int i = 2; i < sizeOne.size(); ++i) {
+      LlapDataBuffer block = et.evicted.get(i - 2);
       assertTrue(block.isInvalid());
       assertSame(sizeOne.get(i), block);
     }
diff --git a/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestOrcMetadataCache.java b/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestOrcMetadataCache.java
index 3408dfff71..be1be7af2a 100644
--- a/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestOrcMetadataCache.java
+++ b/llap-server/src/test/org/apache/hadoop/hive/llap/cache/TestOrcMetadataCache.java
@@ -63,7 +63,7 @@ public void verifyEquals(int i) {
     }
 
     @Override
-    public int tryEvictContiguousData(int allocationSize, int count) {
+    public long tryEvictContiguousData(int allocationSize, int count) {
       return 0;
     }
   }
@@ -92,7 +92,8 @@ public void updateMaxSize(long maxSize) {
     }
 
     @Override
-    public void forceReservedMemory(int allocationSize, int count) {
+    public long forceReservedMemory(int allocationSize, int count) {
+      return allocationSize * count;
     }
   }
 
