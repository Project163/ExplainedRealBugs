diff --git a/ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java b/ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java
index cab7eb3816..e4d611123b 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java
@@ -374,6 +374,14 @@ public static Hive get(HiveConf c) throws HiveException {
     return getInternal(c, false, false, true);
   }
 
+  public static Hive createHiveForSession(HiveConf c) throws HiveException {
+    return create(c, true);
+  }
+
+  public void setConf(HiveConf c) {
+    this.conf = c;
+  }
+
   /**
    * Same as {@link #get(HiveConf)}, except that it checks only the object identity of existing
    * MS client, assuming the relevant settings would be unchanged within the same conf object.
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/session/SessionState.java b/ql/src/java/org/apache/hadoop/hive/ql/session/SessionState.java
index b313362b65..18bbd9e6d6 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/session/SessionState.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/session/SessionState.java
@@ -350,6 +350,7 @@ public enum AuthorizationMode{V1, V2};
 
   private final AtomicLong sparkSessionId = new AtomicLong();
 
+  private Hive hiveDb;
   private final Map<String, QueryState> queryStateMap = new HashMap<>();
 
   public QueryState getQueryState(String queryId) {
@@ -370,6 +371,9 @@ public HiveConf getConf() {
   }
 
   public void setConf(HiveConf conf) {
+    if (hiveDb != null) {
+      hiveDb.setConf(conf);
+    }
     this.sessionConf = conf;
   }
 
@@ -1884,7 +1888,10 @@ public void close() throws IOException {
       unCacheDataNucleusClassLoaders();
     } finally {
       // removes the threadlocal variables, closes underlying HMS connection
-      Hive.closeCurrent();
+      if (hiveDb != null) {
+        hiveDb.close(true);
+        hiveDb = null;
+      }
     }
     progressMonitor = null;
     // Hadoop's ReflectionUtils caches constructors for the classes it instantiated.
@@ -2225,6 +2232,18 @@ public void endScope(String queryId) {
   public Map<Object, Object> getQueryCache(String queryId) {
     return cache.get(queryId);
   }
+
+  public Hive getHiveDb() throws HiveException {
+    if (hiveDb == null) {
+      hiveDb = Hive.createHiveForSession(sessionConf);
+      // Need to setAllowClose to false. For legacy reasons, the Hive object is stored
+      // in thread local storage. If allowClose is true, the session can get closed when
+      // the thread goes away which is not desirable when the Hive object is used across
+      // different queries in the session.
+      hiveDb.setAllowClose(false);
+    }
+    return hiveDb;
+  }
 }
 
 class ResourceMaps {
@@ -2287,5 +2306,4 @@ public Map<String, String> getLocalHdfsLocationMap(SessionState.ResourceType typ
     }
     return result;
   }
-
 }
diff --git a/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java b/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java
index e5a8f9e2d9..f231c20b40 100644
--- a/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java
+++ b/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java
@@ -58,6 +58,7 @@
 import org.apache.hadoop.hive.ql.exec.FetchTask;
 import org.apache.hadoop.hive.ql.log.PerfLogger;
 import org.apache.hadoop.hive.ql.metadata.Hive;
+import org.apache.hadoop.hive.ql.metadata.HiveException;
 import org.apache.hadoop.hive.ql.processors.CommandProcessorException;
 import org.apache.hadoop.hive.ql.session.SessionState;
 import org.apache.hadoop.hive.serde.serdeConstants;
@@ -316,7 +317,11 @@ public void run() {
         @Override
         public Object run() throws HiveSQLException {
           assert (!parentHive.allowClose());
-          Hive.set(parentHive);
+          try {
+            Hive.set(parentSessionState.getHiveDb());
+          } catch (HiveException e) {
+            throw new HiveSQLException(e);
+          }
           // TODO: can this result in cross-thread reuse of session state?
           SessionState.setCurrentSessionState(parentSessionState);
           PerfLogger.setPerfLogger(SessionState.getPerfLogger());
diff --git a/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java b/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
index 82d039ba60..5fef5cd1de 100644
--- a/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
+++ b/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
@@ -240,21 +240,13 @@ protected int processCmd(String cmd) {
    * @throws HiveSQLException
    */
   private void setSessionHive() throws HiveSQLException {
-    Hive newSessionHive;
     try {
-      newSessionHive = Hive.get(getHiveConf());
-
-      // HMS connections from sessionHive shouldn't be closed by any query execution thread when it
-      // recreates the Hive object. It is allowed to be closed only when session is closed/released.
-      newSessionHive.setAllowClose(false);
+      sessionHive = sessionState.getHiveDb();
     } catch (HiveException e) {
-      throw new HiveSQLException("Failed to get metastore connection", e);
+      String msg = "Failed to create Hive Object: " + e;
+      LOG.error(msg, e);
+      throw new HiveSQLException(msg, e);
     }
-
-    // The previous sessionHive object might still be referred by any async query execution thread.
-    // So, it shouldn't be closed here explicitly. Anyways, Hive object will auto-close HMS connection
-    // when it is garbage collected. So, it is safe to just overwrite sessionHive here.
-    sessionHive = newSessionHive;
   }
 
   private void processGlobalInitFile() {
@@ -408,18 +400,10 @@ private synchronized void acquireAfterOpLock(boolean userAccess) {
     // set the thread name with the logging prefix.
     sessionState.updateThreadName();
 
-    // If the thread local Hive is different from sessionHive, it means, the previous query execution in
-    // master thread has re-created Hive object due to changes in MS related configurations in sessionConf.
-    // So, it is necessary to reset sessionHive object based on new sessionConf. Here, we cannot,
-    // directly set sessionHive with thread local Hive because if the previous command was REPL LOAD, then
-    // the config changes lives only within command execution not in session level.
-    // So, the safer option is to invoke Hive.get() which decides if to reuse Thread local Hive or re-create it.
-    if (Hive.getThreadLocal() != sessionHive) {
-      try {
-        setSessionHive();
-      } catch (HiveSQLException e) {
-        throw new RuntimeException(e);
-      }
+    try {
+      setSessionHive();
+    } catch (HiveSQLException e) {
+      throw new RuntimeException(e);
     }
   }
 
