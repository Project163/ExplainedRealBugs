diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/parser/Filter.g b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/parser/Filter.g
index c3977860f7..c09471e295 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/parser/Filter.g
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/parser/Filter.g
@@ -37,10 +37,10 @@ package org.apache.hadoop.hive.metastore.parser;
 
 import java.sql.Date;
 import java.sql.Timestamp;
+import java.time.LocalDate;
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
+import java.time.format.ResolverStyle;
 import java.util.TimeZone;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -52,34 +52,31 @@ import java.util.regex.Pattern;
   private static final Pattern datePattern = Pattern.compile(".*(\\d\\d\\d\\d-\\d\\d-\\d\\d).*");
   private static final Pattern timestampPattern =
       Pattern.compile(".*(\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d:\\d\\d).*");
-  private static final ThreadLocal<SimpleDateFormat> dateFormat =
-       new ThreadLocal<SimpleDateFormat>() {
-    @Override
-    protected SimpleDateFormat initialValue() {
-      SimpleDateFormat val = new SimpleDateFormat("yyyy-MM-dd");
-      val.setLenient(false); // Without this, 2020-20-20 becomes 2021-08-20.
-      val.setTimeZone(TimeZone.getTimeZone("UTC"));
-      return val;
-    };
-  };
-  private static final ThreadLocal<DateTimeFormatter> timestampFormat =
-       new ThreadLocal<DateTimeFormatter>() {
-    @Override
-    protected DateTimeFormatter initialValue() {
-      DateTimeFormatter val = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
-          .withZone(TimeZone.getTimeZone("UTC").toZoneId());
-      return val;
-    };
-  };
 
-  public static java.sql.Date extractDate(String input) {
+  private static final DateTimeFormatter dateFormat = createDateTimeFormatter("uuuu-MM-dd");
+  private static final DateTimeFormatter timestampFormat = createDateTimeFormatter("uuuu-MM-dd HH:mm:ss");
+
+  public static DateTimeFormatter createDateTimeFormatter(String format) {
+    return DateTimeFormatter.ofPattern(format)
+                     .withZone(TimeZone.getTimeZone("UTC").toZoneId())
+                     .withResolverStyle(ResolverStyle.STRICT);
+  }
+
+  public static Object extractDate(String input) {
+    // Date literal is a suffix of timestamp. Try to parse it as a timestamp first
+    Object res = extractTimestamp(input);
+    if (res != null) {
+      return res;
+    }
+    
     Matcher m = datePattern.matcher(input);
     if (!m.matches()) {
       return null;
     }
     try {
-      return new java.sql.Date(dateFormat.get().parse(m.group(1)).getTime());
-    } catch (ParseException pe) {
+       LocalDate val = LocalDate.parse(m.group(1), dateFormat);
+       return java.sql.Date.valueOf(val);
+    } catch (Exception ex) {
       return null;
     }
   }
@@ -90,7 +87,7 @@ import java.util.regex.Pattern;
       return null;
     }
     try {
-       LocalDateTime val = LocalDateTime.from(timestampFormat.get().parse(m.group(1)));
+       LocalDateTime val = LocalDateTime.from(timestampFormat.parse(m.group(1)));
        return Timestamp.valueOf(val);
     } catch (Exception ex) {
       return null;
@@ -166,17 +163,11 @@ binOpExpression
     :
     (
        (
-         (key = Identifier op = operator  value = DateLiteral)
+         (key = Identifier op = operator  value = DateTimeLiteral)
          |
-         (value = DateLiteral  op = operator key = Identifier) { isReverseOrder = true; }
+         (value = DateTimeLiteral  op = operator key = Identifier) { isReverseOrder = true; }
        ) { val = FilterLexer.extractDate(value.getText()); }
        |
-       (
-         (key = Identifier op = operator  value = TimestampLiteral)
-         |
-         (value = TimestampLiteral  op = operator key = Identifier) { isReverseOrder = true; }
-       ) { val = FilterLexer.extractTimestamp(value.getText()); }
-       |
        (
          (key = Identifier op = operator  value = StringLiteral)
          |
@@ -216,16 +207,11 @@ betweenExpression
     (
        key = Identifier (KW_NOT { isPositive = false; } )? BETWEEN
        (
-         (left = DateLiteral KW_AND right = DateLiteral) {
+         (left = DateTimeLiteral KW_AND right = DateTimeLiteral) {
             leftV = FilterLexer.extractDate(left.getText());
             rightV = FilterLexer.extractDate(right.getText());
          }
          |
-         (left = TimestampLiteral KW_AND right = TimestampLiteral) {
-            leftV = FilterLexer.extractTimestamp(left.getText());
-            rightV = FilterLexer.extractTimestamp(right.getText());
-         }
-         |
          (left = StringLiteral KW_AND right = StringLiteral) { leftV = TrimQuotes(left.getText());
             rightV = TrimQuotes(right.getText());
          }
@@ -258,13 +244,13 @@ inExpression
         LPAREN key = Identifier RPAREN ( KW_NOT { isPositive = false; } )? IN LPAREN
         (
             (
-                constant = DateLiteral
+                constant = DateTimeLiteral
                 {
                     constantV = FilterLexer.extractDate(constant.getText());
                     constants.add(constantV);
                 }
                 (
-                    COMMA constant = DateLiteral
+                    COMMA constant = DateTimeLiteral
                     {
                         constantV = FilterLexer.extractDate(constant.getText());
                         constants.add(constantV);
@@ -272,21 +258,6 @@ inExpression
                 )*
             )
             |
-            (
-                constant = TimestampLiteral
-                {
-                    constantV = FilterLexer.extractTimestamp(constant.getText());
-                    constants.add(constantV);
-                }
-                (
-                    COMMA constant = TimestampLiteral
-                    {
-                        constantV = FilterLexer.extractTimestamp(constant.getText());
-                        constants.add(constantV);
-                    }
-                )*
-             )
-            |
             (
                 constant = StringLiteral
                 {
@@ -362,16 +333,11 @@ multiColInExpression
             partialConstants = new ArrayList();
         }
         (
-            constant = DateLiteral
+            constant = DateTimeLiteral
             {
                 constantV = FilterLexer.extractDate(constant.getText());
                 partialConstants.add(constantV);
             }
-            | constant = TimestampLiteral
-            {
-                constantV = FilterLexer.extractTimestamp(constant.getText());
-                partialConstants.add(constantV);
-            }
             | constant = StringLiteral
             {
                 constantV = TrimQuotes(constant.getText());
@@ -386,16 +352,11 @@ multiColInExpression
         (
             COMMA
             (
-                constant = DateLiteral
+                constant = DateTimeLiteral
                 {
                     constantV = FilterLexer.extractDate(constant.getText());
                     partialConstants.add(constantV);
                 }
-                | constant = TimestampLiteral
-                {
-                    constantV = FilterLexer.extractTimestamp(constant.getText());
-                    partialConstants.add(constantV);
-                }
                 | constant = StringLiteral
                 {
                     constantV = TrimQuotes(constant.getText());
@@ -418,16 +379,11 @@ multiColInExpression
                 partialConstants = new ArrayList();
             }
             (
-                constant = DateLiteral
+                constant = DateTimeLiteral
                 {
                     constantV = FilterLexer.extractDate(constant.getText());
                     partialConstants.add(constantV);
                 }
-                | constant = TimestampLiteral
-                {
-                    constantV = FilterLexer.extractTimestamp(constant.getText());
-                    partialConstants.add(constantV);
-                }
                 | constant = StringLiteral
                 {
                     constantV = TrimQuotes(constant.getText());
@@ -442,16 +398,11 @@ multiColInExpression
             (
                 COMMA
                 (
-                    constant = DateLiteral
+                    constant = DateTimeLiteral
                     {
                         constantV = FilterLexer.extractDate(constant.getText());
                         partialConstants.add(constantV);
                     }
-                    | constant = TimestampLiteral
-                    {
-                        constantV = FilterLexer.extractTimestamp(constant.getText());
-                        partialConstants.add(constantV);
-                    }
                     | constant = StringLiteral
                     {
                         constantV = TrimQuotes(constant.getText());
@@ -540,18 +491,14 @@ fragment TimestampString
 /* When I figure out how to make lexer backtrack after validating predicate, dates would be able 
 to support single quotes [( '\'' DateString '\'' ) |]. For now, what we do instead is have a hack
 to parse the string in metastore code from StringLiteral. */
-DateLiteral
+DateTimeLiteral
     :
-    KW_DATE '\'' DateString '\'' { extractDate(getText()) != null }?
+    (TimestampString) => (TimestampString { extractTimestamp(getText()) != null }?)
+    | KW_TIMESTAMP '\'' TimestampString '\'' { extractTimestamp(getText()) != null }?
+    | KW_DATE '\'' DateString '\'' { extractDate(getText()) != null }?
     | DateString { extractDate(getText()) != null }?
     ;
 
-TimestampLiteral
-    :
-    KW_TIMESTAMP '\'' TimestampString '\'' { extractTimestamp(getText()) != null }?
-    | TimestampString { extractTimestamp(getText()) != null }?
-    ;
-
 StringLiteral
     :
     ( '\'' ( ~('\''|'\\') | ('\\' .) )* '\''
diff --git a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestPartFilterExprUtil.java b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestPartFilterExprUtil.java
index 6705440239..1a6a14ee3a 100644
--- a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestPartFilterExprUtil.java
+++ b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestPartFilterExprUtil.java
@@ -274,4 +274,211 @@ private void checkFilter(String filter, String expectTreeString) throws MetaExce
     ExpressionTree expressionTree = PartFilterExprUtil.parseFilterTree(filter);
     assertThat(expressionTree.getRoot().toString(), is(expectTreeString));
   }
+
+  @Test
+  public void testGetFilterParserSingleColInExpressionWhenDateLiteralTypeIsNotSpecifiedNorQuoted() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j) in (1990-11-10, 1990-11-11, 1990-11-12)").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-10}, andOr='OR', rhs=LeafNode{keyName='j', operator='=', value=1990-11-11}}, andOr='OR', rhs=LeafNode{keyName='j', operator='=', value=1990-11-12}}"));
+  }
+
+  @Test
+  public void testGetFilterParserSingleColInExpressionWhenDateLiteralTypeIsSpecified() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j) IN (DATE'1990-11-10', DATE'1990-11-11', DATE'1990-11-12')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-10}, andOr='OR', rhs=LeafNode{keyName='j', operator='=', value=1990-11-11}}, andOr='OR', rhs=LeafNode{keyName='j', operator='=', value=1990-11-12}}"));
+  }
+
+  @Test
+  public void testGetFilterParserMultiColInExpressionWhenDateLiteralTypeIsNotSpecifiedNorQuoted() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(struct(ds1,ds2)) IN (struct(2000-05-08, 2001-04-08), struct(2000-05-09, 2001-04-09))").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-08}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-08}}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-09}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-09}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserMultiColInExpressionWhenDateLiteralTypeIsSpecified() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(struct(ds1,ds2)) IN (struct(DATE'2000-05-08',DATE'2001-04-08'), struct(DATE'2000-05-09',DATE'2001-04-09'))").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-08}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-08}}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-09}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-09}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserSingleColInExpressionWhenTimestampLiteralTypeIsNotSpecifiedNorQuoted() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(dt) IN (2000-01-01 01:00:00, 2000-01-01 01:42:00)").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='=', value=2000-01-01 01:00:00.0}, andOr='OR', rhs=LeafNode{keyName='dt', operator='=', value=2000-01-01 01:42:00.0}}"));
+  }
+
+  @Test
+  public void testGetFilterParserSingleColInExpressionWhenTimestampLiteralTypeIsSpecified() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j) IN (TIMESTAMP'2000-01-01 01:00:00', TIMESTAMP'2000-01-01 01:42:00')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='=', value=2000-01-01 01:00:00.0}, andOr='OR', rhs=LeafNode{keyName='j', operator='=', value=2000-01-01 01:42:00.0}}"));
+  }
+
+  @Test
+  public void testGetFilterParserMultiColInExpressionWhenTimestampLiteralTypeIsNotSpecifiedNorQuoted() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(struct(ds1,ds2)) IN (struct(2000-05-08 01:00:00, 2001-04-08 01:00:00), struct(2000-05-09 01:00:00, 2001-04-09 01:00:00))").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-08 01:00:00.0}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-08 01:00:00.0}}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-09 01:00:00.0}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-09 01:00:00.0}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserMultiColInExpressionWhenTimestampLiteralTypeIsSpecified() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(struct(ds1,ds2)) IN (struct(TIMESTAMP'2000-05-08 01:00:00',TIMESTAMP'2001-04-08 01:00:00'), struct(TIMESTAMP'2000-05-09 01:00:00',TIMESTAMP'2001-04-09 01:00:00'))").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-08 01:00:00.0}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-08 01:00:00.0}}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-09 01:00:00.0}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-09 01:00:00.0}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBetweenExpressionWhenDateLiteralTypeIsNotSpecifiedNorQuoted() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j BETWEEN 1990-11-10 AND 1990-11-11)").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='>=', value=1990-11-10}, andOr='AND', rhs=LeafNode{keyName='j', operator='<=', value=1990-11-11}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBetweenExpressionWhenDateLiteralTypeIsSpecified() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j BETWEEN DATE'1990-11-10' AND DATE'1990-11-11')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='>=', value=1990-11-10}, andOr='AND', rhs=LeafNode{keyName='j', operator='<=', value=1990-11-11}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBetweenExpressionWhenTimestampLiteralTypeIsNotSpecifiedNorQuoted() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("dt BETWEEN 2000-01-01 01:00:00 AND 2000-01-01 01:42:00)").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='>=', value=2000-01-01 01:00:00.0}, andOr='AND', rhs=LeafNode{keyName='dt', operator='<=', value=2000-01-01 01:42:00.0}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBetweenExpressionWhenTimestampLiteralTypeIsSpecified() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("dt BETWEEN TIMESTAMP'2000-01-01 01:00:00' AND TIMESTAMP'2000-01-01 01:42:00')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='>=', value=2000-01-01 01:00:00.0}, andOr='AND', rhs=LeafNode{keyName='dt', operator='<=', value=2000-01-01 01:42:00.0}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBinaryExpressionWhenDateLiteralTypeIsNotSpecifiedNorQuoted() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j = 1990-11-10 or j = 1990-11-11 and j = 1990-11-12)").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-10}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-11}, andOr='AND', rhs=LeafNode{keyName='j', operator='=', value=1990-11-12}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBinaryExpressionWhenDateLiteralTypeIsSpecified() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j = DATE'1990-11-10' or j = DATE'1990-11-11' and j = DATE'1990-11-12')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-10}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-11}, andOr='AND', rhs=LeafNode{keyName='j', operator='=', value=1990-11-12}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBinaryExpressionWhenTimeStampLiteralTypeIsNotSpecifiedNorQuoted() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j = 1990-11-10 01:00:00 or j = 1990-11-11 01:00:24 and j = 1990-11-12 01:42:00)").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-10 01:00:00.0}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-11 01:00:24.0}, andOr='AND', rhs=LeafNode{keyName='j', operator='=', value=1990-11-12 01:42:00.0}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBinaryExpressionWhenTimeStampLiteralTypeIsSpecified() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j = TIMESTAMP'1990-11-10 01:00:00' or j = TIMESTAMP'1990-11-11 01:00:24' and j = TIMESTAMP'1990-11-12 01:42:00')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-10 01:00:00.0}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-11 01:00:24.0}, andOr='AND', rhs=LeafNode{keyName='j', operator='=', value=1990-11-12 01:42:00.0}}}"));
+  }
+
+
+  @Test
+  public void testGetFilterParserSingleColInExpressionWithIntLiteral() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(dt) IN (10, 20)").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='=', value=10}, andOr='OR', rhs=LeafNode{keyName='dt', operator='=', value=20}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBetweenExpressionWithIntLiteral() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("dt between 10 and 20").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='>=', value=10}, andOr='AND', rhs=LeafNode{keyName='dt', operator='<=', value=20}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBinaryExpressionWithIntLiteral() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("dt = 10 or dt = 20").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='=', value=10}, andOr='OR', rhs=LeafNode{keyName='dt', operator='=', value=20}}"));
+  }
+
+  @Test
+  public void testGetFilterParserSingleColInExpressionWithStringLiteral() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(dt) IN ('foo', 'bar')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='=', value=foo}, andOr='OR', rhs=LeafNode{keyName='dt', operator='=', value=bar}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBinaryExpressionWithStringLiteral() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("dt = 'foo' or dt = 'bar'").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='=', value=foo}, andOr='OR', rhs=LeafNode{keyName='dt', operator='=', value=bar}}"));
+  }
+
+  @Test
+  public void testGetFilterParserSingleColInExpressionWithStringLikeDate() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j) in ('1990-11-10', '1990-11-11', '1990-11-12')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-10}, andOr='OR', rhs=LeafNode{keyName='j', operator='=', value=1990-11-11}}, andOr='OR', rhs=LeafNode{keyName='j', operator='=', value=1990-11-12}}"));
+  }
+
+  @Test
+  public void testGetFilterParserMultiColInExpressionWithDateLikeString() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(struct(ds1,ds2)) IN (struct('2000-05-08','2001-04-08'), struct('2000-05-09','2001-04-09'))").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-08}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-08}}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-09}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-09}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBetweenExpressionWithStringLikeDate() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j BETWEEN '1990-11-10' AND '1990-11-11')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='>=', value=1990-11-10}, andOr='AND', rhs=LeafNode{keyName='j', operator='<=', value=1990-11-11}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBinaryExpressionWithStringLikeDate() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j = '1990-11-10' or j = '1990-11-11' and j = '1990-11-12')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-10}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-11}, andOr='AND', rhs=LeafNode{keyName='j', operator='=', value=1990-11-12}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserSingleColInExpressionWithStringLikeTimestamp() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(dt) IN ('2000-01-01 01:00:00', '2000-01-01 01:42:00')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='=', value=2000-01-01 01:00:00}, andOr='OR', rhs=LeafNode{keyName='dt', operator='=', value=2000-01-01 01:42:00}}"));
+  }
+
+  @Test
+  public void testGetFilterParserMultiColInExpressionWithTimestampLikeString() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(struct(ds1,ds2)) IN (struct('2000-05-08 01:00:00','2001-04-08 01:00:00'), struct('2000-05-09 01:00:00','2001-04-09 01:00:00'))").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-08 01:00:00}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-08 01:00:00}}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='ds1', operator='=', value=2000-05-09 01:00:00}, andOr='AND', rhs=LeafNode{keyName='ds2', operator='=', value=2001-04-09 01:00:00}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBetweenExpressionWithStringLikeTimestamp() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("dt BETWEEN '2000-01-01 01:00:00' AND '2000-01-01 01:42:00')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='dt', operator='>=', value=2000-01-01 01:00:00}, andOr='AND', rhs=LeafNode{keyName='dt', operator='<=', value=2000-01-01 01:42:00}}"));
+  }
+
+  @Test
+  public void testGetFilterParserBinaryExpressionWithStringLikeTimeStamp() throws MetaException {
+    ExpressionTree expressionTree = PartFilterExprUtil.getFilterParser("(j = '1990-11-10 01:00:00' or j = '1990-11-11 01:00:24' and j = '1990-11-12 01:42:00')").tree;
+    assertThat(expressionTree.getRoot().toString(), is("TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-10 01:00:00}, andOr='OR', rhs=TreeNode{lhs=LeafNode{keyName='j', operator='=', value=1990-11-11 01:00:24}, andOr='AND', rhs=LeafNode{keyName='j', operator='=', value=1990-11-12 01:42:00}}}"));
+  }
+
+  @Test
+  public void testGetFilterParserWithInvalidDateWithType() {
+    MetaException exception = assertThrows(MetaException.class,
+            () -> PartFilterExprUtil.getFilterParser("(j = DATE'2023-06-32')"));
+
+    assertTrue(exception.getMessage().contains("rule DateTimeLiteral failed"));
+  }
+
+  @Test
+  public void testGetFilterParserWithInvalidDateWithoutTypeNorQuoted() {
+    MetaException exception = assertThrows(MetaException.class,
+            () -> PartFilterExprUtil.getFilterParser("(j = 2023-06-32)"));
+
+    assertTrue(exception.getMessage().contains("rule DateTimeLiteral failed"));
+  }
+
+  @Test
+  public void testGetFilterParserWithInvalidTimestampWithType() {
+    MetaException exception = assertThrows(MetaException.class,
+            () -> PartFilterExprUtil.getFilterParser("(j = TIMESTAMP'2023-06-02 99:35:00')"));
+
+    assertTrue(exception.getMessage().contains("rule DateTimeLiteral failed"));
+  }
+
+  @Test
+  public void testGetFilterParserWithInvalidTimeStampWithoutTypeNorQuoted() {
+    MetaException exception = assertThrows(MetaException.class,
+            () -> PartFilterExprUtil.getFilterParser("(j = 2023-06-02 99:35:00)"));
+
+    assertTrue(exception.getMessage().contains("rule DateTimeLiteral failed"));
+  }
 }
