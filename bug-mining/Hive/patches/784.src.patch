diff --git a/ql/src/java/org/apache/hadoop/hive/ql/udf/UDFConv.java b/ql/src/java/org/apache/hadoop/hive/ql/udf/UDFConv.java
index 1d791e9324..624afd1445 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/udf/UDFConv.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/udf/UDFConv.java
@@ -45,7 +45,7 @@ public class UDFConv extends UDF {
    * Divide x by m as if x is an unsigned 64-bit integer. Examples:
    * unsignedLongDiv(-1, 2) == Long.MAX_VALUE unsignedLongDiv(6, 3) == 2
    * unsignedLongDiv(0, 5) == 0
-   * 
+   *
    * @param x
    *          is treated as unsigned
    * @param m
@@ -66,7 +66,7 @@ private long unsignedLongDiv(long x, int m) {
 
   /**
    * Decode val into value[].
-   * 
+   *
    * @param val
    *          is treated as an unsigned 64-bit integer
    * @param radix
@@ -84,17 +84,19 @@ private void decode(long val, int radix) {
   /**
    * Convert value[] into a long. On overflow, return -1 (as mySQL does). If a
    * negative digit is found, ignore the suffix starting there.
-   * 
+   *
    * @param radix
    *          must be between MIN_RADIX and MAX_RADIX
+   * @param fromPos
+   *          is the first element that should be conisdered
    * @return the result should be treated as an unsigned 64-bit integer.
    */
-  private long encode(int radix) {
+  private long encode(int radix, int fromPos) {
     long val = 0;
     long bound = unsignedLongDiv(-1 - radix, radix); // Possible overflow once
     // val
     // exceeds this value
-    for (int i = 0; i < value.length && value[i] >= 0; i++) {
+    for (int i = fromPos; i < value.length && value[i] >= 0; i++) {
       if (val >= bound) {
         // Check for overflow
         if (unsignedLongDiv(-1 - value[i], radix) < val) {
@@ -108,7 +110,7 @@ private long encode(int radix) {
 
   /**
    * Convert the bytes in value[] to the corresponding chars.
-   * 
+   *
    * @param radix
    *          must be between MIN_RADIX and MAX_RADIX
    * @param fromPos
@@ -124,7 +126,7 @@ private void byte2char(int radix, int fromPos) {
   /**
    * Convert the chars in value[] to the corresponding integers. Convert invalid
    * characters to -1.
-   * 
+   *
    * @param radix
    *          must be between MIN_RADIX and MAX_RADIX
    * @param fromPos
@@ -139,7 +141,7 @@ private void char2byte(int radix, int fromPos) {
   /**
    * Convert numbers between different number bases. If toBase>0 the result is
    * unsigned, otherwise it is signed.
-   * 
+   *
    */
   public Text evaluate(Text n, IntWritable fromBase, IntWritable toBase) {
     if (n == null || fromBase == null || toBase == null) {
@@ -168,7 +170,7 @@ public Text evaluate(Text n, IntWritable fromBase, IntWritable toBase) {
     char2byte(fromBs, value.length - n.getLength() + first);
 
     // Do the conversion by going through a 64 bit integer
-    long val = encode(fromBs);
+    long val = encode(fromBs, value.length - n.getLength() + first);
     if (negative && toBs > 0) {
       if (val < 0) {
         val = -1;
diff --git a/ql/src/test/queries/clientpositive/udf_conv.q b/ql/src/test/queries/clientpositive/udf_conv.q
index ea53deb47f..212bcfb579 100644
--- a/ql/src/test/queries/clientpositive/udf_conv.q
+++ b/ql/src/test/queries/clientpositive/udf_conv.q
@@ -67,3 +67,9 @@ SELECT
   conv(515, 5, 100),
   conv('10', -2, 2)
 FROM src LIMIT 1;
+
+-- Make sure that state is properly reset.
+
+SELECT conv(key, 10, 16),
+       conv(key, 16, 10)
+FROM src LIMIT 3;
diff --git a/ql/src/test/results/clientpositive/udf_conv.q.out b/ql/src/test/results/clientpositive/udf_conv.q.out
index b3aa16d9f2..010e1926cc 100644
--- a/ql/src/test/results/clientpositive/udf_conv.q.out
+++ b/ql/src/test/results/clientpositive/udf_conv.q.out
@@ -188,3 +188,22 @@ POSTHOOK: type: QUERY
 POSTHOOK: Input: default@src
 #### A masked pattern was here ####
 5	NULL	NULL	NULL
+PREHOOK: query: -- Make sure that state is properly reset.
+
+SELECT conv(key, 10, 16),
+       conv(key, 16, 10)
+FROM src LIMIT 3
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: -- Make sure that state is properly reset.
+
+SELECT conv(key, 10, 16),
+       conv(key, 16, 10)
+FROM src LIMIT 3
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+EE	568
+56	134
+137	785
