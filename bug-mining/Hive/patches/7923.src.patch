diff --git a/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/cache/TestCachedStoreUpdateUsingEvents.java b/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/cache/TestCachedStoreUpdateUsingEvents.java
index ae9685f50d..611f54809c 100644
--- a/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/cache/TestCachedStoreUpdateUsingEvents.java
+++ b/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/cache/TestCachedStoreUpdateUsingEvents.java
@@ -265,6 +265,8 @@ public void testTableOpsForUpdateUsingEvents() throws Exception {
     Table newTable = new Table(tbl);
     newTable.setOwner(tblOwner);
     newTable.setOwnerType(PrincipalType.ROLE);
+    Deadline.registerIfNot(100_000);
+    Deadline.startTimer("alter_table");
     hmsHandler.alter_table(dbName, tblName, newTable);
     newTable = rawStore.getTable(DEFAULT_CATALOG_NAME, dbName, tblName);
 
@@ -309,6 +311,8 @@ public void testConstraintsForUpdateUsingEvents() throws Exception {
     String dbName = "Test_Table_Ops";
     String dbOwner = "user1";
     Database db = createTestDb(dbName, dbOwner);
+    Deadline.registerIfNot(100_000);
+    Deadline.startTimer("create_database");
     hmsHandler.create_database(db);
     db = rawStore.getDatabase(DEFAULT_CATALOG_NAME, dbName);
 
diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java
index d68e76d594..b700a887b2 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java
@@ -346,7 +346,7 @@ public void alterTable(RawStore msdb, Warehouse wh, String catName, String dbnam
                   partBatch, newt.getWriteId(), writeIdList);
             }
           }
-
+          Deadline.checkTimeout();
           for (Entry<Partition, ColumnStatistics> partColStats : columnStatsNeedUpdated.entries()) {
             ColumnStatistics newPartColStats = partColStats.getValue();
             newPartColStats.getStatsDesc().setDbName(newDbName);
@@ -389,6 +389,7 @@ public void alterTable(RawStore msdb, Warehouse wh, String catName, String dbnam
                 List<ColumnStatistics> colStats = updateOrGetPartitionColumnStats(msdb, catName, dbname, name,
                     part.getValues(), oldCols, oldt, part, null, null);
                 assert (colStats.isEmpty());
+                Deadline.checkTimeout();
                 if (cascade) {
                   msdb.alterPartition(
                     catName, dbname, name, part.getValues(), part, writeIdList);
@@ -562,6 +563,7 @@ public Partition alterPartition(RawStore msdb, Warehouse wh, String catName, Str
           updateOrGetPartitionColumnStats(msdb, catName, dbname, name, new_part.getValues(),
               oldPart.getSd().getCols(), tbl, new_part, null, null);
         }
+        Deadline.checkTimeout();
         msdb.alterPartition(
             catName, dbname, name, new_part.getValues(), new_part, validWriteIds);
         if (transactionalListeners != null && !transactionalListeners.isEmpty()) {
@@ -1062,8 +1064,8 @@ public static List<ColumnStatistics> alterTableUpdateTableColumnStats(RawStore m
           }
         }
       }
-
       if (doAlterTable) {
+        Deadline.checkTimeout();
         // Change to new table and append stats for the new table
         msdb.alterTable(catName, dbName, tableName, newTable, validWriteIds);
         if (updateColumnStats) {
@@ -1131,6 +1133,7 @@ public static List<ColumnStatistics> updateOrGetPartitionColumnStats(
                 break;
               }
             }
+            Deadline.checkTimeout();
             if (found) {
               if (rename) {
                 if (updateColumnStats) {
diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
index 4c2414e521..f08aeec8dc 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
@@ -21,6 +21,8 @@
 import static org.apache.commons.lang3.StringUtils.join;
 import static org.apache.commons.lang3.StringUtils.normalizeSpace;
 import static org.apache.commons.lang3.StringUtils.repeat;
+import static org.apache.hadoop.hive.metastore.MetastoreDirectSqlUtils.throwMetaOrRuntimeException;
+
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.Statement;
@@ -1760,9 +1762,8 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
     String queryText = null;
     long start = 0;
     long end = 0;
-    Query query = null;
+
     boolean doTrace = LOG.isDebugEnabled();
-    Object qResult = null;
     ForwardQueryResult<?> fqr = null;
     // Check if the status of all the columns of all the partitions exists
     // Extrapolation is not needed.
@@ -1772,23 +1773,29 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
           + " and \"ENGINE\" = ? "
           + " group by \"COLUMN_NAME\", \"COLUMN_TYPE\"";
       start = doTrace ? System.nanoTime() : 0;
-      query = pm.newQuery("javax.jdo.query.SQL", queryText);
-      qResult = executeWithArray(query, prepareParams(catName, dbName, tableName, partNames, colNames, engine),
-          queryText);
-      if (qResult == null) {
-        query.closeAll();
+      try (Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+        Object qResult = executeWithArray(query,
+            prepareParams(catName, dbName, tableName, partNames, colNames,
+                engine), queryText);
+        if (qResult == null) {
+          query.closeAll();
+          return Collections.emptyList();
+        }
+        end = doTrace ? System.nanoTime() : 0;
+        MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
+        List<Object[]> list = MetastoreDirectSqlUtils.ensureList(qResult);
+        List<ColumnStatisticsObj> colStats =
+            new ArrayList<ColumnStatisticsObj>(list.size());
+        for (Object[] row : list) {
+          colStats.add(prepareCSObjWithAdjustedNDV(row, 0,
+              useDensityFunctionForNDVEstimation, ndvTuner));
+          Deadline.checkTimeout();
+        }
+        return colStats;
+      } catch (Exception e) {
+        throwMetaOrRuntimeException(e);
         return Collections.emptyList();
       }
-      end = doTrace ? System.nanoTime() : 0;
-      MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-      List<Object[]> list = MetastoreDirectSqlUtils.ensureList(qResult);
-      List<ColumnStatisticsObj> colStats = new ArrayList<ColumnStatisticsObj>(list.size());
-      for (Object[] row : list) {
-        colStats.add(prepareCSObjWithAdjustedNDV(row, 0, useDensityFunctionForNDVEstimation, ndvTuner));
-        Deadline.checkTimeout();
-      }
-      query.closeAll();
-      return colStats;
     } else {
       // Extrapolation is needed for some columns.
       // In this case, at least a column status for a partition is missing.
@@ -1802,35 +1809,40 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
           + " and \"ENGINE\" = ? "
           + " group by \"COLUMN_NAME\", \"COLUMN_TYPE\"";
       start = doTrace ? System.nanoTime() : 0;
-      query = pm.newQuery("javax.jdo.query.SQL", queryText);
-      qResult = executeWithArray(query, prepareParams(catName, dbName, tableName, partNames, colNames, engine),
-          queryText);
-      end = doTrace ? System.nanoTime() : 0;
-      MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-      if (qResult == null) {
-        query.closeAll();
-        return Collections.emptyList();
-      }
       List<String> noExtraColumnNames = new ArrayList<String>();
       Map<String, String[]> extraColumnNameTypeParts = new HashMap<String, String[]>();
-      List<Object[]> list = MetastoreDirectSqlUtils.ensureList(qResult);
-      for (Object[] row : list) {
-        String colName = (String) row[0];
-        String colType = (String) row[1];
-        // Extrapolation is not needed for this column if
-        // count(\"PARTITION_NAME\")==partNames.size()
-        // Or, extrapolation is not possible for this column if
-        // count(\"PARTITION_NAME\")<2
-        Long count = MetastoreDirectSqlUtils.extractSqlLong(row[2]);
-        if (count == partNames.size() || count < 2) {
-          noExtraColumnNames.add(colName);
-        } else {
-          extraColumnNameTypeParts.put(colName, new String[] { colType, String.valueOf(count) });
+      try(Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+        Object qResult = executeWithArray(query,
+            prepareParams(catName, dbName, tableName, partNames, colNames,
+                engine), queryText);
+        end = doTrace ? System.nanoTime() : 0;
+        MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
+        if (qResult == null) {
+          query.closeAll();
+          return Collections.emptyList();
         }
-        Deadline.checkTimeout();
+
+        List<Object[]> list = MetastoreDirectSqlUtils.ensureList(qResult);
+        for (Object[] row : list) {
+          String colName = (String) row[0];
+          String colType = (String) row[1];
+          // Extrapolation is not needed for this column if
+          // count(\"PARTITION_NAME\")==partNames.size()
+          // Or, extrapolation is not possible for this column if
+          // count(\"PARTITION_NAME\")<2
+          Long count = MetastoreDirectSqlUtils.extractSqlLong(row[2]);
+          if (count == partNames.size() || count < 2) {
+            noExtraColumnNames.add(colName);
+          } else {
+            extraColumnNameTypeParts.put(colName, new String[] {colType, String.valueOf(count)});
+          }
+          Deadline.checkTimeout();
+        }
+      } catch (Exception e) {
+        throwMetaOrRuntimeException(e);
       }
-      query.closeAll();
       // Extrapolation is not needed for columns noExtraColumnNames
+      List<Object[]> list;
       if (noExtraColumnNames.size() != 0) {
         queryText = commonPrefix + " and \"COLUMN_NAME\" in ("
             + makeParams(noExtraColumnNames.size()) + ")" + " and \"PARTITION_NAME\" in ("
@@ -1838,21 +1850,25 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
             + " and \"ENGINE\" = ? "
             + " group by \"COLUMN_NAME\", \"COLUMN_TYPE\"";
         start = doTrace ? System.nanoTime() : 0;
-        query = pm.newQuery("javax.jdo.query.SQL", queryText);
-        qResult = executeWithArray(query,
-            prepareParams(catName, dbName, tableName, partNames, noExtraColumnNames, engine), queryText);
-        if (qResult == null) {
-          query.closeAll();
-          return Collections.emptyList();
-        }
-        list = MetastoreDirectSqlUtils.ensureList(qResult);
-        for (Object[] row : list) {
-          colStats.add(prepareCSObjWithAdjustedNDV(row, 0, useDensityFunctionForNDVEstimation, ndvTuner));
-          Deadline.checkTimeout();
+
+        try (Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+          Object qResult = executeWithArray(query,
+              prepareParams(catName, dbName, tableName, partNames, noExtraColumnNames, engine), queryText);
+          if (qResult == null) {
+            query.closeAll();
+            return Collections.emptyList();
+          }
+          list = MetastoreDirectSqlUtils.ensureList(qResult);
+          for (Object[] row : list) {
+            colStats.add(prepareCSObjWithAdjustedNDV(row, 0,
+                useDensityFunctionForNDVEstimation, ndvTuner));
+            Deadline.checkTimeout();
+          }
+          end = doTrace ? System.nanoTime() : 0;
+          MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
+        } catch (Exception e) {
+          throwMetaOrRuntimeException(e);
         }
-        end = doTrace ? System.nanoTime() : 0;
-        MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-        query.closeAll();
       }
       // Extrapolation is needed for extraColumnNames.
       // give a sequence number for all the partitions
@@ -1870,30 +1886,33 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
             + " and \"ENGINE\" = ? "
             + " group by \"COLUMN_NAME\"";
         start = doTrace ? System.nanoTime() : 0;
-        query = pm.newQuery("javax.jdo.query.SQL", queryText);
-        List<String> extraColumnNames = new ArrayList<String>();
-        extraColumnNames.addAll(extraColumnNameTypeParts.keySet());
-        qResult = executeWithArray(query,
-            prepareParams(catName, dbName, tableName, partNames, extraColumnNames, engine), queryText);
-        if (qResult == null) {
-          query.closeAll();
-          return Collections.emptyList();
-        }
-        list = MetastoreDirectSqlUtils.ensureList(qResult);
-        // see the indexes for colstats in IExtrapolatePartStatus
-        Integer[] sumIndex = new Integer[] { 6, 10, 11, 15 };
-        for (Object[] row : list) {
-          Map<Integer, Object> indexToObject = new HashMap<Integer, Object>();
-          for (int ind = 1; ind < row.length; ind++) {
-            indexToObject.put(sumIndex[ind - 1], row[ind]);
+        try (Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+          List<String> extraColumnNames = new ArrayList<String>();
+          extraColumnNames.addAll(extraColumnNameTypeParts.keySet());
+          Object qResult = executeWithArray(query,
+              prepareParams(catName, dbName, tableName, partNames,
+                  extraColumnNames, engine), queryText);
+          if (qResult == null) {
+            query.closeAll();
+            return Collections.emptyList();
           }
-          // row[0] is the column name
-          sumMap.put((String) row[0], indexToObject);
-          Deadline.checkTimeout();
+          list = MetastoreDirectSqlUtils.ensureList(qResult);
+          // see the indexes for colstats in IExtrapolatePartStatus
+          Integer[] sumIndex = new Integer[] {6, 10, 11, 15};
+          for (Object[] row : list) {
+            Map<Integer, Object> indexToObject = new HashMap<Integer, Object>();
+            for (int ind = 1; ind < row.length; ind++) {
+              indexToObject.put(sumIndex[ind - 1], row[ind]);
+            }
+            // row[0] is the column name
+            sumMap.put((String) row[0], indexToObject);
+            Deadline.checkTimeout();
+          }
+          end = doTrace ? System.nanoTime() : 0;
+          MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
+        } catch (Exception e) {
+          throwMetaOrRuntimeException(e);
         }
-        end = doTrace ? System.nanoTime() : 0;
-        MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-        query.closeAll();
         for (Map.Entry<String, String[]> entry : extraColumnNameTypeParts.entrySet()) {
           Object[] row = new Object[IExtrapolatePartStatus.colStatNames.length + 2];
           String colName = entry.getKey();
@@ -1951,24 +1970,27 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
                     + " order by cast(\"" + colStatName + "\" as decimal)";
               }
               start = doTrace ? System.nanoTime() : 0;
-              query = pm.newQuery("javax.jdo.query.SQL", queryText);
-              qResult = executeWithArray(query,
-                  prepareParams(catName, dbName, tableName, partNames, Arrays.asList(colName), engine), queryText);
-              if (qResult == null) {
+              try (Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+                Object qResult = executeWithArray(query,
+                    prepareParams(catName, dbName, tableName, partNames, Arrays.asList(colName), engine), queryText);
+                if (qResult == null) {
+                  query.closeAll();
+                  return Collections.emptyList();
+                }
+                fqr = (ForwardQueryResult<?>) qResult;
+                Object[] min = (Object[]) (fqr.get(0));
+                Object[] max = (Object[]) (fqr.get(fqr.size() - 1));
+                end = doTrace ? System.nanoTime() : 0;
+                MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
                 query.closeAll();
-                return Collections.emptyList();
-              }
-              fqr = (ForwardQueryResult<?>) qResult;
-              Object[] min = (Object[]) (fqr.get(0));
-              Object[] max = (Object[]) (fqr.get(fqr.size() - 1));
-              end = doTrace ? System.nanoTime() : 0;
-              MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-              query.closeAll();
-              if (min[0] == null || max[0] == null) {
-                row[2 + colStatIndex] = null;
-              } else {
-                row[2 + colStatIndex] = extrapolateMethod.extrapolate(min, max, colStatIndex,
-                    indexMap);
+                if (min[0] == null || max[0] == null) {
+                  row[2 + colStatIndex] = null;
+                } else {
+                  row[2 + colStatIndex] = extrapolateMethod
+                      .extrapolate(min, max, colStatIndex, indexMap);
+                }
+              } catch (Exception e) {
+                throwMetaOrRuntimeException(e);
               }
             } else {
               // if the aggregation type is avg, we use the average on the existing ones.
@@ -1982,21 +2004,24 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
                   + " and \"ENGINE\" = ? "
                   + " group by \"COLUMN_NAME\"";
               start = doTrace ? System.nanoTime() : 0;
-              query = pm.newQuery("javax.jdo.query.SQL", queryText);
-              qResult = executeWithArray(query,
-                  prepareParams(catName, dbName, tableName, partNames, Arrays.asList(colName), engine), queryText);
-              if (qResult == null) {
+              try(Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+                Object qResult = executeWithArray(query,
+                    prepareParams(catName, dbName, tableName, partNames, Arrays.asList(colName), engine), queryText);
+                if (qResult == null) {
+                  query.closeAll();
+                  return Collections.emptyList();
+                }
+                fqr = (ForwardQueryResult<?>) qResult;
+                Object[] avg = (Object[]) (fqr.get(0));
+                // colStatIndex=12,13,14 respond to "AVG_LONG", "AVG_DOUBLE",
+                // "AVG_DECIMAL"
+                row[2 + colStatIndex] = avg[colStatIndex - 12];
+                end = doTrace ? System.nanoTime() : 0;
+                MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
                 query.closeAll();
-                return Collections.emptyList();
+              } catch (Exception e) {
+                throwMetaOrRuntimeException(e);
               }
-              fqr = (ForwardQueryResult<?>) qResult;
-              Object[] avg = (Object[]) (fqr.get(0));
-              // colStatIndex=12,13,14 respond to "AVG_LONG", "AVG_DOUBLE",
-              // "AVG_DECIMAL"
-              row[2 + colStatIndex] = avg[colStatIndex - 12];
-              end = doTrace ? System.nanoTime() : 0;
-              MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-              query.closeAll();
             }
           }
           colStats.add(prepareCSObjWithAdjustedNDV(row, 0, useDensityFunctionForNDVEstimation, ndvTuner));
@@ -2094,22 +2119,26 @@ public List<Object[]> run(List<String> inputPartNames) throws MetaException {
         Math.min(list.size(), partNames.size()));
     String lastPartName = null;
     int from = 0;
-    for (int i = 0; i <= list.size(); ++i) {
-      boolean isLast = i == list.size();
-      String partName = isLast ? null : (String)list.get(i)[0];
-      if (!isLast && partName.equals(lastPartName)) {
-        continue;
-      } else if (from != i) {
-        ColumnStatisticsDesc csd = new ColumnStatisticsDesc(false, dbName, tableName);
-        csd.setCatName(catName);
-        csd.setPartName(lastPartName);
-        result.add(makeColumnStats(list.subList(from, i), csd, 1, engine));
-      }
-      lastPartName = partName;
-      from = i;
-      Deadline.checkTimeout();
+    try {
+      for (int i = 0; i <= list.size(); ++i) {
+        boolean isLast = i == list.size();
+        String partName = isLast ? null : (String) list.get(i)[0];
+        if (!isLast && partName.equals(lastPartName)) {
+          continue;
+        } else if (from != i) {
+          ColumnStatisticsDesc csd =
+              new ColumnStatisticsDesc(false, dbName, tableName);
+          csd.setCatName(catName);
+          csd.setPartName(lastPartName);
+          result.add(makeColumnStats(list.subList(from, i), csd, 1, engine));
+        }
+        lastPartName = partName;
+        from = i;
+        Deadline.checkTimeout();
+      }
+    } finally {
+      b.closeAllQueries();
     }
-    b.closeAllQueries();
     return result;
   }
 
diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetastoreDirectSqlUtils.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetastoreDirectSqlUtils.java
index 53641d4200..77f9b28602 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetastoreDirectSqlUtils.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetastoreDirectSqlUtils.java
@@ -123,38 +123,46 @@ static <T> int loopJoinOrderedResult(PersistenceManager pm, TreeMap<Long, T> tre
       String queryText, Object[] parameters, int keyIndex, ApplyFunc<T> func) throws MetaException {
     boolean doTrace = LOG.isDebugEnabled();
     long start = doTrace ? System.nanoTime() : 0;
-    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    Object result = null;
-    if (parameters == null || parameters.length == 0) {
-      result = query.execute();
-    } else {
-      result = query.executeWithArray(parameters);
-    }
-    long queryTime = doTrace ? System.nanoTime() : 0;
-    if (result == null) {
-      query.closeAll();
-      return 0;
-    }
-    List<Object[]> list = ensureList(result);
-    Iterator<Object[]> iter = list.iterator();
-    Object[] fields = null;
-    for (Map.Entry<Long, T> entry : tree.entrySet()) {
-      if (fields == null && !iter.hasNext()) break;
-      long id = entry.getKey();
-      while (fields != null || iter.hasNext()) {
-        if (fields == null) {
-          fields = iter.next();
+    int rv = 0;
+    long queryTime = 0;
+    try (Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+      Object result = null;
+      if (parameters == null || parameters.length == 0) {
+        result = query.execute();
+      } else {
+        result = query.executeWithArray(parameters);
+      }
+      queryTime = doTrace ? System.nanoTime() : 0;
+      if (result == null) {
+        query.closeAll();
+        return 0;
+      }
+      List<Object[]> list = ensureList(result);
+      Iterator<Object[]> iter = list.iterator();
+      Object[] fields = null;
+      for (Map.Entry<Long, T> entry : tree.entrySet()) {
+        if (fields == null && !iter.hasNext())
+          break;
+        long id = entry.getKey();
+        while (fields != null || iter.hasNext()) {
+          if (fields == null) {
+            fields = iter.next();
+          }
+          long nestedId = extractSqlLong(fields[keyIndex]);
+          if (nestedId < id) {
+            throw new MetaException("Found entries for unknown ID " + nestedId);
+          }
+          if (nestedId > id)
+            break; // fields belong to one of the next entries
+          func.apply(entry.getValue(), fields);
+          fields = null;
         }
-        long nestedId = extractSqlLong(fields[keyIndex]);
-        if (nestedId < id) throw new MetaException("Found entries for unknown ID " + nestedId);
-        if (nestedId > id) break; // fields belong to one of the next entries
-        func.apply(entry.getValue(), fields);
-        fields = null;
+        Deadline.checkTimeout();
       }
-      Deadline.checkTimeout();
+      rv = list.size();
+    } catch (Exception e) {
+      throwMetaOrRuntimeException(e);
     }
-    int rv = list.size();
-    query.closeAll();
     timingTrace(doTrace, queryText, start, queryTime);
     return rv;
   }
@@ -597,4 +605,14 @@ else if (value instanceof byte[]) {
   static interface ApplyFunc<Target> {
     void apply(Target t, Object[] fields) throws MetaException;
   }
+
+  public static void throwMetaOrRuntimeException(Exception e) throws MetaException {
+    if (e instanceof MetaException) {
+      throw (MetaException) e;
+    } else if (e instanceof RuntimeException) {
+      throw (RuntimeException) e;
+    } else {
+      throw new RuntimeException(e);
+    }
+  }
 }
diff --git a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestHiveAlterHandler.java b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestHiveAlterHandler.java
index 88d5e716e1..379dc98631 100644
--- a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestHiveAlterHandler.java
+++ b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestHiveAlterHandler.java
@@ -60,6 +60,8 @@ public void testAlterTableAddColNotUpdateStats() throws MetaException, InvalidOb
         getDefaultCatalog(conf), oldTable.getDbName(), oldTable.getTableName(), Arrays.asList("col1", "col2", "col3"));
     HiveAlterHandler handler = new HiveAlterHandler();
     handler.setConf(conf);
+    Deadline.registerIfNot(100_000);
+    Deadline.startTimer("alterTableUpdateTableColumnStats");
     handler.alterTableUpdateTableColumnStats(msdb, oldTable, newTable, null, null, conf, null);
   }
 
@@ -85,6 +87,8 @@ public void testAlterTableDelColUpdateStats() throws Exception {
     RawStore msdb = Mockito.mock(RawStore.class);
     HiveAlterHandler handler = new HiveAlterHandler();
     handler.setConf(conf);
+    Deadline.registerIfNot(100_000);
+    Deadline.startTimer("alterTableUpdateTableColumnStats");
     try {
       handler.alterTableUpdateTableColumnStats(msdb, oldTable, newTable, null, null, conf, null);
     } catch (Throwable t) {
@@ -121,6 +125,8 @@ public void testAlterTableChangePosNotUpdateStats() throws MetaException, Invali
         getDefaultCatalog(conf), oldTable.getDbName(), oldTable.getTableName(), Arrays.asList("col1", "col2", "col3", "col4"));
     HiveAlterHandler handler = new HiveAlterHandler();
     handler.setConf(conf);
+    Deadline.registerIfNot(100_000);
+    Deadline.startTimer("alterTableUpdateTableColumnStats");
     handler.alterTableUpdateTableColumnStats(msdb, oldTable, newTable, null, null, conf, null);
   }
 
