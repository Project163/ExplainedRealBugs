diff --git a/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java b/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java
index f666d30d32..58615e1391 100644
--- a/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java
+++ b/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java
@@ -2893,7 +2893,10 @@ public static enum ConfVars {
         "Ensures commands with OVERWRITE (such as INSERT OVERWRITE) acquire Exclusive locks for\n" +
         "transactional tables. This ensures that inserts (w/o overwrite) running concurrently\n" +
         "are not hidden by the INSERT OVERWRITE."),
-    TXN_WRITE_X_LOCK("hive.txn.write.xlock", true,
+    TXN_MERGE_INSERT_X_LOCK("hive.txn.xlock.mergeinsert", false,
+        "Ensures MERGE INSERT operations acquire EXCLUSIVE / EXCL_WRITE lock for transactional tables.\n" +
+        "If enabled, prevents duplicates when MERGE statements are executed in parallel transactions."),
+    TXN_WRITE_X_LOCK("hive.txn.xlock.write", true,
         "Manages concurrency levels for ACID resources. Provides better level of query parallelism by enabling " +
         "shared writes and write-write conflict resolution at the commit step." +
         "- If true - exclusive writes are used:\n" +
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/io/AcidUtils.java b/ql/src/java/org/apache/hadoop/hive/ql/io/AcidUtils.java
index bde6c67e52..991f1513c7 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/io/AcidUtils.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/io/AcidUtils.java
@@ -3013,16 +3013,16 @@ Seems much cleaner if each stmt is identified as a particular HiveOperation (whi
         assert t != null;
         if (AcidUtils.isTransactionalTable(t)) {
           if (sharedWrite) {
-            if (!isMerge) {
-              compBuilder.setSharedWrite();
-            } else {
+            if (conf.getBoolVar(ConfVars.TXN_MERGE_INSERT_X_LOCK) && isMerge) {
               compBuilder.setExclWrite();
+            } else {
+              compBuilder.setSharedWrite();
             }
           } else {
-            if (!isMerge) {
-              compBuilder.setSharedRead();
-            } else {
+            if (conf.getBoolVar(ConfVars.TXN_MERGE_INSERT_X_LOCK) && isMerge) {
               compBuilder.setExclusive();
+            } else {
+              compBuilder.setSharedRead();
             }
           }
         } else if (MetaStoreUtils.isNonNativeTable(t.getTTable())) {
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/lockmgr/DbTxnManagerEndToEndTestBase.java b/ql/src/test/org/apache/hadoop/hive/ql/lockmgr/DbTxnManagerEndToEndTestBase.java
index bbbd365d79..651969b452 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/lockmgr/DbTxnManagerEndToEndTestBase.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/lockmgr/DbTxnManagerEndToEndTestBase.java
@@ -49,6 +49,7 @@ public DbTxnManagerEndToEndTestBase() {
     conf.setVar(HiveConf.ConfVars.HIVE_AUTHORIZATION_MANAGER,
             "org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory");
     conf.setBoolVar(HiveConf.ConfVars.HIVE_VECTORIZATION_ENABLED, false);
+    conf.setBoolVar(HiveConf.ConfVars.TXN_MERGE_INSERT_X_LOCK, true);
     TxnDbUtil.setConfValues(conf);
   }
   @BeforeClass
diff --git a/ql/src/test/queries/clientpositive/explain_locks.q b/ql/src/test/queries/clientpositive/explain_locks.q
index 071f4b04fd..467fdd2517 100644
--- a/ql/src/test/queries/clientpositive/explain_locks.q
+++ b/ql/src/test/queries/clientpositive/explain_locks.q
@@ -1,6 +1,6 @@
 set hive.support.concurrency=true;
 set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;
-set hive.txn.write.xlock=true;
+set hive.txn.xlock.write=true;
 
 explain locks drop table test_explain_locks;
 explain locks create table test_explain_locks (a int, b int);
@@ -21,7 +21,7 @@ explain formatted locks update source set b1 = 1 where p1 in (select t.q from ta
 -- the extra predicates in when matched clause match 1 partition
 explain locks merge into target t using source s on t.a = s.a1 when matched and p = 1 and q = 2 then update set b = 1 when matched and p = 2 and q = 2 then delete when not matched and a1 > 100 then insert values(s.a1,s.b1,s.p1, s.q1);
 
-set hive.txn.write.xlock=false;
+set hive.txn.xlock.write=false;
 explain locks update target set b = 1 where p in (select t.q1 from source t where t.a1=5);
 
 explain locks update source set b1 = 1 where p1 in (select t.q from target t where t.p=2);
diff --git a/ql/src/test/results/clientpositive/llap/explain_locks.q.out b/ql/src/test/results/clientpositive/llap/explain_locks.q.out
index 667e6d69ad..692177dfaf 100644
--- a/ql/src/test/results/clientpositive/llap/explain_locks.q.out
+++ b/ql/src/test/results/clientpositive/llap/explain_locks.q.out
@@ -151,7 +151,7 @@ default.target.p=1/q=3 -> EXCL_WRITE
 default.target.p=1/q=3 -> EXCL_WRITE
 default.target.p=1/q=2 -> EXCL_WRITE
 default.target.p=1/q=2 -> EXCL_WRITE
-default.target -> EXCLUSIVE
+default.target -> SHARED_READ
 PREHOOK: query: explain locks update target set b = 1 where p in (select t.q1 from source t where t.a1=5)
 PREHOOK: type: QUERY
 PREHOOK: Input: default@source
@@ -249,4 +249,4 @@ default.target.p=1/q=3 -> SHARED_WRITE
 default.target.p=1/q=3 -> SHARED_WRITE
 default.target.p=1/q=2 -> SHARED_WRITE
 default.target.p=1/q=2 -> SHARED_WRITE
-default.target -> EXCL_WRITE
+default.target -> SHARED_WRITE
