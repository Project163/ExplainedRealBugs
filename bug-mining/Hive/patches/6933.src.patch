diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ConstantPropagateProcFactory.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ConstantPropagateProcFactory.java
index 54d52f8c2a..11159d2e90 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ConstantPropagateProcFactory.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ConstantPropagateProcFactory.java
@@ -63,7 +63,6 @@
 import org.apache.hadoop.hive.ql.plan.JoinDesc;
 import org.apache.hadoop.hive.ql.plan.ReduceSinkDesc;
 import org.apache.hadoop.hive.ql.plan.TableScanDesc;
-import org.apache.hadoop.hive.ql.udf.UDFType;
 import org.apache.hadoop.hive.ql.udf.generic.GenericUDF;
 import org.apache.hadoop.hive.ql.udf.generic.GenericUDF.DeferredJavaObject;
 import org.apache.hadoop.hive.ql.udf.generic.GenericUDFBaseCompare;
@@ -471,7 +470,7 @@ private static ExprNodeDesc foldExprFull(ExprNodeDesc desc, Map<ColumnInfo, Expr
   private static boolean isConstantFoldableUdf(GenericUDF udf,  List<ExprNodeDesc> children) {
     // Runtime constants + deterministic functions can be folded.
     if (!FunctionRegistry.isConsistentWithinQuery(udf)) {
-      if (udf.getClass().equals(GenericUDFUnixTimeStamp.class) 
+      if (udf.getClass().equals(GenericUDFUnixTimeStamp.class)
           && children != null && children.size() > 0) {
         // unix_timestamp is polymorphic (ignore class annotations)
         return true;
@@ -640,8 +639,10 @@ private static ExprNodeDesc shortcutFunction(GenericUDF udf, List<ExprNodeDesc>
             // if true, prune it
             positionsToRemove.set(i);
           } else {
-            // if false, return false
-            return childExpr;
+            if (Boolean.FALSE.equals(c.getValue())) {
+              // if false, return false
+              return childExpr;
+            }
           }
         } else if (childExpr instanceof ExprNodeGenericFuncDesc &&
                 ((ExprNodeGenericFuncDesc)childExpr).getGenericUDF() instanceof GenericUDFOPNotNull &&
diff --git a/ql/src/test/queries/clientpositive/constant_prop_4.q b/ql/src/test/queries/clientpositive/constant_prop_4.q
new file mode 100644
index 0000000000..ba2069c3ea
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/constant_prop_4.q
@@ -0,0 +1,9 @@
+create table cx2(bool1 boolean);
+insert into cx2 values (true),(false),(null);
+
+set hive.cbo.enable=true;
+select bool1 IS TRUE OR (cast(NULL as boolean) AND bool1 IS NOT TRUE AND bool1 IS NOT FALSE) from cx2;
+
+set hive.cbo.enable=false;
+select bool1 IS TRUE OR (cast(NULL as boolean) AND bool1 IS NOT TRUE AND bool1 IS NOT FALSE) from cx2;
+
diff --git a/ql/src/test/results/clientpositive/constant_prop_4.q.out b/ql/src/test/results/clientpositive/constant_prop_4.q.out
new file mode 100644
index 0000000000..f40467b266
--- /dev/null
+++ b/ql/src/test/results/clientpositive/constant_prop_4.q.out
@@ -0,0 +1,39 @@
+PREHOOK: query: create table cx2(bool1 boolean)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:default
+PREHOOK: Output: default@cx2
+POSTHOOK: query: create table cx2(bool1 boolean)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:default
+POSTHOOK: Output: default@cx2
+PREHOOK: query: insert into cx2 values (true),(false),(null)
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+PREHOOK: Output: default@cx2
+POSTHOOK: query: insert into cx2 values (true),(false),(null)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+POSTHOOK: Output: default@cx2
+POSTHOOK: Lineage: cx2.bool1 SCRIPT []
+PREHOOK: query: select bool1 IS TRUE OR (cast(NULL as boolean) AND bool1 IS NOT TRUE AND bool1 IS NOT FALSE) from cx2
+PREHOOK: type: QUERY
+PREHOOK: Input: default@cx2
+#### A masked pattern was here ####
+POSTHOOK: query: select bool1 IS TRUE OR (cast(NULL as boolean) AND bool1 IS NOT TRUE AND bool1 IS NOT FALSE) from cx2
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@cx2
+#### A masked pattern was here ####
+true
+false
+NULL
+PREHOOK: query: select bool1 IS TRUE OR (cast(NULL as boolean) AND bool1 IS NOT TRUE AND bool1 IS NOT FALSE) from cx2
+PREHOOK: type: QUERY
+PREHOOK: Input: default@cx2
+#### A masked pattern was here ####
+POSTHOOK: query: select bool1 IS TRUE OR (cast(NULL as boolean) AND bool1 IS NOT TRUE AND bool1 IS NOT FALSE) from cx2
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@cx2
+#### A masked pattern was here ####
+true
+false
+NULL
