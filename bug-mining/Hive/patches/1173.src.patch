diff --git a/data/files/datatypes.txt b/data/files/datatypes.txt
index 66ef826f08..40e43ffdea 100644
--- a/data/files/datatypes.txt
+++ b/data/files/datatypes.txt
@@ -1,3 +1,3 @@
-\N\N\N\N\N\N\N\N\N\N\N\N\N\N\N\N\N\N
--1false-1.1\N\N\N-1-1-1.0-1\N\N\N\N
-1true1.11121x2ykva92.2111.01abcd1111213142212212x1abcd22012-04-22 09:00:00.123456789123456789.0123456
+\N\N\N\N\N\N\N\N\N\N\N\N\N\N\N\N\N\N\N
+-1false-1.1\N\N\N-1-1-1.0-1\N\N\N\N\N
+1true1.11121x2ykva92.2111.01abcd1111213142212212x1abcd22012-04-22 09:00:00.123456789123456789.0123456YWJjZA==
diff --git a/jdbc/src/java/org/apache/hive/jdbc/HiveBaseResultSet.java b/jdbc/src/java/org/apache/hive/jdbc/HiveBaseResultSet.java
index a65499b00d..775ebeefef 100644
--- a/jdbc/src/java/org/apache/hive/jdbc/HiveBaseResultSet.java
+++ b/jdbc/src/java/org/apache/hive/jdbc/HiveBaseResultSet.java
@@ -439,6 +439,15 @@ private Timestamp getTimestampValue(TStringValue tStringValue) {
     return null;
   }
 
+  private byte[] getBinaryValue(TStringValue tString) {
+    if (tString.isSetValue()) {
+      wasNull = false;
+      return tString.getValue().getBytes();
+    }
+    wasNull = true;
+    return null;
+  }
+
   private BigDecimal getBigDecimalValue(TStringValue tStringValue) {
     if (tStringValue.isSetValue()) {
       wasNull = false;
@@ -480,6 +489,8 @@ private Object getColumnValue(int columnIndex) throws SQLException {
       return getDoubleValue(tColumnValue.getDoubleVal());
     case STRING_TYPE:
       return getStringValue(tColumnValue.getStringVal());
+    case BINARY_TYPE:
+      return getBinaryValue(tColumnValue.getStringVal());
     case TIMESTAMP_TYPE:
       return getTimestampValue(tColumnValue.getStringVal());
     case DECIMAL_TYPE:
@@ -588,6 +599,9 @@ public String getString(int columnIndex) throws SQLException {
     if (wasNull) {
       return null;
     }
+    if (value instanceof byte[]){
+      return new String((byte[])value);
+    }
     return value.toString();
   }
 
diff --git a/jdbc/src/java/org/apache/hive/jdbc/HiveResultSetMetaData.java b/jdbc/src/java/org/apache/hive/jdbc/HiveResultSetMetaData.java
index 1eb18b9b58..378ba30ae1 100644
--- a/jdbc/src/java/org/apache/hive/jdbc/HiveResultSetMetaData.java
+++ b/jdbc/src/java/org/apache/hive/jdbc/HiveResultSetMetaData.java
@@ -114,6 +114,8 @@ public String getColumnTypeName(int column) throws SQLException {
       return serdeConstants.TIMESTAMP_TYPE_NAME;
     } else if ("decimal".equalsIgnoreCase(type)) {
       return serdeConstants.DECIMAL_TYPE_NAME;
+    } else if ("binary".equalsIgnoreCase(type)) {
+      return serdeConstants.BINARY_TYPE_NAME;
     } else if (type.startsWith("map<")) {
       return serdeConstants.STRING_TYPE_NAME;
     } else if (type.startsWith("array<")) {
diff --git a/jdbc/src/java/org/apache/hive/jdbc/Utils.java b/jdbc/src/java/org/apache/hive/jdbc/Utils.java
index 433b2c5bee..120c890707 100644
--- a/jdbc/src/java/org/apache/hive/jdbc/Utils.java
+++ b/jdbc/src/java/org/apache/hive/jdbc/Utils.java
@@ -132,6 +132,8 @@ public static int hiveTypeToSqlType(String type) throws SQLException {
       return Types.TIMESTAMP;
     } else if ("decimal".equalsIgnoreCase(type)) {
       return Types.DECIMAL;
+    } else if ("binary".equalsIgnoreCase(type)) {
+      return Types.BINARY;
     } else if (type.startsWith("map<")) {
       return Types.VARCHAR;
     } else if (type.startsWith("array<")) {
diff --git a/jdbc/src/test/org/apache/hive/jdbc/TestJdbcDriver2.java b/jdbc/src/test/org/apache/hive/jdbc/TestJdbcDriver2.java
index 2e5c30ea3f..b1bacd99a5 100644
--- a/jdbc/src/test/org/apache/hive/jdbc/TestJdbcDriver2.java
+++ b/jdbc/src/test/org/apache/hive/jdbc/TestJdbcDriver2.java
@@ -145,7 +145,8 @@ protected void setUp() throws Exception {
         + " c15 struct<r:int,s:struct<a:int,b:string>>,"
         + " c16 array<struct<m:map<string,string>,n:int>>,"
         + " c17 timestamp, "
-        + " c18 decimal) comment'" + dataTypeTableComment
+        + " c18 decimal, "
+        + " c19 binary) comment'" + dataTypeTableComment
             +"' partitioned by (dt STRING)");
 
     stmt.execute("load data local inpath '"
@@ -408,6 +409,9 @@ public void testDataTypes() throws Exception {
     assertEquals(null, res.getString(14));
     assertEquals(null, res.getString(15));
     assertEquals(null, res.getString(16));
+    assertEquals(null, res.getString(17));
+    assertEquals(null, res.getString(18));
+    assertEquals(null, res.getString(19));
 
     // row 2
     assertTrue(res.next());
@@ -430,6 +434,7 @@ public void testDataTypes() throws Exception {
     assertEquals(null, res.getString(17));
     assertEquals(null, res.getTimestamp(17));
     assertEquals(null, res.getBigDecimal(18));
+    assertEquals(null, res.getString(19));
 
     // row 3
     assertTrue(res.next());
@@ -452,6 +457,7 @@ public void testDataTypes() throws Exception {
     assertEquals("2012-04-22 09:00:00.123456789", res.getString(17));
     assertEquals("2012-04-22 09:00:00.123456789", res.getTimestamp(17).toString());
     assertEquals("123456789.0123456", res.getBigDecimal(18).toString());
+    assertEquals("abcd", res.getString(19));
 
     // test getBoolean rules on non-boolean columns
     assertEquals(true, res.getBoolean(1));
diff --git a/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java b/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java
index 405f0c732b..4bea83fa22 100644
--- a/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java
+++ b/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java
@@ -198,10 +198,16 @@ public RowSet getNextRowSet(FetchOrientation orientation, long maxRows) throws H
   private static Object convertLazyToJava(Object o, ObjectInspector oi) {
     Object obj = ObjectInspectorUtils.copyToStandardObject(o, oi, ObjectInspectorCopyOption.JAVA);
 
+    if (obj == null) {
+      return obj;
+    }
+    if(oi.getTypeName().equals(serdeConstants.BINARY_TYPE_NAME)) {
+      return new String((byte[])obj);
+    }
     // for now, expose non-primitive as a string
     // TODO: expose non-primitive as a structured object while maintaining JDBC compliance
-    if (obj != null && oi.getCategory() != ObjectInspector.Category.PRIMITIVE) {
-      obj = obj.toString();
+    if (oi.getCategory() != ObjectInspector.Category.PRIMITIVE) {
+      return obj.toString();
     }
 
     return obj;
