diff --git a/llap-client/src/java/org/apache/hadoop/hive/llap/tez/LlapProtocolClientProxy.java b/llap-client/src/java/org/apache/hadoop/hive/llap/tez/LlapProtocolClientProxy.java
index f48a1cbe72..ce75d722ab 100644
--- a/llap-client/src/java/org/apache/hadoop/hive/llap/tez/LlapProtocolClientProxy.java
+++ b/llap-client/src/java/org/apache/hadoop/hive/llap/tez/LlapProtocolClientProxy.java
@@ -81,6 +81,7 @@ public class LlapProtocolClientProxy extends AbstractService {
   private final ListeningExecutorService requestManagerExecutor;
   private volatile ListenableFuture<Void> requestManagerFuture;
   private final Token<LlapTokenIdentifier> llapToken;
+  private final String llapTokenUser;
 
   public LlapProtocolClientProxy(
       int numThreads, Configuration conf, Token<LlapTokenIdentifier> llapToken) {
@@ -88,6 +89,15 @@ public LlapProtocolClientProxy(
     this.hostProxies = new ConcurrentHashMap<>();
     this.socketFactory = NetUtils.getDefaultSocketFactory(conf);
     this.llapToken = llapToken;
+    if (llapToken != null) {
+      try {
+        llapTokenUser = llapToken.decodeIdentifier().getOwner().toString();
+      } catch (IOException e) {
+        throw new RuntimeException("Cannot determine the user from token " + llapToken, e);
+      }
+    } else {
+      llapTokenUser = null;
+    }
 
     long connectionTimeout = HiveConf.getTimeVar(conf,
         ConfVars.LLAP_TASK_COMMUNICATOR_CONNECTION_TIMEOUT_MS, TimeUnit.MILLISECONDS);
@@ -474,14 +484,10 @@ private LlapProtocolBlockingPB getProxy(final LlapNodeId nodeId) {
           LOG.debug("Creating a client without a token for " + nodeId);
         }
         proxy = new LlapProtocolClientImpl(getConfig(), nodeId.getHostname(),
-            nodeId.getPort(), retryPolicy, socketFactory);
+            nodeId.getPort(), null, retryPolicy, socketFactory);
       } else {
-        UserGroupInformation ugi;
-        try {
-          ugi = UserGroupInformation.getCurrentUser();
-        } catch (IOException e) {
-          throw new RuntimeException(e);
-        }
+        final UserGroupInformation ugi = UserGroupInformation.createRemoteUser(llapTokenUser);
+        // Clone the token as we'd need to set the service to the one we are talking to.
         Token<LlapTokenIdentifier> nodeToken = new Token<LlapTokenIdentifier>(llapToken);
         SecurityUtil.setTokenService(nodeToken, NetUtils.createSocketAddrForHost(
             nodeId.getHostname(), nodeId.getPort()));
@@ -493,7 +499,7 @@ private LlapProtocolBlockingPB getProxy(final LlapNodeId nodeId) {
           @Override
           public LlapProtocolBlockingPB run() {
            return new LlapProtocolClientImpl(getConfig(), nodeId.getHostname(),
-               nodeId.getPort(), retryPolicy, socketFactory);
+               nodeId.getPort(), ugi, retryPolicy, socketFactory);
           }
         });
       }
diff --git a/llap-common/src/java/org/apache/hadoop/hive/llap/impl/LlapProtocolClientImpl.java b/llap-common/src/java/org/apache/hadoop/hive/llap/impl/LlapProtocolClientImpl.java
index 9234b7d451..3681797eed 100644
--- a/llap-common/src/java/org/apache/hadoop/hive/llap/impl/LlapProtocolClientImpl.java
+++ b/llap-common/src/java/org/apache/hadoop/hive/llap/impl/LlapProtocolClientImpl.java
@@ -18,6 +18,7 @@
 import javax.net.SocketFactory;
 import java.io.IOException;
 import java.net.InetSocketAddress;
+import java.security.PrivilegedExceptionAction;
 
 import com.google.protobuf.RpcController;
 import com.google.protobuf.ServiceException;
@@ -37,22 +38,30 @@
 import org.apache.hadoop.net.NetUtils;
 import org.apache.hadoop.hive.llap.protocol.LlapProtocolBlockingPB;
 import org.apache.hadoop.security.UserGroupInformation;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 // TODO Change all this to be based on a regular interface instead of relying on the Proto service - Exception signatures cannot be controlled without this for the moment.
 
 
 public class LlapProtocolClientImpl implements LlapProtocolBlockingPB {
+  private final static Logger LOG = LoggerFactory.getLogger(LlapProtocolClientImpl.class);
 
   private final Configuration conf;
   private final InetSocketAddress serverAddr;
   private final RetryPolicy retryPolicy;
   private final SocketFactory socketFactory;
-  LlapProtocolBlockingPB proxy;
+  private LlapProtocolBlockingPB proxy;
+  private final UserGroupInformation ugi;
 
 
   public LlapProtocolClientImpl(Configuration conf, String hostname, int port,
+                                UserGroupInformation ugi,
                                 @Nullable RetryPolicy retryPolicy,
                                 @Nullable SocketFactory socketFactory) {
+    // Technically, methods run on a threadpool that is created externally with the UGI.
+    // However, that is brittle, so we'd save the UGI explicitly here.
+    this.ugi = ugi;
     this.conf = conf;
     this.serverAddr = NetUtils.createSocketAddr(hostname, port);
     this.retryPolicy = retryPolicy;
@@ -116,6 +125,21 @@ public LlapProtocolBlockingPB getProxy() throws IOException {
 
   public LlapProtocolBlockingPB createProxy() throws IOException {
     RPC.setProtocolEngine(conf, LlapProtocolBlockingPB.class, ProtobufRpcEngine.class);
+    LOG.info("Creating protocol proxy as " + ugi);
+    if (ugi == null) return createProxyInternal();
+    try {
+      return ugi.doAs(new PrivilegedExceptionAction<LlapProtocolBlockingPB>() {
+        @Override
+        public LlapProtocolBlockingPB run() throws IOException {
+          return createProxyInternal();
+        }
+      });
+    } catch (InterruptedException e) {
+      throw new IOException(e);
+    }
+  }
+
+  private LlapProtocolBlockingPB createProxyInternal() throws IOException {
     ProtocolProxy<LlapProtocolBlockingPB> proxy =
         RPC.getProtocolProxy(LlapProtocolBlockingPB.class, 0, serverAddr,
             UserGroupInformation.getCurrentUser(), conf, NetUtils.getDefaultSocketFactory(conf), 0,
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/LlapTokenChecker.java b/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/LlapTokenChecker.java
index beb5c7f3a0..c606c9bcb2 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/LlapTokenChecker.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/LlapTokenChecker.java
@@ -53,9 +53,25 @@ public static LlapTokenInfo getTokenInfo(String clusterId) throws IOException {
     if ((tokens == null || tokens.isEmpty()) && kerberosName == null) {
       throw new SecurityException("No tokens or kerberos for " + current);
     }
+    warnMultipleTokens(tokens);
     return getTokenInfoInternal(kerberosName, tokens);
   }
 
+  public static void warnMultipleTokens(List<LlapTokenIdentifier> tokens) {
+    if (tokens != null && tokens.size() > 1) {
+      StringBuilder sb = new StringBuilder("Found multiple LLAP tokens: [");
+      boolean isFirst = true;
+      for (LlapTokenIdentifier ti : tokens) {
+        if (!isFirst) {
+          sb.append(", ");
+        }
+        isFirst = false;
+        sb.append(ti);
+      }
+      LOG.warn(sb.append("]").toString());
+    }
+  }
+
   private static List<LlapTokenIdentifier> getLlapTokens(
       UserGroupInformation ugi, String clusterId) {
     List<LlapTokenIdentifier> tokens = null;
diff --git a/llap-server/src/test/org/apache/hadoop/hive/llap/daemon/impl/TestLlapDaemonProtocolServerImpl.java b/llap-server/src/test/org/apache/hadoop/hive/llap/daemon/impl/TestLlapDaemonProtocolServerImpl.java
index b38e9d6217..105a912cef 100644
--- a/llap-server/src/test/org/apache/hadoop/hive/llap/daemon/impl/TestLlapDaemonProtocolServerImpl.java
+++ b/llap-server/src/test/org/apache/hadoop/hive/llap/daemon/impl/TestLlapDaemonProtocolServerImpl.java
@@ -59,7 +59,7 @@ public void test() throws ServiceException, IOException {
 
       LlapProtocolBlockingPB client =
           new LlapProtocolClientImpl(new Configuration(), serverAddr.getHostName(),
-              serverAddr.getPort(), null, null);
+              serverAddr.getPort(), null, null, null);
       SubmitWorkResponseProto responseProto = client.submitWork(null,
           SubmitWorkRequestProto.newBuilder()
               .setAmHost("amhost")
diff --git a/llap-server/src/test/org/apache/hadoop/hive/llap/security/TestLlapSignerImpl.java b/llap-server/src/test/org/apache/hadoop/hive/llap/security/TestLlapSignerImpl.java
index a281fd6fb3..fbce98ae6d 100644
--- a/llap-server/src/test/org/apache/hadoop/hive/llap/security/TestLlapSignerImpl.java
+++ b/llap-server/src/test/org/apache/hadoop/hive/llap/security/TestLlapSignerImpl.java
@@ -169,7 +169,6 @@ private static class FakeSecretManager
     implements SigningSecretManager {
 
     public FakeSecretManager() {
-      // The keys instantly expire and are rolled.
       super(10000000, 10000000, 10000000, 10000000);
     }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDTFGetSplits.java b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDTFGetSplits.java
index 0705e2edab..3741ddff17 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDTFGetSplits.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDTFGetSplits.java
@@ -356,6 +356,7 @@ public InputSplit[] getSplits(JobConf job, int numSplits, TezWork work, Schema s
         // We put the query user, not LLAP user, into the message and token.
         Token<LlapTokenIdentifier> token = tokenClient.createToken(
             applicationId.toString(), queryUser, true);
+        LOG.info("Created the token for remote user: {}", token);
         bos.reset();
         token.write(dos);
         tokenBytes = bos.toByteArray();
