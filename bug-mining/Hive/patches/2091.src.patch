diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java
index 559ebb6eb7..99609173c8 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java
@@ -40,6 +40,7 @@
 import org.apache.hadoop.hive.ql.lockmgr.HiveLock;
 import org.apache.hadoop.hive.ql.lockmgr.HiveLockManager;
 import org.apache.hadoop.hive.ql.lockmgr.HiveLockObj;
+import org.apache.hadoop.hive.ql.metadata.Hive;
 import org.apache.hadoop.hive.ql.metadata.HiveException;
 import org.apache.hadoop.hive.ql.metadata.Partition;
 import org.apache.hadoop.hive.ql.metadata.Table;
@@ -77,17 +78,15 @@ private void moveFile(Path sourcePath, Path targetPath, boolean isDfsDir)
       String mesg_detail = " from " + sourcePath.toString();
       console.printInfo(mesg, mesg_detail);
 
-      // delete the output directory if it already exists
-      fs.delete(targetPath, true);
       // if source exists, rename. Otherwise, create a empty directory
       if (fs.exists(sourcePath)) {
         Path deletePath = null;
         // If it multiple level of folder are there fs.rename is failing so first
         // create the targetpath.getParent() if it not exist
         if (HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVE_INSERT_INTO_MULTILEVEL_DIRS)) {
-        deletePath = createTargetPath(targetPath, fs);
+          deletePath = createTargetPath(targetPath, fs);
         }
-        if (!fs.rename(sourcePath, targetPath)) {
+        if (!Hive.renameFile(conf, sourcePath, targetPath, fs, true, false)) {
           try {
             if (deletePath != null) {
               fs.delete(deletePath, true);
@@ -146,6 +145,9 @@ private Path createTargetPath(Path targetPath, FileSystem fs) throws IOException
         actualPath = actualPath.getParent();
       }
       fs.mkdirs(mkDirPath);
+      if (HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVE_WAREHOUSE_SUBDIR_INHERIT_PERMS)) {
+        fs.setPermission(mkDirPath, fs.getFileStatus(actualPath).getPermission());
+      }
     }
     return deletePath;
   }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java b/ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java
index 5d5fa788f4..e6cb70f599 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java
@@ -2210,7 +2210,7 @@ private static boolean destExists(List<List<Path[]>> result, Path proposed) {
   //method is called. when the replace value is true, this method works a little different
   //from mv command if the destf is a directory, it replaces the destf instead of moving under
   //the destf. in this case, the replaced destf still preserves the original destf's permission
-  static protected boolean renameFile(HiveConf conf, Path srcf, Path destf,
+  public static boolean renameFile(HiveConf conf, Path srcf, Path destf,
       FileSystem fs, boolean replace, boolean isSrcLocal) throws HiveException {
     boolean success = false;
     boolean inheritPerms = HiveConf.getBoolVar(conf,
