diff --git a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFReflect.java b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFReflect.java
index 0e8999eef4..795cbb2dd8 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFReflect.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFReflect.java
@@ -50,8 +50,8 @@ public class GenericUDFReflect extends GenericUDF {
   StringObjectInspector classNameOI;
   StringObjectInspector methodNameOI;
   
-  Class<?>[] parameterJavaClasses; // Classes are Integer, Double, String
-  Class<?>[] parameterJavaTypes;   // Types are int, double, etc
+  PrimitiveTypeEntry[] parameterTypes;
+  Class[] parameterClasses;
   Object[] parameterJavaValues;
   
   @Override
@@ -77,8 +77,8 @@ public ObjectInspector initialize(ObjectInspector[] arguments)
     methodNameOI = (StringObjectInspector)
         ObjectInspectorUtils.getStandardObjectInspector(arguments[1]);
     
-    parameterJavaClasses = new Class[arguments.length - 2];
-    parameterJavaTypes = new Class[arguments.length - 2];
+    parameterTypes = new PrimitiveTypeEntry[arguments.length - 2];
+    parameterClasses = new Class[arguments.length - 2];
     for (int i = 2; i < arguments.length; i++) {
       if (arguments[i].getCategory() != ObjectInspector.Category.PRIMITIVE) {
         throw new UDFArgumentTypeException(i,
@@ -87,10 +87,10 @@ public ObjectInspector initialize(ObjectInspector[] arguments)
       }
       PrimitiveCategory category =
           ((PrimitiveObjectInspector)arguments[i]).getPrimitiveCategory();
-      PrimitiveTypeEntry t =
+      parameterTypes[i - 2] =
           PrimitiveObjectInspectorUtils.getTypeEntryFromPrimitiveCategory(category);
-      parameterJavaClasses[i - 2] = t.primitiveJavaClass;
-      parameterJavaTypes[i - 2] = t.primitiveJavaType;
+      parameterClasses[i - 2] = parameterTypes[i - 2].primitiveJavaType == null ?
+          parameterTypes[i - 2].primitiveJavaClass : parameterTypes[i - 2].primitiveJavaType;
     }
     
     parameterJavaValues = new Object[arguments.length - 2];
@@ -152,17 +152,9 @@ public Object evaluate(DeferredObject[] arguments) throws HiveException {
       methodName = ObjectInspectorUtils.copyToStandardObject(newMethodName, newMethodNameOI);
       String methodNameString = methodNameOI.getPrimitiveJavaObject(methodName);
       try {
-        m = c.getMethod(methodNameString, parameterJavaClasses);
-      } catch (SecurityException e) {
+        m = findMethod(c, methodNameString, parameterTypes, parameterClasses);
+      } catch (Exception e) {
         throw new HiveException("UDFReflect getMethod ", e);
-      } catch (NoSuchMethodException e) {
-        try {
-          m = c.getMethod(methodNameString, parameterJavaTypes);
-        } catch (SecurityException ex) {
-          throw new HiveException("UDFReflect getMethod ", ex);
-        } catch (NoSuchMethodException ex) {
-          throw new HiveException("UDFReflect getMethod ", ex);
-        }
       }
     }
     
@@ -200,5 +192,32 @@ public String getDisplayString(String[] children) {
     sb.append(')');
     return sb.toString();
   }
-  
+
+  // a(string,int,int) can be matched with methods like
+  // a(string,int,int), a(string,int,Integer), a(string,Integer,int) and a(string,Integer,Integer)
+  // and accepts the first one clazz.getMethods() returns
+  private Method findMethod(Class clazz, String name, PrimitiveTypeEntry[] parameterTypes,
+      Class[] parameterClasses) throws Exception {
+    for (Method method : clazz.getMethods()) {
+      if (!method.getName().equals(name) || method.getReturnType() != String.class ||
+          method.getParameterTypes().length != parameterTypes.length) {
+        continue;
+      }
+      // returns first one matches all of the params
+      boolean match = true;
+      Class<?>[] types = method.getParameterTypes();
+      for (int i = 0; i < parameterTypes.length; i++) {
+        if (types[i] != parameterTypes[i].primitiveJavaType &&
+            types[i] != parameterTypes[i].primitiveJavaClass) {
+          match = false;
+          break;
+        }
+      }
+      if (match) {
+        return method;
+      }
+    }
+    // tried all, back to original code (for error message)
+    return clazz.getMethod(name, parameterClasses);
+  }
 }
diff --git a/ql/src/test/queries/clientpositive/udf_reflect.q b/ql/src/test/queries/clientpositive/udf_reflect.q
index 7e534324e5..f357ff5049 100644
--- a/ql/src/test/queries/clientpositive/udf_reflect.q
+++ b/ql/src/test/queries/clientpositive/udf_reflect.q
@@ -8,7 +8,8 @@ SELECT reflect("java.lang.String", "valueOf", 1),
        reflect("java.lang.Math", "min", 2, 3),
        reflect("java.lang.Math", "round", 2.5),
        reflect("java.lang.Math", "exp", 1.0),
-       reflect("java.lang.Math", "floor", 1.9)
+       reflect("java.lang.Math", "floor", 1.9),
+       reflect("java.lang.Integer", "valueOf", key, 16)
 FROM src LIMIT 1;
 
 
@@ -18,5 +19,6 @@ SELECT reflect("java.lang.String", "valueOf", 1),
        reflect("java.lang.Math", "min", 2, 3),
        reflect("java.lang.Math", "round", 2.5),
        reflect("java.lang.Math", "exp", 1.0),
-       reflect("java.lang.Math", "floor", 1.9)
+       reflect("java.lang.Math", "floor", 1.9),
+       reflect("java.lang.Integer", "valueOf", key, 16)
 FROM src LIMIT 1;
diff --git a/ql/src/test/results/clientpositive/udf_reflect.q.out b/ql/src/test/results/clientpositive/udf_reflect.q.out
index 69eb5d9122..91aeab52a1 100644
--- a/ql/src/test/results/clientpositive/udf_reflect.q.out
+++ b/ql/src/test/results/clientpositive/udf_reflect.q.out
@@ -18,7 +18,8 @@ SELECT reflect("java.lang.String", "valueOf", 1),
        reflect("java.lang.Math", "min", 2, 3),
        reflect("java.lang.Math", "round", 2.5),
        reflect("java.lang.Math", "exp", 1.0),
-       reflect("java.lang.Math", "floor", 1.9)
+       reflect("java.lang.Math", "floor", 1.9),
+       reflect("java.lang.Integer", "valueOf", key, 16)
 FROM src LIMIT 1
 PREHOOK: type: QUERY
 POSTHOOK: query: EXPLAIN EXTENDED
@@ -28,11 +29,12 @@ SELECT reflect("java.lang.String", "valueOf", 1),
        reflect("java.lang.Math", "min", 2, 3),
        reflect("java.lang.Math", "round", 2.5),
        reflect("java.lang.Math", "exp", 1.0),
-       reflect("java.lang.Math", "floor", 1.9)
+       reflect("java.lang.Math", "floor", 1.9),
+       reflect("java.lang.Integer", "valueOf", key, 16)
 FROM src LIMIT 1
 POSTHOOK: type: QUERY
 ABSTRACT SYNTAX TREE:
-  (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src))) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.String" "valueOf" 1)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.String" "isEmpty")) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "max" 2 3)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "min" 2 3)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "round" 2.5)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "exp" 1.0)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "floor" 1.9))) (TOK_LIMIT 1)))
+  (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src))) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.String" "valueOf" 1)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.String" "isEmpty")) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "max" 2 3)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "min" 2 3)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "round" 2.5)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "exp" 1.0)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Math" "floor" 1.9)) (TOK_SELEXPR (TOK_FUNCTION reflect "java.lang.Integer" "valueOf" (TOK_TABLE_OR_COL key) 16))) (TOK_LIMIT 1)))
 
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
@@ -62,7 +64,9 @@ STAGE PLANS:
                     type: string
                     expr: reflect('java.lang.Math','floor',1.9)
                     type: string
-              outputColumnNames: _col0, _col1, _col2, _col3, _col4, _col5, _col6
+                    expr: reflect('java.lang.Integer','valueOf',key,16)
+                    type: string
+              outputColumnNames: _col0, _col1, _col2, _col3, _col4, _col5, _col6, _col7
               Limit
                 File Output Operator
                   compressed: false
@@ -74,8 +78,8 @@ STAGE PLANS:
                       input format: org.apache.hadoop.mapred.TextInputFormat
                       output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
                       properties:
-                        columns _col0,_col1,_col2,_col3,_col4,_col5,_col6
-                        columns.types string:string:string:string:string:string:string
+                        columns _col0,_col1,_col2,_col3,_col4,_col5,_col6,_col7
+                        columns.types string:string:string:string:string:string:string:string
                         escape.delim \
                         serialization.format 1
                   TotalFiles: 1
@@ -141,7 +145,8 @@ PREHOOK: query: SELECT reflect("java.lang.String", "valueOf", 1),
        reflect("java.lang.Math", "min", 2, 3),
        reflect("java.lang.Math", "round", 2.5),
        reflect("java.lang.Math", "exp", 1.0),
-       reflect("java.lang.Math", "floor", 1.9)
+       reflect("java.lang.Math", "floor", 1.9),
+       reflect("java.lang.Integer", "valueOf", key, 16)
 FROM src LIMIT 1
 PREHOOK: type: QUERY
 PREHOOK: Input: default@src
@@ -152,9 +157,10 @@ POSTHOOK: query: SELECT reflect("java.lang.String", "valueOf", 1),
        reflect("java.lang.Math", "min", 2, 3),
        reflect("java.lang.Math", "round", 2.5),
        reflect("java.lang.Math", "exp", 1.0),
-       reflect("java.lang.Math", "floor", 1.9)
+       reflect("java.lang.Math", "floor", 1.9),
+       reflect("java.lang.Integer", "valueOf", key, 16)
 FROM src LIMIT 1
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@src
 #### A masked pattern was here ####
-1	true	3	2	3	2.7182818284590455	1.0
+1	true	3	2	3	2.7182818284590455	1.0	568
