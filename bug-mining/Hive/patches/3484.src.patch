diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/PlanModifierUtil.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/PlanModifierUtil.java
index 2c820f064f..3e2fae9ec9 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/PlanModifierUtil.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/PlanModifierUtil.java
@@ -68,23 +68,9 @@ protected static void fixTopOBSchema(final RelNode rootRel,
       if (collationInputRefs.contains(i)) {
         RexNode obyExpr = obChild.getChildExps().get(i);
         if (obyExpr instanceof RexCall) {
-          int a = -1;
-          List<RexNode> operands = new ArrayList<>();
-          for (int k = 0; k< ((RexCall) obyExpr).operands.size(); k++) {
-            RexNode rn = ((RexCall) obyExpr).operands.get(k);
-            for (int j = 0; j < resultSchema.size(); j++) {
-              if( obChild.getChildExps().get(j).toString().equals(rn.toString())) {
-                a = j;
-                break;
-              }
-            } if (a != -1) {
-              operands.add(new RexInputRef(a, rn.getType()));
-            } else {
-              operands.add(rn);
-            }
-            a = -1;
-          }
-          obyExpr = obChild.getCluster().getRexBuilder().makeCall(((RexCall)obyExpr).getOperator(), operands);
+          LOG.debug("Old RexCall : " + obyExpr);
+          obyExpr = adjustOBSchema((RexCall) obyExpr, obChild, resultSchema);
+          LOG.debug("New RexCall : " + obyExpr);
         }
         inputRefToCallMapBldr.put(i, obyExpr);
       }
@@ -106,6 +92,33 @@ protected static void fixTopOBSchema(final RelNode rootRel,
     obRel.setInputRefToCallMap(inputRefToCallMap);
   }
 
+  private static RexCall adjustOBSchema(RexCall obyExpr, Project obChild,
+          List<FieldSchema> resultSchema) {
+    int a = -1;
+    List<RexNode> operands = new ArrayList<>();
+    for (int k = 0; k < obyExpr.operands.size(); k++) {
+      RexNode rn = obyExpr.operands.get(k);
+      for (int j = 0; j < resultSchema.size(); j++) {
+        if( obChild.getChildExps().get(j).toString().equals(rn.toString())) {
+          a = j;
+          break;
+        }
+      }
+      if (a != -1) {
+        operands.add(new RexInputRef(a, rn.getType()));
+      } else {
+        if (rn instanceof RexCall) {
+          operands.add(adjustOBSchema((RexCall)rn, obChild, resultSchema));
+        } else {
+          operands.add(rn);
+        }
+      }
+      a = -1;
+    }
+    return (RexCall) obChild.getCluster().getRexBuilder().makeCall(
+            obyExpr.getType(), obyExpr.getOperator(), operands);
+  }
+
   protected static String generateInvalidSchemaMessage(Project topLevelProj,
       List<FieldSchema> resultSchema, int fieldsForOB) {
     String errorDesc = "Result Schema didn't match Calcite Optimized Op Tree; schema: ";
