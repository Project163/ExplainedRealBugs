diff --git a/CHANGES.txt b/CHANGES.txt
index dff1314ae1..2e75cce39b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -139,6 +139,8 @@ Trunk - Unreleased
 
     HIVE-405. Cleanup operator initialization. (Prasad Chakka via zshao)
 
+    HIVE-652. Turn off auto-merge for insert local. (Namit Jain via zshao)
+
   OPTIMIZATIONS
 
     HIVE-279. Predicate Pushdown support (Prasad Chakka via athusoo).
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java
index 1d797aa3f0..6a16cc39df 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java
@@ -144,4 +144,24 @@ public int execute() {
       return (1);
     }
   }
+ 
+  /*
+   * Does the move task involve moving to a local file system
+   */
+  public boolean isLocal() {
+    loadTableDesc tbd = work.getLoadTableWork();
+    if (tbd != null)
+      return false;
+    
+    loadFileDesc lfd = work.getLoadFileWork();
+    if (lfd != null) {
+      if (lfd.getIsDfsDir()) {
+        return false;
+      }
+      else
+        return true;
+    }
+    
+    return false;
+  }
 }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/GenMRFileSink1.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/GenMRFileSink1.java
index 6f5299c6fc..1d95444313 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/GenMRFileSink1.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/GenMRFileSink1.java
@@ -28,6 +28,7 @@
 import org.apache.hadoop.hive.ql.exec.ColumnInfo;
 import org.apache.hadoop.hive.ql.exec.ConditionalTask;
 import org.apache.hadoop.hive.ql.exec.FileSinkOperator;
+import org.apache.hadoop.hive.ql.exec.MoveTask;
 import org.apache.hadoop.hive.ql.exec.Operator;
 import org.apache.hadoop.hive.ql.exec.MapJoinOperator;
 import org.apache.hadoop.hive.ql.exec.OperatorFactory;
@@ -84,13 +85,27 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx opProcCtx, Ob
     Task<? extends Serializable> currTask = ctx.getCurrTask();
 
     // Has the user enabled merging of files for map-only jobs or for all jobs
-    if (((ctx.getMvTask() != null) && (!ctx.getMvTask().isEmpty())) &&
-        ((ctx.getSeenFileSinkOps() == null) ||
-           (!ctx.getSeenFileSinkOps().contains((FileSinkOperator)nd)))) {
-      if ((parseCtx.getConf().getBoolVar(HiveConf.ConfVars.HIVEMERGEMAPFILES) &&
-          (((mapredWork)currTask.getWork()).getReducer() == null)) ||
-          parseCtx.getConf().getBoolVar(HiveConf.ConfVars.HIVEMERGEMAPREDFILES))
-        chDir = true;
+    if ((ctx.getMvTask() != null) && (!ctx.getMvTask().isEmpty())) 
+    {
+      List<Task<? extends Serializable>> mvTasks = ctx.getMvTask();
+
+      // In case of unions or map-joins, it is possible that the file has already been seen.
+      // So, no need to attempt to merge the files again.
+      if ((ctx.getSeenFileSinkOps() == null) ||
+          (!ctx.getSeenFileSinkOps().contains((FileSinkOperator)nd)))  {
+        
+        // no need of merging if the move is to a local file system
+        MoveTask mvTask = (MoveTask)findMoveTask(mvTasks, (FileSinkOperator)nd);
+        if ((mvTask != null) && !mvTask.isLocal())
+        {
+          // There are separate configuration parameters to control whether to merge for a map-only job
+          // or for a map-reduce job
+          if ((parseCtx.getConf().getBoolVar(HiveConf.ConfVars.HIVEMERGEMAPFILES) &&
+              (((mapredWork)currTask.getWork()).getReducer() == null)) ||
+              parseCtx.getConf().getBoolVar(HiveConf.ConfVars.HIVEMERGEMAPREDFILES))
+            chDir = true;
+        }
+      }
     }
 
     String finalName = processFS(nd, stack, opProcCtx, chDir);
