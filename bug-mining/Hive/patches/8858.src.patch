diff --git a/pom.xml b/pom.xml
index 72e13a9770..21977aea95 100644
--- a/pom.xml
+++ b/pom.xml
@@ -143,7 +143,7 @@
     <hamcrest.version>1.3</hamcrest.version>
     <hbase.version>2.5.6-hadoop3</hbase.version>
     <hppc.version>0.7.2</hppc.version>
-    <nashorn.version>15.4</nashorn.version>
+    <graalvm.version>23.0.8</graalvm.version>
     <!-- required for logging test to avoid including hbase which pulls disruptor transitively -->
     <disruptor.version>3.3.7</disruptor.version>
     <hikaricp.version>4.0.3</hikaricp.version>
@@ -420,9 +420,14 @@
         <version>${commons-math3.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.openjdk.nashorn</groupId>
-        <artifactId>nashorn-core</artifactId>
-        <version>${nashorn.version}</version>
+        <groupId>org.graalvm.js</groupId>
+        <artifactId>js-scriptengine</artifactId>
+        <version>${graalvm.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.graalvm.js</groupId>
+        <artifactId>js</artifactId>
+        <version>${graalvm.version}</version>
       </dependency>
       <dependency>
         <groupId>io.jsonwebtoken</groupId>
diff --git a/ql/pom.xml b/ql/pom.xml
index c3bdd194c1..8e20aff23a 100644
--- a/ql/pom.xml
+++ b/ql/pom.xml
@@ -33,8 +33,12 @@
     <!-- intra-project -->
     <!-- used for vector code-gen -->
     <dependency>
-      <groupId>org.openjdk.nashorn</groupId>
-      <artifactId>nashorn-core</artifactId>
+      <groupId>org.graalvm.js</groupId>
+      <artifactId>js-scriptengine</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.graalvm.js</groupId>
+      <artifactId>js</artifactId>
     </dependency>
     <dependency>
       <groupId>org.apache.atlas</groupId>
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/metadata/PartitionTree.java b/ql/src/java/org/apache/hadoop/hive/ql/metadata/PartitionTree.java
index 3c1e96172f..7a34fde783 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/metadata/PartitionTree.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/metadata/PartitionTree.java
@@ -17,6 +17,7 @@
  */
 package org.apache.hadoop.hive.ql.metadata;
 
+import com.oracle.truffle.js.scriptengine.GraalJSScriptEngine;
 import org.apache.hadoop.hive.metastore.api.AlreadyExistsException;
 import org.apache.hadoop.hive.metastore.api.GetPartitionsFilterSpec;
 import org.apache.hadoop.hive.metastore.api.GetPartitionsRequest;
@@ -28,11 +29,8 @@
 import org.apache.hadoop.hive.metastore.api.PartitionFilterMode;
 import org.apache.hadoop.hive.metastore.api.PartitionListComposingSpec;
 import org.apache.hadoop.hive.metastore.api.PartitionSpec;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import org.graalvm.polyglot.Context;
 
-import javax.script.ScriptEngine;
-import javax.script.ScriptEngineManager;
 import javax.script.ScriptException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -41,7 +39,6 @@
 import java.util.List;
 import java.util.Map;
 
-import static org.apache.hadoop.hive.metastore.Warehouse.LOG;
 import static org.apache.hadoop.hive.metastore.Warehouse.makePartName;
 import static org.apache.hadoop.hive.metastore.utils.MetaStoreUtils.makePartNameMatcher;
 
@@ -50,7 +47,6 @@
  * via references.
  */
 final class PartitionTree {
-  private static final Logger LOG = LoggerFactory.getLogger(PartitionTree.class);
   private Map<String, org.apache.hadoop.hive.metastore.api.Partition> parts = new LinkedHashMap<>();
   private final org.apache.hadoop.hive.metastore.api.Table tTable;
 
@@ -258,21 +254,20 @@ List<Partition> getPartitionsByFilter(final String filter) throws MetaException
       return new ArrayList<>(parts.values());
     }
     List<Partition> result = new ArrayList<>();
-    ScriptEngine se = new ScriptEngineManager().getEngineByName("JavaScript");
-    if (se == null) {
-      LOG.error("JavaScript script engine is not found, therefore partition filtering "
-          + "for temporary tables is disabled.");
-      return result;
-    }
-    for (Map.Entry<String, Partition> entry : parts.entrySet()) {
-      se.put("partitionName", entry.getKey());
-      se.put("values", entry.getValue().getValues());
-      try {
-        if ((Boolean)se.eval(filter)) {
-          result.add(entry.getValue());
+    try (GraalJSScriptEngine se = GraalJSScriptEngine.create(null,
+            Context.newBuilder().allowExperimentalOptions(true)
+                    .option("js.nashorn-compat", "true")
+                    .allowAllAccess(true))) {
+      for (Map.Entry<String, Partition> entry : parts.entrySet()) {
+        se.put("partitionName", entry.getKey());
+        se.put("values", entry.getValue().getValues());
+        try {
+          if ((Boolean) se.eval(filter)) {
+            result.add(entry.getValue());
+          }
+        } catch (ScriptException e) {
+          throw new MetaException("Incorrect partition filter");
         }
-      } catch (ScriptException e) {
-        throw new MetaException("Incorrect partition filter");
       }
     }
     return result;
@@ -311,19 +306,17 @@ GetPartitionsResponse getPartitionsWithSpecs(GetPartitionsRequest getPartitionsR
           matches = filterSpec.getFilters().stream().anyMatch(str -> entry.getValue().getValues().contains(str));
           break;
         case BY_EXPR:
-          ScriptEngine se = new ScriptEngineManager().getEngineByName("JavaScript");
-          if (se == null) {
-            LOG.error("JavaScript script engine is not found, therefore partition filtering "
-                    + "for temporary tables is disabled.");
-            break;
-          }
-
-          for (String filter : filterSpec.getFilters()) {
-            try {
-              se.put("partition", partition);
-              matches = (Boolean) se.eval(filter);
-            } catch (ScriptException e) {
-              throw new MetaException("Error evaluating filter expression: " + e.getMessage());
+          try (GraalJSScriptEngine se = GraalJSScriptEngine.create(null,
+                  Context.newBuilder().allowExperimentalOptions(true)
+                          .option("js.nashorn-compat", "true")
+                          .allowAllAccess(true))) {
+            for (String filter : filterSpec.getFilters()) {
+              try {
+                se.put("partition", partition);
+                matches = (Boolean) se.eval(filter);
+              } catch (ScriptException e) {
+                throw new MetaException("Error evaluating filter expression: " + e.getMessage());
+              }
             }
           }
           break;
