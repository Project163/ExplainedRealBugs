diff --git a/ql/src/java/org/apache/hadoop/hive/ql/io/orc/encoded/EncodedReaderImpl.java b/ql/src/java/org/apache/hadoop/hive/ql/io/orc/encoded/EncodedReaderImpl.java
index 248feaea64..5352042161 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/io/orc/encoded/EncodedReaderImpl.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/io/orc/encoded/EncodedReaderImpl.java
@@ -1242,25 +1242,101 @@ private void processCacheCollisions(long[] collisionMask,
      This may be necessary for obscure combinations of compression and encoding boundaries. */
   private static DiskRangeList findExactPosition(DiskRangeList ranges, long offset) {
     if (offset < 0) return ranges;
-    return findIntersectingPosition(ranges, offset, offset);
+    ranges = findUpperBound(ranges, offset);
+    ranges = findLowerBound(ranges, offset);
+    if (offset < ranges.getOffset() || offset >= ranges.getEnd()) {
+      throwRangesError(ranges, offset, offset);
+    }
+    return ranges;
   }
 
-  private static DiskRangeList findIntersectingPosition(DiskRangeList ranges, long offset, long end) {
+  private static DiskRangeList findIntersectingPosition(
+      DiskRangeList ranges, long offset, long end) {
     if (offset < 0) return ranges;
-    // We expect the offset to be valid TODO: rather, validate
-    while (ranges.getEnd() <= offset) {
-      ranges = ranges.next;
+    ranges = findUpperBound(ranges, offset);
+    ranges = findLowerBound(ranges, end);
+    // We are now on some intersecting buffer, find the first intersecting buffer.
+    while (ranges.prev != null && ranges.prev.getEnd() > offset) {
+      if (ranges.prev.getEnd() > ranges.getOffset()) {
+        throwRangesError(ranges, offset, end);
+      }
+      ranges = ranges.prev;
     }
+    return ranges;
+  }
+
+
+  public static DiskRangeList findLowerBound(DiskRangeList ranges, long end) {
     while (ranges.getOffset() > end) {
+      if (ranges.prev.getEnd() > ranges.getOffset()) {
+        throwRangesError(ranges, end, end);
+      }
       ranges = ranges.prev;
     }
-    // We are now on some intersecting buffer, find the first intersecting buffer.
-    while (ranges.prev != null && ranges.prev.getEnd() > offset) {
-      ranges = ranges.prev;
+    return ranges;
+  }
+
+
+  public static DiskRangeList findUpperBound(DiskRangeList ranges, long offset) {
+    while (ranges.getEnd() <= offset) {
+      if (ranges.next.getOffset() < ranges.getEnd()) {
+        throwRangesError(ranges, offset, offset);
+      }
+      ranges = ranges.next;
     }
     return ranges;
   }
 
+  private static void throwRangesError(DiskRangeList ranges, long offset, long end) {
+    // We are going to fail, so it is ok to do expensive stuff. Ranges are broken, play it safe.
+    IdentityHashMap<DiskRangeList, Boolean> seen = new IdentityHashMap<>();
+    seen.put(ranges, true);
+    StringBuilder errors = new StringBuilder();
+    while (ranges.prev != null) {
+      if (ranges.prev.next != ranges) {
+        errors.append("inconsistent list going back: [").append(ranges).append("].prev = [")
+          .append(ranges.prev).append("]; prev.next = [").append(ranges.prev.next).append("]; ");
+        // Stop, as we won't be able to go forward.
+        break;
+      }
+      if (seen.containsKey(ranges.prev)) {
+        errors.append("loop: [").append(ranges).append(
+            "].prev = [").append(ranges.prev).append("]; ");
+        break;
+      }
+      ranges = ranges.prev;
+      seen.put(ranges, true);
+    }
+    seen.clear();
+    seen.put(ranges, true);
+    StringBuilder sb = new StringBuilder("Incorrect ranges detected while looking for ");
+    if (offset == end) {
+      sb.append(offset);
+    } else {
+      sb.append("[").append(offset).append(", ").append(end).append(")");
+    }
+    sb.append(": [").append(ranges).append("], ");
+    while (ranges.next != null) {
+      if (ranges.next.prev != ranges) {
+        errors.append("inconsistent list going forward: [").append(ranges).append(
+            "].next.prev = [").append(ranges.next.prev).append("]; ");
+      }
+      if (seen.containsKey(ranges.next)) {
+        errors.append("loop: [").append(ranges).append(
+            "].next = [").append(ranges.next).append("]; ");
+        break;
+      }
+      ranges = ranges.next;
+      sb.append("[").append(ranges).append("], ");
+      seen.put(ranges, true);
+    }
+    sb.append("; ").append(errors);
+    String error = sb.toString();
+    LOG.error(error);
+    throw new RuntimeException(error);
+  }
+
+
   /**
    * Reads one compression block from the source; handles compression blocks read from
    * multiple ranges (usually, that would only happen with zcr).
diff --git a/storage-api/src/java/org/apache/hadoop/hive/common/io/DiskRangeList.java b/storage-api/src/java/org/apache/hadoop/hive/common/io/DiskRangeList.java
index 0aba08dabb..83b7ec2ce9 100644
--- a/storage-api/src/java/org/apache/hadoop/hive/common/io/DiskRangeList.java
+++ b/storage-api/src/java/org/apache/hadoop/hive/common/io/DiskRangeList.java
@@ -36,6 +36,7 @@ public DiskRangeList(long offset, long end) {
    * @return the new element
    */
   public DiskRangeList replaceSelfWith(DiskRangeList other) {
+    checkArg(other);
     other.prev = this.prev;
     other.next = this.next;
     if (this.prev != null) {
@@ -48,12 +49,24 @@ public DiskRangeList replaceSelfWith(DiskRangeList other) {
     return other;
   }
 
+  private void checkArg(DiskRangeList other) throws AssertionError {
+    if (other == this) {
+      // The only case where duplicate elements matter... the others are handled by the below.
+      throw new AssertionError("Inserting self into the list [" + other + "]");
+    }
+    if (other.prev != null || other.next != null) {
+      throw new AssertionError("[" + other + "] is part of another list; prev ["
+          + other.prev + "], next [" + other.next + "]");
+    }
+  }
+
   /**
    * Inserts an intersecting range before current in the list and adjusts offset accordingly.
    * @param other the element to insert
    * @return the new element.
    */
   public DiskRangeList insertPartBefore(DiskRangeList other) {
+    checkArg(other);
     assert other.end >= this.offset;
     this.offset = other.end;
     other.prev = this.prev;
@@ -71,6 +84,7 @@ public DiskRangeList insertPartBefore(DiskRangeList other) {
    * @return the new element.
    * */
   public DiskRangeList insertAfter(DiskRangeList other) {
+    checkArg(other);
     other.next = this.next;
     other.prev = this;
     if (this.next != null) {
@@ -94,6 +108,9 @@ public DiskRangeList insertPartAfter(DiskRangeList other) {
   /** Removes an element after current from the list. */
   public void removeAfter() {
     DiskRangeList other = this.next;
+    if (this == other) {
+      throw new AssertionError("Invalid duplicate [" + other + "]");
+    }
     this.next = other.next;
     if (this.next != null) {
       this.next.prev = this;
@@ -103,6 +120,9 @@ public void removeAfter() {
 
   /** Removes the current element from the list. */
   public void removeSelf() {
+    if (this.prev == this || this.next == this) {
+      throw new AssertionError("Invalid duplicate [" + this + "]");
+    }
     if (this.prev != null) {
       this.prev.next = this.next;
     }
