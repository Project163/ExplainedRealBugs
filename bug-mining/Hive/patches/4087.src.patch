diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java b/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
index d76e77fe0a..36b316afaf 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
@@ -232,7 +232,7 @@ private boolean runTestQuery() {
     // Run a self-test query. If it doesn't work, we will self-disable. What a PITA...
     String selfTestQuery = "select \"DB_ID\" from \"DBS\"";
     try {
-      doDbSpecificInitializationsBeforeQuery();
+      prepareTxn();
       query = pm.newQuery("javax.jdo.query.SQL", selfTestQuery);
       query.execute();
       return true;
@@ -255,21 +255,6 @@ public boolean isCompatibleDatastore() {
     return isCompatibleDatastore;
   }
 
-  /**
-   * This function is intended to be called by functions before they put together a query
-   * Thus, any query-specific instantiation to be done from within the transaction is done
-   * here - for eg., for MySQL, we signal that we want to use ANSI SQL quoting behaviour
-   */
-  private void doDbSpecificInitializationsBeforeQuery() throws MetaException {
-    if (dbType != DB.MYSQL) return;
-    try {
-      assert pm.currentTransaction().isActive(); // must be inside tx together with queries
-      executeNoResult("SET @@session.sql_mode=ANSI_QUOTES");
-    } catch (SQLException sqlEx) {
-      throw new MetaException("Error setting ansi quotes: " + sqlEx.getMessage());
-    }
-  }
-
   private void executeNoResult(final String queryText) throws SQLException {
     JDOConnection jdoConn = pm.getDataStoreConnection();
     boolean doTrace = LOG.isDebugEnabled();
@@ -288,8 +273,6 @@ public Database getDatabase(String dbName) throws MetaException{
     try {
       dbName = dbName.toLowerCase();
 
-      doDbSpecificInitializationsBeforeQuery();
-
       String queryTextDbSelector= "select "
           + "\"DB_ID\", \"NAME\", \"DB_LOCATION_URI\", \"DESC\", "
           + "\"OWNER_NAME\", \"OWNER_TYPE\" "
@@ -461,8 +444,6 @@ private List<Partition> getPartitionsViaSqlFilterInternal(String dbName, String
     // We have to be mindful of order during filtering if we are not returning all partitions.
     String orderForFilter = (max != null) ? " order by \"PART_NAME\" asc" : "";
 
-    doDbSpecificInitializationsBeforeQuery();
-
     // Get all simple fields for partitions and related objects, which we can map one-on-one.
     // We will do this in 2 queries to use different existing indices for each one.
     // We do not get table and DB name, assuming they are the same as we are using to filter.
@@ -1131,7 +1112,6 @@ public ColumnStatistics getTableStats(
     if (colNames.isEmpty()) {
       return null;
     }
-    doDbSpecificInitializationsBeforeQuery();
     boolean doTrace = LOG.isDebugEnabled();
     long start = doTrace ? System.nanoTime() : 0;
     String queryText = "select " + STATS_COLLIST + " from \"TAB_COL_STATS\" "
@@ -1254,7 +1234,6 @@ private long partsFoundForPartitions(String dbName, String tableName,
   private List<ColumnStatisticsObj> columnStatisticsObjForPartitions(String dbName,
       String tableName, List<String> partNames, List<String> colNames, long partsFound,
       boolean useDensityFunctionForNDVEstimation) throws MetaException {
-    doDbSpecificInitializationsBeforeQuery();
     // TODO: all the extrapolation logic should be moved out of this class,
     // only mechanical data retrieval should remain here.
     String commonPrefix = "select \"COLUMN_NAME\", \"COLUMN_TYPE\", "
@@ -1571,7 +1550,6 @@ public List<ColumnStatistics> getPartitionStats(String dbName, String tableName,
       return Lists.newArrayList();
     }
     boolean doTrace = LOG.isDebugEnabled();
-    doDbSpecificInitializationsBeforeQuery();
     long start = doTrace ? System.nanoTime() : 0;
     String queryText = "select \"PARTITION_NAME\", " + STATS_COLLIST + " from \"PART_COL_STATS\""
       + " where \"DB_NAME\" = ? and \"TABLE_NAME\" = ? and \"COLUMN_NAME\" in ("
@@ -1668,4 +1646,21 @@ private <T> T executeWithArray(Query query, Object[] params, String sql) throws
       throw new MetaException("See previous errors; " + ex.getMessage());
     }
   }
+
+  /**
+   * This run the necessary logic to prepare for queries. It should be called once, after the
+   * txn on DataNucleus connection is opened, and before any queries are issued. What it does
+   * currently is run db-specific logic, e.g. setting ansi quotes mode for MySQL. The reason it
+   * must be used inside of the txn is connection pooling; there's no way to guarantee that the
+   * effect will apply to the connection that is executing the queries otherwise.
+   */
+  public void prepareTxn() throws MetaException {
+    if (dbType != DB.MYSQL) return;
+    try {
+      assert pm.currentTransaction().isActive(); // must be inside tx together with queries
+      executeNoResult("SET @@session.sql_mode=ANSI_QUOTES");
+    } catch (SQLException sqlEx) {
+      throw new MetaException("Error setting ansi quotes: " + sqlEx.getMessage());
+    }
+  }
 }
diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java b/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
index 803c6e7f3a..1a8913c7c7 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
@@ -2490,6 +2490,7 @@ public T run(boolean initTable) throws MetaException, NoSuchObjectException {
         start(initTable);
         if (doUseDirectSql) {
           try {
+            directSql.prepareTxn();
             setResult(getSqlResult(this));
           } catch (Exception ex) {
             handleDirectSqlError(ex);
