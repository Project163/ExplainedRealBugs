diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
index 0ef792ecef..d28e6307bb 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
@@ -319,12 +319,10 @@ private boolean runTestQuery() {
       tx.begin();
       doCommit = true;
     }
-    Query query = null;
     // Run a self-test query. If it doesn't work, we will self-disable. What a PITA...
     String selfTestQuery = "select \"DB_ID\" from " + DBS + "";
-    try {
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", selfTestQuery))) {
       prepareTxn();
-      query = pm.newQuery("javax.jdo.query.SQL", selfTestQuery);
       query.execute();
       return true;
     } catch (Throwable t) {
@@ -336,9 +334,6 @@ private boolean runTestQuery() {
       if (doCommit) {
         tx.commit();
       }
-      if (query != null) {
-        query.closeAll();
-      }
     }
   }
 
@@ -368,20 +363,22 @@ private void executeNoResult(final String queryText) throws SQLException {
   }
 
   public Database getDatabase(String catName, String dbName) throws MetaException{
-    Query queryDbSelector = null;
-    Query queryDbParams = null;
-    try {
+    String queryTextDbSelector= "select "
+        + "\"DB_ID\", \"NAME\", \"DB_LOCATION_URI\", \"DESC\", "
+        + "\"OWNER_NAME\", \"OWNER_TYPE\", \"CTLG_NAME\" , \"CREATE_TIME\", \"DB_MANAGED_LOCATION_URI\", "
+        + "\"TYPE\", \"DATACONNECTOR_NAME\", \"REMOTE_DBNAME\""
+        + "FROM "+ DBS
+        + " where \"NAME\" = ? and \"CTLG_NAME\" = ? ";
+    String queryTextDbParams = "select \"PARAM_KEY\", \"PARAM_VALUE\" "
+        + " from " + DATABASE_PARAMS + " "
+        + " WHERE \"DB_ID\" = ? "
+        + " AND \"PARAM_KEY\" IS NOT NULL";
+
+    try (QueryWrapper queryDbSelector = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryTextDbSelector));
+         QueryWrapper queryDbParams = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryTextDbParams))) {
       dbName = dbName.toLowerCase();
       catName = catName.toLowerCase();
-
-      String queryTextDbSelector= "select "
-          + "\"DB_ID\", \"NAME\", \"DB_LOCATION_URI\", \"DESC\", "
-          + "\"OWNER_NAME\", \"OWNER_TYPE\", \"CTLG_NAME\" , \"CREATE_TIME\", \"DB_MANAGED_LOCATION_URI\", "
-          + "\"TYPE\", \"DATACONNECTOR_NAME\", \"REMOTE_DBNAME\""
-          + "FROM "+ DBS
-          + " where \"NAME\" = ? and \"CTLG_NAME\" = ? ";
       Object[] params = new Object[] { dbName, catName };
-      queryDbSelector = pm.newQuery("javax.jdo.query.SQL", queryTextDbSelector);
 
       if (LOG.isTraceEnabled()) {
         LOG.trace("getDatabase:query instantiated : " + queryTextDbSelector
@@ -402,12 +399,7 @@ public Database getDatabase(String catName, String dbName) throws MetaException{
       Object[] dbline = sqlResult.get(0);
       Long dbid = MetastoreDirectSqlUtils.extractSqlLong(dbline[0]);
 
-      String queryTextDbParams = "select \"PARAM_KEY\", \"PARAM_VALUE\" "
-          + " from " + DATABASE_PARAMS + " "
-          + " WHERE \"DB_ID\" = ? "
-          + " AND \"PARAM_KEY\" IS NOT NULL";
       params[0] = dbid;
-      queryDbParams = pm.newQuery("javax.jdo.query.SQL", queryTextDbParams);
       if (LOG.isTraceEnabled()) {
         LOG.trace("getDatabase:query2 instantiated : " + queryTextDbParams
             + " with param [" + params[0] + "]");
@@ -450,13 +442,6 @@ public Database getDatabase(String catName, String dbName) throws MetaException{
             + "] owner [" + db.getOwnerName() + "] ownertype ["+ db.getOwnerType() +"]");
       }
       return db;
-    } finally {
-      if (queryDbSelector != null){
-        queryDbSelector.closeAll();
-      }
-      if (queryDbParams != null){
-        queryDbParams.closeAll();
-      }
     }
   }
 
@@ -483,12 +468,12 @@ public List<String> getTables(String catName, String dbName, TableType tableType
       pms.add(tableType.toString());
     }
 
-    Query<?> queryParams = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<String> tableNames = executeWithArray(
-        queryParams, pms.toArray(), queryText, limit);
-    List<String> results = new ArrayList<String>(tableNames);
-    queryParams.closeAll();
-    return results;
+    try (QueryWrapper queryParams = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<String> tableNames = executeWithArray(
+          queryParams, pms.toArray(), queryText, limit);
+      List<String> results = new ArrayList<String>(tableNames);
+      return results;
+    }
   }
 
   /**
@@ -507,12 +492,12 @@ public List<String> getMaterializedViewsForRewriting(String dbName) throws MetaE
     pms.add(dbName);
     pms.add(TableType.MATERIALIZED_VIEW.toString());
 
-    Query<?> queryParams = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<String> mvs = executeWithArray(
-        queryParams, pms.toArray(), queryText);
-    List<String> results = new ArrayList<String>(mvs);
-    queryParams.closeAll();
-    return results;
+    try (QueryWrapper queryParams = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<String> mvs = executeWithArray(
+          queryParams, pms.toArray(), queryText);
+      List<String> results = new ArrayList<String>(mvs);
+      return results;
+    }
   }
 
   /**
@@ -619,10 +604,9 @@ public List<String> getPartitionNamesViaSql(SqlFilterForPushdown filter, List<Fi
       params[i + j + 3] = paramsForFilter.get(j);
     }
 
-    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
     List<String> partNames = new LinkedList<String>();
     int limit = (max == null ? -1 : max);
-    try {
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
       long start = doTrace ? System.nanoTime() : 0;
       List<Object> sqlResult = executeWithArray(query, params, queryText, limit);
       long queryTime = doTrace ? System.nanoTime() : 0;
@@ -631,8 +615,6 @@ public List<String> getPartitionNamesViaSql(SqlFilterForPushdown filter, List<Fi
         Object obj = !columns.isEmpty() ? ((Object[]) result)[0] : result;
         partNames.add((String)obj);
       }
-    } finally {
-      query.closeAll();
     }
     return partNames;
   }
@@ -851,20 +833,14 @@ private static Boolean isViewTable(Table t) {
   }
 
   private boolean isViewTable(String catName, String dbName, String tblName) throws MetaException {
-    Query query = null;
-    try {
-      String queryText = "select \"TBL_TYPE\" from " + TBLS + "" +
-          " inner join " + DBS + " on " + TBLS + ".\"DB_ID\" = " + DBS + ".\"DB_ID\" " +
-          " where " + TBLS + ".\"TBL_NAME\" = ? and " + DBS + ".\"NAME\" = ? and " + DBS + ".\"CTLG_NAME\" = ?";
+    String queryText = "select \"TBL_TYPE\" from " + TBLS + "" +
+        " inner join " + DBS + " on " + TBLS + ".\"DB_ID\" = " + DBS + ".\"DB_ID\" " +
+        " where " + TBLS + ".\"TBL_NAME\" = ? and " + DBS + ".\"NAME\" = ? and " + DBS + ".\"CTLG_NAME\" = ?";
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
       Object[] params = new Object[] { tblName, dbName, catName };
-      query = pm.newQuery("javax.jdo.query.SQL", queryText);
       query.setUnique(true);
       Object result = executeWithArray(query, params, queryText);
       return (result != null) && result.toString().equals(TableType.VIRTUAL_VIEW.toString());
-    } finally {
-      if (query != null) {
-        query.closeAll();
-      }
     }
   }
 
@@ -911,20 +887,21 @@ private List<Long> getPartitionIdsViaSqlFilter(
     }
 
     long start = doTrace ? System.nanoTime() : 0;
-    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object> sqlResult = executeWithArray(query, params, queryText, ((max == null)  ? -1 : max.intValue()));
-    long queryTime = doTrace ? System.nanoTime() : 0;
-    MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, queryTime);
-    if (sqlResult.isEmpty()) {
-      return Collections.emptyList(); // no partitions, bail early.
-    }
-
-    List<Long> result = new ArrayList<>(sqlResult.size());
-    for (Object fields : sqlResult) {
-      result.add(MetastoreDirectSqlUtils.extractSqlLong(fields));
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object> sqlResult = executeWithArray(query, params, queryText, ((max == null) ? -1 : max.intValue()));
+      long queryTime = doTrace ? System.nanoTime() : 0;
+      MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, queryTime);
+      final List<Long> result;
+      if (sqlResult.isEmpty()) {
+        result = Collections.emptyList(); // no partitions, bail early.
+      } else {
+        result = new ArrayList<>(sqlResult.size());
+        for (Object fields : sqlResult) {
+          result.add(MetastoreDirectSqlUtils.extractSqlLong(fields));
+        }
+      }
+      return result;
     }
-    query.closeAll();
-    return result;
   }
 
   /** Should be called with the list short enough to not trip up Oracle/etc. */
@@ -957,12 +934,6 @@ private List<Partition> getPartitionsFromPartitionIds(String catName, String dbN
             + SERDES + ".\"SERDE_ID\" " + "where \"PART_ID\" in (" + partIds
             + ") order by \"PART_NAME\" asc";
 
-    long start = doTrace ? System.nanoTime() : 0;
-    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = executeWithArray(query, null, queryText);
-    long queryTime = doTrace ? System.nanoTime() : 0;
-    Deadline.checkTimeout();
-
     // Read all the fields and create partitions, SDs and serdes.
     TreeMap<Long, Partition> partitions = new TreeMap<Long, Partition>();
     TreeMap<Long, StorageDescriptor> sds = new TreeMap<Long, StorageDescriptor>();
@@ -978,98 +949,104 @@ private List<Partition> getPartitionsFromPartitionIds(String catName, String dbN
     dbName = dbName.toLowerCase();
     catName = normalizeSpace(catName).toLowerCase();
     partitions.navigableKeySet();
-    for (Object[] fields : sqlResult) {
-      // Here comes the ugly part...
-      long partitionId = MetastoreDirectSqlUtils.extractSqlLong(fields[0]);
-      Long sdId = MetastoreDirectSqlUtils.extractSqlLong(fields[1]);
-      Long colId = MetastoreDirectSqlUtils.extractSqlLong(fields[2]);
-      Long serdeId = MetastoreDirectSqlUtils.extractSqlLong(fields[3]);
-
-      Partition part = new Partition();
-      orderedResult.add(part);
-      // Set the collection fields; some code might not check presence before accessing them.
-      part.setParameters(new HashMap<>());
-      part.setValues(new ArrayList<String>());
-      part.setCatName(catName);
-      part.setDbName(dbName);
-      part.setTableName(tblName);
-      if (fields[4] != null) {
-        part.setCreateTime(MetastoreDirectSqlUtils.extractSqlInt(fields[4]));
-      }
-      if (fields[5] != null) {
-        part.setLastAccessTime(MetastoreDirectSqlUtils.extractSqlInt(fields[5]));
-      }
-      Long writeId = MetastoreDirectSqlUtils.extractSqlLong(fields[14]);
-      if (writeId != null && writeId>0) {
-        part.setWriteId(writeId);
-      } else {
-        part.setWriteId(-1L);
-      }
-      partitions.put(partitionId, part);
-
-
-      if (sdId == null) {
-        continue; // Probably a view.
-      }
-      assert serdeId != null;
-
-      // We assume each partition has an unique SD.
-      StorageDescriptor sd = new StorageDescriptor();
-      StorageDescriptor oldSd = sds.put(sdId, sd);
-      if (oldSd != null) {
-        throw new MetaException("Partitions reuse SDs; we don't expect that");
-      }
-      // Set the collection fields; some code might not check presence before accessing them.
-      sd.setSortCols(new ArrayList<Order>());
-      sd.setBucketCols(new ArrayList<String>());
-      sd.setParameters(new HashMap<String, String>());
-      sd.setSkewedInfo(new SkewedInfo(new ArrayList<String>(),
-          new ArrayList<List<String>>(), new HashMap<List<String>, String>()));
-      sd.setInputFormat((String)fields[6]);
-      Boolean tmpBoolean = MetastoreDirectSqlUtils.extractSqlBoolean(fields[7]);
-      if (tmpBoolean != null) {
-        sd.setCompressed(tmpBoolean);
-      }
-      tmpBoolean = MetastoreDirectSqlUtils.extractSqlBoolean(fields[8]);
-      if (tmpBoolean != null) {
-        sd.setStoredAsSubDirectories(tmpBoolean);
-      }
-      sd.setLocation((String)fields[9]);
-      if (fields[10] != null) {
-        sd.setNumBuckets(MetastoreDirectSqlUtils.extractSqlInt(fields[10]));
-      }
-      sd.setOutputFormat((String)fields[11]);
-      sdSb.append(sdId).append(",");
-      part.setSd(sd);
-
-      if (colId != null) {
-        List<FieldSchema> cols = colss.get(colId);
-        // We expect that colId will be the same for all (or many) SDs.
-        if (cols == null) {
-          cols = new ArrayList<FieldSchema>();
-          colss.put(colId, cols);
-          colsSb.append(colId).append(",");
+
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      long start = doTrace ? System.nanoTime() : 0;
+      List<Object[]> sqlResult = executeWithArray(query, null, queryText);
+      long queryTime = doTrace ? System.nanoTime() : 0;
+      Deadline.checkTimeout();
+
+      for (Object[] fields : sqlResult) {
+        // Here comes the ugly part...
+        long partitionId = MetastoreDirectSqlUtils.extractSqlLong(fields[0]);
+        Long sdId = MetastoreDirectSqlUtils.extractSqlLong(fields[1]);
+        Long colId = MetastoreDirectSqlUtils.extractSqlLong(fields[2]);
+        Long serdeId = MetastoreDirectSqlUtils.extractSqlLong(fields[3]);
+
+        Partition part = new Partition();
+        orderedResult.add(part);
+        // Set the collection fields; some code might not check presence before accessing them.
+        part.setParameters(new HashMap<>());
+        part.setValues(new ArrayList<String>());
+        part.setCatName(catName);
+        part.setDbName(dbName);
+        part.setTableName(tblName);
+        if (fields[4] != null) {
+          part.setCreateTime(MetastoreDirectSqlUtils.extractSqlInt(fields[4]));
         }
-        sd.setCols(cols);
-      }
+        if (fields[5] != null) {
+          part.setLastAccessTime(MetastoreDirectSqlUtils.extractSqlInt(fields[5]));
+        }
+        Long writeId = MetastoreDirectSqlUtils.extractSqlLong(fields[14]);
+        if (writeId != null && writeId > 0) {
+          part.setWriteId(writeId);
+        } else {
+          part.setWriteId(-1L);
+        }
+        partitions.put(partitionId, part);
 
-      // We assume each SD has an unique serde.
-      SerDeInfo serde = new SerDeInfo();
-      SerDeInfo oldSerde = serdes.put(serdeId, serde);
-      if (oldSerde != null) {
-        throw new MetaException("SDs reuse serdes; we don't expect that");
-      }
-      serde.setParameters(new HashMap<String, String>());
-      serde.setName((String)fields[12]);
-      serde.setSerializationLib((String)fields[13]);
-      serdeSb.append(serdeId).append(",");
-      sd.setSerdeInfo(serde);
 
-      Deadline.checkTimeout();
-    }
-    query.closeAll();
-    MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, queryTime);
+        if (sdId == null) {
+          continue; // Probably a view.
+        }
+        assert serdeId != null;
 
+        // We assume each partition has an unique SD.
+        StorageDescriptor sd = new StorageDescriptor();
+        StorageDescriptor oldSd = sds.put(sdId, sd);
+        if (oldSd != null) {
+          throw new MetaException("Partitions reuse SDs; we don't expect that");
+        }
+        // Set the collection fields; some code might not check presence before accessing them.
+        sd.setSortCols(new ArrayList<Order>());
+        sd.setBucketCols(new ArrayList<String>());
+        sd.setParameters(new HashMap<String, String>());
+        sd.setSkewedInfo(new SkewedInfo(new ArrayList<String>(),
+            new ArrayList<List<String>>(), new HashMap<List<String>, String>()));
+        sd.setInputFormat((String) fields[6]);
+        Boolean tmpBoolean = MetastoreDirectSqlUtils.extractSqlBoolean(fields[7]);
+        if (tmpBoolean != null) {
+          sd.setCompressed(tmpBoolean);
+        }
+        tmpBoolean = MetastoreDirectSqlUtils.extractSqlBoolean(fields[8]);
+        if (tmpBoolean != null) {
+          sd.setStoredAsSubDirectories(tmpBoolean);
+        }
+        sd.setLocation((String) fields[9]);
+        if (fields[10] != null) {
+          sd.setNumBuckets(MetastoreDirectSqlUtils.extractSqlInt(fields[10]));
+        }
+        sd.setOutputFormat((String) fields[11]);
+        sdSb.append(sdId).append(",");
+        part.setSd(sd);
+
+        if (colId != null) {
+          List<FieldSchema> cols = colss.get(colId);
+          // We expect that colId will be the same for all (or many) SDs.
+          if (cols == null) {
+            cols = new ArrayList<FieldSchema>();
+            colss.put(colId, cols);
+            colsSb.append(colId).append(",");
+          }
+          sd.setCols(cols);
+        }
+
+        // We assume each SD has an unique serde.
+        SerDeInfo serde = new SerDeInfo();
+        SerDeInfo oldSerde = serdes.put(serdeId, serde);
+        if (oldSerde != null) {
+          throw new MetaException("SDs reuse serdes; we don't expect that");
+        }
+        serde.setParameters(new HashMap<String, String>());
+        serde.setName((String) fields[12]);
+        serde.setSerializationLib((String) fields[13]);
+        serdeSb.append(serdeId).append(",");
+        sd.setSerdeInfo(serde);
+
+        Deadline.checkTimeout();
+      }
+      MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, queryTime);
+    }
     // Now get all the one-to-many things. Start with partitions.
     MetastoreDirectSqlUtils
         .setPartitionParameters(PARTITION_PARAMS, convertMapNullsToEmptyStrings, pm, partIds, partitions);
@@ -1153,13 +1130,13 @@ public int getNumPartitionsViaSqlFilter(SqlFilterForPushdown filter) throws Meta
     }
 
     long start = doTrace ? System.nanoTime() : 0;
-    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    query.setUnique(true);
-    int sqlResult = MetastoreDirectSqlUtils.extractSqlInt(query.executeWithArray(params));
-    long queryTime = doTrace ? System.nanoTime() : 0;
-    MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, queryTime);
-    query.closeAll();
-    return sqlResult;
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      query.setUnique(true);
+      int sqlResult = MetastoreDirectSqlUtils.extractSqlInt(query.executeWithArray(params));
+      long queryTime = doTrace ? System.nanoTime() : 0;
+      MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, queryTime);
+      return sqlResult;
+    }
   }
 
   private static String trimCommaList(StringBuilder sb) {
@@ -1443,31 +1420,39 @@ public List<Object[]> run(List<String> input) throws MetaException {
         }
         long start = doTrace ? System.nanoTime() : 0;
         Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-        Object qResult = executeWithArray(query, params, queryText);
-        MetastoreDirectSqlUtils.timingTrace(doTrace, queryText0 + "...)", start, (doTrace ? System.nanoTime() : 0));
-        if (qResult == null) {
-          query.closeAll();
-          return null;
+        try {
+          Object qResult = executeWithArray(query, params, queryText);
+          MetastoreDirectSqlUtils.timingTrace(doTrace, queryText0 + "...)", start, (doTrace ? System.nanoTime() : 0));
+          if (qResult == null) {
+            return null;
+          }
+          return MetastoreDirectSqlUtils.ensureList(qResult);
+        } finally {
+          addQueryAfterUse(query);
         }
-        addQueryAfterUse(query);
-        return MetastoreDirectSqlUtils.ensureList(qResult);
       }
     };
-    List<Object[]> list = Batchable.runBatched(batchSize, colNames, b);
-    if (list.isEmpty()) {
+    List<Object[]> list;
+    try {
+      list = Batchable.runBatched(batchSize, colNames, b);
+      if (list != null) {
+        list = new ArrayList<>(list);
+      }
+    } finally {
+      b.closeAllQueries();
+    }
+
+    if (list == null || list.isEmpty()) {
       return null;
     }
     ColumnStatisticsDesc csd = new ColumnStatisticsDesc(true, dbName, tableName);
     csd.setCatName(catName);
     ColumnStatistics result = makeColumnStats(list, csd, 0, engine);
-    b.closeAllQueries();
     return result;
   }
 
   public List<HiveObjectPrivilege> getTableAllColumnGrants(String catName, String dbName,
                                                            String tableName, String authorizer) throws MetaException {
-    Query query = null;
-
     // These constants should match the SELECT clause of the query.
     final int authorizerIndex = 0;
     final int columnNameIndex = 1;
@@ -1512,8 +1497,7 @@ public List<HiveObjectPrivilege> getTableAllColumnGrants(String catName, String
     List<HiveObjectPrivilege> result = new ArrayList<>();
     final boolean doTrace = LOG.isDebugEnabled();
     long start = doTrace ? System.nanoTime() : 0;
-    query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    try {
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
       List<Object[]> queryResult = MetastoreDirectSqlUtils.ensureList(
               executeWithArray(query, params, queryText));
       long end = doTrace ? System.nanoTime() : 0;
@@ -1543,8 +1527,6 @@ public List<HiveObjectPrivilege> getTableAllColumnGrants(String catName, String
         result.add(new HiveObjectPrivilege(objectRef, principalName, ptype, grantInfo,
                 privAuthorizer));
       }
-    } finally {
-      query.closeAll();
     }
 
     return result;
@@ -1637,8 +1619,7 @@ public List<Long> run(List<String> inputPartNames) throws MetaException {
             String queryText = String.format(queryText0,
                 makeParams(inputColName.size()), makeParams(inputPartNames.size()));
             long start = doTrace ? System.nanoTime() : 0;
-            Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-            try {
+            try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
               Object qResult = executeWithArray(query, prepareParams(
                   catName, dbName, tableName, inputPartNames, inputColName, engine), queryText);
               long end = doTrace ? System.nanoTime() : 0;
@@ -1651,8 +1632,6 @@ public List<Long> run(List<String> inputPartNames) throws MetaException {
                 }
               }
               return Lists.<Long>newArrayList(partsFound);
-            } finally {
-              query.closeAll();
             }
           }
         });
@@ -1690,16 +1669,13 @@ public List<ColStatsObjWithSourceInfo> getColStatsForAllTablePartitions(String c
         + " from " + " " + PART_COL_STATS + " where \"DB_NAME\" = ? and \"CAT_NAME\" = ?";
     long start = 0;
     long end = 0;
-    Query query = null;
     boolean doTrace = LOG.isDebugEnabled();
     Object qResult = null;
     start = doTrace ? System.nanoTime() : 0;
     List<ColStatsObjWithSourceInfo> colStatsForDB = new ArrayList<ColStatsObjWithSourceInfo>();
-    try {
-      query = pm.newQuery("javax.jdo.query.SQL", queryText);
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
       qResult = executeWithArray(query, new Object[] { dbName, catName }, queryText);
       if (qResult == null) {
-        query.closeAll();
         return colStatsForDB;
       }
       end = doTrace ? System.nanoTime() : 0;
@@ -1712,8 +1688,6 @@ public List<ColStatsObjWithSourceInfo> getColStatsForAllTablePartitions(String c
         colStatsForDB.add(new ColStatsObjWithSourceInfo(colStatObj, catName, dbName, tblName, partName));
         Deadline.checkTimeout();
       }
-    } finally {
-      query.closeAll();
     }
     return colStatsForDB;
   }
@@ -1785,12 +1759,11 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
           + " and \"ENGINE\" = ? "
           + " group by \"COLUMN_NAME\", \"COLUMN_TYPE\"";
       start = doTrace ? System.nanoTime() : 0;
-      try (Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+      try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
         Object qResult = executeWithArray(query,
             prepareParams(catName, dbName, tableName, partNames, colNames,
                 engine), queryText);
         if (qResult == null) {
-          query.closeAll();
           return Collections.emptyList();
         }
         end = doTrace ? System.nanoTime() : 0;
@@ -1804,9 +1777,6 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
           Deadline.checkTimeout();
         }
         return colStats;
-      } catch (Exception e) {
-        throwMetaOrRuntimeException(e);
-        return Collections.emptyList();
       }
     } else {
       // Extrapolation is needed for some columns.
@@ -1823,14 +1793,13 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
       start = doTrace ? System.nanoTime() : 0;
       List<String> noExtraColumnNames = new ArrayList<String>();
       Map<String, String[]> extraColumnNameTypeParts = new HashMap<String, String[]>();
-      try(Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+      try(QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
         Object qResult = executeWithArray(query,
             prepareParams(catName, dbName, tableName, partNames, colNames,
                 engine), queryText);
         end = doTrace ? System.nanoTime() : 0;
         MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
         if (qResult == null) {
-          query.closeAll();
           return Collections.emptyList();
         }
 
@@ -1850,8 +1819,6 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
           }
           Deadline.checkTimeout();
         }
-      } catch (Exception e) {
-        throwMetaOrRuntimeException(e);
       }
       // Extrapolation is not needed for columns noExtraColumnNames
       List<Object[]> list;
@@ -1863,11 +1830,10 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
             + " group by \"COLUMN_NAME\", \"COLUMN_TYPE\"";
         start = doTrace ? System.nanoTime() : 0;
 
-        try (Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+        try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
           Object qResult = executeWithArray(query,
               prepareParams(catName, dbName, tableName, partNames, noExtraColumnNames, engine), queryText);
           if (qResult == null) {
-            query.closeAll();
             return Collections.emptyList();
           }
           list = MetastoreDirectSqlUtils.ensureList(qResult);
@@ -1878,8 +1844,6 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
           }
           end = doTrace ? System.nanoTime() : 0;
           MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-        } catch (Exception e) {
-          throwMetaOrRuntimeException(e);
         }
       }
       // Extrapolation is needed for extraColumnNames.
@@ -1898,14 +1862,13 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
             + " and \"ENGINE\" = ? "
             + " group by \"COLUMN_NAME\"";
         start = doTrace ? System.nanoTime() : 0;
-        try (Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+        try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
           List<String> extraColumnNames = new ArrayList<String>();
           extraColumnNames.addAll(extraColumnNameTypeParts.keySet());
           Object qResult = executeWithArray(query,
               prepareParams(catName, dbName, tableName, partNames,
                   extraColumnNames, engine), queryText);
           if (qResult == null) {
-            query.closeAll();
             return Collections.emptyList();
           }
           list = MetastoreDirectSqlUtils.ensureList(qResult);
@@ -1922,8 +1885,6 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
           }
           end = doTrace ? System.nanoTime() : 0;
           MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-        } catch (Exception e) {
-          throwMetaOrRuntimeException(e);
         }
         for (Map.Entry<String, String[]> entry : extraColumnNameTypeParts.entrySet()) {
           Object[] row = new Object[IExtrapolatePartStatus.colStatNames.length + 2];
@@ -1982,11 +1943,10 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
                     + " order by cast(\"" + colStatName + "\" as decimal)";
               }
               start = doTrace ? System.nanoTime() : 0;
-              try (Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+              try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
                 Object qResult = executeWithArray(query,
                     prepareParams(catName, dbName, tableName, partNames, Arrays.asList(colName), engine), queryText);
                 if (qResult == null) {
-                  query.closeAll();
                   return Collections.emptyList();
                 }
                 fqr = (ForwardQueryResult<?>) qResult;
@@ -1994,15 +1954,12 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
                 Object[] max = (Object[]) (fqr.get(fqr.size() - 1));
                 end = doTrace ? System.nanoTime() : 0;
                 MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-                query.closeAll();
                 if (min[0] == null || max[0] == null) {
                   row[2 + colStatIndex] = null;
                 } else {
                   row[2 + colStatIndex] = extrapolateMethod
                       .extrapolate(min, max, colStatIndex, indexMap);
                 }
-              } catch (Exception e) {
-                throwMetaOrRuntimeException(e);
               }
             } else {
               // if the aggregation type is avg, we use the average on the existing ones.
@@ -2016,11 +1973,10 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
                   + " and \"ENGINE\" = ? "
                   + " group by \"COLUMN_NAME\"";
               start = doTrace ? System.nanoTime() : 0;
-              try(Query query = pm.newQuery("javax.jdo.query.SQL", queryText)) {
+              try(QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
                 Object qResult = executeWithArray(query,
                     prepareParams(catName, dbName, tableName, partNames, Arrays.asList(colName), engine), queryText);
                 if (qResult == null) {
-                  query.closeAll();
                   return Collections.emptyList();
                 }
                 fqr = (ForwardQueryResult<?>) qResult;
@@ -2030,9 +1986,6 @@ private List<ColumnStatisticsObj> aggrStatsUseDB(String catName, String dbName,
                 row[2 + colStatIndex] = avg[colStatIndex - 12];
                 end = doTrace ? System.nanoTime() : 0;
                 MetastoreDirectSqlUtils.timingTrace(doTrace, queryText, start, end);
-                query.closeAll();
-              } catch (Exception e) {
-                throwMetaOrRuntimeException(e);
               }
             }
           }
@@ -2107,15 +2060,17 @@ public List<Object[]> run(List<String> inputPartNames) throws MetaException {
                 makeParams(inputColNames.size()), makeParams(inputPartNames.size()));
             long start = doTrace ? System.nanoTime() : 0;
             Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-            Object qResult = executeWithArray(query, prepareParams(
-                catName, dbName, tableName, inputPartNames, inputColNames, engine), queryText);
-            MetastoreDirectSqlUtils.timingTrace(doTrace, queryText0, start, (doTrace ? System.nanoTime() : 0));
-            if (qResult == null) {
-              query.closeAll();
-              return Collections.emptyList();
+            try {
+              Object qResult = executeWithArray(query, prepareParams(
+                  catName, dbName, tableName, inputPartNames, inputColNames, engine), queryText);
+              MetastoreDirectSqlUtils.timingTrace(doTrace, queryText0, start, (doTrace ? System.nanoTime() : 0));
+              if (qResult == null) {
+                return Collections.emptyList();
+              }
+              return MetastoreDirectSqlUtils.ensureList(qResult);
+            } finally {
+              addQueryAfterUse(query);
             }
-            addQueryAfterUse(query);
-            return MetastoreDirectSqlUtils.ensureList(qResult);
           }
         };
         try {
@@ -2125,13 +2080,12 @@ public List<Object[]> run(List<String> inputPartNames) throws MetaException {
         }
       }
     };
-    List<Object[]> list = Batchable.runBatched(batchSize, colNames, b);
 
-    List<ColumnStatistics> result = new ArrayList<ColumnStatistics>(
-        Math.min(list.size(), partNames.size()));
+    List<ColumnStatistics> result = new ArrayList<ColumnStatistics>(partNames.size());
     String lastPartName = null;
     int from = 0;
     try {
+      List<Object[]> list = Batchable.runBatched(batchSize, colNames, b);
       for (int i = 0; i <= list.size(); ++i) {
         boolean isLast = i == list.size();
         String partName = isLast ? null : (String) list.get(i)[0];
@@ -2276,38 +2230,38 @@ public List<SQLForeignKey> getForeignKeys(String catName, String parent_db_name,
       pms.add(parent_db_name);
     }
 
-    Query queryParams = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
-        queryParams, pms.toArray(), queryText));
+    try (QueryWrapper queryParams = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
+          queryParams, pms.toArray(), queryText));
 
-    if (!sqlResult.isEmpty()) {
-      for (Object[] line : sqlResult) {
-        int enableValidateRely = MetastoreDirectSqlUtils.extractSqlInt(line[11]);
-        boolean enable = (enableValidateRely & 4) != 0;
-        boolean validate = (enableValidateRely & 2) != 0;
-        boolean rely = (enableValidateRely & 1) != 0;
-        SQLForeignKey currKey = new SQLForeignKey(
-          MetastoreDirectSqlUtils.extractSqlString(line[0]),
-          MetastoreDirectSqlUtils.extractSqlString(line[1]),
-          MetastoreDirectSqlUtils.extractSqlString(line[2]),
-          MetastoreDirectSqlUtils.extractSqlString(line[3]),
-          MetastoreDirectSqlUtils.extractSqlString(line[4]),
-          MetastoreDirectSqlUtils.extractSqlString(line[5]),
-          MetastoreDirectSqlUtils.extractSqlInt(line[6]),
-          MetastoreDirectSqlUtils.extractSqlInt(line[7]),
-          MetastoreDirectSqlUtils.extractSqlInt(line[8]),
-          MetastoreDirectSqlUtils.extractSqlString(line[9]),
-          MetastoreDirectSqlUtils.extractSqlString(line[10]),
-          enable,
-          validate,
-          rely
+      if (!sqlResult.isEmpty()) {
+        for (Object[] line : sqlResult) {
+          int enableValidateRely = MetastoreDirectSqlUtils.extractSqlInt(line[11]);
+          boolean enable = (enableValidateRely & 4) != 0;
+          boolean validate = (enableValidateRely & 2) != 0;
+          boolean rely = (enableValidateRely & 1) != 0;
+          SQLForeignKey currKey = new SQLForeignKey(
+              MetastoreDirectSqlUtils.extractSqlString(line[0]),
+              MetastoreDirectSqlUtils.extractSqlString(line[1]),
+              MetastoreDirectSqlUtils.extractSqlString(line[2]),
+              MetastoreDirectSqlUtils.extractSqlString(line[3]),
+              MetastoreDirectSqlUtils.extractSqlString(line[4]),
+              MetastoreDirectSqlUtils.extractSqlString(line[5]),
+              MetastoreDirectSqlUtils.extractSqlInt(line[6]),
+              MetastoreDirectSqlUtils.extractSqlInt(line[7]),
+              MetastoreDirectSqlUtils.extractSqlInt(line[8]),
+              MetastoreDirectSqlUtils.extractSqlString(line[9]),
+              MetastoreDirectSqlUtils.extractSqlString(line[10]),
+              enable,
+              validate,
+              rely
           );
-        currKey.setCatName(catName);
-        ret.add(currKey);
+          currKey.setCatName(catName);
+          ret.add(currKey);
+        }
       }
+      return ret;
     }
-    queryParams.closeAll();
-    return ret;
   }
 
   public List<SQLPrimaryKey> getPrimaryKeys(String catName, String db_name, String tbl_name)
@@ -2344,30 +2298,30 @@ public List<SQLPrimaryKey> getPrimaryKeys(String catName, String db_name, String
       pms.add(tbl_name);
     }
 
-    Query queryParams = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
-        queryParams, pms.toArray(), queryText));
+    try (QueryWrapper queryParams = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
+          queryParams, pms.toArray(), queryText));
 
-    if (!sqlResult.isEmpty()) {
-      for (Object[] line : sqlResult) {
+      if (!sqlResult.isEmpty()) {
+        for (Object[] line : sqlResult) {
           int enableValidateRely = MetastoreDirectSqlUtils.extractSqlInt(line[5]);
           boolean enable = (enableValidateRely & 4) != 0;
           boolean validate = (enableValidateRely & 2) != 0;
           boolean rely = (enableValidateRely & 1) != 0;
-        SQLPrimaryKey currKey = new SQLPrimaryKey(
-          MetastoreDirectSqlUtils.extractSqlString(line[0]),
-          MetastoreDirectSqlUtils.extractSqlString(line[1]),
-          MetastoreDirectSqlUtils.extractSqlString(line[2]),
-          MetastoreDirectSqlUtils.extractSqlInt(line[3]), MetastoreDirectSqlUtils.extractSqlString(line[4]),
-          enable,
-          validate,
-          rely);
-        currKey.setCatName(MetastoreDirectSqlUtils.extractSqlString(line[6]));
-        ret.add(currKey);
+          SQLPrimaryKey currKey = new SQLPrimaryKey(
+              MetastoreDirectSqlUtils.extractSqlString(line[0]),
+              MetastoreDirectSqlUtils.extractSqlString(line[1]),
+              MetastoreDirectSqlUtils.extractSqlString(line[2]),
+              MetastoreDirectSqlUtils.extractSqlInt(line[3]), MetastoreDirectSqlUtils.extractSqlString(line[4]),
+              enable,
+              validate,
+              rely);
+          currKey.setCatName(MetastoreDirectSqlUtils.extractSqlString(line[6]));
+          ret.add(currKey);
+        }
       }
+      return ret;
     }
-    queryParams.closeAll();
-    return ret;
   }
 
   public List<SQLUniqueConstraint> getUniqueConstraints(String catName, String db_name, String tbl_name)
@@ -2403,29 +2357,29 @@ public List<SQLUniqueConstraint> getUniqueConstraints(String catName, String db_
       pms.add(tbl_name);
     }
 
-    Query queryParams = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
-        queryParams, pms.toArray(), queryText));
+    try (QueryWrapper queryParams = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
+          queryParams, pms.toArray(), queryText));
 
-    if (!sqlResult.isEmpty()) {
-      for (Object[] line : sqlResult) {
+      if (!sqlResult.isEmpty()) {
+        for (Object[] line : sqlResult) {
           int enableValidateRely = MetastoreDirectSqlUtils.extractSqlInt(line[5]);
           boolean enable = (enableValidateRely & 4) != 0;
           boolean validate = (enableValidateRely & 2) != 0;
           boolean rely = (enableValidateRely & 1) != 0;
-        ret.add(new SQLUniqueConstraint(
-            catName,
-            MetastoreDirectSqlUtils.extractSqlString(line[0]),
-            MetastoreDirectSqlUtils.extractSqlString(line[1]),
-            MetastoreDirectSqlUtils.extractSqlString(line[2]),
-            MetastoreDirectSqlUtils.extractSqlInt(line[3]), MetastoreDirectSqlUtils.extractSqlString(line[4]),
-            enable,
-            validate,
-            rely));
+          ret.add(new SQLUniqueConstraint(
+              catName,
+              MetastoreDirectSqlUtils.extractSqlString(line[0]),
+              MetastoreDirectSqlUtils.extractSqlString(line[1]),
+              MetastoreDirectSqlUtils.extractSqlString(line[2]),
+              MetastoreDirectSqlUtils.extractSqlInt(line[3]), MetastoreDirectSqlUtils.extractSqlString(line[4]),
+              enable,
+              validate,
+              rely));
+        }
       }
+      return ret;
     }
-    queryParams.closeAll();
-    return ret;
   }
 
   public List<SQLNotNullConstraint> getNotNullConstraints(String catName, String db_name, String tbl_name)
@@ -2461,29 +2415,29 @@ public List<SQLNotNullConstraint> getNotNullConstraints(String catName, String d
       pms.add(tbl_name);
     }
 
-    Query queryParams = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
-        queryParams, pms.toArray(), queryText));
+    try (QueryWrapper queryParams = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
+          queryParams, pms.toArray(), queryText));
 
-    if (!sqlResult.isEmpty()) {
-      for (Object[] line : sqlResult) {
+      if (!sqlResult.isEmpty()) {
+        for (Object[] line : sqlResult) {
           int enableValidateRely = MetastoreDirectSqlUtils.extractSqlInt(line[4]);
           boolean enable = (enableValidateRely & 4) != 0;
           boolean validate = (enableValidateRely & 2) != 0;
           boolean rely = (enableValidateRely & 1) != 0;
-        ret.add(new SQLNotNullConstraint(
-            catName,
-            MetastoreDirectSqlUtils.extractSqlString(line[0]),
-            MetastoreDirectSqlUtils.extractSqlString(line[1]),
-            MetastoreDirectSqlUtils.extractSqlString(line[2]),
-            MetastoreDirectSqlUtils.extractSqlString(line[3]),
-            enable,
-            validate,
-            rely));
+          ret.add(new SQLNotNullConstraint(
+              catName,
+              MetastoreDirectSqlUtils.extractSqlString(line[0]),
+              MetastoreDirectSqlUtils.extractSqlString(line[1]),
+              MetastoreDirectSqlUtils.extractSqlString(line[2]),
+              MetastoreDirectSqlUtils.extractSqlString(line[3]),
+              enable,
+              validate,
+              rely));
+        }
       }
+      return ret;
     }
-    queryParams.closeAll();
-    return ret;
   }
 
   public List<SQLDefaultConstraint> getDefaultConstraints(String catName, String db_name, String tbl_name)
@@ -2523,31 +2477,31 @@ public List<SQLDefaultConstraint> getDefaultConstraints(String catName, String d
       pms.add(tbl_name);
     }
 
-    Query queryParams = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
-        queryParams, pms.toArray(), queryText));
+    try (QueryWrapper queryParams = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
+          queryParams, pms.toArray(), queryText));
 
-    if (!sqlResult.isEmpty()) {
-      for (Object[] line : sqlResult) {
-        int enableValidateRely = MetastoreDirectSqlUtils.extractSqlInt(line[4]);
-        boolean enable = (enableValidateRely & 4) != 0;
-        boolean validate = (enableValidateRely & 2) != 0;
-        boolean rely = (enableValidateRely & 1) != 0;
-        SQLDefaultConstraint currConstraint = new SQLDefaultConstraint(
-            catName,
-            MetastoreDirectSqlUtils.extractSqlString(line[0]),
-            MetastoreDirectSqlUtils.extractSqlString(line[1]),
-            MetastoreDirectSqlUtils.extractSqlString(line[2]),
-            MetastoreDirectSqlUtils.extractSqlString(line[5]),
-            MetastoreDirectSqlUtils.extractSqlString(line[3]),
-            enable,
-            validate,
-            rely);
-        ret.add(currConstraint);
-      }
-    }
-    queryParams.closeAll();
-    return ret;
+      if (!sqlResult.isEmpty()) {
+        for (Object[] line : sqlResult) {
+          int enableValidateRely = MetastoreDirectSqlUtils.extractSqlInt(line[4]);
+          boolean enable = (enableValidateRely & 4) != 0;
+          boolean validate = (enableValidateRely & 2) != 0;
+          boolean rely = (enableValidateRely & 1) != 0;
+          SQLDefaultConstraint currConstraint = new SQLDefaultConstraint(
+              catName,
+              MetastoreDirectSqlUtils.extractSqlString(line[0]),
+              MetastoreDirectSqlUtils.extractSqlString(line[1]),
+              MetastoreDirectSqlUtils.extractSqlString(line[2]),
+              MetastoreDirectSqlUtils.extractSqlString(line[5]),
+              MetastoreDirectSqlUtils.extractSqlString(line[3]),
+              enable,
+              validate,
+              rely);
+          ret.add(currConstraint);
+        }
+      }
+      return ret;
+    }
   }
 
   public List<SQLCheckConstraint> getCheckConstraints(String catName, String db_name, String tbl_name)
@@ -2587,31 +2541,31 @@ public List<SQLCheckConstraint> getCheckConstraints(String catName, String db_na
       pms.add(tbl_name);
     }
 
-    Query queryParams = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
-        queryParams, pms.toArray(), queryText));
+    try (QueryWrapper queryParams = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
+          queryParams, pms.toArray(), queryText));
 
-    if (!sqlResult.isEmpty()) {
-      for (Object[] line : sqlResult) {
-        int enableValidateRely = MetastoreDirectSqlUtils.extractSqlInt(line[4]);
-        boolean enable = (enableValidateRely & 4) != 0;
-        boolean validate = (enableValidateRely & 2) != 0;
-        boolean rely = (enableValidateRely & 1) != 0;
-        SQLCheckConstraint currConstraint = new SQLCheckConstraint(
-            catName,
-            MetastoreDirectSqlUtils.extractSqlString(line[0]),
-            MetastoreDirectSqlUtils.extractSqlString(line[1]),
-            MetastoreDirectSqlUtils.extractSqlString(line[2]),
-            MetastoreDirectSqlUtils.extractSqlString(line[5]),
-            MetastoreDirectSqlUtils.extractSqlString(line[3]),
-            enable,
-            validate,
-            rely);
-        ret.add(currConstraint);
-      }
-    }
-    queryParams.closeAll();
-    return ret;
+      if (!sqlResult.isEmpty()) {
+        for (Object[] line : sqlResult) {
+          int enableValidateRely = MetastoreDirectSqlUtils.extractSqlInt(line[4]);
+          boolean enable = (enableValidateRely & 4) != 0;
+          boolean validate = (enableValidateRely & 2) != 0;
+          boolean rely = (enableValidateRely & 1) != 0;
+          SQLCheckConstraint currConstraint = new SQLCheckConstraint(
+              catName,
+              MetastoreDirectSqlUtils.extractSqlString(line[0]),
+              MetastoreDirectSqlUtils.extractSqlString(line[1]),
+              MetastoreDirectSqlUtils.extractSqlString(line[2]),
+              MetastoreDirectSqlUtils.extractSqlString(line[5]),
+              MetastoreDirectSqlUtils.extractSqlString(line[3]),
+              enable,
+              validate,
+              rely);
+          ret.add(currConstraint);
+        }
+      }
+      return ret;
+    }
   }
 
   /**
@@ -2667,26 +2621,24 @@ private void dropPartitionsByPartitionIds(List<Long> partitionIdList) throws Met
             + "INNER JOIN " + PARTITIONS + " ON " + PARTITIONS + ".\"SD_ID\" = " + SDS + ".\"SD_ID\" "
             + "WHERE " + PARTITIONS + ".\"PART_ID\" in (" + partitionIds + ")";
 
-    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = MetastoreDirectSqlUtils
-        .ensureList(executeWithArray(query, null, queryText));
-
     List<Object> sdIdList = new ArrayList<>(partitionIdList.size());
     List<Object> columnDescriptorIdList = new ArrayList<>(1);
     List<Object> serdeIdList = new ArrayList<>(partitionIdList.size());
-
-    if (!sqlResult.isEmpty()) {
-      for (Object[] fields : sqlResult) {
-        sdIdList.add(MetastoreDirectSqlUtils.extractSqlLong(fields[0]));
-        Long colId = MetastoreDirectSqlUtils.extractSqlLong(fields[1]);
-        if (!columnDescriptorIdList.contains(colId)) {
-          columnDescriptorIdList.add(colId);
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object[]> sqlResult = MetastoreDirectSqlUtils
+          .ensureList(executeWithArray(query, null, queryText));
+
+      if (!sqlResult.isEmpty()) {
+        for (Object[] fields : sqlResult) {
+          sdIdList.add(MetastoreDirectSqlUtils.extractSqlLong(fields[0]));
+          Long colId = MetastoreDirectSqlUtils.extractSqlLong(fields[1]);
+          if (!columnDescriptorIdList.contains(colId)) {
+            columnDescriptorIdList.add(colId);
+          }
+          serdeIdList.add(MetastoreDirectSqlUtils.extractSqlLong(fields[2]));
         }
-        serdeIdList.add(MetastoreDirectSqlUtils.extractSqlLong(fields[2]));
       }
     }
-    query.closeAll();
-
     try {
       // Drop privileges
       queryText = "delete from " + PART_PRIVS + " where \"PART_ID\" in (" + partitionIds + ")";
@@ -2750,19 +2702,18 @@ private void dropStorageDescriptors(List<Object> storageDescriptorIdList) throws
         "select " + SKEWED_VALUES + ".\"STRING_LIST_ID_EID\" "
             + "from " + SKEWED_VALUES + " "
             + "WHERE " + SKEWED_VALUES + ".\"SD_ID_OID\" in  (" + sdIds + ")";
-
-    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = MetastoreDirectSqlUtils
-        .ensureList(executeWithArray(query, null, queryText));
-
     List<Object> skewedStringListIdList = new ArrayList<>(0);
 
-    if (!sqlResult.isEmpty()) {
-      for (Object[] fields : sqlResult) {
-        skewedStringListIdList.add(MetastoreDirectSqlUtils.extractSqlLong(fields[0]));
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object[]> sqlResult = MetastoreDirectSqlUtils
+          .ensureList(executeWithArray(query, null, queryText));
+
+      if (!sqlResult.isEmpty()) {
+        for (Object[] fields : sqlResult) {
+          skewedStringListIdList.add(MetastoreDirectSqlUtils.extractSqlLong(fields[0]));
+        }
       }
     }
-    query.closeAll();
 
     String skewedStringListIds = getIdListForIn(skewedStringListIdList);
 
@@ -2871,20 +2822,19 @@ private void dropDanglingColumnDescriptors(List<Object> columnDescriptorIdList)
             + "from " + SDS + " "
             + "WHERE " + SDS + ".\"CD_ID\" in (" + colIds + ") "
             + "GROUP BY " + SDS + ".\"CD_ID\"";
-    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    List<Object[]> sqlResult = MetastoreDirectSqlUtils
-        .ensureList(executeWithArray(query, null, queryText));
-
     List<Object> danglingColumnDescriptorIdList = new ArrayList<>(columnDescriptorIdList.size());
-    if (!sqlResult.isEmpty()) {
-      for (Object[] fields : sqlResult) {
-        if (MetastoreDirectSqlUtils.extractSqlInt(fields[1]) == 0) {
-          danglingColumnDescriptorIdList.add(MetastoreDirectSqlUtils.extractSqlLong(fields[0]));
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
+      List<Object[]> sqlResult = MetastoreDirectSqlUtils
+          .ensureList(executeWithArray(query, null, queryText));
+
+      if (!sqlResult.isEmpty()) {
+        for (Object[] fields : sqlResult) {
+          if (MetastoreDirectSqlUtils.extractSqlInt(fields[1]) == 0) {
+            danglingColumnDescriptorIdList.add(MetastoreDirectSqlUtils.extractSqlLong(fields[0]));
+          }
         }
       }
     }
-    query.closeAll();
-
     if (!danglingColumnDescriptorIdList.isEmpty()) {
       try {
         String danglingCDIds = getIdListForIn(danglingColumnDescriptorIdList);
@@ -2942,8 +2892,7 @@ public Map<String, List<String>> getColAndPartNamesWithStats(
         + PARTITIONS + ".\"PART_NAME\"";
 
     LOG.debug("Running {}", queryText);
-    Query<?> query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    try {
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
       List<Object[]> sqlResult = MetastoreDirectSqlUtils.ensureList(executeWithArray(
           query, new Object[] { dbName, catName, tableName }, queryText));
       Map<String, List<String>> result = new HashMap<>();
@@ -2965,8 +2914,6 @@ public Map<String, List<String>> getColAndPartNamesWithStats(
         result.put(lastPartName, cols);
       }
       return result;
-    } finally {
-      query.closeAll();
     }
   }
 
@@ -2983,8 +2930,7 @@ public List<org.apache.hadoop.hive.common.TableName> getAllTableNamesForStats()
   private void getStatsTableListResult(
       String queryText, List<org.apache.hadoop.hive.common.TableName> result) throws MetaException {
     LOG.debug("Running {}", queryText);
-    Query<?> query = pm.newQuery("javax.jdo.query.SQL", queryText);
-    try {
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", queryText))) {
       List<Object[]> sqlResult = MetastoreDirectSqlUtils
           .ensureList(executeWithArray(query, STATS_TABLE_TYPES, queryText));
       for (Object[] line : sqlResult) {
@@ -2992,8 +2938,6 @@ private void getStatsTableListResult(
             MetastoreDirectSqlUtils.extractSqlString(line[2]), MetastoreDirectSqlUtils
             .extractSqlString(line[1]), MetastoreDirectSqlUtils.extractSqlString(line[0])));
       }
-    } finally {
-      query.closeAll();
     }
   }
 
diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/ObjectStore.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/ObjectStore.java
index 1ceae6406c..164cd5b1ca 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/ObjectStore.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/ObjectStore.java
@@ -314,7 +314,6 @@ private enum TXN_STATUS {
     USER = org.apache.commons.lang3.StringUtils.defaultString(user, "UNKNOWN");
   }
 
-
   private boolean isInitialized = false;
   private PersistenceManager pm = null;
   private SQLGenerator sqlGenerator = null;
@@ -1554,42 +1553,38 @@ private List<MConstraint> listAllTableConstraintsWithOptionalConstraintName(
     constraintname = constraintname!=null?normalizeIdentifier(constraintname):null;
     List<MConstraint> mConstraints = null;
     List<String> constraintNames = new ArrayList<>();
-    Query query = null;
 
-    try {
-      query = pm.newQuery("select constraintName from org.apache.hadoop.hive.metastore.model.MConstraint  where "
+    try (QueryWrapper queryForConstraintName = new QueryWrapper(pm.newQuery("select constraintName from org.apache.hadoop.hive.metastore.model.MConstraint  where "
         + "((parentTable.tableName == ptblname && parentTable.database.name == pdbname && " +
-              "parentTable.database.catalogName == pcatname) || "
+        "parentTable.database.catalogName == pcatname) || "
         + "(childTable != null && childTable.tableName == ctblname &&" +
-              "childTable.database.name == cdbname && childTable.database.catalogName == ccatname)) " +
-          (constraintname != null ? " && constraintName == constraintname" : ""));
-      query.declareParameters("java.lang.String ptblname, java.lang.String pdbname,"
+        "childTable.database.name == cdbname && childTable.database.catalogName == ccatname)) " +
+        (constraintname != null ? " && constraintName == constraintname" : "")));
+        QueryWrapper queryForMConstraint = new QueryWrapper(pm.newQuery(MConstraint.class))) {
+
+      queryForConstraintName.declareParameters("java.lang.String ptblname, java.lang.String pdbname,"
           + "java.lang.String pcatname, java.lang.String ctblname, java.lang.String cdbname," +
           "java.lang.String ccatname" +
         (constraintname != null ? ", java.lang.String constraintname" : ""));
       Collection<?> constraintNamesColl =
         constraintname != null ?
-          ((Collection<?>) query.
+          ((Collection<?>) queryForConstraintName.
             executeWithArray(tableName, dbName, catName, tableName, dbName, catName, constraintname)):
-          ((Collection<?>) query.
+          ((Collection<?>) queryForConstraintName.
             executeWithArray(tableName, dbName, catName, tableName, dbName, catName));
       for (Iterator<?> i = constraintNamesColl.iterator(); i.hasNext();) {
         String currName = (String) i.next();
         constraintNames.add(currName);
       }
-      query = pm.newQuery(MConstraint.class);
-      query.setFilter("param.contains(constraintName)");
-      query.declareParameters("java.util.Collection param");
-      Collection<?> constraints = (Collection<?>)query.execute(constraintNames);
+
+      queryForMConstraint.setFilter("param.contains(constraintName)");
+      queryForMConstraint.declareParameters("java.util.Collection param");
+      Collection<?> constraints = (Collection<?>)queryForMConstraint.execute(constraintNames);
       mConstraints = new ArrayList<>();
       for (Iterator<?> i = constraints.iterator(); i.hasNext();) {
         MConstraint currConstraint = (MConstraint) i.next();
         mConstraints.add(currConstraint);
       }
-    } finally {
-      if (query != null) {
-        query.closeAll();
-      }
     }
     return mConstraints;
   }
@@ -3144,12 +3139,7 @@ public Map<String, String> getPartitionLocations(String catName, String dbName,
       LOG.debug("Done executing query for getPartitionLocations");
       success = commitTransaction();
     } finally {
-      if (!success) {
-        rollbackTransaction();
-      }
-      if (query != null) {
-        query.closeAll();
-      }
+      rollbackAndCleanup(success, query);
     }
     return partLocations;
   }
@@ -3364,36 +3354,35 @@ private List<String> getPartitionNamesViaOrm(Table table, ExpressionTree tree, S
       return null;
     }
 
-    Query query = pm.newQuery(
-        "select partitionName from org.apache.hadoop.hive.metastore.model.MPartition"
-    );
-    query.setFilter(jdoFilter);
-    List<Object[]> orderSpecs = MetaStoreUtils.makeOrderSpecs(order);
-    StringBuilder builder = new StringBuilder();
-    for (Object[] spec : orderSpecs) {
-      // TODO: order by casted value if the type of partition key is not string
-      builder.append("values.get(").append(spec[0]).append(") ").append(spec[1]).append(",");
-    }
-    if (builder.length() > 0) {
-      builder.setLength(builder.length() - 1);
-      query.setOrdering(builder.toString());
-    } else {
-      query.setOrdering("partitionName ascending");
-    }
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(
+        "select partitionName from org.apache.hadoop.hive.metastore.model.MPartition"))) {
+      query.setFilter(jdoFilter);
+      List<Object[]> orderSpecs = MetaStoreUtils.makeOrderSpecs(order);
+      StringBuilder builder = new StringBuilder();
+      for (Object[] spec : orderSpecs) {
+        // TODO: order by casted value if the type of partition key is not string
+        builder.append("values.get(").append(spec[0]).append(") ").append(spec[1]).append(",");
+      }
+      if (builder.length() > 0) {
+        builder.setLength(builder.length() - 1);
+        query.setOrdering(builder.toString());
+      } else {
+        query.setOrdering("partitionName ascending");
+      }
 
-    if (maxParts > -1) {
-      query.setRange(0, maxParts);
-    }
+      if (maxParts > -1) {
+        query.setRange(0, maxParts);
+      }
 
-    String parameterDeclaration = makeParameterDeclarationStringObj(params);
-    query.declareParameters(parameterDeclaration);
-    Collection jdoRes = (Collection)query.executeWithMap(params);
-    List<String> result = new LinkedList<String>();
-    for (Object partName : jdoRes) {
-      result.add((String)partName);
+      String parameterDeclaration = makeParameterDeclarationStringObj(params);
+      query.declareParameters(parameterDeclaration);
+      Collection jdoRes = (Collection) query.executeWithMap(params);
+      List<String> result = new LinkedList<String>();
+      for (Object partName : jdoRes) {
+        result.add((String) partName);
+      }
+      return result;
     }
-    query.closeAll();
-    return result;
   }
 
   private String extractPartitionKey(FieldSchema key, List<FieldSchema> pkeys) {
@@ -3528,6 +3517,7 @@ private List<String> getPartitionNamesByFilter(String catName, String dbName, St
 
     boolean success = false;
     List<String> partNames = new ArrayList<>();
+    Query query = null;
     try {
       openTransaction();
       LOG.debug("Executing getPartitionNamesByFilter");
@@ -3543,7 +3533,7 @@ private List<String> getPartitionNamesByFilter(String catName, String dbName, St
       }
       Map<String, Object> params = new HashMap<>();
       String queryFilterString = makeQueryFilterString(catName, dbName, mtable, filter, params);
-      Query query = pm.newQuery(
+      query = pm.newQuery(
           "select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
               + "where " + queryFilterString);
 
@@ -3572,11 +3562,8 @@ private List<String> getPartitionNamesByFilter(String catName, String dbName, St
       LOG.debug("Done executing query for getPartitionNamesByFilter");
       success = commitTransaction();
       LOG.debug("Done retrieving all objects for getPartitionNamesByFilter, size: {}", partNames.size());
-      query.closeAll();
     } finally {
-      if (!success) {
-        rollbackTransaction();
-      }
+      rollbackAndCleanup(success, query);
     }
     return partNames;
   }
@@ -3585,11 +3572,11 @@ private PartitionValuesResponse getDistinctValuesForPartitionsNoTxn(
       String catName, String dbName, String tableName, List<FieldSchema> cols,
       boolean applyDistinct, long maxParts)
       throws MetaException {
-    try {
+    try (QueryWrapper q = new QueryWrapper(
+        pm.newQuery("select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
+            + "where table.database.name == t1 && table.database.catalogName == t2 && "
+            + "table.tableName == t3 "))) {
       openTransaction();
-      Query q = pm.newQuery("select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
-          + "where table.database.name == t1 && table.database.catalogName == t2 && " +
-          "table.tableName == t3 ");
       q.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
 
       // TODO: Ordering seems to affect the distinctness, needs checking, disabling.
@@ -3635,7 +3622,6 @@ private PartitionValuesResponse getDistinctValuesForPartitionsNoTxn(
           response.addToPartitionValues(rowResponse);
         }
       }
-      q.closeAll();
       return response;
     } finally {
       commitTransaction();
@@ -3650,22 +3636,21 @@ private List<String> getPartitionNamesNoTxn(String catName, String dbName, Strin
     catName = normalizeIdentifier(catName);
     dbName = normalizeIdentifier(dbName);
     tableName = normalizeIdentifier(tableName);
-    Query query =
+    try (QueryWrapper query = new QueryWrapper(
         pm.newQuery("select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
             + "where table.database.name == t1 && table.tableName == t2 && table.database.catalogName == t3 "
-            + "order by partitionName asc");
-    query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
-    query.setResult("partitionName");
-
-    if (max > 0) {
-      query.setRange(0, max);
-    }
-    Collection<String> names = (Collection<String>) query.execute(dbName, tableName, catName);
-    pns.addAll(names);
+            + "order by partitionName asc"))) {
+      query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
+      query.setResult("partitionName");
 
-    query.closeAll();
+      if (max > 0) {
+        query.setRange(0, max);
+      }
+      Collection<String> names = (Collection<String>) query.execute(dbName, tableName, catName);
+      pns.addAll(names);
 
-    return pns;
+      return pns;
+    }
   }
 
   /**
@@ -4035,21 +4020,21 @@ private List<Partition> getPartitionsViaOrmFilter(String catName, String dbName,
       assert !isValidatedFilter;
       return null;
     }
-    Query query = pm.newQuery(MPartition.class, jdoFilter);
-    if (maxParts >= 0) {
-      // User specified a row limit, set it on the Query
-      query.setRange(0, maxParts);
-    }
-    String parameterDeclaration = makeParameterDeclarationStringObj(params);
-    query.declareParameters(parameterDeclaration);
-    query.setOrdering("partitionName ascending");
-    List<MPartition> mparts = (List<MPartition>) query.executeWithMap(params);
-    LOG.debug("Done executing query for getPartitionsViaOrmFilter");
-    pm.retrieveAll(mparts); // TODO: why is this inconsistent with what we get by names?
-    LOG.debug("Done retrieving all objects for getPartitionsViaOrmFilter");
-    List<Partition> results = convertToParts(mparts);
-    query.closeAll();
-    return results;
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(MPartition.class, jdoFilter))) {
+      if (maxParts >= 0) {
+        // User specified a row limit, set it on the Query
+        query.setRange(0, maxParts);
+      }
+      String parameterDeclaration = makeParameterDeclarationStringObj(params);
+      query.declareParameters(parameterDeclaration);
+      query.setOrdering("partitionName ascending");
+      List<MPartition> mparts = (List<MPartition>) query.executeWithMap(params);
+      LOG.debug("Done executing query for getPartitionsViaOrmFilter");
+      pm.retrieveAll(mparts); // TODO: why is this inconsistent with what we get by names?
+      LOG.debug("Done retrieving all objects for getPartitionsViaOrmFilter");
+      List<Partition> results = convertToParts(mparts);
+      return results;
+    }
   }
 
   private Integer getNumPartitionsViaOrmFilter(String catName, String dbName, String tblName, ExpressionTree tree, boolean isValidatedFilter, List<FieldSchema> partitionKeys)
@@ -4062,16 +4047,15 @@ private Integer getNumPartitionsViaOrmFilter(String catName, String dbName, Stri
       return null;
     }
 
-    Query query = pm.newQuery(
-        "select count(partitionName) from org.apache.hadoop.hive.metastore.model.MPartition"
-    );
-    query.setFilter(jdoFilter);
-    String parameterDeclaration = makeParameterDeclarationStringObj(params);
-    query.declareParameters(parameterDeclaration);
-    Long result = (Long) query.executeWithMap(params);
-    query.closeAll();
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(
+        "select count(partitionName) from org.apache.hadoop.hive.metastore.model.MPartition"))) {
+      query.setFilter(jdoFilter);
+      String parameterDeclaration = makeParameterDeclarationStringObj(params);
+      query.declareParameters(parameterDeclaration);
+      Long result = (Long) query.executeWithMap(params);
 
-    return result.intValue();
+      return result.intValue();
+    }
   }
   /**
    * Gets partition names from the table via ORM (JDOQL) name filter.
@@ -4093,16 +4077,16 @@ public List<Partition> run(List<String> input) throws MetaException {
         Pair<Query, Map<String, String>> queryWithParams =
             getPartQueryWithParams(catName, dbName, tblName, input);
 
-        Query query = queryWithParams.getLeft();
-        query.setResultClass(MPartition.class);
-        query.setClass(MPartition.class);
-        query.setOrdering("partitionName ascending");
+        try (QueryWrapper query = new QueryWrapper(queryWithParams.getLeft())) {
+          query.setResultClass(MPartition.class);
+          query.setClass(MPartition.class);
+          query.setOrdering("partitionName ascending");
 
-        List<MPartition> mparts = (List<MPartition>) query.executeWithMap(queryWithParams.getRight());
-        List<Partition> partitions = convertToParts(catName, dbName, tblName, mparts, isAcidTable);
-        query.closeAll();
+          List<MPartition> mparts = (List<MPartition>) query.executeWithMap(queryWithParams.getRight());
+          List<Partition> partitions = convertToParts(catName, dbName, tblName, mparts, isAcidTable);
 
-        return partitions;
+          return partitions;
+        }
       }
     });
   }
@@ -4110,11 +4094,11 @@ public List<Partition> run(List<String> input) throws MetaException {
   private void dropPartitionsNoTxn(String catName, String dbName, String tblName, List<String> partNames) {
     Pair<Query, Map<String, String>> queryWithParams =
         getPartQueryWithParams(catName, dbName, tblName, partNames);
-    Query query = queryWithParams.getLeft();
-    query.setClass(MPartition.class);
-    long deleted = query.deletePersistentAll(queryWithParams.getRight());
-    LOG.debug("Deleted {} partition from store", deleted);
-    query.closeAll();
+    try (QueryWrapper query = new QueryWrapper(queryWithParams.getLeft())) {
+      query.setClass(MPartition.class);
+      long deleted = query.deletePersistentAll(queryWithParams.getRight());
+      LOG.debug("Deleted {} partition from store", deleted);
+    }
   }
 
   /**
@@ -4127,20 +4111,20 @@ private Set<MColumnDescriptor> detachCdsFromSdsNoTxn(
       String catName, String dbName, String tblName, List<String> partNames) {
     Pair<Query, Map<String, String>> queryWithParams =
         getPartQueryWithParams(catName, dbName, tblName, partNames);
-    Query query = queryWithParams.getLeft();
-    query.setClass(MPartition.class);
-    query.setResult("sd");
-    List<MStorageDescriptor> sds = (List<MStorageDescriptor>)query.executeWithMap(
-        queryWithParams.getRight());
-    HashSet<MColumnDescriptor> candidateCds = new HashSet<>();
-    for (MStorageDescriptor sd : sds) {
-      if (sd != null && sd.getCD() != null) {
-        candidateCds.add(sd.getCD());
-        sd.setCD(null);
+    try (QueryWrapper query = new QueryWrapper(queryWithParams.getLeft())) {
+      query.setClass(MPartition.class);
+      query.setResult("sd");
+      List<MStorageDescriptor> sds = (List<MStorageDescriptor>) query.executeWithMap(
+          queryWithParams.getRight());
+      HashSet<MColumnDescriptor> candidateCds = new HashSet<>();
+      for (MStorageDescriptor sd : sds) {
+        if (sd != null && sd.getCD() != null) {
+          candidateCds.add(sd.getCD());
+          sd.setCD(null);
+        }
       }
+      return candidateCds;
     }
-    query.closeAll();
-    return candidateCds;
   }
 
   private String getJDOFilterStrForPartitionNames(String catName, String dbName, String tblName,
@@ -5215,31 +5199,31 @@ private void copyMSD(MStorageDescriptor newSd, MStorageDescriptor oldSd) {
         // If we find it, we will change the reference for the CD.
         // If we do not find it, i.e., the column will be deleted, we do not change it
         // and we let the logic in removeUnusedColumnDescriptor take care of it
-        Query query = pm.newQuery(MConstraint.class, "parentColumn == inCD || childColumn == inCD");
-        query.declareParameters("MColumnDescriptor inCD");
-        List<MConstraint> mConstraintsList = (List<MConstraint>) query.execute(oldSd.getCD());
-        pm.retrieveAll(mConstraintsList);
-        for (MConstraint mConstraint : mConstraintsList) {
-          if (oldSd.getCD().equals(mConstraint.getParentColumn())) {
-            Integer newIdx = mapping.get(mConstraint.getParentIntegerIndex());
-            if (newIdx != null) {
-              mConstraint.setParentColumn(newSd.getCD());
-              mConstraint.setParentIntegerIndex(newIdx);
+        try (QueryWrapper query = new QueryWrapper(pm.newQuery(MConstraint.class, "parentColumn == inCD || childColumn == inCD"))) {
+          query.declareParameters("MColumnDescriptor inCD");
+          List<MConstraint> mConstraintsList = (List<MConstraint>) query.execute(oldSd.getCD());
+          pm.retrieveAll(mConstraintsList);
+          for (MConstraint mConstraint : mConstraintsList) {
+            if (oldSd.getCD().equals(mConstraint.getParentColumn())) {
+              Integer newIdx = mapping.get(mConstraint.getParentIntegerIndex());
+              if (newIdx != null) {
+                mConstraint.setParentColumn(newSd.getCD());
+                mConstraint.setParentIntegerIndex(newIdx);
+              }
             }
-          }
-          if (oldSd.getCD().equals(mConstraint.getChildColumn())) {
-            Integer newIdx = mapping.get(mConstraint.getChildIntegerIndex());
-            if (newIdx != null) {
-              mConstraint.setChildColumn(newSd.getCD());
-              mConstraint.setChildIntegerIndex(newIdx);
+            if (oldSd.getCD().equals(mConstraint.getChildColumn())) {
+              Integer newIdx = mapping.get(mConstraint.getChildIntegerIndex());
+              if (newIdx != null) {
+                mConstraint.setChildColumn(newSd.getCD());
+                mConstraint.setChildIntegerIndex(newIdx);
+              }
             }
           }
+          pm.makePersistentAll(mConstraintsList);
         }
-        pm.makePersistentAll(mConstraintsList);
-        query.closeAll();
+        // Finally replace CD
+        oldSd.setCD(newSd.getCD());
       }
-      // Finally replace CD
-      oldSd.setCD(newSd.getCD());
     }
 
     oldSd.setBucketCols(newSd.getBucketCols());
@@ -8088,8 +8072,9 @@ private void dropPartitionAllColumnGrantsNoTxn(
           dbName, tableName, partNames, MPartitionColumnPrivilege.class,
           "partition.table.tableName", "partition.table.database.name", "partition.partitionName",
           "partition.table.database.catalogName");
-    queryWithParams.getLeft().deletePersistentAll(queryWithParams.getRight());
-    queryWithParams.getLeft().closeAll();
+    try (QueryWrapper wrapper = new QueryWrapper(queryWithParams.getLeft())) {
+      wrapper.deletePersistentAll(queryWithParams.getRight());
+    }
   }
 
   private List<MDBPrivilege> listDatabaseGrants(String catName, String dbName, String authorizer) throws Exception {
@@ -8113,8 +8098,8 @@ private List<MDBPrivilege> listDatabaseGrants(String catName, String dbName, Str
       args = new String[] { dbName, catName };
     }
 
-    try (Query q = query) {
-      final List<MDBPrivilege> mSecurityDBList = (List<MDBPrivilege>) query.executeWithArray(args);
+    try (QueryWrapper q = new QueryWrapper(query)) {
+      final List<MDBPrivilege> mSecurityDBList = (List<MDBPrivilege>) q.executeWithArray(args);
       pm.retrieveAll(mSecurityDBList);
       LOG.debug("Done retrieving all objects for listDatabaseGrants: {}", mSecurityDBList);
       return Collections.unmodifiableList(new ArrayList<>(mSecurityDBList));
@@ -8129,22 +8114,27 @@ private List<MDCPrivilege> listDataConnectorGrants(String dcName, String authori
     dcName = normalizeIdentifier(dcName);
 
     final Query query;
-    final String[] args;
+    String[] args = null;
     final List<MDCPrivilege> mSecurityDCList;
 
     if (authorizer != null) {
       query = pm.newQuery(MDCPrivilege.class, "dataConnector.name == t1 && authorizer == t2");
       query.declareParameters("java.lang.String t1, java.lang.String t2");
       args = new String[] { dcName, authorizer };
-      mSecurityDCList = (List<MDCPrivilege>) query.executeWithArray(args);
     } else {
       query = pm.newQuery(MDCPrivilege.class, "dataConnector.name == t1");
       query.declareParameters("java.lang.String t1");
-      mSecurityDCList = (List<MDCPrivilege>) query.execute(dcName);
     }
-    pm.retrieveAll(mSecurityDCList);
-    LOG.debug("Done retrieving all objects for listDataConnectorGrants: {}", mSecurityDCList);
-    return Collections.unmodifiableList(new ArrayList<>(mSecurityDCList));
+    try (QueryWrapper wrapper = new QueryWrapper(query)) {
+      if (args != null) {
+        mSecurityDCList = (List<MDCPrivilege>) wrapper.executeWithArray(args);
+      } else {
+        mSecurityDCList = (List<MDCPrivilege>) wrapper.execute(dcName);
+      }
+      pm.retrieveAll(mSecurityDCList);
+      LOG.debug("Done retrieving all objects for listDataConnectorGrants: {}", mSecurityDCList);
+      return Collections.unmodifiableList(new ArrayList<>(mSecurityDCList));
+    }
   }
 
   private List<MPartitionPrivilege> listPartitionGrants(String catName, String dbName, String tableName,
@@ -8179,8 +8169,9 @@ private void dropPartitionGrantsNoTxn(String catName, String dbName, String tabl
           dbName, tableName, partNames,MPartitionPrivilege.class, "partition.table.tableName",
           "partition.table.database.name", "partition.partitionName",
           "partition.table.database.catalogName");
-    queryWithParams.getLeft().deletePersistentAll(queryWithParams.getRight());
-    queryWithParams.getLeft().closeAll();
+    try (QueryWrapper wrapper = new QueryWrapper(queryWithParams.getLeft())) {
+      wrapper.deletePersistentAll(queryWithParams.getRight());
+    }
   }
 
   private <T> List<T> queryByPartitionNames(String catName, String dbName, String tableName,
@@ -8188,10 +8179,11 @@ private <T> List<T> queryByPartitionNames(String catName, String dbName, String
       String catCol) {
     Pair<Query, Object[]> queryAndParams = makeQueryByPartitionNames(catName,
         dbName, tableName, partNames, clazz, tbCol, dbCol, partCol, catCol);
-    List<T> results = new ArrayList<T>(
-        (List)queryAndParams.getLeft().executeWithArray(queryAndParams.getRight()));
-    queryAndParams.getLeft().closeAll();
-    return results;
+    try (QueryWrapper wrapper = new QueryWrapper(queryAndParams.getLeft())) {
+      List<T> results = new ArrayList<T>(
+          (List) wrapper.executeWithArray(queryAndParams.getRight()));
+      return results;
+    }
   }
 
   private Pair<Query, Object[]> makeQueryByPartitionNames(
@@ -10246,8 +10238,9 @@ private void dropPartitionColumnStatisticsNoTxn(
     Pair<Query, Object[]> queryWithParams = makeQueryByPartitionNames(
         catName, dbName, tableName, partNames, MPartitionColumnStatistics.class,
         "tableName", "dbName", "partition.partitionName", "catName");
-    queryWithParams.getLeft().deletePersistentAll(queryWithParams.getRight());
-    queryWithParams.getLeft().closeAll();
+    try (QueryWrapper wrapper = new QueryWrapper(queryWithParams.getLeft())) {
+      wrapper.deletePersistentAll(queryWithParams.getRight());
+    }
   }
 
   @Override
@@ -10417,9 +10410,6 @@ public boolean deletePartitionColumnStatistics(String catName, String dbName, St
         }
       }
       ret = commitTransaction();
-    } catch (NoSuchObjectException e) {
-      rollbackTransaction();
-      throw e;
     } finally {
       rollbackAndCleanup(ret, query);
     }
@@ -10510,9 +10500,6 @@ public boolean deleteTableColumnStatistics(String catName, String dbName, String
         }
       }
       ret = commitTransaction();
-    } catch (NoSuchObjectException e) {
-      rollbackTransaction();
-      throw e;
     } finally {
       rollbackAndCleanup(ret, query);
     }
@@ -10542,12 +10529,12 @@ public long cleanupEvents() {
   }
 
   private MDelegationToken getTokenFrom(String tokenId) {
-    Query query = pm.newQuery(MDelegationToken.class, "tokenIdentifier == tokenId");
-    query.declareParameters("java.lang.String tokenId");
-    query.setUnique(true);
-    MDelegationToken delegationToken = (MDelegationToken) query.execute(tokenId);
-    query.closeAll();
-    return delegationToken;
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(MDelegationToken.class, "tokenIdentifier == tokenId"))) {
+      query.declareParameters("java.lang.String tokenId");
+      query.setUnique(true);
+      MDelegationToken delegationToken = (MDelegationToken) query.execute(tokenId);
+      return delegationToken;
+    }
   }
 
   @Override
@@ -11511,13 +11498,10 @@ private void lockNotificationSequenceForUpdate() throws MetaException {
       String lockingQuery = sqlGenerator.addForUpdateClause(selectQuery);
       new RetryingExecutor(conf, () -> {
         prepareQuotes();
-        Query query = pm.newQuery("javax.jdo.query.SQL", lockingQuery);
-        try {
+        try (QueryWrapper query = new QueryWrapper(pm.newQuery("javax.jdo.query.SQL", lockingQuery))) {
           query.setUnique(true);
           // only need to execute it to get db Lock
           query.execute();
-        } finally {
-          query.closeAll();
         }
       }).run();
     }
@@ -12278,12 +12262,7 @@ private List<SQLCheckConstraint> getCheckConstraintsViaJdo(String catName, Strin
       }
       commited = commitTransaction();
     } finally {
-      if (!commited) {
-        rollbackTransaction();
-      }
-      if (query != null) {
-        query.closeAll();
-      }
+      rollbackAndCleanup(commited, query);
     }
     return checkConstraints;
   }
@@ -12317,12 +12296,7 @@ private List<SQLDefaultConstraint> getDefaultConstraintsViaJdo(String catName, S
       }
       commited = commitTransaction();
     } finally {
-      if (!commited) {
-        rollbackTransaction();
-      }
-      if (query != null) {
-        query.closeAll();
-      }
+      rollbackAndCleanup(commited, query);
     }
     return defaultConstraints;
   }
@@ -12514,23 +12488,17 @@ public ISchema getISchema(ISchemaName schemaName) throws MetaException {
   }
 
   private MISchema getMISchema(String catName, String dbName, String name) {
-    Query query = null;
-    try {
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(MISchema.class,
+        "name == schemaName && db.name == dbname && db.catalogName == cat"))) {
       name = normalizeIdentifier(name);
       dbName = normalizeIdentifier(dbName);
       catName = normalizeIdentifier(catName);
-      query = pm.newQuery(MISchema.class,
-          "name == schemaName && db.name == dbname && db.catalogName == cat");
       query.declareParameters(
           "java.lang.String schemaName, java.lang.String dbname, java.lang.String cat");
       query.setUnique(true);
       MISchema mSchema = (MISchema)query.execute(name, dbName, catName);
       pm.retrieve(mSchema);
       return mSchema;
-    } finally {
-      if (query != null) {
-        query.closeAll();
-      }
     }
   }
 
@@ -12625,13 +12593,11 @@ public SchemaVersion getSchemaVersion(SchemaVersionDescriptor version) throws Me
   }
 
   private MSchemaVersion getMSchemaVersion(String catName, String dbName, String schemaName, int version) {
-    Query query = null;
-    try {
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(MSchemaVersion.class,
+        "iSchema.name == schemaName && iSchema.db.name == dbName &&" +
+            "iSchema.db.catalogName == cat && version == schemaVersion"))) {
       dbName = normalizeIdentifier(dbName);
       schemaName = normalizeIdentifier(schemaName);
-      query = pm.newQuery(MSchemaVersion.class,
-          "iSchema.name == schemaName && iSchema.db.name == dbName &&" +
-              "iSchema.db.catalogName == cat && version == schemaVersion");
       query.declareParameters( "java.lang.String schemaName, java.lang.String dbName," +
           "java.lang.String cat, java.lang.Integer schemaVersion");
       query.setUnique(true);
@@ -12645,10 +12611,6 @@ private MSchemaVersion getMSchemaVersion(String catName, String dbName, String s
         }
       }
       return mSchemaVersion;
-    } finally {
-      if (query != null) {
-        query.closeAll();
-      }
     }
   }
 
@@ -12823,18 +12785,12 @@ public SerDeInfo getSerDeInfo(String serDeName) throws NoSuchObjectException, Me
   }
 
   private MSerDeInfo getMSerDeInfo(String serDeName) {
-    Query query = null;
-    try {
-      query = pm.newQuery(MSerDeInfo.class, "name == serDeName");
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(MSerDeInfo.class, "name == serDeName"))) {
       query.declareParameters("java.lang.String serDeName");
       query.setUnique(true);
-      MSerDeInfo mSerDeInfo = (MSerDeInfo)query.execute(serDeName);
+      MSerDeInfo mSerDeInfo = (MSerDeInfo) query.execute(serDeName);
       pm.retrieve(mSerDeInfo);
       return mSerDeInfo;
-    } finally {
-      if (query != null) {
-        query.closeAll();
-      }
     }
   }
 
@@ -14104,27 +14060,27 @@ public List<RuntimeStat> getRuntimeStats(int maxEntries, int maxCreateTime) thro
   }
 
   private List<RuntimeStat> getMRuntimeStats(int maxEntries, int maxCreateTime) {
-    Query<MRuntimeStat> query = pm.newQuery(MRuntimeStat.class);
-    query.setOrdering("createTime descending");
-    if (maxCreateTime > 0) {
-      query.setFilter("createTime < "+maxCreateTime);
-    }
-    if (maxEntries < 0) {
-      maxEntries = Integer.MAX_VALUE;
-    }
-    List<RuntimeStat> ret = new ArrayList<>();
-    List<MRuntimeStat> res = (List<MRuntimeStat>) query.execute();
-    int totalEntries = 0;
-    for (MRuntimeStat mRuntimeStat : res) {
-      pm.retrieve(mRuntimeStat);
-      totalEntries += mRuntimeStat.getWeight();
-      ret.add(MRuntimeStat.toThrift(mRuntimeStat));
-      if (totalEntries >= maxEntries) {
-        break;
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(MRuntimeStat.class))) {
+      query.setOrdering("createTime descending");
+      if (maxCreateTime > 0) {
+        query.setFilter("createTime < " + maxCreateTime);
+      }
+      if (maxEntries < 0) {
+        maxEntries = Integer.MAX_VALUE;
+      }
+      List<RuntimeStat> ret = new ArrayList<>();
+      List<MRuntimeStat> res = (List<MRuntimeStat>) query.execute();
+      int totalEntries = 0;
+      for (MRuntimeStat mRuntimeStat : res) {
+        pm.retrieve(mRuntimeStat);
+        totalEntries += mRuntimeStat.getWeight();
+        ret.add(MRuntimeStat.toThrift(mRuntimeStat));
+        if (totalEntries >= maxEntries) {
+          break;
+        }
       }
+      return ret;
     }
-    query.closeAll();
-    return ret;
   }
 
   /**
@@ -14215,11 +14171,9 @@ public ScheduledQueryPollResponse scheduledQueryPoll(ScheduledQueryPollRequest r
     String namespace = request.getClusterNamespace();
     boolean commited = false;
     ScheduledQueryPollResponse ret = new ScheduledQueryPollResponse();
-    Query q = null;
-    try {
+    try (QueryWrapper q = new QueryWrapper(pm.newQuery(MScheduledQuery.class,
+        "nextExecution <= now && enabled && clusterNamespace == ns && activeExecution == null"))) {
       openTransaction();
-      q = pm.newQuery(MScheduledQuery.class,
-          "nextExecution <= now && enabled && clusterNamespace == ns && activeExecution == null");
       q.setSerializeRead(true);
       q.declareParameters("java.lang.Integer now, java.lang.String ns");
       q.setOrdering("nextExecution");
@@ -14251,9 +14205,6 @@ public ScheduledQueryPollResponse scheduledQueryPoll(ScheduledQueryPollRequest r
       LOG.debug("Caught jdo exception; exclusive", e);
       commited = false;
     } finally {
-      if (q != null) {
-        q.closeAll();
-      }
       if (commited) {
         return ret;
       } else {
@@ -14322,13 +14273,14 @@ private void processScheduledQueryPolicies(ScheduledQueryProgressInfo info) thro
     }
 
     boolean commited = false;
+    Query query = null;
     try {
       openTransaction();
 
       MScheduledExecution lastExecution = pm.getObjectById(MScheduledExecution.class, info.getScheduledExecutionId());
       MScheduledQuery schq = lastExecution.getScheduledQuery();
 
-      Query query = pm.newQuery(MScheduledExecution.class);
+      query = pm.newQuery(MScheduledExecution.class);
       query.setFilter("scheduledQuery == currentSchedule");
       query.setOrdering("scheduledExecutionId descending");
       query.declareParameters("MScheduledQuery currentSchedule");
@@ -14372,9 +14324,7 @@ private void processScheduledQueryPolicies(ScheduledQueryProgressInfo info) thro
     } catch (InvalidInputException e) {
       throw new MetaException("Unexpected InvalidInputException: " + e.getMessage());
     } finally {
-      if (!commited) {
-        rollbackTransaction();
-      }
+      rollbackAndCleanup(commited, query);
     }
   }
 
@@ -14479,17 +14429,18 @@ private ReplicationMetricList getMReplicationMetrics(String policy) {
     if (StringUtils.isEmpty(policy)) {
       return ret;
     }
-    Query<MReplicationMetrics> query = pm.newQuery(MReplicationMetrics.class, "policy == policyParam");
-    query.declareParameters("java.lang.String policyParam");
-    query.setOrdering("scheduledExecutionId descending");
-    List<MReplicationMetrics> list = (List<MReplicationMetrics>) query.execute(policy);
-    List<ReplicationMetrics> returnList = new ArrayList<>();
-    for (MReplicationMetrics mReplicationMetric : list) {
-      pm.retrieve(mReplicationMetric);
-      returnList.add(MReplicationMetrics.toThrift(mReplicationMetric));
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(MReplicationMetrics.class, "policy == policyParam"))) {
+      query.declareParameters("java.lang.String policyParam");
+      query.setOrdering("scheduledExecutionId descending");
+      List<MReplicationMetrics> list = (List<MReplicationMetrics>) query.execute(policy);
+      List<ReplicationMetrics> returnList = new ArrayList<>();
+      for (MReplicationMetrics mReplicationMetric : list) {
+        pm.retrieve(mReplicationMetric);
+        returnList.add(MReplicationMetrics.toThrift(mReplicationMetric));
+      }
+      ret.setReplicationMetricList(returnList);
+      return ret;
     }
-    ret.setReplicationMetricList(returnList);
-    return ret;
   }
 
   private ReplicationMetricList getMReplicationMetrics(long scheduledExecutionId) {
@@ -14497,18 +14448,19 @@ private ReplicationMetricList getMReplicationMetrics(long scheduledExecutionId)
     if (scheduledExecutionId < 0) {
       return ret;
     }
-    Query<MReplicationMetrics> query = pm.newQuery(MReplicationMetrics.class,
-        "scheduledExecutionId == scheduledExecutionIdParam");
-    query.declareParameters("java.lang.Long scheduledExecutionIdParam");
-    query.setOrdering("scheduledExecutionId descending");
-    List<MReplicationMetrics> list = (List<MReplicationMetrics>) query.execute(scheduledExecutionId);
-    List<ReplicationMetrics> returnList = new ArrayList<>();
-    for (MReplicationMetrics mReplicationMetric : list) {
-      pm.retrieve(mReplicationMetric);
-      returnList.add(MReplicationMetrics.toThrift(mReplicationMetric));
-    }
-    ret.setReplicationMetricList(returnList);
-    return ret;
+    try (QueryWrapper query = new QueryWrapper(pm.newQuery(MReplicationMetrics.class,
+        "scheduledExecutionId == scheduledExecutionIdParam"))) {
+      query.declareParameters("java.lang.Long scheduledExecutionIdParam");
+      query.setOrdering("scheduledExecutionId descending");
+      List<MReplicationMetrics> list = (List<MReplicationMetrics>) query.execute(scheduledExecutionId);
+      List<ReplicationMetrics> returnList = new ArrayList<>();
+      for (MReplicationMetrics mReplicationMetric : list) {
+        pm.retrieve(mReplicationMetric);
+        returnList.add(MReplicationMetrics.toThrift(mReplicationMetric));
+      }
+      ret.setReplicationMetricList(returnList);
+      return ret;
+    }
   }
 
   private void ensureScheduledQueriesEnabled() throws MetaException {
@@ -14745,19 +14697,19 @@ public int markScheduledExecutionsTimedOut(int timeoutSecs) throws InvalidOperat
 
   private void recoverInvalidScheduledQueryState(int timeoutSecs) {
     int maxLastUpdateTime = (int) (System.currentTimeMillis() / 1000) - timeoutSecs;
-    Query q = pm.newQuery(MScheduledQuery.class);
-    q.setFilter("activeExecution != null");
+    try (QueryWrapper q = new QueryWrapper(pm.newQuery(MScheduledQuery.class))) {
+      q.setFilter("activeExecution != null");
 
-    List<MScheduledQuery> results = (List<MScheduledQuery>) q.execute();
-    for (MScheduledQuery e : results) {
-      Integer lastUpdateTime = e.getActiveExecution().getLastUpdateTime();
-      if (lastUpdateTime == null || lastUpdateTime < maxLastUpdateTime) {
-        LOG.error("Scheduled query: {} stuck with an activeExecution - clearing",
-            scheduledQueryKeyRef(e.getScheduleKey()));
-        e.setActiveExecution(null);
-        pm.makePersistent(e);
+      List<MScheduledQuery> results = (List<MScheduledQuery>) q.execute();
+      for (MScheduledQuery e : results) {
+        Integer lastUpdateTime = e.getActiveExecution().getLastUpdateTime();
+        if (lastUpdateTime == null || lastUpdateTime < maxLastUpdateTime) {
+          LOG.error("Scheduled query: {} stuck with an activeExecution - clearing",
+              scheduledQueryKeyRef(e.getScheduleKey()));
+          e.setActiveExecution(null);
+          pm.makePersistent(e);
+        }
       }
     }
-    q.closeAll();
   }
 }
diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/QueryWrapper.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/QueryWrapper.java
new file mode 100644
index 0000000000..530ba18071
--- /dev/null
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/QueryWrapper.java
@@ -0,0 +1,430 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.metastore;
+
+import javax.jdo.Extent;
+import javax.jdo.FetchPlan;
+import javax.jdo.PersistenceManager;
+import javax.jdo.Query;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+import static java.util.Objects.requireNonNull;
+
+/**
+ * A wrapper around Query objects where the {@link AutoCloseable#close()} method
+ * is delegated to the wrapped object's {@link Query#closeAll()} method.
+ * This way the users of the wrapper can use try-with-resources without exception handling.
+ */
+public class QueryWrapper implements Query {
+
+  private final Query delegate;
+
+  public QueryWrapper(Query query) {
+    requireNonNull(query, "query is null");
+    this.delegate = query;
+  }
+
+  /**
+   * Delegates the method to {@link Query#closeAll()}, so no exception is thrown.
+   */
+  @Override
+  public void close() {
+    delegate.closeAll();
+  }
+
+  // ======================= Interfaces of Query ===========================
+  @Override
+  public void setClass(Class cls) {
+    delegate.setClass(cls);
+  }
+
+  @Override
+  public void setCandidates(Extent pcs) {
+    delegate.setCandidates(pcs);
+  }
+
+  @Override
+  public void setCandidates(Collection pcs) {
+    delegate.setCandidates(pcs);
+  }
+
+  @Override
+  public void setFilter(String filter) {
+    delegate.setFilter(filter);
+  }
+
+  @Override
+  public void declareImports(String imports) {
+    delegate.declareImports(imports);
+  }
+
+  @Override
+  public void declareParameters(String parameters) {
+    delegate.declareParameters(parameters);
+  }
+
+  @Override
+  public void declareVariables(String variables) {
+    delegate.declareVariables(variables);
+  }
+
+  @Override
+  public void setOrdering(String ordering) {
+    delegate.setOrdering(ordering);
+  }
+
+  @Override
+  public void setIgnoreCache(boolean ignoreCache) {
+    delegate.setIgnoreCache(ignoreCache);
+  }
+
+  @Override
+  public boolean getIgnoreCache() {
+    return delegate.getIgnoreCache();
+  }
+
+  @Override
+  public void compile() {
+    delegate.compile();
+  }
+
+  @Override
+  public Object execute() {
+    return delegate.execute();
+  }
+
+  @Override
+  public Object execute(Object p1) {
+    return delegate.execute(p1);
+  }
+
+  @Override
+  public Object execute(Object p1, Object p2) {
+    return delegate.execute(p1, p2);
+  }
+
+  @Override
+  public Object execute(Object p1, Object p2, Object p3) {
+    return delegate.execute(p1, p2, p3);
+  }
+
+  @Override
+  public Object executeWithMap(Map parameters) {
+    return delegate.executeWithMap(parameters);
+  }
+
+  @Override
+  public Object executeWithArray(Object... parameters) {
+    return delegate.executeWithArray(parameters);
+  }
+
+  @Override
+  public PersistenceManager getPersistenceManager() {
+    return delegate.getPersistenceManager();
+  }
+
+  @Override
+  public void close(Object queryResult) {
+    delegate.close(queryResult);
+  }
+
+  @Override
+  public void closeAll() {
+    delegate.closeAll();
+  }
+
+  @Override
+  public void setGrouping(String group) {
+    delegate.setGrouping(group);
+  }
+
+  @Override
+  public void setUnique(boolean unique) {
+    delegate.setUnique(unique);
+  }
+
+  @Override
+  public void setResult(String data) {
+    delegate.setResult(data);
+  }
+
+  @Override
+  public void setResultClass(Class cls) {
+    delegate.setResultClass(cls);
+  }
+
+  @Override
+  public void setRange(long fromIncl, long toExcl) {
+    delegate.setRange(fromIncl, toExcl);
+  }
+
+  @Override
+  public void setRange(String fromInclToExcl) {
+    delegate.setRange(fromInclToExcl);
+  }
+
+  @Override
+  public void addExtension(String key, Object value) {
+    delegate.addExtension(key, value);
+  }
+
+  @Override
+  public void setExtensions(Map extensions) {
+    delegate.setExtensions(extensions);
+  }
+
+  @Override
+  public FetchPlan getFetchPlan() {
+    return delegate.getFetchPlan();
+  }
+
+  @Override
+  public long deletePersistentAll(Object... parameters) {
+    return delegate.deletePersistentAll(parameters);
+  }
+
+  @Override
+  public long deletePersistentAll(Map parameters) {
+    return delegate.deletePersistentAll(parameters);
+  }
+
+  @Override
+  public long deletePersistentAll() {
+    return delegate.deletePersistentAll();
+  }
+
+  @Override
+  public void setUnmodifiable() {
+    delegate.setUnmodifiable();
+  }
+
+  @Override
+  public boolean isUnmodifiable() {
+    return delegate.isUnmodifiable();
+  }
+
+  @Override
+  public void addSubquery(Query sub, String variableDeclaration, String candidateCollectionExpression) {
+    delegate.addSubquery(sub, variableDeclaration, candidateCollectionExpression);
+  }
+
+  @Override
+  public void addSubquery(Query sub, String variableDeclaration, String candidateCollectionExpression, String parameter) {
+    delegate.addSubquery(sub, variableDeclaration, candidateCollectionExpression, parameter);
+  }
+
+  @Override
+  public void addSubquery(Query sub, String variableDeclaration, String candidateCollectionExpression, String... parameters) {
+    delegate.addSubquery(sub, variableDeclaration, candidateCollectionExpression, parameters);
+  }
+
+  @Override
+  public void addSubquery(Query sub, String variableDeclaration, String candidateCollectionExpression, Map parameters) {
+    delegate.addSubquery(sub, variableDeclaration, candidateCollectionExpression, parameters);
+  }
+
+  @Override
+  public void setDatastoreReadTimeoutMillis(Integer interval) {
+    delegate.setDatastoreReadTimeoutMillis(interval);
+  }
+
+  @Override
+  public Integer getDatastoreReadTimeoutMillis() {
+    return delegate.getDatastoreReadTimeoutMillis();
+  }
+
+  @Override
+  public void setDatastoreWriteTimeoutMillis(Integer interval) {
+    delegate.setDatastoreWriteTimeoutMillis(interval);
+  }
+
+  @Override
+  public Integer getDatastoreWriteTimeoutMillis() {
+    return delegate.getDatastoreWriteTimeoutMillis();
+  }
+
+  @Override
+  public void cancelAll() {
+    delegate.cancelAll();
+  }
+
+  @Override
+  public void cancel(Thread thread) {
+    delegate.cancel(thread);
+  }
+
+  @Override
+  public void setSerializeRead(Boolean serialize) {
+    delegate.setSerializeRead(serialize);
+  }
+
+  @Override
+  public Boolean getSerializeRead() {
+    return delegate.getSerializeRead();
+  }
+
+  @Override
+  public Query saveAsNamedQuery(String name) {
+    return delegate.saveAsNamedQuery(name);
+  }
+
+  @Override
+  public Query filter(String filter) {
+    return delegate.filter(filter);
+  }
+
+  @Override
+  public Query orderBy(String ordering) {
+    return delegate.orderBy(ordering);
+  }
+
+  @Override
+  public Query groupBy(String group) {
+    return delegate.groupBy(group);
+  }
+
+  @Override
+  public Query result(String result) {
+    return delegate.result(result);
+  }
+
+  @Override
+  public Query range(long fromIncl, long toExcl) {
+    return delegate.range(fromIncl, toExcl);
+  }
+
+  @Override
+  public Query range(String fromInclToExcl) {
+    return delegate.range(fromInclToExcl);
+  }
+
+  @Override
+  public Query subquery(Query sub, String variableDeclaration, String candidateCollectionExpression) {
+    return delegate.subquery(sub, variableDeclaration, candidateCollectionExpression);
+  }
+
+  @Override
+  public Query subquery(Query sub, String variableDeclaration, String candidateCollectionExpression, String parameter) {
+    return delegate.subquery(sub, variableDeclaration, candidateCollectionExpression, parameter);
+  }
+
+  @Override
+  public Query subquery(Query sub, String variableDeclaration, String candidateCollectionExpression, String... parameters) {
+    return delegate.subquery(sub, variableDeclaration, candidateCollectionExpression, parameters);
+  }
+
+  @Override
+  public Query subquery(Query sub, String variableDeclaration, String candidateCollectionExpression, Map parameters) {
+    return delegate.subquery(sub, variableDeclaration, candidateCollectionExpression, parameters);
+  }
+
+  @Override
+  public Query imports(String imports) {
+    return delegate.imports(imports);
+  }
+
+  @Override
+  public Query parameters(String parameters) {
+    return delegate.parameters(parameters);
+  }
+
+  @Override
+  public Query variables(String variables) {
+    return delegate.variables(variables);
+  }
+
+  @Override
+  public Query datastoreReadTimeoutMillis(Integer interval) {
+    return delegate.datastoreReadTimeoutMillis(interval);
+  }
+
+  @Override
+  public Query datastoreWriteTimeoutMillis(Integer interval) {
+    return delegate.datastoreWriteTimeoutMillis(interval);
+  }
+
+  @Override
+  public Query serializeRead(Boolean serialize) {
+    return delegate.serializeRead(serialize);
+  }
+
+  @Override
+  public Query unmodifiable() {
+    return delegate.unmodifiable();
+  }
+
+  @Override
+  public Query ignoreCache(boolean flag) {
+    return delegate.ignoreCache(flag);
+  }
+
+  @Override
+  public Query extension(String key, Object value) {
+    return delegate.extension(key, value);
+  }
+
+  @Override
+  public Query extensions(Map values) {
+    return delegate.extensions(values);
+  }
+
+  @Override
+  public Query setNamedParameters(Map namedParamMap) {
+    return delegate.setNamedParameters(namedParamMap);
+  }
+
+  @Override
+  public Query setParameters(Object... paramValues) {
+    return delegate.setParameters(paramValues);
+  }
+
+  @Override
+  public List executeList() {
+    return delegate.executeList();
+  }
+
+  @Override
+  public Object executeUnique() {
+    return delegate.executeUnique();
+  }
+
+  @Override
+  public List executeResultList(Class resultCls) {
+    return delegate.executeResultList(resultCls);
+  }
+
+  @Override
+  public Object executeResultUnique(Class resultCls) {
+    return delegate.executeResultUnique(resultCls);
+  }
+
+  @Override
+  public List<Object> executeResultList() {
+    return delegate.executeResultList();
+  }
+
+  @Override
+  public Object executeResultUnique() {
+    return delegate.executeResultUnique();
+  }
+  // ======================= END ===========================
+}
