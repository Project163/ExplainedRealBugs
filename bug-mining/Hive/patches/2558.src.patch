diff --git a/ql/src/test/results/beelinepositive/convert_enum_to_string.q.out b/ql/src/test/results/beelinepositive/convert_enum_to_string.q.out
index 24acdcdc5d..b576c731b1 100644
--- a/ql/src/test/results/beelinepositive/convert_enum_to_string.q.out
+++ b/ql/src/test/results/beelinepositive/convert_enum_to_string.q.out
@@ -29,9 +29,9 @@ No rows affected
 'my_stringlist','array<string>','from deserializer'
 'my_structlist','array<struct<my_string:string,my_enum:string>>','from deserializer'
 'my_enumlist','array<string>','from deserializer'
-'my_stringset','struct<>','from deserializer'
-'my_enumset','struct<>','from deserializer'
-'my_structset','struct<>','from deserializer'
+'my_stringset','array<string>','from deserializer'
+'my_enumset','array<string>','from deserializer'
+'my_structset','array<struct<my_string:string,my_enum:string>>','from deserializer'
 'b','string',''
 21 rows selected 
 >>>  !record
diff --git a/ql/src/test/results/clientpositive/convert_enum_to_string.q.out b/ql/src/test/results/clientpositive/convert_enum_to_string.q.out
index a1ef04f242..ee33631e11 100644
--- a/ql/src/test/results/clientpositive/convert_enum_to_string.q.out
+++ b/ql/src/test/results/clientpositive/convert_enum_to_string.q.out
@@ -43,9 +43,9 @@ my_enum_structlist_map	map<string,array<struct<my_string:string,my_enum:string,o
 my_stringlist       	array<string>       	from deserializer   
 my_structlist       	array<struct<my_string:string,my_enum:string,optionals:struct<>>>	from deserializer   
 my_enumlist         	array<string>       	from deserializer   
-my_stringset        	struct<>            	from deserializer   
-my_enumset          	struct<>            	from deserializer   
-my_structset        	struct<>            	from deserializer   
+my_stringset        	array<string>       	from deserializer   
+my_enumset          	array<string>       	from deserializer   
+my_structset        	array<struct<my_string:string,my_enum:string,optionals:struct<>>>	from deserializer   
 optionals           	struct<>            	from deserializer   
 b                   	string              	                    
 	 	 
diff --git a/serde/if/test/complex.thrift b/serde/if/test/complex.thrift
index 308b64c93b..8a042ee9be 100644
--- a/serde/if/test/complex.thrift
+++ b/serde/if/test/complex.thrift
@@ -32,3 +32,8 @@ struct Complex {
   5: list<IntString> lintString;
   6: map<string, string> mStringString;
 }
+
+struct SetIntString {
+  1: set<IntString> sIntString;
+  2: string aString;
+}
diff --git a/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/SetIntString.java b/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/SetIntString.java
new file mode 100644
index 0000000000..9b00404c53
--- /dev/null
+++ b/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/SetIntString.java
@@ -0,0 +1,540 @@
+/**
+ * Autogenerated by Thrift Compiler (0.9.0)
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ *  @generated
+ */
+package org.apache.hadoop.hive.serde2.thrift.test;
+
+import org.apache.thrift.scheme.IScheme;
+import org.apache.thrift.scheme.SchemeFactory;
+import org.apache.thrift.scheme.StandardScheme;
+
+import org.apache.thrift.scheme.TupleScheme;
+import org.apache.thrift.protocol.TTupleProtocol;
+import org.apache.thrift.protocol.TProtocolException;
+import org.apache.thrift.EncodingUtils;
+import org.apache.thrift.TException;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class SetIntString implements org.apache.thrift.TBase<SetIntString, SetIntString._Fields>, java.io.Serializable, Cloneable {
+  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("SetIntString");
+
+  private static final org.apache.thrift.protocol.TField S_INT_STRING_FIELD_DESC = new org.apache.thrift.protocol.TField("sIntString", org.apache.thrift.protocol.TType.SET, (short)1);
+  private static final org.apache.thrift.protocol.TField A_STRING_FIELD_DESC = new org.apache.thrift.protocol.TField("aString", org.apache.thrift.protocol.TType.STRING, (short)2);
+
+  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
+  static {
+    schemes.put(StandardScheme.class, new SetIntStringStandardSchemeFactory());
+    schemes.put(TupleScheme.class, new SetIntStringTupleSchemeFactory());
+  }
+
+  public Set<IntString> sIntString; // required
+  public String aString; // required
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+    S_INT_STRING((short)1, "sIntString"),
+    A_STRING((short)2, "aString");
+
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      switch(fieldId) {
+        case 1: // S_INT_STRING
+          return S_INT_STRING;
+        case 2: // A_STRING
+          return A_STRING;
+        default:
+          return null;
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+  static {
+    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+    tmpMap.put(_Fields.S_INT_STRING, new org.apache.thrift.meta_data.FieldMetaData("sIntString", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+        new org.apache.thrift.meta_data.SetMetaData(org.apache.thrift.protocol.TType.SET, 
+            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, IntString.class))));
+    tmpMap.put(_Fields.A_STRING, new org.apache.thrift.meta_data.FieldMetaData("aString", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
+    metaDataMap = Collections.unmodifiableMap(tmpMap);
+    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(SetIntString.class, metaDataMap);
+  }
+
+  public SetIntString() {
+  }
+
+  public SetIntString(
+    Set<IntString> sIntString,
+    String aString)
+  {
+    this();
+    this.sIntString = sIntString;
+    this.aString = aString;
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public SetIntString(SetIntString other) {
+    if (other.isSetSIntString()) {
+      Set<IntString> __this__sIntString = new HashSet<IntString>();
+      for (IntString other_element : other.sIntString) {
+        __this__sIntString.add(new IntString(other_element));
+      }
+      this.sIntString = __this__sIntString;
+    }
+    if (other.isSetAString()) {
+      this.aString = other.aString;
+    }
+  }
+
+  public SetIntString deepCopy() {
+    return new SetIntString(this);
+  }
+
+  @Override
+  public void clear() {
+    this.sIntString = null;
+    this.aString = null;
+  }
+
+  public int getSIntStringSize() {
+    return (this.sIntString == null) ? 0 : this.sIntString.size();
+  }
+
+  public java.util.Iterator<IntString> getSIntStringIterator() {
+    return (this.sIntString == null) ? null : this.sIntString.iterator();
+  }
+
+  public void addToSIntString(IntString elem) {
+    if (this.sIntString == null) {
+      this.sIntString = new HashSet<IntString>();
+    }
+    this.sIntString.add(elem);
+  }
+
+  public Set<IntString> getSIntString() {
+    return this.sIntString;
+  }
+
+  public SetIntString setSIntString(Set<IntString> sIntString) {
+    this.sIntString = sIntString;
+    return this;
+  }
+
+  public void unsetSIntString() {
+    this.sIntString = null;
+  }
+
+  /** Returns true if field sIntString is set (has been assigned a value) and false otherwise */
+  public boolean isSetSIntString() {
+    return this.sIntString != null;
+  }
+
+  public void setSIntStringIsSet(boolean value) {
+    if (!value) {
+      this.sIntString = null;
+    }
+  }
+
+  public String getAString() {
+    return this.aString;
+  }
+
+  public SetIntString setAString(String aString) {
+    this.aString = aString;
+    return this;
+  }
+
+  public void unsetAString() {
+    this.aString = null;
+  }
+
+  /** Returns true if field aString is set (has been assigned a value) and false otherwise */
+  public boolean isSetAString() {
+    return this.aString != null;
+  }
+
+  public void setAStringIsSet(boolean value) {
+    if (!value) {
+      this.aString = null;
+    }
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case S_INT_STRING:
+      if (value == null) {
+        unsetSIntString();
+      } else {
+        setSIntString((Set<IntString>)value);
+      }
+      break;
+
+    case A_STRING:
+      if (value == null) {
+        unsetAString();
+      } else {
+        setAString((String)value);
+      }
+      break;
+
+    }
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case S_INT_STRING:
+      return getSIntString();
+
+    case A_STRING:
+      return getAString();
+
+    }
+    throw new IllegalStateException();
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    if (field == null) {
+      throw new IllegalArgumentException();
+    }
+
+    switch (field) {
+    case S_INT_STRING:
+      return isSetSIntString();
+    case A_STRING:
+      return isSetAString();
+    }
+    throw new IllegalStateException();
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof SetIntString)
+      return this.equals((SetIntString)that);
+    return false;
+  }
+
+  public boolean equals(SetIntString that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_sIntString = true && this.isSetSIntString();
+    boolean that_present_sIntString = true && that.isSetSIntString();
+    if (this_present_sIntString || that_present_sIntString) {
+      if (!(this_present_sIntString && that_present_sIntString))
+        return false;
+      if (!this.sIntString.equals(that.sIntString))
+        return false;
+    }
+
+    boolean this_present_aString = true && this.isSetAString();
+    boolean that_present_aString = true && that.isSetAString();
+    if (this_present_aString || that_present_aString) {
+      if (!(this_present_aString && that_present_aString))
+        return false;
+      if (!this.aString.equals(that.aString))
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return 0;
+  }
+
+  public int compareTo(SetIntString other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    SetIntString typedOther = (SetIntString)other;
+
+    lastComparison = Boolean.valueOf(isSetSIntString()).compareTo(typedOther.isSetSIntString());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetSIntString()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sIntString, typedOther.sIntString);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetAString()).compareTo(typedOther.isSetAString());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetAString()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.aString, typedOther.aString);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public _Fields fieldForId(int fieldId) {
+    return _Fields.findByThriftId(fieldId);
+  }
+
+  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
+  }
+
+  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("SetIntString(");
+    boolean first = true;
+
+    sb.append("sIntString:");
+    if (this.sIntString == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.sIntString);
+    }
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("aString:");
+    if (this.aString == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.aString);
+    }
+    first = false;
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws org.apache.thrift.TException {
+    // check for required fields
+    // check for sub-struct validity
+  }
+
+  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
+    try {
+      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
+    try {
+      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private static class SetIntStringStandardSchemeFactory implements SchemeFactory {
+    public SetIntStringStandardScheme getScheme() {
+      return new SetIntStringStandardScheme();
+    }
+  }
+
+  private static class SetIntStringStandardScheme extends StandardScheme<SetIntString> {
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot, SetIntString struct) throws org.apache.thrift.TException {
+      org.apache.thrift.protocol.TField schemeField;
+      iprot.readStructBegin();
+      while (true)
+      {
+        schemeField = iprot.readFieldBegin();
+        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
+          break;
+        }
+        switch (schemeField.id) {
+          case 1: // S_INT_STRING
+            if (schemeField.type == org.apache.thrift.protocol.TType.SET) {
+              {
+                org.apache.thrift.protocol.TSet _set34 = iprot.readSetBegin();
+                struct.sIntString = new HashSet<IntString>(2*_set34.size);
+                for (int _i35 = 0; _i35 < _set34.size; ++_i35)
+                {
+                  IntString _elem36; // required
+                  _elem36 = new IntString();
+                  _elem36.read(iprot);
+                  struct.sIntString.add(_elem36);
+                }
+                iprot.readSetEnd();
+              }
+              struct.setSIntStringIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          case 2: // A_STRING
+            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
+              struct.aString = iprot.readString();
+              struct.setAStringIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          default:
+            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      struct.validate();
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot, SetIntString struct) throws org.apache.thrift.TException {
+      struct.validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (struct.sIntString != null) {
+        oprot.writeFieldBegin(S_INT_STRING_FIELD_DESC);
+        {
+          oprot.writeSetBegin(new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.STRUCT, struct.sIntString.size()));
+          for (IntString _iter37 : struct.sIntString)
+          {
+            _iter37.write(oprot);
+          }
+          oprot.writeSetEnd();
+        }
+        oprot.writeFieldEnd();
+      }
+      if (struct.aString != null) {
+        oprot.writeFieldBegin(A_STRING_FIELD_DESC);
+        oprot.writeString(struct.aString);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+  }
+
+  private static class SetIntStringTupleSchemeFactory implements SchemeFactory {
+    public SetIntStringTupleScheme getScheme() {
+      return new SetIntStringTupleScheme();
+    }
+  }
+
+  private static class SetIntStringTupleScheme extends TupleScheme<SetIntString> {
+
+    @Override
+    public void write(org.apache.thrift.protocol.TProtocol prot, SetIntString struct) throws org.apache.thrift.TException {
+      TTupleProtocol oprot = (TTupleProtocol) prot;
+      BitSet optionals = new BitSet();
+      if (struct.isSetSIntString()) {
+        optionals.set(0);
+      }
+      if (struct.isSetAString()) {
+        optionals.set(1);
+      }
+      oprot.writeBitSet(optionals, 2);
+      if (struct.isSetSIntString()) {
+        {
+          oprot.writeI32(struct.sIntString.size());
+          for (IntString _iter38 : struct.sIntString)
+          {
+            _iter38.write(oprot);
+          }
+        }
+      }
+      if (struct.isSetAString()) {
+        oprot.writeString(struct.aString);
+      }
+    }
+
+    @Override
+    public void read(org.apache.thrift.protocol.TProtocol prot, SetIntString struct) throws org.apache.thrift.TException {
+      TTupleProtocol iprot = (TTupleProtocol) prot;
+      BitSet incoming = iprot.readBitSet(2);
+      if (incoming.get(0)) {
+        {
+          org.apache.thrift.protocol.TSet _set39 = new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
+          struct.sIntString = new HashSet<IntString>(2*_set39.size);
+          for (int _i40 = 0; _i40 < _set39.size; ++_i40)
+          {
+            IntString _elem41; // required
+            _elem41 = new IntString();
+            _elem41.read(iprot);
+            struct.sIntString.add(_elem41);
+          }
+        }
+        struct.setSIntStringIsSet(true);
+      }
+      if (incoming.get(1)) {
+        struct.aString = iprot.readString();
+        struct.setAStringIsSet(true);
+      }
+    }
+  }
+
+}
+
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorFactory.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorFactory.java
index eded0919f8..d8f0dfb0d0 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorFactory.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorFactory.java
@@ -26,6 +26,7 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
@@ -111,7 +112,8 @@ private static ObjectInspector getReflectionObjectInspectorNoCache(Type t,
     if (t instanceof ParameterizedType) {
       ParameterizedType pt = (ParameterizedType) t;
       // List?
-      if (List.class.isAssignableFrom((Class<?>) pt.getRawType())) {
+      if (List.class.isAssignableFrom((Class<?>) pt.getRawType()) ||
+          Set.class.isAssignableFrom((Class<?>) pt.getRawType())) {
         return getStandardListObjectInspector(getReflectionObjectInspector(pt
             .getActualTypeArguments()[0], options));
       }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/StandardListObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/StandardListObjectInspector.java
index 6eb8803a1d..54ea5be4cd 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/StandardListObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/StandardListObjectInspector.java
@@ -20,6 +20,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 /**
  * DefaultListObjectInspector works on list data that is stored as a Java List
@@ -53,52 +54,64 @@ public ObjectInspector getListElementObjectInspector() {
   }
 
   // with data
+  @SuppressWarnings({ "rawtypes", "unchecked" })
   public Object getListElement(Object data, int index) {
     if (data == null) {
       return null;
     }
-    // We support both List<Object> and Object[]
+    // We support List<Object>, Set<Object> and Object[]
     // so we have to do differently.
-    boolean isArray = ! (data instanceof List);
-    if (isArray) {
-      Object[] list = (Object[]) data;
-      if (index < 0 || index >= list.length) {
-        return null;
-      }
-      return list[index];
-    } else {
-      List<?> list = (List<?>) data;
-      if (index < 0 || index >= list.size()) {
-        return null;
+    if (! (data instanceof List)) {
+      if (! (data instanceof Set)) {
+        Object[] list = (Object[]) data;
+        if (index < 0 || index >= list.length) {
+          return null;
+        }
+        return list[index];
+      } else {
+        data = new ArrayList((Set<?>) data);
       }
-      return list.get(index);
     }
+    List<?> list = (List<?>) data;
+    if (index < 0 || index >= list.size()) {
+      return null;
+    }
+    return list.get(index);
   }
 
   public int getListLength(Object data) {
     if (data == null) {
       return -1;
     }
-    // We support both List<Object> and Object[]
+    // We support List<Object>, Set<Object> and Object[]
     // so we have to do differently.
-    boolean isArray = ! (data instanceof List);
-    if (isArray) {
-      Object[] list = (Object[]) data;
-      return list.length;
+    if (! (data instanceof List)) {
+      if (! (data instanceof Set)) {
+        Object[] list = (Object[]) data;
+        return list.length;
+      } else {
+        Set<?> set = (Set<?>) data;
+        return set.size();
+      }
     } else {
       List<?> list = (List<?>) data;
       return list.size();
     }
   }
 
+  @SuppressWarnings({ "rawtypes", "unchecked" })
   public List<?> getList(Object data) {
     if (data == null) {
       return null;
     }
-    // We support both List<Object> and Object[]
+    // We support List<Object>, Set<Object> and Object[]
     // so we have to do differently.
     if (! (data instanceof List)) {
-      data = java.util.Arrays.asList((Object[]) data);
+      if (! (data instanceof Set)) {
+        data = java.util.Arrays.asList((Object[]) data);
+      } else {
+        data = new ArrayList((Set<?>) data);
+      }
     }
     List<?> list = (List<?>) data;
     return list;
diff --git a/serde/src/test/org/apache/hadoop/hive/serde2/objectinspector/TestThriftObjectInspectors.java b/serde/src/test/org/apache/hadoop/hive/serde2/objectinspector/TestThriftObjectInspectors.java
index 5f692fbe22..e3b306dc6f 100644
--- a/serde/src/test/org/apache/hadoop/hive/serde2/objectinspector/TestThriftObjectInspectors.java
+++ b/serde/src/test/org/apache/hadoop/hive/serde2/objectinspector/TestThriftObjectInspectors.java
@@ -19,7 +19,9 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import junit.framework.TestCase;
 
@@ -27,6 +29,7 @@
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
 import org.apache.hadoop.hive.serde2.thrift.test.Complex;
 import org.apache.hadoop.hive.serde2.thrift.test.IntString;
+import org.apache.hadoop.hive.serde2.thrift.test.SetIntString;
 
 /**
  * TestThriftObjectInspectors.
@@ -109,4 +112,70 @@ public void testThriftObjectInspectors() throws Throwable {
       throw e;
     }
   }
+
+  @SuppressWarnings("unchecked")
+  public void testThriftSetObjectInspector() throws Throwable {
+
+    try {
+      ObjectInspector oi1 = ObjectInspectorFactory
+          .getReflectionObjectInspector(SetIntString.class,
+          ObjectInspectorFactory.ObjectInspectorOptions.THRIFT);
+      ObjectInspector oi2 = ObjectInspectorFactory
+          .getReflectionObjectInspector(SetIntString.class,
+          ObjectInspectorFactory.ObjectInspectorOptions.THRIFT);
+      assertEquals(oi1, oi2);
+
+      // metadata
+      assertEquals(Category.STRUCT, oi1.getCategory());
+      StructObjectInspector soi = (StructObjectInspector) oi1;
+      List<? extends StructField> fields = soi.getAllStructFieldRefs();
+      assertEquals(2, fields.size());
+      assertEquals(fields.get(0), soi.getStructFieldRef("sIntString"));
+      assertEquals(fields.get(1), soi.getStructFieldRef("aString"));
+
+      // null
+      for (int i = 0; i < fields.size(); i++) {
+        assertNull(soi.getStructFieldData(null, fields.get(i)));
+      }
+
+      // real object
+      IntString s1 = new IntString();
+      s1.setMyint(1);
+      s1.setMyString("test");
+      s1.setUnderscore_int(2);
+
+      Set<IntString> set1 = new HashSet<IntString>();
+      set1.add(s1);
+
+      SetIntString s = new SetIntString();
+      s.setSIntString(set1);
+      s.setAString("setString");
+
+      assertEquals(set1, soi.getStructFieldData(s, fields.get(0)));
+      assertEquals("setString", soi.getStructFieldData(s, fields.get(1)));
+
+      // sub fields
+      assertEquals(
+          ObjectInspectorFactory
+          .getStandardListObjectInspector(ObjectInspectorFactory
+              .getReflectionObjectInspector(IntString.class,
+                  ObjectInspectorFactory.ObjectInspectorOptions.THRIFT)),
+          fields.get(0).getFieldObjectInspector());
+      assertEquals(PrimitiveObjectInspectorFactory.javaStringObjectInspector,
+          fields.get(1).getFieldObjectInspector());
+
+      // compare set fields
+      ListObjectInspector loi = (ListObjectInspector) fields.get(0).getFieldObjectInspector();
+      assertEquals(1, loi.getListLength(set1));
+      List<IntString> list = (List<IntString>) loi.getList(set1);
+      assertEquals(1, list.size());
+      s1 = (IntString) loi.getListElement(list, 0);
+      assertEquals(1, s1.getMyint());
+      assertEquals("test", s1.getMyString());
+      assertEquals(2, s1.getUnderscore_int());
+    } catch (Throwable e) {
+      e.printStackTrace();
+      throw e;
+    }
+  }
 }
