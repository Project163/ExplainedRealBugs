diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveProjectSortTransposeRule.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveProjectSortTransposeRule.java
index fd19d99280..1487ed4f8e 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveProjectSortTransposeRule.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveProjectSortTransposeRule.java
@@ -17,6 +17,7 @@
  */
 package org.apache.hadoop.hive.ql.optimizer.calcite.rules;
 
+import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.plan.RelOptRuleOperand;
@@ -25,7 +26,12 @@
 import org.apache.calcite.rel.RelCollationTraitDef;
 import org.apache.calcite.rel.RelFieldCollation;
 import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rex.RexCall;
+import org.apache.calcite.rex.RexCallBinding;
+import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.sql.SqlKind;
+import org.apache.calcite.sql.validate.SqlMonotonicity;
 import org.apache.calcite.util.mapping.Mappings;
 import org.apache.hadoop.hive.ql.optimizer.calcite.reloperators.HiveProject;
 import org.apache.hadoop.hive.ql.optimizer.calcite.reloperators.HiveSortLimit;
@@ -59,16 +65,28 @@ protected HiveProjectSortTransposeRule(RelOptRuleOperand operand) {
   public void onMatch(RelOptRuleCall call) {
     final HiveProject project = call.rel(0);
     final HiveSortLimit sort = call.rel(1);
+    final RelOptCluster cluster = project.getCluster();
 
     // Determine mapping between project input and output fields. If sort
     // relies on non-trivial expressions, we can't push.
     final Mappings.TargetMapping map =
-        RelOptUtil.permutation(
+        RelOptUtil.permutationIgnoreCast(
             project.getProjects(), project.getInput().getRowType()).inverse();
     for (RelFieldCollation fc : sort.getCollation().getFieldCollations()) {
       if (map.getTarget(fc.getFieldIndex()) < 0) {
         return;
       }
+      final RexNode node = project.getProjects().get(map.getTarget(fc.getFieldIndex()));
+      if (node.isA(SqlKind.CAST)) {
+        // Check whether it is a monotonic preserving cast, otherwise we cannot push
+        final RexCall cast = (RexCall) node;
+        final RexCallBinding binding =
+            RexCallBinding.create(cluster.getTypeFactory(), cast,
+                ImmutableList.of(RexUtil.apply(map, sort.getCollation())));
+        if (cast.getOperator().getMonotonicity(binding) == SqlMonotonicity.NOT_MONOTONIC) {
+          return;
+        }
+      }
     }
 
     // Create new collation
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveSortProjectTransposeRule.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveSortProjectTransposeRule.java
index fe29850979..d1be4bcddb 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveSortProjectTransposeRule.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveSortProjectTransposeRule.java
@@ -17,23 +17,13 @@
  */
 package org.apache.hadoop.hive.ql.optimizer.calcite.rules;
 
-import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
-import org.apache.calcite.plan.RelOptRuleOperand;
-import org.apache.calcite.plan.RelOptUtil;
-import org.apache.calcite.rel.RelCollation;
-import org.apache.calcite.rel.RelCollationTraitDef;
-import org.apache.calcite.rel.RelFieldCollation;
-import org.apache.calcite.rel.RelNode;
-import org.apache.calcite.rex.RexUtil;
-import org.apache.calcite.util.mapping.Mappings;
+import org.apache.calcite.rel.rules.SortProjectTransposeRule;
 import org.apache.hadoop.hive.ql.optimizer.calcite.HiveCalciteUtil;
 import org.apache.hadoop.hive.ql.optimizer.calcite.reloperators.HiveProject;
 import org.apache.hadoop.hive.ql.optimizer.calcite.reloperators.HiveSortLimit;
 
-import com.google.common.collect.ImmutableList;
-
-public class HiveSortProjectTransposeRule extends RelOptRule {
+public class HiveSortProjectTransposeRule extends SortProjectTransposeRule {
 
   public static final HiveSortProjectTransposeRule INSTANCE =
       new HiveSortProjectTransposeRule();
@@ -50,10 +40,6 @@ private HiveSortProjectTransposeRule() {
             operand(HiveProject.class, any())));
   }
 
-  protected HiveSortProjectTransposeRule(RelOptRuleOperand operand) {
-    super(operand);
-  }
-
   //~ Methods ----------------------------------------------------------------
 
   @Override
@@ -68,34 +54,4 @@ public boolean matches(RelOptRuleCall call) {
     return true;
   }
 
-  // implement RelOptRule
-  public void onMatch(RelOptRuleCall call) {
-    final HiveSortLimit sort = call.rel(0);
-    final HiveProject project = call.rel(1);
-
-    // Determine mapping between project input and output fields. If sort
-    // relies on non-trivial expressions, we can't push.
-    final Mappings.TargetMapping map =
-        RelOptUtil.permutation(
-            project.getProjects(), project.getInput().getRowType());
-    for (RelFieldCollation fc : sort.getCollation().getFieldCollations()) {
-      if (map.getTargetOpt(fc.getFieldIndex()) < 0) {
-        return;
-      }
-    }
-
-    // Create new collation
-    final RelCollation newCollation =
-        RelCollationTraitDef.INSTANCE.canonize(
-            RexUtil.apply(map, sort.getCollation()));
-
-    // New operators
-    final HiveSortLimit newSort = sort.copy(sort.getTraitSet().replace(newCollation),
-            project.getInput(), newCollation, sort.offset, sort.fetch);
-    final RelNode newProject = project.copy(sort.getTraitSet(),
-            ImmutableList.<RelNode>of(newSort));
-
-    call.transformTo(newProject);
-  }
-
 }
