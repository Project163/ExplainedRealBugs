diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableLoader.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableLoader.java
index 6ac2a01339..c4bdaa0c6a 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableLoader.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableLoader.java
@@ -35,6 +35,4 @@ public interface HashTableLoader {
 
   void load(MapJoinTableContainer[] mapJoinTables, MapJoinTableContainerSerDe[] mapJoinTableSerdes)
       throws HiveException;
-
-  MapJoinKey getKeyType();
 }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java
index 3daf7a595f..3ea9c96a03 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java
@@ -170,11 +170,25 @@ public void cleanUpInputFileChangedOp() throws HiveException {
 
   protected transient final Output outputForMapJoinKey = new Output();
   protected MapJoinKey computeMapJoinKey(Object row, byte alias) throws HiveException {
-    MapJoinKey refKey = (key == null ? loader.getKeyType() : key);
+    MapJoinKey refKey = getRefKey(key, alias);
     return MapJoinKey.readFromRow(outputForMapJoinKey,
         refKey, row, joinKeys[alias], joinKeysObjectInspectors[alias], key == refKey);
   }
 
+  protected MapJoinKey getRefKey(MapJoinKey prevKey, byte alias) {
+    if (prevKey != null) return prevKey;
+    // We assume that since we are joining on the same key, all tables would have either
+    // optimized or non-optimized key; hence, we can pass any key in any table as reference.
+    // We do it so that MJKB could determine whether it can use optimized keys.
+    for (byte pos = 0; pos < order.length; pos++) {
+      if (pos == alias) continue;
+      MapJoinKey refKey = mapJoinTables[pos].getAnyKey();
+      if (refKey != null) return refKey;
+    }
+    return null; // All join tables have 0 keys, doesn't matter what we generate.
+  }
+
+
   @Override
   public void processOp(Object row, int tag) throws HiveException {
     try {
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/mr/HashTableLoader.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/mr/HashTableLoader.java
index e3d21c3fbb..1ba1518f5a 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/mr/HashTableLoader.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/mr/HashTableLoader.java
@@ -155,9 +155,4 @@ private void loadDirectly(MapJoinTableContainer[] mapJoinTables, String inputFil
 
     Arrays.fill(tables, null);
   }
-
-  @Override
-  public MapJoinKey getKeyType() {
-    return new MapJoinKeyObject(); // always use Object-array keys
-  }
 }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/HashMapWrapper.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/HashMapWrapper.java
index 61545b5b55..9df425b2d5 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/HashMapWrapper.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/HashMapWrapper.java
@@ -102,4 +102,9 @@ private static Map<String, String> createConstructorMetaData(int threshold, floa
     metaData.put(LOAD_NAME, String.valueOf(loadFactor));
     return metaData;
   }
+
+  @Override
+  public MapJoinKey getAnyKey() {
+    return mHash.isEmpty() ? null : mHash.keySet().iterator().next();
+  }
 }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/MapJoinTableContainer.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/MapJoinTableContainer.java
index a8cb1aeb6e..988959fe34 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/MapJoinTableContainer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/persistence/MapJoinTableContainer.java
@@ -35,4 +35,6 @@ public interface MapJoinTableContainer {
 
   public void clear();
 
+  public MapJoinKey getAnyKey();
+
 }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/tez/HashTableLoader.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/tez/HashTableLoader.java
index 84739ee590..79af08d6bd 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/tez/HashTableLoader.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/tez/HashTableLoader.java
@@ -124,12 +124,4 @@ public void load(
       lastKey = new MapJoinKeyObject(); // No rows in tables, the key type doesn't matter.
     }
   }
-
-  @Override
-  public MapJoinKey getKeyType() {
-    if (lastKey == null) {
-      throw new AssertionError("Should be called after loading tables");
-    }
-    return lastKey;
-  }
 }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorMapJoinOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorMapJoinOperator.java
index 6ecbcf7966..eef765625b 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorMapJoinOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorMapJoinOperator.java
@@ -159,7 +159,7 @@ public MapJoinKeyEvaluator init() {
 
       @Override
       public MapJoinKey evaluate(VectorHashKeyWrapper kw) throws HiveException {
-        MapJoinKey refKey = (key == null ? loader.getKeyType() : key);
+        MapJoinKey refKey = getRefKey(key, alias);
         key = MapJoinKey.readFromVector(
             output, refKey, kw, keyOutputWriters, keyWrapperBatch, refKey == key);
         return key;
