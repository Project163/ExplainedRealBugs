diff --git a/CHANGES.txt b/CHANGES.txt
index cb33d5286a..f88402a0aa 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -56,6 +56,9 @@ Trunk - Unreleased
     HIVE-567. jdbc: integrate hive with pentaho report designer
     (Raghotham Murthy via namit)
 
+    HIVE-136. escaping in lazy serde
+    (Zheng Shao via namit)
+
   IMPROVEMENTS
     HIVE-389. Option to build without ivy (jssarma)
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/DDLTask.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/DDLTask.java
index eada67c9f4..48fbc8a8ae 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/DDLTask.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/DDLTask.java
@@ -31,6 +31,7 @@
 import java.util.Map;
 import java.util.SortedSet;
 import java.util.TreeSet;
+import java.util.Map.Entry;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -673,10 +674,10 @@ private int createTable(Hive db, createTableDesc crtTbl) throws HiveException {
     if (crtTbl.getSerName() != null) {
       tbl.setSerializationLib(crtTbl.getSerName());
       if (crtTbl.getMapProp() != null) {
-        Iterator<Map.Entry<String, String>> iter = crtTbl.getMapProp()
+        Iterator<Entry<String, String>> iter = crtTbl.getMapProp()
             .entrySet().iterator();
         while (iter.hasNext()) {
-          Map.Entry<String, String> m = (Map.Entry<String, String>) iter.next();
+          Entry<String, String> m = (Entry<String, String>) iter.next();
           tbl.setSerdeParam(m.getKey(), m.getValue());
         }
       }
@@ -686,11 +687,13 @@ private int createTable(Hive db, createTableDesc crtTbl) throws HiveException {
         tbl.setSerdeParam(Constants.SERIALIZATION_FORMAT, crtTbl
             .getFieldDelim());
       }
+      if (crtTbl.getFieldEscape() != null) {
+        tbl.setSerdeParam(Constants.ESCAPE_CHAR, crtTbl.getFieldEscape());
+      }
 
       if (crtTbl.getCollItemDelim() != null)
-        tbl
-            .setSerdeParam(Constants.COLLECTION_DELIM, crtTbl
-                .getCollItemDelim());
+        tbl.setSerdeParam(Constants.COLLECTION_DELIM, 
+            crtTbl.getCollItemDelim());
       if (crtTbl.getMapKeyDelim() != null)
         tbl.setSerdeParam(Constants.MAPKEY_DELIM, crtTbl.getMapKeyDelim());
       if (crtTbl.getLineDelim() != null)
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/ExprNodeIndexEvaluator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/ExprNodeIndexEvaluator.java
index 9ee7d998b7..448286e9d3 100755
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/ExprNodeIndexEvaluator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/ExprNodeIndexEvaluator.java
@@ -78,7 +78,7 @@ public Object evaluate(Object row) throws HiveException {
     } else if (mainInspector.getCategory() == Category.MAP) {
       MapObjectInspector moi = (MapObjectInspector)mainInspector;
       Object indexObject;
-      if (((PrimitiveObjectInspector)moi.getMapKeyObjectInspector()).isWritable()) {
+      if (((PrimitiveObjectInspector)moi.getMapKeyObjectInspector()).preferWritable()) {
         indexObject = indexInspector.getPrimitiveWritableObject(index);
       } else {
         indexObject = indexInspector.getPrimitiveJavaObject(index);
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java
index 76b73e7580..aeb8d72731 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java
@@ -33,11 +33,11 @@
 import org.apache.hadoop.hive.ql.plan.aggregationDesc;
 import org.apache.hadoop.hive.ql.plan.exprNodeDesc;
 import org.apache.hadoop.hive.ql.plan.groupByDesc;
-import org.apache.hadoop.hive.serde2.objectinspector.InspectableObject;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;
 import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils.ObjectInspectorCopyOption;
 import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector.PrimitiveCategory;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
@@ -68,6 +68,7 @@ public class GroupByOperator extends Operator <groupByDesc> implements Serializa
   
   transient protected ExprNodeEvaluator[][] aggregationParameterFields;
   transient protected ObjectInspector[][] aggregationParameterObjectInspectors;
+  transient protected ObjectInspector[][] aggregationParameterStandardObjectInspectors;
   transient protected Object[][] aggregationParameterObjects;
   // In the future, we may allow both count(DISTINCT a) and sum(DISTINCT a) in the same SQL clause,
   // so aggregationIsDistinct is a boolean array instead of a single number. 
@@ -99,6 +100,11 @@ public class GroupByOperator extends Operator <groupByDesc> implements Serializa
   transient long    numRowsCompareHashAggr;
   transient float   minReductionHashAggr;
 
+  // current Key ObjectInspectors are standard ObjectInspectors
+  transient protected ObjectInspector[] currentKeyObjectInspectors;
+  // new Key ObjectInspectors are objectInspectors from the parent
+  transient StructObjectInspector newKeyObjectInspector;
+  transient StructObjectInspector currentKeyObjectInspector;
   
   /**
    * This is used to store the position and field names for variable length fields.
@@ -149,18 +155,23 @@ public void initializeOp(Configuration hconf, Reporter reporter, ObjectInspector
     }
     newKeys = new ArrayList<Object>(keyFields.length);
     
+    currentKeyObjectInspectors = new ObjectInspector[conf.getKeys().size()];
+    
     // init aggregationParameterFields
     aggregationParameterFields = new ExprNodeEvaluator[conf.getAggregators().size()][];
     aggregationParameterObjectInspectors = new ObjectInspector[conf.getAggregators().size()][];
+    aggregationParameterStandardObjectInspectors = new ObjectInspector[conf.getAggregators().size()][];
     aggregationParameterObjects = new Object[conf.getAggregators().size()][];
     for (int i = 0; i < aggregationParameterFields.length; i++) {
       ArrayList<exprNodeDesc> parameters = conf.getAggregators().get(i).getParameters();
       aggregationParameterFields[i] = new ExprNodeEvaluator[parameters.size()];
       aggregationParameterObjectInspectors[i] = new ObjectInspector[parameters.size()];
+      aggregationParameterStandardObjectInspectors[i] = new ObjectInspector[parameters.size()];
       aggregationParameterObjects[i] = new Object[parameters.size()];
       for (int j = 0; j < parameters.size(); j++) {
         aggregationParameterFields[i][j] = ExprNodeEvaluatorFactory.get(parameters.get(j));
         aggregationParameterObjectInspectors[i][j] = null;
+        aggregationParameterStandardObjectInspectors[i][j] = null;
         aggregationParameterObjects[i][j] = null;
       }
     }
@@ -248,10 +259,22 @@ public void initializeOp(Configuration hconf, Reporter reporter, ObjectInspector
     for (int i = 0; i < keyFields.length; i++) {
       if (keyObjectInspectors[i] == null) {
         keyObjectInspectors[i] = keyFields[i].initialize(inputObjInspector[0]);
+        currentKeyObjectInspectors[i] = ObjectInspectorUtils.getStandardObjectInspector(keyObjectInspectors[i], 
+            ObjectInspectorCopyOption.WRITABLE);
       }
-      objectInspectors.set(i, keyObjectInspectors[i]);
+      objectInspectors.set(i, currentKeyObjectInspectors[i]);
     }
     
+    // Generate key names
+    ArrayList<String> keyNames = new ArrayList<String>(keyFields.length);
+    for (int i = 0; i < keyFields.length; i++) {
+      keyNames.add(fieldNames.get(i));
+    }
+    newKeyObjectInspector = 
+      ObjectInspectorFactory.getStandardStructObjectInspector(keyNames, Arrays.asList(keyObjectInspectors));
+    currentKeyObjectInspector = 
+      ObjectInspectorFactory.getStandardStructObjectInspector(keyNames, Arrays.asList(currentKeyObjectInspectors));
+    
     outputObjectInspector = 
       ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, objectInspectors);
 	
@@ -418,6 +441,8 @@ protected void updateAggregations(UDAFEvaluator[] aggs, Object row, ObjectInspec
         if (oi == null) {
           oi = aggregationParameterFields[ai][pi].initialize(rowInspector);
           aggregationParameterObjectInspectors[ai][pi] = oi;
+          aggregationParameterStandardObjectInspectors[ai][pi]
+              = ObjectInspectorUtils.getStandardObjectInspector(oi, ObjectInspectorCopyOption.WRITABLE);
         }
         PrimitiveObjectInspector poi = (PrimitiveObjectInspector)oi;
         o[pi] = poi.getPrimitiveWritableObject(
@@ -457,7 +482,7 @@ else if (!o[pi].equals(lastInvoke[ai][pi])) {
             }
             for (int pi=0; pi<o.length; pi++) {
               lastInvoke[ai][pi] = ObjectInspectorUtils.copyToStandardObject(o[pi],
-                  aggregationParameterObjectInspectors[ai][pi]);
+                  aggregationParameterStandardObjectInspectors[ai][pi], ObjectInspectorCopyOption.WRITABLE);
             }
           }
         }
@@ -512,16 +537,18 @@ public void process(Object row, ObjectInspector rowInspector, int tag) throws Hi
     }
   }
 
-  private static ArrayList<Object> deepCopyElements(Object[] keys, ObjectInspector[] keyObjectInspectors) {
+  private static ArrayList<Object> deepCopyElements(Object[] keys, ObjectInspector[] keyObjectInspectors,
+      ObjectInspectorCopyOption copyOption) {
     ArrayList<Object> result = new ArrayList<Object>(keys.length);
-    deepCopyElements(keys, keyObjectInspectors, result);
+    deepCopyElements(keys, keyObjectInspectors, result, copyOption);
     return result;
   }
   
-  private static void deepCopyElements(Object[] keys, ObjectInspector[] keyObjectInspectors, ArrayList<Object> result) {
+  private static void deepCopyElements(Object[] keys, ObjectInspector[] keyObjectInspectors, ArrayList<Object> result,
+      ObjectInspectorCopyOption copyOption) {
     result.clear();
     for (int i=0; i<keys.length; i++) {
-      result.add(ObjectInspectorUtils.copyToStandardObject(keys[i], keyObjectInspectors[i]));
+      result.add(ObjectInspectorUtils.copyToStandardObject(keys[i], keyObjectInspectors[i], copyOption));
     }
   }
   
@@ -531,10 +558,11 @@ private void processHashAggr(Object row, ObjectInspector rowInspector, ArrayList
     boolean newEntry = false;
 
     // hash-based aggregations
-    aggs = hashAggregations.get(newKeys);
+    ArrayList<Object> newDefaultKeys = deepCopyElements(keyObjects, keyObjectInspectors, ObjectInspectorCopyOption.WRITABLE);
+    aggs = hashAggregations.get(newDefaultKeys);
     if (aggs == null) {
       aggs = newAggregations();
-      hashAggregations.put(deepCopyElements(keyObjects, keyObjectInspectors), aggs);
+      hashAggregations.put(newDefaultKeys, aggs);
       newEntry = true;
       numRowsHashTbl++;      // new entry in the hash table
     }
@@ -552,7 +580,9 @@ private void processAggr(Object row, ObjectInspector rowInspector, ArrayList<Obj
     // Prepare aggs for updating
     UDAFEvaluator[] aggs = null;
     Object[][] lastInvoke = null;
-    boolean keysAreEqual = newKeys.equals(currentKeys);
+    boolean keysAreEqual = ObjectInspectorUtils.compare(
+        newKeys, newKeyObjectInspector,
+        currentKeys, currentKeyObjectInspector) == 0;
     
     // Forward the current keys if needed for sort-based aggregation
     if (currentKeys != null && !keysAreEqual)
@@ -563,7 +593,7 @@ private void processAggr(Object row, ObjectInspector rowInspector, ArrayList<Obj
       if (currentKeys == null) {
         currentKeys = new ArrayList<Object>(keyFields.length);
       }
-      deepCopyElements(keyObjects, keyObjectInspectors, currentKeys);
+      deepCopyElements(keyObjects, keyObjectInspectors, currentKeys, ObjectInspectorCopyOption.WRITABLE);
       
       // Init aggregations
       for(UDAFEvaluator aggregation: aggregations)
@@ -596,7 +626,7 @@ private boolean shouldBeFlushed(ArrayList<Object> newKeys) {
         if (key != null) {
           if (key instanceof String) {
             totalVariableSize += ((String)key).length();
-          } else {
+          } else if (key instanceof Text) {
             totalVariableSize += ((Text)key).getLength();
           }
         }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/DDLSemanticAnalyzer.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/DDLSemanticAnalyzer.java
index 469563af4b..8f12ff19a2 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/DDLSemanticAnalyzer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/DDLSemanticAnalyzer.java
@@ -155,6 +155,7 @@ private void analyzeCreateTable(ASTNode ast)
     List<Order>       sortCols      = null;
     int               numBuckets    = -1;
     String            fieldDelim    = null;
+    String            fieldEscape   = null;
     String            collItemDelim = null;
     String            mapKeyDelim   = null;
     String            lineDelim     = null;
@@ -216,6 +217,9 @@ private void analyzeCreateTable(ASTNode ast)
             switch (rowChild.getToken().getType()) {
               case HiveParser.TOK_TABLEROWFORMATFIELD:
                 fieldDelim = unescapeSQLString(rowChild.getChild(0).getText());
+                if (rowChild.getChildCount()>=2) {
+                  fieldEscape = unescapeSQLString(rowChild.getChild(1).getText());
+                }
                 break;
               case HiveParser.TOK_TABLEROWFORMATCOLLITEMS:
                 collItemDelim = unescapeSQLString(rowChild.getChild(0).getText());
@@ -269,7 +273,8 @@ private void analyzeCreateTable(ASTNode ast)
       createTableDesc crtTblDesc = 
         new createTableDesc(tableName, isExt, cols, partCols, bucketCols, 
                             sortCols, numBuckets,
-                            fieldDelim, collItemDelim, mapKeyDelim, lineDelim,
+                            fieldDelim, fieldEscape,
+                            collItemDelim, mapKeyDelim, lineDelim,
                             comment, inputFormat, outputFormat, location, serde, 
                             mapProp, ifNotExists);
   
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/Hive.g b/ql/src/java/org/apache/hadoop/hive/ql/parse/Hive.g
index 174efbd7b0..f52af6947d 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/Hive.g
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/Hive.g
@@ -383,8 +383,8 @@ tableRowFormatFieldIdentifier
 @init { msgs.push("table row format's field separator"); }
 @after { msgs.pop(); }
     :
-      KW_FIELDS KW_TERMINATED KW_BY fldIdnt=StringLiteral 
-    -> ^(TOK_TABLEROWFORMATFIELD $fldIdnt)
+      KW_FIELDS KW_TERMINATED KW_BY fldIdnt=StringLiteral (KW_ESCAPED KW_BY fldEscape=StringLiteral)?
+    -> ^(TOK_TABLEROWFORMATFIELD $fldIdnt $fldEscape?)
     ;
 
 tableRowFormatCollItemsIdentifier
@@ -1185,6 +1185,7 @@ KW_FORMAT: 'FORMAT';
 KW_DELIMITED: 'DELIMITED';
 KW_FIELDS: 'FIELDS';
 KW_TERMINATED: 'TERMINATED';
+KW_ESCAPED: 'ESCAPED';
 KW_COLLECTION: 'COLLECTION';
 KW_ITEMS: 'ITEMS';
 KW_KEYS: 'KEYS';
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/plan/createTableDesc.java b/ql/src/java/org/apache/hadoop/hive/ql/plan/createTableDesc.java
index ac19c44da9..df0dd6648a 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/plan/createTableDesc.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/plan/createTableDesc.java
@@ -38,6 +38,7 @@ public class createTableDesc extends ddlDesc implements Serializable
   List<Order>         sortCols;
   int                 numBuckets;
   String              fieldDelim;
+  String              fieldEscape;
   String              collItemDelim;
   String              mapKeyDelim;
   String              lineDelim;
@@ -53,6 +54,7 @@ public createTableDesc(String tableName, boolean isExternal,
                          List<FieldSchema> cols, List<FieldSchema> partCols,
                          List<String> bucketCols, List<Order> sortCols, 
                          int numBuckets, String fieldDelim, 
+                         String fieldEscape,
                          String collItemDelim,
                          String mapKeyDelim, String lineDelim, 
                          String comment, String inputFormat, String outputFormat,
@@ -66,6 +68,7 @@ public createTableDesc(String tableName, boolean isExternal,
     this.cols            = cols;
     this.comment         = comment;
     this.fieldDelim      = fieldDelim;
+    this.fieldEscape     = fieldEscape;
     this.inputFormat     = inputFormat;
     this.outputFormat    = outputFormat;
     this.lineDelim       = lineDelim;
@@ -149,6 +152,15 @@ public void setFieldDelim(String fieldDelim) {
     this.fieldDelim = fieldDelim;
   }
 
+  @explain(displayName="field escape")
+  public String getFieldEscape() {
+    return fieldEscape;
+  }
+
+  public void setFieldEscape(String fieldEscape) {
+    this.fieldEscape = fieldEscape;
+  }
+
   @explain(displayName="collection delimiter")
   public String getCollItemDelim() {
     return collItemDelim;
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/io/TestRCFile.java b/ql/src/test/org/apache/hadoop/hive/ql/io/TestRCFile.java
index ffdcd19d01..0fee05668b 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/io/TestRCFile.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/io/TestRCFile.java
@@ -38,8 +38,10 @@
 import org.apache.hadoop.hive.serde2.io.ByteWritable;
 import org.apache.hadoop.hive.serde2.io.DoubleWritable;
 import org.apache.hadoop.hive.serde2.io.ShortWritable;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;
 import org.apache.hadoop.hive.serde2.objectinspector.StructField;
 import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils.ObjectInspectorCopyOption;
 import org.apache.hadoop.io.IntWritable;
 import org.apache.hadoop.io.LongWritable;
 import org.apache.hadoop.io.Text;
@@ -176,10 +178,12 @@ public void testSimpleReadAndWrite() throws IOException, SerDeException {
       assertEquals(8, fieldRefs.size());
       for (int j = 0; j < fieldRefs.size(); j++) {
         Object fieldData = oi.getStructFieldData(row, fieldRefs.get(j));
+        Object standardWritableData = ObjectInspectorUtils.copyToStandardObject(fieldData, 
+            fieldRefs.get(j).getFieldObjectInspector(), ObjectInspectorCopyOption.WRITABLE);
         if (i == 0)
-          assertEquals("Field " + i, fieldData, expectedRecord_1[j]);
+          assertEquals("Field " + i, standardWritableData, expectedRecord_1[j]);
         else
-          assertEquals("Field " + i, fieldData, expectedRecord_2[j]);
+          assertEquals("Field " + i, standardWritableData, expectedRecord_2[j]);
       }
     }
 
@@ -300,7 +304,9 @@ public void fullyReadTest(FileSystem fs, int count, Path file)
       assertEquals(8, fieldRefs.size());
       for (int i = 0; i < fieldRefs.size(); i++) {
         Object fieldData = oi.getStructFieldData(row, fieldRefs.get(i));
-        assertEquals("Field " + i, fieldData, expectedFieldsData[i]);
+        Object standardWritableData = ObjectInspectorUtils.copyToStandardObject(fieldData, 
+            fieldRefs.get(i).getFieldObjectInspector(), ObjectInspectorCopyOption.WRITABLE);
+        assertEquals("Field " + i, standardWritableData, expectedFieldsData[i]);
       }
       // Serialize
       assertEquals(BytesRefArrayWritable.class, serDe.getSerializedClass());
@@ -336,7 +342,9 @@ private void partialReadTest(FileSystem fs, int count, Path file)
 
       for (int i = 0; i < fieldRefs.size(); i++) {
         Object fieldData = oi.getStructFieldData(row, fieldRefs.get(i));
-        assertEquals("Field " + i, fieldData, expectedPartitalFieldsData[i]);
+        Object standardWritableData = ObjectInspectorUtils.copyToStandardObject(fieldData, 
+            fieldRefs.get(i).getFieldObjectInspector(), ObjectInspectorCopyOption.WRITABLE);
+        assertEquals("Field " + i, standardWritableData, expectedPartitalFieldsData[i]);
       }
 
       assertEquals(BytesRefArrayWritable.class, serDe.getSerializedClass());
diff --git a/ql/src/test/queries/clientpositive/create_escape.q b/ql/src/test/queries/clientpositive/create_escape.q
new file mode 100644
index 0000000000..084a7b3596
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/create_escape.q
@@ -0,0 +1,16 @@
+DROP TABLE table1;
+DROP TABLE table2;
+DROP TABLE table3;
+
+CREATE TABLE table1 (a STRING, b STRING)
+ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' ESCAPED BY '\\'
+STORED AS TEXTFILE;
+
+DESCRIBE table1;
+DESCRIBE EXTENDED table1;
+
+INSERT OVERWRITE TABLE table1 SELECT key, '\\\t\\' FROM src WHERE key = 86;
+
+SELECT * FROM table1;
+
+DROP TABLE table1;
diff --git a/ql/src/test/results/clientpositive/create_escape.q.out b/ql/src/test/results/clientpositive/create_escape.q.out
new file mode 100644
index 0000000000..679713fbed
--- /dev/null
+++ b/ql/src/test/results/clientpositive/create_escape.q.out
@@ -0,0 +1,22 @@
+query: DROP TABLE table1
+query: DROP TABLE table2
+query: DROP TABLE table3
+query: CREATE TABLE table1 (a STRING, b STRING)
+ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' ESCAPED BY '\\'
+STORED AS TEXTFILE
+query: DESCRIBE table1
+a	string	
+b	string	
+query: DESCRIBE EXTENDED table1
+a	string	
+b	string	
+	 	 
+Detailed Table Information	Table(tableName:table1,dbName:default,owner:zshao,createTime:1245330503,lastAccessTime:0,retention:0,sd:StorageDescriptor(cols:[FieldSchema(name:a,type:string,comment:null), FieldSchema(name:b,type:string,comment:null)],location:file:/data/users/zshao/tools/136-trunk-apache-hive/build/ql/test/data/warehouse/table1,inputFormat:org.apache.hadoop.mapred.TextInputFormat,outputFormat:org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat,compressed:false,numBuckets:-1,serdeInfo:SerDeInfo(name:null,serializationLib:org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe,parameters:{serialization.format=9,escape.delim=\,field.delim=	}),bucketCols:[],sortCols:[],parameters:{}),partitionKeys:[],parameters:{})
+query: INSERT OVERWRITE TABLE table1 SELECT key, '\\\t\\' FROM src WHERE key = 86
+Input: default/src
+Output: default/table1
+query: SELECT * FROM table1
+Input: default/table1
+Output: file:/data/users/zshao/tools/136-trunk-apache-hive/build/ql/tmp/822936101/10000
+86	\	\
+query: DROP TABLE table1
diff --git a/serde/if/serde.thrift b/serde/if/serde.thrift
index fc8be7b7e4..51d99047c9 100644
--- a/serde/if/serde.thrift
+++ b/serde/if/serde.thrift
@@ -17,6 +17,7 @@ const string COLLECTION_DELIM = "colelction.delim"
 const string LINE_DELIM = "line.delim"
 const string MAPKEY_DELIM = "mapkey.delim"
 const string QUOTE_CHAR = "quote.delim"
+const string ESCAPE_CHAR = "escape.delim"
 
 typedef string PrimitiveType
 typedef string CollectionType
diff --git a/serde/src/gen-java/org/apache/hadoop/hive/serde/Constants.java b/serde/src/gen-java/org/apache/hadoop/hive/serde/Constants.java
index 7ed0e8c310..37df1f8d29 100644
--- a/serde/src/gen-java/org/apache/hadoop/hive/serde/Constants.java
+++ b/serde/src/gen-java/org/apache/hadoop/hive/serde/Constants.java
@@ -39,6 +39,8 @@ public class Constants {
 
   public static final String QUOTE_CHAR = "quote.delim";
 
+  public static final String ESCAPE_CHAR = "escape.delim";
+
   public static final String VOID_TYPE_NAME = "void";
 
   public static final String BOOLEAN_TYPE_NAME = "boolean";
diff --git a/serde/src/gen-php/serde_constants.php b/serde/src/gen-php/serde_constants.php
index 342869b32e..a2dc1fceb5 100644
--- a/serde/src/gen-php/serde_constants.php
+++ b/serde/src/gen-php/serde_constants.php
@@ -32,6 +32,8 @@ $GLOBALS['serde_CONSTANTS']['MAPKEY_DELIM'] = 'mapkey.delim';
 
 $GLOBALS['serde_CONSTANTS']['QUOTE_CHAR'] = 'quote.delim';
 
+$GLOBALS['serde_CONSTANTS']['ESCAPE_CHAR'] = 'escape.delim';
+
 $GLOBALS['serde_CONSTANTS']['VOID_TYPE_NAME'] = 'void';
 
 $GLOBALS['serde_CONSTANTS']['BOOLEAN_TYPE_NAME'] = 'boolean';
diff --git a/serde/src/gen-py/org_apache_hadoop_hive_serde/constants.py b/serde/src/gen-py/org_apache_hadoop_hive_serde/constants.py
index b133d237b6..c5828855cd 100644
--- a/serde/src/gen-py/org_apache_hadoop_hive_serde/constants.py
+++ b/serde/src/gen-py/org_apache_hadoop_hive_serde/constants.py
@@ -31,6 +31,8 @@
 
 QUOTE_CHAR = 'quote.delim'
 
+ESCAPE_CHAR = 'escape.delim'
+
 VOID_TYPE_NAME = 'void'
 
 BOOLEAN_TYPE_NAME = 'boolean'
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/SerDeUtils.java b/serde/src/java/org/apache/hadoop/hive/serde2/SerDeUtils.java
index 4ec391aa53..c57719d92f 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/SerDeUtils.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/SerDeUtils.java
@@ -25,9 +25,18 @@
 import org.apache.hadoop.hive.serde2.objectinspector.ListObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.MapObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;
 import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.StructField;
 import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.BooleanObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.ByteObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.DoubleObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.FloatObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.IntObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.LongObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.ShortObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.StringObjectInspector;
 import org.apache.hadoop.io.Text;
 
 public class SerDeUtils {
@@ -96,6 +105,9 @@ protected static boolean registerCoreSerDes() {
     return true;
   }
 
+  /**
+   * Escape a String in JSON format.
+   */
   public static String escapeString(String str) {
     int length = str.length();
     StringBuilder escape = new StringBuilder(length + 16);
@@ -181,7 +193,7 @@ public static String getJSONString(Object o, ObjectInspector oi) {
     return sb.toString();
   }
 
-  
+
   static void buildJSONString(StringBuilder sb, Object o, ObjectInspector oi) {
 
     switch(oi.getCategory()) {
@@ -189,17 +201,46 @@ static void buildJSONString(StringBuilder sb, Object o, ObjectInspector oi) {
         PrimitiveObjectInspector poi = (PrimitiveObjectInspector)oi;
         if (o == null) {
           sb.append("null");
-        } else if (oi.getTypeName().equals(Constants.STRING_TYPE_NAME)) {
-          String s = (String)poi.getPrimitiveJavaObject(o);
-          sb.append(QUOTE);
-          sb.append(escapeString(s));
-          sb.append(QUOTE);
-        } else if (oi.getTypeName().equals(Constants.BOOLEAN_TYPE_NAME)) {
-          Boolean b = (Boolean)poi.getPrimitiveJavaObject(o);
-          sb.append(b.booleanValue() ? "True" : "False");
         } else {
-          // it's a number - so doesn't need to be escaped.
-          sb.append(o.toString());
+          switch (poi.getPrimitiveCategory()) {
+          case BOOLEAN: {
+            boolean b = ((BooleanObjectInspector)poi).get(o);
+            sb.append(b ? "true" : "false");
+            break;
+          }
+          case BYTE: {
+            sb.append(((ByteObjectInspector)poi).get(o));
+            break;
+          }
+          case SHORT: {
+            sb.append(((ShortObjectInspector)poi).get(o));
+            break;
+          }
+          case INT: {
+            sb.append(((IntObjectInspector)poi).get(o));
+            break;
+          }
+          case LONG: {
+            sb.append(((LongObjectInspector)poi).get(o));
+            break;
+          }
+          case FLOAT: {
+            sb.append(((FloatObjectInspector)poi).get(o));
+            break;
+          }
+          case DOUBLE: {
+            sb.append(((DoubleObjectInspector)poi).get(o));
+            break;
+          }
+          case STRING: {
+            sb.append('"'); 
+            sb.append(escapeString(((StringObjectInspector)poi).getPrimitiveJavaObject(o)));
+            sb.append('"'); 
+            break;
+          }
+          default:
+            throw new RuntimeException("Unknown primitive type: " + poi.getPrimitiveCategory());
+          }
         }
         break;
       }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/columnar/ColumnarSerDe.java b/serde/src/java/org/apache/hadoop/hive/serde2/columnar/ColumnarSerDe.java
index 552e57375b..e729f17d25 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/columnar/ColumnarSerDe.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/columnar/ColumnarSerDe.java
@@ -84,13 +84,15 @@ public void initialize(Configuration job, Properties tbl)
     serdeParams = LazySimpleSerDe.initSerdeParams(job, tbl, getClass()
         .getName());
 
-    cachedLazyStruct = new ColumnarStruct(serdeParams.getRowTypeInfo());
     // Create the ObjectInspectors for the fields. Note: Currently
     // ColumnarObject uses same ObjectInpector as LazyStruct
     cachedObjectInspector = LazyFactory.createColumnarStructInspector(
         serdeParams.getColumnNames(), serdeParams.getColumnTypes(), serdeParams
-            .getSeparators(), serdeParams.getNullSequence());
+            .getSeparators(), serdeParams.getNullSequence(), serdeParams.isEscaped(),
+            serdeParams.getEscapeChar());
 
+    cachedLazyStruct = new ColumnarStruct(cachedObjectInspector);
+    
     int size = serdeParams.getColumnTypes().size();
     field = new BytesRefWritable[size];
     for (int i = 0; i < size; i++) {
@@ -198,13 +200,17 @@ public Writable serialize(Object obj, ObjectInspector objInspector)
             && (declaredFields == null || declaredFields.get(i)
                 .getFieldObjectInspector().getCategory().equals(
                     Category.PRIMITIVE))) {
-          LazySimpleSerDe.serialize(serializeStream, SerDeUtils.getJSONString(
-              f, foi),
+          LazySimpleSerDe.serialize(serializeStream, 
+              SerDeUtils.getJSONString(f, foi),
               PrimitiveObjectInspectorFactory.javaStringObjectInspector,
-              serdeParams.getSeparators(), 1, serdeParams.getNullSequence());
+              serdeParams.getSeparators(), 1, serdeParams.getNullSequence(),
+              serdeParams.isEscaped(), serdeParams.getEscapeChar(),
+              serdeParams.getNeedsEscape());
         } else {
-          LazySimpleSerDe.serialize(serializeStream, f, foi, serdeParams
-              .getSeparators(), 1, serdeParams.getNullSequence());
+          LazySimpleSerDe.serialize(serializeStream, f, foi, 
+              serdeParams.getSeparators(), 1, serdeParams.getNullSequence(),
+              serdeParams.isEscaped(), serdeParams.getEscapeChar(),
+              serdeParams.getNeedsEscape());
         }
 
         field[i].set(serializeStream.getData(), count, serializeStream
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/columnar/ColumnarStruct.java b/serde/src/java/org/apache/hadoop/hive/serde2/columnar/ColumnarStruct.java
index 5a55f31fad..df7678d5f5 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/columnar/ColumnarStruct.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/columnar/ColumnarStruct.java
@@ -25,8 +25,9 @@
 import org.apache.hadoop.hive.serde2.lazy.LazyFactory;
 import org.apache.hadoop.hive.serde2.lazy.LazyObject;
 import org.apache.hadoop.hive.serde2.lazy.LazyUtils;
-import org.apache.hadoop.hive.serde2.typeinfo.StructTypeInfo;
-import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.StructField;
+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
 import org.apache.hadoop.io.Text;
 
 /**
@@ -38,17 +39,6 @@
  */
 public class ColumnarStruct {
 
-  /**
-   * The TypeInfo for this LazyNonPrimitive.
-   */
-  TypeInfo typeInfo;
-  List<TypeInfo> fieldTypeInfos;
-
-  /**
-   * Whether the data is already parsed or not.
-   */
-  boolean parsed;
-
   /**
    * The fields of the struct.
    */
@@ -58,18 +48,17 @@ public class ColumnarStruct {
    * Construct a ColumnarStruct object with the TypeInfo. It creates the first
    * level object at the first place
    * 
-   * @param typeInfo
-   *          the TypeInfo representing the type of this LazyStruct.
+   * @param oi
+   *          the ObjectInspector representing the type of this LazyStruct.
    */
-  public ColumnarStruct(TypeInfo typeInfo) {
-    this.typeInfo = typeInfo;
-    fieldTypeInfos = ((StructTypeInfo) typeInfo).getAllStructFieldTypeInfos();
-    int num = fieldTypeInfos.size();
+  public ColumnarStruct(ObjectInspector oi) {
+    List<? extends StructField> fieldRefs = ((StructObjectInspector) oi).getAllStructFieldRefs();
+    int num = fieldRefs.size();
     fields = new LazyObject[num];
     cachedByteArrayRef = new ByteArrayRef[num];
     fieldIsNull = new boolean[num];
     for (int i = 0; i < num; i++) {
-      fields[i] = LazyFactory.createLazyObject(fieldTypeInfos.get(i));
+      fields[i] = LazyFactory.createLazyObject(fieldRefs.get(i).getFieldObjectInspector());
       cachedByteArrayRef[i] = new ByteArrayRef();
       fieldIsNull[i] = false;
     }
@@ -147,8 +136,6 @@ public void init(BytesRefArrayWritable cols) {
     }
     for (; fieldIndex < fields.length; fieldIndex++)
       fieldIsNull[fieldIndex] = true;
-
-    parsed = true;
   }
 
   ArrayList<Object> cachedList;
@@ -171,4 +158,4 @@ public ArrayList<Object> getFieldsAsList(Text nullSequence) {
     }
     return cachedList;
   }
-}
\ No newline at end of file
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyArray.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyArray.java
index e5fafd57c8..9274e51a92 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyArray.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyArray.java
@@ -21,17 +21,17 @@
 import java.util.Arrays;
 import java.util.List;
 
-import org.apache.hadoop.hive.serde2.typeinfo.ListTypeInfo;
-import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazyListObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.ListObjectInspector;
 import org.apache.hadoop.io.Text;
 
 /**
  * LazyArray stores an array of Lazy Objects.
  * 
  * LazyArray does not deal with the case of a NULL array. That is handled
- * by LazyArrayObjectInspector.
+ * by the parent LazyObject.
  */
-public class LazyArray extends LazyNonPrimitive {
+public class LazyArray extends LazyNonPrimitive<LazyListObjectInspector> {
 
   /**
    * Whether the data is already parsed or not.
@@ -65,11 +65,12 @@ public class LazyArray extends LazyNonPrimitive {
   LazyObject[] arrayElements;
 
   /**
-   * Construct a LazyArray object with the TypeInfo.
-   * @param typeInfo  the TypeInfo representing the type of this LazyArray.
+   * Construct a LazyArray object with the ObjectInspector.
+   * @param oi  the oi representing the type of this LazyArray as well as meta 
+   *            information like separator etc.
    */
-  protected LazyArray(TypeInfo typeInfo) {
-    super(typeInfo);
+  protected LazyArray(LazyListObjectInspector oi) {
+    super(oi);
   }
 
   /**
@@ -86,7 +87,7 @@ public void init(ByteArrayRef bytes, int start, int length) {
    * Enlarge the size of arrays storing information for the elements inside 
    * the array.
    */
-  protected void enlargeArrays() {
+  private void enlargeArrays() {
     if (startPosition == null) {
       int initialSize = 2;
       startPosition = new int[initialSize]; 
@@ -102,9 +103,13 @@ protected void enlargeArrays() {
   /**
    * Parse the bytes and fill arrayLength and startPosition.
    */
-  private void parse(byte separator, Text nullSequence) {
+  private void parse() {
     parsed = true;
     
+    byte separator = oi.getSeparator();
+    boolean isEscaped = oi.isEscaped();
+    byte escapeChar = oi.getEscapeChar();
+    
     // empty array?
     if (length == 0) {
       arrayLength = 0;
@@ -131,7 +136,14 @@ private void parse(byte separator, Text nullSequence) {
         arrayLength++;
         elementByteBegin = elementByteEnd + 1;
       }
-      elementByteEnd++;
+      if (isEscaped && bytes[elementByteEnd] == escapeChar
+          && elementByteEnd+1 < arrayByteEnd) {
+        // ignore the char after escape_char
+        elementByteEnd += 2;
+      } else {
+        elementByteEnd ++;
+      }
+      
     }
     // Store arrayByteEnd+1 in startPosition[arrayLength]
     // so that we can use the same formula to compute the length of
@@ -148,21 +160,22 @@ private void parse(byte separator, Text nullSequence) {
    * Returns the actual primitive object at the index position
    * inside the array represented by this LazyObject.
    */
-  public Object getListElementObject(int index, byte separator, 
-      Text nullSequence) {
+  public Object getListElementObject(int index) {
     if (!parsed) {
-      parse(separator, nullSequence);
+      parse();
     }
     if (index < 0 || index >= arrayLength) {
       return null;
     }
-    return uncheckedGetElement(index, nullSequence);
+    return uncheckedGetElement(index);
   }
   
   /**
-   * Get the element without checking parsed or out-of-bound index.
+   * Get the element without checking out-of-bound index.
    */
-  private Object uncheckedGetElement(int index, Text nullSequence) {
+  private Object uncheckedGetElement(int index) {
+    Text nullSequence = oi.getNullSequence();
+
     int elementLength = startPosition[index+1] - startPosition[index] - 1;
     if (elementLength == nullSequence.getLength() 
         && 0 == LazyUtils.compare(bytes.getData(), startPosition[index], 
@@ -174,7 +187,7 @@ private Object uncheckedGetElement(int index, Text nullSequence) {
         elementInited[index] = true;
         if (arrayElements[index] == null) {
           arrayElements[index] = LazyFactory.createLazyObject(
-            ((ListTypeInfo)typeInfo).getListElementTypeInfo());
+            ((ListObjectInspector)oi).getListElementObjectInspector());
         }
         arrayElements[index].init(bytes, startPosition[index], 
             elementLength);
@@ -185,9 +198,9 @@ private Object uncheckedGetElement(int index, Text nullSequence) {
   
   /** Returns -1 for null array.
    */
-  public int getListLength(byte separator, Text nullSequence) {
+  public int getListLength() {
     if (!parsed) {
-      parse(separator, nullSequence);
+      parse();
     }
     return arrayLength;
   }
@@ -200,9 +213,9 @@ public int getListLength(byte separator, Text nullSequence) {
   /** Returns the List of actual primitive objects.
    *  Returns null for null array.
    */
-  public List<Object> getList(byte separator, Text nullSequence) {
+  public List<Object> getList() {
     if (!parsed) {
-      parse(separator, nullSequence);
+      parse();
     }
     if (arrayLength == -1) {
       return null;
@@ -213,7 +226,7 @@ public List<Object> getList(byte separator, Text nullSequence) {
       cachedList.clear();
     }
     for (int index=0; index<arrayLength; index++) {
-      cachedList.add(uncheckedGetElement(index, nullSequence));
+      cachedList.add(uncheckedGetElement(index));
     }
     return cachedList;
   }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyBoolean.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyBoolean.java
new file mode 100644
index 0000000000..4bf111816e
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyBoolean.java
@@ -0,0 +1,71 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy;
+
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyBooleanObjectInspector;
+import org.apache.hadoop.io.BooleanWritable;
+
+/**
+ * LazyObject for storing a value of boolean.
+ * 
+ * <p>
+ * Part of the code is adapted from Apache Harmony Project.
+ * 
+ * As with the specification, this implementation relied on code laid out in <a
+ * href="http://www.hackersdelight.org/">Henry S. Warren, Jr.'s Hacker's
+ * Delight, (Addison Wesley, 2002)</a> as well as <a
+ * href="http://aggregate.org/MAGIC/">The Aggregate's Magic Algorithms</a>.
+ * </p>
+ * 
+ */
+public class LazyBoolean extends LazyPrimitive<LazyBooleanObjectInspector, BooleanWritable> {
+
+  public LazyBoolean(LazyBooleanObjectInspector oi) {
+    super(oi);
+    data = new BooleanWritable();
+  }
+
+  public LazyBoolean(LazyBoolean copy) {
+    super(copy);
+    data = new BooleanWritable(copy.data.get());
+  }
+  
+  @Override
+  public void init(ByteArrayRef bytes, int start, int length) {
+    if (length == 4 
+        && Character.toUpperCase(bytes.getData()[start]) == 'T'
+        && Character.toUpperCase(bytes.getData()[start+1]) == 'R'
+        && Character.toUpperCase(bytes.getData()[start+2]) == 'U'
+        && Character.toUpperCase(bytes.getData()[start+3]) == 'E') {
+      data.set(true);
+      isNull = false;
+    } else if (length == 5
+          && Character.toUpperCase(bytes.getData()[start]) == 'F'
+          && Character.toUpperCase(bytes.getData()[start+1]) == 'A'
+          && Character.toUpperCase(bytes.getData()[start+2]) == 'L'
+          && Character.toUpperCase(bytes.getData()[start+3]) == 'S'
+          && Character.toUpperCase(bytes.getData()[start+4]) == 'E') {
+      data.set(false);
+      isNull = false;
+    } else { 
+      isNull = true;
+    }
+  }
+  
+
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyByte.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyByte.java
index f3567990fd..d5c2d9e8c4 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyByte.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyByte.java
@@ -18,6 +18,7 @@
 package org.apache.hadoop.hive.serde2.lazy;
 
 import org.apache.hadoop.hive.serde2.io.ByteWritable;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyByteObjectInspector;
 
 /**
  * LazyObject for storing a value of Byte.
@@ -32,12 +33,18 @@
  * </p>
  * 
  */
-public class LazyByte extends LazyPrimitive<ByteWritable> {
+public class LazyByte extends LazyPrimitive<LazyByteObjectInspector, ByteWritable> {
 
-  public LazyByte() {
+  public LazyByte(LazyByteObjectInspector oi) {
+    super(oi);
     data = new ByteWritable();
   }
 
+  public LazyByte(LazyByte copy) {
+    super(copy);
+    data = new ByteWritable(copy.data.get());
+  }
+  
   @Override
   public void init(ByteArrayRef bytes, int start, int length) {
     try {
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyDouble.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyDouble.java
index 03aeebc46c..8ac433db1e 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyDouble.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyDouble.java
@@ -20,17 +20,24 @@
 import java.nio.charset.CharacterCodingException;
 
 import org.apache.hadoop.hive.serde2.io.DoubleWritable;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyDoubleObjectInspector;
 import org.apache.hadoop.io.Text;
 
 /**
  * LazyObject for storing a value of Double.
  * 
  */
-public class LazyDouble extends LazyPrimitive<DoubleWritable> {
+public class LazyDouble extends LazyPrimitive<LazyDoubleObjectInspector, DoubleWritable> {
 
-  public LazyDouble() {
+  public LazyDouble(LazyDoubleObjectInspector oi) {
+    super(oi);
     data = new DoubleWritable();
   }
+
+  public LazyDouble(LazyDouble copy) {
+    super(copy);
+    data = new DoubleWritable(copy.data.get());
+  }  
   
   @Override
   public void init(ByteArrayRef bytes, int start, int length) {
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyFactory.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyFactory.java
index d06effe25c..4a9428e081 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyFactory.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyFactory.java
@@ -20,11 +20,32 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazyListObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazyMapObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazyObjectInspectorFactory;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazySimpleStructObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyBooleanObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyByteObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyDoubleObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyFloatObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyIntObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyLongObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyPrimitiveObjectInspectorFactory;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyShortObjectInspector;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyStringObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;
+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector.PrimitiveCategory;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableByteObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableDoubleObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableFloatObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableIntObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableLongObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableShortObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableStringObjectInspector;
 import org.apache.hadoop.hive.serde2.typeinfo.ListTypeInfo;
 import org.apache.hadoop.hive.serde2.typeinfo.MapTypeInfo;
 import org.apache.hadoop.hive.serde2.typeinfo.StructTypeInfo;
@@ -37,29 +58,32 @@ public class LazyFactory {
   /**
    * Create a lazy primitive class given the type name. 
    */
-  public static LazyPrimitive<?> createLazyPrimitiveClass(String typeName) {
-    PrimitiveCategory p = PrimitiveObjectInspectorUtils.getTypeEntryFromTypeName(typeName).primitiveCategory;
+  public static LazyPrimitive<?,?> createLazyPrimitiveClass(PrimitiveObjectInspector oi) {
+    PrimitiveCategory p = oi.getPrimitiveCategory();
     switch(p) {
+      case BOOLEAN: {
+        return new LazyBoolean((LazyBooleanObjectInspector)oi);
+      }
       case BYTE: {
-        return new LazyByte();
+        return new LazyByte((LazyByteObjectInspector)oi);
       }
       case SHORT: {
-        return new LazyShort();
+        return new LazyShort((LazyShortObjectInspector)oi);
       }
       case INT: {
-        return new LazyInteger();
+        return new LazyInteger((LazyIntObjectInspector)oi);
       }
       case LONG: {
-        return new LazyLong();
+        return new LazyLong((LazyLongObjectInspector)oi);
       }
       case FLOAT: {
-        return new LazyFloat();
+        return new LazyFloat((LazyFloatObjectInspector)oi);
       }
       case DOUBLE: {
-        return new LazyDouble();
+        return new LazyDouble((LazyDoubleObjectInspector)oi);
       }
       case STRING: {
-        return new LazyString();
+        return new LazyString((LazyStringObjectInspector)oi);
       }
       default: {
         throw new RuntimeException("Internal error: no LazyObject for " + p);
@@ -70,17 +94,17 @@ public static LazyPrimitive<?> createLazyPrimitiveClass(String typeName) {
   /**
    * Create a hierarchical LazyObject based on the given typeInfo.
    */
-  public static LazyObject createLazyObject(TypeInfo typeInfo) {
-    ObjectInspector.Category c = typeInfo.getCategory();
+  public static LazyObject createLazyObject(ObjectInspector oi) {
+    ObjectInspector.Category c = oi.getCategory();
     switch(c) {
     case PRIMITIVE:
-      return createLazyPrimitiveClass(typeInfo.getTypeName());
+      return createLazyPrimitiveClass((PrimitiveObjectInspector)oi);
     case MAP:
-      return new LazyMap(typeInfo);      
+      return new LazyMap((LazyMapObjectInspector)oi);      
     case LIST: 
-      return new LazyArray(typeInfo);      
+      return new LazyArray((LazyListObjectInspector)oi);      
     case STRUCT:
-      return new LazyStruct(typeInfo);      
+      return new LazyStruct((LazySimpleStructObjectInspector)oi);      
     }
 
     throw new RuntimeException("Hive LazySerDe Internal error.");
@@ -99,24 +123,27 @@ public static LazyObject createLazyObject(TypeInfo typeInfo) {
    * @return  The ObjectInspector
    */
   public static ObjectInspector createLazyObjectInspector(TypeInfo typeInfo, byte[] separator, 
-      int separatorIndex, Text nullSequence) {
+      int separatorIndex, Text nullSequence, boolean escaped, byte escapeChar) {
     ObjectInspector.Category c = typeInfo.getCategory();
     switch(c) {
     case PRIMITIVE:
-      return PrimitiveObjectInspectorFactory.getPrimitiveWritableObjectInspector(
-          ((PrimitiveTypeInfo)typeInfo).getPrimitiveCategory());
+      return LazyPrimitiveObjectInspectorFactory.getLazyObjectInspector(
+          ((PrimitiveTypeInfo)typeInfo).getPrimitiveCategory(), escaped, escapeChar);
     case MAP:
-      return ObjectInspectorFactory.getLazySimpleMapObjectInspector(
-          createLazyObjectInspector(((MapTypeInfo)typeInfo).getMapKeyTypeInfo(), separator, separatorIndex+2, nullSequence), 
-          createLazyObjectInspector(((MapTypeInfo)typeInfo).getMapValueTypeInfo(), separator, separatorIndex+2, nullSequence), 
+      return LazyObjectInspectorFactory.getLazySimpleMapObjectInspector(
+          createLazyObjectInspector(((MapTypeInfo)typeInfo).getMapKeyTypeInfo(), 
+              separator, separatorIndex+2, nullSequence, escaped, escapeChar), 
+          createLazyObjectInspector(((MapTypeInfo)typeInfo).getMapValueTypeInfo(), 
+              separator, separatorIndex+2, nullSequence, escaped, escapeChar), 
           separator[separatorIndex], 
           separator[separatorIndex+1], 
-          nullSequence);
+          nullSequence, escaped, escapeChar);
     case LIST: 
-      return ObjectInspectorFactory.getLazySimpleListObjectInspector(
-          createLazyObjectInspector(((ListTypeInfo)typeInfo).getListElementTypeInfo(), separator, separatorIndex+1, nullSequence),
+      return LazyObjectInspectorFactory.getLazySimpleListObjectInspector(
+          createLazyObjectInspector(((ListTypeInfo)typeInfo).getListElementTypeInfo(), 
+              separator, separatorIndex+1, nullSequence, escaped, escapeChar),
           separator[separatorIndex], 
-          nullSequence);
+          nullSequence, escaped, escapeChar);
     case STRUCT:
       StructTypeInfo structTypeInfo = (StructTypeInfo)typeInfo;
       List<String> fieldNames = structTypeInfo.getAllStructFieldNames();
@@ -124,14 +151,15 @@ public static ObjectInspector createLazyObjectInspector(TypeInfo typeInfo, byte[
       List<ObjectInspector> fieldObjectInspectors = new ArrayList<ObjectInspector>(fieldTypeInfos.size());
       for(int i=0; i<fieldTypeInfos.size(); i++) {
         fieldObjectInspectors.add(
-            createLazyObjectInspector(fieldTypeInfos.get(i), separator, separatorIndex+1, nullSequence));
+            createLazyObjectInspector(fieldTypeInfos.get(i), separator, 
+                separatorIndex+1, nullSequence, escaped, escapeChar));
       }
-      return ObjectInspectorFactory.getLazySimpleStructObjectInspector(
+      return LazyObjectInspectorFactory.getLazySimpleStructObjectInspector(
           fieldNames, 
           fieldObjectInspectors, 
           separator[separatorIndex], 
           nullSequence,
-          false);  
+          false, escaped, escapeChar);  
     }
 
     throw new RuntimeException("Hive LazySerDe Internal error.");
@@ -143,36 +171,36 @@ public static ObjectInspector createLazyObjectInspector(TypeInfo typeInfo, byte[
    * 
    * @param lastColumnTakesRest whether the last column of the struct should take
    *                            the rest of the row if there are extra fields. 
-   * @see LazyFactory#createLazyObjectInspector(TypeInfo, byte[], int, Text)
+   * @see LazyFactory#createLazyObjectInspector(TypeInfo, byte[], int, Text, boolean, byte)
    */  
   public static ObjectInspector createLazyStructInspector(List<String> columnNames, 
       List<TypeInfo> typeInfos, byte[] separators, 
-      Text nullSequence, boolean lastColumnTakesRest) {
+      Text nullSequence, boolean lastColumnTakesRest, boolean escaped, byte escapeChar) {
     ArrayList<ObjectInspector> columnObjectInspectors =
         new ArrayList<ObjectInspector>(typeInfos.size());  
     for (int i=0; i<typeInfos.size(); i++) {
       columnObjectInspectors.add(
-          LazyFactory.createLazyObjectInspector(typeInfos.get(i), separators, 1, nullSequence));
+          LazyFactory.createLazyObjectInspector(typeInfos.get(i), separators, 1, nullSequence, escaped, escapeChar));
     }
     return 
-        ObjectInspectorFactory.getLazySimpleStructObjectInspector(columnNames,
-            columnObjectInspectors, separators[0], nullSequence, lastColumnTakesRest);
+        LazyObjectInspectorFactory.getLazySimpleStructObjectInspector(columnNames,
+            columnObjectInspectors, separators[0], nullSequence, lastColumnTakesRest, escaped, escapeChar);
   }
   
   /**
    * Create a hierarchical ObjectInspector for ColumnarStruct with the given
    * columnNames and columnTypeInfos.
    * 
-   * @see LazyFactory#createLazyObjectInspector(TypeInfo, byte[], int, Text)
+   * @see LazyFactory#createLazyObjectInspector(TypeInfo, byte[], int, Text, boolean, byte)
    */
   public static ObjectInspector createColumnarStructInspector(
       List<String> columnNames, List<TypeInfo> columnTypes, byte[] separators,
-      Text nullSequence) {
+      Text nullSequence, boolean escaped, byte escapeChar) {
     ArrayList<ObjectInspector> columnObjectInspectors = new ArrayList<ObjectInspector>(
         columnTypes.size());
     for (int i = 0; i < columnTypes.size(); i++) {
       columnObjectInspectors.add(LazyFactory.createLazyObjectInspector(
-          columnTypes.get(i), separators, 1, nullSequence));
+          columnTypes.get(i), separators, 1, nullSequence, escaped, escapeChar));
     }
     return ObjectInspectorFactory.getColumnarStructObjectInspector(columnNames,
         columnObjectInspectors, nullSequence);
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyFloat.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyFloat.java
index 27fe48e21e..ebce98a135 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyFloat.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyFloat.java
@@ -19,6 +19,7 @@
 
 import java.nio.charset.CharacterCodingException;
 
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyFloatObjectInspector;
 import org.apache.hadoop.io.FloatWritable;
 import org.apache.hadoop.io.Text;
 
@@ -26,12 +27,17 @@
  * LazyObject for storing a value of Double.
  * 
  */
-public class LazyFloat extends LazyPrimitive<FloatWritable> {
+public class LazyFloat extends LazyPrimitive<LazyFloatObjectInspector, FloatWritable> {
 
-  public LazyFloat() {
+  public LazyFloat(LazyFloatObjectInspector oi) {
+    super(oi);
     data = new FloatWritable();
   }
   
+  public LazyFloat(LazyFloat copy) {
+    super(copy);
+    data = new FloatWritable(copy.data.get());
+  }  
   
   @Override
   public void init(ByteArrayRef bytes, int start, int length) {
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyInteger.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyInteger.java
index 8537eb8c60..489424ed7a 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyInteger.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyInteger.java
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.io.OutputStream;
 
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyIntObjectInspector;
 import org.apache.hadoop.io.IntWritable;
 
 /**
@@ -35,12 +36,19 @@
  * </p>
  * 
  */
-public class LazyInteger extends LazyPrimitive<IntWritable> {
+public class LazyInteger extends LazyPrimitive<LazyIntObjectInspector, IntWritable> {
 
-  public LazyInteger() {
+  public LazyInteger(LazyIntObjectInspector oi) {
+    super(oi);
     data = new IntWritable();
   }
 
+  public LazyInteger(LazyInteger copy) {
+    super(copy);
+    data = new IntWritable(copy.data.get());
+  }  
+  
+  
   @Override
   public void init(ByteArrayRef bytes, int start, int length) {
     try {
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyLong.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyLong.java
index 7f6fe5bc8f..d6afbd0dd9 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyLong.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyLong.java
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.io.OutputStream;
 
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyLongObjectInspector;
 import org.apache.hadoop.io.LongWritable;
 
 /**
@@ -35,13 +36,19 @@
  * </p>
  * 
  */
-public class LazyLong extends LazyPrimitive<LongWritable> {
+public class LazyLong extends LazyPrimitive<LazyLongObjectInspector, LongWritable> {
 
 
-  public LazyLong() {
+  public LazyLong(LazyLongObjectInspector oi) {
+    super(oi);
     data = new LongWritable();
   }
 
+  public LazyLong(LazyLong copy) {
+    super(copy);
+    data = new LongWritable(copy.data.get());
+  }
+   
   @Override
   public void init(ByteArrayRef bytes, int start, int length) {
     try {
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyMap.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyMap.java
index 6d2c9a5bf5..4bf9631c05 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyMap.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyMap.java
@@ -19,10 +19,12 @@
 
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 
-import org.apache.hadoop.hive.serde2.typeinfo.MapTypeInfo;
-import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazyMapObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.MapObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;
 import org.apache.hadoop.io.Text;
 
 /**
@@ -30,9 +32,9 @@
  * Note that the keys of the map cannot contain null.
  * 
  * LazyMap does not deal with the case of a NULL map. That is handled
- * by LazyMapObjectInspector.
+ * by the parent LazyObject.
  */
-public class LazyMap extends LazyNonPrimitive {
+public class LazyMap extends LazyNonPrimitive<LazyMapObjectInspector> {
   
   /**
    * Whether the data is already parsed or not.
@@ -63,7 +65,7 @@ public class LazyMap extends LazyNonPrimitive {
   /**
    * The keys are stored in an array of LazyPrimitives.
    */
-  LazyPrimitive<?>[] keyObjects;
+  LazyPrimitive<?,?>[] keyObjects;
   /**
    * Whether init() is called on keyObjects[i]. 
    */
@@ -80,11 +82,10 @@ public class LazyMap extends LazyNonPrimitive {
   boolean[] valueInited;
   
   /**
-   * Construct a LazyMap object with the TypeInfo.
-   * @param typeInfo  the TypeInfo representing the type of this LazyMap.
+   * Construct a LazyMap object with the ObjectInspector.
    */
-  protected LazyMap(TypeInfo typeInfo) {
-    super(typeInfo);
+  protected LazyMap(LazyMapObjectInspector oi) {
+    super(oi);
   }
 
   /**
@@ -106,7 +107,7 @@ protected void enlargeArrays() {
       int initialSize = 2;
       keyStart = new int[initialSize];
       keyEnd = new int[initialSize];
-      keyObjects = new LazyPrimitive<?>[initialSize];
+      keyObjects = new LazyPrimitive<?,?>[initialSize];
       valueObjects = new LazyObject[initialSize];
       keyInited = new boolean[initialSize];
       valueInited = new boolean[initialSize];
@@ -122,14 +123,15 @@ protected void enlargeArrays() {
 
   /**
    * Parse the byte[] and fill keyStart, keyEnd.
-   * @param itemSeparator     The separator between different entries.
-   * @param keyValueSeparator The separator between key and value.
-   * @param nullSequence      The byte sequence representing NULL.
    */
-  private void parse(byte itemSeparator, byte keyValueSeparator, 
-      Text nullSequence) {
+  private void parse() {
     parsed = true;
     
+    byte itemSeparator = oi.getItemSeparator();
+    byte keyValueSeparator = oi.getKeyValueSeparator(); 
+    boolean isEscaped = oi.isEscaped();
+    byte escapeChar = oi.getEscapeChar();
+    
     // empty array?
     if (length == 0) {
       mapSize = 0;
@@ -167,7 +169,13 @@ private void parse(byte itemSeparator, byte keyValueSeparator,
           && bytes[elementByteEnd] == keyValueSeparator) {
         keyValueSeparatorPosition = elementByteEnd;
       }
-      elementByteEnd++;
+      if (isEscaped && bytes[elementByteEnd] == escapeChar
+          && elementByteEnd+1 < arrayByteEnd) {
+        // ignore the char after escape_char
+        elementByteEnd += 2;
+      } else {
+        elementByteEnd ++;
+      }
     }
     
     // This makes sure we can use the same formula to compute the
@@ -191,28 +199,23 @@ private void parse(byte itemSeparator, byte keyValueSeparator,
    * most cases, user only wants to get one or two values out of the map, and 
    * the cost of building up a HashMap is substantially higher.
    * 
-   * @param itemSeparator     The separator between different entries.
-   * @param keyValueSeparator The separator between key and value.
-   * @param nullSequence      The byte sequence representing NULL.
    * @param key               The key object that we are looking for.
    * @return The corresponding value object, or NULL if not found
    */
-  public Object getMapValueElement(byte itemSeparator, byte keyValueSeparator, 
-      Text nullSequence, Object key) {
+  public Object getMapValueElement(Object key) {
     if (!parsed) {
-      parse(itemSeparator, keyValueSeparator, nullSequence);
+      parse();
     }
-    
     // search for the key
     for (int i=0; i<mapSize; i++) {
-      LazyPrimitive<?> lazyKeyI = uncheckedGetKey(i, nullSequence);
+      LazyPrimitive<?,?> lazyKeyI = uncheckedGetKey(i);
       if (lazyKeyI == null) continue;
-      // getObject() will convert LazyPrimitive to actual primitive objects.
-      Object keyI = lazyKeyI.getObject();
+      // getWritableObject() will convert LazyPrimitive to actual primitive writable objects.
+      Object keyI = lazyKeyI.getWritableObject();
       if (keyI == null) continue;
       if (keyI.equals(key)) {
         // Got a match, return the value
-        LazyObject v = uncheckedGetValue(i, nullSequence);
+        LazyObject v = uncheckedGetValue(i);
         return v == null ? v : v.getObject();
       }
     }
@@ -225,7 +228,8 @@ public Object getMapValueElement(byte itemSeparator, byte keyValueSeparator,
    * @param index  The index into the array starting from 0
    * @param nullSequence  The byte sequence representing the NULL value
    */
-  private LazyObject uncheckedGetValue(int index, Text nullSequence) {
+  private LazyObject uncheckedGetValue(int index) {
+    Text nullSequence = oi.getNullSequence();
     int valueIBegin = keyEnd[index] + 1;
     int valueILength = keyStart[index+1] - 1 - valueIBegin;
     if (valueILength < 0 || 
@@ -238,7 +242,7 @@ private LazyObject uncheckedGetValue(int index, Text nullSequence) {
       valueInited[index] = true;
       if (valueObjects[index] == null) {
         valueObjects[index] = LazyFactory.createLazyObject(
-            ((MapTypeInfo)typeInfo).getMapValueTypeInfo());
+            ((MapObjectInspector)oi).getMapValueObjectInspector());
       }
       valueObjects[index].init(bytes, valueIBegin, valueILength);
     }
@@ -250,7 +254,8 @@ private LazyObject uncheckedGetValue(int index, Text nullSequence) {
    * @param index  The index into the array starting from 0
    * @param nullSequence  The byte sequence representing the NULL value
    */
-  private LazyPrimitive<?> uncheckedGetKey(int index, Text nullSequence) {
+  private LazyPrimitive<?,?> uncheckedGetKey(int index) {
+    Text nullSequence = oi.getNullSequence(); 
     int keyIBegin = keyStart[index];
     int keyILength = keyEnd[index] - keyStart[index];
     if (keyILength < 0 || 
@@ -264,7 +269,7 @@ private LazyPrimitive<?> uncheckedGetKey(int index, Text nullSequence) {
       if (keyObjects[index] == null) {
         // Keys are always primitive
         keyObjects[index] = LazyFactory.createLazyPrimitiveClass(
-            ((MapTypeInfo)typeInfo).getMapKeyTypeInfo().getTypeName());
+            (PrimitiveObjectInspector)((MapObjectInspector)oi).getMapKeyObjectInspector());
       }
       keyObjects[index].init(bytes, keyIBegin, keyILength);
     }
@@ -276,34 +281,32 @@ private LazyPrimitive<?> uncheckedGetKey(int index, Text nullSequence) {
    * But each LazyMap has a separate cachedMap so we won't overwrite the
    * data by accident.
    */
-  HashMap<Object, Object> cachedMap;
+  LinkedHashMap<Object, Object> cachedMap;
   
   /**
    * Return the map object representing this LazyMap.
-   * Note that the keyObjects will be Java primitive objects.
-   * @param itemSeparator     The separator between different entries.
-   * @param keyValueSeparator The separator between key and value.
-   * @param nullSequence      The byte sequence representing NULL.
+   * Note that the keyObjects will be Writable primitive objects.
    * @return the map object
    */
-  public Map<Object, Object> getMap(byte itemSeparator, byte keyValueSeparator,
-      Text nullSequence) {
+  public Map<Object, Object> getMap() {
     if (!parsed) {
-      parse(itemSeparator, keyValueSeparator, nullSequence);
+      parse();
     }
     if (cachedMap == null) {
-      cachedMap = new HashMap<Object, Object>();
+      // Use LinkedHashMap to provide deterministic order
+      cachedMap = new LinkedHashMap<Object, Object>();
+    } else {
+      cachedMap.clear();
     }
-    cachedMap.clear();
     
     // go through each element of the map
     for (int i = 0; i < mapSize; i++) {
-      LazyPrimitive<?> lazyKey = uncheckedGetKey(i, nullSequence);
+      LazyPrimitive<?,?> lazyKey = uncheckedGetKey(i);
       if (lazyKey == null) continue;
       Object key = lazyKey.getObject();
       // do not overwrite if there are duplicate keys
       if (key != null && !cachedMap.containsKey(key)) {
-        LazyObject lazyValue = uncheckedGetValue(i, nullSequence);
+        LazyObject lazyValue = uncheckedGetValue(i);
         Object value = (lazyValue == null ? null : lazyValue.getObject());
         cachedMap.put(key, value);
       }
@@ -313,15 +316,11 @@ public Map<Object, Object> getMap(byte itemSeparator, byte keyValueSeparator,
 
   /**
    * Get the size of the map represented by this LazyMap.
-   * @param itemSeparator     The separator between different entries.
-   * @param keyValueSeparator The separator between key and value.
-   * @param nullSequence      The byte sequence representing NULL.
    * @return                  The size of the map, -1 for NULL map.
    */
-  public int getMapSize(byte itemSeparator, byte keyValueSeparator,
-      Text nullSequence) {
+  public int getMapSize() {
     if (!parsed) {
-      parse(itemSeparator, keyValueSeparator, nullSequence);
+      parse();
     }
     return mapSize;
   }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyNonPrimitive.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyNonPrimitive.java
index fd352e9079..2f976914c6 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyNonPrimitive.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyNonPrimitive.java
@@ -17,25 +17,28 @@
  */
 package org.apache.hadoop.hive.serde2.lazy;
 
-import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
-
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
 
 /**
  * LazyPrimitive stores a primitive Object in a LazyObject.
  */
-public abstract class LazyNonPrimitive implements LazyObject {
+public abstract class LazyNonPrimitive<OI extends ObjectInspector> extends LazyObject<OI> {
 
   protected ByteArrayRef bytes;
   protected int start;
   protected int length;
-  
+
   /**
-   * The TypeInfo for this LazyNonPrimitive. 
+   * Create a LazyNonPrimitive object with the specified ObjectInspector.
+   * @param oi  The ObjectInspector would have to have a hierarchy of 
+   *            LazyObjectInspectors with the leaf nodes being 
+   *            WritableObjectInspectors.  It's used both for accessing the
+   *            type hierarchy of the complex object, as well as getting
+   *            meta information (separator, nullSequence, etc) when parsing
+   *            the lazy object.
    */
-  TypeInfo typeInfo;
-  
-  protected LazyNonPrimitive(TypeInfo typeInfo) {
-    this.typeInfo = typeInfo;
+  protected LazyNonPrimitive(OI oi) {
+    super(oi);
     bytes = null;
     start = 0;
     length = 0;
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyObject.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyObject.java
index 092c215d8b..1253c62889 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyObject.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyObject.java
@@ -17,14 +17,27 @@
  */
 package org.apache.hadoop.hive.serde2.lazy;
 
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+
 /**
  * LazyObject stores an object in a range of bytes in a byte[].
  * 
  * A LazyObject can represent any primitive object or hierarchical object
  * like array, map or struct.
  */
-public interface LazyObject {
+public abstract class LazyObject<OI extends ObjectInspector> {
 
+  OI oi;
+  
+  /**
+   * Create a LazyObject.
+   * @param oi  Derived classes can access meta information about this Lazy
+   *            Object (e.g, separator, nullSequence, escaper) from it.
+   */
+  protected LazyObject(OI oi) {
+    this.oi = oi;
+  }
+  
   /**
    * Set the data for this LazyObject.
    * We take ByteArrayRef instead of byte[] so that we will be able to drop
@@ -35,12 +48,12 @@ public interface LazyObject {
    * @param length The length of the data, starting from "start"
    * @see ByteArrayRef
    */
-  void init(ByteArrayRef bytes, int start, int length);
+  public abstract void init(ByteArrayRef bytes, int start, int length);
 
   /**
    * If the LazyObject is a primitive Object, then deserialize it and return
    * the actual primitive Object.
    * Otherwise (array, map, struct), return this. 
    */
-  public Object getObject();
+  public abstract Object getObject();
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyPrimitive.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyPrimitive.java
index aa26c7b341..25f7def58e 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyPrimitive.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyPrimitive.java
@@ -17,20 +17,40 @@
  */
 package org.apache.hadoop.hive.serde2.lazy;
 
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.io.Writable;
 
 /**
  * LazyPrimitive stores a primitive Object in a LazyObject.
  */
-public abstract class LazyPrimitive<T> implements LazyObject {
+public abstract class LazyPrimitive<OI extends ObjectInspector, 
+    T extends Writable> extends LazyObject<OI> {
+
+  LazyPrimitive(OI oi) {
+    super(oi);
+  }
+
+  LazyPrimitive(LazyPrimitive<OI, T> copy) {
+    super(copy.oi);
+    isNull = copy.isNull;
+  }
 
   T data;
   boolean isNull = false;
 
   /**
-   * Returns the actual primitive object represented by this LazyObject.
+   * Returns the primitive object represented by this LazyObject.
+   * This is useful because it can make sure we have "null" for null objects.
    */
-  public T getObject() {
-    return isNull ? null : data;
+  public Object getObject() {
+    return isNull ? null : this;
   }
 
+  public T getWritableObject() {
+    return isNull ? null : data;
+  }
+  
+  public String toString() {
+    return isNull ? null : data.toString();
+  }
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyShort.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyShort.java
index 0cd0cf6adf..39fc8e5eba 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyShort.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyShort.java
@@ -18,6 +18,7 @@
 package org.apache.hadoop.hive.serde2.lazy;
 
 import org.apache.hadoop.hive.serde2.io.ShortWritable;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyShortObjectInspector;
 
 /**
  * LazyObject for storing a value of Short.
@@ -32,12 +33,18 @@
  * </p>
  * 
  */
-public class LazyShort extends LazyPrimitive<ShortWritable> {
+public class LazyShort extends LazyPrimitive<LazyShortObjectInspector, ShortWritable> {
 
-  public LazyShort() {
+  public LazyShort(LazyShortObjectInspector oi) {
+    super(oi);
     data = new ShortWritable();
   }
   
+  public LazyShort(LazyShort copy) {
+    super(copy);
+    data = new ShortWritable(copy.data.get());
+  }
+  
   @Override
   public void init(ByteArrayRef bytes, int start, int length) {
     try {
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazySimpleSerDe.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazySimpleSerDe.java
index c92038b212..15be0a1f17 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazySimpleSerDe.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazySimpleSerDe.java
@@ -107,7 +107,11 @@ public static class SerDeParameters {
     boolean lastColumnTakesRest;
     List<String> columnNames;
     List<TypeInfo> columnTypes;
-
+    
+    boolean escaped;
+    byte escapeChar;
+    boolean[] needsEscape;
+    
     public List<TypeInfo> getColumnTypes() {
       return columnTypes;
     }
@@ -135,6 +139,16 @@ public TypeInfo getRowTypeInfo() {
     public boolean isLastColumnTakesRest() {
       return lastColumnTakesRest;
     }
+    
+    public boolean isEscaped() {
+      return escaped;
+    }
+    public byte getEscapeChar() {
+      return escapeChar;
+    }
+    public boolean[] getNeedsEscape() {
+      return needsEscape;
+    }
   }
 
   SerDeParameters serdeParams = null;
@@ -152,15 +166,18 @@ public void initialize(Configuration job, Properties tbl)
 
     serdeParams = LazySimpleSerDe.initSerdeParams(job, tbl, getClass()
         .getName());
-    cachedLazyStruct = (LazyStruct) LazyFactory
-        .createLazyObject(serdeParams.rowTypeInfo);
 
     // Create the ObjectInspectors for the fields
     cachedObjectInspector = LazyFactory.createLazyStructInspector(
-        serdeParams.columnNames, serdeParams.columnTypes,
-        serdeParams.separators, serdeParams.nullSequence,
-        serdeParams.lastColumnTakesRest);
+        serdeParams.getColumnNames(), serdeParams.getColumnTypes(),
+        serdeParams.getSeparators(), serdeParams.getNullSequence(),
+        serdeParams.isLastColumnTakesRest(),
+        serdeParams.isEscaped(),
+        serdeParams.getEscapeChar());
 
+    cachedLazyStruct = (LazyStruct) LazyFactory
+      .createLazyObject(cachedObjectInspector);
+    
     LOG.debug("LazySimpleSerDe initialized with: columnNames="
         + serdeParams.columnNames + " columnTypes=" + serdeParams.columnTypes
         + " separator=" + Arrays.asList(serdeParams.separators)
@@ -171,10 +188,10 @@ public void initialize(Configuration job, Properties tbl)
   public static SerDeParameters initSerdeParams(Configuration job,
       Properties tbl, String serdeName) throws SerDeException {
     SerDeParameters serdeParams = new SerDeParameters();
-    // Read the separators: We use 10 levels of separators by default, but we
+    // Read the separators: We use 8 levels of separators by default, but we
     // should change this when we allow users to specify more than 10 levels
     // of separators through DDL.
-    serdeParams.separators = new byte[10];
+    serdeParams.separators = new byte[8];
     serdeParams.separators[0] = getByte(tbl.getProperty(Constants.FIELD_DELIM,
         tbl.getProperty(Constants.SERIALIZATION_FORMAT)), DefaultSeparators[0]);
     serdeParams.separators[1] = getByte(tbl
@@ -230,6 +247,24 @@ public static SerDeParameters initSerdeParams(Configuration job,
     // Create the LazyObject for storing the rows
     serdeParams.rowTypeInfo = TypeInfoFactory.getStructTypeInfo(
         serdeParams.columnNames, serdeParams.columnTypes);
+    
+    // Get the escape information
+    String escapeProperty = tbl.getProperty(Constants.ESCAPE_CHAR);
+    serdeParams.escaped = (escapeProperty != null);
+    if (serdeParams.escaped) {
+      serdeParams.escapeChar = getByte(escapeProperty, (byte)'\\');
+    }
+    if (serdeParams.escaped) {
+      serdeParams.needsEscape = new boolean[128];
+      for (int i=0; i<128; i++) {
+        serdeParams.needsEscape[i] = false;
+      }
+      serdeParams.needsEscape[serdeParams.escapeChar] = true;
+      for (int i=0; i<serdeParams.separators.length; i++) {
+        serdeParams.needsEscape[serdeParams.separators[i]] = true;
+      }
+    }
+    
     return serdeParams;
   }
 
@@ -342,10 +377,13 @@ public Writable serialize(Object obj, ObjectInspector objInspector)
                 .equals(Category.PRIMITIVE))) {
           serialize(serializeStream, SerDeUtils.getJSONString(f, foi),
               PrimitiveObjectInspectorFactory.javaStringObjectInspector,
-              serdeParams.separators, 1, serdeParams.nullSequence);
+              serdeParams.separators, 1, serdeParams.nullSequence,
+              serdeParams.escaped, serdeParams.escapeChar,
+              serdeParams.needsEscape);
         } else {
           serialize(serializeStream, f, foi, serdeParams.separators, 1,
-              serdeParams.nullSequence);
+              serdeParams.nullSequence, serdeParams.escaped, serdeParams.escapeChar,
+              serdeParams.needsEscape);
         }
       }
     } catch (IOException e) {
@@ -365,12 +403,16 @@ public Writable serialize(Object obj, ObjectInspector objInspector)
    * @param objInspector  The ObjectInspector for the current Object.
    * @param separators    The separators array.
    * @param level         The current level of separator.
-   * @param nullSequence    The byte sequence representing the NULL value.
+   * @param nullSequence  The byte sequence representing the NULL value.
+   * @param escaped       Whether we need to escape the data when writing out
+   * @param escapeChar    Which char to use as the escape char, e.g. '\\'     
+   * @param needsEscape   Which chars needs to be escaped. This array should have size of 128.
+   *                      Negative byte values (or byte values >= 128) are never escaped.
    * @throws IOException 
    */
   public static void serialize(ByteStream.Output out, Object obj, 
       ObjectInspector objInspector, byte[] separators, int level,
-      Text nullSequence) throws IOException {
+      Text nullSequence, boolean escaped, byte escapeChar, boolean[] needsEscape) throws IOException {
     
     if (obj == null) {
       out.write(nullSequence.getBytes(), 0, nullSequence.getLength());
@@ -379,7 +421,7 @@ public static void serialize(ByteStream.Output out, Object obj,
     
     switch (objInspector.getCategory()) {
       case PRIMITIVE: {
-        LazyUtils.writePrimitiveUTF8(out, obj, (PrimitiveObjectInspector)objInspector);
+        LazyUtils.writePrimitiveUTF8(out, obj, (PrimitiveObjectInspector)objInspector, escaped, escapeChar, needsEscape);
         return;
       }
       case LIST: {
@@ -395,7 +437,7 @@ public static void serialize(ByteStream.Output out, Object obj,
               out.write(separator);
             }
             serialize(out, list.get(i), eoi, separators, level+1,
-                nullSequence);
+                nullSequence, escaped, escapeChar, needsEscape);
           }
         }
         return;
@@ -419,10 +461,10 @@ public static void serialize(ByteStream.Output out, Object obj,
               out.write(separator);
             }
             serialize(out, entry.getKey(), koi, separators, level+2, 
-                nullSequence);
+                nullSequence, escaped, escapeChar, needsEscape);
             out.write(keyValueSeparator);
             serialize(out, entry.getValue(), voi, separators, level+2, 
-                nullSequence);
+                nullSequence, escaped, escapeChar, needsEscape);
           }
         }
         return;
@@ -441,7 +483,7 @@ public static void serialize(ByteStream.Output out, Object obj,
             }
             serialize(out, list.get(i),
                 fields.get(i).getFieldObjectInspector(), separators, level+1,
-                nullSequence);
+                nullSequence, escaped, escapeChar, needsEscape);
           }
         }
         return;
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyString.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyString.java
index 0d77b0580d..b9d4a39824 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyString.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyString.java
@@ -17,20 +17,67 @@
  */
 package org.apache.hadoop.hive.serde2.lazy;
 
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyStringObjectInspector;
 import org.apache.hadoop.io.Text;
 
 /**
  * LazyObject for storing a value of String.
  */
-public class LazyString extends LazyPrimitive<Text> {
+public class LazyString extends LazyPrimitive<LazyStringObjectInspector, Text> {
 
-  public LazyString() {
+  public LazyString(LazyStringObjectInspector oi) {
+    super(oi);
     data = new Text();
   }
 
+  public LazyString(LazyString copy) {
+    super(copy);
+    data = new Text(copy.data);
+  }
+   
   @Override
   public void init(ByteArrayRef bytes, int start, int length) {
-    data.set(bytes.getData(), start, length);
+    if (oi.isEscaped()) {
+      byte escapeChar = oi.getEscapeChar();
+      byte[] inputBytes = bytes.getData();
+      
+      // First calculate the length of the output string
+      int outputLength = 0;
+      for (int i=0; i<length; i++) {
+        if (inputBytes[start+i] != escapeChar) {
+          outputLength ++;
+        } else {
+          outputLength ++;
+          i++;
+        }
+      }
+      
+      // Copy the data over, so that the internal state of Text will be set to
+      // the required outputLength.
+      data.set(bytes.getData(), start, outputLength);
+
+      // We need to copy the data byte by byte only in case the
+      // "outputLength < length" (which means there is at least one escaped
+      // byte.
+      if (outputLength < length) {
+        int k = 0;
+        byte[] outputBytes = data.getBytes();
+        for (int i=0; i<length; i++) {
+          byte b = inputBytes[start+i];
+          if (b != escapeChar || i == length - 1) {
+            outputBytes[k++] = b;
+          } else {
+            // get the next byte
+            i++;
+            outputBytes[k++] = inputBytes[start+i];
+          }
+        }
+        assert(k == outputLength);
+      }
+    } else {
+      // if the data is not escaped, simply copy the data.
+      data.set(bytes.getData(), start, length);
+    }
   }
 
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyStruct.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyStruct.java
index 0fbfe46fe3..209376d9b9 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyStruct.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyStruct.java
@@ -23,8 +23,9 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.hive.serde2.typeinfo.StructTypeInfo;
-import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazySimpleStructObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.StructField;
+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
 import org.apache.hadoop.io.Text;
 
 
@@ -33,9 +34,9 @@
  * The field of a struct can be primitive or non-primitive.
  *
  * LazyStruct does not deal with the case of a NULL struct. That is handled
- * by LazySimpleStructObjectInspector.
+ * by the parent LazyObject.
  */
-public class LazyStruct extends LazyNonPrimitive {
+public class LazyStruct extends LazyNonPrimitive<LazySimpleStructObjectInspector> {
 
   private static Log LOG = LogFactory.getLog(LazyStruct.class.getName());
 
@@ -63,11 +64,10 @@ public class LazyStruct extends LazyNonPrimitive {
   boolean[] fieldInited;
   
   /**
-   * Construct a LazyStruct object with the TypeInfo.
-   * @param typeInfo  the TypeInfo representing the type of this LazyStruct.
+   * Construct a LazyStruct object with the ObjectInspector.
    */
-  public LazyStruct(TypeInfo typeInfo) {
-    super(typeInfo);
+  public LazyStruct(LazySimpleStructObjectInspector oi) {
+    super(oi);
   }
   
   /**
@@ -83,20 +83,19 @@ public void init(ByteArrayRef bytes, int start, int length) {
   boolean extraFieldWarned = false;
   /**
    * Parse the byte[] and fill each field.
-   * @param separator  The separator for delimiting the fields in the byte[]
-   * @param nullSequence  The sequence for the NULL value
-   * @param lastColumnTakesRest  Whether the additional fields should be all 
-   *                             put into the last column in case the data 
-   *                             contains more columns than the schema.  
    */
-  private void parse(byte separator, Text nullSequence, 
-      boolean lastColumnTakesRest) {
+  private void parse() {
+    
+    byte separator = oi.getSeparator();
+    boolean lastColumnTakesRest = oi.getLastColumnTakesRest();
+    boolean isEscaped = oi.isEscaped();
+    byte escapeChar = oi.getEscapeChar();
     
     if (fields == null) {
-      List<TypeInfo> fieldTypeInfos = ((StructTypeInfo)typeInfo).getAllStructFieldTypeInfos();
-      fields = new LazyObject[fieldTypeInfos.size()];
+      List<? extends StructField> fieldRefs = ((StructObjectInspector)oi).getAllStructFieldRefs();
+      fields = new LazyObject[fieldRefs.size()];
       for (int i = 0 ; i < fields.length; i++) {
-        fields[i] = LazyFactory.createLazyObject(fieldTypeInfos.get(i));
+        fields[i] = LazyFactory.createLazyObject(fieldRefs.get(i).getFieldObjectInspector());
       }
       fieldInited = new boolean[fields.length];      
       // Extra element to make sure we have the same formula to compute the 
@@ -133,7 +132,13 @@ private void parse(byte separator, Text nullSequence,
         }
         fieldByteBegin = fieldByteEnd + 1;
       }
-      fieldByteEnd++;
+      if (isEscaped && bytes[fieldByteEnd] == escapeChar
+          && fieldByteEnd+1 < structByteEnd) {
+        // ignore the char after escape_char
+        fieldByteEnd += 2;
+      } else {
+        fieldByteEnd++;
+      }
     }
     
     // Extra bytes at the end?
@@ -151,7 +156,7 @@ private void parse(byte separator, Text nullSequence,
     }
     
     Arrays.fill(fieldInited, false);
-    parsed = true;
+    parsed = true;    
   }
   
   /**
@@ -163,34 +168,25 @@ private void parse(byte separator, Text nullSequence,
    * directly use the Object instead of going through 
    * Object PrimitiveObjectInspector.get(Object).  
    * 
-   * NOTE: separator and nullSequence has to be the same each time 
-   * this method is called.  These two parameters are used only once to parse
-   * each record.
-   * 
    * @param fieldID  The field ID
-   * @param separator  The separator for delimiting the fields in the byte[]
-   * @param nullSequence  The sequence for null value
-   * @param lastColumnTakesRest  Whether the additional fields should be all 
-   *                             put into the last column in case the data 
-   *                             contains more columns than the schema.  
    * @return         The field as a LazyObject
    */
-  public Object getField(int fieldID, byte separator, Text nullSequence, 
-      boolean lastColumnTakesRest) {
+  public Object getField(int fieldID) {
     if (!parsed) {
-      parse(separator, nullSequence, lastColumnTakesRest);
+      parse();
     }
-    return uncheckedGetField(fieldID, nullSequence);
+    return uncheckedGetField(fieldID);
   }
-
+  
   /**
    * Get the field out of the row without checking parsed.
    * This is called by both getField and getFieldsAsList.
    * @param fieldID  The id of the field starting from 0.
    * @param nullSequence  The sequence representing NULL value.
-   * @return  The value of the field 
+   * @return  The value of the field
    */
-  private Object uncheckedGetField(int fieldID, Text nullSequence) {
+  private Object uncheckedGetField(int fieldID) {
+    Text nullSequence = oi.getNullSequence();
     // Test the length first so in most cases we avoid doing a byte[] 
     // comparison.
     int fieldByteBegin = startPosition[fieldID];
@@ -211,17 +207,11 @@ private Object uncheckedGetField(int fieldID, Text nullSequence) {
   ArrayList<Object> cachedList;
   /**
    * Get the values of the fields as an ArrayList.
-   * @param separator  The separator for delimiting the fields in the byte[]
-   * @param nullSequence         The sequence for the NULL value
-   * @param lastColumnTakesRest  Whether the additional fields should be all 
-   *                             put into the last column in case the data 
-   *                             contains more columns than the schema.  
    * @return The values of the fields as an ArrayList.
    */
-  public ArrayList<Object> getFieldsAsList(byte separator, Text nullSequence, 
-      boolean lastColumnTakesRest) {
+  public ArrayList<Object> getFieldsAsList() {
     if (!parsed) {
-      parse(separator, nullSequence, lastColumnTakesRest);
+      parse();
     }
     if (cachedList == null) {
       cachedList = new ArrayList<Object>();
@@ -229,7 +219,7 @@ public ArrayList<Object> getFieldsAsList(byte separator, Text nullSequence,
       cachedList.clear();
     }
     for (int i=0; i<fields.length; i++) {
-      cachedList.add(uncheckedGetField(i, nullSequence));
+      cachedList.add(uncheckedGetField(i));
     }
     return cachedList;
   }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyUtils.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyUtils.java
index 681f47df3d..5f238d9224 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyUtils.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyUtils.java
@@ -98,12 +98,44 @@ public static String convertToString(byte[] bytes, int start, int length) {
   static byte[] trueBytes = {(byte)'t', 'r', 'u', 'e'};
   static byte[] falseBytes = {(byte)'f', 'a', 'l', 's', 'e'};
 
+  /**
+   * Write the bytes with special characters escaped.
+   * @param escaped     Whether the data should be written out in an escaped way.
+   * @param escapeChar  if escaped, the char for prefixing special characters.
+   * @param needsEscape if escaped, whether a specific character needs escaping.
+   *                    This array should have size of 128.
+   */
+  private static void writeEscaped(OutputStream out, byte[] bytes,
+      int start, int len, boolean escaped, byte escapeChar, boolean[] needsEscape)
+      throws IOException {
+    if (escaped) {
+      int end = start + len;
+      for (int i = start; i <= end; i++) {
+        if (i == end || (bytes[i] >= 0 && needsEscape[bytes[i]])) {
+          if (i > start) {
+            out.write(bytes, start, i - start);
+          }
+          start = i;
+          if (i < len) {
+            out.write(escapeChar);
+            // the current char will be written out later.
+          }
+        }
+      }
+    } else {
+      out.write(bytes, 0, len);
+    }
+  }
+  
+  
   /**
    * Write out the text representation of a Primitive Object to a UTF8 byte stream.
    * @param out  The UTF8 byte OutputStream
    * @param o    The primitive Object
+   * @param needsEscape  Whether a character needs escaping. This array should have size of 128. 
    */
-  public static void writePrimitiveUTF8(OutputStream out, Object o, PrimitiveObjectInspector oi) throws IOException {
+  public static void writePrimitiveUTF8(OutputStream out, Object o, PrimitiveObjectInspector oi,
+      boolean escaped, byte escapeChar, boolean[] needsEscape) throws IOException {
     
     switch (oi.getPrimitiveCategory()) {
       case BOOLEAN: {
@@ -145,7 +177,7 @@ public static void writePrimitiveUTF8(OutputStream out, Object o, PrimitiveObjec
       }
       case STRING: {
         Text t = ((StringObjectInspector)oi).getPrimitiveWritableObject(o);
-        out.write(t.getBytes(), 0, t.getLength());
+        writeEscaped(out, t.getBytes(), 0, t.getLength(), escaped, escapeChar, needsEscape);
         break;
       }
       default: {
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazyListObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazyListObjectInspector.java
new file mode 100644
index 0000000000..f92768ba17
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazyListObjectInspector.java
@@ -0,0 +1,125 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.serde2.lazy.objectinspector;
+
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hive.serde2.lazy.LazyArray;
+import org.apache.hadoop.hive.serde2.objectinspector.ListObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.io.Text;
+
+/**
+ * LazyListObjectInspector works on array data that is stored in LazyArray.
+ * 
+ * Always use the ObjectInspectorFactory to create new ObjectInspector objects, instead
+ * of directly creating an instance of this class.
+ */
+public class LazyListObjectInspector implements ListObjectInspector {
+
+  public static final Log LOG = LogFactory.getLog(LazyListObjectInspector.class.getName());
+  
+  ObjectInspector listElementObjectInspector;
+  
+  byte separator;
+  Text nullSequence;
+  boolean escaped;
+  byte escapeChar;
+  
+  /** Call ObjectInspectorFactory.getLazySimpleListObjectInspector instead.
+   */
+  protected LazyListObjectInspector(ObjectInspector listElementObjectInspector, 
+      byte separator, Text nullSequence, boolean escaped, byte escapeChar) {
+    this.listElementObjectInspector = listElementObjectInspector;
+    this.separator = separator;
+    this.nullSequence = nullSequence;
+    this.escaped = escaped;
+    this.escapeChar = escapeChar;
+  }
+
+  @Override
+  public final Category getCategory() {
+    return Category.LIST;
+  }
+
+  // without data
+  @Override
+  public ObjectInspector getListElementObjectInspector() {
+    return listElementObjectInspector;
+  }
+  
+  // with data
+  @Override
+  public Object getListElement(Object data, int index) {
+    if (data == null) {
+      return null;
+    }
+    LazyArray array = (LazyArray) data;
+    return array.getListElementObject(index);
+  }
+  
+  @Override
+  public int getListLength(Object data) {
+    if (data == null) {
+      return -1;
+    }
+    LazyArray array = (LazyArray) data;
+    return array.getListLength();
+  }
+  
+  @Override
+  public List<?> getList(Object data) {
+    if (data == null) {
+      return null;
+    }
+    LazyArray array = (LazyArray) data;
+    return array.getList();
+  }
+
+  @Override
+  public String getTypeName() {
+    return org.apache.hadoop.hive.serde.Constants.LIST_TYPE_NAME 
+        + "<" + listElementObjectInspector.getTypeName() + ">";
+  }
+
+  /**
+   * Returns the separator for delimiting items in this array.
+   * Called by LazyArray.init(...).
+   */
+  public byte getSeparator() {
+    return separator;
+  }
+
+  /**
+   * Returns the NullSequence for this array.
+   * Called by LazyArray.init(...).
+   */
+  public Text getNullSequence() {
+    return nullSequence;
+  }
+  public boolean isEscaped() {
+    return escaped;
+  }
+  public byte getEscapeChar() {
+    return escapeChar;
+  }
+
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazyMapObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazyMapObjectInspector.java
new file mode 100644
index 0000000000..3f0e6f627b
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazyMapObjectInspector.java
@@ -0,0 +1,127 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.serde2.lazy.objectinspector;
+
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hive.serde2.lazy.LazyMap;
+import org.apache.hadoop.hive.serde2.objectinspector.MapObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.io.Text;
+
+/**
+ * LazyMapObjectInspector works on struct data that is stored in LazyStruct.
+ * 
+ * Always use the ObjectInspectorFactory to create new ObjectInspector objects, instead
+ * of directly creating an instance of this class.
+ */
+public class LazyMapObjectInspector implements MapObjectInspector {
+
+  public static final Log LOG = LogFactory.getLog(LazyMapObjectInspector.class.getName());
+  
+  ObjectInspector mapKeyObjectInspector;
+  ObjectInspector mapValueObjectInspector;
+  
+  byte itemSeparator;
+  byte keyValueSeparator;  
+  Text nullSequence;
+  boolean escaped;
+  byte escapeChar;
+  
+  /** Call ObjectInspectorFactory.getStandardListObjectInspector instead.
+   */
+  protected LazyMapObjectInspector(ObjectInspector mapKeyObjectInspector,
+      ObjectInspector mapValueObjectInspector,
+      byte itemSeparator, byte keyValueSeparator, Text nullSequence,
+      boolean escaped, byte escapeChar) {
+    this.mapKeyObjectInspector = mapKeyObjectInspector;
+    this.mapValueObjectInspector = mapValueObjectInspector;
+
+    this.itemSeparator = itemSeparator;
+    this.keyValueSeparator = keyValueSeparator;
+    this.nullSequence = nullSequence;
+    this.escaped = escaped;
+    this.escapeChar = escapeChar;
+  }
+
+  @Override
+  public final Category getCategory() {
+    return Category.MAP;
+  }
+
+  @Override
+  public String getTypeName() {
+    return org.apache.hadoop.hive.serde.Constants.MAP_TYPE_NAME 
+        + "<" + mapKeyObjectInspector.getTypeName() + "," 
+        + mapValueObjectInspector.getTypeName() + ">";
+  }
+
+  @Override
+  public ObjectInspector getMapKeyObjectInspector() {
+    return mapKeyObjectInspector;
+  }
+
+  @Override
+  public ObjectInspector getMapValueObjectInspector() {
+    return mapValueObjectInspector;
+  }
+
+  @Override
+  public Object getMapValueElement(Object data, Object key) {
+    if (data == null) {
+      return null;
+    }
+    return ((LazyMap)data).getMapValueElement(key);
+  }
+
+  @Override
+  public Map<?, ?> getMap(Object data) {
+    if (data == null) {
+      return null;
+    }
+    return ((LazyMap)data).getMap();
+  }
+
+  @Override
+  public int getMapSize(Object data) {
+    if (data == null) {
+      return -1;
+    }
+    return ((LazyMap)data).getMapSize();
+  }
+  
+  // Called by LazyMap
+  public byte getItemSeparator() {
+    return itemSeparator;
+  }
+  public byte getKeyValueSeparator() {
+    return keyValueSeparator;
+  }
+  public Text getNullSequence() {
+    return nullSequence;
+  }
+  public boolean isEscaped() {
+    return escaped;
+  }
+  public byte getEscapeChar() {
+    return escapeChar;
+  }
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazyObjectInspectorFactory.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazyObjectInspectorFactory.java
new file mode 100644
index 0000000000..b9116232ed
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazyObjectInspectorFactory.java
@@ -0,0 +1,116 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.serde2.lazy.objectinspector;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.UnionStructObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector.PrimitiveCategory;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableBooleanObjectInspector;
+import org.apache.hadoop.io.Text;
+
+
+/**
+ * ObjectInspectorFactory is the primary way to create new ObjectInspector instances.
+ * 
+ * SerDe classes should call the static functions in this library to create an ObjectInspector
+ * to return to the caller of SerDe2.getObjectInspector().
+ * 
+ * The reason of having caches here is that ObjectInspector is because ObjectInspectors do
+ * not have an internal state - so ObjectInspectors with the same construction parameters should
+ * result in exactly the same ObjectInspector.
+ */
+public class LazyObjectInspectorFactory {
+
+
+
+  static HashMap<ArrayList<Object>, LazySimpleStructObjectInspector> cachedLazySimpleStructObjectInspector =
+    new HashMap<ArrayList<Object>, LazySimpleStructObjectInspector>(); 
+  public static LazySimpleStructObjectInspector getLazySimpleStructObjectInspector(List<String> structFieldNames, 
+      List<ObjectInspector> structFieldObjectInspectors, byte separator, Text nullSequence,
+      boolean lastColumnTakesRest, boolean escaped, byte escapeChar) {
+    ArrayList<Object> signature = new ArrayList<Object>();
+    signature.add(structFieldNames);
+    signature.add(structFieldObjectInspectors);
+    signature.add(Byte.valueOf(separator));
+    signature.add(nullSequence.toString());
+    signature.add(Boolean.valueOf(lastColumnTakesRest));
+    signature.add(Boolean.valueOf(escaped));
+    signature.add(Byte.valueOf(escapeChar));
+    LazySimpleStructObjectInspector result = cachedLazySimpleStructObjectInspector.get(signature);
+    if (result == null) {
+      result = new LazySimpleStructObjectInspector(structFieldNames, structFieldObjectInspectors, 
+          separator, nullSequence, lastColumnTakesRest, escaped, escapeChar);
+      cachedLazySimpleStructObjectInspector.put(signature, result);
+    }
+    return result;
+  }
+
+  static HashMap<ArrayList<Object>, LazyListObjectInspector> cachedLazySimpleListObjectInspector =
+    new HashMap<ArrayList<Object>, LazyListObjectInspector>(); 
+  public static LazyListObjectInspector getLazySimpleListObjectInspector( 
+      ObjectInspector listElementObjectInspector, byte separator, Text nullSequence,
+      boolean escaped, byte escapeChar) {
+    ArrayList<Object> signature = new ArrayList<Object>();
+    signature.add(listElementObjectInspector);
+    signature.add(Byte.valueOf(separator));
+    signature.add(nullSequence.toString());
+    signature.add(Boolean.valueOf(escaped));
+    signature.add(Byte.valueOf(escapeChar));
+    LazyListObjectInspector result = cachedLazySimpleListObjectInspector.get(signature);
+    if (result == null) {
+      result = new LazyListObjectInspector(listElementObjectInspector, 
+          separator, nullSequence, escaped, escapeChar);
+      cachedLazySimpleListObjectInspector.put(signature, result);
+    }
+    return result;
+  }
+  
+  static HashMap<ArrayList<Object>, LazyMapObjectInspector> cachedLazySimpleMapObjectInspector =
+    new HashMap<ArrayList<Object>, LazyMapObjectInspector>(); 
+  public static LazyMapObjectInspector getLazySimpleMapObjectInspector( 
+      ObjectInspector mapKeyObjectInspector, ObjectInspector mapValueObjectInspector, 
+      byte itemSeparator, byte keyValueSeparator, Text nullSequence, boolean escaped, 
+      byte escapeChar) {
+    ArrayList<Object> signature = new ArrayList<Object>();
+    signature.add(mapKeyObjectInspector);
+    signature.add(mapValueObjectInspector);
+    signature.add(Byte.valueOf(itemSeparator));
+    signature.add(Byte.valueOf(keyValueSeparator));
+    signature.add(nullSequence.toString());
+    signature.add(Boolean.valueOf(escaped));
+    signature.add(Byte.valueOf(escapeChar));
+    LazyMapObjectInspector result = cachedLazySimpleMapObjectInspector.get(signature);
+    if (result == null) {
+      result = new LazyMapObjectInspector(mapKeyObjectInspector,
+          mapValueObjectInspector, itemSeparator, keyValueSeparator, nullSequence,
+          escaped, escapeChar);
+      cachedLazySimpleMapObjectInspector.put(signature, result);
+    }
+    return result;
+  }
+  
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazySimpleStructObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazySimpleStructObjectInspector.java
new file mode 100644
index 0000000000..64e1c9b2a8
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/LazySimpleStructObjectInspector.java
@@ -0,0 +1,180 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.serde2.lazy.objectinspector;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hive.serde2.lazy.LazyStruct;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;
+import org.apache.hadoop.hive.serde2.objectinspector.StructField;
+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
+import org.apache.hadoop.io.Text;
+
+/**
+ * LazySimpleStructObjectInspector works on struct data that is stored in LazyStruct.
+ * 
+ * The names of the struct fields and the internal structure of the struct fields
+ * are specified in the ctor of the LazySimpleStructObjectInspector.
+ * 
+ * Always use the ObjectInspectorFactory to create new ObjectInspector objects, instead
+ * of directly creating an instance of this class.
+ */
+public class LazySimpleStructObjectInspector implements StructObjectInspector {
+
+  public static final Log LOG = LogFactory.getLog(LazySimpleStructObjectInspector.class.getName());
+  
+  protected static class MyField implements StructField {
+    protected int fieldID;
+    protected String fieldName;
+    protected ObjectInspector fieldObjectInspector;
+    
+    public MyField(int fieldID, String fieldName, ObjectInspector fieldObjectInspector) {
+      this.fieldID = fieldID;
+      this.fieldName = fieldName.toLowerCase();
+      this.fieldObjectInspector = fieldObjectInspector;
+    }
+
+    public int getFieldID() {
+      return fieldID;
+    }
+    public String getFieldName() {
+      return fieldName;
+    }
+    public ObjectInspector getFieldObjectInspector() {
+      return fieldObjectInspector;
+    }
+    
+    public String toString() {
+      return "" + fieldID + ":" + fieldName;
+    }
+  }
+  
+  protected List<MyField> fields;
+  
+  @Override
+  public String getTypeName() {
+    return ObjectInspectorUtils.getStandardStructTypeName(this);
+  }
+  
+  
+  byte separator;
+  Text nullSequence;  
+  boolean lastColumnTakesRest;
+  boolean escaped;
+  byte escapeChar;
+  
+  /** Call ObjectInspectorFactory.getLazySimpleStructObjectInspector instead.
+   */
+  protected LazySimpleStructObjectInspector(List<String> structFieldNames, List<ObjectInspector> structFieldObjectInspectors,
+      byte separator, Text nullSequence, boolean lastColumnTakesRest,
+      boolean escaped, byte escapeChar) {
+    init(structFieldNames, structFieldObjectInspectors, separator, nullSequence, lastColumnTakesRest,
+        escaped, escapeChar);
+  }
+  protected void init(List<String> structFieldNames, List<ObjectInspector> structFieldObjectInspectors,
+      byte separator, Text nullSequence, boolean lastColumnTakesRest, boolean escaped, byte escapeChar) {
+    assert(structFieldNames.size() == structFieldObjectInspectors.size());
+    
+    this.separator = separator;
+    this.nullSequence = nullSequence;
+    this.lastColumnTakesRest = lastColumnTakesRest;
+    this.escaped = escaped;
+    this.escapeChar = escapeChar;
+    
+    fields = new ArrayList<MyField>(structFieldNames.size()); 
+    for(int i=0; i<structFieldNames.size(); i++) {
+      fields.add(new MyField(i, structFieldNames.get(i), structFieldObjectInspectors.get(i)));
+    }
+  }
+  
+  protected LazySimpleStructObjectInspector(List<StructField> fields, byte separator, Text nullSequence) {
+    init(fields, separator, nullSequence);
+  }
+  protected void init(List<StructField> fields, byte separator, Text nullSequence) {
+    this.separator = separator;
+    this.nullSequence = nullSequence;
+    
+    this.fields = new ArrayList<MyField>(fields.size()); 
+    for(int i=0; i<fields.size(); i++) {
+      this.fields.add(new MyField(i, fields.get(i).getFieldName(), fields.get(i).getFieldObjectInspector()));
+    }
+  }
+
+  
+  @Override
+  public final Category getCategory() {
+    return Category.STRUCT;
+  }
+
+  // Without Data
+  @Override
+  public StructField getStructFieldRef(String fieldName) {
+    return ObjectInspectorUtils.getStandardStructFieldRef(fieldName, fields);
+  }
+  @Override
+  public List<? extends StructField> getAllStructFieldRefs() {
+    return fields;
+  }
+
+  // With Data
+  @Override
+  public Object getStructFieldData(Object data, StructField fieldRef) {
+    if (data == null) {
+      return null;
+    }
+    LazyStruct struct = (LazyStruct)data;
+    MyField f = (MyField) fieldRef;
+    
+    int fieldID = f.getFieldID();
+    assert(fieldID >= 0 && fieldID < fields.size());
+    
+    return struct.getField(fieldID);
+  }
+
+  @Override
+  public List<Object> getStructFieldsDataAsList(Object data) {
+    if (data == null) {
+      return null;
+    }
+    LazyStruct struct = (LazyStruct)data;
+    return struct.getFieldsAsList();
+  }
+
+  // For LazyStruct
+  public byte getSeparator() {
+    return separator;
+  }
+  public Text getNullSequence() {
+    return nullSequence;
+  }
+  public boolean getLastColumnTakesRest() {
+    return lastColumnTakesRest;
+  }
+  public boolean isEscaped() {
+    return escaped;
+  }
+  public byte getEscapeChar() {
+    return escapeChar;
+  }
+  
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/AbstractPrimitiveLazyObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/AbstractPrimitiveLazyObjectInspector.java
new file mode 100644
index 0000000000..b919346587
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/AbstractPrimitiveLazyObjectInspector.java
@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.lazy.LazyPrimitive;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.AbstractPrimitiveObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils.PrimitiveTypeEntry;
+import org.apache.hadoop.io.Writable;
+
+/**
+ * An AbstractPrimitiveLazyObjectInspector for a LazyPrimitive object. 
+ */
+public abstract class AbstractPrimitiveLazyObjectInspector<T extends Writable> extends AbstractPrimitiveObjectInspector {
+
+  protected AbstractPrimitiveLazyObjectInspector(PrimitiveTypeEntry typeEntry) {
+    super(typeEntry); 
+  }
+  
+  @Override
+  public T getPrimitiveWritableObject(Object o) {
+    return o == null ? null : ((LazyPrimitive<?,T>)o).getWritableObject();
+  }
+
+  @Override
+  public boolean preferWritable() {
+    return true;
+  }
+  
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyBooleanObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyBooleanObjectInspector.java
new file mode 100644
index 0000000000..cabefc92a2
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyBooleanObjectInspector.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.lazy.LazyBoolean;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.BooleanObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.io.BooleanWritable;
+
+
+/**
+ * A WritableBooleanObjectInspector inspects a BooleanWritable Object.
+ */
+public class LazyBooleanObjectInspector extends AbstractPrimitiveLazyObjectInspector<BooleanWritable> 
+implements BooleanObjectInspector{
+
+  LazyBooleanObjectInspector() {
+    super(PrimitiveObjectInspectorUtils.booleanTypeEntry);
+  }
+  
+  @Override
+  public boolean get(Object o) {
+    return getPrimitiveWritableObject(o).get();
+  }
+
+  @Override
+  public Object copyObject(Object o) {
+    return o == null ? null : new LazyBoolean((LazyBoolean)o);
+  }
+
+  @Override
+  public Object getPrimitiveJavaObject(Object o) {
+    return o == null ? null : Boolean.valueOf(get(o));
+  }
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyByteObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyByteObjectInspector.java
new file mode 100644
index 0000000000..240b6fd076
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyByteObjectInspector.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.io.ByteWritable;
+import org.apache.hadoop.hive.serde2.lazy.LazyByte;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.ByteObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.io.BooleanWritable;
+
+
+/**
+ * A WritableByteObjectInspector inspects a ByteWritable Object.
+ */
+public class LazyByteObjectInspector extends AbstractPrimitiveLazyObjectInspector<ByteWritable> 
+implements ByteObjectInspector{
+
+  LazyByteObjectInspector() {
+    super(PrimitiveObjectInspectorUtils.byteTypeEntry);
+  }
+  
+  @Override
+  public byte get(Object o) {
+    return getPrimitiveWritableObject(o).get();
+  }
+
+  @Override
+  public Object copyObject(Object o) {
+    return o == null ? null : new LazyByte((LazyByte)o);
+  }
+
+  @Override
+  public Object getPrimitiveJavaObject(Object o) {
+    return o == null ? null : Byte.valueOf(get(o));
+  }
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyDoubleObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyDoubleObjectInspector.java
new file mode 100644
index 0000000000..ada9860fd2
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyDoubleObjectInspector.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.io.DoubleWritable;
+import org.apache.hadoop.hive.serde2.lazy.LazyDouble;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.DoubleObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+
+
+/**
+ * A WritableDoubleObjectInspector inspects a DoubleWritable Object.
+ */
+public class LazyDoubleObjectInspector extends AbstractPrimitiveLazyObjectInspector<DoubleWritable>
+implements DoubleObjectInspector{
+
+  LazyDoubleObjectInspector() {
+    super(PrimitiveObjectInspectorUtils.doubleTypeEntry);
+  }
+  
+  @Override
+  public double get(Object o) {
+    return getPrimitiveWritableObject(o).get();
+  }
+
+  @Override
+  public Object copyObject(Object o) {
+    return o == null ? null : new LazyDouble((LazyDouble)o);
+  }
+
+  @Override
+  public Object getPrimitiveJavaObject(Object o) {
+    return o == null ? null : Double.valueOf(get(o));
+  }
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyFloatObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyFloatObjectInspector.java
new file mode 100644
index 0000000000..3d2ae785cd
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyFloatObjectInspector.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.lazy.LazyFloat;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.FloatObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.io.FloatWritable;
+
+/**
+ * A FloatObjectInspector inspects a FloatWritable Object.
+ */
+public class LazyFloatObjectInspector extends AbstractPrimitiveLazyObjectInspector<FloatWritable> 
+implements FloatObjectInspector{
+
+  LazyFloatObjectInspector() {
+    super(PrimitiveObjectInspectorUtils.floatTypeEntry);
+  }
+  
+  @Override
+  public float get(Object o) {
+    return getPrimitiveWritableObject(o).get();
+  }
+
+  @Override
+  public Object copyObject(Object o) {
+    return o == null ? null : new LazyFloat((LazyFloat)o);
+  }
+
+  @Override
+  public Object getPrimitiveJavaObject(Object o) {
+    return o == null ? null : Float.valueOf(get(o));
+  }
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyIntObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyIntObjectInspector.java
new file mode 100644
index 0000000000..fc28aaf5f0
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyIntObjectInspector.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.lazy.LazyInteger;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.IntObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.io.IntWritable;
+
+
+/**
+ * A WritableIntObjectInspector inspects a IntWritable Object.
+ */
+public class LazyIntObjectInspector extends AbstractPrimitiveLazyObjectInspector<IntWritable> 
+implements IntObjectInspector{
+
+  LazyIntObjectInspector() {
+    super(PrimitiveObjectInspectorUtils.intTypeEntry);
+  }
+  
+  @Override
+  public int get(Object o) {
+    return getPrimitiveWritableObject(o).get();
+  }
+
+  @Override
+  public Object copyObject(Object o) {
+    return o == null ? null : new LazyInteger((LazyInteger)o);
+  }
+
+  @Override
+  public Object getPrimitiveJavaObject(Object o) {
+    return o == null ? null : Integer.valueOf(get(o));
+  }
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyLongObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyLongObjectInspector.java
new file mode 100644
index 0000000000..15df3f3f0e
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyLongObjectInspector.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.lazy.LazyLong;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.LongObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.io.LongWritable;
+
+
+/**
+ * A WritableLongObjectInspector inspects a LongWritable Object.
+ */
+public class LazyLongObjectInspector extends AbstractPrimitiveLazyObjectInspector<LongWritable> 
+implements LongObjectInspector{
+
+  LazyLongObjectInspector() {
+    super(PrimitiveObjectInspectorUtils.longTypeEntry);
+  }
+  
+  @Override
+  public long get(Object o) {
+    return getPrimitiveWritableObject(o).get();
+  }
+
+  @Override
+  public Object copyObject(Object o) {
+    return o == null ? null : new LazyLong((LazyLong)o);
+  }
+
+  @Override
+  public Object getPrimitiveJavaObject(Object o) {
+    return o == null ? null : Long.valueOf(get(o));
+  }
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyPrimitiveObjectInspectorFactory.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyPrimitiveObjectInspectorFactory.java
new file mode 100644
index 0000000000..6eaf0caf24
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyPrimitiveObjectInspectorFactory.java
@@ -0,0 +1,99 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.UnionStructObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector.PrimitiveCategory;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.AbstractPrimitiveJavaObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableBooleanObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableByteObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableDoubleObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableFloatObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableIntObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableLongObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableShortObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableStringObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableVoidObjectInspector;
+import org.apache.hadoop.io.Text;
+
+
+/**
+ * LazyPrimitiveObjectInspectorFactory is the primary way to create new ObjectInspector instances.
+ * 
+ * SerDe classes should call the static functions in this library to create an ObjectInspector
+ * to return to the caller of SerDe2.getObjectInspector().
+ * 
+ * The reason of having caches here is that ObjectInspector is because ObjectInspectors do
+ * not have an internal state - so ObjectInspectors with the same construction parameters should
+ * result in exactly the same ObjectInspector.
+ */
+public class LazyPrimitiveObjectInspectorFactory {
+
+  public final static LazyBooleanObjectInspector lazyBooleanObjectInspector = new LazyBooleanObjectInspector();
+  public final static LazyByteObjectInspector lazyByteObjectInspector = new LazyByteObjectInspector();
+  public final static LazyShortObjectInspector lazyShortObjectInspector = new LazyShortObjectInspector();
+  public final static LazyIntObjectInspector lazyIntObjectInspector = new LazyIntObjectInspector();
+  public final static LazyLongObjectInspector lazyLongObjectInspector = new LazyLongObjectInspector();
+  public final static LazyFloatObjectInspector lazyFloatObjectInspector = new LazyFloatObjectInspector();
+  public final static LazyDoubleObjectInspector lazyDoubleObjectInspector = new LazyDoubleObjectInspector();
+  public final static LazyVoidObjectInspector lazyVoidObjectInspector = new LazyVoidObjectInspector();
+  
+  static HashMap<ArrayList<Object>, LazyStringObjectInspector> cachedLazyStringObjectInspector =
+    new HashMap<ArrayList<Object>, LazyStringObjectInspector>(); 
+  public static LazyStringObjectInspector getLazyStringObjectInspector(boolean escaped, byte escapeChar) {
+    ArrayList<Object> signature = new ArrayList<Object>();
+    signature.add(Boolean.valueOf(escaped));
+    signature.add(Byte.valueOf(escapeChar));
+    LazyStringObjectInspector result = cachedLazyStringObjectInspector.get(signature);
+    if (result == null) {
+      result = new LazyStringObjectInspector(escaped, escapeChar);
+      cachedLazyStringObjectInspector.put(signature, result);
+    }
+    return result;
+  }
+  
+  public static AbstractPrimitiveLazyObjectInspector<?> getLazyObjectInspector(
+      PrimitiveCategory primitiveCategory, boolean escaped, byte escapeChar) {
+    
+    switch(primitiveCategory) {
+    case BOOLEAN: return lazyBooleanObjectInspector;
+    case BYTE: return lazyByteObjectInspector;
+    case SHORT: return lazyShortObjectInspector;
+    case INT: return lazyIntObjectInspector;
+    case LONG: return lazyLongObjectInspector;
+    case FLOAT: return lazyFloatObjectInspector;
+    case DOUBLE: return lazyDoubleObjectInspector;
+    case STRING: return getLazyStringObjectInspector(escaped, escapeChar);
+    case VOID:
+      default:
+        throw new RuntimeException("Internal error: Cannot find ObjectInspector "
+            + " for " + primitiveCategory);
+    }
+  }
+  
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyShortObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyShortObjectInspector.java
new file mode 100644
index 0000000000..f89408ed2b
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyShortObjectInspector.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.io.ShortWritable;
+import org.apache.hadoop.hive.serde2.lazy.LazyShort;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.ShortObjectInspector;
+
+
+/**
+ * A WritableShortObjectInspector inspects a ShortWritable Object.
+ */
+public class LazyShortObjectInspector extends AbstractPrimitiveLazyObjectInspector<ShortWritable> 
+implements ShortObjectInspector{
+
+  LazyShortObjectInspector() {
+    super(PrimitiveObjectInspectorUtils.shortTypeEntry);
+  }
+  
+  @Override
+  public short get(Object o) {
+    return getPrimitiveWritableObject(o).get();
+  }
+
+  @Override
+  public Object copyObject(Object o) {
+    return o == null ? null : new LazyShort((LazyShort)o);
+  }
+
+  @Override
+  public Object getPrimitiveJavaObject(Object o) {
+    return o == null ? null : Short.valueOf(get(o));
+  }
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyStringObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyStringObjectInspector.java
new file mode 100644
index 0000000000..d03353d842
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyStringObjectInspector.java
@@ -0,0 +1,64 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.lazy.LazyString;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.StringObjectInspector;
+import org.apache.hadoop.io.Text;
+
+
+/**
+ * A WritableStringObjectInspector inspects a Text Object.
+ */
+public class LazyStringObjectInspector extends AbstractPrimitiveLazyObjectInspector<Text> 
+implements StringObjectInspector{
+
+  boolean escaped;
+  byte escapeChar;
+  
+  LazyStringObjectInspector(boolean escaped, byte escapeChar) {
+    super(PrimitiveObjectInspectorUtils.stringTypeEntry);
+    this.escaped = escaped;
+    this.escapeChar = escapeChar;
+  }
+
+  @Override
+  public Object copyObject(Object o) {
+    return o == null ? null : new LazyString((LazyString)o);
+  }
+
+  @Override
+  public Text getPrimitiveWritableObject(Object o) {
+    return o == null ? null : ((LazyString)o).getWritableObject();
+  }
+  
+  @Override
+  public String getPrimitiveJavaObject(Object o) {
+    return o == null ? null : ((LazyString)o).getWritableObject().toString();
+  }
+
+  public boolean isEscaped() {
+    return escaped;
+  }
+  public byte getEscapeChar() {
+    return escapeChar;
+  }
+  
+  
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyVoidObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyVoidObjectInspector.java
new file mode 100644
index 0000000000..960ee76729
--- /dev/null
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/lazy/objectinspector/primitive/LazyVoidObjectInspector.java
@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive;
+
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.VoidObjectInspector;
+import org.apache.hadoop.io.NullWritable;
+
+
+/**
+ * A WritableVoidObjectInspector inspects a NullWritable Object.
+ */
+public class LazyVoidObjectInspector extends AbstractPrimitiveLazyObjectInspector<NullWritable> 
+implements VoidObjectInspector{
+
+  LazyVoidObjectInspector() {
+    super(PrimitiveObjectInspectorUtils.voidTypeEntry);
+  }
+  
+  @Override
+  public Object copyObject(Object o) {
+    return o;
+  }
+
+  @Override
+  public Object getPrimitiveJavaObject(Object o) {
+    throw new RuntimeException("Internal error: cannot create Void object.");
+  }
+}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ColumnarStructObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ColumnarStructObjectInspector.java
index e6c206cb07..890cff0243 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ColumnarStructObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ColumnarStructObjectInspector.java
@@ -36,7 +36,7 @@
  * Always use the ObjectInspectorFactory to create new ObjectInspector objects,
  * instead of directly creating an instance of this class.
  */
-public class ColumnarStructObjectInspector implements StructObjectInspector {
+class ColumnarStructObjectInspector implements StructObjectInspector {
 
   public static final Log LOG = LogFactory
       .getLog(ColumnarStructObjectInspector.class.getName());
@@ -82,7 +82,7 @@ public String getTypeName() {
   /**
    * Call ObjectInspectorFactory.getLazySimpleStructObjectInspector instead.
    */
-  protected ColumnarStructObjectInspector(List<String> structFieldNames,
+  public ColumnarStructObjectInspector(List<String> structFieldNames,
       List<ObjectInspector> structFieldObjectInspectors, Text nullSequence) {
     init(structFieldNames, structFieldObjectInspectors, nullSequence);
   }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazyListObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazyListObjectInspector.java
index e1346f8e81..e69de29bb2 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazyListObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazyListObjectInspector.java
@@ -1,97 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.hadoop.hive.serde2.objectinspector;
-
-import java.util.List;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.hive.serde2.lazy.LazyArray;
-import org.apache.hadoop.io.Text;
-
-/**
- * LazyListObjectInspector works on array data that is stored in LazyArray.
- * 
- * Always use the ObjectInspectorFactory to create new ObjectInspector objects, instead
- * of directly creating an instance of this class.
- */
-public class LazyListObjectInspector implements ListObjectInspector {
-
-  public static final Log LOG = LogFactory.getLog(LazyListObjectInspector.class.getName());
-  
-  ObjectInspector listElementObjectInspector;
-  
-  byte separator;
-  Text nullSequence;
-  
-  /** Call ObjectInspectorFactory.getLazySimpleListObjectInspector instead.
-   */
-  protected LazyListObjectInspector(ObjectInspector listElementObjectInspector, 
-      byte separator, Text nullSequence) {
-    this.listElementObjectInspector = listElementObjectInspector;
-    this.separator = separator;
-    this.nullSequence = nullSequence;
-  }
-
-  @Override
-  public final Category getCategory() {
-    return Category.LIST;
-  }
-
-  // without data
-  @Override
-  public ObjectInspector getListElementObjectInspector() {
-    return listElementObjectInspector;
-  }
-  
-  // with data
-  @Override
-  public Object getListElement(Object data, int index) {
-    if (data == null) {
-      return null;
-    }
-    LazyArray array = (LazyArray) data;
-    return array.getListElementObject(index, separator, nullSequence);
-  }
-  
-  @Override
-  public int getListLength(Object data) {
-    if (data == null) {
-      return -1;
-    }
-    LazyArray array = (LazyArray) data;
-    return array.getListLength(separator, nullSequence);
-  }
-  
-  @Override
-  public List<?> getList(Object data) {
-    if (data == null) {
-      return null;
-    }
-    LazyArray array = (LazyArray) data;
-    return array.getList(separator, nullSequence);
-  }
-
-  @Override
-  public String getTypeName() {
-    return org.apache.hadoop.hive.serde.Constants.LIST_TYPE_NAME 
-        + "<" + listElementObjectInspector.getTypeName() + ">";
-  }
-
-}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazyMapObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazyMapObjectInspector.java
index e3688f3405..e69de29bb2 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazyMapObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazyMapObjectInspector.java
@@ -1,104 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.hadoop.hive.serde2.objectinspector;
-
-import java.util.Map;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.hive.serde2.lazy.LazyMap;
-import org.apache.hadoop.io.Text;
-
-/**
- * LazyMapObjectInspector works on struct data that is stored in LazyStruct.
- * 
- * Always use the ObjectInspectorFactory to create new ObjectInspector objects, instead
- * of directly creating an instance of this class.
- */
-public class LazyMapObjectInspector implements MapObjectInspector {
-
-  public static final Log LOG = LogFactory.getLog(LazyMapObjectInspector.class.getName());
-  
-  ObjectInspector mapKeyObjectInspector;
-  ObjectInspector mapValueObjectInspector;
-  
-  byte itemSeparator;
-  byte keyValueSeparator;  
-  Text nullSequence;
-  
-  /** Call ObjectInspectorFactory.getStandardListObjectInspector instead.
-   */
-  protected LazyMapObjectInspector(ObjectInspector mapKeyObjectInspector,
-      ObjectInspector mapValueObjectInspector,
-      byte itemSeparator, byte keyValueSeparator, Text nullSequence) {
-    this.mapKeyObjectInspector = mapKeyObjectInspector;
-    this.mapValueObjectInspector = mapValueObjectInspector;
-
-    this.itemSeparator = itemSeparator;
-    this.keyValueSeparator = keyValueSeparator;
-    this.nullSequence = nullSequence;
-  }
-
-  @Override
-  public final Category getCategory() {
-    return Category.MAP;
-  }
-
-  @Override
-  public String getTypeName() {
-    return org.apache.hadoop.hive.serde.Constants.MAP_TYPE_NAME 
-        + "<" + mapKeyObjectInspector.getTypeName() + "," 
-        + mapValueObjectInspector.getTypeName() + ">";
-  }
-
-  @Override
-  public ObjectInspector getMapKeyObjectInspector() {
-    return mapKeyObjectInspector;
-  }
-
-  @Override
-  public ObjectInspector getMapValueObjectInspector() {
-    return mapValueObjectInspector;
-  }
-
-  @Override
-  public Object getMapValueElement(Object data, Object key) {
-    if (data == null) {
-      return null;
-    }
-    return ((LazyMap)data).getMapValueElement(itemSeparator, keyValueSeparator, nullSequence, key);
-  }
-
-  @Override
-  public Map<?, ?> getMap(Object data) {
-    if (data == null) {
-      return null;
-    }
-    return ((LazyMap)data).getMap(itemSeparator, keyValueSeparator, nullSequence);
-  }
-
-  @Override
-  public int getMapSize(Object data) {
-    if (data == null) {
-      return -1;
-    }
-    return ((LazyMap)data).getMapSize(itemSeparator, keyValueSeparator, nullSequence);
-  }
-  
-}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazySimpleStructObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazySimpleStructObjectInspector.java
index 7cfac48a49..e69de29bb2 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazySimpleStructObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/LazySimpleStructObjectInspector.java
@@ -1,153 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.hadoop.hive.serde2.objectinspector;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.hadoop.hive.serde2.lazy.LazyStruct;
-import org.apache.hadoop.io.Text;
-
-/**
- * LazySimpleStructObjectInspector works on struct data that is stored in LazyStruct.
- * 
- * The names of the struct fields and the internal structure of the struct fields
- * are specified in the ctor of the LazySimpleStructObjectInspector.
- * 
- * Always use the ObjectInspectorFactory to create new ObjectInspector objects, instead
- * of directly creating an instance of this class.
- */
-public class LazySimpleStructObjectInspector implements StructObjectInspector {
-
-  public static final Log LOG = LogFactory.getLog(LazySimpleStructObjectInspector.class.getName());
-  
-  protected static class MyField implements StructField {
-    protected int fieldID;
-    protected String fieldName;
-    protected ObjectInspector fieldObjectInspector;
-    
-    public MyField(int fieldID, String fieldName, ObjectInspector fieldObjectInspector) {
-      this.fieldID = fieldID;
-      this.fieldName = fieldName.toLowerCase();
-      this.fieldObjectInspector = fieldObjectInspector;
-    }
-
-    public int getFieldID() {
-      return fieldID;
-    }
-    public String getFieldName() {
-      return fieldName;
-    }
-    public ObjectInspector getFieldObjectInspector() {
-      return fieldObjectInspector;
-    }
-    
-    public String toString() {
-      return "" + fieldID + ":" + fieldName;
-    }
-  }
-  
-  protected List<MyField> fields;
-  
-  @Override
-  public String getTypeName() {
-    return ObjectInspectorUtils.getStandardStructTypeName(this);
-  }
-  
-  
-  byte separator;
-  Text nullSequence;  
-  boolean lastColumnTakesRest;
-  
-  /** Call ObjectInspectorFactory.getLazySimpleStructObjectInspector instead.
-   */
-  protected LazySimpleStructObjectInspector(List<String> structFieldNames, List<ObjectInspector> structFieldObjectInspectors,
-      byte separator, Text nullSequence, boolean lastColumnTakesRest) {
-    init(structFieldNames, structFieldObjectInspectors, separator, nullSequence, lastColumnTakesRest);
-  }
-  protected void init(List<String> structFieldNames, List<ObjectInspector> structFieldObjectInspectors,
-      byte separator, Text nullSequence, boolean lastColumnTakesRest) {
-    assert(structFieldNames.size() == structFieldObjectInspectors.size());
-    
-    this.separator = separator;
-    this.nullSequence = nullSequence;
-    this.lastColumnTakesRest = lastColumnTakesRest;
-    
-    fields = new ArrayList<MyField>(structFieldNames.size()); 
-    for(int i=0; i<structFieldNames.size(); i++) {
-      fields.add(new MyField(i, structFieldNames.get(i), structFieldObjectInspectors.get(i)));
-    }
-  }
-  
-  protected LazySimpleStructObjectInspector(List<StructField> fields, byte separator, Text nullSequence) {
-    init(fields, separator, nullSequence);
-  }
-  protected void init(List<StructField> fields, byte separator, Text nullSequence) {
-    this.separator = separator;
-    this.nullSequence = nullSequence;
-    
-    this.fields = new ArrayList<MyField>(fields.size()); 
-    for(int i=0; i<fields.size(); i++) {
-      this.fields.add(new MyField(i, fields.get(i).getFieldName(), fields.get(i).getFieldObjectInspector()));
-    }
-  }
-
-  
-  @Override
-  public final Category getCategory() {
-    return Category.STRUCT;
-  }
-
-  // Without Data
-  @Override
-  public StructField getStructFieldRef(String fieldName) {
-    return ObjectInspectorUtils.getStandardStructFieldRef(fieldName, fields);
-  }
-  @Override
-  public List<? extends StructField> getAllStructFieldRefs() {
-    return fields;
-  }
-
-  // With Data
-  @Override
-  public Object getStructFieldData(Object data, StructField fieldRef) {
-    if (data == null) {
-      return null;
-    }
-    LazyStruct struct = (LazyStruct)data;
-    MyField f = (MyField) fieldRef;
-    
-    int fieldID = f.getFieldID();
-    assert(fieldID >= 0 && fieldID < fields.size());
-    
-    return struct.getField(fieldID, separator, nullSequence, lastColumnTakesRest);
-  }
-
-  @Override
-  public List<Object> getStructFieldsDataAsList(Object data) {
-    if (data == null) {
-      return null;
-    }
-    LazyStruct struct = (LazyStruct)data;
-    return struct.getFieldsAsList(separator, nullSequence, lastColumnTakesRest);
-  }
-
-}
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorFactory.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorFactory.java
index 87d3f37ca0..dc13fbe1b2 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorFactory.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorFactory.java
@@ -27,10 +27,8 @@
 import java.util.List;
 import java.util.Map;
 
-import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector.PrimitiveCategory;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
-import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableBooleanObjectInspector;
 import org.apache.hadoop.io.Text;
 
 
@@ -192,60 +190,6 @@ public static StandardStructObjectInspector getStandardStructObjectInspector(Lis
     return result;
   }
 
-  static HashMap<ArrayList<Object>, LazySimpleStructObjectInspector> cachedLazySimpleStructObjectInspector =
-    new HashMap<ArrayList<Object>, LazySimpleStructObjectInspector>(); 
-  public static LazySimpleStructObjectInspector getLazySimpleStructObjectInspector(List<String> structFieldNames, 
-      List<ObjectInspector> structFieldObjectInspectors, byte separator, Text nullSequence,
-      boolean lastColumnTakesRest) {
-    ArrayList<Object> signature = new ArrayList<Object>();
-    signature.add(structFieldNames);
-    signature.add(structFieldObjectInspectors);
-    signature.add(Byte.valueOf(separator));
-    signature.add(nullSequence.toString());
-    signature.add(Boolean.valueOf(lastColumnTakesRest));
-    LazySimpleStructObjectInspector result = cachedLazySimpleStructObjectInspector.get(signature);
-    if (result == null) {
-      result = new LazySimpleStructObjectInspector(structFieldNames, structFieldObjectInspectors, 
-          separator, nullSequence, lastColumnTakesRest);
-      cachedLazySimpleStructObjectInspector.put(signature, result);
-    }
-    return result;
-  }
-
-  static HashMap<ArrayList<Object>, LazyListObjectInspector> cachedLazySimpleListObjectInspector =
-    new HashMap<ArrayList<Object>, LazyListObjectInspector>(); 
-  public static LazyListObjectInspector getLazySimpleListObjectInspector( 
-      ObjectInspector listElementObjectInspector, byte separator, Text nullSequence) {
-    ArrayList<Object> signature = new ArrayList<Object>();
-    signature.add(listElementObjectInspector);
-    signature.add(Byte.valueOf(separator));
-    signature.add(nullSequence.toString());
-    LazyListObjectInspector result = cachedLazySimpleListObjectInspector.get(signature);
-    if (result == null) {
-      result = new LazyListObjectInspector(listElementObjectInspector, 
-          separator, nullSequence);
-      cachedLazySimpleListObjectInspector.put(signature, result);
-    }
-    return result;
-  }
-  
-  static HashMap<ArrayList<Object>, LazyMapObjectInspector> cachedLazySimpleMapObjectInspector =
-    new HashMap<ArrayList<Object>, LazyMapObjectInspector>(); 
-  public static LazyMapObjectInspector getLazySimpleMapObjectInspector( 
-      ObjectInspector mapKeyObjectInspector, ObjectInspector mapValueObjectInspector, 
-      byte itemSeparator, byte keyValueSeparator, Text nullSequence) {
-    ArrayList<Object> signature = new ArrayList<Object>();
-    signature.add(mapKeyObjectInspector);
-    signature.add(mapValueObjectInspector);
-    signature.add(nullSequence.toString());
-    LazyMapObjectInspector result = cachedLazySimpleMapObjectInspector.get(signature);
-    if (result == null) {
-      result = new LazyMapObjectInspector(mapKeyObjectInspector,
-          mapValueObjectInspector, itemSeparator, keyValueSeparator, nullSequence);
-      cachedLazySimpleMapObjectInspector.put(signature, result);
-    }
-    return result;
-  }
   
   static HashMap<List<StructObjectInspector>, UnionStructObjectInspector> cachedUnionStructObjectInspector =
     new HashMap<List<StructObjectInspector>, UnionStructObjectInspector>(); 
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorUtils.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorUtils.java
index 3acc95ec6c..d5bea07b6d 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorUtils.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspectorUtils.java
@@ -83,13 +83,13 @@ public static String getIntegerCSV(int size) {
   /**
    * This enum controls how we copy primitive objects.
    * 
-   * KEEP means keeping the original format of the primitive object. This is usually the most efficient. 
+   * DEFAULT means choosing the most efficient way between JAVA and WRITABLE. 
    * JAVA means converting all primitive objects to java primitive objects.
    * WRITABLE means converting all primitive objects to writable objects. 
    *
    */
   public enum ObjectInspectorCopyOption {
-    KEEP,
+    DEFAULT,
     JAVA,
     WRITABLE
   }
@@ -100,7 +100,7 @@ public enum ObjectInspectorCopyOption {
    * The returned ObjectInspector can be used to inspect the standard object.
    */
   public static ObjectInspector getStandardObjectInspector(ObjectInspector oi) {
-    return getStandardObjectInspector(oi, ObjectInspectorCopyOption.KEEP);
+    return getStandardObjectInspector(oi, ObjectInspectorCopyOption.DEFAULT);
   }
   
   public static ObjectInspector getStandardObjectInspector(ObjectInspector oi, ObjectInspectorCopyOption objectInspectorOption) {
@@ -109,8 +109,12 @@ public static ObjectInspector getStandardObjectInspector(ObjectInspector oi, Obj
       case PRIMITIVE: {
         PrimitiveObjectInspector poi = (PrimitiveObjectInspector)oi;
         switch (objectInspectorOption) {
-          case KEEP: {
-            result = poi;
+          case DEFAULT: {
+            if (poi.preferWritable()) {
+              result = PrimitiveObjectInspectorFactory.getPrimitiveWritableObjectInspector(poi.getPrimitiveCategory());
+            } else {
+              result = PrimitiveObjectInspectorFactory.getPrimitiveJavaObjectInspector(poi.getPrimitiveCategory());
+            }
             break;
           }
           case JAVA: {
@@ -161,7 +165,7 @@ public static ObjectInspector getStandardObjectInspector(ObjectInspector oi, Obj
    * StandardObjectInspector returned by getStandardObjectInspector(oi).
    */
   public static Object copyToStandardObject(Object o, ObjectInspector oi) {
-    return copyToStandardObject(o, oi, ObjectInspectorCopyOption.KEEP);
+    return copyToStandardObject(o, oi, ObjectInspectorCopyOption.DEFAULT);
   }
   
   public static Object copyToStandardObject(Object o, ObjectInspector oi, ObjectInspectorCopyOption objectInspectorOption) {
@@ -174,8 +178,12 @@ public static Object copyToStandardObject(Object o, ObjectInspector oi, ObjectIn
       case PRIMITIVE: {
         PrimitiveObjectInspector loi = (PrimitiveObjectInspector)oi;
         switch (objectInspectorOption) {
-          case KEEP: {
-            result = loi.copyObject(o);
+          case DEFAULT: {
+            if (loi.preferWritable()) {
+              result = loi.getPrimitiveWritableObject(loi.copyObject(o));
+            } else {
+              result = loi.getPrimitiveJavaObject(o);
+            }
             break;
           }
           case JAVA: {
@@ -351,5 +359,116 @@ public static int hashCode(Object o, ObjectInspector objIns) {
         throw new RuntimeException("Hash code on complex types not supported yet.");
     }
   }
+
+  public static int compare(Object o1, ObjectInspector oi1, Object o2, ObjectInspector oi2) {
+    if (oi1.getCategory() != oi2.getCategory()) {
+      return oi1.getCategory().compareTo(oi2.getCategory());
+    }
+
+    if (o1 == null) {
+      return o2 == null ? 0 : -1;
+    } else if (o2 == null) {
+      return 1;
+    }
+    
+    switch (oi1.getCategory()) {
+      case PRIMITIVE: {
+        PrimitiveObjectInspector poi1 = ((PrimitiveObjectInspector)oi1);
+        PrimitiveObjectInspector poi2 = ((PrimitiveObjectInspector)oi2);
+        if (poi1.getPrimitiveCategory() != poi2.getPrimitiveCategory()) {
+          return poi1.getPrimitiveCategory().compareTo(poi2.getPrimitiveCategory());
+        }
+        switch (poi1.getPrimitiveCategory()) {
+          case VOID: return 0;
+          case BOOLEAN: {
+            int v1 = ((BooleanObjectInspector)poi1).get(o1) ? 1 : 0;
+            int v2 = ((BooleanObjectInspector)poi2).get(o2) ? 1 : 0;
+            return v1 - v2;
+          }
+          case BYTE: {
+            int v1 = ((ByteObjectInspector)poi1).get(o1);
+            int v2 = ((ByteObjectInspector)poi2).get(o2);
+            return v1 - v2;
+          }
+          case SHORT: {
+            int v1 = ((ShortObjectInspector)poi1).get(o1);
+            int v2 = ((ShortObjectInspector)poi2).get(o2);
+            return v1 - v2;
+          }
+          case INT: {
+            int v1 = ((IntObjectInspector)poi1).get(o1);
+            int v2 = ((IntObjectInspector)poi2).get(o2);
+            return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
+          }
+          case LONG: {
+            long v1 = ((LongObjectInspector)poi1).get(o1);
+            long v2 = ((LongObjectInspector)poi2).get(o2);
+            return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
+          }
+          case FLOAT: {
+            float v1 = ((FloatObjectInspector)poi1).get(o1);
+            float v2 = ((FloatObjectInspector)poi2).get(o2);
+            return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
+          }
+          case DOUBLE: {
+            double v1 = ((DoubleObjectInspector)poi1).get(o1);
+            double v2 = ((DoubleObjectInspector)poi2).get(o2);
+            return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
+          }
+          case STRING: {
+            if (poi1.preferWritable() || poi2.preferWritable()) {
+              Text t1 = (Text)poi1.getPrimitiveWritableObject(o1);
+              Text t2 = (Text)poi2.getPrimitiveWritableObject(o2);
+              return t1 == null
+                     ? (t2 == null ? 0 : -1)
+                     : (t2 == null ? 1 : t1.compareTo(t2));
+            } else {
+              String s1 = (String)poi1.getPrimitiveJavaObject(o1);
+              String s2 = (String)poi2.getPrimitiveJavaObject(o2);
+              return s1 == null
+                     ? (s2 == null ? 0 : -1)
+                     : (s2 == null ? 1 : s1.compareTo(s2));
+            }
+          }
+          default: {
+            throw new RuntimeException("Unknown type: " + poi1.getPrimitiveCategory());
+          }
+        }
+      }
+      case STRUCT: {
+        StructObjectInspector soi1 = (StructObjectInspector)oi1;
+        StructObjectInspector soi2 = (StructObjectInspector)oi2;
+        List<? extends StructField> fields1 = soi1.getAllStructFieldRefs();
+        List<? extends StructField> fields2 = soi2.getAllStructFieldRefs();
+        int minimum = Math.min(fields1.size(), fields2.size());
+        for (int i=0; i<minimum; i++) {
+          int r = compare(
+              soi1.getStructFieldData(o1, fields1.get(i)),
+              fields1.get(i).getFieldObjectInspector(),
+              soi2.getStructFieldData(o2, fields2.get(i)),
+              fields2.get(i).getFieldObjectInspector());
+          if (r != 0) return r;
+        }
+        return fields1.size() - fields2.size();
+      }
+      case LIST: {
+        ListObjectInspector loi1 = (ListObjectInspector)oi1;
+        ListObjectInspector loi2 = (ListObjectInspector)oi2;
+        int minimum = Math.min(loi1.getListLength(o1), loi1.getListLength(o2));
+        for (int i=0; i<minimum; i++) {
+          int r = compare(
+              loi1.getListElement(o1, i),
+              loi1.getListElementObjectInspector(),
+              loi2.getListElement(o2, i),
+              loi2.getListElementObjectInspector());
+          if (r != 0) return r;
+        }
+        return loi1.getListLength(o1) - loi1.getListLength(o2);
+      }
+      case MAP:
+      default:  
+        throw new RuntimeException("Hash code on map type not supported yet.");
+    }
+  }
   
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/PrimitiveObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/PrimitiveObjectInspector.java
index 891041dd2c..e3867d20d1 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/PrimitiveObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/PrimitiveObjectInspector.java
@@ -69,5 +69,5 @@ public static enum PrimitiveCategory {
    * This can be useful for determining the most efficient way to getting
    * data out of the Object. 
    */
-  public boolean isWritable();
+  public boolean preferWritable();
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/AbstractPrimitiveJavaObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/AbstractPrimitiveJavaObjectInspector.java
index 34a53e7dbb..fa61a05957 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/AbstractPrimitiveJavaObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/AbstractPrimitiveJavaObjectInspector.java
@@ -39,7 +39,7 @@ public Object copyObject(Object o) {
   }
   
   @Override
-  public boolean isWritable() {
+  public boolean preferWritable() {
     return false;
   }
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/AbstractPrimitiveWritableObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/AbstractPrimitiveWritableObjectInspector.java
index 5d745fb871..b6d62c0754 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/AbstractPrimitiveWritableObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/AbstractPrimitiveWritableObjectInspector.java
@@ -34,7 +34,7 @@ public Object getPrimitiveWritableObject(Object o) {
   }
 
   @Override
-  public boolean isWritable() {
+  public boolean preferWritable() {
     return true;
   }
   
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/JavaStringObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/JavaStringObjectInspector.java
index d7a97c8580..5c0af431e1 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/JavaStringObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/JavaStringObjectInspector.java
@@ -39,5 +39,4 @@ public Text getPrimitiveWritableObject(Object o) {
   public String getPrimitiveJavaObject(Object o) {
     return (String)o;
   }
-
 }
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorUtils.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorUtils.java
index a4e7a875d5..f876b453cb 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorUtils.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/PrimitiveObjectInspectorUtils.java
@@ -382,7 +382,7 @@ public static int getInt(Object o, PrimitiveObjectInspector oi) throws NumberFor
       }
       case STRING: {
         StringObjectInspector soi = (StringObjectInspector)oi;
-        if (soi.isWritable()) {
+        if (soi.preferWritable()) {
           Text t = soi.getPrimitiveWritableObject(o);
           result = LazyInteger.parseInt(t.getBytes(), 0, t.getLength());
         } else {
diff --git a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableStringObjectInspector.java b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableStringObjectInspector.java
index 3da6875fe8..62a63bdf3e 100644
--- a/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableStringObjectInspector.java
+++ b/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/primitive/WritableStringObjectInspector.java
@@ -32,7 +32,7 @@ public class WritableStringObjectInspector extends AbstractPrimitiveWritableObje
 
   @Override
   public Object copyObject(Object o) {
-    return new Text((Text)o);
+    return o == null ? null : new Text((Text)o);
   }
 
   @Override
diff --git a/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazyArrayMapStruct.java b/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazyArrayMapStruct.java
index eea4430119..75c9c90ea3 100644
--- a/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazyArrayMapStruct.java
+++ b/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazyArrayMapStruct.java
@@ -21,12 +21,14 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Map;
 
 import org.apache.hadoop.hive.serde2.SerDeUtils;
 import org.apache.hadoop.hive.serde2.io.ByteWritable;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazyObjectInspectorFactory;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
 import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
-import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;
 import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoUtils;
 import org.apache.hadoop.io.IntWritable;
 import org.apache.hadoop.io.Text;
@@ -43,33 +45,44 @@ public void testLazyArray() throws Throwable {
     try {
       // Array of Byte
       Text nullSequence = new Text("\\N");
-      LazyArray b = (LazyArray)LazyFactory.createLazyObject(TypeInfoUtils.getTypeInfoFromTypeString("array<tinyint>"));
+      ObjectInspector oi = LazyFactory.createLazyObjectInspector(
+          TypeInfoUtils.getTypeInfosFromTypeString("array<tinyint>").get(0), 
+          new byte[]{(byte)1}, 0, nullSequence, false, (byte)0);
+      LazyArray b = (LazyArray)LazyFactory.createLazyObject(oi);
       byte[] data = new byte[]{'-', '1', 1, '\\', 'N', 1, '8'};
       TestLazyPrimitive.initLazyObject(b, data, 0, data.length);
       
-      assertNull(b.getListElementObject(-1, (byte)1, nullSequence));
-      assertEquals(new ByteWritable((byte)-1), b.getListElementObject(0, (byte)1, nullSequence));
-      assertNull(b.getListElementObject(1, (byte)1, nullSequence));
-      assertEquals(new ByteWritable((byte)8), b.getListElementObject(2, (byte)1, nullSequence));
-      assertNull(b.getListElementObject(3, (byte)1, nullSequence));
-      assertEquals(
-          Arrays.asList(new ByteWritable[]{new ByteWritable((byte)-1), null, new ByteWritable((byte)8)}),
-          b.getList((byte)1, nullSequence));
+      assertNull(b.getListElementObject(-1));
+      assertEquals(new ByteWritable((byte)-1), ((LazyByte)b.getListElementObject(0)).getWritableObject());
+      assertEquals(new ByteWritable((byte)-1), ((LazyByte)b.getList().get(0)).getWritableObject());
+      assertNull(b.getListElementObject(1));
+      assertNull(b.getList().get(1));
+      assertEquals(new ByteWritable((byte)8), ((LazyByte)b.getListElementObject(2)).getWritableObject());
+      assertEquals(new ByteWritable((byte)8), ((LazyByte)b.getList().get(2)).getWritableObject());
+      assertNull(b.getListElementObject(3));
+      assertEquals(3, b.getList().size());
       
       // Array of String
-      b = (LazyArray)LazyFactory.createLazyObject(TypeInfoUtils.getTypeInfoFromTypeString("array<string>"));
+      oi = LazyFactory.createLazyObjectInspector(
+          TypeInfoUtils.getTypeInfosFromTypeString("array<string>").get(0), 
+          new byte[]{(byte)'\t'}, 0, nullSequence, false, (byte)0);
+      b = (LazyArray)LazyFactory.createLazyObject(oi);
       data = new byte[]{'a', 'b', '\t', 'c', '\t', '\\', 'N', '\t', '\t', 'd'};
       // Note: the first and last element of the byte[] are NOT used
       TestLazyPrimitive.initLazyObject(b, data, 1, data.length - 2);
-      assertNull(b.getListElementObject(-1, (byte)'\t', nullSequence));
-      assertEquals(new Text("b"), b.getListElementObject(0, (byte)'\t', nullSequence));
-      assertEquals(new Text("c"), b.getListElementObject(1, (byte)'\t', nullSequence));
-      assertNull(b.getListElementObject(2, (byte)'\t', nullSequence));
-      assertEquals(new Text(""), b.getListElementObject(3, (byte)'\t', nullSequence));
-      assertEquals(new Text(""), b.getListElementObject(4, (byte)'\t', nullSequence));
-      assertNull(b.getListElementObject(5, (byte)'\t', nullSequence));
-      assertEquals(Arrays.asList(new Text[]{new Text("b"), new Text("c"), null, new Text(""), new Text("")}),
-          b.getList((byte)'\t', nullSequence));
+      assertNull(b.getListElementObject(-1));
+      assertEquals(new Text("b"), ((LazyString)b.getListElementObject(0)).getWritableObject());
+      assertEquals(new Text("b"), ((LazyString)b.getList().get(0)).getWritableObject());
+      assertEquals(new Text("c"), ((LazyString)b.getListElementObject(1)).getWritableObject());
+      assertEquals(new Text("c"), ((LazyString)b.getList().get(1)).getWritableObject());
+      assertNull(((LazyString)b.getListElementObject(2)));
+      assertNull(((LazyString)b.getList().get(2)));
+      assertEquals(new Text(""), ((LazyString)b.getListElementObject(3)).getWritableObject());
+      assertEquals(new Text(""), ((LazyString)b.getList().get(3)).getWritableObject());
+      assertEquals(new Text(""), ((LazyString)b.getListElementObject(4)).getWritableObject());
+      assertEquals(new Text(""), ((LazyString)b.getList().get(4)).getWritableObject());
+      assertNull(((LazyString)b.getListElementObject(5)));
+      assertEquals(5, b.getList().size());
       
     } catch (Throwable e) {
       e.printStackTrace();
@@ -85,43 +98,41 @@ public void testLazyMap() throws Throwable {
       {
         // Map of Integer to String
         Text nullSequence = new Text("\\N");
-        LazyMap b = (LazyMap)LazyFactory.createLazyObject(TypeInfoUtils.getTypeInfoFromTypeString("map<int,string>"));
+        ObjectInspector oi = LazyFactory.createLazyObjectInspector(
+            TypeInfoUtils.getTypeInfosFromTypeString("map<int,string>").get(0), 
+            new byte[]{(byte)1, (byte)2}, 0, nullSequence, false, (byte)0);
+        LazyMap b = (LazyMap)LazyFactory.createLazyObject(oi);
         byte[] data = new byte[]{'2', 2, 'd', 'e', 'f', 1, '-', '1', 2, '\\', 'N', 1, '0', 2, '0', 1, '8', 2, 'a', 'b', 'c'};
         TestLazyPrimitive.initLazyObject(b, data, 0, data.length);
         
-        assertEquals(new Text("def"), b.getMapValueElement((byte)1, (byte)2, nullSequence, new IntWritable(2)));
-        assertNull(b.getMapValueElement((byte)1, (byte)2, nullSequence, Integer.valueOf(-1)));
-        assertEquals(new Text("0"), b.getMapValueElement((byte)1, (byte)2, nullSequence, new IntWritable(0)));
-        assertEquals(new Text("abc"), b.getMapValueElement((byte)1, (byte)2, nullSequence, new IntWritable(8)));
-        assertNull(b.getMapValueElement((byte)1, (byte)2, nullSequence, new IntWritable(12345)));
+        assertEquals(new Text("def"), ((LazyString)b.getMapValueElement(new IntWritable(2))).getWritableObject());
+        assertNull(b.getMapValueElement(new IntWritable(-1)));
+        assertEquals(new Text("0"), ((LazyString)b.getMapValueElement(new IntWritable(0))).getWritableObject());
+        assertEquals(new Text("abc"), ((LazyString)b.getMapValueElement(new IntWritable(8))).getWritableObject());
+        assertNull(b.getMapValueElement(new IntWritable(12345)));
         
-        HashMap<IntWritable, Text> r = new HashMap<IntWritable, Text>();
-        r.put(new IntWritable(2), new Text("def"));
-        r.put(new IntWritable(-1), null);
-        r.put(new IntWritable(0), new Text("0"));
-        r.put(new IntWritable(8), new Text("abc"));
-        assertEquals(r, b.getMap((byte)1, (byte)2, nullSequence));
+        assertEquals("{2:'def',-1:null,0:'0',8:'abc'}".replace('\'', '\"'),
+            SerDeUtils.getJSONString(b, oi));
       }
       
       {
         // Map of String to String
         Text nullSequence = new Text("\\N");
-        LazyMap b = (LazyMap)LazyFactory.createLazyObject(TypeInfoUtils.getTypeInfoFromTypeString("map<string,string>"));
+        ObjectInspector oi = LazyFactory.createLazyObjectInspector(
+            TypeInfoUtils.getTypeInfosFromTypeString("map<string,string>").get(0), 
+            new byte[]{(byte)'#', (byte)'\t'}, 0, nullSequence, false, (byte)0);
+        LazyMap b = (LazyMap)LazyFactory.createLazyObject(oi);
         byte[] data = new byte[]{'2', '\t', 'd', '\t', 'f', '#', '2', '\t', 'd', '#', '-', '1', '#', '0', '\t', '0', '#', '8', '\t', 'a', 'b', 'c'};
         TestLazyPrimitive.initLazyObject(b, data, 0, data.length);
         
-        assertEquals(new Text("d\tf"), b.getMapValueElement((byte)'#', (byte)'\t', nullSequence, new Text("2")));
-        assertNull(b.getMapValueElement((byte)'#', (byte)'\t', nullSequence, new Text("-1")));
-        assertEquals(new Text("0"), b.getMapValueElement((byte)'#', (byte)'\t', nullSequence, new Text("0")));
-        assertEquals(new Text("abc"), b.getMapValueElement((byte)'#', (byte)'\t', nullSequence, new Text("8")));
-        assertNull(b.getMapValueElement((byte)'#', (byte)'\t', nullSequence, new Text("-")));
+        assertEquals(new Text("d\tf"), ((LazyString)b.getMapValueElement(new Text("2"))).getWritableObject());
+        assertNull(b.getMapValueElement(new Text("-1")));
+        assertEquals(new Text("0"), ((LazyString)b.getMapValueElement(new Text("0"))).getWritableObject());
+        assertEquals(new Text("abc"), ((LazyString)b.getMapValueElement(new Text("8"))).getWritableObject());
+        assertNull(b.getMapValueElement(new Text("-")));
         
-        HashMap<Text,Text> r = new HashMap<Text, Text>();
-        r.put(new Text("2"), new Text("d\tf"));
-        r.put(new Text("-1"), null);
-        r.put(new Text("0"), new Text("0"));
-        r.put(new Text("8"), new Text("abc"));
-        assertEquals(r, b.getMap((byte)1, (byte)2, nullSequence));
+        assertEquals("{'2':'d\\tf','2':'d','-1':null,'0':'0','8':'abc'}".replace('\'', '\"'),
+            SerDeUtils.getJSONString(b, oi));
       }
       
     } catch (Throwable e) {
@@ -139,13 +150,11 @@ public void testLazyStruct() throws Throwable {
         ArrayList<TypeInfo> fieldTypeInfos = 
           TypeInfoUtils.getTypeInfosFromTypeString("int,array<string>,map<string,string>,string");
         List<String> fieldNames = Arrays.asList(new String[]{"a", "b", "c", "d"});
-        TypeInfo rowTypeInfo = TypeInfoFactory.getStructTypeInfo(fieldNames, fieldTypeInfos);
-        
         Text nullSequence = new Text("\\N");
         
-        LazyStruct o = (LazyStruct)LazyFactory.createLazyObject(rowTypeInfo);
-        ObjectInspector oi = LazyFactory.createLazyStructInspector(Arrays.asList(new String[]{"a","b","c","d"}),
-            fieldTypeInfos, new byte[] {' ', ':', '='}, nullSequence, false);
+        ObjectInspector oi = LazyFactory.createLazyStructInspector(fieldNames,
+            fieldTypeInfos, new byte[] {' ', ':', '='}, nullSequence, false, false, (byte)0);
+        LazyStruct o = (LazyStruct)LazyFactory.createLazyObject(oi);
         
         Text data;
         
@@ -176,7 +185,7 @@ public void testLazyStruct() throws Throwable {
 
         data = new Text(": : : :");
         TestLazyPrimitive.initLazyObject(o, data.getBytes(), 0, data.getLength());
-        assertEquals("{'a':null,'b':['',''],'c':{'':null},'d':':'}".replace("'", "\""),
+        assertEquals("{'a':null,'b':['',''],'c':{'':null,'':null},'d':':'}".replace("'", "\""),
             SerDeUtils.getJSONString(o, oi));
 
         data = new Text("= = = =");
@@ -186,7 +195,8 @@ public void testLazyStruct() throws Throwable {
         
         // test LastColumnTakesRest
         oi = LazyFactory.createLazyStructInspector(Arrays.asList(new String[]{"a","b","c","d"}),
-            fieldTypeInfos, new byte[] {' ', ':', '='}, nullSequence, true);
+            fieldTypeInfos, new byte[] {' ', ':', '='}, nullSequence, true, false, (byte)0);
+        o = (LazyStruct)LazyFactory.createLazyObject(oi);
         data = new Text("\\N a d=\\N:f=g:h has tail");
         TestLazyPrimitive.initLazyObject(o, data.getBytes(), 0, data.getLength());
         assertEquals("{'a':null,'b':['a'],'c':{'d':null,'f':'g','h':null},'d':'has tail'}".replace("'", "\""),
diff --git a/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazyPrimitive.java b/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazyPrimitive.java
index dd893733cd..f47db6be21 100644
--- a/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazyPrimitive.java
+++ b/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazyPrimitive.java
@@ -22,6 +22,9 @@
 import org.apache.hadoop.hive.serde2.io.ByteWritable;
 import org.apache.hadoop.hive.serde2.io.DoubleWritable;
 import org.apache.hadoop.hive.serde2.io.ShortWritable;
+import org.apache.hadoop.hive.serde2.lazy.objectinspector.primitive.LazyPrimitiveObjectInspectorFactory;
+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
 import org.apache.hadoop.io.IntWritable;
 import org.apache.hadoop.io.LongWritable;
 import org.apache.hadoop.io.Text;
@@ -43,36 +46,36 @@ public static void initLazyObject(LazyObject lo, byte[] data, int start, int len
    */
   public void testLazyByte() throws Throwable {
     try {
-      LazyByte b = new LazyByte();
+      LazyByte b = new LazyByte(LazyPrimitiveObjectInspectorFactory.lazyByteObjectInspector);
       initLazyObject(b,new byte[]{'0'}, 0, 0);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'0'}, 0, 1);
-      assertEquals(new ByteWritable((byte)0), b.getObject());
+      assertEquals(new ByteWritable((byte)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '0'}, 0, 2);
-      assertEquals(new ByteWritable((byte)0), b.getObject());
+      assertEquals(new ByteWritable((byte)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '0'}, 0, 2);
-      assertEquals(new ByteWritable((byte)0), b.getObject());
+      assertEquals(new ByteWritable((byte)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 1);
-      assertEquals(new ByteWritable((byte)1), b.getObject());
+      assertEquals(new ByteWritable((byte)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '-', '1'}, 1, 2);
-      assertEquals(new ByteWritable((byte)-1), b.getObject());
+      assertEquals(new ByteWritable((byte)-1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '+', '1'}, 1, 2);
-      assertEquals(new ByteWritable((byte)1), b.getObject());
+      assertEquals(new ByteWritable((byte)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '8'}, 0, 4);
-      assertEquals(new ByteWritable((byte)-128), b.getObject());
+      assertEquals(new ByteWritable((byte)-128), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '7'}, 0, 4);
-      assertEquals(new ByteWritable((byte)127), b.getObject());
+      assertEquals(new ByteWritable((byte)127), b.getWritableObject());
       
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 2);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '8'}, 0, 4);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '9'}, 0, 4);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
      
     } catch (Throwable e) {
       e.printStackTrace();
@@ -85,40 +88,40 @@ public void testLazyByte() throws Throwable {
    */
   public void testLazyShort() throws Throwable {
     try {
-      LazyShort b = new LazyShort();
+      LazyShort b = new LazyShort(LazyPrimitiveObjectInspectorFactory.lazyShortObjectInspector);
       initLazyObject(b,new byte[]{'0'}, 0, 0);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'0'}, 0, 1);
-      assertEquals(new ShortWritable((short)0), b.getObject());
+      assertEquals(new ShortWritable((short)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '0'}, 0, 2);
-      assertEquals(new ShortWritable((short)0), b.getObject());
+      assertEquals(new ShortWritable((short)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '0'}, 0, 2);
-      assertEquals(new ShortWritable((short)0), b.getObject());
+      assertEquals(new ShortWritable((short)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 1);
-      assertEquals(new ShortWritable((short)1), b.getObject());
+      assertEquals(new ShortWritable((short)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '-', '1'}, 1, 2);
-      assertEquals(new ShortWritable((short)-1), b.getObject());
+      assertEquals(new ShortWritable((short)-1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '+', '1'}, 1, 2);
-      assertEquals(new ShortWritable((short)1), b.getObject());
+      assertEquals(new ShortWritable((short)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '8'}, 0, 4);
-      assertEquals(new ShortWritable((short)-128), b.getObject());
+      assertEquals(new ShortWritable((short)-128), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '7'}, 0, 4);
-      assertEquals(new ShortWritable((short)127), b.getObject());
+      assertEquals(new ShortWritable((short)127), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '3', '2', '7', '6', '8'}, 0, 6);
-      assertEquals(new ShortWritable((short)-32768), b.getObject());
+      assertEquals(new ShortWritable((short)-32768), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '3', '2', '7', '6', '7'}, 0, 6);
-      assertEquals(new ShortWritable((short)32767), b.getObject());
+      assertEquals(new ShortWritable((short)32767), b.getWritableObject());
 
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 2);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '3', '2', '7', '6', '9'}, 0, 6);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '3', '2', '7', '6', '8'}, 0, 6);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
 
     } catch (Throwable e) {
       e.printStackTrace();
@@ -132,44 +135,44 @@ public void testLazyShort() throws Throwable {
    */
   public void testLazyInteger() throws Throwable {
     try {
-      LazyInteger b = new LazyInteger();
+      LazyInteger b = new LazyInteger(LazyPrimitiveObjectInspectorFactory.lazyIntObjectInspector);
       initLazyObject(b,new byte[]{'0'}, 0, 0);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'0'}, 0, 1);
-      assertEquals(new IntWritable((int)0), b.getObject());
+      assertEquals(new IntWritable((int)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '0'}, 0, 2);
-      assertEquals(new IntWritable((int)0), b.getObject());
+      assertEquals(new IntWritable((int)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '0'}, 0, 2);
-      assertEquals(new IntWritable((int)0), b.getObject());
+      assertEquals(new IntWritable((int)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 1);
-      assertEquals(new IntWritable((int)1), b.getObject());
+      assertEquals(new IntWritable((int)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '-', '1'}, 1, 2);
-      assertEquals(new IntWritable((int)-1), b.getObject());
+      assertEquals(new IntWritable((int)-1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '+', '1'}, 1, 2);
-      assertEquals(new IntWritable((int)1), b.getObject());
+      assertEquals(new IntWritable((int)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '8'}, 0, 4);
-      assertEquals(new IntWritable((int)-128), b.getObject());
+      assertEquals(new IntWritable((int)-128), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '7'}, 0, 4);
-      assertEquals(new IntWritable((int)127), b.getObject());
+      assertEquals(new IntWritable((int)127), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '3', '2', '7', '6', '8'}, 0, 6);
-      assertEquals(new IntWritable((int)-32768), b.getObject());
+      assertEquals(new IntWritable((int)-32768), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '3', '2', '7', '6', '7'}, 0, 6);
-      assertEquals(new IntWritable((int)32767), b.getObject());
+      assertEquals(new IntWritable((int)32767), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8'}, 0, 11);
-      assertEquals(new IntWritable((int)-2147483648), b.getObject());
+      assertEquals(new IntWritable((int)-2147483648), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '2', '1', '4', '7', '4', '8', '3', '6', '4', '7'}, 0, 11);
-      assertEquals(new IntWritable((int)2147483647), b.getObject());
+      assertEquals(new IntWritable((int)2147483647), b.getWritableObject());
 
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 2);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '9'}, 0, 11);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8'}, 0, 11);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
 
     } catch (Throwable e) {
       e.printStackTrace();
@@ -183,52 +186,52 @@ public void testLazyInteger() throws Throwable {
    */
   public void testLazyLong() throws Throwable {
     try {
-      LazyLong b = new LazyLong();
+      LazyLong b = new LazyLong(LazyPrimitiveObjectInspectorFactory.lazyLongObjectInspector);
       initLazyObject(b,new byte[]{'0'}, 0, 0);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'0'}, 0, 1);
-      assertEquals(new LongWritable((long)0), b.getObject());
+      assertEquals(new LongWritable((long)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '0'}, 0, 2);
-      assertEquals(new LongWritable((long)0), b.getObject());
+      assertEquals(new LongWritable((long)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '0'}, 0, 2);
-      assertEquals(new LongWritable((long)0), b.getObject());
+      assertEquals(new LongWritable((long)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 1);
-      assertEquals(new LongWritable((long)1), b.getObject());
+      assertEquals(new LongWritable((long)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '-', '1'}, 1, 2);
-      assertEquals(new LongWritable((long)-1), b.getObject());
+      assertEquals(new LongWritable((long)-1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '+', '1'}, 1, 2);
-      assertEquals(new LongWritable((long)1), b.getObject());
+      assertEquals(new LongWritable((long)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '8'}, 0, 4);
-      assertEquals(new LongWritable((long)-128), b.getObject());
+      assertEquals(new LongWritable((long)-128), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '7'}, 0, 4);
-      assertEquals(new LongWritable((long)127), b.getObject());
+      assertEquals(new LongWritable((long)127), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '3', '2', '7', '6', '8'}, 0, 6);
-      assertEquals(new LongWritable((long)-32768), b.getObject());
+      assertEquals(new LongWritable((long)-32768), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '3', '2', '7', '6', '7'}, 0, 6);
-      assertEquals(new LongWritable((long)32767), b.getObject());
+      assertEquals(new LongWritable((long)32767), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8'}, 0, 11);
-      assertEquals(new LongWritable((long)-2147483648), b.getObject());
+      assertEquals(new LongWritable((long)-2147483648), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '2', '1', '4', '7', '4', '8', '3', '6', '4', '7'}, 0, 11);
-      assertEquals(new LongWritable((long)2147483647), b.getObject());
+      assertEquals(new LongWritable((long)2147483647), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5',
           '4', '7', '7', '5', '8', '0', '8'}, 0, 20);
-      assertEquals(new LongWritable((long)-9223372036854775808L), b.getObject());
+      assertEquals(new LongWritable((long)-9223372036854775808L), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5',
           '4', '7', '7', '5', '8', '0', '7'}, 0, 20);
-      assertEquals(new LongWritable((long)9223372036854775807L), b.getObject());
+      assertEquals(new LongWritable((long)9223372036854775807L), b.getWritableObject());
 
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 2);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5',
           '4', '7', '7', '5', '8', '0', '9'}, 0, 20);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5',
           '4', '7', '7', '5', '8', '0', '8'}, 0, 20);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
 
     } catch (Throwable e) {
       e.printStackTrace();
@@ -241,81 +244,81 @@ public void testLazyLong() throws Throwable {
    */
   public void testLazyDouble() throws Throwable {
     try {
-      LazyDouble b = new LazyDouble();
+      LazyDouble b = new LazyDouble(LazyPrimitiveObjectInspectorFactory.lazyDoubleObjectInspector);
       initLazyObject(b,new byte[]{'0'}, 0, 0);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'0'}, 0, 1);
-      assertEquals(new DoubleWritable((double)0), b.getObject());
+      assertEquals(new DoubleWritable((double)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '0'}, 0, 2);
-      assertEquals(new DoubleWritable((double)0), b.getObject());
+      assertEquals(new DoubleWritable((double)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '0'}, 0, 2);
-      assertEquals(new DoubleWritable((double)-0.0), b.getObject());
+      assertEquals(new DoubleWritable((double)-0.0), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 1);
-      assertEquals(new DoubleWritable((double)1), b.getObject());
+      assertEquals(new DoubleWritable((double)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '-', '1'}, 1, 2);
-      assertEquals(new DoubleWritable((double)-1), b.getObject());
+      assertEquals(new DoubleWritable((double)-1), b.getWritableObject());
       initLazyObject(b,new byte[]{'a', '+', '1'}, 1, 2);
-      assertEquals(new DoubleWritable((double)1), b.getObject());
+      assertEquals(new DoubleWritable((double)1), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '8'}, 0, 4);
-      assertEquals(new DoubleWritable((double)-128), b.getObject());
+      assertEquals(new DoubleWritable((double)-128), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '7'}, 0, 4);
-      assertEquals(new DoubleWritable((double)127), b.getObject());
+      assertEquals(new DoubleWritable((double)127), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '3', '2', '7', '6', '8'}, 0, 6);
-      assertEquals(new DoubleWritable((double)-32768), b.getObject());
+      assertEquals(new DoubleWritable((double)-32768), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '3', '2', '7', '6', '7'}, 0, 6);
-      assertEquals(new DoubleWritable((double)32767), b.getObject());
+      assertEquals(new DoubleWritable((double)32767), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8'}, 0, 11);
-      assertEquals(new DoubleWritable((double)-2147483648), b.getObject());
+      assertEquals(new DoubleWritable((double)-2147483648), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '2', '1', '4', '7', '4', '8', '3', '6', '4', '7'}, 0, 11);
-      assertEquals(new DoubleWritable((double)2147483647), b.getObject());
+      assertEquals(new DoubleWritable((double)2147483647), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5',
           '4', '7', '7', '5', '8', '0', '8'}, 0, 20);
-      assertEquals(new DoubleWritable((double)-9223372036854775808L), b.getObject());
+      assertEquals(new DoubleWritable((double)-9223372036854775808L), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5',
           '4', '7', '7', '5', '8', '0', '7'}, 0, 20);
-      assertEquals(new DoubleWritable((long)9223372036854775807L), b.getObject());
+      assertEquals(new DoubleWritable((long)9223372036854775807L), b.getWritableObject());
 
       initLazyObject(b,new byte[]{'-', '3', '.', '7', '6', '8'}, 0, 6);
-      assertEquals(new DoubleWritable((double)-3.768), b.getObject());
+      assertEquals(new DoubleWritable((double)-3.768), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '3', '.', '7', '6', '7'}, 0, 6);
-      assertEquals(new DoubleWritable((double)3.767), b.getObject());
+      assertEquals(new DoubleWritable((double)3.767), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '2', '.', '4', '7', '4', '8', '3', '6', 'e', '8'}, 0, 11);
-      assertEquals(new DoubleWritable((double)-2.474836e8), b.getObject());
+      assertEquals(new DoubleWritable((double)-2.474836e8), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '2', '.', '4', '7', '4', '8', '3', 'E', '-', '7'}, 0, 11);
-      assertEquals(new DoubleWritable((double)2.47483E-7), b.getObject());
+      assertEquals(new DoubleWritable((double)2.47483E-7), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '.', '4', '7', '4', '8', '3', '6', 'e', '8'}, 0, 10);
-      assertEquals(new DoubleWritable((double)-.474836e8), b.getObject());
+      assertEquals(new DoubleWritable((double)-.474836e8), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '.', '4', '7', '4', '8', '3', 'E', '-', '7'}, 0, 10);
-      assertEquals(new DoubleWritable((double).47483E-7), b.getObject());
+      assertEquals(new DoubleWritable((double).47483E-7), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '.'}, 0, 11);
-      assertEquals(new DoubleWritable((double)-214748364.), b.getObject());
+      assertEquals(new DoubleWritable((double)-214748364.), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '2', '1', '4', '7', '4', '8', '3', '6', '4', '.'}, 0, 11);
-      assertEquals(new DoubleWritable((double)+214748364.), b.getObject());
+      assertEquals(new DoubleWritable((double)+214748364.), b.getWritableObject());
 
       initLazyObject(b,new byte[]{'.', '0'}, 0, 2);
-      assertEquals(new DoubleWritable((double).0), b.getObject());
+      assertEquals(new DoubleWritable((double).0), b.getWritableObject());
       initLazyObject(b,new byte[]{'0', '.'}, 0, 2);
-      assertEquals(new DoubleWritable((double)0.), b.getObject());
+      assertEquals(new DoubleWritable((double)0.), b.getWritableObject());
       
       initLazyObject(b,new byte[]{'a', '1', 'b'}, 1, 2);
-      assertNull(b.getObject());
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'.', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', '2', '3'}, 0, 1);
-      assertNull(b.getObject());
+      assertNull(b.getWritableObject());
       
       initLazyObject(b,new byte[]{'-', '1', 'e', '3', '3', '3', '3', '3', '3'}, 0, 9);
-      assertEquals(new DoubleWritable(Double.NEGATIVE_INFINITY), b.getObject());
+      assertEquals(new DoubleWritable(Double.NEGATIVE_INFINITY), b.getWritableObject());
       initLazyObject(b,new byte[]{'+', '1', 'e', '3', '3', '3', '3', '3', '3'}, 0, 9);
-      assertEquals(new DoubleWritable(Double.POSITIVE_INFINITY), b.getObject());
+      assertEquals(new DoubleWritable(Double.POSITIVE_INFINITY), b.getWritableObject());
 
       initLazyObject(b,new byte[]{'+', '1', 'e', '-', '3', '3', '3', '3', '3'}, 0, 8);
-      assertEquals(new DoubleWritable((double)0), b.getObject());
+      assertEquals(new DoubleWritable((double)0), b.getWritableObject());
       initLazyObject(b,new byte[]{'-', '1', 'e', '-', '3', '3', '3', '3', '3'}, 0, 8);
-      assertEquals(new DoubleWritable((double)-0.0), b.getObject());
+      assertEquals(new DoubleWritable((double)-0.0), b.getWritableObject());
       
     } catch (Throwable e) {
       e.printStackTrace();
@@ -328,13 +331,14 @@ public void testLazyDouble() throws Throwable {
    */
   public void testLazyString() throws Throwable {
     try {
-      LazyString b = new LazyString();
+      LazyString b = new LazyString(LazyPrimitiveObjectInspectorFactory
+          .getLazyStringObjectInspector(false,(byte)0));
       initLazyObject(b,new byte[]{'0'}, 0, 0);
-      assertEquals(new Text(""), b.getObject());
+      assertEquals(new Text(""), b.getWritableObject());
       initLazyObject(b,new byte[]{'0'}, 0, 1);
-      assertEquals(new Text("0"), b.getObject());
+      assertEquals(new Text("0"), b.getWritableObject());
       initLazyObject(b,new byte[]{'0', '1', '2'}, 1, 1);
-      assertEquals(new Text("1"), b.getObject());
+      assertEquals(new Text("1"), b.getWritableObject());
       
     } catch (Throwable e) {
       e.printStackTrace();
diff --git a/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazySimpleSerDe.java b/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazySimpleSerDe.java
index 0f754603b4..9114a93845 100644
--- a/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazySimpleSerDe.java
+++ b/serde/src/test/org/apache/hadoop/hive/serde2/lazy/TestLazySimpleSerDe.java
@@ -77,6 +77,9 @@ private void deserializeAndSerialize(LazySimpleSerDe serDe, Text t, String s,
     Object row = serDe.deserialize(t);
     for (int i = 0; i < fieldRefs.size(); i++) {
       Object fieldData = oi.getStructFieldData(row, fieldRefs.get(i));
+      if (fieldData != null) {
+        fieldData = ((LazyPrimitive)fieldData).getWritableObject();
+      }
       assertEquals("Field " + i, expectedFieldsData[i], fieldData);
     }
     // Serialize 
