diff --git a/service/src/java/org/apache/hive/service/cli/CLIService.java b/service/src/java/org/apache/hive/service/cli/CLIService.java
index b842f3733f..714b25909c 100644
--- a/service/src/java/org/apache/hive/service/cli/CLIService.java
+++ b/service/src/java/org/apache/hive/service/cli/CLIService.java
@@ -404,7 +404,7 @@ public OperationHandle getFunctions(SessionHandle sessionHandle,
    */
   @Override
   public OperationHandle getPrimaryKeys(SessionHandle sessionHandle,
-		  String catalog, String schema, String table)
+      String catalog, String schema, String table)
           throws HiveSQLException {
     OperationHandle opHandle = sessionManager.getSession(sessionHandle)
         .getPrimaryKeys(catalog, schema, table);
@@ -417,9 +417,9 @@ public OperationHandle getPrimaryKeys(SessionHandle sessionHandle,
    */
   @Override
   public OperationHandle getCrossReference(SessionHandle sessionHandle,
-		  String primaryCatalog,
-	      String primarySchema, String primaryTable, String foreignCatalog,
-	      String foreignSchema, String foreignTable)
+      String primaryCatalog,
+        String primarySchema, String primaryTable, String foreignCatalog,
+        String foreignSchema, String foreignTable)
           throws HiveSQLException {
     OperationHandle opHandle = sessionManager.getSession(sessionHandle)
         .getCrossReference(primaryCatalog, primarySchema, primaryTable,
@@ -460,6 +460,8 @@ public OperationStatus getOperationStatus(OperationHandle opHandle, boolean getP
         // The background operation thread was cancelled
         LOG.trace(opHandle + ": The background operation was cancelled", e);
       } catch (ExecutionException e) {
+        // Note: Hive ops do not use the normal Future failure path, so this will not happen
+        //       in case of actual failure; the Future will just be done.
         // The background operation thread was aborted
         LOG.warn(opHandle + ": The background operation was aborted", e);
       } catch (InterruptedException e) {
@@ -473,23 +475,28 @@ public OperationStatus getOperationStatus(OperationHandle opHandle, boolean getP
     return opStatus;
   }
 
+  private static final long PROGRESS_MAX_WAIT_NS = 30 * 1000000000l;
   private JobProgressUpdate progressUpdateLog(boolean isProgressLogRequested, Operation operation) {
-    if (isProgressLogRequested && canProvideProgressLog()) {
-        if (OperationType.EXECUTE_STATEMENT.equals(operation.getType())) {
-          SessionState sessionState = operation.getParentSession().getSessionState();
-          try {
-            while (sessionState.getProgressMonitor() == null && !operation.isFinished()) {
-              Thread.sleep(10L); // sleep for 10 ms
-            }
-          } catch (InterruptedException e) {
-            LOG.warn("Error while getting progress update", e);
-          }
-          if (sessionState.getProgressMonitor() != null) {
-            return new JobProgressUpdate(sessionState.getProgressMonitor());
-          }
-        }
+    if (!isProgressLogRequested || !canProvideProgressLog()
+        || !OperationType.EXECUTE_STATEMENT.equals(operation.getType())) {
+      return new JobProgressUpdate(ProgressMonitor.NULL);
+    }
+    
+    SessionState sessionState = operation.getParentSession().getSessionState();
+    long startTime = System.nanoTime();
+    int timeOutMs = 8;
+    try {
+      while (sessionState.getProgressMonitor() == null && !operation.isDone()) {
+        long remainingMs = (PROGRESS_MAX_WAIT_NS - (System.nanoTime() - startTime)) / 1000000l;
+        if (remainingMs <= 0) return new JobProgressUpdate(ProgressMonitor.NULL);
+        Thread.sleep(Math.min(remainingMs, timeOutMs));
+        timeOutMs <<= 1;
+      }
+    } catch (InterruptedException e) {
+      LOG.warn("Error while getting progress update", e);
     }
-    return new JobProgressUpdate(ProgressMonitor.NULL);
+    ProgressMonitor pm = sessionState.getProgressMonitor();
+    return new JobProgressUpdate(pm != null ? pm : ProgressMonitor.NULL);
   }
 
   private boolean canProvideProgressLog() {
diff --git a/service/src/java/org/apache/hive/service/cli/operation/Operation.java b/service/src/java/org/apache/hive/service/cli/operation/Operation.java
index 2039946b6e..11a820fae6 100644
--- a/service/src/java/org/apache/hive/service/cli/operation/Operation.java
+++ b/service/src/java/org/apache/hive/service/cli/operation/Operation.java
@@ -206,20 +206,8 @@ protected final void assertState(List<OperationState> states) throws HiveSQLExce
     this.lastAccessTime = System.currentTimeMillis();
   }
 
-  public boolean isRunning() {
-    return OperationState.RUNNING.equals(state);
-  }
-
-  public boolean isFinished() {
-    return OperationState.FINISHED.equals(state);
-  }
-
-  public boolean isCanceled() {
-    return OperationState.CANCELED.equals(state);
-  }
-
-  public boolean isFailed() {
-    return OperationState.ERROR.equals(state);
+  public boolean isDone() {
+    return state.isTerminal();
   }
 
   protected void createOperationLog() {
diff --git a/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java b/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java
index 668b4b718e..7dde7bf009 100644
--- a/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java
+++ b/service/src/java/org/apache/hive/service/cli/operation/SQLOperation.java
@@ -346,6 +346,7 @@ public Object run() throws HiveSQLException {
             }
             runQuery();
           } catch (HiveSQLException e) {
+            // TODO: why do we invent our own error path op top of the one from Future.get?
             setOperationException(e);
             LOG.error("Error running hive query: ", e);
           } finally {
@@ -361,8 +362,7 @@ public Object run() throws HiveSQLException {
       } catch (Exception e) {
         setOperationException(new HiveSQLException(e));
         LOG.error("Error running hive query as user : " + currentUGI.getShortUserName(), e);
-      }
-      finally {
+      } finally {
         /**
          * We'll cache the ThreadLocal RawStore object for this background thread for an orderly cleanup
          * when this thread is garbage collected later.
