diff --git a/itests/src/test/resources/testconfiguration.properties b/itests/src/test/resources/testconfiguration.properties
index 43c2d56714..d08651b362 100644
--- a/itests/src/test/resources/testconfiguration.properties
+++ b/itests/src/test/resources/testconfiguration.properties
@@ -271,7 +271,11 @@ minitez.query.files.shared=alter_merge_2_orc.q,\
   auto_sortmerge_join_5.q,\
   auto_sortmerge_join_7.q,\
   auto_sortmerge_join_8.q,\
-  auto_sortmerge_join_9.q
+  auto_sortmerge_join_9.q,\
+  auto_join30.q,\
+  auto_join21.q,\
+  auto_join29.q,\
+  auto_join_filters.q
 
 
 minitez.query.files=bucket_map_join_tez1.q,\
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ConvertJoinMapJoin.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ConvertJoinMapJoin.java
index 567c42e4c8..2d22e9a5d5 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ConvertJoinMapJoin.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ConvertJoinMapJoin.java
@@ -507,7 +507,38 @@ private boolean checkColEquality(List<List<String>> grandParentColNames,
   }
 
   public int getMapJoinConversionPos(JoinOperator joinOp, OptimizeTezProcContext context,
-      int buckets) {
+      int buckets) throws SemanticException {
+    /*
+     * HIVE-9038: Join tests fail in tez when we have more than 1 join on the same key and there is
+     * an outer join down the join tree that requires filterTag. We disable this conversion to map
+     * join here now. We need to emulate the behavior of HashTableSinkOperator as in MR or create a
+     * new operation to be able to support this. This seems like a corner case enough to special
+     * case this for now.
+     */
+    if (joinOp.getConf().getConds().length > 1) {
+      boolean hasOuter = false;
+      for (JoinCondDesc joinCondDesc : joinOp.getConf().getConds()) {
+        switch (joinCondDesc.getType()) {
+        case JoinDesc.INNER_JOIN:
+        case JoinDesc.LEFT_SEMI_JOIN:
+        case JoinDesc.UNIQUE_JOIN:
+          hasOuter = false;
+          break;
+
+        case JoinDesc.FULL_OUTER_JOIN:
+        case JoinDesc.LEFT_OUTER_JOIN:
+        case JoinDesc.RIGHT_OUTER_JOIN:
+          hasOuter = true;
+          break;
+
+        default:
+          throw new SemanticException("Unknown join type " + joinCondDesc.getType());
+        }
+      }
+      if (hasOuter) {
+        return -1;
+      }
+    }
     Set<Integer> bigTableCandidateSet =
         MapJoinProcessor.getBigTableCandidates(joinOp.getConf().getConds());
 
