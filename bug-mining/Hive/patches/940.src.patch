diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java
index 9e84e85aec..727afdccbf 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java
@@ -907,6 +907,10 @@ public void closeOp(boolean abort) throws HiveException {
 
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "JOIN";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/FileSinkOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/FileSinkOperator.java
index eb0a4092ac..c5f2a23b77 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/FileSinkOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/FileSinkOperator.java
@@ -736,6 +736,10 @@ public void closeOp(boolean abort) throws HiveException {
    */
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "FS";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/FilterOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/FilterOperator.java
index 3658ef289b..0268cfee3b 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/FilterOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/FilterOperator.java
@@ -149,6 +149,10 @@ public void processOp(Object row, int tag) throws HiveException {
    */
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "FIL";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java
index c9cecbc83e..86690519e4 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java
@@ -1081,6 +1081,10 @@ public List<String> genColLists(
    */
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "GBY";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableDummyOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableDummyOperator.java
index 57ae5fcc8a..70cbff8a3f 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableDummyOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableDummyOperator.java
@@ -54,6 +54,10 @@ public void closeOp(boolean abort) throws HiveException {
 
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "HASHTABLEDUMMY";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableSinkOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableSinkOperator.java
index 13884cdf4a..bd6931c25c 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableSinkOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/HashTableSinkOperator.java
@@ -435,6 +435,10 @@ public void closeOp(boolean abort) throws HiveException {
    */
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "HASHTABLESINK";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/LateralViewForwardOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/LateralViewForwardOperator.java
index 5bfb80550d..4e430f2d3f 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/LateralViewForwardOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/LateralViewForwardOperator.java
@@ -39,6 +39,10 @@ public void processOp(Object row, int tag) throws HiveException {
 
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "LVF";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/LateralViewJoinOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/LateralViewJoinOperator.java
index bba06b6b6e..2fbb81b268 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/LateralViewJoinOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/LateralViewJoinOperator.java
@@ -139,6 +139,10 @@ public void processOp(Object row, int tag) throws HiveException {
 
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "LVJ";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/LimitOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/LimitOperator.java
index c82d2d5c85..276902a299 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/LimitOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/LimitOperator.java
@@ -57,6 +57,10 @@ public void processOp(Object row, int tag) throws HiveException {
 
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "LIM";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java
index 0069872e6d..2a0a58b772 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapJoinOperator.java
@@ -300,6 +300,10 @@ public void closeOp(boolean abort) throws HiveException {
    */
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "MAPJOIN";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapOperator.java
index b6dbf3dc48..67aea5d162 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/MapOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/MapOperator.java
@@ -629,6 +629,10 @@ public void processOp(Object row, int tag) throws HiveException {
 
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "MAP";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/Operator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/Operator.java
index 8fa0591816..f0c35e7490 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/Operator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/Operator.java
@@ -816,6 +816,10 @@ public void logStats() {
    * @return the name of the operator
    */
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "OP";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/ReduceSinkOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/ReduceSinkOperator.java
index 732a5aaa1f..a2caeed64e 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/ReduceSinkOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/ReduceSinkOperator.java
@@ -310,6 +310,10 @@ public void processOp(Object row, int tag) throws HiveException {
    */
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "RS";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/SMBMapJoinOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/SMBMapJoinOperator.java
index 76c5545e5b..1a4063033f 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/SMBMapJoinOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/SMBMapJoinOperator.java
@@ -594,6 +594,10 @@ protected boolean allInitializedParentsAreClosed() {
    */
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "MAPJOIN";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/ScriptOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/ScriptOperator.java
index cbd0784db6..809695e71c 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/ScriptOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/ScriptOperator.java
@@ -699,6 +699,10 @@ public static String[] splitArgs(String args) {
 
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "SCR";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/SelectOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/SelectOperator.java
index 88c3a8bd8e..5bf5b21961 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/SelectOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/SelectOperator.java
@@ -89,6 +89,10 @@ public void processOp(Object row, int tag) throws HiveException {
    */
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "SEL";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/TableScanOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/TableScanOperator.java
index 63af384009..dffdd7b6bd 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/TableScanOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/TableScanOperator.java
@@ -207,6 +207,10 @@ public void closeOp(boolean abort) throws HiveException {
    **/
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "TS";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/UDTFOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/UDTFOperator.java
index 919656c449..312774a230 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/UDTFOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/UDTFOperator.java
@@ -114,6 +114,10 @@ public void forwardUDTFOutput(Object o) throws HiveException {
 
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "UDTF";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/UnionOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/UnionOperator.java
index f1ad15e61f..ee1c7f2020 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/UnionOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/UnionOperator.java
@@ -137,6 +137,10 @@ public synchronized void processOp(Object row, int tag) throws HiveException {
    */
   @Override
   public String getName() {
+    return getOperatorName();
+  }
+
+  static public String getOperatorName() {
     return "UNION";
   }
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/BucketMapJoinOptimizer.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/BucketMapJoinOptimizer.java
index 640ccfad59..d9354f39d0 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/BucketMapJoinOptimizer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/BucketMapJoinOptimizer.java
@@ -40,6 +40,8 @@
 import org.apache.hadoop.hive.conf.HiveConf;
 import org.apache.hadoop.hive.ql.ErrorMsg;
 import org.apache.hadoop.hive.ql.exec.MapJoinOperator;
+import org.apache.hadoop.hive.ql.exec.UnionOperator;
+import org.apache.hadoop.hive.ql.exec.ReduceSinkOperator;
 import org.apache.hadoop.hive.ql.exec.Operator;
 import org.apache.hadoop.hive.ql.exec.TableScanOperator;
 import org.apache.hadoop.hive.ql.lib.DefaultGraphWalker;
@@ -83,12 +85,18 @@ public ParseContext transform(ParseContext pctx) throws SemanticException {
       new BucketMapjoinOptProcCtx(pctx.getConf());
 
     // process map joins with no reducers pattern
-    opRules.put(new RuleRegExp("R1", "MAPJOIN%"), getBucketMapjoinProc(pctx));
-    opRules.put(new RuleRegExp("R2", "RS%.*MAPJOIN"), getBucketMapjoinRejectProc(pctx));
-    opRules.put(new RuleRegExp(new String("R3"), "UNION%.*MAPJOIN%"),
-        getBucketMapjoinRejectProc(pctx));
-    opRules.put(new RuleRegExp(new String("R4"), "MAPJOIN%.*MAPJOIN%"),
-        getBucketMapjoinRejectProc(pctx));
+    opRules.put(new RuleRegExp("R1",
+      MapJoinOperator.getOperatorName() + "%"),
+      getBucketMapjoinProc(pctx));
+    opRules.put(new RuleRegExp("R2",
+      ReduceSinkOperator.getOperatorName() + "%.*" + MapJoinOperator.getOperatorName()),
+      getBucketMapjoinRejectProc(pctx));
+    opRules.put(new RuleRegExp(new String("R3"),
+      UnionOperator.getOperatorName() + "%.*" + MapJoinOperator.getOperatorName() + "%"),
+      getBucketMapjoinRejectProc(pctx));
+    opRules.put(new RuleRegExp(new String("R4"),
+      MapJoinOperator.getOperatorName() + "%.*" + MapJoinOperator.getOperatorName() + "%"),
+      getBucketMapjoinRejectProc(pctx));
 
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ColumnPruner.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ColumnPruner.java
index b469dcd795..582ef14292 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ColumnPruner.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ColumnPruner.java
@@ -23,10 +23,19 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 
-import org.apache.hadoop.hive.ql.exec.FileSinkOperator;
 import org.apache.hadoop.hive.ql.exec.Operator;
-import org.apache.hadoop.hive.ql.exec.ScriptOperator;
+import org.apache.hadoop.hive.ql.exec.FilterOperator;
+import org.apache.hadoop.hive.ql.exec.TableScanOperator;
 import org.apache.hadoop.hive.ql.exec.SelectOperator;
+import org.apache.hadoop.hive.ql.exec.ScriptOperator;
+import org.apache.hadoop.hive.ql.exec.GroupByOperator;
+import org.apache.hadoop.hive.ql.exec.MapJoinOperator;
+import org.apache.hadoop.hive.ql.exec.UnionOperator;
+import org.apache.hadoop.hive.ql.exec.CommonJoinOperator;
+import org.apache.hadoop.hive.ql.exec.ReduceSinkOperator;
+import org.apache.hadoop.hive.ql.exec.LateralViewJoinOperator;
+import org.apache.hadoop.hive.ql.exec.LateralViewForwardOperator;
+import org.apache.hadoop.hive.ql.exec.FileSinkOperator;
 import org.apache.hadoop.hive.ql.lib.DefaultGraphWalker;
 import org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher;
 import org.apache.hadoop.hive.ql.lib.Dispatcher;
@@ -78,24 +87,33 @@ public ParseContext transform(ParseContext pactx) throws SemanticException {
     // the operator stack. The dispatcher
     // generates the plan from the operator tree
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R1", "FIL%"), ColumnPrunerProcFactory
-        .getFilterProc());
-    opRules.put(new RuleRegExp("R2", "GBY%"), ColumnPrunerProcFactory
-        .getGroupByProc());
-    opRules.put(new RuleRegExp("R3", "RS%"), ColumnPrunerProcFactory
-        .getReduceSinkProc());
-    opRules.put(new RuleRegExp("R4", "SEL%"), ColumnPrunerProcFactory
-        .getSelectProc());
-    opRules.put(new RuleRegExp("R5", "JOIN%"), ColumnPrunerProcFactory
-        .getJoinProc());
-    opRules.put(new RuleRegExp("R6", "MAPJOIN%"), ColumnPrunerProcFactory
-        .getMapJoinProc());
-    opRules.put(new RuleRegExp("R7", "TS%"), ColumnPrunerProcFactory
-        .getTableScanProc());
-    opRules.put(new RuleRegExp("R8", "LVJ%"), ColumnPrunerProcFactory
-        .getLateralViewJoinProc());
-    opRules.put(new RuleRegExp("R9", "LVF%"), ColumnPrunerProcFactory
-        .getLateralViewForwardProc());
+    opRules.put(new RuleRegExp("R1",
+      FilterOperator.getOperatorName() + "%"),
+      ColumnPrunerProcFactory.getFilterProc());
+    opRules.put(new RuleRegExp("R2",
+      GroupByOperator.getOperatorName() + "%"),
+      ColumnPrunerProcFactory.getGroupByProc());
+    opRules.put(new RuleRegExp("R3",
+      ReduceSinkOperator.getOperatorName() + "%"),
+      ColumnPrunerProcFactory.getReduceSinkProc());
+    opRules.put(new RuleRegExp("R4",
+      SelectOperator.getOperatorName() + "%"),
+      ColumnPrunerProcFactory.getSelectProc());
+    opRules.put(new RuleRegExp("R5",
+      CommonJoinOperator.getOperatorName() + "%"),
+      ColumnPrunerProcFactory.getJoinProc());
+    opRules.put(new RuleRegExp("R6",
+      MapJoinOperator.getOperatorName() + "%"),
+      ColumnPrunerProcFactory.getMapJoinProc());
+    opRules.put(new RuleRegExp("R7",
+      TableScanOperator.getOperatorName() + "%"),
+      ColumnPrunerProcFactory.getTableScanProc());
+    opRules.put(new RuleRegExp("R8",
+      LateralViewJoinOperator.getOperatorName() + "%"),
+      ColumnPrunerProcFactory.getLateralViewJoinProc());
+    opRules.put(new RuleRegExp("R9",
+      LateralViewForwardOperator.getOperatorName() + "%"),
+      ColumnPrunerProcFactory.getLateralViewForwardProc());
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
     Dispatcher disp = new DefaultRuleDispatcher(ColumnPrunerProcFactory
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/GroupByOptimizer.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/GroupByOptimizer.java
index 29edcbe639..55f0971bef 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/GroupByOptimizer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/GroupByOptimizer.java
@@ -32,6 +32,7 @@
 import org.apache.hadoop.hive.ql.exec.GroupByOperator;
 import org.apache.hadoop.hive.ql.exec.Operator;
 import org.apache.hadoop.hive.ql.exec.TableScanOperator;
+import org.apache.hadoop.hive.ql.exec.ReduceSinkOperator;
 import org.apache.hadoop.hive.ql.exec.Utilities;
 import org.apache.hadoop.hive.ql.lib.DefaultGraphWalker;
 import org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher;
@@ -77,8 +78,11 @@ public ParseContext transform(ParseContext pctx) throws SemanticException {
     GroupByOptProcCtx groupByOptimizeCtx = new GroupByOptProcCtx();
 
     // process group-by pattern
-    opRules.put(new RuleRegExp("R1", "GBY%RS%GBY%"),
-        getMapAggreSortedGroupbyProc(pctx));
+    opRules.put(new RuleRegExp("R1",
+      GroupByOperator.getOperatorName() + "%"
+      + ReduceSinkOperator.getOperatorName() + "%"
+      + GroupByOperator.getOperatorName() + "%"),
+      getMapAggreSortedGroupbyProc(pctx));
 
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/MapJoinProcessor.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/MapJoinProcessor.java
index bb3c9ae4f1..f498efe69d 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/MapJoinProcessor.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/MapJoinProcessor.java
@@ -34,6 +34,7 @@
 import org.apache.hadoop.hive.ql.ErrorMsg;
 import org.apache.hadoop.hive.ql.exec.AbstractMapJoinOperator;
 import org.apache.hadoop.hive.ql.exec.ColumnInfo;
+import org.apache.hadoop.hive.ql.exec.FileSinkOperator;
 import org.apache.hadoop.hive.ql.exec.GroupByOperator;
 import org.apache.hadoop.hive.ql.exec.JoinOperator;
 import org.apache.hadoop.hive.ql.exec.LateralViewJoinOperator;
@@ -714,10 +715,18 @@ public ParseContext transform(ParseContext pactx) throws SemanticException {
     // the operator stack.
     // The dispatcher generates the plan from the operator tree
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R0", "MAPJOIN%"), getCurrentMapJoin());
-    opRules.put(new RuleRegExp("R1", "MAPJOIN%.*FS%"), getMapJoinFS());
-    opRules.put(new RuleRegExp("R2", "MAPJOIN%.*RS%"), getMapJoinDefault());
-    opRules.put(new RuleRegExp("R4", "MAPJOIN%.*UNION%"), getMapJoinDefault());
+    opRules.put(new RuleRegExp("R0",
+      MapJoinOperator.getOperatorName() + "%"),
+      getCurrentMapJoin());
+    opRules.put(new RuleRegExp("R1",
+      MapJoinOperator.getOperatorName() + "%.*" + FileSinkOperator.getOperatorName() + "%"),
+      getMapJoinFS());
+    opRules.put(new RuleRegExp("R2",
+      MapJoinOperator.getOperatorName() + "%.*" + ReduceSinkOperator.getOperatorName() + "%"),
+      getMapJoinDefault());
+    opRules.put(new RuleRegExp("R4",
+      MapJoinOperator.getOperatorName() + "%.*" + UnionOperator.getOperatorName() + "%"),
+      getMapJoinDefault());
 
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ReduceSinkDeDuplication.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ReduceSinkDeDuplication.java
index ef2e34ebed..77c50b02e7 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ReduceSinkDeDuplication.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ReduceSinkDeDuplication.java
@@ -75,8 +75,9 @@ public ParseContext transform(ParseContext pctx) throws SemanticException {
     ReduceSinkDeduplicateProcCtx cppCtx = new ReduceSinkDeduplicateProcCtx(pGraphContext);
 
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R1", "RS%.*RS%"), ReduceSinkDeduplicateProcFactory
-        .getReducerReducerProc());
+    opRules.put(new RuleRegExp("R1",
+      ReduceSinkOperator.getOperatorName() + "%.*" + ReduceSinkOperator.getOperatorName() + "%"),
+      ReduceSinkDeduplicateProcFactory.getReducerReducerProc());
 
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/SamplePruner.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/SamplePruner.java
index bc6b6c11cb..ab2ed81bf3 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/SamplePruner.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/SamplePruner.java
@@ -104,7 +104,12 @@ public ParseContext transform(ParseContext pctx) throws SemanticException {
         .getOpToSamplePruner());
 
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R1", "(TS%FIL%FIL%|TS%FIL%)"), getFilterProc());
+    opRules.put(new RuleRegExp("R1",
+      "(" + TableScanOperator.getOperatorName() + "%"
+      + FilterOperator.getOperatorName() + "%"
+      + FilterOperator.getOperatorName() + "%|"
+      + TableScanOperator.getOperatorName() + "%"
+      + FilterOperator.getOperatorName() + "%)"), getFilterProc());
 
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/SortedMergeBucketMapJoinOptimizer.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/SortedMergeBucketMapJoinOptimizer.java
index 31a0ecb355..65a49371f6 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/SortedMergeBucketMapJoinOptimizer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/SortedMergeBucketMapJoinOptimizer.java
@@ -74,7 +74,7 @@ public ParseContext transform(ParseContext pctx) throws SemanticException {
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
     // go through all map joins and find out all which have enabled bucket map
     // join.
-    opRules.put(new RuleRegExp("R1", "MAPJOIN%"),
+    opRules.put(new RuleRegExp("R1", MapJoinOperator.getOperatorName() + "%"),
         getSortedMergeBucketMapjoinProc(pctx));
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/index/RewriteCanApplyCtx.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/index/RewriteCanApplyCtx.java
index 3de04b1205..cc94254e0f 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/index/RewriteCanApplyCtx.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/index/RewriteCanApplyCtx.java
@@ -31,6 +31,9 @@
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.hive.metastore.api.Index;
 import org.apache.hadoop.hive.ql.exec.Operator;
+import org.apache.hadoop.hive.ql.exec.FilterOperator;
+import org.apache.hadoop.hive.ql.exec.GroupByOperator;
+import org.apache.hadoop.hive.ql.exec.SelectOperator;
 import org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher;
 import org.apache.hadoop.hive.ql.lib.Dispatcher;
 import org.apache.hadoop.hive.ql.lib.GraphWalker;
@@ -255,11 +258,11 @@ public  ParseContext getParseContext() {
   void populateRewriteVars(Operator<? extends OperatorDesc> topOp)
     throws SemanticException{
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R1", "FIL%"),
+    opRules.put(new RuleRegExp("R1", FilterOperator.getOperatorName() + "%"),
         RewriteCanApplyProcFactory.canApplyOnFilterOperator());
-    opRules.put(new RuleRegExp("R2", "GBY%"),
+    opRules.put(new RuleRegExp("R2", GroupByOperator.getOperatorName() + "%"),
         RewriteCanApplyProcFactory.canApplyOnGroupByOperator());
-    opRules.put(new RuleRegExp("R3", "SEL%"),
+    opRules.put(new RuleRegExp("R3", SelectOperator.getOperatorName() + "%"),
         RewriteCanApplyProcFactory.canApplyOnSelectOperator());
 
     // The dispatcher fires the processor corresponding to the closest matching
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/index/RewriteQueryUsingAggregateIndexCtx.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/index/RewriteQueryUsingAggregateIndexCtx.java
index 7fe3777683..b5873a41ee 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/index/RewriteQueryUsingAggregateIndexCtx.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/index/RewriteQueryUsingAggregateIndexCtx.java
@@ -25,6 +25,9 @@
 import java.util.Stack;
 
 import org.apache.hadoop.hive.ql.exec.Operator;
+import org.apache.hadoop.hive.ql.exec.TableScanOperator;
+import org.apache.hadoop.hive.ql.exec.SelectOperator;
+import org.apache.hadoop.hive.ql.exec.GroupByOperator;
 import org.apache.hadoop.hive.ql.lib.DefaultGraphWalker;
 import org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher;
 import org.apache.hadoop.hive.ql.lib.Dispatcher;
@@ -123,14 +126,14 @@ public void invokeRewriteQueryProc(
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
 
     // replace scan operator containing original table with index table
-    opRules.put(new RuleRegExp("R1", "TS%"),
+    opRules.put(new RuleRegExp("R1", TableScanOperator.getOperatorName() + "%"),
         RewriteQueryUsingAggregateIndex.getReplaceTableScanProc());
     //rule that replaces index key selection with
     //sum(`_count_of_indexed_column`) function in original query
-    opRules.put(new RuleRegExp("R2", "SEL%"),
+    opRules.put(new RuleRegExp("R2", SelectOperator.getOperatorName() + "%"),
         RewriteQueryUsingAggregateIndex.getNewQuerySelectSchemaProc());
     //Manipulates the ExprNodeDesc from GroupByOperator aggregation list
-    opRules.put(new RuleRegExp("R3", "GBY%"),
+    opRules.put(new RuleRegExp("R3", GroupByOperator.getOperatorName() + "%"),
         RewriteQueryUsingAggregateIndex.getNewQueryGroupbySchemaProc());
 
     // The dispatcher fires the processor corresponding to the closest matching
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/lineage/Generator.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/lineage/Generator.java
index aeae8e1788..ccbbd284e9 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/lineage/Generator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/lineage/Generator.java
@@ -22,6 +22,17 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 
+import org.apache.hadoop.hive.ql.exec.Operator;
+import org.apache.hadoop.hive.ql.exec.TableScanOperator;
+import org.apache.hadoop.hive.ql.exec.SelectOperator;
+import org.apache.hadoop.hive.ql.exec.ScriptOperator;
+import org.apache.hadoop.hive.ql.exec.GroupByOperator;
+import org.apache.hadoop.hive.ql.exec.MapJoinOperator;
+import org.apache.hadoop.hive.ql.exec.UDTFOperator;
+import org.apache.hadoop.hive.ql.exec.UnionOperator;
+import org.apache.hadoop.hive.ql.exec.CommonJoinOperator;
+import org.apache.hadoop.hive.ql.exec.ReduceSinkOperator;
+import org.apache.hadoop.hive.ql.exec.LateralViewJoinOperator;
 import org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher;
 import org.apache.hadoop.hive.ql.lib.Dispatcher;
 import org.apache.hadoop.hive.ql.lib.GraphWalker;
@@ -52,15 +63,25 @@ public ParseContext transform(ParseContext pctx) throws SemanticException {
     LineageCtx lCtx = new LineageCtx(pctx);
 
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R1", "TS%"), OpProcFactory.getTSProc());
-    opRules.put(new RuleRegExp("R2", "SCR%"), OpProcFactory.getTransformProc());
-    opRules.put(new RuleRegExp("R3", "UDTF%"), OpProcFactory.getTransformProc());
-    opRules.put(new RuleRegExp("R4", "SEL%"), OpProcFactory.getSelProc());
-    opRules.put(new RuleRegExp("R5", "GBY%"), OpProcFactory.getGroupByProc());
-    opRules.put(new RuleRegExp("R6", "UNION%"), OpProcFactory.getUnionProc());
-    opRules.put(new RuleRegExp("R7", "JOIN%|MAPJOIN%"), OpProcFactory.getJoinProc());
-    opRules.put(new RuleRegExp("R8", "RS%"), OpProcFactory.getReduceSinkProc());
-    opRules.put(new RuleRegExp("R9", "LVJ%"), OpProcFactory.getLateralViewJoinProc());
+    opRules.put(new RuleRegExp("R1", TableScanOperator.getOperatorName() + "%"),
+      OpProcFactory.getTSProc());
+    opRules.put(new RuleRegExp("R2", ScriptOperator.getOperatorName() + "%"),
+      OpProcFactory.getTransformProc());
+    opRules.put(new RuleRegExp("R3", UDTFOperator.getOperatorName() + "%"),
+      OpProcFactory.getTransformProc());
+    opRules.put(new RuleRegExp("R4", SelectOperator.getOperatorName() + "%"),
+      OpProcFactory.getSelProc());
+    opRules.put(new RuleRegExp("R5", GroupByOperator.getOperatorName() + "%"),
+      OpProcFactory.getGroupByProc());
+    opRules.put(new RuleRegExp("R6", UnionOperator.getOperatorName() + "%"),
+      OpProcFactory.getUnionProc());
+    opRules.put(new RuleRegExp("R7",
+      CommonJoinOperator.getOperatorName() + "%|" + MapJoinOperator.getOperatorName() + "%"),
+      OpProcFactory.getJoinProc());
+    opRules.put(new RuleRegExp("R8", ReduceSinkOperator.getOperatorName() + "%"),
+      OpProcFactory.getReduceSinkProc());
+    opRules.put(new RuleRegExp("R9", LateralViewJoinOperator.getOperatorName() + "%"),
+      OpProcFactory.getLateralViewJoinProc());
 
     // The dispatcher fires the processor corresponding to the closest matching rule and passes the context along
     Dispatcher disp = new DefaultRuleDispatcher(OpProcFactory.getDefaultProc(), opRules, lCtx);
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/pcr/PartitionConditionRemover.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/pcr/PartitionConditionRemover.java
index 031ba0e566..cbed375fe7 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/pcr/PartitionConditionRemover.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/pcr/PartitionConditionRemover.java
@@ -25,6 +25,9 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hive.ql.exec.Operator;
+import org.apache.hadoop.hive.ql.exec.FilterOperator;
+import org.apache.hadoop.hive.ql.exec.TableScanOperator;
 import org.apache.hadoop.hive.ql.lib.DefaultGraphWalker;
 import org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher;
 import org.apache.hadoop.hive.ql.lib.Dispatcher;
@@ -63,8 +66,13 @@ public ParseContext transform(ParseContext pctx) throws SemanticException {
     PcrOpWalkerCtx opWalkerCtx = new PcrOpWalkerCtx(pctx, opToRemove);
 
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R1", "(TS%FIL%)|(TS%FIL%FIL%)"), PcrOpProcFactory
-        .getFilterProc());
+    opRules.put(new RuleRegExp("R1",
+      "(" + TableScanOperator.getOperatorName() + "%"
+      + FilterOperator.getOperatorName() + "%)|("
+      + TableScanOperator.getOperatorName() + "%"
+      + FilterOperator.getOperatorName() + "%"
+      + FilterOperator.getOperatorName() + "%)"),
+      PcrOpProcFactory.getFilterProc());
 
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/LocalMapJoinProcFactory.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/LocalMapJoinProcFactory.java
index ce8a6ae041..b05cded554 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/LocalMapJoinProcFactory.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/LocalMapJoinProcFactory.java
@@ -191,7 +191,8 @@ public void hasGroupBy(Operator<? extends OperatorDesc> mapJoinOp,
         LocalMapJoinProcCtx localMapJoinProcCtx) throws Exception {
       List<Operator<? extends OperatorDesc>> childOps = mapJoinOp.getChildOperators();
       Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-      opRules.put(new RuleRegExp("R1", "GBY%"), LocalMapJoinProcFactory.getGroupByProc());
+      opRules.put(new RuleRegExp("R1", GroupByOperator.getOperatorName() + "%"),
+        LocalMapJoinProcFactory.getGroupByProc());
       // The dispatcher fires the processor corresponding to the closest
       // matching rule and passes the context along
       Dispatcher disp = new DefaultRuleDispatcher(LocalMapJoinProcFactory.getDefaultProc(),
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/MapJoinResolver.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/MapJoinResolver.java
index 754bb5610a..a279c41de1 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/MapJoinResolver.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/MapJoinResolver.java
@@ -29,6 +29,7 @@
 import org.apache.hadoop.hive.ql.Context;
 import org.apache.hadoop.hive.ql.exec.ConditionalTask;
 import org.apache.hadoop.hive.ql.exec.MapredLocalTask;
+import org.apache.hadoop.hive.ql.exec.MapJoinOperator;
 import org.apache.hadoop.hive.ql.exec.Operator;
 import org.apache.hadoop.hive.ql.exec.Task;
 import org.apache.hadoop.hive.ql.exec.TaskFactory;
@@ -239,7 +240,8 @@ private LocalMapJoinProcCtx adjustLocalTask(MapredLocalTask task)
       LocalMapJoinProcCtx localMapJoinProcCtx = new LocalMapJoinProcCtx(task, physicalContext
           .getParseContext());
       Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-      opRules.put(new RuleRegExp("R1", "MAPJOIN%"), LocalMapJoinProcFactory.getJoinProc());
+      opRules.put(new RuleRegExp("R1", MapJoinOperator.getOperatorName() + "%"),
+        LocalMapJoinProcFactory.getJoinProc());
       // The dispatcher fires the processor corresponding to the closest
       // matching rule and passes the context along
       Dispatcher disp = new DefaultRuleDispatcher(LocalMapJoinProcFactory.getDefaultProc(),
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/MetadataOnlyOptimizer.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/MetadataOnlyOptimizer.java
index 3e7d9790fc..7de3cb54d9 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/MetadataOnlyOptimizer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/MetadataOnlyOptimizer.java
@@ -30,6 +30,7 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hive.ql.exec.FileSinkOperator;
 import org.apache.hadoop.hive.ql.exec.GroupByOperator;
 import org.apache.hadoop.hive.ql.exec.Operator;
 import org.apache.hadoop.hive.ql.exec.TableScanOperator;
@@ -264,8 +265,12 @@ public Object dispatch(Node nd, Stack<Node> stack, Object... nodeOutputs)
       WalkerCtx walkerCtx = new WalkerCtx();
 
       Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-      opRules.put(new RuleRegExp("R1", "TS%"), new TableScanProcessor());
-      opRules.put(new RuleRegExp("R2", "GBY%.*FS%"), new FileSinkProcessor());
+      opRules.put(new RuleRegExp("R1",
+        TableScanOperator.getOperatorName() + "%"),
+        new TableScanProcessor());
+      opRules.put(new RuleRegExp("R2",
+        GroupByOperator.getOperatorName() + "%.*" + FileSinkOperator.getOperatorName() + "%"),
+        new FileSinkProcessor());
 
       // The dispatcher fires the processor corresponding to the closest
       // matching rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/SkewJoinResolver.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/SkewJoinResolver.java
index ef8f3134cf..7a4e98a3b0 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/SkewJoinResolver.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/SkewJoinResolver.java
@@ -24,6 +24,7 @@
 import java.util.Map;
 import java.util.Stack;
 
+import org.apache.hadoop.hive.ql.exec.CommonJoinOperator;
 import org.apache.hadoop.hive.ql.exec.ConditionalTask;
 import org.apache.hadoop.hive.ql.exec.Task;
 import org.apache.hadoop.hive.ql.lib.DefaultGraphWalker;
@@ -81,8 +82,9 @@ public Object dispatch(Node nd, Stack<Node> stack, Object... nodeOutputs)
           physicalContext.getParseContext());
 
       Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-      opRules.put(new RuleRegExp("R1", "JOIN%"), SkewJoinProcFactory
-          .getJoinProc());
+      opRules.put(new RuleRegExp("R1",
+        CommonJoinOperator.getOperatorName() + "%"),
+        SkewJoinProcFactory.getJoinProc());
 
       // The dispatcher fires the processor corresponding to the closest
       // matching rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/index/IndexWhereTaskDispatcher.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/index/IndexWhereTaskDispatcher.java
index f77cb9ca07..61c1be7574 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/index/IndexWhereTaskDispatcher.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/index/IndexWhereTaskDispatcher.java
@@ -28,6 +28,7 @@
 import java.util.Stack;
 
 import org.apache.hadoop.hive.metastore.api.Index;
+import org.apache.hadoop.hive.ql.exec.TableScanOperator;
 import org.apache.hadoop.hive.ql.exec.Task;
 import org.apache.hadoop.hive.ql.index.bitmap.BitmapIndexHandler;
 import org.apache.hadoop.hive.ql.index.compact.CompactIndexHandler;
@@ -131,7 +132,8 @@ private Map<Rule, NodeProcessor> createOperatorRules(ParseContext pctx) throws S
 
     // We set the pushed predicate from the WHERE clause as the filter expr on
     // all table scan operators, so we look for table scan operators(TS%)
-    operatorRules.put(new RuleRegExp("RULEWhere", "TS%"), new IndexWhereProcessor(indexes));
+    operatorRules.put(new RuleRegExp("RULEWhere", TableScanOperator.getOperatorName() + "%"),
+      new IndexWhereProcessor(indexes));
 
     return operatorRules;
   }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ppr/PartitionPruner.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ppr/PartitionPruner.java
index 049e389295..b9bdc93747 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ppr/PartitionPruner.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/ppr/PartitionPruner.java
@@ -37,6 +37,9 @@
 import org.apache.hadoop.hive.ql.exec.ExprNodeEvaluator;
 import org.apache.hadoop.hive.ql.exec.FunctionRegistry;
 import org.apache.hadoop.hive.ql.exec.Utilities;
+import org.apache.hadoop.hive.ql.exec.Operator;
+import org.apache.hadoop.hive.ql.exec.FilterOperator;
+import org.apache.hadoop.hive.ql.exec.TableScanOperator;
 import org.apache.hadoop.hive.ql.lib.DefaultGraphWalker;
 import org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher;
 import org.apache.hadoop.hive.ql.lib.Dispatcher;
@@ -89,8 +92,13 @@ public ParseContext transform(ParseContext pctx) throws SemanticException {
     OpWalkerCtx opWalkerCtx = new OpWalkerCtx(pctx.getOpToPartPruner());
 
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R1", "(TS%FIL%)|(TS%FIL%FIL%)"), OpProcFactory
-        .getFilterProc());
+    opRules.put(new RuleRegExp("R1",
+      "(" + TableScanOperator.getOperatorName() + "%"
+      + FilterOperator.getOperatorName() + "%)|("
+      + TableScanOperator.getOperatorName() + "%"
+      + FilterOperator.getOperatorName() + "%"
+      + FilterOperator.getOperatorName() + "%)"),
+      OpProcFactory.getFilterProc());
 
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/unionproc/UnionProcessor.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/unionproc/UnionProcessor.java
index f6b3853d47..c658c3f041 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/unionproc/UnionProcessor.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/unionproc/UnionProcessor.java
@@ -22,6 +22,11 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 
+import org.apache.hadoop.hive.ql.exec.Operator;
+import org.apache.hadoop.hive.ql.exec.MapJoinOperator;
+import org.apache.hadoop.hive.ql.exec.TableScanOperator;
+import org.apache.hadoop.hive.ql.exec.UnionOperator;
+import org.apache.hadoop.hive.ql.exec.ReduceSinkOperator;
 import org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher;
 import org.apache.hadoop.hive.ql.lib.Dispatcher;
 import org.apache.hadoop.hive.ql.lib.GraphWalker;
@@ -63,14 +68,18 @@ public ParseContext transform(ParseContext pCtx) throws SemanticException {
     // create a walker which walks the tree in a DFS manner while maintaining
     // the operator stack.
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R1", "RS%.*UNION%"),
-        UnionProcFactory.getMapRedUnion());
-    opRules.put(new RuleRegExp("R2", "UNION%.*UNION%"),
-        UnionProcFactory.getUnknownUnion());
-    opRules.put(new RuleRegExp("R3", "TS%.*UNION%"),
-        UnionProcFactory.getMapUnion());
-    opRules.put(new RuleRegExp("R3", "MAPJOIN%.*UNION%"),
-        UnionProcFactory.getMapJoinUnion());
+    opRules.put(new RuleRegExp("R1",
+      ReduceSinkOperator.getOperatorName() + "%.*" + UnionOperator.getOperatorName() + "%"),
+      UnionProcFactory.getMapRedUnion());
+    opRules.put(new RuleRegExp("R2",
+      UnionOperator.getOperatorName() + "%.*" + UnionOperator.getOperatorName() + "%"),
+      UnionProcFactory.getUnknownUnion());
+    opRules.put(new RuleRegExp("R3",
+      TableScanOperator.getOperatorName() + "%.*" + UnionOperator.getOperatorName() + "%"),
+      UnionProcFactory.getMapUnion());
+    opRules.put(new RuleRegExp("R3",
+      MapJoinOperator.getOperatorName() + "%.*" + UnionOperator.getOperatorName() + "%"),
+      UnionProcFactory.getMapJoinUnion());
 
     // The dispatcher fires the processor for the matching rule and passes the
     // context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
index 577bfb0114..73a62ea185 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
@@ -62,6 +62,7 @@
 import org.apache.hadoop.hive.ql.exec.FunctionRegistry;
 import org.apache.hadoop.hive.ql.exec.GroupByOperator;
 import org.apache.hadoop.hive.ql.exec.JoinOperator;
+import org.apache.hadoop.hive.ql.exec.MapJoinOperator;
 import org.apache.hadoop.hive.ql.exec.MapRedTask;
 import org.apache.hadoop.hive.ql.exec.Operator;
 import org.apache.hadoop.hive.ql.exec.OperatorFactory;
@@ -70,6 +71,7 @@
 import org.apache.hadoop.hive.ql.exec.ReduceSinkOperator;
 import org.apache.hadoop.hive.ql.exec.RowSchema;
 import org.apache.hadoop.hive.ql.exec.StatsTask;
+import org.apache.hadoop.hive.ql.exec.SelectOperator;
 import org.apache.hadoop.hive.ql.exec.TableScanOperator;
 import org.apache.hadoop.hive.ql.exec.Task;
 import org.apache.hadoop.hive.ql.exec.TaskFactory;
@@ -7141,27 +7143,42 @@ private void genMapRedTasks(ParseContext pCtx) throws SemanticException {
     // the operator stack.
     // The dispatcher generates the plan from the operator tree
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp(new String("R1"), "TS%"), new GenMRTableScan1());
-    opRules.put(new RuleRegExp(new String("R2"), "TS%.*RS%"),
-        new GenMRRedSink1());
-    opRules.put(new RuleRegExp(new String("R3"), "RS%.*RS%"),
-        new GenMRRedSink2());
-    opRules.put(new RuleRegExp(new String("R4"), "FS%"), new GenMRFileSink1());
-    opRules.put(new RuleRegExp(new String("R5"), "UNION%"), new GenMRUnion1());
-    opRules.put(new RuleRegExp(new String("R6"), "UNION%.*RS%"),
-        new GenMRRedSink3());
-    opRules.put(new RuleRegExp(new String("R6"), "MAPJOIN%.*RS%"),
-        new GenMRRedSink4());
-    opRules.put(new RuleRegExp(new String("R7"), "TS%.*MAPJOIN%"),
-        MapJoinFactory.getTableScanMapJoin());
-    opRules.put(new RuleRegExp(new String("R8"), "RS%.*MAPJOIN%"),
-        MapJoinFactory.getReduceSinkMapJoin());
-    opRules.put(new RuleRegExp(new String("R9"), "UNION%.*MAPJOIN%"),
-        MapJoinFactory.getUnionMapJoin());
-    opRules.put(new RuleRegExp(new String("R10"), "MAPJOIN%.*MAPJOIN%"),
-        MapJoinFactory.getMapJoinMapJoin());
-    opRules.put(new RuleRegExp(new String("R11"), "MAPJOIN%SEL%"),
-        MapJoinFactory.getMapJoin());
+    opRules.put(new RuleRegExp(new String("R1"),
+      TableScanOperator.getOperatorName() + "%"),
+      new GenMRTableScan1());
+    opRules.put(new RuleRegExp(new String("R2"),
+      TableScanOperator.getOperatorName() + "%.*" + ReduceSinkOperator.getOperatorName() + "%"),
+      new GenMRRedSink1());
+    opRules.put(new RuleRegExp(new String("R3"),
+      ReduceSinkOperator.getOperatorName() + "%.*" + ReduceSinkOperator.getOperatorName() + "%"),
+      new GenMRRedSink2());
+    opRules.put(new RuleRegExp(new String("R4"),
+      FileSinkOperator.getOperatorName() + "%"),
+      new GenMRFileSink1());
+    opRules.put(new RuleRegExp(new String("R5"),
+      UnionOperator.getOperatorName() + "%"),
+      new GenMRUnion1());
+    opRules.put(new RuleRegExp(new String("R6"),
+      UnionOperator.getOperatorName() + "%.*" + ReduceSinkOperator.getOperatorName() + "%"),
+      new GenMRRedSink3());
+    opRules.put(new RuleRegExp(new String("R6"),
+      MapJoinOperator.getOperatorName() + "%.*" + ReduceSinkOperator.getOperatorName() + "%"),
+      new GenMRRedSink4());
+    opRules.put(new RuleRegExp(new String("R7"),
+      TableScanOperator.getOperatorName() + "%.*" + MapJoinOperator.getOperatorName() + "%"),
+      MapJoinFactory.getTableScanMapJoin());
+    opRules.put(new RuleRegExp(new String("R8"),
+      ReduceSinkOperator.getOperatorName() + "%.*" + MapJoinOperator.getOperatorName() + "%"),
+      MapJoinFactory.getReduceSinkMapJoin());
+    opRules.put(new RuleRegExp(new String("R9"),
+      UnionOperator.getOperatorName() + "%.*" + MapJoinOperator.getOperatorName() + "%"),
+      MapJoinFactory.getUnionMapJoin());
+    opRules.put(new RuleRegExp(new String("R10"),
+      MapJoinOperator.getOperatorName() + "%.*" + MapJoinOperator.getOperatorName() + "%"),
+      MapJoinFactory.getMapJoinMapJoin());
+    opRules.put(new RuleRegExp(new String("R11"),
+      MapJoinOperator.getOperatorName() + "%" + SelectOperator.getOperatorName() + "%"),
+      MapJoinFactory.getMapJoin());
 
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/ppd/PredicatePushDown.java b/ql/src/java/org/apache/hadoop/hive/ql/ppd/PredicatePushDown.java
index 7b23b7b140..6be3d108fa 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/ppd/PredicatePushDown.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/ppd/PredicatePushDown.java
@@ -21,6 +21,15 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 
+import org.apache.hadoop.hive.ql.exec.Operator;
+import org.apache.hadoop.hive.ql.exec.FilterOperator;
+import org.apache.hadoop.hive.ql.exec.TableScanOperator;
+import org.apache.hadoop.hive.ql.exec.ScriptOperator;
+import org.apache.hadoop.hive.ql.exec.LimitOperator;
+import org.apache.hadoop.hive.ql.exec.UDTFOperator;
+import org.apache.hadoop.hive.ql.exec.CommonJoinOperator;
+import org.apache.hadoop.hive.ql.exec.ReduceSinkOperator;
+import org.apache.hadoop.hive.ql.exec.LateralViewForwardOperator;
 import org.apache.hadoop.hive.ql.lib.DefaultGraphWalker;
 import org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher;
 import org.apache.hadoop.hive.ql.lib.Dispatcher;
@@ -78,14 +87,30 @@ public ParseContext transform(ParseContext pctx) throws SemanticException {
     OpWalkerInfo opWalkerInfo = new OpWalkerInfo(pGraphContext);
 
     Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();
-    opRules.put(new RuleRegExp("R1", "FIL%"), OpProcFactory.getFilterProc());
-    opRules.put(new RuleRegExp("R3", "JOIN%"), OpProcFactory.getJoinProc());
-    opRules.put(new RuleRegExp("R4", "RS%"), OpProcFactory.getRSProc());
-    opRules.put(new RuleRegExp("R5", "TS%"), OpProcFactory.getTSProc());
-    opRules.put(new RuleRegExp("R6", "SCR%"), OpProcFactory.getSCRProc());
-    opRules.put(new RuleRegExp("R6", "LIM%"), OpProcFactory.getLIMProc());
-    opRules.put(new RuleRegExp("R7", "UDTF%"), OpProcFactory.getUDTFProc());
-    opRules.put(new RuleRegExp("R8", "LVF%"), OpProcFactory.getLVFProc());
+    opRules.put(new RuleRegExp("R1",
+      FilterOperator.getOperatorName() + "%"),
+      OpProcFactory.getFilterProc());
+    opRules.put(new RuleRegExp("R3",
+      CommonJoinOperator.getOperatorName() + "%"),
+      OpProcFactory.getJoinProc());
+    opRules.put(new RuleRegExp("R4",
+      ReduceSinkOperator.getOperatorName() + "%"),
+      OpProcFactory.getRSProc());
+    opRules.put(new RuleRegExp("R5",
+      TableScanOperator.getOperatorName() + "%"),
+      OpProcFactory.getTSProc());
+    opRules.put(new RuleRegExp("R6",
+      ScriptOperator.getOperatorName() + "%"),
+      OpProcFactory.getSCRProc());
+    opRules.put(new RuleRegExp("R6",
+      LimitOperator.getOperatorName() + "%"),
+      OpProcFactory.getLIMProc());
+    opRules.put(new RuleRegExp("R7",
+      UDTFOperator.getOperatorName() + "%"),
+      OpProcFactory.getUDTFProc());
+    opRules.put(new RuleRegExp("R8",
+      LateralViewForwardOperator.getOperatorName() + "%"),
+      OpProcFactory.getLVFProc());
 
     // The dispatcher fires the processor corresponding to the closest matching
     // rule and passes the context along
diff --git a/ql/src/test/queries/clientpositive/recursive_dir.q b/ql/src/test/queries/clientpositive/recursive_dir.q
new file mode 100644
index 0000000000..43f373d2c4
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/recursive_dir.q
@@ -0,0 +1,19 @@
+-- The test verifies that sub-directories are supported for versions of hadoop
+-- where MAPREDUCE-1501 is fixed. So, enable this test only for hadoop 23.
+-- INCLUDE_HADOOP_MAJOR_VERSIONS(0.23)
+
+CREATE TABLE fact_daily(x int) PARTITIONED BY (ds STRING);
+CREATE TABLE fact_tz(x int) PARTITIONED BY (ds STRING, hr STRING) 
+LOCATION 'pfile:${system:test.tmp.dir}/fact_tz';
+
+INSERT OVERWRITE TABLE fact_tz PARTITION (ds='1', hr='1')
+SELECT key+11 FROM src WHERE key=484;
+
+ALTER TABLE fact_daily SET TBLPROPERTIES('EXTERNAL'='TRUE');
+ALTER TABLE fact_daily ADD PARTITION (ds='1')
+LOCATION 'pfile:${system:test.tmp.dir}/fact_tz/ds=1';
+
+set mapred.input.dir.recursive=true;
+SELECT * FROM fact_daily WHERE ds='1';
+
+SELECT count(1) FROM fact_daily WHERE ds='1';
