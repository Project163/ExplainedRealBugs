diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java
index 92dd1790cb..089d95f607 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java
@@ -599,74 +599,75 @@ private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {
       // into a null value.
       final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();
       final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));
-
-      for (int i = 0; i < operands.size(); i++) {
-        RexNode operand = operands.get(i);
-        if (operand instanceof RexCall && HiveIn.INSTANCE.equals(((RexCall) operand).op)) {
-          RexCall inCall = (RexCall) operand;
-          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {
-            continue;
-          }
-          RexNode ref = inCall.getOperands().get(0);
-          visitedRefs.add(ref);
-          if (ref.getType().isNullable()) {
-            inLHSExprToRHSNullableExprs.put(ref, ref);
-          }
-          if (inLHSExprToRHSExprs.containsKey(ref)) {
-            Set<SimilarRexNodeElement> expressions = Sets.newHashSet();
-            for (int j = 1; j < inCall.getOperands().size(); j++) {
-              RexNode constNode = inCall.getOperands().get(j);
-              expressions.add(new SimilarRexNodeElement(constNode));
-              if (constNode.getType().isNullable()) {
-                inLHSExprToRHSNullableExprs.put(ref, constNode);
-              }
-            }
-            Collection<SimilarRexNodeElement> knownConstants = inLHSExprToRHSExprs.get(ref);
-            if (!shareSameType(knownConstants, expressions)) {
-              return call;
+      final List<RexNode> newOperands = new ArrayList<>(operands.size());
+      int inExpressionCount = 0;
+      int eqExpressionCount = 0;
+      for (RexNode operand : operands) {
+        if (operand instanceof RexCall inCall && HiveIn.INSTANCE.equals(inCall.op)) {
+          RexNode ref = inCall.getOperands().getFirst();
+          if (HiveCalciteUtil.isDeterministic(ref)) {
+            visitedRefs.add(ref);
+            if (ref.getType().isNullable()) {
+              inLHSExprToRHSNullableExprs.put(ref, ref);
             }
-            knownConstants.retainAll(expressions);
-          } else {
-            for (int j = 1; j < inCall.getOperands().size(); j++) {
-              RexNode constNode = inCall.getOperands().get(j);
-              inLHSExprToRHSExprs.put(ref, new SimilarRexNodeElement(constNode));
-              if (constNode.getType().isNullable()) {
-                inLHSExprToRHSNullableExprs.put(ref, constNode);
+            if (inLHSExprToRHSExprs.containsKey(ref)) {
+              Set<SimilarRexNodeElement> expressions = Sets.newHashSet();
+              for (int j = 1; j < inCall.getOperands().size(); j++) {
+                RexNode constNode = inCall.getOperands().get(j);
+                expressions.add(new SimilarRexNodeElement(constNode));
+                if (constNode.getType().isNullable()) {
+                  inLHSExprToRHSNullableExprs.put(ref, constNode);
+                }
+              }
+              Collection<SimilarRexNodeElement> knownConstants = inLHSExprToRHSExprs.get(ref);
+              if (!shareSameType(knownConstants, expressions)) {
+                return call;
+              }
+              knownConstants.retainAll(expressions);
+            } else {
+              for (int j = 1; j < inCall.getOperands().size(); j++) {
+                RexNode constNode = inCall.getOperands().get(j);
+                inLHSExprToRHSExprs.put(ref, new SimilarRexNodeElement(constNode));
+                if (constNode.getType().isNullable()) {
+                  inLHSExprToRHSNullableExprs.put(ref, constNode);
+                }
               }
             }
+            ++inExpressionCount;
+            continue;
           }
-          operands.remove(i);
-          --i;
         } else if (operand.getKind() == SqlKind.EQUALS) {
           Constraint c = Constraint.of(operand);
-          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {
-            continue;
-          }
-          visitedRefs.add(c.exprNode);
-          if (c.exprNode.getType().isNullable()) {
-            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);
-          }
-          if (c.constNode.getType().isNullable()) {
-            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);
-          }
-          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {
-            Collection<SimilarRexNodeElement> knownConstants = inLHSExprToRHSExprs.get(c.exprNode);
-            Collection<SimilarRexNodeElement> nextConstant = Collections.singleton(new SimilarRexNodeElement(c.constNode));
-            if (!shareSameType(knownConstants, nextConstant)) {
-              return call;
+          if (c != null && HiveCalciteUtil.isDeterministic(c.exprNode)) {
+            visitedRefs.add(c.exprNode);
+            if (c.exprNode.getType().isNullable()) {
+              inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);
+            }
+            if (c.constNode.getType().isNullable()) {
+              inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);
+            }
+            if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {
+              Collection<SimilarRexNodeElement> knownConstants = inLHSExprToRHSExprs.get(c.exprNode);
+              Collection<SimilarRexNodeElement> nextConstant = Collections.singleton(new SimilarRexNodeElement(c.constNode));
+              if (!shareSameType(knownConstants, nextConstant)) {
+                return call;
+              }
+              knownConstants.retainAll(nextConstant);
+            } else {
+              inLHSExprToRHSExprs.put(c.exprNode, new SimilarRexNodeElement(c.constNode));
             }
-            knownConstants.retainAll(nextConstant);
-          } else {
-            inLHSExprToRHSExprs.put(c.exprNode, new SimilarRexNodeElement(c.constNode));
+            ++eqExpressionCount;
+            continue;
           }
-          operands.remove(i);
-          --i;
         }
+        newOperands.add(operand);
+      }
+      if (inExpressionCount + eqExpressionCount == inLHSExprToRHSExprs.keySet().size()) {
+        // No IN and Equality expressions can be merged, bail out
+        return call;
       }
       // Create IN clauses
-      final List<RexNode> newOperands = createInClauses(rexBuilder,
-          visitedRefs, inLHSExprToRHSExprs, inLHSExprToRHSNullableExprs);
-      newOperands.addAll(operands);
+      newOperands.addAll(createInClauses(rexBuilder, visitedRefs, inLHSExprToRHSExprs, inLHSExprToRHSNullableExprs));
       // Return node
       return RexUtil.composeConjunction(rexBuilder, newOperands, false);
     }
@@ -734,26 +735,28 @@ private static boolean shareSameType(
     private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {
       // IN clauses need to be combined by keeping all elements
       final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));
-      final Multimap<RexNode,SimilarRexNodeElement> inLHSExprToRHSExprs = LinkedHashMultimap.create();
-      for (int i = 0; i < operands.size(); i++) {
-        RexNode operand = operands.get(i);
-        if (operand instanceof RexCall && HiveIn.INSTANCE.equals(((RexCall) operand).op)) {
-          RexCall inCall = (RexCall) operand;
-          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {
+      final List<RexNode> newOperands = new ArrayList<>(operands.size());
+      final Multimap<RexNode, SimilarRexNodeElement> inLHSExprToRHSExprs = LinkedHashMultimap.create();
+      int inExpressionCount = 0;
+      for (RexNode operand : operands) {
+        if (operand instanceof RexCall inCall && HiveIn.INSTANCE.equals(inCall.op)) {
+          RexNode ref = inCall.getOperands().getFirst();
+          if (HiveCalciteUtil.isDeterministic(ref)) {
+            for (int j = 1; j < inCall.getOperands().size(); j++) {
+              inLHSExprToRHSExprs.put(ref, new SimilarRexNodeElement(inCall.getOperands().get(j)));
+            }
+            ++inExpressionCount;
             continue;
           }
-          RexNode ref = inCall.getOperands().get(0);
-          for (int j = 1; j < inCall.getOperands().size(); j++) {
-            inLHSExprToRHSExprs.put(ref, new SimilarRexNodeElement(inCall.getOperands().get(j)));
-          }
-          operands.remove(i);
-          --i;
         }
+        newOperands.add(operand);
+      }
+      if (inExpressionCount == inLHSExprToRHSExprs.keySet().size()) {
+        // No IN expressions can be merged, bail out
+        return call;
       }
       // Create IN clauses (fourth parameter is not needed since no expressions were removed)
-      final List<RexNode> newOperands = createInClauses(rexBuilder,
-          inLHSExprToRHSExprs.keySet(), inLHSExprToRHSExprs, null);
-      newOperands.addAll(operands);
+      newOperands.addAll(createInClauses(rexBuilder, inLHSExprToRHSExprs.keySet(), inLHSExprToRHSExprs, null));
       // Return node
       RexNode result = RexUtil.composeDisjunction(rexBuilder, newOperands, false);
       if (!result.getType().equals(call.getType())) {
@@ -782,7 +785,7 @@ private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,
 
     private static List<RexNode> createInClauses(RexBuilder rexBuilder, Set<RexNode> visitedRefs,
         Multimap<RexNode, SimilarRexNodeElement> inLHSExprToRHSExprs, Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs) {
-      final List<RexNode> newExpressions = new ArrayList<>();
+      final List<RexNode> newExpressions = new ArrayList<>(visitedRefs.size());
       for (RexNode ref : visitedRefs) {
         Collection<SimilarRexNodeElement> exprs = inLHSExprToRHSExprs.get(ref);
         if (exprs.isEmpty()) {
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/optimizer/calcite/rules/TestHivePointLookupOptimizerRule.java b/ql/src/test/org/apache/hadoop/hive/ql/optimizer/calcite/rules/TestHivePointLookupOptimizerRule.java
index 199a0673c8..afb089edb3 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/optimizer/calcite/rules/TestHivePointLookupOptimizerRule.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/optimizer/calcite/rules/TestHivePointLookupOptimizerRule.java
@@ -25,6 +25,7 @@
 import org.apache.calcite.rex.RexBuilder;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.sql.SqlCollation;
+import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.util.ConversionUtil;
@@ -311,7 +312,7 @@ public void testObscuredSimple() {
     HiveFilter filter = (HiveFilter) optimizedRelNode;
     RexNode condition = filter.getCondition();
     System.out.println(condition);
-    assertEquals("OR(IN($0, 1, 2), =($1, 99))", condition.toString());
+    assertEquals("OR(=($1, 99), IN($0, 1, 2))", condition.toString());
   }
 
   /** Despite that extraction happen at a higher level; nested parts should also be handled */
@@ -520,4 +521,27 @@ public void testSameDecimalLiteralDifferentPrecision() {
     System.out.println(condition);
     assertEquals("IN($1, 10000:DECIMAL(19, 5), 11000:DECIMAL(19, 5))", condition.toString());
   }
+
+  @Test
+  public void testNothingToBeMergedInOrExpressionAndOperandOrderIsUnchanged() {
+    // @formatter:off
+    final RelNode basePlan = relBuilder
+            .scan("t")
+            .filter(
+                    or(relBuilder,
+                            relBuilder.call(SqlStdOperatorTable.IS_NULL, relBuilder.field("f1")),
+                            relBuilder.call(HiveIn.INSTANCE,
+                                    relBuilder.field("f1"), relBuilder.literal(1), relBuilder.literal(2))
+                      )
+                    )
+            .build();
+    // @formatter:on
+
+    planner.setRoot(basePlan);
+    RelNode optimizedRelNode = planner.findBestExp();
+
+    HiveFilter filter = (HiveFilter) optimizedRelNode;
+    RexNode condition = filter.getCondition();
+    assertEquals("OR(IS NULL($0), IN($0, 1, 2))", condition.toString());
+  }
 }
diff --git a/ql/src/test/queries/clientpositive/pointlookup6.q b/ql/src/test/queries/clientpositive/pointlookup6.q
index d1b05e7fc0..afd0d199fa 100644
--- a/ql/src/test/queries/clientpositive/pointlookup6.q
+++ b/ql/src/test/queries/clientpositive/pointlookup6.q
@@ -17,3 +17,11 @@ WHERE r_table.string_col = l_table.string_col AND l_table.string_col IN ('AAA111
 
 SELECT l_table.string_col from l_table, r_table
 WHERE r_table.string_col = l_table.string_col AND l_table.string_col IN ('AAA111', 'BBB222') AND r_table.string_col IN ('AAA111', 'BBB222');
+
+explain cbo
+SELECT * FROM r_table
+WHERE (
+        MINUTE(string_col) = 2 OR
+        MINUTE(string_col) = 10 OR
+        MINUTE(string_col) IS NULL
+      );
diff --git a/ql/src/test/results/clientpositive/llap/bucket_map_join_tez3.q.out b/ql/src/test/results/clientpositive/llap/bucket_map_join_tez3.q.out
index 1330de2ce3..6b92ef7ad4 100644
--- a/ql/src/test/results/clientpositive/llap/bucket_map_join_tez3.q.out
+++ b/ql/src/test/results/clientpositive/llap/bucket_map_join_tez3.q.out
@@ -109,7 +109,7 @@ POSTHOOK: Input: default@target_table
 OPTIMIZED SQL: SELECT `t0`.`date_col`, CAST('pipeline' AS STRING) AS `string_col`, `t0`.`decimal_col`, `t2`.`date_col` AS `date_col1`, 'pipeline' AS `string_col1`, `t2`.`decimal_col` AS `decimal_col1`
 FROM (SELECT `date_col`, `decimal_col`
 FROM `default`.`target_table`
-WHERE `string_col` = 'pipeline' AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
+WHERE 'pipeline' = `string_col` AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
 INNER JOIN (SELECT `date_col`, `decimal_col`
 FROM `default`.`source_table`
 WHERE CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t2` ON `t0`.`date_col` = `t2`.`date_col` AND `t0`.`decimal_col` = `t2`.`decimal_col`
@@ -336,7 +336,7 @@ POSTHOOK: Input: default@target_table
 OPTIMIZED SQL: SELECT `t0`.`date_col`, CAST('pipeline' AS STRING) AS `string_col`, `t0`.`decimal_col`, `t3`.`date_col` AS `date_col1`, 'pipeline' AS `string_col1`, `t3`.`decimal_col` AS `decimal_col1`
 FROM (SELECT `date_col`, `decimal_col`
 FROM `default`.`target_table`
-WHERE `string_col` = 'pipeline' AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
+WHERE 'pipeline' = `string_col` AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
 INNER JOIN (SELECT `date_col`, `decimal_col`
 FROM `default`.`source_table`
 WHERE CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL
@@ -586,7 +586,7 @@ POSTHOOK: Input: default@target_table
 OPTIMIZED SQL: SELECT `t0`.`date_col`, CAST('pipeline' AS STRING) AS `string_col`, `t0`.`decimal_col`, `t2`.`date_col` AS `date_col1`, 'pipeline' AS `string_col1`, `t2`.`decimal_col` AS `decimal_col1`
 FROM (SELECT `date_col`, `decimal_col`
 FROM `default`.`target_table`
-WHERE `string_col` = 'pipeline' AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
+WHERE 'pipeline' = `string_col` AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
 INNER JOIN (SELECT `date_col`, `decimal_col`
 FROM `default`.`source_table`
 WHERE CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t2` ON `t0`.`date_col` = `t2`.`date_col` AND `t0`.`decimal_col` = `t2`.`decimal_col`
@@ -812,7 +812,7 @@ POSTHOOK: Input: default@target_table
 OPTIMIZED SQL: SELECT `t0`.`date_col`, CAST('pipeline' AS STRING) AS `string_col`, `t0`.`decimal_col`, `t3`.`date_col` AS `date_col1`, 'pipeline' AS `string_col1`, `t3`.`decimal_col` AS `decimal_col1`
 FROM (SELECT `date_col`, `decimal_col`
 FROM `default`.`target_table`
-WHERE `string_col` = 'pipeline' AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
+WHERE 'pipeline' = `string_col` AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
 INNER JOIN (SELECT `date_col`, `decimal_col`
 FROM `default`.`source_table`
 WHERE CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL
@@ -1061,7 +1061,7 @@ POSTHOOK: Input: default@target_table
 OPTIMIZED SQL: SELECT `t0`.`date_col`, CAST('pipeline' AS STRING) AS `string_col`, `t0`.`decimal_col`, `t2`.`date_col` AS `date_col1`, 'pipeline' AS `string_col1`, `t2`.`decimal_col` AS `decimal_col1`
 FROM (SELECT `date_col`, `decimal_col`
 FROM `default`.`target_table`
-WHERE `string_col` = 'pipeline' AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
+WHERE 'pipeline' = `string_col` AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
 INNER JOIN (SELECT `date_col`, `decimal_col`
 FROM `default`.`source_table`
 WHERE CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t2` ON `t0`.`date_col` = `t2`.`date_col` AND `t0`.`decimal_col` = `t2`.`decimal_col`
@@ -1288,7 +1288,7 @@ POSTHOOK: Input: default@target_table
 OPTIMIZED SQL: SELECT `t0`.`date_col`, CAST('pipeline' AS STRING) AS `string_col`, `t0`.`decimal_col`, `t3`.`date_col` AS `date_col1`, 'pipeline' AS `string_col1`, `t3`.`decimal_col` AS `decimal_col1`
 FROM (SELECT `date_col`, `decimal_col`
 FROM `default`.`target_table`
-WHERE `string_col` = 'pipeline' AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
+WHERE 'pipeline' = `string_col` AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
 INNER JOIN (SELECT `date_col`, `decimal_col`
 FROM `default`.`source_table`
 WHERE CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL
@@ -1538,7 +1538,7 @@ POSTHOOK: Input: default@target_table
 OPTIMIZED SQL: SELECT `t0`.`date_col`, CAST('pipeline' AS STRING) AS `string_col`, `t0`.`decimal_col`, `t2`.`date_col` AS `date_col1`, 'pipeline' AS `string_col1`, `t2`.`decimal_col` AS `decimal_col1`
 FROM (SELECT `date_col`, `decimal_col`
 FROM `default`.`target_table`
-WHERE `string_col` = 'pipeline' AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
+WHERE 'pipeline' = `string_col` AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
 INNER JOIN (SELECT `date_col`, `decimal_col`
 FROM `default`.`source_table`
 WHERE CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t2` ON `t0`.`date_col` = `t2`.`date_col` AND `t0`.`decimal_col` = `t2`.`decimal_col`
@@ -1764,7 +1764,7 @@ POSTHOOK: Input: default@target_table
 OPTIMIZED SQL: SELECT `t0`.`date_col`, CAST('pipeline' AS STRING) AS `string_col`, `t0`.`decimal_col`, `t3`.`date_col` AS `date_col1`, 'pipeline' AS `string_col1`, `t3`.`decimal_col` AS `decimal_col1`
 FROM (SELECT `date_col`, `decimal_col`
 FROM `default`.`target_table`
-WHERE `string_col` = 'pipeline' AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
+WHERE 'pipeline' = `string_col` AND CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL) AS `t0`
 INNER JOIN (SELECT `date_col`, `decimal_col`
 FROM `default`.`source_table`
 WHERE CASE WHEN `decimal_col` IS NOT NULL THEN CAST(`decimal_col` AS STRING) = '50000000000000000005905545593' ELSE FALSE END AND `date_col` IS NOT NULL AND `decimal_col` IS NOT NULL
diff --git a/ql/src/test/results/clientpositive/llap/bucketpruning1.q.out b/ql/src/test/results/clientpositive/llap/bucketpruning1.q.out
index 538017c538..95ec3ae60d 100644
--- a/ql/src/test/results/clientpositive/llap/bucketpruning1.q.out
+++ b/ql/src/test/results/clientpositive/llap/bucketpruning1.q.out
@@ -736,7 +736,7 @@ POSTHOOK: Input: default@srcbucket_pruned
 #### A masked pattern was here ####
 OPTIMIZED SQL: SELECT `key`, `value`, CAST('2008-04-08' AS STRING) AS `ds`
 FROM `default`.`srcbucket_pruned`
-WHERE `ds` = '2008-04-08' AND `key` IN (2, 3)
+WHERE `key` IN (2, 3) AND `ds` = '2008-04-08'
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
@@ -750,13 +750,13 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: srcbucket_pruned
-                  filterExpr: ((ds = '2008-04-08') and (key) IN (2, 3)) (type: boolean)
+                  filterExpr: ((key) IN (2, 3) and (ds = '2008-04-08')) (type: boolean)
                   buckets included: [4,6,] of 16
                   Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                   GatherStats: false
                   Filter Operator
                     isSamplingPred: false
-                    predicate: ((ds = '2008-04-08') and (key) IN (2, 3)) (type: boolean)
+                    predicate: ((key) IN (2, 3) and (ds = '2008-04-08')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: key (type: int), value (type: string), '2008-04-08' (type: string)
@@ -807,7 +807,7 @@ POSTHOOK: Input: default@srcbucket_pruned
 #### A masked pattern was here ####
 OPTIMIZED SQL: SELECT `key`, CAST('One' AS STRING) AS `value`, CAST('2008-04-08' AS STRING) AS `ds`
 FROM `default`.`srcbucket_pruned`
-WHERE `ds` = '2008-04-08' AND `value` = 'One' AND `key` IN (2, 3)
+WHERE `key` IN (2, 3) AND `ds` = '2008-04-08' AND `value` = 'One'
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
@@ -821,13 +821,13 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: srcbucket_pruned
-                  filterExpr: ((ds = '2008-04-08') and (value = 'One') and (key) IN (2, 3)) (type: boolean)
+                  filterExpr: ((key) IN (2, 3) and (ds = '2008-04-08') and (value = 'One')) (type: boolean)
                   buckets included: [4,6,] of 16
                   Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                   GatherStats: false
                   Filter Operator
                     isSamplingPred: false
-                    predicate: ((ds = '2008-04-08') and (value = 'One') and (key) IN (2, 3)) (type: boolean)
+                    predicate: ((key) IN (2, 3) and (ds = '2008-04-08') and (value = 'One')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: key (type: int), 'One' (type: string), '2008-04-08' (type: string)
@@ -878,7 +878,7 @@ POSTHOOK: Input: default@srcbucket_pruned
 #### A masked pattern was here ####
 OPTIMIZED SQL: SELECT `key`, CAST('One' AS STRING) AS `value`, CAST('2008-04-08' AS STRING) AS `ds`
 FROM `default`.`srcbucket_pruned`
-WHERE `value` = 'One' AND `ds` = '2008-04-08' AND `key` IN (2, 3)
+WHERE `value` = 'One' AND `key` IN (2, 3) AND `ds` = '2008-04-08'
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
@@ -892,13 +892,13 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: srcbucket_pruned
-                  filterExpr: ((value = 'One') and (ds = '2008-04-08') and (key) IN (2, 3)) (type: boolean)
+                  filterExpr: ((value = 'One') and (key) IN (2, 3) and (ds = '2008-04-08')) (type: boolean)
                   buckets included: [4,6,] of 16
                   Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                   GatherStats: false
                   Filter Operator
                     isSamplingPred: false
-                    predicate: ((value = 'One') and (ds = '2008-04-08') and (key) IN (2, 3)) (type: boolean)
+                    predicate: ((value = 'One') and (key) IN (2, 3) and (ds = '2008-04-08')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: key (type: int), 'One' (type: string), '2008-04-08' (type: string)
@@ -949,7 +949,7 @@ POSTHOOK: Input: default@srcbucket_pruned
 #### A masked pattern was here ####
 OPTIMIZED SQL: SELECT `key`, `value`, CAST('2008-04-08' AS STRING) AS `ds`
 FROM `default`.`srcbucket_pruned`
-WHERE `ds` = '2008-04-08' AND `key` IN (1, 2)
+WHERE `key` IN (1, 2) AND `ds` = '2008-04-08'
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
@@ -963,13 +963,13 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: srcbucket_pruned
-                  filterExpr: ((ds = '2008-04-08') and (key) IN (1, 2)) (type: boolean)
+                  filterExpr: ((key) IN (1, 2) and (ds = '2008-04-08')) (type: boolean)
                   buckets included: [4,13,] of 16
                   Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                   GatherStats: false
                   Filter Operator
                     isSamplingPred: false
-                    predicate: ((ds = '2008-04-08') and (key) IN (1, 2)) (type: boolean)
+                    predicate: ((key) IN (1, 2) and (ds = '2008-04-08')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: key (type: int), value (type: string), '2008-04-08' (type: string)
@@ -1020,7 +1020,7 @@ POSTHOOK: Input: default@srcbucket_pruned
 #### A masked pattern was here ####
 OPTIMIZED SQL: SELECT `key`, CAST('One' AS STRING) AS `value`, CAST('2008-04-08' AS STRING) AS `ds`
 FROM `default`.`srcbucket_pruned`
-WHERE `value` = 'One' AND `ds` = '2008-04-08' AND `key` IN (1, 2)
+WHERE `key` IN (1, 2) AND `value` = 'One' AND `ds` = '2008-04-08'
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
@@ -1034,13 +1034,13 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: srcbucket_pruned
-                  filterExpr: ((value = 'One') and (ds = '2008-04-08') and (key) IN (1, 2)) (type: boolean)
+                  filterExpr: ((key) IN (1, 2) and (value = 'One') and (ds = '2008-04-08')) (type: boolean)
                   buckets included: [4,13,] of 16
                   Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                   GatherStats: false
                   Filter Operator
                     isSamplingPred: false
-                    predicate: ((value = 'One') and (ds = '2008-04-08') and (key) IN (1, 2)) (type: boolean)
+                    predicate: ((key) IN (1, 2) and (value = 'One') and (ds = '2008-04-08')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 268 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: key (type: int), 'One' (type: string), '2008-04-08' (type: string)
diff --git a/ql/src/test/results/clientpositive/llap/fold_eq_with_case_when.q.out b/ql/src/test/results/clientpositive/llap/fold_eq_with_case_when.q.out
index 88f9b0594b..1fb1a96795 100644
--- a/ql/src/test/results/clientpositive/llap/fold_eq_with_case_when.q.out
+++ b/ql/src/test/results/clientpositive/llap/fold_eq_with_case_when.q.out
@@ -50,10 +50,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: lineitem
-                  filterExpr: ((l_shipmode = 'RAIL') and (to_date(CAST( l_shipdate AS TIMESTAMP)) = DATE'1996-03-30')) (type: boolean)
+                  filterExpr: ((l_shipmode = 'RAIL') and (DATE'1996-03-30' = to_date(CAST( l_shipdate AS TIMESTAMP)))) (type: boolean)
                   Statistics: Num rows: 100 Data size: 19000 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((l_shipmode = 'RAIL') and (to_date(CAST( l_shipdate AS TIMESTAMP)) = DATE'1996-03-30')) (type: boolean)
+                    predicate: ((l_shipmode = 'RAIL') and (DATE'1996-03-30' = to_date(CAST( l_shipdate AS TIMESTAMP)))) (type: boolean)
                     Statistics: Num rows: 7 Data size: 1330 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: l_orderkey (type: int), (UDFToDouble(l_partkey) / 1000000.0D) (type: double)
diff --git a/ql/src/test/results/clientpositive/llap/join_filters_overlap.q.out b/ql/src/test/results/clientpositive/llap/join_filters_overlap.q.out
index 78155ec9d5..a4c9b287d6 100644
--- a/ql/src/test/results/clientpositive/llap/join_filters_overlap.q.out
+++ b/ql/src/test/results/clientpositive/llap/join_filters_overlap.q.out
@@ -23,10 +23,10 @@ FROM (SELECT `key`, `value`, `value` = 60 AS `EXPR$0`, `value` = 50 AS `EXPR$1`
 FROM `default`.`a_n4`) AS `t`
 LEFT JOIN (SELECT `key`, CAST(50 AS INT) AS `value`
 FROM `default`.`a_n4`
-WHERE `value` = 50 AND `key` IS NOT NULL) AS `t1` ON `t`.`EXPR$1` AND `t`.`key` = `t1`.`key`
+WHERE `value` = 50 AND `key` IS NOT NULL) AS `t1` ON `t`.`key` = `t1`.`key` AND `t`.`EXPR$1`
 LEFT JOIN (SELECT `key`, CAST(60 AS INT) AS `value`
 FROM `default`.`a_n4`
-WHERE `value` = 60 AND `key` IS NOT NULL) AS `t3` ON `t`.`EXPR$0` AND `t`.`key` = `t3`.`key`
+WHERE `value` = 60 AND `key` IS NOT NULL) AS `t3` ON `t`.`key` = `t3`.`key` AND `t`.`EXPR$0`
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
@@ -301,10 +301,10 @@ FROM (SELECT `key`, CAST(50 AS INT) AS `value`
 FROM `default`.`a_n4`
 WHERE `value` = 50 AND `key` IS NOT NULL) AS `t0`
 RIGHT JOIN (SELECT `key`, `value`, `value` = 60 AS `EXPR$0`, `value` = 50 AS `EXPR$1`
-FROM `default`.`a_n4`) AS `t1` ON `t1`.`EXPR$1` AND `t0`.`key` = `t1`.`key`
+FROM `default`.`a_n4`) AS `t1` ON `t0`.`key` = `t1`.`key` AND `t1`.`EXPR$1`
 LEFT JOIN (SELECT `key`, CAST(60 AS INT) AS `value`
 FROM `default`.`a_n4`
-WHERE `value` = 60 AND `key` IS NOT NULL) AS `t3` ON `t1`.`EXPR$0` AND `t1`.`key` = `t3`.`key`
+WHERE `value` = 60 AND `key` IS NOT NULL) AS `t3` ON `t1`.`key` = `t3`.`key` AND `t1`.`EXPR$0`
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
@@ -579,10 +579,10 @@ FROM (SELECT `key`, CAST(50 AS INT) AS `value`
 FROM `default`.`a_n4`
 WHERE `value` = 50 AND `key` IS NOT NULL) AS `t0`
 RIGHT JOIN (SELECT `key`, `value`, `value` = 60 AS `EXPR$0`, `value` = 50 AS `EXPR$1`
-FROM `default`.`a_n4`) AS `t1` ON `t1`.`EXPR$1` AND `t0`.`key` = `t1`.`key`
+FROM `default`.`a_n4`) AS `t1` ON `t0`.`key` = `t1`.`key` AND `t1`.`EXPR$1`
 LEFT JOIN (SELECT `key`, CAST(60 AS INT) AS `value`
 FROM `default`.`a_n4`
-WHERE `value` = 60 AND `key` IS NOT NULL) AS `t3` ON `t1`.`EXPR$0` AND `t1`.`key` = `t3`.`key`
+WHERE `value` = 60 AND `key` IS NOT NULL) AS `t3` ON `t1`.`key` = `t3`.`key` AND `t1`.`EXPR$0`
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
@@ -856,13 +856,13 @@ OPTIMIZED SQL: SELECT `t`.`key`, `t`.`value`, `t0`.`key` AS `key1`, `t0`.`value`
 FROM (SELECT `key`, `value`, `value` = 40 AS `EXPR$0`, `value` = 50 AS `EXPR$1`
 FROM `default`.`a_n4`) AS `t`
 FULL JOIN (SELECT `key`, `value`, `value` = 60 AS `EXPR$1`, `value` = 50 AS `EXPR$13`
-FROM `default`.`a_n4`) AS `t0` ON `t`.`EXPR$1` AND `t0`.`EXPR$13` AND `t`.`key` = `t0`.`key`
+FROM `default`.`a_n4`) AS `t0` ON `t`.`key` = `t0`.`key` AND `t`.`EXPR$1` AND `t0`.`EXPR$13`
 LEFT JOIN (SELECT `key`, CAST(60 AS INT) AS `value`
 FROM `default`.`a_n4`
-WHERE `value` = 60 AND `key` IS NOT NULL) AS `t2` ON `t0`.`EXPR$1` AND `t0`.`key` = `t2`.`key`
+WHERE `value` = 60 AND `key` IS NOT NULL) AS `t2` ON `t0`.`key` = `t2`.`key` AND `t0`.`EXPR$1`
 LEFT JOIN (SELECT `key`, CAST(40 AS INT) AS `value`
 FROM `default`.`a_n4`
-WHERE `value` = 40 AND `key` IS NOT NULL) AS `t4` ON `t`.`EXPR$0` AND `t`.`key` = `t4`.`key`
+WHERE `value` = 40 AND `key` IS NOT NULL) AS `t4` ON `t`.`key` = `t4`.`key` AND `t`.`EXPR$0`
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
@@ -1173,13 +1173,13 @@ FROM (SELECT `key`, `value`, `value` = 40 AS `EXPR$0`, `value` = 60 AS `EXPR$1`,
 FROM `default`.`a_n4`) AS `t`
 LEFT JOIN (SELECT `key`, CAST(50 AS INT) AS `value`
 FROM `default`.`a_n4`
-WHERE `value` = 50 AND `key` IS NOT NULL) AS `t1` ON `t`.`EXPR$2` AND `t`.`key` = `t1`.`key`
+WHERE `value` = 50 AND `key` IS NOT NULL) AS `t1` ON `t`.`key` = `t1`.`key` AND `t`.`EXPR$2`
 LEFT JOIN (SELECT `key`, CAST(60 AS INT) AS `value`
 FROM `default`.`a_n4`
-WHERE `value` = 60 AND `key` IS NOT NULL) AS `t3` ON `t`.`EXPR$1` AND `t`.`key` = `t3`.`key`
+WHERE `value` = 60 AND `key` IS NOT NULL) AS `t3` ON `t`.`key` = `t3`.`key` AND `t`.`EXPR$1`
 LEFT JOIN (SELECT `key`, CAST(40 AS INT) AS `value`
 FROM `default`.`a_n4`
-WHERE `value` = 40 AND `key` IS NOT NULL) AS `t5` ON `t`.`EXPR$0` AND `t`.`key` = `t5`.`key`
+WHERE `value` = 40 AND `key` IS NOT NULL) AS `t5` ON `t`.`key` = `t5`.`key` AND `t`.`EXPR$0`
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
diff --git a/ql/src/test/results/clientpositive/llap/masking_mv.q.out b/ql/src/test/results/clientpositive/llap/masking_mv.q.out
index 1959fe045f..33e25f3d81 100644
--- a/ql/src/test/results/clientpositive/llap/masking_mv.q.out
+++ b/ql/src/test/results/clientpositive/llap/masking_mv.q.out
@@ -206,9 +206,9 @@ STAGE PLANS:
       Processor Tree:
         TableScan
           alias: default.masking_test_view_n_mv
-          filterExpr: ((key < 10) and ((key % 2) = 0)) (type: boolean)
+          filterExpr: ((key < 10) and (0 = (key % 2))) (type: boolean)
           Filter Operator
-            predicate: ((key < 10) and ((key % 2) = 0)) (type: boolean)
+            predicate: ((key < 10) and (0 = (key % 2))) (type: boolean)
             Select Operator
               expressions: key (type: int)
               outputColumnNames: _col0
@@ -272,10 +272,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.masking_test_view_n_mv
-                  filterExpr: ((key < 10) and ((key % 2) = 0)) (type: boolean)
+                  filterExpr: ((key < 10) and (0 = (key % 2))) (type: boolean)
                   Statistics: Num rows: 500 Data size: 2000 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((key < 10) and ((key % 2) = 0)) (type: boolean)
+                    predicate: ((key < 10) and (0 = (key % 2))) (type: boolean)
                     Statistics: Num rows: 5 Data size: 20 Basic stats: COMPLETE Column stats: COMPLETE
                     Group By Operator
                       keys: key (type: int)
@@ -548,10 +548,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.masking_test_view_n_mv_4
-                  filterExpr: ((key < 10) and ((key % 2) = 0)) (type: boolean)
+                  filterExpr: ((key < 10) and (0 = (key % 2))) (type: boolean)
                   Statistics: Num rows: 500 Data size: 47500 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((key < 10) and ((key % 2) = 0)) (type: boolean)
+                    predicate: ((key < 10) and (0 = (key % 2))) (type: boolean)
                     Statistics: Num rows: 5 Data size: 475 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: reverse(value) (type: string)
@@ -639,10 +639,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.masking_test_view_n_mv_4
-                  filterExpr: ((key < 10) and ((key % 2) = 0)) (type: boolean)
+                  filterExpr: ((key < 10) and (0 = (key % 2))) (type: boolean)
                   Statistics: Num rows: 500 Data size: 47500 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((key < 10) and ((key % 2) = 0)) (type: boolean)
+                    predicate: ((key < 10) and (0 = (key % 2))) (type: boolean)
                     Statistics: Num rows: 5 Data size: 475 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: reverse(value) (type: string), key (type: int)
diff --git a/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb.q.out b/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb.q.out
index 483afea8b0..79c2216e9b 100644
--- a/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb.q.out
+++ b/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb.q.out
@@ -664,10 +664,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv_n0
-                  filterExpr: ((lo_quantity < 25.0D) and (d_year = 1993) and lo_discount BETWEEN 1.0D AND 3.0D) (type: boolean)
+                  filterExpr: ((lo_quantity < 25.0D) and lo_discount BETWEEN 1.0D AND 3.0D and (d_year = 1993)) (type: boolean)
                   Statistics: Num rows: 1 Data size: 28 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((lo_quantity < 25.0D) and (d_year = 1993) and lo_discount BETWEEN 1.0D AND 3.0D) (type: boolean)
+                    predicate: ((lo_quantity < 25.0D) and lo_discount BETWEEN 1.0D AND 3.0D and (d_year = 1993)) (type: boolean)
                     Statistics: Num rows: 1 Data size: 28 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: discounted_price (type: double)
@@ -754,10 +754,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv_n0
-                  filterExpr: ((d_yearmonthnum = 199401) and lo_quantity BETWEEN 26.0D AND 35.0D and lo_discount BETWEEN 4.0D AND 6.0D) (type: boolean)
+                  filterExpr: (lo_quantity BETWEEN 26.0D AND 35.0D and lo_discount BETWEEN 4.0D AND 6.0D and (d_yearmonthnum = 199401)) (type: boolean)
                   Statistics: Num rows: 1 Data size: 28 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((d_yearmonthnum = 199401) and lo_quantity BETWEEN 26.0D AND 35.0D and lo_discount BETWEEN 4.0D AND 6.0D) (type: boolean)
+                    predicate: (lo_quantity BETWEEN 26.0D AND 35.0D and lo_discount BETWEEN 4.0D AND 6.0D and (d_yearmonthnum = 199401)) (type: boolean)
                     Statistics: Num rows: 1 Data size: 28 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: discounted_price (type: double)
@@ -846,10 +846,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv_n0
-                  filterExpr: ((d_year = 1994) and (d_weeknuminyear = 6) and lo_quantity BETWEEN 26.0D AND 35.0D and lo_discount BETWEEN 5.0D AND 7.0D) (type: boolean)
+                  filterExpr: (lo_quantity BETWEEN 26.0D AND 35.0D and lo_discount BETWEEN 5.0D AND 7.0D and (d_year = 1994) and (d_weeknuminyear = 6)) (type: boolean)
                   Statistics: Num rows: 1 Data size: 32 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((d_year = 1994) and (d_weeknuminyear = 6) and lo_quantity BETWEEN 26.0D AND 35.0D and lo_discount BETWEEN 5.0D AND 7.0D) (type: boolean)
+                    predicate: (lo_quantity BETWEEN 26.0D AND 35.0D and lo_discount BETWEEN 5.0D AND 7.0D and (d_year = 1994) and (d_weeknuminyear = 6)) (type: boolean)
                     Statistics: Num rows: 1 Data size: 32 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: discounted_price (type: double)
@@ -1077,10 +1077,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv_n0
-                  filterExpr: ((s_region = 'ASIA') and p_brand1 BETWEEN 'MFGR#2221' AND 'MFGR#2228') (type: boolean)
+                  filterExpr: (p_brand1 BETWEEN 'MFGR#2221' AND 'MFGR#2228' and (s_region = 'ASIA')) (type: boolean)
                   Statistics: Num rows: 1 Data size: 180 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((s_region = 'ASIA') and p_brand1 BETWEEN 'MFGR#2221' AND 'MFGR#2228') (type: boolean)
+                    predicate: (p_brand1 BETWEEN 'MFGR#2221' AND 'MFGR#2228' and (s_region = 'ASIA')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 180 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: d_year (type: int), p_brand1 (type: string), lo_revenue (type: double)
@@ -1333,10 +1333,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv_n0
-                  filterExpr: ((c_region = 'ASIA') and (s_region = 'ASIA') and d_year BETWEEN 1992 AND 1997) (type: boolean)
+                  filterExpr: (d_year BETWEEN 1992 AND 1997 and (c_region = 'ASIA') and (s_region = 'ASIA')) (type: boolean)
                   Statistics: Num rows: 1 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((c_region = 'ASIA') and (s_region = 'ASIA') and d_year BETWEEN 1992 AND 1997) (type: boolean)
+                    predicate: (d_year BETWEEN 1992 AND 1997 and (c_region = 'ASIA') and (s_region = 'ASIA')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: c_nation (type: string), d_year (type: int), s_nation (type: string), lo_revenue (type: double)
@@ -1461,10 +1461,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv_n0
-                  filterExpr: ((c_nation = 'UNITED STATES') and (s_nation = 'UNITED STATES') and d_year BETWEEN 1992 AND 1997) (type: boolean)
+                  filterExpr: (d_year BETWEEN 1992 AND 1997 and (c_nation = 'UNITED STATES') and (s_nation = 'UNITED STATES')) (type: boolean)
                   Statistics: Num rows: 1 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((c_nation = 'UNITED STATES') and (s_nation = 'UNITED STATES') and d_year BETWEEN 1992 AND 1997) (type: boolean)
+                    predicate: (d_year BETWEEN 1992 AND 1997 and (c_nation = 'UNITED STATES') and (s_nation = 'UNITED STATES')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: c_city (type: string), d_year (type: int), s_city (type: string), lo_revenue (type: double)
diff --git a/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_2.q.out b/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_2.q.out
index 0df50799d5..72a69cf822 100644
--- a/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_2.q.out
+++ b/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_2.q.out
@@ -667,10 +667,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv
-                  filterExpr: ((UDFToDouble(lo_quantity) < 25.0D) and (UDFToInteger(d_year) = 1993) and UDFToDouble(lo_discount) BETWEEN 1.0D AND 3.0D) (type: boolean)
+                  filterExpr: ((UDFToDouble(lo_quantity) < 25.0D) and UDFToDouble(lo_discount) BETWEEN 1.0D AND 3.0D and (UDFToInteger(d_year) = 1993)) (type: boolean)
                   Statistics: Num rows: 1 Data size: 260 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((UDFToDouble(lo_quantity) < 25.0D) and (UDFToInteger(d_year) = 1993) and UDFToDouble(lo_discount) BETWEEN 1.0D AND 3.0D) (type: boolean)
+                    predicate: ((UDFToDouble(lo_quantity) < 25.0D) and UDFToDouble(lo_discount) BETWEEN 1.0D AND 3.0D and (UDFToInteger(d_year) = 1993)) (type: boolean)
                     Statistics: Num rows: 1 Data size: 260 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: discounted_price (type: double)
@@ -757,10 +757,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv
-                  filterExpr: ((UDFToInteger(d_yearmonthnum) = 199401) and UDFToDouble(lo_quantity) BETWEEN 26.0D AND 35.0D and UDFToDouble(lo_discount) BETWEEN 4.0D AND 6.0D) (type: boolean)
+                  filterExpr: (UDFToDouble(lo_quantity) BETWEEN 26.0D AND 35.0D and UDFToDouble(lo_discount) BETWEEN 4.0D AND 6.0D and (UDFToInteger(d_yearmonthnum) = 199401)) (type: boolean)
                   Statistics: Num rows: 1 Data size: 260 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((UDFToInteger(d_yearmonthnum) = 199401) and UDFToDouble(lo_quantity) BETWEEN 26.0D AND 35.0D and UDFToDouble(lo_discount) BETWEEN 4.0D AND 6.0D) (type: boolean)
+                    predicate: (UDFToDouble(lo_quantity) BETWEEN 26.0D AND 35.0D and UDFToDouble(lo_discount) BETWEEN 4.0D AND 6.0D and (UDFToInteger(d_yearmonthnum) = 199401)) (type: boolean)
                     Statistics: Num rows: 1 Data size: 260 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: discounted_price (type: double)
@@ -849,10 +849,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv
-                  filterExpr: ((UDFToInteger(d_year) = 1994) and (UDFToInteger(d_weeknuminyear) = 6) and UDFToDouble(lo_quantity) BETWEEN 26.0D AND 35.0D and UDFToDouble(lo_discount) BETWEEN 5.0D AND 7.0D) (type: boolean)
+                  filterExpr: (UDFToDouble(lo_quantity) BETWEEN 26.0D AND 35.0D and UDFToDouble(lo_discount) BETWEEN 5.0D AND 7.0D and (UDFToInteger(d_year) = 1994) and (UDFToInteger(d_weeknuminyear) = 6)) (type: boolean)
                   Statistics: Num rows: 1 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((UDFToInteger(d_year) = 1994) and (UDFToInteger(d_weeknuminyear) = 6) and UDFToDouble(lo_quantity) BETWEEN 26.0D AND 35.0D and UDFToDouble(lo_discount) BETWEEN 5.0D AND 7.0D) (type: boolean)
+                    predicate: (UDFToDouble(lo_quantity) BETWEEN 26.0D AND 35.0D and UDFToDouble(lo_discount) BETWEEN 5.0D AND 7.0D and (UDFToInteger(d_year) = 1994) and (UDFToInteger(d_weeknuminyear) = 6)) (type: boolean)
                     Statistics: Num rows: 1 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: discounted_price (type: double)
@@ -1080,10 +1080,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv
-                  filterExpr: ((s_region = 'ASIA') and p_brand1 BETWEEN 'MFGR#2221' AND 'MFGR#2228') (type: boolean)
+                  filterExpr: (p_brand1 BETWEEN 'MFGR#2221' AND 'MFGR#2228' and (s_region = 'ASIA')) (type: boolean)
                   Statistics: Num rows: 1 Data size: 260 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((s_region = 'ASIA') and p_brand1 BETWEEN 'MFGR#2221' AND 'MFGR#2228') (type: boolean)
+                    predicate: (p_brand1 BETWEEN 'MFGR#2221' AND 'MFGR#2228' and (s_region = 'ASIA')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 260 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: UDFToInteger(d_year) (type: int), p_brand1 (type: string), lo_revenue (type: double)
@@ -1336,10 +1336,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv
-                  filterExpr: ((c_region = 'ASIA') and (s_region = 'ASIA') and UDFToInteger(d_year) BETWEEN 1992 AND 1997) (type: boolean)
+                  filterExpr: (UDFToInteger(d_year) BETWEEN 1992 AND 1997 and (c_region = 'ASIA') and (s_region = 'ASIA')) (type: boolean)
                   Statistics: Num rows: 1 Data size: 428 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((c_region = 'ASIA') and (s_region = 'ASIA') and UDFToInteger(d_year) BETWEEN 1992 AND 1997) (type: boolean)
+                    predicate: (UDFToInteger(d_year) BETWEEN 1992 AND 1997 and (c_region = 'ASIA') and (s_region = 'ASIA')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 428 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: c_nation (type: string), s_nation (type: string), UDFToInteger(d_year) (type: int), lo_revenue (type: double)
@@ -1464,10 +1464,10 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: default.ssb_mv
-                  filterExpr: ((c_nation = 'UNITED STATES') and (s_nation = 'UNITED STATES') and UDFToInteger(d_year) BETWEEN 1992 AND 1997) (type: boolean)
+                  filterExpr: (UDFToInteger(d_year) BETWEEN 1992 AND 1997 and (c_nation = 'UNITED STATES') and (s_nation = 'UNITED STATES')) (type: boolean)
                   Statistics: Num rows: 1 Data size: 428 Basic stats: COMPLETE Column stats: COMPLETE
                   Filter Operator
-                    predicate: ((c_nation = 'UNITED STATES') and (s_nation = 'UNITED STATES') and UDFToInteger(d_year) BETWEEN 1992 AND 1997) (type: boolean)
+                    predicate: (UDFToInteger(d_year) BETWEEN 1992 AND 1997 and (c_nation = 'UNITED STATES') and (s_nation = 'UNITED STATES')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 428 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: c_city (type: string), s_city (type: string), UDFToInteger(d_year) (type: int), lo_revenue (type: double)
diff --git a/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_grouping_sets.q.out b/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_grouping_sets.q.out
index 1ffed8f8a6..93d9496944 100644
--- a/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_grouping_sets.q.out
+++ b/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_grouping_sets.q.out
@@ -696,7 +696,7 @@ POSTHOOK: Input: default@ssb_mv_n3
 #### A masked pattern was here ####
 CBO PLAN:
 HiveAggregate(group=[{}], agg#0=[sum($16)])
-  HiveFilter(condition=[AND(<($8, 2.5E1), =(CAST($18):BIGINT NOT NULL, 29247), =($4, 1993), BETWEEN(false, $7, 1E0:DOUBLE, 3E0:DOUBLE))])
+  HiveFilter(condition=[AND(<($8, 2.5E1), =(CAST($18):BIGINT NOT NULL, 29247), BETWEEN(false, $7, 1E0:DOUBLE, 3E0:DOUBLE), =($4, 1993))])
     HiveTableScan(table=[[default, ssb_mv_n3]], table:alias=[default.ssb_mv_n3])
 
 PREHOOK: query: explain cbo
@@ -731,7 +731,7 @@ POSTHOOK: Input: default@ssb_mv_n3
 #### A masked pattern was here ####
 CBO PLAN:
 HiveAggregate(group=[{}], agg#0=[sum($16)])
-  HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 29247), =($6, 199401), BETWEEN(false, $8, 2.6E1:DOUBLE, 3.5E1:DOUBLE), BETWEEN(false, $7, 4E0:DOUBLE, 6E0:DOUBLE))])
+  HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 29247), BETWEEN(false, $8, 2.6E1:DOUBLE, 3.5E1:DOUBLE), BETWEEN(false, $7, 4E0:DOUBLE, 6E0:DOUBLE), =($6, 199401))])
     HiveTableScan(table=[[default, ssb_mv_n3]], table:alias=[default.ssb_mv_n3])
 
 PREHOOK: query: explain cbo
@@ -768,7 +768,7 @@ POSTHOOK: Input: default@ssb_mv_n3
 #### A masked pattern was here ####
 CBO PLAN:
 HiveAggregate(group=[{}], agg#0=[sum($16)])
-  HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 29247), =($4, 1994), =($3, 6), BETWEEN(false, $8, 2.6E1:DOUBLE, 3.5E1:DOUBLE), BETWEEN(false, $7, 5E0:DOUBLE, 7E0:DOUBLE))])
+  HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 29247), BETWEEN(false, $8, 2.6E1:DOUBLE, 3.5E1:DOUBLE), BETWEEN(false, $7, 5E0:DOUBLE, 7E0:DOUBLE), =($4, 1994), =($3, 6))])
     HiveTableScan(table=[[default, ssb_mv_n3]], table:alias=[default.ssb_mv_n3])
 
 PREHOOK: query: explain cbo
@@ -870,7 +870,7 @@ CBO PLAN:
 HiveSortLimit(sort0=[$1], sort1=[$2], dir0=[ASC], dir1=[ASC])
   HiveProject(lo_revenue=[$2], d_year=[$0], p_brand1=[$1])
     HiveAggregate(group=[{4, 9}], agg#0=[sum($15)])
-      HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 2496), =($14, _UTF-16LE'ASIA'), BETWEEN(false, $9, _UTF-16LE'MFGR#2221':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'MFGR#2228':VARCHAR(2147483647) CHARACTER SET "UTF-16LE"))])
+      HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 2496), BETWEEN(false, $9, _UTF-16LE'MFGR#2221':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'MFGR#2228':VARCHAR(2147483647) CHARACTER SET "UTF-16LE"), =($14, _UTF-16LE'ASIA'))])
         HiveTableScan(table=[[default, ssb_mv_n3]], table:alias=[default.ssb_mv_n3])
 
 PREHOOK: query: explain cbo
@@ -977,7 +977,7 @@ CBO PLAN:
 HiveSortLimit(sort0=[$2], sort1=[$3], dir0=[ASC], dir1=[DESC])
   HiveProject(c_nation=[$0], s_nation=[$2], d_year=[$1], $f3=[$3])
     HiveAggregate(group=[{1, 4, 13}], agg#0=[sum($15)])
-      HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 2496), =($2, _UTF-16LE'ASIA'), =($14, _UTF-16LE'ASIA'), BETWEEN(false, $4, 1992, 1997))])
+      HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 2496), BETWEEN(false, $4, 1992, 1997), =($2, _UTF-16LE'ASIA'), =($14, _UTF-16LE'ASIA'))])
         HiveTableScan(table=[[default, ssb_mv_n3]], table:alias=[default.ssb_mv_n3])
 
 PREHOOK: query: explain cbo
@@ -1030,7 +1030,7 @@ CBO PLAN:
 HiveSortLimit(sort0=[$2], sort1=[$3], dir0=[ASC], dir1=[DESC])
   HiveProject(c_city=[$0], s_city=[$2], d_year=[$1], $f3=[$3])
     HiveAggregate(group=[{0, 4, 12}], agg#0=[sum($15)])
-      HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 2496), =($1, _UTF-16LE'UNITED STATES'), =($13, _UTF-16LE'UNITED STATES'), BETWEEN(false, $4, 1992, 1997))])
+      HiveFilter(condition=[AND(=(CAST($18):BIGINT NOT NULL, 2496), BETWEEN(false, $4, 1992, 1997), =($1, _UTF-16LE'UNITED STATES'), =($13, _UTF-16LE'UNITED STATES'))])
         HiveTableScan(table=[[default, ssb_mv_n3]], table:alias=[default.ssb_mv_n3])
 
 PREHOOK: query: explain cbo
diff --git a/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_grouping_sets_2.q.out b/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_grouping_sets_2.q.out
index a5a7134a9d..10dfb63685 100644
--- a/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_grouping_sets_2.q.out
+++ b/ql/src/test/results/clientpositive/llap/materialized_view_rewrite_ssb_grouping_sets_2.q.out
@@ -719,7 +719,7 @@ CBO PLAN:
 HiveSortLimit(sort0=[$1], sort1=[$2], dir0=[ASC], dir1=[ASC])
   HiveProject($f2=[$2], d_year=[$1], p_brand1=[$0])
     HiveAggregate(group=[{0, 7}], agg#0=[sum($9)])
-      HiveFilter(condition=[AND(=(CAST($8):BIGINT NOT NULL, 0), =($4, _UTF-16LE'ASIA'), BETWEEN(false, $0, _UTF-16LE'MFGR#2221':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'MFGR#2228':VARCHAR(2147483647) CHARACTER SET "UTF-16LE"))])
+      HiveFilter(condition=[AND(=(CAST($8):BIGINT NOT NULL, 0), BETWEEN(false, $0, _UTF-16LE'MFGR#2221':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'MFGR#2228':VARCHAR(2147483647) CHARACTER SET "UTF-16LE"), =($4, _UTF-16LE'ASIA'))])
         HiveTableScan(table=[[default, ssb_mv_n4]], table:alias=[default.ssb_mv_n4])
 
 PREHOOK: query: explain cbo
diff --git a/ql/src/test/results/clientpositive/llap/pcs.q.out b/ql/src/test/results/clientpositive/llap/pcs.q.out
index 37f4d037ae..204b8dc2da 100644
--- a/ql/src/test/results/clientpositive/llap/pcs.q.out
+++ b/ql/src/test/results/clientpositive/llap/pcs.q.out
@@ -526,7 +526,7 @@ FROM `default`.`pcs_t1`
 WHERE `key` IN (1, 2) AND `ds` IN ('2000-04-08', '2000-04-09')) AS `t0`
 INNER JOIN (SELECT `key`, `ds`
 FROM `default`.`pcs_t1`
-WHERE `ds` IN ('2000-04-08', '2000-04-09')) AS `t2` ON (`t0`.`key`, `t0`.`ds`, `t2`.`ds`) IN ((1, '2000-04-08', '2000-04-09'), (2, '2000-04-09', '2000-04-08')) AND `t0`.`ds` = `t2`.`ds`
+WHERE `ds` IN ('2000-04-08', '2000-04-09')) AS `t2` ON `t0`.`ds` = `t2`.`ds` AND (`t0`.`key`, `t0`.`ds`, `t2`.`ds`) IN ((1, '2000-04-08', '2000-04-09'), (2, '2000-04-09', '2000-04-08'))
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-0 depends on stages: Stage-1
diff --git a/ql/src/test/results/clientpositive/llap/pointlookup6.q.out b/ql/src/test/results/clientpositive/llap/pointlookup6.q.out
index 793422da5b..1cb5775b17 100644
--- a/ql/src/test/results/clientpositive/llap/pointlookup6.q.out
+++ b/ql/src/test/results/clientpositive/llap/pointlookup6.q.out
@@ -77,3 +77,28 @@ POSTHOOK: Input: default@l_table
 POSTHOOK: Input: default@r_table
 #### A masked pattern was here ####
 AAA111
+PREHOOK: query: explain cbo
+SELECT * FROM r_table
+WHERE (
+        MINUTE(string_col) = 2 OR
+        MINUTE(string_col) = 10 OR
+        MINUTE(string_col) IS NULL
+      )
+PREHOOK: type: QUERY
+PREHOOK: Input: default@r_table
+#### A masked pattern was here ####
+POSTHOOK: query: explain cbo
+SELECT * FROM r_table
+WHERE (
+        MINUTE(string_col) = 2 OR
+        MINUTE(string_col) = 10 OR
+        MINUTE(string_col) IS NULL
+      )
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@r_table
+#### A masked pattern was here ####
+CBO PLAN:
+HiveProject(string_col=[$0])
+  HiveFilter(condition=[OR(IS NULL(CAST($0):TIMESTAMP(9)), IN(MINUTE(FLAG(MINUTE), CAST($0):TIMESTAMP(9)), 2, 10))])
+    HiveTableScan(table=[[default, r_table]], table:alias=[r_table])
+
diff --git a/ql/src/test/results/clientpositive/llap/rand_partitionpruner2.q.out b/ql/src/test/results/clientpositive/llap/rand_partitionpruner2.q.out
index ee4a4050b2..d866fc52ef 100644
--- a/ql/src/test/results/clientpositive/llap/rand_partitionpruner2.q.out
+++ b/ql/src/test/results/clientpositive/llap/rand_partitionpruner2.q.out
@@ -24,7 +24,7 @@ POSTHOOK: Input: default@srcpart@ds=2008-04-08/hr=12
 POSTHOOK: Output: default@tmptable_n1
 OPTIMIZED SQL: SELECT `key`, `value`, CAST('2008-04-08' AS STRING) AS `ds`, `hr`
 FROM `default`.`srcpart`
-WHERE `ds` = '2008-04-08' AND RAND(1) < 0.1
+WHERE RAND(1) < 0.1 AND `ds` = '2008-04-08'
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-2 depends on stages: Stage-1
diff --git a/ql/src/test/results/clientpositive/llap/rand_partitionpruner3.q.out b/ql/src/test/results/clientpositive/llap/rand_partitionpruner3.q.out
index e3e3d877b8..7f3aae3507 100644
--- a/ql/src/test/results/clientpositive/llap/rand_partitionpruner3.q.out
+++ b/ql/src/test/results/clientpositive/llap/rand_partitionpruner3.q.out
@@ -10,7 +10,7 @@ POSTHOOK: Input: default@srcpart@ds=2008-04-08/hr=12
 #### A masked pattern was here ####
 OPTIMIZED SQL: SELECT `key`, `value`, CAST('2008-04-08' AS STRING) AS `ds`, `hr`
 FROM `default`.`srcpart`
-WHERE CAST(`key` AS DOUBLE) BETWEEN 10 AND 50 AND `ds` = '2008-04-08' AND RAND(1) < 0.1 AND `hr` LIKE '%2'
+WHERE CAST(`key` AS DOUBLE) BETWEEN 10 AND 50 AND RAND(1) < 0.1 AND `ds` = '2008-04-08' AND `hr` LIKE '%2'
 STAGE DEPENDENCIES:
   Stage-0 is a root stage
 
diff --git a/ql/src/test/results/clientpositive/llap/union22.q.out b/ql/src/test/results/clientpositive/llap/union22.q.out
index 2c42e18d38..43974c60a1 100644
--- a/ql/src/test/results/clientpositive/llap/union22.q.out
+++ b/ql/src/test/results/clientpositive/llap/union22.q.out
@@ -90,7 +90,7 @@ FROM `default`.`dst_union22`
 WHERE `k1` > 20) AS `t2`
 LEFT JOIN (SELECT `k1`, `k3`, `k4`
 FROM `default`.`dst_union22_delta`
-WHERE `k0` > 50 AND `k1` > 20 AND `ds` = '1') AS `t4` ON `t2`.`EXPR$0` AND `t2`.`k1` = `t4`.`k1`
+WHERE `k0` > 50 AND `k1` > 20 AND `ds` = '1') AS `t4` ON `t2`.`k1` = `t4`.`k1` AND `t2`.`EXPR$0`
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
   Stage-2 depends on stages: Stage-1
diff --git a/ql/src/test/results/clientpositive/llap/vector_interval_2.q.out b/ql/src/test/results/clientpositive/llap/vector_interval_2.q.out
index 88d79b9e12..559c944c03 100644
--- a/ql/src/test/results/clientpositive/llap/vector_interval_2.q.out
+++ b/ql/src/test/results/clientpositive/llap/vector_interval_2.q.out
@@ -962,7 +962,7 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: vector_interval_2
-                  filterExpr: ((CAST( str2 AS INTERVAL YEAR TO MONTH) >= INTERVAL'1-2') and (CAST( str2 AS INTERVAL YEAR TO MONTH) > INTERVAL'1-2') and (CAST( str1 AS INTERVAL YEAR TO MONTH) <= CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) < CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str2 AS INTERVAL YEAR TO MONTH) >= CAST( str1 AS INTERVAL YEAR TO MONTH)) and (CAST( str2 AS INTERVAL YEAR TO MONTH) > CAST( str1 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) = INTERVAL'1-2') and (CAST( str1 AS INTERVAL YEAR TO MONTH) <> CAST( str2 AS INTERVAL YEAR TO MONTH))) (type: boolean)
+                  filterExpr: ((CAST( str2 AS INTERVAL YEAR TO MONTH) >= INTERVAL'1-2') and (CAST( str2 AS INTERVAL YEAR TO MONTH) > INTERVAL'1-2') and (CAST( str1 AS INTERVAL YEAR TO MONTH) <= CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) < CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str2 AS INTERVAL YEAR TO MONTH) >= CAST( str1 AS INTERVAL YEAR TO MONTH)) and (CAST( str2 AS INTERVAL YEAR TO MONTH) > CAST( str1 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) <> CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) = INTERVAL'1-2')) (type: boolean)
                   Statistics: Num rows: 2 Data size: 428 Basic stats: COMPLETE Column stats: COMPLETE
                   TableScan Vectorization:
                       native: true
@@ -970,8 +970,8 @@ STAGE PLANS:
                     Filter Vectorization:
                         className: VectorFilterOperator
                         native: true
-                        predicateExpression: FilterExprAndExpr(children: FilterIntervalYearMonthColGreaterEqualIntervalYearMonthScalar(col 8:interval_year_month, val 14)(children: CastStringToIntervalYearMonth(col 3:string) -> 8:interval_year_month), FilterIntervalYearMonthColGreaterIntervalYearMonthScalar(col 9:interval_year_month, val 14)(children: CastStringToIntervalYearMonth(col 3:string) -> 9:interval_year_month), FilterLongColLessEqualLongColumn(col 10:interval_year_month, col 11:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 10:interval_year_month, CastStringToIntervalYearMonth(col 3:string) -> 11:interval_year_month), FilterLongColLessLongColumn(col 12:interval_year_month, col 13:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 12:interval_year_month, CastStringToIntervalYearMonth(col 3:string) -> 13:interval_year_month), FilterLongColGreaterEqualLongColumn(col 14:interval_year_month, col 15:interval_year_month)(children: CastStringToIntervalYearMonth(col 3:string) -> 14:interval_year_month, CastStringToIntervalYearMonth(col 2:string) -> 15:interval_year_month), FilterLongColGreaterLongColumn(col 16:interval_year_month, col 17:interval_year_month)(children: CastStringToIntervalYearMonth(col 3:string) -> 16:interval_year_month, CastStringToIntervalYearMonth(col 2:string) -> 17:interval_year_month), FilterIntervalYearMonthColEqualIntervalYearMonthScalar(col 18:interval_year_month, val 14)(children: CastStringToIntervalYearMonth(col 2:string) -> 18:interval_year_month), FilterLongColNotEqualLongColumn(col 19:interval_year_month, col 20:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 19:interval_year_month, CastStringToIntervalYearMonth(col 3:string) -> 20:interval_year_month))
-                    predicate: ((CAST( str2 AS INTERVAL YEAR TO MONTH) >= INTERVAL'1-2') and (CAST( str2 AS INTERVAL YEAR TO MONTH) > INTERVAL'1-2') and (CAST( str1 AS INTERVAL YEAR TO MONTH) <= CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) < CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str2 AS INTERVAL YEAR TO MONTH) >= CAST( str1 AS INTERVAL YEAR TO MONTH)) and (CAST( str2 AS INTERVAL YEAR TO MONTH) > CAST( str1 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) = INTERVAL'1-2') and (CAST( str1 AS INTERVAL YEAR TO MONTH) <> CAST( str2 AS INTERVAL YEAR TO MONTH))) (type: boolean)
+                        predicateExpression: FilterExprAndExpr(children: FilterIntervalYearMonthColGreaterEqualIntervalYearMonthScalar(col 8:interval_year_month, val 14)(children: CastStringToIntervalYearMonth(col 3:string) -> 8:interval_year_month), FilterIntervalYearMonthColGreaterIntervalYearMonthScalar(col 9:interval_year_month, val 14)(children: CastStringToIntervalYearMonth(col 3:string) -> 9:interval_year_month), FilterLongColLessEqualLongColumn(col 10:interval_year_month, col 11:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 10:interval_year_month, CastStringToIntervalYearMonth(col 3:string) -> 11:interval_year_month), FilterLongColLessLongColumn(col 12:interval_year_month, col 13:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 12:interval_year_month, CastStringToIntervalYearMonth(col 3:string) -> 13:interval_year_month), FilterLongColGreaterEqualLongColumn(col 14:interval_year_month, col 15:interval_year_month)(children: CastStringToIntervalYearMonth(col 3:string) -> 14:interval_year_month, CastStringToIntervalYearMonth(col 2:string) -> 15:interval_year_month), FilterLongColGreaterLongColumn(col 16:interval_year_month, col 17:interval_year_month)(children: CastStringToIntervalYearMonth(col 3:string) -> 16:interval_year_month, CastStringToIntervalYearMonth(col 2:string) -> 17:interval_year_month), FilterLongColNotEqualLongColumn(col 18:interval_year_month, col 19:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 18:interval_year_month, CastStringToIntervalYearMonth(col 3:string) -> 19:interval_year_month), FilterIntervalYearMonthColEqualIntervalYearMonthScalar(col 20:interval_year_month, val 14)(children: CastStringToIntervalYearMonth(col 2:string) -> 20:interval_year_month))
+                    predicate: ((CAST( str2 AS INTERVAL YEAR TO MONTH) >= INTERVAL'1-2') and (CAST( str2 AS INTERVAL YEAR TO MONTH) > INTERVAL'1-2') and (CAST( str1 AS INTERVAL YEAR TO MONTH) <= CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) < CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str2 AS INTERVAL YEAR TO MONTH) >= CAST( str1 AS INTERVAL YEAR TO MONTH)) and (CAST( str2 AS INTERVAL YEAR TO MONTH) > CAST( str1 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) <> CAST( str2 AS INTERVAL YEAR TO MONTH)) and (CAST( str1 AS INTERVAL YEAR TO MONTH) = INTERVAL'1-2')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 214 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: ts (type: timestamp)
@@ -1162,7 +1162,7 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: vector_interval_2
-                  filterExpr: ((CAST( str4 AS INTERVAL DAY TO SECOND) >= INTERVAL'1 02:03:04.000000000') and (CAST( str4 AS INTERVAL DAY TO SECOND) > INTERVAL'1 02:03:04.000000000') and (CAST( str3 AS INTERVAL DAY TO SECOND) <= CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) < CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str4 AS INTERVAL DAY TO SECOND) >= CAST( str3 AS INTERVAL DAY TO SECOND)) and (CAST( str4 AS INTERVAL DAY TO SECOND) > CAST( str3 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) = INTERVAL'1 02:03:04.000000000') and (CAST( str3 AS INTERVAL DAY TO SECOND) <> CAST( str4 AS INTERVAL DAY TO SECOND))) (type: boolean)
+                  filterExpr: ((CAST( str4 AS INTERVAL DAY TO SECOND) >= INTERVAL'1 02:03:04.000000000') and (CAST( str4 AS INTERVAL DAY TO SECOND) > INTERVAL'1 02:03:04.000000000') and (CAST( str3 AS INTERVAL DAY TO SECOND) <= CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) < CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str4 AS INTERVAL DAY TO SECOND) >= CAST( str3 AS INTERVAL DAY TO SECOND)) and (CAST( str4 AS INTERVAL DAY TO SECOND) > CAST( str3 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) <> CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) = INTERVAL'1 02:03:04.000000000')) (type: boolean)
                   Statistics: Num rows: 2 Data size: 444 Basic stats: COMPLETE Column stats: COMPLETE
                   TableScan Vectorization:
                       native: true
@@ -1170,8 +1170,8 @@ STAGE PLANS:
                     Filter Vectorization:
                         className: VectorFilterOperator
                         native: true
-                        predicateExpression: FilterExprAndExpr(children: FilterIntervalDayTimeColGreaterEqualIntervalDayTimeScalar(col 8:interval_day_time, val 1 02:03:04.000000000)(children: CastStringToIntervalDayTime(col 5:string) -> 8:interval_day_time), FilterIntervalDayTimeColGreaterIntervalDayTimeScalar(col 9:interval_day_time, val 1 02:03:04.000000000)(children: CastStringToIntervalDayTime(col 5:string) -> 9:interval_day_time), FilterIntervalDayTimeColLessEqualIntervalDayTimeColumn(col 10:interval_day_time, col 11:interval_day_time)(children: CastStringToIntervalDayTime(col 4:string) -> 10:interval_day_time, CastStringToIntervalDayTime(col 5:string) -> 11:interval_day_time), FilterIntervalDayTimeColLessIntervalDayTimeColumn(col 12:interval_day_time, col 13:interval_day_time)(children: CastStringToIntervalDayTime(col 4:string) -> 12:interval_day_time, CastStringToIntervalDayTime(col 5:string) -> 13:interval_day_time), FilterIntervalDayTimeColGreaterEqualIntervalDayTimeColumn(col 14:interval_day_time, col 15:interval_day_time)(children: CastStringToIntervalDayTime(col 5:string) -> 14:interval_day_time, CastStringToIntervalDayTime(col 4:string) -> 15:interval_day_time), FilterIntervalDayTimeColGreaterIntervalDayTimeColumn(col 16:interval_day_time, col 17:interval_day_time)(children: CastStringToIntervalDayTime(col 5:string) -> 16:interval_day_time, CastStringToIntervalDayTime(col 4:string) -> 17:interval_day_time), FilterIntervalDayTimeColEqualIntervalDayTimeScalar(col 18:interval_day_time, val 1 02:03:04.000000000)(children: CastStringToIntervalDayTime(col 4:string) -> 18:interval_day_time), FilterIntervalDayTimeColNotEqualIntervalDayTimeColumn(col 19:interval_day_time, col 20:interval_day_time)(children: CastStringToIntervalDayTime(col 4:string) -> 19:interval_day_time, CastStringToIntervalDayTime(col 5:string) -> 20:interval_day_time))
-                    predicate: ((CAST( str4 AS INTERVAL DAY TO SECOND) >= INTERVAL'1 02:03:04.000000000') and (CAST( str4 AS INTERVAL DAY TO SECOND) > INTERVAL'1 02:03:04.000000000') and (CAST( str3 AS INTERVAL DAY TO SECOND) <= CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) < CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str4 AS INTERVAL DAY TO SECOND) >= CAST( str3 AS INTERVAL DAY TO SECOND)) and (CAST( str4 AS INTERVAL DAY TO SECOND) > CAST( str3 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) = INTERVAL'1 02:03:04.000000000') and (CAST( str3 AS INTERVAL DAY TO SECOND) <> CAST( str4 AS INTERVAL DAY TO SECOND))) (type: boolean)
+                        predicateExpression: FilterExprAndExpr(children: FilterIntervalDayTimeColGreaterEqualIntervalDayTimeScalar(col 8:interval_day_time, val 1 02:03:04.000000000)(children: CastStringToIntervalDayTime(col 5:string) -> 8:interval_day_time), FilterIntervalDayTimeColGreaterIntervalDayTimeScalar(col 9:interval_day_time, val 1 02:03:04.000000000)(children: CastStringToIntervalDayTime(col 5:string) -> 9:interval_day_time), FilterIntervalDayTimeColLessEqualIntervalDayTimeColumn(col 10:interval_day_time, col 11:interval_day_time)(children: CastStringToIntervalDayTime(col 4:string) -> 10:interval_day_time, CastStringToIntervalDayTime(col 5:string) -> 11:interval_day_time), FilterIntervalDayTimeColLessIntervalDayTimeColumn(col 12:interval_day_time, col 13:interval_day_time)(children: CastStringToIntervalDayTime(col 4:string) -> 12:interval_day_time, CastStringToIntervalDayTime(col 5:string) -> 13:interval_day_time), FilterIntervalDayTimeColGreaterEqualIntervalDayTimeColumn(col 14:interval_day_time, col 15:interval_day_time)(children: CastStringToIntervalDayTime(col 5:string) -> 14:interval_day_time, CastStringToIntervalDayTime(col 4:string) -> 15:interval_day_time), FilterIntervalDayTimeColGreaterIntervalDayTimeColumn(col 16:interval_day_time, col 17:interval_day_time)(children: CastStringToIntervalDayTime(col 5:string) -> 16:interval_day_time, CastStringToIntervalDayTime(col 4:string) -> 17:interval_day_time), FilterIntervalDayTimeColNotEqualIntervalDayTimeColumn(col 18:interval_day_time, col 19:interval_day_time)(children: CastStringToIntervalDayTime(col 4:string) -> 18:interval_day_time, CastStringToIntervalDayTime(col 5:string) -> 19:interval_day_time), FilterIntervalDayTimeColEqualIntervalDayTimeScalar(col 20:interval_day_time, val 1 02:03:04.000000000)(children: CastStringToIntervalDayTime(col 4:string) -> 20:interval_day_time))
+                    predicate: ((CAST( str4 AS INTERVAL DAY TO SECOND) >= INTERVAL'1 02:03:04.000000000') and (CAST( str4 AS INTERVAL DAY TO SECOND) > INTERVAL'1 02:03:04.000000000') and (CAST( str3 AS INTERVAL DAY TO SECOND) <= CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) < CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str4 AS INTERVAL DAY TO SECOND) >= CAST( str3 AS INTERVAL DAY TO SECOND)) and (CAST( str4 AS INTERVAL DAY TO SECOND) > CAST( str3 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) <> CAST( str4 AS INTERVAL DAY TO SECOND)) and (CAST( str3 AS INTERVAL DAY TO SECOND) = INTERVAL'1 02:03:04.000000000')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 222 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: ts (type: timestamp)
@@ -1352,7 +1352,7 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: vector_interval_2
-                  filterExpr: (CAST( str1 AS INTERVAL YEAR TO MONTH) is not null and ((dt + CAST( str1 AS INTERVAL YEAR TO MONTH)) = DATE'2002-03-01') and ((dt + INTERVAL'1-2') = DATE'2002-03-01') and (dt <> (dt + CAST( str1 AS INTERVAL YEAR TO MONTH))) and (dt <> (dt + INTERVAL'1-2'))) (type: boolean)
+                  filterExpr: (CAST( str1 AS INTERVAL YEAR TO MONTH) is not null and ((dt + CAST( str1 AS INTERVAL YEAR TO MONTH)) = DATE'2002-03-01') and (dt <> (dt + CAST( str1 AS INTERVAL YEAR TO MONTH))) and ((dt + INTERVAL'1-2') = DATE'2002-03-01') and (dt <> (dt + INTERVAL'1-2'))) (type: boolean)
                   Statistics: Num rows: 2 Data size: 366 Basic stats: COMPLETE Column stats: COMPLETE
                   TableScan Vectorization:
                       native: true
@@ -1360,8 +1360,8 @@ STAGE PLANS:
                     Filter Vectorization:
                         className: VectorFilterOperator
                         native: true
-                        predicateExpression: FilterExprAndExpr(children: SelectColumnIsNotNull(col 8:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 8:interval_year_month), FilterDateColEqualDateScalar(col 10:date, val 11747)(children: DateColAddIntervalYearMonthColumn(col 1:date, col 9:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 9:interval_year_month) -> 10:date), FilterDateColEqualDateScalar(col 11:date, val 11747)(children: DateColAddIntervalYearMonthScalar(col 1:date, val 1-2) -> 11:date), FilterLongColNotEqualLongColumn(col 1:date, col 13:date)(children: DateColAddIntervalYearMonthColumn(col 1:date, col 12:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 12:interval_year_month) -> 13:date), FilterLongColNotEqualLongColumn(col 1:date, col 14:date)(children: DateColAddIntervalYearMonthScalar(col 1:date, val 1-2) -> 14:date))
-                    predicate: (CAST( str1 AS INTERVAL YEAR TO MONTH) is not null and ((dt + CAST( str1 AS INTERVAL YEAR TO MONTH)) = DATE'2002-03-01') and ((dt + INTERVAL'1-2') = DATE'2002-03-01') and (dt <> (dt + CAST( str1 AS INTERVAL YEAR TO MONTH))) and (dt <> (dt + INTERVAL'1-2'))) (type: boolean)
+                        predicateExpression: FilterExprAndExpr(children: SelectColumnIsNotNull(col 8:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 8:interval_year_month), FilterDateColEqualDateScalar(col 10:date, val 11747)(children: DateColAddIntervalYearMonthColumn(col 1:date, col 9:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 9:interval_year_month) -> 10:date), FilterLongColNotEqualLongColumn(col 1:date, col 12:date)(children: DateColAddIntervalYearMonthColumn(col 1:date, col 11:interval_year_month)(children: CastStringToIntervalYearMonth(col 2:string) -> 11:interval_year_month) -> 12:date), FilterDateColEqualDateScalar(col 13:date, val 11747)(children: DateColAddIntervalYearMonthScalar(col 1:date, val 1-2) -> 13:date), FilterLongColNotEqualLongColumn(col 1:date, col 14:date)(children: DateColAddIntervalYearMonthScalar(col 1:date, val 1-2) -> 14:date))
+                    predicate: (CAST( str1 AS INTERVAL YEAR TO MONTH) is not null and ((dt + CAST( str1 AS INTERVAL YEAR TO MONTH)) = DATE'2002-03-01') and (dt <> (dt + CAST( str1 AS INTERVAL YEAR TO MONTH))) and ((dt + INTERVAL'1-2') = DATE'2002-03-01') and (dt <> (dt + INTERVAL'1-2'))) (type: boolean)
                     Statistics: Num rows: 1 Data size: 183 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: ts (type: timestamp)
@@ -1542,7 +1542,7 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: vector_interval_2
-                  filterExpr: ((ts < (ts + INTERVAL'1-0')) and (ts > (ts - INTERVAL'1-0')) and ((ts + INTERVAL'1-2') = TIMESTAMP'2002-03-01 01:02:03') and (ts = (ts + INTERVAL'0-0')) and (ts <> (ts + INTERVAL'1-0')) and ts BETWEEN (ts - INTERVAL'1-0') AND (ts + INTERVAL'1-0')) (type: boolean)
+                  filterExpr: ((ts < (ts + INTERVAL'1-0')) and (ts > (ts - INTERVAL'1-0')) and (TIMESTAMP'2002-04-01 01:02:03' <> (ts + INTERVAL'1-2')) and ((ts + INTERVAL'1-2') = TIMESTAMP'2002-03-01 01:02:03') and (ts = (ts + INTERVAL'0-0')) and (ts <> (ts + INTERVAL'1-0')) and ts BETWEEN (ts - INTERVAL'1-0') AND (ts + INTERVAL'1-0')) (type: boolean)
                   Statistics: Num rows: 2 Data size: 80 Basic stats: COMPLETE Column stats: COMPLETE
                   TableScan Vectorization:
                       native: true
@@ -1550,8 +1550,8 @@ STAGE PLANS:
                     Filter Vectorization:
                         className: VectorFilterOperator
                         native: true
-                        predicateExpression: FilterExprAndExpr(children: FilterTimestampColLessTimestampColumn(col 0:timestamp, col 8:timestamp)(children: TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 8:timestamp), FilterTimestampColGreaterTimestampColumn(col 0:timestamp, col 9:timestamp)(children: TimestampColSubtractIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 9:timestamp), FilterTimestampColEqualTimestampScalar(col 10:timestamp, val 2002-03-01 01:02:03)(children: TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 1-2) -> 10:timestamp), FilterTimestampColEqualTimestampColumn(col 0:timestamp, col 11:timestamp)(children: TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 0-0) -> 11:timestamp), FilterTimestampColNotEqualTimestampColumn(col 0:timestamp, col 12:timestamp)(children: TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 12:timestamp), SelectColumnIsTrue(col 15:boolean)(children: VectorUDFAdaptor(ts BETWEEN (ts - INTERVAL'1-0') AND (ts + INTERVAL'1-0'))(children: TimestampColSubtractIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 13:timestamp, TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 14:timestamp) -> 15:boolean))
-                    predicate: ((ts < (ts + INTERVAL'1-0')) and (ts > (ts - INTERVAL'1-0')) and ((ts + INTERVAL'1-2') = TIMESTAMP'2002-03-01 01:02:03') and (ts = (ts + INTERVAL'0-0')) and (ts <> (ts + INTERVAL'1-0')) and ts BETWEEN (ts - INTERVAL'1-0') AND (ts + INTERVAL'1-0')) (type: boolean)
+                        predicateExpression: FilterExprAndExpr(children: FilterTimestampColLessTimestampColumn(col 0:timestamp, col 8:timestamp)(children: TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 8:timestamp), FilterTimestampColGreaterTimestampColumn(col 0:timestamp, col 9:timestamp)(children: TimestampColSubtractIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 9:timestamp), FilterTimestampScalarNotEqualTimestampColumn(val 2002-04-01 01:02:03, col 10:timestamp)(children: TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 1-2) -> 10:timestamp), FilterTimestampColEqualTimestampScalar(col 11:timestamp, val 2002-03-01 01:02:03)(children: TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 1-2) -> 11:timestamp), FilterTimestampColEqualTimestampColumn(col 0:timestamp, col 12:timestamp)(children: TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 0-0) -> 12:timestamp), FilterTimestampColNotEqualTimestampColumn(col 0:timestamp, col 13:timestamp)(children: TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 13:timestamp), SelectColumnIsTrue(col 16:boolean)(children: VectorUDFAdaptor(ts BETWEEN (ts - INTERVAL'1-0') AND (ts + INTERVAL'1-0'))(children: TimestampColSubtractIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 14:timestamp, TimestampColAddIntervalYearMonthScalar(col 0:timestamp, val 1-0) -> 15:timestamp) -> 16:boolean))
+                    predicate: ((ts < (ts + INTERVAL'1-0')) and (ts > (ts - INTERVAL'1-0')) and (TIMESTAMP'2002-04-01 01:02:03' <> (ts + INTERVAL'1-2')) and ((ts + INTERVAL'1-2') = TIMESTAMP'2002-03-01 01:02:03') and (ts = (ts + INTERVAL'0-0')) and (ts <> (ts + INTERVAL'1-0')) and ts BETWEEN (ts - INTERVAL'1-0') AND (ts + INTERVAL'1-0')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 40 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: ts (type: timestamp)
@@ -1742,7 +1742,7 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: vector_interval_2
-                  filterExpr: (dt is not null and (TIMESTAMP'2001-01-01 01:02:03' < (dt + INTERVAL'0 01:02:04.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' >= (dt - INTERVAL'0 01:02:03.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' > (dt - INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:04.000000000') > TIMESTAMP'2001-01-01 01:02:03') and ((dt - INTERVAL'0 01:02:04.000000000') < TIMESTAMP'2001-01-01 01:02:03') and (ts < (dt + INTERVAL'0 01:02:04.000000000')) and (ts > (dt - INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:03.000000000') = TIMESTAMP'2001-01-01 01:02:03') and (TIMESTAMP'2001-01-01 01:02:03' <> (dt + INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:04.000000000') <> TIMESTAMP'2001-01-01 01:02:03') and (ts = (dt + INTERVAL'0 01:02:03.000000000')) and (ts <> (dt + INTERVAL'0 01:02:04.000000000')) and ts BETWEEN (dt - INTERVAL'0 01:02:03.000000000') AND (dt + INTERVAL'0 01:02:03.000000000')) (type: boolean)
+                  filterExpr: (dt is not null and (TIMESTAMP'2001-01-01 01:02:03' < (dt + INTERVAL'0 01:02:04.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' >= (dt - INTERVAL'0 01:02:03.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' > (dt - INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:04.000000000') > TIMESTAMP'2001-01-01 01:02:03') and ((dt - INTERVAL'0 01:02:04.000000000') < TIMESTAMP'2001-01-01 01:02:03') and (ts < (dt + INTERVAL'0 01:02:04.000000000')) and (ts > (dt - INTERVAL'0 01:02:04.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' <> (dt + INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:03.000000000') = TIMESTAMP'2001-01-01 01:02:03') and ((dt + INTERVAL'0 01:02:04.000000000') <> TIMESTAMP'2001-01-01 01:02:03') and (ts = (dt + INTERVAL'0 01:02:03.000000000')) and (ts <> (dt + INTERVAL'0 01:02:04.000000000')) and ts BETWEEN (dt - INTERVAL'0 01:02:03.000000000') AND (dt + INTERVAL'0 01:02:03.000000000')) (type: boolean)
                   Statistics: Num rows: 2 Data size: 192 Basic stats: COMPLETE Column stats: COMPLETE
                   TableScan Vectorization:
                       native: true
@@ -1750,8 +1750,8 @@ STAGE PLANS:
                     Filter Vectorization:
                         className: VectorFilterOperator
                         native: true
-                        predicateExpression: FilterExprAndExpr(children: SelectColumnIsNotNull(col 1:date), FilterTimestampScalarLessTimestampColumn(val 2001-01-01 01:02:03, col 8:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 8:timestamp), FilterTimestampScalarGreaterEqualTimestampColumn(val 2001-01-01 01:02:03, col 9:timestamp)(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 9:timestamp), FilterTimestampScalarGreaterTimestampColumn(val 2001-01-01 01:02:03, col 10:timestamp)(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 10:timestamp), FilterTimestampColGreaterTimestampScalar(col 11:timestamp, val 2001-01-01 01:02:03)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 11:timestamp), FilterTimestampColLessTimestampScalar(col 12:timestamp, val 2001-01-01 01:02:03)(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 12:timestamp), FilterTimestampColLessTimestampColumn(col 0:timestamp, col 13:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 13:timestamp), FilterTimestampColGreaterTimestampColumn(col 0:timestamp, col 14:timestamp)(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 14:timestamp), FilterTimestampColEqualTimestampScalar(col 15:timestamp, val 2001-01-01 01:02:03)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 15:timestamp), FilterTimestampScalarNotEqualTimestampColumn(val 2001-01-01 01:02:03, col 16:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 16:timestamp), FilterTimestampColNotEqualTimestampScalar(col 17:timestamp, val 2001-01-01 01:02:03)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 17:timestamp), FilterTimestampColEqualTimestampColumn(col 0:timestamp, col 18:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 18:timestamp), FilterTimestampColNotEqualTimestampColumn(col 0:timestamp, col 19:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 19:timestamp), SelectColumnIsTrue(col 22:boolean)(children: VectorUDFAdaptor(ts BETWEEN (dt - INTERVAL'0 01:02:03.000000000') AND (dt + INTERVAL'0 01:02:03.000000000'))(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 20:timestamp, DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 21:timestamp) -> 22:boolean))
-                    predicate: (dt is not null and (TIMESTAMP'2001-01-01 01:02:03' < (dt + INTERVAL'0 01:02:04.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' >= (dt - INTERVAL'0 01:02:03.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' > (dt - INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:04.000000000') > TIMESTAMP'2001-01-01 01:02:03') and ((dt - INTERVAL'0 01:02:04.000000000') < TIMESTAMP'2001-01-01 01:02:03') and (ts < (dt + INTERVAL'0 01:02:04.000000000')) and (ts > (dt - INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:03.000000000') = TIMESTAMP'2001-01-01 01:02:03') and (TIMESTAMP'2001-01-01 01:02:03' <> (dt + INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:04.000000000') <> TIMESTAMP'2001-01-01 01:02:03') and (ts = (dt + INTERVAL'0 01:02:03.000000000')) and (ts <> (dt + INTERVAL'0 01:02:04.000000000')) and ts BETWEEN (dt - INTERVAL'0 01:02:03.000000000') AND (dt + INTERVAL'0 01:02:03.000000000')) (type: boolean)
+                        predicateExpression: FilterExprAndExpr(children: SelectColumnIsNotNull(col 1:date), FilterTimestampScalarLessTimestampColumn(val 2001-01-01 01:02:03, col 8:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 8:timestamp), FilterTimestampScalarGreaterEqualTimestampColumn(val 2001-01-01 01:02:03, col 9:timestamp)(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 9:timestamp), FilterTimestampScalarGreaterTimestampColumn(val 2001-01-01 01:02:03, col 10:timestamp)(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 10:timestamp), FilterTimestampColGreaterTimestampScalar(col 11:timestamp, val 2001-01-01 01:02:03)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 11:timestamp), FilterTimestampColLessTimestampScalar(col 12:timestamp, val 2001-01-01 01:02:03)(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 12:timestamp), FilterTimestampColLessTimestampColumn(col 0:timestamp, col 13:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 13:timestamp), FilterTimestampColGreaterTimestampColumn(col 0:timestamp, col 14:timestamp)(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 14:timestamp), FilterTimestampScalarNotEqualTimestampColumn(val 2001-01-01 01:02:03, col 15:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 15:timestamp), FilterTimestampColEqualTimestampScalar(col 16:timestamp, val 2001-01-01 01:02:03)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 16:timestamp), FilterTimestampColNotEqualTimestampScalar(col 17:timestamp, val 2001-01-01 01:02:03)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 17:timestamp), FilterTimestampColEqualTimestampColumn(col 0:timestamp, col 18:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 18:timestamp), FilterTimestampColNotEqualTimestampColumn(col 0:timestamp, col 19:timestamp)(children: DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:04.000000000) -> 19:timestamp), SelectColumnIsTrue(col 22:boolean)(children: VectorUDFAdaptor(ts BETWEEN (dt - INTERVAL'0 01:02:03.000000000') AND (dt + INTERVAL'0 01:02:03.000000000'))(children: DateColSubtractIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 20:timestamp, DateColAddIntervalDayTimeScalar(col 1:date, val 0 01:02:03.000000000) -> 21:timestamp) -> 22:boolean))
+                    predicate: (dt is not null and (TIMESTAMP'2001-01-01 01:02:03' < (dt + INTERVAL'0 01:02:04.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' >= (dt - INTERVAL'0 01:02:03.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' > (dt - INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:04.000000000') > TIMESTAMP'2001-01-01 01:02:03') and ((dt - INTERVAL'0 01:02:04.000000000') < TIMESTAMP'2001-01-01 01:02:03') and (ts < (dt + INTERVAL'0 01:02:04.000000000')) and (ts > (dt - INTERVAL'0 01:02:04.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' <> (dt + INTERVAL'0 01:02:04.000000000')) and ((dt + INTERVAL'0 01:02:03.000000000') = TIMESTAMP'2001-01-01 01:02:03') and ((dt + INTERVAL'0 01:02:04.000000000') <> TIMESTAMP'2001-01-01 01:02:03') and (ts = (dt + INTERVAL'0 01:02:03.000000000')) and (ts <> (dt + INTERVAL'0 01:02:04.000000000')) and ts BETWEEN (dt - INTERVAL'0 01:02:03.000000000') AND (dt + INTERVAL'0 01:02:03.000000000')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 96 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: ts (type: timestamp)
@@ -1942,7 +1942,7 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: vector_interval_2
-                  filterExpr: ((TIMESTAMP'2001-01-01 01:02:03' < (ts + INTERVAL'1 00:00:00.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' > (ts - INTERVAL'1 00:00:00.000000000')) and ((ts + INTERVAL'1 00:00:00.000000000') > TIMESTAMP'2001-01-01 01:02:03') and ((ts - INTERVAL'1 00:00:00.000000000') < TIMESTAMP'2001-01-01 01:02:03') and (ts < (ts + INTERVAL'1 00:00:00.000000000')) and (ts > (ts - INTERVAL'1 00:00:00.000000000')) and ((ts + INTERVAL'0 00:00:00.000000000') = TIMESTAMP'2001-01-01 01:02:03') and (TIMESTAMP'2001-01-01 01:02:03' <> (ts + INTERVAL'1 00:00:00.000000000')) and TIMESTAMP'2001-01-01 01:02:03' BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000') and ((ts + INTERVAL'1 00:00:00.000000000') <> TIMESTAMP'2001-01-01 01:02:03') and (ts = (ts + INTERVAL'0 00:00:00.000000000')) and (ts <> (ts + INTERVAL'1 00:00:00.000000000')) and ts BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000')) (type: boolean)
+                  filterExpr: ((TIMESTAMP'2001-01-01 01:02:03' < (ts + INTERVAL'1 00:00:00.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' > (ts - INTERVAL'1 00:00:00.000000000')) and ((ts + INTERVAL'1 00:00:00.000000000') > TIMESTAMP'2001-01-01 01:02:03') and ((ts - INTERVAL'1 00:00:00.000000000') < TIMESTAMP'2001-01-01 01:02:03') and (ts < (ts + INTERVAL'1 00:00:00.000000000')) and (ts > (ts - INTERVAL'1 00:00:00.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' <> (ts + INTERVAL'1 00:00:00.000000000')) and TIMESTAMP'2001-01-01 01:02:03' BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000') and ((ts + INTERVAL'0 00:00:00.000000000') = TIMESTAMP'2001-01-01 01:02:03') and ((ts + INTERVAL'1 00:00:00.000000000') <> TIMESTAMP'2001-01-01 01:02:03') and (ts = (ts + INTERVAL'0 00:00:00.000000000')) and (ts <> (ts + INTERVAL'1 00:00:00.000000000')) and ts BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000')) (type: boolean)
                   Statistics: Num rows: 2 Data size: 80 Basic stats: COMPLETE Column stats: COMPLETE
                   TableScan Vectorization:
                       native: true
@@ -1950,8 +1950,8 @@ STAGE PLANS:
                     Filter Vectorization:
                         className: VectorFilterOperator
                         native: true
-                        predicateExpression: FilterExprAndExpr(children: FilterTimestampScalarLessTimestampColumn(val 2001-01-01 01:02:03, col 8:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 8:timestamp), FilterTimestampScalarGreaterTimestampColumn(val 2001-01-01 01:02:03, col 9:timestamp)(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 9:timestamp), FilterTimestampColGreaterTimestampScalar(col 10:timestamp, val 2001-01-01 01:02:03)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 10:timestamp), FilterTimestampColLessTimestampScalar(col 11:timestamp, val 2001-01-01 01:02:03)(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 11:timestamp), FilterTimestampColLessTimestampColumn(col 0:timestamp, col 12:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 12:timestamp), FilterTimestampColGreaterTimestampColumn(col 0:timestamp, col 13:timestamp)(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 13:timestamp), FilterTimestampColEqualTimestampScalar(col 14:timestamp, val 2001-01-01 01:02:03)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 0 00:00:00.000000000) -> 14:timestamp), FilterTimestampScalarNotEqualTimestampColumn(val 2001-01-01 01:02:03, col 15:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 15:timestamp), SelectColumnIsTrue(col 18:boolean)(children: VectorUDFAdaptor(TIMESTAMP'2001-01-01 01:02:03' BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000'))(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 16:timestamp, TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 17:timestamp) -> 18:boolean), FilterTimestampColNotEqualTimestampScalar(col 19:timestamp, val 2001-01-01 01:02:03)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 19:timestamp), FilterTimestampColEqualTimestampColumn(col 0:timestamp, col 20:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 0 00:00:00.000000000) -> 20:timestamp), FilterTimestampColNotEqualTimestampColumn(col 0:timestamp, col 21:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 21:timestamp), SelectColumnIsTrue(col 24:boolean)(children: VectorUDFAdaptor(ts BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000'))(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 22:timestamp, TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 23:timestamp) -> 24:boolean))
-                    predicate: ((TIMESTAMP'2001-01-01 01:02:03' < (ts + INTERVAL'1 00:00:00.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' > (ts - INTERVAL'1 00:00:00.000000000')) and ((ts + INTERVAL'1 00:00:00.000000000') > TIMESTAMP'2001-01-01 01:02:03') and ((ts - INTERVAL'1 00:00:00.000000000') < TIMESTAMP'2001-01-01 01:02:03') and (ts < (ts + INTERVAL'1 00:00:00.000000000')) and (ts > (ts - INTERVAL'1 00:00:00.000000000')) and ((ts + INTERVAL'0 00:00:00.000000000') = TIMESTAMP'2001-01-01 01:02:03') and (TIMESTAMP'2001-01-01 01:02:03' <> (ts + INTERVAL'1 00:00:00.000000000')) and TIMESTAMP'2001-01-01 01:02:03' BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000') and ((ts + INTERVAL'1 00:00:00.000000000') <> TIMESTAMP'2001-01-01 01:02:03') and (ts = (ts + INTERVAL'0 00:00:00.000000000')) and (ts <> (ts + INTERVAL'1 00:00:00.000000000')) and ts BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000')) (type: boolean)
+                        predicateExpression: FilterExprAndExpr(children: FilterTimestampScalarLessTimestampColumn(val 2001-01-01 01:02:03, col 8:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 8:timestamp), FilterTimestampScalarGreaterTimestampColumn(val 2001-01-01 01:02:03, col 9:timestamp)(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 9:timestamp), FilterTimestampColGreaterTimestampScalar(col 10:timestamp, val 2001-01-01 01:02:03)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 10:timestamp), FilterTimestampColLessTimestampScalar(col 11:timestamp, val 2001-01-01 01:02:03)(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 11:timestamp), FilterTimestampColLessTimestampColumn(col 0:timestamp, col 12:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 12:timestamp), FilterTimestampColGreaterTimestampColumn(col 0:timestamp, col 13:timestamp)(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 13:timestamp), FilterTimestampScalarNotEqualTimestampColumn(val 2001-01-01 01:02:03, col 14:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 14:timestamp), SelectColumnIsTrue(col 17:boolean)(children: VectorUDFAdaptor(TIMESTAMP'2001-01-01 01:02:03' BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000'))(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 15:timestamp, TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 16:timestamp) -> 17:boolean), FilterTimestampColEqualTimestampScalar(col 18:timestamp, val 2001-01-01 01:02:03)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 0 00:00:00.000000000) -> 18:timestamp), FilterTimestampColNotEqualTimestampScalar(col 19:timestamp, val 2001-01-01 01:02:03)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 19:timestamp), FilterTimestampColEqualTimestampColumn(col 0:timestamp, col 20:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 0 00:00:00.000000000) -> 20:timestamp), FilterTimestampColNotEqualTimestampColumn(col 0:timestamp, col 21:timestamp)(children: TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 21:timestamp), SelectColumnIsTrue(col 24:boolean)(children: VectorUDFAdaptor(ts BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000'))(children: TimestampColSubtractIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 22:timestamp, TimestampColAddIntervalDayTimeScalar(col 0:timestamp, val 1 00:00:00.000000000) -> 23:timestamp) -> 24:boolean))
+                    predicate: ((TIMESTAMP'2001-01-01 01:02:03' < (ts + INTERVAL'1 00:00:00.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' > (ts - INTERVAL'1 00:00:00.000000000')) and ((ts + INTERVAL'1 00:00:00.000000000') > TIMESTAMP'2001-01-01 01:02:03') and ((ts - INTERVAL'1 00:00:00.000000000') < TIMESTAMP'2001-01-01 01:02:03') and (ts < (ts + INTERVAL'1 00:00:00.000000000')) and (ts > (ts - INTERVAL'1 00:00:00.000000000')) and (TIMESTAMP'2001-01-01 01:02:03' <> (ts + INTERVAL'1 00:00:00.000000000')) and TIMESTAMP'2001-01-01 01:02:03' BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000') and ((ts + INTERVAL'0 00:00:00.000000000') = TIMESTAMP'2001-01-01 01:02:03') and ((ts + INTERVAL'1 00:00:00.000000000') <> TIMESTAMP'2001-01-01 01:02:03') and (ts = (ts + INTERVAL'0 00:00:00.000000000')) and (ts <> (ts + INTERVAL'1 00:00:00.000000000')) and ts BETWEEN (ts - INTERVAL'1 00:00:00.000000000') AND (ts + INTERVAL'1 00:00:00.000000000')) (type: boolean)
                     Statistics: Num rows: 1 Data size: 40 Basic stats: COMPLETE Column stats: COMPLETE
                     Select Operator
                       expressions: ts (type: timestamp)
diff --git a/ql/src/test/results/clientpositive/llap/vector_windowing_navfn.q.out b/ql/src/test/results/clientpositive/llap/vector_windowing_navfn.q.out
index fdc6f3d027..4607932329 100644
--- a/ql/src/test/results/clientpositive/llap/vector_windowing_navfn.q.out
+++ b/ql/src/test/results/clientpositive/llap/vector_windowing_navfn.q.out
@@ -1485,7 +1485,7 @@ STAGE PLANS:
             Map Operator Tree:
                 TableScan
                   alias: over10k_n7
-                  filterExpr: ((t = 10Y) and (s) IN ('oscar allen', 'oscar carson')) (type: boolean)
+                  filterExpr: ((s) IN ('oscar allen', 'oscar carson') and (t = 10Y)) (type: boolean)
                   Statistics: Num rows: 1 Data size: 192 Basic stats: COMPLETE Column stats: NONE
                   TableScan Vectorization:
                       native: true
@@ -1494,8 +1494,8 @@ STAGE PLANS:
                     Filter Vectorization:
                         className: VectorFilterOperator
                         native: true
-                        predicateExpression: FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:tinyint, val 10), FilterStringColumnInList(col 7, values oscar allen, oscar carson))
-                    predicate: ((t = 10Y) and (s) IN ('oscar allen', 'oscar carson')) (type: boolean)
+                        predicateExpression: FilterExprAndExpr(children: FilterStringColumnInList(col 7, values oscar allen, oscar carson), FilterLongColEqualLongScalar(col 0:tinyint, val 10))
+                    predicate: ((s) IN ('oscar allen', 'oscar carson') and (t = 10Y)) (type: boolean)
                     Statistics: Num rows: 1 Data size: 192 Basic stats: COMPLETE Column stats: NONE
                     Reduce Output Operator
                       key expressions: 10Y (type: tinyint), s (type: string)
