diff --git a/itests/hive-minikdc/src/test/java/org/apache/hive/minikdc/TestAuthWithDigestMD5.java b/itests/hive-minikdc/src/test/java/org/apache/hive/minikdc/TestAuthWithDigestMD5.java
new file mode 100644
index 0000000000..088c26869e
--- /dev/null
+++ b/itests/hive-minikdc/src/test/java/org/apache/hive/minikdc/TestAuthWithDigestMD5.java
@@ -0,0 +1,98 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hive.minikdc;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hive.metastore.HiveMetaStoreClient;
+import org.apache.hadoop.hive.metastore.MetaStoreTestUtils;
+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;
+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;
+import org.apache.hadoop.hive.metastore.security.DelegationTokenIdentifier;
+import org.apache.hadoop.hive.metastore.security.HadoopThriftAuthBridge;
+import org.apache.hadoop.io.Text;
+import org.apache.hadoop.security.UserGroupInformation;
+import org.apache.hadoop.security.token.Token;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.concurrent.TimeUnit;
+
+public class TestAuthWithDigestMD5 {
+
+    MiniHiveKdc miniKDC = null;
+    private static HiveMetaStoreClient client;
+    private static final String HS2TOKEN = "HiveServer2ImpersonationToken";
+    private static Configuration conf = null;
+    private static int port;
+
+    @Before
+    public void setUp() throws Exception {
+        miniKDC = new MiniHiveKdc();
+        String hiveMetastorePrincipal = miniKDC.getFullyQualifiedServicePrincipal(miniKDC.getHiveMetastoreServicePrincipal());
+        String hiveMetastoreKeytab = miniKDC.getKeyTabFile(
+                miniKDC.getServicePrincipalForUser(miniKDC.getHiveMetastoreServicePrincipal()));
+        conf = MetastoreConf.newMetastoreConf();
+
+        String correctUser = "correct_user";
+        String correctPassword = "correct_passwd";
+
+        MetastoreConf.setBoolVar(conf, ConfVars.EXECUTE_SET_UGI, false);
+        MetastoreConf.setVar(conf, ConfVars.THRIFT_AUTH_CONFIG_USERNAME, correctUser);
+        MetastoreConf.setVar(conf, ConfVars.THRIFT_AUTH_CONFIG_PASSWORD, correctPassword);
+        MetastoreConf.setBoolVar(conf, ConfVars.USE_THRIFT_SASL, true);
+        MetastoreConf.setVar(conf, ConfVars.KERBEROS_PRINCIPAL, hiveMetastorePrincipal);
+        MetastoreConf.setVar(conf, ConfVars.KERBEROS_KEYTAB_FILE, hiveMetastoreKeytab);
+
+        MetastoreConf.setTimeVar(conf, ConfVars.DELEGATION_TOKEN_RENEW_INTERVAL,2000, TimeUnit.MILLISECONDS);
+        MetastoreConf.setTimeVar(conf, ConfVars.DELEGATION_TOKEN_GC_INTERVAL,1000, TimeUnit.MILLISECONDS);
+
+        port = MetaStoreTestUtils.startMetaStoreWithRetry(HadoopThriftAuthBridge.getBridge(),
+                conf);
+        System.out.println("Starting MetaStore Server on port " + port);
+
+        MetastoreConf.setVar(conf, ConfVars.THRIFT_URIS, "thrift://localhost:" + port);
+        client = new HiveMetaStoreClient(conf);
+    }
+
+
+    @Test
+    public void testPostRenewalTimeThreadKickedIn() throws Exception {
+        String token = client.getDelegationToken("hive","hive");
+        MetastoreConf.setVar(conf, ConfVars.TOKEN_SIGNATURE, HS2TOKEN);
+
+        client = new HiveMetaStoreClient(conf);
+
+        Token<DelegationTokenIdentifier> delegationToken = new Token<DelegationTokenIdentifier>();
+        delegationToken.decodeFromUrlString(token);
+        delegationToken.setService(new Text(HS2TOKEN));
+        UserGroupInformation.getCurrentUser().addToken(delegationToken);
+
+        Thread.sleep(4000);
+        client = new HiveMetaStoreClient(conf);
+        client.close();
+    }
+
+    @After
+    public void tearDown() {
+        MetaStoreTestUtils.close(port);
+        miniKDC.shutDown();
+    }
+
+}
diff --git a/itests/hive-unit-hadoop2/src/test/java/org/apache/hadoop/hive/metastore/security/TestHadoopAuthBridge23.java b/itests/hive-unit-hadoop2/src/test/java/org/apache/hadoop/hive/metastore/security/TestHadoopAuthBridge23.java
index e255333023..98571ffe21 100644
--- a/itests/hive-unit-hadoop2/src/test/java/org/apache/hadoop/hive/metastore/security/TestHadoopAuthBridge23.java
+++ b/itests/hive-unit-hadoop2/src/test/java/org/apache/hadoop/hive/metastore/security/TestHadoopAuthBridge23.java
@@ -204,13 +204,22 @@ public void testDelegationTokenSharedStore() throws Exception {
       // expected
     }
 
-    // token expiration
+    // token Renewal
     MyTokenStore.TOKEN_STORE.addToken(d,
         new DelegationTokenInformation(0, t.getPassword()));
     Assert.assertNotNull(MyTokenStore.TOKEN_STORE.getToken(d));
-    anotherManager.removeExpiredTokens();
+    anotherManager.renewOrRemoveExpiredTokens();
+    Assert.assertTrue(MyTokenStore.TOKEN_STORE.getToken(d).getRenewDate() > 0);
+
+    // test Expiration
+    DelegationTokenIdentifier e = new DelegationTokenIdentifier();
+    e.setMaxDate(0);
+    MyTokenStore.TOKEN_STORE.addToken(e,
+            new DelegationTokenInformation(0, t.getPassword()));
+    Assert.assertNotNull(MyTokenStore.TOKEN_STORE.getToken(e));
+    anotherManager.renewOrRemoveExpiredTokens();
     Assert.assertNull("Expired token not removed",
-        MyTokenStore.TOKEN_STORE.getToken(d));
+        MyTokenStore.TOKEN_STORE.getToken(e));
 
     // key expiration - create an already expired key
     anotherManager.startThreads(); // generates initial key
diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/security/TokenStoreDelegationTokenSecretManager.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/security/TokenStoreDelegationTokenSecretManager.java
index b08ead0fce..01182b8981 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/security/TokenStoreDelegationTokenSecretManager.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/security/TokenStoreDelegationTokenSecretManager.java
@@ -31,14 +31,16 @@
 import java.util.List;
 import java.util.Map;
 
+import org.apache.hadoop.io.Text;
 import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.security.UserGroupInformation;
 import org.apache.hadoop.security.token.Token;
-import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;
 import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenSecretManager;
 import org.apache.hadoop.security.token.delegation.DelegationKey;
 import org.apache.hadoop.security.token.delegation.MetastoreDelegationTokenSupport;
 import org.apache.hadoop.util.Daemon;
 import org.apache.hadoop.util.StringUtils;
+import org.apache.hadoop.util.Time;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -103,6 +105,10 @@ public byte[] retrievePassword(DelegationTokenIdentifier identifier) throws Inva
       if (info == null) {
           throw new InvalidToken("token expired or does not exist: " + identifier);
       }
+      renewIfRequired(System.currentTimeMillis(), identifier, info);
+      // we have to fetch the token again as it has been renewed and info still contains the previous renew time.
+      info = this.tokenStore.getToken(identifier);
+
       // must reuse super as info.getPassword is not accessible
       synchronized (this) {
         try {
@@ -163,8 +169,12 @@ public long renewToken(Token<DelegationTokenIdentifier> token, String renewer) t
       try {
         long res = super.renewToken(token, renewer);
         this.tokenStore.removeToken(id);
-        this.tokenStore.addToken(id, super.currentTokens.get(id));
+        DelegationTokenInformation updatedToken = super.currentTokens.get(id);
+        this.tokenStore.addToken(id, updatedToken);
+        LOGGER.info("Successfully renewed token : " + id + ", Renewal time now is: " +
+                Time.formatTime(updatedToken.getRenewDate()));
         return res;
+
       } finally {
         super.currentTokens.remove(id);
       }
@@ -236,22 +246,40 @@ public synchronized void stopThreads() {
    * that cannot be reused due to private method access. Logic here can more efficiently
    * deal with external token store by only loading into memory the minimum data needed.
    */
-  protected void removeExpiredTokens() {
+  protected void renewOrRemoveExpiredTokens() {
     long now = System.currentTimeMillis();
-    Iterator<DelegationTokenIdentifier> i = tokenStore.getAllDelegationTokenIdentifiers()
-        .iterator();
-    while (i.hasNext()) {
-      DelegationTokenIdentifier id = i.next();
+    for (DelegationTokenIdentifier id : tokenStore.getAllDelegationTokenIdentifiers()) {
       if (now > id.getMaxDate()) {
+        LOGGER.info("Expiry Thread removing expired token: " + id);
         this.tokenStore.removeToken(id); // no need to look at token info
       } else {
         // get token info to check renew date
-        DelegationTokenInformation tokenInfo = tokenStore.getToken(id);
-        if (tokenInfo != null) {
-          if (now > tokenInfo.getRenewDate()) {
-            this.tokenStore.removeToken(id);
-          }
+        try {
+          renewIfRequired(now, id, tokenStore.getToken(id));
+        } catch (InvalidToken e) {
+          LOGGER.warn("Failed to renew token: " + id, e);
+        }
+      }
+    }
+  }
+
+  private void renewIfRequired(long currentTime, DelegationTokenIdentifier id, DelegationTokenInformation tokenInfo)
+          throws InvalidToken {
+    if (tokenInfo != null) {
+      if (currentTime > tokenInfo.getRenewDate() && currentTime < id.getMaxDate()) {
+        // This will be the case when now > tokenInfo.getRenewDate() but less than the token expiration/max time.
+        LOGGER.info("Trying to renew the token: " + id);
+        try {
+          DelegationKey key = getDelegationKey(id.getMasterKeyId());
+          Token<DelegationTokenIdentifier> t = new Token<>(id.getBytes(), createPassword(id.getBytes(), key.getKey()),
+                  id.getKind(), new Text());
+          renewToken(t, UserGroupInformation.getCurrentUser().getShortUserName());
+        } catch (IOException e) {
+          throw new InvalidToken("Unable to renew token: " + id + " due to " + e.getMessage());
         }
+      } else if (currentTime > id.getMaxDate()) {
+        // In this case expiry time has passed and this token cannot be further renewed.
+        throw new InvalidToken("Expiration time passed. Cannot renew the token.");
       }
     }
   }
@@ -309,7 +337,7 @@ public void run() {
             }
           }
           if (lastTokenCacheCleanup + tokenRemoverScanInterval < now) {
-            removeExpiredTokens();
+            renewOrRemoveExpiredTokens();
             lastTokenCacheCleanup = now;
           }
           try {
diff --git a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/security/TestTokenStoreDelegationTokenSecretManager.java b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/security/TestTokenStoreDelegationTokenSecretManager.java
index c0f47a2725..ff0997cfdd 100644
--- a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/security/TestTokenStoreDelegationTokenSecretManager.java
+++ b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/security/TestTokenStoreDelegationTokenSecretManager.java
@@ -41,25 +41,18 @@
   private final Configuration conf = MetastoreConf.newMetastoreConf();
 
   private TokenStoreDelegationTokenSecretManager createTokenMgr(DelegationTokenStore tokenStore,
-      long renewSecs) {
-    MetastoreConf.setTimeVar(conf, MetastoreConf.ConfVars.DELEGATION_TOKEN_RENEW_INTERVAL,
-        renewSecs, TimeUnit.SECONDS);
+      long renewSecs, long gcTime, long maxLifeTime) {
     long secretKeyInterval =
-        MetastoreConf.getTimeVar(conf, MetastoreConf.ConfVars.DELEGATION_KEY_UPDATE_INTERVAL,
-            TimeUnit.MILLISECONDS);
-    long tokenMaxLifetime =
-        MetastoreConf.getTimeVar(conf, MetastoreConf.ConfVars.DELEGATION_TOKEN_MAX_LIFETIME,
-            TimeUnit.MILLISECONDS);
-    long tokenRenewInterval =
-        MetastoreConf.getTimeVar(conf, MetastoreConf.ConfVars.DELEGATION_TOKEN_RENEW_INTERVAL,
-            TimeUnit.MILLISECONDS);
-    long tokenGcInterval =
-        MetastoreConf.getTimeVar(conf, MetastoreConf.ConfVars.DELEGATION_TOKEN_GC_INTERVAL,
-            TimeUnit.MILLISECONDS);
+            MetastoreConf.getTimeVar(conf, MetastoreConf.ConfVars.DELEGATION_KEY_UPDATE_INTERVAL,
+                    TimeUnit.MILLISECONDS);
+    long tokenMaxLifetime = maxLifeTime * 1000;
+    long tokenRenewInterval = renewSecs * 1000;
+    long tokenGcInterval = gcTime * 1000;
     return new TokenStoreDelegationTokenSecretManager(secretKeyInterval, tokenMaxLifetime,
         tokenRenewInterval, tokenGcInterval, tokenStore);
   }
 
+
   private DelegationTokenIdentifier getID(String tokenStr) throws IOException {
     DelegationTokenIdentifier id = new DelegationTokenIdentifier();
     Token<DelegationTokenIdentifier> token = new Token<>();
@@ -74,7 +67,9 @@ private DelegationTokenIdentifier getID(String tokenStr) throws IOException {
   @Test public void testRenewal() throws IOException, InterruptedException {
     DelegationTokenStore tokenStore = new MemoryTokenStore();
     // Have a long renewal to ensure that Thread.sleep does not overshoot the initial validity
-    TokenStoreDelegationTokenSecretManager mgr = createTokenMgr(tokenStore, 3600);
+    TokenStoreDelegationTokenSecretManager mgr = createTokenMgr(tokenStore, 3600, MetastoreConf.getTimeVar(
+            conf, MetastoreConf.ConfVars.DELEGATION_TOKEN_GC_INTERVAL, TimeUnit.SECONDS), MetastoreConf.getTimeVar(conf,
+            MetastoreConf.ConfVars.DELEGATION_TOKEN_MAX_LIFETIME, TimeUnit.SECONDS));
     try {
       mgr.startThreads();
       String tokenStr =
@@ -97,9 +92,9 @@ private DelegationTokenIdentifier getID(String tokenStr) throws IOException {
     }
   }
 
-  @Test public void testExpiry() throws IOException, InterruptedException {
+  @Test public void testTokenRenewalAndRemoval() throws IOException, InterruptedException {
     DelegationTokenStore tokenStore = new MemoryTokenStore();
-    TokenStoreDelegationTokenSecretManager mgr = createTokenMgr(tokenStore, 1);
+    TokenStoreDelegationTokenSecretManager mgr = createTokenMgr(tokenStore, 2, 1, 8);
     try {
       mgr.startThreads();
       String tokenStr =
@@ -107,11 +102,15 @@ private DelegationTokenIdentifier getID(String tokenStr) throws IOException {
               UserGroupInformation.getCurrentUser().getShortUserName());
       DelegationTokenIdentifier id = getID(tokenStr);
       Assert.assertNotNull(mgr.verifyDelegationToken(tokenStr));
-      // Sleep for the renewal duration
-      Thread.sleep(1000);
-      SecretManager.InvalidToken ex = Assert.assertThrows(SecretManager.InvalidToken.class,
-          () -> mgr.verifyDelegationToken(tokenStr));
-      Assert.assertTrue(ex.getMessage(), ex.getMessage().contains("has expired"));
+
+      long initialExpiry = tokenStore.getToken(id).getRenewDate();
+      Thread.sleep(5000);
+      // Token should automatically get renewed by the Thread as the current time is > renew time.
+      Assert.assertTrue(tokenStore.getToken(id).getRenewDate() > initialExpiry);
+
+      Thread.sleep(5000);
+      //Expiry thread will remove the token as it has crossed the maxLifeTime.
+      Assert.assertEquals(tokenStore.getAllDelegationTokenIdentifiers().size(), 0);
     } finally {
       mgr.stopThreads();
     }
