diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/ColumnInfo.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/ColumnInfo.java
index e40da12358..a34a31d5dd 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/ColumnInfo.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/ColumnInfo.java
@@ -208,6 +208,7 @@ public boolean equals(Object obj) {
       return false;
     }
 
+    // TODO: why does this not compare tabAlias?
     ColumnInfo dest = (ColumnInfo)obj;
     if ((!checkEquals(internalName, dest.getInternalName())) ||
         (!checkEquals(alias, dest.getAlias())) ||
@@ -221,6 +222,18 @@ public boolean equals(Object obj) {
     return true;
   }
 
+  public boolean isSameColumnForRR(ColumnInfo other) {
+    return checkEquals(tabAlias, other.tabAlias)
+        && checkEquals(alias, other.alias)
+        && checkEquals(internalName, other.internalName)
+        && checkEquals(getType(), other.getType());
+  }
+
+  public String toMappingString(String tab, String col) {
+    return tab + "." + col + " => {" + tabAlias + ", " + alias + ", "
+        + internalName + ": " + getType() + "}";
+  }
+
   public void setObjectinspector(ObjectInspector writableObjectInspector) {
     this.objectInspector = writableObjectInspector;
   }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/RowResolver.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/RowResolver.java
index 82315eb0d3..469dc9f406 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/RowResolver.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/RowResolver.java
@@ -403,21 +403,27 @@ private static boolean add(RowResolver rrToAddTo, RowResolver rrToAddFrom,
   public boolean putWithCheck(String tabAlias, String colAlias,
       String internalName, ColumnInfo newCI) throws SemanticException {
     ColumnInfo existing = get(tabAlias, colAlias);
+    // Hive adds the same mapping twice... I wish we could fix stuff like that.
     if (existing == null) {
       put(tabAlias, colAlias, newCI);
       return true;
+    } else if (existing.isSameColumnForRR(newCI)) {
+      return true;
     }
-    LOG.warn("Found duplicate column alias in RR: " + existing + " for "
-        + tabAlias + "." + colAlias + " and " + internalName);
+    LOG.warn("Found duplicate column alias in RR: "
+        + existing.toMappingString(tabAlias, colAlias) + " adding "
+        + newCI.toMappingString(tabAlias, colAlias));
     if (internalName != null) {
       existing = get(tabAlias, internalName);
       if (existing == null) {
         put(tabAlias, internalName, newCI);
         return true;
+      } else if (existing.isSameColumnForRR(newCI)) {
+        return true;
       }
+      LOG.warn("Failed to use internal name after finding a duplicate: "
+          + existing.toMappingString(tabAlias, internalName));
     }
-    LOG.warn("Failed to use internal name after finding a duplicate: " + existing
-        + " for " + tabAlias + "." + internalName);
     return false;
   }
 
diff --git a/ql/src/test/results/clientpositive/tez/cbo_correctness.q.out b/ql/src/test/results/clientpositive/tez/cbo_correctness.q.out
index d98cb5b95e..2103d08da8 100644
--- a/ql/src/test/results/clientpositive/tez/cbo_correctness.q.out
+++ b/ql/src/test/results/clientpositive/tez/cbo_correctness.q.out
@@ -16734,26 +16734,6 @@ POSTHOOK: Input: default@t1@dt=2014
 POSTHOOK: Input: default@t2
 POSTHOOK: Input: default@t2@dt=2014
 #### A masked pattern was here ####
- 1	 1	1	1.0	true	2014
- 1	 1	1	1.0	true	2014
- 1 	 1 	1	1.0	true	2014
- 1 	 1 	1	1.0	true	2014
-1	1	1	1.0	false	2014
-1	1	1	1.0	false	2014
-1	1	1	1.0	true	2014
-1	1	1	1.0	true	2014
-1	1	1	1.0	true	2014
-1	1	1	1.0	true	2014
-1	1	1	1.0	true	2014
-1 	1 	1	1.0	true	2014
-1 	1 	1	1.0	true	2014
-2	2	2	2.0	true	2014
-2	2	2	2.0	true	2014
-2	2	2	2.0	true	2014
-2	2	2	2.0	true	2014
-2	2	2	2.0	true	2014
-null	null	NULL	NULL	NULL	2014
-null	null	NULL	NULL	NULL	2014
 1	1	1	1.0	true	2014
 1	1	1	1.0	true	2014
 1	1	1	1.0	true	2014
@@ -16773,6 +16753,26 @@ null	null	NULL	NULL	NULL	2014
 1	1	1	1.0	false	2014
 1	1	1	1.0	false	2014
 null	null	NULL	NULL	NULL	2014
+null	null	NULL	NULL	NULL	2014
+ 1	 1	1	1.0	true	2014
+ 1	 1	1	1.0	true	2014
+ 1 	 1 	1	1.0	true	2014
+ 1 	 1 	1	1.0	true	2014
+1	1	1	1.0	false	2014
+1	1	1	1.0	false	2014
+1	1	1	1.0	true	2014
+1	1	1	1.0	true	2014
+1	1	1	1.0	true	2014
+1	1	1	1.0	true	2014
+1	1	1	1.0	true	2014
+1 	1 	1	1.0	true	2014
+1 	1 	1	1.0	true	2014
+2	2	2	2.0	true	2014
+2	2	2	2.0	true	2014
+2	2	2	2.0	true	2014
+2	2	2	2.0	true	2014
+2	2	2	2.0	true	2014
+null	null	NULL	NULL	NULL	2014
 null	null	NULL	NULL	NULL	2014
 PREHOOK: query: select key from (select key, c_int from (select * from t1 union all select * from t2 where t2.key >=0)r1 union all select key, c_int from t3)r2 where key >=0 order by key
 PREHOOK: type: QUERY
