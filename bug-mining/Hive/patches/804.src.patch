diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java b/metastore/src/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java
index d0c7228afa..b79962a65b 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java
@@ -296,6 +296,7 @@ public Partition alterPartition(final RawStore msdb, Warehouse wh, final String
       try {
         destPath = new Path(wh.getTablePath(msdb.getDatabase(dbname), name),
             Warehouse.makePartName(tbl.getPartitionKeys(), new_part.getValues()));
+        destPath = constructRenamedPartitionPath(destPath, new_part);
       } catch (NoSuchObjectException e) {
         LOG.debug(e);
         throw new InvalidOperationException(
@@ -398,4 +399,15 @@ private boolean checkPartialPartKeysEqual(List<FieldSchema> oldPartKeys,
 
     return true;
   }
+
+  /**
+   * Uses the scheme and authority of the partition's current location, and the path constructed
+   * using the partition's new name to construct a path for the partition's new location.
+   */
+  private Path constructRenamedPartitionPath(Path defaultPath, Partition part) {
+    Path oldPath = new Path(part.getSd().getLocation());
+    URI oldUri = oldPath.toUri();
+
+    return new Path(oldUri.getScheme(), oldUri.getAuthority(), defaultPath.toUri().getPath());
+  }
 }
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/hooks/VerifyPartitionIsNotSubdirectoryOfTableHook.java b/ql/src/test/org/apache/hadoop/hive/ql/hooks/VerifyPartitionIsNotSubdirectoryOfTableHook.java
new file mode 100644
index 0000000000..ce377be1c2
--- /dev/null
+++ b/ql/src/test/org/apache/hadoop/hive/ql/hooks/VerifyPartitionIsNotSubdirectoryOfTableHook.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hive.ql.hooks;
+
+import junit.framework.Assert;
+
+import org.apache.hadoop.hive.ql.metadata.Partition;
+import org.apache.hadoop.hive.ql.metadata.Table;
+
+// This hook verifies that the location of every partition in the inputs and outputs does not
+// start with the location of the table.  It is a very simple check to make sure the location is
+// not a subdirectory.
+public class VerifyPartitionIsNotSubdirectoryOfTableHook implements ExecuteWithHookContext {
+
+  public void run(HookContext hookContext) {
+    for (WriteEntity output : hookContext.getOutputs()) {
+      if (output.getType() == WriteEntity.Type.PARTITION) {
+        verify (output.getPartition(), output.getTable());
+      }
+    }
+
+    for (ReadEntity input : hookContext.getInputs()) {
+      if (input.getType() == ReadEntity.Type.PARTITION) {
+        verify (input.getPartition(), input.getTable());
+      }
+    }
+  }
+
+  private void verify(Partition partition, Table table) {
+    Assert.assertFalse("The location of the partition: " + partition.getName() + " was a " +
+        "subdirectory of the location of the table: " + table.getTableName(),
+        partition.getPartitionPath().toString().startsWith(table.getPath().toString()));
+  }
+}
diff --git a/ql/src/test/queries/clientpositive/rename_partition_location.q b/ql/src/test/queries/clientpositive/rename_partition_location.q
new file mode 100644
index 0000000000..ee4ff8171f
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/rename_partition_location.q
@@ -0,0 +1,20 @@
+-- This test verifies that if the tables location changes, renaming a partition will not change
+-- the partition location accordingly
+
+CREATE TABLE rename_partition_table (key STRING, value STRING) PARTITIONED BY (part STRING)
+STORED AS RCFILE
+LOCATION 'pfile:${system:test.tmp.dir}/rename_partition_table';
+
+INSERT OVERWRITE TABLE rename_partition_table PARTITION (part = '1') SELECT * FROM src;
+
+ALTER TABLE rename_partition_table SET LOCATION 'file:${system:test.tmp.dir}/rename_partition_table';
+
+ALTER TABLE rename_partition_table PARTITION (part = '1') RENAME TO PARTITION (part = '2');
+
+SET hive.exec.post.hooks=org.apache.hadoop.hive.ql.hooks.VerifyPartitionIsNotSubdirectoryOfTableHook;
+
+SELECT count(*) FROM rename_partition_table where part = '2';
+
+SET hive.exec.post.hooks=;
+
+DROP TABLE rename_partition_table;
diff --git a/ql/src/test/results/clientpositive/rename_partition_location.q.out b/ql/src/test/results/clientpositive/rename_partition_location.q.out
new file mode 100644
index 0000000000..1020a2b075
--- /dev/null
+++ b/ql/src/test/results/clientpositive/rename_partition_location.q.out
@@ -0,0 +1,56 @@
+PREHOOK: query: -- This test verifies that if the tables location changes, renaming a partition will not change
+-- the partition location accordingly
+
+CREATE TABLE rename_partition_table (key STRING, value STRING) PARTITIONED BY (part STRING)
+STORED AS RCFILE
+#### A masked pattern was here ####
+PREHOOK: type: CREATETABLE
+POSTHOOK: query: -- This test verifies that if the tables location changes, renaming a partition will not change
+-- the partition location accordingly
+
+CREATE TABLE rename_partition_table (key STRING, value STRING) PARTITIONED BY (part STRING)
+STORED AS RCFILE
+#### A masked pattern was here ####
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: default@rename_partition_table
+PREHOOK: query: INSERT OVERWRITE TABLE rename_partition_table PARTITION (part = '1') SELECT * FROM src
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+PREHOOK: Output: default@rename_partition_table@part=1
+POSTHOOK: query: INSERT OVERWRITE TABLE rename_partition_table PARTITION (part = '1') SELECT * FROM src
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+POSTHOOK: Output: default@rename_partition_table@part=1
+POSTHOOK: Lineage: rename_partition_table PARTITION(part=1).key SIMPLE [(src)src.FieldSchema(name:key, type:string, comment:default), ]
+POSTHOOK: Lineage: rename_partition_table PARTITION(part=1).value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
+#### A masked pattern was here ####
+PREHOOK: type: ALTERTABLE_LOCATION
+PREHOOK: Input: default@rename_partition_table
+PREHOOK: Output: default@rename_partition_table
+#### A masked pattern was here ####
+POSTHOOK: type: ALTERTABLE_LOCATION
+POSTHOOK: Input: default@rename_partition_table
+POSTHOOK: Output: default@rename_partition_table
+POSTHOOK: Lineage: rename_partition_table PARTITION(part=1).key SIMPLE [(src)src.FieldSchema(name:key, type:string, comment:default), ]
+POSTHOOK: Lineage: rename_partition_table PARTITION(part=1).value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
+PREHOOK: query: ALTER TABLE rename_partition_table PARTITION (part = '1') RENAME TO PARTITION (part = '2')
+PREHOOK: type: ALTERTABLE_RENAMEPART
+PREHOOK: Input: default@rename_partition_table
+PREHOOK: Output: default@rename_partition_table@part=1
+POSTHOOK: query: ALTER TABLE rename_partition_table PARTITION (part = '1') RENAME TO PARTITION (part = '2')
+POSTHOOK: type: ALTERTABLE_RENAMEPART
+POSTHOOK: Input: default@rename_partition_table
+POSTHOOK: Input: default@rename_partition_table@part=1
+POSTHOOK: Output: default@rename_partition_table@part=1
+POSTHOOK: Output: default@rename_partition_table@part=2
+POSTHOOK: Lineage: rename_partition_table PARTITION(part=1).key SIMPLE [(src)src.FieldSchema(name:key, type:string, comment:default), ]
+POSTHOOK: Lineage: rename_partition_table PARTITION(part=1).value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
+PREHOOK: query: SELECT count(*) FROM rename_partition_table where part = '2'
+PREHOOK: type: QUERY
+PREHOOK: Input: default@rename_partition_table@part=2
+#### A masked pattern was here ####
+500
+PREHOOK: query: DROP TABLE rename_partition_table
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: default@rename_partition_table
+PREHOOK: Output: default@rename_partition_table
