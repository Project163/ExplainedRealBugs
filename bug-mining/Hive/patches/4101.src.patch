diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateAddColScalar.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateAddColScalar.java
index 9a9c92851a..f540994277 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateAddColScalar.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateAddColScalar.java
@@ -66,6 +66,7 @@ public void evaluate(VectorizedRowBatch batch) {
     /* every line below this is identical for evaluateLong & evaluateString */
     final int n = inputCol.isRepeating ? 1 : batch.size;
     int[] sel = batch.selected;
+    final boolean selectedInUse = (inputCol.isRepeating == false) && batch.selectedInUse;
 
     if(batch.size == 0) {
       /* n != batch.size when isRepeating */
@@ -79,7 +80,7 @@ public void evaluate(VectorizedRowBatch batch) {
       case DATE:
         if (inputCol.noNulls) {
           outV.noNulls = true;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.vector[i] = evaluateDate(inputCol, i);
@@ -97,7 +98,7 @@ public void evaluate(VectorizedRowBatch batch) {
           // Handle case with nulls. Don't do function if the value is null, to save time,
           // because calling the function can be expensive.
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j = 0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = inputCol.isNull[i];
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateAddScalarCol.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateAddScalarCol.java
index e0497a1a2e..2b473eca62 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateAddScalarCol.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateAddScalarCol.java
@@ -72,6 +72,7 @@ public void evaluate(VectorizedRowBatch batch) {
     /* every line below this is identical for evaluateLong & evaluateString */
     final int n = inputCol.isRepeating ? 1 : batch.size;
     int[] sel = batch.selected;
+    final boolean selectedInUse = (inputCol.isRepeating == false) && batch.selectedInUse;
     BytesColumnVector outV = (BytesColumnVector) batch.cols[outputColumn];
 
     switch (inputTypes[0]) {
@@ -91,7 +92,7 @@ public void evaluate(VectorizedRowBatch batch) {
           break;
         } catch (Exception e) {
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = true;
@@ -117,7 +118,7 @@ public void evaluate(VectorizedRowBatch batch) {
 
     if (inputCol.noNulls) {
       outV.noNulls = true;
-      if (batch.selectedInUse) {
+      if (selectedInUse) {
         for(int j=0; j < n; j++) {
           int i = sel[j];
           evaluate(baseDate, inputCol.vector[i], outV, i);
@@ -131,7 +132,7 @@ public void evaluate(VectorizedRowBatch batch) {
       // Handle case with nulls. Don't do function if the value is null, to save time,
       // because calling the function can be expensive.
       outV.noNulls = false;
-      if (batch.selectedInUse) {
+      if (selectedInUse) {
         for(int j = 0; j < n; j++) {
           int i = sel[j];
           outV.isNull[i] = inputCol.isNull[i];
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateDiffColScalar.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateDiffColScalar.java
index 3df53a48c1..0dfe8d5d96 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateDiffColScalar.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateDiffColScalar.java
@@ -71,6 +71,7 @@ public void evaluate(VectorizedRowBatch batch) {
     /* every line below this is identical for evaluateLong & evaluateString */
     final int n = inputCol.isRepeating ? 1 : batch.size;
     int[] sel = batch.selected;
+    final boolean selectedInUse = (inputCol.isRepeating == false) && batch.selectedInUse;
 
     if(batch.size == 0) {
       /* n != batch.size when isRepeating */
@@ -99,7 +100,7 @@ public void evaluate(VectorizedRowBatch batch) {
           break;
         } catch (Exception e) {
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = true;
@@ -119,7 +120,7 @@ public void evaluate(VectorizedRowBatch batch) {
       case DATE:
         if (inputCol.noNulls) {
           outV.noNulls = true;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.vector[i] = evaluateDate(inputCol, i);
@@ -133,7 +134,7 @@ public void evaluate(VectorizedRowBatch batch) {
           // Handle case with nulls. Don't do function if the value is null, to save time,
           // because calling the function can be expensive.
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j = 0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = inputCol.isNull[i];
@@ -155,7 +156,7 @@ public void evaluate(VectorizedRowBatch batch) {
       case TIMESTAMP:
         if (inputCol.noNulls) {
           outV.noNulls = true;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.vector[i] = evaluateTimestamp(inputCol, i);
@@ -169,7 +170,7 @@ public void evaluate(VectorizedRowBatch batch) {
           // Handle case with nulls. Don't do function if the value is null, to save time,
           // because calling the function can be expensive.
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j = 0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = inputCol.isNull[i];
@@ -193,7 +194,7 @@ public void evaluate(VectorizedRowBatch batch) {
       case VARCHAR:
         if (inputCol.noNulls) {
           outV.noNulls = true;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               evaluateString(inputCol, outV, i);
@@ -207,7 +208,7 @@ public void evaluate(VectorizedRowBatch batch) {
           // Handle case with nulls. Don't do function if the value is null, to save time,
           // because calling the function can be expensive.
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j = 0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = inputCol.isNull[i];
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateDiffScalarCol.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateDiffScalarCol.java
index b16a21c670..3ea82aaa4a 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateDiffScalarCol.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFDateDiffScalarCol.java
@@ -70,6 +70,7 @@ public void evaluate(VectorizedRowBatch batch) {
     /* every line below this is identical for evaluateLong & evaluateString */
     final int n = inputCol.isRepeating ? 1 : batch.size;
     int[] sel = batch.selected;
+    final boolean selectedInUse = (inputCol.isRepeating == false) && batch.selectedInUse;
 
     if(batch.size == 0) {
       /* n != batch.size when isRepeating */
@@ -98,7 +99,7 @@ public void evaluate(VectorizedRowBatch batch) {
           break;
         } catch (Exception e) {
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = true;
@@ -118,7 +119,7 @@ public void evaluate(VectorizedRowBatch batch) {
       case DATE:
         if (inputCol.noNulls) {
           outV.noNulls = true;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.vector[i] = evaluateDate(inputCol, i);
@@ -132,7 +133,7 @@ public void evaluate(VectorizedRowBatch batch) {
           // Handle case with nulls. Don't do function if the value is null, to save time,
           // because calling the function can be expensive.
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j = 0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = inputCol.isNull[i];
@@ -154,7 +155,7 @@ public void evaluate(VectorizedRowBatch batch) {
       case TIMESTAMP:
         if (inputCol.noNulls) {
           outV.noNulls = true;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.vector[i] = evaluateTimestamp(inputCol, i);
@@ -168,7 +169,7 @@ public void evaluate(VectorizedRowBatch batch) {
           // Handle case with nulls. Don't do function if the value is null, to save time,
           // because calling the function can be expensive.
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j = 0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = inputCol.isNull[i];
@@ -192,7 +193,7 @@ public void evaluate(VectorizedRowBatch batch) {
       case VARCHAR:
         if (inputCol.noNulls) {
           outV.noNulls = true;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               evaluateString(inputCol, outV, i);
@@ -206,7 +207,7 @@ public void evaluate(VectorizedRowBatch batch) {
           // Handle case with nulls. Don't do function if the value is null, to save time,
           // because calling the function can be expensive.
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j = 0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = inputCol.isNull[i];
@@ -302,4 +303,4 @@ public VectorExpressionDescriptor.Descriptor getDescriptor() {
             VectorExpressionDescriptor.InputExpressionType.COLUMN);
     return b.build();
   }
-}
\ No newline at end of file
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFTimestampFieldLong.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFTimestampFieldLong.java
index 1cda0a9bc8..3b9fffc6ca 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFTimestampFieldLong.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFTimestampFieldLong.java
@@ -98,6 +98,7 @@ public void evaluate(VectorizedRowBatch batch) {
     /* every line below this is identical for evaluateLong & evaluateString */
     final int n = inputCol.isRepeating ? 1 : batch.size;
     int[] sel = batch.selected;
+    final boolean selectedInUse = (inputCol.isRepeating == false) && batch.selectedInUse;
 
     if(batch.size == 0) {
       /* n != batch.size when isRepeating */
@@ -111,7 +112,7 @@ public void evaluate(VectorizedRowBatch batch) {
       case TIMESTAMP:
         if (inputCol.noNulls) {
           outV.noNulls = true;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.vector[i] = getTimestampField(inputCol.vector[i]);
@@ -125,7 +126,7 @@ public void evaluate(VectorizedRowBatch batch) {
           // Handle case with nulls. Don't do function if the value is null, to save time,
           // because calling the function can be expensive.
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = inputCol.isNull[i];
@@ -147,7 +148,7 @@ public void evaluate(VectorizedRowBatch batch) {
       case DATE:
         if (inputCol.noNulls) {
           outV.noNulls = true;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.vector[i] = getDateField(inputCol.vector[i]);
@@ -161,7 +162,7 @@ public void evaluate(VectorizedRowBatch batch) {
           // Handle case with nulls. Don't do function if the value is null, to save time,
           // because calling the function can be expensive.
           outV.noNulls = false;
-          if (batch.selectedInUse) {
+          if (selectedInUse) {
             for(int j=0; j < n; j++) {
               int i = sel[j];
               outV.isNull[i] = inputCol.isNull[i];
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFTimestampFieldString.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFTimestampFieldString.java
index af96988334..45e7a3197c 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFTimestampFieldString.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/vector/expressions/VectorUDFTimestampFieldString.java
@@ -87,6 +87,7 @@ public void evaluate(VectorizedRowBatch batch) {
 
     final int n = inputCol.isRepeating ? 1 : batch.size;
     int[] sel = batch.selected;
+    final boolean selectedInUse = (inputCol.isRepeating == false) && batch.selectedInUse;
 
     if (batch.size == 0) {
 
@@ -99,7 +100,7 @@ public void evaluate(VectorizedRowBatch batch) {
 
     if (inputCol.noNulls) {
       outV.noNulls = true;
-      if (batch.selectedInUse) {
+      if (selectedInUse) {
         for (int j = 0; j < n; j++) {
           int i = sel[j];
           try {
@@ -126,7 +127,7 @@ public void evaluate(VectorizedRowBatch batch) {
       // Handle case with nulls. Don't do function if the value is null, to save time,
       // because calling the function can be expensive.
       outV.noNulls = false;
-      if (batch.selectedInUse) {
+      if (selectedInUse) {
         for (int j = 0; j < n; j++) {
           int i = sel[j];
           outV.isNull[i] = inputCol.isNull[i];
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/exec/vector/expressions/TestVectorTimestampExpressions.java b/ql/src/test/org/apache/hadoop/hive/ql/exec/vector/expressions/TestVectorTimestampExpressions.java
index 419254b172..4a4ce27841 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/exec/vector/expressions/TestVectorTimestampExpressions.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/exec/vector/expressions/TestVectorTimestampExpressions.java
@@ -284,6 +284,15 @@ private void testVectorUDFYear(TestType testType) {
     batch.cols[0].isNull[0] = true;
     verifyUDFYear(batch, testType);
 
+    batch = getVectorizedRowBatch(new long[] {0}, 1, testType);
+    batch.cols[0].isRepeating = true;
+    batch.selectedInUse = true;
+    batch.selected = new int[] {42};
+    verifyUDFYear(batch, testType);
+    batch.cols[0].noNulls = false;
+    batch.cols[0].isNull[0] = true;
+    verifyUDFYear(batch, testType);
+
     batch = getVectorizedRandomRowBatch(200, VectorizedRowBatch.DEFAULT_SIZE, testType);
     verifyUDFYear(batch, testType);
     TestVectorizedRowBatch.addRandomNulls(batch.cols[0]);
@@ -367,6 +376,15 @@ private void testVectorUDFDayOfMonth(TestType testType) {
     batch.cols[0].isNull[0] = true;
     verifyUDFDayOfMonth(batch, testType);
 
+    batch = getVectorizedRowBatch(new long[] {0}, 1, testType);
+    batch.cols[0].isRepeating = true;
+    batch.selectedInUse = true;
+    batch.selected = new int[] {42};
+    verifyUDFDayOfMonth(batch, testType);
+    batch.cols[0].noNulls = false;
+    batch.cols[0].isNull[0] = true;
+    verifyUDFDayOfMonth(batch, testType);
+
     batch = getVectorizedRandomRowBatch(200, VectorizedRowBatch.DEFAULT_SIZE, testType);
     verifyUDFDayOfMonth(batch, testType);
     TestVectorizedRowBatch.addRandomNulls(batch.cols[0]);
@@ -443,6 +461,15 @@ private void testVectorUDFHour(TestType testType) {
     batch.cols[0].isNull[0] = true;
     verifyUDFHour(batch, testType);
 
+    batch = getVectorizedRowBatch(new long[] {0}, 1, testType);
+    batch.cols[0].isRepeating = true;
+    batch.selectedInUse = true;
+    batch.selected = new int[] {42};
+    verifyUDFHour(batch, testType);
+    batch.cols[0].noNulls = false;
+    batch.cols[0].isNull[0] = true;
+    verifyUDFHour(batch, testType);
+
     batch = getVectorizedRandomRowBatch(200, VectorizedRowBatch.DEFAULT_SIZE, testType);
     verifyUDFHour(batch, testType);
     TestVectorizedRowBatch.addRandomNulls(batch.cols[0]);
@@ -519,6 +546,15 @@ private void testVectorUDFMinute(TestType testType) {
     batch.cols[0].isNull[0] = true;
     verifyUDFMinute(batch, testType);
 
+    batch = getVectorizedRowBatch(new long[] {0}, 1, testType);
+    batch.cols[0].isRepeating = true;
+    batch.selectedInUse = true;
+    batch.selected = new int[] {42};
+    verifyUDFMinute(batch, testType);
+    batch.cols[0].noNulls = false;
+    batch.cols[0].isNull[0] = true;
+    verifyUDFMinute(batch, testType);
+
     batch = getVectorizedRandomRowBatch(200, VectorizedRowBatch.DEFAULT_SIZE, testType);
     verifyUDFMinute(batch, testType);
     TestVectorizedRowBatch.addRandomNulls(batch.cols[0]);
@@ -595,6 +631,15 @@ private void testVectorUDFMonth(TestType testType) {
     batch.cols[0].isNull[0] = true;
     verifyUDFMonth(batch, testType);
 
+    batch = getVectorizedRowBatch(new long[] {0}, 1, testType);
+    batch.cols[0].isRepeating = true;
+    batch.selectedInUse = true;
+    batch.selected = new int[] {42};
+    verifyUDFMonth(batch, testType);
+    batch.cols[0].noNulls = false;
+    batch.cols[0].isNull[0] = true;
+    verifyUDFMonth(batch, testType);
+
     batch = getVectorizedRandomRowBatch(200, VectorizedRowBatch.DEFAULT_SIZE, testType);
     verifyUDFMonth(batch, testType);
     TestVectorizedRowBatch.addRandomNulls(batch.cols[0]);
@@ -671,6 +716,15 @@ private void testVectorUDFSecond(TestType testType) {
     batch.cols[0].isNull[0] = true;
     verifyUDFSecond(batch, testType);
 
+    batch = getVectorizedRowBatch(new long[] {0}, 1, testType);
+    batch.cols[0].isRepeating = true;
+    batch.selectedInUse = true;
+    batch.selected = new int[] {42};
+    verifyUDFSecond(batch, testType);
+    batch.cols[0].noNulls = false;
+    batch.cols[0].isNull[0] = true;
+    verifyUDFSecond(batch, testType);
+
     batch = getVectorizedRandomRowBatch(200, VectorizedRowBatch.DEFAULT_SIZE, testType);
     verifyUDFSecond(batch, testType);
     TestVectorizedRowBatch.addRandomNulls(batch.cols[0]);
@@ -761,6 +815,15 @@ private void testVectorUDFUnixTimeStamp(TestType testType) {
     batch.cols[0].isNull[0] = true;
     verifyUDFUnixTimeStamp(batch, testType);
 
+    batch = getVectorizedRowBatch(new long[] {0}, 1, testType);
+    batch.cols[0].isRepeating = true;
+    batch.selectedInUse = true;
+    batch.selected = new int[] {42};
+    verifyUDFUnixTimeStamp(batch, testType);
+    batch.cols[0].noNulls = false;
+    batch.cols[0].isNull[0] = true;
+
+    verifyUDFUnixTimeStamp(batch, testType);
     batch = getVectorizedRandomRowBatch(200, VectorizedRowBatch.DEFAULT_SIZE, testType);
     verifyUDFUnixTimeStamp(batch, testType);
     TestVectorizedRowBatch.addRandomNulls(batch.cols[0]);
@@ -834,6 +897,15 @@ private void testVectorUDFWeekOfYear(TestType testType) {
     batch.cols[0].isNull[0] = true;
     verifyUDFWeekOfYear(batch, testType);
 
+    batch = getVectorizedRowBatch(new long[] {0}, 1, testType);
+    batch.cols[0].isRepeating = true;
+    batch.selectedInUse = true;
+    batch.selected = new int[] {42};
+    verifyUDFWeekOfYear(batch, testType);
+    batch.cols[0].noNulls = false;
+    batch.cols[0].isNull[0] = true;
+    verifyUDFWeekOfYear(batch, testType);
+
     batch = getVectorizedRandomRowBatch(200, VectorizedRowBatch.DEFAULT_SIZE, testType);
     verifyUDFWeekOfYear(batch, testType);
     TestVectorizedRowBatch.addRandomNulls(batch.cols[0]);
