diff --git a/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java b/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java
index fca3ac3b95..ed781f27a7 100644
--- a/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java
+++ b/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java
@@ -94,8 +94,6 @@ public class HiveConf extends Configuration {
       HiveConf.ConfVars.METASTOREPWD,
       HiveConf.ConfVars.METASTORECONNECTURLHOOK,
       HiveConf.ConfVars.METASTORECONNECTURLKEY,
-      HiveConf.ConfVars.METASTOREATTEMPTS,
-      HiveConf.ConfVars.METASTOREINTERVAL,
       HiveConf.ConfVars.METASTOREFORCERELOADCONF,
       HiveConf.ConfVars.METASTORESERVERMINTHREADS,
       HiveConf.ConfVars.METASTORESERVERMAXTHREADS,
@@ -273,10 +271,6 @@ public static enum ConfVars {
     // Name of the connection url in the configuration
     METASTORECONNECTURLKEY("javax.jdo.option.ConnectionURL",
         "jdbc:derby:;databaseName=metastore_db;create=true"),
-    // Number of attempts to retry connecting after there is a JDO datastore err
-    METASTOREATTEMPTS("hive.metastore.ds.retry.attempts", 1),
-    // Number of miliseconds to wait between attepting
-    METASTOREINTERVAL("hive.metastore.ds.retry.interval", 1000),
     // Whether to force reloading of the metastore configuration (including
     // the connection URL, before the next metastore query that accesses the
     // datastore. Once reloaded, this value is reset to false. Used for
@@ -1258,8 +1252,14 @@ private void initialize(Class<?> cls) {
 
     if(this.get("hive.metastore.local", null) != null) {
       l4j.warn("DEPRECATED: Configuration property hive.metastore.local no longer has any " +
-      		"effect. Make sure to provide a valid value for hive.metastore.uris if you are " +
-      		"connecting to a remote metastore.");
+          "effect. Make sure to provide a valid value for hive.metastore.uris if you are " +
+          "connecting to a remote metastore.");
+    }
+
+    if ((this.get("hive.metastore.ds.retry.attempts") != null) ||
+      this.get("hive.metastore.ds.retry.interval") != null) {
+        l4j.warn("DEPRECATED: hive.metastore.ds.retry.* no longer has any effect.  " +
+        "Use hive.hmshandler.retry.* instead");
     }
 
     // if the running class was loaded directly (through eclipse) rather than through a
diff --git a/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/TestHiveMetaStore.java b/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/TestHiveMetaStore.java
index d7854fef57..fcd73c7ada 100644
--- a/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/TestHiveMetaStore.java
+++ b/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/TestHiveMetaStore.java
@@ -2498,8 +2498,8 @@ public void testConcurrentMetastores() throws Exception {
    */
   private void updateTableNameInDB(String oldTableName, String newTableName) throws SQLException {
     String connectionStr = HiveConf.getVar(hiveConf, HiveConf.ConfVars.METASTORECONNECTURLKEY);
-    int interval= HiveConf.getIntVar(hiveConf, HiveConf.ConfVars.METASTOREINTERVAL);
-    int attempts = HiveConf.getIntVar(hiveConf, HiveConf.ConfVars.METASTOREATTEMPTS);
+    int interval= 1;
+    int attempts = 1;
 
 
     Utilities.SQLCommand<Void> execUpdate = new Utilities.SQLCommand<Void>() {
diff --git a/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/TestRawStoreTxn.java b/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/TestRawStoreTxn.java
deleted file mode 100644
index 0b87077d04..0000000000
--- a/itests/hive-unit/src/test/java/org/apache/hadoop/hive/metastore/TestRawStoreTxn.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.hadoop.hive.metastore;
-
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.List;
-
-import javax.jdo.JDOException;
-
-import junit.framework.TestCase;
-
-import org.apache.hadoop.conf.Configuration;
-import org.apache.hadoop.hive.conf.HiveConf;
-
-public class TestRawStoreTxn extends TestCase {
-
-  public static class DummyRawStoreWithCommitError extends DummyRawStoreForJdoConnection {
-    private static int callCount = 0;
-
-    @Override
-    /***
-     * Throw exception on first try
-     */
-    public boolean commitTransaction() {
-      callCount++;
-      if (callCount == 1 ) {
-        throw new JDOException ("Failed for call count " + callCount);
-      } else {
-        return true;
-      }
-    }
-  }
-
-  private ObjectStore objStore;
-  private HiveConf hiveConf;
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    hiveConf = new HiveConf();
-  }
-
-  @Override
-  protected void tearDown() throws Exception {
-    super.tearDown();
-  }
-
-  /***
-   * Check annotations of the restricted methods
-   * @throws Exception
-   */
-  public void testCheckNoRetryMethods() throws Exception {
-    List<String> nonExecMethods =
-      Arrays.asList("commitTransaction", "commitTransaction");
-
-    RawStore rawStore = RetryingRawStore.getProxy(hiveConf, new Configuration(hiveConf),
-          hiveConf.getVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL), 1);
-    for (Method rawStoreMethod : RawStore.class.getMethods()) {
-      if (nonExecMethods.contains(rawStoreMethod.getName())) {
-        assertNotNull(rawStoreMethod.getAnnotation(RawStore.CanNotRetry.class));
-      }
-    }
-  }
-
-  /***
-   * Invoke commit and verify it doesn't get retried
-   * @throws Exception
-   */
-  public void testVerifyNoRetryMethods() throws Exception {
-    hiveConf.setVar(HiveConf.ConfVars.METASTORECONNECTURLKEY,
-        DummyJdoConnectionUrlHook.newUrl);;
-    hiveConf.setVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL,
-        DummyRawStoreWithCommitError.class.getName());
-    RawStore rawStore = RetryingRawStore.getProxy(hiveConf, new Configuration(hiveConf),
-        DummyRawStoreWithCommitError.class.getName(), 1);
-    try {
-      rawStore.commitTransaction();
-      fail("Commit should fail due to no retry");
-    } catch (JDOException e) {
-      // Excepted JDOException
-    }
-  }
-
-}
diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStore.java b/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStore.java
index 4905be040e..a4f46b5280 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStore.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStore.java
@@ -441,7 +441,7 @@ private RawStore newRawStore() throws MetaException {
           + rawStoreClassName));
       Configuration conf = getConf();
 
-      return RetryingRawStore.getProxy(hiveConf, conf, rawStoreClassName, threadLocalId.get());
+      return RawStoreProxy.getProxy(hiveConf, conf, rawStoreClassName, threadLocalId.get());
     }
 
     private void createDefaultDB_core(RawStore ms) throws MetaException, InvalidObjectException {
diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java b/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
index 0715e22275..ff02b0d984 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
@@ -39,6 +39,7 @@
 import java.util.concurrent.locks.ReentrantLock;
 
 import javax.jdo.JDODataStoreException;
+import javax.jdo.JDOEnhanceException;
 import javax.jdo.JDOHelper;
 import javax.jdo.JDOObjectNotFoundException;
 import javax.jdo.PersistenceManager;
@@ -362,7 +363,10 @@ public boolean openTransaction() {
       // currentTransaction is not active
       assert ((currentTransaction != null) && (currentTransaction.isActive()));
     }
-    return currentTransaction.isActive();
+
+    boolean result = currentTransaction.isActive();
+    debugLog("Open transaction: count = " + openTrasactionCalls + ", isActive = " + result);
+    return result;
   }
 
   /**
@@ -374,23 +378,31 @@ public boolean openTransaction() {
   @SuppressWarnings("nls")
   public boolean commitTransaction() {
     if (TXN_STATUS.ROLLBACK == transactionStatus) {
+      debugLog("Commit transaction: rollback");
       return false;
     }
     if (openTrasactionCalls <= 0) {
-      throw new RuntimeException("commitTransaction was called but openTransactionCalls = "
+      RuntimeException e = new RuntimeException("commitTransaction was called but openTransactionCalls = "
           + openTrasactionCalls + ". This probably indicates that there are unbalanced " +
-              "calls to openTransaction/commitTransaction");
+          "calls to openTransaction/commitTransaction");
+      LOG.error(e);
+      throw e;
     }
     if (!currentTransaction.isActive()) {
-      throw new RuntimeException(
-          "Commit is called, but transaction is not active. Either there are"
-              + " mismatching open and close calls or rollback was called in the same trasaction");
+      RuntimeException e = new RuntimeException("commitTransaction was called but openTransactionCalls = "
+          + openTrasactionCalls + ". This probably indicates that there are unbalanced " +
+          "calls to openTransaction/commitTransaction");
+      LOG.error(e);
+      throw e;
     }
     openTrasactionCalls--;
+    debugLog("Commit transaction: count = " + openTrasactionCalls + ", isactive "+ currentTransaction.isActive());
+
     if ((openTrasactionCalls == 0) && currentTransaction.isActive()) {
       transactionStatus = TXN_STATUS.COMMITED;
       currentTransaction.commit();
     }
+
     return true;
   }
 
@@ -410,9 +422,11 @@ public boolean isActiveTransaction() {
    */
   public void rollbackTransaction() {
     if (openTrasactionCalls < 1) {
+      debugLog("rolling back transaction: no open transactions: " + openTrasactionCalls);
       return;
     }
     openTrasactionCalls = 0;
+    debugLog("Rollback transaction, isActive: " + currentTransaction.isActive());
     if (currentTransaction.isActive()
         && transactionStatus != TXN_STATUS.ROLLBACK) {
       transactionStatus = TXN_STATUS.ROLLBACK;
@@ -6151,27 +6165,24 @@ public boolean doesPartitionExist(String dbName, String tableName, List<String>
     }
   }
 
-  /** Add this to code to debug lexer if needed. DebugTokenStream may also be added here. */
-  private void debugLexer(CommonTokenStream stream, FilterLexer lexer) {
-    try {
-      stream.fill();
-      List<?> tokens = stream.getTokens();
-      String report = "LEXER: tokens (" + ((tokens == null) ? "null" : tokens.size()) + "): ";
-      if (tokens != null) {
-        for (Object o : tokens) {
-          if (o == null || !(o instanceof Token)) {
-            report += "[not a token: " + o + "], ";
-          } else {
-            Token t = (Token)o;
-            report += "[at " + t.getCharPositionInLine() + ": "
-                + t.getType() + " " + t.getText() + "], ";
-          }
-        }
-      }
-      report += "; lexer error: " + lexer.errorMsg;
-      LOG.error(report);
-    } catch (Throwable t) {
-      LOG.error("LEXER: tokens (error)", t);
+
+  private void debugLog(String message) {
+    if (LOG.isDebugEnabled()) {
+      LOG.debug(message + getCallStack());
+    }
+  }
+
+  private static final int stackLimit = 5;
+
+  private String getCallStack() {
+    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
+    int thislimit = Math.min(stackLimit, stackTrace.length);
+    StringBuilder sb = new StringBuilder();
+    sb.append(" at:");
+    for (int i = 4; i < thislimit; i++) {
+      sb.append("\n\t");
+      sb.append(stackTrace[i].toString());
     }
+    return sb.toString();
   }
 }
diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/RetryingRawStore.java b/metastore/src/java/org/apache/hadoop/hive/metastore/RawStoreProxy.java
similarity index 62%
rename from metastore/src/java/org/apache/hadoop/hive/metastore/RetryingRawStore.java
rename to metastore/src/java/org/apache/hadoop/hive/metastore/RawStoreProxy.java
index dcf97eca87..1cf09d483b 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/RetryingRawStore.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/RawStoreProxy.java
@@ -37,20 +37,16 @@
 
 @InterfaceAudience.Private
 @InterfaceStability.Evolving
-public class RetryingRawStore implements InvocationHandler {
-
-  private static final Log LOG = LogFactory.getLog(RetryingRawStore.class);
+public class RawStoreProxy implements InvocationHandler {
 
   private final RawStore base;
-  private int retryInterval = 0;
-  private int retryLimit = 0;
   private final MetaStoreInit.MetaStoreInitData metaStoreInitData =
     new MetaStoreInit.MetaStoreInitData();
   private final int id;
   private final HiveConf hiveConf;
   private final Configuration conf; // thread local conf from HMS
 
-  protected RetryingRawStore(HiveConf hiveConf, Configuration conf,
+  protected RawStoreProxy(HiveConf hiveConf, Configuration conf,
       Class<? extends RawStore> rawStoreClass, int id) throws MetaException {
     this.conf = conf;
     this.hiveConf = hiveConf;
@@ -68,10 +64,10 @@ public static RawStore getProxy(HiveConf hiveConf, Configuration conf, String ra
     Class<? extends RawStore> baseClass = (Class<? extends RawStore>) MetaStoreUtils.getClass(
         rawStoreClassName);
 
-    RetryingRawStore handler = new RetryingRawStore(hiveConf, conf, baseClass, id);
+    RawStoreProxy handler = new RawStoreProxy(hiveConf, conf, baseClass, id);
 
     // Look for interfaces on both the class and all base classes.
-    return (RawStore) Proxy.newProxyInstance(RetryingRawStore.class.getClassLoader(),
+    return (RawStore) Proxy.newProxyInstance(RawStoreProxy.class.getClassLoader(),
         getAllInterfaces(baseClass), handler);
   }
 
@@ -86,10 +82,6 @@ private static Class<?>[] getAllInterfaces(Class<?> baseClass) {
   }
 
   private void init() throws MetaException {
-    retryInterval = HiveConf.getIntVar(hiveConf,
-        HiveConf.ConfVars.METASTOREINTERVAL);
-    retryLimit = HiveConf.getIntVar(hiveConf,
-        HiveConf.ConfVars.METASTOREATTEMPTS);
     // Using the hook on startup ensures that the hook always has priority
     // over settings in *.xml.  The thread local conf needs to be used because at this point
     // it has already been initialized using hiveConf.
@@ -104,62 +96,24 @@ private void initMS() {
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
     Object ret = null;
 
-    boolean gotNewConnectUrl = false;
     boolean reloadConf = HiveConf.getBoolVar(hiveConf,
         HiveConf.ConfVars.METASTOREFORCERELOADCONF);
 
     if (reloadConf) {
       MetaStoreInit.updateConnectionURL(hiveConf, getConf(), null, metaStoreInitData);
+      initMS();
     }
 
-    int retryCount = 0;
-    Exception caughtException = null;
-    while (true) {
-      try {
-        if (reloadConf || gotNewConnectUrl) {
-          initMS();
-        }
-        ret = method.invoke(base, args);
-        break;
-      } catch (javax.jdo.JDOException e) {
-        caughtException = e;
-      } catch (UndeclaredThrowableException e) {
-        throw e.getCause();
-      } catch (InvocationTargetException e) {
-        if (e.getCause() instanceof javax.jdo.JDOException) {
-          // Due to reflection, the jdo exception is wrapped in
-          // invocationTargetException
-          caughtException = (javax.jdo.JDOException) e.getCause();
-        } else {
-          throw e.getCause();
-        }
-      }
-
-      if (retryCount >= retryLimit ||
-          (method.getAnnotation(RawStore.CanNotRetry.class) != null)) {
-        throw  caughtException;
-      }
-
-      assert (retryInterval >= 0);
-      retryCount++;
-      LOG.error(
-          String.format(
-              "JDO datastore error. Retrying metastore command " +
-                  "after %d ms (attempt %d of %d)", retryInterval, retryCount, retryLimit));
-      Thread.sleep(retryInterval);
-      // If we have a connection error, the JDO connection URL hook might
-      // provide us with a new URL to access the datastore.
-      String lastUrl = MetaStoreInit.getConnectionURL(getConf());
-      gotNewConnectUrl = MetaStoreInit.updateConnectionURL(hiveConf, getConf(),
-        lastUrl, metaStoreInitData);
+    try {
+      ret = method.invoke(base, args);
+    } catch (UndeclaredThrowableException e) {
+      throw e.getCause();
+    } catch (InvocationTargetException e) {
+      throw e.getCause();
     }
     return ret;
   }
 
-  private String addPrefix(String s) {
-    return id + ": " + s;
-  }
-
   public Configuration getConf() {
     return conf;
   }
diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/RetryingHMSHandler.java b/metastore/src/java/org/apache/hadoop/hive/metastore/RetryingHMSHandler.java
index fb70589c5e..204c9301ac 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/RetryingHMSHandler.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/RetryingHMSHandler.java
@@ -45,13 +45,13 @@ public class RetryingHMSHandler implements InvocationHandler {
     new MetaStoreInit.MetaStoreInitData();
   private final HiveConf hiveConf;
 
-  protected RetryingHMSHandler(HiveConf hiveConf, String name) throws MetaException {
+  protected RetryingHMSHandler(final HiveConf hiveConf, final String name) throws MetaException {
     this.hiveConf = hiveConf;
 
     // This has to be called before initializing the instance of HMSHandler
     init();
 
-    this.base = (IHMSHandler) new HiveMetaStore.HMSHandler(name, hiveConf);
+    this.base = new HiveMetaStore.HMSHandler(name, hiveConf);
   }
 
   public static IHMSHandler getProxy(HiveConf hiveConf, String name) throws MetaException {
@@ -75,8 +75,10 @@ private void initMS() {
     base.setConf(getConf());
   }
 
+
   @Override
-  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+  public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {
+
     Object ret = null;
 
     boolean gotNewConnectUrl = false;
@@ -144,7 +146,7 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
       }
 
       if (retryCount >= retryLimit) {
-        LOG.error(ExceptionUtils.getStackTrace(caughtException));
+        LOG.error("HMSHandler Fatal error: " + ExceptionUtils.getStackTrace(caughtException));
         // Since returning exceptions with a nested "cause" can be a problem in
         // Thrift, we are stuffing the stack trace into the message itself.
         throw new MetaException(ExceptionUtils.getStackTrace(caughtException));
@@ -153,9 +155,10 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
       assert (retryInterval >= 0);
       retryCount++;
       LOG.error(
-          String.format(
-              "JDO datastore error. Retrying HMSHandler " +
-                  "after %d ms (attempt %d of %d)", retryInterval, retryCount, retryLimit));
+        String.format(
+          "Retrying HMSHandler after %d ms (attempt %d of %d)", retryInterval, retryCount, retryLimit) +
+          " with error: " + ExceptionUtils.getStackTrace(caughtException));
+
       Thread.sleep(retryInterval);
       // If we have a connection error, the JDO connection URL hook might
       // provide us with a new URL to access the datastore.
