diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java
index 25132a1d13..1226cd1a1a 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveAlterHandler.java
@@ -235,6 +235,10 @@ public void alterTable(RawStore msdb, Warehouse wh, String catName, String dbnam
 
       boolean renamedTranslatedToExternalTable = rename && MetaStoreUtils.isTranslatedToExternalTable(oldt)
           && MetaStoreUtils.isTranslatedToExternalTable(newt);
+
+      List<ColumnStatistics> columnStatistics = getColumnStats(msdb, oldt);
+      columnStatistics = deleteTableColumnStats(msdb, oldt, newt, columnStatistics);
+
       if (replDataLocationChanged
           || renamedManagedTable || renamedTranslatedToExternalTable) {
         srcPath = new Path(oldt.getSd().getLocation());
@@ -368,8 +372,7 @@ public void alterTable(RawStore msdb, Warehouse wh, String catName, String dbnam
                 writeIdList, newt.getWriteId());
           }
         } else {
-          alterTableUpdateTableColumnStats(
-              msdb, oldt, newt, environmentContext, writeIdList, conf, null);
+          msdb.alterTable(catName, dbname, name, newt, writeIdList);
         }
       } else {
         // operations other than table rename
@@ -420,15 +423,16 @@ public void alterTable(RawStore msdb, Warehouse wh, String catName, String dbnam
             msdb.alterTable(catName, dbname, name, newt, null);
           } else {
             LOG.warn("Alter table not cascaded to partitions.");
-            alterTableUpdateTableColumnStats(
-                msdb, oldt, newt, environmentContext, writeIdList, conf, null);
+            msdb.alterTable(catName, dbname, name, newt, writeIdList);
           }
         } else {
-          alterTableUpdateTableColumnStats(
-              msdb, oldt, newt, environmentContext, writeIdList, conf, null);
+          msdb.alterTable(catName, dbname, name, newt, writeIdList);
         }
       }
 
+      //HIVE-26504: Table columns stats may exist even for partitioned tables, so it must be updated in all cases
+      updateTableColumnStats(msdb, newt, writeIdList, columnStatistics);
+
       if (transactionalListeners != null && !transactionalListeners.isEmpty()) {
         txnAlterTableEventResponses = MetaStoreListenerNotifier.notifyEvent(transactionalListeners,
                   EventMessage.EventType.ALTER_TABLE,
@@ -1011,96 +1015,61 @@ private Path constructRenamedPath(Path defaultNewPath, Path currentPath) {
         defaultNewPath.toUri().getPath());
   }
 
-  @VisibleForTesting
-  public static List<ColumnStatistics> alterTableUpdateTableColumnStats(RawStore msdb, Table oldTable, Table newTable,
-      EnvironmentContext ec, String validWriteIds, Configuration conf, List<String> deletedCols)
-      throws MetaException, InvalidObjectException {
-    String catName = normalizeIdentifier(oldTable.isSetCatName() ? oldTable.getCatName() :
-        getDefaultCatalog(conf));
+  public static List<ColumnStatistics> getColumnStats(RawStore msdb, Table oldTable)
+      throws NoSuchObjectException, MetaException {
+    String catName = normalizeIdentifier(oldTable.isSetCatName()
+        ? oldTable.getCatName()
+        : getDefaultCatalog(msdb.getConf()));
     String dbName = oldTable.getDbName().toLowerCase();
     String tableName = normalizeIdentifier(oldTable.getTableName());
-    String newDbName = newTable.getDbName().toLowerCase();
-    String newTableName = normalizeIdentifier(newTable.getTableName());
-    //if its not called from cahced store then update the table
-    boolean doAlterTable = deletedCols == null;
-    List<ColumnStatistics> newMultiColStats = new ArrayList<>();
+    List<String> columnNames = oldTable.getSd().getCols().stream().map(FieldSchema::getName).collect(Collectors.toList());
+    return msdb.getTableColumnStatistics(catName, dbName, tableName, columnNames);
+  }
 
+  @VisibleForTesting
+  public static List<ColumnStatistics> deleteTableColumnStats(RawStore msdb, Table oldTable, Table newTable, List<ColumnStatistics> multiColStats)
+      throws InvalidObjectException, MetaException {
+    List<ColumnStatistics> newMultiColStats = new ArrayList<>();
     try {
-      List<FieldSchema> oldCols = oldTable.getSd().getCols();
-      List<FieldSchema> newCols = newTable.getSd().getCols();
-      List<ColumnStatistics> multiColStats = null;
-      boolean updateColumnStats = !newDbName.equals(dbName) || !newTableName.equals(tableName)
-          || !MetaStoreServerUtils.columnsIncludedByNameType(oldCols, newCols);
-      // Don't bother in the case of ACID conversion.
-      updateColumnStats = updateColumnStats
-          && (TxnUtils.isAcidTable(oldTable) == TxnUtils.isAcidTable(newTable));
-      if (updateColumnStats) {
-        List<String> oldColNames = new ArrayList<>(oldCols.size());
-        for (FieldSchema oldCol : oldCols) {
-          oldColNames.add(oldCol.getName());
-        }
+      String catName = normalizeIdentifier(oldTable.isSetCatName()
+          ? oldTable.getCatName()
+          : getDefaultCatalog(msdb.getConf()));
+      String dbName = oldTable.getDbName().toLowerCase();
+      String tableName = normalizeIdentifier(oldTable.getTableName());
+      String newDbName = newTable.getDbName().toLowerCase();
+      String newTableName = normalizeIdentifier(newTable.getTableName());
+      List<FieldSchema> oldTableCols = oldTable.getSd().getCols();
+      List<FieldSchema> newTableCols = newTable.getSd().getCols();
+
+      boolean nameChanged = !newDbName.equals(dbName) || !newTableName.equals(tableName);
+
+      if ((nameChanged || !MetaStoreServerUtils.columnsIncludedByNameType(oldTableCols, newTableCols)) &&
+          // Don't bother in the case of ACID conversion.
+          TxnUtils.isAcidTable(oldTable) == TxnUtils.isAcidTable(newTable)) {
+        for (ColumnStatistics colStats : multiColStats) {
+          List<ColumnStatisticsObj> statsObjs = colStats.getStatsObj();
+          List<ColumnStatisticsObj> newStatsObjs = new ArrayList<>();
 
-        // NOTE: this doesn't check stats being compliant, but the alterTable call below does.
-        //       The worst we can do is delete the stats.
-        // Collect column stats which need to be rewritten and remove old stats.
-        multiColStats = msdb.getTableColumnStatistics(catName, dbName, tableName, oldColNames);
-        if (multiColStats.isEmpty()) {
-          updateColumnStats = false;
-        } else {
-          for (ColumnStatistics colStats : multiColStats) {
-            List<ColumnStatisticsObj> statsObjs = colStats.getStatsObj();
-            if (statsObjs != null) {
-              // for out para, this value is initialized by caller.
-              if (deletedCols == null) {
-                deletedCols = new ArrayList<>();
+          if (statsObjs != null) {
+            for (ColumnStatisticsObj statsObj : statsObjs) {
+              boolean found = newTableCols.stream().anyMatch(c -> statsObj.getColName().equalsIgnoreCase(c.getName()) &&
+                  statsObj.getColType().equalsIgnoreCase(c.getType()));
+              if (nameChanged || !found) {
+                msdb.deleteTableColumnStatistics(catName, oldTable.getDbName().toLowerCase(),
+                    normalizeIdentifier(oldTable.getTableName()), statsObj.getColName(), colStats.getEngine());
               }
-              List<ColumnStatisticsObj> newStatsObjs = new ArrayList<>();
-              for (ColumnStatisticsObj statsObj : statsObjs) {
-                boolean found = false;
-                for (FieldSchema newCol : newCols) {
-                  if (statsObj.getColName().equalsIgnoreCase(newCol.getName())
-                      && statsObj.getColType().equalsIgnoreCase(newCol.getType())) {
-                    found = true;
-                    break;
-                  }
-                }
-
-                if (found) {
-                  if (!newDbName.equals(dbName) || !newTableName.equals(tableName)) {
-                    if (doAlterTable) {
-                      msdb.deleteTableColumnStatistics(catName, dbName, tableName, statsObj.getColName(), colStats.getEngine());
-                    }
-                    newStatsObjs.add(statsObj);
-                    deletedCols.add(statsObj.getColName());
-                  }
-                } else {
-                  if (doAlterTable) {
-                    msdb.deleteTableColumnStatistics(catName, dbName, tableName, statsObj.getColName(), colStats.getEngine());
-                  }
-                  deletedCols.add(statsObj.getColName());
-                }
-              }
-              if (doAlterTable) {
-                StatsSetupConst.removeColumnStatsState(newTable.getParameters(), deletedCols);
-                // Change stats
-                ColumnStatisticsDesc statsDesc = colStats.getStatsDesc();
-                statsDesc.setDbName(newDbName);
-                statsDesc.setTableName(newTableName);
-                colStats.setStatsObj(newStatsObjs);
-                newMultiColStats.add(colStats);
+              if (found) {
+                newStatsObjs.add(statsObj);
               }
             }
+            StatsSetupConst.removeColumnStatsState(newTable.getParameters(),
+                statsObjs.stream().map(ColumnStatisticsObj::getColName).collect(Collectors.toList()));
           }
-        }
-      }
-      if (doAlterTable) {
-        Deadline.checkTimeout();
-        // Change to new table and append stats for the new table
-        msdb.alterTable(catName, dbName, tableName, newTable, validWriteIds);
-        if (updateColumnStats) {
-          for (ColumnStatistics colStats : newMultiColStats) {
-            msdb.updateTableColumnStatistics(colStats, validWriteIds, newTable.getWriteId());
-          }
+          ColumnStatisticsDesc statsDesc = colStats.getStatsDesc();
+          statsDesc.setDbName(newDbName);
+          statsDesc.setTableName(newTableName);
+          colStats.setStatsObj(newStatsObjs);
+          newMultiColStats.add(colStats);
         }
       }
     } catch (NoSuchObjectException nsoe) {
@@ -1112,6 +1081,32 @@ public static List<ColumnStatistics> alterTableUpdateTableColumnStats(RawStore m
     return newMultiColStats;
   }
 
+  @VisibleForTesting
+  public void updateTableColumnStats(RawStore msdb, Table newTable, String validWriteIds, List<ColumnStatistics> columnStatistics)
+      throws MetaException, InvalidObjectException {
+    Deadline.checkTimeout();
+    // Change to new table and append stats for the new table
+    for (ColumnStatistics colStats : columnStatistics) {
+      try {
+        msdb.updateTableColumnStatistics(colStats, validWriteIds, newTable.getWriteId());
+      } catch (NoSuchObjectException nsoe) {
+        LOG.debug("Could not find db entry." + nsoe);
+      } catch (InvalidInputException e) {
+        //should not happen since the input were verified before passed in
+        throw new InvalidObjectException("Invalid inputs to update table column stats: " + e);
+      }
+    }
+  }
+
+  public static List<ColumnStatisticsObj> filterColumnStatsForTableColumns(List<FieldSchema> columns, ColumnStatistics colStats) {
+    return colStats.getStatsObj()
+        .stream()
+        .filter(o -> columns
+            .stream()
+            .anyMatch(column -> o.getColName().equalsIgnoreCase(column.getName()) && o.getColType().equalsIgnoreCase(column.getType())))
+        .collect(Collectors.toList());
+  }
+
   public static List<ColumnStatistics> updateOrGetPartitionColumnStats(
       RawStore msdb, String catName, String dbname, String tblname, List<String> partVals,
       List<FieldSchema> oldCols, Table table, Partition part, List<FieldSchema> newCols, List<String> deletedCols)
diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/cache/CachedStore.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/cache/CachedStore.java
index c04230c8e1..b11665c654 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/cache/CachedStore.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/cache/CachedStore.java
@@ -23,9 +23,11 @@
 import java.util.Collection;
 import java.util.EmptyStackException;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.Stack;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
@@ -34,6 +36,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 
 import org.apache.commons.collections.CollectionUtils;
 import org.apache.commons.lang3.exception.ExceptionUtils;
@@ -226,7 +229,6 @@ private static ColumnStatistics updateStatsForAlterPart(RawStore rawStore, Table
   private static void updateStatsForAlterTable(RawStore rawStore, Table tblBefore, Table tblAfter, String catalogName,
       String dbName, String tableName) throws Exception {
     ColumnStatistics colStats = null;
-    List<String> deletedCols = new ArrayList<>();
     if (tblBefore.isSetPartitionKeys()) {
       List<Partition> parts = sharedCache.listCachedPartitions(catalogName, dbName, tableName, -1);
       for (Partition part : parts) {
@@ -234,8 +236,14 @@ private static void updateStatsForAlterTable(RawStore rawStore, Table tblBefore,
       }
     }
 
-    List<ColumnStatistics> multiColumnStats = HiveAlterHandler
-        .alterTableUpdateTableColumnStats(rawStore, tblBefore, tblAfter, null, null, rawStore.getConf(), deletedCols);
+    rawStore.alterTable(catalogName, dbName, tblBefore.getTableName(), tblAfter, null);
+
+    Set<String> deletedCols = new HashSet<>();
+    List<ColumnStatistics> multiColumnStats = HiveAlterHandler.getColumnStats(rawStore, tblBefore);
+    multiColumnStats.forEach(cs ->
+      deletedCols.addAll(HiveAlterHandler.filterColumnStatsForTableColumns(tblBefore.getSd().getCols(), cs)
+          .stream().map(ColumnStatisticsObj::getColName).collect(Collectors.toList())));
+
     if (multiColumnStats.size() > 1) {
       throw new RuntimeException("CachedStore can only be enabled for Hive engine");
     }
diff --git a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestHiveAlterHandler.java b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestHiveAlterHandler.java
index 379dc98631..4d92c5c7fc 100644
--- a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestHiveAlterHandler.java
+++ b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/TestHiveAlterHandler.java
@@ -22,12 +22,12 @@
 import org.apache.hadoop.hive.metastore.annotation.MetastoreUnitTest;
 import org.apache.hadoop.hive.metastore.api.*;
 import org.apache.hadoop.hive.metastore.conf.MetastoreConf;
-import org.apache.hadoop.hive.metastore.utils.MetaStoreUtils;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 import org.mockito.Mockito;
 
 import java.util.Arrays;
+import java.util.List;
 
 import static org.apache.hadoop.hive.metastore.utils.MetaStoreUtils.getDefaultCatalog;
 
@@ -37,7 +37,7 @@ public class TestHiveAlterHandler {
   private Configuration conf = MetastoreConf.newMetastoreConf();
 
   @Test
-  public void testAlterTableAddColNotUpdateStats() throws MetaException, InvalidObjectException, NoSuchObjectException {
+  public void testAlterTableAddColNotUpdateStats() throws MetaException, InvalidObjectException, NoSuchObjectException, InvalidInputException {
     FieldSchema col1 = new FieldSchema("col1", "string", "col1 comment");
     FieldSchema col2 = new FieldSchema("col2", "string", "col2 comment");
     FieldSchema col3 = new FieldSchema("col3", "string", "col3 comment");
@@ -56,13 +56,14 @@ public void testAlterTableAddColNotUpdateStats() throws MetaException, InvalidOb
     newTable.setSd(newSd);
 
     RawStore msdb = Mockito.mock(RawStore.class);
-    Mockito.doThrow(new RuntimeException("shouldn't be called")).when(msdb).getTableColumnStatistics(
-        getDefaultCatalog(conf), oldTable.getDbName(), oldTable.getTableName(), Arrays.asList("col1", "col2", "col3"));
+    Mockito.doThrow(new RuntimeException("shouldn't be called")).when(msdb).updateTableColumnStatistics(
+        Mockito.any(), Mockito.eq(null), Mockito.anyLong());
     HiveAlterHandler handler = new HiveAlterHandler();
     handler.setConf(conf);
     Deadline.registerIfNot(100_000);
-    Deadline.startTimer("alterTableUpdateTableColumnStats");
-    handler.alterTableUpdateTableColumnStats(msdb, oldTable, newTable, null, null, conf, null);
+    Deadline.startTimer("updateTableColumnStats");
+    List<ColumnStatistics> colstats = handler.deleteTableColumnStats(msdb, oldTable, newTable, handler.getColumnStats(msdb, oldTable));
+    handler.updateTableColumnStats(msdb, newTable, null, colstats);
   }
 
   @Test
@@ -88,9 +89,10 @@ public void testAlterTableDelColUpdateStats() throws Exception {
     HiveAlterHandler handler = new HiveAlterHandler();
     handler.setConf(conf);
     Deadline.registerIfNot(100_000);
-    Deadline.startTimer("alterTableUpdateTableColumnStats");
+    Deadline.startTimer("updateTableColumnStats");
     try {
-      handler.alterTableUpdateTableColumnStats(msdb, oldTable, newTable, null, null, conf, null);
+      List<ColumnStatistics> colstats = handler.deleteTableColumnStats(msdb, oldTable, newTable, handler.getColumnStats(msdb, oldTable));
+      handler.updateTableColumnStats(msdb, newTable, null, colstats);
     } catch (Throwable t) {
       System.err.println(t);
       t.printStackTrace(System.err);
@@ -102,7 +104,7 @@ public void testAlterTableDelColUpdateStats() throws Exception {
   }
 
   @Test
-  public void testAlterTableChangePosNotUpdateStats() throws MetaException, InvalidObjectException, NoSuchObjectException {
+  public void testAlterTableChangePosNotUpdateStats() throws MetaException, InvalidObjectException, NoSuchObjectException, InvalidInputException {
     FieldSchema col1 = new FieldSchema("col1", "string", "col1 comment");
     FieldSchema col2 = new FieldSchema("col2", "string", "col2 comment");
     FieldSchema col3 = new FieldSchema("col3", "string", "col3 comment");
@@ -121,13 +123,14 @@ public void testAlterTableChangePosNotUpdateStats() throws MetaException, Invali
     newTable.setSd(newSd);
 
     RawStore msdb = Mockito.mock(RawStore.class);
-    Mockito.doThrow(new RuntimeException("shouldn't be called")).when(msdb).getTableColumnStatistics(
-        getDefaultCatalog(conf), oldTable.getDbName(), oldTable.getTableName(), Arrays.asList("col1", "col2", "col3", "col4"));
+    Mockito.doThrow(new RuntimeException("shouldn't be called")).when(msdb).updateTableColumnStatistics(
+        Mockito.any(), Mockito.eq(null), Mockito.anyLong());
     HiveAlterHandler handler = new HiveAlterHandler();
     handler.setConf(conf);
     Deadline.registerIfNot(100_000);
-    Deadline.startTimer("alterTableUpdateTableColumnStats");
-    handler.alterTableUpdateTableColumnStats(msdb, oldTable, newTable, null, null, conf, null);
+    Deadline.startTimer("updateTableColumnStats");
+    List<ColumnStatistics> colstats = handler.deleteTableColumnStats(msdb, oldTable, newTable, handler.getColumnStats(msdb, oldTable));
+    handler.updateTableColumnStats(msdb, newTable, null, colstats);
   }
 
 }
