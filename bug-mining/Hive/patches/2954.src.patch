diff --git a/common/src/java/org/apache/hive/common/util/HiveStringUtils.java b/common/src/java/org/apache/hive/common/util/HiveStringUtils.java
index 2705f1e2e7..78cd983d6c 100644
--- a/common/src/java/org/apache/hive/common/util/HiveStringUtils.java
+++ b/common/src/java/org/apache/hive/common/util/HiveStringUtils.java
@@ -882,4 +882,8 @@ public static int getTextUtfLength(Text t) {
     }
     return len;
   }
+
+  public static String normalizeIdentifier(String identifier) {
+	  return identifier.trim().toLowerCase();
+	}
 }
diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java b/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
index 1b14fb113e..480ee23623 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/ObjectStore.java
@@ -137,6 +137,7 @@
 import org.apache.hadoop.hive.shims.ShimLoader;
 import org.apache.hadoop.hive.metastore.partition.spec.PartitionSpecProxy;
 import org.apache.hadoop.util.StringUtils;
+import org.apache.hive.common.util.HiveStringUtils;
 import org.apache.thrift.TException;
 import org.datanucleus.store.rdbms.exceptions.MissingTableException;
 
@@ -506,7 +507,7 @@ private MDatabase getMDatabase(String name) throws NoSuchObjectException {
     boolean commited = false;
     try {
       openTransaction();
-      name = name.toLowerCase().trim();
+      name = HiveStringUtils.normalizeIdentifier(name);
       Query query = pm.newQuery(MDatabase.class, "name == dbname");
       query.declareParameters("java.lang.String dbname");
       query.setUnique(true);
@@ -618,7 +619,7 @@ public boolean alterDatabase(String dbName, Database db)
   public boolean dropDatabase(String dbname) throws NoSuchObjectException, MetaException {
     boolean success = false;
     LOG.info("Dropping database " + dbname + " along with all tables");
-    dbname = dbname.toLowerCase();
+    dbname = HiveStringUtils.normalizeIdentifier(dbname);
     try {
       openTransaction();
 
@@ -915,7 +916,7 @@ public List<String> getTables(String dbName, String pattern)
     List<String> tbls = null;
     try {
       openTransaction();
-      dbName = dbName.toLowerCase().trim();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
       // Take the pattern and split it on the | to get all the composing
       // patterns
       String[] subpatterns = pattern.trim().split("\\|");
@@ -961,8 +962,8 @@ private MTable getMTable(String db, String table) {
     boolean commited = false;
     try {
       openTransaction();
-      db = db.toLowerCase().trim();
-      table = table.toLowerCase().trim();
+      db = HiveStringUtils.normalizeIdentifier(db);
+      table = HiveStringUtils.normalizeIdentifier(table);
       Query query = pm.newQuery(MTable.class, "tableName == table && database.name == db");
       query.declareParameters("java.lang.String table, java.lang.String db");
       query.setUnique(true);
@@ -985,7 +986,7 @@ public List<Table> getTableObjectsByName(String db, List<String> tbl_names)
     try {
       openTransaction();
 
-      db = db.toLowerCase().trim();
+      db = HiveStringUtils.normalizeIdentifier(db);
       Query dbExistsQuery = pm.newQuery(MDatabase.class, "name == db");
       dbExistsQuery.declareParameters("java.lang.String db");
       dbExistsQuery.setUnique(true);
@@ -997,7 +998,7 @@ public List<Table> getTableObjectsByName(String db, List<String> tbl_names)
 
       List<String> lowered_tbl_names = new ArrayList<String>();
       for (String t : tbl_names) {
-        lowered_tbl_names.add(t.toLowerCase().trim());
+        lowered_tbl_names.add(HiveStringUtils.normalizeIdentifier(t));
       }
       Query query = pm.newQuery(MTable.class);
       query.setFilter("database.name == db && tbl_names.contains(tableName)");
@@ -1077,7 +1078,7 @@ private MTable convertToMTable(Table tbl) throws InvalidObjectException,
     }
 
     // A new table is always created with a new column descriptor
-    return new MTable(tbl.getTableName().toLowerCase(), mdb,
+    return new MTable(HiveStringUtils.normalizeIdentifier(tbl.getTableName()), mdb,
         convertToMStorageDescriptor(tbl.getSd()), tbl.getOwner(), tbl
             .getCreateTime(), tbl.getLastAccessTime(), tbl.getRetention(),
         convertToMFieldSchemas(tbl.getPartitionKeys()), tbl.getParameters(),
@@ -1090,7 +1091,7 @@ private List<MFieldSchema> convertToMFieldSchemas(List<FieldSchema> keys) {
     if (keys != null) {
       mkeys = new ArrayList<MFieldSchema>(keys.size());
       for (FieldSchema part : keys) {
-        mkeys.add(new MFieldSchema(part.getName().toLowerCase(),
+        mkeys.add(new MFieldSchema(HiveStringUtils.normalizeIdentifier(part.getName()),
             part.getType(), part.getComment()));
       }
     }
@@ -1114,7 +1115,7 @@ private List<MOrder> convertToMOrders(List<Order> keys) {
     if (keys != null) {
       mkeys = new ArrayList<MOrder>(keys.size());
       for (Order part : keys) {
-        mkeys.add(new MOrder(part.getCol().toLowerCase(), part.getOrder()));
+        mkeys.add(new MOrder(HiveStringUtils.normalizeIdentifier(part.getCol()), part.getOrder()));
       }
     }
     return mkeys;
@@ -1489,8 +1490,8 @@ private MPartition getMPartition(String dbName, String tableName,
     boolean commited = false;
     try {
       openTransaction();
-      dbName = dbName.toLowerCase().trim();
-      tableName = tableName.toLowerCase().trim();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
+      tableName = HiveStringUtils.normalizeIdentifier(tableName);
       MTable mtbl = getMTable(dbName, tableName);
       if (mtbl == null) {
         commited = commitTransaction();
@@ -1823,8 +1824,8 @@ public List<String> listPartitionNames(String dbName, String tableName,
 
   private List<String> getPartitionNamesNoTxn(String dbName, String tableName, short max) {
     List<String> pns = new ArrayList<String>();
-    dbName = dbName.toLowerCase().trim();
-    tableName = tableName.toLowerCase().trim();
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
     Query q = pm.newQuery(
         "select partitionName from org.apache.hadoop.hive.metastore.model.MPartition "
         + "where table.database.name == t1 && table.tableName == t2 "
@@ -1860,8 +1861,8 @@ private List<String> getPartitionNamesNoTxn(String dbName, String tableName, sho
   private Collection getPartitionPsQueryResults(String dbName, String tableName,
       List<String> part_vals, short max_parts, String resultsCol)
       throws MetaException, NoSuchObjectException {
-    dbName = dbName.toLowerCase().trim();
-    tableName = tableName.toLowerCase().trim();
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
     Table table = getTable(dbName, tableName);
 
     if (table == null) {
@@ -1970,8 +1971,8 @@ private List<MPartition> listMPartitions(String dbName, String tableName,
     try {
       openTransaction();
       LOG.debug("Executing listMPartitions");
-      dbName = dbName.toLowerCase().trim();
-      tableName = tableName.toLowerCase().trim();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
+      tableName = HiveStringUtils.normalizeIdentifier(tableName);
       Query query = pm.newQuery(MPartition.class,
           "table.tableName == t1 && table.database.name == t2");
       query.declareParameters("java.lang.String t1, java.lang.String t2");
@@ -2292,8 +2293,8 @@ private ObjectPair<Query, Map<String, String>> getPartQueryWithParams(
     query.setFilter(sb.toString());
 
     LOG.debug(" JDOQL filter is " + sb.toString());
-    params.put("t1", tblName.trim().toLowerCase());
-    params.put("t2", dbName.trim().toLowerCase());
+    params.put("t1", HiveStringUtils.normalizeIdentifier(tblName));
+    params.put("t2", HiveStringUtils.normalizeIdentifier(dbName));
 
     query.declareParameters(makeParameterDeclarationString(params));
     return new ObjectPair<Query, Map<String,String>>(query, params);
@@ -2319,9 +2320,9 @@ public GetHelper(String dbName, String tblName, boolean allowSql, boolean allowJ
         throws MetaException {
       assert allowSql || allowJdo;
       this.allowJdo = allowJdo;
-      this.dbName = dbName.toLowerCase();
+      this.dbName = HiveStringUtils.normalizeIdentifier(dbName);
       if (tblName != null){
-        this.tblName = tblName.toLowerCase();
+        this.tblName = HiveStringUtils.normalizeIdentifier(tblName);
       } else {
         // tblName can be null in cases of Helper being used at a higher
         // abstraction level, such as with datbases
@@ -2622,7 +2623,7 @@ public List<String> listTableNamesByFilter(String dbName, String filter, short m
     try {
       openTransaction();
       LOG.debug("Executing listTableNamesByFilter");
-      dbName = dbName.toLowerCase().trim();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
       Map<String, Object> params = new HashMap<String, Object>();
       String queryFilterString = makeQueryFilterString(dbName, null, filter, params);
       Query query = pm.newQuery(MTable.class);
@@ -2667,8 +2668,8 @@ public List<String> listPartitionNamesByFilter(String dbName, String tableName,
     try {
       openTransaction();
       LOG.debug("Executing listMPartitionNamesByFilter");
-      dbName = dbName.toLowerCase();
-      tableName = tableName.toLowerCase();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
+      tableName = HiveStringUtils.normalizeIdentifier(tableName);
 
       MTable mtable = getMTable(dbName, tableName);
       if( mtable == null ) {
@@ -2719,8 +2720,8 @@ public void alterTable(String dbname, String name, Table newTable)
     boolean success = false;
     try {
       openTransaction();
-      name = name.toLowerCase();
-      dbname = dbname.toLowerCase();
+      name = HiveStringUtils.normalizeIdentifier(name);
+      dbname = HiveStringUtils.normalizeIdentifier(dbname);
       MTable newt = convertToMTable(newTable);
       if (newt == null) {
         throw new InvalidObjectException("new table is invalid");
@@ -2733,7 +2734,7 @@ public void alterTable(String dbname, String name, Table newTable)
 
       // For now only alter name, owner, parameters, cols, bucketcols are allowed
       oldt.setDatabase(newt.getDatabase());
-      oldt.setTableName(newt.getTableName().toLowerCase());
+      oldt.setTableName(HiveStringUtils.normalizeIdentifier(newt.getTableName()));
       oldt.setParameters(newt.getParameters());
       oldt.setOwner(newt.getOwner());
       // Fully copy over the contents of the new SD into the old SD,
@@ -2761,9 +2762,9 @@ public void alterIndex(String dbname, String baseTblName, String name, Index new
     boolean success = false;
     try {
       openTransaction();
-      name = name.toLowerCase();
-      baseTblName = baseTblName.toLowerCase();
-      dbname = dbname.toLowerCase();
+      name = HiveStringUtils.normalizeIdentifier(name);
+      baseTblName = HiveStringUtils.normalizeIdentifier(baseTblName);
+      dbname = HiveStringUtils.normalizeIdentifier(dbname);
       MIndex newi = convertToMIndex(newIndex);
       if (newi == null) {
         throw new InvalidObjectException("new index is invalid");
@@ -2788,8 +2789,8 @@ public void alterIndex(String dbname, String baseTblName, String name, Index new
 
   private void alterPartitionNoTxn(String dbname, String name, List<String> part_vals,
       Partition newPart) throws InvalidObjectException, MetaException {
-    name = name.toLowerCase();
-    dbname = dbname.toLowerCase();
+    name = HiveStringUtils.normalizeIdentifier(name);
+    dbname = HiveStringUtils.normalizeIdentifier(dbname);
     MPartition oldp = getMPartition(dbname, name, part_vals);
     MPartition newp = convertToMPart(newPart, false);
     if (oldp == null || newp == null) {
@@ -3022,7 +3023,7 @@ private MIndex convertToMIndex(Index index) throws InvalidObjectException,
           "Underlying index table does not exist for the given index.");
     }
 
-    return new MIndex(index.getIndexName().toLowerCase(), origTable, index.getCreateTime(),
+    return new MIndex(HiveStringUtils.normalizeIdentifier(index.getIndexName()), origTable, index.getCreateTime(),
         index.getLastAccessTime(), index.getParameters(), indexTable, msd,
         index.getIndexHandlerClass(), index.isDeferredRebuild());
   }
@@ -3051,8 +3052,8 @@ private MIndex getMIndex(String dbName, String originalTblName, String indexName
     boolean commited = false;
     try {
       openTransaction();
-      dbName = dbName.toLowerCase().trim();
-      originalTblName = originalTblName.toLowerCase().trim();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
+      originalTblName = HiveStringUtils.normalizeIdentifier(originalTblName);
       MTable mtbl = getMTable(dbName, originalTblName);
       if (mtbl == null) {
         commited = commitTransaction();
@@ -3063,7 +3064,8 @@ private MIndex getMIndex(String dbName, String originalTblName, String indexName
         "origTable.tableName == t1 && origTable.database.name == t2 && indexName == t3");
       query.declareParameters("java.lang.String t1, java.lang.String t2, java.lang.String t3");
       query.setUnique(true);
-      midx = (MIndex) query.execute(originalTblName, dbName, indexName.toLowerCase());
+      midx = (MIndex) query.execute(originalTblName, dbName,
+          HiveStringUtils.normalizeIdentifier(indexName));
       pm.retrieve(midx);
       commited = commitTransaction();
     } finally {
@@ -3137,8 +3139,8 @@ private List<MIndex> listMIndexes(String dbName, String origTableName,
     try {
       openTransaction();
       LOG.debug("Executing listMIndexes");
-      dbName = dbName.toLowerCase().trim();
-      origTableName = origTableName.toLowerCase().trim();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
+      origTableName = HiveStringUtils.normalizeIdentifier(origTableName);
       Query query = pm.newQuery(MIndex.class,
           "origTable.tableName == t1 && origTable.database.name == t2");
       query.declareParameters("java.lang.String t1, java.lang.String t2");
@@ -3163,8 +3165,8 @@ public List<String> listIndexNames(String dbName, String origTableName,
     try {
       openTransaction();
       LOG.debug("Executing listIndexNames");
-      dbName = dbName.toLowerCase().trim();
-      origTableName = origTableName.toLowerCase().trim();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
+      origTableName = HiveStringUtils.normalizeIdentifier(origTableName);
       Query q = pm.newQuery(
           "select indexName from org.apache.hadoop.hive.metastore.model.MIndex "
           + "where origTable.database.name == t1 && origTable.tableName == t2 "
@@ -3585,7 +3587,7 @@ public PrincipalPrivilegeSet getUserPrivilegeSet(String userName,
   public List<PrivilegeGrantInfo> getDBPrivilege(String dbName,
       String principalName, PrincipalType principalType)
       throws InvalidObjectException, MetaException {
-    dbName = dbName.toLowerCase().trim();
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     if (principalName != null) {
       List<MDBPrivilege> userNameDbPriv = this.listPrincipalDBGrants(
@@ -3611,7 +3613,7 @@ public PrincipalPrivilegeSet getDBPrivilegeSet(String dbName,
       String userName, List<String> groupNames) throws InvalidObjectException,
       MetaException {
     boolean commited = false;
-    dbName = dbName.toLowerCase().trim();
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     PrincipalPrivilegeSet ret = new PrincipalPrivilegeSet();
     try {
@@ -3654,8 +3656,8 @@ public PrincipalPrivilegeSet getPartitionPrivilegeSet(String dbName,
       List<String> groupNames) throws InvalidObjectException, MetaException {
     boolean commited = false;
     PrincipalPrivilegeSet ret = new PrincipalPrivilegeSet();
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     try {
       openTransaction();
@@ -3697,8 +3699,8 @@ public PrincipalPrivilegeSet getTablePrivilegeSet(String dbName,
       throws InvalidObjectException, MetaException {
     boolean commited = false;
     PrincipalPrivilegeSet ret = new PrincipalPrivilegeSet();
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     try {
       openTransaction();
@@ -3739,9 +3741,9 @@ public PrincipalPrivilegeSet getColumnPrivilegeSet(String dbName,
       String tableName, String partitionName, String columnName,
       String userName, List<String> groupNames) throws InvalidObjectException,
       MetaException {
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
-    columnName = columnName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
+    columnName = HiveStringUtils.normalizeIdentifier(columnName);
 
     boolean commited = false;
     PrincipalPrivilegeSet ret = new PrincipalPrivilegeSet();
@@ -3783,8 +3785,8 @@ private List<PrivilegeGrantInfo> getPartitionPrivilege(String dbName,
       String tableName, String partName, String principalName,
       PrincipalType principalType) {
 
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     if (principalName != null) {
       List<MPartitionPrivilege> userNameTabPartPriv = this
@@ -3812,8 +3814,8 @@ private PrincipalType getPrincipalTypeFromStr(String str) {
 
   private List<PrivilegeGrantInfo> getTablePrivilege(String dbName,
       String tableName, String principalName, PrincipalType principalType) {
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     if (principalName != null) {
       List<MTablePrivilege> userNameTabPartPriv = this
@@ -3838,9 +3840,9 @@ private List<PrivilegeGrantInfo> getColumnPrivilege(String dbName,
       String tableName, String columnName, String partitionName,
       String principalName, PrincipalType principalType) {
 
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
-    columnName = columnName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
+    columnName = HiveStringUtils.normalizeIdentifier(columnName);
 
     if (partitionName == null) {
       List<MTableColumnPrivilege> userNameColumnPriv = this
@@ -4424,7 +4426,7 @@ public List<MDBPrivilege> listPrincipalDBGrants(String principalName,
       PrincipalType principalType, String dbName) {
     boolean success = false;
     List<MDBPrivilege> mSecurityDBList = null;
-    dbName = dbName.toLowerCase().trim();
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     try {
       openTransaction();
@@ -4508,11 +4510,11 @@ private List<MDBPrivilege> listPrincipalAllDBGrant(
   public List<MTablePrivilege> listAllTableGrants(String dbName,
       String tableName) {
     boolean success = false;
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
     List<MTablePrivilege> mSecurityTabList = null;
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
     try {
       openTransaction();
       LOG.debug("Executing listAllTableGrants");
@@ -4539,8 +4541,8 @@ public List<MTablePrivilege> listAllTableGrants(String dbName,
   @SuppressWarnings("unchecked")
   public List<MPartitionPrivilege> listTableAllPartitionGrants(String dbName,
       String tableName) {
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
     boolean success = false;
     List<MPartitionPrivilege> mSecurityTabPartList = null;
     try {
@@ -4571,8 +4573,8 @@ public List<MTableColumnPrivilege> listTableAllColumnGrants(String dbName,
       String tableName) {
     boolean success = false;
     List<MTableColumnPrivilege> mTblColPrivilegeList = null;
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     try {
       openTransaction();
@@ -4598,8 +4600,8 @@ public List<MTableColumnPrivilege> listTableAllColumnGrants(String dbName,
   public List<MPartitionColumnPrivilege> listTableAllPartitionColumnGrants(String dbName,
       String tableName) {
     boolean success = false;
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     List<MPartitionColumnPrivilege> mSecurityColList = null;
     try {
@@ -4626,8 +4628,8 @@ public List<MPartitionColumnPrivilege> listTableAllPartitionColumnGrants(String
   public List<MPartitionColumnPrivilege> listPartitionAllColumnGrants(String dbName,
       String tableName, List<String> partNames) {
     boolean success = false;
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     List<MPartitionColumnPrivilege> mSecurityColList = null;
     try {
@@ -4658,7 +4660,7 @@ public void dropPartitionAllColumnGrantsNoTxn(
 
   @SuppressWarnings("unchecked")
   private List<MDBPrivilege> listDatabaseGrants(String dbName) {
-    dbName = dbName.toLowerCase().trim();
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     boolean success = false;
     try {
@@ -4684,8 +4686,8 @@ private List<MDBPrivilege> listDatabaseGrants(String dbName) {
   @SuppressWarnings("unchecked")
   private List<MPartitionPrivilege> listPartitionGrants(String dbName, String tableName,
       List<String> partNames) {
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     boolean success = false;
     List<MPartitionPrivilege> mSecurityTabPartList = null;
@@ -4728,8 +4730,8 @@ private ObjectPair<Query, Object[]> makeQueryByPartitionNames(
     String queryStr = tbCol + " == t1 && " + dbCol + " == t2";
     String paramStr = "java.lang.String t1, java.lang.String t2";
     Object[] params = new Object[2 + partNames.size()];
-    params[0] = tableName;
-    params[1] = dbName;
+    params[0] = HiveStringUtils.normalizeIdentifier(tableName);
+    params[1] = HiveStringUtils.normalizeIdentifier(dbName);
     int index = 0;
     for (String partName : partNames) {
       params[index + 2] = partName;
@@ -4748,8 +4750,8 @@ private ObjectPair<Query, Object[]> makeQueryByPartitionNames(
   public List<MTablePrivilege> listAllTableGrants(
       String principalName, PrincipalType principalType, String dbName,
       String tableName) {
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     boolean success = false;
     List<MTablePrivilege> mSecurityTabPartList = null;
@@ -4782,8 +4784,8 @@ public List<MPartitionPrivilege> listPrincipalPartitionGrants(
       String principalName, PrincipalType principalType, String dbName,
       String tableName, String partName) {
     boolean success = false;
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
 
     List<MPartitionPrivilege> mSecurityTabPartList = null;
     try {
@@ -4817,9 +4819,9 @@ public List<MTableColumnPrivilege> listPrincipalTableColumnGrants(
       String principalName, PrincipalType principalType, String dbName,
       String tableName, String columnName) {
     boolean success = false;
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
-    columnName = columnName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
+    columnName = HiveStringUtils.normalizeIdentifier(columnName);
     List<MTableColumnPrivilege> mSecurityColList = null;
     try {
       openTransaction();
@@ -4851,9 +4853,9 @@ public List<MPartitionColumnPrivilege> listPrincipalPartitionColumnGrants(
       String principalName, PrincipalType principalType, String dbName,
       String tableName, String partitionName, String columnName) {
     boolean success = false;
-    tableName = tableName.toLowerCase().trim();
-    dbName = dbName.toLowerCase().trim();
-    columnName = columnName.toLowerCase().trim();
+    tableName = HiveStringUtils.normalizeIdentifier(tableName);
+    dbName = HiveStringUtils.normalizeIdentifier(dbName);
+    columnName = HiveStringUtils.normalizeIdentifier(columnName);
 
     List<MPartitionColumnPrivilege> mSecurityColList = null;
     try {
@@ -6004,7 +6006,8 @@ public ColumnStatistics getTableColumnStatistics(String dbName, String tableName
   protected ColumnStatistics getTableColumnStatisticsInternal(
       String dbName, String tableName, final List<String> colNames, boolean allowSql,
       boolean allowJdo) throws MetaException, NoSuchObjectException {
-    return new GetStatHelper(dbName.toLowerCase(), tableName.toLowerCase(), allowSql, allowJdo) {
+    return new GetStatHelper(HiveStringUtils.normalizeIdentifier(dbName),
+        HiveStringUtils.normalizeIdentifier(tableName), allowSql, allowJdo) {
       @Override
       protected ColumnStatistics getSqlResult(GetHelper<ColumnStatistics> ctx) throws MetaException {
         return directSql.getTableStats(dbName, tblName, colNames);
@@ -6221,7 +6224,9 @@ public boolean deletePartitionColumnStatistics(String dbName, String tableName,
       if (colName != null) {
         query.setUnique(true);
         mStatsObj = (MPartitionColumnStatistics)query.executeWithArray(partName.trim(),
-                                                dbName.trim(), tableName.trim(), colName.trim());
+            HiveStringUtils.normalizeIdentifier(dbName),
+            HiveStringUtils.normalizeIdentifier(tableName),
+            HiveStringUtils.normalizeIdentifier(colName));
         pm.retrieve(mStatsObj);
 
         if (mStatsObj != null) {
@@ -6232,7 +6237,8 @@ public boolean deletePartitionColumnStatistics(String dbName, String tableName,
         }
       } else {
         mStatsObjColl= (List<MPartitionColumnStatistics>)query.execute(partName.trim(),
-                                  dbName.trim(), tableName.trim());
+            HiveStringUtils.normalizeIdentifier(dbName),
+            HiveStringUtils.normalizeIdentifier(tableName));
         pm.retrieveAll(mStatsObjColl);
 
         if (mStatsObjColl != null) {
@@ -6298,8 +6304,10 @@ public boolean deleteTableColumnStatistics(String dbName, String tableName, Stri
 
       if (colName != null) {
         query.setUnique(true);
-        mStatsObj = (MTableColumnStatistics)query.execute(tableName.trim(),
-                                                    dbName.trim(), colName.trim());
+        mStatsObj = (MTableColumnStatistics)query.execute(
+            HiveStringUtils.normalizeIdentifier(tableName),
+            HiveStringUtils.normalizeIdentifier(dbName),
+            HiveStringUtils.normalizeIdentifier(colName));
         pm.retrieve(mStatsObj);
 
         if (mStatsObj != null) {
@@ -6309,7 +6317,9 @@ public boolean deleteTableColumnStatistics(String dbName, String tableName, Stri
               + tableName + " col=" + colName);
         }
       } else {
-        mStatsObjColl= (List<MTableColumnStatistics>)query.execute(tableName.trim(), dbName.trim());
+        mStatsObjColl= (List<MTableColumnStatistics>)query.execute(
+            HiveStringUtils.normalizeIdentifier(tableName),
+            HiveStringUtils.normalizeIdentifier(dbName));
         pm.retrieveAll(mStatsObjColl);
 
         if (mStatsObjColl != null) {
@@ -6688,8 +6698,8 @@ public boolean doesPartitionExist(String dbName, String tableName, List<String>
     boolean success = false;
     try {
       openTransaction();
-      dbName = dbName.toLowerCase().trim();
-      tableName = tableName.toLowerCase().trim();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
+      tableName = HiveStringUtils.normalizeIdentifier(tableName);
 
       // TODO: this could also be passed from upper layer; or this method should filter the list.
       MTable mtbl = getMTable(dbName, tableName);
@@ -6821,8 +6831,8 @@ public void alterFunction(String dbName, String funcName, Function newFunction)
     boolean success = false;
     try {
       openTransaction();
-      funcName = funcName.toLowerCase();
-      dbName = dbName.toLowerCase();
+      funcName = HiveStringUtils.normalizeIdentifier(funcName);
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
       MFunction newf = convertToMFunction(newFunction);
       if (newf == null) {
         throw new InvalidObjectException("new function is invalid");
@@ -6834,7 +6844,7 @@ public void alterFunction(String dbName, String funcName, Function newFunction)
       }
 
       // For now only alter name, owner, class name, type
-      oldf.setFunctionName(newf.getFunctionName().toLowerCase());
+      oldf.setFunctionName(HiveStringUtils.normalizeIdentifier(newf.getFunctionName()));
       oldf.setDatabase(newf.getDatabase());
       oldf.setOwnerName(newf.getOwnerName());
       oldf.setOwnerType(newf.getOwnerType());
@@ -6875,8 +6885,8 @@ private MFunction getMFunction(String db, String function) {
     boolean commited = false;
     try {
       openTransaction();
-      db = db.toLowerCase().trim();
-      function = function.toLowerCase().trim();
+      db = HiveStringUtils.normalizeIdentifier(db);
+      function = HiveStringUtils.normalizeIdentifier(function);
       Query query = pm.newQuery(MFunction.class, "functionName == function && database.name == db");
       query.declareParameters("java.lang.String function, java.lang.String db");
       query.setUnique(true);
@@ -6914,7 +6924,7 @@ public List<String> getFunctions(String dbName, String pattern)
     List<String> funcs = null;
     try {
       openTransaction();
-      dbName = dbName.toLowerCase().trim();
+      dbName = HiveStringUtils.normalizeIdentifier(dbName);
       // Take the pattern and split it on the | to get all the composing
       // patterns
       String[] subpatterns = pattern.trim().split("\\|");
diff --git a/ql/src/test/queries/clientpositive/drop_partition_with_stats.q b/ql/src/test/queries/clientpositive/drop_partition_with_stats.q
new file mode 100644
index 0000000000..40b43c2081
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/drop_partition_with_stats.q
@@ -0,0 +1,68 @@
+-- This test verifies that a table partition could be dropped with columns stats computed
+-- The column stats for a partitioned table will go to PART_COL_STATS
+CREATE DATABASE IF NOT EXISTS partstatsdb1;
+USE partstatsdb1;
+CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p11', Part2='P12');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p21', Part2='P22');
+ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key;
+ANALYZE TABLE testtable PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key;
+
+
+CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P11');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P12');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p21', Part2='P22');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p31', Part2='P32');
+ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key;
+ANALYZE TABLE TestTable1 PARTITION (part1='p11') COMPUTE STATISTICS FOR COLUMNS key;
+ANALYZE TABLE TestTable1 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key;
+
+CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p21', Part2='P22');
+ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key;
+ANALYZE TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key;
+
+ALTER TABLE partstatsdb1.testtable DROP PARTITION (part1='p11', Part2='P12');
+ALTER TABLE partstatsdb1.TestTable1 DROP PARTITION (part1='p11', Part2='P12');
+ALTER TABLE partstatsdb1.TESTTABLE2 DROP PARTITION (part1='p11', Part2='P12');
+
+DROP TABLE partstatsdb1.testtable;
+DROP TABLE partstatsdb1.TestTable1;
+DROP TABLE partstatsdb1.TESTTABLE2;
+DROP DATABASE partstatsdb1;
+
+CREATE DATABASE IF NOT EXISTS PARTSTATSDB2;
+USE PARTSTATSDB2;
+CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p11', Part2='P12');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p21', Part2='P22');
+ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key;
+ANALYZE TABLE testtable PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key;
+
+
+CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P11');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P12');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p21', Part2='P22');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p31', Part2='P32');
+ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key;
+ANALYZE TABLE TestTable1 PARTITION (part1='p11') COMPUTE STATISTICS FOR COLUMNS key;
+ANALYZE TABLE TestTable1 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key;
+
+CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12');
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p21', Part2='P22');
+ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key;
+ANALYZE TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key;
+
+ALTER TABLE PARTSTATSDB2.testtable DROP PARTITION (part1='p11', Part2='P12');
+ALTER TABLE PARTSTATSDB2.TestTable1 DROP PARTITION (part1='p11', Part2='P12');
+ALTER TABLE PARTSTATSDB2.TESTTABLE2 DROP PARTITION (part1='p11', Part2='P12');
+
+DROP TABLE PARTSTATSDB2.testtable;
+DROP TABLE PARTSTATSDB2.TestTable1;
+DROP TABLE PARTSTATSDB2.TESTTABLE2;
+DROP DATABASE PARTSTATSDB2;
+
diff --git a/ql/src/test/queries/clientpositive/drop_table_with_stats.q b/ql/src/test/queries/clientpositive/drop_table_with_stats.q
new file mode 100644
index 0000000000..b655b53aad
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/drop_table_with_stats.q
@@ -0,0 +1,43 @@
+-- This test verifies that a table could be dropped with columns stats computed
+-- The column stats for table without partition will go to TAB_COL_STATS
+CREATE DATABASE IF NOT EXISTS tblstatsdb1;
+USE tblstatsdb1;
+CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable;
+ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key;
+
+CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1;
+ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key;
+
+CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2;
+ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key;
+
+DROP TABLE tblstatsdb1.testtable;
+DROP TABLE tblstatsdb1.TestTable1;
+DROP TABLE tblstatsdb1.TESTTABLE2;
+DROP DATABASE tblstatsdb1;
+
+CREATE DATABASE IF NOT EXISTS TBLSTATSDB2;
+USE TBLSTATSDB2;
+CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable;
+ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key;
+
+
+CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1;
+ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key;
+
+
+CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING);
+LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2;
+ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key;
+
+
+DROP TABLE TBLSTATSDB2.testtable;
+DROP TABLE TBLSTATSDB2.TestTable1;
+DROP TABLE TBLSTATSDB2.TESTTABLE2;
+DROP DATABASE TBLSTATSDB2;
+
diff --git a/ql/src/test/results/clientpositive/drop_partition_with_stats.q.out b/ql/src/test/results/clientpositive/drop_partition_with_stats.q.out
new file mode 100644
index 0000000000..e27e557deb
--- /dev/null
+++ b/ql/src/test/results/clientpositive/drop_partition_with_stats.q.out
@@ -0,0 +1,496 @@
+PREHOOK: query: -- This test verifies that a table partition could be dropped with columns stats computed
+-- The column stats for a partitioned table will go to PART_COL_STATS
+CREATE DATABASE IF NOT EXISTS partstatsdb1
+PREHOOK: type: CREATEDATABASE
+PREHOOK: Output: database:partstatsdb1
+POSTHOOK: query: -- This test verifies that a table partition could be dropped with columns stats computed
+-- The column stats for a partitioned table will go to PART_COL_STATS
+CREATE DATABASE IF NOT EXISTS partstatsdb1
+POSTHOOK: type: CREATEDATABASE
+POSTHOOK: Output: database:partstatsdb1
+PREHOOK: query: USE partstatsdb1
+PREHOOK: type: SWITCHDATABASE
+PREHOOK: Input: database:partstatsdb1
+POSTHOOK: query: USE partstatsdb1
+POSTHOOK: type: SWITCHDATABASE
+POSTHOOK: Input: database:partstatsdb1
+PREHOOK: query: CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:partstatsdb1
+PREHOOK: Output: partstatsdb1@testtable
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:partstatsdb1
+POSTHOOK: Output: partstatsdb1@testtable
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb1@testtable
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb1@testtable
+POSTHOOK: Output: partstatsdb1@testtable@part1=p11/part2=P12
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p21', Part2='P22')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb1@testtable
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p21', Part2='P22')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb1@testtable
+POSTHOOK: Output: partstatsdb1@testtable@part1=p21/part2=P22
+PREHOOK: query: ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb1@testtable
+PREHOOK: Input: partstatsdb1@testtable@part1=p11/part2=P12
+PREHOOK: Input: partstatsdb1@testtable@part1=p21/part2=P22
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb1@testtable
+POSTHOOK: Input: partstatsdb1@testtable@part1=p11/part2=P12
+POSTHOOK: Input: partstatsdb1@testtable@part1=p21/part2=P22
+#### A masked pattern was here ####
+PREHOOK: query: ANALYZE TABLE testtable PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb1@testtable
+PREHOOK: Input: partstatsdb1@testtable@part1=p11/part2=P12
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE testtable PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb1@testtable
+POSTHOOK: Input: partstatsdb1@testtable@part1=p11/part2=P12
+#### A masked pattern was here ####
+PREHOOK: query: CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:partstatsdb1
+PREHOOK: Output: partstatsdb1@TestTable1
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:partstatsdb1
+POSTHOOK: Output: partstatsdb1@TestTable1
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P11')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb1@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P11')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb1@testtable1
+POSTHOOK: Output: partstatsdb1@testtable1@part1=p11/part2=P11
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb1@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb1@testtable1
+POSTHOOK: Output: partstatsdb1@testtable1@part1=p11/part2=P12
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p21', Part2='P22')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb1@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p21', Part2='P22')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb1@testtable1
+POSTHOOK: Output: partstatsdb1@testtable1@part1=p21/part2=P22
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p31', Part2='P32')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb1@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p31', Part2='P32')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb1@testtable1
+POSTHOOK: Output: partstatsdb1@testtable1@part1=p31/part2=P32
+PREHOOK: query: ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb1@testtable1
+PREHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P11
+PREHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P12
+PREHOOK: Input: partstatsdb1@testtable1@part1=p21/part2=P22
+PREHOOK: Input: partstatsdb1@testtable1@part1=p31/part2=P32
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb1@testtable1
+POSTHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P11
+POSTHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P12
+POSTHOOK: Input: partstatsdb1@testtable1@part1=p21/part2=P22
+POSTHOOK: Input: partstatsdb1@testtable1@part1=p31/part2=P32
+#### A masked pattern was here ####
+PREHOOK: query: ANALYZE TABLE TestTable1 PARTITION (part1='p11') COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb1@testtable1
+PREHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P11
+PREHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P12
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TestTable1 PARTITION (part1='p11') COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb1@testtable1
+POSTHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P11
+POSTHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P12
+#### A masked pattern was here ####
+PREHOOK: query: ANALYZE TABLE TestTable1 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb1@testtable1
+PREHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P12
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TestTable1 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb1@testtable1
+POSTHOOK: Input: partstatsdb1@testtable1@part1=p11/part2=P12
+#### A masked pattern was here ####
+PREHOOK: query: CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:partstatsdb1
+PREHOOK: Output: partstatsdb1@TESTTABLE2
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:partstatsdb1
+POSTHOOK: Output: partstatsdb1@TESTTABLE2
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb1@testtable2
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb1@testtable2
+POSTHOOK: Output: partstatsdb1@testtable2@part1=p11/part2=P12
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p21', Part2='P22')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb1@testtable2
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p21', Part2='P22')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb1@testtable2
+POSTHOOK: Output: partstatsdb1@testtable2@part1=p21/part2=P22
+PREHOOK: query: ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb1@testtable2
+PREHOOK: Input: partstatsdb1@testtable2@part1=p11/part2=P12
+PREHOOK: Input: partstatsdb1@testtable2@part1=p21/part2=P22
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb1@testtable2
+POSTHOOK: Input: partstatsdb1@testtable2@part1=p11/part2=P12
+POSTHOOK: Input: partstatsdb1@testtable2@part1=p21/part2=P22
+#### A masked pattern was here ####
+PREHOOK: query: ANALYZE TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb1@testtable2
+PREHOOK: Input: partstatsdb1@testtable2@part1=p11/part2=P12
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb1@testtable2
+POSTHOOK: Input: partstatsdb1@testtable2@part1=p11/part2=P12
+#### A masked pattern was here ####
+PREHOOK: query: ALTER TABLE partstatsdb1.testtable DROP PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: ALTERTABLE_DROPPARTS
+PREHOOK: Input: partstatsdb1@testtable
+PREHOOK: Output: partstatsdb1@testtable@part1=p11/part2=P12
+POSTHOOK: query: ALTER TABLE partstatsdb1.testtable DROP PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: ALTERTABLE_DROPPARTS
+POSTHOOK: Input: partstatsdb1@testtable
+POSTHOOK: Output: partstatsdb1@testtable@part1=p11/part2=P12
+PREHOOK: query: ALTER TABLE partstatsdb1.TestTable1 DROP PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: ALTERTABLE_DROPPARTS
+PREHOOK: Input: partstatsdb1@testtable1
+PREHOOK: Output: partstatsdb1@testtable1@part1=p11/part2=P12
+POSTHOOK: query: ALTER TABLE partstatsdb1.TestTable1 DROP PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: ALTERTABLE_DROPPARTS
+POSTHOOK: Input: partstatsdb1@testtable1
+POSTHOOK: Output: partstatsdb1@testtable1@part1=p11/part2=P12
+PREHOOK: query: ALTER TABLE partstatsdb1.TESTTABLE2 DROP PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: ALTERTABLE_DROPPARTS
+PREHOOK: Input: partstatsdb1@testtable2
+PREHOOK: Output: partstatsdb1@testtable2@part1=p11/part2=P12
+POSTHOOK: query: ALTER TABLE partstatsdb1.TESTTABLE2 DROP PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: ALTERTABLE_DROPPARTS
+POSTHOOK: Input: partstatsdb1@testtable2
+POSTHOOK: Output: partstatsdb1@testtable2@part1=p11/part2=P12
+PREHOOK: query: DROP TABLE partstatsdb1.testtable
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: partstatsdb1@testtable
+PREHOOK: Output: partstatsdb1@testtable
+POSTHOOK: query: DROP TABLE partstatsdb1.testtable
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: partstatsdb1@testtable
+POSTHOOK: Output: partstatsdb1@testtable
+PREHOOK: query: DROP TABLE partstatsdb1.TestTable1
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: partstatsdb1@testtable1
+PREHOOK: Output: partstatsdb1@testtable1
+POSTHOOK: query: DROP TABLE partstatsdb1.TestTable1
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: partstatsdb1@testtable1
+POSTHOOK: Output: partstatsdb1@testtable1
+PREHOOK: query: DROP TABLE partstatsdb1.TESTTABLE2
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: partstatsdb1@testtable2
+PREHOOK: Output: partstatsdb1@testtable2
+POSTHOOK: query: DROP TABLE partstatsdb1.TESTTABLE2
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: partstatsdb1@testtable2
+POSTHOOK: Output: partstatsdb1@testtable2
+PREHOOK: query: DROP DATABASE partstatsdb1
+PREHOOK: type: DROPDATABASE
+PREHOOK: Input: database:partstatsdb1
+PREHOOK: Output: database:partstatsdb1
+POSTHOOK: query: DROP DATABASE partstatsdb1
+POSTHOOK: type: DROPDATABASE
+POSTHOOK: Input: database:partstatsdb1
+POSTHOOK: Output: database:partstatsdb1
+PREHOOK: query: CREATE DATABASE IF NOT EXISTS PARTSTATSDB2
+PREHOOK: type: CREATEDATABASE
+PREHOOK: Output: database:PARTSTATSDB2
+POSTHOOK: query: CREATE DATABASE IF NOT EXISTS PARTSTATSDB2
+POSTHOOK: type: CREATEDATABASE
+POSTHOOK: Output: database:PARTSTATSDB2
+PREHOOK: query: USE PARTSTATSDB2
+PREHOOK: type: SWITCHDATABASE
+PREHOOK: Input: database:partstatsdb2
+POSTHOOK: query: USE PARTSTATSDB2
+POSTHOOK: type: SWITCHDATABASE
+POSTHOOK: Input: database:partstatsdb2
+PREHOOK: query: CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: PARTSTATSDB2@testtable
+PREHOOK: Output: database:partstatsdb2
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: PARTSTATSDB2@testtable
+POSTHOOK: Output: database:partstatsdb2
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb2@testtable
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb2@testtable
+POSTHOOK: Output: partstatsdb2@testtable@part1=p11/part2=P12
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p21', Part2='P22')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb2@testtable
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable PARTITION (part1='p21', Part2='P22')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb2@testtable
+POSTHOOK: Output: partstatsdb2@testtable@part1=p21/part2=P22
+PREHOOK: query: ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb2@testtable
+PREHOOK: Input: partstatsdb2@testtable@part1=p11/part2=P12
+PREHOOK: Input: partstatsdb2@testtable@part1=p21/part2=P22
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb2@testtable
+POSTHOOK: Input: partstatsdb2@testtable@part1=p11/part2=P12
+POSTHOOK: Input: partstatsdb2@testtable@part1=p21/part2=P22
+#### A masked pattern was here ####
+PREHOOK: query: ANALYZE TABLE testtable PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb2@testtable
+PREHOOK: Input: partstatsdb2@testtable@part1=p11/part2=P12
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE testtable PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb2@testtable
+POSTHOOK: Input: partstatsdb2@testtable@part1=p11/part2=P12
+#### A masked pattern was here ####
+PREHOOK: query: CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: PARTSTATSDB2@TestTable1
+PREHOOK: Output: database:partstatsdb2
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: PARTSTATSDB2@TestTable1
+POSTHOOK: Output: database:partstatsdb2
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P11')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb2@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P11')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb2@testtable1
+POSTHOOK: Output: partstatsdb2@testtable1@part1=p11/part2=P11
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb2@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb2@testtable1
+POSTHOOK: Output: partstatsdb2@testtable1@part1=p11/part2=P12
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p21', Part2='P22')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb2@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p21', Part2='P22')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb2@testtable1
+POSTHOOK: Output: partstatsdb2@testtable1@part1=p21/part2=P22
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p31', Part2='P32')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb2@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1 PARTITION (part1='p31', Part2='P32')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb2@testtable1
+POSTHOOK: Output: partstatsdb2@testtable1@part1=p31/part2=P32
+PREHOOK: query: ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb2@testtable1
+PREHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P11
+PREHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P12
+PREHOOK: Input: partstatsdb2@testtable1@part1=p21/part2=P22
+PREHOOK: Input: partstatsdb2@testtable1@part1=p31/part2=P32
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb2@testtable1
+POSTHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P11
+POSTHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P12
+POSTHOOK: Input: partstatsdb2@testtable1@part1=p21/part2=P22
+POSTHOOK: Input: partstatsdb2@testtable1@part1=p31/part2=P32
+#### A masked pattern was here ####
+PREHOOK: query: ANALYZE TABLE TestTable1 PARTITION (part1='p11') COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb2@testtable1
+PREHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P11
+PREHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P12
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TestTable1 PARTITION (part1='p11') COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb2@testtable1
+POSTHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P11
+POSTHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P12
+#### A masked pattern was here ####
+PREHOOK: query: ANALYZE TABLE TestTable1 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb2@testtable1
+PREHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P12
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TestTable1 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb2@testtable1
+POSTHOOK: Input: partstatsdb2@testtable1@part1=p11/part2=P12
+#### A masked pattern was here ####
+PREHOOK: query: CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: PARTSTATSDB2@TESTTABLE2
+PREHOOK: Output: database:partstatsdb2
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING) PARTITIONED BY (part1 STRING, Part2 STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: PARTSTATSDB2@TESTTABLE2
+POSTHOOK: Output: database:partstatsdb2
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb2@testtable2
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb2@testtable2
+POSTHOOK: Output: partstatsdb2@testtable2@part1=p11/part2=P12
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p21', Part2='P22')
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: partstatsdb2@testtable2
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2 PARTITION (part1='p21', Part2='P22')
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: partstatsdb2@testtable2
+POSTHOOK: Output: partstatsdb2@testtable2@part1=p21/part2=P22
+PREHOOK: query: ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb2@testtable2
+PREHOOK: Input: partstatsdb2@testtable2@part1=p11/part2=P12
+PREHOOK: Input: partstatsdb2@testtable2@part1=p21/part2=P22
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb2@testtable2
+POSTHOOK: Input: partstatsdb2@testtable2@part1=p11/part2=P12
+POSTHOOK: Input: partstatsdb2@testtable2@part1=p21/part2=P22
+#### A masked pattern was here ####
+PREHOOK: query: ANALYZE TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: partstatsdb2@testtable2
+PREHOOK: Input: partstatsdb2@testtable2@part1=p11/part2=P12
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TESTTABLE2 PARTITION (part1='p11', Part2='P12') COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: partstatsdb2@testtable2
+POSTHOOK: Input: partstatsdb2@testtable2@part1=p11/part2=P12
+#### A masked pattern was here ####
+PREHOOK: query: ALTER TABLE PARTSTATSDB2.testtable DROP PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: ALTERTABLE_DROPPARTS
+PREHOOK: Input: partstatsdb2@testtable
+PREHOOK: Output: partstatsdb2@testtable@part1=p11/part2=P12
+POSTHOOK: query: ALTER TABLE PARTSTATSDB2.testtable DROP PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: ALTERTABLE_DROPPARTS
+POSTHOOK: Input: partstatsdb2@testtable
+POSTHOOK: Output: partstatsdb2@testtable@part1=p11/part2=P12
+PREHOOK: query: ALTER TABLE PARTSTATSDB2.TestTable1 DROP PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: ALTERTABLE_DROPPARTS
+PREHOOK: Input: partstatsdb2@testtable1
+PREHOOK: Output: partstatsdb2@testtable1@part1=p11/part2=P12
+POSTHOOK: query: ALTER TABLE PARTSTATSDB2.TestTable1 DROP PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: ALTERTABLE_DROPPARTS
+POSTHOOK: Input: partstatsdb2@testtable1
+POSTHOOK: Output: partstatsdb2@testtable1@part1=p11/part2=P12
+PREHOOK: query: ALTER TABLE PARTSTATSDB2.TESTTABLE2 DROP PARTITION (part1='p11', Part2='P12')
+PREHOOK: type: ALTERTABLE_DROPPARTS
+PREHOOK: Input: partstatsdb2@testtable2
+PREHOOK: Output: partstatsdb2@testtable2@part1=p11/part2=P12
+POSTHOOK: query: ALTER TABLE PARTSTATSDB2.TESTTABLE2 DROP PARTITION (part1='p11', Part2='P12')
+POSTHOOK: type: ALTERTABLE_DROPPARTS
+POSTHOOK: Input: partstatsdb2@testtable2
+POSTHOOK: Output: partstatsdb2@testtable2@part1=p11/part2=P12
+PREHOOK: query: DROP TABLE PARTSTATSDB2.testtable
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: partstatsdb2@testtable
+PREHOOK: Output: partstatsdb2@testtable
+POSTHOOK: query: DROP TABLE PARTSTATSDB2.testtable
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: partstatsdb2@testtable
+POSTHOOK: Output: partstatsdb2@testtable
+PREHOOK: query: DROP TABLE PARTSTATSDB2.TestTable1
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: partstatsdb2@testtable1
+PREHOOK: Output: partstatsdb2@testtable1
+POSTHOOK: query: DROP TABLE PARTSTATSDB2.TestTable1
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: partstatsdb2@testtable1
+POSTHOOK: Output: partstatsdb2@testtable1
+PREHOOK: query: DROP TABLE PARTSTATSDB2.TESTTABLE2
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: partstatsdb2@testtable2
+PREHOOK: Output: partstatsdb2@testtable2
+POSTHOOK: query: DROP TABLE PARTSTATSDB2.TESTTABLE2
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: partstatsdb2@testtable2
+POSTHOOK: Output: partstatsdb2@testtable2
+PREHOOK: query: DROP DATABASE PARTSTATSDB2
+PREHOOK: type: DROPDATABASE
+PREHOOK: Input: database:partstatsdb2
+PREHOOK: Output: database:partstatsdb2
+POSTHOOK: query: DROP DATABASE PARTSTATSDB2
+POSTHOOK: type: DROPDATABASE
+POSTHOOK: Input: database:partstatsdb2
+POSTHOOK: Output: database:partstatsdb2
diff --git a/ql/src/test/results/clientpositive/drop_table_with_stats.q.out b/ql/src/test/results/clientpositive/drop_table_with_stats.q.out
new file mode 100644
index 0000000000..fbc3ab9b5d
--- /dev/null
+++ b/ql/src/test/results/clientpositive/drop_table_with_stats.q.out
@@ -0,0 +1,236 @@
+PREHOOK: query: -- This test verifies that a table could be dropped with columns stats computed
+-- The column stats for table without partition will go to TAB_COL_STATS
+CREATE DATABASE IF NOT EXISTS tblstatsdb1
+PREHOOK: type: CREATEDATABASE
+PREHOOK: Output: database:tblstatsdb1
+POSTHOOK: query: -- This test verifies that a table could be dropped with columns stats computed
+-- The column stats for table without partition will go to TAB_COL_STATS
+CREATE DATABASE IF NOT EXISTS tblstatsdb1
+POSTHOOK: type: CREATEDATABASE
+POSTHOOK: Output: database:tblstatsdb1
+PREHOOK: query: USE tblstatsdb1
+PREHOOK: type: SWITCHDATABASE
+PREHOOK: Input: database:tblstatsdb1
+POSTHOOK: query: USE tblstatsdb1
+POSTHOOK: type: SWITCHDATABASE
+POSTHOOK: Input: database:tblstatsdb1
+PREHOOK: query: CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:tblstatsdb1
+PREHOOK: Output: tblstatsdb1@testtable
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:tblstatsdb1
+POSTHOOK: Output: tblstatsdb1@testtable
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: tblstatsdb1@testtable
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: tblstatsdb1@testtable
+PREHOOK: query: ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: tblstatsdb1@testtable
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: tblstatsdb1@testtable
+#### A masked pattern was here ####
+PREHOOK: query: CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:tblstatsdb1
+PREHOOK: Output: tblstatsdb1@TestTable1
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:tblstatsdb1
+POSTHOOK: Output: tblstatsdb1@TestTable1
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: tblstatsdb1@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: tblstatsdb1@testtable1
+PREHOOK: query: ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: tblstatsdb1@testtable1
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: tblstatsdb1@testtable1
+#### A masked pattern was here ####
+PREHOOK: query: CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:tblstatsdb1
+PREHOOK: Output: tblstatsdb1@TESTTABLE2
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:tblstatsdb1
+POSTHOOK: Output: tblstatsdb1@TESTTABLE2
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: tblstatsdb1@testtable2
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: tblstatsdb1@testtable2
+PREHOOK: query: ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: tblstatsdb1@testtable2
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: tblstatsdb1@testtable2
+#### A masked pattern was here ####
+PREHOOK: query: DROP TABLE tblstatsdb1.testtable
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: tblstatsdb1@testtable
+PREHOOK: Output: tblstatsdb1@testtable
+POSTHOOK: query: DROP TABLE tblstatsdb1.testtable
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: tblstatsdb1@testtable
+POSTHOOK: Output: tblstatsdb1@testtable
+PREHOOK: query: DROP TABLE tblstatsdb1.TestTable1
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: tblstatsdb1@testtable1
+PREHOOK: Output: tblstatsdb1@testtable1
+POSTHOOK: query: DROP TABLE tblstatsdb1.TestTable1
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: tblstatsdb1@testtable1
+POSTHOOK: Output: tblstatsdb1@testtable1
+PREHOOK: query: DROP TABLE tblstatsdb1.TESTTABLE2
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: tblstatsdb1@testtable2
+PREHOOK: Output: tblstatsdb1@testtable2
+POSTHOOK: query: DROP TABLE tblstatsdb1.TESTTABLE2
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: tblstatsdb1@testtable2
+POSTHOOK: Output: tblstatsdb1@testtable2
+PREHOOK: query: DROP DATABASE tblstatsdb1
+PREHOOK: type: DROPDATABASE
+PREHOOK: Input: database:tblstatsdb1
+PREHOOK: Output: database:tblstatsdb1
+POSTHOOK: query: DROP DATABASE tblstatsdb1
+POSTHOOK: type: DROPDATABASE
+POSTHOOK: Input: database:tblstatsdb1
+POSTHOOK: Output: database:tblstatsdb1
+PREHOOK: query: CREATE DATABASE IF NOT EXISTS TBLSTATSDB2
+PREHOOK: type: CREATEDATABASE
+PREHOOK: Output: database:TBLSTATSDB2
+POSTHOOK: query: CREATE DATABASE IF NOT EXISTS TBLSTATSDB2
+POSTHOOK: type: CREATEDATABASE
+POSTHOOK: Output: database:TBLSTATSDB2
+PREHOOK: query: USE TBLSTATSDB2
+PREHOOK: type: SWITCHDATABASE
+PREHOOK: Input: database:tblstatsdb2
+POSTHOOK: query: USE TBLSTATSDB2
+POSTHOOK: type: SWITCHDATABASE
+POSTHOOK: Input: database:tblstatsdb2
+PREHOOK: query: CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: TBLSTATSDB2@testtable
+PREHOOK: Output: database:tblstatsdb2
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS testtable (key STRING, value STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: TBLSTATSDB2@testtable
+POSTHOOK: Output: database:tblstatsdb2
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: tblstatsdb2@testtable
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE testtable
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: tblstatsdb2@testtable
+PREHOOK: query: ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: tblstatsdb2@testtable
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE testtable COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: tblstatsdb2@testtable
+#### A masked pattern was here ####
+PREHOOK: query: CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: TBLSTATSDB2@TestTable1
+PREHOOK: Output: database:tblstatsdb2
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS TestTable1 (key STRING, value STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: TBLSTATSDB2@TestTable1
+POSTHOOK: Output: database:tblstatsdb2
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: tblstatsdb2@testtable1
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TestTable1
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: tblstatsdb2@testtable1
+PREHOOK: query: ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: tblstatsdb2@testtable1
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TestTable1 COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: tblstatsdb2@testtable1
+#### A masked pattern was here ####
+PREHOOK: query: CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: TBLSTATSDB2@TESTTABLE2
+PREHOOK: Output: database:tblstatsdb2
+POSTHOOK: query: CREATE TABLE IF NOT EXISTS TESTTABLE2 (key STRING, value STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: TBLSTATSDB2@TESTTABLE2
+POSTHOOK: Output: database:tblstatsdb2
+PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2
+PREHOOK: type: LOAD
+#### A masked pattern was here ####
+PREHOOK: Output: tblstatsdb2@testtable2
+POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/kv1.txt' OVERWRITE INTO TABLE TESTTABLE2
+POSTHOOK: type: LOAD
+#### A masked pattern was here ####
+POSTHOOK: Output: tblstatsdb2@testtable2
+PREHOOK: query: ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key
+PREHOOK: type: QUERY
+PREHOOK: Input: tblstatsdb2@testtable2
+#### A masked pattern was here ####
+POSTHOOK: query: ANALYZE TABLE TESTTABLE2 COMPUTE STATISTICS FOR COLUMNS key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: tblstatsdb2@testtable2
+#### A masked pattern was here ####
+PREHOOK: query: DROP TABLE TBLSTATSDB2.testtable
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: tblstatsdb2@testtable
+PREHOOK: Output: tblstatsdb2@testtable
+POSTHOOK: query: DROP TABLE TBLSTATSDB2.testtable
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: tblstatsdb2@testtable
+POSTHOOK: Output: tblstatsdb2@testtable
+PREHOOK: query: DROP TABLE TBLSTATSDB2.TestTable1
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: tblstatsdb2@testtable1
+PREHOOK: Output: tblstatsdb2@testtable1
+POSTHOOK: query: DROP TABLE TBLSTATSDB2.TestTable1
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: tblstatsdb2@testtable1
+POSTHOOK: Output: tblstatsdb2@testtable1
+PREHOOK: query: DROP TABLE TBLSTATSDB2.TESTTABLE2
+PREHOOK: type: DROPTABLE
+PREHOOK: Input: tblstatsdb2@testtable2
+PREHOOK: Output: tblstatsdb2@testtable2
+POSTHOOK: query: DROP TABLE TBLSTATSDB2.TESTTABLE2
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Input: tblstatsdb2@testtable2
+POSTHOOK: Output: tblstatsdb2@testtable2
+PREHOOK: query: DROP DATABASE TBLSTATSDB2
+PREHOOK: type: DROPDATABASE
+PREHOOK: Input: database:tblstatsdb2
+PREHOOK: Output: database:tblstatsdb2
+POSTHOOK: query: DROP DATABASE TBLSTATSDB2
+POSTHOOK: type: DROPDATABASE
+POSTHOOK: Input: database:tblstatsdb2
+POSTHOOK: Output: database:tblstatsdb2
