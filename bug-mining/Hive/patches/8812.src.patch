diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/security/TokenStoreDelegationTokenSecretManager.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/security/TokenStoreDelegationTokenSecretManager.java
index 01182b8981..a9a2a8d9aa 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/security/TokenStoreDelegationTokenSecretManager.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/security/TokenStoreDelegationTokenSecretManager.java
@@ -105,7 +105,11 @@ public byte[] retrievePassword(DelegationTokenIdentifier identifier) throws Inva
       if (info == null) {
           throw new InvalidToken("token expired or does not exist: " + identifier);
       }
-      renewIfRequired(System.currentTimeMillis(), identifier, info);
+      try {
+        renewIfRequired(identifier, info);
+      } catch (InvalidToken e) {
+        LOGGER.warn("Failed to renew token: " + identifier, e);
+      }
       // we have to fetch the token again as it has been renewed and info still contains the previous renew time.
       info = this.tokenStore.getToken(identifier);
 
@@ -255,7 +259,7 @@ protected void renewOrRemoveExpiredTokens() {
       } else {
         // get token info to check renew date
         try {
-          renewIfRequired(now, id, tokenStore.getToken(id));
+          renewIfRequired(id, tokenStore.getToken(id));
         } catch (InvalidToken e) {
           LOGGER.warn("Failed to renew token: " + id, e);
         }
@@ -263,8 +267,9 @@ protected void renewOrRemoveExpiredTokens() {
     }
   }
 
-  private void renewIfRequired(long currentTime, DelegationTokenIdentifier id, DelegationTokenInformation tokenInfo)
+  public void renewIfRequired(DelegationTokenIdentifier id, DelegationTokenInformation tokenInfo)
           throws InvalidToken {
+    long currentTime = System.currentTimeMillis();
     if (tokenInfo != null) {
       if (currentTime > tokenInfo.getRenewDate() && currentTime < id.getMaxDate()) {
         // This will be the case when now > tokenInfo.getRenewDate() but less than the token expiration/max time.
@@ -273,7 +278,7 @@ private void renewIfRequired(long currentTime, DelegationTokenIdentifier id, Del
           DelegationKey key = getDelegationKey(id.getMasterKeyId());
           Token<DelegationTokenIdentifier> t = new Token<>(id.getBytes(), createPassword(id.getBytes(), key.getKey()),
                   id.getKind(), new Text());
-          renewToken(t, UserGroupInformation.getCurrentUser().getShortUserName());
+          renewToken(t, getTokenIdentifier(t).getRenewer().toString());
         } catch (IOException e) {
           throw new InvalidToken("Unable to renew token: " + id + " due to " + e.getMessage());
         }
diff --git a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/security/TestTokenStoreDelegationTokenSecretManager.java b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/security/TestTokenStoreDelegationTokenSecretManager.java
index ff0997cfdd..c3c6a68c8d 100644
--- a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/security/TestTokenStoreDelegationTokenSecretManager.java
+++ b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/security/TestTokenStoreDelegationTokenSecretManager.java
@@ -92,6 +92,52 @@ private DelegationTokenIdentifier getID(String tokenStr) throws IOException {
     }
   }
 
+  @Test public void testTokenRenewalWithDifferentUsers() throws IOException, InterruptedException {
+    DelegationTokenStore tokenStore = new MemoryTokenStore();
+    // Have a long renewal to ensure that Thread.sleep does not overshoot the initial validity
+    TokenStoreDelegationTokenSecretManager mgr = createTokenMgr(tokenStore, 1, MetastoreConf.getTimeVar(
+            conf, MetastoreConf.ConfVars.DELEGATION_TOKEN_GC_INTERVAL, TimeUnit.SECONDS), MetastoreConf.getTimeVar(conf,
+            MetastoreConf.ConfVars.DELEGATION_TOKEN_MAX_LIFETIME, TimeUnit.SECONDS));
+    try {
+      mgr.startThreads();
+      String tokenStr1 =
+              mgr.getDelegationToken(UserGroupInformation.getCurrentUser().getShortUserName(),
+                      UserGroupInformation.getCurrentUser().getShortUserName());
+      String tokenStr2 =
+              mgr.getDelegationToken("user1", "user1");
+
+      Assert.assertNotNull(mgr.verifyDelegationToken(tokenStr1));
+      Assert.assertNotNull(mgr.verifyDelegationToken(tokenStr2));
+
+      DelegationTokenIdentifier id1 = getID(tokenStr1);
+      DelegationTokenIdentifier id2 = getID(tokenStr2);
+
+      long initialExpiry1 = tokenStore.getToken(id1).getRenewDate();
+      long initialExpiry2 = tokenStore.getToken(id2).getRenewDate();
+
+      Thread.sleep(3000);
+      Assert.assertTrue(System.currentTimeMillis() > id1.getIssueDate());
+      Assert.assertTrue(System.currentTimeMillis() > id2.getIssueDate());
+      // No change in renewal date without renewal
+      Assert.assertEquals(tokenStore.getToken(id1).getRenewDate(), initialExpiry1);
+      Assert.assertEquals(tokenStore.getToken(id2).getRenewDate(), initialExpiry2);
+
+      // Renewal Call
+      mgr.renewIfRequired(id1 ,tokenStore.getToken(id1));
+      mgr.renewIfRequired(id2 ,tokenStore.getToken(id2));
+
+      // Verify the token is valid
+      Assert.assertNotNull(mgr.verifyDelegationToken(tokenStr1));
+      Assert.assertNotNull(mgr.verifyDelegationToken(tokenStr2));
+
+      // Renewal date has increased after renewal
+      Assert.assertTrue(tokenStore.getToken(id1).getRenewDate() > initialExpiry1);
+      Assert.assertTrue(tokenStore.getToken(id2).getRenewDate() > initialExpiry2);
+    } finally {
+      mgr.stopThreads();
+    }
+  }
+
   @Test public void testTokenRenewalAndRemoval() throws IOException, InterruptedException {
     DelegationTokenStore tokenStore = new MemoryTokenStore();
     TokenStoreDelegationTokenSecretManager mgr = createTokenMgr(tokenStore, 2, 1, 8);
