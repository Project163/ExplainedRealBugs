diff --git a/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java b/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
index 57bb53ca3f..906565c1ce 100644
--- a/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
+++ b/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
@@ -111,9 +111,8 @@ public class HiveSessionImpl implements HiveSession {
   // TODO: the control flow for this needs to be defined. Hive is supposed to be thread-local.
   private Hive sessionHive;
 
-  private volatile long lastAccessTime;
-  private volatile long lastIdleTime;
-  private volatile int activeCalls = 0;
+  private volatile long lastAccessTime = System.currentTimeMillis();
+  private volatile boolean lockedByUser;
   private final Semaphore operationLock;
 
 
@@ -184,7 +183,6 @@ public void open(Map<String, String> sessionConfMap) throws HiveSQLException {
       configureSession(sessionConfMap);
     }
     lastAccessTime = System.currentTimeMillis();
-    lastIdleTime = lastAccessTime;
   }
 
 /**
@@ -384,12 +382,11 @@ private synchronized void acquireAfterOpLock(boolean userAccess) {
     sessionState.setIsUsingThriftJDBCBinarySerDe(updateIsUsingThriftJDBCBinarySerDe());
     if (userAccess) {
       lastAccessTime = System.currentTimeMillis();
+      lockedByUser = true;
     }
     // set the thread name with the logging prefix.
     sessionState.updateThreadName();
     Hive.set(sessionHive);
-    activeCalls++;
-    lastIdleTime = 0;
   }
 
   /**
@@ -424,12 +421,7 @@ private synchronized void releaseBeforeOpLock(boolean userAccess) {
     }
     if (userAccess) {
       lastAccessTime = System.currentTimeMillis();
-    }
-    activeCalls--;
-    // lastIdleTime is only set by the last one
-    // who calls release with empty opHandleSet.
-    if (activeCalls == 0 && opHandleSet.isEmpty()) {
-      lastIdleTime = System.currentTimeMillis();
+      lockedByUser = false;
     }
   }
 
@@ -830,16 +822,18 @@ public void closeExpiredOperations() {
 
   @Override
   public long getNoOperationTime() {
-    return lastIdleTime > 0 ? System.currentTimeMillis() - lastIdleTime : 0;
+    boolean noMoreOpHandle = false;
+    synchronized (opHandleSet) {
+      noMoreOpHandle = opHandleSet.isEmpty();
+    }
+    return noMoreOpHandle && !lockedByUser ? System.currentTimeMillis() - lastAccessTime : 0;
   }
 
   private void closeTimedOutOperations(List<Operation> operations) {
     acquire(false, false);
     try {
       for (Operation operation : operations) {
-        synchronized (opHandleSet) {
-          opHandleSet.remove(operation.getHandle());
-        }
+        removeOpHandle(operation.getHandle());
         try {
           operation.close();
         } catch (Exception e) {
