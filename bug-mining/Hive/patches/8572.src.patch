diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
index ed89836903..6315d74885 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
@@ -1345,9 +1345,7 @@ private void processCTE(QB qb, ASTNode ctes, Map<String, CTEClause> aliasToCTEs)
       ASTNode cteQry = (ASTNode) cte.getChild(0);
       String alias = unescapeIdentifier(cte.getChild(1).getText());
       ASTNode withColList = cte.getChildCount() == 3 ? (ASTNode) cte.getChild(2) : null;
-
-      String qName = qb.getId() == null ? "" : qb.getId() + ":";
-      qName += alias.toLowerCase();
+      String qName = getAliasId(alias, qb);
 
       if ( aliasToCTEs.containsKey(qName)) {
         throw new SemanticException(ASTErrorUtils.getMsg(
@@ -2241,11 +2239,6 @@ private void gatherCTEReferences(QB qb, CTEClause current,
 
       CTEClause cte = findCTEFromName(qb, cteName, materializationAliasToCTEs);
       if (cte != null) {
-        if (ctesExpanded.contains(cteName)) {
-          throw new SemanticException("Recursive cte " + cteName +
-              " detected (cycle: " + StringUtils.join(ctesExpanded, " -> ") +
-              " -> " + cteName + ").");
-        }
         cte.reference++;
         current.parents.add(cte);
         if (cte.qbExpr != null) {
@@ -2253,10 +2246,7 @@ private void gatherCTEReferences(QB qb, CTEClause current,
         }
         cte.qbExpr = new QBExpr(cteName);
         doPhase1QBExpr(cte.cteNode, cte.qbExpr, qb.getId(), cteName, cte.withColList, materializationAliasToCTEs);
-
-        ctesExpanded.add(cteName);
         gatherCTEReferences(cte.qbExpr, cte, materializationAliasToCTEs);
-        ctesExpanded.remove(ctesExpanded.size() - 1);
       }
     }
     for (String alias : qb.getSubqAliases()) {
@@ -2267,6 +2257,20 @@ private void gatherCTEReferences(QB qb, CTEClause current,
     }
   }
 
+  private void checkRecursiveCTE(CTEClause current, Set<String> path) throws SemanticException {
+
+    for (CTEClause child : current.parents) {
+      if (path.contains(child.alias)) {
+        throw new SemanticException("Recursive cte " + child.alias +
+            " detected (cycle: " + StringUtils.join(path, " -> ") +
+            " -> " + child.alias + ").");
+      }
+      path.add(child.alias);
+      checkRecursiveCTE(child, path);
+      path.remove(child.alias);
+    }
+  }
+
   void getMetaData(QB qb) throws SemanticException {
     getMetaData(qb, false);
   }
@@ -2277,6 +2281,7 @@ private void getMetaData(QB qb, boolean enableMaterialization) throws SemanticEx
       if (enableMaterialization) {
         materializationAliasToCTEs = getMaterializationMetadata(qb);
       }
+      checkRecursiveCTE(rootClause, new HashSet<>());
       getMetaData(qb, null);
       if (materializationAliasToCTEs != null && !materializationAliasToCTEs.isEmpty()) {
         this.aliasToCTEs.putAll(materializationAliasToCTEs);
diff --git a/ql/src/test/queries/clientpositive/nested_ctes.q b/ql/src/test/queries/clientpositive/nested_ctes.q
index e68adb8420..5337f1504b 100644
--- a/ql/src/test/queries/clientpositive/nested_ctes.q
+++ b/ql/src/test/queries/clientpositive/nested_ctes.q
@@ -5,6 +5,7 @@ with
         select 1
     )
 select * from test1;
+
 with
     test2 as (
         with
@@ -36,3 +37,14 @@ with
         select * from t1
     )
 select * from test4;
+
+with
+    q1 as (
+        with t3 as (select 1)
+        select * from t3
+    ),
+    q2 as (
+        with t3 as (select * from q1)
+        select * from t3
+    )
+select * from q2;
diff --git a/ql/src/test/results/clientpositive/llap/nested_ctes.q.out b/ql/src/test/results/clientpositive/llap/nested_ctes.q.out
index 0b771699b5..fda998825b 100644
--- a/ql/src/test/results/clientpositive/llap/nested_ctes.q.out
+++ b/ql/src/test/results/clientpositive/llap/nested_ctes.q.out
@@ -100,3 +100,30 @@ select * from test4
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@table_1
 #### A masked pattern was here ####
+PREHOOK: query: with
+    q1 as (
+        with t3 as (select 1)
+        select * from t3
+    ),
+    q2 as (
+        with t3 as (select * from q1)
+        select * from t3
+    )
+select * from q2
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+POSTHOOK: query: with
+    q1 as (
+        with t3 as (select 1)
+        select * from t3
+    ),
+    q2 as (
+        with t3 as (select * from q1)
+        select * from t3
+    )
+select * from q2
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+1
