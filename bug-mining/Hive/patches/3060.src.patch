diff --git a/service/src/java/org/apache/hive/service/cli/session/HiveSession.java b/service/src/java/org/apache/hive/service/cli/session/HiveSession.java
index 6359a5b879..45e0e96a92 100644
--- a/service/src/java/org/apache/hive/service/cli/session/HiveSession.java
+++ b/service/src/java/org/apache/hive/service/cli/session/HiveSession.java
@@ -27,7 +27,7 @@
 
 public interface HiveSession extends HiveSessionBase {
 
-  void open();
+  void open(Map<String, String> sessionConfMap) throws Exception;
 
   IMetaStoreClient getMetaStoreClient() throws HiveSQLException;
 
diff --git a/service/src/java/org/apache/hive/service/cli/session/HiveSessionBase.java b/service/src/java/org/apache/hive/service/cli/session/HiveSessionBase.java
index 50094d2626..9b04d679df 100644
--- a/service/src/java/org/apache/hive/service/cli/session/HiveSessionBase.java
+++ b/service/src/java/org/apache/hive/service/cli/session/HiveSessionBase.java
@@ -54,12 +54,6 @@ public interface HiveSessionBase {
    */
   void setOperationManager(OperationManager operationManager);
 
-  /**
-   * Initialize the session
-   * @param sessionConfMap
-   */
-  void initialize(Map<String, String> sessionConfMap) throws Exception;
-
   /**
    * Check whether operation logging is enabled and session dir is created successfully
    */
diff --git a/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java b/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
index cabf32a8ad..5b8e6de0b6 100644
--- a/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
+++ b/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
@@ -47,7 +47,15 @@
 import org.apache.hadoop.hive.shims.ShimLoader;
 import org.apache.hive.common.util.HiveVersionInfo;
 import org.apache.hive.service.auth.HiveAuthFactory;
-import org.apache.hive.service.cli.*;
+import org.apache.hive.service.cli.FetchOrientation;
+import org.apache.hive.service.cli.FetchType;
+import org.apache.hive.service.cli.GetInfoType;
+import org.apache.hive.service.cli.GetInfoValue;
+import org.apache.hive.service.cli.HiveSQLException;
+import org.apache.hive.service.cli.OperationHandle;
+import org.apache.hive.service.cli.RowSet;
+import org.apache.hive.service.cli.SessionHandle;
+import org.apache.hive.service.cli.TableSchema;
 import org.apache.hive.service.cli.operation.ExecuteStatementOperation;
 import org.apache.hive.service.cli.operation.GetCatalogsOperation;
 import org.apache.hive.service.cli.operation.GetColumnsOperation;
@@ -66,26 +74,20 @@
  *
  */
 public class HiveSessionImpl implements HiveSession {
-
   private final SessionHandle sessionHandle;
-
   private String username;
   private final String password;
   private HiveConf hiveConf;
-  private final SessionState sessionState;
+  private SessionState sessionState;
   private String ipAddress;
-
   private static final String FETCH_WORK_SERDE_CLASS =
       "org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe";
   private static final Log LOG = LogFactory.getLog(HiveSessionImpl.class);
-
-
   private SessionManager sessionManager;
   private OperationManager operationManager;
   private final Set<OperationHandle> opHandleSet = new HashSet<OperationHandle>();
   private boolean isOperationLogEnabled;
   private File sessionLogDir;
-
   private volatile long lastAccessTime;
 
   public HiveSessionImpl(TProtocolVersion protocol, String username, String password,
@@ -106,7 +108,6 @@ public HiveSessionImpl(TProtocolVersion protocol, String username, String passwo
     } catch (IOException e) {
       LOG.warn("Error setting scheduler queue: " + e, e);
     }
-
     // Set an explicit session name to control the download directory name
     hiveConf.set(ConfVars.HIVESESSIONID.varname,
         sessionHandle.getHandleIdentifier().toString());
@@ -114,37 +115,36 @@ public HiveSessionImpl(TProtocolVersion protocol, String username, String passwo
     hiveConf.set(ListSinkOperator.OUTPUT_FORMATTER,
         FetchFormatter.ThriftFormatter.class.getName());
     hiveConf.setInt(ListSinkOperator.OUTPUT_PROTOCOL, protocol.getValue());
+  }
 
-    /**
-     * Create a new SessionState object that will be associated with this HiveServer2 session.
-     * When the server executes multiple queries in the same session,
-     * this SessionState object is reused across multiple queries.
-     */
+  @Override
+  /**
+   * Opens a new HiveServer2 session for the client connection.
+   * Creates a new SessionState object that will be associated with this HiveServer2 session.
+   * When the server executes multiple queries in the same session,
+   * this SessionState object is reused across multiple queries.
+   * Note that if doAs is true, this call goes through a proxy object,
+   * which wraps the method logic in a UserGroupInformation#doAs.
+   * That's why it is important to create SessionState here rather than in the constructor.
+   */
+  public void open(Map<String, String> sessionConfMap) throws HiveSQLException {
     sessionState = new SessionState(hiveConf, username);
     sessionState.setUserIpAddress(ipAddress);
     sessionState.setIsHiveServerQuery(true);
-
-    lastAccessTime = System.currentTimeMillis();
     SessionState.start(sessionState);
-  }
-
-  @Override
-  public void initialize(Map<String, String> sessionConfMap) throws Exception {
-    // Process global init file: .hiverc
-    processGlobalInitFile();
     try {
       sessionState.reloadAuxJars();
     } catch (IOException e) {
-      String msg = "fail to load reloadable jar file path" + e;
+      String msg = "Failed to load reloadable jar file path: " + e;
       LOG.error(msg, e);
-      throw new Exception(msg, e);
+      throw new HiveSQLException(msg, e);
     }
-    SessionState.setCurrentSessionState(sessionState);
-
-    // Set conf properties specified by user from client side
+    // Process global init file: .hiverc
+    processGlobalInitFile();
     if (sessionConfMap != null) {
       configureSession(sessionConfMap);
     }
+    lastAccessTime = System.currentTimeMillis();
   }
 
   /**
@@ -199,12 +199,16 @@ private void processGlobalInitFile() {
     }
   }
 
-  private void configureSession(Map<String, String> sessionConfMap) throws Exception {
+  private void configureSession(Map<String, String> sessionConfMap) throws HiveSQLException {
     SessionState.setCurrentSessionState(sessionState);
     for (Map.Entry<String, String> entry : sessionConfMap.entrySet()) {
       String key = entry.getKey();
       if (key.startsWith("set:")) {
-        SetProcessor.setVariable(key.substring(4), entry.getValue());
+        try {
+          SetProcessor.setVariable(key.substring(4), entry.getValue());
+        } catch (Exception e) {
+          throw new HiveSQLException(e);
+        }
       } else if (key.startsWith("use:")) {
         SessionState.get().setCurrentDatabase(entry.getValue());
       } else {
@@ -217,7 +221,6 @@ private void configureSession(Map<String, String> sessionConfMap) throws Excepti
   public void setOperationLogSessionDir(File operationLogRootDir) {
     sessionLogDir = new File(operationLogRootDir, sessionHandle.getHandleIdentifier().toString());
     isOperationLogEnabled = true;
-
     if (!sessionLogDir.exists()) {
       if (!sessionLogDir.mkdir()) {
         LOG.warn("Unable to create operation log session directory: " +
@@ -225,7 +228,6 @@ public void setOperationLogSessionDir(File operationLogRootDir) {
         isOperationLogEnabled = false;
       }
     }
-
     if (isOperationLogEnabled) {
       LOG.info("Operation log session directory is created: " + sessionLogDir.getAbsolutePath());
     }
@@ -265,19 +267,8 @@ public void setOperationManager(OperationManager operationManager) {
     this.operationManager = operationManager;
   }
 
-  @Override
-  /**
-   * Opens a new HiveServer2 session for the client connection.
-   * Note that if doAs is true, this call goes through a proxy object,
-   * which wraps the method logic in a UserGroupInformation#doAs.
-   * That is why it is important to call SessionState#start here rather than the constructor.
-   */
-  public void open() {
-    SessionState.start(sessionState);
-  }
-
   protected synchronized void acquire(boolean userAccess) {
-    // Need to make sure that the this HiveServer2's session's session state is
+    // Need to make sure that the this HiveServer2's session's SessionState is
     // stored in the thread local for the handler thread.
     SessionState.setCurrentSessionState(sessionState);
     if (userAccess) {
@@ -556,7 +547,6 @@ public void close() throws HiveSQLException {
       opHandleSet.clear();
       // Cleanup session log directory.
       cleanupSessionLogDir();
-
       HiveHistory hiveHist = sessionState.getHiveHistory();
       if (null != hiveHist) {
         hiveHist.closeStream();
diff --git a/service/src/java/org/apache/hive/service/cli/session/HiveSessionImplwithUGI.java b/service/src/java/org/apache/hive/service/cli/session/HiveSessionImplwithUGI.java
index 7acd11318a..a29e5d1d81 100644
--- a/service/src/java/org/apache/hive/service/cli/session/HiveSessionImplwithUGI.java
+++ b/service/src/java/org/apache/hive/service/cli/session/HiveSessionImplwithUGI.java
@@ -97,20 +97,25 @@ protected synchronized void acquire(boolean userAccess) {
   }
 
   /**
-   * close the file systems for the session
-   * cancel the session's delegation token and close the metastore connection
+   * Close the file systems for the session and remove it from the FileSystem cache.
+   * Cancel the session's delegation token and close the metastore connection
    */
   @Override
   public void close() throws HiveSQLException {
     try {
-    acquire(true);
-    FileSystem.closeAllForUGI(sessionUgi);
-    cancelDelegationToken();
-    } catch (IOException ioe) {
-      LOG.error("Could not clean up file-system handles for UGI: " + sessionUgi, ioe);
+      acquire(true);
+      cancelDelegationToken();
     } finally {
-      release(true);
-      super.close();
+      try {
+        super.close();
+      } finally {
+        try {
+          FileSystem.closeAllForUGI(sessionUgi);
+        } catch (IOException ioe) {
+          throw new HiveSQLException("Could not clean up file-system handles for UGI: "
+              + sessionUgi, ioe);
+        }
+      }
     }
   }
 
diff --git a/service/src/java/org/apache/hive/service/cli/session/SessionManager.java b/service/src/java/org/apache/hive/service/cli/session/SessionManager.java
index 137359bd2a..16a6ddbc1b 100644
--- a/service/src/java/org/apache/hive/service/cli/session/SessionManager.java
+++ b/service/src/java/org/apache/hive/service/cli/session/SessionManager.java
@@ -267,22 +267,19 @@ public SessionHandle openSession(TProtocolVersion protocol, String username, Str
     session.setSessionManager(this);
     session.setOperationManager(operationManager);
     try {
-      session.initialize(sessionConf);
-      if (isOperationLogEnabled) {
-        session.setOperationLogSessionDir(operationLogRootDir);
-      }
-      session.open();
+      session.open(sessionConf);
     } catch (Exception e) {
-      throw new HiveSQLException("Failed to open new session", e);
+      throw new HiveSQLException("Failed to open new session: " + e, e);
+    }
+    if (isOperationLogEnabled) {
+      session.setOperationLogSessionDir(operationLogRootDir);
     }
     try {
       executeSessionHooks(session);
     } catch (Exception e) {
       throw new HiveSQLException("Failed to execute session hooks", e);
     }
-
     handleToSession.put(session.getSessionHandle(), session);
-
     return session.getSessionHandle();
   }
 
