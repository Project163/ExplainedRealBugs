diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/BaseSemanticAnalyzer.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/BaseSemanticAnalyzer.java
index 2a96d1858f..5e69ec5cef 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/BaseSemanticAnalyzer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/BaseSemanticAnalyzer.java
@@ -57,6 +57,7 @@
 import org.apache.hadoop.hive.ql.metadata.Partition;
 import org.apache.hadoop.hive.ql.metadata.Table;
 import org.apache.hadoop.hive.ql.plan.PlanUtils;
+import org.apache.hadoop.hive.ql.session.SessionState;
 import org.apache.hadoop.hive.ql.session.SessionState.LogHelper;
 import org.apache.hadoop.hive.serde.serdeConstants;
 import org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe;
@@ -322,28 +323,30 @@ public static String charSetString(String charSetName, String charSetString)
   }
 
   /**
-   * Get the name from a table node.
-   * @param tableNameNode the table node
-   * @return if DB name is give, db.tab is returned. Otherwise, tab.
+   * Get dequoted name from a table/column node.
+   * @param tableOrColumnNode the table or column node
+   * @return for table node, db.tab or tab. for column node column.
    */
-  public static String getUnescapedName(ASTNode tableNameNode) {
-    return getUnescapedName(tableNameNode, false);
+  public static String getUnescapedName(ASTNode tableOrColumnNode) {
+    return getUnescapedName(tableOrColumnNode, null);
   }
 
-  public static String getUnescapedName(ASTNode tableNameNode, boolean prependDefaultDB) {
-    if (tableNameNode.getToken().getType() == HiveParser.TOK_TABNAME) {
-      if (tableNameNode.getChildCount() == 2) {
-        String dbName = unescapeIdentifier(tableNameNode.getChild(0).getText());
-        String tableName = unescapeIdentifier(tableNameNode.getChild(1).getText());
+  public static String getUnescapedName(ASTNode tableOrColumnNode, String currentDatabase) {
+    if (tableOrColumnNode.getToken().getType() == HiveParser.TOK_TABNAME) {
+      // table node
+      if (tableOrColumnNode.getChildCount() == 2) {
+        String dbName = unescapeIdentifier(tableOrColumnNode.getChild(0).getText());
+        String tableName = unescapeIdentifier(tableOrColumnNode.getChild(1).getText());
         return dbName + "." + tableName;
       }
-      String tableName = unescapeIdentifier(tableNameNode.getChild(0).getText());
-      if (prependDefaultDB) {
-        return MetaStoreUtils.DEFAULT_DATABASE_NAME + "." + tableName;
+      String tableName = unescapeIdentifier(tableOrColumnNode.getChild(0).getText());
+      if (currentDatabase != null) {
+        return currentDatabase + "." + tableName;
       }
       return tableName;
     }
-    return unescapeIdentifier(tableNameNode.getText());
+    // column node
+    return unescapeIdentifier(tableOrColumnNode.getText());
   }
 
   /**
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
index 230cb39a4d..330aa520ae 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
@@ -704,7 +704,8 @@ public boolean doPhase1(ASTNode ast, QB qb, Phase1Ctx ctx_1)
         break;
 
       case HiveParser.TOK_INSERT_INTO:
-        String tab_name = getUnescapedName((ASTNode)ast.getChild(0).getChild(0), true);
+        String currentDatabase = db.getCurrentDatabase();
+        String tab_name = getUnescapedName((ASTNode)ast.getChild(0).getChild(0), currentDatabase);
         qbp.addInsertIntoTable(tab_name);
 
       case HiveParser.TOK_DESTINATION:
@@ -946,7 +947,7 @@ public void getMetaData(QB qb) throws SemanticException {
         }
 
         // Disallow INSERT INTO on bucketized tables
-        if(qb.getParseInfo().isInsertIntoTable(tab.getDbName(), tab_name) &&
+        if(qb.getParseInfo().isInsertIntoTable(tab.getDbName(), tab.getTableName()) &&
             tab.getNumBuckets() > 0) {
           throw new SemanticException(ErrorMsg.INSERT_INTO_BUCKETIZED_TABLE.
               getMsg("Table: " + tab_name));
diff --git a/ql/src/test/queries/clientpositive/insert1.q b/ql/src/test/queries/clientpositive/insert1.q
index a992e69b62..90acbc26f6 100644
--- a/ql/src/test/queries/clientpositive/insert1.q
+++ b/ql/src/test/queries/clientpositive/insert1.q
@@ -19,3 +19,18 @@ explain
 from insert2
 insert into table insert1 select * where key < 10
 insert overwrite table x.insert1 select * where key > 10 and key < 20;
+
+-- HIVE-3676
+CREATE DATABASE db2;
+USE db2;
+CREATE TABLE result(col1 STRING);
+INSERT OVERWRITE TABLE result SELECT 'db2_insert1' FROM default.src LIMIT 1;
+INSERT INTO TABLE result SELECT 'db2_insert2' FROM default.src LIMIT 1;
+SELECT * FROM result;
+
+USE default;
+CREATE DATABASE db1;
+CREATE TABLE db1.result(col1 STRING);
+INSERT OVERWRITE TABLE db1.result SELECT 'db1_insert1' FROM src LIMIT 1;
+INSERT INTO TABLE db1.result SELECT 'db1_insert2' FROM src LIMIT 1;
+SELECT * FROM db1.result;
diff --git a/ql/src/test/results/clientpositive/insert1.q.out b/ql/src/test/results/clientpositive/insert1.q.out
index c047eafca8..1add50e83a 100644
--- a/ql/src/test/results/clientpositive/insert1.q.out
+++ b/ql/src/test/results/clientpositive/insert1.q.out
@@ -624,3 +624,129 @@ STAGE PLANS:
 #### A masked pattern was here ####
 
 
+PREHOOK: query: -- HIVE-3676
+CREATE DATABASE db2
+PREHOOK: type: CREATEDATABASE
+POSTHOOK: query: -- HIVE-3676
+CREATE DATABASE db2
+POSTHOOK: type: CREATEDATABASE
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+PREHOOK: query: USE db2
+PREHOOK: type: SWITCHDATABASE
+POSTHOOK: query: USE db2
+POSTHOOK: type: SWITCHDATABASE
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+PREHOOK: query: CREATE TABLE result(col1 STRING)
+PREHOOK: type: CREATETABLE
+POSTHOOK: query: CREATE TABLE result(col1 STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: db2@result
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+PREHOOK: query: INSERT OVERWRITE TABLE result SELECT 'db2_insert1' FROM default.src LIMIT 1
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+PREHOOK: Output: db2@result
+POSTHOOK: query: INSERT OVERWRITE TABLE result SELECT 'db2_insert1' FROM default.src LIMIT 1
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+POSTHOOK: Output: db2@result
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: result.col1 SIMPLE []
+PREHOOK: query: INSERT INTO TABLE result SELECT 'db2_insert2' FROM default.src LIMIT 1
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+PREHOOK: Output: db2@result
+POSTHOOK: query: INSERT INTO TABLE result SELECT 'db2_insert2' FROM default.src LIMIT 1
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+POSTHOOK: Output: db2@result
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+PREHOOK: query: SELECT * FROM result
+PREHOOK: type: QUERY
+PREHOOK: Input: db2@result
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT * FROM result
+POSTHOOK: type: QUERY
+POSTHOOK: Input: db2@result
+#### A masked pattern was here ####
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+db2_insert1
+db2_insert2
+PREHOOK: query: USE default
+PREHOOK: type: SWITCHDATABASE
+POSTHOOK: query: USE default
+POSTHOOK: type: SWITCHDATABASE
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+PREHOOK: query: CREATE DATABASE db1
+PREHOOK: type: CREATEDATABASE
+POSTHOOK: query: CREATE DATABASE db1
+POSTHOOK: type: CREATEDATABASE
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+PREHOOK: query: CREATE TABLE db1.result(col1 STRING)
+PREHOOK: type: CREATETABLE
+POSTHOOK: query: CREATE TABLE db1.result(col1 STRING)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: db1@result
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+PREHOOK: query: INSERT OVERWRITE TABLE db1.result SELECT 'db1_insert1' FROM src LIMIT 1
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+PREHOOK: Output: db1@result
+POSTHOOK: query: INSERT OVERWRITE TABLE db1.result SELECT 'db1_insert1' FROM src LIMIT 1
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+POSTHOOK: Output: db1@result
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+PREHOOK: query: INSERT INTO TABLE db1.result SELECT 'db1_insert2' FROM src LIMIT 1
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+PREHOOK: Output: db1@result
+POSTHOOK: query: INSERT INTO TABLE db1.result SELECT 'db1_insert2' FROM src LIMIT 1
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+POSTHOOK: Output: db1@result
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+PREHOOK: query: SELECT * FROM db1.result
+PREHOOK: type: QUERY
+PREHOOK: Input: db1@result
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT * FROM db1.result
+POSTHOOK: type: QUERY
+POSTHOOK: Input: db1@result
+#### A masked pattern was here ####
+POSTHOOK: Lineage: insert1.key SIMPLE [(insert2)a.FieldSchema(name:key, type:int, comment:null), ]
+POSTHOOK: Lineage: insert1.value SIMPLE [(insert2)a.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+POSTHOOK: Lineage: result.col1 SIMPLE []
+db1_insert1
+db1_insert2
