diff --git a/hcatalog/core/src/main/java/org/apache/hive/hcatalog/common/HiveClientCache.java b/hcatalog/core/src/main/java/org/apache/hive/hcatalog/common/HiveClientCache.java
index 730b6ef953..ffa648d0aa 100644
--- a/hcatalog/core/src/main/java/org/apache/hive/hcatalog/common/HiveClientCache.java
+++ b/hcatalog/core/src/main/java/org/apache/hive/hcatalog/common/HiveClientCache.java
@@ -24,6 +24,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -44,6 +45,7 @@
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.RemovalListener;
 import com.google.common.cache.RemovalNotification;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 
 /**
  * A thread safe time expired cache for HiveMetaStoreClient
@@ -59,7 +61,7 @@ class HiveClientCache {
 
   private static final AtomicInteger nextId = new AtomicInteger(0);
 
-  private ScheduledFuture<?> cleanupHandle; // used to cleanup cache
+  private final ScheduledFuture<?> cleanupHandle; // used to cleanup cache
 
   // Since HiveMetaStoreClient is not threadsafe, hive clients are not  shared across threads.
   // Thread local variable containing each thread's unique ID, is used as one of the keys for the cache
@@ -91,6 +93,7 @@ public HiveClientCache(final int timeout) {
     this.timeout = timeout;
     RemovalListener<HiveClientCacheKey, CacheableHiveMetaStoreClient> removalListener =
       new RemovalListener<HiveClientCacheKey, CacheableHiveMetaStoreClient>() {
+        @Override
         public void onRemoval(RemovalNotification<HiveClientCacheKey, CacheableHiveMetaStoreClient> notification) {
           CacheableHiveMetaStoreClient hiveMetaStoreClient = notification.getValue();
           if (hiveMetaStoreClient != null) {
@@ -108,6 +111,7 @@ public void onRemoval(RemovalNotification<HiveClientCacheKey, CacheableHiveMetaS
 
     // Add a maintenance thread that will attempt to trigger a cache clean continuously
     Runnable cleanupThread = new Runnable() {
+      @Override
       public void run() {
         hiveCache.cleanUp();
       }
@@ -134,7 +138,10 @@ public void run() {
      * 5 seconds after the first timeout, and then after that, it'll check for whether or not
      * it can be cleaned every max(DEFAULT_HIVE_CACHE_EXPIRY_TIME_SECONDS,timeout) seconds
      */
-    cleanupHandle = Executors.newScheduledThreadPool(1).scheduleWithFixedDelay(
+    ThreadFactory daemonThreadFactory = (new ThreadFactoryBuilder()).setDaemon(true)
+        .setNameFormat("HiveClientCache-cleaner-%d").build();
+
+    cleanupHandle = Executors.newScheduledThreadPool(1, daemonThreadFactory).scheduleWithFixedDelay(
         cleanupThread,
         timeout + 5, cleanupInterval, TimeUnit.SECONDS);
 
@@ -285,7 +292,7 @@ public int hashCode() {
    * Add # of current users on HiveMetaStoreClient, so that the client can be cleaned when no one is using it.
    */
   public static class CacheableHiveMetaStoreClient extends HiveMetaStoreClient {
-    private AtomicInteger users = new AtomicInteger(0);
+    private final AtomicInteger users = new AtomicInteger(0);
     private volatile boolean expiredFromCache = false;
     private boolean isClosed = false;
     private final long expiryTime;
