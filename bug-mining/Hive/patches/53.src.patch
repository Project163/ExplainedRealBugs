diff --git a/CHANGES.txt b/CHANGES.txt
index e2aa5e734f..db8baab1eb 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -205,3 +205,6 @@ Trunk (unreleased changes)
 
     HIVE-230.  Fix for a Null Pointer Exception that occured while loading a 
     table from a query that returns empty data.  (Prasad Chakka via dhruba)
+
+    HIVE-232. Metastore.warehouse configuration should use inherited 
+    hadoop configuration (Prasad Chakka via dhruba)
diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/Warehouse.java b/metastore/src/java/org/apache/hadoop/hive/metastore/Warehouse.java
index 5fdccd2ea6..f2c683d846 100755
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/Warehouse.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/Warehouse.java
@@ -20,6 +20,7 @@
 
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.net.URI;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -52,6 +53,12 @@ public Warehouse(Configuration conf) throws MetaException {
       throw new MetaException(HiveConf.ConfVars.METASTOREWAREHOUSE.varname + " is not set in the config or blank");
     }
     whRoot = new Path(whRootString);
+    URI uri = whRoot.toUri();
+    // if the METASTOREWAREHOUSE value doesn't have schema and authority specified then inherit
+    // from fs.default.name in hadoop-site.xml 
+    if ((uri.getScheme() == null) && (uri.getAuthority() == null)) {
+      whRoot = new Path(HiveConf.getVar(conf, HiveConf.ConfVars.HADOOPFS), whRootString);
+    }
     try {
       fs  = whRoot.getFileSystem(conf);
     } catch (IOException e) {
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/LoadSemanticAnalyzer.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/LoadSemanticAnalyzer.java
index 96051a60b2..4a0b275ab1 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/LoadSemanticAnalyzer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/LoadSemanticAnalyzer.java
@@ -62,8 +62,6 @@ public LoadSemanticAnalyzer(HiveConf conf) throws SemanticException {
   }
 
   private URI initializeFromURI(String fromPath) throws IOException {
-    // TODO: support hdfs relative path names by defaulting to /user/<user.name>
-
     Path p = new Path(fromPath);
     URI fromURI = p.toUri();
 
@@ -74,16 +72,17 @@ private URI initializeFromURI(String fromPath) throws IOException {
       if(isLocal) {
         if(!fromPath.startsWith("/")) {
           // generate absolute path relative to current directory
-          p = new Path(new Path("file://"+System.getProperty("user.dir")), fromPath);
-        } else {
-          p = new Path("file://"+fromPath);
+          p = new Path(System.getProperty("user.dir"), fromPath);
         }
-        fromURI = p.toUri();
         fromScheme = "file";
+      } else {
+        if(!fromPath.startsWith("/") && StringUtils.isEmpty(fromURI.getAuthority()) ) {
+          // generate absolute path relative to current directory
+          p = new Path(new Path("/user/"+System.getProperty("user.name")), fromPath);
+        }
       }
     }
 
-
     fs = FileSystem.get(fromURI, conf);
     String fromAuthority = null;
 
@@ -100,7 +99,7 @@ private URI initializeFromURI(String fromPath) throws IOException {
     }
 
     try {
-      fromURI = new URI(fromScheme, fromAuthority, fromURI.getPath(), null, null);
+      fromURI = new URI(fromScheme, fromAuthority, p.toString(), null, null);
     } catch (URISyntaxException e) {
       throw new RuntimeException (e);
     }
