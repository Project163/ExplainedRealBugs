diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/tez/TezTask.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/tez/TezTask.java
index 3d276323f5..b086fc0d58 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/tez/TezTask.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/tez/TezTask.java
@@ -578,6 +578,11 @@ DAGClient submit(DAG dag, Ref<TezSessionState> sessionStateRef) throws Exception
         dagClient = sessionState.getSession().submitDAG(dag);
       }
     } catch (Exception e) {
+      if (this.isShutdown) {
+        // Incase of taskShutdown, no need to retry
+        sessionDestroyOrReturnToPool(sessionStateRef, sessionState);
+        throw e;
+      }
       // In case of any other exception, retry. If this also fails, report original error and exit.
       try {
         console.printInfo("Dag submit failed due to " + e.getMessage() + " stack trace: "
@@ -588,12 +593,7 @@ DAGClient submit(DAG dag, Ref<TezSessionState> sessionStateRef) throws Exception
         // we failed to submit after retrying.
         // If this is a non-pool session, destroy it.
         // Otherwise move it to sessionPool, reopen will retry.
-        sessionStateRef.value = null;
-        if (sessionState.isDefault() && sessionState instanceof TezSessionPoolSession) {
-          sessionState.returnToSessionManager();
-        } else {
-          sessionState.destroy();
-        }
+        sessionDestroyOrReturnToPool(sessionStateRef, sessionState);
         throw retryException;
       }
     }
@@ -602,6 +602,16 @@ DAGClient submit(DAG dag, Ref<TezSessionState> sessionStateRef) throws Exception
     return new SyncDagClient(dagClient);
   }
 
+  private void sessionDestroyOrReturnToPool(Ref<TezSessionState> sessionStateRef,
+      TezSessionState sessionState) throws Exception{
+    sessionStateRef.value = null;
+    if (sessionState.isDefault() && sessionState instanceof TezSessionPoolSession) {
+      sessionState.returnToSessionManager();
+    } else {
+      sessionState.destroy();
+    }
+  }
+
   /*
    * close will move the temp files into the right place for the fetch
    * task. If the job has failed it will clean up the files.
