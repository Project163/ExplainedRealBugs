diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/type/RexNodeExprFactory.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/type/RexNodeExprFactory.java
index a57203878d..ee8779188d 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/type/RexNodeExprFactory.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/type/RexNodeExprFactory.java
@@ -165,22 +165,23 @@ protected RexNode createColumnRefExpr(ColumnInfo colInfo, List<RowResolver> rowR
 
   private int getPosition(ColumnInfo colInfo, List<RowResolver> rowResolverList)
       throws SemanticException {
-    ColumnInfo tmp;
-    ColumnInfo cInfoToRet = null;
     int position = 0;
-    for (RowResolver rr : rowResolverList) {
-      tmp = rr.get(colInfo.getTabAlias(), colInfo.getAlias());
-      if (tmp != null) {
-        if (cInfoToRet != null) {
-          throw new CalciteSemanticException("Could not resolve column name");
-        }
-        cInfoToRet = tmp;
-        position += rr.getPosition(cInfoToRet.getInternalName());
-      } else if (cInfoToRet == null) {
+
+    for (RowResolver rr: rowResolverList) {
+      ColumnInfo tmp = rr.get(colInfo.getTabAlias(), colInfo.getAlias());
+      if (tmp == null) {
+        // if column is not present in the RR, increment position by size of RR
         position += rr.getColumnInfos().size();
+      } else {
+        // if column is present, increment position by the position of the column in RR
+        // and return early.
+        position += rr.getPosition(tmp.getInternalName());
+        return position;
       }
     }
-    return position;
+
+    // If we are out of the for loop, then the column is not present in any RR
+    throw new CalciteSemanticException("Could not resolve column name");
   }
 
   /**
diff --git a/ql/src/test/queries/clientpositive/subquery_join.q b/ql/src/test/queries/clientpositive/subquery_join.q
new file mode 100644
index 0000000000..f9dc9795e0
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/subquery_join.q
@@ -0,0 +1,17 @@
+create table t1 (id int);
+create table t2 (id int);
+
+explain cbo select id,
+  (select count(*) from t1 join t2 on t1.id=t2.id)
+  from t2
+order by id;
+
+explain cbo select id,
+  (select count(*) from t1 join t2 using (id))
+  from t2
+order by id;
+
+explain cbo select id,
+  (select count(*) from t1 join t2 where t1.id=t2.id)
+  from t2
+order by id;
diff --git a/ql/src/test/results/clientpositive/llap/subquery_join.q.out b/ql/src/test/results/clientpositive/llap/subquery_join.q.out
new file mode 100644
index 0000000000..737a2cab39
--- /dev/null
+++ b/ql/src/test/results/clientpositive/llap/subquery_join.q.out
@@ -0,0 +1,115 @@
+PREHOOK: query: create table t1 (id int)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:default
+PREHOOK: Output: default@t1
+POSTHOOK: query: create table t1 (id int)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:default
+POSTHOOK: Output: default@t1
+PREHOOK: query: create table t2 (id int)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:default
+PREHOOK: Output: default@t2
+POSTHOOK: query: create table t2 (id int)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:default
+POSTHOOK: Output: default@t2
+Warning: Shuffle Join MERGEJOIN[38][tables = [$hdt$_0, $hdt$_1]] in Stage 'Reducer 2' is a cross product
+PREHOOK: query: explain cbo select id,
+  (select count(*) from t1 join t2 on t1.id=t2.id)
+  from t2
+order by id
+PREHOOK: type: QUERY
+PREHOOK: Input: default@t1
+PREHOOK: Input: default@t2
+#### A masked pattern was here ####
+POSTHOOK: query: explain cbo select id,
+  (select count(*) from t1 join t2 on t1.id=t2.id)
+  from t2
+order by id
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@t1
+POSTHOOK: Input: default@t2
+#### A masked pattern was here ####
+CBO PLAN:
+HiveSortLimit(sort0=[$0], dir0=[ASC])
+  HiveProject(id=[$0], $f0=[$1])
+    HiveJoin(condition=[true], joinType=[left], algorithm=[none], cost=[not available])
+      HiveProject(id=[$0])
+        HiveTableScan(table=[[default, t2]], table:alias=[t2])
+      HiveProject($f0=[$0])
+        HiveAggregate(group=[{}], agg#0=[count()])
+          HiveJoin(condition=[=($0, $1)], joinType=[inner], algorithm=[none], cost=[not available])
+            HiveProject(id=[$0])
+              HiveFilter(condition=[IS NOT NULL($0)])
+                HiveTableScan(table=[[default, t1]], table:alias=[t1])
+            HiveProject(id=[$0])
+              HiveFilter(condition=[IS NOT NULL($0)])
+                HiveTableScan(table=[[default, t2]], table:alias=[t2])
+
+Warning: Shuffle Join MERGEJOIN[38][tables = [$hdt$_0, $hdt$_1]] in Stage 'Reducer 2' is a cross product
+PREHOOK: query: explain cbo select id,
+  (select count(*) from t1 join t2 using (id))
+  from t2
+order by id
+PREHOOK: type: QUERY
+PREHOOK: Input: default@t1
+PREHOOK: Input: default@t2
+#### A masked pattern was here ####
+POSTHOOK: query: explain cbo select id,
+  (select count(*) from t1 join t2 using (id))
+  from t2
+order by id
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@t1
+POSTHOOK: Input: default@t2
+#### A masked pattern was here ####
+CBO PLAN:
+HiveSortLimit(sort0=[$0], dir0=[ASC])
+  HiveProject(id=[$0], $f0=[$1])
+    HiveJoin(condition=[true], joinType=[left], algorithm=[none], cost=[not available])
+      HiveProject(id=[$0])
+        HiveTableScan(table=[[default, t2]], table:alias=[t2])
+      HiveProject($f0=[$0])
+        HiveAggregate(group=[{}], agg#0=[count()])
+          HiveJoin(condition=[=($0, $1)], joinType=[inner], algorithm=[none], cost=[not available])
+            HiveProject(id=[$0])
+              HiveFilter(condition=[IS NOT NULL($0)])
+                HiveTableScan(table=[[default, t1]], table:alias=[t1])
+            HiveProject(id=[$0])
+              HiveFilter(condition=[IS NOT NULL($0)])
+                HiveTableScan(table=[[default, t2]], table:alias=[t2])
+
+Warning: Shuffle Join MERGEJOIN[38][tables = [$hdt$_0, $hdt$_1]] in Stage 'Reducer 2' is a cross product
+PREHOOK: query: explain cbo select id,
+  (select count(*) from t1 join t2 where t1.id=t2.id)
+  from t2
+order by id
+PREHOOK: type: QUERY
+PREHOOK: Input: default@t1
+PREHOOK: Input: default@t2
+#### A masked pattern was here ####
+POSTHOOK: query: explain cbo select id,
+  (select count(*) from t1 join t2 where t1.id=t2.id)
+  from t2
+order by id
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@t1
+POSTHOOK: Input: default@t2
+#### A masked pattern was here ####
+CBO PLAN:
+HiveSortLimit(sort0=[$0], dir0=[ASC])
+  HiveProject(id=[$0], $f0=[$1])
+    HiveJoin(condition=[true], joinType=[left], algorithm=[none], cost=[not available])
+      HiveProject(id=[$0])
+        HiveTableScan(table=[[default, t2]], table:alias=[t2])
+      HiveProject($f0=[$0])
+        HiveAggregate(group=[{}], agg#0=[count()])
+          HiveJoin(condition=[=($0, $1)], joinType=[inner], algorithm=[none], cost=[not available])
+            HiveProject(id=[$0])
+              HiveFilter(condition=[IS NOT NULL($0)])
+                HiveTableScan(table=[[default, t1]], table:alias=[t1])
+            HiveProject(id=[$0])
+              HiveFilter(condition=[IS NOT NULL($0)])
+                HiveTableScan(table=[[default, t2]], table:alias=[t2])
+
