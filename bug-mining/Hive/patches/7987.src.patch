diff --git a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/BucketVersionPopulator.java b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/BucketVersionPopulator.java
index fa8df98923..b5087e5038 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/optimizer/BucketVersionPopulator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/optimizer/BucketVersionPopulator.java
@@ -19,6 +19,7 @@
 package org.apache.hadoop.hive.ql.optimizer;
 
 import java.util.ArrayList;
+import java.util.Comparator;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -131,22 +132,47 @@ private OpGroup newGroup(NodeProcessorCtx procCtx) {
     }
   }
 
+  enum InfoType {
+    MANDATORY, OPTIONAL,
+  };
+
   /**
    * This class represents the version required by an Operator.
    */
-  private static class OperatorBucketingVersionInfo {
+  static class OperatorBucketingVersionInfo {
+
+    public static final Comparator<OperatorBucketingVersionInfo> MANDATORY_FIRST =
+        new Comparator<BucketVersionPopulator.OperatorBucketingVersionInfo>() {
 
+          @Override
+          public int compare(OperatorBucketingVersionInfo i1, OperatorBucketingVersionInfo i2) {
+            int r = i1.infoType.compareTo(i2.infoType);
+            if (r != 0) {
+              // mandatory first
+              return r;
+            }
+            r = Integer.compare(i2.bucketingVersion, i1.bucketingVersion);
+            if (r != 0) {
+              // prefer higher version if avail
+              return r;
+            }
+            r = i1.op.toString().compareTo(i2.op.toString());
+            return r;
+          }
+        };
     private Operator<?> op;
     private int bucketingVersion;
+    private InfoType infoType;
 
-    public OperatorBucketingVersionInfo(Operator<?> op, int bucketingVersion) {
+    public OperatorBucketingVersionInfo(Operator<?> op, InfoType infoType, int bucketingVersion) {
       this.op = op;
+      this.infoType = infoType;
       this.bucketingVersion = bucketingVersion;
     }
 
     @Override
     public String toString() {
-      return String.format("[op: %s, bucketingVersion=%d]", op, bucketingVersion);
+      return String.format("[op: %s, bucketingVersion=%d, infoType=%s]", op, bucketingVersion, infoType);
     }
   }
 
@@ -179,7 +205,7 @@ List<OperatorBucketingVersionInfo> getBucketingVersions() {
           int bucketingVersion = tso.getConf().getTableMetadata().getBucketingVersion();
           int numBuckets = tso.getConf().getNumBuckets();
           if (numBuckets > 1) {
-            ret.add(new OperatorBucketingVersionInfo(operator, bucketingVersion));
+            ret.add(new OperatorBucketingVersionInfo(operator, InfoType.MANDATORY, bucketingVersion));
           } else {
             LOG.info("not considering bucketingVersion for: {} because it has {}<2 buckets ", tso, numBuckets);
           }
@@ -187,7 +213,9 @@ List<OperatorBucketingVersionInfo> getBucketingVersions() {
         if (operator instanceof FileSinkOperator) {
           FileSinkOperator fso = (FileSinkOperator) operator;
           int bucketingVersion = fso.getConf().getTableInfo().getBucketingVersion();
-          ret.add(new OperatorBucketingVersionInfo(operator, bucketingVersion));
+          // for FileSinkOperator-s keeping the RS side in sync w.r.t to the bucketing version is beneficial
+          // but since they are internally compute the bucket number with the correct algo they don't rely on it.
+          ret.add(new OperatorBucketingVersionInfo(operator, InfoType.OPTIONAL, bucketingVersion));
         }
       }
       return ret;
@@ -195,9 +223,10 @@ List<OperatorBucketingVersionInfo> getBucketingVersions() {
 
     public void analyzeBucketVersion() {
       List<OperatorBucketingVersionInfo> bucketingVersions = getBucketingVersions();
+      bucketingVersions.sort(OperatorBucketingVersionInfo.MANDATORY_FIRST);
       try {
         for (OperatorBucketingVersionInfo info : bucketingVersions) {
-          setVersion(info.bucketingVersion);
+          setVersion(info);
         }
       } catch (Exception e) {
         throw new RuntimeException("Error setting bucketingVersion for group: " + bucketingVersions, e);
@@ -208,7 +237,8 @@ public void analyzeBucketVersion() {
       }
     }
 
-    private void setVersion(int newVersion) {
+    private void setVersion(OperatorBucketingVersionInfo info) {
+      int newVersion = info.bucketingVersion;
       if (version == newVersion || newVersion == -1) {
         return;
       }
@@ -216,6 +246,10 @@ private void setVersion(int newVersion) {
         version = newVersion;
         return;
       }
+      if (info.infoType == InfoType.OPTIONAL) {
+        LOG.debug("Ignoring version preference for {}; because {} is already set and its OPTIONAL", info.op, version);
+        return;
+      }
       throw new RuntimeException("Unable to set version");
     }
 
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/optimizer/TestBucketVersionPopulator.java b/ql/src/test/org/apache/hadoop/hive/ql/optimizer/TestBucketVersionPopulator.java
new file mode 100644
index 0000000000..00ba4a071b
--- /dev/null
+++ b/ql/src/test/org/apache/hadoop/hive/ql/optimizer/TestBucketVersionPopulator.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.ql.optimizer;
+
+import static org.junit.Assert.assertEquals;
+import java.util.ArrayList;
+
+import org.apache.hadoop.hive.ql.CompilationOpContext;
+import org.apache.hadoop.hive.ql.exec.Operator;
+import org.apache.hadoop.hive.ql.exec.OperatorFactory;
+import org.apache.hadoop.hive.ql.optimizer.BucketVersionPopulator.InfoType;
+import org.apache.hadoop.hive.ql.optimizer.BucketVersionPopulator.OperatorBucketingVersionInfo;
+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;
+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;
+import org.apache.hadoop.hive.ql.plan.FilterDesc;
+import org.apache.hadoop.hive.ql.plan.OperatorDesc;
+import org.junit.Test;
+
+public class TestBucketVersionPopulator {
+
+  CompilationOpContext cCtx = new CompilationOpContext();
+
+  @Test
+  public void testVersionInfoSort() {
+
+    ArrayList<OperatorBucketingVersionInfo> arr = new ArrayList<>();
+    OperatorBucketingVersionInfo opt2 = buildInfo(InfoType.OPTIONAL, 2);
+    OperatorBucketingVersionInfo opt1 = buildInfo(InfoType.OPTIONAL, 1);
+    OperatorBucketingVersionInfo mand2 = buildInfo(InfoType.MANDATORY, 2);
+    OperatorBucketingVersionInfo mand1 = buildInfo(InfoType.MANDATORY, 1);
+    arr.add(opt2);
+    arr.add(opt1);
+    arr.add(mand2);
+    arr.add(mand1);
+    arr.sort(OperatorBucketingVersionInfo.MANDATORY_FIRST);
+
+    assertEquals(arr.get(0), mand2);
+    assertEquals(arr.get(1), mand1);
+    assertEquals(arr.get(2), opt2);
+    assertEquals(arr.get(3), opt1);
+  }
+
+  private OperatorBucketingVersionInfo buildInfo(InfoType optional, int version) {
+    return new OperatorBucketingVersionInfo(getOp(), optional, version);
+  }
+
+  private Operator<? extends OperatorDesc> getOp() {
+    ExprNodeDesc pred = new ExprNodeConstantDesc(1);
+    FilterDesc fd = new FilterDesc(pred, true);
+    Operator<? extends OperatorDesc> op = OperatorFactory.get(cCtx, fd);
+    return op;
+  }
+
+}
diff --git a/ql/src/test/queries/clientpositive/multi_insert_bucketing_version.q b/ql/src/test/queries/clientpositive/multi_insert_bucketing_version.q
new file mode 100644
index 0000000000..a7d4c6e6b7
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/multi_insert_bucketing_version.q
@@ -0,0 +1,17 @@
+
+drop table if exists t;
+drop table if exists t2;
+drop table if exists t3;
+create table t (a integer);
+create table t2 (a integer);
+create table t3 (a integer);
+alter table t set tblproperties ('bucketing_version'='1');
+alter table t2 set tblproperties ('bucketing_version'='2');
+alter table t3 set tblproperties ('bucketing_version'='2');
+
+-- this should be allowed: we may write to t,t2 locations from the same operator group since they both are non-bucketed tables
+explain
+from t3
+insert into t select a
+insert into t2 select a;
+
diff --git a/ql/src/test/results/clientpositive/llap/multi_insert_bucketing_version.q.out b/ql/src/test/results/clientpositive/llap/multi_insert_bucketing_version.q.out
new file mode 100644
index 0000000000..6ac6530f89
--- /dev/null
+++ b/ql/src/test/results/clientpositive/llap/multi_insert_bucketing_version.q.out
@@ -0,0 +1,232 @@
+PREHOOK: query: drop table if exists t
+PREHOOK: type: DROPTABLE
+POSTHOOK: query: drop table if exists t
+POSTHOOK: type: DROPTABLE
+PREHOOK: query: drop table if exists t2
+PREHOOK: type: DROPTABLE
+POSTHOOK: query: drop table if exists t2
+POSTHOOK: type: DROPTABLE
+PREHOOK: query: drop table if exists t3
+PREHOOK: type: DROPTABLE
+POSTHOOK: query: drop table if exists t3
+POSTHOOK: type: DROPTABLE
+PREHOOK: query: create table t (a integer)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:default
+PREHOOK: Output: default@t
+POSTHOOK: query: create table t (a integer)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:default
+POSTHOOK: Output: default@t
+PREHOOK: query: create table t2 (a integer)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:default
+PREHOOK: Output: default@t2
+POSTHOOK: query: create table t2 (a integer)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:default
+POSTHOOK: Output: default@t2
+PREHOOK: query: create table t3 (a integer)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:default
+PREHOOK: Output: default@t3
+POSTHOOK: query: create table t3 (a integer)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:default
+POSTHOOK: Output: default@t3
+PREHOOK: query: alter table t set tblproperties ('bucketing_version'='1')
+PREHOOK: type: ALTERTABLE_PROPERTIES
+PREHOOK: Input: default@t
+PREHOOK: Output: default@t
+POSTHOOK: query: alter table t set tblproperties ('bucketing_version'='1')
+POSTHOOK: type: ALTERTABLE_PROPERTIES
+POSTHOOK: Input: default@t
+POSTHOOK: Output: default@t
+PREHOOK: query: alter table t2 set tblproperties ('bucketing_version'='2')
+PREHOOK: type: ALTERTABLE_PROPERTIES
+PREHOOK: Input: default@t2
+PREHOOK: Output: default@t2
+POSTHOOK: query: alter table t2 set tblproperties ('bucketing_version'='2')
+POSTHOOK: type: ALTERTABLE_PROPERTIES
+POSTHOOK: Input: default@t2
+POSTHOOK: Output: default@t2
+PREHOOK: query: alter table t3 set tblproperties ('bucketing_version'='2')
+PREHOOK: type: ALTERTABLE_PROPERTIES
+PREHOOK: Input: default@t3
+PREHOOK: Output: default@t3
+POSTHOOK: query: alter table t3 set tblproperties ('bucketing_version'='2')
+POSTHOOK: type: ALTERTABLE_PROPERTIES
+POSTHOOK: Input: default@t3
+POSTHOOK: Output: default@t3
+PREHOOK: query: explain
+from t3
+insert into t select a
+insert into t2 select a
+PREHOOK: type: QUERY
+PREHOOK: Input: default@t3
+PREHOOK: Output: default@t
+PREHOOK: Output: default@t2
+POSTHOOK: query: explain
+from t3
+insert into t select a
+insert into t2 select a
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@t3
+POSTHOOK: Output: default@t
+POSTHOOK: Output: default@t2
+STAGE DEPENDENCIES:
+  Stage-2 is a root stage
+  Stage-3 depends on stages: Stage-2
+  Stage-0 depends on stages: Stage-3
+  Stage-4 depends on stages: Stage-0
+  Stage-1 depends on stages: Stage-3
+  Stage-5 depends on stages: Stage-1
+
+STAGE PLANS:
+  Stage: Stage-2
+    Tez
+#### A masked pattern was here ####
+      Edges:
+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)
+        Reducer 3 <- Map 1 (CUSTOM_SIMPLE_EDGE)
+#### A masked pattern was here ####
+      Vertices:
+        Map 1 
+            Map Operator Tree:
+                TableScan
+                  alias: t3
+                  Statistics: Num rows: 1 Data size: 4 Basic stats: COMPLETE Column stats: NONE
+                  Select Operator
+                    expressions: a (type: int)
+                    outputColumnNames: _col0
+                    Statistics: Num rows: 1 Data size: 4 Basic stats: COMPLETE Column stats: NONE
+                    File Output Operator
+                      compressed: false
+                      Statistics: Num rows: 1 Data size: 4 Basic stats: COMPLETE Column stats: NONE
+                      table:
+                          input format: org.apache.hadoop.mapred.TextInputFormat
+                          output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
+                          serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
+                          name: default.t
+                    Select Operator
+                      expressions: _col0 (type: int)
+                      outputColumnNames: a
+                      Statistics: Num rows: 1 Data size: 4 Basic stats: COMPLETE Column stats: NONE
+                      Group By Operator
+                        aggregations: min(a), max(a), count(1), count(a), compute_bit_vector_hll(a)
+                        minReductionHashAggr: 0.99
+                        mode: hash
+                        outputColumnNames: _col0, _col1, _col2, _col3, _col4
+                        Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                        Reduce Output Operator
+                          null sort order: 
+                          sort order: 
+                          Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                          value expressions: _col0 (type: int), _col1 (type: int), _col2 (type: bigint), _col3 (type: bigint), _col4 (type: binary)
+                  Select Operator
+                    expressions: a (type: int)
+                    outputColumnNames: _col0
+                    Statistics: Num rows: 1 Data size: 4 Basic stats: COMPLETE Column stats: NONE
+                    File Output Operator
+                      compressed: false
+                      Statistics: Num rows: 1 Data size: 4 Basic stats: COMPLETE Column stats: NONE
+                      table:
+                          input format: org.apache.hadoop.mapred.TextInputFormat
+                          output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
+                          serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
+                          name: default.t2
+                    Select Operator
+                      expressions: _col0 (type: int)
+                      outputColumnNames: a
+                      Statistics: Num rows: 1 Data size: 4 Basic stats: COMPLETE Column stats: NONE
+                      Group By Operator
+                        aggregations: min(a), max(a), count(1), count(a), compute_bit_vector_hll(a)
+                        minReductionHashAggr: 0.99
+                        mode: hash
+                        outputColumnNames: _col0, _col1, _col2, _col3, _col4
+                        Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                        Reduce Output Operator
+                          null sort order: 
+                          sort order: 
+                          Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                          value expressions: _col0 (type: int), _col1 (type: int), _col2 (type: bigint), _col3 (type: bigint), _col4 (type: binary)
+            Execution mode: vectorized, llap
+            LLAP IO: all inputs
+        Reducer 2 
+            Execution mode: vectorized, llap
+            Reduce Operator Tree:
+              Group By Operator
+                aggregations: min(VALUE._col0), max(VALUE._col1), count(VALUE._col2), count(VALUE._col3), compute_bit_vector_hll(VALUE._col4)
+                mode: mergepartial
+                outputColumnNames: _col0, _col1, _col2, _col3, _col4
+                Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                Select Operator
+                  expressions: 'LONG' (type: string), UDFToLong(_col0) (type: bigint), UDFToLong(_col1) (type: bigint), (_col2 - _col3) (type: bigint), COALESCE(ndv_compute_bit_vector(_col4),0) (type: bigint), _col4 (type: binary)
+                  outputColumnNames: _col0, _col1, _col2, _col3, _col4, _col5
+                  Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                  File Output Operator
+                    compressed: false
+                    Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                    table:
+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat
+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
+        Reducer 3 
+            Execution mode: vectorized, llap
+            Reduce Operator Tree:
+              Group By Operator
+                aggregations: min(VALUE._col0), max(VALUE._col1), count(VALUE._col2), count(VALUE._col3), compute_bit_vector_hll(VALUE._col4)
+                mode: mergepartial
+                outputColumnNames: _col0, _col1, _col2, _col3, _col4
+                Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                Select Operator
+                  expressions: 'LONG' (type: string), UDFToLong(_col0) (type: bigint), UDFToLong(_col1) (type: bigint), (_col2 - _col3) (type: bigint), COALESCE(ndv_compute_bit_vector(_col4),0) (type: bigint), _col4 (type: binary)
+                  outputColumnNames: _col0, _col1, _col2, _col3, _col4, _col5
+                  Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                  File Output Operator
+                    compressed: false
+                    Statistics: Num rows: 1 Data size: 172 Basic stats: COMPLETE Column stats: NONE
+                    table:
+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat
+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
+
+  Stage: Stage-3
+    Dependency Collection
+
+  Stage: Stage-0
+    Move Operator
+      tables:
+          replace: false
+          table:
+              input format: org.apache.hadoop.mapred.TextInputFormat
+              output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
+              serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
+              name: default.t
+
+  Stage: Stage-4
+    Stats Work
+      Basic Stats Work:
+      Column Stats Desc:
+          Columns: a
+          Column Types: int
+          Table: default.t
+
+  Stage: Stage-1
+    Move Operator
+      tables:
+          replace: false
+          table:
+              input format: org.apache.hadoop.mapred.TextInputFormat
+              output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
+              serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
+              name: default.t2
+
+  Stage: Stage-5
+    Stats Work
+      Basic Stats Work:
+      Column Stats Desc:
+          Columns: a
+          Column Types: int
+          Table: default.t2
+
