diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/type/TypeCheckProcFactory.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/type/TypeCheckProcFactory.java
index 318d0c8779..f8b50ca6c2 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/type/TypeCheckProcFactory.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/type/TypeCheckProcFactory.java
@@ -998,19 +998,12 @@ protected T getXpathOrFuncExprNodeDesc(ASTNode node,
           // different value type. The reason is that Hive and Calcite treat
           // types in IN clauses differently and it is practically impossible
           // to find some correct implementation unless this is done.
-          boolean hasNullValue = false;
           ListMultimap<TypeInfo, T> expressions = ArrayListMultimap.create();
           for (int i = 1; i < children.size(); i++) {
             T columnDesc = children.get(0);
             T valueDesc = interpretNode(columnDesc, children.get(i));
-            if (valueDesc == null) {
-              // Keep original
-              TypeInfo targetType = exprFactory.getTypeInfo(children.get(i));
-              if (!expressions.containsKey(targetType)) {
-                expressions.put(targetType, columnDesc);
-              }
-              expressions.put(targetType, children.get(i));
-            } else {
+            if (valueDesc != null) {
+              // Only add to the expression map if types can be coerced
               TypeInfo targetType = exprFactory.getTypeInfo(valueDesc);
               if (!expressions.containsKey(targetType)) {
                 expressions.put(targetType, columnDesc);
@@ -1018,6 +1011,14 @@ protected T getXpathOrFuncExprNodeDesc(ASTNode node,
               expressions.put(targetType, valueDesc);
             }
           }
+          if(expressions.isEmpty()) {
+            // We will only hit this when none of the operands inside the "in" clause can be type-coerced
+            // That would imply that the result of "in" is a boolean "false"
+            // This should not impact those cases where the "in" clause is used on a boolean column and
+            // there is no operand in the "in" clause that cannot be type-coerced into boolean because
+            // in case of boolean, Hive does not allow such use cases and throws an error
+            return exprFactory.createBooleanConstantExpr("false");
+          }
 
           children.clear();
           List<T> newExprs = new ArrayList<>();
diff --git a/ql/src/test/queries/clientpositive/not_in_scenarios.q b/ql/src/test/queries/clientpositive/not_in_scenarios.q
new file mode 100644
index 0000000000..6d614bd2c0
--- /dev/null
+++ b/ql/src/test/queries/clientpositive/not_in_scenarios.q
@@ -0,0 +1,8 @@
+CREATE TABLE my_tbl (id int);
+insert into my_tbl values (100),(200),(300);
+select * from my_tbl where id not in ('ABC', 'DEF');
+select * from my_tbl where id not in ('ABC', 'DEF', '123');
+select * from my_tbl where id not in ('ABC', 'DEF', '100');
+select * from my_tbl where id not in (100, 'ABC', 200);
+select * from my_tbl where id is not null or id in ("ABC");
+select * from my_tbl where id is not null and id in ("ABC");
\ No newline at end of file
diff --git a/ql/src/test/results/clientpositive/llap/in_coercion.q.out b/ql/src/test/results/clientpositive/llap/in_coercion.q.out
index fe784ef6ec..95fc240397 100644
--- a/ql/src/test/results/clientpositive/llap/in_coercion.q.out
+++ b/ql/src/test/results/clientpositive/llap/in_coercion.q.out
@@ -31,10 +31,12 @@ POSTHOOK: Input: default@src_table
 NULL
 PREHOOK: query: select count(*) from src_table where key in (355.8)
 PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
 PREHOOK: Input: default@src_table
 #### A masked pattern was here ####
 POSTHOOK: query: select count(*) from src_table where key in (355.8)
 POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
 POSTHOOK: Input: default@src_table
 #### A masked pattern was here ####
 0
diff --git a/ql/src/test/results/clientpositive/llap/not_in_scenarios.q.out b/ql/src/test/results/clientpositive/llap/not_in_scenarios.q.out
new file mode 100644
index 0000000000..3ca9fa6edd
--- /dev/null
+++ b/ql/src/test/results/clientpositive/llap/not_in_scenarios.q.out
@@ -0,0 +1,77 @@
+PREHOOK: query: CREATE TABLE my_tbl (id int)
+PREHOOK: type: CREATETABLE
+PREHOOK: Output: database:default
+PREHOOK: Output: default@my_tbl
+POSTHOOK: query: CREATE TABLE my_tbl (id int)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: database:default
+POSTHOOK: Output: default@my_tbl
+PREHOOK: query: insert into my_tbl values (100),(200),(300)
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+PREHOOK: Output: default@my_tbl
+POSTHOOK: query: insert into my_tbl values (100),(200),(300)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+POSTHOOK: Output: default@my_tbl
+POSTHOOK: Lineage: my_tbl.id SCRIPT []
+PREHOOK: query: select * from my_tbl where id not in ('ABC', 'DEF')
+PREHOOK: type: QUERY
+PREHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+POSTHOOK: query: select * from my_tbl where id not in ('ABC', 'DEF')
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+100
+200
+300
+PREHOOK: query: select * from my_tbl where id not in ('ABC', 'DEF', '123')
+PREHOOK: type: QUERY
+PREHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+POSTHOOK: query: select * from my_tbl where id not in ('ABC', 'DEF', '123')
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+100
+200
+300
+PREHOOK: query: select * from my_tbl where id not in ('ABC', 'DEF', '100')
+PREHOOK: type: QUERY
+PREHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+POSTHOOK: query: select * from my_tbl where id not in ('ABC', 'DEF', '100')
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+200
+300
+PREHOOK: query: select * from my_tbl where id not in (100, 'ABC', 200)
+PREHOOK: type: QUERY
+PREHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+POSTHOOK: query: select * from my_tbl where id not in (100, 'ABC', 200)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+300
+PREHOOK: query: select * from my_tbl where id is not null or id in ("ABC")
+PREHOOK: type: QUERY
+PREHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+POSTHOOK: query: select * from my_tbl where id is not null or id in ("ABC")
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+100
+200
+300
+PREHOOK: query: select * from my_tbl where id is not null and id in ("ABC")
+PREHOOK: type: QUERY
+PREHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
+POSTHOOK: query: select * from my_tbl where id is not null and id in ("ABC")
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@my_tbl
+#### A masked pattern was here ####
diff --git a/ql/src/test/results/clientpositive/llap/orc_llap_counters.q.out b/ql/src/test/results/clientpositive/llap/orc_llap_counters.q.out
index 7d28a27438..49210d080b 100644
--- a/ql/src/test/results/clientpositive/llap/orc_llap_counters.q.out
+++ b/ql/src/test/results/clientpositive/llap/orc_llap_counters.q.out
@@ -922,12 +922,12 @@ Stage-1 HIVE COUNTERS:
    RECORDS_OUT_0: 1
    RECORDS_OUT_INTERMEDIATE_Map_1: 0
    RECORDS_OUT_INTERMEDIATE_Reducer_2: 0
-   RECORDS_OUT_OPERATOR_FIL_7: 0
-   RECORDS_OUT_OPERATOR_FS_9: 1
-   RECORDS_OUT_OPERATOR_GBY_8: 1
+   RECORDS_OUT_OPERATOR_FIL_8: 0
+   RECORDS_OUT_OPERATOR_FS_12: 1
+   RECORDS_OUT_OPERATOR_GBY_11: 1
    RECORDS_OUT_OPERATOR_MAP_0: 0
-   RECORDS_OUT_OPERATOR_RS_3: 0
-   RECORDS_OUT_OPERATOR_SEL_2: 0
+   RECORDS_OUT_OPERATOR_RS_10: 0
+   RECORDS_OUT_OPERATOR_SEL_9: 0
    RECORDS_OUT_OPERATOR_TS_0: 0
    TOTAL_TABLE_ROWS_WRITTEN: 0
 Stage-1 LLAP IO COUNTERS:
