diff --git a/common/src/java/org/apache/hadoop/hive/common/type/Date.java b/common/src/java/org/apache/hadoop/hive/common/type/Date.java
index 0f47ba513d..024ab56608 100644
--- a/common/src/java/org/apache/hadoop/hive/common/type/Date.java
+++ b/common/src/java/org/apache/hadoop/hive/common/type/Date.java
@@ -84,7 +84,7 @@ public class Date implements Comparable<Date> {
   private static final LocalDate EPOCH = LocalDate.of(1970, 1, 1);
 
   private static final DateTimeFormatter PARSE_FORMATTER =
-      new DateTimeFormatterBuilder().appendValue(YEAR, 1, 10, SignStyle.NORMAL).appendLiteral('-')
+      new DateTimeFormatterBuilder().appendValue(YEAR, 1, 4, SignStyle.NORMAL).appendLiteral('-')
           .appendValue(MONTH_OF_YEAR, 1, 2, SignStyle.NORMAL).appendLiteral('-')
           .appendValue(DAY_OF_MONTH, 1, 2, SignStyle.NORMAL).toFormatter().withResolverStyle(ResolverStyle.STRICT);
 
@@ -177,13 +177,22 @@ public void setTimeInMillis(long epochMilli) {
    * @throws NullPointerException if {@code text} is null
    */
   public static Date valueOf(final String text) {
-    String s = Objects.requireNonNull(text).trim();
+    String trimedText = Objects.requireNonNull(text).trim();
     ParsePosition pos = new ParsePosition(0);
     try {
-      TemporalAccessor t = PARSE_FORMATTER.parseUnresolved(s, pos);
+      TemporalAccessor t = PARSE_FORMATTER.parse(trimedText, pos);
       if (pos.getErrorIndex() >= 0) {
-        throw new DateTimeParseException("Text could not be parsed to date", s, pos.getErrorIndex());
+        throw new DateTimeParseException("Text could not be parsed to date", trimedText, pos.getErrorIndex());
       }
+      //Check if there is still text left after parsing
+      if(pos.getIndex() < trimedText.length()) {
+        char lastChar = trimedText.charAt(pos.getIndex());
+        //Check if the first character of the remaining is a digit, e.g. "2023-08-0800" if yes, then it is a parse error and must throw an exception
+        if (lastChar >= '0' && lastChar <= '9'){
+          throw new DateTimeParseException("Text '" + trimedText + "' could not be parsed, unparsed text found at index " + pos.getIndex(), trimedText,
+              pos.getIndex());
+        }
+      }  
       return new Date(LocalDate.of(t.get(YEAR), t.get(MONTH_OF_YEAR), t.get(DAY_OF_MONTH)));
     } catch (DateTimeException e) {
       throw new IllegalArgumentException("Cannot create date, parsing error");
diff --git a/common/src/test/org/apache/hive/common/util/TestDateParser.java b/common/src/test/org/apache/hive/common/util/TestDateParser.java
index f492ad52ea..95271fe75a 100644
--- a/common/src/test/org/apache/hive/common/util/TestDateParser.java
+++ b/common/src/test/org/apache/hive/common/util/TestDateParser.java
@@ -45,37 +45,29 @@ void checkInvalidCase(String strValue) {
 
   @Test
   public void testValidCases() throws Exception {
-    checkValidCase("1945-12-31", Date.valueOf("1945-12-31"));
-    checkValidCase("1946-01-01", Date.valueOf("1946-01-01"));
-    checkValidCase("2001-11-12", Date.valueOf("2001-11-12"));
-    checkValidCase("0004-05-06", Date.valueOf("0004-05-06"));
-    checkValidCase("1678-09-10", Date.valueOf("1678-09-10"));
-    checkValidCase("9999-10-11", Date.valueOf("9999-10-11"));
+    checkValidCase("1945-12-31", Date.of(1945,12,31));
+    checkValidCase("1946-01-01", Date.of(1946,1,1));
+    checkValidCase("2001-11-12", Date.of(2001,11,12));
+    checkValidCase("0004-05-06", Date.of(4,5,6));
+    checkValidCase("1678-09-10", Date.of(1678,9,10));
+    checkValidCase("9999-10-11", Date.of(9999,10,11));
 
     // Timestamp strings should parse ok
-    checkValidCase("2001-11-12 01:02:03", Date.valueOf("2001-11-12"));
+    checkValidCase("2001-11-12 01:02:03", Date.of(2001,11,12));
 
     // Leading spaces
-    checkValidCase(" 1946-01-01", Date.valueOf("1946-01-01"));
-    checkValidCase(" 2001-11-12 01:02:03", Date.valueOf("2001-11-12"));
+    checkValidCase(" 1946-01-01", Date.of(1946,01,01));
+    checkValidCase(" 2001-11-12 01:02:03", Date.of(2001,11,12));
   }
 
   @Test
   public void testParseDateFromTimestampWithCommonTimeDelimiter() {
-    for (String d : new String[] { "T", " ", "-", ".", "_", "" }) {
+    for (String d : new String[] { "T", " ", "-", ".", "_" }) {
       String ts = "2023-08-03" + d + "01:02:03";
       assertEquals("Parsing " + ts, Date.of(2023, 8, 3), DateParser.parseDate(ts));
     }
   }
 
-  @Test
-  public void testParseDateFromValidDateLiteralWithTrailingDigits() {
-    assertEquals(Date.of(2023, 8, 8), DateParser.parseDate("2023-08-0800"));
-    // The result may seem unexpected but for many "08-08-20" is a valid date so there is no reason to reject
-    // "08-08-2023" and return null unless in the future Hive becomes stricter in terms of parsing dates.
-    assertEquals(Date.of(8, 8, 20), DateParser.parseDate("08-08-2023"));
-  }
-
   @Test
   public void testInvalidCases() throws Exception {
     checkInvalidCase("2001");
@@ -86,5 +78,8 @@ public void testInvalidCases() throws Exception {
     checkInvalidCase("0000-00-00");
     checkInvalidCase("2001-13-12");
     checkInvalidCase("2001-11-31");
+    checkInvalidCase("19999-10-11");
+    checkInvalidCase("08-08-2023");
+    checkInvalidCase("2023-08-0800");
   }
 }
