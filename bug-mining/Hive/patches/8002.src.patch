diff --git a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFDateFormat.java b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFDateFormat.java
index 3ef9fa07b9..ead43d225e 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFDateFormat.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFDateFormat.java
@@ -17,16 +17,6 @@
  */
 package org.apache.hadoop.hive.ql.udf.generic;
 
-import static org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils.PrimitiveGrouping.DATE_GROUP;
-import static org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils.PrimitiveGrouping.STRING_GROUP;
-
-import java.text.SimpleDateFormat;
-import java.time.Instant;
-import java.time.LocalDateTime;
-import java.time.ZoneId;
-import java.time.ZoneOffset;
-
-import org.apache.hadoop.hive.common.type.Date;
 import org.apache.hadoop.hive.common.type.Timestamp;
 import org.apache.hadoop.hive.conf.HiveConf;
 import org.apache.hadoop.hive.ql.exec.Description;
@@ -34,7 +24,6 @@
 import org.apache.hadoop.hive.ql.exec.UDFArgumentTypeException;
 import org.apache.hadoop.hive.ql.metadata.HiveException;
 import org.apache.hadoop.hive.ql.session.SessionState;
-import org.apache.hadoop.hive.ql.util.DateTimeMath;
 import org.apache.hadoop.hive.serde2.objectinspector.ConstantObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorConverters.Converter;
@@ -42,6 +31,15 @@
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
 import org.apache.hadoop.io.Text;
 
+import java.time.Instant;
+import java.time.ZoneId;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
+
+import static org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils.PrimitiveGrouping.DATE_GROUP;
+import static org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils.PrimitiveGrouping.STRING_GROUP;
+
 /**
  * GenericUDFDateFormat.
  *
@@ -51,18 +49,17 @@
  */
 @Description(name = "date_format", value = "_FUNC_(date/timestamp/string, fmt) - converts a date/timestamp/string "
     + "to a value of string in the format specified by the date format fmt.",
-    extended = "Supported formats are SimpleDateFormat formats - "
-        + "https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html. "
+    extended = "Supported formats are DateTimeFormatter formats - "
+        + "https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html. "
         + "Second argument fmt should be constant.\n"
         + "Example: > SELECT _FUNC_('2015-04-08', 'y');\n '2015'")
 public class GenericUDFDateFormat extends GenericUDF {
-  private transient Converter[] tsConverters = new Converter[2];
-  private transient PrimitiveCategory[] tsInputTypes = new PrimitiveCategory[2];
-  private transient Converter[] dtConverters = new Converter[2];
-  private transient PrimitiveCategory[] dtInputTypes = new PrimitiveCategory[2];
-  private final java.util.Date date = new java.util.Date();
+  private final transient Converter[] tsConverters = new Converter[2];
+  private final transient PrimitiveCategory[] tsInputTypes = new PrimitiveCategory[2];
+
   private final Text output = new Text();
-  private transient SimpleDateFormat formatter;
+  private transient ZoneId timeZone;
+  private transient DateTimeFormatter formatter;
 
   @Override
   public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {
@@ -74,30 +71,28 @@ public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumen
     // the function should support both short date and full timestamp format
     // time part of the timestamp should not be skipped
     checkArgGroups(arguments, 0, tsInputTypes, STRING_GROUP, DATE_GROUP);
-    checkArgGroups(arguments, 0, dtInputTypes, STRING_GROUP, DATE_GROUP);
-
     checkArgGroups(arguments, 1, tsInputTypes, STRING_GROUP);
 
     obtainTimestampConverter(arguments, 0, tsInputTypes, tsConverters);
-    obtainDateConverter(arguments, 0, dtInputTypes, dtConverters);
 
     if (arguments[1] instanceof ConstantObjectInspector) {
       String fmtStr = getConstantStringValue(arguments, 1);
       if (fmtStr != null) {
         try {
-          formatter = new SimpleDateFormat(fmtStr);
-          formatter.setCalendar(DateTimeMath.getTimeZonedProlepticGregorianCalendar());
+          if (timeZone == null) {
+            timeZone = SessionState.get() == null ? new HiveConf().getLocalTimeZone() : SessionState.get().getConf()
+                .getLocalTimeZone();
+          }
+          formatter = DateTimeFormatter.ofPattern(fmtStr);
         } catch (IllegalArgumentException e) {
           // ignore
         }
       }
     } else {
-      throw new UDFArgumentTypeException(1, getFuncName() + " only takes constant as "
-          + getArgOrder(1) + " argument");
+      throw new UDFArgumentTypeException(1, getFuncName() + " only takes constant as " + getArgOrder(1) + " argument");
     }
 
-    ObjectInspector outputOI = PrimitiveObjectInspectorFactory.writableStringObjectInspector;
-    return outputOI;
+    return PrimitiveObjectInspectorFactory.writableStringObjectInspector;
   }
 
   @Override
@@ -106,25 +101,18 @@ public Object evaluate(DeferredObject[] arguments) throws HiveException {
       return null;
     }
 
-    ZoneId id = (SessionState.get() == null) ? new HiveConf().getLocalTimeZone() : SessionState.get().getConf()
-        .getLocalTimeZone();
     // the function should support both short date and full timestamp format
     // time part of the timestamp should not be skipped
     Timestamp ts = getTimestampValue(arguments, 0, tsConverters);
+
     if (ts == null) {
-      Date d = getDateValue(arguments, 0, dtInputTypes, dtConverters);
-      if (d == null) {
-        return null;
-      }
-      ts = Timestamp.ofEpochMilli(d.toEpochMilli(id), id);
+      return null;
     }
 
+    Instant instant = Instant.ofEpochSecond(ts.toEpochSecond(), ts.getNanos());
+    ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, ZoneOffset.UTC);
+    String res = formatter.format(zonedDateTime.withZoneSameLocal(timeZone));
 
-    date.setTime(ts.toEpochMilli(id));
-    String res = formatter.format(date);
-    if (res == null) {
-      return null;
-    }
     output.set(res);
     return output;
   }
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/DateTimeMath.java b/ql/src/java/org/apache/hadoop/hive/ql/util/DateTimeMath.java
index ac471c8b30..5876a6838c 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/util/DateTimeMath.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/DateTimeMath.java
@@ -617,21 +617,4 @@ public static Calendar getProlepticGregorianCalendarUTC() {
     return calendar;
   }
 
-  /**
-   * TODO - this is a temporary fix for handling Julian calendar dates.
-   * Returns a Gregorian calendar that can be used from year 0+ instead of default 1582.10.15.
-   * This is desirable for some UDFs that work on dates which normally would use Julian calendar.
-   * Julian calendar only works with UTC time zone only.
-   * @return the calendar
-   */
-  public static Calendar getTimeZonedProlepticGregorianCalendar() {
-    ZoneId id = SessionState.get() == null ? new HiveConf().getLocalTimeZone() : SessionState.get().getConf()
-        .getLocalTimeZone();
-    GregorianCalendar calendar = new GregorianCalendar(TimeZone.getTimeZone(id));
-
-    if (id.getId().equals("UTC"))
-      calendar.setGregorianChange(new java.util.Date(Long.MIN_VALUE));
-
-    return calendar;
-  }
 }
diff --git a/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFDateFormat.java b/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFDateFormat.java
index 7860ef96bf..40581587b7 100644
--- a/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFDateFormat.java
+++ b/ql/src/test/org/apache/hadoop/hive/ql/udf/generic/TestGenericUDFDateFormat.java
@@ -164,7 +164,7 @@ public void testNullFmt() throws HiveException {
   public void testWrongFmt() throws HiveException {
     GenericUDFDateFormat udf = new GenericUDFDateFormat();
     ObjectInspector valueOI0 = PrimitiveObjectInspectorFactory.writableStringObjectInspector;
-    Text fmtText = new Text("Q");
+    Text fmtText = new Text("B");
     ObjectInspector valueOI1 = PrimitiveObjectInspectorFactory
         .getPrimitiveWritableConstantObjectInspector(TypeInfoFactory.stringTypeInfo, fmtText);
     ObjectInspector[] arguments = { valueOI0, valueOI1 };
@@ -176,7 +176,6 @@ public void testWrongFmt() throws HiveException {
 
 
   @Test
-  @Ignore
   public void testJulianDates() throws HiveException {
     GenericUDFDateFormat udf = new GenericUDFDateFormat();
     ObjectInspector valueOI0 = PrimitiveObjectInspectorFactory.writableStringObjectInspector;
@@ -188,6 +187,19 @@ public void testJulianDates() throws HiveException {
     runAndVerifyStr("1001-01-05", fmtText, "05---01--1001", udf);
   }
 
+  @Test
+  public void testTimestampPriorTo1900() throws HiveException {
+    GenericUDFDateFormat udf = new GenericUDFDateFormat();
+    ObjectInspector valueOI0 = PrimitiveObjectInspectorFactory.writableStringObjectInspector;
+    Text fmtText = new Text("yyyy-MM-dd HH:mm:ss.SSS z");
+    ObjectInspector valueOI1 = PrimitiveObjectInspectorFactory
+        .getPrimitiveWritableConstantObjectInspector(TypeInfoFactory.stringTypeInfo, fmtText);
+    ObjectInspector[] arguments = { valueOI0, valueOI1 };
+    udf.initialize(arguments);
+    runAndVerifyStr("1400-01-14 01:01:10.123", fmtText, "1400-01-14 01:01:10.123 PST", udf);
+    runAndVerifyStr("1800-01-14 01:01:10.123", fmtText, "1800-01-14 01:01:10.123 PST", udf);
+  }
+
   private void runAndVerifyStr(String str, Text fmtText, String expResult, GenericUDF udf)
       throws HiveException {
     DeferredObject valueObj0 = new DeferredJavaObject(str != null ? new Text(str) : null);
diff --git a/ql/src/test/queries/clientpositive/udf_date_format.q b/ql/src/test/queries/clientpositive/udf_date_format.q
index eaec93c3d7..583b1d98d9 100644
--- a/ql/src/test/queries/clientpositive/udf_date_format.q
+++ b/ql/src/test/queries/clientpositive/udf_date_format.q
@@ -63,7 +63,7 @@ date_format(cast(null as timestamp), 'HH');
 -- wrong fmt
 select
 date_format('2015-04-08', ''),
-date_format('2015-04-08', 'Q');
+date_format('2015-04-08', 'B');
 
 -- with time zone
 set hive.local.time.zone=Asia/Bangkok;
@@ -78,3 +78,16 @@ select date_format("2015-04-08 10:30:45","yyyy-MM-dd HH:mm:ss.SSS z");
 --julian date
 set hive.local.time.zone=UTC;
 select date_format("1001-01-05","dd---MM--yyyy");
+
+--dates prior to 1900
+set hive.local.time.zone=Asia/Bangkok;
+select date_format('1400-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z');
+select date_format('1800-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z');
+
+set hive.local.time.zone=Europe/Berlin;
+select date_format('1400-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z');
+select date_format('1800-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z');
+
+set hive.local.time.zone=Africa/Johannesburg;
+select date_format('1400-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z');
+select date_format('1800-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z');
diff --git a/ql/src/test/results/clientpositive/llap/udf_date_format.q.out b/ql/src/test/results/clientpositive/llap/udf_date_format.q.out
index b5b6bfa857..fbb6240ee5 100644
--- a/ql/src/test/results/clientpositive/llap/udf_date_format.q.out
+++ b/ql/src/test/results/clientpositive/llap/udf_date_format.q.out
@@ -8,7 +8,7 @@ PREHOOK: type: DESCFUNCTION
 POSTHOOK: query: DESC FUNCTION EXTENDED date_format
 POSTHOOK: type: DESCFUNCTION
 date_format(date/timestamp/string, fmt) - converts a date/timestamp/string to a value of string in the format specified by the date format fmt.
-Supported formats are SimpleDateFormat formats - https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html. Second argument fmt should be constant.
+Supported formats are DateTimeFormatter formats - https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html. Second argument fmt should be constant.
 Example: > SELECT date_format('2015-04-08', 'y');
  '2015'
 Function class:org.apache.hadoop.hive.ql.udf.generic.GenericUDFDateFormat
@@ -92,7 +92,7 @@ date_format(cast(null as string), 'dd')
 POSTHOOK: type: QUERY
 POSTHOOK: Input: _dummy_database@_dummy_table
 #### A masked pattern was here ####
-10	30	45	09 PM	08	123	08	08	NULL
+10	30	45	09 PM	08	1	08	08	NULL
 PREHOOK: query: select
 date_format(cast('2015-04-08' as date), 'EEEE'),
 date_format(cast('2015-04-08' as date), 'G'),
@@ -149,13 +149,13 @@ POSTHOOK: Input: _dummy_database@_dummy_table
 10	30	45	10 AM	08	123	123	NULL
 PREHOOK: query: select
 date_format('2015-04-08', ''),
-date_format('2015-04-08', 'Q')
+date_format('2015-04-08', 'B')
 PREHOOK: type: QUERY
 PREHOOK: Input: _dummy_database@_dummy_table
 #### A masked pattern was here ####
 POSTHOOK: query: select
 date_format('2015-04-08', ''),
-date_format('2015-04-08', 'Q')
+date_format('2015-04-08', 'B')
 POSTHOOK: type: QUERY
 POSTHOOK: Input: _dummy_database@_dummy_table
 #### A masked pattern was here ####
@@ -196,3 +196,57 @@ POSTHOOK: type: QUERY
 POSTHOOK: Input: _dummy_database@_dummy_table
 #### A masked pattern was here ####
 05---01--1001
+PREHOOK: query: select date_format('1400-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+POSTHOOK: query: select date_format('1400-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+1400-01-14 01:01:10.123 ICT
+PREHOOK: query: select date_format('1800-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+POSTHOOK: query: select date_format('1800-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+1800-01-14 01:01:10.123 ICT
+PREHOOK: query: select date_format('1400-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+POSTHOOK: query: select date_format('1400-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+1400-01-14 01:01:10.123 CET
+PREHOOK: query: select date_format('1800-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+POSTHOOK: query: select date_format('1800-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+1800-01-14 01:01:10.123 CET
+PREHOOK: query: select date_format('1400-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+POSTHOOK: query: select date_format('1400-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+1400-01-14 01:01:10.123 SAST
+PREHOOK: query: select date_format('1800-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+POSTHOOK: query: select date_format('1800-01-14 01:01:10.123', 'yyyy-MM-dd HH:mm:ss.SSS z')
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+#### A masked pattern was here ####
+1800-01-14 01:01:10.123 SAST
