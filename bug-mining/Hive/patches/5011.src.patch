diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStore.java b/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStore.java
index 09211f406b..2a604bf090 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStore.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStore.java
@@ -138,6 +138,7 @@
 import java.net.InetSocketAddress;
 import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
+import java.security.PrivilegedExceptionAction;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.AbstractMap;
@@ -2384,18 +2385,33 @@ private List<Partition> add_partitions_core(final RawStore ms,
             continue;
           }
 
-
+          final UserGroupInformation ugi;
+          try {
+            ugi = UserGroupInformation.getCurrentUser();
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
           partFutures.add(threadPool.submit(new Callable() {
             @Override
             public Partition call() throws Exception {
-              boolean madeDir = createLocationForAddedPartition(table, part);
-              if (addedPartitions.put(new PartValEqWrapper(part), madeDir) != null) {
-                // Technically, for ifNotExists case, we could insert one and discard the other
-                // because the first one now "exists", but it seems better to report the problem
-                // upstream as such a command doesn't make sense.
-                throw new MetaException("Duplicate partitions in the list: " + part);
-              }
-              initializeAddedPartition(table, part, madeDir);
+              ugi.doAs(new PrivilegedExceptionAction<Object>() {
+                @Override
+                public Object run() throws Exception {
+                  try {
+                    boolean madeDir = createLocationForAddedPartition(table, part);
+                    if (addedPartitions.put(new PartValEqWrapper(part), madeDir) != null) {
+                      // Technically, for ifNotExists case, we could insert one and discard the other
+                      // because the first one now "exists", but it seems better to report the problem
+                      // upstream as such a command doesn't make sense.
+                      throw new MetaException("Duplicate partitions in the list: " + part);
+                    }
+                    initializeAddedPartition(table, part, madeDir);
+                  } catch (MetaException e) {
+                    throw new IOException(e.getMessage(), e);
+                  }
+                  return null;
+                }
+              });
               return part;
             }
           }));
@@ -2547,16 +2563,33 @@ private int add_partitions_pspec_core(
             LOG.info("Not adding partition " + part + " as it already exists");
             continue;
           }
+
+          final UserGroupInformation ugi;
+          try {
+            ugi = UserGroupInformation.getCurrentUser();
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
           partFutures.add(threadPool.submit(new Callable() {
             @Override public Object call() throws Exception {
-              boolean madeDir = createLocationForAddedPartition(table, part);
-              if (addedPartitions.put(new PartValEqWrapperLite(part), madeDir) != null) {
-                // Technically, for ifNotExists case, we could insert one and discard the other
-                // because the first one now "exists", but it seems better to report the problem
-                // upstream as such a command doesn't make sense.
-                throw new MetaException("Duplicate partitions in the list: " + part);
-              }
-              initializeAddedPartition(table, part, madeDir);
+              ugi.doAs(new PrivilegedExceptionAction<Object>() {
+                @Override
+                public Object run() throws Exception {
+                  try {
+                    boolean madeDir = createLocationForAddedPartition(table, part);
+                    if (addedPartitions.put(new PartValEqWrapperLite(part), madeDir) != null) {
+                      // Technically, for ifNotExists case, we could insert one and discard the other
+                      // because the first one now "exists", but it seems better to report the problem
+                      // upstream as such a command doesn't make sense.
+                      throw new MetaException("Duplicate partitions in the list: " + part);
+                    }
+                    initializeAddedPartition(table, part, madeDir);
+                  } catch (MetaException e) {
+                    throw new IOException(e.getMessage(), e);
+                  }
+                  return null;
+                }
+              });
               return part;
             }
           }));
diff --git a/ql/src/test/results/clientnegative/external2.q.out b/ql/src/test/results/clientnegative/external2.q.out
index 91b5de4d93..706432ad24 100644
--- a/ql/src/test/results/clientnegative/external2.q.out
+++ b/ql/src/test/results/clientnegative/external2.q.out
@@ -10,4 +10,4 @@ POSTHOOK: Output: default@external2
 PREHOOK: type: ALTERTABLE_ADDPARTS
 #### A masked pattern was here ####
 PREHOOK: Output: default@external2
-FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. MetaException(message:MetaException(message:Got exception: java.io.IOException No FileSystem for scheme: invalidscheme))
+FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. MetaException(message:java.io.IOException: Got exception: java.io.IOException No FileSystem for scheme: invalidscheme)
