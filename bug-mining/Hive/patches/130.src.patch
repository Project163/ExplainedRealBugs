diff --git a/CHANGES.txt b/CHANGES.txt
index ddc5847deb..844f33cd5f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -69,6 +69,9 @@ Trunk - unreleased changes
 
     HIVE-416. Fix backtrack in Hive.g. (Namit Jain via zshao)
 
+    HIVE-432. Fix "SORT BY" using only one reducer.
+    (Zheng Shao via njain)
+
 Release 0.3.0 - Unreleased
 
   INCOMPATIBLE CHANGES
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/ReduceSinkOperator.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/ReduceSinkOperator.java
index 160df9ae35..bc454cddc8 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/ReduceSinkOperator.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/ReduceSinkOperator.java
@@ -21,6 +21,7 @@
 import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.Random;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hive.ql.io.HiveKey;
@@ -122,6 +123,8 @@ public void initialize(Configuration hconf, Reporter reporter) throws HiveExcept
   transient Object[] cachedKeys;
   transient Object[] cachedValues;
   
+  transient Random random;
+  
   public void process(Object row, ObjectInspector rowInspector) throws HiveException {
     try {
       // Evaluate the keys
@@ -168,10 +171,21 @@ public void process(Object row, ObjectInspector rowInspector) throws HiveExcepti
       }
       // Set the HashCode
       int keyHashCode = 0;
-      for(ExprNodeEvaluator e: partitionEval) {
-        e.evaluate(row, rowInspector, tempInspectableObject);
-        keyHashCode = keyHashCode * 31 
-          + (tempInspectableObject.o == null ? 0 : tempInspectableObject.o.hashCode());
+      if (partitionEval.length == 0) {
+        // If no partition cols, just distribute the data uniformly to provide better
+        // load balance.  If the requirement is to have a single reducer, we should set
+        // the number of reducers to 1.
+        // Use a constant seed to make the code deterministic.
+        if (random == null) {
+          random = new Random(12345);
+        }
+        keyHashCode = random.nextInt();
+      } else {
+        for(ExprNodeEvaluator e: partitionEval) {
+          e.evaluate(row, rowInspector, tempInspectableObject);
+          keyHashCode = keyHashCode * 31 
+            + (tempInspectableObject.o == null ? 0 : tempInspectableObject.o.hashCode());
+        }
       }
       keyWritable.setHashCode(keyHashCode);
       
