diff --git a/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java b/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
index 26fbd20ab9..d51f58d60e 100644
--- a/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
+++ b/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
@@ -380,7 +380,7 @@ public List<Partition> getPartitionsViaSqlFilter(
     // Derby and Oracle do not interpret filters ANSI-properly in some cases and need a workaround.
     boolean dbHasJoinCastBug = (dbType == DB.DERBY || dbType == DB.ORACLE);
     String sqlFilter = PartitionFilterGenerator.generateSqlFilter(
-        table, tree, params, joins, dbHasJoinCastBug, defaultPartName);
+        table, tree, params, joins, dbHasJoinCastBug, defaultPartName, dbType);
     if (sqlFilter == null) {
       return null; // Cannot make SQL filter to push down.
     }
@@ -395,7 +395,7 @@ public int getNumPartitionsViaSqlFilter(Table table, ExpressionTree tree) throws
     // Derby and Oracle do not interpret filters ANSI-properly in some cases and need a workaround.
     boolean dbHasJoinCastBug = (dbType == DB.DERBY || dbType == DB.ORACLE);
     String sqlFilter = PartitionFilterGenerator.generateSqlFilter(
-        table, tree, params, joins, dbHasJoinCastBug, defaultPartName);
+        table, tree, params, joins, dbHasJoinCastBug, defaultPartName, dbType);
     if (sqlFilter == null) {
       return 0; // Cannot make SQL filter to push down.
     }
@@ -962,15 +962,17 @@ private static class PartitionFilterGenerator extends TreeVisitor {
     private final List<String> joins;
     private final boolean dbHasJoinCastBug;
     private final String defaultPartName;
+    private final DB dbType;
 
     private PartitionFilterGenerator(Table table, List<Object> params, List<String> joins,
-        boolean dbHasJoinCastBug, String defaultPartName) {
+        boolean dbHasJoinCastBug, String defaultPartName, DB dbType) {
       this.table = table;
       this.params = params;
       this.joins = joins;
       this.dbHasJoinCastBug = dbHasJoinCastBug;
       this.filterBuffer = new FilterBuilder(false);
       this.defaultPartName = defaultPartName;
+      this.dbType = dbType;
     }
 
     /**
@@ -980,15 +982,15 @@ private PartitionFilterGenerator(Table table, List<Object> params, List<String>
      * @param joins the joins necessary for the resulting expression
      * @return the string representation of the expression tree
      */
-    private static String generateSqlFilter(Table table, ExpressionTree tree,
-        List<Object> params, List<String> joins, boolean dbHasJoinCastBug, String defaultPartName)
+    private static String generateSqlFilter(Table table, ExpressionTree tree, List<Object> params,
+        List<String> joins, boolean dbHasJoinCastBug, String defaultPartName, DB dbType)
             throws MetaException {
       assert table != null;
       if (tree.getRoot() == null) {
         return "";
       }
       PartitionFilterGenerator visitor = new PartitionFilterGenerator(
-          table, params, joins, dbHasJoinCastBug, defaultPartName);
+          table, params, joins, dbHasJoinCastBug, defaultPartName, dbType);
       tree.accept(visitor);
       if (visitor.filterBuffer.hasError()) {
         LOG.info("Unable to push down SQL filter: " + visitor.filterBuffer.getErrorMessage());
@@ -1124,7 +1126,12 @@ public void visit(LeafNode node) throws MetaException {
         if (colType == FilterType.Integral) {
           tableValue = "cast(" + tableValue + " as decimal(21,0))";
         } else if (colType == FilterType.Date) {
-          tableValue = "cast(" + tableValue + " as date)";
+          if (dbType == DB.ORACLE) {
+            // Oracle requires special treatment... as usual.
+            tableValue = "TO_DATE(" + tableValue + ", 'YYYY-MM-DD')";
+          } else {
+            tableValue = "cast(" + tableValue + " as date)";
+          }
         }
 
         // Workaround for HIVE_DEFAULT_PARTITION - ignore it like JDO does, for now.
