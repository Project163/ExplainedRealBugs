diff --git a/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java b/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java
index d4514f4812..250debfd9b 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/exec/MoveTask.java
@@ -104,6 +104,29 @@ public MoveTask() {
     super();
   }
 
+  private boolean moveFilesUsingManifestFile(FileSystem fs, Path sourcePath, Path targetPath)
+          throws HiveException, IOException {
+    if (work.isCTAS() && BlobStorageUtils.isBlobStorageFileSystem(conf, fs)) {
+      if (fs.exists(new Path(sourcePath, BLOB_MANIFEST_FILE))) {
+        LOG.debug("Attempting to copy using the paths available in {}", new Path(sourcePath, BLOB_MANIFEST_FILE));
+        ArrayList<String> filesKept;
+        try (FSDataInputStream inStream = fs.open(new Path(sourcePath, BLOB_MANIFEST_FILE))) {
+          String paths = IOUtils.toString(inStream, Charset.defaultCharset());
+          filesKept = new ArrayList(Arrays.asList(paths.split(System.lineSeparator())));
+        }
+        // Remove the first entry from the list, it is the source path.
+        Path srcPath = new Path(filesKept.remove(0));
+        LOG.info("Copying files {} from {} to {}", filesKept, srcPath, targetPath);
+        // Do the move using the filesKept now directly to the target dir.
+        Utilities.moveSpecifiedFilesInParallel(conf, fs, srcPath, targetPath, new HashSet<>(filesKept));
+        return true;
+      }
+      // Fallback case, in any case the _blob_files_kept isn't created, we can do the normal logic. The file won't
+      // be created in case of empty source table as well
+    }
+    return false;
+  }
+
   private void moveFile(Path sourcePath, Path targetPath, boolean isDfsDir)
       throws HiveException {
     try {
@@ -117,25 +140,12 @@ private void moveFile(Path sourcePath, Path targetPath, boolean isDfsDir)
 
       FileSystem fs = sourcePath.getFileSystem(conf);
 
-      if (work.isCTAS() && BlobStorageUtils.isBlobStorageFileSystem(conf, fs)) {
-        if (fs.exists(new Path(sourcePath, BLOB_MANIFEST_FILE))) {
-          LOG.debug("Attempting to copy using the paths available in {}", new Path(sourcePath, BLOB_MANIFEST_FILE));
-          ArrayList<String> filesKept;
-          try (FSDataInputStream inStream = fs.open(new Path(sourcePath, BLOB_MANIFEST_FILE))) {
-            String paths = IOUtils.toString(inStream, Charset.defaultCharset());
-            filesKept = new ArrayList(Arrays.asList(paths.split(System.lineSeparator())));
-          }
-          // Remove the first entry from the list, it is the source path.
-          Path srcPath = new Path(filesKept.remove(0));
-          LOG.info("Copying files {} from {} to {}", filesKept, srcPath, targetPath);
-          // Do the move using the filesKept now directly to the target dir.
-          Utilities.moveSpecifiedFilesInParallel(conf, fs, srcPath, targetPath, new HashSet<>(filesKept));
-          perfLogger.perfLogEnd("MoveTask", PerfLogger.FILE_MOVES);
-          return;
-        }
-        // Fallback case, in any case the _blob_files_kept isn't created, we can do the normal logic. The file won't
-        // be created in case of empty source table as well
+      // if _blob_files_kept is present, use it to move the files. Else fall back to normal case.
+      if (moveFilesUsingManifestFile(fs, sourcePath, targetPath)) {
+        perfLogger.perfLogEnd("MoveTask", PerfLogger.FILE_MOVES);
+        return;
       }
+
       if (isDfsDir) {
         moveFileInDfs (sourcePath, targetPath, conf);
       } else {
@@ -470,6 +480,10 @@ public int execute() {
           // deal with dynamic partitions
           DynamicPartitionCtx dpCtx = tbd.getDPCtx();
           if (dpCtx != null && dpCtx.getNumDPCols() > 0) { // dynamic partitions
+            // if _blob_files_kept is present, use it to move the files to the target path
+            // before loading the partitions.
+            moveFilesUsingManifestFile(tbd.getSourcePath().getFileSystem(conf),
+                    tbd.getSourcePath(), dpCtx.getRootPath());
             dc = handleDynParts(db, table, tbd, ti, dpCtx);
           } else { // static partitions
             dc = handleStaticParts(db, table, tbd, ti);
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/TaskCompiler.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/TaskCompiler.java
index 255baabb93..8cc755e7d1 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/TaskCompiler.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/TaskCompiler.java
@@ -270,7 +270,8 @@ public void compile(final ParseContext pCtx,
     } else if (!isCStats) {
       for (LoadTableDesc ltd : loadTableWork) {
         Task<MoveWork> tsk = TaskFactory
-            .get(new MoveWork(null, null, ltd, null, false));
+            .get(new MoveWork(pCtx.getQueryProperties().isCTAS() && pCtx.getCreateTable().isExternal(),
+                    null, null, ltd, null, false));
         mvTask.add(tsk);
       }
 
diff --git a/ql/src/test/queries/clientpositive/ctas_blob.q b/ql/src/test/queries/clientpositive/ctas_blob.q
index 7d871311bc..4dc998f6b8 100644
--- a/ql/src/test/queries/clientpositive/ctas_blob.q
+++ b/ql/src/test/queries/clientpositive/ctas_blob.q
@@ -22,6 +22,10 @@ create external table t1_ctas as select * from t1;
 
 select * from t1_ctas order by key;
 
+create external table t1_ctas_part partitioned by (key) as select * from t1;
+
+select * from t1_ctas_part order by key;
+
 -- try CTAS with empty external table.
 
 create external table t2 (key int, value string);
@@ -64,4 +68,4 @@ drop table t1_ctas;
 drop table t2_ctas;
 drop table t3_ctas;
 drop table texternal;
-drop table tmanaged;
\ No newline at end of file
+drop table tmanaged;
diff --git a/ql/src/test/results/clientpositive/llap/ctas_blob.q.out b/ql/src/test/results/clientpositive/llap/ctas_blob.q.out
index 9387c97e35..79967b4888 100644
--- a/ql/src/test/results/clientpositive/llap/ctas_blob.q.out
+++ b/ql/src/test/results/clientpositive/llap/ctas_blob.q.out
@@ -62,6 +62,57 @@ POSTHOOK: Input: default@t1_ctas
 4	JKLM
 5	NOPQ
 6	RSTUV
+PREHOOK: query: create external table t1_ctas_part partitioned by (key) as select * from t1
+PREHOOK: type: CREATETABLE_AS_SELECT
+PREHOOK: Input: default@t1
+PREHOOK: Output: database:default
+PREHOOK: Output: default@t1_ctas_part
+PREHOOK: Output: default@t1_ctas_part
+POSTHOOK: query: create external table t1_ctas_part partitioned by (key) as select * from t1
+POSTHOOK: type: CREATETABLE_AS_SELECT
+POSTHOOK: Input: default@t1
+POSTHOOK: Output: database:default
+POSTHOOK: Output: default@t1_ctas_part
+POSTHOOK: Output: default@t1_ctas_part
+POSTHOOK: Output: default@t1_ctas_part@key=1
+POSTHOOK: Output: default@t1_ctas_part@key=2
+POSTHOOK: Output: default@t1_ctas_part@key=3
+POSTHOOK: Output: default@t1_ctas_part@key=4
+POSTHOOK: Output: default@t1_ctas_part@key=5
+POSTHOOK: Output: default@t1_ctas_part@key=6
+POSTHOOK: Lineage: t1_ctas_part.value SIMPLE [(t1)t1.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: t1_ctas_part PARTITION(key=1).value SIMPLE [(t1)t1.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: t1_ctas_part PARTITION(key=2).value SIMPLE [(t1)t1.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: t1_ctas_part PARTITION(key=3).value SIMPLE [(t1)t1.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: t1_ctas_part PARTITION(key=4).value SIMPLE [(t1)t1.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: t1_ctas_part PARTITION(key=5).value SIMPLE [(t1)t1.FieldSchema(name:value, type:string, comment:null), ]
+POSTHOOK: Lineage: t1_ctas_part PARTITION(key=6).value SIMPLE [(t1)t1.FieldSchema(name:value, type:string, comment:null), ]
+PREHOOK: query: select * from t1_ctas_part order by key
+PREHOOK: type: QUERY
+PREHOOK: Input: default@t1_ctas_part
+PREHOOK: Input: default@t1_ctas_part@key=1
+PREHOOK: Input: default@t1_ctas_part@key=2
+PREHOOK: Input: default@t1_ctas_part@key=3
+PREHOOK: Input: default@t1_ctas_part@key=4
+PREHOOK: Input: default@t1_ctas_part@key=5
+PREHOOK: Input: default@t1_ctas_part@key=6
+#### A masked pattern was here ####
+POSTHOOK: query: select * from t1_ctas_part order by key
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@t1_ctas_part
+POSTHOOK: Input: default@t1_ctas_part@key=1
+POSTHOOK: Input: default@t1_ctas_part@key=2
+POSTHOOK: Input: default@t1_ctas_part@key=3
+POSTHOOK: Input: default@t1_ctas_part@key=4
+POSTHOOK: Input: default@t1_ctas_part@key=5
+POSTHOOK: Input: default@t1_ctas_part@key=6
+#### A masked pattern was here ####
+ABCD	1
+BCDE	2
+FGHI	3
+JKLM	4
+NOPQ	5
+RSTUV	6
 PREHOOK: query: create external table t2 (key int, value string)
 PREHOOK: type: CREATETABLE
 PREHOOK: Output: database:default
