diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapSliderUtils.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapSliderUtils.java
index 2d0121c9d7..a0af554845 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapSliderUtils.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapSliderUtils.java
@@ -18,12 +18,13 @@
 
 package org.apache.hadoop.hive.llap.cli;
 
+import com.google.common.io.Files;
 import java.io.File;
 import java.io.IOException;
-
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.hive.conf.HiveConf;
+import org.apache.hadoop.hive.llap.cli.status.LlapStatusHelpers.AppStatusBuilder;
 import org.apache.hadoop.yarn.api.records.ApplicationReport;
 import org.apache.hadoop.yarn.exceptions.YarnException;
 import org.apache.hadoop.yarn.util.Clock;
@@ -39,8 +40,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.common.io.Files;
-
 public class LlapSliderUtils {
   private static final String SLIDER_GZ = "slider-agent.tar.gz";
   private static final Logger LOG = LoggerFactory.getLogger(LlapSliderUtils.class);
@@ -96,7 +95,7 @@ public static ApplicationReport getAppReport(String appName, SliderClient slider
   }
 
   public static ApplicationDiagnostics getApplicationDiagnosticsFromYarnDiagnostics(
-      ApplicationReport appReport, Logger LOG) {
+      ApplicationReport appReport, AppStatusBuilder appStatusBuilder, Logger LOG) {
     if (appReport == null) {
       return null;
     }
@@ -105,13 +104,11 @@ public static ApplicationDiagnostics getApplicationDiagnosticsFromYarnDiagnostic
       return null;
     }
     try {
-      ApplicationDiagnostics appDiagnostics =
-          ApplicationDiagnostics.fromJson(diagnostics);
-      return appDiagnostics;
+      return ApplicationDiagnostics.fromJson(diagnostics);
     } catch (IOException e) {
-      LOG.warn(
-          "Failed to parse application diagnostics from Yarn Diagnostics - {}",
-          diagnostics);
+      LOG.warn("Failed to parse application diagnostics from Yarn Diagnostics - {}", diagnostics);
+      // Set the raw YARN diagnostics here - the caller won't know if they even exist.
+      appStatusBuilder.setDiagnostics(diagnostics);
       return null;
     }
   }
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapStatusOptionsProcessor.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapStatusOptionsProcessor.java
index bd91495da3..4c30b8074b 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapStatusOptionsProcessor.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapStatusOptionsProcessor.java
@@ -39,6 +39,7 @@ public class LlapStatusOptionsProcessor {
   private static final long DEFAULT_WATCH_MODE_TIMEOUT_MS = 5 * 60 * 1000l; // 5 minutes timeout for watch mode
   private static final float DEFAULT_RUNNING_NODES_THRESHOLD = 1.0f;
 
+  // TODO: why doesn't this use one of the existing options implementations?!
   enum OptionConstants {
 
     NAME("name", 'n', "LLAP cluster name", true),
@@ -48,6 +49,10 @@ enum OptionConstants {
     OUTPUT_FILE("outputFile", 'o', "File to which output should be written (Default stdout)", true),
     WATCH_MODE("watch", 'w', "Watch mode waits until all LLAP daemons are running or subset of the nodes are " +
       "running (threshold can be specified via -r option) (Default wait until all nodes are running)", false),
+    // This is a negative because we want the positive to be the default when nothing is specified.
+    NOT_LAUNCHED("notlaunched", 'l', "In watch mode, do not assume that the application was "
+        + "already launched if there's doubt (e.g. if the last application instance has failed).",
+        false),
     RUNNING_NODES_THRESHOLD("runningNodesThreshold", 'r', "When watch mode is enabled (-w), wait until the " +
       "specified threshold of nodes are running (Default 1.0 which means 100% nodes are running)", true),
     STATUS_REFRESH_INTERVAL("refreshInterval", 'i', "Amount of time in seconds to wait until subsequent status checks" +
@@ -108,16 +113,17 @@ public static class LlapStatusOptions {
     private final boolean watchMode;
     private final long watchTimeout;
     private final float runningNodesThreshold;
+    private final boolean isLaunched;
 
     public LlapStatusOptions(final String name) {
       this(name, new Properties(), FIND_YARN_APP_TIMEOUT_MS, null, DEFAULT_STATUS_REFRESH_INTERVAL_MS, false,
-        DEFAULT_WATCH_MODE_TIMEOUT_MS, DEFAULT_RUNNING_NODES_THRESHOLD);
+        DEFAULT_WATCH_MODE_TIMEOUT_MS, DEFAULT_RUNNING_NODES_THRESHOLD, true);
     }
 
     public LlapStatusOptions(String name, Properties hiveProperties, long findAppTimeoutMs,
                               String outputFile, long refreshIntervalMs,
                               final boolean watchMode, final long watchTimeoutMs,
-                              final float runningNodesThreshold) {
+                              final float runningNodesThreshold, final boolean isLaunched) {
       this.name = name;
       this.conf = hiveProperties;
       this.findAppTimeoutMs = findAppTimeoutMs;
@@ -126,6 +132,7 @@ public LlapStatusOptions(String name, Properties hiveProperties, long findAppTim
       this.watchMode = watchMode;
       this.watchTimeout = watchTimeoutMs;
       this.runningNodesThreshold = runningNodesThreshold;
+      this.isLaunched = isLaunched;
     }
 
     public String getName() {
@@ -152,6 +159,10 @@ public boolean isWatchMode() {
       return watchMode;
     }
 
+    public boolean isLaunched() {
+      return isLaunched;
+    }
+
     public long getWatchTimeoutMs() {
       return watchTimeout;
     }
@@ -217,26 +228,30 @@ public LlapStatusOptions processOptions(String[] args) throws ParseException {
       refreshIntervalMs = TimeUnit.MILLISECONDS.convert(refreshIntervalSec, TimeUnit.SECONDS);
     }
 
-    boolean watchMode = commandLine.hasOption(OptionConstants.WATCH_MODE.getLongOpt()) ? true : false;
+    boolean watchMode = commandLine.hasOption(OptionConstants.WATCH_MODE.getLongOpt());
     long watchTimeoutMs = DEFAULT_WATCH_MODE_TIMEOUT_MS;
     if (commandLine.hasOption(OptionConstants.WATCH_MODE_TIMEOUT.getLongOpt())) {
-      long watchTimeoutSec = Long.parseLong(commandLine.getOptionValue(OptionConstants.WATCH_MODE_TIMEOUT.getLongOpt()));
+      long watchTimeoutSec = Long.parseLong(commandLine.getOptionValue(
+          OptionConstants.WATCH_MODE_TIMEOUT.getLongOpt()));
       if (watchTimeoutSec <= 0) {
         throw new IllegalArgumentException("Watch timeout should be >0");
       }
       watchTimeoutMs = TimeUnit.MILLISECONDS.convert(watchTimeoutSec, TimeUnit.SECONDS);
     }
+ 
+    boolean isLaunched = !commandLine.hasOption(OptionConstants.NOT_LAUNCHED.getLongOpt());
 
     float runningNodesThreshold = DEFAULT_RUNNING_NODES_THRESHOLD;
     if (commandLine.hasOption(OptionConstants.RUNNING_NODES_THRESHOLD.getLongOpt())) {
-      runningNodesThreshold = Float.parseFloat(commandLine.getOptionValue(OptionConstants.RUNNING_NODES_THRESHOLD
-        .getLongOpt()));
+      runningNodesThreshold = Float.parseFloat(commandLine.getOptionValue(
+          OptionConstants.RUNNING_NODES_THRESHOLD.getLongOpt()));
       if (runningNodesThreshold < 0.0f || runningNodesThreshold > 1.0f) {
-        throw new IllegalArgumentException("Running nodes threshold value should be between 0.0 and 1.0 (inclusive)");
+        throw new IllegalArgumentException(
+            "Running nodes threshold value should be between 0.0 and 1.0 (inclusive)");
       }
     }
-    return new LlapStatusOptions(name, hiveConf, findAppTimeoutMs, outputFile, refreshIntervalMs, watchMode,
-      watchTimeoutMs, runningNodesThreshold);
+    return new LlapStatusOptions(name, hiveConf, findAppTimeoutMs, outputFile, refreshIntervalMs,
+        watchMode,  watchTimeoutMs, runningNodesThreshold, isLaunched);
   }
 
 
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapStatusServiceDriver.java b/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapStatusServiceDriver.java
index 4fad441727..296a85136f 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapStatusServiceDriver.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapStatusServiceDriver.java
@@ -19,6 +19,7 @@
 package org.apache.hadoop.hive.llap.cli;
 
 
+import com.google.common.annotations.VisibleForTesting;
 import java.io.BufferedOutputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -33,8 +34,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
-
-import com.google.common.annotations.VisibleForTesting;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.CommonConfigurationKeysPublic;
@@ -44,6 +43,7 @@
 import org.apache.hadoop.hive.llap.cli.status.LlapStatusHelpers;
 import org.apache.hadoop.hive.llap.cli.status.LlapStatusHelpers.AppStatusBuilder;
 import org.apache.hadoop.hive.llap.cli.status.LlapStatusHelpers.LlapInstance;
+import org.apache.hadoop.hive.llap.cli.status.LlapStatusHelpers.State;
 import org.apache.hadoop.hive.llap.configuration.LlapDaemonConfiguration;
 import org.apache.hadoop.hive.llap.registry.LlapServiceInstance;
 import org.apache.hadoop.hive.llap.registry.impl.LlapRegistryService;
@@ -71,6 +71,10 @@
 
 public class LlapStatusServiceDriver {
 
+  private static final EnumSet<State> NO_SLIDER_INFO_STATES = EnumSet.of(
+      State.APP_NOT_FOUND, State.COMPLETE, State.LAUNCHING);
+  private static final EnumSet<State> LAUNCHING_STATES = EnumSet.of(
+      State.LAUNCHING, State.RUNNING_PARTIAL, State.RUNNING_ALL);
   private static final Logger LOG = LoggerFactory.getLogger(LlapStatusServiceDriver.class);
   private static final Logger CONSOLE_LOGGER = LoggerFactory.getLogger("LlapStatusServiceDriverConsole");
 
@@ -252,8 +256,7 @@ public int run(LlapStatusOptions options, long watchTimeoutMs) {
 
       if (ret != ExitCode.SUCCESS) {
         return ret.getInt();
-      } else if (EnumSet.of(LlapStatusHelpers.State.APP_NOT_FOUND, LlapStatusHelpers.State.COMPLETE, LlapStatusHelpers.State.LAUNCHING)
-        .contains(appStatusBuilder.getState())) {
+      } else if (NO_SLIDER_INFO_STATES.contains(appStatusBuilder.getState())) {
         return ExitCode.SUCCESS.getInt();
       } else {
         // Get information from slider.
@@ -375,7 +378,7 @@ private ExitCode processAppReport(ApplicationReport appReport,
                                AppStatusBuilder appStatusBuilder) throws
       LlapStatusCliException {
     if (appReport == null) {
-      appStatusBuilder.setState(LlapStatusHelpers.State.APP_NOT_FOUND);
+      appStatusBuilder.setState(State.APP_NOT_FOUND);
       LOG.info("No Application Found");
       return ExitCode.SUCCESS;
     }
@@ -388,11 +391,11 @@ private ExitCode processAppReport(ApplicationReport appReport,
       case NEW:
       case NEW_SAVING:
       case SUBMITTED:
-        appStatusBuilder.setState(LlapStatusHelpers.State.LAUNCHING);
+        appStatusBuilder.setState(State.LAUNCHING);
         return ExitCode.SUCCESS;
       case ACCEPTED:
         appStatusBuilder.maybeCreateAndGetAmInfo().setAppId(appReport.getApplicationId().toString());
-        appStatusBuilder.setState(LlapStatusHelpers.State.LAUNCHING);
+        appStatusBuilder.setState(State.LAUNCHING);
         return ExitCode.SUCCESS;
       case RUNNING:
         appStatusBuilder.maybeCreateAndGetAmInfo().setAppId(appReport.getApplicationId().toString());
@@ -403,8 +406,10 @@ private ExitCode processAppReport(ApplicationReport appReport,
       case KILLED:
         appStatusBuilder.maybeCreateAndGetAmInfo().setAppId(appReport.getApplicationId().toString());
         appStatusBuilder.setAppFinishTime(appReport.getFinishTime());
-        appStatusBuilder.setState(LlapStatusHelpers.State.COMPLETE);
-        ApplicationDiagnostics appDiagnostics = LlapSliderUtils.getApplicationDiagnosticsFromYarnDiagnostics(appReport, LOG);
+        appStatusBuilder.setState(State.COMPLETE);
+        ApplicationDiagnostics appDiagnostics =
+            LlapSliderUtils.getApplicationDiagnosticsFromYarnDiagnostics(
+                appReport, appStatusBuilder, LOG);
         if (appDiagnostics == null) {
           LOG.warn("AppDiagnostics not available for YARN application report");
         } else {
@@ -575,7 +580,7 @@ private ExitCode populateAppStatusFromLlapRegistry(
         LOG.debug("No information found in the LLAP registry");
       }
       appStatusBuilder.setLiveInstances(0);
-      appStatusBuilder.setState(LlapStatusHelpers.State.LAUNCHING);
+      appStatusBuilder.setState(State.LAUNCHING);
       appStatusBuilder.clearRunningLlapInstances();
       return ExitCode.SUCCESS;
     } else {
@@ -608,15 +613,15 @@ private ExitCode populateAppStatusFromLlapRegistry(
       appStatusBuilder.setLiveInstances(validatedInstances.size());
       appStatusBuilder.setLaunchingInstances(llapExtraInstances.size());
       if (validatedInstances.size() >= appStatusBuilder.getDesiredInstances()) {
-        appStatusBuilder.setState(LlapStatusHelpers.State.RUNNING_ALL);
+        appStatusBuilder.setState(State.RUNNING_ALL);
         if (validatedInstances.size() > appStatusBuilder.getDesiredInstances()) {
           LOG.warn("Found more entries in LLAP registry, as compared to desired entries");
         }
       } else {
         if (validatedInstances.size() > 0) {
-          appStatusBuilder.setState(LlapStatusHelpers.State.RUNNING_PARTIAL);
+          appStatusBuilder.setState(State.RUNNING_PARTIAL);
         } else {
-          appStatusBuilder.setState(LlapStatusHelpers.State.LAUNCHING);
+          appStatusBuilder.setState(State.LAUNCHING);
         }
       }
 
@@ -886,116 +891,113 @@ public static void main(String[] args) {
         TimeUnit.SECONDS.convert(watchTimeout, TimeUnit.MILLISECONDS),
         numAttempts, watchMode, new DecimalFormat("#.###").format(runningNodesThreshold));
       while (numAttempts > 0) {
-        try {
-          if (!firstAttempt) {
-            if (watchMode) {
-              try {
-                Thread.sleep(refreshInterval);
-              } catch (InterruptedException e) {
-                // ignore
-              }
-            } else {
-              // reported once, so break
-              break;
+        if (!firstAttempt) {
+          if (watchMode) {
+            try {
+              Thread.sleep(refreshInterval);
+            } catch (InterruptedException e) {
+              // ignore
             }
           } else {
-            firstAttempt = false;
-          }
-          ret = statusServiceDriver.run(options, watchMode ? watchTimeout : 0);
-          currentState = statusServiceDriver.appStatusBuilder.getState();
-          try {
-            lastSummaryLogTime = LlapStatusServiceDriver
-                .maybeLogSummary(clock, lastSummaryLogTime, statusServiceDriver,
-                    watchMode, watchTimeout, launchingState);
-          } catch (Exception e) {
-            LOG.warn("Failed to log summary", e);
+            // reported once, so break
+            break;
           }
+        } else {
+          firstAttempt = false;
+        }
+        ret = statusServiceDriver.run(options, watchMode ? watchTimeout : 0);
+        currentState = statusServiceDriver.appStatusBuilder.getState();
+        try {
+          lastSummaryLogTime = LlapStatusServiceDriver
+              .maybeLogSummary(clock, lastSummaryLogTime, statusServiceDriver,
+                  watchMode, watchTimeout, launchingState);
+        } catch (Exception e) {
+          LOG.warn("Failed to log summary", e);
+        }
 
-          if (ret == ExitCode.SUCCESS.getInt()) {
-            if (watchMode) {
+        if (ret == ExitCode.SUCCESS.getInt()) {
+          if (watchMode) {
 
-              // slider has started llap application, now if for some reason state changes to COMPLETE then fail fast
-              if (launchingState == null &&
-                  (EnumSet.of(LlapStatusHelpers.State.LAUNCHING,
-                      LlapStatusHelpers.State.RUNNING_PARTIAL,
-                      LlapStatusHelpers.State.RUNNING_ALL)
-                      .contains(currentState))) {
-                launchingState = currentState;
-              }
+            // slider has started llap application, now if for some reason state changes to COMPLETE then fail fast
+            if (launchingState == null && LAUNCHING_STATES.contains(currentState)) {
+              launchingState = currentState;
+            }
 
-              if (launchingState != null && currentState.equals(
-                  LlapStatusHelpers.State.COMPLETE)) {
-                LOG.warn("Application stopped while launching. COMPLETE state reached while waiting for RUNNING state."
-                  + " Failing " + "fast..");
+            if (currentState.equals(State.COMPLETE)) {
+              if (launchingState != null || options.isLaunched()) {
+                LOG.warn("COMPLETE state reached while waiting for RUNNING state. Failing.");
+                System.err.println("Final diagnostics: " +
+                    statusServiceDriver.appStatusBuilder.getDiagnostics());
                 break;
+              } else {
+                LOG.info("Found a stopped application; assuming it was a previous attempt "
+                    + "and waiting for the next one. Omit the -l flag to avoid this.");
               }
+            }
 
-              if (!(currentState.equals(LlapStatusHelpers.State.RUNNING_PARTIAL) || currentState.equals(
-                  LlapStatusHelpers.State.RUNNING_ALL))) {
+            if (!(currentState.equals(State.RUNNING_PARTIAL) || currentState.equals(
+                State.RUNNING_ALL))) {
+              if (LOG.isDebugEnabled()) {
+                LOG.debug(
+                    "Current state: {}. Desired state: {}. {}/{} instances.",
+                    currentState,
+                    runningNodesThreshold == 1.0f ?
+                        State.RUNNING_ALL :
+                        State.RUNNING_PARTIAL,
+                    statusServiceDriver.appStatusBuilder.getLiveInstances(),
+                    statusServiceDriver.appStatusBuilder
+                        .getDesiredInstances());
+              }
+              numAttempts--;
+              continue;
+            }
+
+            // we have reached RUNNING state, now check if running nodes threshold is met
+            final int liveInstances = statusServiceDriver.appStatusBuilder.getLiveInstances();
+            final int desiredInstances = statusServiceDriver.appStatusBuilder.getDesiredInstances();
+            if (desiredInstances > 0) {
+              final float ratio = (float) liveInstances / (float) desiredInstances;
+              if (ratio < runningNodesThreshold) {
                 if (LOG.isDebugEnabled()) {
                   LOG.debug(
-                      "Current state: {}. Desired state: {}. {}/{} instances.",
-                      currentState,
-                      runningNodesThreshold == 1.0f ?
-                          LlapStatusHelpers.State.RUNNING_ALL :
-                          LlapStatusHelpers.State.RUNNING_PARTIAL,
+                      "Waiting until running nodes threshold is reached. Current: {} Desired: {}." +
+                          " {}/{} instances.",
+                      new DecimalFormat("#.###").format(ratio),
+                      new DecimalFormat("#.###")
+                          .format(runningNodesThreshold),
                       statusServiceDriver.appStatusBuilder.getLiveInstances(),
                       statusServiceDriver.appStatusBuilder
                           .getDesiredInstances());
                 }
                 numAttempts--;
                 continue;
-              }
-
-              // we have reached RUNNING state, now check if running nodes threshold is met
-              final int liveInstances = statusServiceDriver.appStatusBuilder.getLiveInstances();
-              final int desiredInstances = statusServiceDriver.appStatusBuilder.getDesiredInstances();
-              if (desiredInstances > 0) {
-                final float ratio = (float) liveInstances / (float) desiredInstances;
-                if (ratio < runningNodesThreshold) {
-                  if (LOG.isDebugEnabled()) {
-                    LOG.debug(
-                        "Waiting until running nodes threshold is reached. Current: {} Desired: {}." +
-                            " {}/{} instances.",
-                        new DecimalFormat("#.###").format(ratio),
-                        new DecimalFormat("#.###")
-                            .format(runningNodesThreshold),
-                        statusServiceDriver.appStatusBuilder.getLiveInstances(),
-                        statusServiceDriver.appStatusBuilder
-                            .getDesiredInstances());
-                  }
-                  numAttempts--;
-                  continue;
-                } else {
-                  desiredStateAttained = true;
-                  statusServiceDriver.appStatusBuilder.setRunningThresholdAchieved(true);
-                }
               } else {
-                numAttempts--;
-                continue;
+                desiredStateAttained = true;
+                statusServiceDriver.appStatusBuilder.setRunningThresholdAchieved(true);
               }
+            } else {
+              numAttempts--;
+              continue;
             }
-          } else if (ret == ExitCode.YARN_ERROR.getInt() && watchMode) {
-            LOG.warn("Watch mode enabled and got YARN error. Retrying..");
-            numAttempts--;
-            continue;
-          } else if (ret == ExitCode.SLIDER_CLIENT_ERROR_CREATE_FAILED.getInt() && watchMode) {
-            LOG.warn("Watch mode enabled and slider client creation failed. Retrying..");
-            numAttempts--;
-            continue;
-          } else if (ret == ExitCode.SLIDER_CLIENT_ERROR_OTHER.getInt() && watchMode) {
-            LOG.warn("Watch mode enabled and got slider client error. Retrying..");
-            numAttempts--;
-            continue;
-          } else if (ret == ExitCode.LLAP_REGISTRY_ERROR.getInt() && watchMode) {
-            LOG.warn("Watch mode enabled and got LLAP registry error. Retrying..");
-            numAttempts--;
-            continue;
           }
-          break;
-        } finally {
-          // TODO Remove this before commit.
+        } else if (ret == ExitCode.YARN_ERROR.getInt() && watchMode) {
+          LOG.warn("Watch mode enabled and got YARN error. Retrying..");
+          numAttempts--;
+          continue;
+        } else if (ret == ExitCode.SLIDER_CLIENT_ERROR_CREATE_FAILED.getInt() && watchMode) {
+          LOG.warn("Watch mode enabled and slider client creation failed. Retrying..");
+          numAttempts--;
+          continue;
+        } else if (ret == ExitCode.SLIDER_CLIENT_ERROR_OTHER.getInt() && watchMode) {
+          LOG.warn("Watch mode enabled and got slider client error. Retrying..");
+          numAttempts--;
+          continue;
+        } else if (ret == ExitCode.LLAP_REGISTRY_ERROR.getInt() && watchMode) {
+          LOG.warn("Watch mode enabled and got LLAP registry error. Retrying..");
+          numAttempts--;
+          continue;
         }
+        break;
       }
       // Log final state to CONSOLE_LOGGER
       LlapStatusServiceDriver
@@ -1036,7 +1038,7 @@ private static long maybeLogSummary(Clock clock, long lastSummaryLogTime,
     if (lastSummaryLogTime < currentTime - LOG_SUMMARY_INTERVAL) {
       String diagString = null;
       if (launchingState == null && statusServiceDriver.appStatusBuilder.getState() ==
-          LlapStatusHelpers.State.COMPLETE && watchMode) {
+          State.COMPLETE && watchMode) {
         // First known state was COMPLETED. Wait for the app launch to start.
         diagString = "Awaiting LLAP launch";
         // Clear completed instances in this case. Don't want to provide information from the previous run.
