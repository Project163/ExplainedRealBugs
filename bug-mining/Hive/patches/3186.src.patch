diff --git a/ql/src/java/org/apache/hadoop/hive/ql/io/orc/RecordReaderImpl.java b/ql/src/java/org/apache/hadoop/hive/ql/io/orc/RecordReaderImpl.java
index 2745beec1d..458ad21733 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/io/orc/RecordReaderImpl.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/io/orc/RecordReaderImpl.java
@@ -83,7 +83,9 @@ class RecordReaderImpl implements RecordReader {
 
   private static final Log LOG = LogFactory.getLog(RecordReaderImpl.class);
   private static final boolean isLogTraceEnabled = LOG.isTraceEnabled();
+  private static final boolean isLogDebugEnabled = LOG.isDebugEnabled();
 
+  private final Path path;
   private final FSDataInputStream file;
   private final long firstRow;
   private final List<StripeInformation> stripes =
@@ -265,6 +267,7 @@ static int[] mapSargColumns(List<PredicateLeaf> sargLeaves,
                    long strideRate,
                    Configuration conf
                   ) throws IOException {
+    this.path = path;
     this.file = fileSystem.open(path);
     this.codec = codec;
     this.types = types;
@@ -3263,70 +3266,81 @@ private void advanceToNextRow(long nextRow) throws IOException {
 
   @Override
   public Object next(Object previous) throws IOException {
-    Object result = reader.next(previous);
-    // find the next row
-    rowInStripe += 1;
-    advanceToNextRow(rowInStripe + rowBaseInStripe);
-    if (isLogTraceEnabled) {
-      LOG.trace("row from " + reader.path);
-      LOG.trace("orc row = " + result);
+    try {
+      final Object result = reader.next(previous);
+      // find the next row
+      rowInStripe += 1;
+      advanceToNextRow(rowInStripe + rowBaseInStripe);
+      if (isLogTraceEnabled) {
+        LOG.trace("row from " + reader.path);
+        LOG.trace("orc row = " + result);
+      }
+      return result;
+    } catch (IOException e) {
+      // Rethrow exception with file name in log message
+      throw new IOException("Error reading file: " + path, e);
     }
-    return result;
   }
 
   @Override
   public VectorizedRowBatch nextBatch(VectorizedRowBatch previous) throws IOException {
-    VectorizedRowBatch result = null;
-    if (rowInStripe >= rowCountInStripe) {
-      currentStripe += 1;
-      readStripe();
-    }
-
-    long batchSize = 0;
+    try {
+      final VectorizedRowBatch result;
+      if (rowInStripe >= rowCountInStripe) {
+        currentStripe += 1;
+        readStripe();
+      }
+
+      long batchSize = 0;
+
+      // In case of PPD, batch size should be aware of row group boundaries. If only a subset of row
+      // groups are selected then marker position is set to the end of range (subset of row groups
+      // within strip). Batch size computed out of marker position makes sure that batch size is
+      // aware of row group boundary and will not cause overflow when reading rows
+      // illustration of this case is here https://issues.apache.org/jira/browse/HIVE-6287
+      if (rowIndexStride != 0 && includedRowGroups != null && rowInStripe < rowCountInStripe) {
+        int startRowGroup = (int) (rowInStripe / rowIndexStride);
+        if (!includedRowGroups[startRowGroup]) {
+          while (startRowGroup < includedRowGroups.length && !includedRowGroups[startRowGroup]) {
+            startRowGroup += 1;
+          }
+        }
 
-    // In case of PPD, batch size should be aware of row group boundaries. If only a subset of row
-    // groups are selected then marker position is set to the end of range (subset of row groups
-    // within strip). Batch size computed out of marker position makes sure that batch size is
-    // aware of row group boundary and will not cause overflow when reading rows
-    // illustration of this case is here https://issues.apache.org/jira/browse/HIVE-6287
-    if (rowIndexStride != 0 && includedRowGroups != null && rowInStripe < rowCountInStripe) {
-      int startRowGroup = (int) (rowInStripe / rowIndexStride);
-      if (!includedRowGroups[startRowGroup]) {
-        while (startRowGroup < includedRowGroups.length && !includedRowGroups[startRowGroup]) {
-          startRowGroup += 1;
+        int endRowGroup = startRowGroup;
+        while (endRowGroup < includedRowGroups.length && includedRowGroups[endRowGroup]) {
+          endRowGroup += 1;
         }
-      }
 
-      int endRowGroup = startRowGroup;
-      while (endRowGroup < includedRowGroups.length && includedRowGroups[endRowGroup]) {
-        endRowGroup += 1;
-      }
+        final long markerPosition =
+            (endRowGroup * rowIndexStride) < rowCountInStripe ? (endRowGroup * rowIndexStride)
+                : rowCountInStripe;
+        batchSize = Math.min(VectorizedRowBatch.DEFAULT_SIZE, (markerPosition - rowInStripe));
 
-      final long markerPosition = (endRowGroup * rowIndexStride) < rowCountInStripe ? (endRowGroup * rowIndexStride)
-          : rowCountInStripe;
-      batchSize = Math.min(VectorizedRowBatch.DEFAULT_SIZE, (markerPosition - rowInStripe));
+        if (isLogDebugEnabled && batchSize < VectorizedRowBatch.DEFAULT_SIZE) {
+          LOG.debug("markerPosition: " + markerPosition + " batchSize: " + batchSize);
+        }
+      } else {
+        batchSize = Math.min(VectorizedRowBatch.DEFAULT_SIZE, (rowCountInStripe - rowInStripe));
+      }
 
-      if (LOG.isDebugEnabled() && batchSize < VectorizedRowBatch.DEFAULT_SIZE) {
-        LOG.debug("markerPosition: " + markerPosition + " batchSize: " + batchSize);
+      rowInStripe += batchSize;
+      if (previous == null) {
+        ColumnVector[] cols = (ColumnVector[]) reader.nextVector(null, (int) batchSize);
+        result = new VectorizedRowBatch(cols.length);
+        result.cols = cols;
+      } else {
+        result = previous;
+        result.selectedInUse = false;
+        reader.nextVector(result.cols, (int) batchSize);
       }
-    } else {
-      batchSize = Math.min(VectorizedRowBatch.DEFAULT_SIZE, (rowCountInStripe - rowInStripe));
-    }
 
-    rowInStripe += batchSize;
-    if (previous == null) {
-      ColumnVector[] cols = (ColumnVector[]) reader.nextVector(null, (int) batchSize);
-      result = new VectorizedRowBatch(cols.length);
-      result.cols = cols;
-    } else {
-      result = (VectorizedRowBatch) previous;
-      result.selectedInUse = false;
-      reader.nextVector(result.cols, (int) batchSize);
+      result.size = (int) batchSize;
+      advanceToNextRow(rowInStripe + rowBaseInStripe);
+      return result;
+    } catch (IOException e) {
+      // Rethrow exception with file name in log message
+      throw new IOException("Error reading file: " + path, e);
     }
-
-    result.size = (int) batchSize;
-    advanceToNextRow(rowInStripe + rowBaseInStripe);
-    return result;
   }
 
   @Override
