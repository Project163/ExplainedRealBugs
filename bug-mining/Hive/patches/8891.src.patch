diff --git a/ql/src/test/queries/clientnegative/msck_repair_9.q b/ql/src/test/queries/clientnegative/msck_repair_9.q
new file mode 100644
index 0000000000..7dfe3834b5
--- /dev/null
+++ b/ql/src/test/queries/clientnegative/msck_repair_9.q
@@ -0,0 +1,7 @@
+DROP TABLE IF EXISTS tbl_int;
+
+CREATE EXTERNAL TABLE tbl_int (id INT, name STRING) PARTITIONED BY (month INT) stored as ORC location '${system:test.tmp.dir}/apps/hive/warehouse/test.db/tbl_int/';
+dfs ${system:test.dfs.mkdir} -p ${system:test.tmp.dir}/apps/hive/warehouse/test.db/tbl_int/month=random_partition;
+MSCK REPAIR TABLE tbl_int;
+
+DROP TABLE IF EXISTS tbl_int;
diff --git a/ql/src/test/queries/clientpositive/msck_repair_9.q b/ql/src/test/queries/clientpositive/msck_repair_9.q
index 5660a6f95d..42f0f91fee 100644
--- a/ql/src/test/queries/clientpositive/msck_repair_9.q
+++ b/ql/src/test/queries/clientpositive/msck_repair_9.q
@@ -14,9 +14,23 @@ SHOW PARTITIONS tbl_x;
 
 CREATE EXTERNAL TABLE tbl_y (id INT, name STRING) PARTITIONED BY (month INT, day INT) stored as ORC location '${system:test.tmp.dir}/apps/hive/warehouse/test.db/tbl_x/';
 
+set hive.msck.path.validation=skip;
+
 MSCK REPAIR TABLE tbl_y;
 
 SHOW PARTITIONS tbl_y;
 
+SET hive.exec.default.partition.name=SECOND_PARTITION;
+INSERT INTO tbl_y (id, name, day) values(4, 'ddd', 3);
+
+SET hive.exec.default.partition.name=OTHER_PARTITION;
+INSERT INTO tbl_y (id, name, day) values(4, 'ddd', 3);
+
+SHOW PARTITIONS tbl_y;
+
+set hive.msck.path.validation=ignore;
+MSCK REPAIR TABLE tbl_y;
+SHOW PARTITIONS tbl_y;
+
 DROP TABLE tbl_x;
 DROP TABLE tbl_y;
diff --git a/ql/src/test/results/clientnegative/msck_repair_9.q.out b/ql/src/test/results/clientnegative/msck_repair_9.q.out
new file mode 100644
index 0000000000..22a17bff68
--- /dev/null
+++ b/ql/src/test/results/clientnegative/msck_repair_9.q.out
@@ -0,0 +1,20 @@
+PREHOOK: query: DROP TABLE IF EXISTS tbl_int
+PREHOOK: type: DROPTABLE
+PREHOOK: Output: database:default
+POSTHOOK: query: DROP TABLE IF EXISTS tbl_int
+POSTHOOK: type: DROPTABLE
+POSTHOOK: Output: database:default
+#### A masked pattern was here ####
+PREHOOK: type: CREATETABLE
+#### A masked pattern was here ####
+PREHOOK: Output: database:default
+PREHOOK: Output: default@tbl_int
+#### A masked pattern was here ####
+POSTHOOK: type: CREATETABLE
+#### A masked pattern was here ####
+POSTHOOK: Output: database:default
+POSTHOOK: Output: default@tbl_int
+PREHOOK: query: MSCK REPAIR TABLE tbl_int
+PREHOOK: type: MSCK
+PREHOOK: Output: default@tbl_int
+FAILED: Execution Error, return code 40000 from org.apache.hadoop.hive.ql.ddl.DDLTask. For input string: "random_partition"
diff --git a/ql/src/test/results/clientpositive/llap/msck_repair_9.q.out b/ql/src/test/results/clientpositive/llap/msck_repair_9.q.out
index 1c6394b8f8..048bc72f11 100644
--- a/ql/src/test/results/clientpositive/llap/msck_repair_9.q.out
+++ b/ql/src/test/results/clientpositive/llap/msck_repair_9.q.out
@@ -90,7 +90,57 @@ PREHOOK: Output: default@tbl_y
 POSTHOOK: query: MSCK REPAIR TABLE tbl_y
 POSTHOOK: type: MSCK
 POSTHOOK: Output: default@tbl_y
-Partitions not in metastore:	tbl_y:month=12/day=2	tbl_y:month=12/day=3	tbl_y:month=12/day=__HIVE_DEFAULT_PARTITION__	tbl_y:month=ANOTHER_PARTITION/day=3
+Partitions not in metastore:	tbl_y:month=12/day=2	tbl_y:month=12/day=3	tbl_y:month=ANOTHER_PARTITION/day=3
+#### A masked pattern was here ####
+PREHOOK: query: SHOW PARTITIONS tbl_y
+PREHOOK: type: SHOWPARTITIONS
+PREHOOK: Input: default@tbl_y
+POSTHOOK: query: SHOW PARTITIONS tbl_y
+POSTHOOK: type: SHOWPARTITIONS
+POSTHOOK: Input: default@tbl_y
+month=12/day=2
+month=12/day=3
+month=ANOTHER_PARTITION/day=3
+PREHOOK: query: INSERT INTO tbl_y (id, name, day) values(4, 'ddd', 3)
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+PREHOOK: Output: default@tbl_y
+POSTHOOK: query: INSERT INTO tbl_y (id, name, day) values(4, 'ddd', 3)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+POSTHOOK: Output: default@tbl_y
+POSTHOOK: Output: default@tbl_y@month=SECOND_PARTITION/day=3
+POSTHOOK: Lineage: tbl_y PARTITION(month=SECOND_PARTITION,day=3).id SCRIPT []
+POSTHOOK: Lineage: tbl_y PARTITION(month=SECOND_PARTITION,day=3).name SCRIPT []
+PREHOOK: query: INSERT INTO tbl_y (id, name, day) values(4, 'ddd', 3)
+PREHOOK: type: QUERY
+PREHOOK: Input: _dummy_database@_dummy_table
+PREHOOK: Output: default@tbl_y
+POSTHOOK: query: INSERT INTO tbl_y (id, name, day) values(4, 'ddd', 3)
+POSTHOOK: type: QUERY
+POSTHOOK: Input: _dummy_database@_dummy_table
+POSTHOOK: Output: default@tbl_y
+POSTHOOK: Output: default@tbl_y@month=OTHER_PARTITION/day=3
+POSTHOOK: Lineage: tbl_y PARTITION(month=OTHER_PARTITION,day=3).id SCRIPT []
+POSTHOOK: Lineage: tbl_y PARTITION(month=OTHER_PARTITION,day=3).name SCRIPT []
+PREHOOK: query: SHOW PARTITIONS tbl_y
+PREHOOK: type: SHOWPARTITIONS
+PREHOOK: Input: default@tbl_y
+POSTHOOK: query: SHOW PARTITIONS tbl_y
+POSTHOOK: type: SHOWPARTITIONS
+POSTHOOK: Input: default@tbl_y
+month=12/day=2
+month=12/day=3
+month=ANOTHER_PARTITION/day=3
+month=OTHER_PARTITION/day=3
+month=SECOND_PARTITION/day=3
+PREHOOK: query: MSCK REPAIR TABLE tbl_y
+PREHOOK: type: MSCK
+PREHOOK: Output: default@tbl_y
+POSTHOOK: query: MSCK REPAIR TABLE tbl_y
+POSTHOOK: type: MSCK
+POSTHOOK: Output: default@tbl_y
+Partitions not in metastore:	tbl_y:month=12/day=__HIVE_DEFAULT_PARTITION__
 #### A masked pattern was here ####
 PREHOOK: query: SHOW PARTITIONS tbl_y
 PREHOOK: type: SHOWPARTITIONS
@@ -102,6 +152,8 @@ month=12/day=2
 month=12/day=3
 month=12/day=__HIVE_DEFAULT_PARTITION__
 month=ANOTHER_PARTITION/day=3
+month=OTHER_PARTITION/day=3
+month=SECOND_PARTITION/day=3
 PREHOOK: query: DROP TABLE tbl_x
 PREHOOK: type: DROPTABLE
 PREHOOK: Input: default@tbl_x
diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveMetaStoreChecker.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveMetaStoreChecker.java
index 4afc779cb6..e5a85783e0 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveMetaStoreChecker.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/HiveMetaStoreChecker.java
@@ -444,34 +444,37 @@ void findUnknownPartitions(Table table, Set<Path> missingPartDirs,
     for (Path partPath : missingPartDirs) {
       FileSystem fs = partPath.getFileSystem(conf);
       String partitionName = getPartitionName(fs.makeQualified(tablePath),
-          partPath, partColNames, partitionColToTypeMap);
+          partPath, partColNames, partitionColToTypeMap, conf);
+      if (partitionName == null) {
+        // Skip this partition if there is some issue in the partition validation
+        LOG.warn("Skipping partition : " + partPath.getName());
+        continue;
+      }
       LOG.debug("PartitionName: " + partitionName);
 
-      if (partitionName != null) {
-        CheckResult.PartitionResult pr = new CheckResult.PartitionResult();
-        pr.setPartitionName(partitionName);
-        pr.setTableName(table.getTableName());
-        // Also set the correct partition path here as creating path from Warehouse.makePartPath will always return
-        // lowercase keys/path. Even if we add the new partition with lowerkeys, get queries on such partition
-        // will not return any results.
-        pr.setPath(partPath);
-
-        // Check if partition already exists. No need to check for those partition which are present in db
-        // but no in fs as msck will override the partition location in db
-        if (result.getCorrectPartitions().contains(pr)) {
-          String msg = "The partition '" + pr.toString() + "' already exists for table" + table.getTableName();
-          throw new MetastoreException(msg);
-        } else if (result.getPartitionsNotInMs().contains(pr)) {
-          String msg = "Found two paths for same partition '" + pr.toString() + "' for table " + table.getTableName();
-          throw new MetastoreException(msg);
-        }
-        if (transactionalTable) {
-          setMaxTxnAndWriteIdFromPartition(partPath, pr);
-        }
-        result.getPartitionsNotInMs().add(pr);
-        if (result.getPartitionsNotOnFs().contains(pr)) {
-          result.getPartitionsNotOnFs().remove(pr);
-        }
+      CheckResult.PartitionResult pr = new CheckResult.PartitionResult();
+      pr.setPartitionName(partitionName);
+      pr.setTableName(table.getTableName());
+      // Also set the correct partition path here as creating path from Warehouse.makePartPath will always return
+      // lowercase keys/path. Even if we add the new partition with lowerkeys, get queries on such partition
+      // will not return any results.
+      pr.setPath(partPath);
+
+      // Check if partition already exists. No need to check for those partition which are present in db
+      // but no in fs as msck will override the partition location in db
+      if (result.getCorrectPartitions().contains(pr)) {
+        String msg = "The partition '" + pr.toString() + "' already exists for table" + table.getTableName();
+        throw new MetastoreException(msg);
+      } else if (result.getPartitionsNotInMs().contains(pr)) {
+        String msg = "Found two paths for same partition '" + pr.toString() + "' for table " + table.getTableName();
+        throw new MetastoreException(msg);
+      }
+      if (transactionalTable) {
+        setMaxTxnAndWriteIdFromPartition(partPath, pr);
+      }
+      result.getPartitionsNotInMs().add(pr);
+      if (result.getPartitionsNotOnFs().contains(pr)) {
+        result.getPartitionsNotOnFs().remove(pr);
       }
     }
     LOG.debug("Number of partitions not in metastore : " + result.getPartitionsNotInMs().size());
diff --git a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/utils/MetaStoreServerUtils.java b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/utils/MetaStoreServerUtils.java
index fd2e1926e4..77e93f838d 100644
--- a/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/utils/MetaStoreServerUtils.java
+++ b/standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/utils/MetaStoreServerUtils.java
@@ -63,7 +63,6 @@
 import org.apache.commons.collections.CollectionUtils;
 import org.apache.commons.collections.ListUtils;
 import org.apache.commons.lang3.StringUtils;
-import org.apache.commons.lang3.math.NumberUtils;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileStatus;
 import org.apache.hadoop.fs.Path;
@@ -1608,8 +1607,8 @@ public static Partition getPartition(IMetaStoreClient msc, Table tbl, Map<String
    * @return Partition name, for example partitiondate=2008-01-01
    */
   public static String getPartitionName(Path tablePath, Path partitionPath, Set<String> partCols,
-                                        Map<String, String> partitionColToTypeMap) {
-    String result = null;
+                                        Map<String, String> partitionColToTypeMap, Configuration conf) {
+    StringBuilder result = null;
     Path currPath = partitionPath;
     LOG.debug("tablePath:" + tablePath + ", partCols: " + partCols);
 
@@ -1620,7 +1619,7 @@ public static String getPartitionName(Path tablePath, Path partitionPath, Set<St
       if (parts.length > 0) {
         if (parts.length != 2) {
           LOG.warn(currPath.getName() + " is not a valid partition name");
-          return result;
+          return result.toString();
         }
 
         // Since hive stores partitions keys in lower case, if the hdfs path contains mixed case,
@@ -1629,43 +1628,68 @@ public static String getPartitionName(Path tablePath, Path partitionPath, Set<St
         // Do not convert the partitionValue to lowercase
         String partitionValue = parts[1];
         if (partCols.contains(partitionName)) {
+          String normalisedPartitionValue = getNormalisedPartitionValue(partitionValue,
+                  partitionColToTypeMap.get(partitionName), conf);
+          if (normalisedPartitionValue == null) {
+            return null;
+          }
           if (result == null) {
-            result = partitionName + "="
-                    + getNormalisedPartitionValue(partitionValue, partitionColToTypeMap.get(partitionName));
+            result = new StringBuilder(partitionName + "=" + normalisedPartitionValue);
           } else {
-            result = partitionName + "="
-                    + getNormalisedPartitionValue(partitionValue, partitionColToTypeMap.get(partitionName))
-                    + Path.SEPARATOR + result;
+            result.insert(0, partitionName + "=" + normalisedPartitionValue + Path.SEPARATOR);
           }
         }
       }
       currPath = currPath.getParent();
       LOG.debug("currPath=" + currPath);
     }
-    return result;
+    return (result == null) ? null : result.toString();
   }
 
-  public static String getNormalisedPartitionValue(String partitionValue, String type) {
-
-    if (!NumberUtils.isParsable(partitionValue)) {
+  public static String getNormalisedPartitionValue(String partitionValue, String type, Configuration conf) {
+    // 1. Handle simple exit cases first.
+    if (type == null) {
       return partitionValue;
     }
-
-    LOG.debug("Converting '" + partitionValue + "' to type: '" + type + "'.");
-
-    if (type.equalsIgnoreCase("tinyint")
-    || type.equalsIgnoreCase("smallint")
-    || type.equalsIgnoreCase("int")){
-      return Integer.toString(Integer.parseInt(partitionValue));
-    } else if (type.equalsIgnoreCase("bigint")){
-      return Long.toString(Long.parseLong(partitionValue));
-    } else if (type.equalsIgnoreCase("float")){
-      return Float.toString(Float.parseFloat(partitionValue));
-    } else if (type.equalsIgnoreCase("double")){
-      return Double.toString(Double.parseDouble(partitionValue));
-    } else if (type.startsWith("decimal")){
-      // Decimal datatypes are stored like decimal(10,10)
-      return new BigDecimal(partitionValue).stripTrailingZeros().toPlainString();
+    if (Objects.equals(partitionValue, MetastoreConf.getVar(conf,
+            MetastoreConf.ConfVars.DEFAULTPARTITIONNAME))) {
+      // This is the special partition name for NULL values. It should never be parsed.
+      return partitionValue;
+    }
+    // 2. If the type is not numeric, no normalization is needed.
+    String colType = ColumnType.getTypeName(type);
+    if (!ColumnType.NumericTypes.contains(colType)) {
+      return partitionValue;
+    }
+    // 3. At this point, we have a numeric type that needs normalization.
+    LOG.debug("Normalizing partition value '{}' for type '{}'.", partitionValue, type);
+    try {
+      switch (colType) {
+        case ColumnType.TINYINT_TYPE_NAME:
+        case ColumnType.SMALLINT_TYPE_NAME:
+        case ColumnType.INT_TYPE_NAME:
+          return Integer.toString(Integer.parseInt(partitionValue));
+        case ColumnType.BIGINT_TYPE_NAME:
+          return Long.toString(Long.parseLong(partitionValue));
+        case ColumnType.FLOAT_TYPE_NAME:
+          return Float.toString(Float.parseFloat(partitionValue));
+        case ColumnType.DOUBLE_TYPE_NAME:
+          return Double.toString(Double.parseDouble(partitionValue));
+        case ColumnType.DECIMAL_TYPE_NAME:
+          return new BigDecimal(partitionValue).stripTrailingZeros().toPlainString();
+      }
+    } catch (NumberFormatException e) {
+      // 4. Handle cases where the value cannot be parsed as the expected number type.
+      String validationMode = MetastoreConf.getVar(conf, MetastoreConf.ConfVars.MSCK_PATH_VALIDATION);
+      if ("throw".equals(validationMode)) {
+        LOG.error("Invalid partition value: Cannot parse '{}' as type '{}'. Failing MSCK. "
+                + "Set hive.msck.path.validation=skip to ignore invalid partitions.", partitionValue, type);
+        throw e;
+      } else if ("skip".equals(validationMode)) {
+        LOG.warn("Skipping invalid partition value '{}' for type '{}' due to parsing error.", partitionValue, type);
+        // Signals the caller to skip this partition.
+        return null;
+      }
     }
     return partitionValue;
   }
diff --git a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/utils/TestMetaStoreServerUtils.java b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/utils/TestMetaStoreServerUtils.java
index c09d983810..bb22300b33 100644
--- a/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/utils/TestMetaStoreServerUtils.java
+++ b/standalone-metastore/metastore-server/src/test/java/org/apache/hadoop/hive/metastore/utils/TestMetaStoreServerUtils.java
@@ -75,6 +75,7 @@
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.mock;
@@ -950,22 +951,55 @@ public void testAnonymizeConnectionURL() {
 
   @Test
   public void testConversionToSignificantNumericTypes() {
-    assertEquals("1", MetaStoreServerUtils.getNormalisedPartitionValue("0001", "tinyint"));
-    assertEquals("1", MetaStoreServerUtils.getNormalisedPartitionValue("0001", "smallint"));
-    assertEquals("10", MetaStoreServerUtils.getNormalisedPartitionValue("00010", "int"));
-    assertEquals("-10", MetaStoreServerUtils.getNormalisedPartitionValue("-00010", "int"));
-
-    assertEquals("10", MetaStoreServerUtils.getNormalisedPartitionValue("00010", "bigint"));
-    assertEquals("-10", MetaStoreServerUtils.getNormalisedPartitionValue("-00010", "bigint"));
-
-    assertEquals("1.01", MetaStoreServerUtils.getNormalisedPartitionValue("0001.0100", "float"));
-    assertEquals("-1.01", MetaStoreServerUtils.getNormalisedPartitionValue("-0001.0100", "float"));
-    assertEquals("1.01", MetaStoreServerUtils.getNormalisedPartitionValue("0001.010000", "double"));
-    assertEquals("-1.01", MetaStoreServerUtils.getNormalisedPartitionValue("-0001.010000", "double"));
-    assertEquals("1.01", MetaStoreServerUtils.getNormalisedPartitionValue("0001.0100", "decimal"));
-    assertEquals("-1.01", MetaStoreServerUtils.getNormalisedPartitionValue("-0001.0100", "decimal"));
+    Configuration metastoreConf = MetastoreConf.newMetastoreConf();
+    assertEquals("1", MetaStoreServerUtils.getNormalisedPartitionValue("0001", "tinyint", metastoreConf));
+    assertEquals("1", MetaStoreServerUtils.getNormalisedPartitionValue("0001", "smallint", metastoreConf));
+    assertEquals("10", MetaStoreServerUtils.getNormalisedPartitionValue("00010", "int", metastoreConf));
+    assertEquals("-10", MetaStoreServerUtils.getNormalisedPartitionValue("-00010", "int", metastoreConf));
+
+    assertEquals("10", MetaStoreServerUtils.getNormalisedPartitionValue("00010", "bigint", metastoreConf));
+    assertEquals("-10", MetaStoreServerUtils.getNormalisedPartitionValue("-00010", "bigint", metastoreConf));
+
+    assertEquals("1.01", MetaStoreServerUtils.getNormalisedPartitionValue("0001.0100", "float", metastoreConf));
+    assertEquals("-1.01", MetaStoreServerUtils.getNormalisedPartitionValue("-0001.0100", "float", metastoreConf));
+    assertEquals("1.01", MetaStoreServerUtils.getNormalisedPartitionValue("0001.010000", "double", metastoreConf));
+    assertEquals("-1.01", MetaStoreServerUtils.getNormalisedPartitionValue("-0001.010000", "double", metastoreConf));
+    assertEquals("1.01", MetaStoreServerUtils.getNormalisedPartitionValue("0001.0100", "decimal", metastoreConf));
+    assertEquals("-1.01", MetaStoreServerUtils.getNormalisedPartitionValue("-0001.0100", "decimal", metastoreConf));
+    assertEquals("-1.01", MetaStoreServerUtils.getNormalisedPartitionValue("-0001.0100", "decimal(10,10)", metastoreConf));
     assertEquals("__HIVE_DEFAULT_PARTITION__", MetaStoreServerUtils.getNormalisedPartitionValue(
-        "__HIVE_DEFAULT_PARTITION__", "decimal"));
+        "__HIVE_DEFAULT_PARTITION__", "decimal", metastoreConf));
+  }
+
+  @Test
+  public void testConversionFromStringToNumeric() {
+    Configuration metastoreConf = MetastoreConf.newMetastoreConf();
+    Assert.assertThrows(NumberFormatException.class, () -> MetaStoreServerUtils.getNormalisedPartitionValue(
+            "Random_Partition", "double", metastoreConf));
+    Assert.assertThrows(NumberFormatException.class, () -> MetaStoreServerUtils.getNormalisedPartitionValue(
+            "Random_Partition", "int", metastoreConf));
+    Assert.assertThrows(NumberFormatException.class, () -> MetaStoreServerUtils.getNormalisedPartitionValue(
+            "Random_Partition", "smallint", metastoreConf));
+    Assert.assertThrows(NumberFormatException.class, () -> MetaStoreServerUtils.getNormalisedPartitionValue(
+            "Random_Partition", "bigint", metastoreConf));
+    Assert.assertThrows(NumberFormatException.class, () -> MetaStoreServerUtils.getNormalisedPartitionValue(
+            "Random_Partition", "float", metastoreConf));
+    Assert.assertThrows(NumberFormatException.class, () -> MetaStoreServerUtils.getNormalisedPartitionValue(
+            "Random_Partition", "decimal", metastoreConf));
+
+    MetastoreConf.setVar(metastoreConf, MetastoreConf.ConfVars.MSCK_PATH_VALIDATION, "skip");
+      assertNull(MetaStoreServerUtils.getNormalisedPartitionValue(
+              "Random_Partition", "int", metastoreConf));
+      assertNull(MetaStoreServerUtils.getNormalisedPartitionValue(
+              "Random_Partition", "smallint", metastoreConf));
+      assertNull(MetaStoreServerUtils.getNormalisedPartitionValue(
+              "Random_Partition", "bigint", metastoreConf));
+      assertNull(MetaStoreServerUtils.getNormalisedPartitionValue(
+              "Random_Partition", "float", metastoreConf));
+      assertNull(MetaStoreServerUtils.getNormalisedPartitionValue(
+              "Random_Partition", "double", metastoreConf));
+      assertNull(MetaStoreServerUtils.getNormalisedPartitionValue(
+              "Random_Partition", "decimal", metastoreConf));
   }
 
   @Test
