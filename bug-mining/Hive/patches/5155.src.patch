diff --git a/llap-common/src/java/org/apache/hadoop/hive/llap/security/LlapTokenIdentifier.java b/llap-common/src/java/org/apache/hadoop/hive/llap/security/LlapTokenIdentifier.java
index 08c141f75d..0786b7a563 100644
--- a/llap-common/src/java/org/apache/hadoop/hive/llap/security/LlapTokenIdentifier.java
+++ b/llap-common/src/java/org/apache/hadoop/hive/llap/security/LlapTokenIdentifier.java
@@ -105,7 +105,8 @@ public boolean equals(Object obj) {
 
   @Override
   public String toString() {
-    return KIND + "; " + super.toString() + ", cluster " + clusterId + ", app ID " + appId;
+    return KIND + "; " + super.toString() + ", cluster " + clusterId
+        + ", app ID " + appId + ", signing " + isSigningRequired;
   }
 
   @InterfaceAudience.Private
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/ContainerRunnerImpl.java b/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/ContainerRunnerImpl.java
index 13460501d3..6d7d4dec1d 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/ContainerRunnerImpl.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/ContainerRunnerImpl.java
@@ -22,6 +22,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.apache.hadoop.conf.Configuration;
@@ -54,6 +55,7 @@
 import org.apache.hadoop.hive.llap.daemon.rpc.LlapDaemonProtocolProtos.VertexOrBinary;
 import org.apache.hadoop.hive.llap.metrics.LlapDaemonExecutorMetrics;
 import org.apache.hadoop.hive.llap.security.LlapSignerImpl;
+import org.apache.hadoop.hive.llap.security.LlapTokenIdentifier;
 import org.apache.hadoop.hive.llap.tez.Converters;
 import org.apache.hadoop.hive.llap.tezplugins.LlapTezUtils;
 import org.apache.hadoop.io.DataInputBuffer;
@@ -171,7 +173,13 @@ protected void serviceStop() throws Exception {
 
   @Override
   public SubmitWorkResponseProto submitWork(SubmitWorkRequestProto request) throws IOException {
-    LlapTokenInfo tokenInfo = LlapTokenChecker.getTokenInfo(clusterId);
+    LlapTokenInfo tokenInfo = null;
+    try {
+      tokenInfo = LlapTokenChecker.getTokenInfo(clusterId);
+    } catch (SecurityException ex) {
+      logSecurityErrorRarely(null);
+      throw ex;
+    }
     SignableVertexSpec vertex = extractVertexSpec(request, tokenInfo);
     TezEvent initialEvent = extractInitialEvent(request, tokenInfo);
 
@@ -296,10 +304,16 @@ private TezEvent extractInitialEvent(SubmitWorkRequestProto request, LlapTokenIn
     NotTezEvent initialEvent = NotTezEvent.parseFrom(initialEventBytes);
     if (tokenInfo.isSigningRequired) {
       if (!request.hasInitialEventSignature()) {
+        logSecurityErrorRarely(tokenInfo.userName);
         throw new SecurityException("Unsigned initial event is not allowed");
       }
       byte[] signatureBytes = request.getInitialEventSignature().toByteArray();
-      signer.checkSignature(initialEventBytes, signatureBytes, initialEvent.getKeyId());
+      try {
+        signer.checkSignature(initialEventBytes, signatureBytes, initialEvent.getKeyId());
+      } catch (SecurityException ex) {
+        logSecurityErrorRarely(tokenInfo.userName);
+        throw ex;
+      }
     }
     return NotTezEventHelper.toTezEvent(initialEvent);
   }
@@ -307,6 +321,7 @@ private TezEvent extractInitialEvent(SubmitWorkRequestProto request, LlapTokenIn
   private void checkSignature(SignableVertexSpec vertex, ByteString vertexBinary,
       SubmitWorkRequestProto request, String tokenUserName) throws SecurityException, IOException {
     if (!request.hasWorkSpecSignature()) {
+      logSecurityErrorRarely(tokenUserName);
       throw new SecurityException("Unsigned fragment not allowed");
     }
     if (vertexBinary == null) {
@@ -314,14 +329,36 @@ private void checkSignature(SignableVertexSpec vertex, ByteString vertexBinary,
       vertex.writeTo(os);
       vertexBinary = os.toByteString();
     }
-    signer.checkSignature(vertexBinary.toByteArray(),
-        request.getWorkSpecSignature().toByteArray(), (int)vertex.getSignatureKeyId());
+    try {
+      signer.checkSignature(vertexBinary.toByteArray(),
+          request.getWorkSpecSignature().toByteArray(), (int)vertex.getSignatureKeyId());
+    } catch (SecurityException ex) {
+      logSecurityErrorRarely(tokenUserName);
+      throw ex;
+    }
     if (!vertex.hasUser() || !vertex.getUser().equals(tokenUserName)) {
+      logSecurityErrorRarely(tokenUserName);
       throw new SecurityException("LLAP token is for " + tokenUserName
           + " but the fragment is for " + (vertex.hasUser() ? vertex.getUser() : null));
     }
   }
 
+  private final AtomicLong lastLoggedError = new AtomicLong(0);
+  private void logSecurityErrorRarely(String userName) {
+    if (!LOG.isWarnEnabled()) return;
+    long time = System.nanoTime();
+    long oldTime = lastLoggedError.get();
+    if (oldTime != 0 && (time - oldTime) < 1000000000L) return; // 1 second
+    if (!lastLoggedError.compareAndSet(oldTime, time)) return;
+    String tokens = null;
+    try {
+      tokens = "" + LlapTokenChecker.getLlapTokens(UserGroupInformation.getCurrentUser(), null);
+    } catch (Exception e) {
+      tokens = "error: " + e.getMessage();
+    }
+    LOG.warn("Security error from " + userName + "; cluster " + clusterId + "; tokens " + tokens);
+  }
+
   @Override
   public SourceStateUpdatedResponseProto sourceStateUpdated(
       SourceStateUpdatedRequestProto request) throws IOException {
diff --git a/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/LlapTokenChecker.java b/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/LlapTokenChecker.java
index c606c9bcb2..170ba33648 100644
--- a/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/LlapTokenChecker.java
+++ b/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/LlapTokenChecker.java
@@ -72,7 +72,7 @@ public static void warnMultipleTokens(List<LlapTokenIdentifier> tokens) {
     }
   }
 
-  private static List<LlapTokenIdentifier> getLlapTokens(
+  static List<LlapTokenIdentifier> getLlapTokens(
       UserGroupInformation ugi, String clusterId) {
     List<LlapTokenIdentifier> tokens = null;
     for (TokenIdentifier id : ugi.getTokenIdentifiers()) {
@@ -81,7 +81,7 @@ private static List<LlapTokenIdentifier> getLlapTokens(
         LOG.debug("Token {}", id);
       }
       LlapTokenIdentifier llapId = (LlapTokenIdentifier)id;
-      if (!clusterId.equals(llapId.getClusterId())) continue;
+      if (clusterId != null && !clusterId.equals(llapId.getClusterId())) continue;
       if (tokens == null) {
         tokens = new ArrayList<>();
       }
