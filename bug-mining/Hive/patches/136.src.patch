diff --git a/CHANGES.txt b/CHANGES.txt
index e8703c85f3..308ba56e50 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -15,6 +15,9 @@ Trunk - unreleased changes
 
     HIVE-402. Implement UDF regexp. (Raghu Murthy via namit)
 
+    HIVE-250. Shared memory java dbm for map-side joins.
+    (Joydeep Sen Sarma via zshao)
+
   IMPROVEMENTS
     HIVE-389. Option to build without ivy (jssarma)
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManager.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManager.java
new file mode 100644
index 0000000000..fd3e03e6c1
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManager.java
@@ -0,0 +1,240 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Copyright 2000-2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: RecordManager.java,v 1.3 2005/06/25 23:12:31 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm;
+
+import java.io.IOException;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.Serializer;
+
+/**
+ *  An interface to manages records, which are uninterpreted blobs of data.
+ *  <p>
+ *  The set of record operations is simple: fetch, insert, update and delete.
+ *  Each record is identified using a "rowid" and contains a byte[] data block.
+ *  Rowids are returned on inserts and you can store them someplace safe
+ *  to be able to get  back to them.  Data blocks can be as long as you wish,
+ *  and may have lengths different from the original when updating.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @author <a href="cg@cdegroot.com">Cees de Groot</a>
+ * @version $Id: RecordManager.java,v 1.3 2005/06/25 23:12:31 doomdark Exp $
+ */
+public interface RecordManager
+{
+
+    /**
+     * Reserved slot for name directory.
+     */
+    public static final int NAME_DIRECTORY_ROOT = 0;
+
+
+    /**
+     *  Inserts a new record using standard java object serialization.
+     *
+     *  @param obj the object for the new record.
+     *  @return the rowid for the new record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract long insert( Object obj )
+        throws IOException;
+
+    
+    /**
+     *  Inserts a new record using a custom serializer.
+     *
+     *  @param obj the object for the new record.
+     *  @param serializer a custom serializer
+     *  @return the rowid for the new record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract long insert( Object obj, Serializer serializer )
+        throws IOException;
+
+
+    /**
+     *  Deletes a record.
+     *
+     *  @param recid the rowid for the record that should be deleted.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract void delete( long recid )
+        throws IOException;
+
+
+    /**
+     *  Updates a record using standard java object serialization.
+     *
+     *  @param recid the recid for the record that is to be updated.
+     *  @param obj the new object for the record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract void update( long recid, Object obj )
+        throws IOException;
+
+
+    /**
+     *  Updates a record using a custom serializer.
+     *
+     *  @param recid the recid for the record that is to be updated.
+     *  @param obj the new object for the record.
+     *  @param serializer a custom serializer
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract void update( long recid, Object obj, Serializer serializer )
+        throws IOException;
+
+    
+    /**
+     *  Fetches a record using standard java object serialization.
+     *
+     *  @param recid the recid for the record that must be fetched.
+     *  @return the object contained in the record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract Object fetch( long recid )
+        throws IOException;
+
+
+    /**
+     *  Fetches a record using a custom serializer.
+     *
+     *  @param recid the recid for the record that must be fetched.
+     *  @param serializer a custom serializer
+     *  @return the object contained in the record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract Object fetch( long recid, Serializer serializer )
+        throws IOException;
+
+
+    /**
+     *  Closes the record manager.
+     *
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract void close()
+        throws IOException;
+
+
+    /**
+     *  Returns the number of slots available for "root" rowids. These slots
+     *  can be used to store special rowids, like rowids that point to
+     *  other rowids. Root rowids are useful for bootstrapping access to
+     *  a set of data.
+     */
+    public abstract int getRootCount();
+
+
+    /**
+     *  Returns the indicated root rowid.
+     *
+     *  @see #getRootCount
+     */
+    public abstract long getRoot( int id )
+        throws IOException;
+
+
+    /**
+     *  Sets the indicated root rowid.
+     *
+     *  @see #getRootCount
+     */
+    public abstract void setRoot( int id, long rowid )
+        throws IOException;
+
+
+    /**
+     * Commit (make persistent) all changes since beginning of transaction.
+     */
+    public abstract void commit()
+        throws IOException;
+
+
+    /**
+     * Rollback (cancel) all changes since beginning of transaction.
+     */
+    public abstract void rollback()
+        throws IOException;
+
+
+
+
+    /**
+     * Obtain the record id of a named object. Returns 0 if named object
+     * doesn't exist.
+     */
+    public abstract long getNamedObject( String name )
+        throws IOException;
+
+
+    /**
+     * Set the record id of a named object.
+     */
+    public abstract void setNamedObject( String name, long recid )
+        throws IOException;
+
+}
+
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManagerFactory.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManagerFactory.java
new file mode 100644
index 0000000000..c9f804eacf
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManagerFactory.java
@@ -0,0 +1,135 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Copyright 2000-2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: RecordManagerFactory.java,v 1.2 2005/06/25 23:12:31 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm;
+
+import java.io.IOException;
+import java.util.Properties;
+
+/**
+ * This is the factory class to use for instantiating {@link RecordManager}
+ * instances.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @author <a href="cg@cdegroot.com">Cees de Groot</a>
+ * @version $Id: RecordManagerFactory.java,v 1.2 2005/06/25 23:12:31 doomdark Exp $
+ */
+public final class RecordManagerFactory
+{
+
+    /**
+     * Create a record manager.
+     *
+     * @param name Name of the record file.
+     * @throws IOException if an I/O related exception occurs while creating
+     *                    or opening the record manager.
+     * @throws UnsupportedOperationException if some options are not supported by the
+     *                                      implementation.
+     * @throws IllegalArgumentException if some options are invalid.
+     */
+    public static RecordManager createRecordManager( String name )
+        throws IOException
+    {
+        return createRecordManager( name, new Properties() );
+    }
+
+
+    /**
+     * Create a record manager.
+     *
+     * @param name Name of the record file.
+     * @param options Record manager options.
+     * @throws IOException if an I/O related exception occurs while creating
+     *                    or opening the record manager.
+     * @throws UnsupportedOperationException if some options are not supported by the
+     *                                      implementation.
+     * @throws IllegalArgumentException if some options are invalid.
+     */
+    public static RecordManager createRecordManager( String name,
+                                                     Properties options )
+        throws IOException
+    {
+        String                 provider;
+        Class                  clazz;
+        RecordManagerProvider  factory;
+
+        provider = options.getProperty( RecordManagerOptions.PROVIDER_FACTORY,
+                                        "jdbm.recman.Provider" );
+
+        try {
+            clazz = Class.forName( provider );
+            factory = (RecordManagerProvider) clazz.newInstance();
+        } catch ( Exception except ) {
+            throw new IllegalArgumentException( "Invalid record manager provider: "
+                                                + provider
+                                                + "\n[" + except.getClass().getName()
+                                                + ": " + except.getMessage()
+                                                + "]" );
+        }
+        return factory.createRecordManager( name, options );
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManagerOptions.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManagerOptions.java
new file mode 100644
index 0000000000..1cebaecf04
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManagerOptions.java
@@ -0,0 +1,141 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Copyright 2000-2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: RecordManagerOptions.java,v 1.1 2002/05/31 06:33:20 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm;
+
+/**
+ * Standard options for RecordManager.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @author <a href="cg@cdegroot.com">Cees de Groot</a>
+ * @version $Id: RecordManagerOptions.java,v 1.1 2002/05/31 06:33:20 boisvert Exp $
+ */
+public class RecordManagerOptions
+{
+
+    /**
+     * Option to create a thread-safe record manager.
+     */
+    public static final String PROVIDER_FACTORY = "jdbm.provider";
+
+
+    /**
+     * Option to create a thread-safe record manager.
+     */
+    public static final String THREAD_SAFE = "jdbm.threadSafe";
+
+
+    /**
+     * Option to automatically commit data after each operation.
+     */
+    public static final String AUTO_COMMIT = "jdbm.autoCommit";
+
+
+    /**
+     * Option to disable transaction (to increase performance at the cost of
+     * potential data loss).
+     */
+    public static final String DISABLE_TRANSACTIONS = "jdbm.disableTransactions";
+
+
+    /**
+     * Cache type.
+     */
+    public static final String CACHE_TYPE = "jdbm.cache.type";
+
+
+    /**
+     * Cache size (when applicable)
+     */
+    public static final String CACHE_SIZE = "jdbm.cache.size";
+
+
+    /**
+     * Use normal (strong) object references for the record cache.
+     */
+    public static final String NORMAL_CACHE = "normal";
+
+
+    /**
+     * Use soft references {$link java.lang.ref.SoftReference} for the record
+     * cache instead of the default normal object references.
+     * <p>
+     * Soft references are cleared at the discretion of the garbage collector
+     * in response to memory demand.
+     */
+    public static final String SOFT_REF_CACHE = "soft";
+
+
+    /**
+     * Use weak references {$link java.lang.ref.WeakReference} for the record
+     * cache instead of the default normal object references.
+     * <p>
+     * Weak references do not prevent their referents from being made
+     * finalizable, finalized, and then reclaimed.
+     */
+    public static final String WEAK_REF_CACHE = "weak";
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManagerProvider.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManagerProvider.java
new file mode 100644
index 0000000000..116eadc232
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/RecordManagerProvider.java
@@ -0,0 +1,96 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Copyright 2000-2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: RecordManagerProvider.java,v 1.2 2005/06/25 23:12:31 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm;
+
+import java.io.IOException;
+import java.util.Properties;
+
+/**
+ *  Provider of RecordManager implementation.  Classes implementing this
+ *  interface act as a factory to provide implementations of RecordManager.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: RecordManagerProvider.java,v 1.2 2005/06/25 23:12:31 doomdark Exp $
+ */
+public interface RecordManagerProvider
+{
+
+    /**
+     * Create a record manager.
+     *
+     * @param filename Base filename of the record file.
+     * @param options Record manager options.
+     * @throws IOException if an I/O related exception occurs while creating
+     *                    or opening the record manager.
+     * @throws UnsupportedOperationException if some options are not supported by the
+     *                                      implementation.
+     * @throws IllegalArgumentException if some options are invalid.
+     */
+    public RecordManager createRecordManager( String filename,
+                                              Properties options )
+        throws IOException;
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/ByteArrayComparator.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/ByteArrayComparator.java
new file mode 100644
index 0000000000..7d84f53176
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/ByteArrayComparator.java
@@ -0,0 +1,152 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.util.Comparator;
+import java.io.Serializable;
+
+/**
+ * Comparator for byte arrays.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: ByteArrayComparator.java,v 1.4 2002/05/31 06:33:20 boisvert Exp $
+ */
+public final class ByteArrayComparator
+    implements Comparator, Serializable
+{
+
+    /**
+     * Version id for serialization.
+     */
+    final static long serialVersionUID = 1L;
+
+
+    /**
+     * Compare two objects.
+     *
+     * @param obj1 First object
+     * @param obj2 Second object
+     * @return a positive integer if obj1 > obj2, 0 if obj1 == obj2,
+     *         and a negative integer if obj1 < obj2
+     */
+     public int compare( Object obj1, Object obj2 )
+     {
+        if ( obj1 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj1' is null" );
+        }
+
+        if ( obj2 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj2' is null" );
+        }
+
+        return compareByteArray( (byte[]) obj1, (byte[]) obj2 );
+     }
+
+
+    /**
+     * Compare two byte arrays.
+     */
+    public static int compareByteArray( byte[] thisKey, byte[] otherKey )
+    {
+        int len = Math.min( thisKey.length, otherKey.length );
+
+        // compare the byte arrays
+        for ( int i=0; i<len; i++ ) {
+            if ( thisKey[i] >= 0 ) {
+                if ( otherKey[i] >= 0 ) {
+                    // both positive
+                    if ( thisKey[i] < otherKey[i] ) {
+                        return -1;
+                    } else if ( thisKey[i] > otherKey[i] ) {
+                        return 1;
+                    }
+                } else {
+                    // otherKey is negative => greater (because MSB is 1)
+                    return -1;
+                }
+            } else {
+                if ( otherKey[i] >= 0 ) {
+                    // thisKey is negative => greater (because MSB is 1)
+                    return 1;
+                } else {
+                    // both negative
+                    if ( thisKey[i] < otherKey[i] ) {
+                        return -1;
+                    } else if ( thisKey[i] > otherKey[i] ) {
+                        return 1;
+                    }
+                }
+            }
+        }
+        if ( thisKey.length == otherKey.length) {
+            return 0;
+        }
+        if ( thisKey.length < otherKey.length ) {
+            return -1;
+        }
+        return 1;
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/ByteArraySerializer.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/ByteArraySerializer.java
new file mode 100644
index 0000000000..b4036b7ff4
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/ByteArraySerializer.java
@@ -0,0 +1,120 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.IOException;
+
+
+/**
+ * Serializer for byte arrays -- simple returns the byte array itself.  No actual
+ * serialization is performed.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: ByteArraySerializer.java,v 1.1 2003/03/21 02:48:42 boisvert Exp $
+ */
+public final class ByteArraySerializer
+    implements Serializer
+{
+
+    /**
+     * Version id for serialization.
+     */
+    final static long serialVersionUID = 1L;
+
+
+    /**
+     * Static instance.
+     */
+    public static final ByteArraySerializer INSTANCE = new ByteArraySerializer();
+    
+    
+    /** 
+     * Serialize the content of an object into a byte array.
+     *
+     * @param obj Object to serialize
+     * @return a byte array representing the object's state
+     *
+     */
+    public byte[] serialize( Object obj ) 
+        throws IOException
+    {
+        return (byte[]) obj;
+    }
+
+    
+    /**
+     * Deserialize the content of an object from a byte array.
+     *
+     * @param serialized Byte array representation of the object
+     * @return deserialized object
+     *
+     */
+    public Object deserialize( byte[] serialized ) 
+        throws IOException
+    {
+        return serialized;
+    }    
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/CacheEvictionException.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/CacheEvictionException.java
new file mode 100644
index 0000000000..68d10c2a39
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/CacheEvictionException.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: CacheEvictionException.java,v 1.4 2003/10/21 15:43:20 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+/**
+ *  Exception that occurs during eviction of an object in the cache.
+ *
+ *  @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ *  @version $Id: CacheEvictionException.java,v 1.4 2003/10/21 15:43:20 boisvert Exp $
+ */
+public class CacheEvictionException
+    extends Exception
+{
+
+    /**
+     * Nested exception -- the original exception that occured, if any.
+     */
+    protected Exception _nested;
+
+
+    public CacheEvictionException( Exception nested )
+    {
+        _nested = nested;
+    }
+
+    public Exception getNestedException()
+    {
+        return _nested;
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/CachePolicy.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/CachePolicy.java
new file mode 100644
index 0000000000..c6221435b1
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/CachePolicy.java
@@ -0,0 +1,161 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: CachePolicy.java,v 1.5 2003/11/01 13:25:02 dranatunga Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.util.Enumeration;
+
+/**
+ *  CachePolicity is an abstraction for different cache policies.
+ *  (ie. MRU, time-based, soft-refs, ...)
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @author <a href="mailto:dranatunga@users.sourceforge.net">Dilum Ranatunga</a>
+ * @version $Id: CachePolicy.java,v 1.5 2003/11/01 13:25:02 dranatunga Exp $
+ */
+public interface CachePolicy
+{
+
+    /**
+     * Place an object in the cache. If the cache does not currently contain
+     * an object for the key specified, this mapping is added. If an object
+     * currently exists under the specified key, the current object is
+     * replaced with the new object.
+     * <p>
+     * If the changes to the cache cause the eviction of any objects
+     * <strong>stored under other key(s)</strong>, events corresponding to
+     * the evictions are fired for each object. If an event listener is
+     * unable to handle the eviction, and throws a cache eviction exception,
+     * that exception is propagated to the caller. If such an exception is
+     * thrown, the cache itself should be left as it was before the
+     * <code>put()</code> operation was invoked: the the object whose
+     * eviction failed is still in the cache, and the new insertion or
+     * modification is reverted.
+     *
+     * @param key key for the cached object
+     * @param value the cached object
+     * @throws CacheEvictionException propagated if, while evicting objects
+     *     to make room for new object, an eviction listener encountered
+     *     this problem.
+     */
+    public void put( Object key, Object value )
+        throws CacheEvictionException;
+
+
+    /**
+     * Obtain the object stored under the key specified.
+     *
+     * @param key key the object was cached under
+     * @return the object if it is still in the cache, null otherwise.
+     */
+    public Object get( Object key );
+
+
+    /**
+     * Remove the object stored under the key specified. Note that since
+     * eviction notices are only fired when objects under <strong>different
+     * keys</strong> are evicted, no event is fired for any object stored
+     * under this key (see {@link #put(Object, Object) put( )}).
+     *
+     * @param key key the object was stored in the cache under.
+     */
+    public void remove( Object key );
+
+
+    /**
+     * Remove all objects from the cache. Consistent with
+     * {@link #remove(Object) remove( )}, no eviction notices are fired.
+     */
+    public void removeAll();
+
+
+    /**
+     * Enumerate through the objects currently in the cache.
+     */
+    public Enumeration elements();
+
+
+    /**
+     * Add a listener to this cache policy.
+     * <p>
+     * If this cache policy already contains a listener that is equal to
+     * the one being added, this call has no effect.
+     *
+     * @param listener the (non-null) listener to add to this policy
+     * @throws IllegalArgumentException if listener is null.
+     */
+    public void addListener( CachePolicyListener listener )
+            throws IllegalArgumentException;
+
+    
+    /**
+     * Remove a listener from this cache policy. The listener is found
+     * using object equality, not identity.
+     *
+     * @param listener the listener to remove from this policy
+     */
+    public void removeListener( CachePolicyListener listener );
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/CachePolicyListener.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/CachePolicyListener.java
new file mode 100644
index 0000000000..73c637923f
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/CachePolicyListener.java
@@ -0,0 +1,95 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: CachePolicyListener.java,v 1.3 2003/11/01 13:25:41 dranatunga Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+/**
+ * Callback interface between {@link CachePolicy} and a Cache implementation
+ * to notify about cached object eviction.
+ * <p>
+ * Note that <code>CachePolicy</code> implementations typically use
+ * <em>object equality</em> when removing listeners, so concrete
+ * implementations of this interface should also pay attention to
+ * their {@link Object#equals(Object)} and {@link Object#hashCode()}
+ * methods.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: CachePolicyListener.java,v 1.3 2003/11/01 13:25:41 dranatunga Exp $
+ */
+public interface CachePolicyListener {
+
+    /**
+     * Notification that the cache this listener is attached to is evicting
+     * the object indicated.
+     *
+     * @param obj object being evited from cache
+     * @throws CacheEvictionException if this listener encountered problems
+     *     while preparing for the specified object's eviction. For example,
+     *     a listener may try to persist the object to disk, and encounter
+     *     an <code>IOException</code>.
+     */
+    public void cacheObjectEvicted(Object obj) throws CacheEvictionException;
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Conversion.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Conversion.java
new file mode 100644
index 0000000000..3a4e935c68
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Conversion.java
@@ -0,0 +1,241 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+
+/**
+ * Miscelaneous conversion utility methods.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: Conversion.java,v 1.3 2002/05/31 06:33:20 boisvert Exp $
+ */
+public class Conversion
+{
+
+    /**
+     * Convert a string into a byte array.
+     */
+    public static byte[] convertToByteArray( String s )
+    {
+        try {
+            // see the following page for character encoding
+            // http://java.sun.com/products/jdk/1.1/docs/guide/intl/encoding.doc.html
+            return s.getBytes( "UTF8" );
+        } catch ( java.io.UnsupportedEncodingException uee ) {
+            uee.printStackTrace();
+            throw new Error( "Platform doesn't support UTF8 encoding" );
+        }
+    }
+
+
+    /**
+     * Convert a byte into a byte array.
+     */
+    public static byte[] convertToByteArray( byte n )
+    {
+        n = (byte)( n ^ ( (byte) 0x80 ) ); // flip MSB because "byte" is signed
+        return new byte[] { n };
+    }
+
+
+    /**
+     * Convert a short into a byte array.
+     */
+    public static byte[] convertToByteArray( short n )
+    {
+        n = (short) ( n ^ ( (short) 0x8000 ) ); // flip MSB because "short" is signed
+        byte[] key = new byte[ 2 ];
+        pack2( key, 0, n );
+        return key;
+    }
+
+
+    /**
+     * Convert an int into a byte array.
+     */
+    public static byte[] convertToByteArray( int n )
+    {
+        n = (n ^ 0x80000000); // flip MSB because "int" is signed
+        byte[] key = new byte[4];
+        pack4(key, 0, n);
+        return key;
+    }
+
+
+    /**
+     * Convert a long into a byte array.
+     */
+    public static byte[] convertToByteArray( long n )
+    {
+        n = (n ^ 0x8000000000000000L); // flip MSB because "long" is signed
+        byte[] key = new byte[8];
+        pack8( key, 0, n );
+        return key;
+    }
+
+
+    /**
+     * Convert a byte array (encoded as UTF-8) into a String
+     */
+    public static String convertToString( byte[] buf )
+    {
+        try {
+            // see the following page for character encoding
+            // http://java.sun.com/products/jdk/1.1/docs/guide/intl/encoding.doc.html
+            return new String( buf, "UTF8" );
+        } catch ( java.io.UnsupportedEncodingException uee ) {
+            uee.printStackTrace();
+            throw new Error( "Platform doesn't support UTF8 encoding" );
+        }
+    }
+
+
+    /**
+     * Convert a byte array into an integer (signed 32-bit) value.
+     */
+    public static int convertToInt( byte[] buf )
+    {
+        int value = unpack4( buf, 0 );
+        value = ( value ^ 0x80000000 ); // flip MSB because "int" is signed
+        return value;
+    }
+
+
+    /**
+     * Convert a byte array into a long (signed 64-bit) value.
+     */
+    public static long convertToLong( byte[] buf )
+    {
+        long value = ( (long) unpack4( buf, 0 ) << 32  )
+                     + ( unpack4( buf, 4 ) & 0xFFFFFFFFL );
+        value = ( value ^ 0x8000000000000000L ); // flip MSB because "long" is signed
+        return value;
+    }
+
+
+
+
+    static int unpack4( byte[] buf, int offset )
+    {
+        int value = ( buf[ offset ] << 24 )
+            | ( ( buf[ offset+1 ] << 16 ) & 0x00FF0000 )
+            | ( ( buf[ offset+2 ] << 8 ) & 0x0000FF00 )
+            | ( ( buf[ offset+3 ] << 0 ) & 0x000000FF );
+
+        return value;
+    }
+
+
+    static final void pack2( byte[] data, int offs, int val )
+    {
+        data[offs++] = (byte) ( val >> 8 );
+        data[offs++] = (byte) val;
+    }
+
+
+    static final void pack4( byte[] data, int offs, int val )
+    {
+        data[offs++] = (byte) ( val >> 24 );
+        data[offs++] = (byte) ( val >> 16 );
+        data[offs++] = (byte) ( val >> 8 );
+        data[offs++] = (byte) val;
+    }
+
+
+    static final void pack8( byte[] data, int offs, long val )
+    {
+        pack4( data, 0, (int) ( val >> 32 ) );
+        pack4( data, 4, (int) val );
+    }
+
+
+    /**
+     * Test static methods
+     */
+    public static void main( String[] args )
+    {
+        byte[] buf;
+
+        buf = convertToByteArray( (int) 5 );
+        System.out.println( "int value of 5 is: " + convertToInt( buf ) );
+
+        buf = convertToByteArray( (int) -1 );
+        System.out.println( "int value of -1 is: " + convertToInt( buf ) );
+
+        buf = convertToByteArray( (int) 22111000 );
+        System.out.println( "int value of 22111000 is: " + convertToInt( buf ) );
+
+
+        buf = convertToByteArray( (long) 5L );
+        System.out.println( "long value of 5 is: " + convertToLong( buf ) );
+
+        buf = convertToByteArray( (long) -1L );
+        System.out.println( "long value of -1 is: " + convertToLong( buf ) );
+
+        buf = convertToByteArray( (long) 1112223334445556667L );
+        System.out.println( "long value of 1112223334445556667 is: " + convertToLong( buf ) );
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/DefaultSerializer.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/DefaultSerializer.java
new file mode 100644
index 0000000000..561e4e972d
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/DefaultSerializer.java
@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.IOException;
+
+/**
+ * Default java serializer.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: DefaultSerializer.java,v 1.2 2003/09/21 15:47:00 boisvert Exp $
+ */
+public class DefaultSerializer
+    implements Serializer
+{
+
+    
+    public static final DefaultSerializer INSTANCE = new DefaultSerializer();
+    
+    
+    /**
+     * Construct a DefaultSerializer.
+     */
+    public DefaultSerializer()
+    {
+        // no op
+    }
+
+    
+    /**
+     * Serialize the content of an object into a byte array.
+     *
+     * @param obj Object to serialize
+     * @return a byte array representing the object's state
+     */
+     public byte[] serialize( Object obj )
+        throws IOException
+     {
+         return Serialization.serialize( obj );
+     }
+        
+        
+    /**
+     * Deserialize the content of an object from a byte array.
+     *
+     * @param serialized Byte array representation of the object
+     * @return deserialized object
+     */
+     public Object deserialize( byte[] serialized )
+        throws IOException
+     {
+         try {
+            return Serialization.deserialize( serialized );
+         } catch ( ClassNotFoundException except ) {
+            throw new WrappedRuntimeException( except );
+         }
+     }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/FastIterator.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/FastIterator.java
new file mode 100644
index 0000000000..7b68255a59
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/FastIterator.java
@@ -0,0 +1,86 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: FastIterator.java,v 1.2 2003/10/21 15:43:58 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+
+/**
+ * Fast and simple iterator.
+ *
+ * @version $Revision: 1.2 $
+ * @author <a href="boisvert@intalio.com">Alex Boisvert</a>
+ */
+public abstract class FastIterator
+{
+
+    /**
+     * Returns the next element in the interation.
+     *
+     * @return the next element in the iteration, or null if no more element.
+     */
+    public abstract Object next()
+        throws IterationException;
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/IntegerComparator.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/IntegerComparator.java
new file mode 100644
index 0000000000..b5a1c3d0a2
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/IntegerComparator.java
@@ -0,0 +1,123 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.Serializable;
+import java.util.Comparator;
+
+/**
+ * Comparator for Integer objects.
+ *
+ * @author <a href="mailto:cdaller@iicm.edu">Christof Dallermassl</a>
+ * @version $Id: IntegerComparator.java,v 1.2 2002/05/31 06:33:20 boisvert Exp $
+ */
+public final class IntegerComparator
+    implements Comparator, Serializable
+{
+
+    /**
+     * Version id for serialization.
+     */
+    final static long serialVersionUID = 1L;
+
+
+    /**
+     * Compare two objects.
+     *
+     * @param obj1 First object
+     * @param obj2 Second object
+     * @return a positive integer if obj1 > obj2, 0 if obj1 == obj2,
+     *         and a negative integer if obj1 < obj2
+     */
+    public int compare( Object obj1, Object obj2 )
+    {
+        if ( obj1 == obj2 ) {
+            return 0;
+        }
+
+        if ( obj1 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj1' is null" );
+        }
+
+        if ( obj2 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj2' is null" );
+        }
+
+        // complicated to avoid usage of Integer.compareTo, as this
+        // method is Java 1.2 only!
+        int int1 = ( (Integer) obj1 ).intValue();
+        int int2 = ( (Integer) obj2 ).intValue();
+        if ( int1 == int2 ) {
+            return 0;
+        }
+
+        if ( int1 < int2 ) {
+          return -1;
+        } else {
+          return 1;
+        }
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/IntegerSerializer.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/IntegerSerializer.java
new file mode 100644
index 0000000000..c4aaa8acc1
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/IntegerSerializer.java
@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.IOException;
+
+/**
+ * Optimized serializer for integers.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: IntegerSerializer.java,v 1.2 2003/09/21 15:47:00 boisvert Exp $
+ */
+public class IntegerSerializer
+    implements Serializer
+{
+
+    
+    public static final IntegerSerializer INSTANCE = new IntegerSerializer();
+    
+    
+    /**
+     * Construct an IntegerSerializer.
+     */
+    public IntegerSerializer()
+    {
+        // no op
+    }
+
+    
+    /**
+     * Serialize the content of an object into a byte array.
+     *
+     * @param obj Object to serialize
+     * @return a byte array representing the object's state
+     */
+     public byte[] serialize( Object obj )
+        throws IOException
+     {
+         Integer number = (Integer) obj;
+         return Conversion.convertToByteArray( number.intValue() );
+     }
+        
+        
+    /**
+     * Deserialize the content of an object from a byte array.
+     *
+     * @param serialized Byte array representation of the object
+     * @return deserialized object
+     */
+     public Object deserialize( byte[] serialized )
+        throws IOException
+     {
+         int number = Conversion.convertToInt( serialized );
+         return new Integer( number );
+     }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/IterationException.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/IterationException.java
new file mode 100644
index 0000000000..24cf6eee48
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/IterationException.java
@@ -0,0 +1,115 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: IterationException.java,v 1.2 2003/09/21 15:47:00 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+
+/**
+ * Iteration exception.
+ *
+ * @author <a href="boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Revision: 1.2 $
+ */
+public class IterationException
+    extends WrappedRuntimeException
+{
+
+    /**
+     * Construct a new iteration exception wrapping an underlying exception
+     * and providing a message.
+     *
+     * @param message The exception message
+     * @param except The underlying exception
+     */
+    public IterationException( String message, Exception except )
+    {
+        super( message, except );
+    }
+
+
+    /**
+     * Construct a new iteration exception with a message.
+     *
+     * @param message The exception message
+     */
+    public IterationException( String message )
+    {
+        super( message, null );
+    }
+
+
+    /**
+     * Construct a new iteration exception wrapping an underlying exception.
+     *
+     * @param except The underlying exception
+     */
+    public IterationException( Exception except )
+    {
+        super( except );
+    }
+
+}
+
+
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/LongComparator.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/LongComparator.java
new file mode 100644
index 0000000000..ca0f6af4bd
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/LongComparator.java
@@ -0,0 +1,116 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.Serializable;
+import java.util.Comparator;
+
+/**
+ * Comparator for java.lang.Long objects.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: LongComparator.java,v 1.4 2002/05/31 06:33:20 boisvert Exp $
+ */
+public final class LongComparator
+    implements Comparator, Serializable
+{
+
+    /**
+     * Version id for serialization.
+     */
+    final static long serialVersionUID = 1L;
+
+
+    /**
+     * Compare two objects.
+     *
+     * @param obj1 First object
+     * @param obj2 Second object
+     * @return a positive integer if obj1 > obj2, 0 if obj1 == obj2,
+     *         and a negative integer if obj1 < obj2
+     */
+     public int compare( Object obj1, Object obj2 )
+     {
+        if ( obj1 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj1' is null" );
+        }
+
+        if ( obj2 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj2' is null" );
+        }
+
+        long l1 = ( (Long) obj1 ).longValue();
+        long l2 = ( (Long) obj2 ).longValue();
+
+        if ( l1 > l2 ) {
+            return 1;
+        } else if ( l1 == l2 ) {
+            return 0;
+        } else {
+            return -1;
+        }
+     }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/LongSerializer.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/LongSerializer.java
new file mode 100644
index 0000000000..a2ecb0b611
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/LongSerializer.java
@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.IOException;
+
+/**
+ * Optimized serializer for long integers.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: LongSerializer.java,v 1.2 2003/09/21 15:47:00 boisvert Exp $
+ */
+public class LongSerializer 
+    implements Serializer
+{
+
+    
+    public static final LongSerializer INSTANCE = new LongSerializer();
+    
+    
+    /**
+     * Construct a LongSerializer.
+     */
+    public LongSerializer()
+    {
+        // no op
+    }
+
+    
+    /**
+     * Serialize the content of an object into a byte array.
+     *
+     * @param obj Object to serialize
+     * @return a byte array representing the object's state
+     */
+     public byte[] serialize( Object obj )
+        throws IOException
+     {
+         Long number = (Long) obj;
+         return Conversion.convertToByteArray( number.longValue() );
+     }
+        
+        
+    /**
+     * Deserialize the content of an object from a byte array.
+     *
+     * @param serialized Byte array representation of the object
+     * @return deserialized object
+     */
+     public Object deserialize( byte[] serialized )
+        throws IOException
+     {
+         long number = Conversion.convertToLong( serialized );
+         return new Long( number );
+     }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/MRU.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/MRU.java
new file mode 100644
index 0000000000..ee7205c949
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/MRU.java
@@ -0,0 +1,352 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: MRU.java,v 1.8 2005/06/25 23:12:31 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Vector;
+
+
+/**
+ *  MRU - Most Recently Used cache policy.
+ *
+ *  Methods are *not* synchronized, so no concurrent access is allowed.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: MRU.java,v 1.8 2005/06/25 23:12:31 doomdark Exp $
+ */
+public class MRU implements CachePolicy {
+
+    /** Cached object hashtable */
+    Hashtable _hash = new Hashtable();
+
+    /**
+     * Maximum number of objects in the cache.
+     */
+    int _max;
+
+    /**
+     * Beginning of linked-list of cache elements.  First entry is element
+     * which has been used least recently.
+     */
+    CacheEntry _first;
+
+    /**
+     * End of linked-list of cache elements.  Last entry is element
+     * which has been used most recently.
+     */
+    CacheEntry _last;
+
+
+    /**
+     * Cache eviction listeners
+     */
+    Vector listeners = new Vector();
+
+
+    /**
+     * Construct an MRU with a given maximum number of objects.
+     */
+    public MRU(int max) {
+        if (max <= 0) {
+            throw new IllegalArgumentException("MRU cache must contain at least one entry");
+        }
+        _max = max;
+    }
+
+
+    /**
+     * Place an object in the cache.
+     */
+    public void put(Object key, Object value) throws CacheEvictionException {
+        CacheEntry entry = (CacheEntry)_hash.get(key);
+        if (entry != null) {
+            entry.setValue(value);
+            touchEntry(entry);
+        } else {
+
+            if (_hash.size() == _max) {
+                // purge and recycle entry
+                entry = purgeEntry();
+                entry.setKey(key);
+                entry.setValue(value);
+            } else {
+                entry = new CacheEntry(key, value);
+            }
+            addEntry(entry);
+            _hash.put(entry.getKey(), entry);
+        }
+    }
+
+
+    /**
+     * Obtain an object in the cache
+     */
+    public Object get(Object key) {
+        CacheEntry entry = (CacheEntry)_hash.get(key);
+        if (entry != null) {
+            touchEntry(entry);
+            return entry.getValue();
+        } else {
+            return null;
+        }
+    }
+
+
+    /**
+     * Remove an object from the cache
+     */
+    public void remove(Object key) {
+        CacheEntry entry = (CacheEntry)_hash.get(key);
+        if (entry != null) {
+            removeEntry(entry);
+            _hash.remove(entry.getKey());
+        }
+    }
+
+
+    /**
+     * Remove all objects from the cache
+     */
+    public void removeAll() {
+        _hash = new Hashtable();
+        _first = null;
+        _last = null;
+    }
+
+
+    /**
+     * Enumerate elements' values in the cache
+     */
+    public Enumeration elements() {
+        return new MRUEnumeration(_hash.elements());
+    }
+
+    /**
+     * Add a listener to this cache policy
+     *
+     * @param listener Listener to add to this policy
+     */
+    public void addListener(CachePolicyListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Cannot add null listener.");
+        }
+        if ( ! listeners.contains(listener)) {
+            listeners.addElement(listener);
+        }
+    }
+
+    /**
+     * Remove a listener from this cache policy
+     *
+     * @param listener Listener to remove from this policy
+     */
+    public void removeListener(CachePolicyListener listener) {
+        listeners.removeElement(listener);
+    }
+
+    /**
+     * Add a CacheEntry.  Entry goes at the end of the list.
+     */
+    protected void addEntry(CacheEntry entry) {
+        if (_first == null) {
+            _first = entry;
+            _last = entry;
+        } else {
+            _last.setNext(entry);
+            entry.setPrevious(_last);
+            _last = entry;
+        }
+    }
+
+
+    /**
+     * Remove a CacheEntry from linked list
+     */
+    protected void removeEntry(CacheEntry entry) {
+        if (entry == _first) {
+            _first = entry.getNext();
+        }
+        if (_last == entry) {
+            _last = entry.getPrevious();
+        }
+        CacheEntry previous = entry.getPrevious();
+        CacheEntry next = entry.getNext();
+        if (previous != null) {
+            previous.setNext(next);
+        }
+        if (next != null) {
+            next.setPrevious(previous);
+        }
+        entry.setPrevious(null);
+        entry.setNext(null);
+    }
+
+    /**
+     * Place entry at the end of linked list -- Most Recently Used
+     */
+    protected void touchEntry(CacheEntry entry) {
+        if (_last == entry) {
+            return;
+        }
+        removeEntry(entry);
+        addEntry(entry);
+    }
+
+    /**
+     * Purge least recently used object from the cache
+     *
+     * @return recyclable CacheEntry
+     */
+    protected CacheEntry purgeEntry() throws CacheEvictionException {
+        CacheEntry entry = _first;
+
+        // Notify policy listeners first. if any of them throw an
+        // eviction exception, then the internal data structure
+        // remains untouched.
+        CachePolicyListener listener;
+        for (int i=0; i<listeners.size(); i++) {
+            listener = (CachePolicyListener)listeners.elementAt(i);
+            listener.cacheObjectEvicted(entry.getValue());
+        }
+
+        removeEntry(entry);
+        _hash.remove(entry.getKey());
+
+        entry.setValue(null);
+        return entry;
+    }
+
+}
+
+/**
+ * State information for cache entries.
+ */
+class CacheEntry {
+    private Object _key;
+    private Object _value;
+
+    private CacheEntry _previous;
+    private CacheEntry _next;
+
+    CacheEntry(Object key, Object value) {
+        _key = key;
+        _value = value;
+    }
+
+    Object getKey() {
+        return _key;
+    }
+
+    void setKey(Object obj) {
+        _key = obj;
+    }
+
+    Object getValue() {
+        return _value;
+    }
+
+    void setValue(Object obj) {
+        _value = obj;
+    }
+
+    CacheEntry getPrevious() {
+        return _previous;
+    }
+
+    void setPrevious(CacheEntry entry) {
+        _previous = entry;
+    }
+
+    CacheEntry getNext() {
+        return _next;
+    }
+
+    void setNext(CacheEntry entry) {
+        _next = entry;
+    }
+}
+
+/**
+ * Enumeration wrapper to return actual user objects instead of
+ * CacheEntries.
+ */
+class MRUEnumeration implements Enumeration {
+    Enumeration _enum;
+
+    MRUEnumeration(Enumeration enume) {
+        _enum = enume;
+    }
+
+    public boolean hasMoreElements() {
+        return _enum.hasMoreElements();
+    }
+
+    public Object nextElement() {
+        CacheEntry entry = (CacheEntry)_enum.nextElement();
+        return entry.getValue();
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/ObjectBAComparator.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/ObjectBAComparator.java
new file mode 100644
index 0000000000..683d4ee1a5
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/ObjectBAComparator.java
@@ -0,0 +1,184 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Comparator;
+
+/**
+ * Comparator for objects which have been serialized into byte arrays.
+ * In effect, it wraps another Comparator which compares object and provides
+ * transparent deserialization from byte array to object.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: ObjectBAComparator.java,v 1.1 2002/05/31 06:33:20 boisvert Exp $
+ */
+public final class ObjectBAComparator
+    implements Comparator, Serializable
+{
+
+    /**
+     * Version id for serialization.
+     */
+    final static long serialVersionUID = 1L;
+
+
+    /**
+     * Wrapped comparator.
+     */
+    private Comparator _comparator;
+
+
+    /**
+     * Construct an ObjectByteArrayComparator which wraps an Object Comparator.
+     *
+     * @param comparator Object comparator.
+     */
+    public ObjectBAComparator( Comparator comparator )
+    {
+        if ( comparator == null ) {
+            throw new IllegalArgumentException( "Argument 'comparator' is null" );
+        }
+
+        _comparator = comparator;
+    }
+
+
+    /**
+     * Compare two objects.
+     *
+     * @param obj1 First object
+     * @param obj2 Second object
+     * @return 1 if obj1 > obj2, 0 if obj1 == obj2, -1 if obj1 < obj2
+     */
+     public int compare( Object obj1, Object obj2 )
+     {
+        if ( obj1 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj1' is null" );
+        }
+
+        if ( obj2 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj2' is null" );
+        }
+
+        try {
+            obj1 = Serialization.deserialize( (byte[]) obj1 );
+            obj2 = Serialization.deserialize( (byte[]) obj2 );
+
+            return _comparator.compare( obj1, obj2 );
+        } catch ( IOException except ) {
+            throw new WrappedRuntimeException( except );
+        } catch ( ClassNotFoundException except ) {
+            throw new WrappedRuntimeException( except );
+        }
+     }
+
+
+    /**
+     * Compare two byte arrays.
+     */
+    public static int compareByteArray( byte[] thisKey, byte[] otherKey )
+    {
+        int len = Math.min( thisKey.length, otherKey.length );
+
+        // compare the byte arrays
+        for ( int i=0; i<len; i++ ) {
+            if ( thisKey[i] >= 0 ) {
+                if ( otherKey[i] >= 0 ) {
+                    // both positive
+                    if ( thisKey[i] < otherKey[i] ) {
+                        return -1;
+                    } else if ( thisKey[i] > otherKey[i] ) {
+                        return 1;
+                    }
+                } else {
+                    // otherKey is negative => greater (because MSB is 1)
+                    return -1;
+                }
+            } else {
+                if ( otherKey[i] >= 0 ) {
+                    // thisKey is negative => greater (because MSB is 1)
+                    return 1;
+                } else {
+                    // both negative
+                    if ( thisKey[i] < otherKey[i] ) {
+                        return -1;
+                    } else if ( thisKey[i] > otherKey[i] ) {
+                        return 1;
+                    }
+                }
+            }
+        }
+        if ( thisKey.length == otherKey.length) {
+            return 0;
+        }
+        if ( thisKey.length < otherKey.length ) {
+            return -1;
+        }
+        return 1;
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Serialization.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Serialization.java
new file mode 100644
index 0000000000..a076e08f17
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Serialization.java
@@ -0,0 +1,114 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+/**
+ * Serialization-related utility methods.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: Serialization.java,v 1.1 2002/05/31 06:33:20 boisvert Exp $
+ */
+public final class Serialization
+{
+
+    /**
+     * Serialize the object into a byte array.
+     */
+    public static byte[] serialize( Object obj )
+        throws IOException
+    {
+        ByteArrayOutputStream  baos;
+        ObjectOutputStream     oos;
+
+        baos = new ByteArrayOutputStream();
+        oos = new ObjectOutputStream( baos );
+        oos.writeObject( obj );
+        oos.close();
+
+        return baos.toByteArray();
+    }
+
+
+    /**
+     * Deserialize an object from a byte array
+     */
+    public static Object deserialize( byte[] buf )
+        throws ClassNotFoundException, IOException
+    {
+        ByteArrayInputStream  bais;
+        ObjectInputStream     ois;
+
+        bais = new ByteArrayInputStream( buf );
+        ois = new ObjectInputStream( bais );
+        return ois.readObject();
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Serializer.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Serializer.java
new file mode 100644
index 0000000000..d02b932c88
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Serializer.java
@@ -0,0 +1,100 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.IOException;
+import java.io.Serializable;
+
+/**
+ * Interface used to provide a serialization mechanism other than a class' normal
+ * serialization.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: Serializer.java,v 1.1 2003/03/21 02:48:42 boisvert Exp $
+ */
+public interface Serializer
+    extends Serializable
+{
+
+    /**
+     * Serialize the content of an object into a byte array.
+     *
+     * @param obj Object to serialize
+     * @return a byte array representing the object's state
+     */
+     public byte[] serialize( Object obj )
+        throws IOException;
+        
+        
+    /**
+     * Deserialize the content of an object from a byte array.
+     *
+     * @param serialized Byte array representation of the object
+     * @return deserialized object
+     */
+     public Object deserialize( byte[] serialized )
+        throws IOException;
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/SoftCache.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/SoftCache.java
new file mode 100644
index 0000000000..e3df8717ba
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/SoftCache.java
@@ -0,0 +1,312 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id
+ */
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
+import java.lang.ref.Reference;
+import java.util.Enumeration;
+import java.util.Map;
+import java.util.HashMap;
+
+/**
+ * Wraps a deterministic cache policy with a <q>Level-2</q> cache based on
+ * J2SE's {@link SoftReference soft references}. Soft references allow
+ * this cache to keep references to objects until the memory they occupy
+ * is required elsewhere.
+ * <p>
+ * Since the {@link CachePolicy} interface requires an event be fired
+ * when an object is evicted, and the event contains the actual object,
+ * this class cannot be a stand-alone implementation of
+ * <code>CachePolicy</code>. This limitation arises because Java References
+ * does not support notification before references are cleared; nor do
+ * they support reaching soft referents. Therefore, this wrapper cache
+ * aggressively notifies evictions: events are fired when the objects are
+ * evicted from the internal cache. Consequently, the soft cache may return
+ * a non-null object when <code>get( )</code> is called, even if that
+ * object was said to have been evicted.
+ * <p>
+ * The current implementation uses a hash structure for its internal key
+ * to value mappings.
+ * <p>
+ * Note: this component's publicly exposed methods are not threadsafe;
+ * potentially concurrent code should synchronize on the cache instance.
+ *
+ * @author <a href="mailto:dranatunga@users.sourceforge.net">Dilum Ranatunga</a>
+ * @version $Id: SoftCache.java,v 1.1 2003/11/01 13:29:27 dranatunga Exp $
+ */
+public class SoftCache implements CachePolicy {
+    private static final int INITIAL_CAPACITY = 128;
+    private static final float DEFAULT_LOAD_FACTOR = 1.5f;
+
+    private final ReferenceQueue _clearQueue = new ReferenceQueue();
+    private final CachePolicy _internal;
+    private final Map _cacheMap;
+
+    /**
+     * Creates a soft-reference based L2 cache with a {@link MRU} cache as
+     * the internal (L1) cache. The soft reference cache uses the
+     * default load capacity of 1.5f, which is intended to sacrifice some
+     * performance for space. This compromise is reasonable, since all
+     * {@link #get(Object) get( )s} first try the L1 cache anyway. The
+     * internal MRU is given a capacity of 128 elements.
+     */
+    public SoftCache() {
+        this(new MRU(INITIAL_CAPACITY));
+    }
+
+    /**
+     * Creates a soft-reference based L2 cache wrapping the specified
+     * L1 cache.
+     *
+     * @param internal non null internal cache.
+     * @throws NullPointerException if the internal cache is null.
+     */
+    public SoftCache(CachePolicy internal) throws NullPointerException {
+        this(DEFAULT_LOAD_FACTOR, internal);
+    }
+
+    /**
+     * Creates a soft-reference based L2 cache wrapping the specified
+     * L1 cache. This constructor is somewhat implementation-specific,
+     * so users are encouraged to use {@link #SoftCache(CachePolicy)}
+     * instead.
+     *
+     * @param loadFactor load factor that the soft cache's hash structure
+     *        should use.
+     * @param internal non null internal cache.
+     * @throws IllegalArgumentException if the load factor is nonpositive.
+     * @throws NullPointerException if the internal cache is null.
+     */
+    public SoftCache(float loadFactor, CachePolicy internal) throws IllegalArgumentException, NullPointerException {
+        if (internal == null) {
+            throw new NullPointerException("Internal cache cannot be null.");
+        }
+        _internal = internal;
+        _cacheMap = new HashMap(INITIAL_CAPACITY, loadFactor);
+    }
+
+    /**
+     * Adds the specified value to the cache under the specified key. Note
+     * that the object is added to both this and the internal cache.
+     * @param key the (non-null) key to store the object under
+     * @param value the (non-null) object to place in the cache
+     * @throws CacheEvictionException exception that the internal cache
+     *         would have experienced while evicting an object it currently
+     *         cached.
+     */
+    public void put(Object key, Object value) throws CacheEvictionException {
+        if (key == null) {
+            throw new IllegalArgumentException("key cannot be null.");
+        } else if (value == null) {
+            throw new IllegalArgumentException("value cannot be null.");
+        }
+        _internal.put(key, value);
+        removeClearedEntries();
+        _cacheMap.put(key, new Entry(key, value, _clearQueue));
+    }
+
+    /**
+     * Gets the object cached under the specified key.
+     * <p>
+     * The cache is looked up in the following manner:
+     * <ol>
+     * <li>The internal (L1) cache is checked. If the object is found, it is
+     *     returned.</li>
+     * <li>This (L2) cache is checked. If the object is not found, then
+     *     the caller is informed that the object is inaccessible.</li>
+     * <li>Since the object exists in L2, but not in L1, the object is
+     *     readded to L1 using {@link CachePolicy#put(Object, Object)}.</li>
+     * <li>If the readding succeeds, the value is returned to caller.</li>
+     * <li>If a cache eviction exception is encountered instead, we
+     *     remove the object from L2 and behave as if the object was
+     *     inaccessible.</li>
+     * </ol>
+     * @param key the key that the object was stored under.
+     * @return the object stored under the key specified; null if the
+     *         object is not (nolonger) accessible via this cache.
+     */
+    public Object get(Object key) {
+        // first try the internal cache.
+        Object value = _internal.get(key);
+        if (value != null) {
+            return value;
+        }
+        // poll and remove cleared references.
+        removeClearedEntries();
+        Entry entry = (Entry)_cacheMap.get(key);
+        if (entry == null) { // object is not in cache.
+            return null;
+        }
+        value = entry.getValue();
+        if (value == null) { // object was in cache, but it was cleared.
+            return null;
+        }
+        // we have the object. so we try to re-insert it into internal cache
+        try {
+            _internal.put(key, value);
+        } catch (CacheEvictionException e) {
+            // if the internal cache causes a fuss, we kick the object out.
+            _cacheMap.remove(key);
+            return null;
+        }
+        return value;
+    }
+
+    /**
+     * Removes any object stored under the key specified. Note that the
+     * object is removed from both this (L2) and the internal (L1)
+     * cache.
+     * @param key the key whose object should be removed
+     */
+    public void remove(Object key) {
+        _cacheMap.remove(key);
+        _internal.remove(key);
+    }
+
+    /**
+     * Removes all objects in this (L2) and its internal (L1) cache.
+     */
+    public void removeAll() {
+        _cacheMap.clear();
+        _internal.removeAll();
+    }
+
+    /**
+     * Gets all the objects stored by the internal (L1) cache.
+     * @return an enumeration of objects in internal cache.
+     */
+    public Enumeration elements() {
+        return _internal.elements();
+    }
+
+    /**
+     * Adds the specified listener to this cache. Note that the events
+     * fired by this correspond to the <em>internal</em> cache's events.
+     * @param listener the (non-null) listener to add to this policy
+     * @throws IllegalArgumentException if listener is null.
+     */
+    public void addListener(CachePolicyListener listener)
+            throws IllegalArgumentException {
+        _internal.addListener(listener);
+    }
+
+    /**
+     * Removes a listener that was added earlier.
+     * @param listener the listener to remove.
+     */
+    public void removeListener(CachePolicyListener listener) {
+        _internal.removeListener(listener);
+    }
+
+    /**
+     * Cleans the mapping structure of any obsolete entries. This is usually
+     * called before insertions and lookups on the mapping structure. The
+     * runtime of this is usually very small, but it can be as expensive as
+     * n * log(n) if a large number of soft references were recently cleared.
+     */
+    private final void removeClearedEntries() {
+        for (Reference r = _clearQueue.poll(); r != null; r = _clearQueue.poll()) {
+            Object key = ((Entry)r).getKey();
+            _cacheMap.remove(key);
+        }
+    }
+
+    /**
+     * Value objects we keep in the internal map. This contains the key in
+     * addition to the value, because polling for cleared references
+     * returns these instances, and having access to their corresponding
+     * keys drastically improves the performance of removing the pair
+     * from the map (see {@link SoftCache#removeClearedEntries()}.)
+     */
+    private static class Entry extends SoftReference {
+        private final Object _key;
+
+        /**
+         * Constructor that uses <code>value</code> as the soft
+         * reference's referent.
+         */
+        public Entry(Object key, Object value, ReferenceQueue queue) {
+            super(value, queue);
+            _key = key;
+        }
+
+        /**
+         * Gets the key
+         * @return the key associated with this value.
+         */
+        final Object getKey() {
+            return _key;
+        }
+
+        /**
+         * Gets the value
+         * @return the value; null if it is no longer accessible
+         */
+        final Object getValue() {
+            return this.get();
+        }
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/StringComparator.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/StringComparator.java
new file mode 100644
index 0000000000..bdc545c171
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/StringComparator.java
@@ -0,0 +1,107 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.Serializable;
+import java.util.Comparator;
+
+/**
+ * Comparator for String objects.  Delegates to String.compareTo().
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: StringComparator.java,v 1.5 2005/06/25 23:12:31 doomdark Exp $
+ */
+public final class StringComparator
+    implements Comparator, Serializable
+{
+
+    /**
+     * Version id for serialization.
+     */
+    final static long serialVersionUID = 1L;
+
+
+    /**
+     * Compare two objects.
+     *
+     * @param obj1 First object
+     * @param obj2 Second object
+     * @return a positive integer if obj1 > obj2, 0 if obj1 == obj2,
+     *         and a negative integer if obj1 < obj2
+     */
+     public int compare( Object obj1, Object obj2 )
+     {
+        if ( obj1 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj1' is null" );
+        }
+
+        if ( obj2 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj2' is null" );
+        }
+
+        return ( (String) obj1 ).compareTo((String) obj2 );
+     }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Tuple.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Tuple.java
new file mode 100644
index 0000000000..4f7c25b284
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/Tuple.java
@@ -0,0 +1,139 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+
+/**
+ * Tuple consisting of a key-value pair.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: Tuple.java,v 1.2 2001/05/19 14:02:00 boisvert Exp $
+ */
+public final class Tuple {
+
+    /**
+     * Key
+     */
+    private Object _key;
+
+
+    /**
+     * Value
+     */
+    private Object _value;
+
+
+    /**
+     * Construct an empty Tuple.
+     */
+    public Tuple() {
+        // empty
+    }
+
+
+    /**
+     * Construct a Tuple.
+     *
+     * @param key The key.
+     * @param value The value.
+     */
+    public Tuple( Object key, Object value ) {
+        _key = key;
+        _value = value;
+    }
+
+
+    /**
+     * Get the key.
+     */
+    public Object getKey() {
+        return _key;
+    }
+
+
+    /**
+     * Set the key.
+     */
+    public void setKey( Object key ) {
+        _key = key;
+    }
+
+
+    /**
+     * Get the value.
+     */
+    public Object getValue() {
+        return _value;
+    }
+
+
+    /**
+     * Set the value.
+     */
+    public void setValue( Object value ) {
+        _value = value;
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/TupleBrowser.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/TupleBrowser.java
new file mode 100644
index 0000000000..0749623a61
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/TupleBrowser.java
@@ -0,0 +1,99 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.IOException;
+
+/**
+ * Browser to traverse a collection of tuples.  The browser allows for
+ * forward and reverse order traversal.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: TupleBrowser.java,v 1.2 2001/05/19 14:02:00 boisvert Exp $
+ */
+public abstract class TupleBrowser {
+
+    /**
+     * Get the next tuple.
+     *
+     * @param tuple Tuple into which values are copied.
+     * @return True if values have been copied in tuple, or false if there is
+     *         no next tuple.
+     */
+    public abstract boolean getNext( Tuple tuple )
+        throws IOException;
+
+
+    /**
+     * Get the previous tuple.
+     *
+     * @param tuple Tuple into which values are copied.
+     * @return True if values have been copied in tuple, or false if there is
+     *         no previous tuple.
+     */
+    public abstract boolean getPrevious( Tuple tuple )
+        throws IOException;
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/WrappedRuntimeException.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/WrappedRuntimeException.java
new file mode 100644
index 0000000000..0d32fea400
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/helper/WrappedRuntimeException.java
@@ -0,0 +1,169 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2001 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.helper;
+
+import java.io.PrintStream;
+import java.io.PrintWriter;
+
+/**
+ * A run-time exception that wraps another exception. The printed stack
+ * trace will be that of the wrapped exception.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: WrappedRuntimeException.java,v 1.1 2002/05/31 06:33:20 boisvert Exp $
+ */
+public class WrappedRuntimeException
+    extends RuntimeException
+{
+
+
+    /**
+     * The underlying exception.
+     */
+    private final Exception _except;
+
+
+    /**
+     * Constructs a new runtime exception based on a checked exception.
+     *
+     * @param message The error message
+     * @param except The checked exception
+     */
+    public WrappedRuntimeException( String message, Exception except )
+    {
+        super( message == null ? "No message available" : message );
+
+        if ( except instanceof WrappedRuntimeException &&
+             ( (WrappedRuntimeException) except )._except != null )
+        {
+            _except = ( (WrappedRuntimeException) except )._except;
+        } else {
+            _except = except;
+        }
+    }
+
+
+    /**
+     * Constructs a new runtime exception based on a checked exception.
+     *
+     * @param except The checked exception
+     */
+    public WrappedRuntimeException( Exception except )
+    {
+        super( except == null || except.getMessage() == null ? "No message available" : except.getMessage() );
+
+        if ( except instanceof WrappedRuntimeException &&
+             ( (WrappedRuntimeException) except )._except != null )
+        {
+            _except = ( (WrappedRuntimeException) except )._except;
+        } else {
+            _except = except;
+        }
+    }
+
+
+    /**
+     * Returns the exception wrapped by this runtime exception.
+     *
+     * @return The exception wrapped by this runtime exception
+     */
+    public Exception getException()
+    {
+        return _except;
+    }
+
+
+    public void printStackTrace()
+    {
+        if ( _except == null ) {
+            super.printStackTrace();
+        } else {
+            _except.printStackTrace();
+        }
+    }
+
+
+    public void printStackTrace( PrintStream stream )
+    {
+        if ( _except == null ) {
+            super.printStackTrace( stream );
+        } else {
+            _except.printStackTrace( stream );
+        }
+    }
+
+
+    public void printStackTrace( PrintWriter writer )
+    {
+        if ( _except == null ) {
+            super.printStackTrace( writer );
+        } else {
+            _except.printStackTrace( writer );
+        }
+    }
+
+}
+
+
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HTree.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HTree.java
new file mode 100644
index 0000000000..246868b6f5
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HTree.java
@@ -0,0 +1,206 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are (C) Copyright 2000 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.htree;
+
+import org.apache.hadoop.hive.ql.util.jdbm.RecordManager;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.FastIterator;
+import java.io.IOException;
+
+/**
+ *  Persistent hashtable implementation for PageManager.
+ *  Implemented as an H*Tree structure.
+ *
+ *  WARNING!  If this instance is used in a transactional context, it
+ *            *must* be discarded after a rollback.
+ *
+ *  @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ *  @version $Id: HTree.java,v 1.3 2005/06/25 23:12:32 doomdark Exp $
+ */
+public class HTree
+{
+
+    /**
+     * Root hash directory.
+     */
+    private HashDirectory _root;
+
+
+    /**
+     * Private constructor
+     *
+     * @param root Root hash directory.
+     */
+    private HTree( HashDirectory root ) {
+        _root = root;
+    }
+
+
+    /**
+     * Create a persistent hashtable.
+     *
+     * @param recman Record manager used for persistence.
+     */
+    public static HTree createInstance( RecordManager recman )
+        throws IOException
+    {
+        HashDirectory  root;
+        long           recid;
+
+        root = new HashDirectory( (byte) 0 );
+        recid = recman.insert( root );
+        root.setPersistenceContext( recman, recid );
+
+        return new HTree( root );
+    }
+
+
+    /**
+     * Load a persistent hashtable
+     *
+     * @param recman RecordManager used to store the persistent hashtable
+     * @param root_recid Record id of the root directory of the HTree
+     */
+    public static HTree load( RecordManager recman, long root_recid )
+        throws IOException
+    {
+        HTree tree;
+        HashDirectory root;
+
+        root = (HashDirectory) recman.fetch( root_recid );
+        root.setPersistenceContext( recman, root_recid );
+        tree = new HTree( root );
+        return tree;
+    }
+
+
+    /**
+     * Associates the specified value with the specified key.
+     *
+     * @param key key with which the specified value is to be assocated.
+     * @param value value to be associated with the specified key.
+     */
+    public synchronized void put(Object key, Object value)
+        throws IOException
+    {
+        _root.put(key, value);
+    }
+
+
+    /**
+     * Returns the value which is associated with the given key. Returns
+     * <code>null</code> if there is not association for this key.
+     *
+     * @param key key whose associated value is to be returned
+     */
+    public synchronized Object get(Object key)
+        throws IOException
+    {
+        return _root.get(key);
+    }
+
+
+    /**
+     * Remove the value which is associated with the given key.  If the
+     * key does not exist, this method simply ignores the operation.
+     *
+     * @param key key whose associated value is to be removed
+     */
+    public synchronized void remove(Object key)
+        throws IOException
+    {
+        _root.remove(key);
+    }
+
+
+    /**
+     * Returns an enumeration of the keys contained in this
+     */
+    public synchronized FastIterator keys()
+        throws IOException
+    {
+        return _root.keys();
+    }
+
+
+    /**
+     * Returns an enumeration of the values contained in this
+     */
+    public synchronized FastIterator values()
+        throws IOException
+    {
+        return _root.values();
+    }
+
+
+    /**
+     * Get the record identifier used to load this hashtable.
+     */
+    public long getRecid()
+    {
+        return _root.getRecid();
+    }
+
+}
+
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HashBucket.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HashBucket.java
new file mode 100644
index 0000000000..79b6250002
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HashBucket.java
@@ -0,0 +1,332 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.htree;
+
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+
+import java.util.ArrayList;
+
+/**
+ * A bucket is a placeholder for multiple (key, value) pairs.  Buckets
+ * are used to store collisions (same hash value) at all levels of an
+ * H*tree.
+ *
+ * There are two types of buckets: leaf and non-leaf.
+ *
+ * Non-leaf buckets are buckets which hold collisions which happen
+ * when the H*tree is not fully expanded.   Keys in a non-leaf buckets
+ * can have different hash codes.  Non-leaf buckets are limited to an
+ * arbitrary size.  When this limit is reached, the H*tree should create
+ * a new Directory page and distribute keys of the non-leaf buckets into
+ * the newly created Directory.
+ *
+ * A leaf bucket is a bucket which contains keys which all have
+ * the same <code>hashCode()</code>.  Leaf buckets stand at the
+ * bottom of an H*tree because the hashing algorithm cannot further
+ * discriminate between different keys based on their hash code.
+ *
+ *  @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ *  @version $Id: HashBucket.java,v 1.2 2005/06/25 23:12:32 doomdark Exp $
+ */
+final class HashBucket
+    extends HashNode
+    implements Externalizable
+{
+
+    final static long serialVersionUID = 1L;
+
+    /**
+     * The maximum number of elements (key, value) a non-leaf bucket
+     * can contain.
+     */
+    public static final int OVERFLOW_SIZE = 8;
+
+
+    /**
+     * Depth of this bucket.
+     */
+    private int _depth;
+
+
+    /**
+     * Keys in this bucket.  Keys are ordered to match their respective
+     * value in <code>_values</code>.
+     */
+    private ArrayList _keys;
+
+
+    /**
+     * Values in this bucket.  Values are ordered to match their respective
+     * key in <code>_keys</code>.
+     */
+    private ArrayList _values;
+
+
+    /**
+     * Public constructor for serialization.
+     */
+    public HashBucket() {
+        // empty
+    }
+
+
+    /**
+     * Construct a bucket with a given depth level.  Depth level is the
+     * number of <code>HashDirectory</code> above this bucket.
+     */
+    public HashBucket( int level )
+    {
+        if ( level > HashDirectory.MAX_DEPTH+1 ) {
+            throw new IllegalArgumentException(
+                            "Cannot create bucket with depth > MAX_DEPTH+1. "
+                            + "Depth=" + level );
+        }
+        _depth = level;
+        _keys = new ArrayList( OVERFLOW_SIZE );
+        _values = new ArrayList( OVERFLOW_SIZE );
+    }
+
+
+    /**
+     * Returns the number of elements contained in this bucket.
+     */
+    public int getElementCount()
+    {
+        return _keys.size();
+    }
+
+
+    /**
+     * Returns whether or not this bucket is a "leaf bucket".
+     */
+    public boolean isLeaf()
+    {
+        return ( _depth > HashDirectory.MAX_DEPTH );
+    }
+
+
+    /**
+     * Returns true if bucket can accept at least one more element.
+     */
+    public boolean hasRoom()
+    {
+        if ( isLeaf() ) {
+            return true;  // leaf buckets are never full
+        } else {
+            // non-leaf bucket
+            return ( _keys.size() < OVERFLOW_SIZE );
+        }
+    }
+
+
+    /**
+     * Add an element (key, value) to this bucket.  If an existing element
+     * has the same key, it is replaced silently.
+     *
+     * @return Object which was previously associated with the given key
+     *          or <code>null</code> if no association existed.
+     */
+    public Object addElement( Object key, Object value )
+    {
+        int existing = _keys.indexOf(key);
+        if ( existing != -1 ) {
+            // replace existing element
+            Object before = _values.get( existing );
+            _values.set( existing, value );
+            return before;
+        } else {
+            // add new (key, value) pair
+            _keys.add( key );
+            _values.add( value );
+            return null;
+        }
+    }
+
+
+    /**
+     * Remove an element, given a specific key.
+     *
+     * @param key Key of the element to remove
+     *
+     * @return Removed element value, or <code>null</code> if not found
+     */
+    public Object removeElement( Object key )
+    {
+        int existing = _keys.indexOf(key);
+        if ( existing != -1 ) {
+            Object obj = _values.get( existing );
+            _keys.remove( existing );
+            _values.remove( existing );
+            return obj;
+        } else {
+            // not found
+            return null;
+        }
+    }
+
+
+    /**
+     * Returns the value associated with a given key.  If the given key
+     * is not found in this bucket, returns <code>null</code>.
+     */
+    public Object getValue( Object key )
+    {
+        int existing = _keys.indexOf(key);
+        if ( existing != -1 ) {
+            return _values.get( existing );
+        } else {
+            // key not found
+            return null;
+        }
+    }
+
+
+    /**
+     * Obtain keys contained in this buckets.  Keys are ordered to match
+     * their values, which be be obtained by calling <code>getValues()</code>.
+     *
+     * As an optimization, the Vector returned is the instance member
+     * of this class.  Please don't modify outside the scope of this class.
+     */
+    ArrayList getKeys()
+    {
+        return this._keys;
+    }
+
+
+    /**
+     * Obtain values contained in this buckets.  Values are ordered to match
+     * their keys, which be be obtained by calling <code>getKeys()</code>.
+     *
+     * As an optimization, the Vector returned is the instance member
+     * of this class.  Please don't modify outside the scope of this class.
+     */
+    ArrayList getValues()
+    {
+        return this._values;
+    }
+
+
+    /**
+     * Implement Externalizable interface.
+     */
+    public void writeExternal( ObjectOutput out )
+        throws IOException
+    {
+        out.writeInt( _depth );
+
+        int entries = _keys.size();
+        out.writeInt( entries );
+
+        // write keys
+        for (int i=0; i<entries; i++) {
+            out.writeObject( _keys.get( i ) );
+        }
+        // write values
+        for (int i=0; i<entries; i++) {
+            out.writeObject( _values.get( i ) );
+        }
+    }
+
+
+    /**
+     * Implement Externalizable interface.
+     */
+    public void readExternal(ObjectInput in)
+    throws IOException, ClassNotFoundException {
+        _depth = in.readInt();
+
+        int entries = in.readInt();
+
+        // prepare array lists
+        int size = Math.max( entries, OVERFLOW_SIZE );
+        _keys = new ArrayList( size );
+        _values = new ArrayList( size );
+
+        // read keys
+        for ( int i=0; i<entries; i++ ) {
+            _keys.add( in.readObject() );
+        }
+        // read values
+        for ( int i=0; i<entries; i++ ) {
+            _values.add( in.readObject() );
+        }
+    }
+
+    public String toString() {
+        StringBuffer buf = new StringBuffer();
+        buf.append("HashBucket {depth=");
+        buf.append(_depth);
+        buf.append(", keys=");
+        buf.append(_keys);
+        buf.append(", values=");
+        buf.append(_values);
+        buf.append("}");
+        return buf.toString();
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HashDirectory.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HashDirectory.java
new file mode 100644
index 0000000000..6e43c20685
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HashDirectory.java
@@ -0,0 +1,566 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.htree;
+
+import org.apache.hadoop.hive.ql.util.jdbm.RecordManager;
+
+import org.apache.hadoop.hive.ql.util.jdbm.helper.FastIterator;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.IterationException;
+
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+
+/**
+ *  Hashtable directory page.
+ *
+ *  @author <a href="mailto:boisvert@exoffice.com">Alex Boisvert</a>
+ *  @version $Id: HashDirectory.java,v 1.5 2005/06/25 23:12:32 doomdark Exp $
+ */
+final class HashDirectory
+    extends HashNode
+    implements Externalizable
+{
+
+    static final long serialVersionUID = 1L;
+
+
+    /**
+     * Maximum number of children in a directory.
+     *
+     * (Must be a power of 2 -- if you update this value, you must also
+     *  update BIT_SIZE and MAX_DEPTH.)
+     */
+    static final int MAX_CHILDREN = 256;
+
+
+    /**
+     * Number of significant bits per directory level.
+     */
+    static final int BIT_SIZE = 8; // log2(256) = 8
+
+
+    /**
+     * Maximum number of levels (zero-based)
+     *
+     * (4 * 8 bits = 32 bits, which is the size of an "int", and as
+     *  you know, hashcodes in Java are "ints")
+     */
+    static final int MAX_DEPTH = 3; // 4 levels
+
+
+    /**
+     * Record ids of children pages.
+     */
+    private long[] _children;
+
+
+    /**
+     * Depth of this directory page, zero-based
+     */
+    private byte _depth;
+
+
+    /**
+     * PageManager used to persist changes in directory and buckets
+     */
+    private transient RecordManager _recman;
+
+
+    /**
+     * This directory's record ID in the PageManager.  (transient)
+     */
+    private transient long _recid;
+
+
+    /**
+     * Public constructor used by serialization
+     */
+    public HashDirectory() {
+        // empty
+    }
+
+    /**
+     * Construct a HashDirectory
+     *
+     * @param depth Depth of this directory page.
+     */
+    HashDirectory(byte depth) {
+        _depth = depth;
+        _children = new long[MAX_CHILDREN];
+    }
+
+
+    /**
+     * Sets persistence context.  This method must be called before any
+     * persistence-related operation.
+     *
+     * @param recman RecordManager which stores this directory
+     * @param recid Record id of this directory.
+     */
+    void setPersistenceContext( RecordManager recman, long recid )
+    {
+        this._recman = recman;
+        this._recid = recid;
+    }
+
+
+    /**
+     * Get the record identifier used to load this hashtable.
+     */
+    long getRecid() {
+        return _recid;
+    }
+
+
+    /**
+     * Returns whether or not this directory is empty.  A directory
+     * is empty when it no longer contains buckets or sub-directories.
+     */
+    boolean isEmpty() {
+        for (int i=0; i<_children.length; i++) {
+            if (_children[i] != 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns the value which is associated with the given key. Returns
+     * <code>null</code> if there is not association for this key.
+     *
+     * @param key key whose associated value is to be returned
+     */
+    Object get(Object key)
+        throws IOException
+    {
+        int hash = hashCode( key );
+        long child_recid = _children[ hash ];
+        if ( child_recid == 0 ) {
+            // not bucket/page --> not found
+            return null;
+        } else {
+            HashNode node = (HashNode) _recman.fetch( child_recid );
+            // System.out.println("HashDirectory.get() child is : "+node);
+
+            if ( node instanceof HashDirectory ) {
+                // recurse into next directory level
+                HashDirectory dir = (HashDirectory) node;
+                dir.setPersistenceContext( _recman, child_recid );
+                return dir.get( key );
+            } else {
+                // node is a bucket
+                HashBucket bucket = (HashBucket) node;
+                return bucket.getValue( key );
+            }
+        }
+    }
+
+
+    /**
+     * Associates the specified value with the specified key.
+     *
+     * @param key key with which the specified value is to be assocated.
+     * @param value value to be associated with the specified key.
+     * @return object which was previously associated with the given key,
+     *          or <code>null</code> if no association existed.
+     */
+    Object put(Object key, Object value)
+    throws IOException {
+        if (value == null) {
+            return remove(key);
+        }
+        int hash = hashCode(key);
+        long child_recid = _children[hash];
+        if (child_recid == 0) {
+            // no bucket/page here yet, let's create a bucket
+            HashBucket bucket = new HashBucket(_depth+1);
+
+            // insert (key,value) pair in bucket
+            Object existing = bucket.addElement(key, value);
+
+            long b_recid = _recman.insert(bucket);
+            _children[hash] = b_recid;
+
+            _recman.update(_recid, this);
+
+            // System.out.println("Added: "+bucket);
+            return existing;
+        } else {
+            HashNode node = (HashNode) _recman.fetch( child_recid );
+
+            if ( node instanceof HashDirectory ) {
+                // recursive insert in next directory level
+                HashDirectory dir = (HashDirectory) node;
+                dir.setPersistenceContext( _recman, child_recid );
+                return dir.put( key, value );
+            } else {
+                // node is a bucket
+                HashBucket bucket = (HashBucket)node;
+                if (bucket.hasRoom()) {
+                    Object existing = bucket.addElement(key, value);
+                    _recman.update(child_recid, bucket);
+                    // System.out.println("Added: "+bucket);
+                    return existing;
+                } else {
+                    // overflow, so create a new directory
+                    if (_depth == MAX_DEPTH) {
+                        throw new RuntimeException( "Cannot create deeper directory. "
+                                                    + "Depth=" + _depth );
+                    }
+                    HashDirectory dir = new HashDirectory( (byte) (_depth+1) );
+                    long dir_recid = _recman.insert( dir );
+                    dir.setPersistenceContext( _recman, dir_recid );
+
+                    _children[hash] = dir_recid;
+                    _recman.update( _recid, this );
+
+                    // discard overflown bucket
+                    _recman.delete( child_recid );
+
+                    // migrate existing bucket elements
+                    ArrayList keys = bucket.getKeys();
+                    ArrayList values = bucket.getValues();
+                    int entries = keys.size();
+                    for ( int i=0; i<entries; i++ ) {
+                        dir.put( keys.get( i ), values.get( i ) );
+                    }
+
+                    // (finally!) insert new element
+                    return dir.put( key, value );
+                }
+            }
+        }
+    }
+
+
+    /**
+     * Remove the value which is associated with the given key.  If the
+     * key does not exist, this method simply ignores the operation.
+     *
+     * @param key key whose associated value is to be removed
+     * @return object which was associated with the given key, or
+     *          <code>null</code> if no association existed with given key.
+     */
+    Object remove(Object key) throws IOException {
+        int hash = hashCode(key);
+        long child_recid = _children[hash];
+        if (child_recid == 0) {
+            // not bucket/page --> not found
+            return null;
+        } else {
+            HashNode node = (HashNode) _recman.fetch( child_recid );
+            // System.out.println("HashDirectory.remove() child is : "+node);
+
+            if (node instanceof HashDirectory) {
+                // recurse into next directory level
+                HashDirectory dir = (HashDirectory)node;
+                dir.setPersistenceContext( _recman, child_recid );
+                Object existing = dir.remove(key);
+                if (existing != null) {
+                    if (dir.isEmpty()) {
+                        // delete empty directory
+                        _recman.delete(child_recid);
+                        _children[hash] = 0;
+                        _recman.update(_recid, this);
+                    }
+                }
+                return existing;
+            } else {
+                // node is a bucket
+                HashBucket bucket = (HashBucket)node;
+                Object existing = bucket.removeElement(key);
+                if (existing != null) {
+                    if (bucket.getElementCount() >= 1) {
+                        _recman.update(child_recid, bucket);
+                    } else {
+                        // delete bucket, it's empty
+                        _recman.delete(child_recid);
+                        _children[hash] = 0;
+                        _recman.update(_recid, this);
+                    }
+                }
+                return existing;
+            }
+        }
+    }
+
+    /**
+     * Calculates the hashcode of a key, based on the current directory
+     * depth.
+     */
+    private int hashCode(Object key) {
+        int hashMask = hashMask();
+        int hash = key.hashCode();
+        hash = hash & hashMask;
+        hash = hash >>> ((MAX_DEPTH - _depth) * BIT_SIZE);
+        hash = hash % MAX_CHILDREN;
+        /*
+        System.out.println("HashDirectory.hashCode() is: 0x"
+                           +Integer.toHexString(hash)
+                           +" for object hashCode() 0x"
+                           +Integer.toHexString(key.hashCode()));
+        */
+        return hash;
+    }
+
+    /**
+     * Calculates the hashmask of this directory.  The hashmask is the
+     * bit mask applied to a hashcode to retain only bits that are
+     * relevant to this directory level.
+     */
+    int hashMask() {
+        int bits = MAX_CHILDREN-1;
+        int hashMask = bits << ((MAX_DEPTH - _depth) * BIT_SIZE);
+        /*
+        System.out.println("HashDirectory.hashMask() is: 0x"
+                           +Integer.toHexString(hashMask));
+        */
+        return hashMask;
+    }
+
+    /**
+     * Returns an enumeration of the keys contained in this
+     */
+    FastIterator keys()
+        throws IOException
+    {
+        return new HDIterator( true );
+    }
+
+    /**
+     * Returns an enumeration of the values contained in this
+     */
+    FastIterator values()
+        throws IOException
+    {
+        return new HDIterator( false );
+    }
+
+
+    /**
+     * Implement Externalizable interface
+     */
+    public void writeExternal(ObjectOutput out)
+    throws IOException {
+        out.writeByte(_depth);
+        out.writeObject(_children);
+    }
+
+
+    /**
+     * Implement Externalizable interface
+     */
+    public synchronized void readExternal(ObjectInput in)
+    throws IOException, ClassNotFoundException {
+        _depth = in.readByte();
+        _children = (long[])in.readObject();
+    }
+
+
+    ////////////////////////////////////////////////////////////////////////
+    // INNER CLASS
+    ////////////////////////////////////////////////////////////////////////
+
+    /**
+     * Utility class to enumerate keys/values in a HTree
+     */
+    public class HDIterator
+        extends FastIterator
+    {
+
+        /**
+         * True if we're iterating on keys, False if enumerating on values.
+         */
+        private boolean _iterateKeys;
+
+        /**
+         * Stacks of directories & last enumerated child position
+         */
+        private ArrayList _dirStack;
+        private ArrayList _childStack;
+
+        /**
+         * Current HashDirectory in the hierarchy
+         */
+        private HashDirectory _dir;
+
+        /**
+         * Current child position
+         */
+        private int _child;
+
+        /**
+         * Current bucket iterator
+         */
+        private Iterator _iter;
+
+
+        /**
+         * Construct an iterator on this directory.
+         *
+         * @param iterateKeys True if iteration supplies keys, False
+         *                  if iterateKeys supplies values.
+         */
+        HDIterator( boolean iterateKeys )
+            throws IOException
+        {
+            _dirStack = new ArrayList();
+            _childStack = new ArrayList();
+            _dir = HashDirectory.this;
+            _child = -1;
+            _iterateKeys = iterateKeys;
+
+            prepareNext();
+        }
+
+
+        /**
+         * Returns the next object.
+         */
+        public Object next()
+        {   
+            Object next = null;      
+            if( _iter != null && _iter.hasNext() ) {
+              next = _iter.next();
+            } else {
+              try {
+                prepareNext();
+              } catch ( IOException except ) {
+                throw new IterationException( except );
+              }
+              if ( _iter != null && _iter.hasNext() ) {
+                return next();
+              }
+            }
+            return next;         
+        }
+
+
+        /**
+         * Prepare internal state so we can answer <code>hasMoreElements</code>
+         *
+         * Actually, this code prepares an Enumeration on the next
+         * Bucket to enumerate.   If no following bucket is found,
+         * the next Enumeration is set to <code>null</code>.
+         */
+        private void prepareNext() throws IOException {
+            long child_recid = 0;
+
+            // find next bucket/directory to enumerate
+            do {
+                _child++;
+                if (_child >= MAX_CHILDREN) {
+
+                    if (_dirStack.isEmpty()) {
+                        // no more directory in the stack, we're finished
+                        return;
+                    }
+
+                    // try next page
+                    _dir = (HashDirectory) _dirStack.remove( _dirStack.size()-1 );
+                    _child = ( (Integer) _childStack.remove( _childStack.size()-1 ) ).intValue();
+                    continue;
+                }
+                child_recid = _dir._children[_child];
+            } while (child_recid == 0);
+
+            if (child_recid == 0) {
+                throw new Error("child_recid cannot be 0");
+            }
+
+            HashNode node = (HashNode) _recman.fetch( child_recid );
+            // System.out.println("HDEnumeration.get() child is : "+node);
+ 
+            if ( node instanceof HashDirectory ) {
+                // save current position
+                _dirStack.add( _dir );
+                _childStack.add( new Integer( _child ) );
+
+                _dir = (HashDirectory)node;
+                _child = -1;
+
+                // recurse into
+                _dir.setPersistenceContext( _recman, child_recid );
+                prepareNext();
+            } else {
+                // node is a bucket
+                HashBucket bucket = (HashBucket)node;
+                if ( _iterateKeys ) {
+                    _iter = bucket.getKeys().iterator();
+                } else {
+                    _iter = bucket.getValues().iterator();
+                }
+            }
+        }
+    }
+
+}
+
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HashNode.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HashNode.java
new file mode 100644
index 0000000000..49f608adf7
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/htree/HashNode.java
@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.htree;
+
+import java.io.Serializable;
+
+/**
+ *  Abstract class for Hashtable directory nodes
+ *
+ *  @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ *  @version $Id: HashNode.java,v 1.2 2003/03/21 02:54:58 boisvert Exp $
+ */
+class HashNode implements Serializable {
+
+    // Empty, there's no common functionality.  We use this abstract
+    // class for typing only.
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/BaseRecordManager.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/BaseRecordManager.java
new file mode 100644
index 0000000000..915827f026
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/BaseRecordManager.java
@@ -0,0 +1,503 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Copyright 2000-2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: BaseRecordManager.java,v 1.8 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.IOException;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.hadoop.hive.ql.util.jdbm.RecordManager;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.Serializer;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.DefaultSerializer;
+
+/**
+ *  This class manages records, which are uninterpreted blobs of data. The
+ *  set of operations is simple and straightforward: you communicate with
+ *  the class using long "rowids" and byte[] data blocks. Rowids are returned
+ *  on inserts and you can stash them away someplace safe to be able to get
+ *  back to them. Data blocks can be as long as you wish, and may have
+ *  lengths different from the original when updating.
+ *  <p>
+ *  Operations are synchronized, so that only one of them will happen
+ *  concurrently even if you hammer away from multiple threads. Operations
+ *  are made atomic by keeping a transaction log which is recovered after
+ *  a crash, so the operations specified by this interface all have ACID
+ *  properties.
+ *  <p>
+ *  You identify a file by just the name. The package attaches <tt>.db</tt>
+ *  for the database file, and <tt>.lg</tt> for the transaction log. The
+ *  transaction log is synchronized regularly and then restarted, so don't
+ *  worry if you see the size going up and down.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @author <a href="cg@cdegroot.com">Cees de Groot</a>
+ * @version $Id: BaseRecordManager.java,v 1.8 2005/06/25 23:12:32 doomdark Exp $
+ */
+public final class BaseRecordManager
+    implements RecordManager
+{
+
+    /**
+     * Underlying record file.
+     */
+    private RecordFile _file;
+
+
+    /**
+     * Physical row identifier manager.
+     */
+    private PhysicalRowIdManager _physMgr;
+
+
+    /**
+     * Logigal to Physical row identifier manager.
+     */
+    private LogicalRowIdManager _logMgr;
+
+
+    /**
+     * Page manager.
+     */
+    private PageManager _pageman;
+
+
+    /**
+     * Reserved slot for name directory.
+     */
+    public static final int NAME_DIRECTORY_ROOT = 0;
+
+
+    /**
+     * Static debugging flag
+     */
+    public static final boolean DEBUG = false;
+
+    
+    /**
+     * Directory of named JDBMHashtables.  This directory is a persistent
+     * directory, stored as a Hashtable.  It can be retrived by using
+     * the NAME_DIRECTORY_ROOT.
+     */
+    private Map _nameDirectory;
+
+
+    /**
+     *  Creates a record manager for the indicated file
+     *
+     *  @throws IOException when the file cannot be opened or is not
+     *          a valid file content-wise.
+     */
+    public BaseRecordManager( String filename )
+        throws IOException
+    {
+        _file = new RecordFile( filename );
+        _pageman = new PageManager( _file );
+        _physMgr = new PhysicalRowIdManager( _file, _pageman );
+        _logMgr = new LogicalRowIdManager( _file, _pageman );
+    }
+
+
+    /**
+     *  Get the underlying Transaction Manager
+     */
+    public synchronized TransactionManager getTransactionManager()
+    {
+        checkIfClosed();
+
+        return _file.txnMgr;
+    }
+
+
+    /**
+     *  Switches off transactioning for the record manager. This means
+     *  that a) a transaction log is not kept, and b) writes aren't
+     *  synch'ed after every update. This is useful when batch inserting
+     *  into a new database.
+     *  <p>
+     *  Only call this method directly after opening the file, otherwise
+     *  the results will be undefined.
+     */
+    public synchronized void disableTransactions()
+    {
+        checkIfClosed();
+
+        _file.disableTransactions();
+    }
+
+    
+    /**
+     *  Closes the record manager.
+     *
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized void close()
+        throws IOException
+    {
+        checkIfClosed();
+
+        _pageman.close();
+        _pageman = null;
+
+        _file.close();
+        _file = null;
+    }
+
+
+    /**
+     *  Inserts a new record using standard java object serialization.
+     *
+     *  @param obj the object for the new record.
+     *  @return the rowid for the new record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public long insert( Object obj )
+        throws IOException
+    {
+        return insert( obj, DefaultSerializer.INSTANCE );
+    }
+
+    
+    /**
+     *  Inserts a new record using a custom serializer.
+     *
+     *  @param obj the object for the new record.
+     *  @param serializer a custom serializer
+     *  @return the rowid for the new record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized long insert( Object obj, Serializer serializer )
+        throws IOException
+    {
+        byte[]    data;
+        long      recid;
+        Location  physRowId;
+        
+        checkIfClosed();
+
+        data = serializer.serialize( obj );
+        physRowId = _physMgr.insert( data, 0, data.length );
+        recid = _logMgr.insert( physRowId ).toLong();
+        if ( DEBUG ) {
+            System.out.println( "BaseRecordManager.insert() recid " + recid + " length " + data.length ) ;
+        }
+        return recid;
+    }
+
+    /**
+     *  Deletes a record.
+     *
+     *  @param recid the rowid for the record that should be deleted.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized void delete( long recid )
+        throws IOException
+    {
+        checkIfClosed();
+        if ( recid <= 0 ) {
+            throw new IllegalArgumentException( "Argument 'recid' is invalid: "
+                                                + recid );
+        }
+
+        if ( DEBUG ) {
+            System.out.println( "BaseRecordManager.delete() recid " + recid ) ;
+        }
+
+        Location logRowId = new Location( recid );
+        Location physRowId = _logMgr.fetch( logRowId );
+        _physMgr.delete( physRowId );
+        _logMgr.delete( logRowId );
+    }
+
+
+    /**
+     *  Updates a record using standard java object serialization.
+     *
+     *  @param recid the recid for the record that is to be updated.
+     *  @param obj the new object for the record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public void update( long recid, Object obj )
+        throws IOException
+    {
+        update( recid, obj, DefaultSerializer.INSTANCE );
+    }
+
+    
+    /**
+     *  Updates a record using a custom serializer.
+     *
+     *  @param recid the recid for the record that is to be updated.
+     *  @param obj the new object for the record.
+     *  @param serializer a custom serializer
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized void update( long recid, Object obj, Serializer serializer )
+        throws IOException
+    {
+        checkIfClosed();
+        if ( recid <= 0 ) {
+            throw new IllegalArgumentException( "Argument 'recid' is invalid: "
+                                                + recid );
+        }
+
+        Location logRecid = new Location( recid );
+        Location physRecid = _logMgr.fetch( logRecid );
+        
+        byte[] data = serializer.serialize( obj );
+        if ( DEBUG ) {
+            System.out.println( "BaseRecordManager.update() recid " + recid + " length " + data.length ) ;
+        }
+        
+        Location newRecid = _physMgr.update( physRecid, data, 0, data.length );
+        if ( ! newRecid.equals( physRecid ) ) {
+            _logMgr.update( logRecid, newRecid );
+        }
+    }
+
+
+    /**
+     *  Fetches a record using standard java object serialization.
+     *
+     *  @param recid the recid for the record that must be fetched.
+     *  @return the object contained in the record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public Object fetch( long recid )
+        throws IOException
+    {
+        return fetch( recid, DefaultSerializer.INSTANCE );
+    }
+
+
+    /**
+     *  Fetches a record using a custom serializer.
+     *
+     *  @param recid the recid for the record that must be fetched.
+     *  @param serializer a custom serializer
+     *  @return the object contained in the record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized Object fetch( long recid, Serializer serializer )
+        throws IOException
+    {
+        byte[] data;
+
+        checkIfClosed();
+        if ( recid <= 0 ) {
+            throw new IllegalArgumentException( "Argument 'recid' is invalid: "
+                                                + recid );
+        }
+        data = _physMgr.fetch( _logMgr.fetch( new Location( recid ) ) );
+        if ( DEBUG ) {
+            System.out.println( "BaseRecordManager.fetch() recid " + recid + " length " + data.length ) ;
+        }
+        return serializer.deserialize( data );
+    }
+
+
+    /**
+     *  Returns the number of slots available for "root" rowids. These slots
+     *  can be used to store special rowids, like rowids that point to
+     *  other rowids. Root rowids are useful for bootstrapping access to
+     *  a set of data.
+     */
+    public int getRootCount()
+    {
+        return FileHeader.NROOTS;
+    }
+
+    /**
+     *  Returns the indicated root rowid.
+     *
+     *  @see #getRootCount
+     */
+    public synchronized long getRoot( int id )
+        throws IOException
+    {
+        checkIfClosed();
+
+        return _pageman.getFileHeader().getRoot( id );
+    }
+
+
+    /**
+     *  Sets the indicated root rowid.
+     *
+     *  @see #getRootCount
+     */
+    public synchronized void setRoot( int id, long rowid )
+        throws IOException
+    {
+        checkIfClosed();
+
+        _pageman.getFileHeader().setRoot( id, rowid );
+    }
+
+
+    /**
+     * Obtain the record id of a named object. Returns 0 if named object
+     * doesn't exist.
+     */
+    public long getNamedObject( String name )
+        throws IOException
+    {
+        checkIfClosed();
+
+        Map nameDirectory = getNameDirectory();
+        Long recid = (Long) nameDirectory.get( name );
+        if ( recid == null ) {
+            return 0;
+        }
+        return recid.longValue();
+    }
+
+    /**
+     * Set the record id of a named object.
+     */
+    public void setNamedObject( String name, long recid )
+        throws IOException
+    {
+        checkIfClosed();
+
+        Map nameDirectory = getNameDirectory();
+        if ( recid == 0 ) {
+            // remove from hashtable
+            nameDirectory.remove( name );
+        } else {
+            nameDirectory.put( name, new Long( recid ) );
+        }
+        saveNameDirectory( nameDirectory );
+    }
+
+
+    /**
+     * Commit (make persistent) all changes since beginning of transaction.
+     */
+    public synchronized void commit()
+        throws IOException
+    {
+        checkIfClosed();
+
+        _pageman.commit();
+    }
+
+
+    /**
+     * Rollback (cancel) all changes since beginning of transaction.
+     */
+    public synchronized void rollback()
+        throws IOException
+    {
+        checkIfClosed();
+
+        _pageman.rollback();
+    }
+
+
+    /**
+     * Load name directory
+     */
+    private Map getNameDirectory()
+        throws IOException
+    {
+        // retrieve directory of named hashtable
+        long nameDirectory_recid = getRoot( NAME_DIRECTORY_ROOT );
+        if ( nameDirectory_recid == 0 ) {
+            _nameDirectory = new HashMap();
+            nameDirectory_recid = insert( _nameDirectory );
+            setRoot( NAME_DIRECTORY_ROOT, nameDirectory_recid );
+        } else {
+            _nameDirectory = (Map) fetch( nameDirectory_recid );
+        }
+        return _nameDirectory;
+    }
+
+
+    private void saveNameDirectory( Map directory )
+        throws IOException
+    {
+        long recid = getRoot( NAME_DIRECTORY_ROOT );
+        if ( recid == 0 ) {
+            throw new IOException( "Name directory must exist" );
+        }
+        update( recid, _nameDirectory );
+    }
+
+
+    /**
+     * Check if RecordManager has been closed.  If so, throw an
+     * IllegalStateException.
+     */
+    private void checkIfClosed()
+        throws IllegalStateException
+    {
+        if ( _file == null ) {
+            throw new IllegalStateException( "RecordManager has been closed" );
+        }
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/BlockIo.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/BlockIo.java
new file mode 100644
index 0000000000..a6aae6929c
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/BlockIo.java
@@ -0,0 +1,325 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: BlockIo.java,v 1.2 2002/08/06 05:18:36 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.*;
+
+/**
+ *  This class wraps a page-sized byte array and provides methods
+ *  to read and write data to and from it. The readers and writers
+ *  are just the ones that the rest of the toolkit needs, nothing else.
+ *  Values written are compatible with java.io routines.
+ *
+ *  @see java.io.DataInput
+ *  @see java.io.DataOutput
+ */
+public final class BlockIo implements java.io.Externalizable {
+
+    public final static long serialVersionUID = 2L;
+
+    private long blockId;
+
+    private transient byte[] data; // work area
+    private transient BlockView view = null;
+    private transient boolean dirty = false;
+    private transient int transactionCount = 0;
+
+    /**
+     * Default constructor for serialization
+     */
+    public BlockIo() {
+        // empty
+    }
+
+    /**
+     *  Constructs a new BlockIo instance working on the indicated
+     *  buffer.
+     */
+    BlockIo(long blockId, byte[] data) {
+        // removeme for production version
+        if (blockId > 10000000000L)
+            throw new Error("bogus block id " + blockId);
+        this.blockId = blockId;
+        this.data = data;
+    }
+
+    /**
+     *  Returns the underlying array
+     */
+    byte[] getData() {
+        return data;
+    }
+
+    /**
+     *  Sets the block number. Should only be called by RecordFile.
+     */
+    void setBlockId(long id) {
+        if (isInTransaction())
+            throw new Error("BlockId assigned for transaction block");
+        // removeme for production version
+        if (id > 10000000000L)
+            throw new Error("bogus block id " + id);
+        blockId = id;
+    }
+
+    /**
+     *  Returns the block number.
+     */
+    long getBlockId() {
+        return blockId;
+    }
+
+    /**
+     *  Returns the current view of the block.
+     */
+    public BlockView getView() {
+        return view;
+    }
+
+    /**
+     *  Sets the current view of the block.
+     */
+    public void setView(BlockView view) {
+        this.view = view;
+    }
+
+    /**
+     *  Sets the dirty flag
+     */
+    void setDirty() {
+        dirty = true;
+    }
+
+    /**
+     *  Clears the dirty flag
+     */
+    void setClean() {
+        dirty = false;
+    }
+
+    /**
+     *  Returns true if the dirty flag is set.
+     */
+    boolean isDirty() {
+        return dirty;
+    }
+
+    /**
+     *  Returns true if the block is still dirty with respect to the
+     *  transaction log.
+     */
+    boolean isInTransaction() {
+        return transactionCount != 0;
+    }
+
+    /**
+     *  Increments transaction count for this block, to signal that this
+     *  block is in the log but not yet in the data file. The method also
+     *  takes a snapshot so that the data may be modified in new transactions.
+     */
+    synchronized void incrementTransactionCount() {
+        transactionCount++;
+        // @fixme(alex)
+        setClean();
+    }
+
+    /**
+     *  Decrements transaction count for this block, to signal that this
+     *  block has been written from the log to the data file.
+     */
+    synchronized void decrementTransactionCount() {
+        transactionCount--;
+        if (transactionCount < 0)
+            throw new Error("transaction count on block "
+                            + getBlockId() + " below zero!");
+
+    }
+
+    /**
+     *  Reads a byte from the indicated position
+     */
+    public byte readByte(int pos) {
+        return data[pos];
+    }
+
+    /**
+     *  Writes a byte to the indicated position
+     */
+    public void writeByte(int pos, byte value) {
+        data[pos] = value;
+        setDirty();
+    }
+
+    /**
+     *  Reads a short from the indicated position
+     */
+    public short readShort(int pos) {
+        return (short)
+            (((short) (data[pos+0] & 0xff) << 8) |
+             ((short) (data[pos+1] & 0xff) << 0));
+    }
+
+    /**
+     *  Writes a short to the indicated position
+     */
+    public void writeShort(int pos, short value) {
+        data[pos+0] = (byte)(0xff & (value >> 8));
+        data[pos+1] = (byte)(0xff & (value >> 0));
+        setDirty();
+    }
+
+    /**
+     *  Reads an int from the indicated position
+     */
+    public int readInt(int pos) {
+        return
+            (((int)(data[pos+0] & 0xff) << 24) |
+             ((int)(data[pos+1] & 0xff) << 16) |
+             ((int)(data[pos+2] & 0xff) <<  8) |
+             ((int)(data[pos+3] & 0xff) <<  0));
+    }
+
+    /**
+     *  Writes an int to the indicated position
+     */
+    public void writeInt(int pos, int value) {
+        data[pos+0] = (byte)(0xff & (value >> 24));
+        data[pos+1] = (byte)(0xff & (value >> 16));
+        data[pos+2] = (byte)(0xff & (value >>  8));
+        data[pos+3] = (byte)(0xff & (value >>  0));
+        setDirty();
+    }
+
+    /**
+     *  Reads a long from the indicated position
+     */
+    public long readLong( int pos )
+    {
+        // Contributed by Erwin Bolwidt <ejb@klomp.org>
+        // Gives about 15% performance improvement
+        return
+            ( (long)( ((data[pos+0] & 0xff) << 24) |
+                      ((data[pos+1] & 0xff) << 16) |
+                      ((data[pos+2] & 0xff) <<  8) |
+                      ((data[pos+3] & 0xff)      ) ) << 32 ) |
+            ( (long)( ((data[pos+4] & 0xff) << 24) |
+                      ((data[pos+5] & 0xff) << 16) |
+                      ((data[pos+6] & 0xff) <<  8) |
+                      ((data[pos+7] & 0xff)      ) ) & 0xffffffff );
+        /* Original version by Alex Boisvert.  Might be faster on 64-bit JVMs.
+        return
+            (((long)(data[pos+0] & 0xff) << 56) |
+             ((long)(data[pos+1] & 0xff) << 48) |
+             ((long)(data[pos+2] & 0xff) << 40) |
+             ((long)(data[pos+3] & 0xff) << 32) |
+             ((long)(data[pos+4] & 0xff) << 24) |
+             ((long)(data[pos+5] & 0xff) << 16) |
+             ((long)(data[pos+6] & 0xff) <<  8) |
+             ((long)(data[pos+7] & 0xff) <<  0));
+        */
+    }
+
+    /**
+     *  Writes a long to the indicated position
+     */
+    public void writeLong(int pos, long value) {
+        data[pos+0] = (byte)(0xff & (value >> 56));
+        data[pos+1] = (byte)(0xff & (value >> 48));
+        data[pos+2] = (byte)(0xff & (value >> 40));
+        data[pos+3] = (byte)(0xff & (value >> 32));
+        data[pos+4] = (byte)(0xff & (value >> 24));
+        data[pos+5] = (byte)(0xff & (value >> 16));
+        data[pos+6] = (byte)(0xff & (value >>  8));
+        data[pos+7] = (byte)(0xff & (value >>  0));
+        setDirty();
+    }
+
+    // overrides java.lang.Object
+
+    public String toString() {
+        return "BlockIO("
+            + blockId + ","
+            + dirty + ","
+            + view + ")";
+    }
+
+    // implement externalizable interface
+    public void readExternal(ObjectInput in)
+    throws IOException, ClassNotFoundException {
+        blockId = in.readLong();
+        int length = in.readInt();
+        data = new byte[length];
+        in.readFully(data);
+    }
+
+    // implement externalizable interface
+    public void writeExternal(ObjectOutput out) throws IOException {
+        out.writeLong(blockId);
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/BlockView.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/BlockView.java
new file mode 100644
index 0000000000..0fe30d9aa7
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/BlockView.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: BlockView.java,v 1.2 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  This is a marker interface that is implemented by classes that
+ *  interpret blocks of data by pretending to be an overlay.
+ *
+ *  @see BlockIo#setView
+ */
+public interface BlockView {
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/CacheRecordManager.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/CacheRecordManager.java
new file mode 100644
index 0000000000..ad2fecd068
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/CacheRecordManager.java
@@ -0,0 +1,475 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Copyright 2000-2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: CacheRecordManager.java,v 1.9 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import org.apache.hadoop.hive.ql.util.jdbm.RecordManager;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.CacheEvictionException;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.CachePolicy;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.CachePolicyListener;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.DefaultSerializer;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.Serializer;
+import org.apache.hadoop.hive.ql.util.jdbm.helper.WrappedRuntimeException;
+
+import java.io.IOException;
+import java.util.Enumeration;
+
+/**
+ *  A RecordManager wrapping and caching another RecordManager.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @author <a href="cg@cdegroot.com">Cees de Groot</a>
+ * @version $Id: CacheRecordManager.java,v 1.9 2005/06/25 23:12:32 doomdark Exp $
+ */
+public class CacheRecordManager
+    implements RecordManager
+{
+
+    /**
+     * Wrapped RecordManager
+     */
+    protected RecordManager _recman;
+
+
+    /**
+     * Cache for underlying RecordManager
+     */
+    protected CachePolicy _cache;
+
+
+    /**
+     * Construct a CacheRecordManager wrapping another RecordManager and
+     * using a given cache policy.
+     *
+     * @param recman Wrapped RecordManager
+     * @param cache Cache policy
+     */
+    public CacheRecordManager( RecordManager recman, CachePolicy cache )
+    {
+        if ( recman == null ) {
+            throw new IllegalArgumentException( "Argument 'recman' is null" );
+        }
+        if ( cache == null ) {
+            throw new IllegalArgumentException( "Argument 'cache' is null" );
+        }
+        _recman = recman;
+        _cache = cache;
+        
+        _cache.addListener( new CacheListener() );
+    }
+
+    
+    /**
+     * Get the underlying Record Manager.
+     *
+     * @return underlying RecordManager or null if CacheRecordManager has
+     *         been closed. 
+     */
+    public RecordManager getRecordManager()
+    {
+        return _recman;
+    }
+
+    
+    /**
+     * Get the underlying cache policy
+     *
+     * @return underlying CachePolicy or null if CacheRecordManager has
+     *         been closed. 
+     */
+    public CachePolicy getCachePolicy()
+    {
+        return _cache;
+    }
+
+    
+    /**
+     *  Inserts a new record using a custom serializer.
+     *
+     *  @param obj the object for the new record.
+     *  @return the rowid for the new record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public long insert( Object obj )
+        throws IOException
+    {
+        return insert( obj, DefaultSerializer.INSTANCE );
+    }
+        
+        
+    /**
+     *  Inserts a new record using a custom serializer.
+     *
+     *  @param obj the object for the new record.
+     *  @param serializer a custom serializer
+     *  @return the rowid for the new record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized long insert( Object obj, Serializer serializer )
+        throws IOException
+    {
+        checkIfClosed();
+
+        long recid = _recman.insert( obj, serializer );
+        try {
+            _cache.put( new Long( recid ), new CacheEntry( recid, obj, serializer, false ) );
+        } catch ( CacheEvictionException except ) {
+            throw new WrappedRuntimeException( except );
+        }
+        return recid;
+    }
+
+
+    /**
+     *  Deletes a record.
+     *
+     *  @param recid the rowid for the record that should be deleted.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized void delete( long recid )
+        throws IOException
+    {
+        checkIfClosed();
+
+        _recman.delete( recid );
+        _cache.remove( new Long( recid ) );
+    }
+
+
+    /**
+     *  Updates a record using standard Java serialization.
+     *
+     *  @param recid the recid for the record that is to be updated.
+     *  @param obj the new object for the record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public void update( long recid, Object obj )
+        throws IOException
+    {
+        update( recid, obj, DefaultSerializer.INSTANCE );
+    }
+    
+
+    /**
+     *  Updates a record using a custom serializer.
+     *
+     *  @param recid the recid for the record that is to be updated.
+     *  @param obj the new object for the record.
+     *  @param serializer a custom serializer
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized void update( long recid, Object obj, 
+                                     Serializer serializer )
+        throws IOException
+    {
+        CacheEntry  entry;
+        Long        id;
+        
+        checkIfClosed();
+
+        id = new Long( recid );
+        try {
+            entry = (CacheEntry) _cache.get( id );
+            if ( entry != null ) {
+                // reuse existing cache entry
+                entry._obj = obj;
+                entry._serializer = serializer;
+                entry._isDirty = true;
+            } else {
+                _cache.put( id, new CacheEntry( recid, obj, serializer, true ) );
+            }
+        } catch ( CacheEvictionException except ) {
+            throw new IOException( except.getMessage() );
+        }
+    }
+
+
+    /**
+     *  Fetches a record using standard Java serialization.
+     *
+     *  @param recid the recid for the record that must be fetched.
+     *  @return the object contained in the record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public Object fetch( long recid )
+        throws IOException
+    {
+        return fetch( recid, DefaultSerializer.INSTANCE );
+    }
+
+        
+    /**
+     *  Fetches a record using a custom serializer.
+     *
+     *  @param recid the recid for the record that must be fetched.
+     *  @param serializer a custom serializer
+     *  @return the object contained in the record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized Object fetch( long recid, Serializer serializer )
+        throws IOException
+    {
+        checkIfClosed();
+
+        Long id = new Long( recid );
+        CacheEntry entry = (CacheEntry) _cache.get( id );
+        if ( entry == null ) {
+            entry = new CacheEntry( recid, null, serializer, false );
+            entry._obj = _recman.fetch( recid, serializer );
+            try {
+                _cache.put( id, entry );
+            } catch ( CacheEvictionException except ) {
+                throw new WrappedRuntimeException( except );
+            }
+        }
+        return entry._obj;
+    }
+
+
+    /**
+     *  Closes the record manager.
+     *
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized void close()
+        throws IOException
+    {
+        checkIfClosed();
+
+        updateCacheEntries();
+        _recman.close();
+        _recman = null;
+        _cache = null;
+    }
+
+
+    /**
+     *  Returns the number of slots available for "root" rowids. These slots
+     *  can be used to store special rowids, like rowids that point to
+     *  other rowids. Root rowids are useful for bootstrapping access to
+     *  a set of data.
+     */
+    public synchronized int getRootCount()
+    {
+        checkIfClosed();
+
+        return _recman.getRootCount();
+    }
+
+
+    /**
+     *  Returns the indicated root rowid.
+     *
+     *  @see #getRootCount
+     */
+    public synchronized long getRoot( int id )
+        throws IOException
+    {
+        checkIfClosed();
+
+        return _recman.getRoot( id );
+    }
+
+
+    /**
+     *  Sets the indicated root rowid.
+     *
+     *  @see #getRootCount
+     */
+    public synchronized void setRoot( int id, long rowid )
+        throws IOException
+    {
+        checkIfClosed();
+
+        _recman.setRoot( id, rowid );
+    }
+
+
+    /**
+     * Commit (make persistent) all changes since beginning of transaction.
+     */
+    public synchronized void commit()
+        throws IOException
+    {
+        checkIfClosed();
+        updateCacheEntries();
+        _recman.commit();
+    }
+
+
+    /**
+     * Rollback (cancel) all changes since beginning of transaction.
+     */
+    public synchronized void rollback()
+        throws IOException
+    {
+        checkIfClosed();
+
+        _recman.rollback();
+
+        // discard all cache entries since we don't know which entries
+        // where part of the transaction
+        _cache.removeAll();
+    }
+
+
+    /**
+     * Obtain the record id of a named object. Returns 0 if named object
+     * doesn't exist.
+     */
+    public synchronized long getNamedObject( String name )
+        throws IOException
+    {
+        checkIfClosed();
+
+        return _recman.getNamedObject( name );
+    }
+
+
+    /**
+     * Set the record id of a named object.
+     */
+    public synchronized void setNamedObject( String name, long recid )
+        throws IOException
+    {
+        checkIfClosed();
+
+        _recman.setNamedObject( name, recid );
+    }
+
+
+    /**
+     * Check if RecordManager has been closed.  If so, throw an
+     * IllegalStateException
+     */
+    private void checkIfClosed()
+        throws IllegalStateException
+    {
+        if ( _recman == null ) {
+            throw new IllegalStateException( "RecordManager has been closed" );
+        }
+    }
+
+    
+    /**
+     * Update all dirty cache objects to the underlying RecordManager.
+     */
+    protected void updateCacheEntries()
+        throws IOException
+    {
+        Enumeration enume = _cache.elements();
+        while ( enume.hasMoreElements() ) {
+            CacheEntry entry = (CacheEntry) enume.nextElement();
+            if ( entry._isDirty ) {
+                _recman.update( entry._recid, entry._obj, entry._serializer );
+                entry._isDirty = false;
+            }
+        }
+    }
+
+    
+    private class CacheEntry
+    {
+
+        long _recid;
+        Object _obj;
+        Serializer _serializer;
+        boolean _isDirty;
+        
+        CacheEntry( long recid, Object obj, Serializer serializer, boolean isDirty )
+        {
+            _recid = recid;
+            _obj = obj;
+            _serializer = serializer;
+            _isDirty = isDirty;
+        }
+        
+    } // class CacheEntry
+
+    private class CacheListener
+        implements CachePolicyListener
+    {
+        
+        /** Notification that cache is evicting an object
+         *
+         * @arg obj object evited from cache
+         *
+         */
+        public void cacheObjectEvicted( Object obj ) 
+            throws CacheEvictionException
+        {
+            CacheEntry entry = (CacheEntry) obj;
+            if ( entry._isDirty ) {
+                try {
+                    _recman.update( entry._recid, entry._obj, entry._serializer );
+                } catch ( IOException except ) {
+                    throw new CacheEvictionException( except );
+                }
+            }
+        }
+        
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/DataPage.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/DataPage.java
new file mode 100644
index 0000000000..78bd54262a
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/DataPage.java
@@ -0,0 +1,109 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: DataPage.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  Class describing a page that holds data.
+ */
+final class DataPage extends PageHeader {
+    // offsets
+    private static final short O_FIRST = PageHeader.SIZE; // short firstrowid
+    static final short O_DATA = (short)(O_FIRST + Magic.SZ_SHORT);
+    static final short DATA_PER_PAGE = (short)(RecordFile.BLOCK_SIZE - O_DATA);
+
+    /**
+     *  Constructs a data page view from the indicated block.
+     */
+    DataPage(BlockIo block) {
+  super(block);
+    }
+
+    /**
+     *  Factory method to create or return a data page for the
+     *  indicated block.
+     */
+    static DataPage getDataPageView(BlockIo block) {
+  BlockView view = block.getView();
+  if (view != null && view instanceof DataPage)
+      return (DataPage) view;
+  else
+      return new DataPage(block);
+    }
+
+    /** Returns the first rowid's offset */
+    short getFirst() {
+  return block.readShort(O_FIRST);
+    }
+    
+    /** Sets the first rowid's offset */
+    void setFirst(short value) {
+  paranoiaMagicOk();
+  if (value > 0 && value < O_DATA)
+      throw new Error("DataPage.setFirst: offset " + value 
+          + " too small");
+  block.writeShort(O_FIRST, value);
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FileHeader.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FileHeader.java
new file mode 100644
index 0000000000..6bba1d96f6
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FileHeader.java
@@ -0,0 +1,174 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: FileHeader.java,v 1.3 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  This class represents a file header. It is a 1:1 representation of
+ *  the data that appears in block 0 of a file.
+ */
+class FileHeader implements BlockView {
+    // offsets
+    private static final short O_MAGIC = 0; // short magic
+    private static final short O_LISTS = Magic.SZ_SHORT; // long[2*NLISTS]
+    private static final int O_ROOTS = 
+        O_LISTS + (Magic.NLISTS * 2 * Magic.SZ_LONG);
+
+    // my block
+    private BlockIo block;
+
+    /** The number of "root" rowids available in the file. */
+    static final int NROOTS = 
+        (RecordFile.BLOCK_SIZE - O_ROOTS) / Magic.SZ_LONG;
+
+    /**
+     *  Constructs a FileHeader object from a block.
+     *
+     *  @param block The block that contains the file header
+     *  @param isNew If true, the file header is for a new file.
+     *  @throws IOException if the block is too short to keep the file
+     *          header.
+     */
+    FileHeader(BlockIo block, boolean isNew) {
+        this.block = block;
+        if (isNew)
+            block.writeShort(O_MAGIC, Magic.FILE_HEADER);
+        else if (!magicOk())
+            throw new Error("CRITICAL: file header magic not OK " 
+                            + block.readShort(O_MAGIC));
+    }
+
+    /** Returns true if the magic corresponds with the fileHeader magic.  */
+    private boolean magicOk() {
+        return block.readShort(O_MAGIC) == Magic.FILE_HEADER;
+    }
+
+
+    /** Returns the offset of the "first" block of the indicated list */
+    private short offsetOfFirst(int list) {
+        return (short) (O_LISTS + (2 * Magic.SZ_LONG * list));
+    }
+
+    /** Returns the offset of the "last" block of the indicated list */
+    private short offsetOfLast(int list) {
+        return (short) (offsetOfFirst(list) + Magic.SZ_LONG);
+    }
+
+    /** Returns the offset of the indicated root */
+    private short offsetOfRoot(int root) {
+        return (short) (O_ROOTS + (root * Magic.SZ_LONG));
+    }
+
+    /**
+     *  Returns the first block of the indicated list
+     */
+    long getFirstOf(int list) {
+        return block.readLong(offsetOfFirst(list));
+    }
+    
+    /**
+     *  Sets the first block of the indicated list
+     */
+    void setFirstOf(int list, long value) {
+        block.writeLong(offsetOfFirst(list), value);
+    }
+    
+    /**
+     *  Returns the last block of the indicated list
+     */
+    long getLastOf(int list) {
+        return block.readLong(offsetOfLast(list));
+    }
+    
+    /**
+     *  Sets the last block of the indicated list
+     */
+    void setLastOf(int list, long value) {
+        block.writeLong(offsetOfLast(list), value);
+    }
+
+    /**
+     *  Returns the indicated root rowid. A root rowid is a special rowid
+     *  that needs to be kept between sessions. It could conceivably be
+     *  stored in a special file, but as a large amount of space in the
+     *  block header is wasted anyway, it's more useful to store it where
+     *  it belongs.
+     *
+     *  @see #NROOTS
+     */
+    long getRoot(int root) {
+        return block.readLong(offsetOfRoot(root));
+    }
+
+    /**
+     *  Sets the indicated root rowid.
+     *
+     *  @see #getRoot
+     *  @see #NROOTS
+     */
+    void setRoot(int root, long rowid) {
+        block.writeLong(offsetOfRoot(root), rowid);
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreeLogicalRowIdPage.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreeLogicalRowIdPage.java
new file mode 100644
index 0000000000..294aa46827
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreeLogicalRowIdPage.java
@@ -0,0 +1,172 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: FreeLogicalRowIdPage.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  Class describing a page that holds logical rowids that were freed. Note
+ *  that the methods have *physical* rowids in their signatures - this is
+ *  because logical and physical rowids are internally the same, only their
+ *  external representation (i.e. in the client API) differs.
+ */
+class FreeLogicalRowIdPage extends PageHeader {
+    // offsets
+    private static final short O_COUNT = PageHeader.SIZE; // short count
+    static final short O_FREE = (short)(O_COUNT + Magic.SZ_SHORT);
+    static final short ELEMS_PER_PAGE = (short)
+        ((RecordFile.BLOCK_SIZE - O_FREE) / PhysicalRowId.SIZE);
+
+    // slots we returned.
+    final PhysicalRowId[] slots = new PhysicalRowId[ELEMS_PER_PAGE];
+
+    /**
+     *  Constructs a data page view from the indicated block.
+     */
+    FreeLogicalRowIdPage(BlockIo block) {
+        super(block);
+    }
+
+    /**
+     *  Factory method to create or return a data page for the
+     *  indicated block.
+     */
+    static FreeLogicalRowIdPage getFreeLogicalRowIdPageView(BlockIo block) {
+
+        BlockView view = block.getView();
+        if (view != null && view instanceof FreeLogicalRowIdPage)
+            return (FreeLogicalRowIdPage) view;
+        else
+            return new FreeLogicalRowIdPage(block);
+    }
+
+    /** Returns the number of free rowids */
+    short getCount() {
+        return block.readShort(O_COUNT);
+    }
+
+    /** Sets the number of free rowids */
+    private void setCount(short i) {
+        block.writeShort(O_COUNT, i);
+    }
+
+    /** Frees a slot */
+    void free(int slot) {
+        get(slot).setBlock(0);
+        setCount((short) (getCount() - 1));
+    }
+
+    /** Allocates a slot */
+    PhysicalRowId alloc(int slot) {
+        setCount((short) (getCount() + 1));
+        get(slot).setBlock(-1);
+        return get(slot);
+    }
+
+    /** Returns true if a slot is allocated */
+    boolean isAllocated(int slot) {
+        return get(slot).getBlock() > 0;
+    }
+
+    /** Returns true if a slot is free */
+    boolean isFree(int slot) {
+        return !isAllocated(slot);
+    }
+
+
+    /** Returns the value of the indicated slot */
+    PhysicalRowId get(int slot) {
+        if (slots[slot] == null)
+            slots[slot] = new PhysicalRowId(block, slotToOffset(slot));;
+        return slots[slot];
+    }
+
+    /** Converts slot to offset */
+    private short slotToOffset(int slot) {
+        return (short) (O_FREE +
+                        (slot * PhysicalRowId.SIZE));
+    }
+
+    /**
+     *  Returns first free slot, -1 if no slots are available
+     */
+    int getFirstFree() {
+        for (int i = 0; i < ELEMS_PER_PAGE; i++) {
+            if (isFree(i))
+                return i;
+        }
+        return -1;
+    }
+
+    /**
+     *  Returns first allocated slot, -1 if no slots are available.
+     */
+    int getFirstAllocated() {
+        for (int i = 0; i < ELEMS_PER_PAGE; i++) {
+            if (isAllocated(i))
+                return i;
+        }
+        return -1;
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreeLogicalRowIdPageManager.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreeLogicalRowIdPageManager.java
new file mode 100644
index 0000000000..0a48bdba40
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreeLogicalRowIdPageManager.java
@@ -0,0 +1,161 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: FreeLogicalRowIdPageManager.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This class manages free Logical rowid pages and provides methods
+ *  to free and allocate Logical rowids on a high level.
+ */
+final class FreeLogicalRowIdPageManager {
+    // our record file
+    private RecordFile file;
+    // our page manager
+    private PageManager pageman;
+
+    /**
+     *  Creates a new instance using the indicated record file and
+     *  page manager.
+     */
+    FreeLogicalRowIdPageManager(RecordFile file,
+                                PageManager pageman) throws IOException {
+        this.file = file;
+        this.pageman = pageman;
+    }
+
+    /**
+     *  Returns a free Logical rowid, or
+     *  null if nothing was found.
+     */
+    Location get() throws IOException {
+  
+        // Loop through the free Logical rowid list until we find
+        // the first rowid.
+        Location retval = null;
+        PageCursor curs = new PageCursor(pageman, Magic.FREELOGIDS_PAGE);
+        while (curs.next() != 0) {
+            FreeLogicalRowIdPage fp = FreeLogicalRowIdPage
+                .getFreeLogicalRowIdPageView(file.get(curs.getCurrent()));
+            int slot = fp.getFirstAllocated();
+            if (slot != -1) {
+                // got one!
+                retval =
+                    new Location(fp.get(slot));
+                fp.free(slot);
+                if (fp.getCount() == 0) {
+                    // page became empty - free it
+                    file.release(curs.getCurrent(), false);
+                    pageman.free(Magic.FREELOGIDS_PAGE, curs.getCurrent());
+                }
+                else
+                    file.release(curs.getCurrent(), true);
+                
+                return retval;
+            }
+            else {
+                // no luck, go to next page
+                file.release(curs.getCurrent(), false);
+            }     
+        }
+        return null;
+    }
+
+    /**
+     *  Puts the indicated rowid on the free list
+     */
+    void put(Location rowid)
+    throws IOException {
+        
+        PhysicalRowId free = null;
+        PageCursor curs = new PageCursor(pageman, Magic.FREELOGIDS_PAGE);
+        long freePage = 0;
+        while (curs.next() != 0) {
+            freePage = curs.getCurrent();
+            BlockIo curBlock = file.get(freePage);
+            FreeLogicalRowIdPage fp = FreeLogicalRowIdPage
+                .getFreeLogicalRowIdPageView(curBlock);
+            int slot = fp.getFirstFree();
+            if (slot != -1) {
+                free = fp.alloc(slot);
+                break;
+            }
+            
+            file.release(curBlock);
+        }
+        if (free == null) {
+            // No more space on the free list, add a page.
+            freePage = pageman.allocate(Magic.FREELOGIDS_PAGE);
+            BlockIo curBlock = file.get(freePage);
+            FreeLogicalRowIdPage fp = 
+                FreeLogicalRowIdPage.getFreeLogicalRowIdPageView(curBlock);
+            free = fp.alloc(0);
+        }
+        free.setBlock(rowid.getBlock());
+        free.setOffset(rowid.getOffset());
+        file.release(freePage, true);
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreePhysicalRowId.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreePhysicalRowId.java
new file mode 100644
index 0000000000..425de31f0c
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreePhysicalRowId.java
@@ -0,0 +1,95 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: FreePhysicalRowId.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  This class extends the physical rowid with a size value to indicated
+ *  the size of a free rowid on the free rowid list.
+ */
+final class FreePhysicalRowId extends PhysicalRowId {
+    // offsets
+    private static final short O_SIZE = PhysicalRowId.SIZE; // int size
+    static final short SIZE = O_SIZE + Magic.SZ_INT;
+
+    /**
+     *  Constructs a physical rowid from the indicated data starting at
+     *  the indicated position.
+     */
+    FreePhysicalRowId(BlockIo block, short pos) {
+  super(block, pos);
+    }
+
+    /** Returns the size */
+    int getSize() {
+  return block.readInt(pos + O_SIZE);
+    }
+
+    /** Sets the size */
+    void setSize(int value) {
+  block.writeInt(pos + O_SIZE, value);
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreePhysicalRowIdPage.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreePhysicalRowIdPage.java
new file mode 100644
index 0000000000..2219c5b0da
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreePhysicalRowIdPage.java
@@ -0,0 +1,168 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: FreePhysicalRowIdPage.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  Class describing a page that holds physical rowids that were freed.
+ */
+final class FreePhysicalRowIdPage extends PageHeader {
+    // offsets
+    private static final short O_COUNT = PageHeader.SIZE; // short count
+    static final short O_FREE = O_COUNT + Magic.SZ_SHORT;
+    static final short ELEMS_PER_PAGE = 
+  (RecordFile.BLOCK_SIZE - O_FREE) / FreePhysicalRowId.SIZE;
+    
+    // slots we returned.
+    FreePhysicalRowId[] slots = new FreePhysicalRowId[ELEMS_PER_PAGE];
+
+    /**
+     *  Constructs a data page view from the indicated block.
+     */
+    FreePhysicalRowIdPage(BlockIo block) {
+  super(block);
+    }
+
+    /**
+     *  Factory method to create or return a data page for the
+     *  indicated block.
+     */
+    static FreePhysicalRowIdPage getFreePhysicalRowIdPageView(BlockIo block) {
+  BlockView view = block.getView();
+  if (view != null && view instanceof FreePhysicalRowIdPage)
+      return (FreePhysicalRowIdPage) view;
+  else
+      return new FreePhysicalRowIdPage(block);
+    }
+
+    /** Returns the number of free rowids */
+    short getCount() {
+  return block.readShort(O_COUNT);
+    }
+
+    /** Sets the number of free rowids */
+    private void setCount(short i) {
+  block.writeShort(O_COUNT, i);
+    }
+
+    /** Frees a slot */
+    void free(int slot) {
+  get(slot).setSize(0);
+  setCount((short) (getCount() - 1));
+    }
+
+    /** Allocates a slot */
+    FreePhysicalRowId alloc(int slot) {
+  setCount((short) (getCount() + 1));
+  return get(slot);
+    }
+
+    /** Returns true if a slot is allocated */
+    boolean isAllocated(int slot) {
+  return get(slot).getSize() != 0;
+    }
+
+    /** Returns true if a slot is free */
+    boolean isFree(int slot) {
+  return !isAllocated(slot);
+    }
+    
+    
+    /** Returns the value of the indicated slot */
+    FreePhysicalRowId get(int slot) {
+  if (slots[slot] == null) 
+      slots[slot] = new FreePhysicalRowId(block, slotToOffset(slot));;
+  return slots[slot];
+    }
+
+    /** Converts slot to offset */
+    short slotToOffset(int slot) {
+  return (short) (O_FREE +
+      (slot * FreePhysicalRowId.SIZE));
+    }
+    
+    /** 
+     *  Returns first free slot, -1 if no slots are available
+     */
+    int getFirstFree() {
+  for (int i = 0; i < ELEMS_PER_PAGE; i++) {
+      if (isFree(i))
+    return i;
+  }
+  return -1;
+    }
+
+    /** 
+     *  Returns first slot with available size >= indicated size,  
+     *  or -1 if no slots are available.
+     **/
+    int getFirstLargerThan(int size) {
+  for (int i = 0; i < ELEMS_PER_PAGE; i++) {
+      if (isAllocated(i) && get(i).getSize() >= size)
+    return i;
+  }
+  return -1;
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreePhysicalRowIdPageManager.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreePhysicalRowIdPageManager.java
new file mode 100644
index 0000000000..7e3cd804cf
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/FreePhysicalRowIdPageManager.java
@@ -0,0 +1,170 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: FreePhysicalRowIdPageManager.java,v 1.2 2001/11/17 16:14:25 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This class manages free physical rowid pages and provides methods
+ *  to free and allocate physical rowids on a high level.
+ */
+final class FreePhysicalRowIdPageManager
+{
+    // our record file
+    protected RecordFile _file;
+
+    // our page manager
+    protected PageManager _pageman;
+
+    /**
+     *  Creates a new instance using the indicated record file and
+     *  page manager.
+     */
+    FreePhysicalRowIdPageManager( RecordFile file, PageManager pageman )
+        throws IOException
+    {
+        _file = file;
+        _pageman = pageman;
+    }
+
+
+    /**
+     *  Returns a free physical rowid of the indicated size, or
+     *  null if nothing was found.
+     */
+    Location get( int size )
+        throws IOException
+    {
+        // Loop through the free physical rowid list until we find
+        // a rowid that's large enough.
+        Location retval = null;
+        PageCursor curs = new PageCursor( _pageman, Magic.FREEPHYSIDS_PAGE );
+
+        while (curs.next() != 0) {
+            FreePhysicalRowIdPage fp = FreePhysicalRowIdPage
+                .getFreePhysicalRowIdPageView( _file.get( curs.getCurrent() ) );
+            int slot = fp.getFirstLargerThan( size );
+            if ( slot != -1 ) {
+                // got one!
+                retval = new Location( fp.get( slot ) );
+
+                int slotsize = fp.get( slot ).getSize();
+                fp.free( slot );
+                if ( fp.getCount() == 0 ) {
+                    // page became empty - free it
+                    _file.release( curs.getCurrent(), false );
+                    _pageman.free( Magic.FREEPHYSIDS_PAGE, curs.getCurrent() );
+                } else {
+                    _file.release( curs.getCurrent(), true );
+                }
+
+                return retval;
+            } else {
+                // no luck, go to next page
+                _file.release( curs.getCurrent(), false );
+            }
+
+        }
+        return null;
+    }
+
+    /**
+     *  Puts the indicated rowid on the free list
+     */
+    void put(Location rowid, int size)
+  throws IOException {
+
+  FreePhysicalRowId free = null;
+  PageCursor curs = new PageCursor(_pageman, Magic.FREEPHYSIDS_PAGE);
+  long freePage = 0;
+  while (curs.next() != 0) {
+      freePage = curs.getCurrent();
+      BlockIo curBlock = _file.get(freePage);
+      FreePhysicalRowIdPage fp = FreePhysicalRowIdPage
+    .getFreePhysicalRowIdPageView(curBlock);
+      int slot = fp.getFirstFree();
+      if (slot != -1) {
+    free = fp.alloc(slot);
+    break;
+      }
+
+      _file.release(curBlock);
+  }
+  if (free == null) {
+      // No more space on the free list, add a page.
+      freePage = _pageman.allocate(Magic.FREEPHYSIDS_PAGE);
+      BlockIo curBlock = _file.get(freePage);
+      FreePhysicalRowIdPage fp =
+    FreePhysicalRowIdPage.getFreePhysicalRowIdPageView(curBlock);
+      free = fp.alloc(0);
+  }
+
+  free.setBlock(rowid.getBlock());
+  free.setOffset(rowid.getOffset());
+  free.setSize(size);
+  _file.release(freePage, true);
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/Location.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/Location.java
new file mode 100644
index 0000000000..14a690ce6f
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/Location.java
@@ -0,0 +1,139 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: Location.java,v 1.2 2003/11/01 14:17:21 dranatunga Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ * This class represents a location within a file. Both physical and
+ * logical rowids are based on locations internally - this version is
+ * used when there is no file block to back the location's data.
+ */
+final class Location {
+    private long block;
+    private short offset;
+
+    /**
+     * Creates a location from a (block, offset) tuple.
+     */
+    Location(long block, short offset) {
+        this.block = block;
+        this.offset = offset;
+    }
+
+    /**
+     * Creates a location from a combined block/offset long, as
+     * used in the external representation of logical rowids.
+     * 
+     * @see #toLong()
+     */
+    Location(long blockOffset) {
+        this.offset = (short) (blockOffset & 0xffff);
+        this.block = blockOffset >> 16;
+    }
+
+    /**
+     * Creates a location based on the data of the physical rowid.
+     */
+    Location(PhysicalRowId src) {
+        block = src.getBlock();
+        offset = src.getOffset();
+    }
+
+    /**
+     * Returns the file block of the location
+     */
+    long getBlock() {
+        return block;
+    }
+
+    /**
+     * Returns the offset within the block of the location
+     */
+    short getOffset() {
+        return offset;
+    }
+
+    /**
+     * Returns the external representation of a location when used
+     * as a logical rowid, which combines the block and the offset
+     * in a single long.
+     */
+    long toLong() {
+        return (block << 16) + (long) offset;
+    }
+
+    // overrides of java.lang.Object
+
+    public boolean equals(Object o) {
+        if (o == null || !(o instanceof Location))
+            return false;
+        Location ol = (Location) o;
+        return ol.block == block && ol.offset == offset;
+    }
+
+    public String toString() {
+        return "PL(" + block + ":" + offset + ")";
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/LogicalRowIdManager.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/LogicalRowIdManager.java
new file mode 100644
index 0000000000..b2520d365c
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/LogicalRowIdManager.java
@@ -0,0 +1,163 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: LogicalRowIdManager.java,v 1.3 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This class manages the linked lists of logical rowid pages.
+ */
+final class LogicalRowIdManager {
+    // our record file and associated page manager
+    private RecordFile file;
+    private PageManager pageman;
+    private FreeLogicalRowIdPageManager freeman;
+
+    /**
+     *  Creates a log rowid manager using the indicated record file and
+     *  page manager
+     */
+    LogicalRowIdManager(RecordFile file, PageManager pageman)
+  throws IOException {
+  this.file = file;
+  this.pageman = pageman;
+  this.freeman = new FreeLogicalRowIdPageManager(file, pageman);
+
+    }
+
+    /**
+     *  Creates a new logical rowid pointing to the indicated physical
+     *  id
+     */
+    Location insert(Location loc)
+    throws IOException {
+  // check whether there's a free rowid to reuse
+  Location retval = freeman.get();
+  if (retval == null) {
+      // no. This means that we bootstrap things by allocating
+      // a new translation page and freeing all the rowids on it.
+      long firstPage = pageman.allocate(Magic.TRANSLATION_PAGE);
+      short curOffset = TranslationPage.O_TRANS;
+      for (int i = 0; i < TranslationPage.ELEMS_PER_PAGE; i++) {
+    freeman.put(new Location(firstPage, curOffset));
+    curOffset += PhysicalRowId.SIZE;
+      }
+      retval = freeman.get();
+      if (retval == null) {
+    throw new Error("couldn't obtain free translation");
+      }
+  }
+  // write the translation.
+  update(retval, loc);
+  return retval;
+    }
+
+    /**
+     *  Releases the indicated logical rowid.
+     */
+    void delete(Location rowid)
+  throws IOException {
+
+  freeman.put(rowid);
+    }
+
+    /**
+     *  Updates the mapping
+     *
+     *  @param rowid The logical rowid
+     *  @param loc The physical rowid
+     */
+    void update(Location rowid, Location loc)
+    throws IOException {
+
+        TranslationPage xlatPage = TranslationPage.getTranslationPageView(
+                                       file.get(rowid.getBlock()));
+        PhysicalRowId physid = xlatPage.get(rowid.getOffset());
+        physid.setBlock(loc.getBlock());
+        physid.setOffset(loc.getOffset());
+        file.release(rowid.getBlock(), true);
+    }
+
+    /**
+     *  Returns a mapping
+     *
+     *  @param rowid The logical rowid
+     *  @return The physical rowid
+     */
+    Location fetch(Location rowid)
+    throws IOException {
+
+        TranslationPage xlatPage = TranslationPage.getTranslationPageView(
+                                       file.get(rowid.getBlock()));
+        try {
+            Location retval = new Location(xlatPage.get(rowid.getOffset()));
+            return retval;
+        } finally {
+            file.release(rowid.getBlock(), false);
+        }
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/Magic.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/Magic.java
new file mode 100644
index 0000000000..759753610d
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/Magic.java
@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: Magic.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  This interface contains magic cookies.
+ */
+public interface Magic {
+    /** Magic cookie at start of file */
+    public short FILE_HEADER = 0x1350;
+
+    /** Magic for blocks. They're offset by the block type magic codes. */
+    public short BLOCK = 0x1351;
+
+    /** Magics for blocks in certain lists. Offset by baseBlockMagic */
+    short FREE_PAGE = 0;
+    short USED_PAGE = 1;
+    short TRANSLATION_PAGE = 2;
+    short FREELOGIDS_PAGE = 3;
+    short FREEPHYSIDS_PAGE = 4;
+
+    /** Number of lists in a file */
+    public short NLISTS = 5;
+
+    /**
+     *  Maximum number of blocks in a file, leaving room for a 16 bit
+     *  offset encoded within a long.
+     */
+    long MAX_BLOCKS = 0x7FFFFFFFFFFFL;
+
+    /** Magic for transaction file */
+    short LOGFILE_HEADER = 0x1360;
+
+    /** Size of an externalized byte */
+    public short SZ_BYTE = 1;
+    /** Size of an externalized short */
+    public short SZ_SHORT = 2;
+    /** Size of an externalized int */
+    public short SZ_INT = 4;
+    /** Size of an externalized long */
+    public short SZ_LONG = 8;
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PageCursor.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PageCursor.java
new file mode 100644
index 0000000000..ca37eba591
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PageCursor.java
@@ -0,0 +1,121 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: PageCursor.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This class provides a cursor that can follow lists of pages
+ *  bi-directionally.
+ */
+final class PageCursor {
+    PageManager pageman;
+    long current;
+    short type;
+    
+    /**
+     *  Constructs a page cursor that starts at the indicated block.
+     */
+    PageCursor(PageManager pageman, long current) {
+        this.pageman = pageman;
+        this.current = current;
+    }
+    
+    /**
+     *  Constructs a page cursor that starts at the first block
+     *  of the indicated list.
+     */
+    PageCursor(PageManager pageman, short type) throws IOException {
+        this.pageman = pageman;
+        this.type = type;
+    }
+    
+    /**
+     *  Returns the current value of the cursor.
+     */
+    long getCurrent() throws IOException {
+        return current;
+    }
+    
+    /**
+     *  Returns the next value of the cursor
+     */
+    long next() throws IOException {
+        if (current == 0)
+            current = pageman.getFirst(type);
+        else
+            current = pageman.getNext(current);
+        return current;
+    } 
+    
+    /**
+     *  Returns the previous value of the cursor
+     */
+    long prev() throws IOException {
+        current = pageman.getPrev(current);
+        return current;
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PageHeader.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PageHeader.java
new file mode 100644
index 0000000000..8c07709847
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PageHeader.java
@@ -0,0 +1,174 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: PageHeader.java,v 1.2 2003/09/21 15:47:01 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  This class represents a page header. It is the common superclass for
+ *  all different page views.
+ */
+public class PageHeader implements BlockView {
+    // offsets
+    private static final short O_MAGIC = 0; // short magic
+    private static final short O_NEXT = Magic.SZ_SHORT;  // long next
+    private static final short O_PREV = O_NEXT + Magic.SZ_LONG; // long prev
+    protected static final short SIZE = O_PREV + Magic.SZ_LONG;
+
+    // my block
+    protected BlockIo block;
+
+    /**
+     *  Constructs a PageHeader object from a block
+     *
+     *  @param block The block that contains the file header
+     *  @throws IOException if the block is too short to keep the file
+     *          header.
+     */
+    protected PageHeader(BlockIo block) {
+        initialize(block);
+        if (!magicOk())
+            throw new Error("CRITICAL: page header magic for block "
+                            + block.getBlockId() + " not OK "
+                            + getMagic());
+    }
+    
+    /**
+     *  Constructs a new PageHeader of the indicated type. Used for newly
+     *  created pages.
+     */
+    PageHeader(BlockIo block, short type) {
+        initialize(block);
+        setType(type);
+    }
+    
+    /**
+     *  Factory method to create or return a page header for the
+     *  indicated block.
+     */
+    static PageHeader getView(BlockIo block) {
+        BlockView view = block.getView();
+        if (view != null && view instanceof PageHeader)
+            return (PageHeader) view;
+        else
+            return new PageHeader(block);
+    }
+    
+    private void initialize(BlockIo block) {
+        this.block = block;
+        block.setView(this);
+    }
+    
+    /**
+     *  Returns true if the magic corresponds with the fileHeader magic.
+     */
+    private boolean magicOk() {
+        int magic = getMagic();
+        return magic >= Magic.BLOCK
+            && magic <= (Magic.BLOCK + Magic.FREEPHYSIDS_PAGE);
+    }
+    
+    /**
+     *  For paranoia mode
+     */
+    protected void paranoiaMagicOk() {
+        if (!magicOk())
+            throw new Error("CRITICAL: page header magic not OK "
+                            + getMagic());
+    }
+    
+    /** Returns the magic code */
+    short getMagic() {
+        return block.readShort(O_MAGIC);
+    }
+
+    /** Returns the next block. */
+    long getNext() {
+        paranoiaMagicOk();
+        return block.readLong(O_NEXT);
+    }
+    
+    /** Sets the next block. */
+    void setNext(long next) {
+        paranoiaMagicOk();
+        block.writeLong(O_NEXT, next);
+    }
+    
+    /** Returns the previous block. */
+    long getPrev() {
+        paranoiaMagicOk();
+        return block.readLong(O_PREV);
+    }
+    
+    /** Sets the previous block. */
+    void setPrev(long prev) {
+        paranoiaMagicOk();
+        block.writeLong(O_PREV, prev);
+    }
+    
+    /** Sets the type of the page header */
+    void setType(short type) {
+        block.writeShort(O_MAGIC, (short) (Magic.BLOCK + type));
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PageManager.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PageManager.java
new file mode 100644
index 0000000000..676ce70c93
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PageManager.java
@@ -0,0 +1,290 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: PageManager.java,v 1.3 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.*;
+
+/**
+ *  This class manages the linked lists of pages that make up a file.
+ */
+final class PageManager {
+    // our record file
+    private RecordFile file;
+    // header data
+    private FileHeader header;
+    private BlockIo headerBuf;
+    
+    /**
+     *  Creates a new page manager using the indicated record file.
+     */
+    PageManager(RecordFile file) throws IOException {
+        this.file = file;
+        
+        // check the file header. If the magic is 0, we assume a new
+        // file. Note that we hold on to the file header node.
+        headerBuf = file.get(0);
+        if (headerBuf.readShort(0) == 0)
+            header = new FileHeader(headerBuf, true);
+        else
+            header = new FileHeader(headerBuf, false);
+    }
+    
+    /**
+     *  Allocates a page of the indicated type. Returns recid of the
+     *  page.
+     */
+    long allocate(short type) throws IOException {
+        
+        if (type == Magic.FREE_PAGE)
+            throw new Error("allocate of free page?");
+        
+        // do we have something on the free list?
+        long retval = header.getFirstOf(Magic.FREE_PAGE);
+        boolean isNew = false;
+        if (retval != 0) {
+            // yes. Point to it and make the next of that page the
+            // new first free page.
+            header.setFirstOf(Magic.FREE_PAGE, getNext(retval));
+        }
+        else {
+            // nope. make a new record
+            retval = header.getLastOf(Magic.FREE_PAGE);
+            if (retval == 0)
+                // very new file - allocate record #1
+                retval = 1;
+            header.setLastOf(Magic.FREE_PAGE, retval + 1);
+            isNew = true;
+        }
+        
+        // Cool. We have a record, add it to the correct list
+        BlockIo buf = file.get(retval);
+        PageHeader pageHdr = isNew ? new PageHeader(buf, type) 
+            : PageHeader.getView(buf);
+        long oldLast = header.getLastOf(type);
+        
+        // Clean data.
+        System.arraycopy(RecordFile.cleanData, 0, 
+                         buf.getData(), 0, 
+                         RecordFile.BLOCK_SIZE);
+        pageHdr.setType(type);
+        pageHdr.setPrev(oldLast);
+        pageHdr.setNext(0);
+        
+        
+        if (oldLast == 0)
+            // This was the first one of this type
+            header.setFirstOf(type, retval);
+        header.setLastOf(type, retval);
+        file.release(retval, true);
+        
+        // If there's a previous, fix up its pointer
+        if (oldLast != 0) {
+            buf = file.get(oldLast);
+            pageHdr = PageHeader.getView(buf);
+            pageHdr.setNext(retval);
+            file.release(oldLast, true);
+        }
+        
+        // remove the view, we have modified the type.
+        buf.setView(null);
+        
+        return retval;
+    }
+    
+    /**
+     *  Frees a page of the indicated type.
+     */
+    void free(short type, long recid) throws IOException {
+        if (type == Magic.FREE_PAGE)
+            throw new Error("free free page?");
+        if (recid == 0)
+            throw new Error("free header page?");
+        
+        // get the page and read next and previous pointers
+        BlockIo buf = file.get(recid);
+        PageHeader pageHdr = PageHeader.getView(buf);
+        long prev = pageHdr.getPrev();
+        long next = pageHdr.getNext();
+        
+        // put the page at the front of the free list.
+        pageHdr.setType(Magic.FREE_PAGE);
+        pageHdr.setNext(header.getFirstOf(Magic.FREE_PAGE));
+        pageHdr.setPrev(0);
+        
+        header.setFirstOf(Magic.FREE_PAGE, recid);
+        file.release(recid, true);
+        
+        // remove the page from its old list
+        if (prev != 0) {
+            buf = file.get(prev);
+            pageHdr = PageHeader.getView(buf);
+            pageHdr.setNext(next);
+            file.release(prev, true);
+        }
+        else {
+            header.setFirstOf(type, next);
+        }
+        if (next != 0) {
+            buf = file.get(next);
+            pageHdr = PageHeader.getView(buf);
+            pageHdr.setPrev(prev);
+            file.release(next, true);
+        }
+        else {
+            header.setLastOf(type, prev);
+        }
+        
+    }
+    
+    
+    /**
+     *  Returns the page following the indicated block
+     */
+    long getNext(long block) throws IOException {
+        try {
+            return PageHeader.getView(file.get(block)).getNext();
+        } finally {
+            file.release(block, false);
+        }
+    }
+    
+    /**
+     *  Returns the page before the indicated block
+     */
+    long getPrev(long block) throws IOException {
+        try {
+            return PageHeader.getView(file.get(block)).getPrev();
+        } finally {
+            file.release(block, false);
+        }
+    }
+    
+    /**
+     *  Returns the first page on the indicated list.
+     */
+    long getFirst(short type) throws IOException {
+        return header.getFirstOf(type);
+    }
+
+    /**
+     *  Returns the last page on the indicated list.
+     */
+    long getLast(short type) throws IOException {
+        return header.getLastOf(type);
+    }
+    
+    
+    /**
+     *  Commit all pending (in-memory) data by flushing the page manager.
+     *  This forces a flush of all outstanding blocks (this it's an implicit
+     *  {@link RecordFile#commit} as well).
+     */
+    void commit() throws IOException {
+        // write the header out
+        file.release(headerBuf);
+        file.commit();
+
+        // and obtain it again
+        headerBuf = file.get(0);
+        header = new FileHeader(headerBuf, false);
+    }
+
+    /**
+     *  Flushes the page manager. This forces a flush of all outstanding
+     *  blocks (this it's an implicit {@link RecordFile#commit} as well).
+     */
+    void rollback() throws IOException {
+        // release header
+        file.discard(headerBuf);
+        file.rollback();
+        // and obtain it again
+        headerBuf = file.get(0);
+        if (headerBuf.readShort(0) == 0)
+            header = new FileHeader(headerBuf, true);
+        else
+            header = new FileHeader(headerBuf, false);
+    }
+    
+    /**
+     *  Closes the page manager. This flushes the page manager and releases
+     *  the lock on the header.
+     */
+    void close() throws IOException {   
+        file.release(headerBuf);
+        file.commit();
+        headerBuf = null;
+        header = null;
+        file = null;
+    }
+    
+    /**
+     *  Returns the file header.
+     */
+    FileHeader getFileHeader() {
+        return header;
+    }
+    
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PhysicalRowId.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PhysicalRowId.java
new file mode 100644
index 0000000000..6cdd1e0da8
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PhysicalRowId.java
@@ -0,0 +1,113 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: PhysicalRowId.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  A physical rowid is nothing else than a pointer to a physical location
+ *  in a file - a (block, offset) tuple.
+ *  <P>
+ *  <B>Note</B>: The fact that the offset is modelled as a short limits 
+ *  the block size to 32k.
+ */
+class PhysicalRowId {
+    // offsets
+    private static final short O_BLOCK = 0; // long block
+    private static final short O_OFFSET = Magic.SZ_LONG; // short offset
+    static final int SIZE = O_OFFSET + Magic.SZ_SHORT;
+    
+    // my block and the position within the block
+    BlockIo block;
+    short pos;
+
+    /**
+     *  Constructs a physical rowid from the indicated data starting at
+     *  the indicated position.
+     */
+    PhysicalRowId(BlockIo block, short pos) {
+        this.block = block;
+        this.pos = pos;
+    }
+    
+    /** Returns the block number */
+    long getBlock() {
+        return block.readLong(pos + O_BLOCK);
+    }
+    
+    /** Sets the block number */
+    void setBlock(long value) {
+        block.writeLong(pos + O_BLOCK, value);
+    }
+    
+    /** Returns the offset */
+    short getOffset() {
+        return block.readShort(pos + O_OFFSET);
+    }
+    
+    /** Sets the offset */
+    void setOffset(short value) {
+        block.writeShort(pos + O_OFFSET, value);
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PhysicalRowIdManager.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PhysicalRowIdManager.java
new file mode 100644
index 0000000000..6aa9ba85f8
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/PhysicalRowIdManager.java
@@ -0,0 +1,356 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: PhysicalRowIdManager.java,v 1.3 2003/03/21 03:00:09 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This class manages physical row ids, and their data.
+ */
+final class PhysicalRowIdManager
+{
+
+    // The file we're talking to and the associated page manager.
+    private RecordFile file;
+    private PageManager pageman;
+    private FreePhysicalRowIdPageManager freeman;
+
+    /**
+     *  Creates a new rowid manager using the indicated record file.
+     *  and page manager.
+     */
+    PhysicalRowIdManager( RecordFile file, PageManager pageManager )
+        throws IOException
+    {
+        this.file = file;
+        this.pageman = pageManager;
+        this.freeman = new FreePhysicalRowIdPageManager(file, pageman);
+    }
+
+    /**
+     *  Inserts a new record. Returns the new physical rowid.
+     */
+    Location insert( byte[] data, int start, int length )
+        throws IOException
+    {
+        Location retval = alloc( length );
+        write( retval, data, start, length );
+        return retval;
+    }
+
+    /**
+     *  Updates an existing record. Returns the possibly changed
+     *  physical rowid.
+     */
+    Location update( Location rowid, byte[] data, int start, int length )
+        throws IOException
+    {
+        // fetch the record header
+        BlockIo block = file.get( rowid.getBlock() );
+        RecordHeader head = new RecordHeader( block, rowid.getOffset() );
+        if ( length > head.getAvailableSize() ) {
+            // not enough space - we need to copy to a new rowid.
+            file.release( block );
+            free( rowid );
+            rowid = alloc( length );
+        } else {
+            file.release( block );
+        }
+
+        // 'nuff space, write it in and return the rowid.
+        write( rowid, data, start, length );
+        return rowid;
+    }
+
+    /**
+     *  Deletes a record.
+     */
+    void delete( Location rowid )
+        throws IOException
+    {
+        free( rowid );
+    }
+
+    /**
+     *  Retrieves a record.
+     */
+    byte[] fetch( Location rowid )
+        throws IOException 
+    {
+        // fetch the record header
+        PageCursor curs = new PageCursor( pageman, rowid.getBlock() );
+        BlockIo block = file.get( curs.getCurrent() );
+        RecordHeader head = new RecordHeader( block, rowid.getOffset() );
+
+        // allocate a return buffer
+        byte[] retval = new byte[ head.getCurrentSize() ];
+        if ( retval.length == 0 ) {
+            file.release( curs.getCurrent(), false );
+            return retval;
+        }
+
+        // copy bytes in
+        int offsetInBuffer = 0;
+        int leftToRead = retval.length;
+        short dataOffset = (short) (rowid.getOffset() + RecordHeader.SIZE);
+        while ( leftToRead > 0 ) {
+            // copy current page's data to return buffer
+            int toCopy = RecordFile.BLOCK_SIZE - dataOffset;
+            if ( leftToRead < toCopy ) {
+                toCopy = leftToRead;
+            }
+            System.arraycopy( block.getData(), dataOffset,
+                              retval, offsetInBuffer,
+                              toCopy );
+
+            // Go to the next block
+            leftToRead -= toCopy;
+            offsetInBuffer += toCopy;
+
+            file.release( block );
+
+            if ( leftToRead > 0 ) {
+                block = file.get( curs.next() );
+                dataOffset = DataPage.O_DATA;
+            }
+
+        }
+
+        return retval;
+    }
+
+    /**
+     *  Allocate a new rowid with the indicated size.
+     */
+    private Location alloc( int size )
+        throws IOException
+    {
+        Location retval = freeman.get( size );
+        if ( retval == null ) {
+            retval = allocNew( size, pageman.getLast( Magic.USED_PAGE ) );
+        }
+        return retval;
+    }
+
+    /**
+     *  Allocates a new rowid. The second parameter is there to
+     *  allow for a recursive call - it indicates where the search
+     *  should start.
+     */
+    private Location allocNew( int size, long start )
+        throws IOException
+    {
+        BlockIo curBlock;
+        DataPage curPage;
+        if ( start == 0 ) {
+            // we need to create a new page.
+            start = pageman.allocate( Magic.USED_PAGE );
+            curBlock = file.get( start );
+            curPage = DataPage.getDataPageView( curBlock );
+            curPage.setFirst( DataPage.O_DATA );
+            RecordHeader hdr = new RecordHeader( curBlock, DataPage.O_DATA );
+            hdr.setAvailableSize( 0 );
+            hdr.setCurrentSize( 0 );
+        } else {
+            curBlock = file.get( start );
+            curPage = DataPage.getDataPageView( curBlock );
+        }
+
+        // follow the rowids on this page to get to the last one. We don't
+        // fall off, because this is the last page, remember?
+        short pos = curPage.getFirst();
+        if ( pos == 0 ) {
+            // page is exactly filled by the last block of a record
+            file.release( curBlock );
+            return allocNew( size, 0 );
+        }
+
+        RecordHeader hdr = new RecordHeader( curBlock, pos );
+        while ( hdr.getAvailableSize() != 0 && pos < RecordFile.BLOCK_SIZE ) {
+            pos += hdr.getAvailableSize() + RecordHeader.SIZE;
+            if ( pos == RecordFile.BLOCK_SIZE ) {
+                // Again, a filled page.
+                file.release( curBlock );
+                return allocNew( size, 0 );
+            }
+
+            hdr = new RecordHeader( curBlock, pos );
+        }
+
+        if ( pos == RecordHeader.SIZE ) {
+            // the last record exactly filled the page. Restart forcing
+            // a new page.
+            file.release( curBlock );
+        }
+
+        // we have the position, now tack on extra pages until we've got
+        // enough space.
+        Location retval = new Location( start, pos );
+        int freeHere = RecordFile.BLOCK_SIZE - pos - RecordHeader.SIZE;
+        if ( freeHere < size ) {
+            // check whether the last page would have only a small bit left.
+            // if yes, increase the allocation. A small bit is a record
+            // header plus 16 bytes.
+            int lastSize = (size - freeHere) % DataPage.DATA_PER_PAGE;
+            if (( DataPage.DATA_PER_PAGE - lastSize ) < (RecordHeader.SIZE + 16) ) {
+                size += (DataPage.DATA_PER_PAGE - lastSize);
+            }
+
+            // write out the header now so we don't have to come back.
+            hdr.setAvailableSize( size );
+            file.release( start, true );
+
+            int neededLeft = size - freeHere;
+            // Refactor these two blocks!
+            while ( neededLeft >= DataPage.DATA_PER_PAGE ) {
+                start = pageman.allocate( Magic.USED_PAGE );
+                curBlock = file.get( start );
+                curPage = DataPage.getDataPageView( curBlock );
+                curPage.setFirst( (short) 0 ); // no rowids, just data
+                file.release( start, true );
+                neededLeft -= DataPage.DATA_PER_PAGE;
+            }
+            if ( neededLeft > 0 ) {
+                // done with whole chunks, allocate last fragment.
+                start = pageman.allocate( Magic.USED_PAGE );
+                curBlock = file.get( start );
+                curPage = DataPage.getDataPageView( curBlock );
+                curPage.setFirst( (short) (DataPage.O_DATA + neededLeft) );
+                file.release( start, true );
+            }
+        } else {
+            // just update the current page. If there's less than 16 bytes
+            // left, we increase the allocation (16 bytes is an arbitrary
+            // number).
+            if ( freeHere - size <= (16 + RecordHeader.SIZE) ) {
+                size = freeHere;
+            }
+            hdr.setAvailableSize( size );
+            file.release( start, true );
+        }
+        return retval;
+
+    }
+
+
+    private void free( Location id )
+        throws IOException
+    {
+        // get the rowid, and write a zero current size into it.
+        BlockIo curBlock = file.get( id.getBlock() );
+        DataPage curPage = DataPage.getDataPageView( curBlock );
+        RecordHeader hdr = new RecordHeader( curBlock, id.getOffset() );
+        hdr.setCurrentSize( 0 );
+        file.release( id.getBlock(), true );
+
+        // write the rowid to the free list
+        freeman.put( id, hdr.getAvailableSize() );
+    }
+
+    /**
+     *  Writes out data to a rowid. Assumes that any resizing has been
+     *  done.
+     */
+    private void write(Location rowid, byte[] data, int start, int length )
+        throws IOException
+    {
+        PageCursor curs = new PageCursor( pageman, rowid.getBlock() );
+        BlockIo block = file.get( curs.getCurrent() );
+        RecordHeader hdr = new RecordHeader( block, rowid.getOffset() );
+        hdr.setCurrentSize( length );
+        if ( length == 0 ) {
+            file.release( curs.getCurrent(), true );
+            return;
+        }
+
+        // copy bytes in
+        int offsetInBuffer = start;
+        int leftToWrite = length;
+        short dataOffset = (short) (rowid.getOffset() + RecordHeader.SIZE);
+        while ( leftToWrite > 0 ) {
+            // copy current page's data to return buffer
+            int toCopy = RecordFile.BLOCK_SIZE - dataOffset;
+
+            if ( leftToWrite < toCopy ) {
+                toCopy = leftToWrite;
+            }
+            System.arraycopy( data, offsetInBuffer, block.getData(), 
+                              dataOffset, toCopy );
+
+            // Go to the next block
+            leftToWrite -= toCopy;
+            offsetInBuffer += toCopy;
+
+            file.release( curs.getCurrent(), true );
+
+            if ( leftToWrite > 0 ) {
+                block = file.get( curs.next() );
+                dataOffset = DataPage.O_DATA;
+            }
+        }
+    }
+}
+
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/Provider.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/Provider.java
new file mode 100644
index 0000000000..7ae01f10a9
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/Provider.java
@@ -0,0 +1,134 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Copyright 2000-2001 (C) Alex Boisvert. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: Provider.java,v 1.3 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.IOException;
+import java.util.Properties;
+
+import org.apache.hadoop.hive.ql.util.jdbm.RecordManager;
+import org.apache.hadoop.hive.ql.util.jdbm.RecordManagerOptions;
+import org.apache.hadoop.hive.ql.util.jdbm.RecordManagerProvider;
+
+import org.apache.hadoop.hive.ql.util.jdbm.helper.MRU;
+
+/**
+ * Provider of the default RecordManager implementation.
+ *
+ * @author <a href="mailto:boisvert@intalio.com">Alex Boisvert</a>
+ * @version $Id: Provider.java,v 1.3 2005/06/25 23:12:32 doomdark Exp $
+ */
+public final class Provider
+    implements RecordManagerProvider
+{
+
+    /**
+     * Create a default implementation record manager.
+     *
+     * @param name Name of the record file.
+     * @param options Record manager options.
+     * @throws IOException if an I/O related exception occurs while creating
+     *                    or opening the record manager.
+     * @throws UnsupportedOperationException if some options are not supported by the
+     *                                      implementation.
+     * @throws IllegalArgumentException if some options are invalid.
+     */
+    public RecordManager createRecordManager( String name,
+                                              Properties options )
+        throws IOException
+    {
+        RecordManager  recman;
+        String         value;
+        int            cacheSize;
+
+        recman = new BaseRecordManager( name );
+
+        value = options.getProperty( RecordManagerOptions.DISABLE_TRANSACTIONS, "false" );
+        if ( value.equalsIgnoreCase( "TRUE" ) ) {
+            ( (BaseRecordManager) recman ).disableTransactions();
+        }
+
+        value = options.getProperty( RecordManagerOptions.CACHE_SIZE, "1000" );
+        cacheSize = Integer.parseInt( value );
+
+        value = options.getProperty( RecordManagerOptions.CACHE_TYPE,
+                                     RecordManagerOptions.NORMAL_CACHE );
+        if ( value.equalsIgnoreCase( RecordManagerOptions.NORMAL_CACHE ) ) {
+            MRU cache = new MRU( cacheSize );
+            recman = new CacheRecordManager( recman, cache );
+        } else if ( value.equalsIgnoreCase( RecordManagerOptions.SOFT_REF_CACHE ) ) {
+            throw new IllegalArgumentException( "Soft reference cache not implemented" );
+        } else if ( value.equalsIgnoreCase( RecordManagerOptions.WEAK_REF_CACHE ) ) {
+            throw new IllegalArgumentException( "Weak reference cache not implemented" );
+        } else {
+            throw new IllegalArgumentException( "Invalid cache type: " + value );
+        }
+
+        return recman;
+    }
+
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/RecordCache.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/RecordCache.java
new file mode 100644
index 0000000000..73b8c9b7b0
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/RecordCache.java
@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: RecordCache.java,v 1.2 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This interface is used for synchronization.
+ *  <p>
+ *  RecordManager ensures that the cache has the up-to-date information
+ *  by way of an invalidation protocol.
+ */
+public interface RecordCache {
+
+    /**
+     * Notification to flush content related to a given record.
+     */
+    public void flush(long recid) throws IOException;
+
+    /**
+     * Notification to flush data all of records.
+     */
+    public void flushAll() throws IOException;
+
+    /**
+     * Notification to invalidate content related to given record.
+     */
+    public void invalidate(long recid) throws IOException;
+
+    /**
+     * Notification to invalidate content of all records.
+     */
+    public void invalidateAll() throws IOException;
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/RecordFile.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/RecordFile.java
new file mode 100644
index 0000000000..f5822b6edb
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/RecordFile.java
@@ -0,0 +1,430 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: RecordFile.java,v 1.6 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.*;
+import java.util.*;
+
+/**
+ *  This class represents a random access file as a set of fixed size
+ *  records. Each record has a physical record number, and records are
+ *  cached in order to improve access.
+ *<p>
+ *  The set of dirty records on the in-use list constitutes a transaction.
+ *  Later on, we will send these records to some recovery thingy.
+ */
+public final class RecordFile {
+    final TransactionManager txnMgr;
+
+    // Todo: reorganize in hashes and fifos as necessary.
+    // free -> inUse -> dirty -> inTxn -> free
+    // free is a cache, thus a FIFO. The rest are hashes.
+    private final LinkedList free = new LinkedList();
+    private final HashMap inUse = new HashMap();
+    private final HashMap dirty = new HashMap();
+    private final HashMap inTxn = new HashMap();
+
+    // transactions disabled?
+    private boolean transactionsDisabled = false;
+
+    /** The length of a single block. */
+    public final static int BLOCK_SIZE = 8192;//4096;
+
+    /** The extension of a record file */
+    final static String extension = ".db";
+
+    /** A block of clean data to wipe clean pages. */
+    final static byte[] cleanData = new byte[BLOCK_SIZE];
+
+    private RandomAccessFile file;
+    private final String fileName;
+
+    /**
+     *  Creates a new object on the indicated filename. The file is
+     *  opened in read/write mode.
+     *
+     *  @param fileName the name of the file to open or create, without
+     *         an extension.
+     *  @throws IOException whenever the creation of the underlying
+     *          RandomAccessFile throws it.
+     */
+    RecordFile(String fileName) throws IOException {
+        this.fileName = fileName;
+        file = new RandomAccessFile(fileName + extension, "rw");
+        txnMgr = new TransactionManager(this);
+    }
+
+    /**
+     *  Returns the file name.
+     */
+    String getFileName() {
+        return fileName;
+    }
+
+    /**
+     *  Disables transactions: doesn't sync and doesn't use the
+     *  transaction manager.
+     */
+    void disableTransactions() {
+        transactionsDisabled = true;
+    }
+
+    /**
+     *  Gets a block from the file. The returned byte array is
+     *  the in-memory copy of the record, and thus can be written
+     *  (and subsequently released with a dirty flag in order to
+     *  write the block back).
+     *
+     *  @param blockid The record number to retrieve.
+     */
+     BlockIo get(long blockid) throws IOException {
+         Long key = new Long(blockid);
+
+         // try in transaction list, dirty list, free list
+         BlockIo node = (BlockIo) inTxn.get(key);
+         if (node != null) {
+             inTxn.remove(key);
+             inUse.put(key, node);
+             return node;
+         }
+         node = (BlockIo) dirty.get(key);
+         if (node != null) {
+             dirty.remove(key);
+             inUse.put(key, node);
+             return node;
+         }
+         for (Iterator i = free.iterator(); i.hasNext(); ) {
+             BlockIo cur = (BlockIo) i.next();
+             if (cur.getBlockId() == blockid) {
+                 node = cur;
+                 i.remove();
+                 inUse.put(key, node);
+                 return node;
+             }
+         }
+
+         // sanity check: can't be on in use list
+         if (inUse.get(key) != null) {
+             throw new Error("double get for block " + blockid);
+         }
+
+         // get a new node and read it from the file
+         node = getNewNode(blockid);
+         long offset = blockid * BLOCK_SIZE;
+         if (file.length() > 0 && offset <= file.length()) {
+             read(file, offset, node.getData(), BLOCK_SIZE);
+         } else {
+             System.arraycopy(cleanData, 0, node.getData(), 0, BLOCK_SIZE);
+         }
+         inUse.put(key, node);
+         node.setClean();
+         return node;
+     }
+
+
+    /**
+     *  Releases a block.
+     *
+     *  @param blockid The record number to release.
+     *  @param isDirty If true, the block was modified since the get().
+     */
+    void release(long blockid, boolean isDirty)
+    throws IOException {
+        BlockIo node = (BlockIo) inUse.get(new Long(blockid));
+        if (node == null)
+            throw new IOException("bad blockid " + blockid + " on release");
+        if (!node.isDirty() && isDirty)
+            node.setDirty();
+        release(node);
+    }
+
+    /**
+     *  Releases a block.
+     *
+     *  @param block The block to release.
+     */
+    void release(BlockIo block) {
+        Long key = new Long(block.getBlockId());
+        inUse.remove(key);
+        if (block.isDirty()) {
+            // System.out.println( "Dirty: " + key + block );
+            dirty.put(key, block);
+        } else {
+            if (!transactionsDisabled && block.isInTransaction()) {
+                inTxn.put(key, block);
+            } else {
+                free.add(block);
+            }
+        }
+    }
+
+    /**
+     *  Discards a block (will not write the block even if it's dirty)
+     *
+     *  @param block The block to discard.
+     */
+    void discard(BlockIo block) {
+        Long key = new Long(block.getBlockId());
+        inUse.remove(key);
+
+        // note: block not added to free list on purpose, because
+        //       it's considered invalid
+    }
+
+    /**
+     *  Commits the current transaction by flushing all dirty buffers
+     *  to disk.
+     */
+    void commit() throws IOException {
+        // debugging...
+        if (!inUse.isEmpty() && inUse.size() > 1) {
+            showList(inUse.values().iterator());
+            throw new Error("in use list not empty at commit time ("
+                            + inUse.size() + ")");
+        }
+
+        //  System.out.println("committing...");
+
+        if ( dirty.size() == 0 ) {
+            // if no dirty blocks, skip commit process
+            return;
+        }
+
+        if (!transactionsDisabled) {
+            txnMgr.start();
+        }
+
+        for (Iterator i = dirty.values().iterator(); i.hasNext(); ) {
+            BlockIo node = (BlockIo) i.next();
+            i.remove();
+            // System.out.println("node " + node + " map size now " + dirty.size());
+            if (transactionsDisabled) {
+                long offset = node.getBlockId() * BLOCK_SIZE;
+                file.seek(offset);
+                file.write(node.getData());
+                node.setClean();
+                free.add(node);
+            }
+            else {
+                txnMgr.add(node);
+                inTxn.put(new Long(node.getBlockId()), node);
+            }
+        }
+        if (!transactionsDisabled) {
+            txnMgr.commit();
+        }
+    }
+
+    /**
+     *  Rollback the current transaction by discarding all dirty buffers
+     */
+    void rollback() throws IOException {
+        // debugging...
+        if (!inUse.isEmpty()) {
+            showList(inUse.values().iterator());
+            throw new Error("in use list not empty at rollback time ("
+                            + inUse.size() + ")");
+        }
+        //  System.out.println("rollback...");
+        dirty.clear();
+
+        txnMgr.synchronizeLogFromDisk();
+
+        if (!inTxn.isEmpty()) {
+            showList(inTxn.values().iterator());
+            throw new Error("in txn list not empty at rollback time ("
+                            + inTxn.size() + ")");
+        };
+    }
+
+    /**
+     *  Commits and closes file.
+     */
+    void close() throws IOException {
+        if (!dirty.isEmpty()) {
+            commit();
+        }
+        txnMgr.shutdown();
+
+        if (!inTxn.isEmpty()) {
+            showList(inTxn.values().iterator());
+            throw new Error("In transaction not empty");
+        }
+
+        // these actually ain't that bad in a production release
+        if (!dirty.isEmpty()) {
+            System.out.println("ERROR: dirty blocks at close time");
+            showList(dirty.values().iterator());
+            throw new Error("Dirty blocks at close time");
+        }
+        if (!inUse.isEmpty()) {
+            System.out.println("ERROR: inUse blocks at close time");
+            showList(inUse.values().iterator());
+            throw new Error("inUse blocks at close time");
+        }
+
+        // debugging stuff to keep an eye on the free list
+        // System.out.println("Free list size:" + free.size());
+        file.close();
+        file = null;
+    }
+
+
+    /**
+     * Force closing the file and underlying transaction manager.
+     * Used for testing purposed only.
+     */
+    void forceClose() throws IOException {
+      txnMgr.forceClose();
+      file.close();
+    }
+
+    /**
+     *  Prints contents of a list
+     */
+    private void showList(Iterator i) {
+        int cnt = 0;
+        while (i.hasNext()) {
+            System.out.println("elem " + cnt + ": " + i.next());
+            cnt++;
+        }
+    }
+
+
+    /**
+     *  Returns a new node. The node is retrieved (and removed)
+     *  from the released list or created new.
+     */
+    private BlockIo getNewNode(long blockid)
+    throws IOException {
+
+        BlockIo retval = null;
+        if (!free.isEmpty()) {
+            retval = (BlockIo) free.removeFirst();
+        }
+        if (retval == null)
+            retval = new BlockIo(0, new byte[BLOCK_SIZE]);
+
+        retval.setBlockId(blockid);
+        retval.setView(null);
+        return retval;
+    }
+
+    /**
+     *  Synchs a node to disk. This is called by the transaction manager's
+     *  synchronization code.
+     */
+    void synch(BlockIo node) throws IOException {
+        byte[] data = node.getData();
+        if (data != null) {
+            long offset = node.getBlockId() * BLOCK_SIZE;
+            file.seek(offset);
+            file.write(data);
+        }
+    }
+
+    /**
+     *  Releases a node from the transaction list, if it was sitting
+     *  there.
+     *
+     *  @param recycle true if block data can be reused
+     */
+    void releaseFromTransaction(BlockIo node, boolean recycle)
+    throws IOException {
+        Long key = new Long(node.getBlockId());
+        if ((inTxn.remove(key) != null) && recycle) {
+            free.add(node);
+        }
+    }
+
+    /**
+     *  Synchronizes the file.
+     */
+    void sync() throws IOException {
+        file.getFD().sync();
+    }
+
+
+    /**
+     * Utility method: Read a block from a RandomAccessFile
+     */
+    private static void read(RandomAccessFile file, long offset,
+                             byte[] buffer, int nBytes) throws IOException {
+        file.seek(offset);
+        int remaining = nBytes;
+        int pos = 0;
+        while (remaining > 0) {
+            int read = file.read(buffer, pos, remaining);
+            if (read == -1) {
+                System.arraycopy(cleanData, 0, buffer, pos, remaining);
+                break;
+            }
+            remaining -= read;
+            pos += read;
+        }
+    }
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/RecordHeader.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/RecordHeader.java
new file mode 100644
index 0000000000..107a93ea55
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/RecordHeader.java
@@ -0,0 +1,125 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: RecordHeader.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  The data that comes at the start of a record of data. It stores 
+ *  both the current size and the avaliable size for the record - the latter
+ *  can be bigger than the former, which allows the record to grow without
+ *  needing to be moved and which allows the system to put small records
+ *  in larger free spots.
+ */
+class RecordHeader {
+    // offsets
+    private static final short O_CURRENTSIZE = 0; // int currentSize
+    private static final short O_AVAILABLESIZE = Magic.SZ_INT; // int availableSize
+    static final int SIZE = O_AVAILABLESIZE + Magic.SZ_INT;
+    
+    // my block and the position within the block
+    private BlockIo block;
+    private short pos;
+
+    /**
+     *  Constructs a record header from the indicated data starting at
+     *  the indicated position.
+     */
+    RecordHeader(BlockIo block, short pos) {
+        this.block = block;
+        this.pos = pos;
+        if (pos > (RecordFile.BLOCK_SIZE - SIZE))
+            throw new Error("Offset too large for record header (" 
+                            + block.getBlockId() + ":" 
+                            + pos + ")");
+    }
+
+    /** Returns the current size */
+    int getCurrentSize() {
+        return block.readInt(pos + O_CURRENTSIZE);
+    }
+    
+    /** Sets the current size */
+    void setCurrentSize(int value) {
+        block.writeInt(pos + O_CURRENTSIZE, value);
+    }
+    
+    /** Returns the available size */
+    int getAvailableSize() {
+        return block.readInt(pos + O_AVAILABLESIZE);
+    }
+    
+    /** Sets the available size */
+    void setAvailableSize(int value) {
+        block.writeInt(pos + O_AVAILABLESIZE, value);
+    }
+
+    // overrides java.lang.Object
+    public String toString() {
+        return "RH(" + block.getBlockId() + ":" + pos 
+            + ", avl=" + getAvailableSize()
+            + ", cur=" + getCurrentSize() 
+            + ")";
+    }
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/TransactionManager.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/TransactionManager.java
new file mode 100644
index 0000000000..e7e9a85b30
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/TransactionManager.java
@@ -0,0 +1,427 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: TransactionManager.java,v 1.7 2005/06/25 23:12:32 doomdark Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+import java.io.*;
+import java.util.*;
+
+/**
+ *  This class manages the transaction log that belongs to every
+ *  {@link RecordFile}. The transaction log is either clean, or
+ *  in progress. In the latter case, the transaction manager
+ *  takes care of a roll forward.
+ *<p>
+ *  Implementation note: this is a proof-of-concept implementation
+ *  which hasn't been optimized for speed. For instance, all sorts
+ *  of streams are created for every transaction.
+ */
+// TODO: Handle the case where we are recovering lg9 and lg0, were we
+// should start with lg9 instead of lg0!
+
+public final class TransactionManager {
+    private RecordFile owner;
+
+    // streams for transaction log.
+    private FileOutputStream fos;
+    private ObjectOutputStream oos;
+
+    /** 
+     * By default, we keep 10 transactions in the log file before
+     * synchronizing it with the main database file.
+     */
+    static final int DEFAULT_TXNS_IN_LOG = 10;
+
+    /** 
+     * Maximum number of transactions before the log file is
+     * synchronized with the main database file.
+     */
+    private int _maxTxns = DEFAULT_TXNS_IN_LOG;
+
+    /**
+     * In-core copy of transactions. We could read everything back from
+     * the log file, but the RecordFile needs to keep the dirty blocks in
+     * core anyway, so we might as well point to them and spare us a lot
+     * of hassle.
+     */
+    private ArrayList[] txns = new ArrayList[DEFAULT_TXNS_IN_LOG];
+    private int curTxn = -1;
+
+    /** Extension of a log file. */
+    static final String extension = ".lg";
+
+    /**
+     *  Instantiates a transaction manager instance. If recovery
+     *  needs to be performed, it is done.
+     *
+     *  @param owner the RecordFile instance that owns this transaction mgr.
+     */
+    TransactionManager(RecordFile owner) throws IOException {
+        this.owner = owner;
+        recover();
+        open();
+    }
+
+    
+    /**
+     * Synchronize log file data with the main database file.
+     * <p>
+     * After this call, the main database file is guaranteed to be 
+     * consistent and guaranteed to be the only file needed for 
+     * backup purposes.
+     */
+    public void synchronizeLog()
+        throws IOException
+    {
+        synchronizeLogFromMemory();
+    }
+
+    
+    /**
+     * Set the maximum number of transactions to record in
+     * the log (and keep in memory) before the log is
+     * synchronized with the main database file.
+     * <p>
+     * This method must be called while there are no
+     * pending transactions in the log.
+     */
+    public void setMaximumTransactionsInLog( int maxTxns )
+        throws IOException
+    {
+        if ( maxTxns <= 0 ) {
+            throw new IllegalArgumentException( 
+                "Argument 'maxTxns' must be greater than 0." );
+        }
+        if ( curTxn != -1 ) {
+            throw new IllegalStateException( 
+                "Cannot change setting while transactions are pending in the log" );
+        }
+        _maxTxns = maxTxns;
+        txns = new ArrayList[ maxTxns ];
+    }
+
+    
+    /** Builds logfile name  */
+    private String makeLogName() {
+        return owner.getFileName() + extension;
+    }
+
+
+    /** Synchs in-core transactions to data file and opens a fresh log */
+    private void synchronizeLogFromMemory() throws IOException {
+        close();
+
+        TreeSet blockList = new TreeSet( new BlockIoComparator() );
+
+        int numBlocks = 0;
+        int writtenBlocks = 0;
+        for (int i = 0; i < _maxTxns; i++) {
+            if (txns[i] == null)
+                continue;
+            // Add each block to the blockList, replacing the old copy of this
+            // block if necessary, thus avoiding writing the same block twice
+            for (Iterator k = txns[i].iterator(); k.hasNext(); ) {
+                BlockIo block = (BlockIo)k.next();
+                if ( blockList.contains( block ) ) {
+                    block.decrementTransactionCount();
+                }
+                else {
+                    writtenBlocks++;
+                    boolean result = blockList.add( block );
+                }
+                numBlocks++;
+            }
+
+            txns[i] = null;
+        }
+        // Write the blocks from the blockList to disk
+        synchronizeBlocks(blockList.iterator(), true);
+
+        owner.sync();
+        open();
+    }
+
+
+    /** Opens the log file */
+    private void open() throws IOException {
+        fos = new FileOutputStream(makeLogName());
+        oos = new ObjectOutputStream(fos);
+        oos.writeShort(Magic.LOGFILE_HEADER);
+        oos.flush();
+        curTxn = -1;
+    }
+
+    /** Startup recovery on all files */
+    private void recover() throws IOException {
+        String logName = makeLogName();
+        File logFile = new File(logName);
+        if (!logFile.exists())
+            return;
+        if (logFile.length() == 0) {
+            logFile.delete();
+            return;
+        }
+
+        FileInputStream fis = new FileInputStream(logFile);
+        ObjectInputStream ois = new ObjectInputStream(fis);
+
+        try {
+            if (ois.readShort() != Magic.LOGFILE_HEADER)
+                throw new Error("Bad magic on log file");
+        } catch (IOException e) {
+            // corrupted/empty logfile
+            logFile.delete();
+            return;
+        }
+
+        while (true) {
+            ArrayList blocks = null;
+            try {
+                blocks = (ArrayList) ois.readObject();
+            } catch (ClassNotFoundException e) {
+                throw new Error("Unexcepted exception: " + e);
+            } catch (IOException e) {
+                // corrupted logfile, ignore rest of transactions
+                break;
+            }
+            synchronizeBlocks(blocks.iterator(), false);
+
+            // ObjectInputStream must match exactly each
+            // ObjectOutputStream created during writes
+            try {
+                ois = new ObjectInputStream(fis);
+            } catch (IOException e) {
+                // corrupted logfile, ignore rest of transactions
+                break;
+            }
+        }
+        owner.sync();
+        logFile.delete();
+    }
+
+    /** Synchronizes the indicated blocks with the owner. */
+    private void synchronizeBlocks(Iterator blockIterator, boolean fromCore)
+    throws IOException {
+        // write block vector elements to the data file.
+        while ( blockIterator.hasNext() ) {
+            BlockIo cur = (BlockIo)blockIterator.next();
+            owner.synch(cur);
+            if (fromCore) {
+                cur.decrementTransactionCount();
+                if (!cur.isInTransaction()) {
+                    owner.releaseFromTransaction(cur, true);
+                }
+            }
+        }
+    }
+
+
+    /** Set clean flag on the blocks. */
+    private void setClean(ArrayList blocks)
+    throws IOException {
+        for (Iterator k = blocks.iterator(); k.hasNext(); ) {
+            BlockIo cur = (BlockIo) k.next();
+            cur.setClean();
+        }
+    }
+
+    /** Discards the indicated blocks and notify the owner. */
+    private void discardBlocks(ArrayList blocks)
+    throws IOException {
+        for (Iterator k = blocks.iterator(); k.hasNext(); ) {
+            BlockIo cur = (BlockIo) k.next();
+            cur.decrementTransactionCount();
+            if (!cur.isInTransaction()) {
+                owner.releaseFromTransaction(cur, false);
+            }
+        }
+    }
+
+    /**
+     *  Starts a transaction. This can block if all slots have been filled
+     *  with full transactions, waiting for the synchronization thread to
+     *  clean out slots.
+     */
+    void start() throws IOException {
+        curTxn++;
+        if (curTxn == _maxTxns) {
+            synchronizeLogFromMemory();
+            curTxn = 0;
+        }
+        txns[curTxn] = new ArrayList();
+    }
+
+    /**
+     *  Indicates the block is part of the transaction.
+     */
+    void add(BlockIo block) throws IOException {
+        block.incrementTransactionCount();
+        txns[curTxn].add(block);
+    }
+
+    /**
+     *  Commits the transaction to the log file.
+     */
+    void commit() throws IOException {
+        oos.writeObject(txns[curTxn]);
+        sync();
+
+        // set clean flag to indicate blocks have been written to log
+        setClean(txns[curTxn]);
+
+        // open a new ObjectOutputStream in order to store
+        // newer states of BlockIo
+        oos = new ObjectOutputStream(fos);
+    }
+
+    /** Flushes and syncs */
+    private void sync() throws IOException {
+        oos.flush();
+        fos.flush();
+        fos.getFD().sync();
+    }
+
+    /**
+     *  Shutdowns the transaction manager. Resynchronizes outstanding
+     *  logs.
+     */
+    void shutdown() throws IOException {
+        synchronizeLogFromMemory();
+        close();
+    }
+
+    /**
+     *  Closes open files.
+     */
+    private void close() throws IOException {
+        sync();
+        oos.close();
+        fos.close();
+        oos = null;
+        fos = null;
+    }
+
+    /**
+     * Force closing the file without synchronizing pending transaction data.
+     * Used for testing purposes only.
+     */
+    void forceClose() throws IOException {
+        oos.close();
+        fos.close();
+        oos = null;
+        fos = null;
+    }
+
+    /**
+     * Use the disk-based transaction log to synchronize the data file.
+     * Outstanding memory logs are discarded because they are believed
+     * to be inconsistent.
+     */
+    void synchronizeLogFromDisk() throws IOException {
+        close();
+
+        for ( int i=0; i < _maxTxns; i++ ) {
+            if (txns[i] == null)
+                continue;
+            discardBlocks(txns[i]);
+            txns[i] = null;
+        }
+
+        recover();
+        open();
+    }
+
+
+    /** INNER CLASS.
+     *  Comparator class for use by the tree set used to store the blocks
+     *  to write for this transaction.  The BlockIo objects are ordered by
+     *  their blockIds.
+     */
+    public static class BlockIoComparator
+        implements Comparator
+    {
+
+        public int compare( Object o1, Object o2 ) {
+            BlockIo block1 = (BlockIo)o1;
+            BlockIo block2 = (BlockIo)o2;
+            int result = 0;
+            if ( block1.getBlockId() == block2.getBlockId() ) {
+                result = 0;
+            }
+            else if ( block1.getBlockId() < block2.getBlockId() ) {
+                result = -1;
+            }
+            else {
+                result = 1;
+            }
+            return result;
+        }
+
+        public boolean equals(Object obj) {
+            return super.equals(obj);
+        }
+    } // class BlockIOComparator
+
+}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/TranslationPage.java b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/TranslationPage.java
new file mode 100644
index 0000000000..36eafc146d
--- /dev/null
+++ b/ql/src/java/org/apache/hadoop/hive/ql/util/jdbm/recman/TranslationPage.java
@@ -0,0 +1,109 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg@cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot. 
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: TranslationPage.java,v 1.1 2000/05/06 00:00:31 boisvert Exp $
+ */
+
+package org.apache.hadoop.hive.ql.util.jdbm.recman;
+
+/**
+ *  Class describing a page that holds translations from physical rowids
+ *  to logical rowids. In fact, the page just holds physical rowids - the
+ *  page's block is the block for the logical rowid, the offset serve
+ *  as offset for the rowids.
+ */
+final class TranslationPage extends PageHeader {
+    // offsets
+    static final short O_TRANS = PageHeader.SIZE; // short count
+    static final short ELEMS_PER_PAGE = 
+        (RecordFile.BLOCK_SIZE - O_TRANS) / PhysicalRowId.SIZE;
+    
+    // slots we returned.
+    final PhysicalRowId[] slots = new PhysicalRowId[ELEMS_PER_PAGE];
+
+    /**
+     *  Constructs a data page view from the indicated block.
+     */
+    TranslationPage(BlockIo block) {
+        super(block);
+    }
+
+    /**
+     *  Factory method to create or return a data page for the
+     *  indicated block.
+     */
+    static TranslationPage getTranslationPageView(BlockIo block) {
+        BlockView view = block.getView();
+        if (view != null && view instanceof TranslationPage)
+            return (TranslationPage) view;
+        else
+            return new TranslationPage(block);
+    }
+
+    /** Returns the value of the indicated rowid on the page */
+    PhysicalRowId get(short offset) {
+        int slot = (offset - O_TRANS) / PhysicalRowId.SIZE;
+        if (slots[slot] == null) 
+            slots[slot] = new PhysicalRowId(block, offset);
+        return slots[slot];
+    }
+}
