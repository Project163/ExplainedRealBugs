diff --git a/ql/src/java/org/apache/hadoop/hive/ql/ErrorMsg.java b/ql/src/java/org/apache/hadoop/hive/ql/ErrorMsg.java
index e14208203f..946f9a67c4 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/ErrorMsg.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/ErrorMsg.java
@@ -361,6 +361,7 @@ public enum ErrorMsg {
   BAD_LOCATION_VALUE(10244, "{0}  is not absolute or has no scheme information.  Please specify a complete absolute uri with scheme information."),
   UNSUPPORTED_ALTER_TBL_OP(10245, "{0} alter table options is not supported"),
   INVALID_BIGTABLE_MAPJOIN(10246, "{0} table chosen for streaming is not valid", true),
+  MISSING_OVER_CLAUSE(10247, "Missing over clause for function : "),
 
   SCRIPT_INIT_ERROR(20000, "Unable to initialize custom script."),
   SCRIPT_IO_ERROR(20001, "An error occurred while reading or writing to your custom script. "
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/IdentifiersParser.g b/ql/src/java/org/apache/hadoop/hive/ql/parse/IdentifiersParser.g
index 42230c581f..5bdf47763c 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/IdentifiersParser.g
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/IdentifiersParser.g
@@ -173,8 +173,9 @@ function
         (star=STAR)
         | (dist=KW_DISTINCT)? (selectExpression (COMMA selectExpression)*)?
       )
-    RPAREN -> {$star != null}? ^(TOK_FUNCTIONSTAR functionName)
-           -> {$dist == null}? ^(TOK_FUNCTION functionName (selectExpression+)?)
+    RPAREN (KW_OVER ws=window_specification)?
+           -> {$star != null}? ^(TOK_FUNCTIONSTAR functionName $ws?)
+           -> {$dist == null}? ^(TOK_FUNCTION functionName (selectExpression+)? $ws?)
                             -> ^(TOK_FUNCTIONDI functionName (selectExpression+)?)
     ;
 
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/SelectClauseParser.g b/ql/src/java/org/apache/hadoop/hive/ql/parse/SelectClauseParser.g
index b717dd484b..f4de252101 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/SelectClauseParser.g
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/SelectClauseParser.g
@@ -125,9 +125,9 @@ selectItem
 @init { gParent.msgs.push("selection target"); }
 @after { gParent.msgs.pop(); }
     :
-    ( selectExpression (KW_OVER ws=window_specification )?
+    ( selectExpression
       ((KW_AS? identifier) | (KW_AS LPAREN identifier (COMMA identifier)* RPAREN))?
-    ) -> ^(TOK_SELEXPR selectExpression identifier* $ws?)
+    ) -> ^(TOK_SELEXPR selectExpression identifier*)
     ;
 
 trfmClause
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
index abcd503184..1d6e6fe6ba 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java
@@ -71,7 +71,6 @@
 import org.apache.hadoop.hive.ql.exec.UDFArgumentException;
 import org.apache.hadoop.hive.ql.exec.UnionOperator;
 import org.apache.hadoop.hive.ql.exec.Utilities;
-import org.apache.hadoop.hive.ql.exec.WindowFunctionInfo;
 import org.apache.hadoop.hive.ql.hooks.ReadEntity;
 import org.apache.hadoop.hive.ql.hooks.WriteEntity;
 import org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;
@@ -360,29 +359,39 @@ public void doPhase1QBExpr(ASTNode ast, QBExpr qbexpr, String id, String alias)
   }
 
   private LinkedHashMap<String, ASTNode> doPhase1GetAggregationsFromSelect(
-      ASTNode selExpr, QB qb, String dest) {
+      ASTNode selExpr, QB qb, String dest) throws SemanticException {
 
     // Iterate over the selects search for aggregation Trees.
     // Use String as keys to eliminate duplicate trees.
     LinkedHashMap<String, ASTNode> aggregationTrees = new LinkedHashMap<String, ASTNode>();
+    List<ASTNode> wdwFns = new ArrayList<ASTNode>();
     for (int i = 0; i < selExpr.getChildCount(); ++i) {
-      ASTNode sel = (ASTNode) selExpr.getChild(i);
-      doPhase1GetAllAggregations((ASTNode) sel.getChild(0), aggregationTrees);
-    }
-
-    /*
-     * remove any aggregation to be handled by Windowing.
-     */
-    if ( queryProperties.hasWindowing() && qb.getWindowingSpec(dest) != null ) {
-      HashMap<String, ASTNode> aliasToWdwExprs = qb.getParseInfo().getWindowingExprsForClause(dest);
-      LinkedHashMap<String, ASTNode> aggTreesMinusWindowing = new LinkedHashMap<String, ASTNode>();
-      for(Map.Entry<String,ASTNode> entry : aggregationTrees.entrySet()) {
-        if ( !aliasToWdwExprs.containsKey(entry.getKey())) {
-          aggTreesMinusWindowing.put(entry.getKey(), entry.getValue());
-        }
+      ASTNode function = (ASTNode) selExpr.getChild(i).getChild(0);
+      doPhase1GetAllAggregations((ASTNode) function, aggregationTrees, wdwFns);
+    }
+
+    // window based aggregations are handled differently
+    for (ASTNode wdwFn : wdwFns) {
+      WindowingSpec spec = qb.getWindowingSpec(dest);
+      if(spec == null) {
+        queryProperties.setHasWindowing(true);
+        spec = new WindowingSpec();
+        qb.addDestToWindowingSpec(dest, spec);
+      }
+      HashMap<String, ASTNode> wExprsInDest = qb.getParseInfo().getWindowingExprsForClause(dest);
+      int wColIdx = spec.getWindowExpressions() == null ? 0 : spec.getWindowExpressions().size();
+      WindowFunctionSpec wFnSpec = processWindowFunction(wdwFn,
+        (ASTNode)wdwFn.getChild(wdwFn.getChildCount()-1));
+      // If this is a duplicate invocation of a function; don't add to WindowingSpec.
+      if ( wExprsInDest != null &&
+          wExprsInDest.containsKey(wFnSpec.getExpression().toStringTree())) {
+        continue;
       }
-      aggregationTrees = aggTreesMinusWindowing;
+      wFnSpec.setAlias("_wcol" + wColIdx++);
+      spec.addWindowFunction(wFnSpec);
+      qb.getParseInfo().addWindowingExprToClause(dest, wFnSpec.getExpression());
     }
+
     return aggregationTrees;
   }
 
@@ -406,18 +415,30 @@ private void doPhase1GetColumnAliasesFromSelect(
    * @param aggregations
    *          the key to the HashTable is the toStringTree() representation of
    *          the aggregation subtree.
+   * @throws SemanticException
    */
   private void doPhase1GetAllAggregations(ASTNode expressionTree,
-      HashMap<String, ASTNode> aggregations) {
+      HashMap<String, ASTNode> aggregations, List<ASTNode> wdwFns) throws SemanticException {
     int exprTokenType = expressionTree.getToken().getType();
     if (exprTokenType == HiveParser.TOK_FUNCTION
         || exprTokenType == HiveParser.TOK_FUNCTIONDI
         || exprTokenType == HiveParser.TOK_FUNCTIONSTAR) {
       assert (expressionTree.getChildCount() != 0);
+      if (expressionTree.getChild(expressionTree.getChildCount()-1).getType()
+          == HiveParser.TOK_WINDOWSPEC) {
+        wdwFns.add(expressionTree);
+        return;
+      }
       if (expressionTree.getChild(0).getType() == HiveParser.Identifier) {
         String functionName = unescapeIdentifier(expressionTree.getChild(0)
             .getText());
+        if(FunctionRegistry.impliesOrder(functionName)) {
+          throw new SemanticException(ErrorMsg.MISSING_OVER_CLAUSE.getMsg(functionName));
+        }
         if (FunctionRegistry.getGenericUDAFResolver(functionName) != null) {
+          if(containsLeadLagUDF(expressionTree)) {
+            throw new SemanticException(ErrorMsg.MISSING_OVER_CLAUSE.getMsg(functionName));
+          }
           aggregations.put(expressionTree.toStringTree(), expressionTree);
           FunctionInfo fi = FunctionRegistry.getFunctionInfo(functionName);
           if (!fi.isNative()) {
@@ -430,7 +451,7 @@ private void doPhase1GetAllAggregations(ASTNode expressionTree,
     }
     for (int i = 0; i < expressionTree.getChildCount(); i++) {
       doPhase1GetAllAggregations((ASTNode) expressionTree.getChild(i),
-          aggregations);
+          aggregations, wdwFns);
     }
   }
 
@@ -768,8 +789,6 @@ public boolean doPhase1(ASTNode ast, QB qb, Phase1Ctx ctx_1)
           qbp.setHints((ASTNode) ast.getChild(0));
         }
 
-        handleWindowingExprsInSelectList(qb, ctx_1.dest, ast);
-
         LinkedHashMap<String, ASTNode> aggregations = doPhase1GetAggregationsFromSelect(ast,
             qb, ctx_1.dest);
         doPhase1GetColumnAliasesFromSelect(ast, qbp);
@@ -9484,159 +9503,6 @@ private void processPTF(QB qb, ASTNode ptf) throws SemanticException{
     qb.addPTFNodeToSpec(ptf, spec);
   }
 
-//--------------------------- Windowing handling -----------------------------------
-
-  /*
-   * - A Select Item form is: ^(TOK_SELEXPR selectExpression Identifier* window_specification?)
-   * What makes a UDAF invocation a Windowing Function invocation:
-   * 1. It appears in a SelectExpr that as a WindowSpec
-   * 2. It is a UDAF that implies order (FunctionRegistry.impliesOrder)
-   * 3. It contains lead/lag UDF invocations in its args.
-   */
-  private boolean checkAndExtractWindowFunctionsInSelect(QB qb, ASTNode selectExpr, String dest)
-      throws SemanticException {
-
-    int childCount = selectExpr.getChildCount();
-    ASTNode windowSpec = (ASTNode) selectExpr.getChild(childCount - 1);
-
-    boolean hasWindowSpec = windowSpec.getType() == HiveParser.TOK_WINDOWSPEC;
-
-    ArrayList<ASTNode> functions =
-        extractWindowingUDAFs((ASTNode) selectExpr.getChild(0), !hasWindowSpec);
-    if ( functions.size() == 0 ) {
-      return false;
-    }
-
-    WindowingSpec spec = qb.getWindowingSpec(dest);
-    if(spec == null) {
-      queryProperties.setHasWindowing(true);
-      spec = new WindowingSpec();
-      qb.addDestToWindowingSpec(dest, spec);
-    }
-
-    HashMap<String, ASTNode> wExprsInDest = qb.getParseInfo().getWindowingExprsForClause(dest);
-    int wColIdx = spec.getWindowExpressions() == null ? 0 : spec.getWindowExpressions().size();
-    for(ASTNode function : functions) {
-      WindowFunctionSpec wFnSpec = processWindowFunction(function,
-          hasWindowSpec ? windowSpec : null);
-
-      /*
-       * If this is a duplicate invocation of a function; don't add to WindowingSpec.
-       */
-      if ( wExprsInDest != null &&
-          wExprsInDest.containsKey(wFnSpec.getExpression().toStringTree())) {
-        continue;
-      }
-      wFnSpec.setAlias("_wcol" + wColIdx++);
-      spec.addWindowFunction(wFnSpec);
-      qb.getParseInfo().addWindowingExprToClause(dest, wFnSpec.getExpression());
-    }
-    return true;
-  }
-
-  /*
-   * return the UDAFs within the expressionTree.
-   * If implyOrder is true, then only return the invocations that:
-   * - are for UDAFs that implyOrder (FunctionRegistry.implyOrder)
-   * - or contain a Lead/Lag UDF invocation in their arguments
-   * If implyOrder is false, then return all UDAF invocations.
-   */
-  private ArrayList<ASTNode> extractWindowingUDAFs(ASTNode expressionTree, boolean implyOrder) {
-    ArrayList<ASTNode> aggregations = new ArrayList<ASTNode>();
-    extractWindowingUDAFs(expressionTree, aggregations);
-    if (!implyOrder) {
-      return aggregations;
-    }
-    ArrayList<ASTNode> wdwUDAFs = new ArrayList<ASTNode>();
-    for(ASTNode function : aggregations) {
-      String fnName = function.getChild(0).getText().toLowerCase();
-      if ( FunctionRegistry.impliesOrder(fnName)) {
-        wdwUDAFs.add(function);
-        continue;
-      }
-      boolean hasLLInArgs = false;
-      for(int i=1; i < function.getChildCount(); i++) {
-        ASTNode child = (ASTNode) function.getChild(i);
-        hasLLInArgs = containsLeadLagUDF(child);
-        if (hasLLInArgs) {
-          break;
-        }
-      }
-      if (hasLLInArgs) {
-        wdwUDAFs.add(function);
-      }
-    }
-    return wdwUDAFs;
-  }
-
-  private void extractWindowingUDAFs(ASTNode expressionTree,
-      ArrayList<ASTNode> aggregations) {
-    int exprTokenType = expressionTree.getToken().getType();
-    if (exprTokenType == HiveParser.TOK_FUNCTION
-        || exprTokenType == HiveParser.TOK_FUNCTIONDI
-        || exprTokenType == HiveParser.TOK_FUNCTIONSTAR) {
-      assert (expressionTree.getChildCount() != 0);
-      if (expressionTree.getChild(0).getType() == HiveParser.Identifier) {
-        String functionName = unescapeIdentifier(expressionTree.getChild(0)
-            .getText());
-        WindowFunctionInfo fi = FunctionRegistry.getWindowFunctionInfo(functionName);
-        if (fi != null) {
-          aggregations.add(expressionTree);
-          return;
-        }
-      }
-    }
-    for (int i = 0; i < expressionTree.getChildCount(); i++) {
-      extractWindowingUDAFs((ASTNode) expressionTree.getChild(i),
-          aggregations);
-    }
-  }
-
-  private boolean containsLeadLagUDF(ASTNode expressionTree) {
-    int exprTokenType = expressionTree.getToken().getType();
-    if (exprTokenType == HiveParser.TOK_FUNCTION) {
-      assert (expressionTree.getChildCount() != 0);
-      if (expressionTree.getChild(0).getType() == HiveParser.Identifier) {
-        String functionName = unescapeIdentifier(expressionTree.getChild(0)
-            .getText());
-        functionName = functionName.toLowerCase();
-        if ( FunctionRegistry.LAG_FUNC_NAME.equals(functionName) ||
-            FunctionRegistry.LEAD_FUNC_NAME.equals(functionName)
-            ) {
-          return true;
-        }
-      }
-    }
-    for (int i = 0; i < expressionTree.getChildCount(); i++) {
-      if ( containsLeadLagUDF((ASTNode) expressionTree.getChild(i))) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /*
-   * - Invoked during Phase1 when a TOK_SELECT is encountered.
-   * - Select tree form is: ^(TOK_SELECT ^(TOK_SELECTEXPR...) ^(TOK_SELECTEXPR...) ...)
-   * - A Select Item form is: ^(TOK_SELEXPR selectExpression Identifier* window_specification?)
-   *
-   * See checkAndExtractWindowFunctionsInSelect for rules on what makes a UDAF invocation
-   * a Windowing Function invocation
-   */
-  private void handleWindowingExprsInSelectList(QB qb, String dest, ASTNode selectNode)
-      throws SemanticException {
-    for(int i=0; i < selectNode.getChildCount(); i++)
-    {
-      ASTNode selectExpr = (ASTNode) selectNode.getChild(i);
-      if ( selectExpr.getType() != HiveParser.TOK_SELEXPR )
-      {
-        continue;
-      }
-      boolean hasWindowingExprs = checkAndExtractWindowFunctionsInSelect(qb, selectExpr, dest);
-
-    }
-  }
-
   private void handleQueryWindowClauses(QB qb, Phase1Ctx ctx_1, ASTNode node)
       throws SemanticException {
     WindowingSpec spec = qb.getWindowingSpec(ctx_1.dest);
@@ -9723,7 +9589,7 @@ private WindowFunctionSpec processWindowFunction(ASTNode node, ASTNode wsNode)
     ASTNode nameNode = (ASTNode) node.getChild(0);
     wfSpec.setName(nameNode.getText());
 
-    for(int i=1; i < node.getChildCount(); i++) {
+    for(int i=1; i < node.getChildCount()-1; i++) {
       ASTNode child = (ASTNode) node.getChild(i);
       wfSpec.addArg(child);
     }
@@ -9733,18 +9599,32 @@ private WindowFunctionSpec processWindowFunction(ASTNode node, ASTNode wsNode)
       wfSpec.setWindowSpec(ws);
     }
 
-    /*
-     * In order to distinguish between different UDAF invocations on the same UDAF but different Windows
-     * add the WdwSpec node as a child of the Function Node.
-     * It is safe to do this after the function node has been converetd to a WdwFuncSpec.
-     */
-    if ( wsNode != null ) {
-      node.addChild(wsNode);
-    }
-
     return wfSpec;
   }
 
+  private boolean containsLeadLagUDF(ASTNode expressionTree) {
+    int exprTokenType = expressionTree.getToken().getType();
+    if (exprTokenType == HiveParser.TOK_FUNCTION) {
+      assert (expressionTree.getChildCount() != 0);
+      if (expressionTree.getChild(0).getType() == HiveParser.Identifier) {
+        String functionName = unescapeIdentifier(expressionTree.getChild(0)
+            .getText());
+        functionName = functionName.toLowerCase();
+        if ( FunctionRegistry.LAG_FUNC_NAME.equals(functionName) ||
+            FunctionRegistry.LEAD_FUNC_NAME.equals(functionName)
+            ) {
+          return true;
+        }
+      }
+    }
+    for (int i = 0; i < expressionTree.getChildCount(); i++) {
+      if ( containsLeadLagUDF((ASTNode) expressionTree.getChild(i))) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   private void processQueryWindowClause(WindowingSpec spec, ASTNode node)
       throws SemanticException {
     ASTNode nameNode = (ASTNode) node.getChild(0);
diff --git a/ql/src/test/queries/clientnegative/ptf_negative_HavingLeadWithNoGBYNoWindowing.q b/ql/src/test/queries/clientnegative/ptf_negative_HavingLeadWithNoGBYNoWindowing.q
index b4e0ea306d..f351a1448b 100644
--- a/ql/src/test/queries/clientnegative/ptf_negative_HavingLeadWithNoGBYNoWindowing.q
+++ b/ql/src/test/queries/clientnegative/ptf_negative_HavingLeadWithNoGBYNoWindowing.q
@@ -12,11 +12,9 @@ CREATE TABLE part(
     p_comment STRING
 );
 
-LOAD DATA LOCAL INPATH '../data/files/part_tiny.txt' overwrite into table part;
-
 -- testHavingLeadWithNoGBYNoWindowing
 select  p_mfgr,p_name, p_size 
 from part 
-having lead(p_size, 1) <= p_size 
+having lead(p_size, 1) over() <= p_size 
 distribute by p_mfgr 
 sort by p_name;
diff --git a/ql/src/test/queries/clientnegative/ptf_negative_HavingLeadWithPTF.q b/ql/src/test/queries/clientnegative/ptf_negative_HavingLeadWithPTF.q
index b5fbcc5802..d0d3d3fae2 100644
--- a/ql/src/test/queries/clientnegative/ptf_negative_HavingLeadWithPTF.q
+++ b/ql/src/test/queries/clientnegative/ptf_negative_HavingLeadWithPTF.q
@@ -17,6 +17,6 @@ select  p_mfgr,p_name, p_size
 from noop(on part 
 partition by p_mfgr 
 order by p_name) 
-having lead(p_size, 1) <= p_size 
+having lead(p_size, 1) over() <= p_size 
 distribute by p_mfgr 
 sort by p_name;   
diff --git a/ql/src/test/queries/clientnegative/ptf_negative_InvalidValueBoundary.q b/ql/src/test/queries/clientnegative/ptf_negative_InvalidValueBoundary.q
index 38c65c697b..40a39cb68b 100644
--- a/ql/src/test/queries/clientnegative/ptf_negative_InvalidValueBoundary.q
+++ b/ql/src/test/queries/clientnegative/ptf_negative_InvalidValueBoundary.q
@@ -16,6 +16,6 @@ CREATE TABLE part(
 -- testInvalidValueBoundary
 select  p_mfgr,p_name, p_size,   
 sum(p_size) over (w1) as s ,    
-dense_rank() as dr  
+dense_rank() over(w1) as dr  
 from part  
 window w1 as (partition by p_mfgr order by p_complex range between  2 preceding and current row);
diff --git a/ql/src/test/queries/clientnegative/ptf_negative_WhereWithRankCond.q b/ql/src/test/queries/clientnegative/ptf_negative_WhereWithRankCond.q
index d773ef0166..8f4a21bd6c 100644
--- a/ql/src/test/queries/clientnegative/ptf_negative_WhereWithRankCond.q
+++ b/ql/src/test/queries/clientnegative/ptf_negative_WhereWithRankCond.q
@@ -12,11 +12,9 @@ CREATE TABLE part(
     p_comment STRING
 );
 
-LOAD DATA LOCAL INPATH '../data/files/part_tiny.txt' overwrite into table part;
-
 -- testWhereWithRankCond
 select  p_mfgr,p_name, p_size, 
-rank() as r 
+rank() over() as r 
 from part 
 where r < 4 
 distribute by p_mfgr 
diff --git a/ql/src/test/queries/clientnegative/windowing_leadlag_in_udaf.q b/ql/src/test/queries/clientnegative/windowing_leadlag_in_udaf.q
new file mode 100644
index 0000000000..b54b7a5321
--- /dev/null
+++ b/ql/src/test/queries/clientnegative/windowing_leadlag_in_udaf.q
@@ -0,0 +1,15 @@
+DROP TABLE part;
+
+CREATE TABLE part( 
+    p_partkey INT,
+    p_name STRING,
+    p_mfgr STRING,
+    p_brand STRING,
+    p_type STRING,
+    p_size INT,
+    p_container STRING,
+    p_retailprice DOUBLE,
+    p_comment STRING
+);
+
+select sum(lead(p_retailprice,1)) as s1  from part;
diff --git a/ql/src/test/queries/clientnegative/windowing_ll_no_over.q b/ql/src/test/queries/clientnegative/windowing_ll_no_over.q
new file mode 100644
index 0000000000..3ca1104b01
--- /dev/null
+++ b/ql/src/test/queries/clientnegative/windowing_ll_no_over.q
@@ -0,0 +1,17 @@
+DROP TABLE part;
+
+CREATE TABLE part( 
+    p_partkey INT,
+    p_name STRING,
+    p_mfgr STRING,
+    p_brand STRING,
+    p_type STRING,
+    p_size INT,
+    p_container STRING,
+    p_retailprice DOUBLE,
+    p_comment STRING
+);
+
+select p_mfgr, 
+lead(p_retailprice,1) as s1  
+from part;
diff --git a/ql/src/test/queries/clientpositive/ctas_colname.q b/ql/src/test/queries/clientpositive/ctas_colname.q
index c174b11d29..80b8b4f064 100644
--- a/ql/src/test/queries/clientpositive/ctas_colname.q
+++ b/ql/src/test/queries/clientpositive/ctas_colname.q
@@ -16,10 +16,10 @@ describe formatted x4;
 select * from x4 order by key, value, rr;
 
 explain
-create table x5 as select *, lead(key,1) over(partition by key order by value) from src limit 20;
-create table x5 as select *, lead(key,1) over(partition by key order by value) from src limit 20;
+create table x5 as select *, lead(key,1) over(partition by key order by value) as lead1 from src limit 20;
+create table x5 as select *, lead(key,1) over(partition by key order by value) as lead1 from src limit 20;
 describe formatted x5;
-select * from x5 order by key, value, tok_windowspec;
+select * from x5 order by key, value, lead1;
 
 -- sub queries
 explain
diff --git a/ql/src/test/queries/clientpositive/ptf.q b/ql/src/test/queries/clientpositive/ptf.q
index 059b5f4d36..eea5415d68 100644
--- a/ql/src/test/queries/clientpositive/ptf.q
+++ b/ql/src/test/queries/clientpositive/ptf.q
@@ -196,7 +196,7 @@ rank() over (distribute by p_mfgr sort by p_name) as r,
 dense_rank() over (distribute by p_mfgr sort by p_name) as dr, 
 sum(p_retailprice) over (distribute by p_mfgr sort by p_name rows between unbounded preceding and current row)  as s  
 INSERT OVERWRITE TABLE part_5 select  p_mfgr,p_name, p_size,  
-round(sum(p_size),1) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row) as s2,
+round(sum(p_size) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row),1) as s2,
 rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as r, 
 dense_rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as dr, 
 cume_dist() over (distribute by p_mfgr sort by p_mfgr, p_name) as cud, 
diff --git a/ql/src/test/queries/clientpositive/windowing.q b/ql/src/test/queries/clientpositive/windowing.q
index 7c2a10bc1c..a7297db610 100644
--- a/ql/src/test/queries/clientpositive/windowing.q
+++ b/ql/src/test/queries/clientpositive/windowing.q
@@ -218,14 +218,14 @@ group by p_mfgr, p_brand;
 select * 
 from (
 select p_mfgr, p_brand, s, 
-round(sum(s),2) over w1  as s1
+round(sum(s) over w1 , 2)  as s1
 from mfgr_price_view 
 window w1 as (distribute by p_mfgr sort by p_mfgr )
 ) sq
 order by p_mfgr, p_brand;
 
 select p_mfgr, p_brand, s, 
-round(sum(s),2) over w1  as s1
+round(sum(s) over w1 ,2)  as s1
 from mfgr_price_view 
 window w1 as (distribute by p_mfgr sort by p_brand rows between 2 preceding and current row);
 
@@ -283,7 +283,7 @@ select  p_mfgr,p_name, p_size,
 rank() over(distribute by p_mfgr sort by p_name) as r, 
 dense_rank() over(distribute by p_mfgr sort by p_name) as dr, 
 cume_dist() over(distribute by p_mfgr sort by p_name) as cud, 
-round(sum(p_size),1) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row) as s2, 
+round(sum(p_size) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row),1) as s2, 
 first_value(p_size) over w1  as fv1
 window w1 as (distribute by p_mfgr sort by p_mfgr, p_name rows between 2 preceding and 2 following) 
 INSERT OVERWRITE TABLE part_3 
@@ -387,10 +387,10 @@ from part;
 
 -- 37. testPartitioningVariousForms
 select p_mfgr,
-round(sum(p_retailprice),2) over (partition by p_mfgr order by p_mfgr) as s1,
+round(sum(p_retailprice) over (partition by p_mfgr order by p_mfgr),2) as s1,
 min(p_retailprice) over (partition by p_mfgr) as s2,
 max(p_retailprice) over (distribute by p_mfgr sort by p_mfgr) as s3,
-round(avg(p_retailprice),2) over (distribute by p_mfgr) as s4,
+round(avg(p_retailprice) over (distribute by p_mfgr),2) as s4,
 count(p_retailprice) over (cluster by p_mfgr ) as s5
 from part;
 
@@ -428,7 +428,7 @@ select p_mfgr, p_name, p_size,
         
 -- 44. testOverNoPartitionSingleAggregate
 select p_name, p_retailprice,
-round(avg(p_retailprice),2) over()
+round(avg(p_retailprice) over(),2)
 from part
 order by p_name;
         
diff --git a/ql/src/test/queries/clientpositive/windowing_expressions.q b/ql/src/test/queries/clientpositive/windowing_expressions.q
index 5a4a07232d..2c3339095f 100644
--- a/ql/src/test/queries/clientpositive/windowing_expressions.q
+++ b/ql/src/test/queries/clientpositive/windowing_expressions.q
@@ -35,17 +35,15 @@ create table over10k(
 load data local inpath '../data/files/over10k' into table over10k;
 
 select p_mfgr, p_retailprice, p_size,
-round(sum(p_retailprice),2) = round(sum(lag(p_retailprice,1,0.0)) + last_value(p_retailprice),2) 
-  over(distribute by p_mfgr sort by p_retailprice),
-max(p_retailprice) - min(p_retailprice) = last_value(p_retailprice) - first_value(p_retailprice)
-  over(distribute by p_mfgr sort by p_retailprice)
+round(sum(p_retailprice) over w1 , 2) = round(sum(lag(p_retailprice,1,0.0)) over w1 + last_value(p_retailprice) over w1 , 2), 
+max(p_retailprice) over w1 - min(p_retailprice) over w1 = last_value(p_retailprice) over w1 - first_value(p_retailprice) over w1
 from part
+window w1 as (distribute by p_mfgr sort by p_retailprice)
 ;
-
 select p_mfgr, p_retailprice, p_size,
 rank() over (distribute by p_mfgr sort by p_retailprice) as r,
 sum(p_retailprice) over (distribute by p_mfgr sort by p_retailprice rows between unbounded preceding and current row) as s2,
-sum(p_retailprice) - 5 over (distribute by p_mfgr sort by p_retailprice rows between unbounded preceding and current row) as s1
+sum(p_retailprice) over (distribute by p_mfgr sort by p_retailprice rows between unbounded preceding and current row) -5 as s1
 from part
 ;
 
@@ -66,7 +64,7 @@ select * from t1 limit 3;
 select * from t2 limit 3;
 
 select p_mfgr, p_retailprice, p_size,
-round(sum(p_retailprice),2) + 50.0 = round(sum(lag(p_retailprice,1,50.0)) + last_value(p_retailprice),2) 
-  over(distribute by p_mfgr sort by p_retailprice)
+round(sum(p_retailprice) over w1 , 2) + 50.0 = round(sum(lag(p_retailprice,1,50.0)) over w1 + (last_value(p_retailprice) over w1),2)
 from part
+window w1 as (distribute by p_mfgr sort by p_retailprice)
 limit 11;
diff --git a/ql/src/test/queries/clientpositive/windowing_windowspec.q b/ql/src/test/queries/clientpositive/windowing_windowspec.q
index 00b5b5b867..7cc1367306 100644
--- a/ql/src/test/queries/clientpositive/windowing_windowspec.q
+++ b/ql/src/test/queries/clientpositive/windowing_windowspec.q
@@ -31,4 +31,6 @@ select s, sum(i) over(partition by ts order by s) from over10k limit 100;
 
 select f, sum(f) over (partition by ts order by f range between unbounded preceding and current row) from over10k limit 100;
 
+select s, i, round(avg(d) over (partition by s order by i) / 10.0 , 2) from over10k limit 7;
 
+select s, i, round((avg(d) over  w1 + 10.0) - (avg(d) over w1 - 10.0),2) from over10k window w1 as (partition by s order by i) limit 7;
diff --git a/ql/src/test/results/clientnegative/ptf_negative_HavingLeadWithNoGBYNoWindowing.q.out b/ql/src/test/results/clientnegative/ptf_negative_HavingLeadWithNoGBYNoWindowing.q.out
index 62b501a186..7e9a7a25d1 100644
--- a/ql/src/test/results/clientnegative/ptf_negative_HavingLeadWithNoGBYNoWindowing.q.out
+++ b/ql/src/test/results/clientnegative/ptf_negative_HavingLeadWithNoGBYNoWindowing.q.out
@@ -27,10 +27,4 @@ POSTHOOK: query: CREATE TABLE part(
 )
 POSTHOOK: type: CREATETABLE
 POSTHOOK: Output: default@part
-PREHOOK: query: LOAD DATA LOCAL INPATH '../data/files/part_tiny.txt' overwrite into table part
-PREHOOK: type: LOAD
-PREHOOK: Output: default@part
-POSTHOOK: query: LOAD DATA LOCAL INPATH '../data/files/part_tiny.txt' overwrite into table part
-POSTHOOK: type: LOAD
-POSTHOOK: Output: default@part
 FAILED: SemanticException HAVING specified without GROUP BY
diff --git a/ql/src/test/results/clientnegative/ptf_negative_WhereWithRankCond.q.out b/ql/src/test/results/clientnegative/ptf_negative_WhereWithRankCond.q.out
index 277b07a9d4..d6ecc9072a 100644
--- a/ql/src/test/results/clientnegative/ptf_negative_WhereWithRankCond.q.out
+++ b/ql/src/test/results/clientnegative/ptf_negative_WhereWithRankCond.q.out
@@ -27,10 +27,4 @@ POSTHOOK: query: CREATE TABLE part(
 )
 POSTHOOK: type: CREATETABLE
 POSTHOOK: Output: default@part
-PREHOOK: query: LOAD DATA LOCAL INPATH '../data/files/part_tiny.txt' overwrite into table part
-PREHOOK: type: LOAD
-PREHOOK: Output: default@part
-POSTHOOK: query: LOAD DATA LOCAL INPATH '../data/files/part_tiny.txt' overwrite into table part
-POSTHOOK: type: LOAD
-POSTHOOK: Output: default@part
 FAILED: SemanticException [Error 10004]: Line 7:6 Invalid table alias or column reference 'r': (possible column names are: p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment)
diff --git a/ql/src/test/results/clientnegative/windowing_leadlag_in_udaf.q.out b/ql/src/test/results/clientnegative/windowing_leadlag_in_udaf.q.out
new file mode 100644
index 0000000000..a81028c39f
--- /dev/null
+++ b/ql/src/test/results/clientnegative/windowing_leadlag_in_udaf.q.out
@@ -0,0 +1,30 @@
+PREHOOK: query: DROP TABLE part
+PREHOOK: type: DROPTABLE
+POSTHOOK: query: DROP TABLE part
+POSTHOOK: type: DROPTABLE
+PREHOOK: query: CREATE TABLE part( 
+    p_partkey INT,
+    p_name STRING,
+    p_mfgr STRING,
+    p_brand STRING,
+    p_type STRING,
+    p_size INT,
+    p_container STRING,
+    p_retailprice DOUBLE,
+    p_comment STRING
+)
+PREHOOK: type: CREATETABLE
+POSTHOOK: query: CREATE TABLE part( 
+    p_partkey INT,
+    p_name STRING,
+    p_mfgr STRING,
+    p_brand STRING,
+    p_type STRING,
+    p_size INT,
+    p_container STRING,
+    p_retailprice DOUBLE,
+    p_comment STRING
+)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: default@part
+FAILED: SemanticException [Error 10247]: Missing over clause for function :  sum
diff --git a/ql/src/test/results/clientnegative/windowing_ll_no_over.q.out b/ql/src/test/results/clientnegative/windowing_ll_no_over.q.out
new file mode 100644
index 0000000000..8c913d5b72
--- /dev/null
+++ b/ql/src/test/results/clientnegative/windowing_ll_no_over.q.out
@@ -0,0 +1,30 @@
+PREHOOK: query: DROP TABLE part
+PREHOOK: type: DROPTABLE
+POSTHOOK: query: DROP TABLE part
+POSTHOOK: type: DROPTABLE
+PREHOOK: query: CREATE TABLE part( 
+    p_partkey INT,
+    p_name STRING,
+    p_mfgr STRING,
+    p_brand STRING,
+    p_type STRING,
+    p_size INT,
+    p_container STRING,
+    p_retailprice DOUBLE,
+    p_comment STRING
+)
+PREHOOK: type: CREATETABLE
+POSTHOOK: query: CREATE TABLE part( 
+    p_partkey INT,
+    p_name STRING,
+    p_mfgr STRING,
+    p_brand STRING,
+    p_type STRING,
+    p_size INT,
+    p_container STRING,
+    p_retailprice DOUBLE,
+    p_comment STRING
+)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: default@part
+FAILED: SemanticException [Error 10247]: Missing over clause for function :  lead
diff --git a/ql/src/test/results/clientpositive/correlationoptimizer12.q.out b/ql/src/test/results/clientpositive/correlationoptimizer12.q.out
index 70cf2aa1ea..22dfce95bb 100644
--- a/ql/src/test/results/clientpositive/correlationoptimizer12.q.out
+++ b/ql/src/test/results/clientpositive/correlationoptimizer12.q.out
@@ -15,7 +15,7 @@ JOIN
 ON (xx.key=yy.key)
 POSTHOOK: type: QUERY
 ABSTRACT SYNTAX TREE:
-  (TOK_QUERY (TOK_FROM (TOK_JOIN (TOK_SUBQUERY (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src) x)) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR (. (TOK_TABLE_OR_COL x) key) key) (TOK_SELEXPR (TOK_FUNCTION count (. (TOK_TABLE_OR_COL x) value) (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (. (TOK_TABLE_OR_COL x) key))))) cnt (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (. (TOK_TABLE_OR_COL x) key)))))))) xx) (TOK_SUBQUERY (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src1) y)) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR (. (TOK_TABLE_OR_COL y) key) key) (TOK_SELEXPR (TOK_FUNCTION count (. (TOK_TABLE_OR_COL y) value) (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (. (TOK_TABLE_OR_COL y) key))))) cnt (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (. (TOK_TABLE_OR_COL y) key)))))))) yy) (= (. (TOK_TABLE_OR_COL xx) key) (. (TOK_TABLE_OR_COL yy) key)))) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR (. (TOK_TABLE_OR_COL xx) key)) (TOK_SELEXPR (. (TOK_TABLE_OR_COL xx) cnt)) (TOK_SELEXPR (. (TOK_TABLE_OR_COL yy) key)) (TOK_SELEXPR (. (TOK_TABLE_OR_COL yy) cnt)))))
+  (TOK_QUERY (TOK_FROM (TOK_JOIN (TOK_SUBQUERY (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src) x)) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR (. (TOK_TABLE_OR_COL x) key) key) (TOK_SELEXPR (TOK_FUNCTION count (. (TOK_TABLE_OR_COL x) value) (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (. (TOK_TABLE_OR_COL x) key))))) cnt)))) xx) (TOK_SUBQUERY (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src1) y)) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR (. (TOK_TABLE_OR_COL y) key) key) (TOK_SELEXPR (TOK_FUNCTION count (. (TOK_TABLE_OR_COL y) value) (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (. (TOK_TABLE_OR_COL y) key))))) cnt)))) yy) (= (. (TOK_TABLE_OR_COL xx) key) (. (TOK_TABLE_OR_COL yy) key)))) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR (. (TOK_TABLE_OR_COL xx) key)) (TOK_SELEXPR (. (TOK_TABLE_OR_COL xx) cnt)) (TOK_SELEXPR (. (TOK_TABLE_OR_COL yy) key)) (TOK_SELEXPR (. (TOK_TABLE_OR_COL yy) cnt)))))
 
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
diff --git a/ql/src/test/results/clientpositive/ctas_colname.q.out b/ql/src/test/results/clientpositive/ctas_colname.q.out
index c79b954acf..6c4ee2270c 100644
--- a/ql/src/test/results/clientpositive/ctas_colname.q.out
+++ b/ql/src/test/results/clientpositive/ctas_colname.q.out
@@ -159,7 +159,7 @@ explain
 create table x4 as select *, rank() over(partition by key order by value) as rr from src1
 POSTHOOK: type: CREATETABLE_AS_SELECT
 ABSTRACT SYNTAX TREE:
-  (TOK_CREATETABLE (TOK_TABNAME x4) TOK_LIKETABLE (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src1))) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR TOK_ALLCOLREF) (TOK_SELEXPR (TOK_FUNCTION rank (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (TOK_TABLE_OR_COL key)) (TOK_ORDERBY (TOK_TABSORTCOLNAMEASC (TOK_TABLE_OR_COL value)))))) rr (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (TOK_TABLE_OR_COL key)) (TOK_ORDERBY (TOK_TABSORTCOLNAMEASC (TOK_TABLE_OR_COL value))))))))))
+  (TOK_CREATETABLE (TOK_TABNAME x4) TOK_LIKETABLE (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src1))) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR TOK_ALLCOLREF) (TOK_SELEXPR (TOK_FUNCTION rank (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (TOK_TABLE_OR_COL key)) (TOK_ORDERBY (TOK_TABSORTCOLNAMEASC (TOK_TABLE_OR_COL value)))))) rr)))))
 
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
@@ -307,13 +307,13 @@ POSTHOOK: Input: default@x4
 66	val_66	1
 98	val_98	1
 PREHOOK: query: explain
-create table x5 as select *, lead(key,1) over(partition by key order by value) from src limit 20
+create table x5 as select *, lead(key,1) over(partition by key order by value) as lead1 from src limit 20
 PREHOOK: type: CREATETABLE_AS_SELECT
 POSTHOOK: query: explain
-create table x5 as select *, lead(key,1) over(partition by key order by value) from src limit 20
+create table x5 as select *, lead(key,1) over(partition by key order by value) as lead1 from src limit 20
 POSTHOOK: type: CREATETABLE_AS_SELECT
 ABSTRACT SYNTAX TREE:
-  (TOK_CREATETABLE (TOK_TABNAME x5) TOK_LIKETABLE (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src))) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR TOK_ALLCOLREF) (TOK_SELEXPR (TOK_FUNCTION lead (TOK_TABLE_OR_COL key) 1 (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (TOK_TABLE_OR_COL key)) (TOK_ORDERBY (TOK_TABSORTCOLNAMEASC (TOK_TABLE_OR_COL value)))))) (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (TOK_TABLE_OR_COL key)) (TOK_ORDERBY (TOK_TABSORTCOLNAMEASC (TOK_TABLE_OR_COL value))))))) (TOK_LIMIT 20))))
+  (TOK_CREATETABLE (TOK_TABNAME x5) TOK_LIKETABLE (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src))) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE)) (TOK_SELECT (TOK_SELEXPR TOK_ALLCOLREF) (TOK_SELEXPR (TOK_FUNCTION lead (TOK_TABLE_OR_COL key) 1 (TOK_WINDOWSPEC (TOK_PARTITIONINGSPEC (TOK_DISTRIBUTEBY (TOK_TABLE_OR_COL key)) (TOK_ORDERBY (TOK_TABSORTCOLNAMEASC (TOK_TABLE_OR_COL value)))))) lead1)) (TOK_LIMIT 20))))
 
 STAGE DEPENDENCIES:
   Stage-1 is a root stage
@@ -399,7 +399,7 @@ STAGE PLANS:
   Stage: Stage-4
       Create Table Operator:
         Create Table
-          columns: key string, value string, tok_windowspec string
+          columns: key string, value string, lead1 string
           if not exists: false
           input format: org.apache.hadoop.mapred.TextInputFormat
           # buckets: -1
@@ -411,10 +411,10 @@ STAGE PLANS:
     Stats-Aggr Operator
 
 
-PREHOOK: query: create table x5 as select *, lead(key,1) over(partition by key order by value) from src limit 20
+PREHOOK: query: create table x5 as select *, lead(key,1) over(partition by key order by value) as lead1 from src limit 20
 PREHOOK: type: CREATETABLE_AS_SELECT
 PREHOOK: Input: default@src
-POSTHOOK: query: create table x5 as select *, lead(key,1) over(partition by key order by value) from src limit 20
+POSTHOOK: query: create table x5 as select *, lead(key,1) over(partition by key order by value) as lead1 from src limit 20
 POSTHOOK: type: CREATETABLE_AS_SELECT
 POSTHOOK: Input: default@src
 POSTHOOK: Output: default@x5
@@ -426,7 +426,7 @@ POSTHOOK: type: DESCTABLE
 	 	 
 key                 	string              	None                
 value               	string              	None                
-tok_windowspec      	string              	None                
+lead1               	string              	None                
 	 	 
 # Detailed Table Information	 	 
 Database:           	default             	 
@@ -453,11 +453,11 @@ Bucket Columns:     	[]
 Sort Columns:       	[]                  	 
 Storage Desc Params:	 	 
 	serialization.format	1                   
-PREHOOK: query: select * from x5 order by key, value, tok_windowspec
+PREHOOK: query: select * from x5 order by key, value, lead1
 PREHOOK: type: QUERY
 PREHOOK: Input: default@x5
 #### A masked pattern was here ####
-POSTHOOK: query: select * from x5 order by key, value, tok_windowspec
+POSTHOOK: query: select * from x5 order by key, value, lead1
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@x5
 #### A masked pattern was here ####
diff --git a/ql/src/test/results/clientpositive/ptf.q.out b/ql/src/test/results/clientpositive/ptf.q.out
index b8d60f0974..2b7db57bc8 100644
--- a/ql/src/test/results/clientpositive/ptf.q.out
+++ b/ql/src/test/results/clientpositive/ptf.q.out
@@ -858,7 +858,7 @@ rank() over (distribute by p_mfgr sort by p_name) as r,
 dense_rank() over (distribute by p_mfgr sort by p_name) as dr, 
 sum(p_retailprice) over (distribute by p_mfgr sort by p_name rows between unbounded preceding and current row)  as s  
 INSERT OVERWRITE TABLE part_5 select  p_mfgr,p_name, p_size,  
-round(sum(p_size),1) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row) as s2,
+round(sum(p_size) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row),1) as s2,
 rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as r, 
 dense_rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as dr, 
 cume_dist() over (distribute by p_mfgr sort by p_mfgr, p_name) as cud, 
@@ -876,7 +876,7 @@ rank() over (distribute by p_mfgr sort by p_name) as r,
 dense_rank() over (distribute by p_mfgr sort by p_name) as dr, 
 sum(p_retailprice) over (distribute by p_mfgr sort by p_name rows between unbounded preceding and current row)  as s  
 INSERT OVERWRITE TABLE part_5 select  p_mfgr,p_name, p_size,  
-round(sum(p_size),1) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row) as s2,
+round(sum(p_size) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row),1) as s2,
 rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as r, 
 dense_rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as dr, 
 cume_dist() over (distribute by p_mfgr sort by p_mfgr, p_name) as cud, 
diff --git a/ql/src/test/results/clientpositive/windowing.q.out b/ql/src/test/results/clientpositive/windowing.q.out
index d69ad56e3f..a1c445c9db 100644
--- a/ql/src/test/results/clientpositive/windowing.q.out
+++ b/ql/src/test/results/clientpositive/windowing.q.out
@@ -1029,7 +1029,7 @@ POSTHOOK: Output: default@mfgr_price_view
 PREHOOK: query: select * 
 from (
 select p_mfgr, p_brand, s, 
-round(sum(s),2) over w1  as s1
+round(sum(s) over w1 , 2)  as s1
 from mfgr_price_view 
 window w1 as (distribute by p_mfgr sort by p_mfgr )
 ) sq
@@ -1041,7 +1041,7 @@ PREHOOK: Input: default@part
 POSTHOOK: query: select * 
 from (
 select p_mfgr, p_brand, s, 
-round(sum(s),2) over w1  as s1
+round(sum(s) over w1 , 2)  as s1
 from mfgr_price_view 
 window w1 as (distribute by p_mfgr sort by p_mfgr )
 ) sq
@@ -1067,7 +1067,7 @@ Manufacturer#5	Brand#51	1611.66	7672.66
 Manufacturer#5	Brand#52	3254.17	7672.66
 Manufacturer#5	Brand#53	2806.83	7672.66
 PREHOOK: query: select p_mfgr, p_brand, s, 
-round(sum(s),2) over w1  as s1
+round(sum(s) over w1 ,2)  as s1
 from mfgr_price_view 
 window w1 as (distribute by p_mfgr sort by p_brand rows between 2 preceding and current row)
 PREHOOK: type: QUERY
@@ -1075,7 +1075,7 @@ PREHOOK: Input: default@mfgr_price_view
 PREHOOK: Input: default@part
 #### A masked pattern was here ####
 POSTHOOK: query: select p_mfgr, p_brand, s, 
-round(sum(s),2) over w1  as s1
+round(sum(s) over w1 ,2)  as s1
 from mfgr_price_view 
 window w1 as (distribute by p_mfgr sort by p_brand rows between 2 preceding and current row)
 POSTHOOK: type: QUERY
@@ -1313,7 +1313,7 @@ select  p_mfgr,p_name, p_size,
 rank() over(distribute by p_mfgr sort by p_name) as r, 
 dense_rank() over(distribute by p_mfgr sort by p_name) as dr, 
 cume_dist() over(distribute by p_mfgr sort by p_name) as cud, 
-round(sum(p_size),1) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row) as s2, 
+round(sum(p_size) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row),1) as s2, 
 first_value(p_size) over w1  as fv1
 window w1 as (distribute by p_mfgr sort by p_mfgr, p_name rows between 2 preceding and 2 following) 
 INSERT OVERWRITE TABLE part_3 
@@ -1338,7 +1338,7 @@ select  p_mfgr,p_name, p_size,
 rank() over(distribute by p_mfgr sort by p_name) as r, 
 dense_rank() over(distribute by p_mfgr sort by p_name) as dr, 
 cume_dist() over(distribute by p_mfgr sort by p_name) as cud, 
-round(sum(p_size),1) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row) as s2, 
+round(sum(p_size) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row),1) as s2, 
 first_value(p_size) over w1  as fv1
 window w1 as (distribute by p_mfgr sort by p_mfgr, p_name rows between 2 preceding and 2 following) 
 INSERT OVERWRITE TABLE part_3 
@@ -2248,10 +2248,10 @@ Manufacturer#5	almond aquamarine dodger light gainsboro	46	4
 Manufacturer#5	almond azure blanched chiffon midnight	23	5
 PREHOOK: query: -- 37. testPartitioningVariousForms
 select p_mfgr,
-round(sum(p_retailprice),2) over (partition by p_mfgr order by p_mfgr) as s1,
+round(sum(p_retailprice) over (partition by p_mfgr order by p_mfgr),2) as s1,
 min(p_retailprice) over (partition by p_mfgr) as s2,
 max(p_retailprice) over (distribute by p_mfgr sort by p_mfgr) as s3,
-round(avg(p_retailprice),2) over (distribute by p_mfgr) as s4,
+round(avg(p_retailprice) over (distribute by p_mfgr),2) as s4,
 count(p_retailprice) over (cluster by p_mfgr ) as s5
 from part
 PREHOOK: type: QUERY
@@ -2259,10 +2259,10 @@ PREHOOK: Input: default@part
 #### A masked pattern was here ####
 POSTHOOK: query: -- 37. testPartitioningVariousForms
 select p_mfgr,
-round(sum(p_retailprice),2) over (partition by p_mfgr order by p_mfgr) as s1,
+round(sum(p_retailprice) over (partition by p_mfgr order by p_mfgr),2) as s1,
 min(p_retailprice) over (partition by p_mfgr) as s2,
 max(p_retailprice) over (distribute by p_mfgr sort by p_mfgr) as s3,
-round(avg(p_retailprice),2) over (distribute by p_mfgr) as s4,
+round(avg(p_retailprice) over (distribute by p_mfgr),2) as s4,
 count(p_retailprice) over (cluster by p_mfgr ) as s5
 from part
 POSTHOOK: type: QUERY
@@ -2680,7 +2680,7 @@ Manufacturer#5	almond antique blue firebrick mint	31	2807.79
 Manufacturer#5	almond aquamarine dodger light gainsboro	46	1018.1
 PREHOOK: query: -- 44. testOverNoPartitionSingleAggregate
 select p_name, p_retailprice,
-round(avg(p_retailprice),2) over()
+round(avg(p_retailprice) over(),2)
 from part
 order by p_name
 PREHOOK: type: QUERY
@@ -2688,7 +2688,7 @@ PREHOOK: Input: default@part
 #### A masked pattern was here ####
 POSTHOOK: query: -- 44. testOverNoPartitionSingleAggregate
 select p_name, p_retailprice,
-round(avg(p_retailprice),2) over()
+round(avg(p_retailprice) over(),2)
 from part
 order by p_name
 POSTHOOK: type: QUERY
diff --git a/ql/src/test/results/clientpositive/windowing_expressions.q.out b/ql/src/test/results/clientpositive/windowing_expressions.q.out
index 3dbf225371..8544879b06 100644
--- a/ql/src/test/results/clientpositive/windowing_expressions.q.out
+++ b/ql/src/test/results/clientpositive/windowing_expressions.q.out
@@ -77,20 +77,18 @@ POSTHOOK: query: load data local inpath '../data/files/over10k' into table over1
 POSTHOOK: type: LOAD
 POSTHOOK: Output: default@over10k
 PREHOOK: query: select p_mfgr, p_retailprice, p_size,
-round(sum(p_retailprice),2) = round(sum(lag(p_retailprice,1,0.0)) + last_value(p_retailprice),2) 
-  over(distribute by p_mfgr sort by p_retailprice),
-max(p_retailprice) - min(p_retailprice) = last_value(p_retailprice) - first_value(p_retailprice)
-  over(distribute by p_mfgr sort by p_retailprice)
+round(sum(p_retailprice) over w1 , 2) = round(sum(lag(p_retailprice,1,0.0)) over w1 + last_value(p_retailprice) over w1 , 2), 
+max(p_retailprice) over w1 - min(p_retailprice) over w1 = last_value(p_retailprice) over w1 - first_value(p_retailprice) over w1
 from part
+window w1 as (distribute by p_mfgr sort by p_retailprice)
 PREHOOK: type: QUERY
 PREHOOK: Input: default@part
 #### A masked pattern was here ####
 POSTHOOK: query: select p_mfgr, p_retailprice, p_size,
-round(sum(p_retailprice),2) = round(sum(lag(p_retailprice,1,0.0)) + last_value(p_retailprice),2) 
-  over(distribute by p_mfgr sort by p_retailprice),
-max(p_retailprice) - min(p_retailprice) = last_value(p_retailprice) - first_value(p_retailprice)
-  over(distribute by p_mfgr sort by p_retailprice)
+round(sum(p_retailprice) over w1 , 2) = round(sum(lag(p_retailprice,1,0.0)) over w1 + last_value(p_retailprice) over w1 , 2), 
+max(p_retailprice) over w1 - min(p_retailprice) over w1 = last_value(p_retailprice) over w1 - first_value(p_retailprice) over w1
 from part
+window w1 as (distribute by p_mfgr sort by p_retailprice)
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@part
 #### A masked pattern was here ####
@@ -123,7 +121,7 @@ Manufacturer#5	1789.69	31	true	true
 PREHOOK: query: select p_mfgr, p_retailprice, p_size,
 rank() over (distribute by p_mfgr sort by p_retailprice) as r,
 sum(p_retailprice) over (distribute by p_mfgr sort by p_retailprice rows between unbounded preceding and current row) as s2,
-sum(p_retailprice) - 5 over (distribute by p_mfgr sort by p_retailprice rows between unbounded preceding and current row) as s1
+sum(p_retailprice) over (distribute by p_mfgr sort by p_retailprice rows between unbounded preceding and current row) -5 as s1
 from part
 PREHOOK: type: QUERY
 PREHOOK: Input: default@part
@@ -131,7 +129,7 @@ PREHOOK: Input: default@part
 POSTHOOK: query: select p_mfgr, p_retailprice, p_size,
 rank() over (distribute by p_mfgr sort by p_retailprice) as r,
 sum(p_retailprice) over (distribute by p_mfgr sort by p_retailprice rows between unbounded preceding and current row) as s2,
-sum(p_retailprice) - 5 over (distribute by p_mfgr sort by p_retailprice rows between unbounded preceding and current row) as s1
+sum(p_retailprice) over (distribute by p_mfgr sort by p_retailprice rows between unbounded preceding and current row) -5 as s1
 from part
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@part
@@ -719,17 +717,17 @@ POSTHOOK: Lineage: t2.b1 SCRIPT [(over10k)over10k.FieldSchema(name:t, type:tinyi
 131088	oscar brown
 262258	wendy steinbeck
 PREHOOK: query: select p_mfgr, p_retailprice, p_size,
-round(sum(p_retailprice),2) + 50.0 = round(sum(lag(p_retailprice,1,50.0)) + last_value(p_retailprice),2) 
-  over(distribute by p_mfgr sort by p_retailprice)
+round(sum(p_retailprice) over w1 , 2) + 50.0 = round(sum(lag(p_retailprice,1,50.0)) over w1 + (last_value(p_retailprice) over w1),2)
 from part
+window w1 as (distribute by p_mfgr sort by p_retailprice)
 limit 11
 PREHOOK: type: QUERY
 PREHOOK: Input: default@part
 #### A masked pattern was here ####
 POSTHOOK: query: select p_mfgr, p_retailprice, p_size,
-round(sum(p_retailprice),2) + 50.0 = round(sum(lag(p_retailprice,1,50.0)) + last_value(p_retailprice),2) 
-  over(distribute by p_mfgr sort by p_retailprice)
+round(sum(p_retailprice) over w1 , 2) + 50.0 = round(sum(lag(p_retailprice,1,50.0)) over w1 + (last_value(p_retailprice) over w1),2)
 from part
+window w1 as (distribute by p_mfgr sort by p_retailprice)
 limit 11
 POSTHOOK: type: QUERY
 POSTHOOK: Input: default@part
diff --git a/ql/src/test/results/clientpositive/windowing_windowspec.q.out b/ql/src/test/results/clientpositive/windowing_windowspec.q.out
index a355e30359..09a0684ae3 100644
--- a/ql/src/test/results/clientpositive/windowing_windowspec.q.out
+++ b/ql/src/test/results/clientpositive/windowing_windowspec.q.out
@@ -795,3 +795,33 @@ POSTHOOK: Input: default@over10k
 71.68	722.6499947607517
 79.46	802.1099938452244
 80.02	882.1299904882908
+PREHOOK: query: select s, i, round(avg(d) over (partition by s order by i) / 10.0 , 2) from over10k limit 7
+PREHOOK: type: QUERY
+PREHOOK: Input: default@over10k
+#### A masked pattern was here ####
+POSTHOOK: query: select s, i, round(avg(d) over (partition by s order by i) / 10.0 , 2) from over10k limit 7
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@over10k
+#### A masked pattern was here ####
+alice allen	65545	2.22
+alice allen	65557	2.58
+alice allen	65600	3.38
+alice allen	65609	2.99
+alice allen	65662	2.7
+alice allen	65670	2.88
+alice allen	65720	2.76
+PREHOOK: query: select s, i, round((avg(d) over  w1 + 10.0) - (avg(d) over w1 - 10.0),2) from over10k window w1 as (partition by s order by i) limit 7
+PREHOOK: type: QUERY
+PREHOOK: Input: default@over10k
+#### A masked pattern was here ####
+POSTHOOK: query: select s, i, round((avg(d) over  w1 + 10.0) - (avg(d) over w1 - 10.0),2) from over10k window w1 as (partition by s order by i) limit 7
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@over10k
+#### A masked pattern was here ####
+alice allen	65545	20.0
+alice allen	65557	20.0
+alice allen	65600	20.0
+alice allen	65609	20.0
+alice allen	65662	20.0
+alice allen	65670	20.0
+alice allen	65720	20.0
