diff --git a/bin/ext/cleardanglingscratchdir.cmd b/bin/ext/cleardanglingscratchdir.cmd
index 31104af4eb..1bb045328c 100644
--- a/bin/ext/cleardanglingscratchdir.cmd
+++ b/bin/ext/cleardanglingscratchdir.cmd
@@ -16,7 +16,6 @@
 
 set CLASS=org.apache.hadoop.hive.ql.session.ClearDanglingScratchDir
 set HIVE_OPTS=
-set HADOOP_CLASSPATH=
 
 pushd %HIVE_LIB%
 for /f %%a IN ('dir /b hive-exec-*.jar') do (
diff --git a/bin/hive.cmd b/bin/hive.cmd
index 9080796195..79d6d1b776 100644
--- a/bin/hive.cmd
+++ b/bin/hive.cmd
@@ -361,6 +361,9 @@ goto :EOF
 
 	set /a SERVICE_COUNT = %SERVICE_COUNT% + 1
 	set VAR%SERVICE_COUNT%=schematool
+
+        set /a SERVICE_COUNT = %SERVICE_COUNT% + 1
+        set VAR%SERVICE_COUNT%=cleardanglingscratchdir
 goto :EOF
 
 :AddToAuxParam
diff --git a/itests/hive-unit/src/test/java/org/apache/hadoop/hive/ql/session/TestClearDanglingScratchDir.java b/itests/hive-unit/src/test/java/org/apache/hadoop/hive/ql/session/TestClearDanglingScratchDir.java
index 3cb80a7533..185dbd57c2 100644
--- a/itests/hive-unit/src/test/java/org/apache/hadoop/hive/ql/session/TestClearDanglingScratchDir.java
+++ b/itests/hive-unit/src/test/java/org/apache/hadoop/hive/ql/session/TestClearDanglingScratchDir.java
@@ -28,6 +28,8 @@
 import org.apache.hadoop.fs.permission.FsPermission;
 import org.apache.hadoop.hdfs.MiniDFSCluster;
 import org.apache.hadoop.hive.conf.HiveConf;
+import org.apache.hadoop.hive.ql.WindowsPathUtil;
+import org.apache.hadoop.util.Shell;
 import org.junit.AfterClass;
 import org.junit.Assert;
 import org.junit.BeforeClass;
@@ -47,6 +49,9 @@ public class TestClearDanglingScratchDir {
   static public void oneTimeSetup() throws Exception {
     m_dfs = new MiniDFSCluster.Builder(new Configuration()).numDataNodes(1).format(true).build();
     conf = new HiveConf();
+    if (Shell.WINDOWS) {
+      WindowsPathUtil.convertPathsFromWindowsToHdfs(conf);
+    }
     conf.set(HiveConf.ConfVars.HIVE_SCRATCH_DIR_LOCK.toString(), "true");
     conf.set(HiveConf.ConfVars.METASTORE_AUTO_CREATE_ALL.toString(), "true");
     LoggerFactory.getLogger("SessionState");
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/session/ClearDanglingScratchDir.java b/ql/src/java/org/apache/hadoop/hive/ql/session/ClearDanglingScratchDir.java
index 85437686d5..ee012c2fea 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/session/ClearDanglingScratchDir.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/session/ClearDanglingScratchDir.java
@@ -25,6 +25,7 @@
 import org.apache.commons.cli.HelpFormatter;
 import org.apache.commons.cli.OptionBuilder;
 import org.apache.commons.cli.Options;
+import org.apache.hadoop.fs.FileAlreadyExistsException;
 import org.apache.hadoop.fs.FileStatus;
 import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
@@ -66,6 +67,7 @@ public static void main(String[] args) throws Exception {
 
     if (cli.hasOption("r")) {
       dryRun = true;
+      SessionState.getConsole().printInfo("dry-run mode on");
     }
 
     if (cli.hasOption("v")) {
@@ -99,24 +101,48 @@ public static void main(String[] args) throws Exception {
           }
           continue;
         }
+        boolean removable = false;
+        boolean inuse = false;
         try {
           IOUtils.closeStream(fs.append(lockFilePath));
-          scratchDirToRemove.add(scratchDir.getPath());
-        } catch (RemoteException e) {
+          removable = true;
+        } catch (RemoteException eAppend) {
           // RemoteException with AlreadyBeingCreatedException will be thrown
           // if the file is currently held by a writer
-          if(AlreadyBeingCreatedException.class.getName().equals(e.getClassName())){
-            // Cannot open the lock file for writing, must be held by a live process
-            String message = scratchDir.getPath() + " is being used by live process";
-            if (verbose) {
-              SessionState.getConsole().printInfo(message);
-            } else {
-              SessionState.getConsole().logInfo(message);
+          if(AlreadyBeingCreatedException.class.getName().equals(eAppend.getClassName())){
+            inuse = true;
+          } else if (UnsupportedOperationException.class.getName().equals(eAppend.getClassName())) {
+            // Append is not supported in the cluster, try to use create
+            try {
+              IOUtils.closeStream(fs.create(lockFilePath, false));
+            } catch (RemoteException eCreate) {
+              if (AlreadyBeingCreatedException.class.getName().equals(eCreate.getClassName())){
+                // If the file is held by a writer, will throw AlreadyBeingCreatedException
+                inuse = true;
+              }  else {
+                SessionState.getConsole().printInfo("Unexpected error:" + eCreate.getMessage());
+              }
+            } catch (FileAlreadyExistsException eCreateNormal) {
+                // Otherwise, throw FileAlreadyExistsException, which means the file owner is
+                // dead
+                removable = true;
             }
           } else {
-            throw e;
+            SessionState.getConsole().printInfo("Unexpected error:" + eAppend.getMessage());
           }
         }
+        if (inuse) {
+          // Cannot open the lock file for writing, must be held by a live process
+          String message = scratchDir.getPath() + " is being used by live process";
+          if (verbose) {
+            SessionState.getConsole().printInfo(message);
+          } else {
+            SessionState.getConsole().logInfo(message);
+          }
+        }
+        if (removable) {
+          scratchDirToRemove.add(scratchDir.getPath());
+        }
       }
     }
 
