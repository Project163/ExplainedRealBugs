diff --git a/lib/vagrant/util/is_port_open.rb b/lib/vagrant/util/is_port_open.rb
index a0a79b4f7..b51a01ecd 100644
--- a/lib/vagrant/util/is_port_open.rb
+++ b/lib/vagrant/util/is_port_open.rb
@@ -30,8 +30,7 @@ module Vagrant
           return true
         end
       rescue Timeout::Error, Errno::ECONNREFUSED, Errno::EHOSTUNREACH, \
-             Errno::ENETUNREACH, Errno::EACCES, Errno::ENOTCONN, \
-             Errno::EADDRNOTAVAIL
+             Errno::ENETUNREACH, Errno::EACCES, Errno::ENOTCONN
         # Any of the above exceptions signal that the port is closed.
         return false
       end
diff --git a/test/unit/vagrant/action/builtin/handle_forwarded_port_collisions_test.rb b/test/unit/vagrant/action/builtin/handle_forwarded_port_collisions_test.rb
index 8594413d9..865c35248 100644
--- a/test/unit/vagrant/action/builtin/handle_forwarded_port_collisions_test.rb
+++ b/test/unit/vagrant/action/builtin/handle_forwarded_port_collisions_test.rb
@@ -75,7 +75,8 @@ describe Vagrant::Action::Builtin::HandleForwardedPortCollisions do
       end
 
       it "should check if host port is in use" do
-        expect(instance).to receive(:is_forwarded_already).and_return false
+        expect(instance).to receive(:is_forwarded_already).and_return(false)
+        expect(instance).to receive(:is_port_open?).and_return(false)
         instance.call(env)
       end
 
@@ -148,7 +149,7 @@ describe Vagrant::Action::Builtin::HandleForwardedPortCollisions do
     let(:host_port){ 8080 }
 
     it "should check if the port is open" do
-      expect(instance).to receive(:is_port_open?).with(host_ip, host_port).and_return true
+      expect(instance).to receive(:is_port_open?).with(host_ip, host_port).and_return(true)
       instance.send(:port_check, host_ip, host_port)
     end
 
@@ -156,13 +157,13 @@ describe Vagrant::Action::Builtin::HandleForwardedPortCollisions do
       let(:host_ip){ nil }
 
       it "should set host_ip to 0.0.0.0 when unset" do
-        expect(instance).to receive(:is_port_open?).with("0.0.0.0", host_port).and_return true
+        expect(instance).to receive(:is_port_open?).with("0.0.0.0", host_port).and_return(true)
         instance.send(:port_check, host_ip, host_port)
       end
 
       it "should set host_ip to 127.0.0.1 when 0.0.0.0 is not available" do
-        expect(instance).to receive(:is_port_open?).with("0.0.0.0", host_port).and_raise Errno::EADDRNOTAVAIL
-        expect(instance).to receive(:is_port_open?).with("127.0.0.1", host_port).and_return true
+        expect(instance).to receive(:is_port_open?).with("0.0.0.0", host_port).and_raise(Errno::EADDRNOTAVAIL)
+        expect(instance).to receive(:is_port_open?).with("127.0.0.1", host_port).and_return(true)
         instance.send(:port_check, host_ip, host_port)
       end
     end
diff --git a/test/unit/vagrant/util/is_port_open_test.rb b/test/unit/vagrant/util/is_port_open_test.rb
index ea7042575..d931a8790 100644
--- a/test/unit/vagrant/util/is_port_open_test.rb
+++ b/test/unit/vagrant/util/is_port_open_test.rb
@@ -49,5 +49,15 @@ describe Vagrant::Util::IsPortOpen do
     # best, really.
     expect(klass.is_port_open?("127.0.0.1", closed_port)).not_to be
   end
+
+  it "should handle connection refused" do
+    expect(TCPSocket).to receive(:new).with("0.0.0.0", closed_port).and_raise(Errno::ECONNREFUSED)
+    expect(klass.is_port_open?("0.0.0.0", closed_port)).to be(false)
+  end
+
+  it "should raise an error if cannot assign requested address" do
+    expect(TCPSocket).to receive(:new).with("0.0.0.0", open_port).and_raise(Errno::EADDRNOTAVAIL)
+    expect { klass.is_port_open?("0.0.0.0", open_port) }.to raise_error(Errno::EADDRNOTAVAIL)
+  end
 end
 
