{"url":"https://api.github.com/repos/hashicorp/vagrant/issues/8639","repository_url":"https://api.github.com/repos/hashicorp/vagrant","labels_url":"https://api.github.com/repos/hashicorp/vagrant/issues/8639/labels{/name}","comments_url":"https://api.github.com/repos/hashicorp/vagrant/issues/8639/comments","events_url":"https://api.github.com/repos/hashicorp/vagrant/issues/8639/events","html_url":"https://github.com/hashicorp/vagrant/issues/8639","id":232955640,"node_id":"MDU6SXNzdWUyMzI5NTU2NDA=","number":8639,"title":"How can we support provisioning with reboots on Windows machines?","user":{"login":"dandunckelman","id":1153702,"node_id":"MDQ6VXNlcjExNTM3MDI=","avatar_url":"https://avatars.githubusercontent.com/u/1153702?v=4","gravatar_id":"","url":"https://api.github.com/users/dandunckelman","html_url":"https://github.com/dandunckelman","followers_url":"https://api.github.com/users/dandunckelman/followers","following_url":"https://api.github.com/users/dandunckelman/following{/other_user}","gists_url":"https://api.github.com/users/dandunckelman/gists{/gist_id}","starred_url":"https://api.github.com/users/dandunckelman/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandunckelman/subscriptions","organizations_url":"https://api.github.com/users/dandunckelman/orgs","repos_url":"https://api.github.com/users/dandunckelman/repos","events_url":"https://api.github.com/users/dandunckelman/events{/privacy}","received_events_url":"https://api.github.com/users/dandunckelman/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":218287562,"node_id":"MDU6TGFiZWwyMTgyODc1NjI=","url":"https://api.github.com/repos/hashicorp/vagrant/labels/guest/windows","name":"guest/windows","color":"5319e7","default":false,"description":null}],"state":"closed","locked":true,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2017-06-01T17:39:13Z","updated_at":"2020-03-28T02:05:03Z","closed_at":"2019-01-03T21:52:20Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### Summary\r\nI'd like to continue my discussion from these PRs:\r\n- https://github.com/mitchellh/vagrant/pull/6922\r\n- https://github.com/WinRb/WinRM/pull/262\r\n\r\nMy goal here is to have a discussion on our use-case (and hopefully hear other's use-cases similar to ours) and come to a conclusion on what would be the best approach/interface to this use-case.\r\n\r\ncc: @sneal @mwrock \r\n\r\nSome back story on our use-case:\r\n- We spin up a multi-machine environment with an Active Directory domain controller and other machines that join that domain as part of the provisioning process.\r\n- During the provisioning process where the nodes join the domain, a reboot is triggered (we don't have a way to delay or control this reboot)\r\n- After the reboot, we do further provisioning as a domain user\r\n  - For example:  installing/configuring SQL server\r\n\r\n### Vagrant version\r\nWe are pinned to v1.8.1 due to it being the last version to support \"retryable\" on winrm shell provisioning.\r\n\r\n### Host operating system\r\nUbuntu 16.04\r\n\r\n### Guest operating system\r\nWindows 2012 R2\r\n\r\n### Vagrantfile\r\n```ruby\r\n#!/bin/ruby\r\nrequire \"yaml\"\r\n\r\nyaml_security = YAML.load_file \"./secure.yaml\"\r\nyaml_defaults = YAML.load_file \"./defaults.yaml\"\r\nyaml_blueprint = YAML.load_file \"./blueprint.yaml\"\r\nyaml_build = YAML.load_file \"./build.yaml\"\r\n\r\npuppet_path = '/tmp/ta-puppet'\r\n\r\n\r\nyaml_blueprint[:blueprint][:vapp][:metadata] ||= []\r\nyaml_blueprint[:blueprint][:vapp][:metadata].push( [:blueprint, yaml_blueprint.to_yaml] )\r\n\r\nVagrant.configure('2') do |config|\r\n  config.ssh.insert_key = false\r\n  config.vm.network :forwarded_port, guest: 22, host: 2222, id: 'ssh', disabled: true\r\n  config.vm.network :forwarded_port, guest: 5985, host: 55985, id: 'winrm', disabled: true\r\n  config.vm.network :forwarded_port, guest: 5986, host: 55986, id: 'winrm-ssl', disabled: true\r\n  config.vm.synced_folder \".\", \"/vagrant\", disabled: true\r\n  config.vm.boot_timeout = 900\r\n\r\n  # vapp settings\r\n  config.vm.provider yaml_security[:provider].to_sym do |pro|\r\n    pro.hostname = yaml_security[:security][:apiurl]\r\n    pro.username = yaml_security[:security][:username]\r\n    pro.password = yaml_security[:security][:password]\r\n\r\n    pro.org_name = yaml_security[:security][:org]\r\n    pro.vdc_name = yaml_security[:security][:orgvdc]\r\n    pro.catalog_name = yaml_security[:security][:catalog]\r\n\r\n    pro.vapp_name = \"#{yaml_blueprint[:blueprint][:vapp][:name].downcase.gsub(/[^a-z0-9]/, '_')}-#{yaml_build[:suffix]}\"\r\n    pro.metadata_vapp = yaml_blueprint[:blueprint][:vapp][:metadata]\r\n\r\n    pro.advanced_network = true\r\n    nets = { org: yaml_blueprint[:blueprint][:vapp][:networks][:org], vapp: [] }\r\n    yaml_blueprint[:blueprint][:vapp][:networks][:vapp].each do |net|\r\n      n = { name: net[:name], ip_subnet: net[:ip_subnet] }\r\n      n[:gateway] = net[:gateway] if !net[:gateway].nil?\r\n\r\n      if !net[:dns1].nil? || !net[:dns2].nil?\r\n        n[:ip_dns] = []\r\n        n[:ip_dns].push(net[:dns1]) if !net[:dns1].nil?\r\n        n[:ip_dns].push(net[:dns2]) if !net[:dns2].nil?\r\n      end\r\n\r\n      if net[:dhcp_enabled] == true\r\n        n[:dhcp_enabled] = true\r\n        n[:pool_range] = [ net[:pool_start], net[:pool_end] ]\r\n        n[:dhcp_range] = [ net[:dhcp_start], net[:dhcp_end] ]\r\n      end\r\n\r\n      if net[:name] == 'Management'\r\n        n[:vdc_network_name] = 'Build Network'\r\n      end\r\n\r\n      nets[:vapp].push(n)\r\n    end\r\n\r\n    pro.networks = nets\r\n  end\r\n\r\n  #nodes\r\n  yaml_blueprint[:blueprint][:nodes].each do |yaml_node|\r\n    if yaml_node[:template]\r\n      yt = yaml_node[:template].split( '|' )\r\n      yt.push( 'master' ) if yt.length == 1\r\n      node_template = YAML.load_file( \"nodes/#{ yt.join( '-' ) }/node.yaml\" )\r\n      yaml_node = node_template[:node].merge( yaml_node )\r\n    end\r\n\r\n    node = yaml_defaults[:node_default].merge( yaml_node )\r\n    is_windows = !!node[:box].match( /windows/i )\r\n    is_puppet = !!node[:box].match( /puppet/i )\r\n    is_esx = !!node[:box].match( /esx/i )\r\n\r\n    config.vm.define node[:hostname], primary: node[:primary] do |node_config|\r\n      node_config.vm.box = node[:box]\r\n      node_config.vm.hostname = node[:hostname]\r\n      node_config.vm.box_url = node[:box_url]\r\n      node[:ssh_enabled] = false\r\n\r\n      if is_windows\r\n        node_config.vm.provision \"file\",\r\n                                 source: 'TechAccelerator.psm1',\r\n                                 destination: \"C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\Modules\\\\TechAccelerator\\\\TechAccelerator.psm1\"\r\n      end\r\n      if is_puppet\r\n        if is_windows\r\n          puppet_environments_dir = \"C:\\\\ProgramData\\\\PuppetLabs\\\\code\\\\environments\"\r\n\r\n          # ta_windows puppet module\r\n          node_config.vm.provision \"file\", source: \"ta_windows\", destination: \"C:\\\\ProgramData\\\\PuppetLabs\\\\puppet\\\\etc\\\\modules\\\\ta_windows\"\r\n          node_config.vm.provision \"shell\",\r\n            name: 'Copy \"ta_windows\" Puppet module to environments dir',\r\n            inline: \"cp -r C:\\\\ProgramData\\\\PuppetLabs\\\\puppet\\\\etc\\\\modules\\\\ta_windows #{puppet_environments_dir}\\\\production\\\\modules\\\\\"\r\n        else\r\n          puppet_environments_dir = \"/etc/puppetlabs/code/environments\"\r\n          node_config.vm.provision \"file\", source: \"ta_linux\", destination: \"/etc/puppet/modules/ta_linux\"\r\n          node_config.vm.provision \"shell\",\r\n            name: \"Create '#{puppet_environments_dir}/production/modules' dir\",\r\n            inline: \"mkdir -p #{puppet_environments_dir}/production/modules\"\r\n          node_config.vm.provision \"shell\",\r\n            name: 'Copy \"ta_windows\" Puppet module to environments dir',\r\n            inline: \"cp -r /etc/puppet/modules/ta_linux #{puppet_environments_dir}/production/modules\"\r\n        end\r\n\r\n        if is_windows\r\n          node_config.vm.provision \"shell\", name: 'Update Chocolatey config', inline: 'puppet apply -e \"include \\'ta_windows::choco\\'\"'\r\n        end\r\n\r\n        # copy puppet files over\r\n        node_config.vm.provision \"file\", source: \"puppet\", destination: puppet_path\r\n        node[:ssh_enabled] = true\r\n      end\r\n\r\n      # provisioners\r\n      if node_template\r\n        if !node[:provisioners]\r\n          node[:provisioners] = node_template[:node][:provisioners]\r\n        else\r\n          node_template[:node][:provisioners].each_with_index do |p, i|\r\n            node[:provisioners][i] = p.merge( node[:provisioners][i] )\r\n          end\r\n        end\r\n      end\r\n\r\n      ( node[:provisioners] ||= [] ).each_with_index do |p, i|\r\n        p = yaml_defaults[:provisioner_default].merge( p )\r\n        case p[:type]\r\n          when 'shell'\r\n            if p[:script_type] == 'script'\r\n              args = {\r\n                path: \"script/#{p[:script]}\",\r\n                name: p[:script],\r\n                privileged: ( p[:elevated] == '1' ),\r\n                powershell_elevated_interactive: ( p[:elevated_interactive] == '1' )\r\n              }\r\n\r\n              script = yaml_blueprint[:blueprint][:scripts][ p[:script] ]\r\n              args[:path] = script[:url] if script[:is_script] == '0'\r\n              args[:path] = script[:path] if script[:is_script] == '2'\r\n              args[:env] = p[:env] if !p[:env].empty?\r\n              args[:args] =  p[:args] if !p[:args].empty?\r\n              node_config.vm.provision \"shell\", args\r\n            elsif p[:script_type] == 'inline'\r\n              p[:inline].each do |il|\r\n                node_config.vm.provision \"shell\", inline: il\r\n              end\r\n            end\r\n          when 'puppet'\r\n            node_config.vm.provision \"puppet\" do |puppet|\r\n              puppet.environment = \"production\"\r\n              puppet.environment_path = [ :vm, puppet_environments_dir ]\r\n              puppet.facter = p[:facter]\r\n              puppet.hiera_config_path = \"/var/builder/vagrant/hiera.yaml\"\r\n              puppet.manifest_file = p[:manifest]\r\n              puppet.manifests_path = [ :vm , \"#{puppet_path}/manifests/\" ]\r\n              puppet.options = \"--verbose\"\r\n              puppet.temp_dir = \"#{puppet_path}\"\r\n            end\r\n          when 'file'\r\n            node_config.vm.provision \"file\",\r\n              source: p[:local],\r\n              destination: \"#{p[:dest]}#{p[:name]}\"\r\n        end\r\n\r\n        node[:ssh_enabled] = true\r\n      end\r\n\r\n      if is_windows && node[:ssh_enabled]\r\n        node_config.vm.provision \"shell\", name: \"Update path\", inline: '$env:Path = [System.Environment]::GetEnvironmentVariable(\"Path\",\"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\",\"User\")'\r\n      end\r\n\r\n      # vcloud stuff\r\n      node_config.vm.provider yaml_security[:provider].to_sym do |pro|\r\n        pro.catalog_name = node[:catalog] if node[:catalog]\r\n        pro.memory = node[:memory]\r\n        pro.cpus = node[:cpus]\r\n        pro.add_hdds = node[:add_hdds]\r\n        pro.ssh_enabled = node[:ssh_enabled]\r\n        pro.sync_enabled = node[:sync_enabled]\r\n        pro.power_on = node[:power_on]\r\n        pro.metadata_vm = node[:metadata] if node[:metadata]\r\n        pro.nested_hypervisor = node[:nested_hypervisor]\r\n        pro.enable_guest_customization = node[:enable_guest_customization]\r\n\r\n        if node[:agc_enabled]\r\n          pro.guest_customization_change_sid = node[:agc_sid] if is_windows\r\n          pro.guest_customization_admin_password_reset = node[:agc_change_pass]\r\n\r\n          if is_windows && node[:agc_join_domain]\r\n            pro.guest_customization_join_domain = true\r\n            pro.guest_customization_change_sid = true\r\n            pro.guest_customization_domain_name = node[:agc_domain_name]\r\n            pro.guest_customization_domain_user_name = node[:agc_domain_user]\r\n            pro.guest_customization_domain_user_password = node[:agc_domain_pass]\r\n            pro.guest_customization_domain_ou = node[:agc_domain_ou] if !node[:agc_domain_ou].empty?\r\n          end\r\n\r\n          if is_windows && node[:agc_auto_login]\r\n            pro.guest_customization_admin_password_enabled = true\r\n            pro.guest_customization_admin_password = node[:os_password]\r\n            pro.guest_customization_admin_auto_login = true\r\n            pro.guest_customization_admin_auto_login_count = node[:agc_auto_login_count]\r\n          end\r\n        end\r\n\r\n        if node[:ovf_properties]\r\n          pro.ovf_properties = node[:ovf_properties]\r\n        end\r\n\r\n        if pro.enable_guest_customization\r\n          if is_windows\r\n            pro.guest_customization_script = %Q(\r\nif \"%1%\" == \"precustomization\" (\\r\r\necho Started precustomization: %DATE% %TIME%\\r\r\nnet stop winrm\\r\r\n#{node[:agc_pre_script]}\\r\r\necho Completed precustomization: %DATE% %TIME%\\r\r\n) else if \"%1%\" == \"postcustomization\" (\\r\r\necho Started postcustomization: %DATE% %TIME%\\r\r\n#{node[:agc_post_script]}\\r\r\necho Completed postcustomization: %DATE% %TIME%\\r\r\n)\\r\r\n\\r\r\n)\r\n          else\r\n              pro.guest_customization_script = %Q(\r\nif [ $1 = precustomization ]; then\r\necho \"Started precustomization: $(date)\"\r\n#{node[:agc_pre_script]}\r\necho \"Completed precustomization: $(date)\"\r\nelif [ $1 = postcustomization ]; then\r\necho \"Started postcustomization: $(date)\"\r\n#{node[:agc_post_script]}\r\necho \"Completed postcustomization: $(date)\"\r\nfi\r\n\r\n)\r\n          end\r\n        end\r\n\r\n        nic_out = []\r\n\r\n        node[:nics].each_with_index do |yaml_nic, i|\r\n          if node_template\r\n            if node_template[:node][:nics]\r\n              if node_template[:node][:nics][ i ]\r\n                yaml_nic = node_template[:node][:nics][ i ].merge( yaml_nic )\r\n              end\r\n            end\r\n          end\r\n\r\n          compiled_nic = yaml_defaults[:nic_default].merge( yaml_nic )\r\n          nic = { type: compiled_nic[:type],\r\n                  connected: compiled_nic[:connected],\r\n                  network: compiled_nic[:network],\r\n                  primary: compiled_nic[:primary],\r\n                  ip_mode: compiled_nic[:ip_mode],\r\n                  ip: compiled_nic[:ip],\r\n                  mac: compiled_nic[:mac]\r\n                }\r\n\r\n          if node[:ssh_enabled] && compiled_nic[:network] == 'Management' && compiled_nic[:primary]\r\n            if is_windows\r\n              nic[:forwarded_port] = [ { guest: 5985, host: 55985, auto_correct: true, vmnic_id: i } ]\r\n            else\r\n              nic[:forwarded_port] = [ { guest: 22, host: 2222, auto_correct: true, vmnic_id: i } ]\r\n            end\r\n          end\r\n\r\n          nic_out.push( nic )\r\n        end\r\n\r\n        pro.nics = nic_out\r\n      end\r\n\r\n      if is_windows\r\n        node_config.winrm.username = node[:os_username]\r\n        node_config.winrm.password = node[:os_password]\r\n        node_config.winrm.retry_delay = 15\r\n        node_config.vm.guest = :windows\r\n        node_config.vm.communicator = :winrm\r\n      else\r\n        node_config.ssh.username = node[:os_username]\r\n        node_config.ssh.password = node[:os_password]\r\n        node_config.ssh.shell = 'sh' if is_esx\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n### Debug output\r\nSee my comments from the aforementioned PRs:\r\n- https://github.com/mitchellh/vagrant/pull/6922#issuecomment-293741172\r\n- https://github.com/WinRb/WinRM/pull/262#issuecomment-297557669\r\n- https://github.com/WinRb/WinRM/pull/262#issuecomment-301892030\r\n\r\n### Expected behavior\r\nIdeally, provisioning could continue where it left off after a guest reboots.\r\n\r\nCould we add an option to the winrm shell to specify that we want to use `retryable` (by default, it isn't used)?\r\n- Reference:  https://github.com/mitchellh/vagrant/pull/6922/files#diff-2e2f3d17c9aa332b915aef891a03b55bL95\r\n\r\n### Actual behavior\r\nBecause a reboot clears the shells, when retrying on a specific shell ID, it fails.\r\n- See discussion in PRs mentioned at the top of this issue.\r\n\r\n### References\r\nAre there any other GitHub issues (open or closed) that should be linked here?\r\n- https://github.com/mitchellh/vagrant/pull/6922\r\n- https://github.com/WinRb/WinRM/pull/262","closed_by":{"login":"chrisroberts","id":266674,"node_id":"MDQ6VXNlcjI2NjY3NA==","avatar_url":"https://avatars.githubusercontent.com/u/266674?v=4","gravatar_id":"","url":"https://api.github.com/users/chrisroberts","html_url":"https://github.com/chrisroberts","followers_url":"https://api.github.com/users/chrisroberts/followers","following_url":"https://api.github.com/users/chrisroberts/following{/other_user}","gists_url":"https://api.github.com/users/chrisroberts/gists{/gist_id}","starred_url":"https://api.github.com/users/chrisroberts/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chrisroberts/subscriptions","organizations_url":"https://api.github.com/users/chrisroberts/orgs","repos_url":"https://api.github.com/users/chrisroberts/repos","events_url":"https://api.github.com/users/chrisroberts/events{/privacy}","received_events_url":"https://api.github.com/users/chrisroberts/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/hashicorp/vagrant/issues/8639/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hashicorp/vagrant/issues/8639/timeline","performed_via_github_app":null,"state_reason":"completed"}