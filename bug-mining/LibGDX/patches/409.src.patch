diff --git a/CHANGES b/CHANGES
index a6341a421..197c88cc5 100755
--- a/CHANGES
+++ b/CHANGES
@@ -5,6 +5,7 @@
 - API addition: ProgressBar.isVertical() - returns whether a progress bar is vertical or horizontal.
 - API Change: SplitPane now by default does not allow the split amount to shrink children below their minimum sizes (cropping them). This behavior can be reverted by overriding clampSplitAmount or wrapping the children in Containers set to minSize(0) and fill(). SplitPane also now correctly includes the handle min size in its own min size calculations.
 - API Change: SplitPane.getSplit() renamed to SplitPane.getSplitAmount() to match other getter and setter names.
+- Improved internal Timer synchronization.
 
 [1.9.6]
 - Fix performance regression in LWJGL3 backend, use java.nio instead of BufferUtils. Those are intrinsics and quite a bit faster than BufferUtils on HotSpot.
diff --git a/gdx/src/com/badlogic/gdx/utils/Timer.java b/gdx/src/com/badlogic/gdx/utils/Timer.java
index 7a14b2260..e5605e53a 100644
--- a/gdx/src/com/badlogic/gdx/utils/Timer.java
+++ b/gdx/src/com/badlogic/gdx/utils/Timer.java
@@ -24,19 +24,33 @@ import com.badlogic.gdx.LifecycleListener;
 /** Executes tasks in the future on the main loop thread.
  * @author Nathan Sweet */
 public class Timer {
-	static final Array<Timer> instances = new Array(1);
-	static TimerThread thread;
-	static private final int CANCELLED = -1;
-	static private final int FOREVER = -2;
+	static private final int CANCELLED = -1, FOREVER = -2;
+
+	// TimerThread access is synchronized using threadLock.
+	// Timer access is synchronized using the Timer instance.
+	// Task access is synchronized using the Task instance.
 
-	/** Timer instance for general application wide usage. Static methods on {@link Timer} make convenient use of this instance. */
-	static Timer instance = new Timer();
+	static final Object threadLock = new Object();
+	static TimerThread thread;
 
+	/** Timer instance singleton for general application wide usage. Static methods on {@link Timer} make convenient use of this
+	 * instance. */
 	static public Timer instance () {
-		if (instance == null) {
-			instance = new Timer();
+		synchronized (threadLock) {
+			TimerThread thread = thread();
+			if (thread.instance == null) thread.instance = new Timer();
+			return thread.instance;
+		}
+	}
+
+	static private TimerThread thread () {
+		synchronized (threadLock) {
+			if (thread == null || thread.files != Gdx.files) {
+				if (thread != null) thread.dispose();
+				thread = new TimerThread();
+			}
+			return thread;
 		}
-		return instance;
 	}
 
 	private final Array<Task> tasks = new Array(false, 8);
@@ -72,67 +86,63 @@ public class Timer {
 		synchronized (this) {
 			tasks.add(task);
 		}
-		wake();
-
+		synchronized (threadLock) {
+			threadLock.notifyAll();
+		}
 		return task;
 	}
 
 	/** Stops the timer, tasks will not be executed and time that passes will not be applied to the task delays. */
 	public void stop () {
-		synchronized (instances) {
-			instances.removeValue(this, true);
+		synchronized (threadLock) {
+			thread().instances.removeValue(this, true);
 		}
 	}
 
 	/** Starts the timer if it was stopped. */
 	public void start () {
-		synchronized (instances) {
+		synchronized (threadLock) {
+			TimerThread thread = thread();
+			Array<Timer> instances = thread.instances;
 			if (instances.contains(this, true)) return;
 			instances.add(this);
-			if (thread == null) thread = new TimerThread();
-			wake();
+			threadLock.notifyAll();
 		}
 	}
 
 	/** Cancels all tasks. */
-	public void clear () {
-		synchronized (this) {
-			for (int i = 0, n = tasks.size; i < n; i++)
-				tasks.get(i).cancel();
-			tasks.clear();
-		}
+	public synchronized void clear () {
+		for (int i = 0, n = tasks.size; i < n; i++)
+			tasks.get(i).cancel();
+		tasks.clear();
 	}
 
 	/** Returns true if the timer has no tasks in the queue. Note that this can change at any time. Synchronize on the timer
 	 * instance to prevent tasks being added, removed, or updated. */
-	public boolean isEmpty () {
-		synchronized (this) {
-			return tasks.size == 0;
-		}
+	public synchronized boolean isEmpty () {
+		return tasks.size == 0;
 	}
 
-	long update (long timeMillis, long waitMillis) {
-		synchronized (this) {
-			for (int i = 0, n = tasks.size; i < n; i++) {
-				Task task = tasks.get(i);
-				synchronized (task) {
-					if (task.executeTimeMillis > timeMillis) {
-						waitMillis = Math.min(waitMillis, task.executeTimeMillis - timeMillis);
-						continue;
-					}
-					if (task.repeatCount != CANCELLED) {
-						if (task.repeatCount == 0) task.repeatCount = CANCELLED;
-						task.app.postRunnable(task);
-					}
-					if (task.repeatCount == CANCELLED) {
-						tasks.removeIndex(i);
-						i--;
-						n--;
-					} else {
-						task.executeTimeMillis = timeMillis + task.intervalMillis;
-						waitMillis = Math.min(waitMillis, task.intervalMillis);
-						if (task.repeatCount > 0) task.repeatCount--;
-					}
+	synchronized long update (long timeMillis, long waitMillis) {
+		for (int i = 0, n = tasks.size; i < n; i++) {
+			Task task = tasks.get(i);
+			synchronized (task) {
+				if (task.executeTimeMillis > timeMillis) {
+					waitMillis = Math.min(waitMillis, task.executeTimeMillis - timeMillis);
+					continue;
+				}
+				if (task.repeatCount != CANCELLED) {
+					if (task.repeatCount == 0) task.repeatCount = CANCELLED;
+					task.app.postRunnable(task);
+				}
+				if (task.repeatCount == CANCELLED) {
+					tasks.removeIndex(i);
+					i--;
+					n--;
+				} else {
+					task.executeTimeMillis = timeMillis + task.intervalMillis;
+					waitMillis = Math.min(waitMillis, task.intervalMillis);
+					if (task.repeatCount > 0) task.repeatCount--;
 				}
 			}
 		}
@@ -140,23 +150,15 @@ public class Timer {
 	}
 
 	/** Adds the specified delay to all tasks. */
-	public void delay (long delayMillis) {
-		synchronized (this) {
-			for (int i = 0, n = tasks.size; i < n; i++) {
-				Task task = tasks.get(i);
-				synchronized (task) {
-					task.executeTimeMillis += delayMillis;
-				}
+	public synchronized void delay (long delayMillis) {
+		for (int i = 0, n = tasks.size; i < n; i++) {
+			Task task = tasks.get(i);
+			synchronized (task) {
+				task.executeTimeMillis += delayMillis;
 			}
 		}
 	}
 
-	static void wake () {
-		synchronized (instances) {
-			instances.notifyAll();
-		}
-	}
-
 	/** Schedules a task on {@link #instance}.
 	 * @see #postTask(Task) */
 	static public Task post (Task task) {
@@ -181,17 +183,15 @@ public class Timer {
 		return instance().scheduleTask(task, delaySeconds, intervalSeconds, repeatCount);
 	}
 
-	/** Runnable with a cancel method.
-	 * @see Timer
+	/** Runnable that can be scheduled on a {@link Timer}.
 	 * @author Nathan Sweet */
 	static abstract public class Task implements Runnable {
-		long executeTimeMillis;
-		long intervalMillis;
+		final Application app;
+		long executeTimeMillis, intervalMillis;
 		int repeatCount = CANCELLED;
-		Application app;
 
 		public Task () {
-			app = Gdx.app; // Need to store the app when the task was created for multiple LwjglAWTCanvas.
+			app = Gdx.app; // Store which app to postRunnable (eg for multiple LwjglAWTCanvas).
 			if (app == null) throw new IllegalStateException("Gdx.app not available.");
 		}
 
@@ -205,9 +205,9 @@ public class Timer {
 			repeatCount = CANCELLED;
 		}
 
-		/** Returns true if this task is scheduled to be executed in the future by a timer. The execution time may be reached after
-		 * calling this method which may change the scheduled state. To prevent the scheduled state from changing, synchronize on
-		 * this task object, eg:
+		/** Returns true if this task is scheduled to be executed in the future by a timer. The execution time may be reached at any
+		 * time after calling this method, which may change the scheduled state. To prevent the scheduled state from changing,
+		 * synchronize on this task object, eg:
 		 * 
 		 * <pre>
 		 * synchronized (task) {
@@ -219,76 +219,82 @@ public class Timer {
 			return repeatCount != CANCELLED;
 		}
 
-		/** Returns the time when this task will be executed in milliseconds */
+		/** Returns the time in milliseconds when this task will be executed next. */
 		public synchronized long getExecuteTimeMillis () {
 			return executeTimeMillis;
 		}
 	}
 
-	/** Manages the single timer thread. Stops thread on libgdx application pause and dispose, starts thread on resume.
+	/** Manages a single thread for updating timers. Uses libgdx application events to pause, resume, and dispose the thread.
 	 * @author Nathan Sweet */
 	static class TimerThread implements Runnable, LifecycleListener {
-		Files files;
+		final Files files;
+		final Array<Timer> instances = new Array(1);
+		Timer instance;
 		private long pauseMillis;
 
 		public TimerThread () {
+			files = Gdx.files;
 			Gdx.app.addLifecycleListener(this);
 			resume();
+
+			Thread thread = new Thread(this, "Timer");
+			thread.setDaemon(true);
+			thread.start();
 		}
 
 		public void run () {
 			while (true) {
-				synchronized (instances) {
-					if (files != Gdx.files) return;
+				synchronized (threadLock) {
+					if (thread != this || files != Gdx.files) break;
 
-					long timeMillis = System.nanoTime() / 1000000;
 					long waitMillis = 5000;
-					for (int i = 0, n = instances.size; i < n; i++) {
-						try {
-							waitMillis = instances.get(i).update(timeMillis, waitMillis);
-						} catch (Throwable ex) {
-							throw new GdxRuntimeException("Task failed: " + instances.get(i).getClass().getName(), ex);
+					if (pauseMillis == 0) {
+						long timeMillis = System.nanoTime() / 1000000;
+						for (int i = 0, n = instances.size; i < n; i++) {
+							try {
+								waitMillis = instances.get(i).update(timeMillis, waitMillis);
+							} catch (Throwable ex) {
+								throw new GdxRuntimeException("Task failed: " + instances.get(i).getClass().getName(), ex);
+							}
 						}
 					}
 
-					if (files != Gdx.files) return;
+					if (thread != this || files != Gdx.files) break;
 
 					try {
-						if (waitMillis > 0) instances.wait(waitMillis);
+						if (waitMillis > 0) threadLock.wait(waitMillis);
 					} catch (InterruptedException ignored) {
 					}
 				}
 			}
+			dispose();
 		}
 
 		public void resume () {
-			long delayMillis = System.nanoTime() / 1000000 - pauseMillis;
-			synchronized (instances) {
-				for (int i = 0, n = instances.size; i < n; i++) {
+			synchronized (threadLock) {
+				long delayMillis = System.nanoTime() / 1000000 - pauseMillis;
+				for (int i = 0, n = instances.size; i < n; i++)
 					instances.get(i).delay(delayMillis);
-				}
+				pauseMillis = 0;
+				threadLock.notifyAll();
 			}
-			files = Gdx.files;
-			Thread t = new Thread(this, "Timer");
-			t.setDaemon(true);
-			t.start();
-			thread = this;
 		}
 
 		public void pause () {
-			pauseMillis = System.nanoTime() / 1000000;
-			synchronized (instances) {
-				files = null;
-				wake();
+			synchronized (threadLock) {
+				pauseMillis = System.nanoTime() / 1000000;
+				threadLock.notifyAll();
 			}
-			thread = null;
 		}
 
-		public void dispose () {
-			pause();
+		public void dispose () { // OK to call multiple times.
+			synchronized (threadLock) {
+				if (thread == this) thread = null;
+				instances.clear();
+				threadLock.notifyAll();
+			}
 			Gdx.app.removeLifecycleListener(this);
-			instances.clear();
-			instance = null;
 		}
 	}
 }
