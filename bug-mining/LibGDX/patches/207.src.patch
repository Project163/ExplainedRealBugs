diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
index db8ada012..ee2d0cb39 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
@@ -16,11 +16,13 @@
 
 package com.badlogic.gdx.graphics.g2d;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
+import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.IntArray;
 import com.badlogic.gdx.utils.NumberUtils;
 
@@ -336,18 +338,21 @@ public class BitmapFontCache {
 	/** Counts the actual glyphs excluding characters used to markup the text. */
 	private int countGlyphs (CharSequence seq, int start, int end) {
 		int count = end - start;
-		while (start < end) {
-			char ch = seq.charAt(start++);
-			if (ch == '[') {
-				count--;
-				if (!(start < end && seq.charAt(start) == '[')) { // non escaped '['
-					while (start < end && seq.charAt(start) != ']') {
+		if (font.markupEnabled) {
+			while (start < end) {
+				char ch = seq.charAt(start++);
+				if (ch == '[') {
+					if (start < end && seq.charAt(start) == '[') { // escaped '['
 						start++;
 						count--;
+					} else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(seq, -1, start, end);
+						if (colorTagLen >= 0) {
+							start += colorTagLen + 1;
+							count -= colorTagLen + 2;
+						}
 					}
-					count--;
 				}
-				start++;
 			}
 		}
 		return count;
@@ -356,7 +361,7 @@ public class BitmapFontCache {
 	private void requireSequence (CharSequence seq, int start, int end) {
 		if (vertexData.length == 1) {
 			// don't scan sequence if we just have one page and markup is disabled
-			int newGlyphCount = font.markupEnabled ? countGlyphs(seq, start, end) : end - start;
+			int newGlyphCount = countGlyphs(seq, start, end);
 			require(0, newGlyphCount);
 		} else {
 			for (int i = 0, n = tmpGlyphCount.length; i < n; i++)
@@ -367,10 +372,11 @@ public class BitmapFontCache {
 				char ch = seq.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
 					if (!(start < end && seq.charAt(start) == '[')) { // non escaped '['
-						while (start < end && seq.charAt(start) != ']')
-							start++;
-						start++;
-						continue;
+						int colorTagLen = markup.parseColorTag(seq, -1, start, end);
+						if (colorTagLen >= 0) {
+							start += colorTagLen + 1;
+							continue;
+						}
 					}
 					start++;
 				}
@@ -411,12 +417,16 @@ public class BitmapFontCache {
 			while (start < end) {
 				char ch = str.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
-					if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
-						start += TextMarkup.parseColorTag(markup, str, charsCount, start, end) + 1;
-						color = markup.getLastColor().toFloatBits();
-						continue;
+					if (start < end && str.charAt(start) == '[') // escaped '['
+						start++;
+					else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
+						if (colorTagLen >= 0) {
+							color = markup.getLastColor().toFloatBits();
+							start += colorTagLen + 1;
+							continue;
+						}
 					}
-					start++;
 				}
 				lastGlyph = data.getGlyph(ch);
 				if (lastGlyph != null) {
@@ -428,12 +438,16 @@ public class BitmapFontCache {
 			while (start < end) {
 				char ch = str.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
-					if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
-						start += TextMarkup.parseColorTag(markup, str, charsCount, start, end) + 1;
-						color = markup.getLastColor().toFloatBits();
-						continue;
+					if (start < end && str.charAt(start) == '[') // escaped '['
+						start++;
+					else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
+						if (colorTagLen >= 0) {
+							color = markup.getLastColor().toFloatBits();
+							start += colorTagLen + 1;
+							continue;
+						}
 					}
-					start++;
 				}
 				Glyph g = data.getGlyph(ch);
 				if (g != null) {
@@ -448,12 +462,16 @@ public class BitmapFontCache {
 			while (start < end) {
 				char ch = str.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
-					if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
-						start += TextMarkup.parseColorTag(markup, str, charsCount, start, end) + 1;
-						color = markup.getLastColor().toFloatBits();
-						continue;
+					if (start < end && str.charAt(start) == '[') // escaped '['
+						start++;
+					else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
+						if (colorTagLen >= 0) {
+							color = markup.getLastColor().toFloatBits();
+							start += colorTagLen + 1;
+							continue;
+						}
 					}
-					start++;
 				}
 				lastGlyph = data.getGlyph(ch);
 				if (lastGlyph != null) {
@@ -469,12 +487,16 @@ public class BitmapFontCache {
 			while (start < end) {
 				char ch = str.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
-					if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
-						start += TextMarkup.parseColorTag(markup, str, charsCount, start, end) + 1;
-						color = markup.getLastColor().toFloatBits();
-						continue;
+					if (start < end && str.charAt(start) == '[') // escaped '['
+						start++;
+					else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
+						if (colorTagLen >= 0) {
+							color = markup.getLastColor().toFloatBits();
+							start += colorTagLen + 1;
+							continue;
+						}
 					}
-					start++;
 				}
 				Glyph g = data.getGlyph(ch);
 				if (g != null) {
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java b/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java
index 23562ed95..31b7d7dae 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java
@@ -32,9 +32,16 @@ import com.badlogic.gdx.utils.StringBuilder;
  * @author Alexander Dorokhov */
 class TextMarkup {
 	private static final Color tempColor = new Color();
-	private static final com.badlogic.gdx.utils.StringBuilder tempColorBuffer = new StringBuilder();
+	private static final StringBuilder tempColorBuffer = new StringBuilder();
 
-	public static int parseColorTag (TextMarkup markup, CharSequence str, int nomarkupStart, int start, int end) {
+	/** Parses a color tag.
+	 * @param str the input string
+	 * @param nomarkupStart the index of the string, excluding characters used to markup the text, where color info will be added.
+	 *           if it's negative color info is not set.
+	 * @param start the begin index
+	 * @param end the end index
+	 * @return the number of characters in the tag; {@code -1} in case of unknown color. */
+	public int parseColorTag (CharSequence str, int nomarkupStart, int start, int end) {
 		if (start < end) {
 			final Color hexColor = tempColor;
 			if (str.charAt(start) == '#') {
@@ -43,15 +50,14 @@ class TextMarkup {
 				for (int i = start + 1; i < end; i++) {
 					char ch = str.charAt(i);
 					if (ch == ']') {
-						if (i < start + 2 || i > start + 9)
-							throw new GdxRuntimeException("Hex color cannot have " + (i - start - 1) + " digits.");
+						if (i < start + 2 || i > start + 9) return -1; // Illegal number of hex digits
 						if (i <= start + 7) { // RRGGBB
 							Color.rgb888ToColor(hexColor, colorInt);
 							hexColor.a = 1f;
 						} else { // RRGGBBAA
 							Color.rgba8888ToColor(hexColor, colorInt);
 						}
-						markup.beginChunk(hexColor, nomarkupStart);
+						if (nomarkupStart >= 0) beginChunk(hexColor, nomarkupStart);
 						return i - start;
 					}
 					if (ch >= '0' && ch <= '9')
@@ -61,7 +67,7 @@ class TextMarkup {
 					else if (ch >= 'A' && ch <= 'F')
 						colorInt = colorInt * 16 + (ch - ('A' - 10));
 					else
-						throw new GdxRuntimeException("Unexpected character in hex color: " + ch);
+						return -1; // Unexpected character in hex color
 				}
 			} else {
 				// Parse named color
@@ -69,13 +75,13 @@ class TextMarkup {
 				for (int i = start; i < end; i++) {
 					char ch = str.charAt(i);
 					if (ch == ']') {
-						if (tempColorBuffer.length() == 0) { // end tag []
-							markup.endChunk(nomarkupStart);
+						if (i == start) { // end tag []
+							if (nomarkupStart >= 0) endChunk(nomarkupStart);
 						} else {
 							String colorString = tempColorBuffer.toString();
 							Color newColor = Colors.get(colorString);
-							if (newColor == null) throw new GdxRuntimeException("Unknown color: " + colorString);
-							markup.beginChunk(newColor, nomarkupStart);
+							if (newColor == null) return -1; // Unknown color
+							if (nomarkupStart >= 0) beginChunk(newColor, nomarkupStart);
 						}
 						return i - start;
 					} else {
@@ -84,19 +90,19 @@ class TextMarkup {
 				}
 			}
 		}
-		throw new GdxRuntimeException("Unclosed color tag.");
+		return -1; // Unclosed color tag
 	}
 
 	private static Pool<ColorChunk> colorChunkPool;
 	private static Application app = null;
-	
+
 	private Array<ColorChunk> colorChunks = new Array<ColorChunk>();
 	private Array<Color> currentColorStack = new Array<Color>();
 	private Color lastColor = Color.WHITE;
 	private Color defaultColor = Color.WHITE;
-	
-	public TextMarkup() {
-		if(Gdx.app != app) {
+
+	public TextMarkup () {
+		if (Gdx.app != app) {
 			colorChunkPool = new Pool<ColorChunk>(32) {
 				protected ColorChunk newObject () {
 					return new ColorChunk();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
index 7c6a7872b..11c49099f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
@@ -62,9 +62,9 @@ public class BitmapFontTest extends GdxTest {
 
 		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations.
 		// They are silently ignored, as expected.
-		Label label = new Label("<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][]>>", skin);
+		Label label = new Label("<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][] [Unknown Color]>>", skin);
 
-		label.setPosition(200, 200);
+		label.setPosition(100, 200);
 		stage.addActor(label);
 
 		Window window = new Window("[RED]Multicolor[GREEN] Title", skin);
