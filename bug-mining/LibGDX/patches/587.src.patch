diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java
index c5167a729..7f3c802a0 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java
@@ -308,6 +308,9 @@ public abstract class BaseTmxMapLoader<P extends BaseTmxMapLoader.Parameters> ex
 			}
 			if (flipY) y = mapHeightInPixels - y;
 
+			boolean repeatX = element.getIntAttribute("repeatx", 0) == 1;
+			boolean repeatY = element.getIntAttribute("repeaty", 0) == 1;
+
 			TextureRegion texture = null;
 
 			Element image = element.getChildByName("image");
@@ -319,7 +322,7 @@ public abstract class BaseTmxMapLoader<P extends BaseTmxMapLoader.Parameters> ex
 				y -= texture.getRegionHeight();
 			}
 
-			TiledMapImageLayer layer = new TiledMapImageLayer(texture, x, y);
+			TiledMapImageLayer layer = new TiledMapImageLayer(texture, x, y, repeatX, repeatY);
 
 			loadBasicLayerInfo(layer, element);
 
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapImageLayer.java b/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapImageLayer.java
index 666128432..37cac3bff 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapImageLayer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapImageLayer.java
@@ -25,11 +25,15 @@ public class TiledMapImageLayer extends MapLayer {
 
 	private float x;
 	private float y;
+	private boolean repeatX;
+	private boolean repeatY;
 
-	public TiledMapImageLayer (TextureRegion region, float x, float y) {
+	public TiledMapImageLayer (TextureRegion region, float x, float y, boolean repeatX, boolean repeatY) {
 		this.region = region;
 		this.x = x;
 		this.y = y;
+		this.repeatX = repeatX;
+		this.repeatY = repeatY;
 	}
 
 	public TextureRegion getTextureRegion () {
@@ -56,4 +60,20 @@ public class TiledMapImageLayer extends MapLayer {
 		this.y = y;
 	}
 
+	public boolean isRepeatX () {
+		return repeatX;
+	}
+
+	public void setRepeatX (boolean repeatX) {
+		this.repeatX = repeatX;
+	}
+
+	public boolean isRepeatY () {
+		return repeatY;
+	}
+
+	public void setRepeatY (boolean repeatY) {
+		this.repeatY = repeatY;
+	}
+
 }
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java
index 61db92e4a..3211d84a2 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java
@@ -66,6 +66,7 @@ public abstract class BatchTiledMapRenderer implements TiledMapRenderer, Disposa
 
 	protected Rectangle viewBounds;
 	protected Rectangle imageBounds = new Rectangle();
+	protected Rectangle repeatedImageBounds = new Rectangle();
 
 	protected boolean ownsBatch;
 
@@ -204,37 +205,107 @@ public abstract class BatchTiledMapRenderer implements TiledMapRenderer, Disposa
 
 		imageBounds.set(x1, y1, x2 - x1, y2 - y1);
 
-		if (viewBounds.contains(imageBounds) || viewBounds.overlaps(imageBounds)) {
-			final float u1 = region.getU();
-			final float v1 = region.getV2();
-			final float u2 = region.getU2();
-			final float v2 = region.getV();
-
-			vertices[X1] = x1;
-			vertices[Y1] = y1;
-			vertices[C1] = color;
-			vertices[U1] = u1;
-			vertices[V1] = v1;
-
-			vertices[X2] = x1;
-			vertices[Y2] = y2;
-			vertices[C2] = color;
-			vertices[U2] = u1;
-			vertices[V2] = v2;
-
-			vertices[X3] = x2;
-			vertices[Y3] = y2;
-			vertices[C3] = color;
-			vertices[U3] = u2;
-			vertices[V3] = v2;
-
-			vertices[X4] = x2;
-			vertices[Y4] = y1;
-			vertices[C4] = color;
-			vertices[U4] = u2;
-			vertices[V4] = v1;
-
-			batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+		if (!layer.isRepeatX() && !layer.isRepeatY()) {
+			if (viewBounds.contains(imageBounds) || viewBounds.overlaps(imageBounds)) {
+				final float u1 = region.getU();
+				final float v1 = region.getV2();
+				final float u2 = region.getU2();
+				final float v2 = region.getV();
+
+				vertices[X1] = x1;
+				vertices[Y1] = y1;
+				vertices[C1] = color;
+				vertices[U1] = u1;
+				vertices[V1] = v1;
+
+				vertices[X2] = x1;
+				vertices[Y2] = y2;
+				vertices[C2] = color;
+				vertices[U2] = u1;
+				vertices[V2] = v2;
+
+				vertices[X3] = x2;
+				vertices[Y3] = y2;
+				vertices[C3] = color;
+				vertices[U3] = u2;
+				vertices[V3] = v2;
+
+				vertices[X4] = x2;
+				vertices[Y4] = y1;
+				vertices[C4] = color;
+				vertices[U4] = u2;
+				vertices[V4] = v1;
+
+				batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+			}
+		} else {
+
+			// Determine number of times to repeat image across X and Y, + 4 for padding to avoid pop in/out
+			int repeatX = layer.isRepeatX() ? (int)Math.ceil((viewBounds.width / imageBounds.width) + 4) : 0;
+			int repeatY = layer.isRepeatY() ? (int)Math.ceil((viewBounds.height / imageBounds.height) + 4) : 0;
+
+			// Calculate the offset of the first image to align with the camera
+			float startX = viewBounds.x;
+			float startY = viewBounds.y;
+			startX = startX - (startX % imageBounds.width);
+			startY = startY - (startY % imageBounds.height);
+
+			for (int i = 0; i <= repeatX; i++) {
+				for (int j = 0; j <= repeatY; j++) {
+					float rx1 = x1;
+					float ry1 = y1;
+					float rx2 = x2;
+					float ry2 = y2;
+
+					// Use (i -2)/(j-2) to begin placing our repeating images outside the camera.
+					// In case the image is offset, we must negate this using + (x1% imageBounds.width)
+					// It's a way to get the remainder of how many images would fit between its starting position and 0
+					if (layer.isRepeatX()) {
+						rx1 = startX + ((i - 2) * imageBounds.width) + (x1 % imageBounds.width);
+						rx2 = rx1 + imageBounds.width;
+					}
+
+					if (layer.isRepeatY()) {
+						ry1 = startY + ((j - 2) * imageBounds.height) + (y1 % imageBounds.height);
+						ry2 = ry1 + imageBounds.height;
+					}
+
+					repeatedImageBounds.set(rx1, ry1, rx2 - rx1, ry2 - ry1);
+
+					if (viewBounds.contains(repeatedImageBounds) || viewBounds.overlaps(repeatedImageBounds)) {
+						final float ru1 = region.getU();
+						final float rv1 = region.getV2();
+						final float ru2 = region.getU2();
+						final float rv2 = region.getV();
+
+						vertices[X1] = rx1;
+						vertices[Y1] = ry1;
+						vertices[C1] = color;
+						vertices[U1] = ru1;
+						vertices[V1] = rv1;
+
+						vertices[X2] = rx1;
+						vertices[Y2] = ry2;
+						vertices[C2] = color;
+						vertices[U2] = ru1;
+						vertices[V2] = rv2;
+
+						vertices[X3] = rx2;
+						vertices[Y3] = ry2;
+						vertices[C3] = color;
+						vertices[U3] = ru2;
+						vertices[V3] = rv2;
+
+						vertices[X4] = rx2;
+						vertices[Y4] = ry1;
+						vertices[C4] = color;
+						vertices[U4] = ru2;
+						vertices[V4] = rv1;
+
+						batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+					}
+				}
+			}
 		}
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/HexagonalTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/HexagonalTiledMapRenderer.java
index b669de885..a41dde4e8 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/HexagonalTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/HexagonalTiledMapRenderer.java
@@ -22,6 +22,7 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.maps.tiled.TiledMap;
+import com.badlogic.gdx.maps.tiled.TiledMapImageLayer;
 import com.badlogic.gdx.maps.tiled.TiledMapTile;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
 import com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile;
@@ -258,4 +259,153 @@ public class HexagonalTiledMapRenderer extends BatchTiledMapRenderer {
 			}
 		}
 	}
+
+	@Override
+	public void renderImageLayer (TiledMapImageLayer layer) {
+		final Color batchColor = batch.getColor();
+		final float color = Color.toFloatBits(batchColor.r, batchColor.g, batchColor.b, batchColor.a * layer.getOpacity());
+
+		final float[] vertices = this.vertices;
+
+		TextureRegion region = layer.getTextureRegion();
+
+		if (region == null) {
+			return;
+		}
+
+		int tileHeight = getMap().getProperties().get("tileheight", Integer.class);
+		int mapHeight = getMap().getProperties().get("height", Integer.class);
+		float layerHexLength = hexSideLength;
+		// Map height if it were tiles
+		float totalHeightPixels = (mapHeight * tileHeight) * unitScale;
+		// To determine size of Hex map height we use (mapHeight * tileHeight(3/4)) + (layerHexLength * 0.5f)
+		float hexMapHeightPixels = ((mapHeight * tileHeight * (3f / 4f)) + (layerHexLength * 0.5f)) * unitScale;
+
+		float imageLayerYOffset = 0;
+		float layerTileHeight = tileHeight * unitScale;
+		float halfTileHeight = layerTileHeight * 0.5f;
+
+		if (staggerAxisX) {
+			/** If X axis staggered, must offset imagelayer y position by adding half of tileHeight to match position */
+			imageLayerYOffset = halfTileHeight;
+		} else {
+			/** ImageLayer's y position seems to be placed at an offset determined the total height if this were a normal tile map
+			 * minus the height as calculated for a hexmap. We get this number and use it to counter offset our Y. Then we will have
+			 * our imagelayer matching its position in Tiled. */
+			imageLayerYOffset = -(totalHeightPixels - hexMapHeightPixels);
+		}
+
+		final float x = layer.getX();
+		final float y = layer.getY();
+		final float x1 = x * unitScale - viewBounds.x * (layer.getParallaxX() - 1);
+		final float y1 = y * unitScale - viewBounds.y * (layer.getParallaxY() - 1) + imageLayerYOffset;
+		final float x2 = x1 + region.getRegionWidth() * unitScale;
+		final float y2 = y1 + region.getRegionHeight() * unitScale;
+
+		imageBounds.set(x1, y1, x2 - x1, y2 - y1);
+
+		if (!layer.isRepeatX() && !layer.isRepeatY()) {
+			if (viewBounds.contains(imageBounds) || viewBounds.overlaps(imageBounds)) {
+				final float u1 = region.getU();
+				final float v1 = region.getV2();
+				final float u2 = region.getU2();
+				final float v2 = region.getV();
+
+				vertices[X1] = x1;
+				vertices[Y1] = y1;
+				vertices[C1] = color;
+				vertices[U1] = u1;
+				vertices[V1] = v1;
+
+				vertices[X2] = x1;
+				vertices[Y2] = y2;
+				vertices[C2] = color;
+				vertices[U2] = u1;
+				vertices[V2] = v2;
+
+				vertices[X3] = x2;
+				vertices[Y3] = y2;
+				vertices[C3] = color;
+				vertices[U3] = u2;
+				vertices[V3] = v2;
+
+				vertices[X4] = x2;
+				vertices[Y4] = y1;
+				vertices[C4] = color;
+				vertices[U4] = u2;
+				vertices[V4] = v1;
+
+				batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+			}
+		} else {
+
+			// Determine number of times to repeat image across X and Y, + 4 for padding to avoid pop in/out
+			int repeatX = layer.isRepeatX() ? (int)Math.ceil((viewBounds.width / imageBounds.width) + 4) : 0;
+			int repeatY = layer.isRepeatY() ? (int)Math.ceil((viewBounds.height / imageBounds.height) + 4) : 0;
+
+			// Calculate the offset of the first image to align with the camera
+			float startX = viewBounds.x;
+			float startY = viewBounds.y;
+			startX = startX - (startX % imageBounds.width);
+			startY = startY - (startY % imageBounds.height);
+
+			for (int i = 0; i <= repeatX; i++) {
+				for (int j = 0; j <= repeatY; j++) {
+					float rx1 = x1;
+					float ry1 = y1;
+					float rx2 = x2;
+					float ry2 = y2;
+
+					// Use (i -2)/(j-2) to begin placing our repeating images outside the camera.
+					// In case the image is offset, we must negate this using + (x1% imageBounds.width)
+					// It's a way to get the remainder of how many images would fit between its starting position and 0
+					if (layer.isRepeatX()) {
+						rx1 = startX + ((i - 2) * imageBounds.width) + (x1 % imageBounds.width);
+						rx2 = rx1 + imageBounds.width;
+					}
+
+					if (layer.isRepeatY()) {
+						ry1 = startY + ((j - 2) * imageBounds.height) + (y1 % imageBounds.height);
+						ry2 = ry1 + imageBounds.height;
+					}
+
+					repeatedImageBounds.set(rx1, ry1, rx2 - rx1, ry2 - ry1);
+
+					if (viewBounds.contains(repeatedImageBounds) || viewBounds.overlaps(repeatedImageBounds)) {
+						final float ru1 = region.getU();
+						final float rv1 = region.getV2();
+						final float ru2 = region.getU2();
+						final float rv2 = region.getV();
+
+						vertices[X1] = rx1;
+						vertices[Y1] = ry1;
+						vertices[C1] = color;
+						vertices[U1] = ru1;
+						vertices[V1] = rv1;
+
+						vertices[X2] = rx1;
+						vertices[Y2] = ry2;
+						vertices[C2] = color;
+						vertices[U2] = ru1;
+						vertices[V2] = rv2;
+
+						vertices[X3] = rx2;
+						vertices[Y3] = ry2;
+						vertices[C3] = color;
+						vertices[U3] = ru2;
+						vertices[V3] = rv2;
+
+						vertices[X4] = rx2;
+						vertices[Y4] = ry1;
+						vertices[C4] = color;
+						vertices[U4] = ru2;
+						vertices[V4] = rv1;
+
+						batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+					}
+				}
+			}
+		}
+	}
+
 }
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricStaggeredTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricStaggeredTiledMapRenderer.java
index b72bd9ca7..be1c66be8 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricStaggeredTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricStaggeredTiledMapRenderer.java
@@ -22,6 +22,7 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.maps.tiled.TiledMap;
+import com.badlogic.gdx.maps.tiled.TiledMapImageLayer;
 import com.badlogic.gdx.maps.tiled.TiledMapTile;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
@@ -187,4 +188,134 @@ public class IsometricStaggeredTiledMapRenderer extends BatchTiledMapRenderer {
 			}
 		}
 	}
+
+	@Override
+	public void renderImageLayer (TiledMapImageLayer layer) {
+		final Color batchColor = batch.getColor();
+		final float color = Color.toFloatBits(batchColor.r, batchColor.g, batchColor.b, batchColor.a * layer.getOpacity());
+
+		final float[] vertices = this.vertices;
+
+		TextureRegion region = layer.getTextureRegion();
+
+		if (region == null) {
+			return;
+		}
+
+		/** Must offset imagelayer x position by half of tileWidth to match position */
+		int tileWidth = getMap().getProperties().get("tilewidth", Integer.class);
+		float halfTileWidth = (tileWidth * 0.5f) * unitScale;
+
+		final float x = layer.getX();
+		final float y = layer.getY();
+		final float x1 = x * unitScale - viewBounds.x * (layer.getParallaxX() - 1) - halfTileWidth;
+		final float y1 = y * unitScale - viewBounds.y * (layer.getParallaxY() - 1);
+		final float x2 = x1 + region.getRegionWidth() * unitScale;
+		final float y2 = y1 + region.getRegionHeight() * unitScale;
+
+		imageBounds.set(x1, y1, x2 - x1, y2 - y1);
+
+		if (!layer.isRepeatX() && !layer.isRepeatY()) {
+			if (viewBounds.contains(imageBounds) || viewBounds.overlaps(imageBounds)) {
+				final float u1 = region.getU();
+				final float v1 = region.getV2();
+				final float u2 = region.getU2();
+				final float v2 = region.getV();
+
+				vertices[X1] = x1;
+				vertices[Y1] = y1;
+				vertices[C1] = color;
+				vertices[U1] = u1;
+				vertices[V1] = v1;
+
+				vertices[X2] = x1;
+				vertices[Y2] = y2;
+				vertices[C2] = color;
+				vertices[U2] = u1;
+				vertices[V2] = v2;
+
+				vertices[X3] = x2;
+				vertices[Y3] = y2;
+				vertices[C3] = color;
+				vertices[U3] = u2;
+				vertices[V3] = v2;
+
+				vertices[X4] = x2;
+				vertices[Y4] = y1;
+				vertices[C4] = color;
+				vertices[U4] = u2;
+				vertices[V4] = v1;
+
+				batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+			}
+		} else {
+
+			// Determine number of times to repeat image across X and Y, + 4 for padding to avoid pop in/out
+			int repeatX = layer.isRepeatX() ? (int)Math.ceil((viewBounds.width / imageBounds.width) + 4) : 0;
+			int repeatY = layer.isRepeatY() ? (int)Math.ceil((viewBounds.height / imageBounds.height) + 4) : 0;
+
+			// Calculate the offset of the first image to align with the camera
+			float startX = viewBounds.x;
+			float startY = viewBounds.y;
+			startX = startX - (startX % imageBounds.width);
+			startY = startY - (startY % imageBounds.height);
+
+			for (int i = 0; i <= repeatX; i++) {
+				for (int j = 0; j <= repeatY; j++) {
+					float rx1 = x1;
+					float ry1 = y1;
+					float rx2 = x2;
+					float ry2 = y2;
+
+					// Use (i -2)/(j-2) to begin placing our repeating images outside the camera.
+					// In case the image is offset, we must negate this using + (x1% imageBounds.width)
+					// It's a way to get the remainder of how many images would fit between its starting position and 0
+					if (layer.isRepeatX()) {
+						rx1 = startX + ((i - 2) * imageBounds.width) + (x1 % imageBounds.width);
+						rx2 = rx1 + imageBounds.width;
+					}
+
+					if (layer.isRepeatY()) {
+						ry1 = startY + ((j - 2) * imageBounds.height) + (y1 % imageBounds.height);
+						ry2 = ry1 + imageBounds.height;
+					}
+
+					repeatedImageBounds.set(rx1, ry1, rx2 - rx1, ry2 - ry1);
+
+					if (viewBounds.contains(repeatedImageBounds) || viewBounds.overlaps(repeatedImageBounds)) {
+						final float ru1 = region.getU();
+						final float rv1 = region.getV2();
+						final float ru2 = region.getU2();
+						final float rv2 = region.getV();
+
+						vertices[X1] = rx1;
+						vertices[Y1] = ry1;
+						vertices[C1] = color;
+						vertices[U1] = ru1;
+						vertices[V1] = rv1;
+
+						vertices[X2] = rx1;
+						vertices[Y2] = ry2;
+						vertices[C2] = color;
+						vertices[U2] = ru1;
+						vertices[V2] = rv2;
+
+						vertices[X3] = rx2;
+						vertices[Y3] = ry2;
+						vertices[C3] = color;
+						vertices[U3] = ru2;
+						vertices[V3] = rv2;
+
+						vertices[X4] = rx2;
+						vertices[Y4] = ry1;
+						vertices[C4] = color;
+						vertices[U4] = ru2;
+						vertices[V4] = rv1;
+
+						batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+					}
+				}
+			}
+		}
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricTiledMapRenderer.java
index bb073b8d5..8af8b70df 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricTiledMapRenderer.java
@@ -22,6 +22,7 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.maps.tiled.TiledMap;
+import com.badlogic.gdx.maps.tiled.TiledMapImageLayer;
 import com.badlogic.gdx.maps.tiled.TiledMapTile;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
@@ -231,4 +232,140 @@ public class IsometricTiledMapRenderer extends BatchTiledMapRenderer {
 			}
 		}
 	}
+
+	@Override
+	public void renderImageLayer (TiledMapImageLayer layer) {
+		final Color batchColor = batch.getColor();
+		final float color = Color.toFloatBits(batchColor.r, batchColor.g, batchColor.b, batchColor.a * layer.getOpacity());
+
+		final float[] vertices = this.vertices;
+
+		TextureRegion region = layer.getTextureRegion();
+
+		if (region == null) {
+			return;
+		}
+		/** Because of the way libGDX handles the isometric coordinates. The leftmost tile of the map begins rendering at world
+		 * position 0,0, while in Tiled the y position is actually totalHeight/2 ex. Map 800px in height, leftmost tile edge starts
+		 * rendering at 0,400 in tiled To compensate for that we need to subtract half the map's height in pixels then add half of
+		 * the tile's height in order to position it properly in order to get a 1 to 1 rendering as to where the imagelayer renders
+		 * in tiled. */
+		int tileHeight = getMap().getProperties().get("tileheight", Integer.class);
+		int mapHeight = getMap().getProperties().get("height", Integer.class);
+		float mapHeightPixels = (mapHeight * tileHeight) * unitScale;
+		float halfTileHeight = (tileHeight * 0.5f) * unitScale;
+
+		float x = layer.getX();
+		float y = layer.getY();
+		final float x1 = x * unitScale - viewBounds.x * (layer.getParallaxX() - 1);
+		final float y1 = y * unitScale - viewBounds.y * (layer.getParallaxY() - 1) - (mapHeightPixels * 0.5f) + halfTileHeight;
+		float x2 = x1 + region.getRegionWidth() * unitScale;
+		float y2 = y1 + region.getRegionHeight() * unitScale;
+
+		imageBounds.set(x1, y1, x2 - x1, y2 - y1);
+
+		if (!layer.isRepeatX() && !layer.isRepeatY()) {
+			if (viewBounds.contains(imageBounds) || viewBounds.overlaps(imageBounds)) {
+				final float u1 = region.getU();
+				final float v1 = region.getV2();
+				final float u2 = region.getU2();
+				final float v2 = region.getV();
+
+				vertices[X1] = x1;
+				vertices[Y1] = y1;
+				vertices[C1] = color;
+				vertices[U1] = u1;
+				vertices[V1] = v1;
+
+				vertices[X2] = x1;
+				vertices[Y2] = y2;
+				vertices[C2] = color;
+				vertices[U2] = u1;
+				vertices[V2] = v2;
+
+				vertices[X3] = x2;
+				vertices[Y3] = y2;
+				vertices[C3] = color;
+				vertices[U3] = u2;
+				vertices[V3] = v2;
+
+				vertices[X4] = x2;
+				vertices[Y4] = y1;
+				vertices[C4] = color;
+				vertices[U4] = u2;
+				vertices[V4] = v1;
+
+				batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+			}
+		} else {
+
+			// Determine number of times to repeat image across X and Y, + 4 for padding to avoid pop in/out
+			int repeatX = layer.isRepeatX() ? (int)Math.ceil((viewBounds.width / imageBounds.width) + 4) : 0;
+			int repeatY = layer.isRepeatY() ? (int)Math.ceil((viewBounds.height / imageBounds.height) + 4) : 0;
+
+			// Calculate the offset of the first image to align with the camera
+			float startX = viewBounds.x;
+			float startY = viewBounds.y;
+			startX = startX - (startX % imageBounds.width);
+			startY = startY - (startY % imageBounds.height);
+
+			for (int i = 0; i <= repeatX; i++) {
+				for (int j = 0; j <= repeatY; j++) {
+					float rx1 = x1;
+					float ry1 = y1;
+					float rx2 = x2;
+					float ry2 = y2;
+
+					// Use (i -2)/(j-2) to begin placing our repeating images outside the camera.
+					// In case the image is offset, we must negate this using + (x1% imageBounds.width)
+					// It's a way to get the remainder of how many images would fit between its starting position and 0
+					if (layer.isRepeatX()) {
+						rx1 = startX + ((i - 2) * imageBounds.width) + (x1 % imageBounds.width);
+						rx2 = rx1 + imageBounds.width;
+					}
+
+					if (layer.isRepeatY()) {
+						ry1 = startY + ((j - 2) * imageBounds.height) + (y1 % imageBounds.height);
+						ry2 = ry1 + imageBounds.height;
+					}
+
+					repeatedImageBounds.set(rx1, ry1, rx2 - rx1, ry2 - ry1);
+
+					if (viewBounds.contains(repeatedImageBounds) || viewBounds.overlaps(repeatedImageBounds)) {
+						final float ru1 = region.getU();
+						final float rv1 = region.getV2();
+						final float ru2 = region.getU2();
+						final float rv2 = region.getV();
+
+						vertices[X1] = rx1;
+						vertices[Y1] = ry1;
+						vertices[C1] = color;
+						vertices[U1] = ru1;
+						vertices[V1] = rv1;
+
+						vertices[X2] = rx1;
+						vertices[Y2] = ry2;
+						vertices[C2] = color;
+						vertices[U2] = ru1;
+						vertices[V2] = rv2;
+
+						vertices[X3] = rx2;
+						vertices[Y3] = ry2;
+						vertices[C3] = color;
+						vertices[U3] = ru2;
+						vertices[V3] = rv2;
+
+						vertices[X4] = rx2;
+						vertices[Y4] = ry1;
+						vertices[C4] = color;
+						vertices[U4] = ru2;
+						vertices[V4] = rv1;
+
+						batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+					}
+				}
+			}
+		}
+	}
+
 }
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthoCachedTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthoCachedTiledMapRenderer.java
index 927d0dd26..8d46b10bd 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthoCachedTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthoCachedTiledMapRenderer.java
@@ -355,6 +355,8 @@ public class OrthoCachedTiledMapRenderer implements TiledMapRenderer, Disposable
 		}
 	}
 
+	protected Rectangle imageBounds = new Rectangle();
+
 	@Override
 	public void renderImageLayer (TiledMapImageLayer layer) {
 		final float color = Color.toFloatBits(1.0f, 1.0f, 1.0f, layer.getOpacity());
@@ -373,36 +375,105 @@ public class OrthoCachedTiledMapRenderer implements TiledMapRenderer, Disposable
 		final float x2 = x1 + region.getRegionWidth() * unitScale;
 		final float y2 = y1 + region.getRegionHeight() * unitScale;
 
-		final float u1 = region.getU();
-		final float v1 = region.getV2();
-		final float u2 = region.getU2();
-		final float v2 = region.getV();
-
-		vertices[X1] = x1;
-		vertices[Y1] = y1;
-		vertices[C1] = color;
-		vertices[U1] = u1;
-		vertices[V1] = v1;
-
-		vertices[X2] = x1;
-		vertices[Y2] = y2;
-		vertices[C2] = color;
-		vertices[U2] = u1;
-		vertices[V2] = v2;
-
-		vertices[X3] = x2;
-		vertices[Y3] = y2;
-		vertices[C3] = color;
-		vertices[U3] = u2;
-		vertices[V3] = v2;
-
-		vertices[X4] = x2;
-		vertices[Y4] = y1;
-		vertices[C4] = color;
-		vertices[U4] = u2;
-		vertices[V4] = v1;
-
-		spriteCache.add(region.getTexture(), vertices, 0, NUM_VERTICES);
+		imageBounds.set(x1, y1, x2 - x1, y2 - y1);
+		if (!layer.isRepeatX() && !layer.isRepeatY()) {
+
+			final float u1 = region.getU();
+			final float v1 = region.getV2();
+			final float u2 = region.getU2();
+			final float v2 = region.getV();
+
+			vertices[X1] = x1;
+			vertices[Y1] = y1;
+			vertices[C1] = color;
+			vertices[U1] = u1;
+			vertices[V1] = v1;
+
+			vertices[X2] = x1;
+			vertices[Y2] = y2;
+			vertices[C2] = color;
+			vertices[U2] = u1;
+			vertices[V2] = v2;
+
+			vertices[X3] = x2;
+			vertices[Y3] = y2;
+			vertices[C3] = color;
+			vertices[U3] = u2;
+			vertices[V3] = v2;
+
+			vertices[X4] = x2;
+			vertices[Y4] = y1;
+			vertices[C4] = color;
+			vertices[U4] = u2;
+			vertices[V4] = v1;
+
+			spriteCache.add(region.getTexture(), vertices, 0, NUM_VERTICES);
+
+		} else {
+
+			// Determine number of times to repeat image across X and Y, + 4 for padding to avoid pop in/out
+			int repeatX = layer.isRepeatX() ? (int)Math.ceil((cacheBounds.width / imageBounds.width) + 4) : 0;
+			int repeatY = layer.isRepeatY() ? (int)Math.ceil((cacheBounds.height / imageBounds.height) + 4) : 0;
+
+			// Calculate the offset of the first image to align with the camera
+			float startX = cacheBounds.x;
+			float startY = cacheBounds.y;
+			startX = startX - (startX % imageBounds.width);
+			startY = startY - (startY % imageBounds.height);
+
+			for (int i = 0; i <= repeatX; i++) {
+				for (int j = 0; j <= repeatY; j++) {
+					float rx1 = x1;
+					float ry1 = y1;
+					float rx2 = x2;
+					float ry2 = y2;
+
+					// Use (i -2)/(j-2) to begin placing our repeating images outside the camera.
+					// In case the image is offset, we must negate this using + (x1% imageBounds.width)
+					// It's a way to get the remainder of how many images would fit between its starting position and 0
+					if (layer.isRepeatX()) {
+						rx1 = startX + ((i - 2) * imageBounds.width) + (x1 % imageBounds.width);
+						rx2 = rx1 + imageBounds.width;
+					}
+
+					if (layer.isRepeatY()) {
+						ry1 = startY + ((j - 2) * imageBounds.height) + (y1 % imageBounds.height);
+						ry2 = ry1 + imageBounds.height;
+					}
+
+					final float ru1 = region.getU();
+					final float rv1 = region.getV2();
+					final float ru2 = region.getU2();
+					final float rv2 = region.getV();
+
+					vertices[X1] = rx1;
+					vertices[Y1] = ry1;
+					vertices[C1] = color;
+					vertices[U1] = ru1;
+					vertices[V1] = rv1;
+
+					vertices[X2] = rx1;
+					vertices[Y2] = ry2;
+					vertices[C2] = color;
+					vertices[U2] = ru1;
+					vertices[V2] = rv2;
+
+					vertices[X3] = rx2;
+					vertices[Y3] = ry2;
+					vertices[C3] = color;
+					vertices[U3] = ru2;
+					vertices[V3] = rv2;
+
+					vertices[X4] = rx2;
+					vertices[Y4] = ry1;
+					vertices[C4] = color;
+					vertices[U4] = ru2;
+					vertices[V4] = rv1;
+
+					spriteCache.add(region.getTexture(), vertices, 0, NUM_VERTICES);
+				}
+			}
+		}
 	}
 
 	/** Causes the cache to be rebuilt the next time it is rendered. */
diff --git a/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/hex_x.tmx b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/hex_x.tmx
new file mode 100644
index 000000000..074662336
--- /dev/null
+++ b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/hex_x.tmx
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.9" tiledversion="1.9.2" orientation="hexagonal" renderorder="left-down" width="20" height="16" tilewidth="112" tileheight="96" infinite="0" hexsidelength="48" staggeraxis="x" staggerindex="odd" nextlayerid="8" nextobjectid="1">
+ <tileset firstgid="1" name="hexes" tilewidth="112" tileheight="96" tilecount="4" columns="2">
+  <image source="../tiled/hex/hexes.png" width="256" height="256"/>
+ </tileset>
+ <imagelayer id="3" name="Badlogic Layer" repeatx="1" repeaty="1">
+  <image source="../../badlogic.jpg" width="256" height="256"/>
+ </imagelayer>
+ <layer id="1" name="Tile Layer 1" width="20" height="16">
+  <data encoding="base64">
+   AAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
+  </data>
+ </layer>
+ <layer id="2" name="Tile Layer 2" width="20" height="16" offsetx="48" offsety="-24">
+  <data encoding="base64">
+   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
+  </data>
+ </layer>
+ <imagelayer id="4" name="Blue Tile Top Repeat X" repeatx="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="5" name="Blue Tile Bottom Repeat X" offsetx="32" offsety="1536" repeatx="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="6" name="Blue Tile Left Repeat Y" repeaty="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="7" name="Blue Tile Right Repeat Y" offsetx="1600" offsety="336" repeaty="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+</map>
diff --git a/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/hex_y.tmx b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/hex_y.tmx
new file mode 100644
index 000000000..9dd7a91b4
--- /dev/null
+++ b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/hex_y.tmx
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.9" tiledversion="1.9.2" orientation="hexagonal" renderorder="left-down" width="20" height="16" tilewidth="112" tileheight="96" infinite="0" hexsidelength="48" staggeraxis="y" staggerindex="odd" nextlayerid="9" nextobjectid="16">
+ <tileset firstgid="1" name="hexes" tilewidth="112" tileheight="96" tilecount="4" columns="2">
+  <image source="../tiled/hex/hexes.png" width="256" height="256"/>
+ </tileset>
+ <imagelayer id="3" name="Badlogic Layer" repeatx="1" repeaty="1">
+  <image source="../../badlogic.jpg" width="256" height="256"/>
+ </imagelayer>
+ <layer id="1" name="Tile Layer 1" width="20" height="16">
+  <data encoding="base64">
+   AAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
+  </data>
+ </layer>
+ <layer id="2" name="Tile Layer 2" width="20" height="16" offsetx="48" offsety="-24">
+  <data encoding="base64">
+   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
+  </data>
+ </layer>
+ <imagelayer id="4" name="Blue Tile Top Repeat X" repeatx="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="5" name="Blue Tile Bottom Repeat X" offsetx="0" offsety="1141" repeatx="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="6" name="Blue Tile Left Repeat Y" repeaty="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="7" name="Blue Tile Right Repeat Y" offsetx="2264" offsety="171.333" repeaty="1" >
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+</map>
diff --git a/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/iso.tmx b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/iso.tmx
new file mode 100644
index 000000000..16b45e412
--- /dev/null
+++ b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/iso.tmx
@@ -0,0 +1,79 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.9" tiledversion="1.9.2" orientation="isometric" renderorder="right-down" width="25" height="25" tilewidth="64" tileheight="32" infinite="0" nextlayerid="10" nextobjectid="10">
+ <properties>
+  <property name="boolCustomProperty" type="bool" value="true"/>
+  <property name="floatCustomProperty" type="float" value="1.56"/>
+  <property name="intCustomProperty" type="int" value="5"/>
+  <property name="mapCustomProperty" value="mapCustomValue"/>
+ </properties>
+ <tileset firstgid="1" name="isometric_grass_and_water" tilewidth="64" tileheight="64" tilecount="24" columns="4">
+  <tileoffset x="0" y="16"/>
+  <properties>
+   <property name="tilesetCustomProperty" value="tilesetCustomValue"/>
+  </properties>
+  <image source="../tiled/isometric_grass_and_water.png" width="256" height="384"/>
+  <tile id="0">
+   <properties>
+    <property name="tileCustomProperty" value="tileCustomValue"/>
+   </properties>
+  </tile>
+  <wangsets>
+   <wangset name="Terrains" type="corner" tile="-1">
+    <wangcolor name="Grass" color="#ff0000" tile="0" probability="1"/>
+    <wangcolor name="Water" color="#00ff00" tile="22" probability="1"/>
+    <wangtile tileid="0" wangid="0,1,0,1,0,1,0,1"/>
+    <wangtile tileid="1" wangid="0,1,0,1,0,1,0,1"/>
+    <wangtile tileid="2" wangid="0,1,0,1,0,1,0,1"/>
+    <wangtile tileid="3" wangid="0,1,0,1,0,1,0,1"/>
+    <wangtile tileid="4" wangid="0,1,0,2,0,1,0,1"/>
+    <wangtile tileid="5" wangid="0,1,0,1,0,2,0,1"/>
+    <wangtile tileid="6" wangid="0,1,0,1,0,1,0,2"/>
+    <wangtile tileid="7" wangid="0,2,0,1,0,1,0,1"/>
+    <wangtile tileid="8" wangid="0,2,0,2,0,2,0,1"/>
+    <wangtile tileid="9" wangid="0,1,0,2,0,2,0,2"/>
+    <wangtile tileid="10" wangid="0,2,0,1,0,2,0,2"/>
+    <wangtile tileid="11" wangid="0,2,0,2,0,1,0,2"/>
+    <wangtile tileid="12" wangid="0,1,0,2,0,2,0,1"/>
+    <wangtile tileid="13" wangid="0,1,0,1,0,2,0,2"/>
+    <wangtile tileid="14" wangid="0,2,0,1,0,1,0,2"/>
+    <wangtile tileid="15" wangid="0,2,0,2,0,1,0,1"/>
+    <wangtile tileid="16" wangid="0,1,0,2,0,2,0,1"/>
+    <wangtile tileid="17" wangid="0,1,0,1,0,2,0,2"/>
+    <wangtile tileid="18" wangid="0,2,0,1,0,1,0,2"/>
+    <wangtile tileid="19" wangid="0,2,0,2,0,1,0,1"/>
+    <wangtile tileid="20" wangid="0,2,0,1,0,2,0,1"/>
+    <wangtile tileid="21" wangid="0,1,0,2,0,1,0,2"/>
+    <wangtile tileid="22" wangid="0,2,0,2,0,2,0,2"/>
+    <wangtile tileid="23" wangid="0,2,0,2,0,2,0,2"/>
+   </wangset>
+  </wangsets>
+ </tileset>
+ <imagelayer id="3" name="Badlogic Repeat XY" repeatx="1" repeaty="1">
+  <image source="../../badlogic.jpg" width="256" height="256"/>
+ </imagelayer>
+ <imagelayer id="4" name="Blue Tile Top Repeat X" repeatx="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="5" name="Blue Tile Bottom Repeat X" offsetx="0" offsety="768" repeatx="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="6" name="Blue Tile Left Repeat Y" offsetx="1" offsety="0" repeaty="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="7" name="Blue Tile Right Repeat Y" offsetx="1568" offsety="480" repeaty="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <layer id="1" name="Tile Layer 2" width="25" height="25">
+  <data encoding="base64" compression="zlib">
+   eJztwwEJAAAMBKGL8f2TLsdAwVVTVfXVA6nmOpk=
+  </data>
+ </layer>
+ <layer id="2" name="Tile Layer 1" width="25" height="25" offsetx="64" offsety="-64">
+  <properties>
+   <property name="layerCustomProperty" value="layerCustomValue"/>
+  </properties>
+  <data encoding="base64" compression="zlib">
+   eJx1lttywjAMROVgyqVtAoFC/v9L68xoh5PFPGhIYktrrVYyS0QszZ7Nvpvd0n7y24L1Q7MhrTSreN/le821HZ7lv9qYa6sdE0cYs/kX7PXYwtfaevYp7WDrd+SnHByjYr/npP1zZ4/elcuM71rjeckdc5KNHX75fMwc9s2uzb6AsYstJzwrv5/Tz89SLIZy8v203llV8xl7yMU+462/v81OqA114/UhrzUxRqwprnh6ZGzp2PNQfPqRu/X9hnMV8F/xLg1L42erDf2oaa2RI2qPtbgbhmw2H69nMUxx/gVccXdC3AW/o/HV60vW59Lhu8arDxmfGIPFUV1qbLVQEIs4PlOeHQxqVjmzr5mLYsmf+5Qj5yM1r3Ne4p1D5VcMh3qWZibLx2fYkBhPYOv81I9wbrGd45zFU7zrndpwDjkHXXfej9zHc3EG+D3AWcCZMJif7hTnVxr6i9edtoBDz8N7kxqbY6sN9gJnsnqIOqCme7Un76579sIV8dccHvHqZefH76BP9wjzkVapM2rL+5/8cR6QS9eh8p2AT12y5oO9+7yh5hzLZypnHX29/pzB9PE7bOg8Mza5KvGu4R7mp/89zqvr7x+TnxEn
+  </data>
+ </layer>
+</map>
diff --git a/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/iso_stag.tmx b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/iso_stag.tmx
new file mode 100644
index 000000000..4a495ee20
--- /dev/null
+++ b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/iso_stag.tmx
@@ -0,0 +1,79 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.9" tiledversion="1.9.2" orientation="staggered" renderorder="right-down" width="12" height="25" tilewidth="64" tileheight="32" infinite="0" staggeraxis="y" staggerindex="even" nextlayerid="8" nextobjectid="1">
+ <properties>
+  <property name="boolCustomProperty" type="bool" value="true"/>
+  <property name="floatCustomProperty" type="float" value="1.56"/>
+  <property name="intCustomProperty" type="int" value="5"/>
+  <property name="mapCustomProperty" value="mapCustomValue"/>
+ </properties>
+ <tileset firstgid="1" name="isometric_grass_and_water" tilewidth="64" tileheight="64" tilecount="24" columns="4">
+  <tileoffset x="0" y="16"/>
+  <properties>
+   <property name="tilesetCustomProperty" value="tilesetCustomValue"/>
+  </properties>
+  <image source="../tiled/isometric_grass_and_water.png" width="256" height="384"/>
+  <tile id="0">
+   <properties>
+    <property name="tileCustomProperty" value="tileCustomValue"/>
+   </properties>
+  </tile>
+  <wangsets>
+   <wangset name="Terrains" type="corner" tile="-1">
+    <wangcolor name="Grass" color="#ff0000" tile="0" probability="1"/>
+    <wangcolor name="Water" color="#00ff00" tile="22" probability="1"/>
+    <wangtile tileid="0" wangid="0,1,0,1,0,1,0,1"/>
+    <wangtile tileid="1" wangid="0,1,0,1,0,1,0,1"/>
+    <wangtile tileid="2" wangid="0,1,0,1,0,1,0,1"/>
+    <wangtile tileid="3" wangid="0,1,0,1,0,1,0,1"/>
+    <wangtile tileid="4" wangid="0,1,0,2,0,1,0,1"/>
+    <wangtile tileid="5" wangid="0,1,0,1,0,2,0,1"/>
+    <wangtile tileid="6" wangid="0,1,0,1,0,1,0,2"/>
+    <wangtile tileid="7" wangid="0,2,0,1,0,1,0,1"/>
+    <wangtile tileid="8" wangid="0,2,0,2,0,2,0,1"/>
+    <wangtile tileid="9" wangid="0,1,0,2,0,2,0,2"/>
+    <wangtile tileid="10" wangid="0,2,0,1,0,2,0,2"/>
+    <wangtile tileid="11" wangid="0,2,0,2,0,1,0,2"/>
+    <wangtile tileid="12" wangid="0,1,0,2,0,2,0,1"/>
+    <wangtile tileid="13" wangid="0,1,0,1,0,2,0,2"/>
+    <wangtile tileid="14" wangid="0,2,0,1,0,1,0,2"/>
+    <wangtile tileid="15" wangid="0,2,0,2,0,1,0,1"/>
+    <wangtile tileid="16" wangid="0,1,0,2,0,2,0,1"/>
+    <wangtile tileid="17" wangid="0,1,0,1,0,2,0,2"/>
+    <wangtile tileid="18" wangid="0,2,0,1,0,1,0,2"/>
+    <wangtile tileid="19" wangid="0,2,0,2,0,1,0,1"/>
+    <wangtile tileid="20" wangid="0,2,0,1,0,2,0,1"/>
+    <wangtile tileid="21" wangid="0,1,0,2,0,1,0,2"/>
+    <wangtile tileid="22" wangid="0,2,0,2,0,2,0,2"/>
+    <wangtile tileid="23" wangid="0,2,0,2,0,2,0,2"/>
+   </wangset>
+  </wangsets>
+ </tileset>
+ <imagelayer id="7" name="Image Layer 5" repeatx="1" repeaty="1">
+  <image source="../../badlogic.jpg" width="256" height="256"/>
+ </imagelayer>
+ <layer id="1" name="Tile Layer 2" width="12" height="25">
+  <data encoding="base64">
+   GAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAA
+  </data>
+ </layer>
+ <layer id="2" name="Tile Layer 1" width="12" height="25" offsetx="8" offsety="-8">
+  <properties>
+   <property name="layerCustomProperty" value="layerCustomValue"/>
+  </properties>
+  <data encoding="base64">
+   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAA
+  </data>
+ </layer>
+ <imagelayer id="3" name="Blue Tile Top Repeat X" repeatx="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="4" name="Blue Tile Bottom Repeat X" offsetx="0" offsety="384" repeatx="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="5" name="Blue Tile Right Repeat Y" repeaty="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="6" name="Blue Tile Left Repeat Y" offsetx="768" offsety="64" repeaty="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+</map>
diff --git a/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/ortho.tmx b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/ortho.tmx
new file mode 100644
index 000000000..22128762d
--- /dev/null
+++ b/tests/gdx-tests-android/assets/data/maps/tiled-imagelayer/ortho.tmx
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.9" tiledversion="1.9.2" orientation="orthogonal" renderorder="right-down" width="80" height="10" tilewidth="32" tileheight="32" infinite="0" nextlayerid="11" nextobjectid="1">
+ <tileset firstgid="1" source="../tiled/tiles.tsx"/>
+ <imagelayer id="7" name="Blue Tile Repeat X and Y Layer" repeatx="1" repeaty="1">
+  <image source="../../tile.png" width="35" height="35"/>
+ </imagelayer>
+ <imagelayer id="2" name="Badlogic Offset and Repeat Y Layer" offsetx="-256" offsety="0" repeaty="1">
+  <image source="../../badlogic.jpg" width="256" height="256"/>
+ </imagelayer>
+ <imagelayer id="9" name="Badlogic Offset and Repeat Y Layer Right" offsetx="2560" offsety="-160" repeaty="1">
+  <image source="../../badlogic.jpg" width="256" height="256"/>
+ </imagelayer>
+ <imagelayer id="8" name="Badlogic Offset and Repeat X Layer" offsetx="512" offsety="320" repeatx="1">
+  <image source="../../badlogic.jpg" width="256" height="256"/>
+ </imagelayer>
+ <imagelayer id="10" name="Badlogic Offset and Repeat X Layer Top" offsetx="512" offsety="-256" repeatx="1">
+  <image source="../../badlogic.jpg" width="256" height="256"/>
+ </imagelayer>
+ <layer id="3" name="Clouds" width="80" height="10">
+  <data encoding="csv">
+0,0,0,0,0,0,0,0,0,0,0,0,97,98,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,97,105,105,98,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,97,101,105,105,105,105,98,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,98,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,99,102,102,102,102,102,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,105,105,98,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,101,105,105,105,105,98,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,99,102,102,102,102,102,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+</data>
+ </layer>
+ <layer id="1" name="Platforms and Bushes" width="80" height="10">
+  <data encoding="csv">
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+115,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+113,114,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+113,114,115,116,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,115,116,0,16,0,10,11,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+113,114,113,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,115,117,118,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+113,114,113,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,113,114,113,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,115,116,
+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,6,0,0,0,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,6
+</data>
+ </layer>
+</map>
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/TiledMapImageLayerRepeatTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/TiledMapImageLayerRepeatTest.java
new file mode 100644
index 000000000..8c2e39ca0
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/TiledMapImageLayerRepeatTest.java
@@ -0,0 +1,158 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tests;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Input;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.OrthographicCamera;
+import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
+import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
+import com.badlogic.gdx.maps.tiled.TiledMap;
+import com.badlogic.gdx.maps.tiled.TiledMapRenderer;
+import com.badlogic.gdx.maps.tiled.TmxMapLoader;
+import com.badlogic.gdx.maps.tiled.renderers.*;
+import com.badlogic.gdx.tests.utils.GdxTest;
+import com.badlogic.gdx.tests.utils.OrthoCamController;
+import com.badlogic.gdx.utils.Disposable;
+import com.badlogic.gdx.utils.ScreenUtils;
+
+public class TiledMapImageLayerRepeatTest extends GdxTest {
+	private final static String MAP_ORTHO = "data/maps/tiled-imagelayer/ortho.tmx";
+	private final static String MAP_ISO = "data/maps/tiled-imagelayer/iso.tmx";
+	private final static String MAP_ISO_STAG = "data/maps/tiled-imagelayer/iso_stag.tmx";
+	private final static String MAP_HEX_X = "data/maps/tiled-imagelayer/hex_x.tmx";
+	private final static String MAP_HEX_Y = "data/maps/tiled-imagelayer/hex_y.tmx";
+	private TiledMap map;
+	private TiledMapRenderer renderer;
+	private OrthographicCamera camera;
+	private OrthoCamController cameraController;
+	private AssetManager assetManager;
+	private BitmapFont font;
+	private SpriteBatch batch;
+	private ShapeRenderer shapeRenderer;
+	private int mapType = 0;
+
+	@Override
+	public void create () {
+		float w = Gdx.graphics.getWidth();
+		float h = Gdx.graphics.getHeight();
+
+		camera = new OrthographicCamera();
+		camera.setToOrtho(false, (w / h) * 10, 10);
+		camera.zoom = 2;
+		camera.update();
+
+		cameraController = new OrthoCamController(camera);
+		Gdx.input.setInputProcessor(cameraController);
+
+		font = new BitmapFont();
+		batch = new SpriteBatch();
+		shapeRenderer = new ShapeRenderer();
+
+		assetManager = new AssetManager();
+		assetManager.setLoader(TiledMap.class, new TmxMapLoader(new InternalFileHandleResolver()));
+		assetManager.load(MAP_ORTHO, TiledMap.class);
+		assetManager.load(MAP_ISO, TiledMap.class);
+		assetManager.load(MAP_ISO_STAG, TiledMap.class);
+		assetManager.load(MAP_HEX_X, TiledMap.class);
+		assetManager.load(MAP_HEX_Y, TiledMap.class);
+		assetManager.finishLoading();
+
+		map = assetManager.get(MAP_ORTHO);
+		renderer = new OrthogonalTiledMapRenderer(map, 1f / 32f);
+	}
+
+	@Override
+	public void render () {
+		if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_1)) {
+			if (mapType != 0) {
+				if (renderer instanceof Disposable) ((Disposable)renderer).dispose();
+				mapType = 0;
+				map = assetManager.get(MAP_ORTHO);
+				renderer = new OrthogonalTiledMapRenderer(map, 1f / 64f);
+			}
+		} else if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_2)) {
+			if (mapType != 1) {
+				if (renderer instanceof Disposable) ((Disposable)renderer).dispose();
+				mapType = 1;
+				map = assetManager.get(MAP_ORTHO);
+				renderer = new OrthoCachedTiledMapRenderer(map, 1f / 32f);
+				((OrthoCachedTiledMapRenderer)renderer).setBlending(true);
+			}
+		} else if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_3)) {
+			if (mapType != 2) {
+				if (renderer instanceof Disposable) ((Disposable)renderer).dispose();
+				mapType = 2;
+				map = assetManager.get(MAP_ISO);
+				renderer = new IsometricTiledMapRenderer(map, 1f / 64f);
+			}
+		} else if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_4)) {
+			if (mapType != 3) {
+				if (renderer instanceof Disposable) ((Disposable)renderer).dispose();
+				mapType = 3;
+				map = assetManager.get(MAP_ISO_STAG);
+				renderer = new IsometricStaggeredTiledMapRenderer(map, 1f / 48f);
+			}
+		} else if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_5)) {
+			if (mapType != 4) {
+				if (renderer instanceof Disposable) ((Disposable)renderer).dispose();
+				mapType = 4;
+				map = assetManager.get(MAP_HEX_X);
+				renderer = new HexagonalTiledMapRenderer(map, 1f / 128f);
+			}
+		} else if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_6)) {
+			if (mapType != 5) {
+				if (renderer instanceof Disposable) ((Disposable)renderer).dispose();
+				mapType = 5;
+				map = assetManager.get(MAP_HEX_Y);
+				renderer = new HexagonalTiledMapRenderer(map, 1f / 128);
+			}
+		}
+
+		ScreenUtils.clear(100f / 255f, 100f / 255f, 250f / 255f, 1f);
+		camera.update();
+
+		// add margin to view bounds so it is easy to see any issues with clipping, calculated same way as
+		// BatchTiledMapRenderer#setView (OrthographicCamera)
+		final float margin = 3;
+		final float width = camera.viewportWidth * camera.zoom - margin * 2;
+		final float height = camera.viewportHeight * camera.zoom - margin * 2;
+		final float w = width * Math.abs(camera.up.y) + height * Math.abs(camera.up.x);
+		final float h = height * Math.abs(camera.up.y) + width * Math.abs(camera.up.x);
+		final float x = camera.position.x - w / 2;
+		final float y = camera.position.y - h / 2;
+		renderer.setView(camera.combined, x, y, w, h);
+		renderer.render();
+
+		shapeRenderer.setProjectionMatrix(camera.combined);
+		shapeRenderer.begin(ShapeType.Line);
+		shapeRenderer.setColor(Color.RED);
+		shapeRenderer.rect(x, y, w, h);
+		shapeRenderer.end();
+
+		batch.begin();
+		font.draw(batch, "FPS: " + Gdx.graphics.getFramesPerSecond(), 10, 20);
+		font.draw(batch, "Switch type with 1-6", Gdx.graphics.getHeight() - 100, 50);
+		font.draw(batch, renderer.getClass().getSimpleName(), Gdx.graphics.getHeight() - 100, 20);
+		batch.end();
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index 215a07b9d..01d653a9c 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -311,6 +311,7 @@ public class GdxTests {
 		TiledMapGroupLayerTest.class,
 		TiledMapAtlasAssetManagerTest.class,
 		TiledMapDirectLoaderTest.class,
+		TiledMapImageLayerRepeatTest.class,
 		TiledMapModifiedExternalTilesetTest.class,
 		TiledMapObjectLoadingTest.class,
 		TiledMapObjectPropertyTest.class,
