diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java
index 15d7fb2f5..da07b3dc5 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java
@@ -277,13 +277,28 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 	}
 
 	public void glDrawElements (int mode, int count, int type, Buffer indices) {
-		if (indices instanceof ShortBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_SHORT)
-			GL11.glDrawElements(mode, (ShortBuffer)indices);
-		else if (indices instanceof ByteBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_SHORT)
-			GL11.glDrawElements(mode, ((ByteBuffer)indices).asShortBuffer()); // FIXME yay...
-		else if (indices instanceof ByteBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_BYTE)
-			GL11.glDrawElements(mode, (ByteBuffer)indices);
-		else
+		if (indices instanceof ShortBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_SHORT) {
+			ShortBuffer sb = (ShortBuffer)indices;
+			int position = sb.position();
+			int oldLimit = sb.limit();
+			sb.limit(position + count);
+			GL11.glDrawElements(mode, sb);
+			sb.limit(oldLimit);
+		} else if (indices instanceof ByteBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_SHORT) {
+			ShortBuffer sb = ((ByteBuffer)indices).asShortBuffer();
+			int position = sb.position();
+			int oldLimit = sb.limit();
+			sb.limit(position + count);
+			GL11.glDrawElements(mode, sb);
+			sb.limit(oldLimit);
+		} else if (indices instanceof ByteBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_BYTE) {
+			ByteBuffer bb = (ByteBuffer)indices;
+			int position = bb.position();
+			int oldLimit = bb.limit();
+			bb.limit(position + count);
+			GL11.glDrawElements(mode, bb);
+			bb.limit(oldLimit);
+		} else
 			throw new GdxRuntimeException("Can't use " + indices.getClass().getName()
 				+ " with this method. Use ShortBuffer or ByteBuffer instead. Blame LWJGL");
 	}
diff --git a/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/Lwjgl3GL20.java b/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/Lwjgl3GL20.java
index 9df66aa74..baa71c874 100644
--- a/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/Lwjgl3GL20.java
+++ b/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/Lwjgl3GL20.java
@@ -276,13 +276,28 @@ class Lwjgl3GL20 implements com.badlogic.gdx.graphics.GL20 {
 	}
 
 	public void glDrawElements (int mode, int count, int type, Buffer indices) {
-		if (indices instanceof ShortBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_SHORT)
-			GL11.glDrawElements(mode, (ShortBuffer)indices);
-		else if (indices instanceof ByteBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_SHORT)
-			GL11.glDrawElements(mode, ((ByteBuffer)indices).asShortBuffer());
-		else if (indices instanceof ByteBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_BYTE)
-			GL11.glDrawElements(mode, (ByteBuffer)indices);
-		else
+		if (indices instanceof ShortBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_SHORT) {
+			ShortBuffer sb = (ShortBuffer)indices;
+			int position = sb.position();
+			int oldLimit = sb.limit();
+			sb.limit(position + count);
+			GL11.glDrawElements(mode, sb);
+			sb.limit(oldLimit);
+		} else if (indices instanceof ByteBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_SHORT) {
+			ShortBuffer sb = ((ByteBuffer)indices).asShortBuffer();
+			int position = sb.position();
+			int oldLimit = sb.limit();
+			sb.limit(position + count);
+			GL11.glDrawElements(mode, sb);
+			sb.limit(oldLimit);
+		} else if (indices instanceof ByteBuffer && type == com.badlogic.gdx.graphics.GL20.GL_UNSIGNED_BYTE) {
+			ByteBuffer bb = (ByteBuffer)indices;
+			int position = bb.position();
+			int oldLimit = bb.limit();
+			bb.limit(position + count);
+			GL11.glDrawElements(mode, bb);
+			bb.limit(oldLimit);
+		} else
 			throw new GdxRuntimeException("Can't use " + indices.getClass().getName()
 				+ " with this method. Use ShortBuffer or ByteBuffer instead. Blame LWJGL");
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/GL20.java b/gdx/src/com/badlogic/gdx/graphics/GL20.java
index c5dc036af..2bf89c0ae 100644
--- a/gdx/src/com/badlogic/gdx/graphics/GL20.java
+++ b/gdx/src/com/badlogic/gdx/graphics/GL20.java
@@ -377,6 +377,7 @@ public interface GL20 {
 
 	public void glDrawArrays (int mode, int first, int count);
 
+	/** Not fully supported with GWT backend: indices content is ignored, only buffer position is used. */
 	public void glDrawElements (int mode, int count, int type, Buffer indices);
 
 	public void glEnable (int cap);
diff --git a/gdx/src/com/badlogic/gdx/graphics/Mesh.java b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
index 75ec576ca..0e7550ebb 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Mesh.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
@@ -621,10 +621,8 @@ public class Mesh implements Disposable {
 				int oldPosition = buffer.position();
 				int oldLimit = buffer.limit();
 				((Buffer)buffer).position(offset);
-				((Buffer)buffer).limit(offset + count);
 				Gdx.gl20.glDrawElements(primitiveType, count, GL20.GL_UNSIGNED_SHORT, buffer);
 				((Buffer)buffer).position(oldPosition);
-				((Buffer)buffer).limit(oldLimit);
 			} else {
 				Gdx.gl20.glDrawArrays(primitiveType, offset, count);
 			}
diff --git a/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestWrapper.java b/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestWrapper.java
index 2d0673778..2eac6712d 100644
--- a/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestWrapper.java
+++ b/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestWrapper.java
@@ -90,6 +90,7 @@ import com.badlogic.gdx.tests.YDownTest;
 import com.badlogic.gdx.tests.conformance.DisplayModeTest;
 import com.badlogic.gdx.tests.g3d.ModelCacheTest;
 import com.badlogic.gdx.tests.g3d.ShadowMappingTest;
+import com.badlogic.gdx.tests.gles2.VertexArrayTest;
 import com.badlogic.gdx.tests.gwt.GwtInputTest;
 import com.badlogic.gdx.tests.gwt.GwtWindowModeTest;
 import com.badlogic.gdx.tests.math.OctreeTest;
@@ -491,6 +492,10 @@ public class GwtTestWrapper extends AbstractTestWrapper {
 				public GdxTest instance () {
 					return new TextAreaTest3();
 				}
+			}, new GwtInstancer() {
+				public GdxTest instance () {
+					return new VertexArrayTest();
+				}
 			} // these may have issues with tab getting intercepted by the browser
 		};
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/gles2/VertexArrayTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles2/VertexArrayTest.java
new file mode 100644
index 000000000..fb7811486
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles2/VertexArrayTest.java
@@ -0,0 +1,114 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tests.gles2;
+
+import java.nio.Buffer;
+import java.nio.ByteBuffer;
+import java.nio.ShortBuffer;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Mesh.VertexDataType;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.tests.utils.GdxTest;
+import com.badlogic.gdx.tests.utils.GdxTestConfig;
+import com.badlogic.gdx.utils.BufferUtils;
+
+/** Touch the screen to cycle over 9 test case : (2 triangles, first triangle, second triangle) x (short buffer/short, byte
+ * buffer/short, byte buffer/byte). */
+@GdxTestConfig(OnlyGL20 = true)
+public class VertexArrayTest extends GdxTest {
+	ShaderProgram shader;
+	Mesh mesh;
+	int[][] testCases = {{0, 0, 6}, {0, 0, 3}, {0, 3, 3}, {1, 0, 6}, {1, 0, 3}, {1, 3, 3}, {2, 0, 6}, {2, 0, 3}, {2, 3, 3}};
+	int testCase = 0;
+	ByteBuffer byteBuffer;
+	ByteBuffer shortsAsByteBuffer;
+
+	@Override
+	public void create () {
+		String vertexShader = "attribute vec4 vPosition;    \n" + "void main()                  \n"
+			+ "{                            \n" + "   gl_Position = vPosition;  \n" + "}                            \n";
+		String fragmentShader = "#ifdef GL_ES\n" + "precision mediump float;\n" + "#endif\n"
+			+ "void main()                                  \n" + "{                                            \n"
+			+ "  gl_FragColor = vec4 ( 1.0, 1.0, 1.0, 1.0 );\n" + "}";
+
+		shader = new ShaderProgram(vertexShader, fragmentShader);
+		mesh = new Mesh(VertexDataType.VertexArray, true, 4, 6, new VertexAttribute(Usage.Position, 3, "vPosition"));
+		float[] vertices = {-0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, -0.5f, 0.5f, 0.0f, 0.5f, 0.5f, 0.0f};
+		mesh.setVertices(vertices);
+
+		short[] indices = {0, 1, 2, 2, 1, 3};
+		mesh.setIndices(indices);
+
+		shortsAsByteBuffer = BufferUtils.newByteBuffer(12);
+		ShortBuffer sb = shortsAsByteBuffer.asShortBuffer();
+		sb.put(indices);
+		sb.flip();
+
+		byteBuffer = BufferUtils.newByteBuffer(6);
+		byteBuffer.put(new byte[] {0, 1, 2, 2, 1, 3});
+		byteBuffer.flip();
+	}
+
+	@Override
+	public void render () {
+		boolean log = false;
+		if (Gdx.input.justTouched()) {
+			testCase = (testCase + 1) % testCases.length;
+			log = true;
+		}
+		int mode = testCases[testCase][0];
+		int offset = testCases[testCase][1];
+		int count = testCases[testCase][2];
+		if (log) {
+			Gdx.app.log("VertexArrayTest", "mode: " + mode + ", offset: " + offset + ", count: " + count);
+		}
+
+		Gdx.gl20.glViewport(0, 0, Gdx.graphics.getBackBufferWidth(), Gdx.graphics.getBackBufferHeight());
+		Gdx.gl20.glClear(GL20.GL_COLOR_BUFFER_BIT);
+		shader.bind();
+		mesh.bind(shader);
+
+		Buffer buffer;
+		int type;
+		if (mode == 0) {
+			type = GL20.GL_UNSIGNED_SHORT;
+			buffer = mesh.getIndicesBuffer();
+			buffer.position(offset);
+		} else if (mode == 1) {
+			type = GL20.GL_UNSIGNED_SHORT;
+			buffer = shortsAsByteBuffer;
+			buffer.position(offset * 2);
+		} else {
+			type = GL20.GL_UNSIGNED_BYTE;
+			buffer = byteBuffer;
+			buffer.position(offset);
+		}
+
+		if (log) {
+			Gdx.app.log("VertexArrayTest", "position: " + buffer.position());
+		}
+
+		Gdx.gl20.glDrawElements(GL20.GL_TRIANGLES, count, type, buffer);
+		buffer.position(0);
+		mesh.unbind(shader);
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/CommandLineOptions.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/CommandLineOptions.java
index 6879bf42e..4f344e858 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/CommandLineOptions.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/CommandLineOptions.java
@@ -37,6 +37,7 @@ public class CommandLineOptions {
 		GdxTestConfig config = clazz.getAnnotation(GdxTestConfig.class);
 		if (config != null) {
 			if (config.requireGL30() && !gl30) return false;
+			if (config.OnlyGL20() && gl30) return false;
 		}
 		return true;
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTestConfig.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTestConfig.java
index 98dbaaca7..930a51cdf 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTestConfig.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTestConfig.java
@@ -11,4 +11,6 @@ import java.lang.annotation.Target;
 @Target(TYPE)
 public @interface GdxTestConfig {
 	boolean requireGL30() default false;
+
+	boolean OnlyGL20() default false;
 }
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index 6197a75b5..76fed1bf5 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -78,6 +78,7 @@ import com.badlogic.gdx.tests.g3d.TextureRegion3DTest;
 import com.badlogic.gdx.tests.g3d.utils.DefaultTextureBinderTest;
 import com.badlogic.gdx.tests.gles2.HelloTriangle;
 import com.badlogic.gdx.tests.gles2.SimpleVertexShader;
+import com.badlogic.gdx.tests.gles2.VertexArrayTest;
 import com.badlogic.gdx.tests.gles3.InstancedRenderingTest;
 import com.badlogic.gdx.tests.gles3.PixelBufferObjectTest;
 import com.badlogic.gdx.tests.net.NetAPITest;
@@ -286,6 +287,7 @@ public class GdxTests {
 		UtfFontTest.class,
 		VBOWithVAOPerformanceTest.class,
 		Vector2dTest.class,
+		VertexArrayTest.class,
 		VertexBufferObjectShaderTest.class,
 		VibratorTest.class,
 		ViewportTest1.class,
