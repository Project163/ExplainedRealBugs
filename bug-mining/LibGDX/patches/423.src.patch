diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OpenALMusic.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OpenALMusic.java
index 39a683e39..c972147f0 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OpenALMusic.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OpenALMusic.java
@@ -25,6 +25,8 @@ import org.lwjgl.openal.AL11;
 import com.badlogic.gdx.audio.Music;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.FloatArray;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
 import static org.lwjgl.openal.AL10.*;
@@ -37,6 +39,8 @@ public abstract class OpenALMusic implements Music {
 	static private final byte[] tempBytes = new byte[bufferSize];
 	static private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(bufferSize);
 
+	private FloatArray renderedSecondsQueue = new FloatArray(bufferCount);
+
 	private final OpenALAudio audio;
 	private IntBuffer buffers;
 	private int sourceID = -1;
@@ -44,7 +48,7 @@ public abstract class OpenALMusic implements Music {
 	private boolean isLooping, isPlaying;
 	private float volume = 1;
 	private float pan = 0;
-	private float renderedSeconds, secondsPerBuffer;
+	private float renderedSeconds, maxSecondsPerBuffer;
 
 	protected final FileHandle file;
 	protected int bufferOverhead = 0;
@@ -60,7 +64,7 @@ public abstract class OpenALMusic implements Music {
 	protected void setup (int channels, int sampleRate) {
 		this.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;
 		this.sampleRate = sampleRate;
-		secondsPerBuffer = (float)(bufferSize - bufferOverhead)  / (bytesPerSample * channels * sampleRate);
+		maxSecondsPerBuffer = (float)(bufferSize - bufferOverhead) / (bytesPerSample * channels * sampleRate);
 	}
 
 	public void play () {
@@ -75,7 +79,8 @@ public abstract class OpenALMusic implements Music {
 				buffers = BufferUtils.createIntBuffer(bufferCount);
 				alGenBuffers(buffers);
 				int errorCode = alGetError();
-				if (errorCode != AL_NO_ERROR) throw new GdxRuntimeException("Unable to allocate audio buffers. AL Error: " + errorCode);
+				if (errorCode != AL_NO_ERROR)
+					throw new GdxRuntimeException("Unable to allocate audio buffers. AL Error: " + errorCode);
 			}
 			alSourcei(sourceID, AL_LOOPING, AL_FALSE);
 			setPan(pan, volume);
@@ -158,15 +163,18 @@ public abstract class OpenALMusic implements Music {
 		isPlaying = false;
 		alSourceStop(sourceID);
 		alSourceUnqueueBuffers(sourceID, buffers);
-		renderedSeconds += (secondsPerBuffer * bufferCount);
+		while (renderedSecondsQueue.size > 0) {
+			renderedSeconds = renderedSecondsQueue.pop();
+		}
 		if (position <= renderedSeconds) {
 			reset();
 			renderedSeconds = 0;
 		}
-		while (renderedSeconds < (position - secondsPerBuffer)) {
+		while (renderedSeconds < (position - maxSecondsPerBuffer)) {
 			if (read(tempBytes) <= 0) break;
-			renderedSeconds += secondsPerBuffer;
+			renderedSeconds += maxSecondsPerBuffer;
 		}
+		renderedSecondsQueue.add(renderedSeconds);
 		boolean filled = false;
 		for (int i = 0; i < bufferCount; i++) {
 			int bufferID = buffers.get(i);
@@ -174,6 +182,7 @@ public abstract class OpenALMusic implements Music {
 			filled = true;
 			alSourceQueueBuffers(sourceID, bufferID);
 		}
+		renderedSecondsQueue.pop();
 		if (!filled) {
 			stop();
 			if (onCompletionListener != null) onCompletionListener.onCompletion(this);
@@ -220,7 +229,7 @@ public abstract class OpenALMusic implements Music {
 		while (buffers-- > 0) {
 			int bufferID = alSourceUnqueueBuffers(sourceID);
 			if (bufferID == AL_INVALID_VALUE) break;
-			renderedSeconds += secondsPerBuffer;
+			renderedSeconds = renderedSecondsQueue.pop();
 			if (end) continue;
 			if (fill(bufferID))
 				alSourceQueueBuffers(sourceID, bufferID);
@@ -242,12 +251,18 @@ public abstract class OpenALMusic implements Music {
 		if (length <= 0) {
 			if (isLooping) {
 				loop();
-				renderedSeconds = 0;
 				length = read(tempBytes);
 				if (length <= 0) return false;
+				if (renderedSecondsQueue.size > 0) {
+					renderedSecondsQueue.set(0, 0);
+				}
 			} else
 				return false;
 		}
+		float previousLoadedSeconds = renderedSecondsQueue.size > 0 ? renderedSecondsQueue.first() : 0;
+		float currentBufferSeconds = maxSecondsPerBuffer * (float)length / (float)bufferSize;
+		renderedSecondsQueue.insert(0, previousLoadedSeconds + currentBufferSeconds);
+
 		tempBuffer.put(tempBytes, 0, length).flip();
 		alBufferData(bufferID, format, tempBuffer, sampleRate);
 		return true;
diff --git a/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/audio/OpenALMusic.java b/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/audio/OpenALMusic.java
index 384ce920f..211514dc6 100644
--- a/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/audio/OpenALMusic.java
+++ b/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/audio/OpenALMusic.java
@@ -25,6 +25,8 @@ import org.lwjgl.openal.AL11;
 import com.badlogic.gdx.audio.Music;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.FloatArray;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
 import static org.lwjgl.openal.AL10.*;
@@ -38,6 +40,8 @@ public abstract class OpenALMusic implements Music {
 	static private final byte[] tempBytes = new byte[bufferSize];
 	static private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(bufferSize);
 
+	private FloatArray renderedSecondsQueue = new FloatArray(bufferCount);
+
 	private final OpenALAudio audio;
 	private IntBuffer buffers;
 	private int sourceID = -1;
@@ -45,7 +49,7 @@ public abstract class OpenALMusic implements Music {
 	private boolean isLooping, isPlaying;
 	private float volume = 1;
 	private float pan = 0;
-	private float renderedSeconds, secondsPerBuffer;
+	private float renderedSeconds, maxSecondsPerBuffer;
 
 	protected final FileHandle file;
 	protected int bufferOverhead = 0;
@@ -61,7 +65,7 @@ public abstract class OpenALMusic implements Music {
 	protected void setup (int channels, int sampleRate) {
 		this.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;
 		this.sampleRate = sampleRate;
-		secondsPerBuffer = (float)(bufferSize - bufferOverhead)  / (bytesPerSample * channels * sampleRate);
+		maxSecondsPerBuffer = (float)(bufferSize - bufferOverhead) / (bytesPerSample * channels * sampleRate);
 	}
 
 	public void play () {
@@ -76,7 +80,8 @@ public abstract class OpenALMusic implements Music {
 				buffers = BufferUtils.createIntBuffer(bufferCount);
 				alGenBuffers(buffers);
 				int errorCode = alGetError();
-				if (errorCode != AL_NO_ERROR) throw new GdxRuntimeException("Unable to allocate audio buffers. AL Error: " + errorCode);
+				if (errorCode != AL_NO_ERROR)
+					throw new GdxRuntimeException("Unable to allocate audio buffers. AL Error: " + errorCode);
 			}
 
 			alSourcei(sourceID, AL_DIRECT_CHANNELS_SOFT, AL_TRUE);
@@ -161,15 +166,18 @@ public abstract class OpenALMusic implements Music {
 		isPlaying = false;
 		alSourceStop(sourceID);
 		alSourceUnqueueBuffers(sourceID, buffers);
-		renderedSeconds += (secondsPerBuffer * bufferCount);
+		while (renderedSecondsQueue.size > 0) {
+			renderedSeconds = renderedSecondsQueue.pop();
+		}
 		if (position <= renderedSeconds) {
 			reset();
 			renderedSeconds = 0;
 		}
-		while (renderedSeconds < (position - secondsPerBuffer)) {
+		while (renderedSeconds < (position - maxSecondsPerBuffer)) {
 			if (read(tempBytes) <= 0) break;
-			renderedSeconds += secondsPerBuffer;
+			renderedSeconds += maxSecondsPerBuffer;
 		}
+		renderedSecondsQueue.add(renderedSeconds);
 		boolean filled = false;
 		for (int i = 0; i < bufferCount; i++) {
 			int bufferID = buffers.get(i);
@@ -177,6 +185,7 @@ public abstract class OpenALMusic implements Music {
 			filled = true;
 			alSourceQueueBuffers(sourceID, bufferID);
 		}
+		renderedSecondsQueue.pop();
 		if (!filled) {
 			stop();
 			if (onCompletionListener != null) onCompletionListener.onCompletion(this);
@@ -223,7 +232,7 @@ public abstract class OpenALMusic implements Music {
 		while (buffers-- > 0) {
 			int bufferID = alSourceUnqueueBuffers(sourceID);
 			if (bufferID == AL_INVALID_VALUE) break;
-			renderedSeconds += secondsPerBuffer;
+			renderedSeconds = renderedSecondsQueue.pop();
 			if (end) continue;
 			if (fill(bufferID))
 				alSourceQueueBuffers(sourceID, bufferID);
@@ -245,12 +254,18 @@ public abstract class OpenALMusic implements Music {
 		if (length <= 0) {
 			if (isLooping) {
 				loop();
-				renderedSeconds = 0;
 				length = read(tempBytes);
 				if (length <= 0) return false;
+				if (renderedSecondsQueue.size > 0) {
+					renderedSecondsQueue.set(0, 0);
+				}
 			} else
 				return false;
 		}
+		float previousLoadedSeconds = renderedSecondsQueue.size > 0 ? renderedSecondsQueue.first() : 0;
+		float currentBufferSeconds = maxSecondsPerBuffer * (float)length / (float)bufferSize;
+		renderedSecondsQueue.insert(0, previousLoadedSeconds + currentBufferSeconds);
+
 		tempBuffer.put(tempBytes, 0, length).flip();
 		alBufferData(bufferID, format, tempBuffer, sampleRate);
 		return true;
diff --git a/tests/gdx-tests-android/assets/data/8.12.loop.wav b/tests/gdx-tests-android/assets/data/8.12.loop.wav
new file mode 100644
index 000000000..ad1409405
Binary files /dev/null and b/tests/gdx-tests-android/assets/data/8.12.loop.wav differ
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/MusicTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/MusicTest.java
index 62fe02427..0a15c7e04 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/MusicTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/MusicTest.java
@@ -25,16 +25,19 @@ import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.ui.SelectBox;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Slider;
+import com.badlogic.gdx.scenes.scene2d.ui.Table;
 import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
 import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
+import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class MusicTest extends GdxTest {
 
 	Music music;
-	float songDuration = 183;
+	float songDuration;
 	float currentPosition;
 
 	TextureRegion buttons;
@@ -44,11 +47,14 @@ public class MusicTest extends GdxTest {
 	Stage stage;
 	Slider slider;
 	boolean sliderUpdating = false;
+	SelectBox<Song> musicBox;
+
+	enum Song {
+		MP3, OGG, WAV
+	}
 
 	@Override
 	public void create () {
-		music = Gdx.audio.newMusic(Gdx.files.internal("data/8.12.mp3"));
-		music.play();
 
 		buttons = new TextureRegion(new Texture(Gdx.files.internal("data/playback.png")));
 		batch = new SpriteBatch();
@@ -64,11 +70,50 @@ public class MusicTest extends GdxTest {
 				if (!sliderUpdating && slider.isDragging()) music.setPosition((slider.getValue() / 100f) * songDuration);
 			}
 		});
+
+		musicBox = new SelectBox<Song>(skin);
+		musicBox.setItems(Song.values());
+		musicBox.addListener(new ChangeListener() {
+			@Override
+			public void changed (ChangeEvent event, Actor actor) {
+				setSong(musicBox.getSelected());
+			}
+		});
+		setSong(musicBox.getSelected());
+
+		Table table = new Table(skin);
+		table.add(musicBox);
+		table.setFillParent(true);
+		stage.addActor(table);
+
 		stage.addActor(slider);
 
 		Gdx.input.setInputProcessor(stage);
 	}
 
+	void setSong (Song song) {
+		if (music != null) {
+			music.dispose();
+		}
+		switch (song) {
+		default:
+		case MP3:
+			music = Gdx.audio.newMusic(Gdx.files.internal("data/8.12.mp3"));
+			songDuration = 183;
+			break;
+		case OGG:
+			music = Gdx.audio.newMusic(Gdx.files.internal("data/cloudconnected.ogg"));
+			songDuration = 22;
+			break;
+		case WAV:
+			music = Gdx.audio.newMusic(Gdx.files.internal("data/8.12.loop.wav"));
+			songDuration = 4;
+			break;
+		}
+		music.setLooping(true);
+		music.play();
+	}
+
 	@Override
 	public void resize (int width, int height) {
 		batch.getProjectionMatrix().setToOrtho2D(0, 0, width, height);
