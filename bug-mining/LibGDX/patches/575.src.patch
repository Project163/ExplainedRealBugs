diff --git a/CHANGES b/CHANGES
index e315ff4f8..a9b08430a 100644
--- a/CHANGES
+++ b/CHANGES
@@ -9,6 +9,7 @@
 - [BREAKING CHANGE] WidgetGroup#hit first validates the layout.
 - [BREAKING CHANGE] Cell getters return object wrapper instead of primitives.
 - [BREAKING CHANGE] MeshPartBuilder#lastIndex now returns int instead of short.
+- [BREAKING CHANGE] Mesh#getVerticesBuffer, Mesh#getIndicesBuffer, VertexData#getBuffer, and IndexData#getBuffer are deprecated in favor to new methods with boolean parameter. If you subclassed some of these classes, you need to implement the new methods.
 - iOS: Add new MobiVM MetalANGLE backend
 - API Addition: Added Haptics API with 4 different Input#vibrate() methods with complete Android and iOS implementations.
 - Fix: Fixed Android and iOS touch cancelled related issues, see #6871.
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
index 038e9d901..e87915332 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
@@ -136,18 +136,20 @@ public class IndexBufferObject implements IndexData {
 		}
 	}
 
-	/**
-	 * <p>
-	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
-	 * If you need immediate uploading use {@link #setIndices(short[], int, int)}.
-	 * </p>
-	 * 
-	 * @return the underlying short buffer. */
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
+	@Override
+	@Deprecated
 	public ShortBuffer getBuffer () {
 		isDirty = true;
 		return buffer;
 	}
 
+	@Override
+	public ShortBuffer getBuffer (boolean forWriting) {
+		isDirty |= forWriting;
+		return buffer;
+	}
+
 	/** Binds this IndexBufferObject for rendering with glDrawElements. */
 	public void bind () {
 		if (bufferHandle == 0) throw new GdxRuntimeException("No buffer allocated!");
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
index 99f271d35..fddb8ff63 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
@@ -96,12 +96,20 @@ public class VertexBufferObject implements VertexData {
 		return buffer.capacity() / (attributes.vertexSize / 4);
 	}
 
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
 	@Override
+	@Deprecated
 	public FloatBuffer getBuffer () {
 		isDirty = true;
 		return buffer;
 	}
 
+	@Override
+	public FloatBuffer getBuffer (boolean forWriting) {
+		isDirty |= forWriting;
+		return buffer;
+	}
+
 	private void bufferChanged () {
 		if (isBound) {
 			Gdx.gl20.glBufferData(GL20.GL_ARRAY_BUFFER, buffer.limit(), buffer, usage);
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
index 77cb6a705..28b7c9429 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
@@ -83,12 +83,20 @@ public class VertexBufferObjectWithVAO implements VertexData {
 		return buffer.capacity() * 4 / attributes.vertexSize;
 	}
 
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
 	@Override
+	@Deprecated
 	public FloatBuffer getBuffer () {
 		isDirty = true;
 		return buffer;
 	}
 
+	@Override
+	public FloatBuffer getBuffer (boolean forWriting) {
+		isDirty |= forWriting;
+		return buffer;
+	}
+
 	private void bufferChanged () {
 		if (isBound) {
 			Gdx.gl20.glBufferData(GL20.GL_ARRAY_BUFFER, buffer.limit(), buffer, usage);
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btIndexedMesh.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btIndexedMesh.java
index 8629abd2b..78d02d748 100644
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btIndexedMesh.java
+++ b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btIndexedMesh.java
@@ -172,8 +172,7 @@ public class btIndexedMesh extends BulletBase {
 
 		if (posAttr == null) throw new com.badlogic.gdx.utils.GdxRuntimeException("Mesh doesn't have a position attribute");
 
-		set(tag, mesh.getVerticesBuffer(), mesh.getVertexSize(), mesh.getNumVertices(), posAttr.offset, mesh.getIndicesBuffer(),
-			offset, count);
+		set(tag, mesh.getVerticesBuffer(false), mesh.getVertexSize(), mesh.getNumVertices(), posAttr.offset, mesh.getIndicesBuffer(false), offset, count);
 	}
 
 	/** Convenience method to set this btIndexedMesh to the specified vertex and index data. The specified data must be indexed and
diff --git a/gdx/src/com/badlogic/gdx/graphics/Mesh.java b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
index 0e7550ebb..b51d8ab0c 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Mesh.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
@@ -389,10 +389,10 @@ public class Mesh implements Disposable {
 			throw new IndexOutOfBoundsException();
 		if ((vertices.length - destOffset) < count) throw new IllegalArgumentException(
 			"not enough room in vertices array, has " + vertices.length + " floats, needs " + count);
-		int pos = getVerticesBuffer().position();
-		((Buffer)getVerticesBuffer()).position(srcOffset);
-		getVerticesBuffer().get(vertices, destOffset, count);
-		((Buffer)getVerticesBuffer()).position(pos);
+		int pos = getVerticesBuffer(false).position();
+		((Buffer) getVerticesBuffer(false)).position(srcOffset);
+		getVerticesBuffer(false).get(vertices, destOffset, count);
+		((Buffer) getVerticesBuffer(false)).position(pos);
 		return vertices;
 	}
 
@@ -454,10 +454,10 @@ public class Mesh implements Disposable {
 			"Invalid range specified, offset: " + srcOffset + ", count: " + count + ", max: " + max);
 		if ((indices.length - destOffset) < count) throw new IllegalArgumentException(
 			"not enough room in indices array, has " + indices.length + " shorts, needs " + count);
-		int pos = getIndicesBuffer().position();
-		((Buffer)getIndicesBuffer()).position(srcOffset);
-		getIndicesBuffer().get(indices, destOffset, count);
-		((Buffer)getIndicesBuffer()).position(pos);
+		int pos = getIndicesBuffer(false).position();
+		((Buffer) getIndicesBuffer(false)).position(srcOffset);
+		getIndicesBuffer(false).get(indices, destOffset, count);
+		((Buffer) getIndicesBuffer(false)).position(pos);
 	}
 
 	/** @return the number of defined indices */
@@ -617,7 +617,7 @@ public class Mesh implements Disposable {
 
 		if (isVertexArray) {
 			if (indices.getNumIndices() > 0) {
-				ShortBuffer buffer = indices.getBuffer();
+				ShortBuffer buffer = indices.getBuffer(false);
 				int oldPosition = buffer.position();
 				int oldLimit = buffer.limit();
 				((Buffer)buffer).position(offset);
@@ -679,9 +679,15 @@ public class Mesh implements Disposable {
 		return vertices.getAttributes();
 	}
 
-	/** @return the backing FloatBuffer holding the vertices. Does not have to be a direct buffer on Android! */
+	/** @return the backing FloatBuffer holding the vertices. Does not have to be a direct buffer on Android!
+	 * @deprecated use {@link #getVerticesBuffer(boolean)} instead */
+	@Deprecated
 	public FloatBuffer getVerticesBuffer () {
-		return vertices.getBuffer();
+		return vertices.getBuffer(true);
+	}
+
+	public FloatBuffer getVerticesBuffer (boolean forWriting) {
+		return vertices.getBuffer(forWriting);
 	}
 
 	/** Calculates the {@link BoundingBox} of the vertices contained in this mesh. In case no vertices are defined yet a
@@ -702,7 +708,7 @@ public class Mesh implements Disposable {
 		final int numVertices = getNumVertices();
 		if (numVertices == 0) throw new GdxRuntimeException("No vertices defined");
 
-		final FloatBuffer verts = vertices.getBuffer();
+		final FloatBuffer verts = vertices.getBuffer(false);
 		bbox.inf();
 		final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);
 		final int offset = posAttrib.offset / 4;
@@ -772,8 +778,8 @@ public class Mesh implements Disposable {
 		if (offset < 0 || count < 1 || offset + count > max)
 			throw new GdxRuntimeException("Invalid part specified ( offset=" + offset + ", count=" + count + ", max=" + max + " )");
 
-		final FloatBuffer verts = vertices.getBuffer();
-		final ShortBuffer index = indices.getBuffer();
+		final FloatBuffer verts = vertices.getBuffer(false);
+		final ShortBuffer index = indices.getBuffer(false);
 		final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);
 		final int posoff = posAttrib.offset / 4;
 		final int vertexSize = vertices.getAttributes().vertexSize / 4;
@@ -847,8 +853,8 @@ public class Mesh implements Disposable {
 		int numIndices = getNumIndices();
 		if (offset < 0 || count < 1 || offset + count > numIndices) throw new GdxRuntimeException("Not enough indices");
 
-		final FloatBuffer verts = vertices.getBuffer();
-		final ShortBuffer index = indices.getBuffer();
+		final FloatBuffer verts = vertices.getBuffer(false);
+		final ShortBuffer index = indices.getBuffer(false);
 		final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);
 		final int posoff = posAttrib.offset / 4;
 		final int vertexSize = vertices.getAttributes().vertexSize / 4;
@@ -945,9 +951,14 @@ public class Mesh implements Disposable {
 		return calculateRadius(center.x, center.y, center.z, 0, getNumIndices(), null);
 	}
 
-	/** @return the backing shortbuffer holding the indices. Does not have to be a direct buffer on Android! */
+	/** @return the backing shortbuffer holding the indices. Does not have to be a direct buffer on Android!
+	 * @deprecated use {@link #getIndicesBuffer(boolean)} instead */
 	public ShortBuffer getIndicesBuffer () {
-		return indices.getBuffer();
+		return indices.getBuffer(true);
+	}
+
+	public ShortBuffer getIndicesBuffer (boolean forWriting) {
+		return indices.getBuffer(forWriting);
 	}
 
 	private static void addManagedMesh (Application app, Mesh mesh) {
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
index 2c3a41313..0d5ee022f 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
@@ -956,8 +956,8 @@ public class SpriteBatch implements Batch {
 		lastTexture.bind();
 		Mesh mesh = this.mesh;
 		mesh.setVertices(vertices, 0, idx);
-		((Buffer)mesh.getIndicesBuffer()).position(0);
-		((Buffer)mesh.getIndicesBuffer()).limit(count);
+		((Buffer) mesh.getIndicesBuffer(true)).position(0);
+		((Buffer) mesh.getIndicesBuffer(true)).limit(count);
 
 		if (blendingDisabled) {
 			Gdx.gl.glDisable(GL20.GL_BLEND);
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java
index 887dab74a..7b7cef137 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java
@@ -171,9 +171,9 @@ public class SpriteCache implements Disposable {
 		if (drawing) throw new IllegalStateException("end must be called before beginCache");
 		if (currentCache != null) throw new IllegalStateException("endCache must be called before begin.");
 		int verticesPerImage = mesh.getNumIndices() > 0 ? 4 : 6;
-		currentCache = new Cache(caches.size, mesh.getVerticesBuffer().limit());
+		currentCache = new Cache(caches.size, mesh.getVerticesBuffer(false).limit());
 		caches.add(currentCache);
-		mesh.getVerticesBuffer().compact();
+		mesh.getVerticesBuffer(true).compact();
 	}
 
 	/** Starts the redefinition of an existing cache, allowing the add and {@link #endCache()} methods to be called. If this is not
@@ -184,19 +184,19 @@ public class SpriteCache implements Disposable {
 		if (currentCache != null) throw new IllegalStateException("endCache must be called before begin.");
 		if (cacheID == caches.size - 1) {
 			Cache oldCache = caches.removeIndex(cacheID);
-			((Buffer)mesh.getVerticesBuffer()).limit(oldCache.offset);
+			((Buffer) mesh.getVerticesBuffer(true)).limit(oldCache.offset);
 			beginCache();
 			return;
 		}
 		currentCache = caches.get(cacheID);
-		((Buffer)mesh.getVerticesBuffer()).position(currentCache.offset);
+		((Buffer) mesh.getVerticesBuffer(true)).position(currentCache.offset);
 	}
 
 	/** Ends the definition of a cache, returning the cache ID to be used with {@link #draw(int)}. */
 	public int endCache () {
 		if (currentCache == null) throw new IllegalStateException("beginCache must be called before endCache.");
 		Cache cache = currentCache;
-		int cacheCount = mesh.getVerticesBuffer().position() - cache.offset;
+		int cacheCount = mesh.getVerticesBuffer(false).position() - cache.offset;
 		if (cache.textures == null) {
 			// New cache.
 			cache.maxCount = cacheCount;
@@ -206,7 +206,7 @@ public class SpriteCache implements Disposable {
 			for (int i = 0, n = counts.size; i < n; i++)
 				cache.counts[i] = counts.get(i);
 
-			((Buffer)mesh.getVerticesBuffer()).flip();
+			((Buffer) mesh.getVerticesBuffer(true)).flip();
 		} else {
 			// Redefine existing cache.
 			if (cacheCount > cache.maxCount) {
@@ -225,7 +225,7 @@ public class SpriteCache implements Disposable {
 			for (int i = 0, n = cache.textureCount; i < n; i++)
 				cache.counts[i] = counts.get(i);
 
-			FloatBuffer vertices = mesh.getVerticesBuffer();
+			FloatBuffer vertices = mesh.getVerticesBuffer(true);
 			((Buffer)vertices).position(0);
 			Cache lastCache = caches.get(caches.size - 1);
 			((Buffer)vertices).limit(lastCache.offset + lastCache.maxCount);
@@ -241,7 +241,7 @@ public class SpriteCache implements Disposable {
 	/** Invalidates all cache IDs and resets the SpriteCache so new caches can be added. */
 	public void clear () {
 		caches.clear();
-		((Buffer)mesh.getVerticesBuffer()).clear().flip();
+		((Buffer) mesh.getVerticesBuffer(true)).clear().flip();
 	}
 
 	/** Adds the specified vertices to the cache. Each vertex should have 5 elements, one for each of the attributes: x, y, color,
@@ -259,7 +259,7 @@ public class SpriteCache implements Disposable {
 		} else
 			counts.incr(lastIndex, count);
 
-		mesh.getVerticesBuffer().put(vertices, offset, length);
+		mesh.getVerticesBuffer(true).put(vertices, offset, length);
 	}
 
 	/** Adds the specified texture to the cache. */
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java
index 67db48578..1aba19755 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java
@@ -247,9 +247,9 @@ public class Model implements Disposable {
 		meshes.add(mesh);
 		disposables.add(mesh);
 
-		BufferUtils.copy(modelMesh.vertices, mesh.getVerticesBuffer(), modelMesh.vertices.length, 0);
+		BufferUtils.copy(modelMesh.vertices, mesh.getVerticesBuffer(true), modelMesh.vertices.length, 0);
 		int offset = 0;
-		((Buffer)mesh.getIndicesBuffer()).clear();
+		((Buffer) mesh.getIndicesBuffer(true)).clear();
 		for (ModelMeshPart part : modelMesh.parts) {
 			MeshPart meshPart = new MeshPart();
 			meshPart.id = part.id;
@@ -258,12 +258,12 @@ public class Model implements Disposable {
 			meshPart.size = hasIndices ? part.indices.length : numVertices;
 			meshPart.mesh = mesh;
 			if (hasIndices) {
-				mesh.getIndicesBuffer().put(part.indices);
+				mesh.getIndicesBuffer(true).put(part.indices);
 			}
 			offset += meshPart.size;
 			meshParts.add(meshPart);
 		}
-		((Buffer)mesh.getIndicesBuffer()).position(0);
+		((Buffer) mesh.getIndicesBuffer(true)).position(0);
 		for (MeshPart part : meshParts)
 			part.update();
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java
index bb833a514..287bbc8b2 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java
@@ -95,17 +95,18 @@ public class IndexArray implements IndexData {
 		((Buffer)byteBuffer).position(pos);
 	}
 
-	/**
-	 * <p>
-	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
-	 * If you need immediate uploading use {@link #setIndices(short[], int, int)}.
-	 * </p>
-	 *
-	 * @return the underlying short buffer. */
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
+	@Override
+	@Deprecated
 	public ShortBuffer getBuffer () {
 		return buffer;
 	}
 
+	@Override
+	public ShortBuffer getBuffer (boolean forWriting) {
+		return buffer;
+	}
+
 	/** Binds this IndexArray for rendering with glDrawElements. */
 	public void bind () {
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
index 8353d6137..d932b50c3 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
@@ -168,18 +168,20 @@ public class IndexBufferObject implements IndexData {
 		}
 	}
 
-	/**
-	 * <p>
-	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
-	 * If you need immediate uploading use {@link #setIndices(short[], int, int)}.
-	 * </p>
-	 *
-	 * @return the underlying short buffer. */
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
+	@Override
+	@Deprecated
 	public ShortBuffer getBuffer () {
 		isDirty = true;
 		return buffer;
 	}
 
+	@Override
+	public ShortBuffer getBuffer (boolean forWriting) {
+		isDirty |= forWriting;
+		return buffer;
+	}
+
 	/** Binds this IndexBufferObject for rendering with glDrawElements. */
 	public void bind () {
 		if (bufferHandle == 0) throw new GdxRuntimeException("No buffer allocated!");
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObjectSubData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObjectSubData.java
index 43fa21fd5..4bddfe8d4 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObjectSubData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObjectSubData.java
@@ -155,18 +155,20 @@ public class IndexBufferObjectSubData implements IndexData {
 		}
 	}
 
-	/**
-	 * <p>
-	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
-	 * If you need immediate uploading use {@link #setIndices(short[], int, int)}.
-	 * </p>
-	 *
-	 * @return the underlying short buffer. */
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
+	@Override
+	@Deprecated
 	public ShortBuffer getBuffer () {
 		isDirty = true;
 		return buffer;
 	}
 
+	@Override
+	public ShortBuffer getBuffer (boolean forWriting) {
+		isDirty |= forWriting;
+		return buffer;
+	}
+
 	/** Binds this IndexBufferObject for rendering with glDrawElements. */
 	public void bind () {
 		if (bufferHandle == 0) throw new GdxRuntimeException("IndexBufferObject cannot be used after it has been disposed.");
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexData.java
index 2865027a0..3f6a45cff 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexData.java
@@ -60,13 +60,20 @@ public interface IndexData extends Disposable {
 
 	/**
 	 * <p>
-	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
+	 * Returns the underlying ShortBuffer. If you modify the buffer contents they will be uploaded on the next call to {@link #bind()}.
 	 * If you need immediate uploading use {@link #setIndices(short[], int, int)}.
 	 * </p>
 	 * 
-	 * @return the underlying short buffer. */
+	 * @return the underlying short buffer.
+	 * @deprecated use {@link #getBuffer(boolean)} instead */
 	public ShortBuffer getBuffer ();
 
+	/** Returns the underlying ShortBuffer for reading or writing.
+	 * @param forWriting when true, the underlying buffer will be uploaded on the next call to {@link #bind()}. If you need
+	 *           immediate uploading use {@link #setIndices(short[], int, int)}.
+	 * @return the underlying short buffer. */
+	public ShortBuffer getBuffer (boolean forWriting);
+
 	/** Binds this IndexBufferObject for rendering with glDrawElements. */
 	public void bind ();
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
index 67971f24a..635130e88 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
@@ -67,12 +67,19 @@ public class VertexArray implements VertexData {
 		BufferUtils.disposeUnsafeByteBuffer(byteBuffer);
 	}
 
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
 	@Override
+	@Deprecated
 	public FloatBuffer getBuffer () {
 		return buffer;
 	}
 
 	@Override
+	public FloatBuffer getBuffer (boolean forWriting) {
+		return buffer;
+	}
+
+	@Override
 	public int getNumVertices () {
 		return buffer.limit() * 4 / attributes.vertexSize;
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
index cb039cacf..da4880abd 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
@@ -94,12 +94,20 @@ public class VertexBufferObject implements VertexData {
 		return byteBuffer.capacity() / attributes.vertexSize;
 	}
 
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
 	@Override
+	@Deprecated
 	public FloatBuffer getBuffer () {
 		isDirty = true;
 		return buffer;
 	}
 
+	@Override
+	public FloatBuffer getBuffer (boolean forWriting) {
+		isDirty |= forWriting;
+		return buffer;
+	}
+
 	/** Low level method to reset the buffer and attributes to the specified values. Use with care!
 	 * @param data
 	 * @param ownsBuffer
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java
index 92e15574b..b1bfb8925 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java
@@ -100,12 +100,20 @@ public class VertexBufferObjectSubData implements VertexData {
 		return byteBuffer.capacity() / attributes.vertexSize;
 	}
 
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
 	@Override
+	@Deprecated
 	public FloatBuffer getBuffer () {
 		isDirty = true;
 		return buffer;
 	}
 
+	@Override
+	public FloatBuffer getBuffer (boolean forWriting) {
+		isDirty |= forWriting;
+		return buffer;
+	}
+
 	private void bufferChanged () {
 		if (isBound) {
 			Gdx.gl20.glBufferSubData(GL20.GL_ARRAY_BUFFER, 0, byteBuffer.limit(), byteBuffer);
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
index 7a0ec874f..92b1a80cd 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
@@ -104,12 +104,20 @@ public class VertexBufferObjectWithVAO implements VertexData {
 		return byteBuffer.capacity() / attributes.vertexSize;
 	}
 
+	/** @deprecated use {@link #getBuffer(boolean)} instead */
 	@Override
+	@Deprecated
 	public FloatBuffer getBuffer () {
 		isDirty = true;
 		return buffer;
 	}
 
+	@Override
+	public FloatBuffer getBuffer (boolean forWriting) {
+		isDirty |= forWriting;
+		return buffer;
+	}
+
 	private void bufferChanged () {
 		if (isBound) {
 			Gdx.gl20.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java
index ab8a040b8..3f7097322 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java
@@ -54,9 +54,17 @@ public interface VertexData extends Disposable {
 	/** Returns the underlying FloatBuffer and marks it as dirty, causing the buffer contents to be uploaded on the next call to
 	 * bind. If you need immediate uploading use {@link #setVertices(float[], int, int)}; Any modifications made to the Buffer
 	 * *after* the call to bind will not automatically be uploaded.
-	 * @return the underlying FloatBuffer holding the vertex data. */
+	 * @return the underlying FloatBuffer holding the vertex data.
+	 * @deprecated use {@link #getBuffer(boolean)} instead. */
+	@Deprecated
 	public FloatBuffer getBuffer ();
 
+	/** Returns the underlying FloatBuffer for reading or writing.
+	 * @param forWriting when true, the underlying buffer will be uploaded on the next call to bind. If you need immediate
+	 *           uploading use {@link #setVertices(float[], int, int)}.
+	 * @return the underlying FloatBuffer holding the vertex data. */
+	public FloatBuffer getBuffer (boolean forWriting);
+
 	/** Binds this VertexData for rendering via glDrawArrays or glDrawElements. */
 	public void bind (ShaderProgram shader);
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/VBOWithVAOPerformanceTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/VBOWithVAOPerformanceTest.java
index e032b2758..72142d0e8 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/VBOWithVAOPerformanceTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/VBOWithVAOPerformanceTest.java
@@ -346,11 +346,18 @@ public class VBOWithVAOPerformanceTest extends GdxTest {
 			return byteBuffer.capacity() / attributes.vertexSize;
 		}
 
+		@Deprecated
 		@Override
 		public FloatBuffer getBuffer () {
 			isDirty = true;
 			return buffer;
 		}
+		
+		@Override
+		public FloatBuffer getBuffer (boolean forWriting) {
+			isDirty |= forWriting;
+			return buffer;
+		}
 
 		private void bufferChanged () {
 			if (isBound) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/VertexBufferObjectShaderTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/VertexBufferObjectShaderTest.java
index 65cedbff1..056f697ae 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/VertexBufferObjectShaderTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/VertexBufferObjectShaderTest.java
@@ -55,7 +55,7 @@ public class VertexBufferObjectShaderTest extends GdxTest {
 		texture.bind();
 		vbo.bind(shader);
 		indices.bind();
-		gl.glDrawElements(GL20.GL_TRIANGLES, 3, GL20.GL_UNSIGNED_SHORT, indices.getBuffer().position());
+		gl.glDrawElements(GL20.GL_TRIANGLES, 3, GL20.GL_UNSIGNED_SHORT, indices.getBuffer(false).position());
 		indices.unbind();
 		vbo.unbind(shader);
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullDistanceTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullDistanceTest.java
index b657eb4ce..3d6f24330 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullDistanceTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullDistanceTest.java
@@ -97,7 +97,7 @@ public class ConvexHullDistanceTest extends BaseBulletTest {
 
 	public static btConvexHullShape createConvexHullShape (final Model model, boolean optimize) {
 		final Mesh mesh = model.meshes.get(0);
-		final btConvexHullShape shape = new btConvexHullShape(mesh.getVerticesBuffer(), mesh.getNumVertices(),
+		final btConvexHullShape shape = new btConvexHullShape(mesh.getVerticesBuffer(false), mesh.getNumVertices(),
 			mesh.getVertexSize());
 		if (!optimize) return shape;
 		// now optimize the shape
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java
index f6db0991d..eec3ea68f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java
@@ -54,7 +54,7 @@ public class ConvexHullTest extends BaseBulletTest {
 
 	public static btConvexHullShape createConvexHullShape (final Model model, boolean optimize) {
 		final Mesh mesh = model.meshes.get(0);
-		final btConvexHullShape shape = new btConvexHullShape(mesh.getVerticesBuffer(), mesh.getNumVertices(),
+		final btConvexHullShape shape = new btConvexHullShape(mesh.getVerticesBuffer(false), mesh.getNumVertices(),
 			mesh.getVertexSize());
 		if (!optimize) return shape;
 		// now optimize the shape
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftBodyTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftBodyTest.java
index 1d38ef91f..1312ca6d6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftBodyTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftBodyTest.java
@@ -98,12 +98,12 @@ public class SoftBodyTest extends BaseBulletTest {
 			new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE),
 			new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
 		final int vertSize = mesh.getVertexSize() / 4;
-		((Buffer)mesh.getVerticesBuffer()).position(0);
-		((Buffer)mesh.getVerticesBuffer()).limit(vertCount * vertSize);
-		((Buffer)mesh.getIndicesBuffer()).position(0);
-		((Buffer)mesh.getIndicesBuffer()).limit(faceCount * 3);
-		softBody.getVertices(mesh.getVerticesBuffer(), vertCount, mesh.getVertexSize(), 0);
-		softBody.getIndices(mesh.getIndicesBuffer(), faceCount);
+		((Buffer) mesh.getVerticesBuffer(true)).position(0);
+		((Buffer) mesh.getVerticesBuffer(true)).limit(vertCount * vertSize);
+		((Buffer) mesh.getIndicesBuffer(true)).position(0);
+		((Buffer) mesh.getIndicesBuffer(true)).limit(faceCount * 3);
+		softBody.getVertices(mesh.getVerticesBuffer(true), vertCount, mesh.getVertexSize(), 0);
+		softBody.getIndices(mesh.getIndicesBuffer(true), faceCount);
 
 		final float[] verts = new float[vertCount * vertSize];
 		final int uvOffset = mesh.getVertexAttribute(Usage.TextureCoordinates).offset / 4;
@@ -150,7 +150,7 @@ public class SoftBodyTest extends BaseBulletTest {
 
 	@Override
 	protected void renderWorld () {
-		softBody.getVertices(mesh.getVerticesBuffer(), softBody.getNodeCount(), mesh.getVertexSize(), 0);
+		softBody.getVertices(mesh.getVerticesBuffer(true), softBody.getNodeCount(), mesh.getVertexSize(), 0);
 		softBody.getWorldTransform(instance.transform);
 		super.renderWorld();
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java
index 6624865e2..0ea6177c9 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java
@@ -82,8 +82,8 @@ public class SoftMeshTest extends BaseBulletTest {
 		positionOffset = meshPart.mesh.getVertexAttribute(Usage.Position).offset;
 		normalOffset = meshPart.mesh.getVertexAttribute(Usage.Normal).offset;
 
-		softBody = new btSoftBody(worldInfo, meshPart.mesh.getVerticesBuffer(), meshPart.mesh.getVertexSize(), positionOffset,
-			normalOffset, meshPart.mesh.getIndicesBuffer(), meshPart.offset, meshPart.size, indexMap, 0);
+		softBody = new btSoftBody(worldInfo, meshPart.mesh.getVerticesBuffer(false), meshPart.mesh.getVertexSize(), positionOffset,
+			normalOffset, meshPart.mesh.getIndicesBuffer(false), meshPart.offset, meshPart.size, indexMap, 0);
 		// Set mass of the first vertex to zero so its unmovable, comment out this line to make it a fully dynamic body.
 		softBody.setMass(0, 0);
 		com.badlogic.gdx.physics.bullet.softbody.btSoftBody.Material pm = softBody.appendMaterial();
@@ -120,8 +120,8 @@ public class SoftMeshTest extends BaseBulletTest {
 	public void render () {
 		if (world.renderMeshes) {
 			MeshPart meshPart = model.nodes.get(0).parts.get(0).meshPart;
-			softBody.getVertices(meshPart.mesh.getVerticesBuffer(), meshPart.mesh.getVertexSize(), positionOffset, normalOffset,
-				meshPart.mesh.getIndicesBuffer(), meshPart.offset, meshPart.size, indexMap, 0);
+			softBody.getVertices(meshPart.mesh.getVerticesBuffer(true), meshPart.mesh.getVertexSize(), positionOffset, normalOffset,
+				meshPart.mesh.getIndicesBuffer(false), meshPart.offset, meshPart.size, indexMap, 0);
 			softBody.getWorldTransform(entity.transform);
 		}
 		super.render();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/TriangleRaycastTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/TriangleRaycastTest.java
index 939ef6029..bf3e456f2 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/TriangleRaycastTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/TriangleRaycastTest.java
@@ -172,8 +172,8 @@ public class TriangleRaycastTest extends BaseBulletTest {
 
 		// Get the position coordinates of the vertices belonging to intersected triangle.
 		Mesh mesh = model.meshParts.get(currentPartId).mesh;
-		FloatBuffer verticesBuffer = mesh.getVerticesBuffer();
-		ShortBuffer indicesBuffer = mesh.getIndicesBuffer();
+		FloatBuffer verticesBuffer = mesh.getVerticesBuffer(false);
+		ShortBuffer indicesBuffer = mesh.getIndicesBuffer(false);
 
 		int posOffset = mesh.getVertexAttributes().findByUsage(VertexAttributes.Usage.Position).offset / 4;
 		int vertexSize = mesh.getVertexSize() / 4;
@@ -181,7 +181,7 @@ public class TriangleRaycastTest extends BaseBulletTest {
 
 		// Store the three vertices belonging to the selected triangle.
 		for (int i = 0; i < 3; i++) {
-			int currentVertexIndex = indicesBuffer.get(currentTriangleFirstVertexIndex + i);
+			int currentVertexIndex = indicesBuffer.get(currentTriangleFirstVertexIndex + i) & 0xFFFF;
 			int j = currentVertexIndex * vertexSize + posOffset;
 			float x = verticesBuffer.get(j++);
 			float y = verticesBuffer.get(j++);
