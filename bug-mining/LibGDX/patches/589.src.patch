diff --git a/gdx/src/com/badlogic/gdx/math/BSpline.java b/gdx/src/com/badlogic/gdx/math/BSpline.java
index c2f201b9b..994051cb7 100644
--- a/gdx/src/com/badlogic/gdx/math/BSpline.java
+++ b/gdx/src/com/badlogic/gdx/math/BSpline.java
@@ -190,14 +190,16 @@ public class BSpline<T extends Vector<T>> implements Path<T> {
 		this.degree = degree;
 		this.continuous = continuous;
 		this.spanCount = continuous ? controlPoints.length : controlPoints.length - degree;
+		// We use knots.size instead of storing another variable in each BSpline.
+		int knotCount = continuous ? controlPoints.length : controlPoints.length - 1;
 		if (knots == null)
-			knots = new Array<T>(spanCount);
+			knots = new Array<T>(knotCount);
 		else {
 			knots.clear();
-			knots.ensureCapacity(spanCount);
+			knots.ensureCapacity(knotCount);
 		}
-		for (int i = 0; i < spanCount; i++)
-			knots.add(calculate(controlPoints[0].cpy(), continuous ? i : (int)(i + 0.5f * degree), 0f, controlPoints, degree,
+		for (int i = 0; i < knotCount; i++)
+			knots.add(calculate(controlPoints[0].cpy(), continuous ? i : i + (int)(0.5f * degree), 0f, controlPoints, degree,
 				continuous, tmp));
 		return this;
 	}
@@ -237,12 +239,13 @@ public class BSpline<T extends Vector<T>> implements Path<T> {
 
 	/** @return The span closest to the specified value, restricting to the specified spans. */
 	public int nearest (final T in, int start, final int count) {
+		int knotCount = knots.size;
 		while (start < 0)
-			start += spanCount;
-		int result = start % spanCount;
+			start += knotCount;
+		int result = start % knotCount;
 		float dst = in.dst2(knots.get(result));
 		for (int i = 1; i < count; i++) {
-			final int idx = (start + i) % spanCount;
+			final int idx = (start + i) % knotCount;
 			final float d = in.dst2(knots.get(idx));
 			if (d < dst) {
 				dst = d;
@@ -264,8 +267,8 @@ public class BSpline<T extends Vector<T>> implements Path<T> {
 	public float approximate (final T in, final int near) {
 		int n = near;
 		final T nearest = knots.get(n);
-		final T previous = knots.get(n > 0 ? n - 1 : spanCount - 1);
-		final T next = knots.get((n + 1) % spanCount);
+		final T previous = knots.get(n > 0 ? n - 1 : knots.size - 1);
+		final T next = knots.get((n + 1) % knots.size);
 		final float dstPrev2 = in.dst2(previous);
 		final float dstNext2 = in.dst2(next);
 		T P1, P2, P3;
@@ -277,9 +280,9 @@ public class BSpline<T extends Vector<T>> implements Path<T> {
 			P1 = previous;
 			P2 = nearest;
 			P3 = in;
-			n = n > 0 ? n - 1 : spanCount - 1;
+			n = n > 0 ? n - 1 : knots.size - 1;
 		}
-		float L1Sqr = P1.dst2(P2);
+		float L1Sqr = P1.dst2(P2) + 1E-10f; // arbitrary epsilon value to avoid division by 0
 		float L2Sqr = P3.dst2(P2);
 		float L3Sqr = P3.dst2(P1);
 		float L1 = (float)Math.sqrt(L1Sqr);
diff --git a/gdx/test/com/badlogic/gdx/math/BSplineTest.java b/gdx/test/com/badlogic/gdx/math/BSplineTest.java
new file mode 100644
index 000000000..228bb91b2
--- /dev/null
+++ b/gdx/test/com/badlogic/gdx/math/BSplineTest.java
@@ -0,0 +1,124 @@
+
+package com.badlogic.gdx.math;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class BSplineTest {
+
+	@Test
+	public void testCubicSplineNonContinuous () {
+		Vector3[] controlPoints = {new Vector3(0, 0, 0), new Vector3(1, 1, 0), new Vector3(2, 0, 0), new Vector3(3, -1, 0)};
+		BSpline<Vector3> spline = new BSpline<>(controlPoints, 3, false);
+
+		Vector3 result = new Vector3();
+		spline.valueAt(result, 0.5f);
+
+		Vector3 expected = new Vector3(1.5f, 0.5f, 0);
+		Assert.assertEquals(expected.x, result.x, 0.1f); // Error tolerance is large because the curves are... curvy.
+		Assert.assertEquals(expected.y, result.y, 0.1f);
+		Assert.assertEquals(expected.z, result.z, 0.1f);
+	}
+
+	@Test
+	public void testCubicSplineContinuous () {
+		// Define a rough circle based on the 4 cardinal directions.
+		Vector3[] controlPoints = {new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(-1, 0, 0), new Vector3(0, -1, 0),};
+		BSpline<Vector3> spline = new BSpline<>(controlPoints, 3, true);
+
+		Vector3 result = new Vector3();
+		// 0.875f turns around the circle takes us to the southeast quadrant.
+		spline.valueAt(result, 0.875f);
+
+		// The BSpline does not travel through the control points.
+		Vector3 expected = new Vector3(0.45f, -0.45f, 0);
+		Assert.assertEquals(expected.x, result.x, 0.1f);
+		Assert.assertEquals(expected.y, result.y, 0.1f);
+		Assert.assertEquals(expected.z, result.z, 0.1f);
+	}
+
+	@Test
+	public void testCubicDerivative () {
+		Vector3[] controlPoints = {new Vector3(0, 0, 0), new Vector3(1, 1, 0), new Vector3(2, 0, 0), new Vector3(3, -1, 0)};
+		BSpline<Vector3> spline = new BSpline<>(controlPoints, 3, true);
+
+		Vector3 derivative = new Vector3();
+		spline.derivativeAt(derivative, 0.5f);
+
+		Vector3 expectedDerivative = new Vector3(1, -1, 0);
+		Assert.assertEquals(expectedDerivative.x, derivative.x, 0.001f);
+		Assert.assertEquals(expectedDerivative.y, derivative.y, 0.001f);
+		Assert.assertEquals(expectedDerivative.z, derivative.z, 0.001f);
+	}
+
+	@Test
+	public void testContinuousApproximation () {
+		Vector3[] controlPoints = {new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)};
+		BSpline<Vector3> spline = new BSpline<>(controlPoints, 3, true);
+
+		Vector3 point = new Vector3(0.45f, -0.45f, 0.0f);
+		float t = spline.approximate(point);
+
+		// 0.875 turns corresponds to the southeast quadrant, where point is.
+		Assert.assertEquals(0.875f, t, 0.1f);
+	}
+
+	@Test
+	public void testNonContinuousApproximation () {
+		Vector3[] controlPoints = {new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)};
+		BSpline<Vector3> spline = new BSpline<>(controlPoints, 3, false);
+
+		Vector3 point;
+		float t;
+		point = new Vector3(0.0f, 0.666f, 0.0f);
+		t = spline.approximate(point);
+		Assert.assertEquals(0.0f, t, 0.1f);
+		point = new Vector3(-0.666f, 0.0f, 0.0f);
+		t = spline.approximate(point);
+		Assert.assertEquals(1.0f, t, 0.1f);
+		point = new Vector3(-0.45f, 0.45f, 0.0f);
+		t = spline.approximate(point);
+		Assert.assertEquals(0.5f, t, 0.1f);
+
+	}
+
+	@Test
+	public void testSplineContinuity () {
+		Vector3[] controlPoints = {new Vector3(0, 0, 0), new Vector3(1, 1, 0), new Vector3(2, 0, 0), new Vector3(3, -1, 0)};
+		BSpline<Vector3> spline = new BSpline<>(controlPoints, 3, true);
+
+		Vector3 start = new Vector3();
+		Vector3 end = new Vector3();
+		spline.valueAt(start, 0.0f);
+		spline.valueAt(end, 1.0f);
+
+		// For a continuous spline, the start and end points should be equal
+		Assert.assertEquals(start.x, end.x, 0.001f);
+		Assert.assertEquals(start.y, end.y, 0.001f);
+		Assert.assertEquals(start.z, end.z, 0.001f);
+	}
+
+	/** Test to validate calculation with edge cases (t = 0 and t = 1). */
+	@Test
+	public void testEdgeCases () {
+		// The first and last control points aren't on the path.
+		Vector3[] controlPoints = {new Vector3(0, 0, 0), new Vector3(1, 1, 0), new Vector3(2, 0, 0), new Vector3(3, -1, 0)};
+		BSpline<Vector3> spline = new BSpline<>(controlPoints, 3, false);
+
+		Vector3 start = new Vector3();
+		Vector3 expectedStart = new Vector3(1f, 0.666f, 0f);
+		Vector3 end = new Vector3();
+		Vector3 expectedEnd = new Vector3(2f, 0f, 0f);
+		spline.valueAt(start, 0.0f);
+
+		Assert.assertEquals(expectedStart.x, start.x, 0.001f);
+		Assert.assertEquals(expectedStart.y, start.y, 0.001f);
+		Assert.assertEquals(expectedStart.z, start.z, 0.001f);
+
+		spline.valueAt(end, 1.0f);
+
+		Assert.assertEquals(expectedEnd.x, end.x, 0.001f);
+		Assert.assertEquals(expectedEnd.y, end.y, 0.001f);
+		Assert.assertEquals(expectedEnd.z, end.z, 0.001f);
+	}
+}
