diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplication.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplication.java
index b431d5d25..a9072d3eb 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplication.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplication.java
@@ -212,6 +212,7 @@ public abstract class GwtApplication implements EntryPoint, Application {
 		lastHeight = graphics.getHeight();
 		Gdx.graphics = graphics;
 		Gdx.gl20 = graphics.getGL20();
+		Gdx.gl30 = graphics.getGL30();
 		Gdx.gl = Gdx.gl20;
 		if (config.disableAudio) {
 			audio = null;
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplicationConfiguration.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplicationConfiguration.java
index e529d4153..640087c07 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplicationConfiguration.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplicationConfiguration.java
@@ -53,6 +53,10 @@ public class GwtApplicationConfiguration {
 	public TextArea log;
 	/** whether to use debugging mode for OpenGL calls. Errors will result in a RuntimeException being thrown. */
 	public boolean useDebugGL = false;
+	/** Experimental, whether to enable OpenGL ES 30 (aka WebGL2) if supported. If not supported it will fall-back to OpenGL ES
+	 * 2.0. When GL ES 30 is enabled, {@link com.badlogic.gdx.Gdx#gl30} can be used to access its functionality.
+	 * @deprecated this option is currently experimental and not yet fully supported, expect issues. */
+	@Deprecated public boolean useGL30 = false;
 	/** preserve the back buffer, needed if you fetch a screenshot via canvas#toDataUrl, may have performance impact **/
 	public boolean preserveDrawingBuffer = false;
 	/** whether to include an alpha channel in the color buffer to combine the color buffer with the rest of the webpage
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
index 80f835dae..ea7545606 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
@@ -167,7 +167,7 @@ public class GwtGL20 implements GL20 {
 		}
 	}
 
-	private void ensureCapacity (IntBuffer buffer) {
+	protected void ensureCapacity (IntBuffer buffer) {
 		if (buffer.remaining() > intBuffer.length()) {
 			intBuffer = TypedArrays.createInt32Array(buffer.remaining());
 		}
@@ -179,7 +179,7 @@ public class GwtGL20 implements GL20 {
 		}
 	}
 
-	private WebGLUniformLocation getUniformLocation (int location) {
+	protected WebGLUniformLocation getUniformLocation (int location) {
 		return uniforms.get(currProgram).get(location);
 	}
 
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL30.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL30.java
new file mode 100644
index 000000000..28a204923
--- /dev/null
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL30.java
@@ -0,0 +1,917 @@
+/*******************************************************************************
+ * Copyright 2022 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.gwt;
+
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.GL30;
+import com.badlogic.gdx.graphics.Pixmap;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.google.gwt.core.client.GWT;
+import com.google.gwt.core.client.JsArrayBoolean;
+import com.google.gwt.core.client.JsArrayInteger;
+import com.google.gwt.typedarrays.client.Uint8ArrayNative;
+import com.google.gwt.typedarrays.shared.ArrayBufferView;
+import com.google.gwt.typedarrays.shared.TypedArrays;
+import com.google.gwt.typedarrays.shared.Uint32Array;
+import com.google.gwt.webgl.client.WebGL2RenderingContext;
+import com.google.gwt.webgl.client.WebGLFramebuffer;
+import com.google.gwt.webgl.client.WebGLQuery;
+import com.google.gwt.webgl.client.WebGLSampler;
+import com.google.gwt.webgl.client.WebGLTexture;
+import com.google.gwt.webgl.client.WebGLTransformFeedback;
+import com.google.gwt.webgl.client.WebGLUniformLocation;
+import com.google.gwt.webgl.client.WebGLVertexArrayObject;
+
+import java.nio.Buffer;
+import java.nio.ByteBuffer;
+import java.nio.FloatBuffer;
+import java.nio.HasArrayBufferView;
+import java.nio.IntBuffer;
+import java.nio.LongBuffer;
+
+/** @author Simon Gerst
+ * @author JamesTKhan */
+public class GwtGL30 extends GwtGL20 implements GL30 {
+	private final IntMap<WebGLQuery> queries = IntMap.create();
+	private int nextQueryId = 1;
+	private final IntMap<WebGLSampler> samplers = IntMap.create();
+	private int nextSamplerId = 1;
+	private final IntMap<WebGLTransformFeedback> feedbacks = IntMap.create();
+	private int nextFeedbackId = 1;
+	private final IntMap<WebGLVertexArrayObject> vertexArrays = IntMap.create();
+	private int nextVertexArrayId = 1;
+	private final Uint32Array uIntBuffer = TypedArrays.createUint32Array(2000 * 6);
+
+	final protected WebGL2RenderingContext gl;
+
+	protected GwtGL30 (WebGL2RenderingContext gl) {
+		super(gl);
+		this.gl = gl;
+	}
+
+	private Uint32Array copyUnsigned (IntBuffer buffer) {
+		if (GWT.isProdMode()) {
+			return ((Uint32Array)((HasArrayBufferView)buffer).getTypedArray()).subarray(buffer.position(), buffer.remaining());
+		} else {
+			ensureCapacity(buffer);
+			for (int i = buffer.position(), j = 0; i < buffer.limit(); i++, j++) {
+				uIntBuffer.set(j, buffer.get(i));
+			}
+			return uIntBuffer.subarray(0, buffer.remaining());
+		}
+	}
+
+	private int allocateQueryId (WebGLQuery query) {
+		int id = nextQueryId++;
+		queries.put(id, query);
+		return id;
+	}
+
+	private void deallocateQueryId (int id) {
+		queries.remove(id);
+	}
+
+	private int allocateSamplerId (WebGLSampler query) {
+		int id = nextSamplerId++;
+		samplers.put(id, query);
+		return id;
+	}
+
+	private void deallocateFeedbackId (int id) {
+		feedbacks.remove(id);
+	}
+
+	private int allocateFeedbackId (WebGLTransformFeedback feedback) {
+		int id = nextFeedbackId++;
+		feedbacks.put(id, feedback);
+		return id;
+	}
+
+	private void deallocateSamplerId (int id) {
+		samplers.remove(id);
+	}
+
+	private int allocateVertexArrayId (WebGLVertexArrayObject vArray) {
+		int id = nextVertexArrayId++;
+		vertexArrays.put(id, vArray);
+		return id;
+	}
+
+	private void deallocateVertexArrayId (int id) {
+		vertexArrays.remove(id);
+	}
+
+	@Override
+	public void glBeginQuery (int target, int id) {
+		gl.beginQuery(target, queries.get(id));
+	}
+
+	@Override
+	public void glBeginTransformFeedback (int primitiveMode) {
+		gl.beginTransformFeedback(primitiveMode);
+	}
+
+	@Override
+	public void glBindBufferBase (int target, int index, int buffer) {
+		gl.bindBufferBase(target, index, buffers.get(buffer));
+	}
+
+	@Override
+	public void glBindBufferRange (int target, int index, int buffer, int offset, int size) {
+		gl.bindBufferRange(target, index, buffers.get(buffer), offset, size);
+	}
+
+	@Override
+	public void glBindSampler (int unit, int sampler) {
+		gl.bindSampler(unit, samplers.get(sampler));
+	}
+
+	@Override
+	public void glBindTransformFeedback (int target, int id) {
+		gl.bindTransformFeedback(target, feedbacks.get(id));
+	}
+
+	@Override
+	public void glBindVertexArray (int array) {
+		gl.bindVertexArray(vertexArrays.get(array));
+	}
+
+	@Override
+	public void glBlitFramebuffer (int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1,
+		int mask, int filter) {
+		gl.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
+	}
+
+	@Override
+	public void glClearBufferfi (int buffer, int drawbuffer, float depth, int stencil) {
+		gl.clearBufferfi(buffer, drawbuffer, depth, stencil);
+	}
+
+	@Override
+	public void glClearBufferfv (int buffer, int drawbuffer, FloatBuffer value) {
+		gl.clearBufferfv(buffer, drawbuffer, copy(value));
+	}
+
+	@Override
+	public void glClearBufferiv (int buffer, int drawbuffer, IntBuffer value) {
+		gl.clearBufferiv(buffer, drawbuffer, copy(value));
+	}
+
+	@Override
+	public void glClearBufferuiv (int buffer, int drawbuffer, IntBuffer value) {
+		gl.clearBufferuiv(buffer, drawbuffer, copy(value));
+	}
+
+	@Override
+	public void glCopyBufferSubData (int readTarget, int writeTarget, int readOffset, int writeOffset, int size) {
+		gl.copyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
+	}
+
+	@Override
+	public void glCopyTexSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width,
+		int height) {
+		gl.copyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
+	}
+
+	@Override
+	public void glDeleteQueries (int n, int[] ids, int offset) {
+		for (int i = offset; i < offset + n; i++) {
+			int id = ids[i];
+			WebGLQuery query = queries.get(id);
+			deallocateQueryId(id);
+			gl.deleteQuery(query);
+		}
+	}
+
+	@Override
+	public void glDeleteQueries (int n, IntBuffer ids) {
+		int startPosition = ids.position();
+		for (int i = 0; i < n; i++) {
+			int id = ids.get();
+			WebGLQuery query = queries.get(id);
+			deallocateQueryId(id);
+			gl.deleteQuery(query);
+		}
+		ids.position(startPosition);
+	}
+
+	@Override
+	public void glDeleteSamplers (int count, int[] samplers, int offset) {
+		for (int i = offset; i < offset + count; i++) {
+			int id = samplers[i];
+			WebGLSampler sampler = this.samplers.get(id);
+			deallocateSamplerId(id);
+			gl.deleteSampler(sampler);
+		}
+	}
+
+	@Override
+	public void glDeleteSamplers (int n, IntBuffer ids) {
+		int startPosition = ids.position();
+		for (int i = 0; i < n; i++) {
+			int id = ids.get();
+			WebGLSampler sampler = samplers.get(id);
+			deallocateSamplerId(id);
+			gl.deleteSampler(sampler);
+		}
+		ids.position(startPosition);
+	}
+
+	@Override
+	public void glDeleteTransformFeedbacks (int n, int[] ids, int offset) {
+		for (int i = offset; i < offset + n; i++) {
+			int id = ids[i];
+			WebGLTransformFeedback feedback = feedbacks.get(id);
+			deallocateFeedbackId(id);
+			gl.deleteTransformFeedback(feedback);
+		}
+	}
+
+	@Override
+	public void glDeleteTransformFeedbacks (int n, IntBuffer ids) {
+		int startPosition = ids.position();
+		for (int i = 0; i < n; i++) {
+			int id = ids.get();
+			WebGLTransformFeedback feedback = feedbacks.get(id);
+			deallocateFeedbackId(id);
+			gl.deleteTransformFeedback(feedback);
+		}
+		ids.position(startPosition);
+	}
+
+	@Override
+	public void glDeleteVertexArrays (int n, int[] arrays, int offset) {
+		for (int i = offset; i < offset + n; i++) {
+			int id = arrays[i];
+			WebGLVertexArrayObject vArray = vertexArrays.get(id);
+			deallocateVertexArrayId(id);
+			gl.deleteVertexArray(vArray);
+		}
+	}
+
+	@Override
+	public void glDeleteVertexArrays (int n, IntBuffer ids) {
+		int startPosition = ids.position();
+		for (int i = 0; i < n; i++) {
+			int id = ids.get();
+			WebGLVertexArrayObject vArray = vertexArrays.get(id);
+			deallocateVertexArrayId(id);
+			gl.deleteVertexArray(vArray);
+		}
+		ids.position(startPosition);
+	}
+
+	@Override
+	public void glDrawArraysInstanced (int mode, int first, int count, int instanceCount) {
+		gl.drawArraysInstanced(mode, first, count, instanceCount);
+	}
+
+	@Override
+	public void glDrawBuffers (int n, IntBuffer bufs) {
+		int startPosition = bufs.position();
+		gl.drawBuffers(copy((IntBuffer)bufs).subarray(0, n));
+		bufs.position(startPosition);
+	}
+
+	@Override
+	public void glDrawElementsInstanced (int mode, int count, int type, int indicesOffset, int instanceCount) {
+		gl.drawElementsInstanced(mode, count, type, indicesOffset, instanceCount);
+	}
+
+	@Override
+	public void glDrawRangeElements (int mode, int start, int end, int count, int type, Buffer indices) {
+		gl.drawRangeElements(mode, start, end, count, type, indices.position());
+	}
+
+	@Override
+	public void glDrawRangeElements (int mode, int start, int end, int count, int type, int offset) {
+		gl.drawRangeElements(mode, start, end, count, type, offset);
+	}
+
+	@Override
+	public void glTexImage2D (int target, int level, int internalformat, int width, int height, int border, int format, int type,
+		int offset) {
+		gl.texImage2D(target, level, internalformat, width, height, border, format, type, offset);
+	}
+
+	@Override
+	public void glEndQuery (int target) {
+		gl.endQuery(target);
+	}
+
+	@Override
+	public void glEndTransformFeedback () {
+		gl.endTransformFeedback();
+	}
+
+	@Override
+	public void glFlushMappedBufferRange (int target, int offset, int length) {
+		throw new UnsupportedOperationException("glFlushMappedBufferRange not supported on WebGL2");
+	}
+
+	@Override
+	public void glFramebufferTextureLayer (int target, int attachment, int texture, int level, int layer) {
+		gl.framebufferTextureLayer(target, attachment, textures.get(texture), level, layer);
+	}
+
+	@Override
+	public void glGenQueries (int n, int[] ids, int offset) {
+		for (int i = offset; i < offset + n; i++) {
+			WebGLQuery query = gl.createQuery();
+			int id = allocateQueryId(query);
+			ids[i] = id;
+		}
+	}
+
+	@Override
+	public void glGenQueries (int n, IntBuffer ids) {
+		int startPosition = ids.position();
+		for (int i = 0; i < n; i++) {
+			WebGLQuery query = gl.createQuery();
+			int id = allocateQueryId(query);
+			ids.put(id);
+		}
+		ids.position(startPosition);
+	}
+
+	@Override
+	public void glGenSamplers (int count, int[] samplers, int offset) {
+		for (int i = offset; i < offset + count; i++) {
+			WebGLSampler sampler = gl.createSampler();
+			int id = allocateSamplerId(sampler);
+			samplers[i] = id;
+		}
+	}
+
+	@Override
+	public void glGenSamplers (int n, IntBuffer ids) {
+		int startPosition = ids.position();
+		for (int i = 0; i < n; i++) {
+			WebGLSampler sampler = gl.createSampler();
+			int id = allocateSamplerId(sampler);
+			ids.put(id);
+		}
+		ids.position(startPosition);
+	}
+
+	@Override
+	public void glGenTransformFeedbacks (int n, int[] ids, int offset) {
+		for (int i = offset; i < offset + n; i++) {
+			WebGLTransformFeedback feedback = gl.createTransformFeedback();
+			int id = allocateFeedbackId(feedback);
+			ids[i] = id;
+		}
+	}
+
+	@Override
+	public void glGenTransformFeedbacks (int n, IntBuffer ids) {
+		int startPosition = ids.position();
+		for (int i = 0; i < n; i++) {
+			WebGLTransformFeedback feedback = gl.createTransformFeedback();
+			int id = allocateFeedbackId(feedback);
+			ids.put(id);
+		}
+		ids.position(startPosition);
+	}
+
+	@Override
+	public void glGenVertexArrays (int n, int[] arrays, int offset) {
+		for (int i = offset; i < offset + n; i++) {
+			WebGLVertexArrayObject vArray = gl.createVertexArray();
+			int id = allocateVertexArrayId(vArray);
+			arrays[i] = id;
+		}
+	}
+
+	@Override
+	public void glGenVertexArrays (int n, IntBuffer ids) {
+		int startPosition = ids.position();
+		for (int i = 0; i < n; i++) {
+			WebGLVertexArrayObject vArray = gl.createVertexArray();
+			int id = allocateVertexArrayId(vArray);
+			ids.put(id);
+		}
+		ids.position(startPosition);
+	}
+
+	@Override
+	public void glGetActiveUniformBlockiv (int program, int uniformBlockIndex, int pname, IntBuffer params) {
+		if (pname == GL30.GL_UNIFORM_BLOCK_BINDING || pname == GL30.GL_UNIFORM_BLOCK_DATA_SIZE
+			|| pname == GL30.GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS) {
+			params.put(gl.getActiveUniformBlockParameteri(programs.get(program), uniformBlockIndex, pname));
+		} else if (pname == GL30.GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES) {
+			Uint32Array array = gl.getActiveUniformBlockParameterv(programs.get(program), uniformBlockIndex, pname);
+			for (int i = 0; i < array.length(); i++) {
+				params.put(i, (int)array.get(i));
+			}
+		} else if (pname == GL30.GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER
+			|| pname == GL30.GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER) {
+			boolean result = gl.getActiveUniformBlockParameterb(programs.get(program), uniformBlockIndex, pname);
+			params.put(result ? GL20.GL_TRUE : GL20.GL_FALSE);
+		} else {
+			throw new GdxRuntimeException("Unsupported pname passed to glGetActiveUniformBlockiv");
+		}
+		params.flip();
+	}
+
+	@Override
+	public String glGetActiveUniformBlockName (int program, int uniformBlockIndex) {
+		return gl.getActiveUniformBlockName(programs.get(program), uniformBlockIndex);
+	}
+
+	@Override
+	public void glGetActiveUniformBlockName (int program, int uniformBlockIndex, Buffer length, Buffer uniformBlockName) {
+		throw new UnsupportedOperationException("glGetActiveUniformBlockName with Buffer parameters not supported on WebGL2");
+	}
+
+	@Override
+	public void glGetActiveUniformsiv (int program, int uniformCount, IntBuffer uniformIndices, int pname, IntBuffer params) {
+		if (pname == GL30.GL_UNIFORM_IS_ROW_MAJOR) {
+			JsArrayBoolean arr = gl.getActiveUniformsb(programs.get(program), copy(uniformIndices).subarray(0, uniformCount), pname);
+			for (int i = 0; i < uniformCount; i++) {
+				params.put(i, arr.get(i) ? GL20.GL_TRUE : GL20.GL_FALSE);
+			}
+		} else {
+			JsArrayInteger arr = gl.getActiveUniformsi(programs.get(program), copy(uniformIndices).subarray(0, uniformCount), pname);
+			for (int i = 0; i < uniformCount; i++) {
+				params.put(i, arr.get(i));
+			}
+		}
+		params.flip();
+	}
+
+	@Override
+	public void glGetBufferParameteri64v (int target, int pname, LongBuffer params) {
+		throw new UnsupportedOperationException("glGetBufferParameteri64v not supported on WebGL2");
+	}
+
+	@Override
+	public Buffer glGetBufferPointerv (int target, int pname) {
+		throw new UnsupportedOperationException("glGetBufferPointerv not supported on WebGL2");
+	}
+
+	@Override
+	public void glGetFloatv (int pname, FloatBuffer params) {
+		// Override GwtGL20 method to check if it's a pname introduced with GL30.
+		if (pname == GL30.GL_MAX_TEXTURE_LOD_BIAS) {
+			params.put(0, gl.getParameterf(pname));
+			params.flip();
+		} else {
+			super.glGetFloatv(pname, params);
+		}
+	}
+
+	@Override
+	public int glGetFragDataLocation (int program, String name) {
+		return gl.getFragDataLocation(programs.get(program), name);
+	}
+
+	@Override
+	public void glGetIntegerv (int pname, IntBuffer params) {
+		// Override GwtGL20 method to check if it's a pname introduced with GL30.
+		switch (pname) {
+		case GL30.GL_DRAW_BUFFER0:
+		case GL30.GL_DRAW_BUFFER1:
+		case GL30.GL_DRAW_BUFFER2:
+		case GL30.GL_DRAW_BUFFER3:
+		case GL30.GL_DRAW_BUFFER4:
+		case GL30.GL_DRAW_BUFFER5:
+		case GL30.GL_DRAW_BUFFER6:
+		case GL30.GL_DRAW_BUFFER7:
+		case GL30.GL_DRAW_BUFFER8:
+		case GL30.GL_DRAW_BUFFER9:
+		case GL30.GL_DRAW_BUFFER10:
+		case GL30.GL_FRAGMENT_SHADER_DERIVATIVE_HINT:
+		case GL30.GL_MAX_3D_TEXTURE_SIZE:
+		case GL30.GL_MAX_ARRAY_TEXTURE_LAYERS:
+		case GL30.GL_MAX_COLOR_ATTACHMENTS:
+		case GL30.GL_MAX_DRAW_BUFFERS:
+		case GL30.GL_MAX_ELEMENTS_INDICES:
+		case GL30.GL_MAX_ELEMENTS_VERTICES:
+		case GL30.GL_MAX_FRAGMENT_INPUT_COMPONENTS:
+		case GL30.GL_MAX_FRAGMENT_UNIFORM_BLOCKS:
+		case GL30.GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:
+		case GL30.GL_MAX_PROGRAM_TEXEL_OFFSET:
+		case GL30.GL_MAX_SAMPLES:
+		case GL30.GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:
+		case GL30.GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:
+		case GL30.GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:
+		case GL30.GL_MAX_UNIFORM_BUFFER_BINDINGS:
+		case GL30.GL_MAX_VARYING_COMPONENTS:
+		case GL30.GL_MAX_VERTEX_OUTPUT_COMPONENTS:
+		case GL30.GL_MAX_VERTEX_UNIFORM_BLOCKS:
+		case GL30.GL_MAX_VERTEX_UNIFORM_COMPONENTS:
+		case GL30.GL_MIN_PROGRAM_TEXEL_OFFSET:
+		case GL30.GL_PACK_ROW_LENGTH:
+		case GL30.GL_PACK_SKIP_PIXELS:
+		case GL30.GL_PACK_SKIP_ROWS:
+		case GL30.GL_READ_BUFFER:
+		case GL30.GL_UNPACK_IMAGE_HEIGHT:
+		case GL30.GL_UNPACK_ROW_LENGTH:
+		case GL30.GL_UNPACK_SKIP_IMAGES:
+		case GL30.GL_UNPACK_SKIP_PIXELS:
+		case GL30.GL_UNPACK_SKIP_ROWS:
+			params.put(0, gl.getParameteri(pname));
+			params.flip();
+			return;
+		case GL30.GL_DRAW_FRAMEBUFFER_BINDING:
+		case GL30.GL_READ_FRAMEBUFFER_BINDING:
+			WebGLFramebuffer fbo = gl.getParametero(pname);
+			if (fbo == null) {
+				params.put(0);
+			} else {
+				params.put(frameBuffers.getKey(fbo));
+			}
+			params.flip();
+			return;
+		case GL30.GL_TEXTURE_BINDING_2D_ARRAY:
+		case GL30.GL_TEXTURE_BINDING_3D:
+			WebGLTexture tex = gl.getParametero(pname);
+			if (tex == null) {
+				params.put(0);
+			} else {
+				params.put(textures.getKey(tex));
+			}
+			params.flip();
+			return;
+		case GL30.GL_VERTEX_ARRAY_BINDING:
+			WebGLVertexArrayObject obj = gl.getParametero(pname);
+			if (obj == null) {
+				params.put(0);
+			} else {
+				params.put(vertexArrays.getKey(obj));
+			}
+			params.flip();
+			return;
+		default:
+			// Assume it is a GL20 pname
+			super.glGetIntegerv(pname, params);
+		}
+	}
+
+	@Override
+	public void glGetInteger64v (int pname, LongBuffer params) {
+		switch (pname) {
+		case GL30.GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:
+		case GL30.GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:
+		case GL30.GL_MAX_ELEMENT_INDEX:
+		case GL30.GL_MAX_SERVER_WAIT_TIMEOUT:
+		case GL30.GL_MAX_UNIFORM_BLOCK_SIZE:
+			params.put(gl.getParameteri64(pname));
+			params.flip();
+			return;
+		default:
+			throw new UnsupportedOperationException("Given glGetInteger64v enum not supported on WebGL2");
+		}
+	}
+
+	@Override
+	public void glGetQueryiv (int target, int pname, IntBuffer params) {
+		// Not 100% clear on this one. Returning the integer key for the query.
+		// Similar to how GwtGL20 handles FBO in glGetIntegerv
+		WebGLQuery query = gl.getQuery(target, pname);
+		if (query == null) {
+			params.put(0);
+		} else {
+			params.put(queries.getKey(query));
+		}
+		params.flip();
+	}
+
+	@Override
+	public void glGetQueryObjectuiv (int id, int pname, IntBuffer params) {
+		// In WebGL2 getQueryObject was renamed to getQueryParameter
+		if (pname == GL30.GL_QUERY_RESULT) {
+			params.put(gl.getQueryParameteri(queries.get(id), pname));
+		} else if (pname == GL30.GL_QUERY_RESULT_AVAILABLE) {
+			boolean result = gl.getQueryParameterb(queries.get(id), pname);
+			params.put(result ? GL20.GL_TRUE : GL20.GL_FALSE);
+		} else {
+			throw new GdxRuntimeException("Unsupported pname passed to glGetQueryObjectuiv");
+		}
+		params.flip();
+	}
+
+	@Override
+	public void glGetSamplerParameterfv (int sampler, int pname, FloatBuffer params) {
+		params.put(gl.getSamplerParameterf(samplers.get(sampler), pname));
+		params.flip();
+	}
+
+	@Override
+	public void glGetSamplerParameteriv (int sampler, int pname, IntBuffer params) {
+		params.put(gl.getSamplerParameteri(samplers.get(sampler), pname));
+		params.flip();
+	}
+
+	@Override
+	public String glGetStringi (int name, int index) {
+		throw new UnsupportedOperationException("glGetStringi not supported on WebGL2");
+	}
+
+	@Override
+	public int glGetUniformBlockIndex (int program, String uniformBlockName) {
+		return gl.getUniformBlockIndex(programs.get(program), uniformBlockName);
+	}
+
+	@Override
+	public void glGetUniformIndices (int program, String[] uniformNames, IntBuffer uniformIndices) {
+		JsArrayInteger array = gl.getUniformIndices(programs.get(program), uniformNames);
+		for (int i = 0; i < array.length(); i++) {
+			uniformIndices.put(i, array.get(i));
+		}
+		uniformIndices.flip();
+	}
+
+	@Override
+	public void glGetUniformuiv (int program, int location, IntBuffer params) {
+		// fv and iv also not implemented in GwtGL20
+		throw new UnsupportedOperationException("glGetUniformuiv not implemented on WebGL2");
+	}
+
+	@Override
+	public void glGetVertexAttribIiv (int index, int pname, IntBuffer params) {
+		// fv and iv also not implemented in GwtGL20
+		throw new UnsupportedOperationException("glGetVertexAttribIiv not implemented on WebGL2");
+	}
+
+	@Override
+	public void glGetVertexAttribIuiv (int index, int pname, IntBuffer params) {
+		// fv and iv also not implemented in GwtGL20
+		throw new UnsupportedOperationException("glGetVertexAttribIuiv not implemented on WebGL2");
+	}
+
+	@Override
+	public void glInvalidateFramebuffer (int target, int numAttachments, IntBuffer attachments) {
+		int startPosition = attachments.position();
+		gl.invalidateFramebuffer(target, copy((IntBuffer)attachments).subarray(0, numAttachments));
+		attachments.position(startPosition);
+	}
+
+	@Override
+	public void glInvalidateSubFramebuffer (int target, int numAttachments, IntBuffer attachments, int x, int y, int width,
+		int height) {
+		int startPosition = attachments.position();
+		gl.invalidateSubFramebuffer(target, copy((IntBuffer)attachments).subarray(0, numAttachments), x, y, width, height);
+		attachments.position(startPosition);
+	}
+
+	@Override
+	public boolean glIsQuery (int id) {
+		return gl.isQuery(queries.get(id));
+	}
+
+	@Override
+	public boolean glIsSampler (int id) {
+		return gl.isSampler(samplers.get(id));
+	}
+
+	@Override
+	public boolean glIsTransformFeedback (int id) {
+		return gl.isTransformFeedback(feedbacks.get(id));
+	}
+
+	@Override
+	public boolean glIsVertexArray (int id) {
+		return gl.isVertexArray(vertexArrays.get(id));
+	}
+
+	@Override
+	public Buffer glMapBufferRange (int target, int offset, int length, int access) {
+		throw new UnsupportedOperationException("glMapBufferRange not supported on WebGL2");
+	}
+
+	@Override
+	public void glPauseTransformFeedback () {
+		gl.pauseTransformFeedback();
+	}
+
+	@Override
+	public void glProgramParameteri (int program, int pname, int value) {
+		// Per WebGL2 spec: Accessing binary representations of compiled shader programs is not supported in the WebGL 2.0 API.
+		// This includes OpenGL ES 3.0 GetProgramBinary, ProgramBinary, and ProgramParameteri entry points
+		throw new UnsupportedOperationException("glProgramParameteri not supported on WebGL2");
+	}
+
+	@Override
+	public void glReadBuffer (int mode) {
+		gl.readBuffer(mode);
+	}
+
+	@Override
+	public void glRenderbufferStorageMultisample (int target, int samples, int internalformat, int width, int height) {
+		gl.renderbufferStorageMultisample(target, samples, internalformat, width, height);
+	}
+
+	@Override
+	public void glResumeTransformFeedback () {
+		gl.resumeTransformFeedback();
+	}
+
+	@Override
+	public void glSamplerParameterf (int sampler, int pname, float param) {
+		gl.samplerParameterf(samplers.get(sampler), pname, param);
+	}
+
+	@Override
+	public void glSamplerParameterfv (int sampler, int pname, FloatBuffer param) {
+		gl.samplerParameterf(samplers.get(sampler), pname, param.get());
+	}
+
+	@Override
+	public void glSamplerParameteri (int sampler, int pname, int param) {
+		gl.samplerParameteri(samplers.get(sampler), pname, param);
+	}
+
+	@Override
+	public void glSamplerParameteriv (int sampler, int pname, IntBuffer param) {
+		gl.samplerParameterf(samplers.get(sampler), pname, param.get());
+	}
+
+	@Override
+	public void glTexImage3D (int target, int level, int internalformat, int width, int height, int depth, int border, int format,
+		int type, Buffer pixels) {
+		// Taken from glTexImage2D
+		if (pixels == null) {
+			gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, (ArrayBufferView)null);
+			return;
+		}
+
+		if (pixels.limit() > 1) {
+			HasArrayBufferView arrayHolder = (HasArrayBufferView)pixels;
+			ArrayBufferView webGLArray = arrayHolder.getTypedArray();
+			ArrayBufferView buffer;
+			if (pixels instanceof FloatBuffer) {
+				buffer = webGLArray;
+			} else {
+				int length = pixels.remaining();
+				if (!(pixels instanceof ByteBuffer)) {
+					// It seems for ByteBuffer we don't need this byte conversion
+					length *= 4;
+				}
+				int byteOffset = webGLArray.byteOffset() + pixels.position() * 4;
+				buffer = Uint8ArrayNative.create(webGLArray.buffer(), byteOffset, length);
+			}
+			gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, buffer);
+		} else {
+			Pixmap pixmap = Pixmap.pixmaps.get(((IntBuffer)pixels).get(0));
+			// Prefer to use the HTMLImageElement when possible, since reading from the CanvasElement can be lossy.
+			if (pixmap.canUseImageElement()) {
+				gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, pixmap.getImageElement());
+			} else if (pixmap.canUseVideoElement()) {
+				gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, pixmap.getVideoElement());
+			} else {
+				gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, pixmap.getCanvasElement());
+			}
+		}
+	}
+
+	@Override
+	public void glTexImage3D (int target, int level, int internalformat, int width, int height, int depth, int border, int format,
+		int type, int offset) {
+		gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, offset);
+	}
+
+	@Override
+	public void glTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format, int type,
+		int offset) {
+		gl.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, offset);
+	}
+
+	@Override
+	public void glTexSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth,
+		int format, int type, Buffer pixels) {
+		// Taken from glTexSubImage2D
+		if (pixels.limit() > 1) {
+			HasArrayBufferView arrayHolder = (HasArrayBufferView)pixels;
+			ArrayBufferView webGLArray = arrayHolder.getTypedArray();
+			ArrayBufferView buffer;
+			if (pixels instanceof FloatBuffer) {
+				buffer = webGLArray;
+			} else {
+				int length = pixels.remaining();
+				if (!(pixels instanceof ByteBuffer)) {
+					// It seems for ByteBuffer we don't need this byte conversion
+					length *= 4;
+				}
+				int byteOffset = webGLArray.byteOffset() + pixels.position() * 4;
+				buffer = Uint8ArrayNative.create(webGLArray.buffer(), byteOffset, length);
+			}
+			gl.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, buffer);
+		} else {
+			Pixmap pixmap = Pixmap.pixmaps.get(((IntBuffer)pixels).get(0));
+			gl.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type,
+				pixmap.getCanvasElement());
+		}
+	}
+
+	@Override
+	public void glTexSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth,
+		int format, int type, int offset) {
+		gl.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, offset);
+	}
+
+	@Override
+	public void glTransformFeedbackVaryings (int program, String[] varyings, int bufferMode) {
+		gl.transformFeedbackVaryings(programs.get(program), varyings, bufferMode);
+	}
+
+	@Override
+	public void glUniform1uiv (int location, int count, IntBuffer value) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform1uiv(loc, copyUnsigned(value), 0, count);
+	}
+
+	@Override
+	public void glUniform3uiv (int location, int count, IntBuffer value) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform3uiv(loc, copyUnsigned(value), 0, count);
+	}
+
+	@Override
+	public void glUniform4uiv (int location, int count, IntBuffer value) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform4uiv(loc, copyUnsigned(value), 0, count);
+	}
+
+	@Override
+	public void glUniformBlockBinding (int program, int uniformBlockIndex, int uniformBlockBinding) {
+		gl.uniformBlockBinding(programs.get(program), uniformBlockIndex, uniformBlockBinding);
+	}
+
+	@Override
+	public void glUniformMatrix2x3fv (int location, int count, boolean transpose, FloatBuffer value) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniformMatrix2x3fv(loc, transpose, copy(value));
+	}
+
+	@Override
+	public void glUniformMatrix2x4fv (int location, int count, boolean transpose, FloatBuffer value) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniformMatrix2x4fv(loc, transpose, copy(value), 0, count);
+	}
+
+	@Override
+	public void glUniformMatrix3x2fv (int location, int count, boolean transpose, FloatBuffer value) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniformMatrix3x2fv(loc, transpose, copy(value), 0, count);
+	}
+
+	@Override
+	public void glUniformMatrix3x4fv (int location, int count, boolean transpose, FloatBuffer value) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniformMatrix3x4fv(loc, transpose, copy(value), 0, count);
+	}
+
+	@Override
+	public void glUniformMatrix4x2fv (int location, int count, boolean transpose, FloatBuffer value) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniformMatrix4x2fv(loc, transpose, copy(value), 0, count);
+	}
+
+	@Override
+	public void glUniformMatrix4x3fv (int location, int count, boolean transpose, FloatBuffer value) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniformMatrix4x3fv(loc, transpose, copy(value), 0, count);
+	}
+
+	@Override
+	public boolean glUnmapBuffer (int target) {
+		throw new UnsupportedOperationException("glUnmapBuffer not supported on WebGL2");
+	}
+
+	@Override
+	public void glVertexAttribDivisor (int index, int divisor) {
+		gl.vertexAttribDivisor(index, divisor);
+	}
+
+	@Override
+	public void glVertexAttribI4i (int index, int x, int y, int z, int w) {
+		gl.vertexAttribI4i(index, x, y, z, w);
+	}
+
+	@Override
+	public void glVertexAttribI4ui (int index, int x, int y, int z, int w) {
+		gl.vertexAttribI4ui(index, x, y, z, w);
+	}
+
+	@Override
+	public void glVertexAttribIPointer (int index, int size, int type, int stride, int offset) {
+		gl.vertexAttribIPointer(index, size, type, stride, offset);
+	}
+
+}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL30Debug.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL30Debug.java
new file mode 100644
index 000000000..cd6dd1c3f
--- /dev/null
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL30Debug.java
@@ -0,0 +1,1630 @@
+/*******************************************************************************
+ * Copyright 2023 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.gwt;
+
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.google.gwt.webgl.client.WebGL2RenderingContext;
+
+import java.nio.Buffer;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+import java.nio.LongBuffer;
+
+/** Does not extend from GwtGL20Debug as we would not have GL30 methods to override meaning we would need to implement all of GL30
+ * here as well.
+ *
+ * Instead, GL30 override methods are first, then GL20 override methods are beneath which were copied from
+ * {@link GwtGL20Debug}. */
+public class GwtGL30Debug extends GwtGL30 {
+
+	protected GwtGL30Debug (WebGL2RenderingContext gl) {
+		super(gl);
+	}
+
+	private void checkError () {
+		int error = 0;
+		if ((error = gl.getError()) != GL_NO_ERROR) {
+			throw new GdxRuntimeException("GL error: " + error + ", " + Integer.toHexString(error));
+		}
+	}
+
+	@Override
+	public void glBeginQuery (int target, int id) {
+		super.glBeginQuery(target, id);
+		checkError();
+	}
+
+	@Override
+	public void glBeginTransformFeedback (int primitiveMode) {
+		super.glBeginTransformFeedback(primitiveMode);
+		checkError();
+	}
+
+	@Override
+	public void glBindBufferBase (int target, int index, int buffer) {
+		super.glBindBufferBase(target, index, buffer);
+		checkError();
+	}
+
+	@Override
+	public void glBindBufferRange (int target, int index, int buffer, int offset, int size) {
+		super.glBindBufferRange(target, index, buffer, offset, size);
+		checkError();
+	}
+
+	@Override
+	public void glBindSampler (int unit, int sampler) {
+		super.glBindSampler(unit, sampler);
+		checkError();
+	}
+
+	@Override
+	public void glBindTransformFeedback (int target, int id) {
+		super.glBindTransformFeedback(target, id);
+		checkError();
+	}
+
+	@Override
+	public void glBindVertexArray (int array) {
+		super.glBindVertexArray(array);
+		checkError();
+	}
+
+	@Override
+	public void glBlitFramebuffer (int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1,
+		int mask, int filter) {
+		super.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
+		checkError();
+	}
+
+	@Override
+	public void glClearBufferfi (int buffer, int drawbuffer, float depth, int stencil) {
+		super.glClearBufferfi(buffer, drawbuffer, depth, stencil);
+		checkError();
+	}
+
+	@Override
+	public void glClearBufferfv (int buffer, int drawbuffer, FloatBuffer value) {
+		super.glClearBufferfv(buffer, drawbuffer, value);
+		checkError();
+	}
+
+	@Override
+	public void glClearBufferiv (int buffer, int drawbuffer, IntBuffer value) {
+		super.glClearBufferiv(buffer, drawbuffer, value);
+		checkError();
+	}
+
+	@Override
+	public void glClearBufferuiv (int buffer, int drawbuffer, IntBuffer value) {
+		super.glClearBufferuiv(buffer, drawbuffer, value);
+		checkError();
+	}
+
+	@Override
+	public void glCopyBufferSubData (int readTarget, int writeTarget, int readOffset, int writeOffset, int size) {
+		super.glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
+		checkError();
+	}
+
+	@Override
+	public void glCopyTexSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width,
+		int height) {
+		super.glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteQueries (int n, int[] ids, int offset) {
+		super.glDeleteQueries(n, ids, offset);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteQueries (int n, IntBuffer ids) {
+		super.glDeleteQueries(n, ids);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteSamplers (int count, int[] samplers, int offset) {
+		super.glDeleteSamplers(count, samplers, offset);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteSamplers (int n, IntBuffer ids) {
+		super.glDeleteSamplers(n, ids);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteTransformFeedbacks (int n, int[] ids, int offset) {
+		super.glDeleteTransformFeedbacks(n, ids, offset);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteTransformFeedbacks (int n, IntBuffer ids) {
+		super.glDeleteTransformFeedbacks(n, ids);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteVertexArrays (int n, int[] arrays, int offset) {
+		super.glDeleteVertexArrays(n, arrays, offset);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteVertexArrays (int n, IntBuffer ids) {
+		super.glDeleteVertexArrays(n, ids);
+		checkError();
+	}
+
+	@Override
+	public void glDrawArraysInstanced (int mode, int first, int count, int instanceCount) {
+		super.glDrawArraysInstanced(mode, first, count, instanceCount);
+		checkError();
+	}
+
+	@Override
+	public void glDrawBuffers (int n, IntBuffer bufs) {
+		super.glDrawBuffers(n, bufs);
+		checkError();
+	}
+
+	@Override
+	public void glDrawElementsInstanced (int mode, int count, int type, int indicesOffset, int instanceCount) {
+		super.glDrawElementsInstanced(mode, count, type, indicesOffset, instanceCount);
+		checkError();
+	}
+
+	@Override
+	public void glDrawRangeElements (int mode, int start, int end, int count, int type, Buffer indices) {
+		super.glDrawRangeElements(mode, start, end, count, type, indices);
+		checkError();
+	}
+
+	@Override
+	public void glDrawRangeElements (int mode, int start, int end, int count, int type, int offset) {
+		super.glDrawRangeElements(mode, start, end, count, type, offset);
+		checkError();
+	}
+
+	@Override
+	public void glTexImage2D (int target, int level, int internalformat, int width, int height, int border, int format, int type,
+		int offset) {
+		super.glTexImage2D(target, level, internalformat, width, height, border, format, type, offset);
+		checkError();
+	}
+
+	@Override
+	public void glEndQuery (int target) {
+		super.glEndQuery(target);
+		checkError();
+	}
+
+	@Override
+	public void glEndTransformFeedback () {
+		super.glEndTransformFeedback();
+		checkError();
+	}
+
+	@Override
+	public void glFlushMappedBufferRange (int target, int offset, int length) {
+		super.glFlushMappedBufferRange(target, offset, length);
+		checkError();
+	}
+
+	@Override
+	public void glFramebufferTextureLayer (int target, int attachment, int texture, int level, int layer) {
+		super.glFramebufferTextureLayer(target, attachment, texture, level, layer);
+		checkError();
+	}
+
+	@Override
+	public void glGenQueries (int n, int[] ids, int offset) {
+		super.glGenQueries(n, ids, offset);
+		checkError();
+	}
+
+	@Override
+	public void glGenQueries (int n, IntBuffer ids) {
+		super.glGenQueries(n, ids);
+		checkError();
+	}
+
+	@Override
+	public void glGenSamplers (int count, int[] samplers, int offset) {
+		super.glGenSamplers(count, samplers, offset);
+		checkError();
+	}
+
+	@Override
+	public void glGenSamplers (int n, IntBuffer ids) {
+		super.glGenSamplers(n, ids);
+		checkError();
+	}
+
+	@Override
+	public void glGenTransformFeedbacks (int n, int[] ids, int offset) {
+		super.glGenTransformFeedbacks(n, ids, offset);
+		checkError();
+	}
+
+	@Override
+	public void glGenTransformFeedbacks (int n, IntBuffer ids) {
+		super.glGenTransformFeedbacks(n, ids);
+		checkError();
+	}
+
+	@Override
+	public void glGenVertexArrays (int n, int[] arrays, int offset) {
+		super.glGenVertexArrays(n, arrays, offset);
+		checkError();
+	}
+
+	@Override
+	public void glGenVertexArrays (int n, IntBuffer ids) {
+		super.glGenVertexArrays(n, ids);
+		checkError();
+	}
+
+	@Override
+	public void glGetActiveUniformBlockiv (int program, int uniformBlockIndex, int pname, IntBuffer params) {
+		super.glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
+		checkError();
+	}
+
+	@Override
+	public String glGetActiveUniformBlockName (int program, int uniformBlockIndex) {
+		return super.glGetActiveUniformBlockName(program, uniformBlockIndex);
+	}
+
+	@Override
+	public void glGetActiveUniformBlockName (int program, int uniformBlockIndex, Buffer length, Buffer uniformBlockName) {
+		super.glGetActiveUniformBlockName(program, uniformBlockIndex, length, uniformBlockName);
+		checkError();
+	}
+
+	@Override
+	public void glGetActiveUniformsiv (int program, int uniformCount, IntBuffer uniformIndices, int pname, IntBuffer params) {
+		super.glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetBufferParameteri64v (int target, int pname, LongBuffer params) {
+		super.glGetBufferParameteri64v(target, pname, params);
+		checkError();
+	}
+
+	@Override
+	public Buffer glGetBufferPointerv (int target, int pname) {
+		return super.glGetBufferPointerv(target, pname);
+	}
+
+	@Override
+	public int glGetFragDataLocation (int program, String name) {
+		return super.glGetFragDataLocation(program, name);
+	}
+
+	@Override
+	public void glGetInteger64v (int pname, LongBuffer params) {
+		super.glGetInteger64v(pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetQueryiv (int target, int pname, IntBuffer params) {
+		super.glGetQueryiv(target, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetQueryObjectuiv (int id, int pname, IntBuffer params) {
+		super.glGetQueryObjectuiv(id, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetSamplerParameterfv (int sampler, int pname, FloatBuffer params) {
+		super.glGetSamplerParameterfv(sampler, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetSamplerParameteriv (int sampler, int pname, IntBuffer params) {
+		super.glGetSamplerParameteriv(sampler, pname, params);
+		checkError();
+	}
+
+	@Override
+	public String glGetStringi (int name, int index) {
+		return super.glGetStringi(name, index);
+	}
+
+	@Override
+	public int glGetUniformBlockIndex (int program, String uniformBlockName) {
+		return super.glGetUniformBlockIndex(program, uniformBlockName);
+	}
+
+	@Override
+	public void glGetUniformIndices (int program, String[] uniformNames, IntBuffer uniformIndices) {
+		super.glGetUniformIndices(program, uniformNames, uniformIndices);
+		checkError();
+	}
+
+	@Override
+	public void glGetUniformuiv (int program, int location, IntBuffer params) {
+		super.glGetUniformuiv(program, location, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetVertexAttribIiv (int index, int pname, IntBuffer params) {
+		super.glGetVertexAttribIiv(index, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetVertexAttribIuiv (int index, int pname, IntBuffer params) {
+		super.glGetVertexAttribIuiv(index, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glInvalidateFramebuffer (int target, int numAttachments, IntBuffer attachments) {
+		super.glInvalidateFramebuffer(target, numAttachments, attachments);
+		checkError();
+	}
+
+	@Override
+	public void glInvalidateSubFramebuffer (int target, int numAttachments, IntBuffer attachments, int x, int y, int width,
+		int height) {
+		super.glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
+		checkError();
+	}
+
+	@Override
+	public boolean glIsQuery (int id) {
+		return super.glIsQuery(id);
+	}
+
+	@Override
+	public boolean glIsSampler (int id) {
+		return super.glIsSampler(id);
+	}
+
+	@Override
+	public boolean glIsTransformFeedback (int id) {
+		return super.glIsTransformFeedback(id);
+	}
+
+	@Override
+	public boolean glIsVertexArray (int id) {
+		return super.glIsVertexArray(id);
+	}
+
+	@Override
+	public Buffer glMapBufferRange (int target, int offset, int length, int access) {
+		return super.glMapBufferRange(target, offset, length, access);
+	}
+
+	@Override
+	public void glPauseTransformFeedback () {
+		super.glPauseTransformFeedback();
+		checkError();
+	}
+
+	@Override
+	public void glProgramParameteri (int program, int pname, int value) {
+		super.glProgramParameteri(program, pname, value);
+		checkError();
+	}
+
+	@Override
+	public void glReadBuffer (int mode) {
+		super.glReadBuffer(mode);
+		checkError();
+	}
+
+	@Override
+	public void glRenderbufferStorageMultisample (int target, int samples, int internalformat, int width, int height) {
+		super.glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
+		checkError();
+	}
+
+	@Override
+	public void glResumeTransformFeedback () {
+		super.glResumeTransformFeedback();
+		checkError();
+	}
+
+	@Override
+	public void glSamplerParameterf (int sampler, int pname, float param) {
+		super.glSamplerParameterf(sampler, pname, param);
+		checkError();
+	}
+
+	@Override
+	public void glSamplerParameterfv (int sampler, int pname, FloatBuffer param) {
+		super.glSamplerParameterfv(sampler, pname, param);
+		checkError();
+	}
+
+	@Override
+	public void glSamplerParameteri (int sampler, int pname, int param) {
+		super.glSamplerParameteri(sampler, pname, param);
+		checkError();
+	}
+
+	@Override
+	public void glSamplerParameteriv (int sampler, int pname, IntBuffer param) {
+		super.glSamplerParameteriv(sampler, pname, param);
+		checkError();
+	}
+
+	@Override
+	public void glTexImage3D (int target, int level, int internalformat, int width, int height, int depth, int border, int format,
+		int type, Buffer pixels) {
+		super.glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
+		checkError();
+	}
+
+	@Override
+	public void glTexImage3D (int target, int level, int internalformat, int width, int height, int depth, int border, int format,
+		int type, int offset) {
+		super.glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, offset);
+		checkError();
+	}
+
+	@Override
+	public void glTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format, int type,
+		int offset) {
+		super.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, offset);
+		checkError();
+	}
+
+	@Override
+	public void glTexSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth,
+		int format, int type, Buffer pixels) {
+		super.glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
+		checkError();
+	}
+
+	@Override
+	public void glTexSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth,
+		int format, int type, int offset) {
+		super.glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, offset);
+		checkError();
+	}
+
+	@Override
+	public void glTransformFeedbackVaryings (int program, String[] varyings, int bufferMode) {
+		super.glTransformFeedbackVaryings(program, varyings, bufferMode);
+		checkError();
+	}
+
+	@Override
+	public void glUniform1uiv (int location, int count, IntBuffer value) {
+		super.glUniform1uiv(location, count, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniform3uiv (int location, int count, IntBuffer value) {
+		super.glUniform3uiv(location, count, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniform4uiv (int location, int count, IntBuffer value) {
+		super.glUniform4uiv(location, count, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniformBlockBinding (int program, int uniformBlockIndex, int uniformBlockBinding) {
+		super.glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
+		checkError();
+	}
+
+	@Override
+	public void glUniformMatrix2x3fv (int location, int count, boolean transpose, FloatBuffer value) {
+		super.glUniformMatrix2x3fv(location, count, transpose, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniformMatrix2x4fv (int location, int count, boolean transpose, FloatBuffer value) {
+		super.glUniformMatrix2x4fv(location, count, transpose, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniformMatrix3x2fv (int location, int count, boolean transpose, FloatBuffer value) {
+		super.glUniformMatrix3x2fv(location, count, transpose, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniformMatrix3x4fv (int location, int count, boolean transpose, FloatBuffer value) {
+		super.glUniformMatrix3x4fv(location, count, transpose, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniformMatrix4x2fv (int location, int count, boolean transpose, FloatBuffer value) {
+		super.glUniformMatrix4x2fv(location, count, transpose, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniformMatrix4x3fv (int location, int count, boolean transpose, FloatBuffer value) {
+		super.glUniformMatrix4x3fv(location, count, transpose, value);
+		checkError();
+	}
+
+	@Override
+	public boolean glUnmapBuffer (int target) {
+		return super.glUnmapBuffer(target);
+	}
+
+	@Override
+	public void glVertexAttribDivisor (int index, int divisor) {
+		super.glVertexAttribDivisor(index, divisor);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttribI4i (int index, int x, int y, int z, int w) {
+		super.glVertexAttribI4i(index, x, y, z, w);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttribI4ui (int index, int x, int y, int z, int w) {
+		super.glVertexAttribI4ui(index, x, y, z, w);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttribIPointer (int index, int size, int type, int stride, int offset) {
+		super.glVertexAttribIPointer(index, size, type, stride, offset);
+		checkError();
+	}
+
+	/** Begin GL20 methods **/
+
+	@Override
+	public void glActiveTexture (int texture) {
+		super.glActiveTexture(texture);
+		checkError();
+	}
+
+	@Override
+	public void glBindTexture (int target, int texture) {
+
+		super.glBindTexture(target, texture);
+		checkError();
+	}
+
+	@Override
+	public void glBlendFunc (int sfactor, int dfactor) {
+
+		super.glBlendFunc(sfactor, dfactor);
+		checkError();
+	}
+
+	@Override
+	public void glClear (int mask) {
+
+		super.glClear(mask);
+		checkError();
+	}
+
+	@Override
+	public void glClearColor (float red, float green, float blue, float alpha) {
+
+		super.glClearColor(red, green, blue, alpha);
+		checkError();
+	}
+
+	@Override
+	public void glClearDepthf (float depth) {
+
+		super.glClearDepthf(depth);
+		checkError();
+	}
+
+	@Override
+	public void glClearStencil (int s) {
+
+		super.glClearStencil(s);
+		checkError();
+	}
+
+	@Override
+	public void glColorMask (boolean red, boolean green, boolean blue, boolean alpha) {
+
+		super.glColorMask(red, green, blue, alpha);
+		checkError();
+	}
+
+	@Override
+	public void glCompressedTexImage2D (int target, int level, int internalformat, int width, int height, int border,
+		int imageSize, Buffer data) {
+
+		super.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
+		checkError();
+	}
+
+	@Override
+	public void glCompressedTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format,
+		int imageSize, Buffer data) {
+
+		super.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
+		checkError();
+	}
+
+	@Override
+	public void glCopyTexImage2D (int target, int level, int internalformat, int x, int y, int width, int height, int border) {
+
+		super.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
+		checkError();
+	}
+
+	@Override
+	public void glCopyTexSubImage2D (int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
+
+		super.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
+		checkError();
+	}
+
+	@Override
+	public void glCullFace (int mode) {
+
+		super.glCullFace(mode);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteTextures (int n, IntBuffer textures) {
+
+		super.glDeleteTextures(n, textures);
+		checkError();
+	}
+
+	@Override
+	public void glDepthFunc (int func) {
+
+		super.glDepthFunc(func);
+		checkError();
+	}
+
+	@Override
+	public void glDepthMask (boolean flag) {
+
+		super.glDepthMask(flag);
+		checkError();
+	}
+
+	@Override
+	public void glDepthRangef (float zNear, float zFar) {
+
+		super.glDepthRangef(zNear, zFar);
+		checkError();
+	}
+
+	@Override
+	public void glDisable (int cap) {
+
+		super.glDisable(cap);
+		checkError();
+	}
+
+	@Override
+	public void glDrawArrays (int mode, int first, int count) {
+
+		super.glDrawArrays(mode, first, count);
+		checkError();
+	}
+
+	@Override
+	public void glDrawElements (int mode, int count, int type, Buffer indices) {
+
+		super.glDrawElements(mode, count, type, indices);
+		checkError();
+	}
+
+	@Override
+	public void glEnable (int cap) {
+
+		super.glEnable(cap);
+		checkError();
+	}
+
+	@Override
+	public void glFinish () {
+
+		super.glFinish();
+		checkError();
+	}
+
+	@Override
+	public void glFlush () {
+
+		super.glFlush();
+		checkError();
+	}
+
+	@Override
+	public void glFrontFace (int mode) {
+
+		super.glFrontFace(mode);
+		checkError();
+	}
+
+	@Override
+	public void glGenTextures (int n, IntBuffer textures) {
+
+		super.glGenTextures(n, textures);
+		checkError();
+	}
+
+	@Override
+	public int glGetError () {
+
+		return super.glGetError();
+	}
+
+	@Override
+	public void glGetIntegerv (int pname, IntBuffer params) {
+
+		super.glGetIntegerv(pname, params);
+		checkError();
+	}
+
+	@Override
+	public String glGetString (int name) {
+
+		return super.glGetString(name);
+	}
+
+	@Override
+	public void glHint (int target, int mode) {
+
+		super.glHint(target, mode);
+		checkError();
+	}
+
+	@Override
+	public void glLineWidth (float width) {
+
+		super.glLineWidth(width);
+		checkError();
+	}
+
+	@Override
+	public void glPixelStorei (int pname, int param) {
+
+		super.glPixelStorei(pname, param);
+		checkError();
+	}
+
+	@Override
+	public void glPolygonOffset (float factor, float units) {
+
+		super.glPolygonOffset(factor, units);
+		checkError();
+	}
+
+	@Override
+	public void glReadPixels (int x, int y, int width, int height, int format, int type, Buffer pixels) {
+
+		super.glReadPixels(x, y, width, height, format, type, pixels);
+		checkError();
+	}
+
+	@Override
+	public void glScissor (int x, int y, int width, int height) {
+
+		super.glScissor(x, y, width, height);
+		checkError();
+	}
+
+	@Override
+	public void glStencilFunc (int func, int ref, int mask) {
+
+		super.glStencilFunc(func, ref, mask);
+		checkError();
+	}
+
+	@Override
+	public void glStencilMask (int mask) {
+
+		super.glStencilMask(mask);
+		checkError();
+	}
+
+	@Override
+	public void glStencilOp (int fail, int zfail, int zpass) {
+
+		super.glStencilOp(fail, zfail, zpass);
+		checkError();
+	}
+
+	@Override
+	public void glTexImage2D (int target, int level, int internalformat, int width, int height, int border, int format, int type,
+		Buffer pixels) {
+
+		super.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
+		checkError();
+	}
+
+	@Override
+	public void glTexParameterf (int target, int pname, float param) {
+
+		super.glTexParameterf(target, pname, param);
+		checkError();
+	}
+
+	@Override
+	public void glTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format, int type,
+		Buffer pixels) {
+
+		super.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
+		checkError();
+	}
+
+	@Override
+	public void glViewport (int x, int y, int width, int height) {
+
+		super.glViewport(x, y, width, height);
+		checkError();
+	}
+
+	@Override
+	public void glAttachShader (int program, int shader) {
+
+		super.glAttachShader(program, shader);
+		checkError();
+	}
+
+	@Override
+	public void glBindAttribLocation (int program, int index, String name) {
+
+		super.glBindAttribLocation(program, index, name);
+		checkError();
+	}
+
+	@Override
+	public void glBindBuffer (int target, int buffer) {
+
+		super.glBindBuffer(target, buffer);
+		checkError();
+	}
+
+	@Override
+	public void glBindFramebuffer (int target, int framebuffer) {
+
+		super.glBindFramebuffer(target, framebuffer);
+		checkError();
+	}
+
+	@Override
+	public void glBindRenderbuffer (int target, int renderbuffer) {
+
+		super.glBindRenderbuffer(target, renderbuffer);
+		checkError();
+	}
+
+	@Override
+	public void glBlendColor (float red, float green, float blue, float alpha) {
+
+		super.glBlendColor(red, green, blue, alpha);
+		checkError();
+	}
+
+	@Override
+	public void glBlendEquation (int mode) {
+
+		super.glBlendEquation(mode);
+		checkError();
+	}
+
+	@Override
+	public void glBlendEquationSeparate (int modeRGB, int modeAlpha) {
+
+		super.glBlendEquationSeparate(modeRGB, modeAlpha);
+		checkError();
+	}
+
+	@Override
+	public void glBlendFuncSeparate (int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
+
+		super.glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
+		checkError();
+	}
+
+	@Override
+	public void glBufferData (int target, int size, Buffer data, int usage) {
+
+		super.glBufferData(target, size, data, usage);
+		checkError();
+	}
+
+	@Override
+	public void glBufferSubData (int target, int offset, int size, Buffer data) {
+
+		super.glBufferSubData(target, offset, size, data);
+		checkError();
+	}
+
+	@Override
+	public int glCheckFramebufferStatus (int target) {
+
+		return super.glCheckFramebufferStatus(target);
+	}
+
+	@Override
+	public void glCompileShader (int shader) {
+
+		super.glCompileShader(shader);
+		checkError();
+	}
+
+	@Override
+	public int glCreateProgram () {
+
+		int program = super.glCreateProgram();
+		checkError();
+		return program;
+	}
+
+	@Override
+	public int glCreateShader (int type) {
+
+		int shader = super.glCreateShader(type);
+		checkError();
+		return shader;
+	}
+
+	@Override
+	public void glDeleteBuffers (int n, IntBuffer buffers) {
+
+		super.glDeleteBuffers(n, buffers);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteFramebuffers (int n, IntBuffer framebuffers) {
+
+		super.glDeleteFramebuffers(n, framebuffers);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteProgram (int program) {
+
+		super.glDeleteProgram(program);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteRenderbuffers (int n, IntBuffer renderbuffers) {
+
+		super.glDeleteRenderbuffers(n, renderbuffers);
+		checkError();
+	}
+
+	@Override
+	public void glDeleteShader (int shader) {
+
+		super.glDeleteShader(shader);
+		checkError();
+	}
+
+	@Override
+	public void glDetachShader (int program, int shader) {
+
+		super.glDetachShader(program, shader);
+		checkError();
+	}
+
+	@Override
+	public void glDisableVertexAttribArray (int index) {
+
+		super.glDisableVertexAttribArray(index);
+		checkError();
+	}
+
+	@Override
+	public void glDrawElements (int mode, int count, int type, int indices) {
+
+		super.glDrawElements(mode, count, type, indices);
+		checkError();
+	}
+
+	@Override
+	public void glEnableVertexAttribArray (int index) {
+
+		super.glEnableVertexAttribArray(index);
+		checkError();
+	}
+
+	@Override
+	public void glFramebufferRenderbuffer (int target, int attachment, int renderbuffertarget, int renderbuffer) {
+
+		super.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
+		checkError();
+	}
+
+	@Override
+	public void glFramebufferTexture2D (int target, int attachment, int textarget, int texture, int level) {
+
+		super.glFramebufferTexture2D(target, attachment, textarget, texture, level);
+		checkError();
+	}
+
+	@Override
+	public void glGenBuffers (int n, IntBuffer buffers) {
+
+		super.glGenBuffers(n, buffers);
+		checkError();
+	}
+
+	@Override
+	public void glGenerateMipmap (int target) {
+
+		super.glGenerateMipmap(target);
+		checkError();
+	}
+
+	@Override
+	public void glGenFramebuffers (int n, IntBuffer framebuffers) {
+
+		super.glGenFramebuffers(n, framebuffers);
+		checkError();
+	}
+
+	@Override
+	public void glGenRenderbuffers (int n, IntBuffer renderbuffers) {
+
+		super.glGenRenderbuffers(n, renderbuffers);
+		checkError();
+	}
+
+	@Override
+	public String glGetActiveAttrib (int program, int index, IntBuffer size, IntBuffer type) {
+
+		String attrib = super.glGetActiveAttrib(program, index, size, type);
+		checkError();
+		return attrib;
+	}
+
+	@Override
+	public String glGetActiveUniform (int program, int index, IntBuffer size, IntBuffer type) {
+
+		String uniform = super.glGetActiveUniform(program, index, size, type);
+		checkError();
+		return uniform;
+	}
+
+	@Override
+	public void glGetAttachedShaders (int program, int maxcount, Buffer count, IntBuffer shaders) {
+
+		super.glGetAttachedShaders(program, maxcount, count, shaders);
+		checkError();
+	}
+
+	@Override
+	public int glGetAttribLocation (int program, String name) {
+
+		int loc = super.glGetAttribLocation(program, name);
+		checkError();
+		return loc;
+	}
+
+	@Override
+	public void glGetBooleanv (int pname, Buffer params) {
+
+		super.glGetBooleanv(pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetBufferParameteriv (int target, int pname, IntBuffer params) {
+
+		super.glGetBufferParameteriv(target, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetFloatv (int pname, FloatBuffer params) {
+
+		super.glGetFloatv(pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetFramebufferAttachmentParameteriv (int target, int attachment, int pname, IntBuffer params) {
+
+		super.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetProgramiv (int program, int pname, IntBuffer params) {
+
+		super.glGetProgramiv(program, pname, params);
+		checkError();
+	}
+
+	@Override
+	public String glGetProgramInfoLog (int program) {
+
+		String info = super.glGetProgramInfoLog(program);
+		checkError();
+		return info;
+	}
+
+	@Override
+	public void glGetRenderbufferParameteriv (int target, int pname, IntBuffer params) {
+
+		super.glGetRenderbufferParameteriv(target, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetShaderiv (int shader, int pname, IntBuffer params) {
+
+		super.glGetShaderiv(shader, pname, params);
+		checkError();
+	}
+
+	@Override
+	public String glGetShaderInfoLog (int shader) {
+
+		String info = super.glGetShaderInfoLog(shader);
+		checkError();
+		return info;
+	}
+
+	@Override
+	public void glGetShaderPrecisionFormat (int shadertype, int precisiontype, IntBuffer range, IntBuffer precision) {
+
+		super.glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
+		checkError();
+	}
+
+	@Override
+	public void glGetTexParameterfv (int target, int pname, FloatBuffer params) {
+
+		super.glGetTexParameterfv(target, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetTexParameteriv (int target, int pname, IntBuffer params) {
+
+		super.glGetTexParameteriv(target, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetUniformfv (int program, int location, FloatBuffer params) {
+
+		super.glGetUniformfv(program, location, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetUniformiv (int program, int location, IntBuffer params) {
+
+		super.glGetUniformiv(program, location, params);
+		checkError();
+	}
+
+	@Override
+	public int glGetUniformLocation (int program, String name) {
+
+		int loc = super.glGetUniformLocation(program, name);
+		checkError();
+		return loc;
+	}
+
+	@Override
+	public void glGetVertexAttribfv (int index, int pname, FloatBuffer params) {
+
+		super.glGetVertexAttribfv(index, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetVertexAttribiv (int index, int pname, IntBuffer params) {
+
+		super.glGetVertexAttribiv(index, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glGetVertexAttribPointerv (int index, int pname, Buffer pointer) {
+
+		super.glGetVertexAttribPointerv(index, pname, pointer);
+		checkError();
+	}
+
+	@Override
+	public boolean glIsBuffer (int buffer) {
+
+		boolean res = super.glIsBuffer(buffer);
+		checkError();
+		return res;
+	}
+
+	@Override
+	public boolean glIsEnabled (int cap) {
+
+		boolean res = super.glIsEnabled(cap);
+		checkError();
+		return res;
+	}
+
+	@Override
+	public boolean glIsFramebuffer (int framebuffer) {
+
+		boolean res = super.glIsFramebuffer(framebuffer);
+		checkError();
+		return res;
+	}
+
+	@Override
+	public boolean glIsProgram (int program) {
+
+		boolean res = super.glIsProgram(program);
+		checkError();
+		return res;
+	}
+
+	@Override
+	public boolean glIsRenderbuffer (int renderbuffer) {
+
+		boolean res = super.glIsRenderbuffer(renderbuffer);
+		checkError();
+		return res;
+	}
+
+	@Override
+	public boolean glIsShader (int shader) {
+
+		boolean res = super.glIsShader(shader);
+		checkError();
+		return res;
+	}
+
+	@Override
+	public boolean glIsTexture (int texture) {
+
+		boolean res = super.glIsTexture(texture);
+		checkError();
+		return res;
+	}
+
+	@Override
+	public void glLinkProgram (int program) {
+
+		super.glLinkProgram(program);
+		checkError();
+	}
+
+	@Override
+	public void glReleaseShaderCompiler () {
+
+		super.glReleaseShaderCompiler();
+		checkError();
+	}
+
+	@Override
+	public void glRenderbufferStorage (int target, int internalformat, int width, int height) {
+
+		super.glRenderbufferStorage(target, internalformat, width, height);
+		checkError();
+	}
+
+	@Override
+	public void glSampleCoverage (float value, boolean invert) {
+
+		super.glSampleCoverage(value, invert);
+		checkError();
+	}
+
+	@Override
+	public void glShaderBinary (int n, IntBuffer shaders, int binaryformat, Buffer binary, int length) {
+
+		super.glShaderBinary(n, shaders, binaryformat, binary, length);
+		checkError();
+	}
+
+	@Override
+	public void glShaderSource (int shader, String source) {
+
+		super.glShaderSource(shader, source);
+		checkError();
+	}
+
+	@Override
+	public void glStencilFuncSeparate (int face, int func, int ref, int mask) {
+
+		super.glStencilFuncSeparate(face, func, ref, mask);
+		checkError();
+	}
+
+	@Override
+	public void glStencilMaskSeparate (int face, int mask) {
+
+		super.glStencilMaskSeparate(face, mask);
+		checkError();
+	}
+
+	@Override
+	public void glStencilOpSeparate (int face, int fail, int zfail, int zpass) {
+
+		super.glStencilOpSeparate(face, fail, zfail, zpass);
+		checkError();
+	}
+
+	@Override
+	public void glTexParameterfv (int target, int pname, FloatBuffer params) {
+
+		super.glTexParameterfv(target, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glTexParameteri (int target, int pname, int param) {
+
+		super.glTexParameteri(target, pname, param);
+		checkError();
+	}
+
+	@Override
+	public void glTexParameteriv (int target, int pname, IntBuffer params) {
+
+		super.glTexParameteriv(target, pname, params);
+		checkError();
+	}
+
+	@Override
+	public void glUniform1f (int location, float x) {
+
+		super.glUniform1f(location, x);
+		checkError();
+	}
+
+	@Override
+	public void glUniform1fv (int location, int count, FloatBuffer v) {
+
+		super.glUniform1fv(location, count, v);
+		checkError();
+	}
+
+	@Override
+	public void glUniform1i (int location, int x) {
+
+		super.glUniform1i(location, x);
+		checkError();
+	}
+
+	@Override
+	public void glUniform1iv (int location, int count, IntBuffer v) {
+
+		super.glUniform1iv(location, count, v);
+		checkError();
+	}
+
+	@Override
+	public void glUniform2f (int location, float x, float y) {
+
+		super.glUniform2f(location, x, y);
+		checkError();
+	}
+
+	@Override
+	public void glUniform2fv (int location, int count, FloatBuffer v) {
+
+		super.glUniform2fv(location, count, v);
+		checkError();
+	}
+
+	@Override
+	public void glUniform2i (int location, int x, int y) {
+
+		super.glUniform2i(location, x, y);
+		checkError();
+	}
+
+	@Override
+	public void glUniform2iv (int location, int count, IntBuffer v) {
+
+		super.glUniform2iv(location, count, v);
+		checkError();
+	}
+
+	@Override
+	public void glUniform3f (int location, float x, float y, float z) {
+
+		super.glUniform3f(location, x, y, z);
+		checkError();
+	}
+
+	@Override
+	public void glUniform3fv (int location, int count, FloatBuffer v) {
+
+		super.glUniform3fv(location, count, v);
+		checkError();
+	}
+
+	@Override
+	public void glUniform3i (int location, int x, int y, int z) {
+
+		super.glUniform3i(location, x, y, z);
+		checkError();
+	}
+
+	@Override
+	public void glUniform3iv (int location, int count, IntBuffer v) {
+
+		super.glUniform3iv(location, count, v);
+		checkError();
+	}
+
+	@Override
+	public void glUniform4f (int location, float x, float y, float z, float w) {
+
+		super.glUniform4f(location, x, y, z, w);
+		checkError();
+	}
+
+	@Override
+	public void glUniform4fv (int location, int count, FloatBuffer v) {
+
+		super.glUniform4fv(location, count, v);
+		checkError();
+	}
+
+	@Override
+	public void glUniform4i (int location, int x, int y, int z, int w) {
+
+		super.glUniform4i(location, x, y, z, w);
+		checkError();
+	}
+
+	@Override
+	public void glUniform4iv (int location, int count, IntBuffer v) {
+
+		super.glUniform4iv(location, count, v);
+		checkError();
+	}
+
+	@Override
+	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value) {
+
+		super.glUniformMatrix2fv(location, count, transpose, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value) {
+
+		super.glUniformMatrix3fv(location, count, transpose, value);
+		checkError();
+	}
+
+	@Override
+	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value) {
+
+		super.glUniformMatrix4fv(location, count, transpose, value);
+		checkError();
+	}
+
+	@Override
+	public void glUseProgram (int program) {
+
+		super.glUseProgram(program);
+		checkError();
+	}
+
+	@Override
+	public void glValidateProgram (int program) {
+
+		super.glValidateProgram(program);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttrib1f (int indx, float x) {
+
+		super.glVertexAttrib1f(indx, x);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttrib1fv (int indx, FloatBuffer values) {
+
+		super.glVertexAttrib1fv(indx, values);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttrib2f (int indx, float x, float y) {
+
+		super.glVertexAttrib2f(indx, x, y);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttrib2fv (int indx, FloatBuffer values) {
+
+		super.glVertexAttrib2fv(indx, values);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttrib3f (int indx, float x, float y, float z) {
+
+		super.glVertexAttrib3f(indx, x, y, z);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttrib3fv (int indx, FloatBuffer values) {
+
+		super.glVertexAttrib3fv(indx, values);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttrib4f (int indx, float x, float y, float z, float w) {
+
+		super.glVertexAttrib4f(indx, x, y, z, w);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttrib4fv (int indx, FloatBuffer values) {
+
+		super.glVertexAttrib4fv(indx, values);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, Buffer ptr) {
+
+		super.glVertexAttribPointer(indx, size, type, normalized, stride, ptr);
+		checkError();
+	}
+
+	@Override
+	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, int ptr) {
+
+		super.glVertexAttribPointer(indx, size, type, normalized, stride, ptr);
+		checkError();
+	}
+}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGraphics.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGraphics.java
index e1b5bf400..905acd86e 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGraphics.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGraphics.java
@@ -31,6 +31,7 @@ import com.google.gwt.dom.client.CanvasElement;
 import com.google.gwt.dom.client.Style;
 import com.google.gwt.user.client.Window;
 import com.google.gwt.user.client.ui.Panel;
+import com.google.gwt.webgl.client.WebGL2RenderingContext;
 import com.google.gwt.webgl.client.WebGLContextAttributes;
 import com.google.gwt.webgl.client.WebGLRenderingContext;
 
@@ -55,8 +56,8 @@ public class GwtGraphics extends AbstractGraphics {
 	CanvasElement canvas;
 	WebGLRenderingContext context;
 	GLVersion glVersion;
-	GL20 gl;
-	String extensions;
+	private GL20 gl20;
+	private GL30 gl30;
 	float fps = 0;
 	long lastTimeStamp = System.currentTimeMillis();
 	long frameId = -1;
@@ -90,13 +91,25 @@ public class GwtGraphics extends AbstractGraphics {
 		attributes.setPreserveDrawingBuffer(config.preserveDrawingBuffer);
 		attributes.setXrCompatible(config.xrCompatible);
 
-		context = WebGLRenderingContext.getContext(canvas, attributes);
+		if (config.useGL30) {
+			// Check for WebGL2 support, and fall back to 1.0 if not supported.
+			context = WebGL2RenderingContext.getContext(canvas, attributes);
+		}
+
+		if (config.useGL30 && context != null) {
+			// WebGL2 supported
+			this.gl30 = config.useDebugGL ? new GwtGL30Debug((WebGL2RenderingContext)context)
+				: new GwtGL30((WebGL2RenderingContext)context);
+			this.gl20 = gl30;
+		} else {
+			context = WebGLRenderingContext.getContext(canvas, attributes);
+			this.gl20 = config.useDebugGL ? new GwtGL20Debug(context) : new GwtGL20(context);
+		}
 		context.viewport(0, 0, getWidth(), getHeight());
-		this.gl = config.useDebugGL ? new GwtGL20Debug(context) : new GwtGL20(context);
 
-		String versionString = gl.glGetString(GL20.GL_VERSION);
-		String vendorString = gl.glGetString(GL20.GL_VENDOR);
-		String rendererString = gl.glGetString(GL20.GL_RENDERER);
+		String versionString = gl20.glGetString(GL20.GL_VERSION);
+		String vendorString = gl20.glGetString(GL20.GL_VENDOR);
+		String rendererString = gl20.glGetString(GL20.GL_RENDERER);
 		glVersion = new GLVersion(Application.ApplicationType.WebGL, versionString, vendorString, rendererString);
 	}
 
@@ -106,29 +119,36 @@ public class GwtGraphics extends AbstractGraphics {
 
 	@Override
 	public GL20 getGL20 () {
-		return gl;
+		return gl20;
 	}
 
 	@Override
 	public void setGL20 (GL20 gl20) {
-		this.gl = gl20;
+		this.gl20 = gl20;
 		Gdx.gl = gl20;
 		Gdx.gl20 = gl20;
 	}
 
 	@Override
 	public boolean isGL30Available () {
-		return false;
+		return gl30 != null;
 	}
 
 	@Override
 	public GL30 getGL30 () {
-		return null;
+		return gl30;
 	}
 
 	@Override
 	public void setGL30 (GL30 gl30) {
+		this.gl30 = gl30;
+		if (gl30 != null) {
+			this.gl20 = gl30;
 
+			Gdx.gl = gl20;
+			Gdx.gl20 = gl20;
+			Gdx.gl30 = gl30;
+		}
 	}
 
 	@Override
diff --git a/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGL2RenderingContext.java b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGL2RenderingContext.java
new file mode 100644
index 000000000..7b08c6eb8
--- /dev/null
+++ b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGL2RenderingContext.java
@@ -0,0 +1,559 @@
+/*******************************************************************************
+ * Copyright 2022 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.google.gwt.webgl.client;
+
+import com.google.gwt.canvas.dom.client.ImageData;
+import com.google.gwt.core.client.JavaScriptObject;
+import com.google.gwt.core.client.JsArrayBoolean;
+import com.google.gwt.core.client.JsArrayInteger;
+import com.google.gwt.core.client.JsArrayString;
+import com.google.gwt.dom.client.CanvasElement;
+import com.google.gwt.dom.client.ImageElement;
+import com.google.gwt.dom.client.VideoElement;
+import com.google.gwt.typedarrays.shared.ArrayBufferView;
+import com.google.gwt.typedarrays.shared.Float32Array;
+import com.google.gwt.typedarrays.shared.Int32Array;
+import com.google.gwt.typedarrays.shared.Uint32Array;
+
+/** @author Simon Gerst
+ * @author JamesTKhan */
+public class WebGL2RenderingContext extends WebGLRenderingContext {
+
+	/** Returns a WebGL2 context for the given canvas element. Returns null if no 3d context is available. */
+	public static WebGL2RenderingContext getContext (CanvasElement canvas) {
+		return getContext(canvas, WebGLContextAttributes.create());
+	}
+
+	/** Returns a WebGL2 context for the given canvas element. Returns null if no 3d context is available. */
+	public static native WebGL2RenderingContext getContext (CanvasElement canvas, WebGLContextAttributes attributes) /*-{
+		try {
+			var ctx = canvas.getContext("webgl2", attributes);
+			if (ctx != null) {
+				console.log('WebGL2 Enabled');
+				if ($wnd.WebGLDebugUtils) {
+					if ($wnd.console && $wnd.console.log) {
+						console.log('WebGL debugging enabled');
+					}
+					return $wnd.WebGLDebugUtils.makeDebugContext(ctx);
+				}
+				return ctx;
+			}
+		} catch (e) {
+			console.log(e);
+		}
+		return null;
+	}-*/;
+
+	protected WebGL2RenderingContext () {
+	}
+
+	/** Converts a Java primitive string array to JsArrayString
+	 *
+	 * @param input primitive string array
+	 * @return converted JsArrayString */
+	private static JsArrayString toJsArray (String[] input) {
+		JsArrayString jsArrayString = JsArrayString.createArray().cast();
+		for (String s : input) {
+			jsArrayString.push(s);
+		}
+		return jsArrayString;
+	}
+
+	public final native void beginQuery (int target, WebGLQuery query)/*-{
+		this.beginQuery(target, query);
+	}-*/;
+
+	public final native void beginTransformFeedback (int primitiveMode)/*-{
+		this.beginTransformFeedback(primitiveMode);
+	}-*/;
+
+	public final native void bindBufferBase (int target, int index, WebGLBuffer buffer)/*-{
+		this.bindBufferBase(target, index, buffer);
+	}-*/;
+
+	public final native void bindBufferRange (int target, int index, WebGLBuffer buffer, int offset, int size)/*-{
+		this.bindBufferRange(target, index, buffer, offset, size);
+	}-*/;
+
+	public final native void bindSampler (int unit, WebGLSampler sampler)/*-{
+		this.bindSampler(unit, sampler);
+	}-*/;
+
+	public final native void bindTransformFeedback (int target, WebGLTransformFeedback id)/*-{
+		this.bindTransformFeedback(target, id);
+
+	}-*/;
+
+	public final native void bindVertexArray (WebGLVertexArrayObject array)/*-{
+		this.bindVertexArray(array);
+	}-*/;
+
+	public final native void blitFramebuffer (int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1,
+		int dstY1, int mask, int filter)/*-{
+		this.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1,
+				dstY1, mask, filter);
+	}-*/;
+
+	public final native void clearBufferfi (int buffer, int drawbuffer, float depth, int stencil)/*-{
+		this.clearBufferfi(buffer, drawbuffer, depth, stencil);
+	}-*/;
+
+	public final void clearBufferfv (int buffer, int drawbuffer, Float32Array value) {
+		this.clearBufferfv(buffer, drawbuffer, (JavaScriptObject)value);
+	}
+
+	public final native void clearBufferfv (int buffer, int drawbuffer, JavaScriptObject value)/*-{
+		this.clearBufferfv(buffer, drawbuffer, value);
+	}-*/;
+
+	public final void clearBufferiv (int buffer, int drawbuffer, Int32Array value) {
+		this.clearBufferiv(buffer, drawbuffer, (JavaScriptObject)value);
+	}
+
+	public final native void clearBufferiv (int buffer, int drawbuffer, JavaScriptObject value)/*-{
+		this.clearBufferiv(buffer, drawbuffer, value);
+	}-*/;
+
+	public final void clearBufferuiv (int buffer, int drawbuffer, Int32Array value) {
+		this.clearBufferuiv(buffer, drawbuffer, (JavaScriptObject)value);
+	}
+
+	public final native void clearBufferuiv (int buffer, int drawbuffer, JavaScriptObject value)/*-{
+		this.clearBufferuiv(buffer, drawbuffer, value);
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native int clientWaitSync (WebGLSync sync, int flags, /* GLint64 */int timeout)/*-{
+// throw "UnsupportedOperation";
+// }-*/;
+
+// Commented out in GL30 interface
+// public final native void compressedTexImage3D (int target, int level, int internalformat, int width, int height, int depth,
+// int border, ArrayBufferView data)/*-{
+// throw "UnsupportedOperation";
+// }-*/;
+
+// Commented out in GL30 interface
+// public final native void compressedTexSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int width,
+// int height, int depth, int format, ArrayBufferView data)/*-{
+// throw "UnsupportedOperation";
+//
+// }-*/;
+
+	public final native void copyBufferSubData (int readTarget, int writeTarget, int readOffset, int writeOffset, int size)/*-{
+		this.copyBufferSubData(readTarget, writeTarget, readOffset,
+				writeOffset, size);
+	}-*/;
+
+	public final native void copyTexSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int x, int y,
+		int width, int height)/*-{
+    	this.copyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
+	}-*/;
+
+	public final native WebGLQuery createQuery ()/*-{
+		return this.createQuery();
+	}-*/;
+
+	public final native WebGLSampler createSampler ()/*-{
+		return this.createSampler();
+	}-*/;
+
+	public final native WebGLTransformFeedback createTransformFeedback ()/*-{
+		return this.createTransformFeedback();
+	}-*/;
+
+	public final native WebGLVertexArrayObject createVertexArray ()/*-{
+		return this.createVertexArray();
+	}-*/;
+
+	public final native void deleteQuery (WebGLQuery query)/*-{
+		this.deleteQuery(query);
+	}-*/;
+
+	public final native void deleteSampler (WebGLSampler sampler)/*-{
+		this.deleteSampler(sampler);
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native void deleteSync (WebGLSync sync)/*-{
+// this.deleteSync(sync);
+// }-*/;
+
+	public final native void deleteTransformFeedback (WebGLTransformFeedback transformFeedback)/*-{
+		this.deleteTransformFeedback(transformFeedback);
+	}-*/;
+
+	public final native void deleteVertexArray (WebGLVertexArrayObject vertexArray)/*-{
+		this.deleteVertexArray(vertexArray);
+	}-*/;
+
+	public final native void drawArraysInstanced (int mode, int first, int count, int instanceCount)/*-{
+		this.drawArraysInstanced(mode, first, count, instanceCount);
+	}-*/;
+
+	public final native void drawBuffers (Int32Array buffers)/*-{
+		this.drawBuffers(buffers);
+	}-*/;
+
+	public final native void drawElementsInstanced (int mode, int count, int type, int offset, int instanceCount)/*-{
+		this.drawElementsInstanced(mode, count, type, offset, instanceCount);
+	}-*/;
+
+	public final native void drawRangeElements (int mode, int start, int end, int count, int type, int offset)/*-{
+		this.drawRangeElements(mode, start, end, count, type, offset);
+	}-*/;
+
+	public final native void texImage2D (int target, int level, int internalformat, int width, int height, int border, int format,
+		int type, int offset)/*-{
+		this.texImage2D(target, level, internalformat, width, height, border, format, type, offset);
+	}-*/;
+
+	public final native void endQuery (int target)/*-{
+		this.endQuery(target);
+	}-*/;
+
+	public final native void endTransformFeedback ()/*-{
+		this.endTransformFeedback();
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native WebGLSync fenceSync (int condition, int flags)/*-{
+// throw "UnsupportedOperation";
+//
+// }-*/;
+
+	public final native void framebufferTextureLayer (int target, int attachment, WebGLTexture texture, int level, int layer)/*-{
+		this.framebufferTextureLayer(target, attachment, texture, level, layer);
+	}-*/;
+
+	public final native String getActiveUniformBlockName (WebGLProgram program, int uniformBlockIndex)/*-{
+        return this.getActiveUniformBlockName(program, uniformBlockIndex);
+	}-*/;
+
+	public final native int getActiveUniformBlockParameteri (WebGLProgram program, int uniformBlockIndex, int pname)/*-{
+		return this.getActiveUniformBlockParameter(program, uniformBlockIndex, pname);
+	}-*/;
+
+	public final native <T extends ArrayBufferView> T getActiveUniformBlockParameterv (WebGLProgram program, int uniformBlockIndex,
+		int pname)/*-{
+		return this.getActiveUniformBlockParameter(program, uniformBlockIndex, pname);
+	}-*/;
+
+	public final native boolean getActiveUniformBlockParameterb (WebGLProgram program, int uniformBlockIndex, int pname)/*-{
+		return this.getActiveUniformBlockParameter(program, uniformBlockIndex, pname);
+	}-*/;
+
+	public final native JsArrayInteger getActiveUniformsi (WebGLProgram program, Int32Array uniformIndices, int pname)/*-{
+    	return this.getActiveUniforms(program, uniformIndices, pname);
+	}-*/;
+
+	public final native JsArrayBoolean getActiveUniformsb (WebGLProgram program, Int32Array uniformIndices, int pname)/*-{
+		return this.getActiveUniforms(program, uniformIndices, pname);
+	}-*/;
+
+	public final native int getFragDataLocation (WebGLProgram program, String name)/*-{
+        return this.getFragDataLocation(program, name);
+	}-*/;
+
+	// Returning an int but GL type is GLint64 and GL30 interface uses LongBuffer. JS does not support long
+	// so we return an int, not sure how else to preserve the long values at this time.
+	public final native int getParameteri64 (int pname) /*-{
+		return this.getParameter(pname);
+	}-*/;
+
+	public final native WebGLQuery getQuery (int target, int pname)/*-{
+		return this.getQuery(target, pname);
+	}-*/;
+
+	public final native boolean getQueryParameterb (WebGLQuery query, int pname)/*-{
+		return this.getQueryParameter(query, pname);
+	}-*/;
+
+	public final native int getQueryParameteri (WebGLQuery query, int pname)/*-{
+		return this.getQueryParameter(query, pname);
+	}-*/;
+
+	public final native float getSamplerParameterf (WebGLSampler sampler, int pname)/*-{
+		return this.getSamplerParameter(sampler, pname);
+	}-*/;
+
+	public final native int getSamplerParameteri (WebGLSampler sampler, int pname)/*-{
+		return this.getSamplerParameter(sampler, pname);
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native WebGLActiveInfo getTransformFeedbackVarying (WebGLProgram program, int index)/*-{
+// throw "UnsupportedOperation";
+// }-*/;
+
+	public final native int getUniformBlockIndex (WebGLProgram program, String uniformBlockName)/*-{
+        return this.getUniformBlockIndex(program, uniformBlockName);
+	}-*/;
+
+	public final JsArrayInteger getUniformIndices (WebGLProgram program, String[] uniformNames) {
+		return this.getUniformIndices(program, toJsArray(uniformNames));
+	}
+
+	public final native JsArrayInteger getUniformIndices (WebGLProgram program, JsArrayString uniformNames)/*-{
+		return this.getUniformIndices(program, uniformNames);
+	}-*/;
+
+	public final native void invalidateFramebuffer (int target, Int32Array attachments)/*-{
+		this.invalidateFramebuffer(target, attachments);
+	}-*/;
+
+	public final native void invalidateSubFramebuffer (int target, Int32Array attachments, int x, int y, int width, int height)/*-{
+		this.invalidateSubFramebuffer(target, attachments, x, y, width, height);
+	}-*/;
+
+	public final native boolean isQuery (WebGLQuery query)/*-{
+        return this.isQuery(query);
+	}-*/;
+
+	public final native boolean isSampler (WebGLSampler sampler)/*-{
+		return this.isSampler(sampler);
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native boolean isSync (WebGLSync sync)/*-{
+// return this.isSync(sync);
+// }-*/;
+
+	public final native boolean isTransformFeedback (WebGLTransformFeedback transformFeedback)/*-{
+		return this.isTransformFeedback(transformFeedback);
+	}-*/;
+
+	public final native boolean isVertexArray (WebGLVertexArrayObject vertexArray)/*-{
+		return this.isVertexArray(vertexArray);
+	}-*/;
+
+	public final native void pauseTransformFeedback ()/*-{
+        this.pauseTransformFeedback();
+	}-*/;
+
+	public final native void readBuffer (int src)/*-{
+		this.readBuffer(src);
+	}-*/;
+
+	public final native void renderbufferStorageMultisample (int target, int samples, int internalformat, int width, int height)/*-{
+		this.renderbufferStorageMultisample(target, samples, internalformat, width, height);
+	}-*/;
+
+	public final native void resumeTransformFeedback ()/*-{
+		this.resumeTransformFeedback();
+	}-*/;
+
+	public final native void samplerParameterf (WebGLSampler sampler, int pname, float param)/*-{
+		this.samplerParameterf(sampler, pname, param);
+	}-*/;
+
+	public final native void samplerParameteri (WebGLSampler sampler, int pname, int param)/*-{
+		this.samplerParameteri(sampler, pname, param);
+	}-*/;
+
+	public final native void texImage3D (int target, int level, int internalformat, int width, int height, int depth, int border,
+		int format, int type, int offset)/*-{
+		this.texImage3D(target, level, internalformat, width, height, depth, border,
+				format, type, offset);
+	}-*/;
+
+	public final native void texImage3D (int target, int level, int internalformat, int width, int height, int depth, int border,
+		int format, int type, ArrayBufferView pixels)/*-{
+		this.texImage3D(target, level, internalformat, width, height, depth, border,
+				format, type, pixels);
+	}-*/;
+
+	public final native void texImage3D (int target, int level, int internalformat, int width, int height, int depth, int border,
+		int format, int type, ImageData pixels) /*-{
+		this.texImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
+	}-*/;
+
+	public final native void texImage3D (int target, int level, int internalformat, int width, int height, int depth, int border,
+		int format, int type, ImageElement image) /*-{
+		this.texImage3D(target, level, internalformat, width, height, depth, border, format, type, image);
+	}-*/;
+
+	public final native void texImage3D (int target, int level, int internalformat, int width, int height, int depth, int border,
+		int format, int type, CanvasElement canvas) /*-{
+		this.texImage3D(target, level, internalformat, width, height, depth, border, format, type, canvas);
+	}-*/;
+
+	public final native void texImage3D (int target, int level, int internalformat, int width, int height, int depth, int border,
+		int format, int type, VideoElement video) /*-{
+		this.texImage3D(target, level, internalformat, width, height, depth, border, format, type, video);
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native void texStorage2D (int target, int levels, int internalformat, int width, int height)/*-{
+// this.texStorage2D(target, levels, internalformat, width, height)
+// }-*/;
+
+// Commented out in GL30 interface
+// public final native void texStorage3D (int target, int levels, int internalformat, int width, int height, int depth)/*-{
+// throw "UnsupportedOperation";
+// }-*/;
+
+	public final native void texSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int width, int height,
+		int depth, int format, int type, ArrayBufferView pixels)/*-{
+    	this.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
+	}-*/;
+
+	public final native void texSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int width, int height,
+		int depth, int format, int type, CanvasElement canvas)/*-{
+		this.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, canvas);
+	}-*/;
+
+	public final native void texSubImage3D (int target, int level, int xoffset, int yoffset, int zoffset, int width, int height,
+		int depth, int format, int type, int offset)/*-{
+		this.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, offset);
+	}-*/;
+
+	public final native void texSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format,
+		int type, int offset)/*-{
+		this.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, offset);
+	}-*/;
+
+	public final void transformFeedbackVaryings (WebGLProgram program, String[] varyings, int bufferMode) {
+		this.transformFeedbackVaryings(program, toJsArray(varyings), bufferMode);
+	}
+
+	public final native void transformFeedbackVaryings (WebGLProgram program, JsArrayString varyings, int bufferMode)/*-{
+		this.transformFeedbackVaryings(program, varyings, bufferMode);
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native void uniform1ui (WebGLUniformLocation location, int v0)/*-{
+// this.uniform1ui(location, v0);
+// }-*/;
+
+	public final void uniform1uiv (WebGLUniformLocation location, Uint32Array value, int srcOffset, int srcLength) {
+		this.uniform1uiv(location, (JavaScriptObject)value, srcOffset, srcLength);
+	}
+
+	public final native void uniform1uiv (WebGLUniformLocation location, JavaScriptObject value, int srcOffset, int srcLength)/*-{
+    	this.uniform1uiv(location, value, srcOffset, srcLength);
+	}-*/;
+
+	public final void uniform3uiv (WebGLUniformLocation location, Uint32Array value, int srcOffset, int srcLength) {
+		this.uniform3uiv(location, (JavaScriptObject)value, srcOffset, srcLength);
+	}
+
+	public final native void uniform3uiv (WebGLUniformLocation location, JavaScriptObject value, int srcOffset, int srcLength)/*-{
+		this.uniform3uiv(location, value, srcOffset, srcLength)
+	}-*/;
+
+	public final void uniform4uiv (WebGLUniformLocation location, Uint32Array value, int srcOffset, int srcLength) {
+		this.uniform4uiv(location, (JavaScriptObject)value, srcOffset, srcLength);
+	}
+
+	public final native void uniform4uiv (WebGLUniformLocation location, JavaScriptObject value, int srcOffset, int srcLength)/*-{
+		this.uniform4uiv(location, value, srcOffset, srcLength)
+	}-*/;
+
+	public final native void uniformBlockBinding (WebGLProgram program, int uniformBlockIndex, int uniformBlockBinding)/*-{
+		this.uniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
+	}-*/;
+
+	public final void uniformMatrix2x3fv (WebGLUniformLocation location, boolean transpose, Float32Array value) {
+		this.uniformMatrix2x3fv(location, transpose, (JavaScriptObject)value);
+	}
+
+	public final native void uniformMatrix2x3fv (WebGLUniformLocation location, boolean transpose, JavaScriptObject value)/*-{
+		this.uniformMatrix2x3fv(location, transpose, value);
+	}-*/;
+
+	public final void uniformMatrix2x4fv (WebGLUniformLocation location, boolean transpose, Float32Array value, int srcOffset,
+		int srcLength) {
+		this.uniformMatrix2x4fv(location, transpose, (JavaScriptObject)value, srcOffset, srcLength);
+	}
+
+	public final native void uniformMatrix2x4fv (WebGLUniformLocation location, boolean transpose, JavaScriptObject value,
+		int srcOffset, int srcLength)/*-{
+		this.uniformMatrix2x4fv(location, transpose, value, srcOffset, srcLength);
+	}-*/;
+
+	public final void uniformMatrix3x2fv (WebGLUniformLocation location, boolean transpose, Float32Array value, int srcOffset,
+		int srcLength) {
+		this.uniformMatrix3x2fv(location, transpose, (JavaScriptObject)value, srcOffset, srcLength);
+	}
+
+	public final native void uniformMatrix3x2fv (WebGLUniformLocation location, boolean transpose, JavaScriptObject value,
+		int srcOffset, int srcLength)/*-{
+		this.uniformMatrix3x2fv(location, transpose, value, srcOffset, srcLength);
+	}-*/;
+
+	public final void uniformMatrix3x4fv (WebGLUniformLocation location, boolean transpose, Float32Array value, int srcOffset,
+		int srcLength) {
+		this.uniformMatrix3x4fv(location, transpose, (JavaScriptObject)value, srcOffset, srcLength);
+	}
+
+	public final native void uniformMatrix3x4fv (WebGLUniformLocation location, boolean transpose, JavaScriptObject value,
+		int srcOffset, int srcLength)/*-{
+		this.uniformMatrix3x4fv(location, transpose, value, srcOffset, srcLength);
+	}-*/;
+
+	public final void uniformMatrix4x2fv (WebGLUniformLocation location, boolean transpose, Float32Array value, int srcOffset,
+		int srcLength) {
+		this.uniformMatrix4x2fv(location, transpose, (JavaScriptObject)value, srcOffset, srcLength);
+	}
+
+	public final native void uniformMatrix4x2fv (WebGLUniformLocation location, boolean transpose, JavaScriptObject value,
+		int srcOffset, int srcLength)/*-{
+		this.uniformMatrix4x2fv(location, transpose, value, srcOffset, srcLength);
+	}-*/;
+
+	public final void uniformMatrix4x3fv (WebGLUniformLocation location, boolean transpose, Float32Array value, int srcOffset,
+		int srcLength) {
+		this.uniformMatrix4x3fv(location, transpose, (JavaScriptObject)value, srcOffset, srcLength);
+	}
+
+	public final native void uniformMatrix4x3fv (WebGLUniformLocation location, boolean transpose, JavaScriptObject value,
+		int srcOffset, int srcLength)/*-{
+		this.uniformMatrix4x3fv(location, transpose, value, srcOffset, srcLength);
+	}-*/;
+
+	public final native void vertexAttribDivisor (int index, int divisor)/*-{
+		this.vertexAttribDivisor(index, divisor);
+	}-*/;
+
+	public final native void vertexAttribI4i (int index, int x, int y, int z, int w)/*-{
+		this.vertexAttribI4i(index, x, y, z, w);
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native void vertexAttribI4iv (int index, VertexAttribIVSource values)/*-{
+// throw "UnsupportedOperation";
+// }-*/;
+
+	public final native void vertexAttribI4ui (int index, int x, int y, int z, int w)/*-{
+		this.vertexAttribI4ui(index, x, y, z, w);
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native void vertexAttribI4uiv (int index, VertexAttribUIVSource values)/*-{
+// throw "UnsupportedOperation";
+// }-*/;
+
+	public final native void vertexAttribIPointer (int index, int size, int type, int stride, int offset)/*-{
+		this.vertexAttribIPointer(index, size, type, stride, offset);
+	}-*/;
+
+// Commented out in GL30 interface
+// public final native void waitSync (WebGLSync sync, int flags, /* GLint64 */int timeout)/*-{
+// throw "UnsupportedOperation";
+// }-*/;
+};
diff --git a/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLQuery.java b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLQuery.java
new file mode 100644
index 000000000..9ab5636f4
--- /dev/null
+++ b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLQuery.java
@@ -0,0 +1,23 @@
+/*******************************************************************************
+ * Copyright 2022 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.google.gwt.webgl.client;
+
+public class WebGLQuery extends WebGLObject {
+
+	protected WebGLQuery () {
+	}
+}
diff --git a/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLSampler.java b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLSampler.java
new file mode 100644
index 000000000..9f51a170a
--- /dev/null
+++ b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLSampler.java
@@ -0,0 +1,24 @@
+/*******************************************************************************
+ * Copyright 2022 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.google.gwt.webgl.client;
+
+import com.google.gwt.core.client.JavaScriptObject;
+
+public class WebGLSampler extends JavaScriptObject {
+	protected WebGLSampler () {
+	}
+}
diff --git a/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLTransformFeedback.java b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLTransformFeedback.java
new file mode 100644
index 000000000..78ca88acf
--- /dev/null
+++ b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLTransformFeedback.java
@@ -0,0 +1,23 @@
+/*******************************************************************************
+ * Copyright 2022 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.google.gwt.webgl.client;
+
+public class WebGLTransformFeedback extends WebGLObject {
+
+	protected WebGLTransformFeedback () {
+	}
+}
diff --git a/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLVertexArrayObject.java b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLVertexArrayObject.java
new file mode 100644
index 000000000..cfc7a0962
--- /dev/null
+++ b/backends/gdx-backends-gwt/src/com/google/gwt/webgl/client/WebGLVertexArrayObject.java
@@ -0,0 +1,23 @@
+/*******************************************************************************
+ * Copyright 2022 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.google.gwt.webgl.client;
+
+public class WebGLVertexArrayObject extends WebGLObject {
+
+	protected WebGLVertexArrayObject () {
+	}
+}
diff --git a/gdx/res/com/badlogic/gdx.gwt.xml b/gdx/res/com/badlogic/gdx.gwt.xml
index 141cbff3a..095b4633f 100644
--- a/gdx/res/com/badlogic/gdx.gwt.xml
+++ b/gdx/res/com/badlogic/gdx.gwt.xml
@@ -88,10 +88,10 @@
 		<include name="graphics/Pixmap.java"/> <!-- Emulated -->
 		<exclude name="graphics/PixmapIO.java"/> <!-- Reason: No DeflaterOutputStream -->
 		<include name="graphics/Texture.java"/>
-		<exclude name="graphics/Texture3D.java"/> <!-- GLES 3.0 -->
-		<exclude name="graphics/Texture3DData.java"/> <!-- GLES 3.0 -->
-		<exclude name="graphics/TextureArray.java"/> <!-- GLES 3.0 -->
-		<exclude name="graphics/TextureArrayData.java"/> <!-- GLES 3.0 -->
+		<include name="graphics/Texture3D.java"/> <!-- GLES 3.0 -->
+		<include name="graphics/Texture3DData.java"/> <!-- GLES 3.0 -->
+		<include name="graphics/TextureArray.java"/> <!-- GLES 3.0 -->
+		<include name="graphics/TextureArrayData.java"/> <!-- GLES 3.0 -->
 		<exclude name="graphics/TextureData.java"/> <!-- emulated: TextureData.Factory requires ETC1 -->
 		<include name="graphics/VertexAttribute.java"/>
 		<include name="graphics/VertexAttributes.java"/>
@@ -238,11 +238,11 @@
 		<include name="graphics/g3d/utils/shapebuilders/SphereShapeBuilder.java"/>
 
 	<!-- graphics/glutils -->
-		<exclude name="graphics/glutils/CustomTexture3DData.java"/> <!-- GLES 3.0 -->
+		<include name="graphics/glutils/CustomTexture3DData.java"/> <!-- GLES 3.0 -->
 		<exclude name="graphics/glutils/ETC1.java"/> <!-- Reason: No ETC1 Support -->
 		<include name="graphics/glutils/ETC1TextureData.java"/>  <!-- Emulated: explodes on construction -->
 		<include name="graphics/glutils/FacedCubemapData.java"/>
-		<exclude name="graphics/glutils/FileTextureArrayData.java"/> <!-- GLES 3.0 -->
+		<include name="graphics/glutils/FileTextureArrayData.java"/> <!-- GLES 3.0 -->
 		<include name="graphics/glutils/FileTextureData.java"/> <!-- Emulated: No PixmapIO -->
 		<include name="graphics/glutils/FloatFrameBuffer.java"/>
 		<include name="graphics/glutils/FloatTextureData.java"/>
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/FloatFrameBuffer.java b/gdx/src/com/badlogic/gdx/graphics/glutils/FloatFrameBuffer.java
index c747adf2e..5f7965dab 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/FloatFrameBuffer.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/FloatFrameBuffer.java
@@ -28,6 +28,7 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 public class FloatFrameBuffer extends FrameBuffer {
 
 	FloatFrameBuffer () {
+		checkExtensions();
 	}
 
 	/** Creates a GLFrameBuffer from the specifications provided by bufferBuilder
@@ -35,6 +36,7 @@ public class FloatFrameBuffer extends FrameBuffer {
 	 * @param bufferBuilder **/
 	protected FloatFrameBuffer (GLFrameBufferBuilder<? extends GLFrameBuffer<Texture>> bufferBuilder) {
 		super(bufferBuilder);
+		checkExtensions();
 	}
 
 	/** Creates a new FrameBuffer with a float backing texture, having the given dimensions and potentially a depth buffer
@@ -45,6 +47,7 @@ public class FloatFrameBuffer extends FrameBuffer {
 	 * @param hasDepth whether to attach a depth buffer
 	 * @throws GdxRuntimeException in case the FrameBuffer could not be created */
 	public FloatFrameBuffer (int width, int height, boolean hasDepth) {
+		checkExtensions();
 		FloatFrameBufferBuilder bufferBuilder = new FloatFrameBufferBuilder(width, height);
 		bufferBuilder.addFloatAttachment(GL30.GL_RGBA32F, GL30.GL_RGBA, GL30.GL_FLOAT, false);
 		if (hasDepth) bufferBuilder.addBasicDepthRenderBuffer();
@@ -67,4 +70,13 @@ public class FloatFrameBuffer extends FrameBuffer {
 		return result;
 	}
 
+	/** Check for support for any required extensions on the current platform. */
+	private void checkExtensions () {
+		if (Gdx.graphics.isGL30Available() && Gdx.app.getType() == ApplicationType.WebGL) {
+			// For WebGL2, Rendering to a Floating Point Texture requires this extension
+			if (!Gdx.graphics.supportsExtension("EXT_color_buffer_float"))
+				throw new GdxRuntimeException("Extension EXT_color_buffer_float not supported!");
+		}
+	}
+
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/FloatTextureData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/FloatTextureData.java
index c968f40ac..3d27acea7 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/FloatTextureData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/FloatTextureData.java
@@ -81,7 +81,7 @@ public class FloatTextureData implements TextureData {
 	@Override
 	public void consumeCustomData (int target) {
 		if (Gdx.app.getType() == ApplicationType.Android || Gdx.app.getType() == ApplicationType.iOS
-			|| Gdx.app.getType() == ApplicationType.WebGL) {
+			|| (Gdx.app.getType() == ApplicationType.WebGL && !Gdx.graphics.isGL30Available())) {
 
 			if (!Gdx.graphics.supportsExtension("OES_texture_float"))
 				throw new GdxRuntimeException("Extension OES_texture_float not supported!");
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
index 1ba08d67a..efc55275a 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
@@ -16,6 +16,7 @@
 
 package com.badlogic.gdx.graphics.glutils;
 
+import com.badlogic.gdx.Application;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Pixmap;
@@ -80,7 +81,11 @@ public class FrameBuffer extends GLFrameBuffer<Texture> {
 		GLOnlyTextureData data = new GLOnlyTextureData(bufferBuilder.width, bufferBuilder.height, 0, attachmentSpec.internalFormat,
 			attachmentSpec.format, attachmentSpec.type);
 		Texture result = new Texture(data);
-		result.setFilter(TextureFilter.Linear, TextureFilter.Linear);
+		// Filtering support for depth textures on WebGL is spotty https://github.com/KhronosGroup/OpenGL-API/issues/84
+		boolean webGLDepth = attachmentSpec.isDepth && Gdx.app.getType() == Application.ApplicationType.WebGL;
+		if (!webGLDepth) {
+			result.setFilter(TextureFilter.Linear, TextureFilter.Linear);
+		}
 		result.setWrap(TextureWrap.ClampToEdge, TextureWrap.ClampToEdge);
 		return result;
 	}
diff --git a/tests/gdx-tests-android/assets/data/shaders/ubo.frag b/tests/gdx-tests-android/assets/data/shaders/ubo.frag
new file mode 100644
index 000000000..806173910
--- /dev/null
+++ b/tests/gdx-tests-android/assets/data/shaders/ubo.frag
@@ -0,0 +1,13 @@
+
+in vec4 v_color;
+in vec2 v_texCoords;
+
+uniform sampler2D u_texture;
+uniform u_bufferBlock {
+    vec3 colorBuffer;
+    vec2 positionBuffer;
+};
+
+void main () {
+    fragColor = v_color * texture(u_texture, v_texCoords) * vec4(colorBuffer, 1.0);
+}
\ No newline at end of file
diff --git a/tests/gdx-tests-android/assets/data/shaders/ubo.vert b/tests/gdx-tests-android/assets/data/shaders/ubo.vert
new file mode 100644
index 000000000..9cb0dab1d
--- /dev/null
+++ b/tests/gdx-tests-android/assets/data/shaders/ubo.vert
@@ -0,0 +1,25 @@
+#ifdef GL_ES
+// Sharing a UBO requires precision in Vertex shader
+precision mediump float;
+#endif
+
+in vec4 a_position;
+in vec4 a_color;
+in vec2 a_texCoord0;
+
+uniform mat4 u_projTrans;
+uniform u_bufferBlock {
+    vec3 colorBuffer;
+    vec2 positionBuffer;
+};
+
+out vec4 v_color;
+out vec2 v_texCoords;
+
+void main () {
+    v_color = a_color;
+    v_color.a = v_color.a * (255.0/254.0);
+    v_texCoords = a_texCoord0;
+    gl_Position = u_projTrans * a_position;
+    gl_Position.xy += positionBuffer;
+}
\ No newline at end of file
diff --git a/tests/gdx-tests-gwt/build.gradle b/tests/gdx-tests-gwt/build.gradle
index a65630464..cec6bf4f0 100644
--- a/tests/gdx-tests-gwt/build.gradle
+++ b/tests/gdx-tests-gwt/build.gradle
@@ -42,6 +42,7 @@ dependencies {
 	implementation project(":tests:gdx-tests")
 	implementation project(":backends:gdx-backend-gwt")
 	implementation project(":extensions:gdx-box2d-parent:gdx-box2d-gwt")
+	compileOnly "com.google.gwt:gwt-dev:${versions.gwt}"
 }
 
 gwt {
diff --git a/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestStarter.java b/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestStarter.java
index b4086679b..7160cc506 100644
--- a/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestStarter.java
+++ b/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestStarter.java
@@ -19,6 +19,8 @@ package com.badlogic.gdx.tests.gwt.client;
 import com.badlogic.gdx.ApplicationListener;
 import com.badlogic.gdx.backends.gwt.GwtApplication;
 import com.badlogic.gdx.backends.gwt.GwtApplicationConfiguration;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.google.gwt.user.client.Window;
 
 public class GwtTestStarter extends GwtApplication {
 	@Override
@@ -26,6 +28,15 @@ public class GwtTestStarter extends GwtApplication {
 		GwtApplicationConfiguration config = new GwtApplicationConfiguration(true);
 		config.useGyroscope = true;
 		config.padVertical = 150;
+
+		// Look for URL parameter '?useGL30=true' to enable WebGL2
+		config.useGL30 = Boolean.parseBoolean(Window.Location.getParameter("useGL30"));
+
+		if (config.useGL30) {
+			ShaderProgram.prependVertexCode = "#version 300 es\n#define varying out\n#define attribute in\n";
+			ShaderProgram.prependFragmentCode = "#version 300 es\n#define varying in\n#define texture2D texture\n#define gl_FragColor fragColor\nprecision mediump float;\nout vec4 fragColor;\n";
+		}
+
 		// config.openURLInNewWindow = true;
 		return config;
 	}
diff --git a/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestWrapper.java b/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestWrapper.java
index 402e02328..5afc9e9f4 100644
--- a/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestWrapper.java
+++ b/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/client/GwtTestWrapper.java
@@ -1,6 +1,7 @@
 
 package com.badlogic.gdx.tests.gwt.client;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.tests.AbstractTestWrapper;
 import com.badlogic.gdx.tests.AccelerometerTest;
 import com.badlogic.gdx.tests.ActionSequenceTest;
@@ -29,6 +30,7 @@ import com.badlogic.gdx.tests.DownloadTest;
 import com.badlogic.gdx.tests.EdgeDetectionTest;
 import com.badlogic.gdx.tests.FilesTest;
 import com.badlogic.gdx.tests.FilterPerformanceTest;
+import com.badlogic.gdx.tests.FloatTextureTest;
 import com.badlogic.gdx.tests.FrameBufferTest;
 import com.badlogic.gdx.tests.FramebufferToTextureTest;
 import com.badlogic.gdx.tests.GLProfilerErrorTest;
@@ -91,8 +93,14 @@ import com.badlogic.gdx.tests.VertexBufferObjectShaderTest;
 import com.badlogic.gdx.tests.YDownTest;
 import com.badlogic.gdx.tests.conformance.DisplayModeTest;
 import com.badlogic.gdx.tests.g3d.ModelCacheTest;
+import com.badlogic.gdx.tests.g3d.MultipleRenderTargetTest;
 import com.badlogic.gdx.tests.g3d.ShadowMappingTest;
+import com.badlogic.gdx.tests.g3d.TextureArrayTest;
 import com.badlogic.gdx.tests.gles2.VertexArrayTest;
+import com.badlogic.gdx.tests.gles3.GL30Texture3DTest;
+import com.badlogic.gdx.tests.gles3.NonPowerOfTwoTest;
+import com.badlogic.gdx.tests.gles3.UniformBufferObjectsTest;
+import com.badlogic.gdx.tests.gles3.InstancedRenderingTest;
 import com.badlogic.gdx.tests.gwt.GwtInputTest;
 import com.badlogic.gdx.tests.gwt.GwtWindowModeTest;
 import com.badlogic.gdx.tests.math.CollisionPlaygroundTest;
@@ -102,427 +110,568 @@ import com.badlogic.gdx.tests.net.OpenBrowserExample;
 import com.badlogic.gdx.tests.superkoalio.SuperKoalio;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
+import java.util.ArrayList;
+
 public class GwtTestWrapper extends AbstractTestWrapper {
 	@Override
 	protected AbstractTestWrapper.Instancer[] getTestList () {
-		Instancer[] tests = {new GwtInstancer() {
+		ArrayList<Instancer> tests = new ArrayList<>();
+
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new AccelerometerTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new ActionTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new ActionSequenceTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new AlphaTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new AnimationTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new AnnotationTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new AssetManagerTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new AtlasIssueTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new BigMeshTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new BitmapFontAlignmentTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new BitmapFontFlipTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new BitmapFontTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new BitmapFontMetricsTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new BlitTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new Box2DCharacterControllerTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new Box2DTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new Box2DTestCollection();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new BufferUtilsTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new ClipboardTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new ColorTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new CollisionPlaygroundTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new ComplexActionTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new CustomShaderSpriteBatchTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new DecalTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new DisplayModeTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new LabelScaleTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new EdgeDetectionTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new FilesTest();
 			}
-		}, new GwtInstancer() {
+		});
+		tests.add(new GwtInstancer() {
 			public GdxTest instance () {
 				return new FilterPerformanceTest();
 			}
-		},
+		});
 // new GwtInstancer() {public GdxTest instance(){return new FlickScrollPaneTest();}}, // FIXME this messes up stuff, why?
-			new GwtInstancer() {
-				public GdxTest instance () {
-					return new FrameBufferTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new DownloadTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new FramebufferToTextureTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new GestureDetectorTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new GLProfilerErrorTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new GroupCullingTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new GroupFadeTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new GwtInputTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new GwtWindowModeTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new I18NSimpleMessageTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ImageScaleTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ImageTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new IndexBufferObjectShaderTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new IntegerBitmapFontTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new InterpolationTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new InverseKinematicsTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new IsometricTileTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new KinematicBodyTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new LifeCycleTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new LabelTest();
-				}
-			},
-			// new GwtInstancer() {public GdxTest instance(){return new MatrixJNITest();}}, // No purpose
-			new GwtInstancer() {
-				public GdxTest instance () {
-					return new MeshShaderTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new MeshWithCustomAttributesTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new MipMapTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ModelCacheTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new MultitouchTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new MusicTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new OctreeTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new OpenBrowserExample();
-				}
-// }, new GwtInstancer() { public GdxTest instance () { return new NoncontinuousRenderingTest(); } // FIXME doesn't compile due to
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new FrameBufferTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new DownloadTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new FramebufferToTextureTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new GestureDetectorTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new GLProfilerErrorTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new GroupCullingTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new GroupFadeTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new GwtInputTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new GwtWindowModeTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new I18NSimpleMessageTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ImageScaleTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ImageTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new IndexBufferObjectShaderTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new IntegerBitmapFontTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new InterpolationTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new InverseKinematicsTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new IsometricTileTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new KinematicBodyTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new LifeCycleTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new LabelTest();
+			}
+		});
+		// new GwtInstancer() {public GdxTest instance(){return new MatrixJNITest();}}, // No purpose
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new MeshShaderTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new MeshWithCustomAttributesTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new MipMapTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ModelCacheTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new MultitouchTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new MusicTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new OctreeTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new OpenBrowserExample();
+			}
+		});
+// tests.add(new GwtInstancer() { public GdxTest instance () { return new NoncontinuousRenderingTest(); } // FIXME doesn't compile
+// due to
 // the use of Thread
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new OrientedBoundingBoxTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ParallaxTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ParticleEmitterTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new PixelsPerInchTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new PixmapPackerTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new PixmapTest();
-				}
-			},
-			// new GwtInstancer() {public GdxTest instance(){return new PixmapBlendingTest();}}, // FIXME no idea why this doesn't
-			// work
-			new GwtInstancer() {
-				public GdxTest instance () {
-					return new PreferencesTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ProjectiveTextureTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new RotationTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ReflectionCorrectnessTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new Scene2dTest();
-				}
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new OrientedBoundingBoxTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ParallaxTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ParticleEmitterTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new PixelsPerInchTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new PixmapPackerTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new PixmapTest();
+			}
+		});
+		// new GwtInstancer() {public GdxTest instance(){return new PixmapBlendingTest();}}, // FIXME no idea why this doesn't
+		// work
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new PreferencesTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ProjectiveTextureTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new RotationTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ReflectionCorrectnessTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new Scene2dTest();
+			}
+		});
 
 // new GwtInstancer() {public GdxTest instance(){return new RunnablePostTest();}}, // Goes into infinite loop
 // new GwtInstancer() {public GdxTest instance(){return new ScrollPaneTest();}}, // FIXME this messes up stuff, why?
 // new GwtInstancer() {public GdxTest instance(){return new ShaderMultitextureTest();}}, // FIXME fucks up stuff
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ShadowMappingTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ShapeRendererTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SimpleAnimationTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SimpleDecalTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SimpleStageCullingTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SortedSpriteTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SpriteBatchShaderTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SpriteCacheOffsetTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SpriteCacheTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SoundTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new StageTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SystemCursorTest();
-				}
-			},
-			// new GwtInstancer() {public GdxTest instance(){return new StagePerformanceTest();}}, // FIXME borks out
-			new GwtInstancer() {
-				public GdxTest instance () {
-					return new TableTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new TextButtonTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new TextButtonTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new TextureAtlasTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new TiledMapObjectLoadingTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new UITest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new VertexBufferObjectShaderTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new YDownTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new SuperKoalio();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new ReflectionTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new TiledMapAtlasAssetManagerTest();
-				}
-			}, new GwtInstancer() {
-				public GdxTest instance () {
-					return new TimeUtilsTest();
-				}
-			}, new GwtInstancer() {
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ShadowMappingTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ShapeRendererTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SimpleAnimationTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SimpleDecalTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SimpleStageCullingTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SortedSpriteTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SpriteBatchShaderTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SpriteCacheOffsetTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SpriteCacheTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SoundTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new StageTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SystemCursorTest();
+			}
+		});
+		// new GwtInstancer() {public GdxTest instance(){return new StagePerformanceTest();}}, // FIXME borks out
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TableTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TextButtonTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TextButtonTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TextureAtlasTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TiledMapObjectLoadingTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new UITest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new VertexBufferObjectShaderTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new YDownTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new SuperKoalio();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new ReflectionTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TiledMapAtlasAssetManagerTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TimeUtilsTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new GWTLossyPremultipliedAlphaTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new QuadTreeFloatTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new QuadTreeFloatNearestTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TextAreaTest();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TextAreaTest2();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new TextAreaTest3();
+			}
+		});
+		tests.add(new GwtInstancer() {
+			public GdxTest instance () {
+				return new VertexArrayTest();
+			}
+		});
+		// these may have issues with tab getting intercepted by the browser
+
+		// Add the GL30 tests if applicable
+		if (Gdx.graphics.isGL30Available()) {
+			tests.add(new GwtInstancer() {
 				public GdxTest instance () {
-					return new GWTLossyPremultipliedAlphaTest();
+					return new FloatTextureTest();
 				}
-			}, new GwtInstancer() {
+			});
+			tests.add(new GwtInstancer() {
 				public GdxTest instance () {
-					return new QuadTreeFloatTest();
+					return new GL30Texture3DTest();
 				}
-			}, new GwtInstancer() {
+			});
+			tests.add(new GwtInstancer() {
 				public GdxTest instance () {
-					return new QuadTreeFloatNearestTest();
+					return new InstancedRenderingTest();
 				}
-			}, new GwtInstancer() {
+			});
+			tests.add(new GwtInstancer() {
 				public GdxTest instance () {
-					return new TextAreaTest();
+					return new MultipleRenderTargetTest();
 				}
-			}, new GwtInstancer() {
+			});
+			tests.add(new GwtInstancer() {
 				public GdxTest instance () {
-					return new TextAreaTest2();
+					return new NonPowerOfTwoTest();
 				}
-			}, new GwtInstancer() {
+			});
+			tests.add(new GwtInstancer() {
 				public GdxTest instance () {
-					return new TextAreaTest3();
+					return new TextureArrayTest();
 				}
-			}, new GwtInstancer() {
+			});
+			tests.add(new GwtInstancer() {
 				public GdxTest instance () {
-					return new VertexArrayTest();
+					return new UniformBufferObjectsTest();
 				}
-			} // these may have issues with tab getting intercepted by the browser
-		};
+			});
+		}
+
+		Instancer[] testArr = new Instancer[tests.size()];
+		tests.toArray(testArr);
 
-		return tests;
+		return testArr;
 	}
 
-	abstract static class GwtInstancer implements Instancer {
+	abstract static class GwtInstancer implements AbstractTestWrapper.Instancer {
 		@Override
 		public String getSimpleName () {
 			return instance().getClass().getSimpleName();
diff --git a/tests/gdx-tests/res/com/badlogic/gdx/GdxTests.gwt.xml b/tests/gdx-tests/res/com/badlogic/gdx/GdxTests.gwt.xml
index 6438bf782..18a27e2c1 100644
--- a/tests/gdx-tests/res/com/badlogic/gdx/GdxTests.gwt.xml
+++ b/tests/gdx-tests/res/com/badlogic/gdx/GdxTests.gwt.xml
@@ -14,11 +14,9 @@
 		<exclude name="**/KTXTest.java"/> <!-- use ECT1 which is native -->
 		<exclude name="**/ETC1Test.java"/> <!-- native -->
 		<exclude name="**/FFTTest.java"/> <!-- native -->
-		<exclude name="**/FloatTextureTest.java"/> <!-- GLES 2.0 extension -->
 		<exclude name="**/FreeType*.java"/> <!-- native  -->
 		<exclude name="**/Gdx2DTest.java"/> <!-- native -->
 		<exclude name="**/GdxTests.java"/> <!-- utility -->
-		<exclude name="**/GL30Texture3DTest.java"/> <!-- GLES 3.0 -->
 		<exclude name="**/HeightField.java"/> <!-- Incompatible type due to emulation -->
 		<exclude name="**/HeightMapTest.java"/> <!-- Incompatible type due to emulation -->
 		<exclude name="**/I18NMessageTest.java"/> <!-- MessageBundle -->
@@ -37,10 +35,9 @@
 		<exclude name="**/SensorTest.java"/> <!-- Tests device accelerometer, compass, gyro -->
 		<exclude name="**/SoundTouchTest.java"/> <!-- native -->
 		<exclude name="**/StbTrueTypeTest.java"/> <!-- native -->
-		<exclude name="**/TextureArrayTest.java"/> <!-- GLES 3.0 -->
 		<exclude name="**/TextureDownloadTest.java"/> <!-- http utils missing -->
 		<exclude name="**/TTFFactoryTest.java"/> <!-- native -->
-		<exclude name="**/VBOWithVAOPerformanceTest.java"/> <!-- GLES 3.0 -->
+		<exclude name="**/VBOWithVAOPerformanceTest.java"/> <!-- GLES 3.0, Emulation issues -->
 		<exclude name="**/VorbisTest.java"/> <!-- native -->
 		<exclude name="**/WavTest.java"/> <!-- naive -->
 		<exclude name="**/voxel/*.java"/> <!-- PerlinNoiseGenerator uses a method not in the emulated version of Buffer -->
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/MultipleRenderTargetTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/MultipleRenderTargetTest.java
index c998707a7..a503ce5d8 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/MultipleRenderTargetTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/MultipleRenderTargetTest.java
@@ -145,7 +145,7 @@ public class MultipleRenderTargetTest extends GdxTest {
 		frameBufferBuilder.addColorTextureAttachment(GL30.GL_RGBA8, GL30.GL_RGBA, GL30.GL_UNSIGNED_BYTE);
 		frameBufferBuilder.addColorTextureAttachment(GL30.GL_RGB8, GL30.GL_RGB, GL30.GL_UNSIGNED_BYTE);
 		frameBufferBuilder.addColorTextureAttachment(GL30.GL_RGB8, GL30.GL_RGB, GL30.GL_UNSIGNED_BYTE);
-		frameBufferBuilder.addDepthTextureAttachment(GL30.GL_DEPTH_COMPONENT, GL30.GL_UNSIGNED_SHORT);
+		frameBufferBuilder.addDepthTextureAttachment(GL30.GL_DEPTH_COMPONENT16, GL30.GL_UNSIGNED_SHORT);
 
 		frameBuffer = frameBufferBuilder.build();
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/GL30Texture3DTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/GL30Texture3DTest.java
index 8c169dd02..f0635d4cb 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/GL30Texture3DTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/GL30Texture3DTest.java
@@ -66,7 +66,7 @@ public class GL30Texture3DTest extends GdxTest {
 			+ "in vec2 v_texCoords;\n" //
 			+ "out vec4 fragColor;" //
 			+ "uniform sampler2D u_texture;\n" //
-			+ "uniform sampler3D u_texture3D;\n" //
+			+ "uniform LOWP sampler3D u_texture3D;\n" //
 			+ "uniform float u_time;\n" //
 			+ "void main()\n"//
 			+ "{\n" //
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/InstancedRenderingTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/InstancedRenderingTest.java
index 249b38faa..d856b3700 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/InstancedRenderingTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/InstancedRenderingTest.java
@@ -45,6 +45,9 @@ public class InstancedRenderingTest extends GdxTest {
 		if (Gdx.gl30 == null) {
 			throw new GdxRuntimeException("GLES 3.0 profile required for this test");
 		}
+
+		String ovs = ShaderProgram.prependVertexCode;
+		String ofs = ShaderProgram.prependFragmentCode;
 		ShaderProgram.prependVertexCode = "#version 300 es\n";
 		ShaderProgram.prependFragmentCode = "#version 300 es\n";
 		shader = new ShaderProgram(Gdx.files.internal("data/shaders/instanced-rendering.vert"),
@@ -53,6 +56,9 @@ public class InstancedRenderingTest extends GdxTest {
 			throw new GdxRuntimeException("Shader compile error: " + shader.getLog());
 		}
 
+		ShaderProgram.prependVertexCode = ovs;
+		ShaderProgram.prependFragmentCode = ofs;
+
 		mesh = new Mesh(true, 6, 0, new VertexAttribute(Usage.Position, 2, "a_position"));
 
 		float size = 2f / (float)Math.sqrt(INSTANCE_COUNT) * 0.5f;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/NonPowerOfTwoTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/NonPowerOfTwoTest.java
new file mode 100644
index 000000000..dabd6a3c2
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/NonPowerOfTwoTest.java
@@ -0,0 +1,57 @@
+/*******************************************************************************
+ * Copyright 2022 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tests.gles3;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.tests.utils.GdxTest;
+import com.badlogic.gdx.utils.ScreenUtils;
+
+/** Added during WebGL2 implementation. Non-POT mipmap texture support was added in WebGL2 This test renders a non-POT texture. On
+ * WebGL1 you will receive a non-POT error.
+ * @author JamesTKhan */
+public class NonPowerOfTwoTest extends GdxTest {
+	SpriteBatch batch;
+	Texture texture;
+
+	@Override
+	public void create () {
+		batch = new SpriteBatch();
+		texture = new Texture(Gdx.files.internal("data/heightmap.png"), true);
+		texture.setFilter(Texture.TextureFilter.MipMapLinearNearest, Texture.TextureFilter.Linear);
+	}
+
+	@Override
+	public void render () {
+		ScreenUtils.clear(0, 0, 0, 1);
+		batch.begin();
+		batch.draw(texture, 0, 0, texture.getWidth(), texture.getHeight());
+		batch.end();
+	}
+
+	@Override
+	public void resize (int width, int height) {
+		batch.getProjectionMatrix().setToOrtho2D(0, 0, width, height);
+	}
+
+	@Override
+	public void dispose () {
+		texture.dispose();
+		batch.dispose();
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/UniformBufferObjectsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/UniformBufferObjectsTest.java
new file mode 100644
index 000000000..f8ae392f4
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/gles3/UniformBufferObjectsTest.java
@@ -0,0 +1,153 @@
+/*******************************************************************************
+ * Copyright 2022 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tests.gles3;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL30;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.Interpolation;
+import com.badlogic.gdx.math.RandomXS128;
+import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.scenes.scene2d.ui.Skin;
+import com.badlogic.gdx.scenes.scene2d.ui.Table;
+import com.badlogic.gdx.tests.utils.GdxTest;
+import com.badlogic.gdx.tests.utils.GdxTestConfig;
+import com.badlogic.gdx.utils.BufferUtils;
+import com.badlogic.gdx.utils.ScreenUtils;
+import com.badlogic.gdx.utils.viewport.ScreenViewport;
+
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+/** Added during WebGL2 implementation but also applicable to Desktop. UBO's were added in WebGL2, this test uses a UBO to send
+ * color and position data to the shader using a buffer.
+ * @author JamesTKhan */
+@GdxTestConfig(requireGL30 = true)
+public class UniformBufferObjectsTest extends GdxTest {
+
+	Skin skin;
+	Stage stage;
+	Table table;
+
+	RandomXS128 random;
+	SpriteBatch batch;
+	Texture texture;
+	ShaderProgram shaderProgram;
+	FloatBuffer uniformBuffer = BufferUtils.newFloatBuffer(16);
+
+	float lerpToR = 1.0f;
+	float lerpToG = 1.0f;
+	float lerpToB = 1.0f;
+	float elapsedTime = 0;
+
+	@Override
+	public void create () {
+		random = new RandomXS128();
+		batch = new SpriteBatch();
+		texture = new Texture(Gdx.files.internal("data/badlogic.jpg"));
+		texture.setFilter(Texture.TextureFilter.Linear, Texture.TextureFilter.Linear);
+
+		shaderProgram = new ShaderProgram(Gdx.files.internal("data/shaders/ubo.vert"), Gdx.files.internal("data/shaders/ubo.frag"));
+
+		Gdx.app.log("UniformBufferObjectsTest", shaderProgram.getLog());
+		if (shaderProgram.isCompiled()) {
+			Gdx.app.log("UniformBufferObjectsTest", "Shader compiled");
+			batch.setShader(shaderProgram);
+		}
+
+		IntBuffer tmpBuffer = BufferUtils.newIntBuffer(16);
+
+		// Get the block index for the uniform block
+		int blockIndex = Gdx.gl30.glGetUniformBlockIndex(shaderProgram.getHandle(), "u_bufferBlock");
+
+		// Use the index to get the active block uniform count
+		Gdx.gl30.glGetActiveUniformBlockiv(shaderProgram.getHandle(), blockIndex, GL30.GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS, tmpBuffer);
+		int activeUniforms = tmpBuffer.get(0);
+
+		tmpBuffer.clear();
+		Gdx.gl30.glGenBuffers(1, tmpBuffer);
+		int bufferHandle = tmpBuffer.get(0);
+
+		Gdx.gl.glBindBuffer(GL30.GL_UNIFORM_BUFFER, bufferHandle);
+		Gdx.gl.glBufferData(GL30.GL_UNIFORM_BUFFER, 16, uniformBuffer, GL30.GL_STATIC_DRAW);
+
+		int bindingPoint = 0;
+		// Use the index to bind to a binding point, then bind the buffer
+		Gdx.gl30.glUniformBlockBinding(shaderProgram.getHandle(), blockIndex, bindingPoint);
+		Gdx.gl30.glBindBufferBase(GL30.GL_UNIFORM_BUFFER, bindingPoint, bufferHandle);
+
+		// UI
+		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
+		stage = new Stage(new ScreenViewport());
+		Gdx.input.setInputProcessor(stage);
+
+		table = new Table();
+		table.add(new Label("Block Uniforms (2 is expected):" + activeUniforms, skin)).row();
+		table.add(new Label("Block Index (-1 is invalid): " + blockIndex, skin));
+		stage.addActor(table);
+	}
+
+	@Override
+	public void render () {
+		ScreenUtils.clear(0, 0, 0, 1);
+		elapsedTime += Gdx.graphics.getDeltaTime();
+
+		if (elapsedTime > 2f) {
+			elapsedTime = 0;
+			lerpToR = random.nextFloat();
+			lerpToG = random.nextFloat();
+			lerpToB = random.nextFloat();
+		}
+
+		// Update the colors
+		uniformBuffer.put(0, Interpolation.smooth.apply(uniformBuffer.get(0), lerpToR, Gdx.graphics.getDeltaTime() * 2));// ColorBuffer.R
+		uniformBuffer.put(1, Interpolation.smooth.apply(uniformBuffer.get(1), lerpToG, Gdx.graphics.getDeltaTime() * 2));// ColorBuffer.G
+		uniformBuffer.put(2, Interpolation.smooth.apply(uniformBuffer.get(2), lerpToB, Gdx.graphics.getDeltaTime() * 2));// ColorBuffer.B
+
+		// Update the positions
+		uniformBuffer.put(4, Interpolation.smooth.apply(uniformBuffer.get(4), lerpToR, Gdx.graphics.getDeltaTime() * 2));// Position.X
+		uniformBuffer.put(5, Interpolation.smooth.apply(uniformBuffer.get(5), lerpToG, Gdx.graphics.getDeltaTime() * 2));// Position.Y
+
+		// Update the buffer data store
+		Gdx.gl30.glBufferSubData(GL30.GL_UNIFORM_BUFFER, 0, uniformBuffer.capacity() * 4, uniformBuffer);
+
+		batch.begin();
+		batch.draw(texture, 0, 0, Gdx.graphics.getWidth() / 2f, Gdx.graphics.getHeight() / 2f);
+		batch.end();
+
+		stage.act();
+		stage.draw();
+	}
+
+	@Override
+	public void resize (int width, int height) {
+		stage.getViewport().update(width, height, true);
+		batch.getProjectionMatrix().setToOrtho2D(0, 0, width, height);
+
+		table.setPosition(stage.getViewport().getScreenWidth() * .25f, stage.getViewport().getScreenHeight() * .95f);
+	}
+
+	@Override
+	public void dispose () {
+		texture.dispose();
+		batch.dispose();
+		shaderProgram.dispose();
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index 8a4ef783a..eab293103 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -49,6 +49,8 @@ import com.badlogic.gdx.tests.extensions.FreeTypeMetricsTest;
 import com.badlogic.gdx.tests.extensions.FreeTypePackTest;
 import com.badlogic.gdx.tests.extensions.FreeTypeTest;
 import com.badlogic.gdx.tests.extensions.InternationalFontsTest;
+import com.badlogic.gdx.tests.gles3.NonPowerOfTwoTest;
+import com.badlogic.gdx.tests.gles3.UniformBufferObjectsTest;
 import com.badlogic.gdx.tests.math.CollisionPlaygroundTest;
 import com.badlogic.gdx.tests.math.OctreeTest;
 import com.badlogic.gdx.tests.g3d.Animation3DTest;
@@ -204,6 +206,7 @@ public class GdxTests {
 		NetAPITest.class,
 		NinePatchTest.class,
 		NoncontinuousRenderingTest.class,
+		NonPowerOfTwoTest.class,
 		OctreeTest.class,
 		OnscreenKeyboardTest.class,
 		OrientedBoundingBoxTest.class,
@@ -294,6 +297,7 @@ public class GdxTests {
 		TreeTest.class,
 		UISimpleTest.class,
 		UITest.class,
+		UniformBufferObjectsTest.class,
 		UtfFontTest.class,
 		VBOWithVAOPerformanceTest.class,
 		Vector2dTest.class,
