diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
index f40523dc4..474917a93 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
@@ -353,7 +353,6 @@ public class DefaultShader extends BaseShader {
 	protected int pointLightsLoc;
 	protected int pointLightsColorOffset;
 	protected int pointLightsPositionOffset;
-	protected int pointLightsIntensityOffset;
 	protected int pointLightsSize;
 
 	protected final boolean lighting;
@@ -459,7 +458,6 @@ public class DefaultShader extends BaseShader {
 		pointLightsLoc 				= loc(u_pointLights0color);
 		pointLightsColorOffset 		= loc(u_pointLights0color) - pointLightsLoc;
 		pointLightsPositionOffset 	= loc(u_pointLights0position) - pointLightsLoc;
-		pointLightsIntensityOffset = loc(u_pointLights0intensity) - pointLightsLoc;
 		pointLightsSize 				= loc(u_pointLights1color) - pointLightsLoc;
 		if (pointLightsSize < 0)
 			pointLightsSize = 0;
diff --git a/tests/gdx-tests-android/assets/data/g3d/shaders/lighttest.fragment.glsl b/tests/gdx-tests-android/assets/data/g3d/shaders/lighttest.fragment.glsl
deleted file mode 100644
index d7d223ba4..000000000
--- a/tests/gdx-tests-android/assets/data/g3d/shaders/lighttest.fragment.glsl
+++ /dev/null
@@ -1,179 +0,0 @@
-#ifdef GL_ES 
-#define LOWP lowp
-#define MED mediump
-#define HIGH highp
-precision mediump float;
-#else
-#define MED
-#define LOWP
-#define HIGH
-#endif
-
-#if defined(specularTextureFlag) || defined(specularColorFlag)
-#define specularFlag
-#endif
-
-#ifdef normalFlag
-varying vec3 v_normal;
-#endif //normalFlag
-
-#if defined(colorFlag)
-varying vec4 v_color;
-#endif
-
-#ifdef blendedFlag
-varying float v_opacity;
-#ifdef alphaTestFlag
-varying float v_alphaTest;
-#endif //alphaTestFlag
-#endif //blendedFlag
-
-#if defined(diffuseTextureFlag) || defined(specularTextureFlag)
-#define textureFlag
-varying MED vec2 v_texCoords0;
-#endif
-
-#ifdef diffuseColorFlag
-uniform vec4 u_diffuseColor;
-#endif
-
-#ifdef diffuseTextureFlag
-uniform sampler2D u_diffuseTexture;
-#endif
-
-#ifdef specularColorFlag
-uniform vec4 u_specularColor;
-#endif
-
-#ifdef specularTextureFlag
-uniform sampler2D u_specularTexture;
-#endif
-
-#ifdef normalTextureFlag
-uniform sampler2D u_normalTexture;
-#endif
-
-#ifdef lightingFlag
-varying vec3 v_lightDiffuse;
-
-#if	defined(ambientLightFlag) || defined(ambientCubemapFlag) || defined(sphericalHarmonicsFlag)
-#define ambientFlag
-#endif //ambientFlag
-
-#ifdef specularFlag
-varying vec3 v_lightSpecular;
-#endif //specularFlag
-
-#ifdef shadowMapFlag
-uniform sampler2D u_shadowTexture;
-uniform float u_shadowPCFOffset;
-varying vec3 v_shadowMapUv;
-#define separateAmbientFlag
-
-float getShadowness(vec2 offset)
-{
-    const vec4 bitShifts = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0);
-    return step(v_shadowMapUv.z, dot(texture2D(u_shadowTexture, v_shadowMapUv.xy + offset), bitShifts));//+(1.0/255.0));	
-}
-
-float getShadow() 
-{
-	return (//getShadowness(vec2(0,0)) + 
-			getShadowness(vec2(u_shadowPCFOffset, u_shadowPCFOffset)) +
-			getShadowness(vec2(-u_shadowPCFOffset, u_shadowPCFOffset)) +
-			getShadowness(vec2(u_shadowPCFOffset, -u_shadowPCFOffset)) +
-			getShadowness(vec2(-u_shadowPCFOffset, -u_shadowPCFOffset))) * 0.20;
-}
-#endif //shadowMapFlag
-
-#if defined(ambientFlag) && defined(separateAmbientFlag)
-varying vec3 v_ambientLight;
-#endif //separateAmbientFlag
-
-#endif //lightingFlag
-
-#ifdef fogFlag
-uniform vec4 u_fogColor;
-varying float v_fog;
-#endif // fogFlag
-
-void main() {
-	#if defined(normalFlag) 
-		vec3 normal = v_normal;
-	#endif // normalFlag
-		
-	#if defined(diffuseTextureFlag) && defined(diffuseColorFlag) && defined(colorFlag)
-		vec4 diffuse = texture2D(u_diffuseTexture, v_texCoords0) * u_diffuseColor * v_color;
-	#elif defined(diffuseTextureFlag) && defined(diffuseColorFlag)
-		vec4 diffuse = texture2D(u_diffuseTexture, v_texCoords0) * u_diffuseColor;
-	#elif defined(diffuseTextureFlag) && defined(colorFlag)
-		vec4 diffuse = texture2D(u_diffuseTexture, v_texCoords0) * v_color;
-	#elif defined(diffuseTextureFlag)
-		vec4 diffuse = texture2D(u_diffuseTexture, v_texCoords0);
-	#elif defined(diffuseColorFlag) && defined(colorFlag)
-		vec4 diffuse = u_diffuseColor * v_color;
-	#elif defined(diffuseColorFlag)
-		vec4 diffuse = u_diffuseColor;
-	#elif defined(colorFlag)
-		vec4 diffuse = v_color;
-	#else
-		vec4 diffuse = vec4(1.0);
-	#endif
-
-	#if (!defined(lightingFlag))  
-		gl_FragColor.rgb = diffuse.rgb;
-	#elif (!defined(specularFlag))
-		#if defined(ambientFlag) && defined(separateAmbientFlag)
-			#ifdef shadowMapFlag
-				gl_FragColor.rgb = (diffuse.rgb * (v_ambientLight + getShadow() * v_lightDiffuse));
-				//gl_FragColor.rgb = texture2D(u_shadowTexture, v_shadowMapUv.xy);
-			#else
-				gl_FragColor.rgb = (diffuse.rgb * (v_ambientLight + v_lightDiffuse));
-			#endif //shadowMapFlag
-		#else
-			#ifdef shadowMapFlag
-				gl_FragColor.rgb = getShadow() * (diffuse.rgb * v_lightDiffuse);
-			#else
-				gl_FragColor.rgb = (diffuse.rgb * v_lightDiffuse);
-			#endif //shadowMapFlag
-		#endif
-	#else
-		#if defined(specularTextureFlag) && defined(specularColorFlag)
-			vec3 specular = texture2D(u_specularTexture, v_texCoords0).rgb * u_specularColor.rgb * v_lightSpecular;
-		#elif defined(specularTextureFlag)
-			vec3 specular = texture2D(u_specularTexture, v_texCoords0).rgb * v_lightSpecular;
-		#elif defined(specularColorFlag)
-			vec3 specular = u_specularColor.rgb * v_lightSpecular;
-		#else
-			vec3 specular = v_lightSpecular;
-		#endif
-			
-		#if defined(ambientFlag) && defined(separateAmbientFlag)
-			#ifdef shadowMapFlag
-			gl_FragColor.rgb = (diffuse.rgb * (getShadow() * v_lightDiffuse + v_ambientLight)) + specular;
-				//gl_FragColor.rgb = texture2D(u_shadowTexture, v_shadowMapUv.xy);
-			#else
-				gl_FragColor.rgb = (diffuse.rgb * (v_lightDiffuse + v_ambientLight)) + specular;
-			#endif //shadowMapFlag
-		#else
-			#ifdef shadowMapFlag
-				gl_FragColor.rgb = getShadow() * ((diffuse.rgb * v_lightDiffuse) + specular);
-			#else
-				gl_FragColor.rgb = (diffuse.rgb * v_lightDiffuse) + specular;
-			#endif //shadowMapFlag
-		#endif
-	#endif //lightingFlag
-
-	#ifdef fogFlag
-    	gl_FragColor.rgb = mix(gl_FragColor.rgb, u_fogColor.rgb, v_fog);
-    #endif // end fogFlag
-
-	#ifdef blendedFlag
-		gl_FragColor.a = diffuse.a * v_opacity;
-		#ifdef alphaTestFlag
-			if (gl_FragColor.a <= v_alphaTest)
-				discard;
-		#endif
-	#endif
-
-}
diff --git a/tests/gdx-tests-android/assets/data/g3d/shaders/lighttest.vertex.glsl b/tests/gdx-tests-android/assets/data/g3d/shaders/lighttest.vertex.glsl
deleted file mode 100644
index 86142a95a..000000000
--- a/tests/gdx-tests-android/assets/data/g3d/shaders/lighttest.vertex.glsl
+++ /dev/null
@@ -1,326 +0,0 @@
-#if defined(diffuseTextureFlag) || defined(specularTextureFlag)
-#define textureFlag
-#endif
-
-#if defined(specularTextureFlag) || defined(specularColorFlag)
-#define specularFlag
-#endif
-
-#if defined(specularFlag) || defined(fogFlag)
-#define cameraPositionFlag
-#endif
-
-attribute vec3 a_position;
-uniform mat4 u_projViewTrans;
-
-#if defined(colorFlag)
-varying vec4 v_color;
-attribute vec4 a_color;
-#endif // colorFlag
-
-#ifdef normalFlag
-attribute vec3 a_normal;
-uniform mat3 u_normalMatrix;
-varying vec3 v_normal;
-#endif // normalFlag
-
-#ifdef textureFlag
-attribute vec2 a_texCoord0;
-varying vec2 v_texCoords0;
-#endif // textureFlag
-
-#ifdef boneWeight0Flag
-#define boneWeightsFlag
-attribute vec2 a_boneWeight0;
-#endif //boneWeight0Flag
-
-#ifdef boneWeight1Flag
-#ifndef boneWeightsFlag
-#define boneWeightsFlag
-#endif
-attribute vec2 a_boneWeight1;
-#endif //boneWeight1Flag
-
-#ifdef boneWeight2Flag
-#ifndef boneWeightsFlag
-#define boneWeightsFlag
-#endif
-attribute vec2 a_boneWeight2;
-#endif //boneWeight2Flag
-
-#ifdef boneWeight3Flag
-#ifndef boneWeightsFlag
-#define boneWeightsFlag
-#endif
-attribute vec2 a_boneWeight3;
-#endif //boneWeight3Flag
-
-#ifdef boneWeight4Flag
-#ifndef boneWeightsFlag
-#define boneWeightsFlag
-#endif
-attribute vec2 a_boneWeight4;
-#endif //boneWeight4Flag
-
-#ifdef boneWeight5Flag
-#ifndef boneWeightsFlag
-#define boneWeightsFlag
-#endif
-attribute vec2 a_boneWeight5;
-#endif //boneWeight5Flag
-
-#ifdef boneWeight6Flag
-#ifndef boneWeightsFlag
-#define boneWeightsFlag
-#endif
-attribute vec2 a_boneWeight6;
-#endif //boneWeight6Flag
-
-#ifdef boneWeight7Flag
-#ifndef boneWeightsFlag
-#define boneWeightsFlag
-#endif
-attribute vec2 a_boneWeight7;
-#endif //boneWeight7Flag
-
-#if defined(numBones) && defined(boneWeightsFlag)
-#if (numBones > 0) 
-#define skinningFlag
-#endif
-#endif
-
-uniform mat4 u_worldTrans;
-
-#if defined(numBones)
-#if numBones > 0
-uniform mat4 u_bones[numBones];
-#endif //numBones
-#endif
-
-#ifdef shininessFlag
-uniform float u_shininess;
-#else
-const float u_shininess = 20.0;
-#endif // shininessFlag
-
-#ifdef blendedFlag
-uniform float u_opacity;
-varying float v_opacity;
-
-#ifdef alphaTestFlag
-uniform float u_alphaTest;
-varying float v_alphaTest;
-#endif //alphaTestFlag
-#endif // blendedFlag
-
-#ifdef lightingFlag
-varying vec3 v_lightDiffuse;
-
-#ifdef ambientLightFlag
-uniform vec3 u_ambientLight;
-#endif // ambientLightFlag
-
-#ifdef ambientCubemapFlag
-uniform vec3 u_ambientCubemap[6];
-#endif // ambientCubemapFlag 
-
-#ifdef sphericalHarmonicsFlag
-uniform vec3 u_sphericalHarmonics[9];
-#endif //sphericalHarmonicsFlag
-
-#ifdef specularFlag
-varying vec3 v_lightSpecular;
-#endif // specularFlag
-
-#ifdef cameraPositionFlag
-uniform vec4 u_cameraPosition;
-#endif // cameraPositionFlag
-
-#ifdef fogFlag
-varying float v_fog;
-#endif // fogFlag
-
-
-#if defined(numDirectionalLights) && (numDirectionalLights > 0)
-struct DirectionalLight
-{
-	vec3 color;
-	vec3 direction;
-};
-uniform DirectionalLight u_dirLights[numDirectionalLights];
-#endif // numDirectionalLights
-
-#if defined(numPointLights) && (numPointLights > 0)
-struct PointLight
-{
-	vec4 color;
-	vec4 position;
-	//float intensity;
-};
-uniform PointLight u_pointLights[numPointLights];
-//uniform vec3 u_pointLightPosition;
-//uniform vec3 u_pointLightColor;
-uniform float u_pointLightIntensity;
-#endif // numPointLights
-
-#if	defined(ambientLightFlag) || defined(ambientCubemapFlag) || defined(sphericalHarmonicsFlag)
-#define ambientFlag
-#endif //ambientFlag
-
-#ifdef shadowMapFlag
-uniform mat4 u_shadowMapProjViewTrans;
-varying vec3 v_shadowMapUv;
-#define separateAmbientFlag
-#endif //shadowMapFlag
-
-#if defined(ambientFlag) && defined(separateAmbientFlag)
-varying vec3 v_ambientLight;
-#endif //separateAmbientFlag
-
-#endif // lightingFlag
-
-void main() {
-	#ifdef textureFlag
-		v_texCoords0 = a_texCoord0;
-	#endif // textureFlag
-	
-	#if defined(colorFlag)
-		v_color = a_color;
-	#endif // colorFlag
-		
-	#ifdef blendedFlag
-		v_opacity = u_opacity;
-		#ifdef alphaTestFlag
-			v_alphaTest = u_alphaTest;
-		#endif //alphaTestFlag
-	#endif // blendedFlag
-	
-	#ifdef skinningFlag
-		mat4 skinning = mat4(0.0);
-		#ifdef boneWeight0Flag
-			skinning += (a_boneWeight0.y) * u_bones[int(a_boneWeight0.x)];
-		#endif //boneWeight0Flag
-		#ifdef boneWeight1Flag				
-			skinning += (a_boneWeight1.y) * u_bones[int(a_boneWeight1.x)];
-		#endif //boneWeight1Flag
-		#ifdef boneWeight2Flag		
-			skinning += (a_boneWeight2.y) * u_bones[int(a_boneWeight2.x)];
-		#endif //boneWeight2Flag
-		#ifdef boneWeight3Flag
-			skinning += (a_boneWeight3.y) * u_bones[int(a_boneWeight3.x)];
-		#endif //boneWeight3Flag
-		#ifdef boneWeight4Flag
-			skinning += (a_boneWeight4.y) * u_bones[int(a_boneWeight4.x)];
-		#endif //boneWeight4Flag
-		#ifdef boneWeight5Flag
-			skinning += (a_boneWeight5.y) * u_bones[int(a_boneWeight5.x)];
-		#endif //boneWeight5Flag
-		#ifdef boneWeight6Flag
-			skinning += (a_boneWeight6.y) * u_bones[int(a_boneWeight6.x)];
-		#endif //boneWeight6Flag
-		#ifdef boneWeight7Flag
-			skinning += (a_boneWeight7.y) * u_bones[int(a_boneWeight7.x)];
-		#endif //boneWeight7Flag
-	#endif //skinningFlag
-
-	#ifdef skinningFlag
-		vec4 pos = u_worldTrans * skinning * vec4(a_position, 1.0);
-	#else
-		vec4 pos = u_worldTrans * vec4(a_position, 1.0);
-	#endif
-		
-	gl_Position = u_projViewTrans * pos;
-		
-	#ifdef shadowMapFlag
-		vec4 spos = u_shadowMapProjViewTrans * pos;
-		v_shadowMapUv.xy = (spos.xy / spos.w) * 0.5 + 0.5;
-		v_shadowMapUv.z = min(spos.z * 0.5 + 0.5, 0.998);
-	#endif //shadowMapFlag
-	
-	#if defined(normalFlag)
-		#if defined(skinningFlag)
-			vec3 normal = normalize((u_worldTrans * skinning * vec4(a_normal, 0.0)).xyz);
-		#else
-			vec3 normal = normalize(u_normalMatrix * a_normal);
-		#endif
-		v_normal = normal;
-	#endif // normalFlag
-
-    #ifdef fogFlag
-        vec3 flen = u_cameraPosition.xyz - pos.xyz;
-        float fog = dot(flen, flen) * u_cameraPosition.w;
-        v_fog = min(fog, 1.0);
-    #endif
-
-	#ifdef lightingFlag
-		#if	defined(ambientLightFlag)
-        	vec3 ambientLight = u_ambientLight;
-		#elif defined(ambientFlag)
-        	vec3 ambientLight = vec3(0.0);
-		#endif
-			
-		#ifdef ambientCubemapFlag 		
-			vec3 squaredNormal = normal * normal;
-			vec3 isPositive  = step(0.0, normal);
-			ambientLight += squaredNormal.x * mix(u_ambientCubemap[0], u_ambientCubemap[1], isPositive.x) +
-					squaredNormal.y * mix(u_ambientCubemap[2], u_ambientCubemap[3], isPositive.y) +
-					squaredNormal.z * mix(u_ambientCubemap[4], u_ambientCubemap[5], isPositive.z);
-		#endif // ambientCubemapFlag
-
-		#ifdef sphericalHarmonicsFlag
-			ambientLight += u_sphericalHarmonics[0];
-			ambientLight += u_sphericalHarmonics[1] * normal.x;
-			ambientLight += u_sphericalHarmonics[2] * normal.y;
-			ambientLight += u_sphericalHarmonics[3] * normal.z;
-			ambientLight += u_sphericalHarmonics[4] * (normal.x * normal.z);
-			ambientLight += u_sphericalHarmonics[5] * (normal.z * normal.y);
-			ambientLight += u_sphericalHarmonics[6] * (normal.y * normal.x);
-			ambientLight += u_sphericalHarmonics[7] * (3.0 * normal.z * normal.z - 1.0);
-			ambientLight += u_sphericalHarmonics[8] * (normal.x * normal.x - normal.y * normal.y);			
-		#endif // sphericalHarmonicsFlag
-
-		#ifdef ambientFlag
-			#ifdef separateAmbientFlag
-				v_ambientLight = ambientLight;
-				v_lightDiffuse = vec3(0.0);
-			#else
-				v_lightDiffuse = ambientLight;
-			#endif //separateAmbientFlag
-		#else
-	        v_lightDiffuse = vec3(0.0);
-		#endif //ambientFlag
-
-			
-		#ifdef specularFlag
-			v_lightSpecular = vec3(0.0);
-			vec3 viewVec = normalize(u_cameraPosition.xyz - pos.xyz);
-		#endif // specularFlag
-			
-		#if defined(numDirectionalLights) && (numDirectionalLights > 0) && defined(normalFlag)
-			for (int i = 0; i < numDirectionalLights; i++) {
-				vec3 lightDir = -u_dirLights[i].direction;
-				float NdotL = clamp(dot(normal, lightDir), 0.0, 1.0);
-				v_lightDiffuse += u_dirLights[i].color * NdotL;
-				#ifdef specularFlag
-					float halfDotView = clamp(dot(normal, normalize(lightDir + viewVec)), 0.0, 2.0);
-					v_lightSpecular += u_dirLights[i].color * clamp(NdotL * pow(halfDotView, u_shininess), 0.0, 1.0);
-				#endif // specularFlag
-			}
-		#endif // numDirectionalLights
-
-		#if defined(numPointLights) && (numPointLights > 0) && defined(normalFlag)
-			for (int i = 0; i < numPointLights; i++) {
-				vec3 lightDir = u_pointLights[i].position.xyz - pos.xyz;
-				float dist2 = dot(lightDir, lightDir);
-				lightDir *= inversesqrt(dist2);
-				float NdotL = clamp(dot(normal, lightDir), 0.0, 2.0);
-				float falloff = clamp(u_pointLightIntensity / (1.0 + dist2), 0.0, 2.0); // FIXME mul intensity on cpu
-				v_lightDiffuse += u_pointLights[i].color.xyz * (NdotL * falloff);
-				#ifdef specularFlag
-					float halfDotView = clamp(dot(normal, normalize(lightDir + viewVec)), 0.0, 2.0);
-					v_lightSpecular += u_pointLights[i].color * clamp(NdotL * pow(halfDotView, u_shininess) * falloff, 0.0, 2.0);
-				#endif // specularFlag
-			}
-		#endif // numPointLights
-	#endif // lightingFlag
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/LightsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/LightsTest.java
index 0100ec322..aae115d86 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/LightsTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/LightsTest.java
@@ -1,213 +1,76 @@
 package com.badlogic.gdx.tests.g3d;
 
 import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.InputMultiplexer;
-import com.badlogic.gdx.graphics.Camera;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.PerspectiveCamera;
-import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.Attributes;
-import com.badlogic.gdx.graphics.g3d.Environment;
 import com.badlogic.gdx.graphics.g3d.Material;
 import com.badlogic.gdx.graphics.g3d.Model;
 import com.badlogic.gdx.graphics.g3d.ModelBatch;
 import com.badlogic.gdx.graphics.g3d.ModelInstance;
 import com.badlogic.gdx.graphics.g3d.Renderable;
-import com.badlogic.gdx.graphics.g3d.Shader;
 import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
 import com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;
 import com.badlogic.gdx.graphics.g3d.environment.PointLight;
-import com.badlogic.gdx.graphics.g3d.shaders.BaseShader;
-import com.badlogic.gdx.graphics.g3d.shaders.DefaultShader;
-import com.badlogic.gdx.graphics.g3d.shaders.BaseShader.Uniform;
-import com.badlogic.gdx.graphics.g3d.utils.AnimationController;
-import com.badlogic.gdx.graphics.g3d.utils.CameraInputController;
-import com.badlogic.gdx.graphics.g3d.utils.MeshPartBuilder;
 import com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;
-import com.badlogic.gdx.graphics.g3d.utils.RenderContext;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.math.collision.BoundingBox;
-import com.badlogic.gdx.tests.utils.GdxTest;
 import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.ObjectMap;
 
-public class LightsTest extends GdxTest {
-	PerspectiveCamera cam;
-	CameraInputController inputController;
-	ModelBatch modelBatch;
-	Model model;
-	Renderable renderable;
-	Environment environment;
+public class LightsTest extends ModelTest {
+	DirectionalLight dirLight;
 	PointLight pointLight;
-	Vector3 tmpV = new Vector3();
-	Shader shader;
+	Model lightModel;
+	Renderable pLight;
+	Vector3 center = new Vector3(), transformedCenter = new Vector3(), tmpV = new Vector3();
+	float radius = 1f;
 	
 	@Override
 	public void create () {
-		modelBatch = new ModelBatch();
-		environment = new Environment();
+		super.create();
+		environment.clear();
 		environment.set(new ColorAttribute(ColorAttribute.AmbientLight, 0.2f, 0.2f, 0.2f, 1.0f));
+		environment.add(dirLight = new DirectionalLight().set(0.8f, 0.2f, 0.2f, -1f, -2f, -0.5f));
 		environment.add(pointLight = new PointLight().set(0.2f, 0.8f, 0.2f, 0f, 0f, 0f, 100f));
 		
-		cam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-		cam.position.set(0f, 0f, 5f);
-		cam.lookAt(0,0,0);
-		cam.near = 1f;
-		cam.far = 300f;
-		cam.update();		
-		
-		ModelBuilder modelBuilder = new ModelBuilder();
-		model = modelBuilder.createSphere(2f, 3f, 2f, 10, 10, GL10.GL_TRIANGLES, new Material(ColorAttribute.createDiffuse(1, 1, 1, 1)), Usage.Position | Usage.Normal);
-		renderable = model.nodes.get(0).parts.get(0).setRenderable(new Renderable());
-		renderable.environment = environment;
-		if (true) {
-			DefaultShader.Config config = new DefaultShader.Config();
-			config.numPointLights = 2;
-			renderable.shader = shader = new DefaultShader(renderable, config);
-		} else {
-			DefaultShader.Config config = new DefaultShader.Config(Gdx.files.internal("data/g3d/shaders/lighttest.vertex.glsl").readString(), Gdx.files.internal("data/g3d/shaders/lighttest.fragment.glsl").readString());
-			config.numPointLights = 2;
-			renderable.shader = shader = new DefaultShader(renderable, config) {
-				protected final int u_pointLightPosition	= register(new Uniform("u_pointLightPosition"), new Setter() {
-					@Override public boolean isGlobal (BaseShader shader, int inputID) { return false; }
-					@Override public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
-						shader.set(inputID, pointLight.position);
-					}
-				});
-				protected final int u_pointLightIntensity	= register(new Uniform("u_pointLightIntensity"), new Setter() {
-					@Override public boolean isGlobal (BaseShader shader, int inputID) { return false; }
-					@Override public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
-						shader.set(inputID, pointLight.intensity);
-					}
-				});
-				protected final int u_pointLightColor		= register(new Uniform("u_pointLightColor"), new Setter() {
-					@Override public boolean isGlobal (BaseShader shader, int inputID) { return false; }
-					@Override public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
-						shader.set(inputID, pointLight.color.g, pointLight.color.r, pointLight.color.b);
-					}
-				});
-				
-				@Override
-				public void init () {
-					super.init();
-	//				if (!has(u_pointLightPosition))
-	//					Gdx.app.error("LightsTest", "No uniform called: u_pointLightPosition");
-	//				if (!has(u_pointLightColor))
-	//					Gdx.app.error("LightsTest", "No uniform called: u_pointLightColor");
-					if (!has(u_pointLightIntensity))
-						Gdx.app.error("LightsTest", "No uniform called: u_pointLightIntensity");
-					Gdx.app.log("LightsTest", "Shader log: "+program.getLog());
-					Gdx.app.log("LightsTest", "pointLightsLoc = "+pointLightsLoc);
-					Gdx.app.log("LightsTest", "pointLightsColorOffset = "+pointLightsColorOffset);
-					Gdx.app.log("LightsTest", "pointLightsPositionOffset = "+pointLightsPositionOffset);
-					Gdx.app.log("LightsTest", "pointLightsIntensityOffset = "+pointLightsIntensityOffset);
-					Gdx.app.log("LightsTest", "pointLightsSize = "+pointLightsSize);
-					for (String uniform : program.getUniforms())
-						Gdx.app.log("LightsTest", "Uniform: name="+uniform+", size="+program.getUniformSize(uniform)+", type="+program.getUniformType(uniform)+", location="+program.getUniformLocation(uniform));
-				}
-				
-				boolean lightsSet;
-				@Override
-				public void begin (Camera camera, RenderContext context) {
-					lightsSet = false;
-					super.begin(camera, context);
-				}
-				
-				@Override
-				protected final void bindLights(final Renderable renderable) {
-					final Environment lights = renderable.environment;
-					final Array<DirectionalLight> dirs = lights.directionalLights; 
-					final Array<PointLight> points = lights.pointLights;
-					
-					if (dirLightsLoc >= 0) {
-						for (int i = 0; i < directionalLights.length; i++) {
-							if (dirs == null || i >= dirs.size) {
-								if (lightsSet && directionalLights[i].color.r == 0f && directionalLights[i].color.g == 0f && directionalLights[i].color.b == 0f)
-									continue;
-								directionalLights[i].color.set(0,0,0,1);
-							} else if (lightsSet && directionalLights[i].equals(dirs.get(i)))
-								continue;
-							else
-								directionalLights[i].set(dirs.get(i));
-							
-							int idx = dirLightsLoc + i * dirLightsSize; 
-							program.setUniformf(idx+dirLightsColorOffset, directionalLights[i].color.r, directionalLights[i].color.g, directionalLights[i].color.b);
-							program.setUniformf(idx+dirLightsDirectionOffset, directionalLights[i].direction);
-							if (dirLightsSize <= 0)
-								break;
-						}
-					}
-					
-					if (pointLightsLoc >= 0) {
-						for (int i = 0; i < pointLights.length; i++) {
-							if (points == null || i >= points.size) {
-								if (lightsSet && pointLights[i].intensity == 0f)
-									continue;
-								pointLights[i].intensity = 0f;
-							} else if (lightsSet && pointLights[i].equals(points.get(i)))
-								continue;
-							else
-								pointLights[i].set(points.get(i));
-
-							int idx = pointLightsLoc + i * pointLightsSize;
-							program.setUniformf(idx+pointLightsColorOffset, pointLights[i].color.r, pointLights[i].color.g, pointLights[i].color.b, 1f);
-							program.setUniformf(idx+pointLightsPositionOffset, pointLights[i].position.x, pointLights[i].position.y, pointLights[i].position.z, 0f);
-							if (pointLightsIntensityOffset >= 0)
-								program.setUniformf(idx+pointLightsIntensityOffset, pointLights[i].intensity);
-							if (pointLightsSize <= 0)
-								break;
-						}
-					}
-
-					if (lights.has(ColorAttribute.Fog)) {
-						set(u_fogColor, ((ColorAttribute)lights.get(ColorAttribute.Fog)).color);
-					}
-					
-					if (lights.shadowMap != null) {
-						set(u_shadowMapProjViewTrans, lights.shadowMap.getProjViewTrans());
-						set(u_shadowTexture, lights.shadowMap.getDepthMap());
-						set(u_shadowPCFOffset, 1.f / (float)(2f * lights.shadowMap.getDepthMap().texture.getWidth()));
-					}
-					
-					lightsSet = true;
-				}
-			};
-		}
-		shader.init();
-      pointLight.position.set(0,3f,0);
-      pointLight.intensity = 9f;
-		
-		Gdx.input.setInputProcessor(inputController = new CameraInputController(cam));
+		ModelBuilder mb = new ModelBuilder();
+		lightModel = mb.createSphere(1, 1, 1, 10, 10, new Material(ColorAttribute.createDiffuse(1, 1, 1, 1)), Usage.Position);
+		lightModel.nodes.get(0).parts.get(0).setRenderable(pLight = new Renderable());
+	}
+	
+	@Override
+	protected void onLoaded () {
+		super.onLoaded();
+		BoundingBox bounds = instances.get(0).calculateBoundingBox(new BoundingBox());
+		center.set(bounds.getCenter());
+		radius = bounds.getDimensions().len() * .5f;
+		pointLight.position.set(0,radius,0).add(transformedCenter.set(center).mul(transform));
+		pointLight.intensity = radius * radius;
+		((ColorAttribute)pLight.material.get(ColorAttribute.Diffuse)).color.set(pointLight.color);
+		final float s = 0.2f * radius;
+		pLight.worldTransform.setToScaling(s, s, s);
 	}
 
 	@Override
-	public void render () {
-      final float delta = Gdx.graphics.getDeltaTime();
-      
-      pointLight.position.rotate(Vector3.X, delta * 50f);
-      pointLight.position.rotate(Vector3.Y, delta * 13f);
-      pointLight.position.rotate(Vector3.Z, delta * 3f);
+	protected void render (ModelBatch batch, Array<ModelInstance> instances) {
+		final float delta = Gdx.graphics.getDeltaTime();
+		dirLight.direction.rotate(Vector3.X, delta * 45f);
+		dirLight.direction.rotate(Vector3.Y, delta * 25f);
+		dirLight.direction.rotate(Vector3.Z, delta * 33f);
 		
-		inputController.update();
+		pointLight.position.sub(transformedCenter);
+		pointLight.position.rotate(Vector3.X, delta * 50f);
+		pointLight.position.rotate(Vector3.Y, delta * 13f);
+		pointLight.position.rotate(Vector3.Z, delta * 3f);
+		pointLight.position.add(transformedCenter.set(center).mul(transform));
 		
-		Gdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-
-		modelBatch.begin(cam);
-		modelBatch.render(renderable);
-		modelBatch.end();
+		pLight.worldTransform.setTranslation(pointLight.position);
+		batch.render(pLight);
+		
+		super.render(batch, instances);
 	}
 	
 	@Override
 	public void dispose () {
-		modelBatch.dispose();
-		model.dispose();
-		shader.dispose();
-	}
-	
-	public boolean needsGL20 () {
-		return true;
+		lightModel.dispose();
+		super.dispose();
 	}
-}
+}
\ No newline at end of file
