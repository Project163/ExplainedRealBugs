diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
index 9e321de76..5e793bfa3 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
@@ -98,7 +98,7 @@ public class DefaultShader extends BaseShader {
 		public final static Uniform emissiveColor = new Uniform("u_emissiveColor", ColorAttribute.Emissive);
 		public final static Uniform reflectionColor = new Uniform("u_reflectionColor", ColorAttribute.Reflection);
 		public final static Uniform normalTexture = new Uniform("u_normalTexture", TextureAttribute.Normal);
-		public final static Uniform alphaTest = new Uniform("u_alphaTest", FloatAttribute.AlphaTest);
+		public final static Uniform alphaTest = new Uniform("u_alphaTest");
 
 		public final static Uniform ambientCube = new Uniform("u_ambientCubemap");
 		public final static Uniform dirLights = new Uniform("u_dirLights");
@@ -486,7 +486,8 @@ public class DefaultShader extends BaseShader {
 
 	/** The renderable used to create this shader, invalid after the call to init */
 	private Renderable renderable;
-	private long materialMask;
+	/** The material attributes that this shader supports */
+	protected final long materialMask;
 	private long vertexMask;
 	protected final Config config;
 	/** Material attributes which are not required but always supported. */
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DepthShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DepthShader.java
index 461326db9..26bb47caf 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DepthShader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DepthShader.java
@@ -22,12 +22,16 @@ import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.graphics.g3d.Renderable;
+import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
 import com.badlogic.gdx.graphics.g3d.utils.RenderContext;
 import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 
 public class DepthShader extends DefaultShader {
 	public static class Config extends DefaultShader.Config {
 		public boolean depthBufferOnly = false;
+		public float defaultAlphaTest = 0.5f;
 
 		public Config () {
 			super();
@@ -56,28 +60,14 @@ public class DepthShader extends DefaultShader {
 	}
 
 	public static String createPrefix (final Renderable renderable, final Config config) {
-		String prefix = "";
-		final long mask = renderable.material.getMask();
-		final long attributes = renderable.mesh.getVertexAttributes().getMask();
-		if ((attributes & Usage.BoneWeight) == Usage.BoneWeight) {
-			final int n = renderable.mesh.getVertexAttributes().size();
-			for (int i = 0; i < n; i++) {
-				final VertexAttribute attr = renderable.mesh.getVertexAttributes().get(i);
-				if (attr.usage == Usage.BoneWeight) prefix += "#define boneWeight" + attr.unit + "Flag\n";
-			}
-		}
-		// FIXME Add transparent texture support
-// if ((mask & BlendingAttribute.Type) == BlendingAttribute.Type)
-// prefix += "#define "+BlendingAttribute.Alias+"Flag\n";
-// if ((mask & TextureAttribute.Diffuse) == TextureAttribute.Diffuse)
-// prefix += "#define "+TextureAttribute.DiffuseAlias+"Flag\n";
-		if (renderable.bones != null && config.numBones > 0) prefix += "#define numBones " + config.numBones + "\n";
+		String prefix = DefaultShader.createPrefix(renderable, config);
 		if (!config.depthBufferOnly) prefix += "#define PackedDepthFlag\n";
 		return prefix;
 	}
 
 	public final int numBones;
 	public final int weights;
+	private final FloatAttribute alphaTestAttribute;
 
 	public DepthShader (final Renderable renderable) {
 		this(renderable, new Config());
@@ -107,6 +97,7 @@ public class DepthShader extends DefaultShader {
 			if (attr.usage == Usage.BoneWeight) w |= (1 << attr.unit);
 		}
 		weights = w;
+		alphaTestAttribute = new FloatAttribute(FloatAttribute.AlphaTest, config.defaultAlphaTest);
 	}
 
 	@Override
@@ -124,6 +115,12 @@ public class DepthShader extends DefaultShader {
 
 	@Override
 	public boolean canRender (Renderable renderable) {
+		if (renderable.material.has(BlendingAttribute.Type)) {
+			if ((materialMask & BlendingAttribute.Type) != BlendingAttribute.Type)
+				return false;
+			if (renderable.material.has(TextureAttribute.Diffuse) != ((materialMask & TextureAttribute.Diffuse) == TextureAttribute.Diffuse))
+				return false;
+		}
 		final boolean skinned = ((renderable.mesh.getVertexAttributes().getMask() & Usage.BoneWeight) == Usage.BoneWeight);
 		if (skinned != (numBones > 0)) return false;
 		if (!skinned) return true;
@@ -135,4 +132,21 @@ public class DepthShader extends DefaultShader {
 		}
 		return w == weights;
 	}
+	
+	@Override
+	public void render (final Renderable renderable) {
+		if (renderable.material.has(BlendingAttribute.Type)) {
+			final BlendingAttribute blending = (BlendingAttribute)renderable.material.get(BlendingAttribute.Type);
+			renderable.material.remove(BlendingAttribute.Type);
+			final boolean hasAlphaTest = renderable.material.has(FloatAttribute.AlphaTest);
+			if (!hasAlphaTest)
+				renderable.material.set(alphaTestAttribute);
+			if (blending.opacity >= ((FloatAttribute)renderable.material.get(FloatAttribute.AlphaTest)).value)
+				super.render(renderable);
+			if (!hasAlphaTest)
+				renderable.material.remove(FloatAttribute.AlphaTest);
+			renderable.material.set(blending);
+		} else
+			super.render(renderable);
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/depth.fragment.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/depth.fragment.glsl
index b016e991f..7aa2c9e5c 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/depth.fragment.glsl
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/depth.fragment.glsl
@@ -9,11 +9,23 @@ precision mediump float;
 #define HIGH
 #endif
 
+#if defined(diffuseTextureFlag) && defined(blendedFlag)
+#define blendedTextureFlag
+varying MED vec2 v_texCoords0;
+uniform sampler2D u_diffuseTexture;
+uniform float u_alphaTest;
+#endif
+
 #ifdef PackedDepthFlag
 varying HIGH float v_depth;
 #endif //PackedDepthFlag
 
 void main() {
+	#ifdef blendedTextureFlag
+		if (texture2D(u_diffuseTexture, v_texCoords0).a < u_alphaTest)
+			discard;
+	#endif // blendedTextureFlag
+	
 	#ifdef PackedDepthFlag
 		HIGH float depth = v_depth;
 		const HIGH vec4 bias = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/depth.vertex.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/depth.vertex.glsl
index a91858c5e..297a478ef 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/depth.vertex.glsl
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/depth.vertex.glsl
@@ -1,6 +1,13 @@
 attribute vec3 a_position;
 uniform mat4 u_projViewWorldTrans;
 
+#if defined(diffuseTextureFlag) && defined(blendedFlag)
+#define blendedTextureFlag
+attribute vec2 a_texCoord0;
+varying vec2 v_texCoords0;
+#endif
+
+
 #ifdef boneWeight0Flag
 #define boneWeightsFlag
 attribute vec2 a_boneWeight0;
@@ -72,6 +79,10 @@ varying float v_depth;
 #endif //PackedDepthFlag
 
 void main() {
+	#ifdef blendedTextureFlag
+		v_texCoords0 = a_texCoord0;
+	#endif // blendedTextureFlag
+	
 	#ifdef skinningFlag
 		mat4 skinning = mat4(0.0);
 		#ifdef boneWeight0Flag
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/Animation3DTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/Animation3DTest.java
index 7e20bd83e..8e01a31a3 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/Animation3DTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/Animation3DTest.java
@@ -26,7 +26,9 @@ import com.badlogic.gdx.graphics.g3d.Material;
 import com.badlogic.gdx.graphics.g3d.Model;
 import com.badlogic.gdx.graphics.g3d.ModelBatch;
 import com.badlogic.gdx.graphics.g3d.ModelInstance;
+import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
 import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute;
 import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
 import com.badlogic.gdx.graphics.g3d.environment.DirectionalShadowLight;
 import com.badlogic.gdx.graphics.g3d.model.Animation;
@@ -45,6 +47,7 @@ public class Animation3DTest extends BaseG3dHudTest {
 	ModelInstance skydome;
 	Model floorModel;
 	ModelInstance character;
+	ModelInstance tree;
 	AnimationController animation;
 	DirectionalShadowLight shadowLight;
 	ModelBatch shadowBatch;
@@ -57,7 +60,7 @@ public class Animation3DTest extends BaseG3dHudTest {
 		lights = new Environment();
 		lights.set(new ColorAttribute(ColorAttribute.AmbientLight, 0.4f, 0.4f, 0.4f, 1.f));
 		lights.add((shadowLight = new DirectionalShadowLight(1024, 1024, 30f, 30f, 1f, 100f))
-			.set(0.8f, 0.8f, 0.8f, -1f, -.8f, -.2f));
+			.set(0.8f, 0.8f, 0.8f, -.4f, -.4f, -.4f));
 		lights.shadowMap = shadowLight;
 		inputController.rotateLeftKey = inputController.rotateRightKey = inputController.forwardKey = inputController.backwardKey = 0;
 		cam.position.set(25, 25, 25);
@@ -66,6 +69,7 @@ public class Animation3DTest extends BaseG3dHudTest {
 		modelsWindow.setVisible(false);
 		assets.load("data/g3d/skydome.g3db", Model.class);
 		assets.load("data/g3d/concrete.png", Texture.class);
+		assets.load("data/tree.png", Texture.class);
 		loading = true;
 		trForward.translation.set(0, 0, 8f);
 		trBackward.translation.set(0, 0, -8f);
@@ -74,14 +78,21 @@ public class Animation3DTest extends BaseG3dHudTest {
 
 		ModelBuilder builder = new ModelBuilder();
 		builder.begin();
+		builder.node().id = "floor";
 		MeshPartBuilder part = builder.part("floor", GL20.GL_TRIANGLES, Usage.Position | Usage.TextureCoordinates | Usage.Normal,
-			new Material());
+			new Material("concrete"));
 		((MeshBuilder)part).ensureRectangles(1600);
 		for (float x = -200f; x < 200f; x += 10f) {
 			for (float z = -200f; z < 200f; z += 10f) {
 				part.rect(x, 0, z + 10f, x + 10f, 0, z + 10f, x + 10f, 0, z, x, 0, z, 0, 1, 0);
 			}
 		}
+		builder.node().id = "tree";
+		part = builder.part("tree", GL20.GL_TRIANGLES, Usage.Position | Usage.TextureCoordinates | Usage.Normal,
+			new Material("tree"));
+		part.rect( 0f, 0f, -10f, 10f, 0f, -10f, 10f, 10f, -10f,  0f, 10f, -10f, 0, 0, 1f);
+		part.setUVRange(1, 0, 0, 1);
+		part.rect(10f, 0f, -10f,  0f, 0f, -10f,  0f, 10f, -10f, 10f, 10f, -10f, 0, 0, -1f);
 		floorModel = builder.end();
 
 		shadowBatch = new ModelBatch(new DepthShaderProvider());
@@ -143,6 +154,7 @@ public class Animation3DTest extends BaseG3dHudTest {
 			shadowLight.begin(character.transform.getTranslation(tmpVector), cam.direction);
 			shadowBatch.begin(shadowLight.getCamera());
 			if (character != null) shadowBatch.render(character);
+			if (tree != null) shadowBatch.render(tree);
 			shadowBatch.end();
 			shadowLight.end();
 		}
@@ -169,8 +181,13 @@ public class Animation3DTest extends BaseG3dHudTest {
 	protected void onLoaded () {
 		if (skydome == null) {
 			skydome = new ModelInstance(assets.get("data/g3d/skydome.g3db", Model.class));
-			floorModel.materials.get(0).set(TextureAttribute.createDiffuse(assets.get("data/g3d/concrete.png", Texture.class)));
-			instances.add(new ModelInstance(floorModel));
+			floorModel.getMaterial("concrete").set(TextureAttribute.createDiffuse(assets.get("data/g3d/concrete.png", Texture.class)));
+			floorModel.getMaterial("tree").set(
+				TextureAttribute.createDiffuse(assets.get("data/tree.png", Texture.class)),
+				new BlendingAttribute()
+				);
+			instances.add(new ModelInstance(floorModel, "floor"));
+			instances.add(tree = new ModelInstance(floorModel, "tree"));
 			assets.load("data/g3d/knight.g3db", Model.class);
 			loading = true;
 		} else if (character == null) {
