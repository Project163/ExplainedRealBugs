{"url":"https://api.github.com/repos/libgdx/libgdx/issues/6430","repository_url":"https://api.github.com/repos/libgdx/libgdx","labels_url":"https://api.github.com/repos/libgdx/libgdx/issues/6430/labels{/name}","comments_url":"https://api.github.com/repos/libgdx/libgdx/issues/6430/comments","events_url":"https://api.github.com/repos/libgdx/libgdx/issues/6430/events","html_url":"https://github.com/libgdx/libgdx/issues/6430","id":814694194,"node_id":"MDU6SXNzdWU4MTQ2OTQxOTQ=","number":6430,"title":"calculateBoundingBox unnecessarily dirties the vertex and index buffers","user":{"login":"neilccbrown","id":2347447,"node_id":"MDQ6VXNlcjIzNDc0NDc=","avatar_url":"https://avatars.githubusercontent.com/u/2347447?v=4","gravatar_id":"","url":"https://api.github.com/users/neilccbrown","html_url":"https://github.com/neilccbrown","followers_url":"https://api.github.com/users/neilccbrown/followers","following_url":"https://api.github.com/users/neilccbrown/following{/other_user}","gists_url":"https://api.github.com/users/neilccbrown/gists{/gist_id}","starred_url":"https://api.github.com/users/neilccbrown/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/neilccbrown/subscriptions","organizations_url":"https://api.github.com/users/neilccbrown/orgs","repos_url":"https://api.github.com/users/neilccbrown/repos","events_url":"https://api.github.com/users/neilccbrown/events{/privacy}","received_events_url":"https://api.github.com/users/neilccbrown/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":{"login":"mgsx-dev","id":8074238,"node_id":"MDQ6VXNlcjgwNzQyMzg=","avatar_url":"https://avatars.githubusercontent.com/u/8074238?v=4","gravatar_id":"","url":"https://api.github.com/users/mgsx-dev","html_url":"https://github.com/mgsx-dev","followers_url":"https://api.github.com/users/mgsx-dev/followers","following_url":"https://api.github.com/users/mgsx-dev/following{/other_user}","gists_url":"https://api.github.com/users/mgsx-dev/gists{/gist_id}","starred_url":"https://api.github.com/users/mgsx-dev/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mgsx-dev/subscriptions","organizations_url":"https://api.github.com/users/mgsx-dev/orgs","repos_url":"https://api.github.com/users/mgsx-dev/repos","events_url":"https://api.github.com/users/mgsx-dev/events{/privacy}","received_events_url":"https://api.github.com/users/mgsx-dev/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"mgsx-dev","id":8074238,"node_id":"MDQ6VXNlcjgwNzQyMzg=","avatar_url":"https://avatars.githubusercontent.com/u/8074238?v=4","gravatar_id":"","url":"https://api.github.com/users/mgsx-dev","html_url":"https://github.com/mgsx-dev","followers_url":"https://api.github.com/users/mgsx-dev/followers","following_url":"https://api.github.com/users/mgsx-dev/following{/other_user}","gists_url":"https://api.github.com/users/mgsx-dev/gists{/gist_id}","starred_url":"https://api.github.com/users/mgsx-dev/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mgsx-dev/subscriptions","organizations_url":"https://api.github.com/users/mgsx-dev/orgs","repos_url":"https://api.github.com/users/mgsx-dev/repos","events_url":"https://api.github.com/users/mgsx-dev/events{/privacy}","received_events_url":"https://api.github.com/users/mgsx-dev/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":1,"created_at":"2021-02-23T17:53:37Z","updated_at":"2022-11-15T19:55:50Z","closed_at":"2022-11-15T19:55:50Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"#### Issue details\r\nCalling Mesh.calculatingBoundingBox (and related functions like Mesh.extendBoundingBox, Mesh.calculateRadius) calls VertexData.getBuffer() and IndexData.getBuffer().  The implementations of these methods mark the buffer as dirty (for the general case where the user has called them and may modify the data) and on the next call to VertexData.bind() the data is reuploaded to the GPU using glBufferData or similar.\r\n\r\nThis means that calculating the bounding box is made into an expensive GPU operation even though it doesn't need to go near the GPU.  I have problems with this where I am animating a small part of a big model and recalculating the bounding box, which causes my whole model to be reuploaded to the GPU.  The test case below shows that while the bounding box calculation is quite quick (5 microseconds), the reupload is much more expensive if the GPU is saturated (740 microseconds).\r\n\r\nI suggest that VertexData should have some kind of access mechanism specifically for the Mesh bounding box methods that allows it to access the data without marking it as dirty, whether that's a getBufferReadOnly() method or some kind of instanceof check for the built-in buffer types.  It's a pain to work around as a library user - you either need to hold a duplicate copy of the mesh for the bounding box checks, or you have to duplicate the calculateBoundingBox code yourself and hack into the vertex buffer internals to get the data without marking it as dirty.\r\n\r\n#### Reproduction steps/code\r\nHere is a complete test case showing the times involved:\r\n```java\r\nimport com.badlogic.gdx.ApplicationAdapter;\r\nimport com.badlogic.gdx.graphics.GL20;\r\nimport com.badlogic.gdx.graphics.Mesh;\r\nimport com.badlogic.gdx.graphics.VertexAttribute;\r\nimport com.badlogic.gdx.graphics.g3d.model.MeshPart;\r\nimport com.badlogic.gdx.graphics.glutils.ShaderProgram;\r\nimport com.badlogic.gdx.math.collision.BoundingBox;\r\n\r\npublic class MyGdxGame extends ApplicationAdapter {\r\n    public static final int LOOP_AMOUNT = 1000;\r\n    public static final int FRAME_AMOUNT = 10;\r\n    ShaderProgram shaderProgram;\r\n\tMesh bigMesh;\r\n\tMeshPart meshPart;\r\n\tBoundingBox boundingBox = new BoundingBox();\r\n\tint frames = 0;\r\n\t\r\n\tlong nanosJustBox;\r\n\tlong nanosDirtyBind;\r\n        long nanosCleanBind;\r\n\t\r\n\t@Override\r\n\tpublic void create () {\r\n\t\tbigMesh = new Mesh(true, 30_000, 100, VertexAttribute.Position(), VertexAttribute.Normal(), VertexAttribute.Tangent(), VertexAttribute.TexCoords(0));\r\n\t\t// Vertex values not important here:\r\n\t\tfloat[] vertices = new float[30_000 * 11];\r\n        short[] indices = new short[bigMesh.getMaxIndices()];\r\n        for (int i = 0; i < bigMesh.getMaxIndices(); i++)\r\n        {\r\n            indices[i] = (short)i;\r\n        }\r\n        bigMesh.setVertices(vertices);\r\n        bigMesh.setIndices(indices);\r\n        meshPart = new MeshPart(\"\", bigMesh, 0, 100, GL20.GL_TRIANGLES);\r\n        String vs = \"attribute vec4 a_position; void main(){ gl_Position = a_position;}\";\r\n        String fs = \"void main(){ gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); }\";\r\n        shaderProgram = new ShaderProgram(vs, fs);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void render () {\r\n\t    if (frames < FRAME_AMOUNT)\r\n        {\r\n            long t0 = System.nanoTime();\r\n            for (int i = 0; i < LOOP_AMOUNT; i++)\r\n                meshPart.mesh.calculateBoundingBox(boundingBox, meshPart.offset, meshPart.size);\r\n            long t1 = System.nanoTime();\r\n            for (int i = 0; i < LOOP_AMOUNT; i++)\r\n            {\r\n                // Calls vertices.getBuffer(), which does the dirty marking without the work of calculateBoundingBox:\r\n                meshPart.mesh.getVerticesBuffer();\r\n                bigMesh.bind(shaderProgram);\r\n                bigMesh.unbind(shaderProgram);\r\n            }\r\n            long t2 = System.nanoTime();\r\n            for (int i = 0; i < LOOP_AMOUNT; i++)\r\n            {\r\n                bigMesh.bind(shaderProgram);\r\n                bigMesh.unbind(shaderProgram);\r\n            }\r\n            long t3 = System.nanoTime();\r\n            \r\n            nanosJustBox += (t1 - t0);\r\n            nanosDirtyBind += (t2 - t1);\r\n            nanosCleanBind += (t3 - t2);\r\n        }\r\n\t    else if (frames == FRAME_AMOUNT)\r\n        {\r\n            System.out.println(\"Nanos on box: \" + (nanosJustBox / (FRAME_AMOUNT * LOOP_AMOUNT)));\r\n            System.out.println(\"Nanos on dirty bind: \" + (nanosDirtyBind / 10000L));\r\n            System.out.println(\"Nanos on clean bind: \" + (nanosCleanBind / 10000L));\r\n        }\r\n        frames += 1;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void dispose () {\r\n\t\tbigMesh.dispose();\r\n\t}\r\n}\r\n\r\n```\r\n\r\n#### Version of LibGDX and/or relevant dependencies\r\nThe above used libGDX 1.9.14\r\n\r\n#### Output\r\nOn an Nvidia GTX 1080 I got the following output:\r\n```\r\nNanos on box: 5383\r\nNanos on dirty bind: 739774\r\nNanos on clean bind: 1469\r\n```\r\nThe difference between dirty bind and clean bind is equivalent to the effect of calculateBoundingBox unnecessarily marking the mesh as dirty.\r\n\r\n#### Please select the affected platforms\r\n- [ ] Android\r\n- [ ] iOS\r\n- [ ] HTML/GWT\r\n- [X] Windows\r\n- [X] Linux\r\n- [X] MacOS\r\n","closed_by":{"login":"Tom-Ski","id":4346114,"node_id":"MDQ6VXNlcjQzNDYxMTQ=","avatar_url":"https://avatars.githubusercontent.com/u/4346114?v=4","gravatar_id":"","url":"https://api.github.com/users/Tom-Ski","html_url":"https://github.com/Tom-Ski","followers_url":"https://api.github.com/users/Tom-Ski/followers","following_url":"https://api.github.com/users/Tom-Ski/following{/other_user}","gists_url":"https://api.github.com/users/Tom-Ski/gists{/gist_id}","starred_url":"https://api.github.com/users/Tom-Ski/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Tom-Ski/subscriptions","organizations_url":"https://api.github.com/users/Tom-Ski/orgs","repos_url":"https://api.github.com/users/Tom-Ski/repos","events_url":"https://api.github.com/users/Tom-Ski/events{/privacy}","received_events_url":"https://api.github.com/users/Tom-Ski/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/libgdx/libgdx/issues/6430/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/libgdx/libgdx/issues/6430/timeline","performed_via_github_app":null,"state_reason":"completed"}