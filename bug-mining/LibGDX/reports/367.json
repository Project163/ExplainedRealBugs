{"url":"https://api.github.com/repos/libgdx/libgdx/issues/4186","repository_url":"https://api.github.com/repos/libgdx/libgdx","labels_url":"https://api.github.com/repos/libgdx/libgdx/issues/4186/labels{/name}","comments_url":"https://api.github.com/repos/libgdx/libgdx/issues/4186/comments","events_url":"https://api.github.com/repos/libgdx/libgdx/issues/4186/events","html_url":"https://github.com/libgdx/libgdx/issues/4186","id":164752006,"node_id":"MDU6SXNzdWUxNjQ3NTIwMDY=","number":4186,"title":"Array.sort(Comparator<T>) does not produce results consistant with ArrayList.sort(Comparator<T>) when used with the default ModelCache.Sorter","user":{"login":"Bolt-Head","id":19981350,"node_id":"MDQ6VXNlcjE5OTgxMzUw","avatar_url":"https://avatars.githubusercontent.com/u/19981350?v=4","gravatar_id":"","url":"https://api.github.com/users/Bolt-Head","html_url":"https://github.com/Bolt-Head","followers_url":"https://api.github.com/users/Bolt-Head/followers","following_url":"https://api.github.com/users/Bolt-Head/following{/other_user}","gists_url":"https://api.github.com/users/Bolt-Head/gists{/gist_id}","starred_url":"https://api.github.com/users/Bolt-Head/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Bolt-Head/subscriptions","organizations_url":"https://api.github.com/users/Bolt-Head/orgs","repos_url":"https://api.github.com/users/Bolt-Head/repos","events_url":"https://api.github.com/users/Bolt-Head/events{/privacy}","received_events_url":"https://api.github.com/users/Bolt-Head/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2016-07-11T03:04:16Z","updated_at":"2016-08-07T19:24:06Z","closed_at":"2016-08-07T19:19:35Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"#### Issue details\n\nThe ModelCache class uses a comparator of ModelCache.sorter() to sort renderables by VertexAttribute, Material, and then primitive. However the first time the sorter is ran for any renderable they are sorted incorrectly. Not only is this functionally incorrect, but it has the impact of unnecessary mesh pool requests/allocations which can cause lag as objects enter the camera frustum.\n\nI included several test scenarios shown in runTests(). The ArrayList is always able to sort the renderables correctly. However the first time the Array sorts renderables of different VertexAttributes it will fail to sort them correct, shown in the Test 1 output.\n\nThe render function is not important for the test results but it may be useful in showing what the test is trying to accomplish. In this case it is render a grid of blocks, some of which have a packed color component and other that do not (causing them to have two different types of VertexAttributes). These should be able to be built as 2 meshes (1 swap) but instead require 4 meshes (3 swaps). As the number of renderables are increased the number of uncessary extra meshes can reach well over 100.\n#### Reproduction steps/code\n\nSingle file test case:\n\n```\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\nimport com.badlogic.gdx.ApplicationAdapter;\nimport com.badlogic.gdx.Gdx;\nimport com.badlogic.gdx.InputMultiplexer;\nimport com.badlogic.gdx.graphics.Color;\nimport com.badlogic.gdx.graphics.GL20;\nimport com.badlogic.gdx.graphics.PerspectiveCamera;\nimport com.badlogic.gdx.graphics.VertexAttributes;\nimport com.badlogic.gdx.graphics.VertexAttributes.Usage;\nimport com.badlogic.gdx.graphics.g3d.Environment;\nimport com.badlogic.gdx.graphics.g3d.Material;\nimport com.badlogic.gdx.graphics.g3d.Model;\nimport com.badlogic.gdx.graphics.g3d.ModelBatch;\nimport com.badlogic.gdx.graphics.g3d.ModelCache;\nimport com.badlogic.gdx.graphics.g3d.ModelInstance;\nimport com.badlogic.gdx.graphics.g3d.Renderable;\nimport com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;\nimport com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;\nimport com.badlogic.gdx.graphics.g3d.utils.CameraInputController;\nimport com.badlogic.gdx.graphics.g3d.utils.DefaultShaderProvider;\nimport com.badlogic.gdx.graphics.g3d.utils.MeshPartBuilder;\nimport com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;\nimport com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BoxShapeBuilder;\nimport com.badlogic.gdx.utils.Array;\nimport com.badlogic.gdx.utils.Logger;\nimport com.badlogic.gdx.utils.Pool;\n\npublic class ModelCacheTest extends ApplicationAdapter {\n\n    private ModelCache modelCache;\n    private ModelBuilder modelBuilder = new ModelBuilder();\n    private Array<ModelInstance> instances0 = new Array<ModelInstance>();\n    private Array<ModelInstance> instances1 = new Array<ModelInstance>();\n\n    private Array<Model> models = new Array<Model>();\n\n    private Logger logger = new Logger(\"LOG\", Logger.INFO);\n    public PerspectiveCamera cam;\n    public CameraInputController inputController;\n    public ModelBatch modelBatch;\n    public Environment environment;\n\n    private final Comparator<Renderable> comparator = new ModelCache.Sorter();\n\n\n    private Pool<Renderable> fakeRenderablesPool = new Pool<Renderable>() {\n        @Override\n        protected Renderable newObject() {\n            return new Renderable();\n        }\n    };\n\n    @Override\n    public void create() {\n        modelBatch = new ModelBatch(new DefaultShaderProvider());\n\n        environment = new Environment();\n        environment.set(new ColorAttribute(ColorAttribute.AmbientLight, .4f,\n                .4f, .4f, 1f));\n        environment.add(new DirectionalLight().set(0.8f, 0.8f, 0.8f, -1f,\n                -0.8f, -0.2f));\n\n        cam = new PerspectiveCamera(67, Gdx.graphics.getWidth(),\n                Gdx.graphics.getHeight());\n        cam.position.set(10f, 10f, 10f);\n        cam.lookAt(0, 0, 0);\n        cam.near = 1f;\n        cam.far = 30f;\n        cam.update();\n\n        Gdx.input.setInputProcessor(new InputMultiplexer(\n                inputController = new CameraInputController(cam)));\n\n        this.modelCache = new ModelCache();\n\n        Material materialRed = new Material();\n        Material materialBlue = new Material();\n        Material materialBlueDuplicate = new Material();\n        Material materialGreen = new Material();\n\n        materialRed.set(ColorAttribute.createDiffuse(Color.RED));\n        materialBlue.set(ColorAttribute.createDiffuse(Color.BLUE));\n        materialGreen.set(ColorAttribute.createDiffuse(Color.GREEN));\n        materialBlueDuplicate.set(ColorAttribute.createDiffuse(Color.BLUE));\n\n        final int usageBasic = Usage.Position | Usage.Normal;\n        final int usageBasicColor = Usage.Position | Usage.ColorPacked | Usage.Normal;\n\n        models.add(buildCubeModel(materialRed, usageBasic));\n        models.add(buildCubeModel(materialRed, usageBasicColor));\n        models.add(buildCubeModel(materialBlue, usageBasic));\n        models.add(buildCubeModel(materialBlue, usageBasicColor));\n        models.add(buildCubeModel(materialBlueDuplicate, usageBasic));\n        models.add(buildCubeModel(materialBlueDuplicate, usageBasicColor));\n        models.add(buildCubeModel(materialGreen, usageBasic));\n        models.add(buildCubeModel(materialGreen, usageBasicColor));\n\n\n        for (int i = 0, s = models.size; i < s; i++) {  \n            for(int ii =0; ii < 5;ii++) {\n                int index = ( i * ii + i)%models.size;\n                Model model = models.get(index);\n                ModelInstance modelInstance = new ModelInstance(model);\n                modelInstance.transform.trn(i * 2, 0, ii*2);\n                instances0.add(modelInstance);\n                instances1.add(modelInstance.copy());\n\n            }\n        }\n\n        runTests();\n    }\n\n    private Model buildCubeModel(Material material, int usage) {\n        modelBuilder.begin();\n        MeshPartBuilder part = modelBuilder.part(\"\", GL20.GL_TRIANGLES, usage,\n                material);\n        BoxShapeBuilder.build(part, 1f, 1f, 1f);\n\n        Model model = modelBuilder.end();\n\n        return model;\n    }\n    @Override\n    public void render() {\n        visualizeTest();\n    }\n    private void visualizeTest() {\n        inputController.update();\n        Gdx.gl.glViewport(0, 0, Gdx.graphics.getBackBufferWidth(),\n                Gdx.graphics.getBackBufferHeight());\n        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);\n\n        modelCache.begin();\n        for (ModelInstance renderable : instances0) {\n            modelCache.add(renderable);\n        }\n        modelCache.end();\n\n        modelBatch.begin(cam);\n        modelBatch.render(modelCache, environment);\n        modelBatch.end();\n    }\n\n\n    private void runTests() {\n        logger.info(\"Test 1. Sort GDX Array and then ArrayList\");\n        runGdxArrayTest(instances0);\n        runArrayListTest(instances0);   \n\n        logger.info(\"Test 2. Exact same as Test 1 (same model instances)\");\n        runGdxArrayTest(instances0);\n        runArrayListTest(instances0);   \n\n        logger.info(\"Test 3. Sort ArrayList and then GDX Array (copied model instances)\");\n        runArrayListTest(instances1);\n        runGdxArrayTest(instances1);\n    }\n\n    private void runArrayListTest(Array<ModelInstance> instances) {\n        Array<Renderable> renderables = getRenderables(instances);\n\n        ArrayList<Renderable> arrayList = new ArrayList<Renderable>();\n        for (Renderable renderable : renderables) {\n            arrayList.add(renderable);\n        }\n\n        arrayList.sort(comparator);\n\n        //Copy back to GDX array for simpler validation \n        renderables.clear();\n        for (Renderable renderable : arrayList) {\n            renderables.add(renderable);\n        }\n\n        String resultText = checkResults(renderables,\"ArrayList\");  \n        logger.info(resultText);\n    }\n\n    private static String checkResults(Array<Renderable> renderables,String testName) {\n        int swapCount = calculateSwapCount(renderables);\n        StringBuilder builder = new StringBuilder();\n\n        boolean succcess = swapCount == 1;\n\n        String result = succcess ? \"SUCCESS\" : \"FAIL\";\n        builder.append(\"Results: \" + testName + \" == \" + result);\n\n        if(!succcess) {\n            builder.append(\"\\nTotal swaps = \" + swapCount);\n            builder.append(\"\\nFailed Array Contents=\\n\");\n            for(int i = 0; i < renderables.size;i++){\n                builder.append(renderables.get(i).meshPart.mesh.getVertexAttributes().getMask()).append(\", \");\n            }\n        }\n        return builder.toString();\n    }\n\n    private void runGdxArrayTest(Array<ModelInstance> instances) {\n        Array<Renderable> renderables = getRenderables(instances);\n        renderables.sort(comparator);\n\n        String resultText =  checkResults(renderables,\"GDX Array\"); \n        logger.info(resultText);\n    }\n\n\n    private Array<Renderable> getRenderables(Array<ModelInstance> instances) {\n        Array<Renderable> renderables = new Array<Renderable>(); \n        for (ModelInstance instance : instances) {\n            instance.getRenderables(renderables, fakeRenderablesPool);\n        }\n        return renderables;\n    }\n\n\n    /** \n     *  Calculates the number of meshes that would be requsted from the MeshPool, See ModelCache.end()\n       https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g3d/ModelCache.java#L250\n     */ \n    private static int calculateSwapCount(Array<Renderable> items) {\n\n        final Renderable first = items.get(0);\n        VertexAttributes vertexAttributes = first.meshPart.mesh\n                .getVertexAttributes();\n        Material material = first.material;\n        int primitiveType = first.meshPart.primitiveType;\n\n        int meshSwapCount = 0;\n\n        for (int i = 0, n = items.size; i < n; ++i) {\n            final Renderable renderable = items.get(i);\n            final VertexAttributes va = renderable.meshPart.mesh\n                    .getVertexAttributes();\n            final Material mat = renderable.material;\n            final int pt = renderable.meshPart.primitiveType;\n\n            final boolean sameMesh = va.equals(vertexAttributes);\n\n            final boolean samePart = sameMesh && pt == primitiveType\n                    && mat.same(material, true);\n\n            if (!samePart) {\n                if (!sameMesh) {\n                    meshSwapCount++;\n                }\n                vertexAttributes = va;\n            }\n            material = mat;\n            primitiveType = pt;\n        }\n        return meshSwapCount;\n    }\n\n    @Override\n    public void dispose() {\n        modelBatch.dispose();\n        for (Model model : models) {\n            model.dispose();\n        }\n\n    }\n}\n```\n#### Version of LibGDX and/or relevant dependencies\n\n1.9.3\n#### Stacktrace\n\nLOG: Test 1. Sort GDX Array and then ArrayList\nLOG: Results: GDX Array == **FAIL**\nTotal swaps = 3\nFailed Array Contents=\n9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 13, 13, 13, 13, 13, 13, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 13, 13, 13, 13, 13, 13, \nLOG: Results: ArrayList == SUCCESS\n\nLOG: Test 2. Exact same as Test 1 (same model instances)\nLOG: Results: GDX Array == SUCCESS\nLOG: Results: ArrayList == SUCCESS\n\nLOG: Test 3. Sort ArrayList and then GDX Array (copied model instances)\nLOG: Results: ArrayList == SUCCESS\nLOG: Results: GDX Array == SUCCESS\n#### Please select the affected platforms\n- [ ] Android\n- [ ] iOS (robovm)\n- [ ] iOS (MOE)\n- [ ] HTML/GWT\n- [X] Windows\n- [ ] Linux\n- [ ] MacOS\n","closed_by":{"login":"xoppa","id":2349087,"node_id":"MDQ6VXNlcjIzNDkwODc=","avatar_url":"https://avatars.githubusercontent.com/u/2349087?v=4","gravatar_id":"","url":"https://api.github.com/users/xoppa","html_url":"https://github.com/xoppa","followers_url":"https://api.github.com/users/xoppa/followers","following_url":"https://api.github.com/users/xoppa/following{/other_user}","gists_url":"https://api.github.com/users/xoppa/gists{/gist_id}","starred_url":"https://api.github.com/users/xoppa/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xoppa/subscriptions","organizations_url":"https://api.github.com/users/xoppa/orgs","repos_url":"https://api.github.com/users/xoppa/repos","events_url":"https://api.github.com/users/xoppa/events{/privacy}","received_events_url":"https://api.github.com/users/xoppa/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/libgdx/libgdx/issues/4186/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/libgdx/libgdx/issues/4186/timeline","performed_via_github_app":null,"state_reason":"completed"}