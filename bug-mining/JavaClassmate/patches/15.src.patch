diff --git a/VERSION.txt b/VERSION.txt
index 9ddf869..f421e07 100644
--- a/VERSION.txt
+++ b/VERSION.txt
@@ -3,6 +3,11 @@ Java ClassMate project: licensed under Apache License 2.0
 
 Release notes:
 
+1.3.3 (28-Sep-2016)
+
+#33: "ghost" type parameter in field
+ (reported, fix contributed by web-online@github)
+
 1.3.2 (25-Sep-2016)
 
 #30: ArrayIndexOutOfBoundsException when resolving Object.class
diff --git a/src/main/java/com/fasterxml/classmate/ResolvedType.java b/src/main/java/com/fasterxml/classmate/ResolvedType.java
index 77465d0..58e0fd0 100644
--- a/src/main/java/com/fasterxml/classmate/ResolvedType.java
+++ b/src/main/java/com/fasterxml/classmate/ResolvedType.java
@@ -91,7 +91,7 @@ public abstract class ResolvedType
     /**
      * Returns ordered list of interfaces (in declaration order) that this type
      * implements.
-     * 
+     *
      * @return List of interfaces this type implements, if any; empty list if none
      */
     public abstract List<ResolvedType> getImplementedInterfaces();
diff --git a/src/main/java/com/fasterxml/classmate/TypeResolver.java b/src/main/java/com/fasterxml/classmate/TypeResolver.java
index a7752d8..6a0c6a7 100644
--- a/src/main/java/com/fasterxml/classmate/TypeResolver.java
+++ b/src/main/java/com/fasterxml/classmate/TypeResolver.java
@@ -404,19 +404,17 @@ public class TypeResolver implements Serializable
             ResolvedType elementType = _fromAny(context, rawType.getComponentType(), typeBindings);
             return new ResolvedArrayType(rawType, typeBindings, elementType);
         }
+        // Work-around/fix for [#33]: if the type has no type parameters, don't include
+        // typeBindings in the ResolvedType
+        if (!typeBindings.isEmpty() && rawType.getTypeParameters().length == 0) {
+            typeBindings = TypeBindings.emptyBindings();
+        }
         // For other types super interfaces are needed...
         if (rawType.isInterface()) {
             return new ResolvedInterfaceType(rawType, typeBindings,
                     _resolveSuperInterfaces(context, rawType, typeBindings));
             
         }
-        // for issue 33: if the type has no type parameters,
-        // don't include typeBindings in the ResolvedType
-        if (rawType.getTypeParameters().length == 0) {
-            return new ResolvedObjectType(rawType, null,
-                    _resolveSuperClass(context, rawType, typeBindings),
-                    _resolveSuperInterfaces(context, rawType, typeBindings));
-        }
         return new ResolvedObjectType(rawType, typeBindings,
                 _resolveSuperClass(context, rawType, typeBindings),
                 _resolveSuperInterfaces(context, rawType, typeBindings));
diff --git a/src/main/java/com/fasterxml/classmate/types/ResolvedInterfaceType.java b/src/main/java/com/fasterxml/classmate/types/ResolvedInterfaceType.java
index 6a4d9eb..823d062 100644
--- a/src/main/java/com/fasterxml/classmate/types/ResolvedInterfaceType.java
+++ b/src/main/java/com/fasterxml/classmate/types/ResolvedInterfaceType.java
@@ -9,7 +9,6 @@ import com.fasterxml.classmate.members.RawMethod;
 
 public class ResolvedInterfaceType extends ResolvedType
 {
-
     /**
      * List of interfaces this type implements; may be empty but never null
      */
diff --git a/src/test/java/com/fasterxml/classmate/TestSubtypeResolution.java b/src/test/java/com/fasterxml/classmate/TestSubtypeResolution.java
index 03f53db..1c61e68 100644
--- a/src/test/java/com/fasterxml/classmate/TestSubtypeResolution.java
+++ b/src/test/java/com/fasterxml/classmate/TestSubtypeResolution.java
@@ -178,7 +178,7 @@ public class TestSubtypeResolution extends BaseTest
 
         // and must look the same in other respects too:
         assertEquals("Ljava/util/HashMap<Ljava/lang/String;Ljava/lang/Long;>;", subtype.getSignature());
-        assertEquals("java.util.HashMap<java.lang.String,java.lang.Long> extends java.util.AbstractMap<java.lang.String,java.lang.Long> implements java.util.Map<java.lang.String,java.lang.Long>,java.lang.Cloneable<java.lang.String,java.lang.Long>,java.io.Serializable<java.lang.String,java.lang.Long>",
+        assertEquals("java.util.HashMap<java.lang.String,java.lang.Long> extends java.util.AbstractMap<java.lang.String,java.lang.Long> implements java.util.Map<java.lang.String,java.lang.Long>,java.lang.Cloneable,java.io.Serializable",
                 subtype.getFullDescription());
     }
 
diff --git a/src/test/java/com/fasterxml/classmate/members/GhostTypeParameterInFieldTest.java b/src/test/java/com/fasterxml/classmate/members/GhostTypeParameterInFieldTest.java
index 3cb31dd..1df63e9 100644
--- a/src/test/java/com/fasterxml/classmate/members/GhostTypeParameterInFieldTest.java
+++ b/src/test/java/com/fasterxml/classmate/members/GhostTypeParameterInFieldTest.java
@@ -6,20 +6,26 @@ import junit.framework.TestCase;
 
 import com.fasterxml.classmate.*;
 
-// for issue "ghost" type parameter in field:
+// for [#33]: "ghost" parameter
 public class GhostTypeParameterInFieldTest
     extends TestCase
 {
-    public static class A<T extends Number> {
+    public static class GenericWithClass<T extends Number> {
         public List<T> listOfT;
         public T t;
         public Integer i;
     }
 
-    public void testGhostTypeParameterInField()
+    public static class GenericWithInterface<T extends Number> {
+        public List<T> listOfT;
+        public T t;
+        public Number i;
+    }
+
+    public void testGhostTypeParameterWithClass()
     {
         TypeResolver resolver = new TypeResolver();
-        ResolvedType resolvedType = resolver.resolve(A.class, Integer.class);
+        ResolvedType resolvedType = resolver.resolve(GenericWithClass.class, Integer.class);
         MemberResolver memberResolver = new MemberResolver(resolver);
         ResolvedTypeWithMembers resolvedTypeWithMembers = memberResolver.resolve(resolvedType, null, null);
         ResolvedField[] fields = resolvedTypeWithMembers.getMemberFields();
@@ -33,7 +39,7 @@ public class GhostTypeParameterInFieldTest
         ResolvedType listOfT_Type = listOfT_Field.getType();
         assertEquals(List.class, listOfT_Type.getErasedType());
         List<ResolvedType> listOfT_TypeParams = listOfT_Type.getTypeParameters();
-        assertEquals("Expected 1 type paramter for listOfT, got " + listOfT_TypeParams.size() + ": " + listOfT_TypeParams, 1, listOfT_TypeParams.size());
+        assertEquals("Expected 1 type parameter for listOfT, got " + listOfT_TypeParams.size() + ": " + listOfT_TypeParams, 1, listOfT_TypeParams.size());
         assertEquals(Integer.class, listOfT_TypeParams.get(0).getErasedType());
 
         // field t
@@ -42,7 +48,7 @@ public class GhostTypeParameterInFieldTest
         ResolvedType t_Type = t_Field.getType();
         assertEquals(Integer.class, t_Type.getErasedType());
         List<ResolvedType> t_TypeParams = t_Type.getTypeParameters();
-        assertEquals("Expected 0 type paramter for t, got " + t_TypeParams.size() + ": " + t_TypeParams, 0, t_TypeParams.size());
+        assertEquals("Expected 0 type parameter for t, got " + t_TypeParams.size() + ": " + t_TypeParams, 0, t_TypeParams.size());
 
         // field i
         ResolvedField i_Field = fields[2];
@@ -50,7 +56,43 @@ public class GhostTypeParameterInFieldTest
         ResolvedType i_Type = i_Field.getType();
         assertEquals(Integer.class, i_Type.getErasedType());
         List<ResolvedType> i_TypeParams = i_Type.getTypeParameters();
-        assertEquals("Expected 0 type paramter for i, got " + i_TypeParams.size() + ": " + i_TypeParams, 0, i_TypeParams.size());
+        assertEquals("Expected 0 type parameter for i, got " + i_TypeParams.size() + ": " + i_TypeParams, 0, i_TypeParams.size());
     }
 
+    public void testGhostTypeParameterWithInterface()
+    {
+        TypeResolver resolver = new TypeResolver();
+        ResolvedType resolvedType = resolver.resolve(GenericWithInterface.class, Integer.class);
+        MemberResolver memberResolver = new MemberResolver(resolver);
+        ResolvedTypeWithMembers resolvedTypeWithMembers = memberResolver.resolve(resolvedType, null, null);
+        ResolvedField[] fields = resolvedTypeWithMembers.getMemberFields();
+
+        // test fields
+        assertEquals(3, fields.length);
+
+        // field List<T> listOfT
+        ResolvedField listOfT_Field = fields[0];
+        assertEquals("listOfT", listOfT_Field.getName());
+        ResolvedType listOfT_Type = listOfT_Field.getType();
+        assertEquals(List.class, listOfT_Type.getErasedType());
+        List<ResolvedType> listOfT_TypeParams = listOfT_Type.getTypeParameters();
+        assertEquals("Expected 1 type parameter for listOfT, got " + listOfT_TypeParams.size() + ": " + listOfT_TypeParams, 1, listOfT_TypeParams.size());
+        assertEquals(Integer.class, listOfT_TypeParams.get(0).getErasedType());
+
+        // field t
+        ResolvedField t_Field = fields[1];
+        assertEquals("t", t_Field.getName());
+        ResolvedType t_Type = t_Field.getType();
+        assertEquals(Integer.class, t_Type.getErasedType());
+        List<ResolvedType> t_TypeParams = t_Type.getTypeParameters();
+        assertEquals("Expected 0 type parameter for t, got " + t_TypeParams.size() + ": " + t_TypeParams, 0, t_TypeParams.size());
+
+        // field i
+        ResolvedField i_Field = fields[2];
+        assertEquals("i", i_Field.getName());
+        ResolvedType i_Type = i_Field.getType();
+        assertEquals(Number.class, i_Type.getErasedType());
+        List<ResolvedType> i_TypeParams = i_Type.getTypeParameters();
+        assertEquals("Expected 0 type parameter for i, got " + i_TypeParams.size() + ": " + i_TypeParams, 0, i_TypeParams.size());
+    }
 }
