diff --git a/release-notes.txt b/release-notes.txt
new file mode 100644
index 0000000..3686597
--- /dev/null
+++ b/release-notes.txt
@@ -0,0 +1,4 @@
+
+0.5.4:
+
+* Fixed issue#4: problems with self-referential type variables
diff --git a/src/main/java/com/fasterxml/classmate/TypeBindings.java b/src/main/java/com/fasterxml/classmate/TypeBindings.java
index 3a27d75..2982ba9 100644
--- a/src/main/java/com/fasterxml/classmate/TypeBindings.java
+++ b/src/main/java/com/fasterxml/classmate/TypeBindings.java
@@ -20,6 +20,9 @@ public final class TypeBindings
      */
     private final String[] _names;
 
+    /**
+     * Types matching names
+     */
     private final ResolvedType[] _types;
 
     private final int _hashCode;
@@ -84,6 +87,20 @@ public final class TypeBindings
         return new TypeBindings(names, types);
     }
 
+    /**
+     * Method for creating an instance that has same bindings as this object,
+     * plus one additional binding
+     */
+    public TypeBindings withAdditionalBinding(String name, ResolvedType type)
+    {
+        int len = _names.length;
+        String[] newNames = Arrays.copyOf(_names, len+1);
+        newNames[len] = name;
+        ResolvedType[] newTypes = Arrays.copyOf(_types, len+1);
+        newTypes[len] = type;
+        return new TypeBindings(newNames, newTypes);
+    }
+    
     /*
     /**********************************************************************
     /* Accessors
diff --git a/src/main/java/com/fasterxml/classmate/TypeResolver.java b/src/main/java/com/fasterxml/classmate/TypeResolver.java
index 6270901..0767110 100644
--- a/src/main/java/com/fasterxml/classmate/TypeResolver.java
+++ b/src/main/java/com/fasterxml/classmate/TypeResolver.java
@@ -310,6 +310,8 @@ public class TypeResolver
     /**********************************************************************
      */
 
+    int depth = 0;
+    
     private ResolvedType _fromAny(ClassStack context, Type mainType, TypeBindings typeBindings)
     {
         if (mainType instanceof Class<?>) {
@@ -450,15 +452,19 @@ public class TypeResolver
     private ResolvedType _fromVariable(ClassStack context, TypeVariable<?> variable, TypeBindings typeBindings)
     {
         // ideally should find it via bindings:
-        ResolvedType type = typeBindings.findBoundType(variable.getName());
+        String name = variable.getName();
+        ResolvedType type = typeBindings.findBoundType(name);
         if (type != null) {
             return type;
         }
         /* but if not, use bounds... note that approach here is simplistics; not taking
          * into account possible multiple bounds, nor consider upper bounds.
          */
+        /* 02-Mar-2011, tatu: As per issue#4, need to avoid self-reference cycles here;
+         *   can be handled by (temporarily) adding binding:
+         */
+        typeBindings = typeBindings.withAdditionalBinding(name, sJavaLangObject);
         Type[] bounds = variable.getBounds();
-        //context._addPlaceholder(name);        
         return _fromAny(context, bounds[0], typeBindings);
     }
 
@@ -518,12 +524,13 @@ public class TypeResolver
     
     /**
      * Simple helper class used to keep track of 'call stack' for classes being referenced
+     * (as well as unbound variables)
      */
     private final static class ClassStack
     {
         private final ClassStack _parent;
         private final Class<?> _current;
-
+        
         private ArrayList<ResolvedRecursiveType> _selfRefs;
         
         public ClassStack(Class<?> rootType) {
@@ -542,7 +549,7 @@ public class TypeResolver
         {
             return new ClassStack(this, cls);
         }
-
+        
         /**
          * Method called to indicate that there is a self-reference from
          * deeper down in stack pointing into type this stack frame represents.
diff --git a/src/test/java/com/fasterxml/classmate/TestMemberGenericTypes.java b/src/test/java/com/fasterxml/classmate/TestMemberGenericTypes.java
index e803331..5c72a31 100644
--- a/src/test/java/com/fasterxml/classmate/TestMemberGenericTypes.java
+++ b/src/test/java/com/fasterxml/classmate/TestMemberGenericTypes.java
@@ -42,15 +42,6 @@ public class TestMemberGenericTypes extends BaseTest
         public static <T extends Serializable> void staticValue(T value) { }
     }
 
-    // And issue #4 with somewhat complex self-reference(s)
-    static class ComplexSelfType<T, V extends ComplexSelfType<T, V>> { }
-
-    static class ClassUsingComplexSelfType {
-      public <T, V extends ComplexSelfType<T, V>> V complexMap(V input) {
-        return null;
-      }
-    }
-    
     /*
     /**********************************************************************
     /* setup
@@ -244,38 +235,4 @@ public class TestMemberGenericTypes extends BaseTest
         ResolvedType arg = statics[0].getArgumentType(0);
         assertEquals(Serializable.class, arg.getErasedType());
     }
-
-    /**
-     * Unit test for Issue#4, bit more complex self references.
-     */
-    public void testSelfReferences()
-    {
-          TypeResolver typeResolver = new TypeResolver();
-          MemberResolver memberResolver = new MemberResolver(typeResolver);
-
-          ResolvedType t = typeResolver.resolve(ClassUsingComplexSelfType.class);
-          ResolvedMethod[] resolvedMethods = memberResolver.resolve(t, null, null).getMemberMethods();
-          assertEquals(1, resolvedMethods.length);
-          ResolvedMethod m = resolvedMethods[0];
-          assertEquals("complexMap", m.getName());
-
-          assertEquals(1, m.getArgumentCount());
-          ResolvedType argType = m.getArgumentType(0);
-
-          ResolvedType returnType = m.getReturnType();
-
-          // All right... hmmh. Actually, due to lack of bindings, they are just Objects
-          assertEquals(Object.class, argType.getErasedType());
-          assertEquals(Object.class, returnType.getErasedType());
-          
-          /*
-    static class ComplexSelfType<T, V extends ComplexSelfType<T, V>> { }
-
-    static class ClassUsingComplexSelfType {
-      public <T, V extends ComplexSelfType<T, V>> V complexMap(V input) {
-        return null;
-      }
-    }
-           */
-    }
 }
diff --git a/src/test/java/com/fasterxml/classmate/TestSelfRefMemberTypes.java b/src/test/java/com/fasterxml/classmate/TestSelfRefMemberTypes.java
new file mode 100644
index 0000000..67e9d9b
--- /dev/null
+++ b/src/test/java/com/fasterxml/classmate/TestSelfRefMemberTypes.java
@@ -0,0 +1,80 @@
+package com.fasterxml.classmate;
+
+import com.fasterxml.classmate.members.ResolvedMethod;
+
+/**
+ * Unit tests to check issue #4, problems with local generic self-referential
+ * generic types.
+ */
+public class TestSelfRefMemberTypes extends BaseTest
+{
+    /*
+    /**********************************************************************
+    /* Helper types
+    /**********************************************************************
+     */
+
+    static class MyComparable {
+        public <T extends Comparable<T>> T foobar() { return null; }
+    }
+    
+    static class ComplexSelfType<T, V extends ComplexSelfType<T, V>> { }
+
+    static class ClassUsingComplexSelfType {
+      public <T, V extends ComplexSelfType<T, V>> V complexMap(V input) {
+        return null;
+      }
+    }
+    
+    /*
+    /**********************************************************************
+    /* setup
+    /**********************************************************************
+     */
+
+    protected TypeResolver typeResolver;
+    
+    protected void setUp()
+    {
+        // Let's use a single instance for all tests, to increase chance of seeing failures
+        typeResolver = new TypeResolver();
+    }
+
+    /*
+    /**********************************************************************
+    /* Unit tests
+    /**********************************************************************
+     */
+
+    public void testSelfReferencesSimple()
+    {
+        TypeResolver typeResolver = new TypeResolver();
+        MemberResolver memberResolver = new MemberResolver(typeResolver);
+        ResolvedType type = typeResolver.resolve(MyComparable.class);
+        ResolvedMethod[] resolvedMethods = memberResolver.resolve(type, null, null).getMemberMethods();
+
+        assertEquals(1, resolvedMethods.length);
+        assertEquals(Comparable.class, resolvedMethods[0].getReturnType().getErasedType());
+    }
+
+    public void testSelfReferencesComplex()
+    {
+          TypeResolver typeResolver = new TypeResolver();
+          MemberResolver memberResolver = new MemberResolver(typeResolver);
+
+          ResolvedType t = typeResolver.resolve(ClassUsingComplexSelfType.class);
+          ResolvedMethod[] resolvedMethods = memberResolver.resolve(t, null, null).getMemberMethods();
+          assertEquals(1, resolvedMethods.length);
+          ResolvedMethod m = resolvedMethods[0];
+          assertEquals("complexMap", m.getName());
+
+          assertEquals(1, m.getArgumentCount());
+          ResolvedType argType = m.getArgumentType(0);
+
+          ResolvedType returnType = m.getReturnType();
+
+          // All right... hmmh. Actually, due to lack of bindings, they are just Objects
+          assertEquals(ComplexSelfType.class, argType.getErasedType());
+          assertEquals(ComplexSelfType.class, returnType.getErasedType());
+      }
+}
