diff --git a/release-notes.txt b/release-notes.txt
index 6e1b23b..96d0cdc 100644
--- a/release-notes.txt
+++ b/release-notes.txt
@@ -3,8 +3,10 @@ Java ClassMate project: licensed under Apache License 2.0
 
 Release notes:
 
-0.6.0:
+0.7.0:
 
+* [Issue#11]: ResolvedType uses `java.lang.reflect.Type` to allow combination
+  of Class<?>, GenericType and ResolvedType.
 * [Issue#12]: ResolvedType now implements `java.lang.reflect.Type`
 
 0.5.4:
diff --git a/src/main/java/com/fasterxml/classmate/TypeResolver.java b/src/main/java/com/fasterxml/classmate/TypeResolver.java
index 37053b9..a93f879 100644
--- a/src/main/java/com/fasterxml/classmate/TypeResolver.java
+++ b/src/main/java/com/fasterxml/classmate/TypeResolver.java
@@ -93,7 +93,7 @@ public class TypeResolver implements Serializable
     public ResolvedType resolve(Type type)
     {
         if (type instanceof GenericType<?>) {
-            return resolve((GenericType<?>) type);
+            return _fromGenericType(null, (GenericType<?>) type, TypeBindings.emptyBindings());
         }
         if (type instanceof Class<?>) {
             return _fromClass(null, (Class<?>) type, TypeBindings.emptyBindings());
@@ -102,30 +102,6 @@ public class TypeResolver implements Serializable
         return resolve(type, TypeBindings.emptyBindings());
     }
 
-    /**
-     * Factory method for resolving given generic type, defined by using sub-class
-     * instance of {@link GenericType}
-     */
-    public ResolvedType resolve(GenericType<?> generic)
-    {
-        /* To allow multiple levels of inheritance (just in case someone
-         * wants to go to town with inheritnace of GenericType),
-         * we better resolve the whole thing; then dig out
-         * type parameterization...
-         */
-        ResolvedType type = _fromClass(null, generic.getClass(), TypeBindings.emptyBindings());
-        ResolvedType genType = type.findSupertype(GenericType.class);
-        if (genType == null) { // sanity check; shouldn't occur
-            throw new IllegalArgumentException("Unparameterized GenericType instance ("+generic.getClass().getName()+")");
-        }
-        TypeBindings b = genType.getTypeBindings();
-        ResolvedType[] params = b.typeParameterArray();
-        if (params.length == 0) {
-            throw new IllegalArgumentException("Unparameterized GenericType instance ("+generic.getClass().getName()+")");
-        }
-        return params[0];
-    }
-
     /*
     /**********************************************************************
     /* Factory methods, with explicit parameterization
@@ -163,12 +139,14 @@ public class TypeResolver implements Serializable
     /**
      * Factory method for constructing array type of given element type.
      */
-    public ResolvedArrayType arrayType(ResolvedType elementType)
+    public ResolvedArrayType arrayType(Type elementType)
     {
+        ResolvedType resolvedElementType = resolve(elementType, TypeBindings.emptyBindings());
         // Arrays are cumbersome for some reason:
-        Object emptyArray = Array.newInstance(elementType.getErasedType(), 0);
+        Object emptyArray = Array.newInstance(resolvedElementType.getErasedType(), 0);
         // Should we try to use cache? It's bit tricky, so let's not bother yet
-        return new ResolvedArrayType(emptyArray.getClass(), TypeBindings.emptyBindings(), elementType);
+        return new ResolvedArrayType(emptyArray.getClass(), TypeBindings.emptyBindings(),
+                resolvedElementType);
     }
 
     /**
@@ -315,6 +293,9 @@ public class TypeResolver implements Serializable
         if (mainType instanceof ParameterizedType) {
             return _fromParamType(context, (ParameterizedType) mainType, typeBindings);
         }
+        if (mainType instanceof GenericType<?>) {
+            return _fromGenericType(context, (GenericType<?>) mainType, typeBindings);
+        }
         if (mainType instanceof GenericArrayType) {
             return _fromArrayType(context, (GenericArrayType) mainType, typeBindings);
         }
@@ -363,6 +344,30 @@ public class TypeResolver implements Serializable
         return type;
     }
 
+    /**
+     * Factory method for resolving given generic type, defined by using sub-class
+     * instance of {@link GenericType}
+     */
+    private ResolvedType _fromGenericType(ClassStack context, GenericType<?> generic, TypeBindings typeBindings)
+    {
+        /* To allow multiple levels of inheritance (just in case someone
+         * wants to go to town with inheritance of GenericType),
+         * we better resolve the whole thing; then dig out
+         * type parameterization...
+         */
+        ResolvedType type = _fromClass(context, generic.getClass(), typeBindings);
+        ResolvedType genType = type.findSupertype(GenericType.class);
+        if (genType == null) { // sanity check; shouldn't occur
+            throw new IllegalArgumentException("Unparameterized GenericType instance ("+generic.getClass().getName()+")");
+        }
+        TypeBindings b = genType.getTypeBindings();
+        ResolvedType[] params = b.typeParameterArray();
+        if (params.length == 0) {
+            throw new IllegalArgumentException("Unparameterized GenericType instance ("+generic.getClass().getName()+")");
+        }
+        return params[0];
+    }
+    
     private ResolvedType _constructType(ClassStack context, Class<?> rawType, TypeBindings typeBindings)
     {
         // Ok: no easy shortcut, let's figure out type of type...
