diff --git a/VERSION.txt b/VERSION.txt
index 7eb1f65..03e447a 100644
--- a/VERSION.txt
+++ b/VERSION.txt
@@ -3,8 +3,10 @@ Java ClassMate project: licensed under Apache License 2.0
 
 Release notes:
 
-1.1.1 (xx-xxx-2014)
+1.2.0 (16-Sep-2014)
 
+#22: ResolvedTypeWithMembers should expose static fields as well
+ (proposed by arikkfir@github)
 - Made `ResolvedMethod`, `ResolvedField` sortable to simplify tests
 - More unit tests, from Jackson type resolver fails
 
diff --git a/pom.xml b/pom.xml
index a72de8d..9e29452 100644
--- a/pom.xml
+++ b/pom.xml
@@ -8,7 +8,7 @@
     <groupId>com.fasterxml</groupId>
     <artifactId>classmate</artifactId>
     <name>ClassMate</name>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.0-SNAPSHOT</version>
     <packaging>bundle</packaging>
     <description>Library for introspecting types with full generic information
         including resolving of field and method types.
diff --git a/src/main/java/com/fasterxml/classmate/Annotations.java b/src/main/java/com/fasterxml/classmate/Annotations.java
index a7685e8..7fb63bc 100644
--- a/src/main/java/com/fasterxml/classmate/Annotations.java
+++ b/src/main/java/com/fasterxml/classmate/Annotations.java
@@ -72,6 +72,7 @@ public class Annotations implements Serializable, Iterable<Annotation>
     /**********************************************************************
      */
 
+    @Override
     public Iterator<Annotation> iterator()
     {
         if (_annotations == null) {
diff --git a/src/main/java/com/fasterxml/classmate/ResolvedTypeWithMembers.java b/src/main/java/com/fasterxml/classmate/ResolvedTypeWithMembers.java
index 3d8170d..15cb61f 100644
--- a/src/main/java/com/fasterxml/classmate/ResolvedTypeWithMembers.java
+++ b/src/main/java/com/fasterxml/classmate/ResolvedTypeWithMembers.java
@@ -80,6 +80,8 @@ public class ResolvedTypeWithMembers
 
     protected ResolvedMethod[] _staticMethods = null;
 
+    protected ResolvedField[] _staticFields = null;
+
     protected ResolvedMethod[] _memberMethods = null;
 
     protected ResolvedField[] _memberFields = null;
@@ -157,6 +159,21 @@ public class ResolvedTypeWithMembers
     /**********************************************************************
      */
 
+    /**
+     * Method for finding all static fields of the main type (except for ones
+     * possibly filtered out by filter) and applying annotation overrides, if any,
+     * to annotations.
+     * 
+     * @since 1.2.0
+     */
+    public ResolvedField[] getStaticFields()
+    {
+        if (_staticFields == null) {
+            _staticFields = resolveStaticFields();
+        }
+        return _staticFields;
+    }
+    
     /**
      * Method for finding all static methods of the main type (except for ones
      * possibly filtered out by filter) and applying annotation overrides, if any,
@@ -290,39 +307,6 @@ public class ResolvedTypeWithMembers
         }
         return fields.values().toArray(new ResolvedField[fields.size()]);
     }
-    
-    /**
-     * Method that will actually resolve full information (types, annotations)
-     * for static methods, using configured filter.
-     */
-    protected ResolvedMethod[] resolveStaticMethods()
-    {
-        // First get static methods for main type, filter
-        LinkedHashMap<MethodKey, ResolvedMethod> methods = new LinkedHashMap<MethodKey, ResolvedMethod>();
-        for (RawMethod method : _mainType.getType().getStaticMethods()) {
-            if (_methodFilter == null || _methodFilter.include(method)) {
-                methods.put(method.createKey(), resolveMethod(method));
-            }
-        }
-        // then apply overrides (mix-ins):
-        for (HierarchicType type : overridesOnly()) {
-            for (RawMethod raw : type.getType().getStaticMethods()) {
-                ResolvedMethod method = methods.get(raw.createKey()); 
-                // must override something, otherwise to ignore
-                if (method != null) {
-                    for (Annotation ann : raw.getAnnotations()) {
-                        if (_annotationHandler.includeMethodAnnotation(ann)) {
-                            method.applyOverride(ann);
-                        }
-                    }
-                }
-            }
-        }
-        if (methods.size() == 0) {
-            return NO_RESOLVED_METHODS;
-        }
-        return methods.values().toArray(new ResolvedMethod[methods.size()]);
-    }
 
     protected ResolvedMethod[] resolveMemberMethods()
     {
@@ -440,6 +424,77 @@ public class ResolvedTypeWithMembers
         }
         return methods.values().toArray(new ResolvedMethod[methods.size()]);
     }
+    
+    /**
+     * Method for fully resolving static field definitions and associated annotations.
+     * Neither field definitions nor associated annotations inherit, but we may
+     * still need to add annotation overrides, as well as filter out filters
+     * and annotations that caller is not interested in.
+     * 
+     * @since 1.2.0
+     */
+    protected ResolvedField[] resolveStaticFields()
+    {
+        // First get static methods for main type, filter
+        LinkedHashMap<String, ResolvedField> fields = new LinkedHashMap<String, ResolvedField>();
+        for (RawField field : _mainType.getType().getStaticFields()) {
+            if (_fieldFilter == null || _fieldFilter.include(field)) {
+                fields.put(field.getName(), resolveField(field));
+            }
+        }
+        // then apply overrides (mix-ins):
+        for (HierarchicType type : overridesOnly()) {
+            for (RawField raw : type.getType().getStaticFields()) {
+                ResolvedField field = fields.get(raw.getName()); 
+                // must override something, otherwise to ignore
+                if (field != null) {
+                    for (Annotation ann : raw.getAnnotations()) {
+                        if (_annotationHandler.includeFieldAnnotation(ann)) {
+                            field.applyOverride(ann);
+                        }
+                    }
+                }
+            }
+        }
+        // and that's it?
+        if (fields.isEmpty()) {
+            return NO_RESOLVED_FIELDS;
+        }
+        return fields.values().toArray(new ResolvedField[ fields.size()]);
+    }
+
+    /**
+     * Method that will actually resolve full information (types, annotations)
+     * for static methods, using configured filter.
+     */
+    protected ResolvedMethod[] resolveStaticMethods()
+    {
+        // First get static methods for main type, filter
+        LinkedHashMap<MethodKey, ResolvedMethod> methods = new LinkedHashMap<MethodKey, ResolvedMethod>();
+        for (RawMethod method : _mainType.getType().getStaticMethods()) {
+            if (_methodFilter == null || _methodFilter.include(method)) {
+                methods.put(method.createKey(), resolveMethod(method));
+            }
+        }
+        // then apply overrides (mix-ins):
+        for (HierarchicType type : overridesOnly()) {
+            for (RawMethod raw : type.getType().getStaticMethods()) {
+                ResolvedMethod method = methods.get(raw.createKey()); 
+                // must override something, otherwise to ignore
+                if (method != null) {
+                    for (Annotation ann : raw.getAnnotations()) {
+                        if (_annotationHandler.includeMethodAnnotation(ann)) {
+                            method.applyOverride(ann);
+                        }
+                    }
+                }
+            }
+        }
+        if (methods.size() == 0) {
+            return NO_RESOLVED_METHODS;
+        }
+        return methods.values().toArray(new ResolvedMethod[methods.size()]);
+    }
 
     /*
     /**********************************************************************
diff --git a/src/main/java/com/fasterxml/classmate/TypeResolver.java b/src/main/java/com/fasterxml/classmate/TypeResolver.java
index 87e015b..acd3c67 100644
--- a/src/main/java/com/fasterxml/classmate/TypeResolver.java
+++ b/src/main/java/com/fasterxml/classmate/TypeResolver.java
@@ -36,7 +36,7 @@ public class TypeResolver implements Serializable
      * pre-create type for <code>java.lang.Object</code>
      */
     private final static ResolvedObjectType sJavaLangObject =
-        new ResolvedObjectType(Object.class, null, null, NO_TYPES);
+        ResolvedObjectType.create(Object.class, null, null, null);
 
     /**
      * Since number of primitive types is small, and they are frequently needed,
diff --git a/src/main/java/com/fasterxml/classmate/types/ResolvedObjectType.java b/src/main/java/com/fasterxml/classmate/types/ResolvedObjectType.java
index cf09b0c..28f35e8 100644
--- a/src/main/java/com/fasterxml/classmate/types/ResolvedObjectType.java
+++ b/src/main/java/com/fasterxml/classmate/types/ResolvedObjectType.java
@@ -96,6 +96,12 @@ public class ResolvedObjectType extends ResolvedType
     {
         this(erased, bindings, (ResolvedType) superClass, interfaces);
     }
+
+    public static ResolvedObjectType create(Class<?> erased, TypeBindings bindings,
+            ResolvedType superClass, List<ResolvedType> interfaces)
+    {
+        return new ResolvedObjectType(erased, bindings, superClass, interfaces);
+    }
     
     @Override
     public boolean canCreateSubtypes() {
diff --git a/src/test/java/com/fasterxml/classmate/TestMemberResolver.java b/src/test/java/com/fasterxml/classmate/TestMemberResolver.java
index 0e4015e..ce763da 100644
--- a/src/test/java/com/fasterxml/classmate/TestMemberResolver.java
+++ b/src/test/java/com/fasterxml/classmate/TestMemberResolver.java
@@ -39,7 +39,7 @@ public class TestMemberResolver extends BaseTest
 
         protected String stringField;
 
-        protected static int staticIntField2;
+        protected static int staticIntFieldSub;
         
         public SubClass() { super(""); }
 
@@ -168,6 +168,10 @@ public class TestMemberResolver extends BaseTest
 
         ResolvedConstructor[] ctors = bean.getConstructors();
         assertEquals(2, ctors.length);
+
+        ResolvedField[] staticFields = bean.getStaticFields();
+        assertEquals(1, staticFields.length);
+        assertEquals("staticIntField", staticFields[0].getName());
     }
     
     /**
@@ -358,10 +362,15 @@ public class TestMemberResolver extends BaseTest
     {
         ResolvedMethod[] statics = bean.getStaticMethods();
         assertEquals(0, statics.length);
-        
+
         ResolvedMethod[] members = bean.getMemberMethods();
         assertEquals(2, members.length);
 
+        // Subtype has 1 static, base 1; only one from sub-type should be included
+        ResolvedField[] staticFields = bean.getStaticFields();
+        assertEquals(1, staticFields.length);
+        assertEquals("staticIntFieldSub", staticFields[0].getName());
+        
         ResolvedField[] fields = bean.getMemberFields();
         assertEquals(3, fields.length);
 
