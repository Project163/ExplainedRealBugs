diff --git a/VERSION.txt b/VERSION.txt
index 8823fcf..d8e0737 100644
--- a/VERSION.txt
+++ b/VERSION.txt
@@ -3,6 +3,11 @@ Java ClassMate project: licensed under Apache License 2.0
 
 Release notes:
 
+1.3.2 (not yet released)
+
+#30: ArrayIndexOutOfBoundsException when resolving Object.class
+ (reported by meszibalu@github)
+
 1.3.1 (25-Oct-2015)
 
 - Fix a problem with caching of subtype-extended types, causing problems
diff --git a/src/main/java/com/fasterxml/classmate/GenericType.java b/src/main/java/com/fasterxml/classmate/GenericType.java
index be7bad4..2a076ad 100644
--- a/src/main/java/com/fasterxml/classmate/GenericType.java
+++ b/src/main/java/com/fasterxml/classmate/GenericType.java
@@ -11,9 +11,9 @@ import java.io.Serializable;
  * >http://gafter.blogspot.com/2006/12/super-type-tokens.html</a>,
  *<p>
  * Usage is by sub-classing: here is one way to instantiate reference
- * to generic type <code>List&lt;Integer></code>:
+ * to generic type <code>List&lt;Integer&gt;</code>:
  *<pre>
- *  GenericType type = new GenericType&lt;List&lt;Integer>>() { };
+ *  GenericType type = new GenericType&lt;List&lt;Integer&gt;&gt;() { };
  *</pre>
  * which can be passed to methods that accept <code>GenericReference</code>.
  */
diff --git a/src/main/java/com/fasterxml/classmate/MemberResolver.java b/src/main/java/com/fasterxml/classmate/MemberResolver.java
index 5579a87..1f0f9c5 100644
--- a/src/main/java/com/fasterxml/classmate/MemberResolver.java
+++ b/src/main/java/com/fasterxml/classmate/MemberResolver.java
@@ -117,17 +117,29 @@ public class MemberResolver implements Serializable
             AnnotationConfiguration annotationConfig,
             AnnotationOverrides annotationOverrides)
     {
-        // First: flatten basic type hierarchy (highest to lowest precedence)
+        List<ResolvedType> types = new ArrayList<ResolvedType>();
         HashSet<ClassKey> seenTypes = new HashSet<ClassKey>();
-        ArrayList<ResolvedType> types = new ArrayList<ResolvedType>();
-        _gatherTypes(mainType, seenTypes, types);
+
+        // First: flatten basic type hierarchy (highest to lowest precedence)
+        
+        // 09-May-2016, tatu: Special case, from [#30] is that of `Object.class`, which
+        //   by default settings has no parentage. Not 100% sure this is proper fix, but
+        //   it does take care of the immediate problem.
+        if (!_cfgIncludeLangObject && (mainType.getErasedType() == Object.class)) {
+            types = new ArrayList<ResolvedType>(1);
+            types.add(mainType);
+            seenTypes.add(new ClassKey(Object.class));
+        } else {
+            types = new ArrayList<ResolvedType>();
+            _gatherTypes(mainType, seenTypes, types);
+        }
 
         // Second step: inject mix-ins (keeping order from highest to lowest)
         HierarchicType[] htypes;
         HierarchicType mainHierarchicType = null;
-
+        
         // Third step: add mix-ins (if any), reverse order (lowest to highest precedence)
-        if (annotationOverrides == null) { // just create hierarchic instances:
+        if (annotationOverrides == null) { // just create hierarchic instances
             int len = types.size();
             htypes = new HierarchicType[len];
             for (int i = 0; i < len; ++i) {
@@ -156,8 +168,8 @@ public class MemberResolver implements Serializable
             htypes = typesWithMixins.toArray(new HierarchicType[typesWithMixins.size()]);
         }
         // And that's about all we need to do; rest computed lazily
-        return new ResolvedTypeWithMembers(_typeResolver, annotationConfig, mainHierarchicType, htypes,
-                _constructorFilter, _fieldFilter, _methodFilter);
+        return new ResolvedTypeWithMembers(_typeResolver, annotationConfig, mainHierarchicType,
+                htypes, _constructorFilter, _fieldFilter, _methodFilter);
     }
 
     private void _addOverrides(List<HierarchicType> typesWithOverrides, Set<ClassKey> seenTypes, Class<?> override)
@@ -201,7 +213,8 @@ public class MemberResolver implements Serializable
     /**********************************************************************
      */
     
-    protected void _gatherTypes(ResolvedType currentType, Set<ClassKey> seenTypes, List<ResolvedType> types)
+    protected void _gatherTypes(ResolvedType currentType, Set<ClassKey> seenTypes,
+            List<ResolvedType> types)
     {
         // may get called with null if no parent type
         if (currentType == null) {
@@ -209,7 +222,7 @@ public class MemberResolver implements Serializable
         }
         Class<?> raw = currentType.getErasedType();
         // Also, don't include Object.class unless that's ok
-        if (!_cfgIncludeLangObject && raw == Object.class) {
+        if (!_cfgIncludeLangObject && (raw == Object.class)) {
             return;
         }
         // Finally, only include first instance of an interface, so:
diff --git a/src/main/java/com/fasterxml/classmate/ResolvedType.java b/src/main/java/com/fasterxml/classmate/ResolvedType.java
index 5ca02c9..77465d0 100644
--- a/src/main/java/com/fasterxml/classmate/ResolvedType.java
+++ b/src/main/java/com/fasterxml/classmate/ResolvedType.java
@@ -60,7 +60,7 @@ public abstract class ResolvedType
      */
     
     /**
-     * Returns type-erased Class<?> that this resolved type has.
+     * Returns type-erased Class&lt;?&gt; that this resolved type has.
      */
     public Class<?> getErasedType() { return _erasedType; }
 
@@ -76,7 +76,7 @@ public abstract class ResolvedType
     /**
      * Accessor that must be used to find out actual type in
      * case of "self-reference"; case where type refers
-     * recursive to itself (like, <code>T implements Comparable&lt;T></code>).
+     * recursive to itself (like, <code>T implements Comparable&lt;T&gt;</code>).
      * For all other types returns null but for self-references "real" type.
      * Separate accessor is provided to avoid accidental infinite loops.
      */
diff --git a/src/main/java/com/fasterxml/classmate/ResolvedTypeWithMembers.java b/src/main/java/com/fasterxml/classmate/ResolvedTypeWithMembers.java
index 15cb61f..6620e0e 100644
--- a/src/main/java/com/fasterxml/classmate/ResolvedTypeWithMembers.java
+++ b/src/main/java/com/fasterxml/classmate/ResolvedTypeWithMembers.java
@@ -28,7 +28,7 @@ public class ResolvedTypeWithMembers
     private final static ResolvedMethod[] NO_RESOLVED_METHODS = new ResolvedMethod[0];
     private final static ResolvedField[] NO_RESOLVED_FIELDS = new ResolvedField[0];
     private final static ResolvedConstructor[] NO_RESOLVED_CONSTRUCTORS = new ResolvedConstructor[0];
-    
+
     /**
      * Default annotation configuration is to ignore all annotations types.
      */
@@ -44,7 +44,7 @@ public class ResolvedTypeWithMembers
      * Handler for resolving annotation information
      */
     protected final AnnotationHandler _annotationHandler;
-    
+
     /**
      * Leaf of the type hierarchy, i.e. type from which this hierarchy
      * was generated.
@@ -66,12 +66,12 @@ public class ResolvedTypeWithMembers
      * Filter to use for selecting constructors to include
      */
     protected Filter<RawConstructor> _constructorFilter;
-    
+
     /**
      * Filter to use for selecting methods to include
      */
     protected Filter<RawMethod> _methodFilter;
-    
+
     /*
     /**********************************************************************
     /* Lazily constructed members
@@ -93,7 +93,7 @@ public class ResolvedTypeWithMembers
     /* Life cycle at this point
     /**********************************************************************
      */
-    
+
     public ResolvedTypeWithMembers(TypeResolver typeResolver, AnnotationConfiguration annotationConfig,
             HierarchicType mainType, HierarchicType[] types,
             Filter<RawConstructor> constructorFilter, Filter<RawField> fieldFilter, Filter<RawMethod> methodFilter)
diff --git a/src/main/java/com/fasterxml/classmate/TypeResolver.java b/src/main/java/com/fasterxml/classmate/TypeResolver.java
index 9e577f1..da798a0 100644
--- a/src/main/java/com/fasterxml/classmate/TypeResolver.java
+++ b/src/main/java/com/fasterxml/classmate/TypeResolver.java
@@ -94,7 +94,7 @@ public class TypeResolver implements Serializable
      *</pre>
      * which would be equivalent to
      *<pre>
-     *  ResolvedType type = TypeResolver.resolve(new GenericType&lt;List&lt;Integer>>() { });
+     *  ResolvedType type = TypeResolver.resolve(new GenericType&lt;List&lt;Integer&gt;&gt;() { });
      *</pre>
      * Note that you can mix different types of type parameters, whether already
      * resolved ({@link ResolvedType}), type-erased ({@link java.lang.Class}) or
@@ -180,7 +180,7 @@ public class TypeResolver implements Serializable
      * (subtype must properly extend or implement specified supertype).
      *<p>
      * A typical use case here is to refine a generic type; for example, given
-     * that we have generic type like <code>List&ltInteger></code>, but we want
+     * that we have generic type like <code>List&lt;Integer&gt;</code>, but we want
      * a more specific implementation type like
      * class <code>ArrayList</code> but with same parameterization (here just <code>Integer</code>),
      * we could achieve it by:
@@ -288,10 +288,12 @@ public class TypeResolver implements Serializable
      */
 
     /**
-     * Helper method that can be used to checked whether given resolved type
+     * Convenience method that can be used to checked whether given resolved type
      * (with erased type of <code>java.lang.Object</code>) is a placeholder
      * for "self-reference"; these are nasty recursive ("self") types
      * needed with some interfaces
+     *
+     * @param type Type to check
      */
     public static boolean isSelfReference(ResolvedType type)
     {
diff --git a/src/test/java/com/fasterxml/classmate/TestMemberResolver.java b/src/test/java/com/fasterxml/classmate/TestMemberResolver.java
index ce763da..38965b1 100644
--- a/src/test/java/com/fasterxml/classmate/TestMemberResolver.java
+++ b/src/test/java/com/fasterxml/classmate/TestMemberResolver.java
@@ -318,7 +318,7 @@ public class TestMemberResolver extends BaseTest
         assertEquals(2, typesWithOverrides.size());
     }
 
-    public void testGatherTypesWithInterfaces() throws IllegalAccessException, InvocationTargetException
+    public void testGatherTypesWithInterfaces() throws Exception
     {
         ResolvedType resolvedType = typeResolver.resolve(MemberResolver.class);
         MemberResolver memberResolver = new MemberResolver(typeResolver);
@@ -352,6 +352,15 @@ public class TestMemberResolver extends BaseTest
         assertEquals(2, types.size());
     }
 
+    public void testJavaLangObject30() throws Exception
+    {
+        MemberResolver memberResolver = new MemberResolver(typeResolver);
+
+        ResolvedType type = typeResolver.resolve(Object.class);
+        ResolvedTypeWithMembers members = memberResolver.resolve(type, null, null);
+        assertNotNull(members);
+    }
+
     /*
     /**********************************************************************
     /* Helper methods
