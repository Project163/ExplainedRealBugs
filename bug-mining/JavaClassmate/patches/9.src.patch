diff --git a/VERSION.txt b/VERSION.txt
index 7c7e5e4..0f6b2c1 100644
--- a/VERSION.txt
+++ b/VERSION.txt
@@ -3,6 +3,11 @@ Java ClassMate project: licensed under Apache License 2.0
 
 Release notes:
 
+1.1.0 (xx-xxx-2014)
+
+#16: ClassCastException in TypeResolver (ResolvedRecursiveType cannot be cast to ResolvedObjectType)
+ (reported by deki@github)
+
 1.0.0 (15-Oct-2013)
 
 The official Big One-Oh version!
diff --git a/src/main/java/com/fasterxml/classmate/TypeResolver.java b/src/main/java/com/fasterxml/classmate/TypeResolver.java
index 488450b..87e015b 100644
--- a/src/main/java/com/fasterxml/classmate/TypeResolver.java
+++ b/src/main/java/com/fasterxml/classmate/TypeResolver.java
@@ -411,15 +411,21 @@ public class TypeResolver implements Serializable
         return resolved;
     }
 
-    private ResolvedObjectType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings typeBindings)
+    /**
+     * NOTE: return type changed in 1.0.1 from {@link ResolvedObjectType} to
+     *    {@link ResolvedType}, since it was found that other types may
+     *    be returned...
+     * 
+     * @return Usually a {@link ResolvedObjectType}, but possibly also
+     *    {@link ResolvedRecursiveType}
+     */
+    private ResolvedType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings typeBindings)
     {
         Type parent = rawType.getGenericSuperclass();
         if (parent == null) {
             return null;
         }
-        ResolvedType rt = _fromAny(context, parent, typeBindings);
-        // can this ever be something other than class? (primitive, array)
-        return (ResolvedObjectType) rt;
+        return _fromAny(context, parent, typeBindings);
     }
     
     private ResolvedType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings)
diff --git a/src/main/java/com/fasterxml/classmate/types/ResolvedObjectType.java b/src/main/java/com/fasterxml/classmate/types/ResolvedObjectType.java
index c6e0278..cf09b0c 100644
--- a/src/main/java/com/fasterxml/classmate/types/ResolvedObjectType.java
+++ b/src/main/java/com/fasterxml/classmate/types/ResolvedObjectType.java
@@ -17,7 +17,13 @@ import com.fasterxml.classmate.members.RawMethod;
  */
 public class ResolvedObjectType extends ResolvedType
 {
-    protected final ResolvedObjectType _superClass;
+    /**
+     * While fundamentally super class has to be {@link ResolvedObjectType}
+     * (or null for {@link java.lang.Object}), we may need to hold on to
+     * a {@link ResolvedRecursiveType} occasionally.
+     */
+    protected final ResolvedType _superClass;
+
     /**
      * List of interfaces this type implements; may be empty but never null
      */
@@ -44,9 +50,9 @@ public class ResolvedObjectType extends ResolvedType
     /* Life cycle
     /**********************************************************************
      */
-
+    
     public ResolvedObjectType(Class<?> erased, TypeBindings bindings,
-            ResolvedObjectType superClass, List<ResolvedType> interfaces)
+            ResolvedType superClass, List<ResolvedType> interfaces)
     {
         this(erased, bindings, superClass,
                 (interfaces == null || interfaces.isEmpty()) ? NO_TYPES :
@@ -54,13 +60,42 @@ public class ResolvedObjectType extends ResolvedType
     }
 
     public ResolvedObjectType(Class<?> erased, TypeBindings bindings,
-            ResolvedObjectType superClass, ResolvedType[] interfaces)
+            ResolvedType superClass, ResolvedType[] interfaces)
     {
         super(erased, bindings);
+        /* 19-Aug-2014, tatu: bit unclean, but has to do for now.
+         *   Problem is, there is no common super-type, nor can we yet
+         *   force or coerce recursive types. Rather, they may only get
+         *   resolved only slightly after construction. So... need to
+         *   keep a reference.
+         */
+        if (superClass != null) {
+            if (!(superClass instanceof ResolvedObjectType)
+                    && !(superClass instanceof ResolvedRecursiveType)
+                    ) {
+                throw new IllegalArgumentException("Unexpected parent type for "
+                        +erased.getName()+": "+superClass.getClass().getName());
+            }
+        }
+        
         _superClass = superClass;
         _superInterfaces = (interfaces == null) ? NO_TYPES : interfaces;
         _modifiers = erased.getModifiers();
     }
+
+    @Deprecated // since 1.1; removed from 1.2 -- kept for binary backwards compatibility
+    public ResolvedObjectType(Class<?> erased, TypeBindings bindings,
+            ResolvedObjectType superClass, List<ResolvedType> interfaces)
+    {
+        this(erased, bindings, (ResolvedType) superClass, interfaces);
+    }
+
+    @Deprecated // since 1.1; removed from 1.2 -- kept for binary backwards compatibility
+    public ResolvedObjectType(Class<?> erased, TypeBindings bindings,
+            ResolvedObjectType superClass, ResolvedType[] interfaces)
+    {
+        this(erased, bindings, (ResolvedType) superClass, interfaces);
+    }
     
     @Override
     public boolean canCreateSubtypes() {
@@ -74,7 +109,27 @@ public class ResolvedObjectType extends ResolvedType
      */
 
     @Override
-    public ResolvedObjectType getParentClass() { return _superClass; }
+    public ResolvedObjectType getParentClass() {
+        
+        /* 19-Aug-2014, tatu: Ugly does it... sigh.
+         *   But can't be helped because ResolvedRecursiveType is typically only
+         *   resolved after instances of this type have been constructed.
+         *   This means that resolution will need to be done somewhat dynamically.
+         */
+        if (_superClass == null) {
+            return null;
+        }
+        if (_superClass instanceof ResolvedObjectType) {
+            return (ResolvedObjectType) _superClass;
+        }
+        ResolvedType rt = ((ResolvedRecursiveType) _superClass).getSelfReferencedType();
+        if (!(rt instanceof ResolvedObjectType)) {
+            throw new IllegalStateException("Internal error: self-referential parent type ("
+                    +_superClass+") does not resolve into proper ResolvedObjectType, but instead to: "
+                    +rt);
+        }
+        return (ResolvedObjectType) rt;
+    }
 
     @Override
     public ResolvedType getSelfReferencedType() { return null; }
diff --git a/src/main/java/com/fasterxml/classmate/types/ResolvedRecursiveType.java b/src/main/java/com/fasterxml/classmate/types/ResolvedRecursiveType.java
index de36884..c8d7a18 100644
--- a/src/main/java/com/fasterxml/classmate/types/ResolvedRecursiveType.java
+++ b/src/main/java/com/fasterxml/classmate/types/ResolvedRecursiveType.java
@@ -20,7 +20,7 @@ import com.fasterxml.classmate.members.RawMethod;
 public class ResolvedRecursiveType extends ResolvedType
 {
     /**
-     * Actual fully resolved type; assigned once resultion is complete
+     * Actual fully resolved type; assigned once resolution is complete
      */
     protected ResolvedType _referencedType;
 
diff --git a/src/test/java/com/fasterxml/classmate/ResolvedTypeTest.java b/src/test/java/com/fasterxml/classmate/ResolvedTypeTest.java
index d6cde93..e0a5b92 100644
--- a/src/test/java/com/fasterxml/classmate/ResolvedTypeTest.java
+++ b/src/test/java/com/fasterxml/classmate/ResolvedTypeTest.java
@@ -11,13 +11,16 @@ import java.util.List;
 
 import static junit.framework.Assert.*;
 
-/**
- * User: blangel
- * Date: 4/13/12
- * Time: 4:30 PM
- */
-public class ResolvedTypeTest {
+public class ResolvedTypeTest
+{
+    // For [Issue#16]
 
+    private static class Foo16 extends Bar16 { }
+
+    private static class Bar16 extends Zen16<Bar16, Foo16> { }
+
+    private static class Zen16<A, B extends A>  { }
+    
     @Test
     public void canCreateSubtype() {
         ResolvedObjectType stringType = new ResolvedObjectType(String.class, null, null, ResolvedType.NO_TYPES);
@@ -111,4 +114,31 @@ public class ResolvedTypeTest {
         assertEquals(0, type.getStaticFields().size());
     }
 
+    // For [Issue#16]
+    @Test
+    public void testIssue16()
+    {
+        TypeResolver resolver = new TypeResolver();
+        ResolvedType type = resolver.resolve(Bar16.class);
+        assertNotNull(type);
+
+        // We'll have the "default" constructor so
+        assertEquals(1, type.getConstructors().size());
+        assertEquals(0, type.getMemberFields().size());
+        assertEquals(0, type.getMemberMethods().size());
+        assertEquals(0, type.getStaticMethods().size());
+        assertEquals(0, type.getStaticFields().size());
+
+        assertEquals(Bar16.class, type.getErasedType());
+        ResolvedType parent = type.getParentClass();
+        assertNotNull(parent);
+        assertEquals(Zen16.class, parent.getErasedType());
+
+        List<ResolvedType> params = parent.getTypeParameters();
+        assertNotNull(params);
+        assertEquals(2, params.size());
+
+        assertEquals(Bar16.class, params.get(0).getErasedType());
+        assertEquals(Foo16.class, params.get(1).getErasedType());
+    }
 }
