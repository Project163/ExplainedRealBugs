diff --git a/VERSION.txt b/VERSION.txt
index 8ef1e06..ccaa381 100644
--- a/VERSION.txt
+++ b/VERSION.txt
@@ -6,6 +6,8 @@ Release notes:
 1.3.4 (09-Sep-2017)
 
 #38: Add `Automatic-Module-Name` for JDK9 interoperability
+#40: Make cache used by `TypeResolver` pluggable; offer concurrent
+  variant in addition to LRU
 
 1.3.3 (28-Sep-2016)
 
diff --git a/pom.xml b/pom.xml
index a869978..a809be6 100644
--- a/pom.xml
+++ b/pom.xml
@@ -7,7 +7,7 @@
     </parent>
     <artifactId>classmate</artifactId>
     <name>ClassMate</name>
-    <version>1.3.5-SNAPSHOT</version>
+    <version>1.4.0-SNAPSHOT</version>
     <packaging>bundle</packaging>
     <description>Library for introspecting types with full generic information
         including resolving of field and method types.
@@ -17,8 +17,8 @@
         <connection>scm:git:git@github.com:FasterXML/java-classmate.git</connection>
         <developerConnection>scm:git:git@github.com:FasterXML/java-classmate.git</developerConnection>
         <url>http://github.com/FasterXML/java-classmate</url>
-      <tag>HEAD</tag>
-  </scm>
+	<tag>HEAD</tag>
+    </scm>
     <developers>
         <developer>
             <id>tatu</id>
@@ -44,6 +44,7 @@ com.fasterxml.classmate.*;version=${project.version}
 </osgi.export>
 	<osgi.private>com.fasterxml.classmate.util.*</osgi.private>
 
+	<jdk.module.name>com.fasterxml.classmate</jdk.module.name>
     </properties>
 
     <!-- Licensing -->
@@ -77,7 +78,7 @@ com.fasterxml.classmate.*;version=${project.version}
               <artifactId>maven-bundle-plugin</artifactId>
               <configuration>
 		<instructions combine.children="merge">
-		  <Automatic-Module-Name>com.fasterxml.classmate</Automatic-Module-Name>
+		  <Automatic-Module-Name>${jdk.module.name}</Automatic-Module-Name>
 		</instructions>
               </configuration>
             </plugin>
diff --git a/src/main/java/com/fasterxml/classmate/TypeResolver.java b/src/main/java/com/fasterxml/classmate/TypeResolver.java
index ce9e38a..628ecd8 100644
--- a/src/main/java/com/fasterxml/classmate/TypeResolver.java
+++ b/src/main/java/com/fasterxml/classmate/TypeResolver.java
@@ -7,7 +7,9 @@ import java.util.*;
 import com.fasterxml.classmate.types.*;
 import com.fasterxml.classmate.util.ClassKey;
 import com.fasterxml.classmate.util.ClassStack;
+import com.fasterxml.classmate.util.LRUTypeCache;
 import com.fasterxml.classmate.util.ResolvedTypeCache;
+import com.fasterxml.classmate.util.ResolvedTypeKey;
 
 /**
  * Object that is used for resolving generic type information of a class
@@ -64,20 +66,40 @@ public class TypeResolver implements Serializable
      */
     
     /**
-     * Simple cache of types resolved by this resolved; capped to last 200 resolved types.
+     * Simple cache of types resolved by this resolver.
      * Caching works because type instances themselves are mostly immutable;
      * and properly synchronized in cases where transient data (raw members) are
      * accessed.
      */
-    protected final ResolvedTypeCache _resolvedTypes = new ResolvedTypeCache(200);
+    protected final ResolvedTypeCache _resolvedTypes;
 
     /*
     /**********************************************************************
     /* Life cycle
     /**********************************************************************
      */
-    
-    public TypeResolver() { }
+
+    /**
+     * Constructs type cache; equivalent to:
+     *<pre> 
+     *   TypeResolver(ResolvedTypeCache.lruCache(200));
+     *</pre>
+     */
+    public TypeResolver() {
+        this(ResolvedTypeCache.lruCache(200));
+    }
+
+    /**
+     * Constructor that specifies type cache to use.
+     *
+     * @param typeCache Cache to use for avoiding repeated resolution of already resolved
+     *    types
+     *
+     * @since 1.4
+     */
+    public TypeResolver(ResolvedTypeCache typeCache) {
+        _resolvedTypes = typeCache;
+    }
 
     /*
     /**********************************************************************
@@ -354,7 +376,7 @@ public class TypeResolver implements Serializable
 
         // If not, already recently resolved?
         ResolvedType[] typeParameters = typeBindings.typeParameterArray();
-        ResolvedTypeCache.Key key = _resolvedTypes.key(rawType, typeParameters);
+        ResolvedTypeKey key = _resolvedTypes.key(rawType, typeParameters);
         // 25-Oct-2015, tatu: one twist; if any TypePlaceHolders included, key will NOT be created,
         //   which means that caching should not be used (since type is mutable)
         if (key == null) {
diff --git a/src/main/java/com/fasterxml/classmate/util/ConcurrentTypeCache.java b/src/main/java/com/fasterxml/classmate/util/ConcurrentTypeCache.java
new file mode 100644
index 0000000..72013e4
--- /dev/null
+++ b/src/main/java/com/fasterxml/classmate/util/ConcurrentTypeCache.java
@@ -0,0 +1,68 @@
+package com.fasterxml.classmate.util;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+import com.fasterxml.classmate.ResolvedType;
+
+/**
+ * Alternative {@link ResolvedTypeCache} implementation that uses
+ * {@link ConcurrentHashMap} for efficient concurrent access and limits maximum
+ * entry count to specified maximum. But instead of trying to optimize retention
+ * by access (as {@link LRUTypeCache} does, will simply clear (remove all entries)
+ * if maximum size is reached. This works well as long as maximum size is large enough
+ * to cover most commonly resolved types, and works well for higher concurrency use
+ * cases.
+ * 
+ * @see LRUTypeCache
+ */
+public class ConcurrentTypeCache
+    extends ResolvedTypeCache
+{
+    private static final long serialVersionUID = 1L;
+
+    protected final int _maxEntries;
+
+    protected final transient ConcurrentHashMap<ResolvedTypeKey, ResolvedType> _map;
+
+    public ConcurrentTypeCache(int maxEntries) {
+        // We'll use concurrency level of 4, seems reasonable
+        _map = new ConcurrentHashMap<ResolvedTypeKey, ResolvedType>(maxEntries,
+                0.8f, 4);
+        _maxEntries = maxEntries;
+    }
+
+    // For JDK serialization: have to re-construct backing Map since it is NOT serialized
+    Object readResolve() {
+        return new ConcurrentTypeCache(_maxEntries);
+    }
+
+    @Override
+    public ResolvedType find(ResolvedTypeKey key) {
+        if (key == null) {
+            throw new IllegalArgumentException("Null key not allowed");
+        }
+        return _map.get(key);
+    }
+
+    @Override
+    public int size() {
+        return _map.size();
+    }
+    
+    @Override
+    public void put(ResolvedTypeKey key, ResolvedType type) {
+        if (key == null) {
+            throw new IllegalArgumentException("Null key not allowed");
+        }
+        if (_map.size() >= _maxEntries) {
+            // double-locking, yes, but safe here; trying to avoid "clear storms"
+            // when multiple threads think they are to flush the cache
+            synchronized (this) {
+                if (_map.size() >= _maxEntries) {
+                    _map.clear();
+                }
+            }
+        }
+        _map.put(key, type);
+    }
+}
diff --git a/src/main/java/com/fasterxml/classmate/util/LRUTypeCache.java b/src/main/java/com/fasterxml/classmate/util/LRUTypeCache.java
new file mode 100644
index 0000000..502ad4c
--- /dev/null
+++ b/src/main/java/com/fasterxml/classmate/util/LRUTypeCache.java
@@ -0,0 +1,88 @@
+package com.fasterxml.classmate.util;
+
+import java.util.*;
+
+import com.fasterxml.classmate.ResolvedType;
+
+/**
+ * Simple cache used for storing up to specified number of most recently accessed
+ * {@link ResolvedType} instances. Uses "least-recently used" eviction algorithm
+ * (via {@link LinkedHashMap} used internally) which optimized retention, but
+ * requires full synchronization as read operation also has to modify internal state
+ * to maintain LRU aspects.
+ * This means that it works well in optimizing access patterns, by keeping most recently
+ * accessed types in cache, but may not well work well for highly concurrent cases due
+ * to synchronization overhead.
+ *<p>
+ * Like all {@link ResolvedTypeCache} implementations,
+ * access is thread-safe and caller need not (and should not) use additional synchronization.
+ *<p>
+ *
+ * @see ConcurrentTypeCache
+ *
+ * @since 1.4
+ */
+public class LRUTypeCache extends ResolvedTypeCache
+{
+    private static final long serialVersionUID = 1L;
+
+    protected final int _maxEntries;
+
+    protected final transient CacheMap _map;
+
+    public LRUTypeCache(int maxEntries) {
+        _map = new CacheMap(maxEntries);
+        _maxEntries = maxEntries;
+    }
+
+    // For JDK serialization: have to re-construct backing Map since it is NOT serialized
+    Object readResolve() {
+        return new LRUTypeCache(_maxEntries);
+    }
+
+    @Override
+    public synchronized ResolvedType find(ResolvedTypeKey key) {
+        if (key == null) {
+            throw new IllegalArgumentException("Null key not allowed");
+        }
+        return _map.get(key);
+    }
+
+    @Override
+    public synchronized int size() {
+        return _map.size();
+    }
+    
+    @Override
+    public synchronized void put(ResolvedTypeKey key, ResolvedType type) {
+        if (key == null) {
+            throw new IllegalArgumentException("Null key not allowed");
+        }
+        _map.put(key, type);
+    }
+
+    /*
+    /**********************************************************************
+    /* Helper classes
+    /**********************************************************************
+     */
+
+    /**
+     * Simple sub-class to get LRU cache
+     */
+    @SuppressWarnings("serial")
+    private final static class CacheMap
+        extends LinkedHashMap<ResolvedTypeKey, ResolvedType>
+    {
+        protected final int _maxEntries;
+        
+        public CacheMap(int maxEntries) {
+            _maxEntries = maxEntries;
+        }
+
+        @Override
+        protected boolean removeEldestEntry(Map.Entry<ResolvedTypeKey, ResolvedType> eldest) {
+            return size() > _maxEntries;
+        }
+    }
+}
diff --git a/src/main/java/com/fasterxml/classmate/util/ResolvedTypeCache.java b/src/main/java/com/fasterxml/classmate/util/ResolvedTypeCache.java
index 753422a..0e15c9f 100644
--- a/src/main/java/com/fasterxml/classmate/util/ResolvedTypeCache.java
+++ b/src/main/java/com/fasterxml/classmate/util/ResolvedTypeCache.java
@@ -1,7 +1,7 @@
 package com.fasterxml.classmate.util;
 
 import java.io.Serializable;
-import java.util.*;
+import java.util.List;
 
 import com.fasterxml.classmate.ResolvedType;
 import com.fasterxml.classmate.types.TypePlaceHolder;
@@ -13,28 +13,36 @@ import com.fasterxml.classmate.types.TypePlaceHolder;
  * are fully synchronized so that caller need not do explicit synchronization.
  */
 @SuppressWarnings("serial")
-public class ResolvedTypeCache implements Serializable
+public abstract class ResolvedTypeCache implements Serializable
 {
-    protected final CacheMap _map;
-    
-    public ResolvedTypeCache(int maxEntries) {
-        _map = new CacheMap(maxEntries);
+    /**
+     * @since 1.4
+     */
+    public static ResolvedTypeCache lruCache(int maxEntries) {
+        return new LRUTypeCache(maxEntries);
+    }
+
+    /**
+     * @since 1.4
+     */
+    public static ResolvedTypeCache concurrentCache(int maxEntries) {
+        return new ConcurrentTypeCache(maxEntries);
     }
 
     /**
      * Helper method for constructing reusable cache keys
      */
-    public Key key(Class<?> simpleType) {
-        return new Key(simpleType);
+    public ResolvedTypeKey key(Class<?> simpleType) {
+        return new ResolvedTypeKey(simpleType);
     }
 
     /**
      * Helper method for constructing reusable cache keys
      */
-    public Key key(Class<?> simpleType, ResolvedType[] tp) {
+    public ResolvedTypeKey key(Class<?> simpleType, ResolvedType[] tp) {
         int len = (tp == null) ? 0 : tp.length;
         if (len == 0) {
-            return new Key(simpleType);
+            return new ResolvedTypeKey(simpleType);
         }
         // 25-Oct-2015, tatu: Need to prevent caching of anything with TypePlaceHolder;
         //   can cause problems otherwise as those are ephemeral/mutable containers
@@ -43,136 +51,24 @@ public class ResolvedTypeCache implements Serializable
                 return null;
             }
         }
-        return new Key(simpleType, tp);
-    }
-    
-    public synchronized ResolvedType find(Key key) {
-        if (key == null) {
-            throw new IllegalArgumentException("Null key not allowed");
-        }
-        return _map.get(key);
+        return new ResolvedTypeKey(simpleType, tp);
     }
 
-    public synchronized int size() {
-        return _map.size();
-    }
-    
-    public synchronized void put(Key key, ResolvedType type) {
-        if (key == null) {
-            throw new IllegalArgumentException("Null key not allowed");
-        }
-        _map.put(key, type);
-    }
+    public abstract ResolvedType find(ResolvedTypeKey key);
 
-    /*
-    /**********************************************************************
-    /* Methods for unit tests
-    /**********************************************************************
-     */
+    public abstract int size();
+
+    public abstract void put(ResolvedTypeKey key, ResolvedType type);
+
+    // // // Methods for unit tests
 
     /**
      * Method only used by test code: do not use otherwise.
      */
-    protected void addForTest(ResolvedType type)
+    protected void _addForTest(ResolvedType type)
     {
         List<ResolvedType> tp = type.getTypeParameters();
         ResolvedType[] tpa = tp.toArray(new ResolvedType[tp.size()]);
         put(key(type.getErasedType(), tpa), type);
     }
-    
-    /*
-    /**********************************************************************
-    /* Helper classes
-    /**********************************************************************
-     */
-    
-    /**
-     * Key used for type entries.
-     */
-    public static class Key
-    {
-        private final Class<?> _erasedType;
-        private final ResolvedType[] _typeParameters;
-        private final int _hashCode;
-
-        public Key(Class<?> simpleType) {
-            this(simpleType, null);
-        }
-        
-        public Key(Class<?> erasedType, ResolvedType[] tp)
-        {
-            // let's not hold on type empty arrays
-            if (tp != null && tp.length == 0) {
-                tp = null;
-            }
-            _erasedType = erasedType;
-            _typeParameters = tp;
-            int h = erasedType.getName().hashCode();
-            if (tp != null) {
-                h += tp.length;
-            }
-            _hashCode = h;
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append("[CacheKey: ");
-            sb.append(_erasedType.getName())
-                .append('(');
-            if (_typeParameters != null) {
-                for (int i = 0; i < _typeParameters.length; ++i) {
-                    if (i > 0) {
-                        sb.append(',');
-                    }
-                    sb.append(_typeParameters[i]);
-                }
-            }
-            sb.append(")]");
-            return sb.toString();
-        }
-        
-        @Override
-        public int hashCode() { return _hashCode; }
-
-        @Override
-        public boolean equals(Object o)
-        {
-            if (o == this) return true;
-            if (o == null || o.getClass() != getClass()) return false;
-            Key other = (Key) o;
-            if (other._erasedType != _erasedType) return false;
-            ResolvedType[] otherTP = other._typeParameters;
-            if (_typeParameters == null) {
-                return (otherTP == null);
-            }
-            if (otherTP == null || otherTP.length != _typeParameters.length) {
-                return false;
-            }
-            for (int i = 0, len = _typeParameters.length; i < len; ++i) {
-                if (!_typeParameters[i].equals(otherTP[i])) {
-                    return false;
-                }
-            }
-            return true;
-        }
-    }
-
-    /**
-     * Simple sub-class to get LRU cache
-     */
-    private final static class CacheMap
-        extends LinkedHashMap<ResolvedTypeCache.Key, ResolvedType>
-    {
-        protected final int _maxEntries;
-        
-        public CacheMap(int maxEntries) {
-            _maxEntries = maxEntries;
-        }
-
-        @Override
-        protected boolean removeEldestEntry(Map.Entry<Key, ResolvedType> eldest) {
-            return size() > _maxEntries;
-        }
-    }
 }
diff --git a/src/main/java/com/fasterxml/classmate/util/ResolvedTypeKey.java b/src/main/java/com/fasterxml/classmate/util/ResolvedTypeKey.java
new file mode 100644
index 0000000..f5b7bb5
--- /dev/null
+++ b/src/main/java/com/fasterxml/classmate/util/ResolvedTypeKey.java
@@ -0,0 +1,75 @@
+package com.fasterxml.classmate.util;
+
+import com.fasterxml.classmate.ResolvedType;
+
+/**
+ * Key used for entries cached in a {@link ResolvedTypeCache}.
+ */
+public class ResolvedTypeKey
+{
+    private final Class<?> _erasedType;
+    private final ResolvedType[] _typeParameters;
+    private final int _hashCode;
+
+    public ResolvedTypeKey(Class<?> simpleType) {
+        this(simpleType, null);
+    }
+    
+    public ResolvedTypeKey(Class<?> erasedType, ResolvedType[] tp)
+    {
+        // let's not hold on type empty arrays
+        if (tp != null && tp.length == 0) {
+            tp = null;
+        }
+        _erasedType = erasedType;
+        _typeParameters = tp;
+        int h = erasedType.getName().hashCode();
+        if (tp != null) {
+            h += tp.length;
+        }
+        _hashCode = h;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("[CacheKey: ");
+        sb.append(_erasedType.getName())
+            .append('(');
+        if (_typeParameters != null) {
+            for (int i = 0; i < _typeParameters.length; ++i) {
+                if (i > 0) {
+                    sb.append(',');
+                }
+                sb.append(_typeParameters[i]);
+            }
+        }
+        sb.append(")]");
+        return sb.toString();
+    }
+    
+    @Override
+    public int hashCode() { return _hashCode; }
+
+    @Override
+    public boolean equals(Object o)
+    {
+        if (o == this) return true;
+        if (o == null || o.getClass() != getClass()) return false;
+        ResolvedTypeKey other = (ResolvedTypeKey) o;
+        if (other._erasedType != _erasedType) return false;
+        ResolvedType[] otherTP = other._typeParameters;
+        if (_typeParameters == null) {
+            return (otherTP == null);
+        }
+        if (otherTP == null || otherTP.length != _typeParameters.length) {
+            return false;
+        }
+        for (int i = 0, len = _typeParameters.length; i < len; ++i) {
+            if (!_typeParameters[i].equals(otherTP[i])) {
+                return false;
+            }
+        }
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/com/fasterxml/classmate/TestTypeResolver.java b/src/test/java/com/fasterxml/classmate/TestTypeResolver.java
index 758f7a4..b2c0405 100644
--- a/src/test/java/com/fasterxml/classmate/TestTypeResolver.java
+++ b/src/test/java/com/fasterxml/classmate/TestTypeResolver.java
@@ -7,7 +7,7 @@ import com.fasterxml.classmate.members.RawMethod;
 import com.fasterxml.classmate.members.ResolvedMethod;
 import com.fasterxml.classmate.types.*;
 import com.fasterxml.classmate.util.ClassKey;
-import com.fasterxml.classmate.util.ResolvedTypeCache;
+import com.fasterxml.classmate.util.ResolvedTypeKey;
 
 @SuppressWarnings("serial")
 public class TestTypeResolver extends BaseTest
@@ -378,7 +378,7 @@ public class TestTypeResolver extends BaseTest
         }
         // add a mock class to force 'internal-error' case
         Object subclass = new Object() { };
-        typeResolver._resolvedTypes.put(new ResolvedTypeCache.Key(subclass.getClass()), new ResolvedObjectType(subclass.getClass(), null, (ResolvedType) null, ResolvedType.NO_TYPES) {
+        typeResolver._resolvedTypes.put(new ResolvedTypeKey(subclass.getClass()), new ResolvedObjectType(subclass.getClass(), null, (ResolvedType) null, ResolvedType.NO_TYPES) {
             @Override public ResolvedType findSupertype(Class<?> erasedSupertype) {
                 return null;
             }
@@ -395,7 +395,7 @@ public class TestTypeResolver extends BaseTest
         subclass = new Params<Object>();
         final ResolvedType finalSuperType = supertype;
         TypeBindings typeBindings = TypeBindings.emptyBindings(); // force failure of parameter resolution
-        typeResolver._resolvedTypes.put(new ResolvedTypeCache.Key(subclass.getClass()), new ResolvedObjectType(subclass.getClass(),
+        typeResolver._resolvedTypes.put(new ResolvedTypeKey(subclass.getClass()), new ResolvedObjectType(subclass.getClass(),
                 typeBindings, (ResolvedType) null, ResolvedType.NO_TYPES) {
             @Override public ResolvedType findSupertype(Class<?> erasedSupertype) {
                 return finalSuperType;
diff --git a/src/test/java/com/fasterxml/classmate/TypeBindingsTest.java b/src/test/java/com/fasterxml/classmate/TypeBindingsTest.java
index a881f77..9da1422 100644
--- a/src/test/java/com/fasterxml/classmate/TypeBindingsTest.java
+++ b/src/test/java/com/fasterxml/classmate/TypeBindingsTest.java
@@ -88,7 +88,8 @@ public class TypeBindingsTest
         assertFalse(instance.equals(null));
 
         // test different classes
-        assertFalse(instance.equals("not a TypeBindings"));
+        Object strKey = "not a TypeBindings";
+        assertFalse(instance.equals(strKey));
 
         // test no types
         TypeBindings instance1 = TypeBindings.create(Object.class, (List<ResolvedType>) null);
diff --git a/src/test/java/com/fasterxml/classmate/util/TestResolvedTypeCache.java b/src/test/java/com/fasterxml/classmate/util/TestResolvedTypeCache.java
index 35f944d..475ad50 100644
--- a/src/test/java/com/fasterxml/classmate/util/TestResolvedTypeCache.java
+++ b/src/test/java/com/fasterxml/classmate/util/TestResolvedTypeCache.java
@@ -12,51 +12,73 @@ import java.util.Set;
 
 public class TestResolvedTypeCache extends TestCase
 {
-
-    private static class KeySubclass extends ResolvedTypeCache.Key {
+    private static class KeySubclass extends ResolvedTypeKey {
         private KeySubclass(Class<?> simpleType) {
             super(simpleType);
         }
     }
 
-    public void testSimpleCaching()
+    public void testSimpleLRUCaching()
+    {
+        LRUTypeCache cache = (LRUTypeCache) ResolvedTypeCache.lruCache(2);
+        _testSimple(cache, true);
+    }
+
+    public void testSimpleConcurrentCaching()
     {
-        ResolvedTypeCache cache = new ResolvedTypeCache(2);
+        ConcurrentTypeCache cache = (ConcurrentTypeCache) ResolvedTypeCache.concurrentCache(2);
+        _testSimple(cache, false);
+    }
+
+    private void _testSimple(ResolvedTypeCache cache, boolean lru) {
         assertEquals(0, cache.size());
         // bogus, just needed for testing:
         ResolvedType type1 = new ResolvedInterfaceType(Map.class, null, null);
-        cache.addForTest(type1);
+        cache._addForTest(type1);
         assertEquals(1, cache.size());
         // re-adding won't change anything:
-        cache.addForTest(type1);
+        cache._addForTest(type1);
         assertEquals(1, cache.size());
         ResolvedType type2 = new ResolvedInterfaceType(Set.class, null, null);
-        cache.addForTest(type2);
+        cache._addForTest(type2);
         assertEquals(2, cache.size());
         ResolvedType type3 = new ResolvedInterfaceType(List.class, null, null);
-        cache.addForTest(type3);
-        assertEquals(2, cache.size());
+        cache._addForTest(type3);
+
+        // when full, behavior varies
+        if (lru) {
+            // will just replace oldest
+            assertEquals(2, cache.size());
+        } else {
+            assertEquals(1, cache.size());
+        }
 
         // should now only have types 2 and 3 available
         ResolvedType found1 = cache.find(cache.key(Map.class));
         ResolvedType found2 = cache.find(cache.key(Set.class));
         ResolvedType found3 = cache.find(cache.key(List.class));
+
         assertNull(found1);
-        assertSame(type2, found2);
-        assertSame(type3, found3);
+        if (lru) {
+            assertSame(type2, found2);
+            assertSame(type3, found3);
+        } else {
+            assertNull(found2);
+            assertSame(type3, found3);
+        }
     }
-
+    
     @SuppressWarnings("unused")
-    public void testKeyEquals() {
-
+    public void testKeyEquals()
+    {
         try {
-            new ResolvedTypeCache.Key(null);
+            new ResolvedTypeKey(null);
             fail("Expecting a NullPointerException.");
         } catch (NullPointerException npe) {
             // expected
         }
 
-        ResolvedTypeCache.Key key = new ResolvedTypeCache.Key(String.class);
+        ResolvedTypeKey key = new ResolvedTypeKey(String.class);
 
         // test referential equality
         assertTrue(key.equals(key));
@@ -65,48 +87,48 @@ public class TestResolvedTypeCache extends TestCase
         assertFalse(key.equals(null));
 
         // test unequal class
-        assertFalse(key.equals("test"));
+        Object strKey = "test";
+        assertFalse(key.equals(strKey));
 
         // test subclass
         assertFalse(key.equals(new KeySubclass(String.class)));
 
         // test unequal resolve-class
-        ResolvedTypeCache.Key key1 = new ResolvedTypeCache.Key(Object.class);
+        ResolvedTypeKey key1 = new ResolvedTypeKey(Object.class);
         assertFalse(key.equals(key1));
 
         // test equal resolve-class
-        ResolvedTypeCache.Key key2 = new ResolvedTypeCache.Key(String.class);
+        ResolvedTypeKey key2 = new ResolvedTypeKey(String.class);
         assertTrue(key.equals(key2));
 
         // test equal, 0-length resolved-type array change to null
-        ResolvedTypeCache.Key key3 = new ResolvedTypeCache.Key(String.class, new ResolvedType[] {  });
+        ResolvedTypeKey key3 = new ResolvedTypeKey(String.class, new ResolvedType[] {  });
         assertTrue(key.equals(key3));
 
         // test unequal, null other type-parameters
-        ResolvedTypeCache.Key key4 = new ResolvedTypeCache.Key(String.class, new ResolvedType[] { ResolvedObjectType.create(String.class, null, null, null)} );
+        ResolvedTypeKey key4 = new ResolvedTypeKey(String.class, new ResolvedType[] { ResolvedObjectType.create(String.class, null, null, null)} );
         assertFalse(key.equals(key4));
         assertFalse(key4.equals(key));
 
         // test unequal, type-parameters length
-        ResolvedTypeCache.Key key5 = new ResolvedTypeCache.Key(String.class, new ResolvedType[] {
+        ResolvedTypeKey key5 = new ResolvedTypeKey(String.class, new ResolvedType[] {
                 ResolvedObjectType.create(String.class, null, null, null),
                 ResolvedObjectType.create(Object.class, null, null, null)
         });
         assertFalse(key4.equals(key5));
 
         // test unequal type-parameters
-        ResolvedTypeCache.Key key6 = new ResolvedTypeCache.Key(String.class, new ResolvedType[] {
+        ResolvedTypeKey key6 = new ResolvedTypeKey(String.class, new ResolvedType[] {
                 ResolvedObjectType.create(Object.class, null, null, null),
                 ResolvedObjectType.create(String.class, null, null, null)
         });
         assertFalse(key5.equals(key6));
 
         // test equal type-parameters
-        ResolvedTypeCache.Key key7 = new ResolvedTypeCache.Key(String.class, new ResolvedType[] {
+        ResolvedTypeKey key7 = new ResolvedTypeKey(String.class, new ResolvedType[] {
                 ResolvedObjectType.create(Object.class, null, null, null),
                 ResolvedObjectType.create(String.class, null, null, null)
         });
         assertTrue(key6.equals(key7));
-
     }
-}
\ No newline at end of file
+}
