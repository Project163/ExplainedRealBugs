diff --git a/CHANGES b/CHANGES
index 6789f76..821ff48 100644
--- a/CHANGES
+++ b/CHANGES
@@ -9,6 +9,9 @@ Version 3.2
 (bugfix release, release date to be decided)
 
 - Added missing `err` parameter forwarding to the `secho` function.
+- Fixed default parameters not being handled properly by the context
+  invoke method.  This is a backwards incompatible change if the function
+  was used improperly.  See :ref:`upgrade-to-3.2` for more information.
 
 Version 3.1
 -----------
diff --git a/click/core.py b/click/core.py
index 99c1f49..2119903 100644
--- a/click/core.py
+++ b/click/core.py
@@ -369,26 +369,65 @@ class Context(object):
         return self.command.get_help(self)
 
     def invoke(*args, **kwargs):
-        """Invokes a command callback in exactly the way it expects.
+        """Invokes a command callback in exactly the way it expects.  There
+        are two ways to invoke this method:
+
+        1.  the first argument can be a callback and all other arguments and
+            keyword arguments are forwarded directly to the function.
+        2.  the first argument is a click command object.  In that case all
+            arguments are forwarded as well but proper click parameters
+            (options and click arguments) must be keyword arguments and Click
+            will fill in defaults.
+
+        Note that before Click 3.2 keyword arguments were not properly filled
+        in against the intention of this code and no context was created.  For
+        more information about this change and why it was done in a bugfix
+        release see :ref:`upgrade-to-3.2`.
         """
         self, callback = args[:2]
+        ctx = self
+
+        # This is just to improve the error message in cases where old
+        # code incorrectly invoked this method.  This will eventually be
+        # removed.
+        injected_arguments = False
 
         # It's also possible to invoke another command which might or
-        # might not have a callback.
+        # might not have a callback.  In that case we also fill
+        # in defaults and make a new context for this command.
         if isinstance(callback, Command):
-            callback = callback.callback
+            other_cmd = callback
+            callback = other_cmd.callback
+            ctx = Context(other_cmd, info_name=other_cmd.name, parent=self)
             if callback is None:
                 raise TypeError('The given command does not have a '
                                 'callback that can be invoked.')
 
+            for param in other_cmd.params:
+                if param.name not in kwargs and param.expose_value:
+                    kwargs[param.name] = param.get_default(ctx)
+                    injected_arguments = True
+
         args = args[2:]
         if getattr(callback, '__click_pass_context__', False):
-            args = (self,) + args
+            args = (ctx,) + args
         with augment_usage_errors(self):
-            return callback(*args, **kwargs)
+            try:
+                with ctx:
+                    return callback(*args, **kwargs)
+            except TypeError as e:
+                if not injected_arguments:
+                    raise
+                if 'got multiple values for keyword argument' in str(e):
+                    raise RuntimeError(
+                        'You called .invoke() on the context with a command '
+                        'but provided parameters as positional arguments.  '
+                        'This is not supported but sometimes worked by chance '
+                        'in older versions of Click.  To fix this see '
+                        'http://click.pocoo.org/upgrading/#upgrading-to-3.2')
 
     def forward(*args, **kwargs):
-        """Similar to :meth:`forward` but fills in default keyword
+        """Similar to :meth:`invoke` but fills in default keyword
         arguments from the current context if the other command expects
         it.  This cannot invoke callbacks directly, only other commands.
         """
@@ -400,8 +439,7 @@ class Context(object):
             raise TypeError('Callback is not a command.')
 
         for param in self.params:
-            if param in self.params and \
-               param not in kwargs:
+            if param not in kwargs:
                 kwargs[param] = self.params[param]
 
         return self.invoke(cmd, **kwargs)
diff --git a/docs/upgrading.rst b/docs/upgrading.rst
index 5ece494..6a37b3c 100644
--- a/docs/upgrading.rst
+++ b/docs/upgrading.rst
@@ -6,6 +6,34 @@ this is not entirely possible.  In case we need to break backwards
 compatibility this document gives you information about how to upgrade or
 handle backwards compatibility properly.
 
+.. _upgrade-to-3.2:
+
+Upgrading to 3.2
+----------------
+
+Click 3.2 contains a fix for the :meth:`Context.invoke` function when used
+with other commands.  The original intention of this function was to
+invoke the other command as as if it came from the command line when it
+was passed a context object instead of a function.  This use was only
+documented in a single place in the documentation before and there was no
+proper explanation for the method in the API documentation.
+
+The core issue is that before 3.2 this call worked against intentions::
+
+    ctx.invoke(other_command, 'arg1', 'arg2')
+
+This was never intended to work as it does not allow Click to operate on
+the parameters.  Given that this pattern was never documented and ill
+intended the decision was made to change this behavior in a bugfix release
+before it spreads by accident and developers depend on it.
+
+The correct invocation for the above command is the following::
+
+    ctx.invoke(other_command, name_of_arg1='arg1', name_of_arg2='arg2')
+
+This also allowed us to fix the issue that defaults were not handled
+properly by this function.
+
 .. _upgrade-to-2.0:
 
 Upgrading to 2.0
diff --git a/tests/test_commands.py b/tests/test_commands.py
index f7ccbbb..24118ed 100644
--- a/tests/test_commands.py
+++ b/tests/test_commands.py
@@ -7,7 +7,7 @@ def test_other_command_invoke(runner):
     @click.command()
     @click.pass_context
     def cli(ctx):
-        return ctx.invoke(other_cmd, 42)
+        return ctx.invoke(other_cmd, arg=42)
 
     @click.command()
     @click.argument('arg', type=click.INT)
@@ -19,6 +19,23 @@ def test_other_command_invoke(runner):
     assert result.output == '42\n'
 
 
+def test_other_command_invoke_invalid_custom_error(runner):
+    @click.command()
+    @click.pass_context
+    def cli(ctx):
+        return ctx.invoke(other_cmd, 42)
+
+    @click.command()
+    @click.argument('arg', type=click.INT)
+    def other_cmd(arg):
+        click.echo(arg)
+
+    result = runner.invoke(cli, [])
+    assert isinstance(result.exception, RuntimeError)
+    assert 'upgrading-to-3.2' in str(result.exception)
+    assert click.__version__ < '5.0'
+
+
 def test_other_command_forward(runner):
     cli = click.Group()
 
@@ -194,3 +211,21 @@ def test_object_propagation(runner):
         result = runner.invoke(cli, ['sync'])
         assert result.exception is None
         assert result.output == 'Debug is off\n'
+
+
+def test_other_command_invoke_with_defaults(runner):
+    @click.command()
+    @click.pass_context
+    def cli(ctx):
+        return ctx.invoke(other_cmd)
+
+    @click.command()
+    @click.option('--foo', type=click.INT, default=42)
+    @click.pass_context
+    def other_cmd(ctx, foo):
+        assert ctx.info_name == 'other_cmd'
+        click.echo(foo)
+
+    result = runner.invoke(cli, [])
+    assert not result.exception
+    assert result.output == '42\n'
