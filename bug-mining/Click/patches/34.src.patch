diff --git a/CHANGES b/CHANGES
index 256fc5f..188f8c8 100644
--- a/CHANGES
+++ b/CHANGES
@@ -39,6 +39,9 @@ Version 6.0
   mode is enabled.
 - Relaxed restriction that disallowed chained commands to have other
   chained commands as child commands.
+- Arguments with positive nargs can now have defaults implemented.
+  Previously this configuration would often result in slightly unexpected
+  values be returned.
 
 Version 5.1
 -----------
diff --git a/click/__init__.py b/click/__init__.py
index b927a73..9c53ddb 100644
--- a/click/__init__.py
+++ b/click/__init__.py
@@ -41,7 +41,8 @@ from .termui import prompt, confirm, get_terminal_size, echo_via_pager, \
 
 # Exceptions
 from .exceptions import ClickException, UsageError, BadParameter, \
-     FileError, Abort, NoSuchOption, BadOptionUsage, MissingParameter
+     FileError, Abort, NoSuchOption, BadOptionUsage, BadArgumentUsage, \
+     MissingParameter
 
 # Formatting
 from .formatting import HelpFormatter, wrap_text
@@ -78,7 +79,8 @@ __all__ = [
 
     # Exceptions
     'ClickException', 'UsageError', 'BadParameter', 'FileError',
-    'Abort', 'NoSuchOption', 'BadOptionUsage', 'MissingParameter',
+    'Abort', 'NoSuchOption', 'BadOptionUsage', 'BadArgumentUsage',
+    'MissingParameter',
 
     # Formatting
     'HelpFormatter', 'wrap_text',
diff --git a/click/exceptions.py b/click/exceptions.py
index 042433a..635cedc 100644
--- a/click/exceptions.py
+++ b/click/exceptions.py
@@ -165,7 +165,19 @@ class BadOptionUsage(UsageError):
     .. versionadded:: 4.0
     """
 
-    def __init__(self, option_name, message, ctx=None):
+    def __init__(self, message, ctx=None):
+        UsageError.__init__(self, message, ctx)
+
+
+class BadArgumentUsage(UsageError):
+    """Raised if an argument is generally supplied but the use of the argument
+    was incorrect.  This is for instance raised if the number of values
+    for an argument is not correct.
+
+    .. versionadded:: 6.0
+    """
+
+    def __init__(self, message, ctx=None):
         UsageError.__init__(self, message, ctx)
 
 
diff --git a/click/parser.py b/click/parser.py
index 426cde6..9775c9f 100644
--- a/click/parser.py
+++ b/click/parser.py
@@ -16,14 +16,66 @@
     and might cause us issues.
 """
 import re
-from .exceptions import UsageError, NoSuchOption, BadOptionUsage
-from .utils import unpack_args
+from collections import deque
+from .exceptions import UsageError, NoSuchOption, BadOptionUsage, \
+     BadArgumentUsage
 
 
-def _error_args(nargs, opt):
+def _unpack_args(args, nargs_spec):
+    """Given an iterable of arguments and an iterable of nargs specifications,
+    it returns a tuple with all the unpacked arguments at the first index
+    and all remaining arguments as the second.
+
+    The nargs specification is the number of arguments that should be consumed
+    or `-1` to indicate that this position should eat up all the remainders.
+
+    Missing items are filled with `None`.
+    """
+    args = deque(args)
+    nargs_spec = deque(nargs_spec)
+    rv = []
+    spos = None
+
+    def _fetch(c):
+        try:
+            if spos is None:
+                return c.popleft()
+            else:
+                return c.pop()
+        except IndexError:
+            return None
+
+    while nargs_spec:
+        nargs = _fetch(nargs_spec)
+        if nargs == 1:
+            rv.append(_fetch(args))
+        elif nargs > 1:
+            x = [_fetch(args) for _ in range(nargs)]
+            # If we're reversed, we're pulling in the arguments in reverse,
+            # so we need to turn them around.
+            if spos is not None:
+                x.reverse()
+            rv.append(tuple(x))
+        elif nargs < 0:
+            if spos is not None:
+                raise TypeError('Cannot have two nargs < 0')
+            spos = len(rv)
+            rv.append(None)
+
+    # spos is the position of the wildcard (star).  If it's not `None`,
+    # we fill it with the remainder.
+    if spos is not None:
+        rv[spos] = tuple(args)
+        args = []
+        rv[spos + 1:] = reversed(rv[spos + 1:])
+
+    return tuple(rv), list(args)
+
+
+def _error_opt_args(nargs, opt):
     if nargs == 1:
-        raise BadOptionUsage(opt, '%s option requires an argument' % opt)
-    raise BadOptionUsage(opt, '%s option requires %d arguments' % (opt, nargs))
+        raise BadOptionUsage('%s option requires an argument' % opt)
+    raise BadOptionUsage('%s option requires %d arguments' % (opt, nargs))
 
 
 def split_opt(opt):
@@ -116,6 +168,13 @@ class Argument(object):
         self.obj = obj
 
     def process(self, value, state):
+        if self.nargs > 1:
+            holes = sum(1 for x in value if x is None)
+            if holes == len(value):
+                value = None
+            elif holes != 0:
+                raise BadArgumentUsage('argument %s takes %d values'
+                                       % (self.dest, self.nargs))
         state.opts[self.dest] = value
         state.order.append(self.obj)
 
@@ -213,8 +272,8 @@ class OptionParser(object):
         return state.opts, state.largs, state.order
 
     def _process_args_for_args(self, state):
-        pargs, args = unpack_args(state.largs + state.rargs,
-                                  [x.nargs for x in self._args])
+        pargs, args = _unpack_args(state.largs + state.rargs,
+                                   [x.nargs for x in self._args])
 
         for idx, arg in enumerate(self._args):
             arg.process(pargs[idx], state)
@@ -275,7 +334,7 @@ class OptionParser(object):
 
             nargs = option.nargs
             if len(state.rargs) < nargs:
-                _error_args(nargs, opt)
+                _error_opt_args(nargs, opt)
             elif nargs == 1:
                 value = state.rargs.pop(0)
             else:
@@ -283,7 +342,7 @@ class OptionParser(object):
                 del state.rargs[:nargs]
 
         elif explicit_value is not None:
-            raise BadOptionUsage(opt, '%s option does not take a value' % opt)
+            raise BadOptionUsage('%s option does not take a value' % opt)
 
         else:
             value = None
@@ -315,7 +374,7 @@ class OptionParser(object):
 
                 nargs = option.nargs
                 if len(state.rargs) < nargs:
-                    _error_args(nargs, opt)
+                    _error_opt_args(nargs, opt)
                 elif nargs == 1:
                     value = state.rargs.pop(0)
                 else:
diff --git a/click/utils.py b/click/utils.py
index ea6205d..eee626d 100644
--- a/click/utils.py
+++ b/click/utils.py
@@ -1,6 +1,5 @@
 import os
 import sys
-from collections import deque
 
 from .globals import resolve_color_default
 
@@ -23,70 +22,6 @@ def _posixify(name):
     return '-'.join(name.split()).lower()
 
 
-def unpack_args(args, nargs_spec):
-    """Given an iterable of arguments and an iterable of nargs specifications,
-    it returns a tuple with all the unpacked arguments at the first index
-    and all remaining arguments as the second.
-
-    The nargs specification is the number of arguments that should be consumed
-    or `-1` to indicate that this position should eat up all the remainders.
-
-    Missing items are filled with `None`.
-
-    Examples:
-
-    >>> unpack_args(range(6), [1, 2, 1, -1])
-    ((0, (1, 2), 3, (4, 5)), [])
-    >>> unpack_args(range(6), [1, 2, 1])
-    ((0, (1, 2), 3), [4, 5])
-    >>> unpack_args(range(6), [-1])
-    (((0, 1, 2, 3, 4, 5),), [])
-    >>> unpack_args(range(6), [1, 1])
-    ((0, 1), [2, 3, 4, 5])
-    >>> unpack_args(range(6), [-1,1,1,1,1])
-    (((0, 1), 2, 3, 4, 5), [])
-    """
-    args = deque(args)
-    nargs_spec = deque(nargs_spec)
-    rv = []
-    spos = None
-
-    def _fetch(c):
-        try:
-            if spos is None:
-                return c.popleft()
-            else:
-                return c.pop()
-        except IndexError:
-            return None
-
-    while nargs_spec:
-        nargs = _fetch(nargs_spec)
-        if nargs == 1:
-            rv.append(_fetch(args))
-        elif nargs > 1:
-            x = [_fetch(args) for _ in range(nargs)]
-            # If we're reversed, we're pulling in the arguments in reverse,
-            # so we need to turn them around.
-            if spos is not None:
-                x.reverse()
-            rv.append(tuple(x))
-        elif nargs < 0:
-            if spos is not None:
-                raise TypeError('Cannot have two nargs < 0')
-            spos = len(rv)
-            rv.append(None)
-
-    # spos is the position of the wildcard (star).  If it's not `None`,
-    # we fill it with the remainder.
-    if spos is not None:
-        rv[spos] = tuple(args)
-        args = []
-        rv[spos + 1:] = reversed(rv[spos + 1:])
-
-    return tuple(rv), list(args)
-
-
 def safecall(func):
     """Wraps a function so that it swallows exceptions."""
     def wrapper(*args, **kwargs):
diff --git a/tests/test_arguments.py b/tests/test_arguments.py
index 570888c..751ca69 100644
--- a/tests/test_arguments.py
+++ b/tests/test_arguments.py
@@ -258,3 +258,21 @@ def test_nargs_specified_plus_star_ordering(runner):
         'd',
         PY2 and "(u'e', u'f')" or "('e', 'f')",
     ]
+
+
+def test_defaults_for_nargs(runner):
+    @click.command()
+    @click.argument('a', nargs=2, type=int, default=(1, 2))
+    def cmd(a):
+        x, y = a
+        click.echo(x + y)
+
+    result = runner.invoke(cmd, [])
+    assert result.output.strip() == '3'
+
+    result = runner.invoke(cmd, ['3', '4'])
+    assert result.output.strip() == '7'
+
+    result = runner.invoke(cmd, ['3'])
+    assert result.exception is not None
+    assert 'argument a takes 2 values' in result.output
