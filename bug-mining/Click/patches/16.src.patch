diff --git a/CHANGES b/CHANGES
index 821ff48..cdd8121 100644
--- a/CHANGES
+++ b/CHANGES
@@ -12,6 +12,11 @@ Version 3.2
 - Fixed default parameters not being handled properly by the context
   invoke method.  This is a backwards incompatible change if the function
   was used improperly.  See :ref:`upgrade-to-3.2` for more information.
+- Removed the `invoked_subcommands` attribute largely.  It is not possible
+  to provide it to work error free due to how the parsing works so this
+  API has been deprecated.  See :ref:`upgrade-to-3.2` for more information.
+- Restored the functionality of `invoked_subcommand` which was broken as
+  a regression in 3.1.
 
 Version 3.1
 -----------
diff --git a/click/core.py b/click/core.py
index cb2b8cd..dd777c0 100644
--- a/click/core.py
+++ b/click/core.py
@@ -173,14 +173,17 @@ class Context(object):
             default_map = parent.default_map.get(info_name)
         self.default_map = default_map
 
-        #: This is similar to :attr:`invoked_subcommand` but it holds a
-        #: list of multiple subcommand names.  This is useful if multi command
-        #: chaining is enabled.
+        #: This flag indicates if a subcommand is going to be executed. A
+        #: group callback can use this information to figure out if it's
+        #: being executed directly or because the execution flow passes
+        #: onwards to a subcommand. By default it's None, but it can be
+        #: the name of the subcommand to execute.
         #:
-        #: This property and :attr:`invoked_subcommand` are synchronized.
-        #:
-        #: .. versionadded:: 3.0
-        self.invoked_subcommands = []
+        #: If chaining is enabled this will be set to ``'*'`` in case
+        #: any commands are executed.  It is however not possible to
+        #: figure out which ones.  If you require this knowledge you
+        #: should use a :func:`resultcallback`.
+        self.invoked_subcommand = None
 
         if terminal_width is None and parent is not None:
             terminal_width = parent.terminal_width
@@ -248,28 +251,24 @@ class Context(object):
         if self._depth == 0:
             self.close()
 
-    def _get_invoked_subcommand(self):
-        """This flag indicates if a subcommand is going to be executed.  A
-        group callback can use this information to figure out if it's
-        being executed directly or because the execution flow passes
-        onwards to a subcommand.  By default it's `None`, but it can be
-        the name of the subcommand to execute.
-
-        If chaining is enabled and more than one subcommand is invoked
-        then the value will be the string ``'*'``.  For chaining you
-        should be using :attr:`invoked_subcommands` instead.
-        """
-        if len(self.invoked_subcommands) == 1:
-            return self.invoked_subcommands[0]
-        if len(self.invoked_subcommands) > 1:
-            return '*'
-    def _set_invoked_subcommand(self, value):
-        if value is not None:
-            value = [value]
-        self.invoked_subcommands = value
-    invoked_subcommand = property(_get_invoked_subcommand,
-                                  _set_invoked_subcommand)
-    del _get_invoked_subcommand, _set_invoked_subcommand
+    def _get_invoked_subcommands(self):
+        from warnings import warn
+        warn(Warning('This API does not work properly and has been largely '
+                     'removed in Click 3.2 to fix a regression the '
+                     'introduction of this API caused.  Consult the '
+                     'upgrade documentation for more information.  For '
+                     'more information about this see '
+                     'http://click.pocoo.org/upgrading/#upgrading-to-3.2'),
+             stacklevel=2)
+        if self.invoked_subcommand is None:
+            return []
+        return [self.invoked_subcommand]
+    def _set_invoked_subcommands(self, value):
+        self.invoked_subcommand = \
+            len(value) > 1 and '*' or value and value[0] or None
+    invoked_subcommands = property(_get_invoked_subcommands,
+                                   _set_invoked_subcommands)
+    del _get_invoked_subcommands, _set_invoked_subcommands
 
     def make_formatter(self):
         """Creates the formatter for the help and usage output."""
@@ -928,15 +927,20 @@ class MultiCommand(Command):
             # Make sure the context is entered so we do not clean up
             # resources until the result processor has worked.
             with ctx:
+                cmd_name, cmd, args = self.resolve_command(ctx, args)
+                ctx.invoked_subcommand = cmd_name
                 Command.invoke(self, ctx)
-                sub_ctx = self.handle_subcommand(ctx, args)
-                ctx.invoked_subcommands = [sub_ctx.info_name]
+                sub_ctx = cmd.make_context(cmd_name, args, parent=ctx)
                 with sub_ctx:
                     return _process_result(sub_ctx.command.invoke(sub_ctx))
 
-        # Make sure the context is entered so we do not clean up
-        # resources until the result processor has worked.
+        # In chain mode we create the contexts step by step, but after the
+        # base command has been invoked.  Because at that point we do not
+        # know the subcommands yet, the invoked subcommand attribute is
+        # set to ``*`` to inform the command that subcommands are executed
+        # but nothing else.
         with ctx:
+            ctx.invoked_subcommand = args and '*' or None
             Command.invoke(self, ctx)
 
             # Otherwise we make every single context and invoke them in a
@@ -944,21 +948,20 @@ class MultiCommand(Command):
             # is the list of all invoked subcommand's results.
             contexts = []
             while args:
-                sub_ctx = self.handle_subcommand(ctx, args, allow_extra_args=True,
-                                                 allow_interspersed_args=False)
+                cmd_name, cmd, args = self.resolve_command(ctx, args)
+                sub_ctx = cmd.make_context(cmd_name, args, parent=ctx,
+                                           allow_extra_args=True,
+                                           allow_interspersed_args=False)
                 contexts.append(sub_ctx)
                 args = sub_ctx.args
 
-            # Now that we have all contexts, we can invoke them.
-            ctx.invoked_subcommands = [x.info_name for x in contexts]
-
             rv = []
             for sub_ctx in contexts:
                 with sub_ctx:
                     rv.append(sub_ctx.command.invoke(sub_ctx))
             return _process_result(rv)
 
-    def handle_subcommand(self, ctx, args, **extra):
+    def resolve_command(self, ctx, args):
         cmd_name = make_str(args[0])
         original_cmd_name = cmd_name
 
@@ -982,7 +985,7 @@ class MultiCommand(Command):
                 self.parse_args(ctx, ctx.args)
             ctx.fail('No such command "%s".' % original_cmd_name)
 
-        return cmd.make_context(cmd_name, args[1:], parent=ctx, **extra)
+        return cmd_name, cmd, args[1:]
 
     def get_command(self, ctx, cmd_name):
         """Given a context and a command name, this returns a
diff --git a/docs/commands.rst b/docs/commands.rst
index 3cd9337..1b59e6a 100644
--- a/docs/commands.rst
+++ b/docs/commands.rst
@@ -315,9 +315,9 @@ normal.
 
 Another note: the :attr:`Context.invoked_subcommand` attribute is a bit
 useless for multi commands as it will give ``'*'`` as value if more than
-one command is invoked.  Instead you should be using the
-:attr:`Context.invoked_subcommands` attribute instead which is a list
-(note the trailing "s").
+one command is invoked.  This is necessary because the handling of
+subcommands happens one after another so the exact subcommands that will
+be handled are not yet available when the callback fires.
 
 
 Multi Command Pipelines
diff --git a/docs/upgrading.rst b/docs/upgrading.rst
index 6a37b3c..b682d21 100644
--- a/docs/upgrading.rst
+++ b/docs/upgrading.rst
@@ -11,6 +11,13 @@ handle backwards compatibility properly.
 Upgrading to 3.2
 ----------------
 
+Click 3.2 had to perform two changes to multi commands which were
+triggered by a change between Click 2 and Click 3 that had bigger
+consequences than anticipated.
+
+Context Invokes
+```````````````
+
 Click 3.2 contains a fix for the :meth:`Context.invoke` function when used
 with other commands.  The original intention of this function was to
 invoke the other command as as if it came from the command line when it
@@ -34,6 +41,27 @@ The correct invocation for the above command is the following::
 This also allowed us to fix the issue that defaults were not handled
 properly by this function.
 
+Multicommand Chaining API
+`````````````````````````
+
+Click 3 introduced multicommand chaning.  This required a change in how
+Click internally dispatches.  Unfortunately this change was not correctly
+implemented and it appeared that it was possible to provide an API that
+can inform the super command about all the subcommands that will be
+invoked.
+
+This assumption however does not work with one of the API guarantees that
+have been given in the past.  As such this functionality has been removed
+in 3.2 as it was already broken.  Instead the accidentally broken
+functionality of the :attr:`Context.invoked_subcommand` attribute was
+restored.
+
+If you do require the know which exact commands will be invoked there are
+different ways to cope with this.  The first one is to let the subcommands
+all return functions and then to invoke the functions in a
+:meth:`Context.resultcallback`.
+
+
 .. _upgrade-to-2.0:
 
 Upgrading to 2.0
diff --git a/tests/test_chain.py b/tests/test_chain.py
index 64ebb85..d1f9c1f 100644
--- a/tests/test_chain.py
+++ b/tests/test_chain.py
@@ -103,11 +103,14 @@ def test_chaining_with_arguments(runner):
     ]
 
 
-def test_context_subcommand_info_sync():
+def test_context_subcommand_info_sync(recwarn):
     @click.command()
     def cli():
         pass
 
+    def _assert_warning():
+        assert 'removed in Click 3.2' in str(recwarn.pop(Warning).message)
+
     ctx = click.Context(cli, info_name='cli')
 
     assert ctx.invoked_subcommand is None
@@ -126,7 +129,9 @@ def test_context_subcommand_info_sync():
 
     ctx.invoked_subcommands = ['foo', 'bar']
     assert ctx.invoked_subcommand == '*'
-    assert ctx.invoked_subcommands == ['foo', 'bar']
+    assert ctx.invoked_subcommands == ['*']
+
+    assert 'removed in Click 3.2' in str(recwarn.pop(Warning).message)
 
 
 def test_pipeline(runner):
diff --git a/tests/test_commands.py b/tests/test_commands.py
index 24118ed..7c8b453 100644
--- a/tests/test_commands.py
+++ b/tests/test_commands.py
@@ -229,3 +229,26 @@ def test_other_command_invoke_with_defaults(runner):
     result = runner.invoke(cli, [])
     assert not result.exception
     assert result.output == '42\n'
+
+
+def test_invoked_subcommand(runner):
+    @click.group(invoke_without_command=True)
+    @click.pass_context
+    def cli(ctx):
+        if ctx.invoked_subcommand is None:
+            click.echo('no subcommand, use default')
+            ctx.invoke(sync)
+        else:
+            click.echo('invoke subcommand')
+
+    @cli.command()
+    def sync():
+        click.echo('in subcommand')
+
+    result = runner.invoke(cli, ['sync'])
+    assert not result.exception
+    assert result.output == 'invoke subcommand\nin subcommand\n'
+
+    result = runner.invoke(cli)
+    assert not result.exception
+    assert result.output == 'no subcommand, use default\nin subcommand\n'
