diff --git a/src/AutoMapper/Configuration/MappingExpression.cs b/src/AutoMapper/Configuration/MappingExpression.cs
index 5ad46b14..a506f5a6 100644
--- a/src/AutoMapper/Configuration/MappingExpression.cs
+++ b/src/AutoMapper/Configuration/MappingExpression.cs
@@ -12,7 +12,7 @@ namespace AutoMapper.Configuration
 
     public class MappingExpression : MappingExpression<object, object>, IMappingExpression
     {
-        public MappingExpression(TypePair types, MemberList memberList) : base(memberList, types.SourceType, types.DestinationType)
+        public MappingExpression(TypePair types, MemberList memberList) : base(memberList, types)
         {
         }
 
@@ -145,11 +145,16 @@ public MappingExpression(MemberList memberList)
         {
         }
 
-        public MappingExpression(MemberList memberList, Type sourceType, Type destinationType)
+        public MappingExpression(MemberList memberList, Type sourceType, Type destinationType)
+            : this(memberList, new TypePair(sourceType, destinationType))
+        {
+        }
+
+        public MappingExpression(MemberList memberList, TypePair types)
         {
             MemberList = memberList;
-            Types = new TypePair(sourceType, destinationType);
-            IsOpenGeneric = sourceType.IsGenericTypeDefinition() || destinationType.IsGenericTypeDefinition();
+            Types = types;
+            IsOpenGeneric = types.SourceType.IsGenericTypeDefinition() || types.DestinationType.IsGenericTypeDefinition();
         }
 
         public MemberList MemberList { get; }
@@ -247,8 +252,8 @@ public void ForAllMembers(Action<IMemberConfigurationExpression<TSource, TDestin
 
         public IMappingExpression<TSource, TDestination> Include(Type otherSourceType, Type otherDestinationType)
         {
-            CheckIsDerived(otherSourceType, typeof(TSource));
-            CheckIsDerived(otherDestinationType, typeof(TDestination));
+            CheckIsDerived(otherSourceType, SourceType);
+            CheckIsDerived(otherDestinationType, DestinationType);
             return IncludeCore(otherSourceType, otherDestinationType);
         }
 
@@ -263,8 +268,8 @@ public void ForAllMembers(Action<IMemberConfigurationExpression<TSource, TDestin
 
         public IMappingExpression<TSource, TDestination> IncludeBase(Type sourceBase, Type destinationBase)
         {
-            CheckIsDerived(typeof(TSource), sourceBase);
-            CheckIsDerived(typeof(TDestination), destinationBase);
+            CheckIsDerived(SourceType, sourceBase);
+            CheckIsDerived(DestinationType, destinationBase);
             TypeMapActions.Add(tm => tm.IncludeBaseTypes(sourceBase, destinationBase));
             return this;
         }
diff --git a/src/AutoMapper/PropertyMap.cs b/src/AutoMapper/PropertyMap.cs
index efe43818..9bf917d2 100644
--- a/src/AutoMapper/PropertyMap.cs
+++ b/src/AutoMapper/PropertyMap.cs
@@ -56,6 +56,7 @@ public PropertyMap(PropertyMap inheritedMappedProperty, TypeMap typeMap)
         public object NullSubstitute { get; set; }
         public ValueResolverConfiguration ValueResolverConfig { get; set; }
         public IEnumerable<ValueTransformerConfiguration> ValueTransformers => _valueTransformerConfigs;
+        public string CustomSourceMemberName { get; set; }
 
         public MemberInfo SourceMember
         {
@@ -93,7 +94,6 @@ public Type SourceType
             }
         }
 
-        public string CustomSourceMemberName { get; set; }
 
         public void ChainMembers(IEnumerable<MemberInfo> members)
         {
@@ -114,6 +114,7 @@ public void ApplyInheritedPropertyMap(PropertyMap inheritedMappedProperty)
             NullSubstitute = NullSubstitute ?? inheritedMappedProperty.NullSubstitute;
             MappingOrder = MappingOrder ?? inheritedMappedProperty.MappingOrder;
             ValueResolverConfig = ValueResolverConfig ?? inheritedMappedProperty.ValueResolverConfig;
+            CustomSourceMemberName = CustomSourceMemberName ?? inheritedMappedProperty.CustomSourceMemberName;
         }
 
         public bool IsMapped() => HasSource() || Ignored;
diff --git a/src/UnitTests/MappingInheritance/IncludeBaseWithNonGenericUsage.cs b/src/UnitTests/MappingInheritance/IncludeBaseWithNonGenericUsage.cs
new file mode 100644
index 00000000..28e17edb
--- /dev/null
+++ b/src/UnitTests/MappingInheritance/IncludeBaseWithNonGenericUsage.cs
@@ -0,0 +1,78 @@
+using System;
+using Shouldly;
+using Xunit;
+
+namespace AutoMapper.UnitTests.MappingInheritance
+{
+    public class IncludeBaseWithNonGenericUsage : NonValidatingSpecBase
+    {
+        class Source : SourceBase<string>
+        { }
+
+        class Destination : DestinationBase<string>
+        { }
+
+        abstract class SourceBase<T>
+        {
+            public T Id;
+            public string Timestamp;
+        }
+
+        abstract class DestinationBase<T>
+        {
+            public T Id;
+            public string Time;
+        }
+
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
+        {
+            // It does not matter if generic type is <String> or <>, result is the same.
+            cfg.CreateMap(typeof(SourceBase<string>), typeof(DestinationBase<string>))
+                .ForMember("Time", mo => mo.MapFrom("Timestamp"));
+            cfg.CreateMap(typeof(Source), typeof(Destination))
+                .IncludeBase(typeof(SourceBase<string>), typeof(DestinationBase<string>));
+        });
+
+        [Fact]
+        public void Should_pass_validation()
+        {
+            Should.NotThrow(() => Configuration.AssertConfigurationIsValid());
+        }
+    }
+
+    public class IncludeBaseWithGenericUsage : NonValidatingSpecBase
+    {
+        class Source : SourceBase<string>
+        { }
+
+        class Destination : DestinationBase<string>
+        { }
+
+        abstract class SourceBase<T>
+        {
+            public T Id;
+            public string Timestamp;
+        }
+
+        abstract class DestinationBase<T>
+        {
+            public T Id;
+            public string Time;
+        }
+
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
+        {
+            // It does not matter if generic type is <String> or <>, result is the same.
+            cfg.CreateMap<SourceBase<string>, DestinationBase<string>>()
+                .ForMember("Time", mo => mo.MapFrom("Timestamp"));
+            cfg.CreateMap<Source, Destination>()
+                .IncludeBase<SourceBase<string>, DestinationBase<string>>();
+        });
+
+        [Fact]
+        public void Should_pass_validation()
+        {
+            Should.NotThrow(() => Configuration.AssertConfigurationIsValid());
+        }
+    }
+}
\ No newline at end of file
