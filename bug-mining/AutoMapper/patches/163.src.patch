diff --git a/src/AutoMapper/Mappers/ConvertMapper.cs b/src/AutoMapper/Mappers/ConvertMapper.cs
index b37d1423..ba30ea9e 100644
--- a/src/AutoMapper/Mappers/ConvertMapper.cs
+++ b/src/AutoMapper/Mappers/ConvertMapper.cs
@@ -7,6 +7,7 @@ namespace AutoMapper.Mappers
 {
     using LazyExpression = Lazy<LambdaExpression>;
     using static Expression;
+    using static ExpressionExtensions;
 
     public class ConvertMapper : IObjectMapper
     {
@@ -32,13 +33,32 @@ select new
 
         static LambdaExpression ConvertExpression(Type sourceType, Type destinationType)
         {
-            var sourceParameter = Parameter(sourceType, "source");
-            var underlyingDestinationType = Nullable.GetUnderlyingType(destinationType) ?? destinationType;
+            var sourceParameter = Parameter(sourceType, "source");
+            bool nullableDestination;
+            var underlyingDestinationType = UnderlyingType(destinationType, out nullableDestination);
             var convertMethod = typeof(Convert).GetDeclaredMethod("To" + underlyingDestinationType.Name, new[] { sourceType });
-            var callConvert = Call(convertMethod, sourceParameter);
-            return Lambda(callConvert, sourceParameter);
-        }
-
+            Expression convertCall = Call(convertMethod, sourceParameter);
+            var lambdaBody = nullableDestination && !sourceType.IsValueType() ?
+                                            Condition(Equal(sourceParameter, Constant(null)), Constant(null, destinationType), ToType(convertCall, destinationType)) :
+                                            convertCall;
+            return Lambda(lambdaBody, sourceParameter);
+        }
+
+        private static Type UnderlyingType(Type type, out bool nullable)
+        {
+            var underlyingDestinationType = Nullable.GetUnderlyingType(type);
+            if(underlyingDestinationType == null)
+            {
+                nullable = false;
+                return type;
+            }
+            else
+            {
+                nullable = true;
+                return underlyingDestinationType;
+            }
+        }
+
         public bool IsMatch(TypePair types) => _converters.ContainsKey(types);
 
         public Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider, PropertyMap propertyMap, Expression sourceExpression, Expression destExpression, Expression contextExpression)
diff --git a/src/UnitTests/Mappers/ConvertMapperTests.cs b/src/UnitTests/Mappers/ConvertMapperTests.cs
index 22f259fd..c6d8209b 100644
--- a/src/UnitTests/Mappers/ConvertMapperTests.cs
+++ b/src/UnitTests/Mappers/ConvertMapperTests.cs
@@ -44,6 +44,12 @@ public void From_string()
             Mapper.Map<string, decimal?>("12").ShouldEqual(12);
             Mapper.Map<string, ushort>("12").ShouldEqual((ushort)12);
             Mapper.Map<string, ulong>("12").ShouldEqual((ulong)12);
-        }
-    }
+        }
+
+        [Fact]
+        public void From_null_string_to_nullable_int()
+        {
+            Mapper.Map<string, int?>(null).ShouldBeNull();
+        }
+    }
 }
\ No newline at end of file
