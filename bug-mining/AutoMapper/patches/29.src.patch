diff --git a/src/AutoMapper/ConfigurationStore.cs b/src/AutoMapper/ConfigurationStore.cs
index 705229bc..34ff6013 100644
--- a/src/AutoMapper/ConfigurationStore.cs
+++ b/src/AutoMapper/ConfigurationStore.cs
@@ -330,10 +330,10 @@ public TypeMap[] GetAllTypeMaps()
 
 		public TypeMap FindTypeMapFor(Type sourceType, Type destinationType)
 		{
-			return FindTypeMapFor( null, sourceType, destinationType ) ;
+			return FindTypeMapFor( null, null, sourceType, destinationType ) ;
 		}
 
-		public TypeMap FindTypeMapFor(object source, Type sourceType, Type destinationType)
+		public TypeMap FindTypeMapFor(object source, object destination, Type sourceType, Type destinationType)
 		{
 			var typeMapPair = new TypePair(sourceType, destinationType);
 			
@@ -342,7 +342,7 @@ public TypeMap FindTypeMapFor(object source, Type sourceType, Type destinationTy
             if (!_typeMapCache.TryGetValue(typeMapPair, out typeMap))
             {
                 // Cache miss
-                typeMap = FindTypeMap(source, sourceType, destinationType, DefaultProfileName);
+                typeMap = FindTypeMap(source, destination, sourceType, destinationType, DefaultProfileName);
 
                 //We don't want to inherit base mappings which may be ambiguous or too specific resulting in cast exceptions
                 if (source == null || source.GetType() == sourceType)
@@ -351,12 +351,16 @@ public TypeMap FindTypeMapFor(object source, Type sourceType, Type destinationTy
             // Due to the inheritance we can have derrived mapping cached which is not valid for this source object
             else if (source != null && typeMap != null && !typeMap.SourceType.IsAssignableFrom(source.GetType()))
             {
-                typeMap = FindTypeMapFor(source, source.GetType(), destinationType);
+                typeMap = FindTypeMapFor(source, destination, source.GetType(), destinationType);
             }
 
+            if (typeMap == null && destination != null && destination.GetType() != destinationType)
+            {
+                typeMap = FindTypeMapFor(source, destination, sourceType, destination.GetType());
+            }
             if (typeMap != null && typeMap.DestinationTypeOverride != null)
             {
-                return FindTypeMapFor(source, sourceType, typeMap.DestinationTypeOverride);
+                return FindTypeMapFor(source, destination, sourceType, typeMap.DestinationTypeOverride);
             }
             // Check for runtime derived types
 		    var shouldCheckDerivedType = (typeMap != null) && (typeMap.HasDerivedTypesToInclude()) && (source != null) && (source.GetType() != sourceType);
@@ -401,7 +405,7 @@ public TypeMap FindTypeMapFor(object source, Type sourceType, Type destinationTy
                 if (potentialTypeMap == null)
                 {
                     var targetSourceType = targetDestinationType != destinationType ? potentialSourceType : typeMap.SourceType;
-                    typeMap = FindTypeMap(source, targetSourceType, targetDestinationType, DefaultProfileName);
+                    typeMap = FindTypeMap(source, destination, targetSourceType, targetDestinationType, DefaultProfileName);
                 }
                 else
                     typeMap = potentialTypeMap;
@@ -429,8 +433,8 @@ private static IEnumerable<Type> InheritanceTree(Type type)
 
 		public TypeMap FindTypeMapFor(ResolutionResult resolutionResult, Type destinationType)
 		{
-			return FindTypeMapFor(resolutionResult.Value, resolutionResult.Type, destinationType) ??
-			       FindTypeMapFor(resolutionResult.Value, resolutionResult.MemberType, destinationType);
+			return FindTypeMapFor(resolutionResult.Value, null, resolutionResult.Type, destinationType) ??
+			       FindTypeMapFor(resolutionResult.Value, null, resolutionResult.MemberType, destinationType);
 		}
 
 		public IFormatterConfiguration GetProfileConfiguration(string profileName)
@@ -525,7 +529,7 @@ private static bool ShouldCheckMap(TypeMap typeMap)
 #endif
 	    }
 
-	    private TypeMap FindTypeMap(object source, Type sourceType, Type destinationType, string profileName)
+	    private TypeMap FindTypeMap(object source, object destination, Type sourceType, Type destinationType, string profileName)
         {
             TypeMap typeMap = FindExplicitlyDefinedTypeMap(sourceType, destinationType);
 
@@ -542,7 +546,7 @@ private TypeMap FindTypeMap(object source, Type sourceType, Type destinationType
                 {
                     foreach (var sourceInterface in sourceType.GetInterfaces())
                     {
-                        typeMap = ((IConfigurationProvider)this).FindTypeMapFor(source, sourceInterface, destinationType);
+                        typeMap = ((IConfigurationProvider)this).FindTypeMapFor(source, destination, sourceInterface, destinationType);
 
                         if (typeMap == null) continue;
 
@@ -556,7 +560,7 @@ private TypeMap FindTypeMap(object source, Type sourceType, Type destinationType
                     }
 
                     if ((sourceType.BaseType != null) && (typeMap == null))
-                        typeMap = ((IConfigurationProvider)this).FindTypeMapFor(source, sourceType.BaseType, destinationType);
+                        typeMap = ((IConfigurationProvider)this).FindTypeMapFor(source, destination, sourceType.BaseType, destinationType);
                 }
             }
             return typeMap;
@@ -600,7 +604,7 @@ private void DryRunTypeMap(ICollection<TypeMap> typeMapsChecked, ResolutionConte
 						{
 							var sourceType = lastResolver.MemberType;
 							var destinationType = propertyMap.DestinationProperty.MemberType;
-							var memberTypeMap = ((IConfigurationProvider)this).FindTypeMapFor(null, sourceType, destinationType);
+							var memberTypeMap = ((IConfigurationProvider)this).FindTypeMapFor(sourceType, destinationType);
 
                             if (typeMapsChecked.Any(typeMap => Equals(typeMap, memberTypeMap)))
                                 continue;
@@ -616,7 +620,7 @@ private void DryRunTypeMap(ICollection<TypeMap> typeMapsChecked, ResolutionConte
 			{
 				Type sourceElementType = TypeHelper.GetElementType(context.SourceType);
 				Type destElementType = TypeHelper.GetElementType(context.DestinationType);
-				TypeMap itemTypeMap = ((IConfigurationProvider) this).FindTypeMapFor(null, sourceElementType, destElementType);
+				TypeMap itemTypeMap = ((IConfigurationProvider) this).FindTypeMapFor(sourceElementType, destElementType);
 
                 if (typeMapsChecked.Any(typeMap => Equals(typeMap, itemTypeMap)))
                     return;
diff --git a/src/AutoMapper/IConfigurationProvider.cs b/src/AutoMapper/IConfigurationProvider.cs
index 9ebb9302..495fc66f 100644
--- a/src/AutoMapper/IConfigurationProvider.cs
+++ b/src/AutoMapper/IConfigurationProvider.cs
@@ -15,7 +15,7 @@ public TypeMapCreatedEventArgs(TypeMap typeMap)
 	public interface IConfigurationProvider : IProfileConfiguration
 	{
 		TypeMap[] GetAllTypeMaps();
-		TypeMap FindTypeMapFor(object source, Type sourceType, Type destinationType);
+		TypeMap FindTypeMapFor(object source, object destination, Type sourceType, Type destinationType);
 		TypeMap FindTypeMapFor(Type sourceType, Type destinationType);
 		TypeMap FindTypeMapFor(ResolutionResult resolutionResult, Type destinationType);
 		IFormatterConfiguration GetProfileConfiguration(string profileName);
diff --git a/src/AutoMapper/Mapper.cs b/src/AutoMapper/Mapper.cs
index d3adf753..2da8f7f8 100644
--- a/src/AutoMapper/Mapper.cs
+++ b/src/AutoMapper/Mapper.cs
@@ -173,12 +173,12 @@ public static void AddProfile<TProfile>() where TProfile : Profile, new()
 
 		public static TypeMap FindTypeMapFor(Type sourceType, Type destinationType)
 		{
-			return ConfigurationProvider.FindTypeMapFor(null, sourceType, destinationType);
+			return ConfigurationProvider.FindTypeMapFor(sourceType, destinationType);
 		}
 
 		public static TypeMap FindTypeMapFor<TSource, TDestination>()
 		{
-			return ConfigurationProvider.FindTypeMapFor(null, typeof(TSource), typeof(TDestination));
+			return ConfigurationProvider.FindTypeMapFor(typeof(TSource), typeof(TDestination));
 		}
 
 		public static TypeMap[] GetAllTypeMaps()
diff --git a/src/AutoMapper/Mappers/DataReaderMapper.cs b/src/AutoMapper/Mappers/DataReaderMapper.cs
index a056c2e0..7958b957 100644
--- a/src/AutoMapper/Mappers/DataReaderMapper.cs
+++ b/src/AutoMapper/Mappers/DataReaderMapper.cs
@@ -21,7 +21,7 @@ public object Map(ResolutionContext context, IMappingEngineRunner mapper)
                 if (context.TypeMap == null)
                 {
                     var configurationProvider = mapper.ConfigurationProvider;
-                    TypeMap typeMap = configurationProvider.FindTypeMapFor(context.SourceValue, context.SourceType, destinationElementType);
+                    TypeMap typeMap = configurationProvider.FindTypeMapFor(context.SourceValue, null, context.SourceType, destinationElementType);
                     resolveUsingContext = new ResolutionContext(typeMap, context.SourceValue, context.SourceType, destinationElementType, new MappingOperationOptions());
                 }
 				var buildFrom = CreateBuilder(destinationElementType, dataReader);
diff --git a/src/AutoMapper/Mappers/DictionaryMapper.cs b/src/AutoMapper/Mappers/DictionaryMapper.cs
index 5d12ecb3..d2faee29 100644
--- a/src/AutoMapper/Mappers/DictionaryMapper.cs
+++ b/src/AutoMapper/Mappers/DictionaryMapper.cs
@@ -45,8 +45,8 @@ public object Map(ResolutionContext context, IMappingEngineRunner mapper)
 				object sourceKey = sourceKvpType.GetProperty("Key").GetValue(keyValuePair, new object[0]);
 				object sourceValue = sourceKvpType.GetProperty("Value").GetValue(keyValuePair, new object[0]);
 
-				TypeMap keyTypeMap = mapper.ConfigurationProvider.FindTypeMapFor(sourceKey, sourceKeyType, destKeyType);
-				TypeMap valueTypeMap = mapper.ConfigurationProvider.FindTypeMapFor(sourceValue, sourceValueType, destValueType);
+				TypeMap keyTypeMap = mapper.ConfigurationProvider.FindTypeMapFor(sourceKey, null, sourceKeyType, destKeyType);
+				TypeMap valueTypeMap = mapper.ConfigurationProvider.FindTypeMapFor(sourceValue, null, sourceValueType, destValueType);
 
 				ResolutionContext keyContext = context.CreateElementContext(keyTypeMap, sourceKey, sourceKeyType, destKeyType, count);
 				ResolutionContext valueContext = context.CreateElementContext(valueTypeMap, sourceValue, sourceValueType, destValueType, count);
diff --git a/src/AutoMapper/Mappers/EnumerableMapper.cs b/src/AutoMapper/Mappers/EnumerableMapper.cs
index 2f9af0a7..bb78a3f0 100644
--- a/src/AutoMapper/Mappers/EnumerableMapper.cs
+++ b/src/AutoMapper/Mappers/EnumerableMapper.cs
@@ -56,7 +56,7 @@ public object Map(ResolutionContext context, IMappingEngineRunner mapper)
 
 			foreach (object item in enumerableValue)
 			{
-				var typeMap = mapper.ConfigurationProvider.FindTypeMapFor(item, sourceElementType, destKvpType);
+				var typeMap = mapper.ConfigurationProvider.FindTypeMapFor(item, null, sourceElementType, destKvpType);
 
 				Type targetSourceType = typeMap != null ? typeMap.SourceType : sourceElementType;
 				Type targetDestinationType = typeMap != null ? typeMap.DestinationType : destKvpType;
diff --git a/src/AutoMapper/MappingEngine.cs b/src/AutoMapper/MappingEngine.cs
index 16376a7a..98025844 100644
--- a/src/AutoMapper/MappingEngine.cs
+++ b/src/AutoMapper/MappingEngine.cs
@@ -96,7 +96,7 @@ public TDestination Map<TDestination>(object source, Action<IMappingOperationOpt
 	    public TDestination Map<TSource, TDestination>(TSource source, TDestination destination, Action<IMappingOperationOptions> opts)
 	    {
             Type modelType = typeof(TSource);
-            Type destinationType = (Equals(destination, default(TDestination)) ? typeof(TDestination) : destination.GetType());
+            Type destinationType = typeof(TDestination);
 
             return (TDestination)Map(source, destination, modelType, destinationType, opts);
         }
@@ -108,7 +108,7 @@ public object Map(object source, Type sourceType, Type destinationType)
 
 	    public object Map(object source, Type sourceType, Type destinationType, Action<IMappingOperationOptions> opts)
 	    {
-            TypeMap typeMap = ConfigurationProvider.FindTypeMapFor(source, sourceType, destinationType);
+            TypeMap typeMap = ConfigurationProvider.FindTypeMapFor(source, null, sourceType, destinationType);
 
 	        var options = new MappingOperationOptions();
 
@@ -126,7 +126,7 @@ public object Map(object source, object destination, Type sourceType, Type desti
 
 	    public object Map(object source, object destination, Type sourceType, Type destinationType, Action<IMappingOperationOptions> opts)
 	    {
-            TypeMap typeMap = ConfigurationProvider.FindTypeMapFor(source, sourceType, destinationType);
+            TypeMap typeMap = ConfigurationProvider.FindTypeMapFor(source, destination, sourceType, destinationType);
 
 	        var options = new MappingOperationOptions();
 
@@ -139,7 +139,7 @@ public object Map(object source, object destination, Type sourceType, Type desti
 
 
 	    public TDestination DynamicMap<TSource, TDestination>(TSource source)
-		{
+		{   
 			Type modelType = typeof(TSource);
 			Type destinationType = typeof(TDestination);
 
@@ -149,7 +149,7 @@ public object Map(object source, object destination, Type sourceType, Type desti
 		public void DynamicMap<TSource, TDestination>(TSource source, TDestination destination)
 		{
 			Type modelType = typeof(TSource);
-            Type destinationType = (Equals(destination, default(TDestination)) ? typeof(TDestination) : destination.GetType());
+            Type destinationType = typeof(TDestination);
 
 			DynamicMap(source, destination, modelType, destinationType);
 		}
@@ -164,7 +164,7 @@ public TDestination DynamicMap<TDestination>(object source)
 
 		public object DynamicMap(object source, Type sourceType, Type destinationType)
 		{
-			var typeMap = ConfigurationProvider.FindTypeMapFor(source, sourceType, destinationType) ??
+			var typeMap = ConfigurationProvider.FindTypeMapFor(source, null, sourceType, destinationType) ??
 			              ConfigurationProvider.CreateTypeMap(sourceType, destinationType);
 
 			var context = new ResolutionContext(typeMap, source, sourceType, destinationType, new MappingOperationOptions
@@ -177,7 +177,7 @@ public object DynamicMap(object source, Type sourceType, Type destinationType)
 
 		public void DynamicMap(object source, object destination, Type sourceType, Type destinationType)
 		{
-			var typeMap = ConfigurationProvider.FindTypeMapFor(source, sourceType, destinationType) ??
+			var typeMap = ConfigurationProvider.FindTypeMapFor(source, destination, sourceType, destinationType) ??
 			              ConfigurationProvider.CreateTypeMap(sourceType, destinationType);
 
 			var context = new ResolutionContext(typeMap, source, destination, sourceType, destinationType, new MappingOperationOptions
@@ -201,7 +201,7 @@ public void DynamicMap(object source, object destination, Type sourceType, Type
         {
             Type destinationType = typeof(TDestination);
             Type sourceType = typeof(TSource);
-            TypeMap typeMap = ConfigurationProvider.FindTypeMapFor(source, sourceType, destinationType);
+            TypeMap typeMap = ConfigurationProvider.FindTypeMapFor(source, null, sourceType, destinationType);
             var context = parentContext.CreateTypeContext(typeMap, source, sourceType, destinationType);
             return (TDestination)((IMappingEngineRunner)this).Map(context);
         }
diff --git a/src/UnitTests/Bug/InterfaceSelfMappingBug.cs b/src/UnitTests/Bug/InterfaceSelfMappingBug.cs
new file mode 100644
index 00000000..0975dc32
--- /dev/null
+++ b/src/UnitTests/Bug/InterfaceSelfMappingBug.cs
@@ -0,0 +1,45 @@
+ï»¿using NUnit.Framework;
+using Should;
+
+namespace AutoMapper.UnitTests.Bug
+{
+    [TestFixture]
+    public class InterfaceSelfMappingBug
+    {
+        public interface IFoo
+        {
+            int Value { get; set; } 
+        }
+
+        public class Bar : IFoo
+        {
+            public int Value { get; set; }
+        }
+
+        public class Baz : IFoo
+        {
+            public int Value { get; set; }
+        }
+
+        [Test]
+        public void Example()
+        {
+            Mapper.Configuration.AllowNullCollections = true;
+            Mapper.CreateMap<IFoo, IFoo>();
+            Mapper.AssertConfigurationIsValid();
+
+            IFoo bar = new Bar
+            {
+                Value = 5
+            };
+            IFoo baz = new Baz
+            {
+                Value = 10
+            };
+
+            Mapper.Map(bar, baz);
+
+            baz.Value.ShouldEqual(5);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/UnitTests/Bug/ObjectTypeMapFailure.cs b/src/UnitTests/Bug/ObjectTypeMapFailure.cs
index 331f56e7..e0373d80 100644
--- a/src/UnitTests/Bug/ObjectTypeMapFailure.cs
+++ b/src/UnitTests/Bug/ObjectTypeMapFailure.cs
@@ -24,7 +24,7 @@ public void Should_map_the_object_type()
             vm2.Radius.ShouldEqual(300); // succeeds
         }
 
-        [Test]
+        [Test, Ignore("Don't think this should really work - I don't know which types to create the type maps for")]
         public void Should_dynamic_map_the_object_type()
         {
             var displayModel = new DisplayModel
diff --git a/src/UnitTests/UnitTests.csproj b/src/UnitTests/UnitTests.csproj
index fa87e6b3..6e20411d 100644
--- a/src/UnitTests/UnitTests.csproj
+++ b/src/UnitTests/UnitTests.csproj
@@ -119,6 +119,7 @@
     <Compile Include="Bug\EnumMatchingOnValue.cs" />
     <Compile Include="Bug\IgnoreAll.cs" />
     <Compile Include="Bug\InheritanceIssue.cs" />
+    <Compile Include="Bug\InterfaceSelfMappingBug.cs" />
     <Compile Include="Bug\MemberNamedTypeBug.cs" />
     <Compile Include="Bug\MultipleInterfaceInheritance.cs" />
     <Compile Include="Bug\MultipleTypeConverterInterfaces.cs" />
