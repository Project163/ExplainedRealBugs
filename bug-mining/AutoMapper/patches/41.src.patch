diff --git a/src/AutoMapper/Mappers/MapperRegistry.cs b/src/AutoMapper/Mappers/MapperRegistry.cs
index 60888190..9ba15c7e 100644
--- a/src/AutoMapper/Mappers/MapperRegistry.cs
+++ b/src/AutoMapper/Mappers/MapperRegistry.cs
@@ -13,6 +13,7 @@ public class MapperRegistry : IMapperRegistry
             new TypeMapMapper(TypeMapObjectMapperRegistry.AllMappers()),
             new StringMapper(),
             new FlagsEnumMapper(),
+            new AssignableMapper(),
             new EnumMapper(),
             new PrimitiveArrayMapper(),
             new ArrayMapper(),
@@ -21,7 +22,6 @@ public class MapperRegistry : IMapperRegistry
             new ReadOnlyCollectionMapper(),
             new CollectionMapper(),
             new EnumerableMapper(),
-            new AssignableMapper(),
             new NullableSourceMapper(),
             new NullableMapper(),
             new ImplicitConversionOperatorMapper(),
diff --git a/src/AutoMapper/QueryableExtensions.cs b/src/AutoMapper/QueryableExtensions.cs
index 77694390..f0ad4273 100644
--- a/src/AutoMapper/QueryableExtensions.cs
+++ b/src/AutoMapper/QueryableExtensions.cs
@@ -13,7 +13,7 @@ public static class Extensions
     {
         private static readonly IDictionaryFactory DictionaryFactory = PlatformAdapter.Resolve<IDictionaryFactory>();
 
-        private static readonly Internal.IDictionary<TypePair, LambdaExpression> _expressionCache 
+        private static readonly Internal.IDictionary<TypePair, LambdaExpression> _expressionCache
             = DictionaryFactory.CreateDictionary<TypePair, LambdaExpression>();
 
         /// <summary>
@@ -106,10 +106,13 @@ private static Expression CreateMapExpression(IMappingEngine mappingEngine, Type
 
                 var destinationMember = propertyMap.DestinationProperty.MemberInfo;
 
-                MemberAssignment bindExpression = null;
-                // next to lists, also arrays
-                // and objects!!!
-                if (propertyMap.DestinationPropertyType.GetInterfaces().Any(t => t.Name == "IEnumerable") &&
+                MemberAssignment bindExpression;
+
+                if (propertyMap.DestinationPropertyType.IsAssignableFrom(result.Type))
+                {
+                    bindExpression = Expression.Bind(destinationMember, result.ResolutionExpression);
+                }
+                else if (propertyMap.DestinationPropertyType.GetInterfaces().Any(t => t.Name == "IEnumerable") &&
                     propertyMap.DestinationPropertyType != typeof(string))
                 {
                     Type destinationListType = propertyMap.DestinationPropertyType.GetGenericArguments().First();
@@ -122,9 +125,9 @@ private static Expression CreateMapExpression(IMappingEngine mappingEngine, Type
                     var transformedExpression = CreateMapExpression(mappingEngine, sourceListType, destinationListType);
 
                     MethodCallExpression selectExpression = Expression.Call(
-                        typeof (Enumerable),
+                        typeof(Enumerable),
                         "Select",
-                        new[] {sourceListType, destinationListType},
+                        new[] { sourceListType, destinationListType },
                         result.ResolutionExpression,
                         transformedExpression);
 
@@ -133,9 +136,9 @@ private static Expression CreateMapExpression(IMappingEngine mappingEngine, Type
                     if (typeof(IList<>).MakeGenericType(destinationListType).IsAssignableFrom(propertyMap.DestinationPropertyType))
                     {
                         MethodCallExpression toListCallExpression = Expression.Call(
-                            typeof (Enumerable),
+                            typeof(Enumerable),
                             "ToList",
-                            new Type[] {destinationListType},
+                            new Type[] { destinationListType },
                             selectExpression);
 
                         var toListIfSourceIsNotNull =
@@ -160,29 +163,29 @@ private static Expression CreateMapExpression(IMappingEngine mappingEngine, Type
                         bindExpression = Expression.Bind(destinationMember, selectIfSourceIsNotNull);
                     }
                 }
-                else
+                else if (result.Type != propertyMap.DestinationPropertyType &&
+                         // avoid nullable etc.
+                         propertyMap.DestinationPropertyType.BaseType != typeof (ValueType) &&
+                         propertyMap.DestinationPropertyType.BaseType != typeof (Enum))
                 {
-                    // does of course not work for subclasses etc./generic ...
-                    if (result.Type != propertyMap.DestinationPropertyType &&
-                        // avoid nullable etc.
-                        propertyMap.DestinationPropertyType.BaseType != typeof(ValueType) &&
-                        propertyMap.DestinationPropertyType.BaseType != typeof(Enum))
-                    {
-                        var transformedExpression = CreateMapExpression(mappingEngine, result.Type, propertyMap.DestinationPropertyType, result.ResolutionExpression);
+                    var transformedExpression = CreateMapExpression(mappingEngine, result.Type,
+                                                                    propertyMap.DestinationPropertyType,
+                                                                    result.ResolutionExpression);
 
-                        var isNullExpression = Expression.Equal(result.ResolutionExpression, Expression.Constant(null));
+                    var isNullExpression = Expression.Equal(result.ResolutionExpression, Expression.Constant(null));
 
-                        var transformIfIsNotNull =
-                            Expression.Condition(isNullExpression, Expression.Constant(null, propertyMap.DestinationPropertyType),
-                                                 transformedExpression);
+                    var transformIfIsNotNull =
+                        Expression.Condition(isNullExpression,
+                                             Expression.Constant(null, propertyMap.DestinationPropertyType),
+                                             transformedExpression);
 
-                        bindExpression = Expression.Bind(destinationMember, transformIfIsNotNull);
-                    }
-                    else
-                    {
-                        bindExpression = Expression.Bind(destinationMember, result.ResolutionExpression);
-                    }
+                    bindExpression = Expression.Bind(destinationMember, transformIfIsNotNull);
+                }
+                else
+                {
+                    throw new AutoMapperMappingException("Unable to create a map expression from " + result.Type + " to " + propertyMap.DestinationPropertyType);
                 }
+
                 bindings.Add(bindExpression);
             }
             return bindings;
diff --git a/src/UnitTests/Projection/PrimitiveArraysTest.cs b/src/UnitTests/Projection/PrimitiveArraysTest.cs
new file mode 100644
index 00000000..118d698f
--- /dev/null
+++ b/src/UnitTests/Projection/PrimitiveArraysTest.cs
@@ -0,0 +1,56 @@
+ï»¿using System;
+using System.Collections.Generic;
+using AutoMapper.QueryableExtensions;
+using Xunit;
+using System.Linq;
+using Should;
+
+namespace AutoMapper.UnitTests.Projection
+{
+    namespace PrimitiveArrays
+    {
+        public class PrimitiveArraysExpressionTest
+        {
+            [Fact]
+            public void Should_not_fail()
+            {
+                Mapper.CreateMap<Source, Destination>();
+
+                typeof(NullReferenceException).ShouldNotBeThrownBy(() => Mapper.Engine.CreateMapExpression<Source, Destination>());
+            }
+
+            [Fact]
+            public void Should_map_values()
+            {
+                Mapper.CreateMap<Source, Destination>();
+
+                var sources = new List<Source>
+                {
+                    new Source
+                    {
+                        Value1 = new byte[] {1, 2, 3},
+                        Value2 = new[] {4, 5, 6}
+                    }
+                };
+
+                var expr = sources.AsQueryable().Project().To<Destination>();
+
+                var result = expr.ToList();
+
+                result[0].Value1.ShouldEqual(sources[0].Value1);
+                result[0].Value2.ShouldEqual(sources[0].Value2);
+            }
+        }
+        public class Source
+        {
+            public byte[] Value1 { get; set; }
+            public int[] Value2 { get; set; }
+        }
+
+        public class Destination
+        {
+            public byte[] Value1 { get; set; }
+            public int[] Value2 { get; set; }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/UnitTests/UnitTests.Net4.csproj b/src/UnitTests/UnitTests.Net4.csproj
index e89add9a..0a2204c6 100644
--- a/src/UnitTests/UnitTests.Net4.csproj
+++ b/src/UnitTests/UnitTests.Net4.csproj
@@ -168,6 +168,7 @@
     <Compile Include="NullBehavior.cs" />
     <Compile Include="Profiles.cs" />
     <Compile Include="Projection\MapFromTest.cs" />
+    <Compile Include="Projection\PrimitiveArraysTest.cs" />
     <Compile Include="Projection\ProjectCollectionEnumerableTest.cs" />
     <Compile Include="Projection\ProjectCollectionListTest.cs" />
     <Compile Include="Projection\ProjectTest.cs" />
