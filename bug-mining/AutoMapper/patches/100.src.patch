diff --git a/src/AutoMapper/IMappingEngine.cs b/src/AutoMapper/IMappingEngine.cs
index 0565521a..dc339b1f 100644
--- a/src/AutoMapper/IMappingEngine.cs
+++ b/src/AutoMapper/IMappingEngine.cs
@@ -1,6 +1,7 @@
 namespace AutoMapper
 {
     using System;
+    using System.Linq.Expressions;
 
     /// <summary>
     /// Performs mapping based on configuration
@@ -159,5 +160,7 @@ public interface IMappingEngine : IDisposable
         /// <param name="sourceType">Source type to use</param>
         /// <param name="destinationType">Destination type to use</param>
         void DynamicMap(object source, object destination, Type sourceType, Type destinationType);
+
+        Expression CreateMapExpression(Type sourceType, Type destinationType, System.Collections.Generic.IDictionary<string, object> parameters = null, params string[] membersToExpand);
     }
 }
\ No newline at end of file
diff --git a/src/AutoMapper/IMappingEngineRunner.cs b/src/AutoMapper/IMappingEngineRunner.cs
index a32d9474..9ca53b93 100644
--- a/src/AutoMapper/IMappingEngineRunner.cs
+++ b/src/AutoMapper/IMappingEngineRunner.cs
@@ -1,5 +1,8 @@
 namespace AutoMapper
 {
+    using System.Linq.Expressions;
+    using QueryableExtensions;
+
     /// <summary>
     /// Main entry point for executing maps
     /// </summary>
@@ -10,5 +13,10 @@ public interface IMappingEngineRunner
 		IConfigurationProvider ConfigurationProvider { get; }
 	    bool ShouldMapSourceValueAsNull(ResolutionContext context);
 	    bool ShouldMapSourceCollectionAsNull(ResolutionContext context);
+
+        Expression CreateMapExpression(ExpressionRequest request,
+            Expression instanceParameter, Internal.IDictionary<ExpressionRequest, int> typePairCount);
+
+        LambdaExpression CreateMapExpression(ExpressionRequest request, Internal.IDictionary<ExpressionRequest, int> typePairCount);
 	}
 }
diff --git a/src/AutoMapper/Mapper.cs b/src/AutoMapper/Mapper.cs
index ab40f3b8..b3899383 100644
--- a/src/AutoMapper/Mapper.cs
+++ b/src/AutoMapper/Mapper.cs
@@ -397,7 +397,6 @@ public static void AssertConfigurationIsValid<TProfile>() where TProfile : Profi
         public static void Reset()
         {
             MapperRegistry.Reset();
-            Extensions.ClearExpressionCache();
             _configuration = LazyFactory.Create(_configurationInit);
             _mappingEngine = LazyFactory.Create(_mappingEngineInit);
         }
diff --git a/src/AutoMapper/MappingEngine.cs b/src/AutoMapper/MappingEngine.cs
index a6b9aeef..63f24645 100644
--- a/src/AutoMapper/MappingEngine.cs
+++ b/src/AutoMapper/MappingEngine.cs
@@ -1,36 +1,62 @@
 namespace AutoMapper
 {
     using System;
+    using System.Collections.Generic;
     using System.Linq;
+    using System.Linq.Expressions;
     using System.Reflection;
     using Impl;
     using Internal;
     using Mappers;
+    using QueryableExtensions;
+    using QueryableExtensions.Impl;
 
     public class MappingEngine : IMappingEngine, IMappingEngineRunner
     {
         private static readonly IDictionaryFactory DictionaryFactory = PlatformAdapter.Resolve<IDictionaryFactory>();
 
-        private static readonly IProxyGeneratorFactory ProxyGeneratorFactory =
-            PlatformAdapter.Resolve<IProxyGeneratorFactory>();
+        private static readonly IProxyGeneratorFactory ProxyGeneratorFactory = PlatformAdapter.Resolve<IProxyGeneratorFactory>();
+
+        private static readonly IExpressionResultConverter[] ExpressionResultConverters =
+        {
+            new MemberGetterExpressionResultConverter(),
+            new MemberResolverExpressionResultConverter(),
+            new NullSubstitutionExpressionResultConverter()
+        };
+
+        private static readonly IExpressionBinder[] Binders =
+        {
+            new NullableExpressionBinder(),
+            new AssignableExpressionBinder(),
+            new EnumerableExpressionBinder(),
+            new MappedTypeExpressionBinder(),
+            new CustomProjectionExpressionBinder(),
+            new StringExpressionBinder()
+        };
+
 
         private bool _disposed;
         private readonly IObjectMapper[] _mappers;
-        private readonly IDictionary<TypePair, IObjectMapper> _objectMapperCache;
+        private readonly Internal.IDictionary<TypePair, IObjectMapper> _objectMapperCache;
+        private readonly Internal.IDictionary<ExpressionRequest, LambdaExpression> _expressionCache;
+
         private readonly Func<Type, object> _serviceCtor;
 
         public MappingEngine(IConfigurationProvider configurationProvider)
             : this(
-                configurationProvider, DictionaryFactory.CreateDictionary<TypePair, IObjectMapper>(),
+                configurationProvider,
+                DictionaryFactory.CreateDictionary<TypePair, IObjectMapper>(),
+                DictionaryFactory.CreateDictionary<ExpressionRequest, LambdaExpression>(),
                 configurationProvider.ServiceCtor)
         {
         }
 
-        public MappingEngine(IConfigurationProvider configurationProvider,
-            IDictionary<TypePair, IObjectMapper> objectMapperCache, Func<Type, object> serviceCtor)
+        public MappingEngine(IConfigurationProvider configurationProvider, Internal.IDictionary<TypePair, IObjectMapper> objectMapperCache, Internal.IDictionary<ExpressionRequest, LambdaExpression> expressionCache,
+            Func<Type, object> serviceCtor)
         {
             ConfigurationProvider = configurationProvider;
             _objectMapperCache = objectMapperCache;
+            _expressionCache = expressionCache;
             _serviceCtor = serviceCtor;
             _mappers = configurationProvider.GetMappers();
             ConfigurationProvider.TypeMapCreated += ClearTypeMap;
@@ -219,8 +245,155 @@ public void DynamicMap(object source, object destination, Type sourceType, Type
             TypeMap typeMap = ConfigurationProvider.ResolveTypeMap(source, null, sourceType, destinationType);
             var context = parentContext.CreateTypeContext(typeMap, source, null, sourceType, destinationType);
             return (TDestination) ((IMappingEngineRunner) this).Map(context);
+        }
+
+        public Expression CreateMapExpression(Type sourceType, Type destinationType, System.Collections.Generic.IDictionary<string, object> parameters = null, params string[] membersToExpand)
+        {
+            parameters = parameters ?? new Dictionary<string, object>();
+
+            var cachedExpression =
+                _expressionCache.GetOrAdd(new ExpressionRequest(sourceType, destinationType, membersToExpand),
+                    tp => CreateMapExpression(tp, DictionaryFactory.CreateDictionary<ExpressionRequest, int>()));
+
+            if (!parameters.Any())
+                return cachedExpression;
+
+            var visitor = new ConstantExpressionReplacementVisitor(parameters);
+
+            return visitor.Visit(cachedExpression);
+        }
+
+        public LambdaExpression CreateMapExpression(ExpressionRequest request, Internal.IDictionary<ExpressionRequest, int> typePairCount)
+        {
+            // this is the input parameter of this expression with name <variableName>
+            ParameterExpression instanceParameter = Expression.Parameter(request.SourceType, "dto");
+
+            var total = CreateMapExpression(request, instanceParameter, typePairCount);
+
+            return Expression.Lambda(total, instanceParameter);
         }
 
+        public Expression CreateMapExpression(ExpressionRequest request,
+            Expression instanceParameter, Internal.IDictionary<ExpressionRequest, int> typePairCount)
+        {
+            var typeMap = ConfigurationProvider.ResolveTypeMap(request.SourceType,
+                request.DestinationType);
+
+            if (typeMap == null)
+            {
+                const string MessageFormat = "Missing map from {0} to {1}. Create using Mapper.CreateMap<{0}, {1}>.";
+
+                var message = string.Format(MessageFormat, request.SourceType.Name, request.DestinationType.Name);
+
+                throw new InvalidOperationException(message);
+            }
+
+            var bindings = CreateMemberBindings(request, typeMap, instanceParameter, typePairCount);
+
+            var parameterReplacer = new ParameterReplacementVisitor(instanceParameter);
+            var visitor = new NewFinderVisitor();
+            var constructorExpression = typeMap.DestinationConstructorExpression(instanceParameter);
+            visitor.Visit(parameterReplacer.Visit(constructorExpression));
+
+            var expression = Expression.MemberInit(
+                visitor.NewExpression,
+                bindings.ToArray()
+                );
+            return Expression.Convert(expression, request.DestinationType);
+        }
+
+        private class NewFinderVisitor : ExpressionVisitor
+        {
+            public NewExpression NewExpression { get; private set; }
+
+            protected override Expression VisitNew(NewExpression node)
+            {
+                NewExpression = node;
+                return base.VisitNew(node);
+            }
+        }
+
+        private List<MemberBinding> CreateMemberBindings(ExpressionRequest request,
+            TypeMap typeMap,
+            Expression instanceParameter, Internal.IDictionary<ExpressionRequest, int> typePairCount)
+        {
+            var bindings = new List<MemberBinding>();
+
+            var visitCount = typePairCount.AddOrUpdate(request, 0, (tp, i) => i + 1);
+
+            if (visitCount >= typeMap.MaxDepth)
+                return bindings;
+
+            foreach (var propertyMap in typeMap.GetPropertyMaps().Where(pm => pm.CanResolveValue()))
+            {
+                var result = ResolveExpression(propertyMap, request.SourceType, instanceParameter);
+
+                if (propertyMap.ExplicitExpansion &&
+                    !request.IncludedMembers.Contains(propertyMap.DestinationProperty.Name))
+                    continue;
+
+                var propertyTypeMap = ConfigurationProvider.ResolveTypeMap(result.Type,
+                    propertyMap.DestinationPropertyType);
+                var propertyRequest = new ExpressionRequest(result.Type, propertyMap.DestinationPropertyType,
+                    request.IncludedMembers);
+
+                var binder = Binders.FirstOrDefault(b => b.IsMatch(propertyMap, propertyTypeMap, result));
+
+                if (binder == null)
+                {
+                    var message =
+                        $"Unable to create a map expression from {propertyMap.SourceMember?.DeclaringType?.Name}.{propertyMap.SourceMember?.Name} ({result.Type}) to {propertyMap.DestinationProperty.MemberInfo.DeclaringType?.Name}.{propertyMap.DestinationProperty.Name} ({propertyMap.DestinationPropertyType})";
+
+                    throw new AutoMapperMappingException(message);
+                }
+
+                var bindExpression = binder.Build(this, propertyMap, propertyTypeMap, propertyRequest, result, typePairCount);
+
+                bindings.Add(bindExpression);
+            }
+            return bindings;
+        }
+
+        private static ExpressionResolutionResult ResolveExpression(PropertyMap propertyMap, Type currentType,
+            Expression instanceParameter)
+        {
+            var result = new ExpressionResolutionResult(instanceParameter, currentType);
+            foreach (var resolver in propertyMap.GetSourceValueResolvers())
+            {
+                var matchingExpressionConverter =
+                    ExpressionResultConverters.FirstOrDefault(c => c.CanGetExpressionResolutionResult(result, resolver));
+                if (matchingExpressionConverter == null)
+                    throw new Exception("Can't resolve this to Queryable Expression");
+                result = matchingExpressionConverter.GetExpressionResolutionResult(result, propertyMap, resolver);
+            }
+            return result;
+        }
+
+        private class ConstantExpressionReplacementVisitor : ExpressionVisitor
+        {
+            private readonly System.Collections.Generic.IDictionary<string, object> _paramValues;
+
+            public ConstantExpressionReplacementVisitor(
+                System.Collections.Generic.IDictionary<string, object> paramValues)
+            {
+                _paramValues = paramValues;
+            }
+
+            protected override Expression VisitMember(MemberExpression node)
+            {
+                if (!node.Member.DeclaringType.Name.Contains("<>"))
+                    return base.VisitMember(node);
+
+                if (!_paramValues.ContainsKey(node.Member.Name))
+                    return base.VisitMember(node);
+
+                return Expression.Convert(
+                    Expression.Constant(_paramValues[node.Member.Name]),
+                    node.Member.GetMemberType());
+            }
+        }
+
+
         object IMappingEngineRunner.Map(ResolutionContext context)
         {
             try
diff --git a/src/AutoMapper/QueryableExtensions/ExpressionRequest.cs b/src/AutoMapper/QueryableExtensions/ExpressionRequest.cs
index 256b254c..c5e0b97e 100644
--- a/src/AutoMapper/QueryableExtensions/ExpressionRequest.cs
+++ b/src/AutoMapper/QueryableExtensions/ExpressionRequest.cs
@@ -10,7 +10,7 @@ public class ExpressionRequest : IEquatable<ExpressionRequest>
         public Type DestinationType { get; }
         public string[] IncludedMembers { get; private set; }
 
-        public ExpressionRequest(Type sourceType, Type destinationType, params string[] includedMembers)
+        public ExpressionRequest(Type sourceType, Type destinationType,  params string[] includedMembers)
         {
             SourceType = sourceType;
             DestinationType = destinationType;
diff --git a/src/AutoMapper/QueryableExtensions/Extensions.cs b/src/AutoMapper/QueryableExtensions/Extensions.cs
index 35c92fb0..9dd16a8f 100644
--- a/src/AutoMapper/QueryableExtensions/Extensions.cs
+++ b/src/AutoMapper/QueryableExtensions/Extensions.cs
@@ -5,37 +5,9 @@ namespace AutoMapper.QueryableExtensions
     using System.Linq;
     using System.Linq.Expressions;
     using Impl;
-    using Internal;
 
     public static class Extensions
     {
-        private static readonly IDictionaryFactory DictionaryFactory = PlatformAdapter.Resolve<IDictionaryFactory>();
-
-        private static readonly Internal.IDictionary<ExpressionRequest, LambdaExpression> _expressionCache
-            = DictionaryFactory.CreateDictionary<ExpressionRequest, LambdaExpression>();
-
-        private static readonly IExpressionResultConverter[] ExpressionResultConverters =
-        {
-            new MemberGetterExpressionResultConverter(),
-            new MemberResolverExpressionResultConverter(),
-            new NullSubstitutionExpressionResultConverter()
-        };
-
-        private static readonly IExpressionBinder[] Binders =
-        {
-            new NullableExpressionBinder(),
-            new AssignableExpressionBinder(),
-            new EnumerableExpressionBinder(),
-            new MappedTypeExpressionBinder(),
-            new CustomProjectionExpressionBinder(),
-            new StringExpressionBinder()
-        };
-
-        public static void ClearExpressionCache()
-        {
-            _expressionCache.Clear();
-        }
-
         /// <summary>
         /// Create an expression tree representing a mapping from the <typeparamref name="TSource"/> type to <typeparamref name="TDestination"/> type
         /// Includes flattening and expressions inside MapFrom member configuration
@@ -47,7 +19,7 @@ public static void ClearExpressionCache()
         /// <param name="membersToExpand">Expand members explicitly previously marked as members to explicitly expand</param>
         /// <returns>Expression tree mapping source to destination type</returns>
         public static Expression<Func<TSource, TDestination>> CreateMapExpression<TSource, TDestination>(
-            this IMappingEngine mappingEngine, System.Collections.Generic.IDictionary<string, object> parameters = null,
+            this IMappingEngine mappingEngine, IDictionary<string, object> parameters = null,
             params string[] membersToExpand)
         {
             return
@@ -68,34 +40,31 @@ public static void ClearExpressionCache()
         /// <returns>Expression tree mapping source to destination type</returns>
         public static Expression CreateMapExpression(this IMappingEngine mappingEngine,
             Type sourceType, Type destinationType,
-            System.Collections.Generic.IDictionary<string, object> parameters = null, params string[] membersToExpand)
+            IDictionary<string, object> parameters = null, params string[] membersToExpand)
         {
-            //Expression.const
-            parameters = parameters ?? new Dictionary<string, object>();
-
-            var cachedExpression =
-                _expressionCache.GetOrAdd(new ExpressionRequest(sourceType, destinationType, membersToExpand),
-                    tp =>
-                        CreateMapExpression(mappingEngine, tp,
-                            DictionaryFactory.CreateDictionary<ExpressionRequest, int>()));
-
-            if (!parameters.Any())
-                return cachedExpression;
-
-            var visitor = new ConstantExpressionReplacementVisitor(parameters);
-
-            return visitor.Visit(cachedExpression);
+            return mappingEngine.CreateMapExpression(sourceType, destinationType, parameters, membersToExpand);
         }
 
         public static IQueryable<TDestination> Map<TSource, TDestination>(this IQueryable<TSource> sourceQuery,
             IQueryable<TDestination> destQuery)
         {
-            return QueryMapperVisitor.Map<TSource, TDestination>(sourceQuery, destQuery, Mapper.Engine);
+            return sourceQuery.Map(destQuery, Mapper.Engine);
+        }
+
+        public static IQueryable<TDestination> Map<TSource, TDestination>(this IQueryable<TSource> sourceQuery,
+            IQueryable<TDestination> destQuery, IMappingEngine mappingEngine)
+        {
+            return QueryMapperVisitor.Map<TSource, TDestination>(sourceQuery, destQuery, mappingEngine);
         }
 
         public static IQueryDataSourceInjection<TSource> UseAsDataSource<TSource>(this IQueryable<TSource> dataSource)
         {
-            return new QueryDataSourceInjection<TSource>(dataSource);
+            return dataSource.UseAsDataSource(Mapper.Engine);
+        }
+
+        public static IQueryDataSourceInjection<TSource> UseAsDataSource<TSource>(this IQueryable<TSource> dataSource, IMappingEngine mappingEngine)
+        {
+            return new QueryDataSourceInjection<TSource>(dataSource, mappingEngine);
         }
 
         /// <summary>
@@ -154,136 +123,5 @@ public static IQueryDataSourceInjection<TSource> UseAsDataSource<TSource>(this I
             return new ProjectionExpression(source, mappingEngine).To<TDestination>();
         }
 
-        internal static LambdaExpression CreateMapExpression(IMappingEngine mappingEngine, ExpressionRequest request,
-            Internal.IDictionary<ExpressionRequest, int> typePairCount)
-        {
-            // this is the input parameter of this expression with name <variableName>
-            ParameterExpression instanceParameter = Expression.Parameter(request.SourceType, "dto");
-
-            var total = CreateMapExpression(mappingEngine, request, instanceParameter, typePairCount);
-
-            return Expression.Lambda(total, instanceParameter);
-        }
-
-        internal static Expression CreateMapExpression(IMappingEngine mappingEngine, ExpressionRequest request,
-            Expression instanceParameter, Internal.IDictionary<ExpressionRequest, int> typePairCount)
-        {
-            var typeMap = mappingEngine.ConfigurationProvider.ResolveTypeMap(request.SourceType,
-                request.DestinationType);
-
-            if(typeMap == null)
-            {
-                const string MessageFormat = "Missing map from {0} to {1}. Create using Mapper.CreateMap<{0}, {1}>.";
-
-                var message = string.Format(MessageFormat, request.SourceType.Name, request.DestinationType.Name);
-
-                throw new InvalidOperationException(message);
-            }
-
-            var bindings = CreateMemberBindings(mappingEngine, request, typeMap, instanceParameter, typePairCount);
-
-            var parameterReplacer = new ParameterReplacementVisitor(instanceParameter);
-            var visitor = new NewFinderVisitor();
-            var constructorExpression = typeMap.DestinationConstructorExpression(instanceParameter);
-            visitor.Visit(parameterReplacer.Visit(constructorExpression));
-
-            var expression = Expression.MemberInit(
-                visitor.NewExpression,
-                bindings.ToArray()
-                );
-            return Expression.Convert(expression, request.DestinationType);
-        }
-
-        private class NewFinderVisitor : ExpressionVisitor
-        {
-            public NewExpression NewExpression { get; private set; }
-
-            protected override Expression VisitNew(NewExpression node)
-            {
-                NewExpression = node;
-                return base.VisitNew(node);
-            }
-        }
-
-        private static List<MemberBinding> CreateMemberBindings(IMappingEngine mappingEngine, ExpressionRequest request,
-            TypeMap typeMap,
-            Expression instanceParameter, Internal.IDictionary<ExpressionRequest, int> typePairCount)
-        {
-            var bindings = new List<MemberBinding>();
-
-            var visitCount = typePairCount.AddOrUpdate(request, 0, (tp, i) => i + 1);
-
-            if (visitCount >= typeMap.MaxDepth)
-                return bindings;
-
-            foreach (var propertyMap in typeMap.GetPropertyMaps().Where(pm => pm.CanResolveValue()))
-            {
-                var result = ResolveExpression(propertyMap, request.SourceType, instanceParameter);
-
-                if (propertyMap.ExplicitExpansion &&
-                    !request.IncludedMembers.Contains(propertyMap.DestinationProperty.Name))
-                    continue;
-
-                var propertyTypeMap = mappingEngine.ConfigurationProvider.ResolveTypeMap(result.Type,
-                    propertyMap.DestinationPropertyType);
-                var propertyRequest = new ExpressionRequest(result.Type, propertyMap.DestinationPropertyType,
-                    request.IncludedMembers);
-
-                var binder = Binders.FirstOrDefault(b => b.IsMatch(propertyMap, propertyTypeMap, result));
-
-                if (binder == null)
-                {
-                    var message =
-                        $"Unable to create a map expression from {propertyMap.SourceMember.DeclaringType.Name}.{propertyMap.SourceMember.Name} ({result.Type}) to {propertyMap.DestinationProperty.MemberInfo.DeclaringType.Name}.{propertyMap.DestinationProperty.Name} ({propertyMap.DestinationPropertyType})";
-
-                    throw new AutoMapperMappingException(message);
-                }
-
-                var bindExpression = binder.Build(mappingEngine, propertyMap, propertyTypeMap, propertyRequest, result,
-                    typePairCount);
-
-                bindings.Add(bindExpression);
-            }
-            return bindings;
-        }
-
-        private static ExpressionResolutionResult ResolveExpression(PropertyMap propertyMap, Type currentType,
-            Expression instanceParameter)
-        {
-            var result = new ExpressionResolutionResult(instanceParameter, currentType);
-            foreach (var resolver in propertyMap.GetSourceValueResolvers())
-            {
-                var matchingExpressionConverter =
-                    ExpressionResultConverters.FirstOrDefault(c => c.CanGetExpressionResolutionResult(result, resolver));
-                if (matchingExpressionConverter == null)
-                    throw new Exception("Can't resolve this to Queryable Expression");
-                result = matchingExpressionConverter.GetExpressionResolutionResult(result, propertyMap, resolver);
-            }
-            return result;
-        }
-
-        private class ConstantExpressionReplacementVisitor : ExpressionVisitor
-        {
-            private readonly System.Collections.Generic.IDictionary<string, object> _paramValues;
-
-            public ConstantExpressionReplacementVisitor(
-                System.Collections.Generic.IDictionary<string, object> paramValues)
-            {
-                _paramValues = paramValues;
-            }
-
-            protected override Expression VisitMember(MemberExpression node)
-            {
-                if (!node.Member.DeclaringType.Name.Contains("<>"))
-                    return base.VisitMember(node);
-
-                if (!_paramValues.ContainsKey(node.Member.Name))
-                    return base.VisitMember(node);
-
-                return Expression.Convert(
-                    Expression.Constant(_paramValues[node.Member.Name]),
-                    node.Member.GetMemberType());
-            }
-        }
     }
 }
diff --git a/src/AutoMapper/QueryableExtensions/IExpressionBinder.cs b/src/AutoMapper/QueryableExtensions/IExpressionBinder.cs
index 52a4b259..1157d33c 100644
--- a/src/AutoMapper/QueryableExtensions/IExpressionBinder.cs
+++ b/src/AutoMapper/QueryableExtensions/IExpressionBinder.cs
@@ -1,12 +1,11 @@
 namespace AutoMapper.QueryableExtensions
 {
     using System.Linq.Expressions;
-    using Internal;
 
     public interface IExpressionBinder
     {
         bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionResolutionResult result);
 
-        MemberAssignment Build(IMappingEngine mappingEngine, PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionRequest request, ExpressionResolutionResult result, IDictionary<ExpressionRequest, int> typePairCount);
+        MemberAssignment Build(IMappingEngine mappingEngine, PropertyMap propertyMap, TypeMap propertyTypeMap, ExpressionRequest request, ExpressionResolutionResult result, Internal.IDictionary<ExpressionRequest, int> typePairCount);
     }
 }
\ No newline at end of file
diff --git a/src/AutoMapper/QueryableExtensions/Impl/EnumerableExpressionBinder.cs b/src/AutoMapper/QueryableExtensions/Impl/EnumerableExpressionBinder.cs
index 3aca7ee9..6d85c563 100644
--- a/src/AutoMapper/QueryableExtensions/Impl/EnumerableExpressionBinder.cs
+++ b/src/AutoMapper/QueryableExtensions/Impl/EnumerableExpressionBinder.cs
@@ -18,36 +18,24 @@ public bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, Expression
         }
 
         public MemberAssignment Build(IMappingEngine mappingEngine, PropertyMap propertyMap, TypeMap propertyTypeMap,
-            ExpressionRequest request, ExpressionResolutionResult result,
-            Internal.IDictionary<ExpressionRequest, int> typePairCount)
+            ExpressionRequest request, ExpressionResolutionResult result, Internal.IDictionary<ExpressionRequest, int> typePairCount)
         {
             return BindEnumerableExpression(mappingEngine, propertyMap, request, result, typePairCount);
         }
 
         private static MemberAssignment BindEnumerableExpression(IMappingEngine mappingEngine, PropertyMap propertyMap,
-            ExpressionRequest request, ExpressionResolutionResult result,
-            Internal.IDictionary<ExpressionRequest, int> typePairCount)
+            ExpressionRequest request, ExpressionResolutionResult result, Internal.IDictionary<ExpressionRequest, int> typePairCount)
         {
             MemberAssignment bindExpression;
             Type destinationListType = GetDestinationListTypeFor(propertyMap);
-            Type sourceListType = null;
-            // is list
 
-            if (result.Type.IsArray)
-            {
-                sourceListType = result.Type.GetElementType();
-            }
-            else
-            {
-                sourceListType = result.Type.GetGenericArguments().First();
-            }
+            var sourceListType = result.Type.IsArray ? result.Type.GetElementType() : result.Type.GetGenericArguments().First();
             var listTypePair = new ExpressionRequest(sourceListType, destinationListType, request.IncludedMembers);
 
-
             var selectExpression = result.ResolutionExpression;
             if (sourceListType != destinationListType)
             {
-                var transformedExpression = Extensions.CreateMapExpression(mappingEngine, listTypePair, typePairCount);
+                var transformedExpression = ((IMappingEngineRunner)mappingEngine).CreateMapExpression(listTypePair, typePairCount);
                 selectExpression = Expression.Call(
                     typeof (Enumerable),
                     "Select",
diff --git a/src/AutoMapper/QueryableExtensions/Impl/MappedTypeExpressionBinder.cs b/src/AutoMapper/QueryableExtensions/Impl/MappedTypeExpressionBinder.cs
index 0ed162a1..a11e6969 100644
--- a/src/AutoMapper/QueryableExtensions/Impl/MappedTypeExpressionBinder.cs
+++ b/src/AutoMapper/QueryableExtensions/Impl/MappedTypeExpressionBinder.cs
@@ -11,19 +11,15 @@ public bool IsMatch(PropertyMap propertyMap, TypeMap propertyTypeMap, Expression
         }
 
         public MemberAssignment Build(IMappingEngine mappingEngine, PropertyMap propertyMap, TypeMap propertyTypeMap,
-            ExpressionRequest request, ExpressionResolutionResult result,
-            IDictionary<ExpressionRequest, int> typePairCount)
+            ExpressionRequest request, ExpressionResolutionResult result, Internal.IDictionary<ExpressionRequest, int> typePairCount)
         {
             return BindMappedTypeExpression(mappingEngine, propertyMap, request, result, typePairCount);
         }
 
         private static MemberAssignment BindMappedTypeExpression(IMappingEngine mappingEngine, PropertyMap propertyMap,
-            ExpressionRequest request, ExpressionResolutionResult result,
-            IDictionary<ExpressionRequest, int> typePairCount)
+            ExpressionRequest request, ExpressionResolutionResult result, Internal.IDictionary<ExpressionRequest, int> typePairCount)
         {
-            var transformedExpression = Extensions.CreateMapExpression(mappingEngine, request,
-                result.ResolutionExpression,
-                typePairCount);
+            var transformedExpression = ((IMappingEngineRunner)mappingEngine).CreateMapExpression(request, result.ResolutionExpression, typePairCount);
 
             // Handles null source property so it will not create an object with possible non-nullable propeerties 
             // which would result in an exception.
diff --git a/src/AutoMapper/QueryableExtensions/Impl/QueryDataSourceInjection.cs b/src/AutoMapper/QueryableExtensions/Impl/QueryDataSourceInjection.cs
index 079735c9..fbfa2827 100644
--- a/src/AutoMapper/QueryableExtensions/Impl/QueryDataSourceInjection.cs
+++ b/src/AutoMapper/QueryableExtensions/Impl/QueryDataSourceInjection.cs
@@ -10,16 +10,18 @@ public interface IQueryDataSourceInjection<TSource>
     public class QueryDataSourceInjection<TSource> : IQueryDataSourceInjection<TSource>
     {
         private readonly IQueryable<TSource> _dataSource;
+        private readonly IMappingEngine _mappingEngine;
 
-        public QueryDataSourceInjection(IQueryable<TSource> dataSource)
+        public QueryDataSourceInjection(IQueryable<TSource> dataSource, IMappingEngine mappingEngine)
         {
             _dataSource = dataSource;
+            _mappingEngine = mappingEngine;
         }
 
         public IQueryable<TDestination> For<TDestination>(SourceInjectedQueryInspector inspector = null)
         {
             return new SourceInjectedQuery<TSource, TDestination>(_dataSource,
-                new TDestination[0].AsQueryable(), Mapper.Engine, inspector);
+                new TDestination[0].AsQueryable(), _mappingEngine, inspector);
         }
     }
 }
\ No newline at end of file
diff --git a/src/UnitTests/Query/SourceInjectedQuery.cs b/src/UnitTests/Query/SourceInjectedQuery.cs
index b6346b73..db9d1f11 100644
--- a/src/UnitTests/Query/SourceInjectedQuery.cs
+++ b/src/UnitTests/Query/SourceInjectedQuery.cs
@@ -57,7 +57,7 @@ public void Shoud_use_destination_elementType()
                 .UseAsDataSource().For<Destination>();
 
             result.ElementType.ShouldEqual(typeof(Destination));
-            
+
             result = result.Where(s => s.DestValue > 3);
             result.ElementType.ShouldEqual(typeof(Destination));
         }
@@ -145,7 +145,7 @@ public void Shoud_support_any_stupid_thing_you_can_throw_at_it_with_annonumus_ty
               .UseAsDataSource().For<Destination>()
               .Where(s => true && 5.ToString() == "5" && s.DestValue.ToString() != "0")
               .OrderBy(s => s.DestValue).SkipWhile(d => d.DestValue < 7).Take(1)
-              .OrderByDescending(s => s.DestValue).Select(s => new {A = s.DestValue});
+              .OrderByDescending(s => s.DestValue).Select(s => new { A = s.DestValue });
 
             result.First().A.ShouldEqual(_source.Max(s => s.SrcValue));
         }
@@ -155,131 +155,131 @@ public void Shoud_support_any_stupid_thing_you_can_throw_at_it_with_annonumus_ty
                         new User { UserId = 1, Account = new Account(){ Id = 3,Things = {new Thing(){Bar = "Bar 3"}, new Thing(){ Bar ="Bar 4"}}}},
                     };
         [Fact]
-    public void Map_select_method()
+        public void Map_select_method()
         {
             SetupAutoMapper();
             var result = _source2.AsQueryable()
               .UseAsDataSource().For<UserModel>().OrderBy(s => s.Id).ThenBy(s => s.FullName).Select(s => (object)s.AccountModel.ThingModels.Select(b => b.BarModel));
 
             (result.First() as IEnumerable<string>).Last().ShouldEqual("Bar 4");
-    }
+        }
 
-    [Fact]
-    public void Map_orderBy_thenBy_expression()
-    {
+        [Fact]
+        public void Map_orderBy_thenBy_expression()
+        {
             SetupAutoMapper();
             var result = _source2.AsQueryable()
               .UseAsDataSource().For<UserModel>().Select(s => (object)s.AccountModel.ThingModels);
 
             (result.First() as IEnumerable<Thing>).Last().Bar.ShouldEqual("Bar 2");
+        }
+
+        private static void SetupAutoMapper()
+        {
+            Mapper.CreateMap<User, UserModel>()
+            .ForMember(d => d.Id, opt => opt.MapFrom(s => s.UserId))
+            .ForMember(d => d.FullName, opt => opt.MapFrom(s => s.Name))
+            .ForMember(d => d.LoggedOn, opt => opt.MapFrom(s => s.IsLoggedOn ? "Y" : "N"))
+            .ForMember(d => d.IsOverEighty, opt => opt.MapFrom(s => s.Age > 80))
+            .ForMember(d => d.AccountName, opt => opt.MapFrom(s => s.Account == null ? string.Empty : string.Concat(s.Account.FirstName, " ", s.Account.LastName)))
+            .ForMember(d => d.AgeInYears, opt => opt.MapFrom(s => s.Age))
+            .ForMember(d => d.IsActive, opt => opt.MapFrom(s => s.Active))
+            .ForMember(d => d.AccountModel, opt => opt.MapFrom(s => s.Account));
+
+            Mapper.CreateMap<UserModel, User>()
+                .ForMember(d => d.UserId, opt => opt.MapFrom(s => s.Id))
+                .ForMember(d => d.Name, opt => opt.MapFrom(s => s.FullName))
+                .ForMember(d => d.IsLoggedOn, opt => opt.MapFrom(s => s.LoggedOn.ToUpper() == "Y"))
+                .ForMember(d => d.Age, opt => opt.MapFrom(s => s.AgeInYears))
+                .ForMember(d => d.Active, opt => opt.MapFrom(s => s.IsActive))
+                .ForMember(d => d.Account, opt => opt.MapFrom(s => s.AccountModel));
+
+            Mapper.CreateMap<Account, AccountModel>()
+                .ForMember(d => d.Bal, opt => opt.MapFrom(s => s.Balance))
+                .ForMember(d => d.DateCreated, opt => opt.MapFrom(s => s.CreateDate))
+                .ForMember(d => d.ComboName, opt => opt.MapFrom(s => string.Concat(s.FirstName, " ", s.LastName)))
+                .ForMember(d => d.ThingModels, opt => opt.MapFrom(s => s.Things));
+
+            Mapper.CreateMap<AccountModel, Account>()
+                .ForMember(d => d.Balance, opt => opt.MapFrom(s => s.Bal))
+                .ForMember(d => d.Things, opt => opt.MapFrom(s => s.ThingModels));
+
+            Mapper.CreateMap<Thing, ThingModel>()
+                .ForMember(d => d.FooModel, opt => opt.MapFrom(s => s.Foo))
+                .ForMember(d => d.BarModel, opt => opt.MapFrom(s => s.Bar));
+
+            Mapper.CreateMap<ThingModel, Thing>()
+                .ForMember(d => d.Foo, opt => opt.MapFrom(s => s.FooModel))
+                .ForMember(d => d.Bar, opt => opt.MapFrom(s => s.BarModel));
+
+            //Mapper.CreateMap<IEnumerable<Thing>, IEnumerable<ThingModel>>();
+            //Mapper.CreateMap<IEnumerable<ThingModel>, IEnumerable<Thing>>();
+            //Mapper.CreateMap<IEnumerable<User>, IEnumerable<UserModel>>();
+            //Mapper.CreateMap<IEnumerable<UserModel>, IEnumerable<User>>();
+        }
+
     }
 
-    private static void SetupAutoMapper()
+    public class Account
     {
-        Mapper.CreateMap<User, UserModel>()
-        .ForMember(d => d.Id, opt => opt.MapFrom(s => s.UserId))
-        .ForMember(d => d.FullName, opt => opt.MapFrom(s => s.Name))
-        .ForMember(d => d.LoggedOn, opt => opt.MapFrom(s => s.IsLoggedOn ? "Y" : "N"))
-        .ForMember(d => d.IsOverEighty, opt => opt.MapFrom(s => s.Age > 80))
-        .ForMember(d => d.AccountName, opt => opt.MapFrom(s => s.Account == null ? string.Empty : string.Concat(s.Account.FirstName, " ", s.Account.LastName)))
-        .ForMember(d => d.AgeInYears, opt => opt.MapFrom(s => s.Age))
-        .ForMember(d => d.IsActive, opt => opt.MapFrom(s => s.Active))
-        .ForMember(d => d.AccountModel, opt => opt.MapFrom(s => s.Account));
-
-        Mapper.CreateMap<UserModel, User>()
-            .ForMember(d => d.UserId, opt => opt.MapFrom(s => s.Id))
-            .ForMember(d => d.Name, opt => opt.MapFrom(s => s.FullName))
-            .ForMember(d => d.IsLoggedOn, opt => opt.MapFrom(s => s.LoggedOn.ToUpper() == "Y"))
-            .ForMember(d => d.Age, opt => opt.MapFrom(s => s.AgeInYears))
-            .ForMember(d => d.Active, opt => opt.MapFrom(s => s.IsActive))
-            .ForMember(d => d.Account, opt => opt.MapFrom(s => s.AccountModel));
-
-        Mapper.CreateMap<Account, AccountModel>()
-            .ForMember(d => d.Bal, opt => opt.MapFrom(s => s.Balance))
-            .ForMember(d => d.DateCreated, opt => opt.MapFrom(s => s.CreateDate))
-            .ForMember(d => d.ComboName, opt => opt.MapFrom(s => string.Concat(s.FirstName, " ", s.LastName)))
-            .ForMember(d => d.ThingModels, opt => opt.MapFrom(s => s.Things));
-
-        Mapper.CreateMap<AccountModel, Account>()
-            .ForMember(d => d.Balance, opt => opt.MapFrom(s => s.Bal))
-            .ForMember(d => d.Things, opt => opt.MapFrom(s => s.ThingModels));
-
-        Mapper.CreateMap<Thing, ThingModel>()
-            .ForMember(d => d.FooModel, opt => opt.MapFrom(s => s.Foo))
-            .ForMember(d => d.BarModel, opt => opt.MapFrom(s => s.Bar));
-
-        Mapper.CreateMap<ThingModel, Thing>()
-            .ForMember(d => d.Foo, opt => opt.MapFrom(s => s.FooModel))
-            .ForMember(d => d.Bar, opt => opt.MapFrom(s => s.BarModel));
-
-        //Mapper.CreateMap<IEnumerable<Thing>, IEnumerable<ThingModel>>();
-        //Mapper.CreateMap<IEnumerable<ThingModel>, IEnumerable<Thing>>();
-        //Mapper.CreateMap<IEnumerable<User>, IEnumerable<UserModel>>();
-        //Mapper.CreateMap<IEnumerable<UserModel>, IEnumerable<User>>();
+        public Account()
+        {
+            Things = new List<Thing>();
+        }
+        public int Id { get; set; }
+        public double Balance { get; set; }
+        public string FirstName { get; set; }
+        public string LastName { get; set; }
+        public DateTime CreateDate { get; set; }
+        public ICollection<Thing> Things { get; set; }
     }
 
-}
-
-public class Account
-{
-    public Account()
+    public class AccountModel
     {
-        Things = new List<Thing>();
+        public AccountModel()
+        {
+            ThingModels = new List<ThingModel>();
+        }
+        public int Id { get; set; }
+        public double Bal { get; set; }
+        public string ComboName { get; set; }
+        public DateTime DateCreated { get; set; }
+        public ICollection<ThingModel> ThingModels { get; set; }
     }
-    public int Id { get; set; }
-    public double Balance { get; set; }
-    public string FirstName { get; set; }
-    public string LastName { get; set; }
-    public DateTime CreateDate { get; set; }
-    public ICollection<Thing> Things { get; set; }
-}
 
-public class AccountModel
-{
-    public AccountModel()
+    public class Thing
     {
-        ThingModels = new List<ThingModel>();
+        public int Foo { get; set; }
+        public string Bar { get; set; }
     }
-    public int Id { get; set; }
-    public double Bal { get; set; }
-    public string ComboName { get; set; }
-    public DateTime DateCreated { get; set; }
-    public ICollection<ThingModel> ThingModels { get; set; }
-}
 
-public class Thing
-{
-    public int Foo { get; set; }
-    public string Bar { get; set; }
-}
-
-public class ThingModel
-{
-    public int FooModel { get; set; }
-    public string BarModel { get; set; }
-}
+    public class ThingModel
+    {
+        public int FooModel { get; set; }
+        public string BarModel { get; set; }
+    }
 
-public class User
-{
-    public int UserId { get; set; }
-    public string Name { get; set; }
-    public bool IsLoggedOn { get; set; }
-    public int Age { get; set; }
-    public bool Active { get; set; }
-    public Account Account { get; set; }
-}
+    public class User
+    {
+        public int UserId { get; set; }
+        public string Name { get; set; }
+        public bool IsLoggedOn { get; set; }
+        public int Age { get; set; }
+        public bool Active { get; set; }
+        public Account Account { get; set; }
+    }
 
-public class UserModel
-{
-    public int Id { get; set; }
-    public string FullName { get; set; }
-    public string AccountName { get; set; }
-    public bool IsOverEighty { get; set; }
-    public string LoggedOn { get; set; }
-    public int AgeInYears { get; set; }
-    public bool IsActive { get; set; }
-    public AccountModel AccountModel { get; set; }
-}
+    public class UserModel
+    {
+        public int Id { get; set; }
+        public string FullName { get; set; }
+        public string AccountName { get; set; }
+        public bool IsOverEighty { get; set; }
+        public string LoggedOn { get; set; }
+        public int AgeInYears { get; set; }
+        public bool IsActive { get; set; }
+        public AccountModel AccountModel { get; set; }
     }
+}
 
 
