diff --git a/src/AutoMapper/AutoMapper.csproj b/src/AutoMapper/AutoMapper.csproj
index 6f97efe7..a6a88420 100644
--- a/src/AutoMapper/AutoMapper.csproj
+++ b/src/AutoMapper/AutoMapper.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Summary>A convention-based object-object mapper.</Summary>
     <Description>A convention-based object-object mapper.</Description>
-    <TargetFrameworks>netstandard2.0;netstandard1.3;net45</TargetFrameworks>
+    <TargetFrameworks>netstandard2.0;netstandard1.3;net45;netcoreapp2.0</TargetFrameworks>
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
     <AssemblyName>AutoMapper</AssemblyName>
     <AssemblyOriginatorKeyFile>..\..\AutoMapper.snk</AssemblyOriginatorKeyFile>
@@ -19,9 +19,12 @@
 
   <ItemGroup Condition=" '$(TargetFramework)' == 'netstandard2.0' ">
     <PackageReference Include="Microsoft.CSharp" Version="4.5.0" />
-    <PackageReference Include="System.Reflection.Emit" Version="4.3.0" />
   </ItemGroup>
 
+  <PropertyGroup Condition=" '$(TargetFramework)' == 'net45' OR '$(TargetFramework)' == 'netcoreapp2.0'">
+    <DefineConstants>DYNAMIC_METHODS</DefineConstants>
+  </PropertyGroup>
+
   <ItemGroup Condition=" '$(TargetFramework)' == 'netstandard1.3' ">
     <PackageReference Include="System.Linq.Queryable" Version="4.3.0" />
     <PackageReference Include="System.Dynamic.Runtime" Version="4.3.0" />
@@ -31,7 +34,6 @@
     <PackageReference Include="System.Resources.ResourceManager" Version="4.3.0" />
     <PackageReference Include="System.ComponentModel.TypeConverter" Version="4.3.0" />
     <PackageReference Include="System.Runtime.Serialization.Primitives" Version="4.3.0" />
-    <PackageReference Include="System.Reflection.Emit" Version="4.3.0" />
     <PackageReference Include="System.Collections.Specialized" Version="4.3.0" />
   </ItemGroup>
 
diff --git a/src/AutoMapper/Execution/PropertyDescription.cs b/src/AutoMapper/Execution/PropertyDescription.cs
new file mode 100644
index 00000000..44b91e4f
--- /dev/null
+++ b/src/AutoMapper/Execution/PropertyDescription.cs
@@ -0,0 +1,46 @@
+using System;
+using System.Diagnostics;
+using System.Reflection;
+
+namespace AutoMapper.Execution
+{
+    [DebuggerDisplay("{Name}-{Type.Name}")]
+    public struct PropertyDescription : IEquatable<PropertyDescription>
+    {
+        internal static PropertyDescription[] Empty = new PropertyDescription[0];
+
+        public PropertyDescription(string name, Type type, bool canWrite = true)
+        {
+            Name = name;
+            Type = type;
+            CanWrite = canWrite;
+        }
+
+        public PropertyDescription(PropertyInfo property)
+        {
+            Name = property.Name;
+            Type = property.PropertyType;
+            CanWrite = property.CanWrite;
+        }
+
+        public string Name { get; }
+
+        public Type Type { get; }
+
+        public bool CanWrite { get; }
+
+        public override int GetHashCode()
+        {
+            var code = HashCodeCombiner.Combine(Name, Type);
+            return HashCodeCombiner.CombineCodes(code, CanWrite.GetHashCode());
+        }
+
+        public override bool Equals(object other) => other is PropertyDescription description && Equals(description);
+
+        public bool Equals(PropertyDescription other) => Name == other.Name && Type == other.Type && CanWrite == other.CanWrite;
+
+        public static bool operator ==(PropertyDescription left, PropertyDescription right) => left.Equals(right);
+
+        public static bool operator !=(PropertyDescription left, PropertyDescription right) => !left.Equals(right);
+    }
+}
\ No newline at end of file
diff --git a/src/AutoMapper/Execution/PropertyEmitter.cs b/src/AutoMapper/Execution/PropertyEmitter.cs
index c5391c2e..959f5002 100644
--- a/src/AutoMapper/Execution/PropertyEmitter.cs
+++ b/src/AutoMapper/Execution/PropertyEmitter.cs
@@ -1,3 +1,4 @@
+#if DYNAMIC_METHODS
 namespace AutoMapper.Execution
 {
     using System;
@@ -64,4 +65,5 @@ public MethodBuilder GetSetter(Type requiredType)
             ? throw new InvalidOperationException("Types are not compatible")
             : _setterBuilder;
     }
-}
\ No newline at end of file
+}
+#endif
\ No newline at end of file
diff --git a/src/AutoMapper/Execution/ProxyGenerator.cs b/src/AutoMapper/Execution/ProxyGenerator.cs
index 23b0e459..79398ef0 100644
--- a/src/AutoMapper/Execution/ProxyGenerator.cs
+++ b/src/AutoMapper/Execution/ProxyGenerator.cs
@@ -1,3 +1,4 @@
+#if DYNAMIC_METHODS
 namespace AutoMapper.Execution
 {
     using System;
@@ -116,8 +117,7 @@ private static Type EmitProxy(TypeDescription typeDescription)
             var fieldBuilders = new Dictionary<string, PropertyEmitter>();
             foreach(var property in propertiesToImplement)
             {
-                PropertyEmitter propertyEmitter;
-                if(fieldBuilders.TryGetValue(property.Name, out propertyEmitter))
+                if(fieldBuilders.TryGetValue(property.Name, out var propertyEmitter))
                 {
                     if((propertyEmitter.PropertyType != property.Type) &&
                         ((property.CanWrite) || (!property.Type.IsAssignableFrom(propertyEmitter.PropertyType))))
@@ -130,8 +130,7 @@ private static Type EmitProxy(TypeDescription typeDescription)
                 else
                 {
                     fieldBuilders.Add(property.Name,
-                        propertyEmitter =
-                            new PropertyEmitter(typeBuilder, property, propertyChangedField));
+                        new PropertyEmitter(typeBuilder, property, propertyChangedField));
                 }
             }
             return typeBuilder.CreateType();
@@ -161,83 +160,5 @@ private static byte[] StringToByteArray(string hex)
             return bytes;
         }
     }
-
-    public struct TypeDescription : IEquatable<TypeDescription>
-    {
-        public TypeDescription(Type type) : this(type, PropertyDescription.Empty)
-        {
-        }
-
-        public TypeDescription(Type type, IEnumerable<PropertyDescription> additionalProperties)
-        {
-            Type = type ?? throw new ArgumentNullException(nameof(type));
-            if(additionalProperties == null)
-            {
-                throw new ArgumentNullException(nameof(additionalProperties));
-            }
-            AdditionalProperties = additionalProperties.OrderBy(p => p.Name).ToArray();
-        }
-
-        public Type Type { get; }
-
-        public PropertyDescription[] AdditionalProperties { get; }
-
-        public override int GetHashCode()
-        {
-            var hashCode = Type.GetHashCode();
-            foreach(var property in AdditionalProperties)
-            {
-                hashCode = HashCodeCombiner.CombineCodes(hashCode, property.GetHashCode());
-            }
-            return hashCode;
-        }
-
-        public override bool Equals(object other) => other is TypeDescription && Equals((TypeDescription)other);
-
-        public bool Equals(TypeDescription other) => Type == other.Type && AdditionalProperties.SequenceEqual(other.AdditionalProperties);
-
-        public static bool operator ==(TypeDescription left, TypeDescription right) => left.Equals(right);
-
-        public static bool operator !=(TypeDescription left, TypeDescription right) => !left.Equals(right);
-    }
-
-    [DebuggerDisplay("{Name}-{Type.Name}")]
-    public struct PropertyDescription : IEquatable<PropertyDescription>
-    {
-        internal static PropertyDescription[] Empty = new PropertyDescription[0];
-
-        public PropertyDescription(string name, Type type, bool canWrite = true)
-        {
-            Name = name;
-            Type = type;
-            CanWrite = canWrite;
-        }
-
-        public PropertyDescription(PropertyInfo property)
-        {
-            Name = property.Name;
-            Type = property.PropertyType;
-            CanWrite = property.CanWrite;
-        }
-
-        public string Name { get; }
-
-        public Type Type { get; }
-
-        public bool CanWrite { get; }
-
-        public override int GetHashCode()
-        {
-            var code = HashCodeCombiner.Combine(Name, Type);
-            return HashCodeCombiner.CombineCodes(code, CanWrite.GetHashCode());
-        }
-
-        public override bool Equals(object other) => other is PropertyDescription && Equals((PropertyDescription)other);
-
-        public bool Equals(PropertyDescription other) => Name == other.Name && Type == other.Type && CanWrite == other.CanWrite;
-
-        public static bool operator ==(PropertyDescription left, PropertyDescription right) => left.Equals(right);
-
-        public static bool operator !=(PropertyDescription left, PropertyDescription right) => !left.Equals(right);
-    }
-}
\ No newline at end of file
+}
+#endif
\ No newline at end of file
diff --git a/src/AutoMapper/Execution/TypeDescription.cs b/src/AutoMapper/Execution/TypeDescription.cs
new file mode 100644
index 00000000..dded7e31
--- /dev/null
+++ b/src/AutoMapper/Execution/TypeDescription.cs
@@ -0,0 +1,45 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace AutoMapper.Execution
+{
+    public struct TypeDescription : IEquatable<TypeDescription>
+    {
+        public TypeDescription(Type type) : this(type, PropertyDescription.Empty)
+        {
+        }
+
+        public TypeDescription(Type type, IEnumerable<PropertyDescription> additionalProperties)
+        {
+            Type = type ?? throw new ArgumentNullException(nameof(type));
+            if(additionalProperties == null)
+            {
+                throw new ArgumentNullException(nameof(additionalProperties));
+            }
+            AdditionalProperties = additionalProperties.OrderBy(p => p.Name).ToArray();
+        }
+
+        public Type Type { get; }
+
+        public PropertyDescription[] AdditionalProperties { get; }
+
+        public override int GetHashCode()
+        {
+            var hashCode = Type.GetHashCode();
+            foreach(var property in AdditionalProperties)
+            {
+                hashCode = HashCodeCombiner.CombineCodes(hashCode, property.GetHashCode());
+            }
+            return hashCode;
+        }
+
+        public override bool Equals(object other) => other is TypeDescription description && Equals(description);
+
+        public bool Equals(TypeDescription other) => Type == other.Type && AdditionalProperties.SequenceEqual(other.AdditionalProperties);
+
+        public static bool operator ==(TypeDescription left, TypeDescription right) => left.Equals(right);
+
+        public static bool operator !=(TypeDescription left, TypeDescription right) => !left.Equals(right);
+    }
+}
\ No newline at end of file
diff --git a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
index eba550ad..9c2089ce 100644
--- a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
+++ b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
@@ -14,19 +14,19 @@ namespace AutoMapper.Execution
     public class TypeMapPlanBuilder
     {
         private static readonly Expression<Func<AutoMapperMappingException>> CtorExpression =
-            () => new AutoMapperMappingException(null, null, default(TypePair), null, null);
+            () => new AutoMapperMappingException(null, null, default, null, null);
 
         private static readonly Expression<Action<ResolutionContext>> IncTypeDepthInfo =
-            ctxt => ctxt.IncrementTypeDepth(default(TypePair));
+            ctxt => ctxt.IncrementTypeDepth(default);
 
         private static readonly Expression<Action<ResolutionContext>> ValidateMap =
-            ctxt => ctxt.ValidateMap(default(TypeMap));
+            ctxt => ctxt.ValidateMap(default);
 
         private static readonly Expression<Action<ResolutionContext>> DecTypeDepthInfo =
-            ctxt => ctxt.DecrementTypeDepth(default(TypePair));
+            ctxt => ctxt.DecrementTypeDepth(default);
 
         private static readonly Expression<Func<ResolutionContext, int>> GetTypeDepthInfo =
-            ctxt => ctxt.GetTypeDepth(default(TypePair));
+            ctxt => ctxt.GetTypeDepth(default);
 
         private readonly IConfigurationProvider _configurationProvider;
         private readonly ParameterExpression _destination;
@@ -58,7 +58,7 @@ public LambdaExpression CreateMapperLambda(HashSet<TypeMap> typeMapsPath)
             CheckForCycles(typeMapsPath);
 
             if(typeMapsPath != null)
-            {
+            {
                 return null;
             }
 
@@ -75,26 +75,26 @@ public LambdaExpression CreateMapperLambda(HashSet<TypeMap> typeMapsPath)
         }
 
         private void CheckForCycles(HashSet<TypeMap> typeMapsPath)
-        {
-            bool inlineWasChecked;
+        {
+            bool inlineWasChecked;
             if(_typeMap.ConstructorMappingTypes == null)
-            {
-                _typeMap.ConstructorMappingTypes = GetConstructorMappingTypes();
+            {
+                _typeMap.ConstructorMappingTypes = GetConstructorMappingTypes();
                 inlineWasChecked = false;
-            }
-            else
-            {
+            }
+            else
+            {
                 inlineWasChecked = true;
             }
             if(typeMapsPath == null)
             {
                 typeMapsPath = new HashSet<TypeMap>();
-            }
+            }
             typeMapsPath.Add(_typeMap);
-            var defaultPropertyMap = new PropertyMap(default(MemberInfo), null);
-            var properties = 
-                _typeMap.GetPropertyMaps().Where(pm=>pm.CanResolveValue()).Select(pm=>new { PropertyTypeMap = ResolvePropertyTypeMap(pm), PropertyMap = pm })
-                .Concat(_typeMap.ConstructorMappingTypes.Select(tp => new { PropertyTypeMap = ResolveTypeMap(tp), PropertyMap = defaultPropertyMap }))
+            var defaultPropertyMap = new PropertyMap(default(MemberInfo), null);
+            var properties = 
+                _typeMap.GetPropertyMaps().Where(pm=>pm.CanResolveValue()).Select(pm=>new { PropertyTypeMap = ResolvePropertyTypeMap(pm), PropertyMap = pm })
+                .Concat(_typeMap.ConstructorMappingTypes.Select(tp => new { PropertyTypeMap = ResolveTypeMap(tp), PropertyMap = defaultPropertyMap }))
                 .Where(p => p.PropertyTypeMap != null && !p.PropertyTypeMap.PreserveReferences && p.PropertyTypeMap.MapExpression == null);
             foreach(var property in properties)
             {
@@ -105,29 +105,29 @@ private void CheckForCycles(HashSet<TypeMap> typeMapsPath)
                 }
                 var propertyTypeMap = property.PropertyTypeMap;
                 if(typeMapsPath.Contains(propertyTypeMap))
-                {
+                {
                     if(propertyTypeMap.SourceType.IsValueType())
-                    {
+                    {
                         if(propertyTypeMap.MaxDepth == 0)
                         {
                             propertyTypeMap.MaxDepth = 10;
-                        }
-                        typeMapsPath.Remove(_typeMap);
-                        return;
-                    }
+                        }
+                        typeMapsPath.Remove(_typeMap);
+                        return;
+                    }
                     else
                     {
                         SetPreserveReferences(propertyTypeMap);
                         foreach(var derivedTypeMap in propertyTypeMap.IncludedDerivedTypes.Select(typePair => ResolveTypeMap(typePair)))
                         {
                             SetPreserveReferences(derivedTypeMap);
-                        }
+                        }
                     }
-                }
-                propertyTypeMap.CreateMapperLambda(_configurationProvider, typeMapsPath);
-            }
-            typeMapsPath.Remove(_typeMap);
-            return;
+                }
+                propertyTypeMap.CreateMapperLambda(_configurationProvider, typeMapsPath);
+            }
+            typeMapsPath.Remove(_typeMap);
+            return;
 
             void SetPreserveReferences(TypeMap propertyTypeMap)
             {
@@ -322,6 +322,7 @@ private Expression CreateNewDestinationFunc()
             {
                 return CreateNewDestinationExpression(_typeMap.ConstructorMap);
             }
+#if DYNAMIC_METHODS
             if(_typeMap.DestinationTypeToUse.IsInterface())
             {
                 var ctor = Call(null,
@@ -332,27 +333,28 @@ private Expression CreateNewDestinationFunc()
                 // We're invoking a delegate here to make it have the right accessibility
                 return Invoke(ctor);
             }
+#endif
             return DelegateFactory.GenerateConstructorExpression(_typeMap.DestinationTypeToUse);
         }
 
         private Expression CreateNewDestinationExpression(ConstructorMap constructorMap)
         {
-            var ctorArgs = constructorMap.CtorParams.Select(CreateConstructorParameterExpression);
-            var variables = constructorMap.Ctor.GetParameters().Select(parameter => Variable(parameter.ParameterType, parameter.Name)).ToArray();
-            var body = variables.Zip(ctorArgs,
-                                                (variable, expression) => (Expression) Assign(variable, ToType(expression, variable.Type)))
-                                                .Concat(new[] { CheckReferencesCache(New(constructorMap.Ctor, variables)) })
+            var ctorArgs = constructorMap.CtorParams.Select(CreateConstructorParameterExpression);
+            var variables = constructorMap.Ctor.GetParameters().Select(parameter => Variable(parameter.ParameterType, parameter.Name)).ToArray();
+            var body = variables.Zip(ctorArgs,
+                                                (variable, expression) => (Expression) Assign(variable, ToType(expression, variable.Type)))
+                                                .Concat(new[] { CheckReferencesCache(New(constructorMap.Ctor, variables)) })
                                                 .ToArray();
             return Block(variables, body);
         }
-
+
         private TypePair[] GetConstructorMappingTypes()
         {
             if(_typeMap.DestinationCtor != null || _typeMap.ConstructDestinationUsingServiceLocator || _typeMap.ConstructorMap?.CanResolve != true)
-            {
+            {
                 return new TypePair[0];
-            }
-            return _typeMap.ConstructorMap.CtorParams.Select(p => new TypePair(ResolveSource(p).Type, p.DestinationType)).ToArray();
+            }
+            return _typeMap.ConstructorMap.CtorParams.Select(p => new TypePair(ResolveSource(p).Type, p.DestinationType)).ToArray();
         }
 
         private Expression ResolveSource(ConstructorParameterMap ctorParamMap)
@@ -371,7 +373,7 @@ private Expression ResolveSource(ConstructorParameterMap ctorParamMap)
         }
 
         private Expression CreateConstructorParameterExpression(ConstructorParameterMap ctorParamMap)
-        {
+        {
             var resolvedExpression = ResolveSource(ctorParamMap);
             var resolvedValue = Variable(resolvedExpression.Type, "resolvedValue");
             return Block(new[] {resolvedValue},
@@ -437,7 +439,7 @@ private Expression CreatePropertyMapFunc(PropertyMap propertyMap, Expression des
                 .Concat(_typeMap.ValueTransformers)
                 .Concat(_typeMap.Profile.ValueTransformers)
                 .Where(vt => vt.IsMatch(propertyMap))
-                .Aggregate(valueResolverExpr, (current, vtConfig) => ToType(ReplaceParameters(vtConfig.TransformerExpression, ToType(current, vtConfig.ValueType)), propertyMap.DestinationPropertyType));
+                .Aggregate(valueResolverExpr, (current, vtConfig) => ToType(ReplaceParameters(vtConfig.TransformerExpression, ToType(current, vtConfig.ValueType)), propertyMap.DestinationPropertyType));
 
             ParameterExpression propertyValue;
             Expression setPropertyValue;
@@ -558,15 +560,15 @@ private Expression BuildValueResolverFunc(PropertyMap propertyMap, Expression de
 
             return valueResolverFunc;
         }
-
-        private Expression Chain(IEnumerable<MemberInfo> members, Type destinationType) =>
-            members
+
+        private Expression Chain(IEnumerable<MemberInfo> members, Type destinationType) =>
+            members
                 .Aggregate(
                         (Expression) Source,
-                        (inner, getter) => getter is MethodInfo method ? 
-                            (getter.IsStatic() ? Call(null, method, inner) : (Expression) Call(inner, method)) : 
-                            MakeMemberAccess(getter.IsStatic() ? null : inner, getter))
-                .NullCheck(destinationType);
+                        (inner, getter) => getter is MethodInfo method ? 
+                            (getter.IsStatic() ? Call(null, method, inner) : (Expression) Call(inner, method)) : 
+                            MakeMemberAccess(getter.IsStatic() ? null : inner, getter))
+                .NullCheck(destinationType);
 
         private Expression CreateInstance(Type type)
             => Call(Property(Context, nameof(ResolutionContext.Options)),
diff --git a/src/AutoMapper/LockingConcurrentDictionary.cs b/src/AutoMapper/LockingConcurrentDictionary.cs
index 7dc6059f..b7eb3a52 100644
--- a/src/AutoMapper/LockingConcurrentDictionary.cs
+++ b/src/AutoMapper/LockingConcurrentDictionary.cs
@@ -31,7 +31,7 @@ public bool TryGetValue(TKey key, out TValue value)
                 value = lazy.Value;
                 return true;
             }
-            value = default(TValue);
+            value = default;
             return false;
         }
 
diff --git a/src/AutoMapper/Mapper.cs b/src/AutoMapper/Mapper.cs
index 3aca514b..b36e9247 100644
--- a/src/AutoMapper/Mapper.cs
+++ b/src/AutoMapper/Mapper.cs
@@ -200,7 +200,7 @@ public Mapper(IConfigurationProvider configurationProvider, Func<Type, object> s
         TDestination IMapper.Map<TDestination>(object source)
         {
             if (source == null)
-                return default(TDestination);
+                return default;
 
             var types = new TypePair(source.GetType(), typeof(TDestination));
 
diff --git a/src/AutoMapper/Mappers/TypeConverterMapper.cs b/src/AutoMapper/Mappers/TypeConverterMapper.cs
index 53e6c3db..1eb7f230 100644
--- a/src/AutoMapper/Mappers/TypeConverterMapper.cs
+++ b/src/AutoMapper/Mappers/TypeConverterMapper.cs
@@ -24,7 +24,7 @@ public class TypeConverterMapper : IObjectMapper
                 return (TDestination)typeConverter.ConvertFrom(source);
             }
 
-            return default(TDestination);
+            return default;
         }
 
         private static readonly MethodInfo MapMethodInfo = typeof(TypeConverterMapper).GetDeclaredMethod(nameof(Map));
diff --git a/src/AutoMapper/PropertyMap.cs b/src/AutoMapper/PropertyMap.cs
index e0bf20f3..448c65c0 100644
--- a/src/AutoMapper/PropertyMap.cs
+++ b/src/AutoMapper/PropertyMap.cs
@@ -17,7 +17,7 @@ public class PropertyMap
         private readonly List<MemberInfo> _memberChain = new List<MemberInfo>();
         private readonly List<ValueTransformerConfiguration> _valueTransformerConfigs = new List<ValueTransformerConfiguration>();
 
-        internal static PropertyMap Default { get; } = new PropertyMap(default(MemberInfo), default(TypeMap));
+        internal static PropertyMap Default { get; } = new PropertyMap(default(MemberInfo), default);
         
         public PropertyMap(PathMap pathMap)
         {
@@ -132,9 +132,9 @@ public void MapFrom(LambdaExpression sourceMember)
         public void MapFrom(string propertyOrField)
         {
             if(TypeMap.SourceType.IsGenericTypeDefinition())
-            {
+            {
                 return;
-            }
+            }
             MapFrom(MemberAccessLambda(TypeMap.SourceType, propertyOrField));
         }
 
diff --git a/src/AutoMapper/QueryableExtensions/ExpressionBuilder.cs b/src/AutoMapper/QueryableExtensions/ExpressionBuilder.cs
index 062d2f35..ac6df3b0 100644
--- a/src/AutoMapper/QueryableExtensions/ExpressionBuilder.cs
+++ b/src/AutoMapper/QueryableExtensions/ExpressionBuilder.cs
@@ -434,6 +434,7 @@ bool IsSubQuery()
 
             public override LetPropertyMaps New() => new FirstPassLetPropertyMaps(_configurationProvider);
 
+#if DYNAMIC_METHODS
             public override QueryExpressions GetSubQueryExpression(ExpressionBuilder builder, Expression projection, TypeMap typeMap, ExpressionRequest request, Expression instanceParameter, TypePairCount typePairCount)
             {
                 var letMapInfos = _savedPaths.Select(path => new
@@ -449,6 +450,7 @@ public override QueryExpressions GetSubQueryExpression(ExpressionBuilder builder
                 }).ToArray();
 
                 var properties = letMapInfos.Select(m => m.Property).Concat(GetMemberAccessesVisitor.Retrieve(projection, instanceParameter));
+
                 var letType = ProxyGenerator.GetSimilarType(typeof(object), properties);
                 var typeMapFactory = new TypeMapFactory();
                 TypeMap firstTypeMap;
@@ -476,6 +478,7 @@ void ReplaceSubQueries()
                     projection = new ReplaceMemberAccessesVisitor(instanceParameter, secondParameter).Visit(projection);
                 }
             }
+#endif
 
             class GetMemberAccessesVisitor : ExpressionVisitor
             {
@@ -544,7 +547,7 @@ public class LetPropertyMaps
         public virtual LetPropertyMaps New() => Default;
 
         public virtual QueryExpressions GetSubQueryExpression(ExpressionBuilder builder, Expression projection, TypeMap typeMap, ExpressionRequest request, Expression instanceParameter, TypePairCount typePairCount)
-            => throw new NotImplementedException();
+            => throw new NotImplementedException("Cannot generate let expression on this platform to handle complex projections where an expression refers to a parameter in an outer scope.");
 
         public struct PropertyPath
         {
diff --git a/src/AutoMapper/TypeExtensions.cs b/src/AutoMapper/TypeExtensions.cs
index 816a1ece..179bd03c 100644
--- a/src/AutoMapper/TypeExtensions.cs
+++ b/src/AutoMapper/TypeExtensions.cs
@@ -2,11 +2,10 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using System.Reflection.Emit;
 
 namespace AutoMapper
 {
-#if NET45
+#if DYNAMIC_METHODS
     using System.Reflection.Emit;
 #endif
 
@@ -22,16 +21,12 @@ internal static class TypeExtensions
 
         public static IEnumerable<ConstructorInfo> GetDeclaredConstructors(this Type type) => type.GetTypeInfo().DeclaredConstructors;
 
-#if !NET45
-        public static MethodInfo GetAddMethod(this EventInfo eventInfo) => eventInfo.AddMethod;
-
-        public static MethodInfo GetRemoveMethod(this EventInfo eventInfo) => eventInfo.RemoveMethod;
-#endif
-
+#if DYNAMIC_METHODS
         public static Type CreateType(this TypeBuilder type)
         {
             return type.CreateTypeInfo().AsType();
         }
+#endif
 
         public static IEnumerable<MemberInfo> GetDeclaredMembers(this Type type) => type.GetTypeInfo().DeclaredMembers;
 
diff --git a/src/UnitTests/Bug/MapAtRuntimeWithCollections/EntityDTO20.cs b/src/UnitTests/Bug/MapAtRuntimeWithCollections/EntityDTO20.cs
index 6ee826ac..f6a3682e 100644
--- a/src/UnitTests/Bug/MapAtRuntimeWithCollections/EntityDTO20.cs
+++ b/src/UnitTests/Bug/MapAtRuntimeWithCollections/EntityDTO20.cs
@@ -8,7 +8,6 @@ namespace OmmitedDTOModel3WithCollections
 {
     public class EntityDTO20 : BaseEntity
     {
-        //TODO Remove comments
         public EntityDTO20()
         {
             this.Entities8 = new List<EntityDTO8>();
diff --git a/src/UnitTests/Internal/CreateProxyThreading.cs b/src/UnitTests/Internal/CreateProxyThreading.cs
index ae3dc785..82e95367 100644
--- a/src/UnitTests/Internal/CreateProxyThreading.cs
+++ b/src/UnitTests/Internal/CreateProxyThreading.cs
@@ -1,4 +1,5 @@
-﻿using System;
+﻿#if DYNAMIC_METHODS
+using System;
 using System.Linq;
 using System.Threading.Tasks;
 using AutoMapper.Execution;
@@ -34,4 +35,5 @@ public interface ISomeDto
         }
 
     }
-}
\ No newline at end of file
+}
+#endif
\ No newline at end of file
