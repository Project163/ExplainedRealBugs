diff --git a/src/AutoMapper/PropertyMap.cs b/src/AutoMapper/PropertyMap.cs
index bfa3cc05..36e3ea18 100644
--- a/src/AutoMapper/PropertyMap.cs
+++ b/src/AutoMapper/PropertyMap.cs
@@ -8,6 +8,9 @@
 
 namespace AutoMapper
 {
+    using System.Diagnostics;
+
+    [DebuggerDisplay("{DestinationProperty.Name}")]
     public class PropertyMap
     {
         private readonly LinkedList<IValueResolver> _sourceValueResolvers = new LinkedList<IValueResolver>();
diff --git a/src/AutoMapper/TypeInfo.cs b/src/AutoMapper/TypeInfo.cs
index f1b50797..f521dad0 100644
--- a/src/AutoMapper/TypeInfo.cs
+++ b/src/AutoMapper/TypeInfo.cs
@@ -7,10 +7,13 @@
 using AutoMapper.Internal;
 
 namespace AutoMapper
-{
+{
+    using System.Diagnostics;
+
     /// <summary>
     /// Contains cached reflection information for easy retrieval
-    /// </summary>
+    /// </summary>
+    [DebuggerDisplay("{Type}")]
     public class TypeInfo
     {
         private readonly MemberInfo[] _publicGetters;
diff --git a/src/AutoMapper/TypeMap.cs b/src/AutoMapper/TypeMap.cs
index e8de78f2..754136e2 100644
--- a/src/AutoMapper/TypeMap.cs
+++ b/src/AutoMapper/TypeMap.cs
@@ -2,6 +2,7 @@ namespace AutoMapper
 {
     using System;
     using System.Collections.Generic;
+    using System.Diagnostics;
     using System.Linq;
     using System.Reflection;
     using Impl;
@@ -10,6 +11,7 @@ namespace AutoMapper
     /// <summary>
     /// Main configuration object holding all mapping configuration for a source and destination type
     /// </summary>
+    [DebuggerDisplay("{_sourceType.Type.Name} -> {_destinationType.Type.Name}")]
     public class TypeMap
     {
         private readonly IList<Action<object, object>> _afterMapActions = new List<Action<object, object>>();
@@ -263,9 +265,34 @@ public override int GetHashCode()
 
         public PropertyMap GetExistingPropertyMapFor(IMemberAccessor destinationProperty)
         {
-            return _propertyMaps.FirstOrDefault(pm => pm.DestinationProperty.Name.Equals(destinationProperty.Name))
-                   ??
-                   _inheritedMaps.FirstOrDefault(pm => pm.DestinationProperty.Name.Equals(destinationProperty.Name));
+            var propertyMap =
+                _propertyMaps.FirstOrDefault(pm => pm.DestinationProperty.Name.Equals(destinationProperty.Name));
+
+            if (propertyMap != null)
+                return propertyMap;
+
+            propertyMap =
+                _inheritedMaps.FirstOrDefault(pm => pm.DestinationProperty.Name.Equals(destinationProperty.Name));
+
+            if (propertyMap == null)
+                return null;
+
+            var propertyInfo = propertyMap.DestinationProperty.MemberInfo as PropertyInfo;
+
+            if (propertyInfo == null)
+                return propertyMap;
+
+            var baseAccessor = propertyInfo.GetAccessors()[0];
+
+            if (baseAccessor.IsAbstract || baseAccessor.IsVirtual)
+                return propertyMap;
+
+            var accessor = ((PropertyInfo)destinationProperty.MemberInfo).GetAccessors()[0];
+
+            if (baseAccessor.DeclaringType == accessor.DeclaringType)
+                return propertyMap;
+
+            return null;
         }
 
         public void AddInheritedPropertyMap(PropertyMap mappedProperty)
diff --git a/src/UnitTests/Bug/ParentChildResolversBug.cs b/src/UnitTests/Bug/ParentChildResolversBug.cs
new file mode 100644
index 00000000..43c62ce4
--- /dev/null
+++ b/src/UnitTests/Bug/ParentChildResolversBug.cs
@@ -0,0 +1,112 @@
+ï»¿namespace AutoMapper.UnitTests.Bug
+{
+    namespace ParentChildResolversBug
+    {
+        using Should;
+        using Xunit;
+
+        public enum DestEnum
+        {
+            a,
+            b,
+            c,
+        }
+
+        public enum ParentDestEnum
+        {
+            d,
+            e,
+            f
+        }
+
+        public class ParentDest
+        {
+            public ParentDestEnum? field
+            {
+                get;
+                set;
+            }
+        }
+
+        public class Dest : ParentDest
+        {
+            public new DestEnum? field
+            {
+                get;
+                set;
+            }
+        }
+
+        public class Source
+        {
+            public string fieldCode
+            {
+                get;
+                set;
+            }
+        }
+
+
+        public class ParentResolver : ValueResolver<Source, ParentDestEnum?>
+        {
+            protected override ParentDestEnum? ResolveCore(Source source)
+            {
+                switch (source.fieldCode)
+                {
+                    case "testa": return ParentDestEnum.d;
+                    case "testb": return ParentDestEnum.e;
+                    case "testc": return ParentDestEnum.f;
+                    default: return null;
+                }
+            }
+        }
+
+        public class Resolver : ValueResolver<Source, DestEnum?>
+        {
+            protected override DestEnum? ResolveCore(Source source)
+            {
+                switch (source.fieldCode)
+                {
+                    case "testa": return DestEnum.a;
+                    case "testb": return DestEnum.b;
+                    case "testc": return DestEnum.c;
+                    default: return null;
+                }
+            }
+        }
+
+        public class ParentChildResolverTests : AutoMapperSpecBase
+        {
+            private Dest _dest;
+
+            protected override void Establish_context()
+            {
+                Mapper.Initialize(cfg =>
+                {
+                    cfg.CreateMap<Source, ParentDest>()
+                        .ForMember(dest => dest.field, opt => opt.ResolveUsing<ParentResolver>())
+                        .Include<Source, Dest>();
+
+                    cfg.CreateMap<Source, Dest>()
+                        .ForMember(dest => dest.field, opt => opt.ResolveUsing<Resolver>());
+                });
+            }
+
+            protected override void Because_of()
+            {
+                var source = new Source()
+                {
+                    fieldCode = "testa"
+                };
+
+                _dest = Mapper.Map<Dest>(source);
+            }
+
+            [Fact]
+            public void Should_use_correct_resolver()
+            {
+                _dest.field.ShouldEqual(DestEnum.a);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/UnitTests/UnitTests.Net4.csproj b/src/UnitTests/UnitTests.Net4.csproj
index 37d42328..a16186a1 100644
--- a/src/UnitTests/UnitTests.Net4.csproj
+++ b/src/UnitTests/UnitTests.Net4.csproj
@@ -117,6 +117,7 @@
     <Compile Include="Bug\NullableEnumToNullableValueType.cs" />
     <Compile Include="Bug\NullablePropertiesBug.cs" />
     <Compile Include="Bug\ObjectTypeMapFailure.cs" />
+    <Compile Include="Bug\ParentChildResolversBug.cs" />
     <Compile Include="Bug\ProjectCollectionsBug.cs" />
     <Compile Include="Bug\RecognizeIxesBug.cs" />
     <Compile Include="Bug\RepeatedMappingConfigurationTest.cs" />
