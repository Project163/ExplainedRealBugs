diff --git a/src/AutoMapper/Execution/ExpressionBuilder.cs b/src/AutoMapper/Execution/ExpressionBuilder.cs
index e8cbeb7a..15d64b9e 100644
--- a/src/AutoMapper/Execution/ExpressionBuilder.cs
+++ b/src/AutoMapper/Execution/ExpressionBuilder.cs
@@ -25,7 +25,6 @@ public static class ExpressionBuilder
         public static readonly ParameterExpression ContextParameter = Parameter(typeof(ResolutionContext), "context");
         public static readonly MethodInfo IListClear = typeof(IList).GetMethod(nameof(IList.Clear));
         public static readonly MethodInfo IListAdd = typeof(IList).GetMethod(nameof(IList.Add));
-        public static readonly PropertyInfo IListIsReadOnly = typeof(IList).GetProperty(nameof(IList.IsReadOnly));
         public static readonly MethodInfo IncTypeDepthInfo = typeof(ResolutionContext).GetMethod(nameof(ResolutionContext.IncrementTypeDepth), TypeExtensions.InstanceFlags);
         public static readonly MethodInfo DecTypeDepthInfo = typeof(ResolutionContext).GetMethod(nameof(ResolutionContext.DecrementTypeDepth), TypeExtensions.InstanceFlags);
         public static readonly MethodInfo ContextCreate = typeof(ResolutionContext).GetMethod(nameof(ResolutionContext.CreateInstance), TypeExtensions.InstanceFlags);
@@ -83,12 +82,10 @@ Expression ClearDestinationCollection()
             {
                 Type destinationCollectionType;
                 MethodInfo clearMethod;
-                PropertyInfo isReadOnlyProperty;
                 if (destinationType.IsListType())
                 {
                     destinationCollectionType = typeof(IList);
                     clearMethod = IListClear;
-                    isReadOnlyProperty = IListIsReadOnly;
                 }
                 else
                 {
@@ -98,14 +95,12 @@ Expression ClearDestinationCollection()
                         return null;
                     }
                     clearMethod = destinationCollectionType.GetMethod("Clear");
-                    isReadOnlyProperty = destinationCollectionType.GetProperty("IsReadOnly");
                 }
                 var destinationVariable = Variable(destinationCollectionType, "collectionDestination");
                 var clear = Expression.Call(destinationVariable, clearMethod);
-                var isReadOnly = Expression.Property(destinationVariable, isReadOnlyProperty);
                 return Block(new[] {destinationVariable},
                     Assign(destinationVariable, ToType(destinationParameter, destinationCollectionType)),
-                    Condition(OrElse(ReferenceEqual(destinationVariable, Null), isReadOnly), Empty, clear),
+                    Condition(ReferenceEqual(destinationVariable, Null), Empty, clear),
                     destination);
             }
             Expression DefaultDestination()
diff --git a/src/AutoMapper/Mappers/CollectionMapper.cs b/src/AutoMapper/Mappers/CollectionMapper.cs
index cb99add8..d76b6d4e 100644
--- a/src/AutoMapper/Mappers/CollectionMapper.cs
+++ b/src/AutoMapper/Mappers/CollectionMapper.cs
@@ -48,7 +48,7 @@ Expression MapCollectionCore(Expression destExpression)
             {
                 var destinationType = destExpression.Type;
                 MethodInfo addMethod;
-                bool isIList;
+                bool isIList, mustUseDestination = memberMap != null && (memberMap.UseDestinationValue == true || !memberMap.CanBeSet);
                 Type destinationCollectionType, destinationElementType;
                 GetDestinationType();
                 var passedDestination = Variable(destExpression.Type, "passedDestination");
@@ -80,26 +80,29 @@ void GetDestinationType()
                 {
                     destinationCollectionType = destinationType.GetICollectionType();
                     destinationElementType = destinationCollectionType?.GenericTypeArguments[0] ?? GetEnumerableElementType(destinationType);
-                    if (destinationCollectionType == null && destinationType.IsInterface)
-                    {
-                        destinationCollectionType = typeof(ICollection<>).MakeGenericType(destinationElementType);
-                        destExpression = ToType(destExpression, destinationCollectionType);
-                    }
+                    isIList = destExpression.Type.IsListType();
                     if (destinationCollectionType == null)
                     {
-                        destinationCollectionType = typeof(IList);
-                        addMethod = IListAdd;
-                        isIList = true;
+                        if (isIList)
+                        {
+                            destinationCollectionType = typeof(IList);
+                            addMethod = IListAdd;
+                        }
+                        else
+                        {
+                            destinationCollectionType = typeof(ICollection<>).MakeGenericType(destinationElementType);
+                            destExpression = Convert(mustUseDestination ? destExpression : Null, destinationCollectionType);
+                            addMethod = destinationCollectionType.GetMethod("Add");
+                        }
                     }
                     else
                     {
-                        isIList = destExpression.Type.IsListType();
                         addMethod = destinationCollectionType.GetMethod("Add");
                     }
                 }
                 void UseDestinationValue()
                 {
-                    if (memberMap is { UseDestinationValue: true })
+                    if (mustUseDestination)
                     {
                         destination = passedDestination;
                         assignNewExpression = ExpressionBuilder.Empty;
@@ -107,14 +110,7 @@ void UseDestinationValue()
                     else
                     {
                         destination = newExpression;
-                        var createInstance = ObjectFactory.GenerateConstructorExpression(passedDestination.Type);
-                        var shouldCreateDestination = ReferenceEqual(passedDestination, Null);
-                        if (memberMap is { CanBeSet: true })
-                        {
-                            var isReadOnly = isIList ? Property(passedDestination, IListIsReadOnly) : ExpressionBuilder.Property(ToType(passedDestination, destinationCollectionType), "IsReadOnly");
-                            shouldCreateDestination = OrElse(shouldCreateDestination, isReadOnly);
-                        }
-                        assignNewExpression = Assign(newExpression, Condition(shouldCreateDestination, ToType(createInstance, passedDestination.Type), passedDestination));
+                        assignNewExpression = Assign(newExpression, Coalesce(passedDestination, ObjectFactory.GenerateConstructorExpression(passedDestination.Type)));
                     }
                 }
                 Expression CheckContext()
diff --git a/src/UnitTests/ArraysAndLists.cs b/src/UnitTests/ArraysAndLists.cs
index b85b1de5..7f7be8cd 100644
--- a/src/UnitTests/ArraysAndLists.cs
+++ b/src/UnitTests/ArraysAndLists.cs
@@ -12,7 +12,40 @@
 using AutoMapper.Internal.Mappers;
 
 namespace AutoMapper.UnitTests.ArraysAndLists
-{
+{
+    public class When_mapping_to_Existing_IEnumerable : AutoMapperSpecBase
+    {
+        public class Source
+        {
+            public IEnumerable<SourceItem> Items { get; set; } = Enumerable.Empty<SourceItem>();
+        }
+        public class Destination
+        {
+            public IEnumerable<DestinationItem> Items { get; set; } = Enumerable.Empty<DestinationItem>();
+        }
+        public class SourceItem
+        {
+            public string Value { get; set; }
+        }
+        public class DestinationItem
+        {
+            public string Value { get; set; }
+        }
+        protected override MapperConfiguration Configuration => new MapperConfiguration(c =>
+        {
+            c.CreateMap<Source, Destination>();
+            c.CreateMap<SourceItem, DestinationItem>();
+        });
+        [Fact]
+        public void Should_overwrite_the_existing_list()
+        {
+            var destination = new Destination();
+            var existingList = destination.Items;
+            Mapper.Map(new Source(), destination);
+            destination.Items.ShouldNotBeSameAs(existingList);
+            destination.Items.ShouldBeEmpty();
+        }
+    }
     public class When_mapping_to_an_array_as_ICollection_with_MapAtRuntime : AutoMapperSpecBase
     {
         Destination _destination;
@@ -478,7 +511,7 @@ public class Destination
         {
             cfg.CreateMap<Source, Destination>();
         });
-        protected override void Because_of() => Mapper.Map<Source, Destination>(new Source { Values = new[] { 1, 2, 3, 4 }, Values2 = new List<int> { 9, 8, 7, 6 } }, _destination);
+        protected override void Because_of() => Mapper.Map(new Source { Values = new[] { 1, 2, 3, 4 }, Values2 = new List<int> { 9, 8, 7, 6 } }, _destination);
         [Fact]
         public void Should_map_the_list_of_source_items()
         {
diff --git a/src/UnitTests/MappingInheritance/IncludedMappingShouldInheritBaseMappings.cs b/src/UnitTests/MappingInheritance/IncludedMappingShouldInheritBaseMappings.cs
index 1508c533..6eb3862c 100644
--- a/src/UnitTests/MappingInheritance/IncludedMappingShouldInheritBaseMappings.cs
+++ b/src/UnitTests/MappingInheritance/IncludedMappingShouldInheritBaseMappings.cs
@@ -9,40 +9,27 @@ public class ReadonlyCollectionPropertiesOverride : AutoMapperSpecBase
     {
         protected override MapperConfiguration Configuration => new MapperConfiguration(cfg =>
         {
-            cfg.CreateMap<DomainModelBase, ModelBase>()
-                .ForMember(d => d.CodeList, o => o.MapFrom(s => s.CodeList))
-                .ForMember(d => d.KeyValuesOtherName, o => o.MapFrom(s => new[] { new KeyValueModel { Key = "key1", Value = "value1" } }))
-                .Include<DomainModel, Model>();
-            cfg.CreateMap<DomainModel, Model>().ForAllMembers(o => o.DoNotUseDestinationValue());
+            cfg.CreateMap<SourceBase, DestinationBase>()
+                .Include<Source, Destination>()
+                .ForMember(d=>d.CodeList, o => o.UseDestinationValue());
+            cfg.CreateMap<Source, Destination>().ForMember(d=>d.CodeList, o => o.DoNotUseDestinationValue());
         });
-        public class DomainModelBase
+        public class SourceBase
         {
             public ICollection<string> CodeList { get; } = new List<string>();
         }
-        public class DomainModel : DomainModelBase
+        public class Source : SourceBase
         {
         }
-        public class ModelBase
-        {
-            public ICollection<KeyValueModel> KeyValuesOtherName { get; } = new List<KeyValueModel>();
-            public ICollection<string> CodeList { get; } = new List<string>();
-        }
-        public class Model : ModelBase
+        public class DestinationBase
         {
+            public ICollection<string> CodeList { get; set; } = new HashSet<string>();
         }
-        public class KeyValueModel
+        public class Destination : DestinationBase
         {
-            public string Key { get; set; }
-            public string Value { get; set; }
         }
         [Fact]
-        public void ShouldMapOk()
-        {
-            var domainModel = new DomainModel { CodeList = { "DMItemCode1" } };
-            var result = Mapper.Map<Model>(domainModel);
-            result.CodeList.ShouldBeEmpty();
-            result.KeyValuesOtherName.ShouldBeEmpty();
-        }
+        public void ShouldMapOk() => Mapper.Map<Destination>(new Source { CodeList = { "DMItemCode1" } }).CodeList.ShouldNotBeOfType<HashSet<string>>();
     }
     public class ReadonlyCollectionProperties : AutoMapperSpecBase
     {
