diff --git a/src/AutoMapper/Execution/RuntimeMapper.cs b/src/AutoMapper/Execution/RuntimeMapper.cs
new file mode 100644
index 00000000..5e60ff5d
--- /dev/null
+++ b/src/AutoMapper/Execution/RuntimeMapper.cs
@@ -0,0 +1,103 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Linq.Expressions;
+
+namespace AutoMapper.Execution
+{
+    internal class RuntimeMapper : IRuntimeMapper
+    {
+        private readonly ResolutionContext _resolutionContext;
+        private readonly IRuntimeMapper _inner;
+
+        public RuntimeMapper(ResolutionContext resolutionContext, IRuntimeMapper inner)
+        {
+            _resolutionContext = resolutionContext;
+            _inner = inner;
+        }
+
+        public IConfigurationProvider ConfigurationProvider => _inner.ConfigurationProvider;
+        public Func<Type, object> ServiceCtor => _inner.ServiceCtor;
+        public ResolutionContext DefaultContext => _inner.DefaultContext;
+
+        public TDestination Map<TDestination>(object source)
+            => (TDestination)_inner.Map(source, null, source.GetType(), typeof(TDestination), _resolutionContext);
+
+        public TDestination Map<TDestination>(object source, Action<IMappingOperationOptions> opts)
+        {
+            opts(_resolutionContext.Options);
+
+            return Map<TDestination>(source);
+        }
+
+        public TDestination Map<TSource, TDestination>(TSource source)
+            => _inner.Map(source, default(TDestination), _resolutionContext);
+
+        public TDestination Map<TSource, TDestination>(TSource source, Action<IMappingOperationOptions<TSource, TDestination>> opts)
+        {
+            var typedOptions = new MappingOperationOptions<TSource, TDestination>(_inner.ServiceCtor);
+
+            opts(typedOptions);
+
+            var destination = default(TDestination);
+
+            typedOptions.BeforeMapAction(source, destination);
+
+            destination = _inner.Map(source, destination, _resolutionContext);
+
+            typedOptions.AfterMapAction(source, destination);
+
+            return destination;
+        }
+
+        public TDestination Map<TSource, TDestination>(TSource source, TDestination destination)
+            => _inner.Map(source, destination, _resolutionContext);
+
+        public TDestination Map<TSource, TDestination>(TSource source, TDestination destination, Action<IMappingOperationOptions<TSource, TDestination>> opts)
+        {
+            var typedOptions = new MappingOperationOptions<TSource, TDestination>(_inner.ServiceCtor);
+
+            opts(typedOptions);
+
+            typedOptions.BeforeMapAction(source, destination);
+
+            destination = _inner.Map(source, destination, _resolutionContext);
+
+            typedOptions.AfterMapAction(source, destination);
+
+            return destination;
+        }
+
+        public object Map(object source, Type sourceType, Type destinationType)
+            => _inner.Map(source, null, sourceType, destinationType, _resolutionContext);
+
+        public object Map(object source, Type sourceType, Type destinationType, Action<IMappingOperationOptions> opts)
+        {
+            opts(_resolutionContext.Options);
+
+            return Map(source, sourceType, destinationType);
+        }
+
+        public object Map(object source, object destination, Type sourceType, Type destinationType)
+            => _inner.Map(source, destination, sourceType, destinationType, _resolutionContext);
+
+        public object Map(object source, object destination, Type sourceType, Type destinationType, Action<IMappingOperationOptions> opts)
+        {
+            opts(_resolutionContext.Options);
+
+            return Map(source, destination, sourceType, destinationType);
+        }
+
+        public IQueryable<TDestination> ProjectTo<TDestination>(IQueryable source, object parameters = null, params Expression<Func<TDestination, object>>[] membersToExpand)
+            => _inner.ProjectTo(source, parameters, membersToExpand);
+
+        public IQueryable<TDestination> ProjectTo<TDestination>(IQueryable source, IDictionary<string, object> parameters, params string[] membersToExpand)
+            => _inner.ProjectTo<TDestination>(source, parameters, membersToExpand);
+
+        public object Map(object source, object destination, Type sourceType, Type destinationType, ResolutionContext context, IMemberMap memberMap = null)
+            => _inner.Map(source, destination, sourceType, destinationType, context, memberMap);
+
+        public TDestination Map<TSource, TDestination>(TSource source, TDestination destination, ResolutionContext context, IMemberMap memberMap = null)
+            => _inner.Map(source, destination, context, memberMap);
+    }
+}
\ No newline at end of file
diff --git a/src/AutoMapper/ResolutionContext.cs b/src/AutoMapper/ResolutionContext.cs
index f04958ae..1f9a1c82 100644
--- a/src/AutoMapper/ResolutionContext.cs
+++ b/src/AutoMapper/ResolutionContext.cs
@@ -1,5 +1,6 @@
 using System;
 using System.Collections.Generic;
+using AutoMapper.Execution;
 
 namespace AutoMapper
 {
@@ -105,7 +106,7 @@ internal int GetTypeDepth(TypePair types)
         public ResolutionContext(IMappingOperationOptions options, IRuntimeMapper mapper)
         {
             Options = options;
-            Mapper = mapper;
+            Mapper = new RuntimeMapper(this, mapper);
         }
 
         internal bool IsDefault => this == Mapper.DefaultContext;
diff --git a/src/UnitTests/ContextItems.cs b/src/UnitTests/ContextItems.cs
index 05310ad7..43989606 100644
--- a/src/UnitTests/ContextItems.cs
+++ b/src/UnitTests/ContextItems.cs
@@ -1,4 +1,7 @@
-﻿namespace AutoMapper.UnitTests
+﻿using System.Collections.Generic;
+using System.Linq;
+
+namespace AutoMapper.UnitTests
 {
     namespace ContextItems
     {
@@ -93,5 +96,98 @@ public void Should_use_value_passed_in()
                 dest.Value1.ShouldBe(15);
             }
         }
+
+        public class When_mapping_nested_context_items : AutoMapperSpecBase
+        {
+            public class Door { }
+
+            public class FromGarage
+            {
+                public List<FromCar> FromCars { get; set; }
+            }
+
+            public class ToGarage
+            {
+                public List<ToCar> ToCars { get; set; }
+            }
+
+            public class FromCar
+            {
+                public int Id { get; set; }
+                public string Name { get; set; }
+                public Door Door { get; set; }
+            }
+
+            public class ToCar
+            {
+                public int Id { get; set; }
+                public string Name { get; set; }
+                public Door Door { get; set; }
+            }
+
+            protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
+            {
+                cfg.CreateMap<FromGarage, ToGarage>()
+                    .ForMember(dest => dest.ToCars, opts => opts.MapFrom((src, dest, destVal, ctx) =>
+                    {
+                        var toCars = new List<ToCar>();
+
+                        ToCar toCar;
+                        foreach (var fromCar in src.FromCars)
+                        {
+                            toCar = ctx.Mapper.Map<ToCar>(fromCar);
+                            if (toCar == null)
+                                continue;
+
+                            toCars.Add(toCar);
+                        }
+
+                        return toCars;
+                    }));
+
+                cfg.CreateMap<FromCar, ToCar>()
+                    .ConvertUsing((src, dest, ctx) =>
+                    {
+                        ToCar toCar = null;
+                        FromCar fromCar = src;
+
+                        if (fromCar.Name != null)
+                        {
+                            toCar = new ToCar
+                            {
+                                Id = fromCar.Id,
+                                Name = fromCar.Name,
+                                Door = (Door) ctx.Items["Door"]
+                            };
+                        }
+
+                        return toCar;
+                    });
+            });
+
+            [Fact]
+            public void Should_flow_context_items_to_nested_mappings()
+            {
+                var door = new Door();
+                var fromGarage = new FromGarage
+                {
+                    FromCars = new List<FromCar>
+                    {
+                        new FromCar {Door = door, Id = 2, Name = "Volvo"},
+                        new FromCar {Door = door, Id = 3, Name = "Hyundai"},
+                    }
+                };
+
+                var toGarage = Mapper.Map<ToGarage>(fromGarage, opts =>
+                {
+                    opts.Items.Add("Door", door);
+                });
+
+                foreach (var d in toGarage.ToCars.Select(c => c.Door))
+                {
+                    d.ShouldBeSameAs(door);
+                }
+            }
+        }
     }
 }
\ No newline at end of file
