diff --git a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
index 42c25dce..2864ced0 100644
--- a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
+++ b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
@@ -68,13 +68,17 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
                 return Lambda(typeMap.CustomProjection.ReplaceParameters(srcParam), srcParam, destParam, ctxtParam);
             }
 
-            var destinationFunc = CreateDestinationFunc(typeMap, typeMapRegistry, srcParam, destParam, ctxtParam);
+            bool constructorMapping;
 
-            var assignmentFunc = CreateAssignmentFunc(typeMap, configurationProvider, typeMapRegistry, srcParam, destParam, ctxtParam, destinationFunc);
+            var destination = Variable(destParam.Type, "destination");
 
-            var mapperFunc = CreateMapperFunc(typeMap, srcParam, destParam, ctxtParam, assignmentFunc);
+            var destinationFunc = CreateDestinationFunc(typeMap, typeMapRegistry, srcParam, destParam, ctxtParam, destination, out constructorMapping);
 
-            var lambdaExpr = Lambda(mapperFunc, srcParam, destParam, ctxtParam);
+            var assignmentFunc = CreateAssignmentFunc(typeMap, configurationProvider, typeMapRegistry, srcParam, destParam, ctxtParam, destinationFunc, destination, constructorMapping);
+
+            var mapperFunc = CreateMapperFunc(typeMap, srcParam, destination, ctxtParam, assignmentFunc);
+
+            var lambdaExpr = Lambda(Block(new[] { destination }, mapperFunc), srcParam, destParam, ctxtParam);
 
             return lambdaExpr;
         }
@@ -84,16 +88,18 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
             TypeMapRegistry typeMapRegistry,
             ParameterExpression srcParam,
             ParameterExpression destParam,
-            ParameterExpression ctxtParam)
+            ParameterExpression ctxtParam,
+            ParameterExpression destination,
+            out bool constructorMapping)
         {
-            var newDestFunc = ToType(CreateNewDestinationFunc(typeMap, typeMapRegistry, srcParam, ctxtParam),
+            var newDestFunc = ToType(CreateNewDestinationFunc(typeMap, typeMapRegistry, srcParam, ctxtParam, out constructorMapping),
                 typeMap.DestinationTypeToUse);
 
             var getDest = typeMap.DestinationTypeToUse.GetTypeInfo().IsValueType
                 ? newDestFunc
                 : Coalesce(destParam, newDestFunc);
 
-            Expression destinationFunc = Assign(destParam, getDest);
+            Expression destinationFunc = Assign(destination, getDest);
 
             if (typeMap.PreserveReferences)
             {
@@ -120,18 +126,27 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
             ParameterExpression srcParam,
             ParameterExpression destParam,
             ParameterExpression ctxtParam,
-            Expression destinationFunc)
+            Expression destinationFunc,
+            ParameterExpression destination,
+            bool constructorMapping)
         {
-            var typeMaps = typeMap.GetPropertyMaps()
-                    .Where(pm => pm.CanResolveValue() && !typeMap.IsMappedThroughConstructor(pm.DestinationProperty.Name))
-                    .Select(pm => TryPropertyMap(pm, configurationProvider, registry, srcParam, destParam, ctxtParam))
-                    .ToList();
-
-            var actions = typeMaps;
-
+            var actions = new List<Expression>();
+            foreach(var propertyMap in typeMap.GetPropertyMaps())
+            {
+                if(!propertyMap.CanResolveValue())
+                {
+                    continue;
+                }
+                var property = TryPropertyMap(propertyMap, configurationProvider, registry, srcParam, destination, ctxtParam);
+                if(constructorMapping && typeMap.ConstructorParameterMatches(propertyMap.DestinationProperty.Name))
+                {
+                    property = IfThen(NotEqual(destParam, Expression.Constant(null)), property);
+                }
+                actions.Add(property);
+            }
             foreach (var beforeMapAction in typeMap.BeforeMapActions)
             {
-                actions.Insert(0, beforeMapAction.ReplaceParameters(srcParam, destParam, ctxtParam));
+                actions.Insert(0, beforeMapAction.ReplaceParameters(srcParam, destination, ctxtParam));
             }
             actions.Insert(0, destinationFunc);
             if (typeMap.MaxDepth > 0)
@@ -140,14 +155,14 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
             }
             actions.AddRange(
                 typeMap.AfterMapActions.Select(
-                    afterMapAction => afterMapAction.ReplaceParameters(srcParam, destParam, ctxtParam)));
+                    afterMapAction => afterMapAction.ReplaceParameters(srcParam, destination, ctxtParam)));
 
             if (typeMap.MaxDepth > 0)
             {
                 actions.Add(Call(ctxtParam, ((MethodCallExpression)DecTypeDepthInfo.Body).Method, Constant(typeMap.Types)));
             }
 
-            actions.Add(destParam);
+            actions.Add(destination);
 
             return Block(actions);
         }
@@ -215,8 +230,11 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
             TypeMap typeMap,
             TypeMapRegistry typeMapRegistry,
             ParameterExpression srcParam,
-            ParameterExpression ctxtParam)
+            ParameterExpression ctxtParam,
+            out bool constructorMapping)
         {
+            constructorMapping = false;
+
             if (typeMap.DestinationCtor != null)
                 return typeMap.DestinationCtor.ReplaceParameters(srcParam, ctxtParam);
 
@@ -226,9 +244,11 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
                         .MakeGenericMethod(typeMap.DestinationTypeToUse)
                     );
 
-            if (typeMap.ConstructorMap?.CanResolve == true)
+            if(typeMap.ConstructorMap?.CanResolve == true)
+            {
+                constructorMapping = true;
                 return typeMap.ConstructorMap.BuildExpression(typeMapRegistry, srcParam, ctxtParam);
-
+            }
 #if NET45
             if (typeMap.DestinationTypeToUse.IsInterface())
             {
diff --git a/src/AutoMapper/TypeMap.cs b/src/AutoMapper/TypeMap.cs
index 3de9918d..c66e2222 100644
--- a/src/AutoMapper/TypeMap.cs
+++ b/src/AutoMapper/TypeMap.cs
@@ -87,7 +87,7 @@ public PropertyMap[] GetPropertyMaps()
             return _orderedPropertyMaps ?? _propertyMaps.Concat(_inheritedMaps).ToArray();
         }
 
-        public bool IsMappedThroughConstructor(string destinationPropertyName)
+        public bool ConstructorParameterMatches(string destinationPropertyName)
         {
             return ConstructorMap?.CtorParams.Any(c => c.Parameter.Name.Equals(destinationPropertyName, StringComparison.OrdinalIgnoreCase)) == true;
         }
diff --git a/src/UnitTests/Constructors.cs b/src/UnitTests/Constructors.cs
index 1493786f..f6e6b3d4 100644
--- a/src/UnitTests/Constructors.cs
+++ b/src/UnitTests/Constructors.cs
@@ -5,6 +5,175 @@
 
 namespace AutoMapper.UnitTests.Constructors
 {
+    public class When_constructor_is_partial_match_with_value_type : AutoMapperSpecBase
+    {
+        GeoCoordinate _destination;
+
+        public class GeolocationDTO
+        {
+            public double Longitude { get; set; }
+            public double Latitude { get; set; }
+            public double? HorizontalAccuracy { get; set; }
+        }
+
+        public struct GeoCoordinate
+        {
+            public GeoCoordinate(double longitude, double latitude, double x)
+            {
+                Longitude = longitude;
+                Latitude = latitude;
+                HorizontalAccuracy = 0;
+            }
+            public double Longitude { get; set; }
+            public double Latitude { get; set; }
+            public double? HorizontalAccuracy { get; set; }
+        }
+
+        protected override MapperConfiguration Configuration => new MapperConfiguration(cfg =>
+        {
+            cfg.CreateMap<GeoCoordinate, GeolocationDTO>();
+            cfg.CreateMap<GeolocationDTO, GeoCoordinate>();
+        });
+
+        protected override void Because_of()
+        {
+            var source = new GeolocationDTO
+            {
+                Latitude = 34d,
+                Longitude = -93d,
+                HorizontalAccuracy = 100
+            };
+            _destination = Mapper.Map<GeoCoordinate>(source);
+        }
+
+        [Fact]
+        public void Should_map_ok()
+        {
+            _destination.Latitude.ShouldEqual(34);
+            _destination.Longitude.ShouldEqual(-93);
+            _destination.HorizontalAccuracy.ShouldEqual(100);
+        }
+    }
+
+    public class When_constructor_is_partial_match : AutoMapperSpecBase
+    {
+        GeoCoordinate _destination;
+
+        public class GeolocationDTO
+        {
+            public double Longitude { get; set; }
+            public double Latitude { get; set; }
+            public double? HorizontalAccuracy { get; set; }
+        }
+
+        public class GeoCoordinate
+        {
+            public GeoCoordinate()
+            {
+            }
+            public GeoCoordinate(double longitude, double latitude, double x)
+            {
+                Longitude = longitude;
+                Latitude = latitude;
+            }
+            public double Longitude { get; set; }
+            public double Latitude { get; set; }
+            public double? HorizontalAccuracy { get; set; }
+            public double Altitude { get; set; }
+            public double VerticalAccuracy { get; set; }
+            public double Speed { get; set; }
+            public double Course { get; set; }
+        }
+
+        protected override MapperConfiguration Configuration => new MapperConfiguration(cfg =>
+        {
+            cfg.CreateMap<GeoCoordinate, GeolocationDTO>();
+
+            cfg.CreateMap<GeolocationDTO, GeoCoordinate>()
+                .ForMember(dest => dest.Altitude, opt => opt.Ignore())
+                .ForMember(dest => dest.VerticalAccuracy, opt => opt.Ignore())
+                .ForMember(dest => dest.Speed, opt => opt.Ignore())
+                .ForMember(dest => dest.Course, opt => opt.Ignore());
+        });
+
+        protected override void Because_of()
+        {
+            var source = new GeolocationDTO
+            {
+                Latitude = 34d,
+                Longitude = -93d,
+                HorizontalAccuracy = 100
+            };
+            _destination = Mapper.Map<GeoCoordinate>(source);
+        }
+
+        [Fact]
+        public void Should_map_ok()
+        {
+            _destination.Latitude.ShouldEqual(34);
+            _destination.Longitude.ShouldEqual(-93);
+            _destination.HorizontalAccuracy.ShouldEqual(100);
+        }
+    }
+
+    public class When_constructor_matches_but_the_destination_is_passed : AutoMapperSpecBase
+    {
+        Destination _destination = new Destination();
+
+        public class Source
+        {
+            public int MyTypeId { get; set; }
+        }
+
+        public class MyType
+        {
+        }
+
+        public class Destination
+        {
+            private MyType _myType;
+
+            public Destination()
+            {
+
+            }
+            public Destination(MyType myType)
+            {
+                _myType = myType;
+            }
+
+            public MyType MyType
+            {
+                get { return _myType; }
+                set { _myType = value; }
+            }
+        }
+
+        protected override MapperConfiguration Configuration
+        {
+            get
+            {
+                return new MapperConfiguration(cfg =>
+                {
+                    cfg.RecognizePostfixes("Id");
+                    cfg.CreateMap<Source, Destination>();
+                    cfg.CreateMap<int, MyType>();
+                });
+            }
+        }
+
+        protected override void Because_of()
+        {
+            Mapper.Map(new Source(), _destination);
+        }
+
+        [Fact]
+        public void Should_map_ok()
+        {
+            _destination.MyType.ShouldNotBeNull();
+        }
+    }
+
     public class When_mapping_through_constructor_and_destination_has_setter : AutoMapperSpecBase
     {
         public class Source
