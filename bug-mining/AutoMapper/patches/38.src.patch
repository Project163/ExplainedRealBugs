diff --git a/src/AutoMapper/Mappers/EnumMapper.cs b/src/AutoMapper/Mappers/EnumMapper.cs
index de0bd513..edaed8c6 100644
--- a/src/AutoMapper/Mappers/EnumMapper.cs
+++ b/src/AutoMapper/Mappers/EnumMapper.cs
@@ -1,142 +1,142 @@
-using System;
-using System.ComponentModel;
-using System.Linq;
-
-namespace AutoMapper.Mappers
-{
-    public class EnumMapper : IObjectMapper
-    {
-        public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-        {
-            bool toEnum = false;
-            Type enumSourceType = TypeHelper.GetEnumerationType(context.SourceType);
-        	Type enumDestinationType = TypeHelper.GetEnumerationType(context.DestinationType);
-
-            if (EnumToStringMapping(context, ref toEnum))
-            {
-                if (context.SourceValue == null)
-                {
-                    return mapper.CreateObject(context);
-                }
-
-                if (toEnum)
-                {
-                    var stringValue = context.SourceValue.ToString();
-                    if (string.IsNullOrEmpty(stringValue))
-                    {
-                        return mapper.CreateObject(context);
-                    }
-
-                    return Enum.Parse(enumDestinationType, stringValue, true);
-                }
-                return Enum.GetName(enumSourceType, context.SourceValue);
-            }
-            if (EnumToEnumMapping(context))
-            {
-                if (context.SourceValue == null)
+using System;
+using System.ComponentModel;
+using System.Linq;
+
+namespace AutoMapper.Mappers
+{
+    public class EnumMapper : IObjectMapper
+    {
+        public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+        {
+            bool toEnum = false;
+            Type enumSourceType = TypeHelper.GetEnumerationType(context.SourceType);
+        	Type enumDestinationType = TypeHelper.GetEnumerationType(context.DestinationType);
+
+            if (EnumToStringMapping(context, ref toEnum))
+            {
+                if (context.SourceValue == null)
+                {
+                    return mapper.CreateObject(context);
+                }
+
+                if (toEnum)
+                {
+                    var stringValue = context.SourceValue.ToString();
+                    if (string.IsNullOrEmpty(stringValue))
+                    {
+                        return mapper.CreateObject(context);
+                    }
+
+                    return Enum.Parse(enumDestinationType, stringValue, true);
+                }
+                return Enum.GetName(enumSourceType, context.SourceValue);
+            }
+            if (EnumToEnumMapping(context))
+            {
+                if (context.SourceValue == null)
                 {
                     if (mapper.ShouldMapSourceValueAsNull(context) && context.DestinationType.IsNullableType())
-                        return null;
-
-                    return mapper.CreateObject(context);
-                }
-
-                if (!Enum.IsDefined(enumSourceType, context.SourceValue))
-                {
-					return Enum.ToObject(enumDestinationType, context.SourceValue);
-                }
-
-#if !SILVERLIGHT
-                if (!Enum.GetNames(enumDestinationType).Contains(context.SourceValue.ToString()))
-                {
-                    Type underlyingSourceType = Enum.GetUnderlyingType(enumSourceType);
-                    var underlyingSourceValue = Convert.ChangeType(context.SourceValue, underlyingSourceType);
-
-                    return Enum.ToObject(context.DestinationType, underlyingSourceValue);
-                }
-#endif
-
-				return Enum.Parse(enumDestinationType, Enum.GetName(enumSourceType, context.SourceValue), true);
-            }
-            if (EnumToUnderlyingTypeMapping(context, ref toEnum))
-            {
-                if (toEnum)
-                {
-                    return Enum.Parse(enumDestinationType, context.SourceValue.ToString(), true);
-                }
-
-                if (EnumToNullableTypeMapping(context))
-                {
-                    return ConvertEnumToNullableType(context);
-                }
-
-                return Convert.ChangeType(context.SourceValue, context.DestinationType, null);
-            }
-            return null;
-        }
-
-        public bool IsMatch(ResolutionContext context)
-        {
-            bool toEnum = false;
-            return EnumToStringMapping(context, ref toEnum) || EnumToEnumMapping(context) || EnumToUnderlyingTypeMapping(context, ref toEnum);
-        }
-
-        private static bool EnumToEnumMapping(ResolutionContext context)
-        {
-            // Enum to enum mapping
-            var sourceEnumType = TypeHelper.GetEnumerationType(context.SourceType);
-            var destEnumType = TypeHelper.GetEnumerationType(context.DestinationType);
-            return sourceEnumType != null && destEnumType != null;
-        }
-
-        private static bool EnumToUnderlyingTypeMapping(ResolutionContext context, ref bool toEnum)
-        {
-            var sourceEnumType = TypeHelper.GetEnumerationType(context.SourceType);
-            var destEnumType = TypeHelper.GetEnumerationType(context.DestinationType);
-
-            // Enum to underlying type
-            if (sourceEnumType != null)
-            {
-				return context.DestinationType.IsAssignableFrom(Enum.GetUnderlyingType(sourceEnumType));
-            }
-            if (destEnumType != null)
-            {
-                toEnum = true;
-				return context.SourceType.IsAssignableFrom(Enum.GetUnderlyingType(destEnumType));
-            }
-            return false;
-        }
-
-        private static bool EnumToStringMapping(ResolutionContext context, ref bool toEnum)
-        {
-            var sourceEnumType = TypeHelper.GetEnumerationType(context.SourceType);
-            var destEnumType = TypeHelper.GetEnumerationType(context.DestinationType);
-
-            // Enum to string
-            if (sourceEnumType != null)
-            {
-                return context.DestinationType.IsAssignableFrom(typeof(string));
-            }
-            if (destEnumType != null)
-            {
-                toEnum = true;
-                return context.SourceType.IsAssignableFrom(typeof(string));
-            }
-            return false;
-        }
-
-        private static bool EnumToNullableTypeMapping(ResolutionContext context)
-        {
-            if (!context.DestinationType.IsGenericType)
-            {
-                return false;
-            }
-
-            var genericType = context.DestinationType.GetGenericTypeDefinition();
-            return genericType.Equals(typeof(Nullable<>));
-        }
-
-        private static object ConvertEnumToNullableType(ResolutionContext context)
+                        return null;
+
+                    return mapper.CreateObject(context);
+                }
+
+                if (!Enum.IsDefined(enumSourceType, context.SourceValue))
+                {
+					return Enum.ToObject(enumDestinationType, context.SourceValue);
+                }
+
+#if !SILVERLIGHT
+                if (!Enum.GetNames(enumDestinationType).Contains(context.SourceValue.ToString()))
+                {
+                    Type underlyingSourceType = Enum.GetUnderlyingType(enumSourceType);
+                    var underlyingSourceValue = Convert.ChangeType(context.SourceValue, underlyingSourceType);
+
+                    return Enum.ToObject(context.DestinationType, underlyingSourceValue);
+                }
+#endif
+
+				return Enum.Parse(enumDestinationType, Enum.GetName(enumSourceType, context.SourceValue), true);
+            }
+            if (EnumToUnderlyingTypeMapping(context, ref toEnum))
+            {
+                if (toEnum)
+                {
+                    return Enum.Parse(enumDestinationType, context.SourceValue.ToString(), true);
+                }
+
+                if (EnumToNullableTypeMapping(context))
+                {
+                    return ConvertEnumToNullableType(context);
+                }
+
+                return Convert.ChangeType(context.SourceValue, context.DestinationType, null);
+            }
+            return null;
+        }
+
+        public bool IsMatch(ResolutionContext context)
+        {
+            bool toEnum = false;
+            return EnumToStringMapping(context, ref toEnum) || EnumToEnumMapping(context) || EnumToUnderlyingTypeMapping(context, ref toEnum);
+        }
+
+        private static bool EnumToEnumMapping(ResolutionContext context)
+        {
+            // Enum to enum mapping
+            var sourceEnumType = TypeHelper.GetEnumerationType(context.SourceType);
+            var destEnumType = TypeHelper.GetEnumerationType(context.DestinationType);
+            return sourceEnumType != null && destEnumType != null;
+        }
+
+        private static bool EnumToUnderlyingTypeMapping(ResolutionContext context, ref bool toEnum)
+        {
+            var sourceEnumType = TypeHelper.GetEnumerationType(context.SourceType);
+            var destEnumType = TypeHelper.GetEnumerationType(context.DestinationType);
+
+            // Enum to underlying type
+            if (sourceEnumType != null)
+            {
+				return context.DestinationType.IsAssignableFrom(Enum.GetUnderlyingType(sourceEnumType));
+            }
+            if (destEnumType != null)
+            {
+                toEnum = true;
+				return context.SourceType.IsAssignableFrom(Enum.GetUnderlyingType(destEnumType));
+            }
+            return false;
+        }
+
+        private static bool EnumToStringMapping(ResolutionContext context, ref bool toEnum)
+        {
+            var sourceEnumType = TypeHelper.GetEnumerationType(context.SourceType);
+            var destEnumType = TypeHelper.GetEnumerationType(context.DestinationType);
+
+            // Enum to string
+            if (sourceEnumType != null)
+            {
+                return context.DestinationType.IsAssignableFrom(typeof(string));
+            }
+            if (destEnumType != null)
+            {
+                toEnum = true;
+                return context.SourceType.IsAssignableFrom(typeof(string));
+            }
+            return false;
+        }
+
+        private static bool EnumToNullableTypeMapping(ResolutionContext context)
+        {
+            if (!context.DestinationType.IsGenericType)
+            {
+                return false;
+            }
+
+            var genericType = context.DestinationType.GetGenericTypeDefinition();
+            return genericType.Equals(typeof(Nullable<>));
+        }
+
+        private static object ConvertEnumToNullableType(ResolutionContext context)
         {
             var nullableConverter = new NullableConverter(context.DestinationType);
             
@@ -147,7 +147,7 @@ private static object ConvertEnumToNullableType(ResolutionContext context)
 
             var destType = nullableConverter.UnderlyingType;
             return Convert.ChangeType(context.SourceValue, destType);
-        }
-
-    }
+        }
+
+    }
 }
\ No newline at end of file
diff --git a/src/UnitTests/Bug/EFCollections.cs b/src/UnitTests/Bug/EFCollections.cs
new file mode 100644
index 00000000..128551e9
--- /dev/null
+++ b/src/UnitTests/Bug/EFCollections.cs
@@ -0,0 +1,63 @@
+ï»¿using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using NUnit.Framework;
+using Should;
+
+namespace AutoMapper.UnitTests.Bug
+{
+    public class EFCollections : AutoMapperSpecBase
+    {
+        private Dest _dest;
+
+        public class Source
+        {
+            public ICollection<Child> Children { get; set; }
+
+        }
+
+        public class _Source : Source
+        {
+        }
+
+        public class _Child : Child
+        {
+
+        }
+
+        public class Dest
+        {
+            public ICollection<DestChild> Children { get; set; } 
+        }
+
+        public class DestChild {}
+
+        protected override void Establish_context()
+        {
+            Mapper.Initialize(cfg =>
+            {
+                cfg.CreateMap<Source, Dest>();
+                cfg.CreateMap<Child, DestChild>();
+            });
+        }
+
+        protected override void Because_of()
+        {
+            var source = new _Source
+            {
+                Children = new Collection<Child>
+                {
+                    new _Child(),
+                    new _Child()
+                }
+            };
+            _dest = Mapper.Map<Source, Dest>(source);
+        }
+
+        [Test]
+        public void Should_map_collection_items()
+        {
+            _dest.Children.Count.ShouldEqual(2);
+        }
+    }
+}
diff --git a/src/UnitTests/UnitTests.csproj b/src/UnitTests/UnitTests.csproj
index b66eef3b..cb63f22d 100644
--- a/src/UnitTests/UnitTests.csproj
+++ b/src/UnitTests/UnitTests.csproj
@@ -117,6 +117,7 @@
     <Compile Include="Bug\AddingConfigurationForNonMatchingDestinationMemberBug.cs" />
     <Compile Include="Bug\DeepInheritanceIssue.cs" />
     <Compile Include="Bug\DuplicateValuesBug.cs" />
+    <Compile Include="Bug\EFCollections.cs" />
     <Compile Include="Bug\EnumConditionsBug.cs" />
     <Compile Include="Bug\EnumMatchingOnValue.cs" />
     <Compile Include="Bug\ExistingArrays.cs" />
