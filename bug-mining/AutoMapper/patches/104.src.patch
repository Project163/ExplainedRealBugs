diff --git a/src/AutoMapper/Internal/MappingExpression.cs b/src/AutoMapper/Internal/MappingExpression.cs
index aa18c9cc..a3af8adc 100644
--- a/src/AutoMapper/Internal/MappingExpression.cs
+++ b/src/AutoMapper/Internal/MappingExpression.cs
@@ -282,7 +282,8 @@ private bool HasAnInaccessibleSetter(PropertyInfo property)
 
         public void ProjectUsing(Expression<Func<TSource, TDestination>> projectionExpression)
         {
-            TypeMap.UseCustomProjection(projectionExpression);
+            TypeMap.UseCustomProjection(projectionExpression);
+            ConvertUsing(projectionExpression.Compile());
         }
 
         public void NullSubstitute(object nullSubstitute)
diff --git a/src/UnitTests/CustomMapping.cs b/src/UnitTests/CustomMapping.cs
index fae053a5..e3702f0e 100644
--- a/src/UnitTests/CustomMapping.cs
+++ b/src/UnitTests/CustomMapping.cs
@@ -409,6 +409,55 @@ public void Should_ignore_other_mapping_rules()
             }
         }
 
+        public class When_specifying_a_custom_translator_using_projection : AutoMapperSpecBase
+        {
+            private Source _source;
+            private Destination _dest;
+
+            public class Source
+            {
+                public int Value { get; set; }
+                public int AnotherValue { get; set; }
+            }
+
+            public class Destination
+            {
+                public int Value { get; set; }
+            }
+
+            protected override void Establish_context()
+            {
+                base.Establish_context();
+
+                _source = new Source
+                {
+                    Value = 10,
+                    AnotherValue = 1000
+                };
+            }
+
+            [Fact]
+            public void Should_use_the_custom_translator()
+            {
+                Mapper.CreateMap<Source, Destination>()
+                    .ProjectUsing(s => new Destination { Value = s.Value + 10 });
+
+                _dest = Mapper.Map<Source, Destination>(_source);
+                _dest.Value.ShouldEqual(20);
+            }
+
+            [Fact]
+            public void Should_ignore_other_mapping_rules()
+            {
+                Mapper.CreateMap<Source, Destination>()
+                    .ForMember(dest => dest.Value, opt => opt.MapFrom(src => src.AnotherValue))
+                    .ProjectUsing(s => new Destination { Value = s.Value + 10 });
+
+                _dest = Mapper.Map<Source, Destination>(_source);
+                _dest.Value.ShouldEqual(20);
+            }
+        }
+
         public class When_specifying_a_custom_translator_and_passing_in_the_destination_object : AutoMapperSpecBase
         {
             private Source _source;
diff --git a/src/UnitTests/IMappingExpression/NonGenericProjectEnumTest.cs b/src/UnitTests/IMappingExpression/NonGenericProjectEnumTest.cs
index 76ccd1c2..b4e9c2ec 100644
--- a/src/UnitTests/IMappingExpression/NonGenericProjectEnumTest.cs
+++ b/src/UnitTests/IMappingExpression/NonGenericProjectEnumTest.cs
@@ -49,6 +49,49 @@ public enum CustomerType
         }
     }
 
+    public class NonGenericProjectAndMapEnumTest
+    {
+        public NonGenericProjectAndMapEnumTest()
+        {
+            Mapper.CreateMap(typeof(Customer), typeof(CustomerDto));
+            Mapper.CreateMap(typeof(CustomerType), typeof(string)).ProjectUsing(ct => ct.ToString().ToUpper());
+        }
+
+        [Fact]
+        public void ProjectingEnumToString()
+        {
+            var customers = new[] { new Customer() { FirstName = "Bill", LastName = "White", CustomerType = CustomerType.Vip } }.AsQueryable();
+
+            var projected = Mapper.Map<CustomerDto[]>(customers);
+            projected.ShouldNotBeNull();
+            Assert.Equal(customers.Single().CustomerType.ToString().ToUpper(), projected.Single().CustomerType);
+        }
+
+        public class Customer
+        {
+            public string FirstName { get; set; }
+
+            public string LastName { get; set; }
+
+            public CustomerType CustomerType { get; set; }
+        }
+
+        public class CustomerDto
+        {
+            public string FirstName { get; set; }
+
+            public string LastName { get; set; }
+
+            public string CustomerType { get; set; }
+        }
+
+        public enum CustomerType
+        {
+            Regular,
+            Vip,
+        }
+    }
+
     public class NonGenericProjectionOverrides : NonValidatingSpecBase
     {
         public class Source
