diff --git a/src/AutoMapper/Internal/DelegateBasedResolver.cs b/src/AutoMapper/Internal/DelegateBasedResolver.cs
index d79101ca..e854fc41 100644
--- a/src/AutoMapper/Internal/DelegateBasedResolver.cs
+++ b/src/AutoMapper/Internal/DelegateBasedResolver.cs
@@ -27,6 +27,10 @@ public ResolutionResult Resolve(ResolutionResult source)
 			{
 				result = null;
 			}
+			catch (ArgumentNullException)
+			{
+				result = null;
+			}
 
 			return source.New(result);
 		}
diff --git a/src/AutoMapper/Internal/PropertyGetter.cs b/src/AutoMapper/Internal/PropertyGetter.cs
index 8a1eca2a..3b1a1fae 100644
--- a/src/AutoMapper/Internal/PropertyGetter.cs
+++ b/src/AutoMapper/Internal/PropertyGetter.cs
@@ -17,6 +17,8 @@ public PropertyGetter(PropertyInfo propertyInfo)
 			_memberType = _propertyInfo.PropertyType;
 			if (_propertyInfo.GetGetMethod(true) != null)
 				_lateBoundPropertyGet = DelegateFactory.CreateGet(propertyInfo);
+			else
+			    _lateBoundPropertyGet = src => null;
 		}
 
 		public override MemberInfo MemberInfo
diff --git a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
index 26e2db93..2ceff617 100644
--- a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
+++ b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
@@ -89,11 +89,7 @@ private void MapPropertyValue(ResolutionContext context, IMappingEngineRunner ma
 			{
 				if (propertyMap.CanResolveValue())
                 {
-                    if (!propertyMap.ShouldAssignValue(context.CreateMemberContext(null, null, null, null, propertyMap)))
-                        return;
-
-					object destinationValue = null;
-					ResolutionResult result;
+                    ResolutionResult result;
 
 					try
 					{
@@ -105,16 +101,14 @@ private void MapPropertyValue(ResolutionContext context, IMappingEngineRunner ma
                     }
                     catch (Exception ex)
 					{
-						var errorContext = CreateErrorContext(context, propertyMap, destinationValue);
+						var errorContext = CreateErrorContext(context, propertyMap, null);
 						throw new AutoMapperMappingException(errorContext, ex);
 					}
 
-                    if (result.ShouldIgnore) return;
+                    if (result.ShouldIgnore) 
+                        return;
 
-					if (propertyMap.UseDestinationValue)
-					{
-						destinationValue = propertyMap.DestinationProperty.GetValue(mappedObject);
-					}
+					object destinationValue = propertyMap.DestinationProperty.GetValue(mappedObject);
 
 					var sourceType = result.Type;
 					var destinationType = propertyMap.DestinationProperty.MemberType;
@@ -126,7 +120,10 @@ private void MapPropertyValue(ResolutionContext context, IMappingEngineRunner ma
 					var newContext = context.CreateMemberContext(typeMap, result.Value, destinationValue, targetSourceType,
 																 propertyMap);
 
-					try
+                    if (!propertyMap.ShouldAssignValue(newContext))
+                        return;
+
+                    try
 					{
 						object propertyValueToAssign = mapper.Map(newContext);
 
diff --git a/src/UnitTests/Bug/ContextValuesIncorrect.cs b/src/UnitTests/Bug/ContextValuesIncorrect.cs
new file mode 100644
index 00000000..5b373c45
--- /dev/null
+++ b/src/UnitTests/Bug/ContextValuesIncorrect.cs
@@ -0,0 +1,60 @@
+ï»¿using NUnit.Framework;
+using Should;
+
+namespace AutoMapper.UnitTests.Bug
+{
+    namespace ContextValuesIncorrect
+    {
+        public class Foo
+        {
+            public int? Value { get; set; }
+            public int? Value2 { get; set; }
+        }
+
+        public class FooDto
+        {
+            public int? Value { get; set; }
+            public int? Value2 { get; set; }
+        }
+
+        public class When_conditionally_skipping_null_destination_values : AutoMapperSpecBase
+        {
+            private FooDto _destination;
+
+            protected override void Establish_context()
+            {
+                Mapper.Initialize(cfg =>
+                {
+                    cfg.CreateMap<Foo, FooDto>()
+                        .ForAllMembers(opt => opt.Condition(ctx => ctx.DestinationValue == null));
+                });
+            }
+            protected override void Because_of()
+            {
+                var source = new Foo
+                {
+                    Value = 3,
+                    Value2 = 4
+                };
+                _destination = new FooDto
+                {
+                    Value = 5
+                };
+
+                Mapper.Map(source, _destination);
+            }
+
+            [Test]
+            public void Should_map_the_null_value()
+            {
+                _destination.Value2.ShouldEqual(4);
+            }
+
+            [Test]
+            public void Should_leave_the_non_null_value_alone()
+            {
+                _destination.Value.ShouldEqual(5);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/UnitTests/Bug/EnumConditionsBug.cs b/src/UnitTests/Bug/EnumConditionsBug.cs
index a15b4669..8fc8a3e0 100644
--- a/src/UnitTests/Bug/EnumConditionsBug.cs
+++ b/src/UnitTests/Bug/EnumConditionsBug.cs
@@ -36,12 +36,12 @@ public void Mapper_respects_condition()
                     .ForMember(m => m.Prop1, o =>
                     {
                         o.Condition(c => { _c1Called = true; return !c.IsSourceValueNull; });
-                        o.MapFrom(f => f.Prop1.Aggregate((current, next) => current | next));
+                        o.ResolveUsing(f => f.Prop1.Aggregate((current, next) => current | next));
                     })
                     .ForMember(m => m.Prop2, o =>
                     {
                         o.Condition(c => { _c2Called = true; return !c.IsSourceValueNull; });
-                        o.MapFrom(f => f.Prop2.Aggregate((current, next) => current | next));
+                        o.ResolveUsing(f => f.Prop2.Aggregate((current, next) => current | next));
                     });
                 var src = new EnumTestSource { Prop1 = new[] { Enum1.One }, Prop2 = null };
                 var dest = Mapper.Map<EnumTestDest>(src); // will throw
diff --git a/src/UnitTests/CollectionMapping.cs b/src/UnitTests/CollectionMapping.cs
index e0fe7bc7..aa0b7b58 100644
--- a/src/UnitTests/CollectionMapping.cs
+++ b/src/UnitTests/CollectionMapping.cs
@@ -205,7 +205,7 @@ public void Should_keep_and_fill_destination_list()
         }
 
         [Test]
-        public void Should_replace_destination_collection()
+        public void Should_not_replace_destination_collection()
         {
             Mapper.CreateMap<MasterDto, MasterWithCollection>();
             Mapper.CreateMap<DetailDto, Detail>();
@@ -225,7 +225,7 @@ public void Should_replace_destination_collection()
 
             Mapper.Map(dto, master);
 
-            Assert.That(master.Details, Is.Not.SameAs(originalCollection));
+            Assert.That(master.Details, Is.SameAs(originalCollection));
         }
 
         [Test]
@@ -250,7 +250,7 @@ public void Should_be_able_to_map_to_a_collection_type_that_implements_ICollecti
         }
 
         [Test]
-        public void Should_replace_destination_list()
+        public void Should_not_replace_destination_list()
         {
             Mapper.CreateMap<MasterDto, MasterWithList>();
             Mapper.CreateMap<DetailDto, Detail>();
@@ -270,7 +270,7 @@ public void Should_replace_destination_list()
 
             Mapper.Map(dto, master);
 
-            Assert.That(master.Details, Is.Not.SameAs(originalCollection));
+            Assert.That(master.Details, Is.SameAs(originalCollection));
         }
 
 #if !SILVERLIGHT
diff --git a/src/UnitTests/ConditionalMapping.cs b/src/UnitTests/ConditionalMapping.cs
index cecfe5f1..e361570d 100644
--- a/src/UnitTests/ConditionalMapping.cs
+++ b/src/UnitTests/ConditionalMapping.cs
@@ -67,7 +67,7 @@ protected override void Establish_context()
                             opt.Condition(src => src.Value > 0);
                             opt.ResolveUsing(src =>
                             {
-                                throw new Exception("Blarg");
+                                return 10;
                             });
                         });
                 });
@@ -84,7 +84,7 @@ public void Should_skip_the_mapping_when_the_condition_is_true()
             [Test]
             public void Should_execute_the_mapping_when_the_condition_is_false()
             {
-                typeof(AutoMapperMappingException).ShouldBeThrownBy(() => Mapper.Map<Source, Destination>(new Source { Value = 7 }));
+                Mapper.Map<Source, Destination>(new Source { Value = 7 }).Value.ShouldEqual(10);
             }
         }
 
diff --git a/src/UnitTests/UnitTests.csproj b/src/UnitTests/UnitTests.csproj
index ec0b094e..b8ab3375 100644
--- a/src/UnitTests/UnitTests.csproj
+++ b/src/UnitTests/UnitTests.csproj
@@ -109,6 +109,7 @@
     <Compile Include="Bug\AssignableCollectionBug.cs" />
     <Compile Include="Bug\CannotConvertEnumToNullable.cs" />
     <Compile Include="Bug\CollectionMapperMapsISetIncorrectly.cs" />
+    <Compile Include="Bug\ContextValuesIncorrect.cs" />
     <Compile Include="Bug\CreateMapExpressionWithIgnoredPropertyBug.cs" />
     <Compile Include="Bug\CustomIEnumerableBug.cs" />
     <Compile Include="Bug\AddingConfigurationForNonMatchingDestinationMemberBug.cs" />
