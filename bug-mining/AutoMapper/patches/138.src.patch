diff --git a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
index d0829c61..eccc7d4a 100644
--- a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
+++ b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
@@ -453,7 +453,8 @@ public static Expression ContextMap(Expression valueResolverExpr, Expression des
             }
             else if (propertyMap.CustomExpression != null)
             {
-                valueResolverFunc = propertyMap.CustomExpression.ReplaceParameters(srcParam).IfNotNull();
+                var nullCheckedExpression = propertyMap.CustomExpression.ReplaceParameters(srcParam).IfNotNull();
+                valueResolverFunc = TryCatch(nullCheckedExpression, Catch(typeof(NullReferenceException), Default(nullCheckedExpression.Type)));
             }
             else if (propertyMap.SourceMembers.Any()
                      && propertyMap.SourceType != null
diff --git a/src/UnitTests/CustomMapping.cs b/src/UnitTests/CustomMapping.cs
index 0c31693e..8dc50055 100644
--- a/src/UnitTests/CustomMapping.cs
+++ b/src/UnitTests/CustomMapping.cs
@@ -5,6 +5,30 @@
 
 namespace AutoMapper.UnitTests
 {
+    public class When_throwing_NRE_from_MapFrom : AutoMapperSpecBase
+    {
+        class Source
+        {
+        }
+
+        class Destination
+        {
+            public string Value { get; set; }
+        }
+
+        protected override MapperConfiguration Configuration => new MapperConfiguration(cfg =>
+        {
+            string x = null;
+            cfg.CreateMap<Source, Destination>().ForMember(d=>d.Value, o=>o.MapFrom(s=>x.ToString()));
+        });
+
+        [Fact]
+        public void We_should_catch_it()
+        {
+            Mapper.Map<Destination>(new Source()).Value.ShouldBeNull();
+        }
+    }
+
     public class When_using_value_with_mismatched_properties : AutoMapperSpecBase
     {
         Destination _destination;
