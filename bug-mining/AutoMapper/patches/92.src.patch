diff --git a/src/AutoMapper/Internal/ConcurrentDictionaryFactory.cs b/src/AutoMapper/Internal/ConcurrentDictionaryFactory.cs
index 6b2807f6..10a09cf2 100644
--- a/src/AutoMapper/Internal/ConcurrentDictionaryFactory.cs
+++ b/src/AutoMapper/Internal/ConcurrentDictionaryFactory.cs
@@ -44,7 +44,12 @@ public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory)
             public bool TryRemove(TKey key, out TValue value)
             {
                 return _dictionary.TryRemove(key, out value);
-            }
+            }
+
+            public void Clear()
+            {
+                _dictionary.Clear();
+            }
         }
     }
 }
diff --git a/src/AutoMapper/Internal/DictionaryFactory.cs b/src/AutoMapper/Internal/DictionaryFactory.cs
index dd993376..940367a5 100644
--- a/src/AutoMapper/Internal/DictionaryFactory.cs
+++ b/src/AutoMapper/Internal/DictionaryFactory.cs
@@ -87,6 +87,11 @@ public bool TryRemove(TKey key, out TValue value)
                     return true;
                 }
             }
+
+            public void Clear()
+            {
+                _dictionary.Clear();
+            }
         }
     }
 }
\ No newline at end of file
diff --git a/src/AutoMapper/Internal/IDictionary.cs b/src/AutoMapper/Internal/IDictionary.cs
index 25184a1e..35116dd2 100644
--- a/src/AutoMapper/Internal/IDictionary.cs
+++ b/src/AutoMapper/Internal/IDictionary.cs
@@ -48,7 +48,8 @@ public interface IDictionary<TKey, TValue>
             );
 
         TValue this[TKey key] { get; set; }
-        bool TryRemove(TKey key, out TValue value);
+        bool TryRemove(TKey key, out TValue value);
+        void Clear();
     }
 
     public interface INullableConverter
diff --git a/src/AutoMapper/Mapper.cs b/src/AutoMapper/Mapper.cs
index 92ec0a4c..fc21a911 100644
--- a/src/AutoMapper/Mapper.cs
+++ b/src/AutoMapper/Mapper.cs
@@ -3,8 +3,9 @@
 
 namespace AutoMapper
 {
-    using Internal;
-
+    using Internal;
+    using QueryableExtensions;
+
     /// <summary>
     /// Main entry point for AutoMapper, for both creating maps and performing maps.
     /// </summary>
@@ -438,7 +439,8 @@ public static void AssertConfigurationIsValid<TProfile>() where TProfile : Profi
         /// </summary>
 		public static void Reset()
         {
-            MapperRegistry.Reset();
+            MapperRegistry.Reset();
+            Extensions.ClearExpressionCache();
             _configuration = LazyFactory.Create(_configurationInit);
             _mappingEngine = LazyFactory.Create(_mappingEngineInit);
 		}
diff --git a/src/AutoMapper/QueryableExtensions/Extensions.cs b/src/AutoMapper/QueryableExtensions/Extensions.cs
index 1543f185..6768af92 100644
--- a/src/AutoMapper/QueryableExtensions/Extensions.cs
+++ b/src/AutoMapper/QueryableExtensions/Extensions.cs
@@ -32,6 +32,11 @@ public static class Extensions
             new StringExpressionBinder(),
         };
 
+        public static void ClearExpressionCache()
+        {
+            _expressionCache.Clear();
+        }
+
         /// <summary>
         /// Create an expression tree representing a mapping from the <typeparamref name="TSource"/> type to <typeparamref name="TDestination"/> type
         /// Includes flattening and expressions inside MapFrom member configuration
diff --git a/src/UnitTests/Projection/ExplicitValues.cs b/src/UnitTests/Projection/ExplicitValues.cs
index 5aa34c6f..b2368c5b 100644
--- a/src/UnitTests/Projection/ExplicitValues.cs
+++ b/src/UnitTests/Projection/ExplicitValues.cs
@@ -39,4 +39,45 @@ public void Should_substitute_value()
             _dests[0].Value.ShouldEqual(5);
         }
     }
+
+    public class ExplicitValues_ForReset : AutoMapperSpecBase
+    {
+        private List<Dest> _dests;
+
+        public class Source
+        {
+            public int Value { get; set; }
+        }
+
+        public class Dest
+        {
+            public int Value { get; set; }
+        }
+
+        protected override void Establish_context()
+        {
+            Mapper.CreateMap<Source, Dest>()
+                .ForMember(dest => dest.Value, opt => opt.UseValue(5));
+
+            new[] { new Source { Value = 10 } }.AsQueryable().Project().To<Dest>().ToList();
+
+            Mapper.Reset();
+
+            Mapper.CreateMap<Source, Dest>()
+                    .ForMember(dest => dest.Value, opt => opt.UseValue(10));
+        }
+
+        protected override void Because_of()
+        {
+            var source = new[] { new Source { Value = 10 } }.AsQueryable();
+
+            _dests = source.Project().To<Dest>().ToList();
+        }
+
+        [Fact]
+        public void Should_substitute_value()
+        {
+            _dests[0].Value.ShouldEqual(10);
+        }
+    }
 }
\ No newline at end of file
