diff --git a/src/AutoMapper/IMappingExpression.cs b/src/AutoMapper/IMappingExpression.cs
index ca4dadf9..10b8001f 100644
--- a/src/AutoMapper/IMappingExpression.cs
+++ b/src/AutoMapper/IMappingExpression.cs
@@ -1,35 +1,35 @@
-using System;
-using System.Linq.Expressions;
-
-namespace AutoMapper
-{
-    public interface IMappingExpression
-    {
-        void ConvertUsing<TTypeConverter>();
-        void ConvertUsing(Type typeConverterType);
-        IMappingExpression WithProfile(string profileName);
+using System;
+using System.Linq.Expressions;
+
+namespace AutoMapper
+{
+    public interface IMappingExpression
+    {
+        void ConvertUsing<TTypeConverter>();
+        void ConvertUsing(Type typeConverterType);
+        IMappingExpression WithProfile(string profileName);
         IMappingExpression ForMember(string name, Action<IMemberConfigurationExpression> memberOptions);
-    }
-
-    public interface IMappingExpression<TSource, TDestination>
-    {
-        IMappingExpression<TSource, TDestination> ForMember(Expression<Func<TDestination, object>> destinationMember, Action<IMemberConfigurationExpression<TSource>> memberOptions);
-        IMappingExpression<TSource, TDestination> ForMember(string name, Action<IMemberConfigurationExpression<TSource>> memberOptions);
-        void ForAllMembers(Action<IMemberConfigurationExpression<TSource>> memberOptions);
-        IMappingExpression<TSource, TDestination> Include<TOtherSource, TOtherDestination>()
-            where TOtherSource : TSource
-            where TOtherDestination : TDestination;
-        IMappingExpression<TSource, TDestination> WithProfile(string profileName);
-        void ConvertUsing(Func<TSource, TDestination> mappingFunction);
-        void ConvertUsing(ITypeConverter<TSource, TDestination> converter);
-        void ConvertUsing<TTypeConverter>() where TTypeConverter : ITypeConverter<TSource, TDestination>;
-        IMappingExpression<TSource, TDestination> BeforeMap(Action<TSource, TDestination> beforeFunction);
-        IMappingExpression<TSource, TDestination> BeforeMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>;
-        IMappingExpression<TSource, TDestination> AfterMap(Action<TSource, TDestination> afterFunction);
-        IMappingExpression<TSource, TDestination> AfterMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>;
-        IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor);
-    }
-
+    }
+
+    public interface IMappingExpression<TSource, TDestination>
+    {
+        IMappingExpression<TSource, TDestination> ForMember(Expression<Func<TDestination, object>> destinationMember, Action<IMemberConfigurationExpression<TSource>> memberOptions);
+        IMappingExpression<TSource, TDestination> ForMember(string name, Action<IMemberConfigurationExpression<TSource>> memberOptions);
+        void ForAllMembers(Action<IMemberConfigurationExpression<TSource>> memberOptions);
+        IMappingExpression<TSource, TDestination> Include<TOtherSource, TOtherDestination>()
+            where TOtherSource : TSource
+            where TOtherDestination : TDestination;
+        IMappingExpression<TSource, TDestination> WithProfile(string profileName);
+        void ConvertUsing(Func<TSource, TDestination> mappingFunction);
+        void ConvertUsing(ITypeConverter<TSource, TDestination> converter);
+        void ConvertUsing<TTypeConverter>() where TTypeConverter : ITypeConverter<TSource, TDestination>;
+        IMappingExpression<TSource, TDestination> BeforeMap(Action<TSource, TDestination> beforeFunction);
+        IMappingExpression<TSource, TDestination> BeforeMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>;
+        IMappingExpression<TSource, TDestination> AfterMap(Action<TSource, TDestination> afterFunction);
+        IMappingExpression<TSource, TDestination> AfterMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>;
+        IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor);
+    }
+
     public interface IMemberConfigurationExpression
     {
         void MapFrom(string sourceMember);
@@ -37,53 +37,54 @@ public interface IMemberConfigurationExpression
         IResolverConfigurationExpression ResolveUsing(Type valueResolverType);
         IResolverConfigurationExpression ResolveUsing<TValueResolver>();
         void Ignore();
-    }
-
-    public interface IMemberConfigurationExpression<TSource>
-    {
-        void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter;
-        IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter;
-        IFormatterCtorExpression AddFormatter(Type valueFormatterType);
-        void AddFormatter(IValueFormatter formatter);
-        void NullSubstitute(object nullSubstitute);
-        IResolverConfigurationExpression<TSource, TValueResolver> ResolveUsing<TValueResolver>() where TValueResolver : IValueResolver;
-        IResolverConfigurationExpression<TSource> ResolveUsing(Type valueResolverType);
-        IResolutionExpression<TSource> ResolveUsing(IValueResolver valueResolver);
-        void MapFrom<TMember>(Func<TSource, TMember> sourceMember);
-        void Ignore();
-        void SetMappingOrder(int mappingOrder);
-        void UseDestinationValue();
-        void UseValue<TValue>(TValue value);
-        void UseValue(object value);
+    }
+
+    public interface IMemberConfigurationExpression<TSource>
+    {
+        void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter;
+        IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter;
+        IFormatterCtorExpression AddFormatter(Type valueFormatterType);
+        void AddFormatter(IValueFormatter formatter);
+        void NullSubstitute(object nullSubstitute);
+        IResolverConfigurationExpression<TSource, TValueResolver> ResolveUsing<TValueResolver>() where TValueResolver : IValueResolver;
+        IResolverConfigurationExpression<TSource> ResolveUsing(Type valueResolverType);
+        IResolutionExpression<TSource> ResolveUsing(IValueResolver valueResolver);
+        void ResolveUsing(Func<TSource, object> resolver);
+        void MapFrom<TMember>(Expression<Func<TSource, TMember>> sourceMember);
+        void Ignore();
+        void SetMappingOrder(int mappingOrder);
+        void UseDestinationValue();
+        void UseValue<TValue>(TValue value);
+        void UseValue(object value);
         void Condition(Func<TSource, bool> condition);
         void Condition(Func<ResolutionContext, bool> condition);
-    }
-
+    }
+
     public interface IResolutionExpression
     {
         void FromMember(string sourcePropertyName);
-    }
-    
+    }
+    
     public interface IResolverConfigurationExpression : IResolutionExpression
     {
         IResolutionExpression ConstructedBy(Func<IValueResolver> constructor);
-    }
-
-    public interface IResolutionExpression<TSource> : IResolutionExpression
-    {
-        void FromMember(Func<TSource, object> sourceMember);
-    }
-
-    public interface IResolverConfigurationExpression<TSource, TValueResolver>
-        where TValueResolver : IValueResolver
-    {
-        IResolverConfigurationExpression<TSource, TValueResolver> FromMember(Func<TSource, object> sourceMember);
-        IResolverConfigurationExpression<TSource, TValueResolver> FromMember(string sourcePropertyName);
-        IResolverConfigurationExpression<TSource, TValueResolver> ConstructedBy(Func<TValueResolver> constructor);
-    }
-
-    public interface IResolverConfigurationExpression<TSource> : IResolutionExpression<TSource>
-    {
-        IResolutionExpression<TSource> ConstructedBy(Func<IValueResolver> constructor);
-    }
+    }
+
+    public interface IResolutionExpression<TSource> : IResolutionExpression
+    {
+        void FromMember(Expression<Func<TSource, object>> sourceMember);
+    }
+
+    public interface IResolverConfigurationExpression<TSource, TValueResolver>
+        where TValueResolver : IValueResolver
+    {
+        IResolverConfigurationExpression<TSource, TValueResolver> FromMember(Expression<Func<TSource, object>> sourceMember);
+        IResolverConfigurationExpression<TSource, TValueResolver> FromMember(string sourcePropertyName);
+        IResolverConfigurationExpression<TSource, TValueResolver> ConstructedBy(Func<TValueResolver> constructor);
+    }
+
+    public interface IResolverConfigurationExpression<TSource> : IResolutionExpression<TSource>
+    {
+        IResolutionExpression<TSource> ConstructedBy(Func<IValueResolver> constructor);
+    }
 }
\ No newline at end of file
diff --git a/src/AutoMapper/Internal/MappingExpression.cs b/src/AutoMapper/Internal/MappingExpression.cs
index 0d58cb60..c8918b38 100644
--- a/src/AutoMapper/Internal/MappingExpression.cs
+++ b/src/AutoMapper/Internal/MappingExpression.cs
@@ -1,41 +1,41 @@
-using System;
-using System.Linq.Expressions;
+using System;
+using System.Linq.Expressions;
 using AutoMapper.Internal;
-using System.Linq;
-
-namespace AutoMapper
-{
-	internal class MappingExpression : IMappingExpression, IMemberConfigurationExpression
-	{
-		private readonly TypeMap _typeMap;
+using System.Linq;
+
+namespace AutoMapper
+{
+	internal class MappingExpression : IMappingExpression, IMemberConfigurationExpression
+	{
+		private readonly TypeMap _typeMap;
 		private readonly Func<Type, object> _typeConverterCtor;
-	    private PropertyMap _propertyMap;
-
-	    public MappingExpression(TypeMap typeMap, Func<Type, object> typeConverterCtor)
-		{
-			_typeMap = typeMap;
-			_typeConverterCtor = typeConverterCtor;
-		}
-
-		public void ConvertUsing<TTypeConverter>()
-		{
-			ConvertUsing(typeof(TTypeConverter));
-		}
-
-		public void ConvertUsing(Type typeConverterType)
+	    private PropertyMap _propertyMap;
+
+	    public MappingExpression(TypeMap typeMap, Func<Type, object> typeConverterCtor)
+		{
+			_typeMap = typeMap;
+			_typeConverterCtor = typeConverterCtor;
+		}
+
+		public void ConvertUsing<TTypeConverter>()
+		{
+			ConvertUsing(typeof(TTypeConverter));
+		}
+
+		public void ConvertUsing(Type typeConverterType)
 		{
 			var interfaceType = typeof (ITypeConverter<,>).MakeGenericType(_typeMap.SourceType, _typeMap.DestinationType);
-			var convertMethodType = interfaceType.IsAssignableFrom(typeConverterType) ? interfaceType : typeConverterType;
-			var converter = new DeferredInstantiatedConverter(convertMethodType, () => _typeConverterCtor(typeConverterType));
-
-			_typeMap.UseCustomMapper(converter.Convert);
-		}
-
-		public IMappingExpression WithProfile(string profileName)
-		{
-			_typeMap.Profile = profileName;
-
-			return this;
+			var convertMethodType = interfaceType.IsAssignableFrom(typeConverterType) ? interfaceType : typeConverterType;
+			var converter = new DeferredInstantiatedConverter(convertMethodType, () => _typeConverterCtor(typeConverterType));
+
+			_typeMap.UseCustomMapper(converter.Convert);
+		}
+
+		public IMappingExpression WithProfile(string profileName)
+		{
+			_typeMap.Profile = profileName;
+
+			return this;
 		}
 
         public IMappingExpression ForMember(string name, Action<IMemberConfigurationExpression> memberOptions)
@@ -50,14 +50,16 @@ private void ForDestinationMember(IMemberAccessor destinationProperty, Action<IM
             _propertyMap = _typeMap.FindOrCreatePropertyMapFor(destinationProperty);
 
             memberOptions(this);
-        }
-
+        }
+
 	    public void MapFrom(string sourceMember)
 	    {
 	        var members = _typeMap.SourceType.GetMember(sourceMember);
             if (!members.Any()) throw new AutoMapperConfigurationException(string.Format("Unable to find source member {0} on type {1}", sourceMember, _typeMap.SourceType.FullName));
-            if (members.Skip(1).Any()) throw new AutoMapperConfigurationException(string.Format("Source member {0} is ambiguous on type {1}", sourceMember, _typeMap.SourceType.FullName));
-            _propertyMap.AssignCustomValueResolver( members.Single().ToMemberGetter() );
+            if (members.Skip(1).Any()) throw new AutoMapperConfigurationException(string.Format("Source member {0} is ambiguous on type {1}", sourceMember, _typeMap.SourceType.FullName));
+            var member = members.Single();
+            _propertyMap.SourceMember = member;
+            _propertyMap.AssignCustomValueResolver(member.ToMemberGetter());
 	    }
 
 	    public IResolutionExpression ResolveUsing(IValueResolver valueResolver)
@@ -89,129 +91,138 @@ public void Ignore()
 	    {
 	        _propertyMap.Ignore();
 	    }
-	}
-
-	internal class MappingExpression<TSource, TDestination> : IMappingExpression<TSource, TDestination>, IMemberConfigurationExpression<TSource>, IFormatterCtorConfigurator
-	{
-		private readonly TypeMap _typeMap;
-		private readonly Func<Type, object> _serviceCtor;
-		private PropertyMap _propertyMap;
-
-		public MappingExpression(TypeMap typeMap, Func<Type, object> serviceCtor)
-		{
-			_typeMap = typeMap;
-			_serviceCtor = serviceCtor;
-		}
-
-		public IMappingExpression<TSource, TDestination> ForMember(Expression<Func<TDestination, object>> destinationMember,
-																   Action<IMemberConfigurationExpression<TSource>> memberOptions)
-		{
-		    var memberInfo = ReflectionHelper.FindProperty(destinationMember);
-		    IMemberAccessor destProperty = memberInfo.ToMemberAccessor();
-			ForDestinationMember(destProperty, memberOptions);
-			return new MappingExpression<TSource, TDestination>(_typeMap, _serviceCtor);
-		}
-
-		public IMappingExpression<TSource, TDestination> ForMember(string name,
-																   Action<IMemberConfigurationExpression<TSource>> memberOptions)
-		{
-			IMemberAccessor destProperty = new PropertyAccessor(typeof(TDestination).GetProperty(name));
-			ForDestinationMember(destProperty, memberOptions);
-			return new MappingExpression<TSource, TDestination>(_typeMap, _serviceCtor);
-		}
-
-		public void ForAllMembers(Action<IMemberConfigurationExpression<TSource>> memberOptions)
-		{
-		    var typeInfo = new TypeInfo(_typeMap.DestinationType);
-
-		    typeInfo.GetPublicWriteAccessors().Each(acc => ForDestinationMember(acc.ToMemberAccessor(), memberOptions));
-		}
-
-		public IMappingExpression<TSource, TDestination> Include<TOtherSource, TOtherDestination>()
-			where TOtherSource : TSource
-			where TOtherDestination : TDestination
-		{
-			_typeMap.IncludeDerivedTypes(typeof(TOtherSource), typeof(TOtherDestination));
-
-			return this;
-		}
-
-		public IMappingExpression<TSource, TDestination> WithProfile(string profileName)
-		{
-			_typeMap.Profile = profileName;
-
-			return this;
-		}
-
-		public void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
-		{
-			_propertyMap.AddFormatterToSkip<TValueFormatter>();
-		}
-
-		public IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
-		{
-			var formatter = new DeferredInstantiatedFormatter(() => (IValueFormatter)_serviceCtor(typeof(TValueFormatter)));
-
-			AddFormatter(formatter);
-
-			return new FormatterCtorExpression<TValueFormatter>(this);
-		}
-
-		public IFormatterCtorExpression AddFormatter(Type valueFormatterType)
-		{
-			var formatter = new DeferredInstantiatedFormatter(() => (IValueFormatter)_serviceCtor(valueFormatterType));
-
-			AddFormatter(formatter);
-
-			return new FormatterCtorExpression(valueFormatterType, this);
-		}
-
-		public void AddFormatter(IValueFormatter formatter)
-		{
-			_propertyMap.AddFormatter(formatter);
-		}
-
-		public void NullSubstitute(object nullSubstitute)
-		{
-			_propertyMap.SetNullSubstitute(nullSubstitute);
-		}
-
-		public IResolverConfigurationExpression<TSource, TValueResolver> ResolveUsing<TValueResolver>() where TValueResolver : IValueResolver
-		{
-			var resolver = new DeferredInstantiatedResolver(() => (IValueResolver)_serviceCtor(typeof(TValueResolver)));
-
-			ResolveUsing(resolver);
-
-			return new ResolutionExpression<TSource, TValueResolver>(_propertyMap);
-		}
-
-		public IResolverConfigurationExpression<TSource> ResolveUsing(Type valueResolverType)
-		{
-			var resolver = new DeferredInstantiatedResolver(() => (IValueResolver)_serviceCtor(valueResolverType));
-
-			ResolveUsing(resolver);
-
-			return new ResolutionExpression<TSource>(_propertyMap);
-		}
-
-		public IResolutionExpression<TSource> ResolveUsing(IValueResolver valueResolver)
-		{
-			_propertyMap.AssignCustomValueResolver(valueResolver);
-
-			return new ResolutionExpression<TSource>(_propertyMap);
-		}
-
-		public void MapFrom<TMember>(Func<TSource, TMember> sourceMember)
-		{
-			_propertyMap.AssignCustomValueResolver(new DelegateBasedResolver<TSource, TMember>(sourceMember));
-		}
-
-		public void UseValue<TValue>(TValue value)
-		{
-			MapFrom(src => value);
-		}
-
-		public void UseValue(object value)
+	}
+
+	internal class MappingExpression<TSource, TDestination> : IMappingExpression<TSource, TDestination>, IMemberConfigurationExpression<TSource>, IFormatterCtorConfigurator
+	{
+		private readonly TypeMap _typeMap;
+		private readonly Func<Type, object> _serviceCtor;
+		private PropertyMap _propertyMap;
+
+		public MappingExpression(TypeMap typeMap, Func<Type, object> serviceCtor)
+		{
+			_typeMap = typeMap;
+			_serviceCtor = serviceCtor;
+		}
+
+		public IMappingExpression<TSource, TDestination> ForMember(Expression<Func<TDestination, object>> destinationMember,
+																   Action<IMemberConfigurationExpression<TSource>> memberOptions)
+		{
+		    var memberInfo = ReflectionHelper.FindProperty(destinationMember);
+		    IMemberAccessor destProperty = memberInfo.ToMemberAccessor();
+			ForDestinationMember(destProperty, memberOptions);
+			return new MappingExpression<TSource, TDestination>(_typeMap, _serviceCtor);
+		}
+
+		public IMappingExpression<TSource, TDestination> ForMember(string name,
+																   Action<IMemberConfigurationExpression<TSource>> memberOptions)
+		{
+			IMemberAccessor destProperty = new PropertyAccessor(typeof(TDestination).GetProperty(name));
+			ForDestinationMember(destProperty, memberOptions);
+			return new MappingExpression<TSource, TDestination>(_typeMap, _serviceCtor);
+		}
+
+		public void ForAllMembers(Action<IMemberConfigurationExpression<TSource>> memberOptions)
+		{
+		    var typeInfo = new TypeInfo(_typeMap.DestinationType);
+
+		    typeInfo.GetPublicWriteAccessors().Each(acc => ForDestinationMember(acc.ToMemberAccessor(), memberOptions));
+		}
+
+		public IMappingExpression<TSource, TDestination> Include<TOtherSource, TOtherDestination>()
+			where TOtherSource : TSource
+			where TOtherDestination : TDestination
+		{
+			_typeMap.IncludeDerivedTypes(typeof(TOtherSource), typeof(TOtherDestination));
+
+			return this;
+		}
+
+		public IMappingExpression<TSource, TDestination> WithProfile(string profileName)
+		{
+			_typeMap.Profile = profileName;
+
+			return this;
+		}
+
+		public void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
+		{
+			_propertyMap.AddFormatterToSkip<TValueFormatter>();
+		}
+
+		public IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
+		{
+			var formatter = new DeferredInstantiatedFormatter(() => (IValueFormatter)_serviceCtor(typeof(TValueFormatter)));
+
+			AddFormatter(formatter);
+
+			return new FormatterCtorExpression<TValueFormatter>(this);
+		}
+
+		public IFormatterCtorExpression AddFormatter(Type valueFormatterType)
+		{
+			var formatter = new DeferredInstantiatedFormatter(() => (IValueFormatter)_serviceCtor(valueFormatterType));
+
+			AddFormatter(formatter);
+
+			return new FormatterCtorExpression(valueFormatterType, this);
+		}
+
+		public void AddFormatter(IValueFormatter formatter)
+		{
+			_propertyMap.AddFormatter(formatter);
+		}
+
+		public void NullSubstitute(object nullSubstitute)
+		{
+			_propertyMap.SetNullSubstitute(nullSubstitute);
+		}
+
+		public IResolverConfigurationExpression<TSource, TValueResolver> ResolveUsing<TValueResolver>() where TValueResolver : IValueResolver
+		{
+			var resolver = new DeferredInstantiatedResolver(() => (IValueResolver)_serviceCtor(typeof(TValueResolver)));
+
+			ResolveUsing(resolver);
+
+			return new ResolutionExpression<TSource, TValueResolver>(_propertyMap);
+		}
+
+		public IResolverConfigurationExpression<TSource> ResolveUsing(Type valueResolverType)
+		{
+			var resolver = new DeferredInstantiatedResolver(() => (IValueResolver)_serviceCtor(valueResolverType));
+
+			ResolveUsing(resolver);
+
+			return new ResolutionExpression<TSource>(_propertyMap);
+		}
+
+		public IResolutionExpression<TSource> ResolveUsing(IValueResolver valueResolver)
+		{
+			_propertyMap.AssignCustomValueResolver(valueResolver);
+
+			return new ResolutionExpression<TSource>(_propertyMap);
+		}
+
+		public void ResolveUsing(Func<TSource, object> resolver)
+		{
+			_propertyMap.AssignCustomValueResolver(new DelegateBasedResolver<TSource>(resolver));
+		}
+
+		public void MapFrom<TMember>(Expression<Func<TSource, TMember>> sourceMember)
+		{
+            if (sourceMember.Body is MemberExpression)
+            {
+                _propertyMap.SourceMember = (sourceMember.Body as MemberExpression).Member;
+            }
+            _propertyMap.AssignCustomValueResolver(new DelegateBasedResolver<TSource, TMember>(sourceMember.Compile()));
+		}
+
+		public void UseValue<TValue>(TValue value)
+		{
+			MapFrom(src => value);
+		}
+
+		public void UseValue(object value)
 		{
             _propertyMap.AssignCustomValueResolver(new DelegateBasedResolver<TSource>(src => value));
 		}
@@ -221,99 +232,99 @@ public void Condition(Func<TSource, bool> condition)
 	        Condition(context => condition((TSource) context.Parent.SourceValue));
 	    }
 
-	    public void Condition(Func<ResolutionContext, bool> condition)
+	    public void Condition(Func<ResolutionContext, bool> condition)
         {
             _propertyMap.ApplyCondition(condition);
-        }
-
-	    public void Ignore()
-		{
-			_propertyMap.Ignore();
-		}
-
-		public void UseDestinationValue()
-		{
-			_propertyMap.UseDestinationValue = true;
-		}
-
-		public void SetMappingOrder(int mappingOrder)
-		{
-			_propertyMap.SetMappingOrder(mappingOrder);
-		}
-
-		public void ConstructFormatterBy(Type formatterType, Func<IValueFormatter> instantiator)
-		{
-			_propertyMap.RemoveLastFormatter();
-			_propertyMap.AddFormatter(new DeferredInstantiatedFormatter(instantiator));
-		}
-
-		public void ConvertUsing(Func<TSource, TDestination> mappingFunction)
-		{
-			_typeMap.UseCustomMapper(source => mappingFunction((TSource)source.SourceValue));
-		}
-
-		public void ConvertUsing(Func<ResolutionContext, TDestination> mappingFunction)
-		{
-			_typeMap.UseCustomMapper(context => mappingFunction(context));
-		}
-
-        public void ConvertUsing(Func<ResolutionContext, TSource, TDestination> mappingFunction)
-        {
-            _typeMap.UseCustomMapper(source => mappingFunction(source, (TSource)source.SourceValue));
-        }
-
-		public void ConvertUsing(ITypeConverter<TSource, TDestination> converter)
-		{
-			ConvertUsing(converter.Convert);
-		}
-
-		public void ConvertUsing<TTypeConverter>() where TTypeConverter : ITypeConverter<TSource, TDestination>
-		{
-			var converter = new DeferredInstantiatedConverter<TSource, TDestination>(() => (TTypeConverter)_serviceCtor(typeof(TTypeConverter)));
-
-			ConvertUsing(converter.Convert);
-		}
-
-		public IMappingExpression<TSource, TDestination> BeforeMap(Action<TSource, TDestination> beforeFunction)
-		{
-			_typeMap.AddBeforeMapAction((src, dest) => beforeFunction((TSource)src, (TDestination)dest));
-
-			return this;
-		}
-
-		public IMappingExpression<TSource, TDestination> BeforeMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>
-		{
-			Action<TSource, TDestination> beforeFunction = (src, dest) => ((TMappingAction)_serviceCtor(typeof(TMappingAction))).Process(src, dest);
-
-			return BeforeMap(beforeFunction);
-		}
-
-		public IMappingExpression<TSource, TDestination> AfterMap(Action<TSource, TDestination> afterFunction)
-		{
-			_typeMap.AddAfterMapAction((src, dest) => afterFunction((TSource)src, (TDestination)dest));
-
-			return this;
-		}
-
-		public IMappingExpression<TSource, TDestination> AfterMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>
-		{
-			Action<TSource, TDestination> afterFunction = (src, dest) => ((TMappingAction)_serviceCtor(typeof(TMappingAction))).Process(src, dest);
-
-			return AfterMap(afterFunction);
-		}
-
-		public IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor)
-		{
-			_typeMap.DestinationCtor = src => ctor((TSource) src);
-
-			return this;
-		}
-
-		private void ForDestinationMember(IMemberAccessor destinationProperty, Action<IMemberConfigurationExpression<TSource>> memberOptions)
-		{
-			_propertyMap = _typeMap.FindOrCreatePropertyMapFor(destinationProperty);
-
-			memberOptions(this);
-		}
-	}
-}
+        }
+
+	    public void Ignore()
+		{
+			_propertyMap.Ignore();
+		}
+
+		public void UseDestinationValue()
+		{
+			_propertyMap.UseDestinationValue = true;
+		}
+
+		public void SetMappingOrder(int mappingOrder)
+		{
+			_propertyMap.SetMappingOrder(mappingOrder);
+		}
+
+		public void ConstructFormatterBy(Type formatterType, Func<IValueFormatter> instantiator)
+		{
+			_propertyMap.RemoveLastFormatter();
+			_propertyMap.AddFormatter(new DeferredInstantiatedFormatter(instantiator));
+		}
+
+		public void ConvertUsing(Func<TSource, TDestination> mappingFunction)
+		{
+			_typeMap.UseCustomMapper(source => mappingFunction((TSource)source.SourceValue));
+		}
+
+		public void ConvertUsing(Func<ResolutionContext, TDestination> mappingFunction)
+		{
+			_typeMap.UseCustomMapper(context => mappingFunction(context));
+		}
+
+        public void ConvertUsing(Func<ResolutionContext, TSource, TDestination> mappingFunction)
+        {
+            _typeMap.UseCustomMapper(source => mappingFunction(source, (TSource)source.SourceValue));
+        }
+
+		public void ConvertUsing(ITypeConverter<TSource, TDestination> converter)
+		{
+			ConvertUsing(converter.Convert);
+		}
+
+		public void ConvertUsing<TTypeConverter>() where TTypeConverter : ITypeConverter<TSource, TDestination>
+		{
+			var converter = new DeferredInstantiatedConverter<TSource, TDestination>(() => (TTypeConverter)_serviceCtor(typeof(TTypeConverter)));
+
+			ConvertUsing(converter.Convert);
+		}
+
+		public IMappingExpression<TSource, TDestination> BeforeMap(Action<TSource, TDestination> beforeFunction)
+		{
+			_typeMap.AddBeforeMapAction((src, dest) => beforeFunction((TSource)src, (TDestination)dest));
+
+			return this;
+		}
+
+		public IMappingExpression<TSource, TDestination> BeforeMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>
+		{
+			Action<TSource, TDestination> beforeFunction = (src, dest) => ((TMappingAction)_serviceCtor(typeof(TMappingAction))).Process(src, dest);
+
+			return BeforeMap(beforeFunction);
+		}
+
+		public IMappingExpression<TSource, TDestination> AfterMap(Action<TSource, TDestination> afterFunction)
+		{
+			_typeMap.AddAfterMapAction((src, dest) => afterFunction((TSource)src, (TDestination)dest));
+
+			return this;
+		}
+
+		public IMappingExpression<TSource, TDestination> AfterMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>
+		{
+			Action<TSource, TDestination> afterFunction = (src, dest) => ((TMappingAction)_serviceCtor(typeof(TMappingAction))).Process(src, dest);
+
+			return AfterMap(afterFunction);
+		}
+
+		public IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor)
+		{
+			_typeMap.DestinationCtor = src => ctor((TSource) src);
+
+			return this;
+		}
+
+		private void ForDestinationMember(IMemberAccessor destinationProperty, Action<IMemberConfigurationExpression<TSource>> memberOptions)
+		{
+			_propertyMap = _typeMap.FindOrCreatePropertyMapFor(destinationProperty);
+
+			memberOptions(this);
+		}
+	}
+}
diff --git a/src/AutoMapper/Internal/ResolutionExpression.cs b/src/AutoMapper/Internal/ResolutionExpression.cs
index c7521b98..9fd0718b 100644
--- a/src/AutoMapper/Internal/ResolutionExpression.cs
+++ b/src/AutoMapper/Internal/ResolutionExpression.cs
@@ -1,4 +1,5 @@
 using System;
+using System.Linq.Expressions;
 
 namespace AutoMapper
 {
@@ -15,13 +16,18 @@ public ResolutionExpression(Type sourceType, PropertyMap propertyMap)
 	        _propertyMap = propertyMap;
 	    }
 
-	    public void FromMember(Func<TSource, object> sourceMember)
+	    public void FromMember(Expression<Func<TSource, object>> sourceMember)
 		{
-			_propertyMap.ChainTypeMemberForResolver(new DelegateBasedResolver<TSource>(sourceMember));
+            if (sourceMember.Body is MemberExpression)
+            {
+                _propertyMap.SourceMember = (sourceMember.Body as MemberExpression).Member;
+            }
+            _propertyMap.ChainTypeMemberForResolver(new DelegateBasedResolver<TSource>(sourceMember.Compile()));
 		}
 
 		public void FromMember(string sourcePropertyName)
 		{
+            _propertyMap.SourceMember = _sourceType.GetMember(sourcePropertyName)[0];
 			_propertyMap.ChainTypeMemberForResolver(new PropertyNameResolver(_sourceType, sourcePropertyName));
 		}
 
@@ -53,15 +59,20 @@ public ResolutionExpression(PropertyMap propertyMap)
 			_propertyMap = propertyMap;
 		}
 
-		public IResolverConfigurationExpression<TSource, TValueResolver> FromMember(Func<TSource, object> sourceMember)
+        public IResolverConfigurationExpression<TSource, TValueResolver> FromMember(Expression<Func<TSource, object>> sourceMember)
 		{
-			_propertyMap.ChainTypeMemberForResolver(new DelegateBasedResolver<TSource>(sourceMember));
+            if (sourceMember.Body is MemberExpression)
+            {
+                _propertyMap.SourceMember = (sourceMember.Body as MemberExpression).Member;
+            }
+            _propertyMap.ChainTypeMemberForResolver(new DelegateBasedResolver<TSource>(sourceMember.Compile()));
 
 			return this;
 		}
 
 		public IResolverConfigurationExpression<TSource, TValueResolver> FromMember(string sourcePropertyName)
 		{
+            _propertyMap.SourceMember = typeof(TSource).GetMember(sourcePropertyName)[0];
 			_propertyMap.ChainTypeMemberForResolver(new PropertyNameResolver(typeof(TSource), sourcePropertyName));
 
 			return this;
diff --git a/src/AutoMapper/PropertyMap.cs b/src/AutoMapper/PropertyMap.cs
index 282ccd09..12bc175f 100644
--- a/src/AutoMapper/PropertyMap.cs
+++ b/src/AutoMapper/PropertyMap.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Reflection;
 using AutoMapper.Internal;
 
 namespace AutoMapper
@@ -19,6 +20,7 @@ public class PropertyMap
         private bool _sealed;
         private IValueResolver[] _cachedResolvers;
         private Func<ResolutionContext, bool> _condition;
+        private MemberInfo _sourceMember;
 
         public PropertyMap(IMemberAccessor destinationProperty)
         {
@@ -27,6 +29,27 @@ public PropertyMap(IMemberAccessor destinationProperty)
 
         public IMemberAccessor DestinationProperty { get; private set; }
 
+        public MemberInfo SourceMember
+        {
+            get
+            {
+                if (_sourceMember == null)
+                {
+                    var sourceMemberGetter = GetSourceValueResolvers()
+                        .OfType<IMemberGetter>().LastOrDefault();
+                    return sourceMemberGetter == null ? null : sourceMemberGetter.MemberInfo;
+                }
+                else
+                {
+                    return _sourceMember;
+                }
+            }
+            internal set
+            {
+                _sourceMember = value;
+            }
+        }
+
         public bool CanBeSet
         {
             get
diff --git a/src/UnitTests/CustomMapping.cs b/src/UnitTests/CustomMapping.cs
index c7122447..3de92079 100644
--- a/src/UnitTests/CustomMapping.cs
+++ b/src/UnitTests/CustomMapping.cs
@@ -16,6 +16,7 @@ public class ModelObject
 				public int Value2fff { get; set; }
 				public int Value3 { get; set; }
 				public int Value4 { get; set; }
+				public int Value5 { get; set; }
 			}
 
 			public class ModelDto
@@ -24,6 +25,7 @@ public class ModelDto
 				public int Value2 { get; set; }
 				public int Value3 { get; set; }
 				public int Value4 { get; set; }
+				public int Value5 { get; set; }
 			}
 
 			public class CustomResolver : IValueResolver
@@ -60,9 +62,10 @@ protected override void Establish_context()
 				Mapper.CreateMap<ModelObject, ModelDto>()
 					.ForMember(dto => dto.Value, opt => opt.ResolveUsing<CustomResolver>())
 					.ForMember(dto => dto.Value2, opt => opt.ResolveUsing(new CustomResolver2()))
-					.ForMember(dto => dto.Value4, opt => opt.ResolveUsing(typeof(CustomResolver3)));
+					.ForMember(dto => dto.Value4, opt => opt.ResolveUsing(typeof(CustomResolver3)))
+					.ForMember(dto => dto.Value5, opt => opt.ResolveUsing(src => src.Value5 + 5));
 
-				var model = new ModelObject { Value = 42, Value2fff = 42, Value3 = 42, Value4 = 42 };
+				var model = new ModelObject { Value = 42, Value2fff = 42, Value3 = 42, Value4 = 42, Value5 = 42 };
 				_result = Mapper.Map<ModelObject, ModelDto>(model);
 			}
 
@@ -89,6 +92,12 @@ public void Should_use_the_type_object_based_mapping_for_custom_dto_members()
 			{
 				_result.Value4.ShouldEqual(46);
 			}
+
+			[Test]
+			public void Should_use_the_func_based_mapping_for_custom_dto_members()
+			{
+				_result.Value5.ShouldEqual(47);
+			}
 		}
 
 		public class When_using_a_custom_resolver_for_a_child_model_property_instead_of_the_model : AutoMapperSpecBase
diff --git a/src/UnitTests/Tests/PropertyMapSpecs.cs b/src/UnitTests/Tests/PropertyMapSpecs.cs
new file mode 100644
index 00000000..dfc25f73
--- /dev/null
+++ b/src/UnitTests/Tests/PropertyMapSpecs.cs
@@ -0,0 +1,231 @@
+using System;
+using System.Linq;
+using System.Reflection;
+using Machine.Specifications;
+
+namespace AutoMapper.UnitTests.Tests
+{
+    public abstract class PropertyMap_SourceMember_Specs
+    {
+        Cleanup after = () => Mapper.Reset();
+    }
+
+    public abstract class using_generic_configuration : PropertyMap_SourceMember_Specs
+    {
+        Establish context = () => Mapper.CreateMap<Source, Destination>()
+            .ForMember(d => d.Ignored, o => o.Ignore())
+            .ForMember(d => d.RenamedField, o => o.MapFrom(s => s.NamedProperty))
+            .ForMember(d => d.IntField, o => o.ResolveUsing<FakeResolver>().FromMember(s => s.StringField))
+            .ForMember("IntProperty", o => o.ResolveUsing<FakeResolver>().FromMember("AnotherStringField"))
+            .ForMember(d => d.IntProperty3, o => o.ResolveUsing(typeof(FakeResolver)).FromMember(s => s.StringField3))
+            .ForMember(d => d.IntField4, o => o.ResolveUsing(new FakeResolver()).FromMember("StringField4"));
+
+        protected class Source
+        {
+            public int PropertyWithMatchingName { get; set; }
+            public NestedSource NestedSource { get; set; }
+            public int NamedProperty { get; set; }
+            public string StringField;
+            public string AnotherStringField;
+            public string StringField3;
+            public string StringField4;
+        }
+
+        protected class NestedSource
+        {
+            public int SomeField;
+        }
+
+        protected class Destination
+        {
+            public int PropertyWithMatchingName { get; set; }
+            public string NestedSourceSomeField;
+            public string Ignored { get; set; }
+            public string RenamedField;
+            public int IntField;
+            public int IntProperty { get; set; }
+            public int IntProperty3 { get; set; }
+            public int IntField4;
+        }
+
+        class FakeResolver : ValueResolver<string, int>
+        {
+            protected override int ResolveCore(string source)
+            {
+                return default(int);
+            }
+        }
+    }
+
+    [Subject(typeof(PropertyMap), ".SourceMember")]
+    public class when_members_have_matching_names : using_generic_configuration
+    {
+        const string memberName = "PropertyWithMatchingName";
+        static MemberInfo sourceMember;
+
+        Because of = () => sourceMember =
+            Mapper.FindTypeMapFor<Source, Destination>()
+                .GetPropertyMaps()
+                .Single(pm => pm.DestinationProperty.Name == memberName)
+                .SourceMember;
+
+        It should_not_be_null = () => sourceMember.ShouldNotBeNull();
+
+        It should_have_the_matching_member_of_the_source_type_as_value = () =>
+            sourceMember.ShouldBeTheSameAs(typeof(Source).GetProperty(memberName));
+    }
+
+    [Subject(typeof(PropertyMap), ".SourceMember")]
+    public class when_the_destination_member_is_flattened : using_generic_configuration
+    {
+        static MemberInfo sourceMember;
+
+        Because of = () => sourceMember =
+            Mapper.FindTypeMapFor<Source, Destination>()
+                .GetPropertyMaps()
+                .Single(pm => pm.DestinationProperty.Name == "NestedSourceSomeField")
+                .SourceMember;
+
+        It should_not_be_null = () => sourceMember.ShouldNotBeNull();
+
+        It should_have_the_member_of_the_nested_source_type_as_value = () =>
+            sourceMember.ShouldBeTheSameAs(typeof(NestedSource).GetField("SomeField"));
+    }
+
+    [Subject(typeof(PropertyMap), ".SourceMember")]
+    public class when_the_destination_member_is_ignored : using_generic_configuration
+    {
+        static Exception exception;
+        static MemberInfo sourceMember;
+
+        Because of = () => exception = Catch.Exception(() =>
+            sourceMember =
+                Mapper.FindTypeMapFor<Source, Destination>()
+                    .GetPropertyMaps()
+                    .Single(pm => pm.DestinationProperty.Name == "Ignored")
+                    .SourceMember
+        );
+
+        It should_not_throw_an_exception = () => exception.ShouldBeNull();
+
+        It should_be_null = () => sourceMember.ShouldBeNull();
+    }
+
+    [Subject(typeof(PropertyMap), ".SourceMember")]
+    public class when_the_destination_member_is_projected : using_generic_configuration
+    {
+        static MemberInfo sourceMember;
+
+        Because of = () => sourceMember =
+            Mapper.FindTypeMapFor<Source, Destination>()
+                .GetPropertyMaps()
+                .Single(pm => pm.DestinationProperty.Name == "RenamedField")
+                .SourceMember;
+
+        It should_not_be_null = () => sourceMember.ShouldNotBeNull();
+
+        It should_have_the_projected_member_of_the_source_type_as_value = () =>
+            sourceMember.ShouldBeTheSameAs(typeof(Source).GetProperty("NamedProperty"));
+    }
+
+    [Subject(typeof(PropertyMap), ".SourceMember")]
+    public class when_the_destination_member_is_resolved_from_a_source_member : using_generic_configuration
+    {
+        static MemberInfo sourceMember;
+
+        Because of = () => sourceMember =
+            Mapper.FindTypeMapFor<Source, Destination>()
+                .GetPropertyMaps()
+                .Single(pm => pm.DestinationProperty.Name == "IntField")
+                .SourceMember;
+
+        It should_not_be_null = () => sourceMember.ShouldNotBeNull();
+
+        It should_have_the_member_of_the_source_type_it_is_resolved_from_as_value = () =>
+            sourceMember.ShouldBeTheSameAs(typeof(Source).GetField("StringField"));
+    }
+
+    [Subject(typeof(PropertyMap), ".SourceMember")]
+    public class when_the_destination_property_is_resolved_from_a_source_member_using_the_Magic_String_overload : using_generic_configuration
+    {
+        static MemberInfo sourceMember;
+
+        Because of = () => sourceMember =
+            Mapper.FindTypeMapFor<Source, Destination>()
+                .GetPropertyMaps()
+                .Single(pm => pm.DestinationProperty.Name == "IntProperty")
+                .SourceMember;
+
+        It should_not_be_null = () => sourceMember.ShouldNotBeNull();
+
+        It should_have_the_member_of_the_source_type_it_is_resolved_from_as_value = () =>
+            sourceMember.ShouldBeTheSameAs(typeof(Source).GetField("AnotherStringField"));
+    }
+
+    [Subject(typeof(PropertyMap), ".SourceMember")]
+    public class when_the_destination_property_is_resolved_from_a_source_member_using_the_non_generic_resolve_method : using_generic_configuration
+    {
+        static MemberInfo sourceMember;
+
+        Because of = () => sourceMember =
+            Mapper.FindTypeMapFor<Source, Destination>()
+                .GetPropertyMaps()
+                .Single(pm => pm.DestinationProperty.Name == "IntProperty3")
+                .SourceMember;
+
+        It should_not_be_null = () => sourceMember.ShouldNotBeNull();
+
+        It should_have_the_member_of_the_source_type_it_is_resolved_from_as_value = () =>
+            sourceMember.ShouldBeTheSameAs(typeof(Source).GetField("StringField3"));
+    }
+
+    [Subject(typeof(PropertyMap), ".SourceMember")]
+    public class when_the_destination_property_is_resolved_from_a_source_member_using_non_the_generic_resolve_method_and_the_Magic_String_overload : using_generic_configuration
+    {
+        static MemberInfo sourceMember;
+
+        Because of = () => sourceMember =
+            Mapper.FindTypeMapFor<Source, Destination>()
+                .GetPropertyMaps()
+                .Single(pm => pm.DestinationProperty.Name == "IntField4")
+                .SourceMember;
+
+        It should_not_be_null = () => sourceMember.ShouldNotBeNull();
+
+        It should_have_the_member_of_the_source_type_it_is_resolved_from_as_value = () =>
+            sourceMember.ShouldBeTheSameAs(typeof(Source).GetField("StringField4"));
+    }
+
+    public abstract class using_nongeneric_configuration : PropertyMap_SourceMember_Specs
+    {
+        Establish context = () => Mapper.CreateMap(typeof(Source), typeof(Destination))
+            .ForMember("RenamedProperty", o => o.MapFrom("NamedProperty"));
+
+        protected class Source
+        {
+            public int NamedProperty { get; set; }
+        }
+
+        protected class Destination
+        {
+            public string RenamedProperty { get; set; }
+        }
+    }
+
+    [Subject(typeof(PropertyMap), ".SourceMember")]
+    public class when_the_destination_property_is_projected : using_nongeneric_configuration
+    {
+        static MemberInfo sourceMember;
+
+        Because of = () => sourceMember =
+            Mapper.FindTypeMapFor<Source, Destination>()
+                .GetPropertyMaps()
+                .Single(pm => pm.DestinationProperty.Name == "RenamedProperty")
+                .SourceMember;
+
+        It should_not_be_null = () => sourceMember.ShouldNotBeNull();
+
+        It should_have_the_projected_member_of_the_source_type_as_value = () =>
+            sourceMember.ShouldBeTheSameAs(typeof(Source).GetProperty("NamedProperty"));
+    }
+}
\ No newline at end of file
diff --git a/src/UnitTests/UnitTests.csproj b/src/UnitTests/UnitTests.csproj
index 3b5a80b1..af9e0b08 100644
--- a/src/UnitTests/UnitTests.csproj
+++ b/src/UnitTests/UnitTests.csproj
@@ -170,6 +170,7 @@
     <Compile Include="TesterExtensions.cs" />
     <Compile Include="ConfigurationValidation.cs" />
     <Compile Include="ResolutionContextTester.cs" />
+    <Compile Include="Tests\PropertyMapSpecs.cs" />
     <Compile Include="Tests\MapperTests.cs" />
     <Compile Include="Tests\TypeInfoSpecs.cs" />
     <Compile Include="Tests\TypeMapFactorySpecs.cs" />
