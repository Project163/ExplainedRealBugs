diff --git a/src/AutoMapper.Silverlight/AutoMapper.Silverlight.csproj b/src/AutoMapper.Silverlight/AutoMapper.Silverlight.csproj
index 9b58659c..14dfcea5 100644
--- a/src/AutoMapper.Silverlight/AutoMapper.Silverlight.csproj
+++ b/src/AutoMapper.Silverlight/AutoMapper.Silverlight.csproj
@@ -275,9 +275,15 @@
     <Compile Include="..\AutoMapper\Mappers\EnumMapper.cs">
       <Link>Mappers\EnumMapper.cs</Link>
     </Compile>
+    <Compile Include="..\AutoMapper\Mappers\ExplicitConversionOperatorMapper.cs">
+      <Link>Mappers\ExplicitConversionOperatorMapper.cs</Link>
+    </Compile>
     <Compile Include="..\AutoMapper\Mappers\FlagsEnumMapper.cs">
       <Link>Mappers\FlagsEnumMapper.cs</Link>
     </Compile>
+    <Compile Include="..\AutoMapper\Mappers\ImplicitConversionOperatorMapper.cs">
+      <Link>Mappers\ImplicitConversionOperatorMapper.cs</Link>
+    </Compile>
     <Compile Include="..\AutoMapper\Mappers\ITypeMapObjectMapper.cs">
       <Link>Mappers\ITypeMapObjectMapper.cs</Link>
     </Compile>
diff --git a/src/AutoMapper/AutoMapper.csproj b/src/AutoMapper/AutoMapper.csproj
index a99aa846..3c2bad76 100644
--- a/src/AutoMapper/AutoMapper.csproj
+++ b/src/AutoMapper/AutoMapper.csproj
@@ -92,6 +92,8 @@
       <Link>Properties\CommonAssemblyInfo.cs</Link>
     </Compile>
     <Compile Include="Internal\AliasedMember.cs" />
+    <Compile Include="Mappers\ExplicitConversionOperatorMapper.cs" />
+    <Compile Include="Mappers\ImplicitConversionOperatorMapper.cs" />
     <Compile Include="MemberList.cs" />
     <Compile Include="Mappers\NameValueCollectionMapper.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
diff --git a/src/AutoMapper/AutoMapperMappingException.cs b/src/AutoMapper/AutoMapperMappingException.cs
index ad0d867b..d4658d28 100644
--- a/src/AutoMapper/AutoMapperMappingException.cs
+++ b/src/AutoMapper/AutoMapperMappingException.cs
@@ -70,7 +70,8 @@ public override string Message
                 string message = null;
                 if (Context != null)
                 {
-                    message = "\n\nMapping types:";
+
+                    message = _message + "\n\nMapping types:";
                     message += Environment.NewLine + string.Format("{0} -> {1}", Context.SourceType.Name, Context.DestinationType.Name);
                     message += Environment.NewLine + string.Format("{0} -> {1}", Context.SourceType.FullName, Context.DestinationType.FullName);
 
@@ -124,6 +125,7 @@ private static IEnumerable<ResolutionContext> GetContexts(ResolutionContext cont
 	        yield return context;
 	    }
 
+#if !DEBUG
 	    public override string StackTrace
         {
             get
@@ -134,5 +136,6 @@ public override string StackTrace
                         .Where(str => !str.TrimStart().StartsWith("at AutoMapper.")));
             }
         }
+#endif
     }
 }
diff --git a/src/AutoMapper/Mappers/ExplicitConversionOperatorMapper.cs b/src/AutoMapper/Mappers/ExplicitConversionOperatorMapper.cs
new file mode 100644
index 00000000..968ebbe0
--- /dev/null
+++ b/src/AutoMapper/Mappers/ExplicitConversionOperatorMapper.cs
@@ -0,0 +1,35 @@
+using System.Reflection;
+using System.Linq;
+
+namespace AutoMapper.Mappers
+{
+	public class ExplicitConversionOperatorMapper : IObjectMapper
+	{
+		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+		{
+		    var implicitOperator = GetExplicitConversionOperator(context);
+
+		    return implicitOperator.Invoke(null, new[] {context.SourceValue});
+		}
+
+		public bool IsMatch(ResolutionContext context)
+		{
+            var methodInfo = GetExplicitConversionOperator(context);
+
+		    return methodInfo != null;
+		}
+
+	    private static MethodInfo GetExplicitConversionOperator(ResolutionContext context)
+	    {
+	        var sourceTypeMethod = context.SourceType.GetMethods(BindingFlags.Public | BindingFlags.Static)
+                .Where(mi => mi.Name == "op_Explicit")
+                .Where(mi => mi.ReturnType == context.DestinationType)
+                .FirstOrDefault();
+
+            var destTypeMethod = context.DestinationType.GetMethod("op_Explicit", new[] { context.SourceType });
+
+	        return sourceTypeMethod ?? destTypeMethod;
+	    }
+	}
+
+}
\ No newline at end of file
diff --git a/src/AutoMapper/Mappers/ImplicitConversionOperatorMapper.cs b/src/AutoMapper/Mappers/ImplicitConversionOperatorMapper.cs
new file mode 100644
index 00000000..283d1aa0
--- /dev/null
+++ b/src/AutoMapper/Mappers/ImplicitConversionOperatorMapper.cs
@@ -0,0 +1,35 @@
+using System.Reflection;
+using System.Linq;
+
+namespace AutoMapper.Mappers
+{
+	public class ImplicitConversionOperatorMapper : IObjectMapper
+	{
+		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+		{
+		    var implicitOperator = GetImplicitConversionOperator(context);
+
+		    return implicitOperator.Invoke(null, new[] {context.SourceValue});
+		}
+
+		public bool IsMatch(ResolutionContext context)
+		{
+            var methodInfo = GetImplicitConversionOperator(context);
+
+		    return methodInfo != null;
+		}
+
+	    private static MethodInfo GetImplicitConversionOperator(ResolutionContext context)
+	    {
+	        var sourceTypeMethod = context.SourceType.GetMethods(BindingFlags.Public | BindingFlags.Static)
+                .Where(mi => mi.Name == "op_Implicit")
+                .Where(mi => mi.ReturnType == context.DestinationType)
+                .FirstOrDefault();
+
+	        var destTypeMethod = context.DestinationType.GetMethod("op_Implicit", new[] {context.SourceType});
+
+	        return sourceTypeMethod ?? destTypeMethod;
+	    }
+	}
+
+}
\ No newline at end of file
diff --git a/src/AutoMapper/Mappers/MapperRegistry.cs b/src/AutoMapper/Mappers/MapperRegistry.cs
index a99efc58..11e4b941 100644
--- a/src/AutoMapper/Mappers/MapperRegistry.cs
+++ b/src/AutoMapper/Mappers/MapperRegistry.cs
@@ -28,7 +28,10 @@ public static class MapperRegistry
             new EnumerableMapper(),
             new AssignableMapper(),
             new TypeConverterMapper(),
-            new NullableMapper()
+            new NullableSourceMapper(),
+            new NullableMapper(),
+            new ImplicitConversionOperatorMapper(),
+            new ExplicitConversionOperatorMapper(),
         };
     }
 }
\ No newline at end of file
diff --git a/src/AutoMapper/Mappers/NullableMapper.cs b/src/AutoMapper/Mappers/NullableMapper.cs
index 8c1ce9da..ccdfe70b 100644
--- a/src/AutoMapper/Mappers/NullableMapper.cs
+++ b/src/AutoMapper/Mappers/NullableMapper.cs
@@ -12,4 +12,17 @@ public bool IsMatch(ResolutionContext context)
 			return context.DestinationType.IsNullableType();
 		}
 	}
+
+	public class NullableSourceMapper : IObjectMapper
+	{
+		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+		{
+			return context.SourceValue ?? mapper.CreateObject(context);
+		}
+
+		public bool IsMatch(ResolutionContext context)
+		{
+			return context.SourceType.IsNullableType() && ! context.DestinationType.IsNullableType();
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/UnitTests/ConfigurationValidation.cs b/src/UnitTests/ConfigurationValidation.cs
index 7b13de39..6d3e7bfb 100644
--- a/src/UnitTests/ConfigurationValidation.cs
+++ b/src/UnitTests/ConfigurationValidation.cs
@@ -103,12 +103,12 @@ public class When_testing_a_dto_with_matching_member_names_but_mismatched_types
         {
             public class Source
             {
-                public int Value { get; set; }
+                public decimal Value { get; set; }
             }
 
             public class Destination
             {
-                public decimal Value { get; set; }
+                public Type Value { get; set; }
             }
 
             protected override void Establish_context()
diff --git a/src/UnitTests/ConversionOperators.cs b/src/UnitTests/ConversionOperators.cs
new file mode 100644
index 00000000..db33a4ed
--- /dev/null
+++ b/src/UnitTests/ConversionOperators.cs
@@ -0,0 +1,155 @@
+using NUnit.Framework;
+using Should;
+
+namespace AutoMapper.UnitTests
+{
+    namespace ConversionOperators
+    {
+        public class When_mapping_to_classes_with_implicit_conversion_operators_on_the_destination : AutoMapperSpecBase
+        {
+            private Bar _bar;
+
+            public class Foo
+            {
+                public string Value { get; set; }
+            }
+
+            public class Bar
+            {
+                public string OtherValue { get; set; }
+
+                public static implicit operator Bar(Foo other)
+                {
+                    return new Bar
+                    {
+                        OtherValue = other.Value
+                    };
+                }
+
+            }
+
+            protected override void Because_of()
+            {
+                var source = new Foo { Value = "Hello" };
+
+                _bar = Mapper.Map<Foo, Bar>(source);
+            }
+
+            [Test]
+            public void Should_use_the_implicit_conversion_operator()
+            {
+                _bar.OtherValue.ShouldEqual("Hello");
+            }
+        }
+        
+        public class When_mapping_to_classes_with_implicit_conversion_operators_on_the_source : AutoMapperSpecBase
+        {
+            private Bar _bar;
+
+            public class Foo
+            {
+                public string Value { get; set; }
+
+                public static implicit operator Bar(Foo other)
+                {
+                    return new Bar
+                    {
+                        OtherValue = other.Value
+                    };
+                }
+
+                public static implicit operator string(Foo other)
+                {
+                    return other.Value;
+                }
+
+            }
+
+            public class Bar
+            {
+                public string OtherValue { get; set; }
+            }
+
+            protected override void Because_of()
+            {
+                var source = new Foo { Value = "Hello" };
+
+                _bar = Mapper.Map<Foo, Bar>(source);
+            }
+
+            [Test]
+            public void Should_use_the_implicit_conversion_operator()
+            {
+                _bar.OtherValue.ShouldEqual("Hello");
+            }
+        }
+
+        public class When_mapping_to_classes_with_explicit_conversion_operator_on_the_destination : AutoMapperSpecBase
+        {
+            private Bar _bar;
+
+            public class Foo
+            {
+                public string Value { get; set; }
+            }
+
+            public class Bar
+            {
+                public string OtherValue { get; set; }
+
+                public static explicit operator Bar(Foo other)
+                {
+                    return new Bar
+                    {
+                        OtherValue = other.Value
+                    };
+                }
+            }
+
+            protected override void Because_of()
+            {
+                _bar = Mapper.Map<Foo, Bar>(new Foo { Value = "Hello" });
+            }
+
+            [Test]
+            public void Should_use_the_explicit_conversion_operator()
+            {
+                _bar.OtherValue.ShouldEqual("Hello");
+            }
+        }
+
+        public class When_mapping_to_classes_with_explicit_conversion_operator_on_the_source : AutoMapperSpecBase
+        {
+            private Bar _bar;
+
+            public class Foo
+            {
+                public string Value { get; set; }
+
+                public static explicit operator Bar(Foo other)
+                {
+                    return new Bar
+                    {
+                        OtherValue = other.Value
+                    };
+                }
+            }
+
+            public class Bar
+            {
+                public string OtherValue { get; set; }
+            }
+
+            protected override void Because_of()
+            {
+                _bar = Mapper.Map<Foo, Bar>(new Foo { Value = "Hello" });
+            }
+
+            [Test]
+            public void Should_use_the_explicit_conversion_operator()
+            {
+                _bar.OtherValue.ShouldEqual("Hello");
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/UnitTests/UnitTests.csproj b/src/UnitTests/UnitTests.csproj
index 2777904e..68cf2ae2 100644
--- a/src/UnitTests/UnitTests.csproj
+++ b/src/UnitTests/UnitTests.csproj
@@ -128,6 +128,7 @@
     <Compile Include="ConditionalMapping.cs" />
     <Compile Include="Configuration\MapperConfigurationSpecs.cs" />
     <Compile Include="Constructors.cs" />
+    <Compile Include="ConversionOperators.cs" />
     <Compile Include="CustomFormatters.cs" />
     <Compile Include="CustomMapping.cs" />
     <Compile Include="DataReaderMapping.cs" />
