diff --git a/src/AutoMapper/IMappingOperationOptions.cs b/src/AutoMapper/IMappingOperationOptions.cs
index 97af6670..6f403c21 100644
--- a/src/AutoMapper/IMappingOperationOptions.cs
+++ b/src/AutoMapper/IMappingOperationOptions.cs
@@ -5,6 +5,7 @@ namespace AutoMapper
     public interface IMappingOperationOptions
     {
         void ConstructServicesUsing(Func<Type, object> constructor);
+        bool CreateMissingTypeMaps { get; set; }
     }
 
     public class MappingOperationOptions : IMappingOperationOptions
@@ -16,6 +17,8 @@ public class MappingOperationOptions : IMappingOperationOptions
             get { return _serviceCtor; }
         }
 
+        public bool CreateMissingTypeMaps { get; set; }
+
         public void ConstructServicesUsing(Func<Type, object> constructor)
         {
             _serviceCtor = constructor;
diff --git a/src/AutoMapper/MappingEngine.cs b/src/AutoMapper/MappingEngine.cs
index b62975eb..16376a7a 100644
--- a/src/AutoMapper/MappingEngine.cs
+++ b/src/AutoMapper/MappingEngine.cs
@@ -167,7 +167,10 @@ public object DynamicMap(object source, Type sourceType, Type destinationType)
 			var typeMap = ConfigurationProvider.FindTypeMapFor(source, sourceType, destinationType) ??
 			              ConfigurationProvider.CreateTypeMap(sourceType, destinationType);
 
-			var context = new ResolutionContext(typeMap, source, sourceType, destinationType, new MappingOperationOptions());
+			var context = new ResolutionContext(typeMap, source, sourceType, destinationType, new MappingOperationOptions
+			{
+			    CreateMissingTypeMaps = true
+			});
 
 			return ((IMappingEngineRunner)this).Map(context);
 		}
@@ -177,7 +180,10 @@ public void DynamicMap(object source, object destination, Type sourceType, Type
 			var typeMap = ConfigurationProvider.FindTypeMapFor(source, sourceType, destinationType) ??
 			              ConfigurationProvider.CreateTypeMap(sourceType, destinationType);
 
-			var context = new ResolutionContext(typeMap, source, destination, sourceType, destinationType, new MappingOperationOptions());
+			var context = new ResolutionContext(typeMap, source, destination, sourceType, destinationType, new MappingOperationOptions
+			{
+			    CreateMissingTypeMaps = true
+			});
 
 			((IMappingEngineRunner)this).Map(context);
 		}
@@ -330,10 +336,21 @@ object IMappingEngineRunner.Map(ResolutionContext context)
 
 				if (mapperToUse == null)
 				{
-                    if (context.SourceValue != null)
-					    throw new AutoMapperMappingException(context, "Missing type map configuration or unsupported mapping.");
+                    if (context.Options.CreateMissingTypeMaps)
+                    {
+                        var typeMap = ConfigurationProvider.CreateTypeMap(context.SourceType, context.DestinationType);
 
-				    return ObjectCreator.CreateDefaultValue(context.DestinationType);
+                        context = context.CreateTypeContext(typeMap, context.SourceValue, context.SourceType, context.DestinationType);
+
+                        mapperToUse = _objectMapperCache.GetOrAdd(contextTypePair, missFunc);
+                    }
+                    else
+                    {
+                        if (context.SourceValue != null)
+                            throw new AutoMapperMappingException(context, "Missing type map configuration or unsupported mapping.");
+
+                        return ObjectCreator.CreateDefaultValue(context.DestinationType);
+                    }
 				}
 
 				return mapperToUse.Map(context, this);
diff --git a/src/UnitTests/DynamicMapping.cs b/src/UnitTests/DynamicMapping.cs
index ca1de850..03153b96 100644
--- a/src/UnitTests/DynamicMapping.cs
+++ b/src/UnitTests/DynamicMapping.cs
@@ -35,6 +35,58 @@ public void Should_dynamically_map_the_two_types()
 			}
 		}
 
+        public class When_mapping_two_non_configured_types_with_nesting : AutoMapperSpecBase
+        {
+            private Destination _resultWithGenerics;
+
+            public class Source
+            {
+                public int Value { get; set; }
+                public ChildSource Child { get; set; }
+            }
+
+            public class ChildSource
+            {
+                public string Value2 { get; set; }
+            }
+
+            public class Destination
+            {
+                public int Value { get; set; }
+                public ChildDestination Child { get; set; }
+            }
+
+            public class ChildDestination
+            {
+                public string Value2 { get; set; }
+            }
+
+            protected override void Because_of()
+            {
+                var source = new Source
+                {
+                    Value = 5,
+                    Child = new ChildSource
+                    {
+                        Value2 = "foo"
+                    }
+                };
+                _resultWithGenerics = Mapper.DynamicMap<Source, Destination>(source);
+            }
+
+            [Test]
+            public void Should_dynamically_map_the_two_types()
+            {
+                _resultWithGenerics.Value.ShouldEqual(5);
+            }
+
+            [Test]
+            public void Should_dynamically_map_the_children()
+            {
+                _resultWithGenerics.Child.Value2.ShouldEqual("foo");
+            }
+        }
+
 		public class When_mapping_two_non_configured_types_that_do_not_match : NonValidatingSpecBase
 		{
 			public class Source
