diff --git a/src/AutoMapper/Internal/PrimitiveExtensions.cs b/src/AutoMapper/Internal/PrimitiveExtensions.cs
index 40e78f33..84fe3ee2 100644
--- a/src/AutoMapper/Internal/PrimitiveExtensions.cs
+++ b/src/AutoMapper/Internal/PrimitiveExtensions.cs
@@ -1,75 +1,75 @@
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-
-namespace AutoMapper
-{
-	public static class PrimitiveExtensions
-	{
-		public static string ToNullSafeString(this object value)
-		{
-			return value == null ? null : value.ToString();
-		}
-        
-		public static bool IsNullableType(this Type type)
-		{
-			return type.IsGenericType && (type.GetGenericTypeDefinition().Equals(typeof(Nullable<>)));
-		}
-
-        public static Type GetTypeOfNullable(this Type type)
-        {
-            return type.GetGenericArguments()[0];
-        }
-
-        public static bool IsCollectionType(this Type type)
-        {
-            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(ICollection<>))
-            {
-                return true;
-            }
-
-            IEnumerable<Type> genericInterfaces = type.GetInterfaces().Where(t => t.IsGenericType);
-            IEnumerable<Type> baseDefinitions = genericInterfaces.Select(t => t.GetGenericTypeDefinition());
-            
-            var isCollectionType = baseDefinitions.Any(t => t == typeof(ICollection<>));
-
-            return isCollectionType;
-        }
-
-
-		public static bool IsEnumerableType(this Type type)
-		{
-			return type.GetInterfaces().Contains(typeof (IEnumerable));
-		}
-
-		public static bool IsListType(this Type type)
-		{
-			return type.GetInterfaces().Contains(typeof (IList));
-		}
-
-		public static bool IsListOrDictionaryType(this Type type)
-		{
-			return type.IsListType() || type.IsDictionaryType();
-		}
-
-		public static bool IsDictionaryType(this Type type)
-		{
-			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(System.Collections.Generic.IDictionary<,>))
-				return true;
-
-			var genericInterfaces = type.GetInterfaces().Where(t => t.IsGenericType);
-			var baseDefinitions = genericInterfaces.Select(t => t.GetGenericTypeDefinition());
-			return baseDefinitions.Any(t => t == typeof(System.Collections.Generic.IDictionary<,>));
-		}
-
-		public static Type GetDictionaryType(this Type type)
-		{
-			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(System.Collections.Generic.IDictionary<,>))
-				return type;
-
-			var genericInterfaces = type.GetInterfaces().Where(t => t.IsGenericType && t.GetGenericTypeDefinition() == typeof(System.Collections.Generic.IDictionary<,>));
-			return genericInterfaces.FirstOrDefault();
-		}
-	}
-}
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace AutoMapper.Internal
+{
+	public static class PrimitiveExtensions
+	{
+		public static string ToNullSafeString(this object value)
+		{
+			return value == null ? null : value.ToString();
+		}
+        
+		public static bool IsNullableType(this Type type)
+		{
+			return type.IsGenericType && (type.GetGenericTypeDefinition().Equals(typeof(Nullable<>)));
+		}
+
+        public static Type GetTypeOfNullable(this Type type)
+        {
+            return type.GetGenericArguments()[0];
+        }
+
+        public static bool IsCollectionType(this Type type)
+        {
+            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(ICollection<>))
+            {
+                return true;
+            }
+
+            IEnumerable<Type> genericInterfaces = type.GetInterfaces().Where(t => t.IsGenericType);
+            IEnumerable<Type> baseDefinitions = genericInterfaces.Select(t => t.GetGenericTypeDefinition());
+            
+            var isCollectionType = baseDefinitions.Any(t => t == typeof(ICollection<>));
+
+            return isCollectionType;
+        }
+
+
+		public static bool IsEnumerableType(this Type type)
+		{
+			return type.GetInterfaces().Contains(typeof (IEnumerable));
+		}
+
+		public static bool IsListType(this Type type)
+		{
+			return type.GetInterfaces().Contains(typeof (IList));
+		}
+
+		public static bool IsListOrDictionaryType(this Type type)
+		{
+			return type.IsListType() || type.IsDictionaryType();
+		}
+
+		public static bool IsDictionaryType(this Type type)
+		{
+			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(System.Collections.Generic.IDictionary<,>))
+				return true;
+
+			var genericInterfaces = type.GetInterfaces().Where(t => t.IsGenericType);
+			var baseDefinitions = genericInterfaces.Select(t => t.GetGenericTypeDefinition());
+			return baseDefinitions.Any(t => t == typeof(System.Collections.Generic.IDictionary<,>));
+		}
+
+		public static Type GetDictionaryType(this Type type)
+		{
+			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(System.Collections.Generic.IDictionary<,>))
+				return type;
+
+			var genericInterfaces = type.GetInterfaces().Where(t => t.IsGenericType && t.GetGenericTypeDefinition() == typeof(System.Collections.Generic.IDictionary<,>));
+			return genericInterfaces.FirstOrDefault();
+		}
+	}
+}
diff --git a/src/AutoMapper/Mappers/ArrayMapper.cs b/src/AutoMapper/Mappers/ArrayMapper.cs
index c7708c67..a4eb45bd 100644
--- a/src/AutoMapper/Mappers/ArrayMapper.cs
+++ b/src/AutoMapper/Mappers/ArrayMapper.cs
@@ -1,32 +1,33 @@
-using System;
-
-namespace AutoMapper.Mappers
-{
-	public class ArrayMapper : EnumerableMapperBase<Array>
-	{
-		public override bool IsMatch(ResolutionContext context)
-		{
-			return (context.DestinationType.IsArray) && (context.SourceType.IsEnumerableType());
-		}
-
-		protected override void ClearEnumerable(Array enumerable)
-		{
-			// no op
-		}
-
-		protected override void SetElementValue(Array destination, object mappedValue, int index)
-		{
-			destination.SetValue(mappedValue, index);
-		}
-
-	    protected override Array CreateDestinationObjectBase(Type destElementType, int sourceLength)
-	    {
-            throw new NotImplementedException();
-        }
-
-	    protected override object GetOrCreateDestinationObject(ResolutionContext context, IMappingEngineRunner mapper, Type destElementType, int sourceLength)
-        {
-            return ObjectCreator.CreateArray(destElementType, sourceLength);
-        }
-	}
+using System;
+using AutoMapper.Internal;
+
+namespace AutoMapper.Mappers
+{
+	public class ArrayMapper : EnumerableMapperBase<Array>
+	{
+		public override bool IsMatch(ResolutionContext context)
+		{
+			return (context.DestinationType.IsArray) && (context.SourceType.IsEnumerableType());
+		}
+
+		protected override void ClearEnumerable(Array enumerable)
+		{
+			// no op
+		}
+
+		protected override void SetElementValue(Array destination, object mappedValue, int index)
+		{
+			destination.SetValue(mappedValue, index);
+		}
+
+	    protected override Array CreateDestinationObjectBase(Type destElementType, int sourceLength)
+	    {
+            throw new NotImplementedException();
+        }
+
+	    protected override object GetOrCreateDestinationObject(ResolutionContext context, IMappingEngineRunner mapper, Type destElementType, int sourceLength)
+        {
+            return ObjectCreator.CreateArray(destElementType, sourceLength);
+        }
+	}
 }
\ No newline at end of file
diff --git a/src/AutoMapper/Mappers/CollectionMapper.cs b/src/AutoMapper/Mappers/CollectionMapper.cs
index d425ad02..3a223443 100644
--- a/src/AutoMapper/Mappers/CollectionMapper.cs
+++ b/src/AutoMapper/Mappers/CollectionMapper.cs
@@ -1,68 +1,69 @@
-using System;
-using System.Collections.Generic;
-
-namespace AutoMapper.Mappers
-{
-    public class CollectionMapper : IObjectMapper
-    {
-        public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-        {
-            Type genericType = typeof(EnumerableMapper<,>);
-
-            var collectionType = context.DestinationType;
-            var elementType = TypeHelper.GetElementType(context.DestinationType);
-            
-            var enumerableMapper = genericType.MakeGenericType(collectionType, elementType);
-
-            var objectMapper = (IObjectMapper)Activator.CreateInstance(enumerableMapper);
-
-            return objectMapper.Map(context, mapper);
-        }
-
-        public bool IsMatch(ResolutionContext context)
-        {
-            var isMatch = context.SourceType.IsEnumerableType() && context.DestinationType.IsCollectionType();
-
-            return isMatch;
-        }
-
-        #region Nested type: EnumerableMapper
-
-        private class EnumerableMapper<TCollection, TElement> : EnumerableMapperBase<TCollection>
-            where TCollection : ICollection<TElement>
-        {
-            public override bool IsMatch(ResolutionContext context)
-            {
-                throw new NotImplementedException();
-            }
-
-            protected override void SetElementValue(TCollection destination, object mappedValue, int index)
-            {
-                destination.Add((TElement)mappedValue);
-            }
-
-            protected override void ClearEnumerable(TCollection enumerable)
-            {
-                enumerable.Clear();
-            }
-
-            protected override TCollection CreateDestinationObjectBase(Type destElementType, int sourceLength)
-            {
-                Object collection;
-                
-                if (typeof(TCollection).IsInterface)
-                {
-                    collection = new List<TElement>();
-                }
-                else
-                {
-                    collection = ObjectCreator.CreateDefaultValue(typeof(TCollection));
-                }
-
-                return (TCollection)collection;
-            }
-        }
-
-        #endregion
-    }
+using System;
+using System.Collections.Generic;
+using AutoMapper.Internal;
+
+namespace AutoMapper.Mappers
+{
+    public class CollectionMapper : IObjectMapper
+    {
+        public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+        {
+            Type genericType = typeof(EnumerableMapper<,>);
+
+            var collectionType = context.DestinationType;
+            var elementType = TypeHelper.GetElementType(context.DestinationType);
+            
+            var enumerableMapper = genericType.MakeGenericType(collectionType, elementType);
+
+            var objectMapper = (IObjectMapper)Activator.CreateInstance(enumerableMapper);
+
+            return objectMapper.Map(context, mapper);
+        }
+
+        public bool IsMatch(ResolutionContext context)
+        {
+            var isMatch = context.SourceType.IsEnumerableType() && context.DestinationType.IsCollectionType();
+
+            return isMatch;
+        }
+
+        #region Nested type: EnumerableMapper
+
+        private class EnumerableMapper<TCollection, TElement> : EnumerableMapperBase<TCollection>
+            where TCollection : ICollection<TElement>
+        {
+            public override bool IsMatch(ResolutionContext context)
+            {
+                throw new NotImplementedException();
+            }
+
+            protected override void SetElementValue(TCollection destination, object mappedValue, int index)
+            {
+                destination.Add((TElement)mappedValue);
+            }
+
+            protected override void ClearEnumerable(TCollection enumerable)
+            {
+                enumerable.Clear();
+            }
+
+            protected override TCollection CreateDestinationObjectBase(Type destElementType, int sourceLength)
+            {
+                Object collection;
+                
+                if (typeof(TCollection).IsInterface)
+                {
+                    collection = new List<TElement>();
+                }
+                else
+                {
+                    collection = ObjectCreator.CreateDefaultValue(typeof(TCollection));
+                }
+
+                return (TCollection)collection;
+            }
+        }
+
+        #endregion
+    }
 }
\ No newline at end of file
diff --git a/src/AutoMapper/Mappers/DictionaryMapper.cs b/src/AutoMapper/Mappers/DictionaryMapper.cs
index d2faee29..f3a8e6fe 100644
--- a/src/AutoMapper/Mappers/DictionaryMapper.cs
+++ b/src/AutoMapper/Mappers/DictionaryMapper.cs
@@ -1,65 +1,66 @@
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-
-namespace AutoMapper.Mappers
-{
-	// So IEnumerable<T> inherits IEnumerable
-	// but IDictionary<TKey, TValue> DOES NOT inherit IDictionary
-	// Fiddlesticks.
-	public class DictionaryMapper : IObjectMapper
-	{
-		private static readonly Type KvpType = typeof(KeyValuePair<,>);
-
-		public bool IsMatch(ResolutionContext context)
-		{
-			return (context.SourceType.IsDictionaryType() && context.DestinationType.IsDictionaryType());
-		}
-
-		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-		{
-            if (context.IsSourceValueNull && mapper.ShouldMapSourceCollectionAsNull(context))
-                return null;
-
-			var sourceEnumerableValue = (IEnumerable)context.SourceValue ?? new object[0];
-			IEnumerable<object> keyValuePairs = sourceEnumerableValue.Cast<object>();
-
-			Type genericSourceDictType = context.SourceType.GetDictionaryType();
-			Type sourceKeyType = genericSourceDictType.GetGenericArguments()[0];
-			Type sourceValueType = genericSourceDictType.GetGenericArguments()[1];
-			Type sourceKvpType = KvpType.MakeGenericType(sourceKeyType, sourceValueType);
-			Type genericDestDictType = context.DestinationType.GetDictionaryType();
-			Type destKeyType = genericDestDictType.GetGenericArguments()[0];
-			Type destValueType = genericDestDictType.GetGenericArguments()[1];
-
-			var dictionaryEntries = keyValuePairs.OfType<DictionaryEntry>();
-			if (dictionaryEntries.Any())
-				keyValuePairs = dictionaryEntries.Select(e => Activator.CreateInstance(sourceKvpType, e.Key, e.Value));
-
-			object destDictionary = ObjectCreator.CreateDictionary(context.DestinationType, destKeyType, destValueType);
-			int count = 0;
-
-			foreach (object keyValuePair in keyValuePairs)
-			{
-				object sourceKey = sourceKvpType.GetProperty("Key").GetValue(keyValuePair, new object[0]);
-				object sourceValue = sourceKvpType.GetProperty("Value").GetValue(keyValuePair, new object[0]);
-
-				TypeMap keyTypeMap = mapper.ConfigurationProvider.FindTypeMapFor(sourceKey, null, sourceKeyType, destKeyType);
-				TypeMap valueTypeMap = mapper.ConfigurationProvider.FindTypeMapFor(sourceValue, null, sourceValueType, destValueType);
-
-				ResolutionContext keyContext = context.CreateElementContext(keyTypeMap, sourceKey, sourceKeyType, destKeyType, count);
-				ResolutionContext valueContext = context.CreateElementContext(valueTypeMap, sourceValue, sourceValueType, destValueType, count);
-
-				object destKey = mapper.Map(keyContext);
-				object destValue = mapper.Map(valueContext);
-
-				genericDestDictType.GetMethod("Add").Invoke(destDictionary, new[] { destKey, destValue });
-
-				count++;
-			}
-
-			return destDictionary;
-		}
-	}
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using AutoMapper.Internal;
+
+namespace AutoMapper.Mappers
+{
+	// So IEnumerable<T> inherits IEnumerable
+	// but IDictionary<TKey, TValue> DOES NOT inherit IDictionary
+	// Fiddlesticks.
+	public class DictionaryMapper : IObjectMapper
+	{
+		private static readonly Type KvpType = typeof(KeyValuePair<,>);
+
+		public bool IsMatch(ResolutionContext context)
+		{
+			return (context.SourceType.IsDictionaryType() && context.DestinationType.IsDictionaryType());
+		}
+
+		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+		{
+            if (context.IsSourceValueNull && mapper.ShouldMapSourceCollectionAsNull(context))
+                return null;
+
+			var sourceEnumerableValue = (IEnumerable)context.SourceValue ?? new object[0];
+			IEnumerable<object> keyValuePairs = sourceEnumerableValue.Cast<object>();
+
+			Type genericSourceDictType = context.SourceType.GetDictionaryType();
+			Type sourceKeyType = genericSourceDictType.GetGenericArguments()[0];
+			Type sourceValueType = genericSourceDictType.GetGenericArguments()[1];
+			Type sourceKvpType = KvpType.MakeGenericType(sourceKeyType, sourceValueType);
+			Type genericDestDictType = context.DestinationType.GetDictionaryType();
+			Type destKeyType = genericDestDictType.GetGenericArguments()[0];
+			Type destValueType = genericDestDictType.GetGenericArguments()[1];
+
+			var dictionaryEntries = keyValuePairs.OfType<DictionaryEntry>();
+			if (dictionaryEntries.Any())
+				keyValuePairs = dictionaryEntries.Select(e => Activator.CreateInstance(sourceKvpType, e.Key, e.Value));
+
+			object destDictionary = ObjectCreator.CreateDictionary(context.DestinationType, destKeyType, destValueType);
+			int count = 0;
+
+			foreach (object keyValuePair in keyValuePairs)
+			{
+				object sourceKey = sourceKvpType.GetProperty("Key").GetValue(keyValuePair, new object[0]);
+				object sourceValue = sourceKvpType.GetProperty("Value").GetValue(keyValuePair, new object[0]);
+
+				TypeMap keyTypeMap = mapper.ConfigurationProvider.FindTypeMapFor(sourceKey, null, sourceKeyType, destKeyType);
+				TypeMap valueTypeMap = mapper.ConfigurationProvider.FindTypeMapFor(sourceValue, null, sourceValueType, destValueType);
+
+				ResolutionContext keyContext = context.CreateElementContext(keyTypeMap, sourceKey, sourceKeyType, destKeyType, count);
+				ResolutionContext valueContext = context.CreateElementContext(valueTypeMap, sourceValue, sourceValueType, destValueType, count);
+
+				object destKey = mapper.Map(keyContext);
+				object destValue = mapper.Map(valueContext);
+
+				genericDestDictType.GetMethod("Add").Invoke(destDictionary, new[] { destKey, destValue });
+
+				count++;
+			}
+
+			return destDictionary;
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/AutoMapper/Mappers/EnumerableMapper.cs b/src/AutoMapper/Mappers/EnumerableMapper.cs
index bb78a3f0..98fdff2e 100644
--- a/src/AutoMapper/Mappers/EnumerableMapper.cs
+++ b/src/AutoMapper/Mappers/EnumerableMapper.cs
@@ -1,81 +1,82 @@
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Reflection;
-
-namespace AutoMapper.Mappers
-{
-	public class EnumerableMapper : EnumerableMapperBase<IList>
-	{
-		public override bool IsMatch(ResolutionContext context)
-		{
-			return (context.DestinationType.IsEnumerableType()) && (context.SourceType.IsEnumerableType());
-		}
-
-		protected override void SetElementValue(IList destination, object mappedValue, int index)
-		{
-			destination.Add(mappedValue);
-		}
-
-		protected override void ClearEnumerable(IList enumerable)
-		{
-			enumerable.Clear();
-		}
-
-		protected override IList CreateDestinationObjectBase(Type destElementType, int sourceLength)
-		{
-			return ObjectCreator.CreateList(destElementType);
-		}
-	}
-
-	public class EnumerableToDictionaryMapper : IObjectMapper
-	{
-		private static readonly Type KvpType = typeof(KeyValuePair<,>);
-
-		public bool IsMatch(ResolutionContext context)
-		{
-			return (context.DestinationType.IsDictionaryType()) 
-				&& (context.SourceType.IsEnumerableType())
-				&& (!context.SourceType.IsDictionaryType());
-		}
-
-		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-		{
-			var sourceEnumerableValue = (IEnumerable)context.SourceValue ?? new object[0];
-			IEnumerable<object> enumerableValue = sourceEnumerableValue.Cast<object>();
-
-			Type sourceElementType = TypeHelper.GetElementType(context.SourceType, sourceEnumerableValue);
-			Type genericDestDictType = context.DestinationType.GetDictionaryType();
-			Type destKeyType = genericDestDictType.GetGenericArguments()[0];
-			Type destValueType = genericDestDictType.GetGenericArguments()[1];
-			Type destKvpType = KvpType.MakeGenericType(destKeyType, destValueType);
-
-			object destDictionary = ObjectCreator.CreateDictionary(context.DestinationType, destKeyType, destValueType);
-			int count = 0;
-
-			foreach (object item in enumerableValue)
-			{
-				var typeMap = mapper.ConfigurationProvider.FindTypeMapFor(item, null, sourceElementType, destKvpType);
-
-				Type targetSourceType = typeMap != null ? typeMap.SourceType : sourceElementType;
-				Type targetDestinationType = typeMap != null ? typeMap.DestinationType : destKvpType;
-
-				var newContext = context.CreateElementContext(typeMap, item, targetSourceType, targetDestinationType, count);
-
-				object mappedValue = mapper.Map(newContext);
-				var keyProperty = mappedValue.GetType().GetProperty("Key");
-				object destKey = keyProperty.GetValue(mappedValue, null);
-				
-				var valueProperty = mappedValue.GetType().GetProperty("Value");
-				object destValue = valueProperty.GetValue(mappedValue, null);
-
-				genericDestDictType.GetMethod("Add").Invoke(destDictionary, new[] {destKey, destValue});
-
-				count++;
-			}
-
-			return destDictionary;
-		}
-	}
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using AutoMapper.Internal;
+
+namespace AutoMapper.Mappers
+{
+	public class EnumerableMapper : EnumerableMapperBase<IList>
+	{
+		public override bool IsMatch(ResolutionContext context)
+		{
+			return (context.DestinationType.IsEnumerableType()) && (context.SourceType.IsEnumerableType());
+		}
+
+		protected override void SetElementValue(IList destination, object mappedValue, int index)
+		{
+			destination.Add(mappedValue);
+		}
+
+		protected override void ClearEnumerable(IList enumerable)
+		{
+			enumerable.Clear();
+		}
+
+		protected override IList CreateDestinationObjectBase(Type destElementType, int sourceLength)
+		{
+			return ObjectCreator.CreateList(destElementType);
+		}
+	}
+
+	public class EnumerableToDictionaryMapper : IObjectMapper
+	{
+		private static readonly Type KvpType = typeof(KeyValuePair<,>);
+
+		public bool IsMatch(ResolutionContext context)
+		{
+			return (context.DestinationType.IsDictionaryType()) 
+				&& (context.SourceType.IsEnumerableType())
+				&& (!context.SourceType.IsDictionaryType());
+		}
+
+		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+		{
+			var sourceEnumerableValue = (IEnumerable)context.SourceValue ?? new object[0];
+			IEnumerable<object> enumerableValue = sourceEnumerableValue.Cast<object>();
+
+			Type sourceElementType = TypeHelper.GetElementType(context.SourceType, sourceEnumerableValue);
+			Type genericDestDictType = context.DestinationType.GetDictionaryType();
+			Type destKeyType = genericDestDictType.GetGenericArguments()[0];
+			Type destValueType = genericDestDictType.GetGenericArguments()[1];
+			Type destKvpType = KvpType.MakeGenericType(destKeyType, destValueType);
+
+			object destDictionary = ObjectCreator.CreateDictionary(context.DestinationType, destKeyType, destValueType);
+			int count = 0;
+
+			foreach (object item in enumerableValue)
+			{
+				var typeMap = mapper.ConfigurationProvider.FindTypeMapFor(item, null, sourceElementType, destKvpType);
+
+				Type targetSourceType = typeMap != null ? typeMap.SourceType : sourceElementType;
+				Type targetDestinationType = typeMap != null ? typeMap.DestinationType : destKvpType;
+
+				var newContext = context.CreateElementContext(typeMap, item, targetSourceType, targetDestinationType, count);
+
+				object mappedValue = mapper.Map(newContext);
+				var keyProperty = mappedValue.GetType().GetProperty("Key");
+				object destKey = keyProperty.GetValue(mappedValue, null);
+				
+				var valueProperty = mappedValue.GetType().GetProperty("Value");
+				object destValue = valueProperty.GetValue(mappedValue, null);
+
+				genericDestDictType.GetMethod("Add").Invoke(destDictionary, new[] {destKey, destValue});
+
+				count++;
+			}
+
+			return destDictionary;
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/AutoMapper/Mappers/HashSetMapper.cs b/src/AutoMapper/Mappers/HashSetMapper.cs
index 9ea777bb..370436f3 100644
--- a/src/AutoMapper/Mappers/HashSetMapper.cs
+++ b/src/AutoMapper/Mappers/HashSetMapper.cs
@@ -1,5 +1,6 @@
 ï»¿using System.Linq;
 using System.Reflection;
+using AutoMapper.Internal;
 
 namespace AutoMapper.Mappers
 {
diff --git a/src/AutoMapper/Mappers/NullableMapper.cs b/src/AutoMapper/Mappers/NullableMapper.cs
index ccdfe70b..318a44a9 100644
--- a/src/AutoMapper/Mappers/NullableMapper.cs
+++ b/src/AutoMapper/Mappers/NullableMapper.cs
@@ -1,28 +1,30 @@
-namespace AutoMapper.Mappers
-{
-	public class NullableMapper : IObjectMapper
-	{
-		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-		{
-			return context.SourceValue;
-		}
-
-		public bool IsMatch(ResolutionContext context)
-		{
-			return context.DestinationType.IsNullableType();
-		}
-	}
-
-	public class NullableSourceMapper : IObjectMapper
-	{
-		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-		{
-			return context.SourceValue ?? mapper.CreateObject(context);
-		}
-
-		public bool IsMatch(ResolutionContext context)
-		{
-			return context.SourceType.IsNullableType() && ! context.DestinationType.IsNullableType();
-		}
-	}
+using AutoMapper.Internal;
+
+namespace AutoMapper.Mappers
+{
+	public class NullableMapper : IObjectMapper
+	{
+		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+		{
+			return context.SourceValue;
+		}
+
+		public bool IsMatch(ResolutionContext context)
+		{
+			return context.DestinationType.IsNullableType();
+		}
+	}
+
+	public class NullableSourceMapper : IObjectMapper
+	{
+		public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+		{
+			return context.SourceValue ?? mapper.CreateObject(context);
+		}
+
+		public bool IsMatch(ResolutionContext context)
+		{
+			return context.SourceType.IsNullableType() && ! context.DestinationType.IsNullableType();
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/AutoMapper/Mappers/ReadOnlyCollectionMapper.cs b/src/AutoMapper/Mappers/ReadOnlyCollectionMapper.cs
index 335fb584..081e0572 100644
--- a/src/AutoMapper/Mappers/ReadOnlyCollectionMapper.cs
+++ b/src/AutoMapper/Mappers/ReadOnlyCollectionMapper.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
+using AutoMapper.Internal;
 
 namespace AutoMapper.Mappers
 {
diff --git a/src/AutoMapper/Mappers/TypeHelper.cs b/src/AutoMapper/Mappers/TypeHelper.cs
index 88882d63..a5c49564 100644
--- a/src/AutoMapper/Mappers/TypeHelper.cs
+++ b/src/AutoMapper/Mappers/TypeHelper.cs
@@ -1,75 +1,76 @@
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-
-namespace AutoMapper.Mappers
-{
-    public static class TypeHelper
-	{
-		public static Type GetElementType(Type enumerableType)
-		{
-			return GetElementType(enumerableType, null);
-		}
-
-		public static Type GetElementType(Type enumerableType, IEnumerable enumerable)
-		{
-			if (enumerableType.HasElementType)
-			{
-				return enumerableType.GetElementType();
-			}
-
-			if (enumerableType.IsGenericType && enumerableType.GetGenericTypeDefinition().Equals(typeof(IEnumerable<>)))
-			{
-				return enumerableType.GetGenericArguments()[0];
-			}
-
-            Type ienumerableType = GetIEnumerableType(enumerableType);
-            if (ienumerableType != null)
-			{
-				return ienumerableType.GetGenericArguments()[0];
-			}
-
-			if (typeof(IEnumerable).IsAssignableFrom(enumerableType))
-			{
-				if (enumerable != null)
-				{
-					var first = enumerable.Cast<object>().FirstOrDefault();
-					if (first != null)
-						return first.GetType();
-				}
-				return typeof(object);
-			}
-
-			throw new ArgumentException(String.Format("Unable to find the element type for type '{0}'.", enumerableType), "enumerableType");
-		}
-
-		public static Type GetEnumerationType(Type enumType)
-		{
-			if (enumType.IsNullableType())
-			{
-				enumType = enumType.GetGenericArguments()[0];
-			}
-
-			if (!enumType.IsEnum)
-				return null;
-
-			return enumType;
-		}
-
-        private static Type GetIEnumerableType(Type enumerableType)
-        {
-            try
-            {
-                return enumerableType.GetInterfaces().FirstOrDefault(t => t.Name == "IEnumerable`1");
-            }
-            catch (System.Reflection.AmbiguousMatchException)
-            {
-                if (enumerableType.BaseType != typeof(object))
-                    return GetIEnumerableType(enumerableType.BaseType);
-
-                return null;
-            }
-        }
-	}
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using AutoMapper.Internal;
+
+namespace AutoMapper.Mappers
+{
+    public static class TypeHelper
+	{
+		public static Type GetElementType(Type enumerableType)
+		{
+			return GetElementType(enumerableType, null);
+		}
+
+		public static Type GetElementType(Type enumerableType, IEnumerable enumerable)
+		{
+			if (enumerableType.HasElementType)
+			{
+				return enumerableType.GetElementType();
+			}
+
+			if (enumerableType.IsGenericType && enumerableType.GetGenericTypeDefinition().Equals(typeof(IEnumerable<>)))
+			{
+				return enumerableType.GetGenericArguments()[0];
+			}
+
+            Type ienumerableType = GetIEnumerableType(enumerableType);
+            if (ienumerableType != null)
+			{
+				return ienumerableType.GetGenericArguments()[0];
+			}
+
+			if (typeof(IEnumerable).IsAssignableFrom(enumerableType))
+			{
+				if (enumerable != null)
+				{
+					var first = enumerable.Cast<object>().FirstOrDefault();
+					if (first != null)
+						return first.GetType();
+				}
+				return typeof(object);
+			}
+
+			throw new ArgumentException(String.Format("Unable to find the element type for type '{0}'.", enumerableType), "enumerableType");
+		}
+
+		public static Type GetEnumerationType(Type enumType)
+		{
+			if (enumType.IsNullableType())
+			{
+				enumType = enumType.GetGenericArguments()[0];
+			}
+
+			if (!enumType.IsEnum)
+				return null;
+
+			return enumType;
+		}
+
+        private static Type GetIEnumerableType(Type enumerableType)
+        {
+            try
+            {
+                return enumerableType.GetInterfaces().FirstOrDefault(t => t.Name == "IEnumerable`1");
+            }
+            catch (System.Reflection.AmbiguousMatchException)
+            {
+                if (enumerableType.BaseType != typeof(object))
+                    return GetIEnumerableType(enumerableType.BaseType);
+
+                return null;
+            }
+        }
+	}
 }
\ No newline at end of file
diff --git a/src/AutoMapper/TypeInfo.cs b/src/AutoMapper/TypeInfo.cs
index b1f8dae5..e90892a8 100644
--- a/src/AutoMapper/TypeInfo.cs
+++ b/src/AutoMapper/TypeInfo.cs
@@ -4,6 +4,7 @@
 using System.Linq;
 using System.Reflection;
 using System.Runtime.CompilerServices;
+using AutoMapper.Internal;
 
 namespace AutoMapper
 {
@@ -87,7 +88,7 @@ private MemberInfo[] BuildPublicAccessors(IEnumerable<MemberInfo> allMembers)
                 .GroupBy(x => x.Name) // group properties of the same name together
                 .Select(x =>
                     x.Any(y => y.CanWrite && y.CanRead) ? // favor the first property that can both read & write - otherwise pick the first one
-						x.Where(y => y.CanWrite && y.CanRead).First() :
+						x.First(y => y.CanWrite && y.CanRead) :
                         x.First())
 				.Where(pi => pi.CanWrite || pi.PropertyType.IsListOrDictionaryType())
                 .OfType<MemberInfo>() // cast back to MemberInfo so we can add back FieldInfo objects
diff --git a/src/AutoMapper/ValueFormatter.cs b/src/AutoMapper/ValueFormatter.cs
index 5d388b65..f3346bea 100644
--- a/src/AutoMapper/ValueFormatter.cs
+++ b/src/AutoMapper/ValueFormatter.cs
@@ -1,18 +1,20 @@
-namespace AutoMapper
-{
-	public abstract class ValueFormatter<T> : IValueFormatter
-	{
-		public string FormatValue(ResolutionContext context)
-		{
-			if (context.SourceValue == null)
-				return null;
-
-			if (!(context.SourceValue is T))
-				return context.SourceValue.ToNullSafeString();
-
-			return FormatValueCore((T)context.SourceValue);
-		}
-
-		protected abstract string FormatValueCore(T value);
-	}
+using AutoMapper.Internal;
+
+namespace AutoMapper
+{
+	public abstract class ValueFormatter<T> : IValueFormatter
+	{
+		public string FormatValue(ResolutionContext context)
+		{
+			if (context.SourceValue == null)
+				return null;
+
+			if (!(context.SourceValue is T))
+				return context.SourceValue.ToNullSafeString();
+
+			return FormatValueCore((T)context.SourceValue);
+		}
+
+		protected abstract string FormatValueCore(T value);
+	}
 }
\ No newline at end of file
diff --git a/src/UnitTests/Internal/PrimitiveExtensionsTester.cs b/src/UnitTests/Internal/PrimitiveExtensionsTester.cs
index f947b605..a8c36f87 100644
--- a/src/UnitTests/Internal/PrimitiveExtensionsTester.cs
+++ b/src/UnitTests/Internal/PrimitiveExtensionsTester.cs
@@ -1,34 +1,35 @@
-using System.Collections;
-using System.Collections.Generic;
-using Xunit;
-using Should;
-
-namespace AutoMapper.UnitTests
-{
-	public class PrimitiveExtensionsTester
-	{
-		[Fact]
-		public void Should_not_flag_only_enumerable_type_as_writeable_collection()
-		{
-			typeof(string).IsListOrDictionaryType().ShouldBeFalse();
-		}
-
-		[Fact]
-		public void Should_flag_list_as_writable_collection()
-		{
-			typeof(int[]).IsListOrDictionaryType().ShouldBeTrue();
-		}
-
-		[Fact]
-		public void Should_flag_generic_list_as_writeable_collection()
-		{
-			typeof(List<int>).IsListOrDictionaryType().ShouldBeTrue();
-		}
-
-		[Fact]
-		public void Should_flag_dictionary_as_writeable_collection()
-		{
-			typeof(Dictionary<string, int>).IsListOrDictionaryType().ShouldBeTrue();
-		}
-	}
+using System.Collections;
+using System.Collections.Generic;
+using AutoMapper.Internal;
+using Xunit;
+using Should;
+
+namespace AutoMapper.UnitTests
+{
+	public class PrimitiveExtensionsTester
+	{
+		[Fact]
+		public void Should_not_flag_only_enumerable_type_as_writeable_collection()
+		{
+			typeof(string).IsListOrDictionaryType().ShouldBeFalse();
+		}
+
+		[Fact]
+		public void Should_flag_list_as_writable_collection()
+		{
+			typeof(int[]).IsListOrDictionaryType().ShouldBeTrue();
+		}
+
+		[Fact]
+		public void Should_flag_generic_list_as_writeable_collection()
+		{
+			typeof(List<int>).IsListOrDictionaryType().ShouldBeTrue();
+		}
+
+		[Fact]
+		public void Should_flag_dictionary_as_writeable_collection()
+		{
+			typeof(Dictionary<string, int>).IsListOrDictionaryType().ShouldBeTrue();
+		}
+	}
 }
\ No newline at end of file
