diff --git a/src/AutoMapper/TypeDetails.cs b/src/AutoMapper/TypeDetails.cs
index e3c57256..a730e50c 100644
--- a/src/AutoMapper/TypeDetails.cs
+++ b/src/AutoMapper/TypeDetails.cs
@@ -67,30 +67,27 @@ public TypeDetails(Type type, Func<PropertyInfo, bool> shouldMapProperty, Func<F
 
         public IEnumerable<MethodInfo> PublicNoArgExtensionMethods { get; }
 
-        private IList<MethodInfo> BuildPublicNoArgExtensionMethods(IEnumerable<MethodInfo> sourceExtensionMethodSearch)
+        private IEnumerable<MethodInfo> BuildPublicNoArgExtensionMethods(IEnumerable<MethodInfo> sourceExtensionMethodSearch)
         {
-            var sourceExtensionMethodSearchArray = sourceExtensionMethodSearch.ToArray();
+            var explicitExtensionMethods = sourceExtensionMethodSearch.Where(method => method.GetParameters()[0].ParameterType == Type);
 
-            var explicitExtensionMethods = sourceExtensionMethodSearchArray
-                .Where(method => method.GetParameters()[0].ParameterType == Type)
-                .ToList();
+            var genericInterfaces = Type.GetTypeInfo().ImplementedInterfaces.Where(t => t.IsGenericType());
 
-            var genericInterfaces = Type.GetTypeInfo().ImplementedInterfaces.Where(t => t.IsGenericType()).ToList();
-
-            if (Type.IsInterface() && Type.IsGenericType())
-                genericInterfaces.Add(Type);
-
-            explicitExtensionMethods.AddRange(
-                from genericMethod in sourceExtensionMethodSearchArray
+            if(Type.IsInterface() && Type.IsGenericType())
+            {
+                genericInterfaces = genericInterfaces.Union(new[] { Type });
+            }
+            return explicitExtensionMethods.Concat
+            (
+                from genericMethod in sourceExtensionMethodSearch
                 where genericMethod.IsGenericMethodDefinition
                 from genericInterface in genericInterfaces
                 let genericInterfaceArguments = genericInterface.GetTypeInfo().GenericTypeArguments
                 where genericMethod.GetGenericArguments().Length == genericInterfaceArguments.Length
                 let methodMatch = genericMethod.MakeGenericMethod(genericInterfaceArguments)
                 where methodMatch.GetParameters()[0].ParameterType.GetTypeInfo().IsAssignableFrom(genericInterface.GetTypeInfo())
-                select methodMatch);
-
-            return explicitExtensionMethods;
+                select methodMatch
+            ).ToArray();
         }
 
         private static MemberInfo[] BuildPublicReadAccessors(IEnumerable<MemberInfo> allMembers)
diff --git a/src/UnitTests/Bug/DuplicateExtensionMethods.cs b/src/UnitTests/Bug/DuplicateExtensionMethods.cs
new file mode 100644
index 00000000..3485c258
--- /dev/null
+++ b/src/UnitTests/Bug/DuplicateExtensionMethods.cs
@@ -0,0 +1,42 @@
+ï»¿using Xunit;
+using Should;
+using System;
+using System.Collections.Generic;
+
+namespace AutoMapper.UnitTests.Bug
+{
+    public class DuplicateExtensionMethods : AutoMapperSpecBase
+    {
+        public class Outlay
+        {
+            public int Amount { get; set; }
+        }
+
+        public enum AccountKind { None }
+
+        class Source
+        {
+            public int UserId { get; set; }
+            public string UserName { get; set; }
+            public string UserPhone { get; set; }
+            public string IDCard { get; set; }
+            public AccountKind Kind { get; set; }
+            public decimal UnUsedAmount { get; set; }
+            public List<Outlay> Outlay { get; set; }
+        }
+        class Destination
+        {
+            public int UserId { get; set; }
+            public string UserName { get; set; }
+            public string UserPhone { get; set; }
+            public string IDCard { get; set; }
+            public AccountKind Kind { get; set; }
+            public decimal UnUsedAmount { get; set; }
+        }
+
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
+        {
+            cfg.CreateMap<Source, Destination>();
+        });
+    }
+}
\ No newline at end of file
