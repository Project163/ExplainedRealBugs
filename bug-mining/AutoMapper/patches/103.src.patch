diff --git a/src/AutoMapper.Net4/AutoMapper.Net4.csproj b/src/AutoMapper.Net4/AutoMapper.Net4.csproj
index d43c3d8f..77e214d1 100644
--- a/src/AutoMapper.Net4/AutoMapper.Net4.csproj
+++ b/src/AutoMapper.Net4/AutoMapper.Net4.csproj
@@ -24,6 +24,7 @@
     <WarningLevel>4</WarningLevel>
     <DocumentationFile>bin\Debug\AutoMapper.XML</DocumentationFile>
     <Prefer32Bit>false</Prefer32Bit>
+    <NoWarn>1591</NoWarn>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
diff --git a/src/AutoMapper/QueryableExtensions/Extensions.cs b/src/AutoMapper/QueryableExtensions/Extensions.cs
index 9dd16a8f..b5bcdf2c 100644
--- a/src/AutoMapper/QueryableExtensions/Extensions.cs
+++ b/src/AutoMapper/QueryableExtensions/Extensions.cs
@@ -6,6 +6,9 @@ namespace AutoMapper.QueryableExtensions
     using System.Linq.Expressions;
     using Impl;
 
+    /// <summary>
+    /// Queryable extensions for AutoMapper
+    /// </summary>
     public static class Extensions
     {
         /// <summary>
@@ -45,12 +48,29 @@ public static class Extensions
             return mappingEngine.CreateMapExpression(sourceType, destinationType, parameters, membersToExpand);
         }
 
+        /// <summary>
+        /// Maps a queryable expression of a source type to a queryable expression of a destination type
+        /// </summary>
+        /// <typeparam name="TSource">Source type</typeparam>
+        /// <typeparam name="TDestination">Destination type</typeparam>
+        /// <param name="sourceQuery">Source queryable</param>
+        /// <param name="destQuery">Destination queryable</param>
+        /// <returns>Mapped destination queryable</returns>
         public static IQueryable<TDestination> Map<TSource, TDestination>(this IQueryable<TSource> sourceQuery,
             IQueryable<TDestination> destQuery)
         {
             return sourceQuery.Map(destQuery, Mapper.Engine);
         }
 
+        /// <summary>
+        /// Maps a queryable expression of a source type to a queryable expression of a destination type
+        /// </summary>
+        /// <typeparam name="TSource">Source type</typeparam>
+        /// <typeparam name="TDestination">Destination type</typeparam>
+        /// <param name="sourceQuery">Source queryable</param>
+        /// <param name="destQuery">Destination queryable</param>
+        /// <param name="mappingEngine">Mapping engine instance</param>
+        /// <returns>Mapped destination queryable</returns>
         public static IQueryable<TDestination> Map<TSource, TDestination>(this IQueryable<TSource> sourceQuery,
             IQueryable<TDestination> destQuery, IMappingEngine mappingEngine)
         {
@@ -75,6 +95,7 @@ public static IQueryDataSourceInjection<TSource> UseAsDataSource<TSource>(this I
         /// <typeparam name="TSource">Source type</typeparam>
         /// <param name="source">Queryable source</param>
         /// <returns>Expression to project into</returns>
+        [Obsolete("Use ProjectTo instead")]
         public static IProjectionExpression Project<TSource>(
             this IQueryable<TSource> source)
         {
@@ -90,6 +111,7 @@ public static IQueryDataSourceInjection<TSource> UseAsDataSource<TSource>(this I
         /// <param name="source">Queryable source</param>
         /// <param name="mappingEngine">Mapping engine instance</param>
         /// <returns>Expression to project into</returns>
+        [Obsolete("Use ProjectTo instead")]
         public static IProjectionExpression Project<TSource>(
             this IQueryable<TSource> source, IMappingEngine mappingEngine)
         {
@@ -97,16 +119,23 @@ public static IQueryDataSourceInjection<TSource> UseAsDataSource<TSource>(this I
         }
 
         /// <summary>
-        /// Extention method to project from a queryable using the static <see cref="Mapper.Engine"/> property.
+        /// Extention method to project from a queryable using the provided mapping engine
         /// </summary>
         /// <remarks>Projections are only calculated once and cached</remarks>
         /// <typeparam name="TDestination">Destination type</typeparam>
         /// <param name="source">Queryable source</param>
+        /// <param name="mappingEngine">Mapping engine instance</param>
+        /// <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
+        /// <param name="membersToExpand">Explicit members to expand</param>
         /// <returns>Expression to project into</returns>
         public static IQueryable<TDestination> ProjectTo<TDestination>(
-            this IQueryable source)
+            this IQueryable source,
+            object parameters,
+            IMappingEngine mappingEngine,
+            params Expression<Func<TDestination, object>>[] membersToExpand
+            )
         {
-            return source.ProjectTo<TDestination>(Mapper.Engine);
+            return new ProjectionExpression(source, mappingEngine).To(parameters, membersToExpand);
         }
 
         /// <summary>
@@ -115,13 +144,66 @@ public static IQueryDataSourceInjection<TSource> UseAsDataSource<TSource>(this I
         /// <remarks>Projections are only calculated once and cached</remarks>
         /// <typeparam name="TDestination">Destination type</typeparam>
         /// <param name="source">Queryable source</param>
-        /// <param name="mappingEngine">Mapping engine instance</param>
+        /// <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
+        /// <param name="membersToExpand">Explicit members to expand</param>
+        /// <returns>Expression to project into</returns>
+        public static IQueryable<TDestination> ProjectTo<TDestination>(
+            this IQueryable source,
+            object parameters,
+            params Expression<Func<TDestination, object>>[] membersToExpand
+            )
+        {
+            return source.ProjectTo(parameters, Mapper.Engine, membersToExpand);
+        }
+
+        /// <summary>
+        /// Extention method to project from a queryable using the provided mapping engine
+        /// </summary>
+        /// <remarks>Projections are only calculated once and cached</remarks>
+        /// <typeparam name="TDestination">Destination type</typeparam>
+        /// <param name="source">Queryable source</param>
+        /// <param name="membersToExpand">Explicit members to expand</param>
         /// <returns>Expression to project into</returns>
         public static IQueryable<TDestination> ProjectTo<TDestination>(
-            this IQueryable source, IMappingEngine mappingEngine)
+            this IQueryable source,
+            params Expression<Func<TDestination, object>>[] membersToExpand
+            )
+        {
+            return source.ProjectTo(null, membersToExpand);
+        }
+
+        /// <summary>
+        /// Projects the source type to the destination type given the mapping configuration
+        /// </summary>
+        /// <typeparam name="TDestination">Destination type to map to</typeparam>
+        /// <param name="source">Queryable source</param>
+        /// <param name="mappingEngine">Mapping engine instance</param>
+        /// <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
+        /// <param name="membersToExpand">Explicit members to expand</param>
+        /// <returns>Queryable result, use queryable extension methods to project and execute result</returns>
+        public static IQueryable<TDestination> ProjectTo<TDestination>(this IQueryable source,
+            IDictionary<string, object> parameters,
+            IMappingEngine mappingEngine,
+            params string[] membersToExpand
+            )
         {
-            return new ProjectionExpression(source, mappingEngine).To<TDestination>();
+            return new ProjectionExpression(source, mappingEngine).To<TDestination>(parameters, membersToExpand);
         }
 
+        /// <summary>
+        /// Projects the source type to the destination type given the mapping configuration
+        /// </summary>
+        /// <typeparam name="TDestination">Destination type to map to</typeparam>
+        /// <param name="source">Queryable source</param>
+        /// <param name="parameters">Optional parameter object for parameterized mapping expressions</param>
+        /// <param name="membersToExpand">Explicit members to expand</param>
+        /// <returns>Queryable result, use queryable extension methods to project and execute result</returns>
+        public static IQueryable<TDestination> ProjectTo<TDestination>(this IQueryable source,
+            IDictionary<string, object> parameters,
+            params string[] membersToExpand
+            )
+        {
+            return source.ProjectTo<TDestination>(parameters, Mapper.Engine, membersToExpand);
+        }
     }
 }
diff --git a/src/UnitTests/Bug/CreateMapExpressionWithIgnoredPropertyBug.cs b/src/UnitTests/Bug/CreateMapExpressionWithIgnoredPropertyBug.cs
index 7d1ebca8..fedf4b81 100644
--- a/src/UnitTests/Bug/CreateMapExpressionWithIgnoredPropertyBug.cs
+++ b/src/UnitTests/Bug/CreateMapExpressionWithIgnoredPropertyBug.cs
@@ -18,7 +18,7 @@ public void ShouldNotMapPropertyWhenItIsIgnored()
 
             IQueryable<Person> collection = (new List<Person> { new Person { Name = "Person1" } }).AsQueryable();
 
-            List<Person> result = collection.Project().To<Person>().ToList();
+            List<Person> result = collection.ProjectTo<Person>().ToList();
 
             result.ForEach(x => x.Name.ShouldBeNull());
         }
diff --git a/src/UnitTests/Bug/NestedMappingProjectionsExplicitExpanding.cs b/src/UnitTests/Bug/NestedMappingProjectionsExplicitExpanding.cs
index 6fb0c6b6..16416b44 100644
--- a/src/UnitTests/Bug/NestedMappingProjectionsExplicitExpanding.cs
+++ b/src/UnitTests/Bug/NestedMappingProjectionsExplicitExpanding.cs
@@ -51,7 +51,7 @@ protected override void Establish_context()
         protected override void Because_of()
         {
             var fuEntity = new FuEntity { Man = new ManEntity { Chu = new ChuEntity { Prop = _propValue } } };
-            _destination = new[] { fuEntity }.AsQueryable().Project().To<Fu>(null, m=>m.Man, m=>m.Man.Chu).First();
+            _destination = new[] { fuEntity }.AsQueryable().ProjectTo<Fu>(m=>m.Man, m=>m.Man.Chu).First();
         }
 
         [Fact]
diff --git a/src/UnitTests/Bug/ProjectCollectionsBug.cs b/src/UnitTests/Bug/ProjectCollectionsBug.cs
index 1c4a176b..b1576a95 100644
--- a/src/UnitTests/Bug/ProjectCollectionsBug.cs
+++ b/src/UnitTests/Bug/ProjectCollectionsBug.cs
@@ -60,7 +60,7 @@ public void Should_not_throw_exception()
                 var belist = new List<BEntity>();
                 belist.Add(be);
                 IQueryable<BEntity> bei = belist.AsQueryable();
-                typeof(Exception).ShouldNotBeThrownBy(() => bei.Project().To<B>());
+                typeof(Exception).ShouldNotBeThrownBy(() => bei.ProjectTo<B>());
             }
         }
     }
diff --git a/src/UnitTests/ExpressionBridge.cs b/src/UnitTests/ExpressionBridge.cs
index 1745a53d..c7012b11 100644
--- a/src/UnitTests/ExpressionBridge.cs
+++ b/src/UnitTests/ExpressionBridge.cs
@@ -193,14 +193,14 @@ public void Should_use_extension_methods()
                 
                 var queryable = _products.AsQueryable();
 
-                var simpleProducts = queryable.Project().To<SimpleProductDto>().ToList();
+                var simpleProducts = queryable.ProjectTo<SimpleProductDto>().ToList();
 
                 simpleProducts.Count.ShouldEqual(1);
                 simpleProducts[0].Name.ShouldEqual("Foo");
                 simpleProducts[0].ProductSubcategoryName.ShouldEqual("Bar");
                 simpleProducts[0].CategoryName.ShouldEqual("Baz");
 
-                var extendedProducts = queryable.Project().To<ExtendedProductDto>().ToList();
+                var extendedProducts = queryable.ProjectTo<ExtendedProductDto>().ToList();
 
                 extendedProducts.Count.ShouldEqual(1);
                 extendedProducts[0].Name.ShouldEqual("Foo");
@@ -209,7 +209,7 @@ public void Should_use_extension_methods()
                 extendedProducts[0].BOM.Count.ShouldEqual(1);
                 extendedProducts[0].BOM[0].BillOfMaterialsID.ShouldEqual(5);
 
-                var complexProducts = queryable.Project().To<ComplexProductDto>().ToList();
+                var complexProducts = queryable.ProjectTo<ComplexProductDto>().ToList();
 
                 complexProducts.Count.ShouldEqual(1);
                 complexProducts[0].Name.ShouldEqual("Foo");
@@ -225,7 +225,7 @@ public void List_of_abstract_should_be_mapped()
 
                 var queryable = _products.AsQueryable();
 
-                var abstractProducts = queryable.Project().To<AbstractProductDto>().ToList();
+                var abstractProducts = queryable.ProjectTo<AbstractProductDto>().ToList();
 
                 abstractProducts[0].Types.Count.ShouldEqual(3);
                 abstractProducts[0].Types[0].GetType().ShouldEqual(typeof (ProdTypeA));
@@ -301,7 +301,7 @@ protected override void Because_of()
                 [Fact]
                 public void Should_not_throw_exception()
                 {
-                    typeof(StackOverflowException).ShouldNotBeThrownBy(() => _bei.Project().To<B>());
+                    typeof(StackOverflowException).ShouldNotBeThrownBy(() => _bei.ProjectTo<B>());
                 }
             }
         }
diff --git a/src/UnitTests/Projection/ConstructorTests.cs b/src/UnitTests/Projection/ConstructorTests.cs
index bbf805ba..2b789180 100644
--- a/src/UnitTests/Projection/ConstructorTests.cs
+++ b/src/UnitTests/Projection/ConstructorTests.cs
@@ -46,7 +46,7 @@ protected override void Because_of()
                 }
             }.AsQueryable();
 
-            _dest = values.Project().To<Dest>().ToArray();
+            _dest = values.ProjectTo<Dest>().ToArray();
         }
 
         [Fact]
diff --git a/src/UnitTests/Projection/ExplicitExpansion.cs b/src/UnitTests/Projection/ExplicitExpansion.cs
index a6a712ea..c0529473 100644
--- a/src/UnitTests/Projection/ExplicitExpansion.cs
+++ b/src/UnitTests/Projection/ExplicitExpansion.cs
@@ -53,7 +53,7 @@ protected override void Because_of()
                 }
             };
 
-            _dests = sourceList.AsQueryable().Project().To<Dest>(membersToExpand: d => d.Child2).ToArray();
+            _dests = sourceList.AsQueryable().ProjectTo<Dest>(d => d.Child2).ToArray();
         }
 
         [Fact]
diff --git a/src/UnitTests/Projection/ExplicitValues.cs b/src/UnitTests/Projection/ExplicitValues.cs
index 5f9b4e93..6ac79d5f 100644
--- a/src/UnitTests/Projection/ExplicitValues.cs
+++ b/src/UnitTests/Projection/ExplicitValues.cs
@@ -30,7 +30,7 @@ protected override void Because_of()
         {
             var source = new[] { new Source { Value = 10 } }.AsQueryable();
 
-            _dests = source.Project().To<Dest>().ToList();
+            _dests = source.ProjectTo<Dest>().ToList();
         }
 
         [Fact]
@@ -59,7 +59,7 @@ protected override void Establish_context()
             Mapper.CreateMap<Source, Dest>()
                 .ForMember(dest => dest.Value, opt => opt.UseValue(5));
 
-            new[] { new Source { Value = 10 } }.AsQueryable().Project().To<Dest>().ToList();
+            new[] { new Source { Value = 10 } }.AsQueryable().ProjectTo<Dest>().ToList();
 
             Mapper.Reset();
 
@@ -71,7 +71,7 @@ protected override void Because_of()
         {
             var source = new[] { new Source { Value = 10 } }.AsQueryable();
 
-            _dests = source.Project().To<Dest>().ToList();
+            _dests = source.ProjectTo<Dest>().ToList();
         }
 
         [Fact]
diff --git a/src/UnitTests/Projection/InheritedMaps.cs b/src/UnitTests/Projection/InheritedMaps.cs
index ada9355d..deeb6c85 100644
--- a/src/UnitTests/Projection/InheritedMaps.cs
+++ b/src/UnitTests/Projection/InheritedMaps.cs
@@ -48,7 +48,7 @@ protected override void Because_of()
                     }
                 }.AsQueryable();
 
-                _dest = sources.Project().To<Dest>().ToArray();
+                _dest = sources.ProjectTo<Dest>().ToArray();
             }
 
             [Fact]
diff --git a/src/UnitTests/Projection/NestedExpressionsMapFromTests.cs b/src/UnitTests/Projection/NestedExpressionsMapFromTests.cs
index 3afd86c9..0dcc99ca 100644
--- a/src/UnitTests/Projection/NestedExpressionsMapFromTests.cs
+++ b/src/UnitTests/Projection/NestedExpressionsMapFromTests.cs
@@ -33,7 +33,7 @@ public void Should_use_nested_expression()
                     }
                 };
 
-                var projected = items.AsQueryable().Project().To<ParentDto>().ToList();
+                var projected = items.AsQueryable().ProjectTo<ParentDto>().ToList();
 
                 projected[0].TotalSum.ShouldEqual(9);
             }
diff --git a/src/UnitTests/Projection/NullSubstitutes.cs b/src/UnitTests/Projection/NullSubstitutes.cs
index a8271f2f..22ad87ca 100644
--- a/src/UnitTests/Projection/NullSubstitutes.cs
+++ b/src/UnitTests/Projection/NullSubstitutes.cs
@@ -29,7 +29,7 @@ protected override void Because_of()
         {
             var source = new[] {new Source()}.AsQueryable();
 
-            _dests = source.Project().To<Dest>().ToList();
+            _dests = source.ProjectTo<Dest>().ToList();
         }
 
         [Fact]
@@ -66,7 +66,7 @@ protected override void Because_of()
         {
             var source = new[] {new Source()}.AsQueryable();
 
-            _dests = source.Project().To<Dest>().ToList();
+            _dests = source.ProjectTo<Dest>().ToList();
         }
 
         [Fact]
diff --git a/src/UnitTests/Projection/NullableItemsTests.cs b/src/UnitTests/Projection/NullableItemsTests.cs
index 32240def..668e0b90 100644
--- a/src/UnitTests/Projection/NullableItemsTests.cs
+++ b/src/UnitTests/Projection/NullableItemsTests.cs
@@ -28,7 +28,7 @@ public void Should_project_null_value()
                     }
                 };
 
-                var projected = items.AsQueryable().Project().To<ParentDto>().ToList();
+                var projected = items.AsQueryable().ProjectTo<ParentDto>().ToList();
 
                 projected[0].Value.ShouldEqual(5);
                 projected[0].ChildValue.ShouldBeNull();
@@ -93,9 +93,9 @@ public void Should_not_fail()
                     }
                 };
 
-                var projected = items.AsQueryable().Project().To<ParentDto>().ToList();
+                var projected = items.AsQueryable().ProjectTo<ParentDto>().ToList();
 
-                typeof(NullReferenceException).ShouldNotBeThrownBy(() => items.AsQueryable().Project().To<ParentDto>().ToList());
+                typeof(NullReferenceException).ShouldNotBeThrownBy(() => items.AsQueryable().ProjectTo<ParentDto>().ToList());
                 Assert.NotNull(projected[0].Date);
             }
         }
diff --git a/src/UnitTests/Projection/ParameterizedQueriesTests.cs b/src/UnitTests/Projection/ParameterizedQueriesTests.cs
index 54ab580a..ed72f06f 100644
--- a/src/UnitTests/Projection/ParameterizedQueriesTests.cs
+++ b/src/UnitTests/Projection/ParameterizedQueriesTests.cs
@@ -38,7 +38,7 @@ protected override void Because_of()
                 new Source()
             }.AsQueryable();
 
-            _dests = _sources.Project().To<Dest>(new { value = 10 }).ToArray();
+            _dests = _sources.ProjectTo<Dest>(new { value = 10 }).ToArray();
         }
 
         [Fact]
@@ -50,7 +50,7 @@ public void Should_substitute_parameter_value()
         [Fact]
         public void Should_not_cache_parameter_value()
         {
-            var newDests = _sources.Project().To<Dest>(new {value = 15}).ToArray();
+            var newDests = _sources.ProjectTo<Dest>(new {value = 15}).ToArray();
 
             newDests[0].Value.ShouldEqual(20);
         }
@@ -86,7 +86,7 @@ protected override void Because_of()
                 new Source()
             }.AsQueryable();
 
-            _dests = _sources.Project().To<Dest>(new Dictionary<string, object>{{"value", 10}}).ToArray();
+            _dests = _sources.ProjectTo<Dest>(new Dictionary<string, object>{{"value", 10}}).ToArray();
         }
 
         [Fact]
@@ -98,7 +98,7 @@ public void Should_substitute_parameter_value()
         [Fact]
         public void Should_not_cache_parameter_value()
         {
-            var newDests = _sources.Project().To<Dest>(new Dictionary<string, object> { { "value", 15 } }).ToArray();
+            var newDests = _sources.ProjectTo<Dest>(new Dictionary<string, object> { { "value", 15 } }).ToArray();
 
             newDests[0].Value.ShouldEqual(20);
         }
@@ -151,7 +151,7 @@ public void Should_only_replace_outer_parameters()
         {
             var db = new DB();
 
-            var user = db.Users.Project().To<UserViewModel>(new { db }).FirstOrDefault(a => a.Id == 2);
+            var user = db.Users.ProjectTo<UserViewModel>(new { db }).FirstOrDefault(a => a.Id == 2);
 
             user.position.ShouldEqual(1);
         }
diff --git a/src/UnitTests/Projection/PrimitiveArraysTest.cs b/src/UnitTests/Projection/PrimitiveArraysTest.cs
index 1cfea884..9149ccdb 100644
--- a/src/UnitTests/Projection/PrimitiveArraysTest.cs
+++ b/src/UnitTests/Projection/PrimitiveArraysTest.cs
@@ -34,7 +34,7 @@ public void Should_map_values()
                     }
                 };
 
-                var expr = sources.AsQueryable().Project().To<Destination>();
+                var expr = sources.AsQueryable().ProjectTo<Destination>();
 
                 var result = expr.ToList();
 
diff --git a/src/UnitTests/Projection/ProjectCollectionEnumerableTest.cs b/src/UnitTests/Projection/ProjectCollectionEnumerableTest.cs
index 129aa0f0..210f993d 100644
--- a/src/UnitTests/Projection/ProjectCollectionEnumerableTest.cs
+++ b/src/UnitTests/Projection/ProjectCollectionEnumerableTest.cs
@@ -25,7 +25,7 @@ public void ProjectWithNullCollectionSourceProperty()
 		{
 			var customers = new[] { new Customer() }.AsQueryable();
 
-			var mapped = customers.Project().To<CustomerDto>().SingleOrDefault();
+			var mapped = customers.ProjectTo<CustomerDto>().SingleOrDefault();
 
             mapped.ShouldNotBeNull();
             mapped.Addresses.ShouldBeNull();
@@ -37,7 +37,7 @@ public void ProjectWithAssignedCollectionSourceProperty()
 			var customer = new Customer { Addresses = new List<Address> { new Address(Street1), new Address(Street2) } };
 			var customers = new[] { customer }.AsQueryable();
 
-			var mapped = customers.Project().To<CustomerDto>().SingleOrDefault();
+			var mapped = customers.ProjectTo<CustomerDto>().SingleOrDefault();
 
 			mapped.ShouldNotBeNull();
 
diff --git a/src/UnitTests/Projection/ProjectCollectionListTest.cs b/src/UnitTests/Projection/ProjectCollectionListTest.cs
index 161396a8..ee6b16fc 100644
--- a/src/UnitTests/Projection/ProjectCollectionListTest.cs
+++ b/src/UnitTests/Projection/ProjectCollectionListTest.cs
@@ -3,7 +3,8 @@
 
 namespace AutoMapper.UnitTests.Projection
 {
-	using System.Collections.Generic;
+    using System;
+    using System.Collections.Generic;
 	using System.Linq;
 
 	using AutoMapper;
@@ -26,7 +27,7 @@ public void ProjectWithNullCollectionSourceProperty()
 		{
 			var customers = new[] { new Customer() }.AsQueryable();
 
-			var mapped = customers.Project().To<CustomerDto>().SingleOrDefault();
+			var mapped = customers.ProjectTo<CustomerDto>().SingleOrDefault();
 			mapped.ShouldNotBeNull();
 			mapped.Addresses.ShouldBeNull();
 		}
@@ -38,7 +39,7 @@ public void ProjectWithAssignedCollectionSourceProperty()
 
 			var customers = new[] { customer }.AsQueryable();
 
-			var mapped = customers.Project().To<CustomerDto>().SingleOrDefault();
+			var mapped = customers.ProjectTo<CustomerDto>().SingleOrDefault();
 
 			mapped.ShouldNotBeNull();
 
@@ -67,9 +68,31 @@ public class CustomerDto
 			public IList<AddressDto> Addresses { get; set; }
 		}
 
-		public class AddressDto
+		public class AddressDto : IEquatable<AddressDto>
 		{
-			public string Street { get; set; }
+		    public bool Equals(AddressDto other)
+		    {
+		        if (ReferenceEquals(null, other)) return false;
+		        if (ReferenceEquals(this, other)) return true;
+		        return string.Equals(Street, other.Street);
+		    }
+
+		    public override int GetHashCode()
+		    {
+		        return (Street != null ? Street.GetHashCode() : 0);
+		    }
+
+		    public static bool operator ==(AddressDto left, AddressDto right)
+		    {
+		        return Equals(left, right);
+		    }
+
+		    public static bool operator !=(AddressDto left, AddressDto right)
+		    {
+		        return !Equals(left, right);
+		    }
+
+		    public string Street { get; set; }
 
 			public override string ToString()
 			{
diff --git a/src/UnitTests/Projection/ProjectEnumTest.cs b/src/UnitTests/Projection/ProjectEnumTest.cs
index 1b26dba7..4fd84b8c 100644
--- a/src/UnitTests/Projection/ProjectEnumTest.cs
+++ b/src/UnitTests/Projection/ProjectEnumTest.cs
@@ -19,7 +19,7 @@ public void ProjectingEnumToString()
         {
             var customers = new[] { new Customer() { FirstName = "Bill", LastName = "White", CustomerType = CustomerType.Vip } }.AsQueryable();
 
-            var projected = customers.Project().To<CustomerDto>();
+            var projected = customers.ProjectTo<CustomerDto>();
             projected.ShouldNotBeNull();
             Assert.Equal(customers.Single().CustomerType.ToString().ToUpper(), projected.Single().CustomerType);
         }
diff --git a/src/UnitTests/Projection/ProjectEnumerableToArrayTest.cs b/src/UnitTests/Projection/ProjectEnumerableToArrayTest.cs
index 4b7529c2..3567f649 100644
--- a/src/UnitTests/Projection/ProjectEnumerableToArrayTest.cs
+++ b/src/UnitTests/Projection/ProjectEnumerableToArrayTest.cs
@@ -26,7 +26,7 @@ public void EnumerablesAreMappedToArrays()
                 new Movie() { Actors = new Actor[] { new Actor() { Name = "Actor 3" }, new Actor() { Name = "Actor 4" } } }
                 }.AsQueryable();
 
-            var mapped = movies.Project().To<MovieDto>();
+            var mapped = movies.ProjectTo<MovieDto>();
 
             mapped.ElementAt(0).Actors.Length.ShouldEqual(2);
             mapped.ElementAt(1).Actors[1].Name.ShouldEqual("Actor 4");
diff --git a/src/UnitTests/Projection/ProjectTest.cs b/src/UnitTests/Projection/ProjectTest.cs
index 143beeaf..76386924 100644
--- a/src/UnitTests/Projection/ProjectTest.cs
+++ b/src/UnitTests/Projection/ProjectTest.cs
@@ -23,7 +23,7 @@ public void SelectUsingProjectToWithNullComplexSourceProperty()
 		{
 			var customers = new[] { new Customer { FirstName = "Bill", LastName = "White" } }.AsQueryable();
 
-			var projected = customers.Project().To<CustomerDto>().SingleOrDefault();
+			var projected = customers.ProjectTo<CustomerDto>().SingleOrDefault();
 			projected.ShouldNotBeNull();
 			projected.Address.ShouldBeNull();
 		}
@@ -37,7 +37,7 @@ public void ProjectToWithUnmappedTypeShouldThrowException()
 
 			IList<Unmapped> projected = null;
 
-            typeof(InvalidOperationException).ShouldBeThrownBy(() => projected = customers.Project().To<Unmapped>().ToList());
+            typeof(InvalidOperationException).ShouldBeThrownBy(() => projected = customers.ProjectTo<Unmapped>().ToList());
 
 			projected.ShouldBeNull();
 		}
diff --git a/src/UnitTests/Projection/ToStringTests.cs b/src/UnitTests/Projection/ToStringTests.cs
index 6c93ca7c..1295ef04 100644
--- a/src/UnitTests/Projection/ToStringTests.cs
+++ b/src/UnitTests/Projection/ToStringTests.cs
@@ -34,7 +34,7 @@ protected override void Because_of()
                 }
             }.AsQueryable();
 
-            _dests = sources.Project().To<Dest>().ToArray();
+            _dests = sources.ProjectTo<Dest>().ToArray();
         }
 
         [Fact]
