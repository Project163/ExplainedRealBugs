diff --git a/src/AutoMapper/AutoMapperConfigurationException.cs b/src/AutoMapper/AutoMapperConfigurationException.cs
index ad133767..0498b245 100644
--- a/src/AutoMapper/AutoMapperConfigurationException.cs
+++ b/src/AutoMapper/AutoMapperConfigurationException.cs
@@ -14,11 +14,13 @@ public class TypeMapConfigErrors
         {
             public TypeMap TypeMap { get; }
             public string[] UnmappedPropertyNames { get; }
+            public bool CanConstruct { get; }
 
-            public TypeMapConfigErrors(TypeMap typeMap, string[] unmappedPropertyNames)
+            public TypeMapConfigErrors(TypeMap typeMap, string[] unmappedPropertyNames, bool canConstruct)
             {
                 TypeMap = typeMap;
                 UnmappedPropertyNames = unmappedPropertyNames;
+                CanConstruct = canConstruct;
             }
         }
 
@@ -78,7 +80,7 @@ public override string Message
                 {
                     var message =
                         new StringBuilder(
-                            "\nUnmapped members were found. Review the types and members below.\nAdd a custom mapping expression, ignore, add a custom resolver, or modify the source/destination type\n");
+                            "\nUnmapped members were found. Review the types and members below.\nAdd a custom mapping expression, ignore, add a custom resolver, or modify the source/destination type\nFor no matching constructor, add a no-arg ctor, add optional arguments, or map all of the constructor parameters");
 
                     foreach (var error in Errors)
                     {
@@ -93,10 +95,18 @@ public override string Message
                                            error.TypeMap.DestinationType.FullName + " (" +
                                            error.TypeMap.ConfiguredMemberList + " member list)");
                         message.AppendLine();
-                        message.AppendLine("Unmapped properties:");
-                        foreach (var name in error.UnmappedPropertyNames)
+
+                        if (error.UnmappedPropertyNames.Any())
+                        {
+                            message.AppendLine("Unmapped properties:");
+                            foreach (var name in error.UnmappedPropertyNames)
+                            {
+                                message.AppendLine(name);
+                            }
+                        }
+                        if (!error.CanConstruct)
                         {
-                            message.AppendLine(name);
+                            message.AppendLine("No available constructor.");
                         }
                     }
                     return message.ToString();
diff --git a/src/AutoMapper/ConfigurationValidator.cs b/src/AutoMapper/ConfigurationValidator.cs
index fdcd2211..7308d556 100644
--- a/src/AutoMapper/ConfigurationValidator.cs
+++ b/src/AutoMapper/ConfigurationValidator.cs
@@ -24,8 +24,9 @@ public void AssertConfigurationIsValid(IEnumerable<TypeMap> typeMaps)
                 (from typeMap in maps
                     where typeMap.ShouldCheckForValid()
                     let unmappedPropertyNames = typeMap.GetUnmappedPropertyNames()
-                    where unmappedPropertyNames.Length > 0
-                    select new AutoMapperConfigurationException.TypeMapConfigErrors(typeMap, unmappedPropertyNames)
+                    let canConstruct = typeMap.CanConstruct()
+                    where unmappedPropertyNames.Length > 0 || !canConstruct
+                    select new AutoMapperConfigurationException.TypeMapConfigErrors(typeMap, unmappedPropertyNames, canConstruct)
                     ).ToArray();
 
             if (badTypeMaps.Any())
diff --git a/src/AutoMapper/TypeMap.cs b/src/AutoMapper/TypeMap.cs
index eb92882c..4c04c863 100644
--- a/src/AutoMapper/TypeMap.cs
+++ b/src/AutoMapper/TypeMap.cs
@@ -145,6 +145,41 @@ public string[] GetUnmappedPropertyNames()
             return properties.Where(memberName => !IgnorePropertiesStartingWith.Any(memberName.StartsWith)).ToArray();
         }
 
+        public bool CanConstruct()
+        {
+            if (DestinationCtor != null)
+                return true;
+
+            if (ConstructDestinationUsingServiceLocator)
+                return true;
+
+            if (ConstructorMap?.CanResolve == true)
+                return true;
+
+#if NET45
+            if (DestinationTypeToUse.IsInterface())
+                return true;
+#endif
+
+            if (DestinationTypeToUse.IsAbstract())
+                return true;
+
+            if (DestinationTypeToUse.IsGenericTypeDefinition())
+                return true;
+
+            if (!DestinationTypeToUse.IsClass())
+                return true;
+
+            var constructors = DestinationTypeToUse
+                .GetDeclaredConstructors()
+                .Where(ci => !ci.IsStatic);
+
+            //find a ctor with only optional args
+            var ctorWithOptionalArgs = constructors.FirstOrDefault(c => c.GetParameters().All(p => p.IsOptional));
+
+            return ctorWithOptionalArgs != null;
+        }
+
         public PropertyMap FindOrCreatePropertyMapFor(MemberInfo destinationProperty)
         {
             var propertyMap = GetExistingPropertyMapFor(destinationProperty);
diff --git a/src/UnitTests/ConfigurationValidation.cs b/src/UnitTests/ConfigurationValidation.cs
index 2ff185b3..05977da3 100644
--- a/src/UnitTests/ConfigurationValidation.cs
+++ b/src/UnitTests/ConfigurationValidation.cs
@@ -61,6 +61,87 @@ public void Should_skip_validation()
         }
     }
 
+    public class When_constructor_does_not_match : NonValidatingSpecBase
+    {
+        public class Source
+        {
+            public int Value { get; set; }
+        }
+
+        public class Dest
+        {
+            public Dest(int blarg)
+            {
+                Value = blarg;
+            }
+            public int Value { get; set; }
+        }
+
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg => cfg.CreateMap<Source, Dest>());
+
+        [Fact]
+        public void Should_throw()
+        {
+            typeof(AutoMapperConfigurationException).ShouldBeThrownBy(() => Configuration.AssertConfigurationIsValid());
+        }
+    }
+
+    public class When_constructor_partially_matches : NonValidatingSpecBase
+    {
+        public class Source
+        {
+            public int Value { get; set; }
+        }
+
+        public class Dest
+        {
+            public Dest(int value, int blarg)
+            {
+                Value = blarg;
+            }
+
+            public int Value { get; }
+        }
+
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg => cfg.CreateMap<Source, Dest>());
+
+        [Fact]
+        public void Should_throw()
+        {
+            typeof(AutoMapperConfigurationException).ShouldBeThrownBy(() => Configuration.AssertConfigurationIsValid());
+        }
+    }
+
+    public class When_constructor_partially_matches_and_ctor_param_configured : NonValidatingSpecBase
+    {
+        public class Source
+        {
+            public int Value { get; set; }
+        }
+
+        public class Dest
+        {
+            public Dest(int value, int blarg)
+            {
+                Value = blarg;
+            }
+
+            public int Value { get; }
+        }
+
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
+        {
+            cfg.CreateMap<Source, Dest>()
+                .ForCtorParam("blarg", opt => opt.MapFrom(src => src.Value));
+        });
+
+        [Fact]
+        public void Should_throw()
+        {
+            typeof(AutoMapperConfigurationException).ShouldNotBeThrownBy(() => Configuration.AssertConfigurationIsValid());
+        }
+    }
+
     public class When_testing_a_dto_with_mismatched_members : NonValidatingSpecBase
     {
         public class ModelObject
