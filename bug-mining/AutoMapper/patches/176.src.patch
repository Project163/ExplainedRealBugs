diff --git a/src/AutoMapper/PropertyMap.cs b/src/AutoMapper/PropertyMap.cs
index 4a2a7c0b..48e81195 100644
--- a/src/AutoMapper/PropertyMap.cs
+++ b/src/AutoMapper/PropertyMap.cs
@@ -39,7 +39,6 @@ public PropertyMap(PropertyMap inheritedMappedProperty, TypeMap typeMap)
         public LambdaExpression Condition { get; set; }
         public LambdaExpression PreCondition { get; set; }
         public LambdaExpression CustomExpression { get; private set; }
-        public MemberInfo CustomSourceMember { get; set; }
         public bool UseDestinationValue { get; set; }
         public bool ExplicitExpansion { get; set; }
         public object NullSubstitute { get; set; }
@@ -52,9 +51,6 @@ public MemberInfo SourceMember
                 if (CustomSourceMemberName != null)
                     return TypeMap.SourceType.GetMember(CustomSourceMemberName).FirstOrDefault();
 
-                if (CustomSourceMember != null)
-                    return CustomSourceMember;
-
                 if (CustomExpression != null)
                 {
                     var finder = new MemberFinderVisitor();
@@ -94,38 +90,23 @@ public void ChainMembers(IEnumerable<MemberInfo> members)
 
         public void ApplyInheritedPropertyMap(PropertyMap inheritedMappedProperty)
         {
-            if (!CanResolveValue() && inheritedMappedProperty.Ignored)
-            {
-                Ignored = true;
-            }
+            Ignored = inheritedMappedProperty.Ignored && !ResolveConfigured();
             CustomExpression = CustomExpression ?? inheritedMappedProperty.CustomExpression;
             CustomResolver = CustomResolver ?? inheritedMappedProperty.CustomResolver;
             Condition = Condition ?? inheritedMappedProperty.Condition;
             PreCondition = PreCondition ?? inheritedMappedProperty.PreCondition;
             NullSubstitute = NullSubstitute ?? inheritedMappedProperty.NullSubstitute;
             MappingOrder = MappingOrder ?? inheritedMappedProperty.MappingOrder;
-            CustomSourceMember = CustomSourceMember ?? inheritedMappedProperty.CustomSourceMember;
             ValueResolverConfig = ValueResolverConfig ?? inheritedMappedProperty.ValueResolverConfig;
         }
 
-        public bool IsMapped()
-        {
-            return _memberChain.Count > 0 
-                || ValueResolverConfig != null 
-                || CustomResolver != null 
-                || SourceMember != null
-                || CustomExpression != null
-                || Ignored;
-        }
+        public bool IsMapped() => HasSource() || Ignored;
 
-        public bool CanResolveValue()
-        {
-            return (_memberChain.Count > 0
-                || ValueResolverConfig != null
-                || CustomResolver != null
-                || SourceMember != null
-                || CustomExpression != null) && !Ignored;
-        }
+        public bool CanResolveValue() => HasSource() && !Ignored;
+
+        public bool HasSource() =>_memberChain.Count > 0 || ResolveConfigured();
+
+        public bool ResolveConfigured() => ValueResolverConfig != null || CustomResolver != null || CustomExpression != null || CustomSourceMemberName != null;
 
         public void SetCustomValueResolverExpression<TSource, TMember>(Expression<Func<TSource, TMember>> sourceMember)
         {
diff --git a/src/UnitTests/MappingInheritance/IgnoreShouldBeInherited.cs b/src/UnitTests/MappingInheritance/IgnoreShouldBeInherited.cs
new file mode 100644
index 00000000..b939fe06
--- /dev/null
+++ b/src/UnitTests/MappingInheritance/IgnoreShouldBeInherited.cs
@@ -0,0 +1,38 @@
+﻿using System;
+using Should;
+using Xunit;
+
+namespace AutoMapper.UnitTests.Bug
+{
+    public class IgnoreShouldBeInherited : AutoMapperSpecBase
+    {
+        public class BaseDomain
+        {            
+        }
+
+        public class SpecificDomain : BaseDomain
+        {
+            public string SpecificProperty { get; set; }            
+        }
+
+        public class Dto
+        {
+            public string SpecificProperty { get; set; }
+        }
+
+        protected override MapperConfiguration Configuration => new MapperConfiguration(cfg =>
+        {
+            cfg.CreateMap<BaseDomain, Dto>()
+                .ForMember(d => d.SpecificProperty, m => m.Ignore())
+                .Include<SpecificDomain, Dto>();
+            cfg.CreateMap<SpecificDomain, Dto>();
+        });
+
+        [Fact]
+        public void Should_map_ok()
+        {
+            var dto = Mapper.Map<Dto>(new SpecificDomain { SpecificProperty = "Test" });
+            dto.SpecificProperty.ShouldBeNull();
+        }
+    }
+}
diff --git a/src/UnitTests/MappingInheritance/InheritedIgnoreShouldBeOverridenByConventionMapping.cs b/src/UnitTests/MappingInheritance/InheritedIgnoreShouldBeOverridenByConventionMapping.cs
deleted file mode 100644
index 46238e7a..00000000
--- a/src/UnitTests/MappingInheritance/InheritedIgnoreShouldBeOverridenByConventionMapping.cs
+++ /dev/null
@@ -1,72 +0,0 @@
-﻿using Should;
-using Xunit;
-
-namespace AutoMapper.UnitTests.Bug
-{
-    public class InheritedIgnoreShouldBeOverriddenByConventionMapping
-    {
-        public class BaseDomain
-        {
-            
-        }
-
-        public class SpecificDomain : BaseDomain
-        {
-            public string SpecificProperty { get; set; }            
-        }
-
-        public class Dto
-        {
-            public string SpecificProperty { get; set; }
-        }
-
-        [Fact]
-        public void inhertited_ignore_should_be_pass_validation()
-        {
-            var config = new MapperConfiguration(cfg =>
-            {
-                cfg.CreateMap<BaseDomain, Dto>()
-                    .ForMember(d => d.SpecificProperty, m => m.Ignore())
-                    .Include<SpecificDomain, Dto>();
-
-                cfg.CreateMap<SpecificDomain, Dto>();
-            });
-
-            config.AssertConfigurationIsValid();
-        }
-
-        [Fact]
-        public void inhertited_ignore_should_be_overridden_by_successful_convention_mapping()
-        {
-            var config = new MapperConfiguration(cfg =>
-            {
-                cfg.CreateMap<BaseDomain, Dto>()
-                    .ForMember(d => d.SpecificProperty, m => m.Ignore())
-                    .Include<SpecificDomain, Dto>();
-
-                cfg.CreateMap<SpecificDomain, Dto>();
-            });
-
-            var dto = config.CreateMapper().Map<BaseDomain, Dto>(new SpecificDomain {SpecificProperty = "Test"});
-
-            dto.SpecificProperty.ShouldEqual("Test");
-        }
-        
-        [Fact]
-        public void inhertited_ignore_should_be_overridden_by_successful_convention_mapping_with_one_parameter()
-        {
-            var config = new MapperConfiguration(cfg =>
-            {
-                cfg.CreateMap<BaseDomain, Dto>()
-                    .ForMember(d => d.SpecificProperty, m => m.Ignore())
-                    .Include<SpecificDomain, Dto>();
-
-                cfg.CreateMap<SpecificDomain, Dto>();
-            });
-
-            var dto = config.CreateMapper().Map<Dto>(new SpecificDomain { SpecificProperty = "Test" });
-
-            dto.SpecificProperty.ShouldEqual("Test");
-        }
-    }
-}
diff --git a/src/UnitTests/UnitTests.Net4.csproj b/src/UnitTests/UnitTests.Net4.csproj
index 8421f622..18f5b7bb 100644
--- a/src/UnitTests/UnitTests.Net4.csproj
+++ b/src/UnitTests/UnitTests.Net4.csproj
@@ -356,6 +356,7 @@
     <Compile Include="MappingExceptions.cs" />
     <Compile Include="MappingInheritance\ApplyIncludeBaseRecursively.cs" />
     <Compile Include="MappingInheritance\ConventionMappedCollectionShouldMapBaseTypes.cs" />
+    <Compile Include="MappingInheritance\IgnoreShouldBeInherited.cs" />
     <Compile Include="MappingInheritance\IgnoreShouldBeInheritedIfConventionCannotMap.cs" />
     <Compile Include="MappingInheritance\IncludeBaseShouldNotCreateMaps.cs" />
     <Compile Include="MappingInheritance\MapToBaseClass.cs" />
@@ -364,7 +365,6 @@
     <Compile Include="MappingInheritance\IncludedBaseMappingShouldInheritBaseMappings.cs" />
     <Compile Include="MappingInheritance\IncludedMappingShouldInheritBaseMappings.cs" />
     <Compile Include="MappingInheritance\InheritanceWithoutIncludeShouldWork.cs" />
-    <Compile Include="MappingInheritance\InheritedIgnoreShouldBeOverridenByConventionMapping.cs" />
     <Compile Include="MappingInheritance\MultipleInheritedBaseMappingsOfSameTypeFails.cs" />
     <Compile Include="MappingInheritance\OverrideIgnore.cs" />
     <Compile Include="MappingInheritance\PropertyOnMappingShouldResolveMostSpecificType.cs" />
