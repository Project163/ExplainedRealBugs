diff --git a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
index ddcd4021..4402d7c5 100644
--- a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
+++ b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
@@ -88,7 +88,10 @@ protected virtual object ReassignValue(ResolutionContext context, object o)
 			private void MapPropertyValue(ResolutionContext context, IMappingEngineRunner mapper, object mappedObject, PropertyMap propertyMap)
 			{
 				if (propertyMap.CanResolveValue())
-				{
+                {
+                    if (!propertyMap.ShouldAssignValue(context.CreateMemberContext(null, null, null, null, propertyMap)))
+                        return;
+
 					object destinationValue = null;
 					ResolutionResult result;
 
@@ -123,9 +126,6 @@ private void MapPropertyValue(ResolutionContext context, IMappingEngineRunner ma
 					var newContext = context.CreateMemberContext(typeMap, result.Value, destinationValue, targetSourceType,
 																 propertyMap);
 
-                    if (!propertyMap.ShouldAssignValue(newContext))
-                        return;
-
 					try
 					{
 						object propertyValueToAssign = mapper.Map(newContext);
diff --git a/src/UnitTests/ConditionalMapping.cs b/src/UnitTests/ConditionalMapping.cs
index cc5a78f7..6b18136e 100644
--- a/src/UnitTests/ConditionalMapping.cs
+++ b/src/UnitTests/ConditionalMapping.cs
@@ -45,6 +45,51 @@ public void Should_execute_the_mapping_when_the_condition_is_false()
             }
         }
 
+        public class When_configuring_a_member_to_skip_based_on_the_property_value_with_custom_mapping : AutoMapperSpecBase
+        {
+            public class Source
+            {
+                public int Value { get; set; }
+            }
+
+            public class Destination
+            {
+                public int Value { get; set; }
+            }
+
+            protected override void Establish_context()
+            {
+                Mapper.Initialize(cfg =>
+                {
+                    cfg.CreateMap<Source, Destination>()
+                        .ForMember(dest => dest.Value, opt =>
+                        {
+                            opt.Condition(src => src.Value > 0);
+                            opt.ResolveUsing(src =>
+                            {
+                                throw new Exception("Blarg");
+                                return 5;
+                            });
+                        });
+                });
+            }
+
+            [Test]
+            public void Should_skip_the_mapping_when_the_condition_is_true()
+            {
+                var destination = Mapper.Map<Source, Destination>(new Source { Value = -1 });
+
+                destination.Value.ShouldEqual(0);
+            }
+
+            [Test]
+            public void Should_execute_the_mapping_when_the_condition_is_false()
+            {
+                typeof(AutoMapperMappingException).ShouldBeThrownBy(() => Mapper.Map<Source, Destination>(new Source { Value = 7 }));
+            }
+        }
+
+
         public class When_configuring_a_member_to_skip_based_on_the_property_metadata : AutoMapperSpecBase
         {
             private Destination _destination;
