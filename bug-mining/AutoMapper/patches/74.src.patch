diff --git a/src/AutoMapper/IMappingExpression.cs b/src/AutoMapper/IMappingExpression.cs
index 0817e62d..37107084 100644
--- a/src/AutoMapper/IMappingExpression.cs
+++ b/src/AutoMapper/IMappingExpression.cs
@@ -97,10 +97,18 @@ public interface IMappingExpression<TSource, TDestination>
         /// </summary>
         /// <typeparam name="TOtherSource">Derived source type</typeparam>
         /// <typeparam name="TOtherDestination">Derived destination type</typeparam>
-        /// <returns></returns>
+        /// <returns>Itself</returns>
         IMappingExpression<TSource, TDestination> Include<TOtherSource, TOtherDestination>()
             where TOtherSource : TSource
-            where TOtherDestination : TDestination;
+            where TOtherDestination : TDestination;
+
+        /// <summary>
+        /// Include this configuration in derived types' maps
+        /// </summary>
+        /// <param name="derivedSourceType">Derived source type</param>
+        /// <param name="derivedDestinationType">Derived destination type</param>
+        /// <returns>Itself</returns>
+        IMappingExpression<TSource, TDestination> Include(Type derivedSourceType, Type derivedDestinationType);
 
         /// <summary>
         /// Assign a profile to the current type map
diff --git a/src/AutoMapper/Internal/MappingExpression.cs b/src/AutoMapper/Internal/MappingExpression.cs
index b560bdbf..46b027a7 100644
--- a/src/AutoMapper/Internal/MappingExpression.cs
+++ b/src/AutoMapper/Internal/MappingExpression.cs
@@ -225,7 +225,12 @@ private bool HasAnInaccessibleSetter(PropertyInfo property)
             where TOtherSource : TSource
             where TOtherDestination : TDestination
         {
-            _typeMap.IncludeDerivedTypes(typeof(TOtherSource), typeof(TOtherDestination));
+            return Include(typeof(TOtherSource), typeof(TOtherDestination));
+        }
+
+        public IMappingExpression<TSource, TDestination> Include(Type otherSourceType, Type otherDestinationType)
+        {
+            _typeMap.IncludeDerivedTypes(otherSourceType, otherDestinationType);
 
             return this;
         }
@@ -345,6 +350,11 @@ public void Condition(Func<TSource, bool> condition)
             foreach (var destProperty in _typeMap.GetPropertyMaps().Where(pm => pm.IsIgnored()))
             {
                 mappingExpression.ForSourceMember(destProperty.DestinationProperty.Name, opt => opt.Ignore());
+            }
+
+            foreach (var includedDerivedType in _typeMap.IncludedDerivedTypes)
+            {
+                mappingExpression.Include(includedDerivedType.DestinationType, includedDerivedType.SourceType);
             }
 
             return mappingExpression;
diff --git a/src/AutoMapper/TypeMap.cs b/src/AutoMapper/TypeMap.cs
index 754136e2..9ccf7467 100644
--- a/src/AutoMapper/TypeMap.cs
+++ b/src/AutoMapper/TypeMap.cs
@@ -91,6 +91,11 @@ public Type DestinationType
 
         public MemberList ConfiguredMemberList { get; private set; }
 
+        public IEnumerable<TypePair> IncludedDerivedTypes
+        {
+            get {  return _includedDerivedTypes; }
+        } 
+
         public int MaxDepth
         {
             get { return _maxDepth; }
diff --git a/src/UnitTests/ReverseMapping.cs b/src/UnitTests/ReverseMapping.cs
index ca6ee94a..534c6623 100644
--- a/src/UnitTests/ReverseMapping.cs
+++ b/src/UnitTests/ReverseMapping.cs
@@ -248,6 +248,61 @@ public void Should_not_throw_exception_for_unmapped_properties()
 
         }
 
+        public class When_reverse_mapping_with_inheritance : AutoMapperSpecBase
+        {
+            private ASrc _bsrcResult;
+
+            public class ASrc
+            {
+                public string A { get; set; }
+            }
+
+            public class BSrc : ASrc
+            {
+                public string B { get; set; }
+            }
+
+            public class ADest
+            {
+                public string A { get; set; }
+            }
+
+            public class BDest : ADest
+            {
+                public string B { get; set; }
+            }
+
+            protected override void Establish_context()
+            {
+                Mapper.Initialize(cfg =>
+                {
+                    cfg.CreateMap<ASrc, ADest>()
+                        .Include<BSrc, BDest>()
+                        .ReverseMap();
+
+                    cfg.CreateMap<BSrc, BDest>()
+                        .ReverseMap();
+                });
+            }
+
+            protected override void Because_of()
+            {
+                var bdest = new BDest
+                {
+                    A = "A",
+                    B = "B"
+                };
+
+                _bsrcResult = Mapper.Map<ADest, ASrc>(bdest);
+            }
+
+            [Fact]
+            public void Should_create_derived_reverse_map()
+            {
+                _bsrcResult.ShouldBeType<BSrc>();
+            }
+        }
+
         public static class AutoMapperExtensions
         {
             // from http://stackoverflow.com/questions/954480/automapper-ignore-the-rest/6474397#6474397
