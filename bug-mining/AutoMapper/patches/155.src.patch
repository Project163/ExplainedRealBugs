diff --git a/src/AutoMapper/ConstructorMap.cs b/src/AutoMapper/ConstructorMap.cs
index 96f8d659..6e954ebd 100644
--- a/src/AutoMapper/ConstructorMap.cs
+++ b/src/AutoMapper/ConstructorMap.cs
@@ -53,14 +53,14 @@ public Expression NewExpression(Expression instanceParameter)
         }
 
         public Expression BuildExpression(
-            TypeMapRegistry typeMapRegistry,
+            IConfigurationProvider configuration,
             ParameterExpression srcParam, 
             ParameterExpression ctxtParam)
         {
             if (!CanResolve)
                 return null;
 
-            var ctorArgs = CtorParams.Select(p => p.CreateExpression(typeMapRegistry, srcParam, ctxtParam));
+            var ctorArgs = CtorParams.Select(p => p.CreateExpression(configuration, srcParam, ctxtParam));
 
             ctorArgs =
                 ctorArgs.Zip(Ctor.GetParameters(),
diff --git a/src/AutoMapper/ConstructorParameterMap.cs b/src/AutoMapper/ConstructorParameterMap.cs
index 1466e433..68ba80f9 100644
--- a/src/AutoMapper/ConstructorParameterMap.cs
+++ b/src/AutoMapper/ConstructorParameterMap.cs
@@ -34,9 +34,7 @@ public ConstructorParameterMap(ParameterInfo parameter, MemberInfo[] sourceMembe
         public Type SourceType => CustomExpression?.ReturnType ?? SourceMembers.LastOrDefault()?.GetMemberType();
         public Type DestinationType => Parameter.ParameterType;
 
-        public Expression CreateExpression(TypeMapRegistry typeMapRegistry,
-            ParameterExpression srcParam,
-            ParameterExpression ctxtParam)
+        public Expression CreateExpression(IConfigurationProvider configuration, ParameterExpression srcParam, ParameterExpression ctxtParam)
         {
             if (CustomExpression != null)
                 return CustomExpression.ConvertReplaceParameters(srcParam).IfNotNull(DestinationType);
@@ -47,7 +45,7 @@ public ConstructorParameterMap(ParameterInfo parameter, MemberInfo[] sourceMembe
                 return Invoke(Constant(CustomValueResolver), srcParam, ctxtParam);
             }
 
-            if (Parameter.IsOptional && (!SourceMembers.Any() || typeMapRegistry.GetTypeMap(new TypePair(SourceType, DestinationType)) == null))
+            if (Parameter.IsOptional && (!SourceMembers.Any() || configuration.ResolveTypeMap(SourceType, DestinationType) == null))
             {
                 DefaultValue = true;
                 return Constant(Parameter.GetDefaultValue());
@@ -64,7 +62,7 @@ public ConstructorParameterMap(ParameterInfo parameter, MemberInfo[] sourceMembe
             valueResolverExpr = valueResolverExpr.IfNotNull(DestinationType);
 
             if ((SourceType.IsEnumerableType() && SourceType != typeof (string))
-                || typeMapRegistry.GetTypeMap(new TypePair(SourceType, DestinationType)) != null
+                || configuration.ResolveTypeMap(SourceType, DestinationType) != null
                 || !DestinationType.IsAssignableFrom(SourceType))
             {
                 /*
diff --git a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
index f957e9b2..09e87ca6 100644
--- a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
+++ b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
@@ -232,7 +232,7 @@ private Expression CreateNewDestinationFunc(out bool constructorMapping)
             if(_typeMap.ConstructorMap?.CanResolve == true)
             {
                 constructorMapping = true;
-                return _typeMap.ConstructorMap.BuildExpression(_typeMapRegistry, _source, _context);
+                return _typeMap.ConstructorMap.BuildExpression(_configurationProvider, _source, _context);
             }
 #if NET45
             if(_typeMap.DestinationTypeToUse.IsInterface())
@@ -297,8 +297,7 @@ private Expression CreatePropertyMapFunc(PropertyMap propertyMap)
                 var match = _configurationProvider.GetMappers().FirstOrDefault(m => m.IsMatch(typePair));
                 if(typeMap != null && (typeMap.TypeConverterType != null || typeMap.CustomMapper != null))
                 {
-                    if(typeMap.Sealed != true)
-                        typeMap.Seal(_typeMapRegistry, _configurationProvider);
+                    typeMap.Seal(_typeMapRegistry, _configurationProvider);
                     valueResolverExpr = typeMap.MapExpression.ConvertReplaceParameters(valueResolverExpr, destValueExpr, _context);
                 }
                 else if(match != null && typeMap == null)
@@ -507,8 +506,7 @@ private Expression BuildValueResolverFunc(PropertyMap propertyMap, Expression de
 
             if(propertyMap.DestinationPropertyType == typeof(string) && valueResolverFunc.Type != typeof(string)
                 &&
-                _typeMapRegistry.GetTypeMap(new TypePair(valueResolverFunc.Type, propertyMap.DestinationPropertyType)) ==
-                null)
+                _configurationProvider.ResolveTypeMap(valueResolverFunc.Type, propertyMap.DestinationPropertyType) == null)
             {
                 valueResolverFunc = Call(valueResolverFunc, typeof(object).GetDeclaredMethod("ToString", new Type[0]));
             }
diff --git a/src/AutoMapper/MapperConfiguration.cs b/src/AutoMapper/MapperConfiguration.cs
index 0b54a858..9eb21f2d 100644
--- a/src/AutoMapper/MapperConfiguration.cs
+++ b/src/AutoMapper/MapperConfiguration.cs
@@ -109,39 +109,43 @@ public TypeMap ResolveTypeMap(Type sourceType, Type destinationType)
         public TypeMap ResolveTypeMap(TypePair typePair)
         {
             var typeMap = _typeMapPlanCache.GetOrAdd(typePair, _getTypeMap);
-
-            _typeMapPlanCache.AddOrUpdate(typePair, typeMap, (tp, tm) =>
+            if(Configuration.CreateMissingTypeMaps && typeMap != null && typeMap.MapExpression == null)
             {
-                if (tm != null)
-                    lock (tm)
-                        if (tm.Sealed == false)
-                            tm.Seal(_typeMapRegistry, this);
-                return tm;
-            });
-
+                lock(typeMap)
+                {
+                    typeMap.Seal(_typeMapRegistry, this);
+                }
+            }
             return typeMap;
         }
 
-        private TypeMap GetTypeMap(TypePair pair)
+        private TypeMap GetTypeMap(TypePair initialTypes)
         {
-            foreach (var tp in pair.GetRelatedTypePairs())
+            TypeMap typeMap;
+            foreach(var types in initialTypes.GetRelatedTypePairs())
             {
-                TypeMap typeMap;
-                if (_typeMapPlanCache.TryGetValue(tp, out typeMap))
+                if(_typeMapPlanCache.TryGetValue(types, out typeMap))
+                {
                     return typeMap;
-
-                typeMap = FindClosedGenericTypeMapFor(tp, pair);
-
-                if (typeMap != null)
+                }
+                typeMap = FindTypeMapFor(types);
+                if(typeMap != null)
+                {
                     return typeMap;
-
-                if (CoveredByObjectMap(pair))
-                    return null;
-
-                typeMap = FindConventionTypeMapFor(tp);
-
-                if (typeMap != null)
+                }
+                typeMap = FindClosedGenericTypeMapFor(types, initialTypes);
+                if(typeMap != null)
+                {
                     return typeMap;
+                }
+                if(!CoveredByObjectMap(initialTypes))
+                {
+                    typeMap = FindConventionTypeMapFor(types);
+                    if(typeMap != null)
+                    {
+                        return typeMap;
+                    }
+                }
             }
             return null;
         }
@@ -290,6 +294,11 @@ private TypeMap FindConventionTypeMapFor(TypePair typePair)
                 .Select(p => p.ConfigureConventionTypeMap(_typeMapRegistry, typePair))
                 .FirstOrDefault(t => t != null);
 
+            if(!Configuration.CreateMissingTypeMaps)
+            {
+                typeMap?.Seal(_typeMapRegistry, this);
+            }
+
             return typeMap;
         }
 
@@ -303,6 +312,8 @@ private TypeMap FindClosedGenericTypeMapFor(TypePair typePair, TypePair requeste
                 .Select(p => p.ConfigureClosedGenericTypeMap(_typeMapRegistry, typePair, requestedTypes))
                 .FirstOrDefault(t => t != null);
 
+            typeMap?.Seal(_typeMapRegistry, this);
+
             return typeMap;
         }
 
diff --git a/src/AutoMapper/Mappers/ArrayMapper.cs b/src/AutoMapper/Mappers/ArrayMapper.cs
index da17d530..9e57f74f 100644
--- a/src/AutoMapper/Mappers/ArrayMapper.cs
+++ b/src/AutoMapper/Mappers/ArrayMapper.cs
@@ -36,8 +36,7 @@ public Expression MapExpression(TypeMapRegistry typeMapRegistry, IConfigurationP
             var sourceElementType = TypeHelper.GetElementType(sourceExpression.Type);
             var destElementType = TypeHelper.GetElementType(destExpression.Type);
 
-            if (destExpression.Type.IsAssignableFrom(sourceExpression.Type)
-                && typeMapRegistry.GetTypeMap(new TypePair(sourceElementType, destElementType)) == null)
+            if (destExpression.Type.IsAssignableFrom(sourceExpression.Type) && configurationProvider.ResolveTypeMap(sourceElementType, destElementType) == null)
             {
                 // return (TDestination[]) source;
                 var convertExpr = Convert(sourceExpression, destElementType.MakeArrayType());
diff --git a/src/AutoMapper/Mappers/CollectionMapper.cs b/src/AutoMapper/Mappers/CollectionMapper.cs
index 4d974f20..c8be5fc3 100644
--- a/src/AutoMapper/Mappers/CollectionMapper.cs
+++ b/src/AutoMapper/Mappers/CollectionMapper.cs
@@ -147,8 +147,7 @@ internal static Expression NewExpr(this Type baseType, Type ifInterfaceType)
             var typeMap = configurationProvider.ResolveTypeMap(typePair);
             if (typeMap != null && (typeMap.TypeConverterType != null || typeMap.CustomMapper != null))
             {
-                if (typeMap.Sealed != true)
-                    typeMap.Seal(typeMapRegistry, configurationProvider);
+                typeMap.Seal(typeMapRegistry, configurationProvider);
                 return typeMap.MapExpression.ReplaceParameters(itemParam, Default(typePair.DestinationType), contextParam);
             }
             var match = configurationProvider.GetMappers().FirstOrDefault(m => m.IsMatch(typePair));
diff --git a/src/AutoMapper/TypeMap.cs b/src/AutoMapper/TypeMap.cs
index d5a50096..ad52537a 100644
--- a/src/AutoMapper/TypeMap.cs
+++ b/src/AutoMapper/TypeMap.cs
@@ -26,8 +26,7 @@ public class TypeMap
 
         private readonly IList<PropertyMap> _inheritedMaps = new List<PropertyMap>();
         private PropertyMap[] _orderedPropertyMaps;
-        private bool? _sealed = false;
-        public bool? Sealed => _sealed;
+        private bool _sealed;
         private readonly IList<TypeMap> _inheritedTypeMaps = new List<TypeMap>();
 
         public TypeMap(TypeDetails sourceType, TypeDetails destinationType, MemberList memberList, IProfileConfiguration profile)
@@ -249,9 +248,11 @@ public void AddAfterMapAction(LambdaExpression afterMap)
 
         public void Seal(TypeMapRegistry typeMapRegistry, IConfigurationProvider configurationProvider)
         {
-            if (_sealed == true)
+            if(_sealed)
+            {
                 return;
-            _sealed = null;
+            }
+            _sealed = true;
 
             foreach (var inheritedTypeMap in _inheritedTypeMaps)
             {
@@ -264,8 +265,6 @@ public void Seal(TypeMapRegistry typeMapRegistry, IConfigurationProvider configu
                     .OrderBy(map => map.MappingOrder).ToArray();
 
             MapExpression = new TypeMapPlanBuilder(configurationProvider, typeMapRegistry, this).CreateMapperLambda();
-
-            _sealed = true;
         }
 
         public PropertyMap GetExistingPropertyMapFor(MemberInfo destinationProperty)
