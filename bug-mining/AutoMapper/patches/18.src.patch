diff --git a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
index 4402d7c5..26e2db93 100644
--- a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
+++ b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
@@ -63,13 +63,13 @@ public object Map(ResolutionContext context, IMappingEngineRunner mapper)
 				if (context.SourceValue != null)
 					context.InstanceCache.Add(context, mappedObject);
 
-				context.TypeMap.BeforeMap(context.SourceValue, mappedObject);
-
-				foreach (PropertyMap propertyMap in context.TypeMap.GetPropertyMaps())
-				{
-					MapPropertyValue(context, mapper, mappedObject, propertyMap);
-				}
-				mappedObject = ReassignValue(context, mappedObject);
+				context.TypeMap.BeforeMap(context.SourceValue, mappedObject);
+
+                foreach (PropertyMap propertyMap in context.TypeMap.GetPropertyMaps())
+                {
+                    MapPropertyValue(context.CreatePropertyMapContext(propertyMap), mapper, mappedObject, propertyMap);
+                }
+                mappedObject = ReassignValue(context, mappedObject); mappedObject = ReassignValue(context, mappedObject);
 
                 context.TypeMap.AfterMap(context.SourceValue, mappedObject);
 
diff --git a/src/AutoMapper/ResolutionContext.cs b/src/AutoMapper/ResolutionContext.cs
index d31a6538..d1ddae73 100644
--- a/src/AutoMapper/ResolutionContext.cs
+++ b/src/AutoMapper/ResolutionContext.cs
@@ -152,6 +152,11 @@ public ResolutionContext CreateTypeContext(TypeMap memberTypeMap, object sourceV
             return new ResolutionContext(this, memberTypeMap, sourceValue, sourceType, destinationType);
         }
 
+        public ResolutionContext CreatePropertyMapContext(PropertyMap propertyMap)
+        {
+            return new ResolutionContext(this, SourceValue, DestinationValue, SourceType, propertyMap);
+        }
+
 		public ResolutionContext CreateMemberContext(TypeMap memberTypeMap, object memberValue, object destinationValue, Type sourceMemberType, PropertyMap propertyMap)
 		{
 			return memberTypeMap != null
diff --git a/src/UnitTests/PropertyMapContexts.cs b/src/UnitTests/PropertyMapContexts.cs
new file mode 100644
index 00000000..8d336749
--- /dev/null
+++ b/src/UnitTests/PropertyMapContexts.cs
@@ -0,0 +1,75 @@
+ï»¿using System;
+using NUnit.Framework;
+using Should;
+
+namespace AutoMapper.UnitTests
+{
+    [TestFixture]
+    public class CustomValueResolverIsNotSuppliedWithContextPropertyMap
+    {
+
+        public class Source
+        {
+            public string CodeValue1 { get; set; }
+            public string CodeValue2 { get; set; }
+        }
+
+
+        public class DestinationDto
+        {
+            public CodeValueDto CodeValue1 { get; set; }
+            public CodeValueDto CodeValue2 { get; set; }
+        }
+
+
+        public class CodeValueDto
+        {
+            public string Code { get; set; }
+            public string Title { get; set; }
+            public string Type { get; set; }
+        }
+
+
+        public class CodeValueDtoResolver : IValueResolver
+        {
+            public ResolutionResult Resolve(ResolutionResult source)
+            {
+                var propertyMap = source.Context.PropertyMap;
+
+                propertyMap.ShouldNotBeNull();
+
+                var codeValueTypeId = propertyMap.SourceMember.DeclaringType.Name + ":" + propertyMap.SourceMember.Name;
+                return source.New(LookupCodeValue(codeValueTypeId, "" + source.Value));
+            }
+
+            private CodeValueDto LookupCodeValue(string codeValueTypeId, string code)
+            {
+                switch (codeValueTypeId + "==" + code)
+                {
+                    case "Source:CodeValue1==Value1":
+                        return new CodeValueDto { Code = "" + code, Title = "lookup value for Value1==1" };
+                    case "Source:CodeValue2==Value1":
+                        return new CodeValueDto { Code = "" + code, Title = "lookup value for Value2==1" };
+                    default:
+                        throw new InvalidOperationException();
+                }
+            }
+        }
+
+
+        [Test]
+        public void CustomValueResolver_Should_Be_Supplied_With_Current_PropertyMap()
+        {
+            Mapper.CreateMap<Source, DestinationDto>()
+              .ForMember(x => x.CodeValue1, o => o.ResolveUsing<CodeValueDtoResolver>().FromMember(y => y.CodeValue1))
+              .ForMember(x => x.CodeValue2, o => o.ResolveUsing<CodeValueDtoResolver>().FromMember(y => y.CodeValue2));
+
+            var src = new Source { CodeValue1 = "Value1", CodeValue2 = "Value1" };
+
+            var dest = Mapper.Map<Source, DestinationDto>(src);
+
+            dest.CodeValue1.Title.ShouldEqual("lookup value for Value1==1");
+            dest.CodeValue2.Title.ShouldEqual("lookup value for Value2==1");
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/UnitTests/UnitTests.csproj b/src/UnitTests/UnitTests.csproj
index 218dd0a4..ec0b094e 100644
--- a/src/UnitTests/UnitTests.csproj
+++ b/src/UnitTests/UnitTests.csproj
@@ -170,6 +170,7 @@
     <Compile Include="NestedContainers.cs" />
     <Compile Include="NullBehavior.cs" />
     <Compile Include="Profiles.cs" />
+    <Compile Include="PropertyMapContexts.cs" />
     <Compile Include="Regression.cs" />
     <Compile Include="ReverseMapping.cs" />
     <Compile Include="TesterExtensions.cs" />
