diff --git a/src/AutoMapper/IMappingExpression.cs b/src/AutoMapper/IMappingExpression.cs
index be1eecb0..58a7325b 100644
--- a/src/AutoMapper/IMappingExpression.cs
+++ b/src/AutoMapper/IMappingExpression.cs
@@ -176,7 +176,14 @@ public interface IMappingExpression<TSource, TDestination>
         /// </summary>
         /// <param name="ctor">Callback to create the destination type given the source object</param>
         /// <returns>Itself</returns>
-        IMappingExpression<TSource, TDestination> ConstructUsing(Expression<Func<TSource, TDestination>> ctor);
+        IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor);
+
+        /// <summary>
+        /// Supply a custom instantiation expression for the destination type for LINQ projection
+        /// </summary>
+        /// <param name="ctor">Callback to create the destination type given the source object</param>
+        /// <returns>Itself</returns>
+        IMappingExpression<TSource, TDestination> ConstructProjectionUsing(Expression<Func<TSource, TDestination>> ctor);
 
         /// <summary>
         /// Supply a custom instantiation function for the destination type, based on the entire resolution context
diff --git a/src/AutoMapper/Internal/MappingExpression.cs b/src/AutoMapper/Internal/MappingExpression.cs
index 7ea529b8..556e7e85 100644
--- a/src/AutoMapper/Internal/MappingExpression.cs
+++ b/src/AutoMapper/Internal/MappingExpression.cs
@@ -505,13 +505,9 @@ public void ConvertUsing(ITypeConverter<TSource, TDestination> converter)
             return AfterMap(afterFunction);
         }
 
-        public IMappingExpression<TSource, TDestination> ConstructUsing(Expression<Func<TSource, TDestination>> ctor)
+        public IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor)
         {
-            var func = ctor.Compile();
-
-            TypeMap.ConstructExpression = ctor;
-
-            return ConstructUsing(ctxt => func((TSource)ctxt.SourceValue));
+            return ConstructUsing(ctxt => ctor((TSource)ctxt.SourceValue));
         }
 
         public IMappingExpression<TSource, TDestination> ConstructUsing(Func<ResolutionContext, TDestination> ctor)
@@ -519,8 +515,17 @@ public void ConvertUsing(ITypeConverter<TSource, TDestination> converter)
             TypeMap.DestinationCtor = ctxt => ctor(ctxt);
 
             return this;
-        }
-
+        }
+
+        public IMappingExpression<TSource, TDestination> ConstructProjectionUsing(Expression<Func<TSource, TDestination>> ctor)
+        {
+            var func = ctor.Compile();
+
+            TypeMap.ConstructExpression = ctor;
+
+            return ConstructUsing(ctxt => func((TSource)ctxt.SourceValue));
+        }
+
         private void ForDestinationMember(IMemberAccessor destinationProperty, Action<IMemberConfigurationExpression<TSource>> memberOptions)
         {
             _propertyMap = TypeMap.FindOrCreatePropertyMapFor(destinationProperty);
diff --git a/src/AutoMapper/QueryableExtensions.cs b/src/AutoMapper/QueryableExtensions.cs
index 765e8eda..653eb3d6 100644
--- a/src/AutoMapper/QueryableExtensions.cs
+++ b/src/AutoMapper/QueryableExtensions.cs
@@ -89,16 +89,29 @@ private static Expression CreateMapExpression(IMappingEngine mappingEngine, Expr
 
             var bindings = CreateMemberBindings(mappingEngine, request, typeMap, instanceParameter, typePairCount);
 
-            var ctorExpr = Expression.New(request.DestinationType);
+            var parameterReplacer = new ParameterReplacementVisitor(instanceParameter);
+            var visitor = new NewFinderVisitor();
+            visitor.Visit(parameterReplacer.Visit(typeMap.ConstructExpression));
 
             var expression = Expression.MemberInit(
-                ctorExpr,
+                visitor.NewExpression,
                 bindings.ToArray()
                 );
 
             return expression;
         }
 
+        private class NewFinderVisitor : ExpressionVisitor
+        {
+            public NewExpression NewExpression { get; private set; }
+
+            protected override Expression VisitNew(NewExpression node)
+            {
+                NewExpression = node;
+                return base.VisitNew(node);
+            }
+        }
+
         private static List<MemberBinding> CreateMemberBindings(IMappingEngine mappingEngine, ExpressionRequest request,
             TypeMap typeMap,
             Expression instanceParameter, Internal.IDictionary<ExpressionRequest, int> typePairCount)
diff --git a/src/AutoMapper/TypeMap.cs b/src/AutoMapper/TypeMap.cs
index 2e4070c8..a1cac4b6 100644
--- a/src/AutoMapper/TypeMap.cs
+++ b/src/AutoMapper/TypeMap.cs
@@ -38,6 +38,7 @@ public TypeMap(TypeInfo sourceType, TypeInfo destinationType, MemberList memberL
             _destinationType = destinationType;
             Profile = ConfigurationStore.DefaultProfileName;
             ConfiguredMemberList = memberList;
+            ConstructExpression = Expression.Lambda(Expression.New(destinationType.Type));
         }
 
         public ConstructorMap ConstructorMap
@@ -109,7 +110,7 @@ public int MaxDepth
         }
 
         public Func<object, object> Substitution { get; set; }
-        public Expression<Func<object, object>> ConstructExpression { get; set; }
+        public LambdaExpression ConstructExpression { get; set; }
 
         public IEnumerable<PropertyMap> GetPropertyMaps()
         {
diff --git a/src/UnitTests/Projection/ConstructorTests.cs b/src/UnitTests/Projection/ConstructorTests.cs
index 377ed150..8e39da25 100644
--- a/src/UnitTests/Projection/ConstructorTests.cs
+++ b/src/UnitTests/Projection/ConstructorTests.cs
@@ -32,7 +32,7 @@ public Dest(int other)
         protected override void Establish_context()
         {
             Mapper.CreateMap<Source, Dest>()
-                .ConstructUsing(src => new Dest(src.Value + 10));
+                .ConstructProjectionUsing(src => new Dest(src.Value + 10));
         }
 
         protected override void Because_of()
