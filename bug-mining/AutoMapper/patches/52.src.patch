diff --git a/src/AutoMapper/ConfigurationStore.cs b/src/AutoMapper/ConfigurationStore.cs
index fde54b98..0e349d16 100644
--- a/src/AutoMapper/ConfigurationStore.cs
+++ b/src/AutoMapper/ConfigurationStore.cs
@@ -97,7 +97,7 @@ public bool DataReaderMapperYieldReturnEnabled
             get { return GetProfile(DefaultProfileName).DataReaderMapperYieldReturnEnabled; }
 	    }
 
-	    public Assembly[] SourceExtensionMethodSearch
+	    public IEnumerable<Assembly> SourceExtensionMethodSearch
 		{
 			get { return GetProfile(DefaultProfileName).SourceExtensionMethodSearch; }
 			set { GetProfile(DefaultProfileName).SourceExtensionMethodSearch = value; }
diff --git a/src/AutoMapper/INamingConvention.cs b/src/AutoMapper/INamingConvention.cs
index 98cb4116..fde9925a 100644
--- a/src/AutoMapper/INamingConvention.cs
+++ b/src/AutoMapper/INamingConvention.cs
@@ -70,7 +70,7 @@ public interface IMappingOptions
         /// <summary>
         /// Assemblies to search for extension methods
         /// </summary>
-	    Assembly[] SourceExtensionMethodSearch { get; set; }
+	    IEnumerable<Assembly> SourceExtensionMethodSearch { get; set; }
 	}
 
 	public class PascalCaseNamingConvention : INamingConvention
diff --git a/src/AutoMapper/Internal/FormatterExpression.cs b/src/AutoMapper/Internal/FormatterExpression.cs
index 4a204973..a0cd14bb 100644
--- a/src/AutoMapper/Internal/FormatterExpression.cs
+++ b/src/AutoMapper/Internal/FormatterExpression.cs
@@ -41,7 +41,7 @@ public FormatterExpression(Func<Type, IValueFormatter> formatterCtor)
         public IEnumerable<AliasedMember> Aliases { get { return _aliases; } }
         public bool ConstructorMappingEnabled { get; set; }
         public bool DataReaderMapperYieldReturnEnabled { get; set; }
-        public Assembly[] SourceExtensionMethodSearch { get; set; }
+        public IEnumerable<Assembly> SourceExtensionMethodSearch { get; set; }
 
         public IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
 		{
diff --git a/src/AutoMapper/Internal/MappingExpression.cs b/src/AutoMapper/Internal/MappingExpression.cs
index f6b9d8f7..057a3aaa 100644
--- a/src/AutoMapper/Internal/MappingExpression.cs
+++ b/src/AutoMapper/Internal/MappingExpression.cs
@@ -4,7 +4,9 @@
 using System.Linq;
 
 namespace AutoMapper
-{
+{
+    using System.Reflection;
+
     public class MappingExpression : IMappingExpression, IMemberConfigurationExpression
     {
         private readonly TypeMap _typeMap;
diff --git a/src/AutoMapper/Internal/TypeMapFactory.cs b/src/AutoMapper/Internal/TypeMapFactory.cs
index 090d3274..f42b7027 100644
--- a/src/AutoMapper/Internal/TypeMapFactory.cs
+++ b/src/AutoMapper/Internal/TypeMapFactory.cs
@@ -16,8 +16,8 @@ public class TypeMapFactory : ITypeMapFactory
 
         public TypeMap CreateTypeMap(Type sourceType, Type destinationType, IMappingOptions options, MemberList memberList)
         {
-            var sourceTypeInfo = GetTypeInfo(sourceType);
-            var destTypeInfo = GetTypeInfo(destinationType);
+            var sourceTypeInfo = GetTypeInfo(sourceType, options.SourceExtensionMethodSearch);
+            var destTypeInfo = GetTypeInfo(destinationType, Enumerable.Empty<Assembly>());
 
             var typeMap = new TypeMap(sourceTypeInfo, destTypeInfo, memberList);
 
@@ -74,9 +74,9 @@ public TypeMap CreateTypeMap(Type sourceType, Type destinationType, IMappingOpti
             return true;
         }
 
-        private static TypeInfo GetTypeInfo(Type type)
+        private static TypeInfo GetTypeInfo(Type type, IEnumerable<Assembly> extensionMethodsToSearch)
         {
-            TypeInfo typeInfo = _typeInfos.GetOrAdd(type, t => new TypeInfo(type));
+            TypeInfo typeInfo = _typeInfos.GetOrAdd(type, t => new TypeInfo(type, extensionMethodsToSearch));
 
             return typeInfo;
         }
@@ -119,7 +119,7 @@ private static TypeInfo GetTypeInfo(Type type)
                         resolvers.AddLast(valueResolver);
 
                         foundMatch = MapDestinationPropertyToSource(resolvers,
-                                                                    GetTypeInfo(valueResolver.GetMemberType()),
+                                                                    GetTypeInfo(valueResolver.GetMemberType(), mappingOptions.SourceExtensionMethodSearch),
                                                                     snippet.Second, mappingOptions);
 
                         if (!foundMatch)
diff --git a/src/AutoMapper/Profile.cs b/src/AutoMapper/Profile.cs
index 309848b4..621911eb 100644
--- a/src/AutoMapper/Profile.cs
+++ b/src/AutoMapper/Profile.cs
@@ -87,7 +87,7 @@ public bool DataReaderMapperYieldReturnEnabled
             get { return _configurator.DataReaderMapperYieldReturnEnabled; }
 	    }
 
-	    public Assembly[] SourceExtensionMethodSearch
+	    public IEnumerable<Assembly> SourceExtensionMethodSearch
 		{
 			get { return GetProfile().SourceExtensionMethodSearch; }
 			set { GetProfile().SourceExtensionMethodSearch = value; }
diff --git a/src/AutoMapper/TypeInfo.cs b/src/AutoMapper/TypeInfo.cs
index 3ee4d929..0bf5d838 100644
--- a/src/AutoMapper/TypeInfo.cs
+++ b/src/AutoMapper/TypeInfo.cs
@@ -16,11 +16,17 @@ public class TypeInfo
         private readonly MemberInfo[] _publicGetters;
         private readonly MemberInfo[] _publicAccessors;
         private readonly MethodInfo[] _publicGetMethods;
-        private readonly ConstructorInfo[] _constructors;
-
-        public Type Type { get; private set; }
-
-        public TypeInfo(Type type)
+        private readonly ConstructorInfo[] _constructors;
+        private readonly MethodInfo[] _extensionMethods;
+
+        public Type Type { get; private set; }
+
+        public TypeInfo(Type type)
+            : this (type, Enumerable.Empty<Assembly>())
+        {
+        }
+        
+        public TypeInfo(Type type, IEnumerable<Assembly> extensionMethodsToSearch)
         {
             Type = type;
         	var publicReadableMembers = GetAllPublicReadableMembers();
@@ -28,7 +34,8 @@ public TypeInfo(Type type)
 			_publicGetters = BuildPublicReadAccessors(publicReadableMembers);
             _publicAccessors = BuildPublicAccessors(publicWritableMembers);
             _publicGetMethods = BuildPublicNoArgMethods();
-            _constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
+            _constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
+            _extensionMethods = BuildPublicNoArgExtensionMethods(extensionMethodsToSearch);
         }
 
         public IEnumerable<ConstructorInfo> GetConstructors()
@@ -51,23 +58,51 @@ public IEnumerable<MethodInfo> GetPublicNoArgMethods()
             return _publicGetMethods;
         }
 
-		public IEnumerable<MethodInfo> GetPublicNoArgExtensionMethods(Assembly[] sourceExtensionMethodSearch)
-		{
-			if (sourceExtensionMethodSearch == null)
-			{
-				return new MethodInfo[] { };
-			}
-
-			//http://stackoverflow.com/questions/299515/c-sharp-reflection-to-identify-extension-methods
-			return sourceExtensionMethodSearch
-				.SelectMany(assembly => assembly.GetTypes())
-				.Where(type => type.IsSealed && !type.IsGenericType && !type.IsNested)
-				.SelectMany(type => type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic))
-				.Where(method => method.IsDefined(typeof(ExtensionAttribute), false))
-				.Where(method => method.GetParameters()[0].ParameterType == this.Type);
-		}
-
-		private MemberInfo[] BuildPublicReadAccessors(IEnumerable<MemberInfo> allMembers)
+		public IEnumerable<MethodInfo> GetPublicNoArgExtensionMethods(IEnumerable<Assembly> sourceExtensionMethodSearch)
+		{
+		    return _extensionMethods;
+		}
+
+        private MethodInfo[] BuildPublicNoArgExtensionMethods(IEnumerable<Assembly> sourceExtensionMethodSearch)
+        {
+            //http://stackoverflow.com/questions/299515/c-sharp-reflection-to-identify-extension-methods
+            var extensionMethods = (sourceExtensionMethodSearch ?? Enumerable.Empty<Assembly>())
+                .Concat(new[] {typeof (Enumerable).Assembly})
+                .SelectMany(assembly => assembly.GetTypes())
+                .Where(type => type.IsSealed && !type.IsGenericType && !type.IsNested)
+                .SelectMany(type => type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic))
+                .Where(method => method.IsDefined(typeof (ExtensionAttribute), false))
+                .Where(method => method.GetParameters().Length == 1)
+                .ToArray();
+
+            var explicitExtensionMethods = extensionMethods
+                .Where(method => method.GetParameters()[0].ParameterType == Type)
+                .ToList();
+
+            var genericInterfaces = Type.GetInterfaces().Where(t => t.IsGenericType).ToList();
+
+            if (Type.IsInterface && Type.IsGenericType)
+                genericInterfaces.Add(Type);
+
+            foreach (var method in extensionMethods
+                .Where(method => method.IsGenericMethodDefinition))
+            {
+                var parameterType = method.GetParameters()[0].ParameterType;
+
+                var interfaceMatch = genericInterfaces
+                    .Where(t => t.GetGenericTypeDefinition().GetGenericArguments().Length == parameterType.GetGenericArguments().Length)
+                    .FirstOrDefault(t => method.MakeGenericMethod(t.GetGenericArguments()).GetParameters()[0].ParameterType.IsAssignableFrom(t));
+
+                if (interfaceMatch != null)
+                {
+                    explicitExtensionMethods.Add(method.MakeGenericMethod(interfaceMatch.GetGenericArguments()));
+                }
+            }
+
+            return explicitExtensionMethods.ToArray();
+        }
+
+        private MemberInfo[] BuildPublicReadAccessors(IEnumerable<MemberInfo> allMembers)
         {
 			// Multiple types may define the same property (e.g. the class and multiple interfaces) - filter this to one of those properties
             var filteredMembers = allMembers
diff --git a/src/UnitTests/ExtensionMethods.cs b/src/UnitTests/ExtensionMethods.cs
index a919bd38..60bea2b6 100644
--- a/src/UnitTests/ExtensionMethods.cs
+++ b/src/UnitTests/ExtensionMethods.cs
@@ -7,7 +7,11 @@ namespace AutoMapper.UnitTests
 {
 	namespace ExtensionMethods
 	{
-		public static class When_extension_method_returns_value_type_SourceExtensions
+	    using System.Collections;
+	    using System.Collections.Generic;
+	    using System.Linq;
+
+	    public static class When_extension_method_returns_value_type_SourceExtensions
 		{
 			public static string GetValue2(this When_extension_method_returns_value_type.Source source) { return "hello from extension"; }
 		}
@@ -102,5 +106,36 @@ public void Should_still_map_value_type()
 				_destination.Value1.ShouldEqual(7);
 			}
 		}
+
+	    public class When_extension_contains_LINQ_methods : AutoMapperSpecBase
+	    {
+	        private Destination _destination;
+
+	        public class Source
+	        {
+	            public IEnumerable<int> Values { get; set; }
+	        }
+
+	        public class Destination
+	        {
+	            public int ValuesCount { get; set; }
+	        }
+
+	        protected override void Establish_context()
+	        {
+	            Mapper.Initialize(cfg => cfg.CreateMap<Source, Destination>());
+	        }
+
+	        protected override void Because_of()
+	        {
+	            _destination = Mapper.Map<Source, Destination>(new Source {Values = Enumerable.Repeat(1, 10)});
+	        }
+
+	        [Fact]
+	        public void Should_resolve_LINQ_method_automatically()
+	        {
+	            _destination.ValuesCount.ShouldEqual(10);
+	        }
+	    }
 	}
 }
\ No newline at end of file
diff --git a/src/UnitTests/Tests/TypeMapFactorySpecs.cs b/src/UnitTests/Tests/TypeMapFactorySpecs.cs
index c206100e..9331287f 100644
--- a/src/UnitTests/Tests/TypeMapFactorySpecs.cs
+++ b/src/UnitTests/Tests/TypeMapFactorySpecs.cs
@@ -7,6 +7,8 @@
 
 namespace AutoMapper.UnitTests.Tests
 {
+    using Assembly = System.Reflection.Assembly;
+
     public class StubNamingConvention : INamingConvention
     {
         public Regex SplittingExpression { get; set; }
@@ -29,7 +31,7 @@ public class StubMappingOptions : IMappingOptions
 
         private IEnumerable<AliasedMember> _aliases = new List<AliasedMember>();
 
-        private System.Reflection.Assembly[] _sourceExtensionMethodSearch = null;
+        private IEnumerable<Assembly> _sourceExtensionMethodSearch = null;
 
         public INamingConvention SourceMemberNamingConvention
         {
@@ -78,7 +80,7 @@ public bool DataReaderMapperYieldReturnEnabled
             get { return false; }
         }
 
-        public System.Reflection.Assembly[] SourceExtensionMethodSearch
+        public IEnumerable<Assembly> SourceExtensionMethodSearch
         {
             get { return _sourceExtensionMethodSearch; }
             set { _sourceExtensionMethodSearch = value; }
