diff --git a/src/AutoMapper/ConstructorMap.cs b/src/AutoMapper/ConstructorMap.cs
index 0b8a7d58..36ef6b46 100644
--- a/src/AutoMapper/ConstructorMap.cs
+++ b/src/AutoMapper/ConstructorMap.cs
@@ -1,48 +1,48 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Reflection;
-using AutoMapper.Internal;
-
-namespace AutoMapper
-{
-    public class ConstructorMap
-    {
-        private static readonly IDelegateFactory DelegateFactory = PlatformAdapter.Resolve<IDelegateFactory>();
-        private readonly LateBoundParamsCtor _runtimeCtor;
-        public ConstructorInfo Ctor { get; private set; }
-        public IEnumerable<ConstructorParameterMap> CtorParams { get; private set; }
-
-        public ConstructorMap(ConstructorInfo ctor, IEnumerable<ConstructorParameterMap> ctorParams)
-        {
-            Ctor = ctor;
-            CtorParams = ctorParams;
-
-            _runtimeCtor = DelegateFactory.CreateCtor(ctor, CtorParams);
-        }
-
-        public object ResolveValue(ResolutionContext context, IMappingEngineRunner mappingEngine)
-        {
-            var ctorArgs = new List<object>();
-
-            foreach (var map in CtorParams)
-            {
-                var result = map.ResolveValue(context);
-
-                var sourceType = result.Type;
-                var destinationType = map.Parameter.ParameterType;
-
-                var typeMap = mappingEngine.ConfigurationProvider.FindTypeMapFor(result, destinationType);
-
-                Type targetSourceType = typeMap != null ? typeMap.SourceType : sourceType;
-
-                var newContext = context.CreateTypeContext(typeMap, result.Value, targetSourceType, destinationType);
-
-                var value = mappingEngine.Map(newContext);
-
-                ctorArgs.Add(value);
-            }
-
-            return _runtimeCtor(ctorArgs.ToArray());
-        }
-    }
+﻿using System;
+using System.Collections.Generic;
+using System.Reflection;
+using AutoMapper.Internal;
+
+namespace AutoMapper
+{
+    public class ConstructorMap
+    {
+        private static readonly IDelegateFactory DelegateFactory = PlatformAdapter.Resolve<IDelegateFactory>();
+        private readonly LateBoundParamsCtor _runtimeCtor;
+        public ConstructorInfo Ctor { get; private set; }
+        public IEnumerable<ConstructorParameterMap> CtorParams { get; private set; }
+
+        public ConstructorMap(ConstructorInfo ctor, IEnumerable<ConstructorParameterMap> ctorParams)
+        {
+            Ctor = ctor;
+            CtorParams = ctorParams;
+
+            _runtimeCtor = DelegateFactory.CreateCtor(ctor, CtorParams);
+        }
+
+        public object ResolveValue(ResolutionContext context, IMappingEngineRunner mappingEngine)
+        {
+            var ctorArgs = new List<object>();
+
+            foreach (var map in CtorParams)
+            {
+                var result = map.ResolveValue(context);
+
+                var sourceType = result.Type;
+                var destinationType = map.Parameter.ParameterType;
+
+                var typeMap = mappingEngine.ConfigurationProvider.FindTypeMapFor(result, destinationType);
+
+                Type targetSourceType = typeMap != null ? typeMap.SourceType : sourceType;
+
+                var newContext = context.CreateTypeContext(typeMap, result.Value, null, targetSourceType, destinationType);
+
+                var value = mappingEngine.Map(newContext);
+
+                ctorArgs.Add(value);
+            }
+
+            return _runtimeCtor(ctorArgs.ToArray());
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/AutoMapper/Internal/TypeMapFactory.cs b/src/AutoMapper/Internal/TypeMapFactory.cs
index be3f3846..090d3274 100644
--- a/src/AutoMapper/Internal/TypeMapFactory.cs
+++ b/src/AutoMapper/Internal/TypeMapFactory.cs
@@ -52,7 +52,7 @@ public TypeMap CreateTypeMap(Type sourceType, Type destinationType, IMappingOpti
             var parameters = new List<ConstructorParameterMap>();
             var ctorParameters = destCtor.GetParameters();
 
-            if (ctorParameters.Length > 0 && !options.ConstructorMappingEnabled)
+            if (ctorParameters.Length == 0 || !options.ConstructorMappingEnabled)
                 return false;
 
             foreach (var parameter in ctorParameters)
diff --git a/src/AutoMapper/MappingEngine.cs b/src/AutoMapper/MappingEngine.cs
index 73e08812..8b1c0266 100644
--- a/src/AutoMapper/MappingEngine.cs
+++ b/src/AutoMapper/MappingEngine.cs
@@ -186,7 +186,7 @@ public void DynamicMap(object source, object destination, Type sourceType, Type
             Type destinationType = typeof(TDestination);
             Type sourceType = typeof(TSource);
             TypeMap typeMap = ConfigurationProvider.FindTypeMapFor(source, null, sourceType, destinationType);
-            var context = parentContext.CreateTypeContext(typeMap, source, sourceType, destinationType);
+            var context = parentContext.CreateTypeContext(typeMap, source, null, sourceType, destinationType);
             return (TDestination)((IMappingEngineRunner)this).Map(context);
         }
 
@@ -206,7 +206,7 @@ object IMappingEngineRunner.Map(ResolutionContext context)
                     {
                         var typeMap = ConfigurationProvider.CreateTypeMap(context.SourceType, context.DestinationType);
 
-                        context = context.CreateTypeContext(typeMap, context.SourceValue, context.SourceType, context.DestinationType);
+                        context = context.CreateTypeContext(typeMap, context.SourceValue, context.DestinationValue, context.SourceType, context.DestinationType);
 
                         mapperToUse = _objectMapperCache.GetOrAdd(contextTypePair, missFunc);
                     }
diff --git a/src/AutoMapper/ResolutionContext.cs b/src/AutoMapper/ResolutionContext.cs
index 7f346075..cb2f36b2 100644
--- a/src/AutoMapper/ResolutionContext.cs
+++ b/src/AutoMapper/ResolutionContext.cs
@@ -115,10 +115,11 @@ private ResolutionContext(ResolutionContext context, object sourceValue, Type so
             Options = context.Options;
         }
 
-        private ResolutionContext(ResolutionContext context, TypeMap memberTypeMap, object sourceValue, Type sourceType, Type destinationType)
+        private ResolutionContext(ResolutionContext context, TypeMap memberTypeMap, object sourceValue, object destinationValue, Type sourceType, Type destinationType)
         {
             TypeMap = memberTypeMap;
             SourceValue = sourceValue;
+            DestinationValue = destinationValue;
             Parent = context;
             AssignTypes(memberTypeMap, sourceType, destinationType);
             InstanceCache = context.InstanceCache;
@@ -189,9 +190,9 @@ public ResolutionContext CreateValueContext(object sourceValue, Type sourceType)
 			return new ResolutionContext(this, sourceValue, sourceType);
 		}
 
-        public ResolutionContext CreateTypeContext(TypeMap memberTypeMap, object sourceValue, Type sourceType, Type destinationType)
+        public ResolutionContext CreateTypeContext(TypeMap memberTypeMap, object sourceValue, object destinationValue, Type sourceType, Type destinationType)
         {
-            return new ResolutionContext(this, memberTypeMap, sourceValue, sourceType, destinationType);
+            return new ResolutionContext(this, memberTypeMap, sourceValue, destinationValue, sourceType, destinationType);
         }
 
         public ResolutionContext CreatePropertyMapContext(PropertyMap propertyMap)
diff --git a/src/UnitTests/Bug/DestinationCtorCalledTwice.cs b/src/UnitTests/Bug/DestinationCtorCalledTwice.cs
new file mode 100644
index 00000000..8e0265ed
--- /dev/null
+++ b/src/UnitTests/Bug/DestinationCtorCalledTwice.cs
@@ -0,0 +1,49 @@
+﻿using Xunit;
+using Should;
+
+namespace AutoMapper.UnitTests.Bug
+{
+    namespace DestinationCtorCalledTwice
+    {
+        public class Bug : AutoMapperSpecBase
+        {
+            public class Source
+            {
+                public int Value { get; set; }
+            }
+            public class Destination
+            {
+                private static int _callCount = 0;
+                
+                public Destination()
+                {
+                    _callCount++;
+                }
+
+                public int Value { get; set; }
+                public static int CallCount { get { return _callCount; } }
+
+                public static void Reset()
+                {
+                    _callCount = 0;
+                }
+            }
+
+            public Bug()
+            {
+                Destination.Reset();
+            }
+
+            [Fact]
+            public void Should_call_ctor_once()
+            {
+                var source = new Source {Value = 5};
+                var dest = new Destination {Value = 7};
+
+                Mapper.Map(source, dest, opt => opt.CreateMissingTypeMaps = true);
+
+                Destination.CallCount.ShouldEqual(1);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/UnitTests/UnitTests.Net4.csproj b/src/UnitTests/UnitTests.Net4.csproj
index 0a2204c6..2173eb0f 100644
--- a/src/UnitTests/UnitTests.Net4.csproj
+++ b/src/UnitTests/UnitTests.Net4.csproj
@@ -90,6 +90,7 @@
     <Compile Include="Bug\CannotConvertEnumToNullable.cs" />
     <Compile Include="Bug\ConditionBug.cs" />
     <Compile Include="Bug\ContextValuesIncorrect.cs" />
+    <Compile Include="Bug\DestinationCtorCalledTwice.cs" />
     <Compile Include="Bug\DestinationValueInitializedByCtorBug.cs" />
     <Compile Include="Bug\CreateMapExpressionWithIgnoredPropertyBug.cs" />
     <Compile Include="Bug\CollectionMapperMapsISetIncorrectly.cs" />
