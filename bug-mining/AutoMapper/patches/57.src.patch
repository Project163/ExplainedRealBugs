diff --git a/src/AutoMapper/IMappingExpression.cs b/src/AutoMapper/IMappingExpression.cs
index f4e8c111..540e7e9e 100644
--- a/src/AutoMapper/IMappingExpression.cs
+++ b/src/AutoMapper/IMappingExpression.cs
@@ -305,6 +305,14 @@ public interface IMemberConfigurationExpression<TSource>
         /// <param name="resolver">Callback function to resolve against source type</param>
         void ResolveUsing(Func<TSource, object> resolver);
 
+        /// <summary>
+        /// Resolve destination member using a custom value resolver callback. Used instead of MapFrom when not simply redirecting a source member
+        /// Access both the source object and current resolution context for additional mapping, context items and parent objects
+        /// This method cannot be used in conjunction with LINQ query projection
+        /// </summary>
+        /// <param name="resolver">Callback function to resolve against source type</param>
+        void ResolveUsing(Func<ResolutionResult, object> resolver);
+
         /// <summary>
         /// Specify the source member to map from. Can only reference a member on the <typeparamref name="TSource"/> type
         /// This method can be used in mapping to LINQ query projections, while ResolveUsing cannot.
diff --git a/src/AutoMapper/Internal/DelegateBasedResolver.cs b/src/AutoMapper/Internal/DelegateBasedResolver.cs
index b0370492..9e0d14af 100644
--- a/src/AutoMapper/Internal/DelegateBasedResolver.cs
+++ b/src/AutoMapper/Internal/DelegateBasedResolver.cs
@@ -4,9 +4,9 @@ namespace AutoMapper
 
 	public class DelegateBasedResolver<TSource> : IValueResolver
 	{
-		private readonly Func<TSource, object> _method;
+        private readonly Func<ResolutionResult, object> _method;
 
-		public DelegateBasedResolver(Func<TSource, object> method)
+        public DelegateBasedResolver(Func<ResolutionResult, object> method)
 		{
 			_method = method;
 		}
@@ -19,7 +19,7 @@ public ResolutionResult Resolve(ResolutionResult source)
                                             source.Value.GetType());
 			}
 
-            var result = _method((TSource) source.Value);
+            var result = _method(source);
 
 			return source.New(result);
 		}
diff --git a/src/AutoMapper/Internal/DelegateBasedResolver2.cs b/src/AutoMapper/Internal/DelegateBasedResolver2.cs
index 0733f557..f2269c8d 100644
--- a/src/AutoMapper/Internal/DelegateBasedResolver2.cs
+++ b/src/AutoMapper/Internal/DelegateBasedResolver2.cs
@@ -1,31 +1,32 @@
-using System;
-
 namespace AutoMapper
 {
-	public class DelegateBasedResolver<TSource, TMember> : IMemberResolver
-	{
-		private readonly Func<TSource, TMember> _method;
+    using System;
+
+    public class DelegateBasedResolver<TSource, TMember> : IMemberResolver
+    {
+        private readonly Func<TSource, TMember> _method;
 
-		public DelegateBasedResolver(Func<TSource, TMember> method)
-		{
-			_method = method;
-		}
+        public DelegateBasedResolver(Func<TSource, TMember> method)
+        {
+            _method = method;
+        }
 
-		public ResolutionResult Resolve(ResolutionResult source)
-		{
+        public ResolutionResult Resolve(ResolutionResult source)
+        {
             if (source.Value != null && !(source.Value is TSource))
-			{
-				throw new ArgumentException("Expected obj to be of type " + typeof(TSource) + " but was " + source.Value.GetType());
-			}
+            {
+                throw new ArgumentException("Expected obj to be of type " + typeof (TSource) + " but was " +
+                                            source.Value.GetType());
+            }
+
+            var result = _method((TSource) source.Value);
 
-			    var result = _method((TSource)source.Value);
-			    
-                return source.New(result, MemberType);
-			}
+            return source.New(result, MemberType);
+        }
 
-		public Type MemberType
-		{
-            get { return typeof(TMember); }
-		}
-	}
-}
+        public Type MemberType
+        {
+            get { return typeof (TMember); }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/AutoMapper/Internal/MappingExpression.cs b/src/AutoMapper/Internal/MappingExpression.cs
index d2187e73..bb011ab6 100644
--- a/src/AutoMapper/Internal/MappingExpression.cs
+++ b/src/AutoMapper/Internal/MappingExpression.cs
@@ -275,6 +275,11 @@ public IResolutionExpression<TSource> ResolveUsing(IValueResolver valueResolver)
 
         public void ResolveUsing(Func<TSource, object> resolver)
         {
+            _propertyMap.AssignCustomValueResolver(new DelegateBasedResolver<TSource>(r => resolver((TSource)r.Value)));
+        }
+
+        public void ResolveUsing(Func<ResolutionResult, object> resolver)
+        {
             _propertyMap.AssignCustomValueResolver(new DelegateBasedResolver<TSource>(resolver));
         }
 
diff --git a/src/AutoMapper/Internal/ResolutionExpression.cs b/src/AutoMapper/Internal/ResolutionExpression.cs
index 398b246c..36d4c6eb 100644
--- a/src/AutoMapper/Internal/ResolutionExpression.cs
+++ b/src/AutoMapper/Internal/ResolutionExpression.cs
@@ -22,7 +22,8 @@ public void FromMember(Expression<Func<TSource, object>> sourceMember)
             {
                 _propertyMap.SourceMember = (sourceMember.Body as MemberExpression).Member;
             }
-            _propertyMap.ChainTypeMemberForResolver(new DelegateBasedResolver<TSource>(sourceMember.Compile()));
+	        var func = sourceMember.Compile();
+            _propertyMap.ChainTypeMemberForResolver(new DelegateBasedResolver<TSource>(r => func((TSource) r.Value)));
 		}
 
 		public void FromMember(string sourcePropertyName)
@@ -65,7 +66,8 @@ public ResolutionExpression(PropertyMap propertyMap)
             {
                 _propertyMap.SourceMember = ((MemberExpression) sourceMember.Body).Member;
             }
-            _propertyMap.ChainTypeMemberForResolver(new DelegateBasedResolver<TSource>(sourceMember.Compile()));
+            var func = sourceMember.Compile();
+            _propertyMap.ChainTypeMemberForResolver(new DelegateBasedResolver<TSource>(r => func((TSource)r.Value)));
 
 			return this;
 		}
diff --git a/src/UnitTests/ConditionalMapping.cs b/src/UnitTests/ConditionalMapping.cs
index 3f9c68e0..57a2d5f6 100644
--- a/src/UnitTests/ConditionalMapping.cs
+++ b/src/UnitTests/ConditionalMapping.cs
@@ -66,7 +66,7 @@ protected override void Establish_context()
                         .ForMember(dest => dest.Value, opt =>
                         {
                             opt.Condition(src => src.Value > 0);
-                            opt.ResolveUsing(src =>
+                            opt.ResolveUsing((Source src) =>
                             {
                                 return 10;
                             });
diff --git a/src/UnitTests/ContextItems.cs b/src/UnitTests/ContextItems.cs
index c94cc407..6d060a20 100644
--- a/src/UnitTests/ContextItems.cs
+++ b/src/UnitTests/ContextItems.cs
@@ -41,5 +41,42 @@ public void Should_use_value_passed_in()
                 dest.Value.ShouldEqual(15);
             }
         }
+
+        public class When_mapping_with_contextual_values_in_resolve_func : AutoMapperSpecBase
+        {
+            private Dest _dest;
+
+            public class Source
+            {
+                public int Value1 { get; set; }
+            }
+
+            public class Dest
+            {
+                public int Value1 { get; set; }
+            }
+
+            public class ContextResolver : IValueResolver
+            {
+                public ResolutionResult Resolve(ResolutionResult source)
+                {
+                    return source.New((int) source.Value + (int)source.Context.Options.Items["Item"]);
+                }
+            }
+
+            [Fact]
+            public void Should_use_value_passed_in()
+            {
+                Mapper.Initialize(cfg =>
+                {
+                    cfg.CreateMap<Source, Dest>()
+                        .ForMember(d => d.Value1, opt => opt.ResolveUsing(result => (int)result.Context.Options.Items["Item"] + ((Source)result.Value).Value1));
+                });
+
+                var dest = Mapper.Map<Source, Dest>(new Source { Value1 = 5 }, opt => { opt.Items["Item"] = 10; });
+
+                dest.Value1.ShouldEqual(15);
+            }
+        }
     }
 }
\ No newline at end of file
