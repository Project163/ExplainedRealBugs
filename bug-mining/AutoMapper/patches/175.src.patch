diff --git a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
index 3e257c12..8ee4157e 100644
--- a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
+++ b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
@@ -118,11 +118,9 @@ private Expression CreateDestinationFunc(out bool constructorMapping)
             if(_typeMap.PreserveReferences)
             {
                 var dest = Variable(typeof(object), "dest");
-
-                Expression valueBag = Property(_context, "InstanceCache");
-                var set = Assign(Property(valueBag, "Item", _source), dest);
-                var setCache =
-                    IfThen(NotEqual(_source, Constant(null)), set);
+                var setValue = _context.Type.GetDeclaredMethod("CacheDestination");
+                var set = Call(_context, setValue, _source, Constant(_destination.Type), _destination);
+                var setCache = IfThen(NotEqual(_source, Constant(null)), set);
 
                 destinationFunc = Block(new[] { dest }, Assign(dest, destinationFunc), setCache, dest);
             }
@@ -203,13 +201,14 @@ private Expression CreateMapperFunc(Expression assignmentFunc)
             if(_typeMap.PreserveReferences)
             {
                 var cache = Variable(_typeMap.DestinationTypeToUse, "cachedDestination");
-
+                var hasDestination = _context.Type.GetDeclaredMethod("HasDestination");
+                var getDestination = _context.Type.GetDeclaredMethod("GetDestination");
                 var condition = Condition(
                     AndAlso(
                         NotEqual(_source, Constant(null)),
-                        Call(Property(_context, "InstanceCache"), typeof(Dictionary<object, object>).GetDeclaredMethod("ContainsKey"), _source)),
+                        Call(_context, hasDestination, _source, Constant(_destination.Type))),
                     Assign(cache,
-                        ToType(Property(Property(_context, "InstanceCache"), "Item", _source), _typeMap.DestinationTypeToUse)),
+                        ToType(Call(_context, getDestination, _source, Constant(_destination.Type)), _destination.Type)),
                     Assign(cache, mapperFunc)
                     );
 
diff --git a/src/AutoMapper/ResolutionContext.cs b/src/AutoMapper/ResolutionContext.cs
index 1bceca85..ef1b7986 100644
--- a/src/AutoMapper/ResolutionContext.cs
+++ b/src/AutoMapper/ResolutionContext.cs
@@ -10,7 +10,7 @@ namespace AutoMapper
     /// </summary>
     public class ResolutionContext
     {
-        private Dictionary<object, object> _instanceCache;
+        private Dictionary<SourceDestinationType, object> _instanceCache;
         private Dictionary<TypePair, int> _typeDepth;
 
         /// <summary>
@@ -18,10 +18,25 @@ public class ResolutionContext
         /// </summary>
         public IMappingOperationOptions Options { get; }
 
+        internal bool HasDestination(object source, Type destinationType)
+        {
+            return InstanceCache.ContainsKey(new SourceDestinationType(source, destinationType));
+        }
+
+        internal object GetDestination(object source, Type destinationType)
+        {
+            return InstanceCache[new SourceDestinationType(source, destinationType)];
+        }
+
+        internal void CacheDestination(object source, Type destinationType, object destination)
+        {
+            InstanceCache.Add(new SourceDestinationType(source, destinationType), destination);
+        }
+
         /// <summary>
         /// Instance cache for resolving circular references
         /// </summary>
-        public Dictionary<object, object> InstanceCache
+        public Dictionary<SourceDestinationType, object> InstanceCache
         {
             get
             {
@@ -30,7 +45,7 @@ public class ResolutionContext
                 {
                     return _instanceCache;
                 }
-                _instanceCache = new Dictionary<object, object>();
+                _instanceCache = new Dictionary<SourceDestinationType, object>();
                 return _instanceCache;
             }
         }
@@ -112,5 +127,29 @@ internal object Map(object source, object destination, Type sourceType, Type des
         {
             return Mapper.Map(source, destination, sourceType, destinationType, this);
         }
+    }
+
+    public struct SourceDestinationType : IEquatable<SourceDestinationType>
+    {
+        private readonly int _hashCode;
+        private readonly object _source;
+        private readonly Type _destinationType;
+
+        public SourceDestinationType(object source, Type destinationType)
+        {
+            _source = source;
+            _destinationType = destinationType;
+            _hashCode = (_source.GetHashCode() * 397) ^ _destinationType.GetHashCode();
+        }
+
+        public override int GetHashCode()
+        {
+            return _hashCode;
+        }
+
+        public bool Equals(SourceDestinationType other)
+        {
+            return ReferenceEquals(_source, other._source) && _destinationType == other._destinationType;
+        }
     }
 }
\ No newline at end of file
diff --git a/src/UnitTests/Bug/OneSourceWithMultipleDestinationsAndPreserveReferences.cs b/src/UnitTests/Bug/OneSourceWithMultipleDestinationsAndPreserveReferences.cs
new file mode 100644
index 00000000..52d88a5a
--- /dev/null
+++ b/src/UnitTests/Bug/OneSourceWithMultipleDestinationsAndPreserveReferences.cs
@@ -0,0 +1,43 @@
+ï»¿using Xunit;
+using Should;
+
+namespace AutoMapper.UnitTests.Bug
+{
+    public class OneSourceWithMultipleDestinationsAndPreserveReferences : AutoMapperSpecBase
+    {
+        ClientModel _destination;
+
+        public partial class Client
+        {
+            public string Address1 { get; set; }
+        }
+        public class AddressModel
+        {
+            public string Address1 { get; set; }
+        }
+        public class ClientModel
+        {
+            public AddressModel Address { get; set; }
+        }
+
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(mapConfig =>
+        {
+            mapConfig.CreateMap<Client, ClientModel>()
+                .ForMember(m => m.Address, opt => opt.MapFrom(x => x))
+                .PreserveReferences();
+            mapConfig.CreateMap<Client, AddressModel>()
+                .PreserveReferences();
+        });
+
+        protected override void Because_of()
+        {
+            _destination = Mapper.Map<ClientModel>(new Client { Address1 = "abc" });
+        }
+
+        [Fact]
+        public void Should_map_ok()
+        {
+            _destination.Address.Address1.ShouldEqual("abc");
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/UnitTests/UnitTests.Net4.csproj b/src/UnitTests/UnitTests.Net4.csproj
index 8421f622..6e8a85df 100644
--- a/src/UnitTests/UnitTests.Net4.csproj
+++ b/src/UnitTests/UnitTests.Net4.csproj
@@ -93,6 +93,7 @@
     <Compile Include="AssertionExtensions.cs" />
     <Compile Include="BasicFlattening.cs" />
     <Compile Include="Bug\CannotProjectStringToNullableEnum.cs" />
+    <Compile Include="Bug\OneSourceWithMultipleDestinationsAndPreserveReferences.cs" />
     <Compile Include="Bug\ConventionCreateMapsWithCircularReference.cs" />
     <Compile Include="Bug\ConvertMapperThreading.cs" />
     <Compile Include="Bug\DeepCloningBug.cs" />
