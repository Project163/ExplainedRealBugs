diff --git a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
index 2ceff617..f0a1c272 100644
--- a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
+++ b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
@@ -1,68 +1,68 @@
-using System;
-using System.Collections.Generic;
-
-namespace AutoMapper.Mappers
-{
-	public class TypeMapObjectMapperRegistry
-	{
-		public static Func<IEnumerable<ITypeMapObjectMapper>> AllMappers =
-			() => new ITypeMapObjectMapper[]
-            {
-                new CustomMapperStrategy(),
-                new NullMappingStrategy(),
-                new CacheMappingStrategy(),
-                new NewObjectPropertyMapMappingStrategy(),
-                new ExistingObjectMappingStrategy()
-            };
-
-		private class CustomMapperStrategy : ITypeMapObjectMapper
-		{
-			public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				return context.TypeMap.CustomMapper(context);
-			}
-
-			public bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				return context.TypeMap.CustomMapper != null;
-			}
-		}
-
-		private class NullMappingStrategy : ITypeMapObjectMapper
-		{
-			public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				return null;
-			}
-
-			public bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				var profileConfiguration = mapper.ConfigurationProvider.GetProfileConfiguration(context.TypeMap.Profile);
-				return (context.SourceValue == null && profileConfiguration.MapNullSourceValuesAsNull);
-			}
-		}
-
-		private class CacheMappingStrategy : ITypeMapObjectMapper
-		{
-			public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				return context.InstanceCache[context];
-			}
-
-			public bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				return context.DestinationValue == null && context.InstanceCache.ContainsKey(context);
-			}
-		}
-
-		private abstract class PropertyMapMappingStrategy : ITypeMapObjectMapper
-		{
-			public object Map(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				var mappedObject = GetMappedObject(context, mapper);
-				if (context.SourceValue != null)
-					context.InstanceCache.Add(context, mappedObject);
-
+using System;
+using System.Collections.Generic;
+
+namespace AutoMapper.Mappers
+{
+	public class TypeMapObjectMapperRegistry
+	{
+		public static Func<IEnumerable<ITypeMapObjectMapper>> AllMappers =
+			() => new ITypeMapObjectMapper[]
+            {
+                new CustomMapperStrategy(),
+                new NullMappingStrategy(),
+                new CacheMappingStrategy(),
+                new NewObjectPropertyMapMappingStrategy(),
+                new ExistingObjectMappingStrategy()
+            };
+
+		private class CustomMapperStrategy : ITypeMapObjectMapper
+		{
+			public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				return context.TypeMap.CustomMapper(context);
+			}
+
+			public bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				return context.TypeMap.CustomMapper != null;
+			}
+		}
+
+		private class NullMappingStrategy : ITypeMapObjectMapper
+		{
+			public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				return null;
+			}
+
+			public bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				var profileConfiguration = mapper.ConfigurationProvider.GetProfileConfiguration(context.TypeMap.Profile);
+				return (context.SourceValue == null && profileConfiguration.MapNullSourceValuesAsNull);
+			}
+		}
+
+		private class CacheMappingStrategy : ITypeMapObjectMapper
+		{
+			public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				return context.InstanceCache[context];
+			}
+
+			public bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				return context.DestinationValue == null && context.InstanceCache.ContainsKey(context);
+			}
+		}
+
+		private abstract class PropertyMapMappingStrategy : ITypeMapObjectMapper
+		{
+			public object Map(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				var mappedObject = GetMappedObject(context, mapper);
+				if (context.SourceValue != null)
+					context.InstanceCache.Add(context, mappedObject);
+
 				context.TypeMap.BeforeMap(context.SourceValue, mappedObject);
 
                 foreach (PropertyMap propertyMap in context.TypeMap.GetPropertyMaps())
@@ -73,117 +73,124 @@ public object Map(ResolutionContext context, IMappingEngineRunner mapper)
 
                 context.TypeMap.AfterMap(context.SourceValue, mappedObject);
 
-                return mappedObject;
-			}
-
-			protected virtual object ReassignValue(ResolutionContext context, object o)
-			{
-				return o;
-			}
-
-			public abstract bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper);
-
-			protected abstract object GetMappedObject(ResolutionContext context, IMappingEngineRunner mapper);
-
-			private void MapPropertyValue(ResolutionContext context, IMappingEngineRunner mapper, object mappedObject, PropertyMap propertyMap)
-			{
-				if (propertyMap.CanResolveValue())
+                return mappedObject;
+			}
+
+			protected virtual object ReassignValue(ResolutionContext context, object o)
+			{
+				return o;
+			}
+
+			public abstract bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper);
+
+			protected abstract object GetMappedObject(ResolutionContext context, IMappingEngineRunner mapper);
+
+			private void MapPropertyValue(ResolutionContext context, IMappingEngineRunner mapper, object mappedObject, PropertyMap propertyMap)
+			{
+				if (propertyMap.CanResolveValue())
                 {
-                    ResolutionResult result;
-
-					try
-					{
-						result = propertyMap.ResolveValue(context);
+                    ResolutionResult result;
+
+                    Exception resolvingExc = null;
+					try
+					{
+						result = propertyMap.ResolveValue(context);
 					}
                     catch (AutoMapperMappingException)
                     {
                         throw;
                     }
-                    catch (Exception ex)
-					{
-						var errorContext = CreateErrorContext(context, propertyMap, null);
-						throw new AutoMapperMappingException(errorContext, ex);
-					}
-
-                    if (result.ShouldIgnore) 
-                        return;
-
-					object destinationValue = propertyMap.DestinationProperty.GetValue(mappedObject);
-
-					var sourceType = result.Type;
-					var destinationType = propertyMap.DestinationProperty.MemberType;
-
-					var typeMap = mapper.ConfigurationProvider.FindTypeMapFor(result, destinationType);
-
-					Type targetSourceType = typeMap != null ? typeMap.SourceType : sourceType;
-
-					var newContext = context.CreateMemberContext(typeMap, result.Value, destinationValue, targetSourceType,
+                    catch (Exception ex)
+					{
+						var errorContext = CreateErrorContext(context, propertyMap, null);
+						resolvingExc = new AutoMapperMappingException(errorContext, ex);
+
+                        result = new ResolutionResult(context);
+					}
+
+                    if (result.ShouldIgnore) 
+                        return;
+
+					object destinationValue = propertyMap.DestinationProperty.GetValue(mappedObject);
+
+					var sourceType = result.Type;
+					var destinationType = propertyMap.DestinationProperty.MemberType;
+
+					var typeMap = mapper.ConfigurationProvider.FindTypeMapFor(result, destinationType);
+
+					Type targetSourceType = typeMap != null ? typeMap.SourceType : sourceType;
+
+					var newContext = context.CreateMemberContext(typeMap, result.Value, destinationValue, targetSourceType,
 																 propertyMap);
 
                     if (!propertyMap.ShouldAssignValue(newContext))
                         return;
 
-                    try
-					{
-						object propertyValueToAssign = mapper.Map(newContext);
-
-						AssignValue(propertyMap, mappedObject, propertyValueToAssign);
-					}
+                    // If condition succeeded and resolving failed, throw
+                    if (resolvingExc != null)
+                        throw resolvingExc;
+
+                    try
+					{
+						object propertyValueToAssign = mapper.Map(newContext);
+
+						AssignValue(propertyMap, mappedObject, propertyValueToAssign);
+					}
                     catch (AutoMapperMappingException)
                     {
                         throw;
-                    }
-					catch (Exception ex)
-					{
-						throw new AutoMapperMappingException(newContext, ex);
-					}
-				}
-			}
-
-			protected virtual void AssignValue(PropertyMap propertyMap, object mappedObject, object propertyValueToAssign)
-			{
-				if (!propertyMap.UseDestinationValue && propertyMap.CanBeSet)
-					propertyMap.DestinationProperty.SetValue(mappedObject, propertyValueToAssign);
-			}
-
-			private ResolutionContext CreateErrorContext(ResolutionContext context, PropertyMap propertyMap, object destinationValue)
-			{
-				return context.CreateMemberContext(
-					null,
-					context.SourceValue,
-					destinationValue,
-					context.SourceValue == null
-						? typeof(object)
-						: context.SourceValue.GetType(),
-					propertyMap);
-			}
-
-		}
-
-		private class NewObjectPropertyMapMappingStrategy : PropertyMapMappingStrategy
-		{
-			public override bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				return context.DestinationValue == null;
-			}
-
-			protected override object GetMappedObject(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				return mapper.CreateObject(context);
-			}
-		}
-
-		private class ExistingObjectMappingStrategy : PropertyMapMappingStrategy
-		{
-			public override bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				return true;
-			}
-
-			protected override object GetMappedObject(ResolutionContext context, IMappingEngineRunner mapper)
-			{
-				return context.DestinationValue;
-			}
-		}
-	}
+                    }
+					catch (Exception ex)
+					{
+						throw new AutoMapperMappingException(newContext, ex);
+					}
+				}
+			}
+
+			protected virtual void AssignValue(PropertyMap propertyMap, object mappedObject, object propertyValueToAssign)
+			{
+				if (!propertyMap.UseDestinationValue && propertyMap.CanBeSet)
+					propertyMap.DestinationProperty.SetValue(mappedObject, propertyValueToAssign);
+			}
+
+			private ResolutionContext CreateErrorContext(ResolutionContext context, PropertyMap propertyMap, object destinationValue)
+			{
+				return context.CreateMemberContext(
+					null,
+					context.SourceValue,
+					destinationValue,
+					context.SourceValue == null
+						? typeof(object)
+						: context.SourceValue.GetType(),
+					propertyMap);
+			}
+
+		}
+
+		private class NewObjectPropertyMapMappingStrategy : PropertyMapMappingStrategy
+		{
+			public override bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				return context.DestinationValue == null;
+			}
+
+			protected override object GetMappedObject(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				return mapper.CreateObject(context);
+			}
+		}
+
+		private class ExistingObjectMappingStrategy : PropertyMapMappingStrategy
+		{
+			public override bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				return true;
+			}
+
+			protected override object GetMappedObject(ResolutionContext context, IMappingEngineRunner mapper)
+			{
+				return context.DestinationValue;
+			}
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/UnitTests/Bug/ConditionBug.cs b/src/UnitTests/Bug/ConditionBug.cs
new file mode 100644
index 00000000..769b87d7
--- /dev/null
+++ b/src/UnitTests/Bug/ConditionBug.cs
@@ -0,0 +1,63 @@
+ï»¿using NUnit.Framework;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using Should;
+
+namespace AutoMapper.UnitTests.Bug
+{
+    namespace ConditionBug
+    {
+        [TestFixture]
+        public class Example : AutoMapperSpecBase
+        {
+            public class SubSource
+            {
+                public string SubValue { get; set; }
+            }
+
+            public class Source
+            {
+                public Source() { Value = new List<SubSource>(); }
+                public List<SubSource> Value { get; set; }
+            }
+
+            public class Destination
+            {
+                public string Value { get; set; }
+            }
+
+            protected override void Establish_context()
+            {
+                Mapper.Initialize(cfg => cfg.CreateMap<Source, Destination>()
+                                             .ForMember(dest => dest.Value, opt =>
+                                             {
+                                                 opt.Condition(src => src.Value.Count > 1);
+                                                 opt.ResolveUsing(src => src.Value[1].SubValue);
+                                             }));
+            }
+
+            [Test]
+            public void Should_skip_the_mapping_when_the_condition_is_false()
+            {
+                var src = new Source();
+                src.Value.Add(new SubSource { SubValue = "x" });
+                var destination = Mapper.Map<Source, Destination>(src);
+
+                destination.Value.ShouldBeNull();
+            }
+
+            [Test]
+            public void Should_execute_the_mapping_when_the_condition_is_true()
+            {
+                var src = new Source();
+                src.Value.Add(new SubSource { SubValue = "x" });
+                src.Value.Add(new SubSource { SubValue = "x" });
+                var destination = Mapper.Map<Source, Destination>(src);
+
+                destination.Value.ShouldEqual("x");
+            }
+        }
+    }
+}
diff --git a/src/UnitTests/UnitTests.csproj b/src/UnitTests/UnitTests.csproj
index 690875db..ff88e3e4 100644
--- a/src/UnitTests/UnitTests.csproj
+++ b/src/UnitTests/UnitTests.csproj
@@ -108,6 +108,7 @@
     <Compile Include="Bug\AllowNullDestinationValuesBugs.cs" />
     <Compile Include="Bug\AssignableCollectionBug.cs" />
     <Compile Include="Bug\CannotConvertEnumToNullable.cs" />
+    <Compile Include="Bug\ConditionBug.cs" />
     <Compile Include="Bug\ContextValuesIncorrect.cs" />
     <Compile Include="Bug\CreateMapExpressionWithIgnoredPropertyBug.cs" />
     <Compile Include="Bug\CollectionMapperMapsISetIncorrectly.cs" />
