diff --git a/src/AutoMapper/Configuration/MappingExpression.cs b/src/AutoMapper/Configuration/MappingExpression.cs
index 1b54bb28..d9acc63b 100644
--- a/src/AutoMapper/Configuration/MappingExpression.cs
+++ b/src/AutoMapper/Configuration/MappingExpression.cs
@@ -32,9 +32,6 @@ void IMappingExpression.ConvertUsing<TTypeConverter>()
         public void ConvertUsing(Type typeConverterType) 
             => TypeMapActions.Add(tm => tm.TypeConverterType = typeConverterType);
 
-        public void As(Type typeOverride) 
-            => TypeMapActions.Add(tm => tm.DestinationTypeOverride = typeOverride);
-
         public void ForAllOtherMembers(Action<IMemberConfigurationExpression> memberOptions) 
             => base.ForAllOtherMembers(o => memberOptions((IMemberConfigurationExpression)o));
 
@@ -471,9 +468,11 @@ private void ForDestinationMember<TMember>(IMemberAccessor destinationProperty,
 
         public void As<T>()
         {
-            TypeMapActions.Add(tm => tm.DestinationTypeOverride = typeof(T));
+            As(typeof(T));
         }
 
+        public void As(Type typeOverride) => TypeMapActions.Add(tm => tm.DestinationTypeOverride = typeOverride);
+
         public IMappingExpression<TSource, TDestination> ForCtorParam(string ctorParamName, Action<ICtorParamConfigurationExpression<TSource>> paramOptions)
         {
             var ctorParamExpression = new CtorParamConfigurationExpression<TSource>(ctorParamName);
diff --git a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
index 33e9cdc7..f296cc34 100644
--- a/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
+++ b/src/AutoMapper/Execution/TypeMapPlanBuilder.cs
@@ -14,11 +14,11 @@ public static class TypeMapPlanBuilder
     {
         public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationProvider configurationProvider, TypeMapRegistry typeMapRegistry)
         {
-            if (typeMap.SourceType.IsGenericTypeDefinition() || typeMap.DestinationType.IsGenericTypeDefinition())
+            if (typeMap.SourceType.IsGenericTypeDefinition() || typeMap.DestinationTypeToUse.IsGenericTypeDefinition())
                 return null;
 
             var srcParam = Parameter(typeMap.SourceType, "src");
-            var destParam = Parameter(typeMap.DestinationType, "dest");
+            var destParam = Parameter(typeMap.DestinationTypeToUse, "dest");
             var ctxtParam = Parameter(typeof (ResolutionContext), "ctxt");
 
             if (typeMap.Substitution != null)
@@ -34,14 +34,14 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
                 {
                     var genericTypeParam = typeMap.SourceType.IsGenericType()
                         ? typeMap.SourceType.GetTypeInfo().GenericTypeArguments[0]
-                        : typeMap.DestinationType.GetTypeInfo().GenericTypeArguments[0];
+                        : typeMap.DestinationTypeToUse.GetTypeInfo().GenericTypeArguments[0];
                     type = typeMap.TypeConverterType.MakeGenericType(genericTypeParam);
                 }
                 else type = typeMap.TypeConverterType;
 
                 // (src, dest, ctxt) => ((ITypeConverter<TSource, TDest>)ctxt.Options.CreateInstance<TypeConverterType>()).ToType(src, ctxt);
                 var converterInterfaceType = typeof (ITypeConverter<,>).MakeGenericType(typeMap.SourceType,
-                    typeMap.DestinationType);
+                    typeMap.DestinationTypeToUse);
                 return Lambda(
                     Call(
                         ToType(
@@ -68,8 +68,6 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
                 return Lambda(typeMap.CustomProjection.ReplaceParameters(srcParam), srcParam, destParam, ctxtParam);
             }
 
-            ParameterExpression contextToReuse = null;
-
             var destinationFunc = CreateDestinationFunc(typeMap, typeMapRegistry, srcParam, destParam, ctxtParam);
 
             var assignmentFunc = CreateAssignmentFunc(typeMap, configurationProvider, typeMapRegistry, srcParam, destParam, ctxtParam, destinationFunc);
@@ -89,7 +87,7 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
             ParameterExpression ctxtParam)
         {
             var newDestFunc = ToType(CreateNewDestinationFunc(typeMap, typeMapRegistry, srcParam, ctxtParam),
-                typeMap.DestinationType);
+                typeMap.DestinationTypeToUse);
 
             var getDest = typeMap.DestinationTypeToUse.GetTypeInfo().IsValueType
                 ? newDestFunc
@@ -167,7 +165,7 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
             {
                 mapperFunc =
                     Condition(typeMap.Condition.Body,
-                        mapperFunc, Default(typeMap.DestinationType));
+                        mapperFunc, Default(typeMap.DestinationTypeToUse));
                 //mapperFunc = (source, context, destFunc) => _condition(context) ? inner(source, context, destFunc) : default(TDestination);
             }
 
@@ -179,7 +177,7 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
                         Constant(typeMap.MaxDepth)
                     ),
                     mapperFunc,
-                    Default(typeMap.DestinationType));
+                    Default(typeMap.DestinationTypeToUse));
                 //mapperFunc = (source, context, destFunc) => context.GetTypeDepth(types) <= maxDepth ? inner(source, context, destFunc) : default(TDestination);
             }
 
@@ -187,13 +185,13 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
             {
                 mapperFunc =
                     Condition(Equal(srcParam, Default(typeMap.SourceType)),
-                        Default(typeMap.DestinationType), mapperFunc.RemoveIfNotNull(srcParam));
+                        Default(typeMap.DestinationTypeToUse), mapperFunc.RemoveIfNotNull(srcParam));
                 //mapperFunc = (source, context, destFunc) => source == default(TSource) ? default(TDestination) : inner(source, context, destFunc);
             }
 
             if (typeMap.PreserveReferences)
             {
-                var cache = Variable(typeMap.DestinationType, "cachedDestination");
+                var cache = Variable(typeMap.DestinationTypeToUse, "cachedDestination");
 
                 var condition = Condition(
                     AndAlso(
@@ -204,7 +202,7 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
                                 typeof (Dictionary<object, object>).GetMethod("ContainsKey"), srcParam)
                             )),
                     Assign(cache,
-                        ToType(Property(Property(ctxtParam, "InstanceCache"), "Item", srcParam), typeMap.DestinationType)),
+                        ToType(Property(Property(ctxtParam, "InstanceCache"), "Item", srcParam), typeMap.DestinationTypeToUse)),
                     Assign(cache, mapperFunc)
                     );
 
@@ -225,26 +223,26 @@ public static LambdaExpression BuildMapperFunc(TypeMap typeMap, IConfigurationPr
             if (typeMap.ConstructDestinationUsingServiceLocator)
                 return Call(MakeMemberAccess(ctxtParam, typeof (ResolutionContext).GetProperty("Options")),
                     typeof (MappingOperationOptions).GetMethod("CreateInstance")
-                        .MakeGenericMethod(typeMap.DestinationType)
+                        .MakeGenericMethod(typeMap.DestinationTypeToUse)
                     );
 
             if (typeMap.ConstructorMap?.CanResolve == true)
                 return typeMap.ConstructorMap.BuildExpression(typeMapRegistry, srcParam, ctxtParam);
 
-            if (typeMap.DestinationType.IsInterface())
+            if (typeMap.DestinationTypeToUse.IsInterface())
             {
-                var ctor = Call(Constant(ObjectCreator.DelegateFactory), typeof(DelegateFactory).GetMethod("CreateCtor", new[] { typeof(Type) }), Call(New(typeof(ProxyGenerator)), typeof(ProxyGenerator).GetMethod("GetProxyType"), Constant(typeMap.DestinationType)));
+                var ctor = Call(Constant(ObjectCreator.DelegateFactory), typeof(DelegateFactory).GetMethod("CreateCtor", new[] { typeof(Type) }), Call(New(typeof(ProxyGenerator)), typeof(ProxyGenerator).GetMethod("GetProxyType"), Constant(typeMap.DestinationTypeToUse)));
                 // We're invoking a delegate here
                 return Invoke(ctor);
             }
 
-            if (typeMap.DestinationType.IsAbstract())
+            if (typeMap.DestinationTypeToUse.IsAbstract())
                 return Constant(null);
 
-            if (typeMap.DestinationType.IsGenericTypeDefinition())
+            if (typeMap.DestinationTypeToUse.IsGenericTypeDefinition())
                 return Constant(null);
 
-            return DelegateFactory.GenerateConstructorExpression(typeMap.DestinationType);
+            return DelegateFactory.GenerateConstructorExpression(typeMap.DestinationTypeToUse);
         }
 
         private static readonly Expression<Func<AutoMapperMappingException>> CtorExpression = () => new AutoMapperMappingException(null, null, default(TypePair), null, null);
diff --git a/src/AutoMapper/Profile.cs b/src/AutoMapper/Profile.cs
index 30b8af66..9487c314 100644
--- a/src/AutoMapper/Profile.cs
+++ b/src/AutoMapper/Profile.cs
@@ -270,7 +270,7 @@ TypeMap IProfileConfiguration.ConfigureClosedGenericTypeMap(TypeMapRegistry type
 
             Configure(typeMapRegistry, closedMap);
 
-            if (closedMap.TypeConverterType != null)
+            if(closedMap.TypeConverterType != null)
             {
                 var typeParams = 
                     (openMapConfig.SourceType.IsGenericTypeDefinition() ? closedTypes.SourceType.GetGenericArguments() : new Type[0])
@@ -279,9 +279,12 @@ TypeMap IProfileConfiguration.ConfigureClosedGenericTypeMap(TypeMapRegistry type
 
                 var neededParameters = closedMap.TypeConverterType.GetGenericParameters().Length;
                 closedMap.TypeConverterType = closedMap.TypeConverterType.MakeGenericType(typeParams.Take(neededParameters).ToArray());
-
             }
-
+            if(closedMap.DestinationTypeOverride?.IsGenericTypeDefinition() == true)
+            {
+                var neededParameters = closedMap.DestinationTypeOverride.GetGenericParameters().Length;
+                closedMap.DestinationTypeOverride = closedMap.DestinationTypeOverride.MakeGenericType(closedTypes.DestinationType.GetGenericArguments().Take(neededParameters).ToArray());
+            }
             return closedMap;
         }
 
diff --git a/src/AutoMapper/QueryableExtensions/ExpressionBuilder.cs b/src/AutoMapper/QueryableExtensions/ExpressionBuilder.cs
index 27ee4c3b..a644e6c7 100644
--- a/src/AutoMapper/QueryableExtensions/ExpressionBuilder.cs
+++ b/src/AutoMapper/QueryableExtensions/ExpressionBuilder.cs
@@ -128,7 +128,7 @@ private LambdaExpression DestinationConstructorExpression(TypeMap typeMap, Expre
             }
             var newExpression = typeMap.ConstructorMap?.CanResolve == true
                 ? typeMap.ConstructorMap.NewExpression(instanceParameter)
-                : New(typeMap.DestinationTypeOverride ?? typeMap.DestinationType);
+                : New(typeMap.DestinationTypeToUse);
 
             return Lambda(newExpression);
         }
diff --git a/src/UnitTests/MappingInheritance/ShouldSupportOnlyDestinationTypeBeingDerived.cs b/src/UnitTests/MappingInheritance/ShouldSupportOnlyDestinationTypeBeingDerived.cs
index 65c768ca..fafd3731 100644
--- a/src/UnitTests/MappingInheritance/ShouldSupportOnlyDestinationTypeBeingDerived.cs
+++ b/src/UnitTests/MappingInheritance/ShouldSupportOnlyDestinationTypeBeingDerived.cs
@@ -105,4 +105,71 @@ public void Mapper_Should_Allow_Overriding_Of_Destination_Type()
         }
 
     }
+
+    public class AsWithGenerics : AutoMapperSpecBase
+    {
+        INodeModel<int> _destination;
+
+        public interface INodeModel<T> : INodeModel where T : struct
+        {
+            new T? ID { get; set; }
+        }
+
+        public interface INodeModel
+        {
+            object ID { get; set; }
+            string Name { get; set; }
+        }
+
+        public class NodeModel<T> : INodeModel<T> where T : struct
+        {
+            public T? ID { get; set; }
+            public string Name { get; set; }
+
+            object INodeModel.ID
+            {
+                get
+                {
+                    return ID;
+                }
+
+                set
+                {
+                    ID = value as T?;
+                }
+            }
+        }
+
+        public class NodeDto<T> where T : struct
+        {
+            public T? ID { get; set; }
+            public string Name { get; set; }
+        }
+
+        protected override MapperConfiguration Configuration
+        {
+            get
+            {
+                return new MapperConfiguration(cfg => {
+                    cfg.CreateMap(typeof(NodeDto<>), typeof(NodeModel<>));
+                    cfg.CreateMap(typeof(NodeDto<>), typeof(INodeModel<>)).As(typeof(NodeModel<>));
+                    cfg.CreateMap(typeof(INodeModel<>), typeof(NodeModel<>));
+                });
+            }
+        }
+
+        protected override void Because_of()
+        {
+            var dto = new NodeDto<int> { ID = 1, Name = "Hi" };
+            _destination = Mapper.Map<INodeModel<int>>(dto);
+        }
+
+        [Fact]
+        public void Should_override_the_map()
+        {
+            _destination.ShouldBeType<NodeModel<int>>();
+            _destination.ID.ShouldEqual(1);
+            _destination.Name.ShouldEqual("Hi");
+        }
+    }
 }
