diff --git a/src/AutoMapper/IMappingExpression.cs b/src/AutoMapper/IMappingExpression.cs
index 37107084..466b786e 100644
--- a/src/AutoMapper/IMappingExpression.cs
+++ b/src/AutoMapper/IMappingExpression.cs
@@ -395,6 +395,18 @@ public interface IMemberConfigurationExpression<TSource>
         /// </summary>
         /// <param name="condition">Condition to evaluate using the current resolution context</param>
         void Condition(Func<ResolutionContext, bool> condition);
+       
+        /// <summary>
+        /// Conditionally map this member, evaluated before accessing the source value
+        /// </summary>
+        /// <param name="condition">Condition to evaluate using the source object</param>
+        void PreCondition(Func<TSource, bool> condition);
+
+        /// <summary>
+        /// Conditionally map this member, evaluated before accessing the source value
+        /// </summary>
+        /// <param name="condition">Condition to evaluate using the current resolution context</param>
+        void PreCondition(Func<ResolutionContext, bool> condition);
     }
 
     /// <summary>
diff --git a/src/AutoMapper/Internal/MappingExpression.cs b/src/AutoMapper/Internal/MappingExpression.cs
index 46b027a7..617e85bd 100644
--- a/src/AutoMapper/Internal/MappingExpression.cs
+++ b/src/AutoMapper/Internal/MappingExpression.cs
@@ -328,8 +328,23 @@ public void UseValue(object value)
         public void Condition(Func<TSource, bool> condition)
         {
             Condition(context => condition((TSource)context.Parent.SourceValue));
-        }
-
+        }
+
+        public void Condition(Func<ResolutionContext, bool> condition)
+        {
+            _propertyMap.ApplyCondition(condition);
+        }
+
+        public void PreCondition(Func<TSource, bool> condition)
+        {
+            PreCondition(context => condition((TSource)context.Parent.SourceValue));
+        }
+
+        public void PreCondition(Func<ResolutionContext, bool> condition)
+        {
+            _propertyMap.ApplyPreCondition(condition);
+        }
+
         public IMappingExpression<TSource, TDestination> MaxDepth(int depth)
         {
             _typeMap.MaxDepth = depth;
@@ -388,12 +403,6 @@ public void Condition(Func<TSource, bool> condition)
 
             return this;
         }
-
-
-        public void Condition(Func<ResolutionContext, bool> condition)
-        {
-            _propertyMap.ApplyCondition(condition);
-        }
 
         public void Ignore()
         {
diff --git a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
index ba426b21..2bc194ca 100644
--- a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
+++ b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
@@ -107,7 +107,7 @@ protected virtual object ReassignValue(ResolutionContext context, object o)
 
 			private void MapPropertyValue(ResolutionContext context, IMappingEngineRunner mapper, object mappedObject, PropertyMap propertyMap)
 			{
-				if (propertyMap.CanResolveValue())
+				if (propertyMap.CanResolveValue() && propertyMap.ShouldAssignValuePreResolving(context))
                 {
                     ResolutionResult result;
 
diff --git a/src/AutoMapper/PropertyMap.cs b/src/AutoMapper/PropertyMap.cs
index ca84afc8..ecdca253 100644
--- a/src/AutoMapper/PropertyMap.cs
+++ b/src/AutoMapper/PropertyMap.cs
@@ -25,6 +25,7 @@ public class PropertyMap
         private bool _sealed;
         private IValueResolver[] _cachedResolvers;
         private Func<ResolutionContext, bool> _condition;
+        private Func<ResolutionContext, bool> _preCondition;
         private MemberInfo _sourceMember;
 
         public PropertyMap(IMemberAccessor destinationProperty)
@@ -253,11 +254,21 @@ public void ApplyCondition(Func<ResolutionContext, bool> condition)
             _condition = condition;
         }
 
+        public void ApplyPreCondition(Func<ResolutionContext, bool> condition)
+        {
+            _preCondition = condition;
+        }
+
         public bool ShouldAssignValue(ResolutionContext context)
         {
             return _condition == null || _condition(context);
         }
 
+        public bool ShouldAssignValuePreResolving(ResolutionContext context)
+        {
+            return _preCondition == null || _preCondition(context);
+        }
+
         public void SetCustomValueResolverExpression<TSource, TMember>(Expression<Func<TSource, TMember>> sourceMember)
         {
             if (sourceMember.Body is MemberExpression)
diff --git a/src/UnitTests/Bug/ConditionBug.cs b/src/UnitTests/Bug/ConditionBug.cs
index d7e6182d..b77b0f8c 100644
--- a/src/UnitTests/Bug/ConditionBug.cs
+++ b/src/UnitTests/Bug/ConditionBug.cs
@@ -199,4 +199,47 @@ public void Should_not_map_value_when_not_null()
             }
         }
     }
+
+    namespace SourceValueExceptionConditionPropertyBug
+    {
+        using System;
+        using Should;
+        using Xunit;
+
+        public class Source
+        {
+            public bool Accessed = false;
+            public int Value
+            {
+                get
+                {
+                    Accessed = true;
+                    return 5;
+                }
+            }
+        }
+
+        public class Dest
+        {
+            public int Value { get; set; }
+        }
+
+        public class ConditionTests : NonValidatingSpecBase
+        {
+            protected override void Establish_context()
+            {
+                Mapper.Initialize(cfg => cfg.CreateMap<Source, Dest>()
+                    .ForMember(d => d.Value, opt => opt.PreCondition((ResolutionContext rc) => false)));
+            }
+
+            [Fact]
+            public void Should_not_map()
+            {
+                var source = new Source();
+                Mapper.Map<Source, Dest>(source);
+                source.Accessed.ShouldBeFalse();
+            }
+        }
+    }
+
 }
