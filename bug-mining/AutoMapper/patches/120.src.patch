diff --git a/src/AutoMapper/Configuration/MappingExpression.cs b/src/AutoMapper/Configuration/MappingExpression.cs
index c5e7e3b1..1f6c8bf9 100644
--- a/src/AutoMapper/Configuration/MappingExpression.cs
+++ b/src/AutoMapper/Configuration/MappingExpression.cs
@@ -178,16 +178,8 @@ protected virtual IMemberConfiguration CreateMemberConfigurationExpression<TMemb
         public IMappingExpression<TSource, TDestination> ForMember(string name,
                                                                    Action<IMemberConfigurationExpression<TSource, object>> memberOptions)
         {
-            var memberInfo = new[] { DestinationType }
-                .RecursiveSelect(i => i.GetTypeInfo().ImplementedInterfaces)
-                .Distinct()
-                .Select(i => i.GetMember(name).FirstOrDefault())
-                .FirstOrDefault(m => m != null);
-            if(memberInfo == null)
-            {
-                throw new ArgumentOutOfRangeException(nameof(name), "Cannot find a field or property named " + name);
-            }
-            ForDestinationMember(memberInfo.ToMemberAccessor(), memberOptions);
+            var member = DestinationType.GetFieldOrProperty(name);
+            ForDestinationMember(member.ToMemberAccessor(), memberOptions);
             return this;
         }
 
diff --git a/src/AutoMapper/Configuration/PrimitiveExtensions.cs b/src/AutoMapper/Configuration/PrimitiveExtensions.cs
index 4cfab2c8..ce6fc0d8 100644
--- a/src/AutoMapper/Configuration/PrimitiveExtensions.cs
+++ b/src/AutoMapper/Configuration/PrimitiveExtensions.cs
@@ -13,6 +13,20 @@ public static class PrimitiveExtensions
             TValue value;
             dictionary.TryGetValue(key, out value);
             return value;
+        }
+
+        public static MemberInfo GetFieldOrProperty(this Type type, string name)
+        {
+            var memberInfo = new[] { type }
+                .RecursiveSelect(i => i.GetTypeInfo().ImplementedInterfaces)
+                .Distinct()
+                .Select(i => i.GetMember(name).FirstOrDefault())
+                .FirstOrDefault(m => m != null);
+            if(memberInfo == null)
+            {
+                throw new ArgumentOutOfRangeException(nameof(name), "Cannot find a field or property named " + name);
+            }
+            return memberInfo;
         }
 
         public static bool IsNullableType(this Type type)
diff --git a/src/IntegrationTests.Net4/IntegrationTests.Net4.csproj b/src/IntegrationTests.Net4/IntegrationTests.Net4.csproj
index e34eb2d1..6922d81a 100644
--- a/src/IntegrationTests.Net4/IntegrationTests.Net4.csproj
+++ b/src/IntegrationTests.Net4/IntegrationTests.Net4.csproj
@@ -81,6 +81,7 @@
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="MaxDepthWithCollections.cs" />
     <Compile Include="ProxyTests.cs" />
+    <Compile Include="QueryableInterfaceInheritanceIssue.cs" />
     <Compile Include="TestDbConfiguration.cs" />
   </ItemGroup>
   <ItemGroup>
diff --git a/src/IntegrationTests.Net4/QueryableInterfaceInheritanceIssue.cs b/src/IntegrationTests.Net4/QueryableInterfaceInheritanceIssue.cs
new file mode 100644
index 00000000..d2fe42df
--- /dev/null
+++ b/src/IntegrationTests.Net4/QueryableInterfaceInheritanceIssue.cs
@@ -0,0 +1,67 @@
+ï»¿using System.Collections.Generic;
+using System.Data.Entity;
+using System.Linq;
+using AutoMapper.QueryableExtensions;
+using Should;
+using Xunit;
+
+namespace AutoMapper.UnitTests.Projection
+{
+    public class QueryableInterfaceInheritanceIssue : AutoMapperSpecBase
+    {
+        QueryableDto[] _result;
+
+        public interface IBaseQueryableInterface
+        {
+            string Id { get; set; }
+        }
+
+        public interface IQueryableInterface : IBaseQueryableInterface
+        {
+        }
+
+        public class QueryableInterfaceImpl : IQueryableInterface
+        {
+            public string Id { get; set; }
+        }
+
+        public class QueryableDto
+        {
+            public string Id { get; set; }
+        }
+
+        class Initializer : DropCreateDatabaseAlways<ClientContext>
+        {
+            protected override void Seed(ClientContext context)
+            {
+                context.Entities.AddRange(new[] { new QueryableInterfaceImpl { Id = "One" }, new QueryableInterfaceImpl { Id = "Two" }});
+            }
+        }
+
+        class ClientContext : DbContext
+        {
+            public ClientContext()
+            {
+                Database.SetInitializer(new Initializer());
+            }
+            public DbSet<QueryableInterfaceImpl> Entities { get; set; }
+        }
+
+        protected override void Because_of()
+        {
+            using(var context = new ClientContext())
+            {
+                _result = context.Entities.ProjectTo<QueryableDto>(ConfigProvider).ToArray();
+            }
+        }
+
+        [Fact]
+        public void QueryableShouldMapSpecifiedBaseInterfaceMember()
+        {
+            _result.FirstOrDefault(dto => dto.Id == "One").ShouldNotBeNull();
+            _result.FirstOrDefault(dto => dto.Id == "Two").ShouldNotBeNull();
+        }
+
+        protected override MapperConfiguration Configuration => new MapperConfiguration(cfg => cfg.CreateMap<IQueryableInterface, QueryableDto>());
+    }
+}
\ No newline at end of file
