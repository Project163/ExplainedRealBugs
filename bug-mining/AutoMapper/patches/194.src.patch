diff --git a/src/AutoMapper/InternalApi.cs b/src/AutoMapper/InternalApi.cs
index bbbf9eab..622a12ea 100644
--- a/src/AutoMapper/InternalApi.cs
+++ b/src/AutoMapper/InternalApi.cs
@@ -156,6 +156,7 @@ public interface IGlobalConfiguration : IConfigurationProvider
         int MaxExecutionPlanDepth { get; }
         int RecursiveQueriesMaxDepth { get; }
         IEnumerable<ProfileMap> GetProfiles();
+        TypeMap GetIncludedTypeMap(TypePair typePair);
     }
     [EditorBrowsable(EditorBrowsableState.Never)]
     public interface IProfileExpressionInternal : IProfileExpression
diff --git a/src/AutoMapper/MapperConfiguration.cs b/src/AutoMapper/MapperConfiguration.cs
index 7c746c28..8313e395 100644
--- a/src/AutoMapper/MapperConfiguration.cs
+++ b/src/AutoMapper/MapperConfiguration.cs
@@ -254,14 +254,12 @@ private void Seal()
                     redirectedTypes.Add(Tuple.Create(typeMap.Types, new TypePair(typeMap.SourceType, typeMap.DestinationTypeOverride)));
                 }
                 derivedMaps.AddRange(GetDerivedTypeMaps(typeMap).Select(derivedMap => Tuple.Create(new TypePair(derivedMap.SourceType, typeMap.DestinationType), derivedMap)));
-            }
+            }
+            IGlobalConfiguration globalConfiguration = this;
             foreach (var redirectedType in redirectedTypes)
             {
-                var derivedMap = FindTypeMapFor(redirectedType.Item2);
-                if (derivedMap != null)
-                {
-                    _resolvedMaps[redirectedType.Item1] = derivedMap;
-                }
+                var derivedMap = globalConfiguration.GetIncludedTypeMap(redirectedType.Item2);
+                _resolvedMaps[redirectedType.Item1] = derivedMap;
             }
             foreach (var derivedMap in derivedMaps.Where(derivedMap => !_resolvedMaps.ContainsKey(derivedMap.Item1)))
             {
@@ -288,28 +286,25 @@ private IEnumerable<TypeMap> GetDerivedTypeMaps(TypeMap typeMap)
             }
         }
 
-        IEnumerable<TypeMap> IGlobalConfiguration.GetIncludedTypeMaps(IEnumerable<TypePair> includedTypes)
-        {
-            foreach (var pair in includedTypes)
-            {
-                var typeMap = FindTypeMapFor(pair);
-                if (typeMap != null)
-                {
-                    yield return typeMap;
+        IEnumerable<TypeMap> IGlobalConfiguration.GetIncludedTypeMaps(IEnumerable<TypePair> includedTypes) => includedTypes.Select(this.Internal().GetIncludedTypeMap);
+        TypeMap IGlobalConfiguration.GetIncludedTypeMap(TypePair pair)
+        {
+            var typeMap = FindTypeMapFor(pair);
+            if (typeMap != null)
+            {
+                return typeMap;
+            }
+            else
+            {
+                typeMap = ResolveTypeMap(pair);
+                // we want the exact map the user included, but we could instantiate an open generic
+                if (typeMap == null || typeMap.Types != pair)
+                {
+                    throw QueryMapperHelper.MissingMapException(pair);
                 }
-                else
-                {
-                    typeMap = ResolveTypeMap(pair);
-                    // we want the exact map the user included, but we could instantiate an open generic
-                    if (typeMap == null || typeMap.Types != pair)
-                    {
-                        throw QueryMapperHelper.MissingMapException(pair);
-                    }
-                    yield return typeMap;
-                }
+                return typeMap;
             }
-        }
-
+        }
         private TypeMap FindClosedGenericTypeMapFor(TypePair typePair)
         {
             var genericTypePair = typePair.GetOpenGenericTypePair();
diff --git a/src/AutoMapper/ProfileMap.cs b/src/AutoMapper/ProfileMap.cs
index 54ffb89f..b72c1668 100644
--- a/src/AutoMapper/ProfileMap.cs
+++ b/src/AutoMapper/ProfileMap.cs
@@ -210,7 +210,7 @@ private void ApplyMemberMaps(TypeMap currentMap, IGlobalConfiguration configurat
         {
             foreach (var includedMemberExpression in currentMap.GetAllIncludedMembers())
             {
-                var includedMap = configurationProvider.GetIncludedTypeMaps(new[] { new TypePair(includedMemberExpression.Body.Type, currentMap.DestinationType) }).Single();
+                var includedMap = configurationProvider.GetIncludedTypeMap(new TypePair(includedMemberExpression.Body.Type, currentMap.DestinationType));
                 var includedMember = new IncludedMember(includedMap, includedMemberExpression);
                 if (currentMap.AddMemberMap(includedMember))
                 {
diff --git a/src/UnitTests/MappingInheritance/ShouldSupportOnlyDestinationTypeBeingDerived.cs b/src/UnitTests/MappingInheritance/ShouldSupportOnlyDestinationTypeBeingDerived.cs
index a32a8cf5..bf8ca9ba 100644
--- a/src/UnitTests/MappingInheritance/ShouldSupportOnlyDestinationTypeBeingDerived.cs
+++ b/src/UnitTests/MappingInheritance/ShouldSupportOnlyDestinationTypeBeingDerived.cs
@@ -1,13 +1,28 @@
 ï»¿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using AutoMapper.Mappers;
 using Shouldly;
 using Xunit;
 
 namespace AutoMapper.UnitTests.MappingInheritance
 {
+    public class AsWithMissingMap : NonValidatingSpecBase
+    {
+        interface TInterface
+        {
+            string Value { get; set; }
+        }
+        class TConcrete : TInterface
+        {
+            public string Value { get; set; }
+        }
+        class TModel
+        {
+            public string Value { get; set; }
+        }
+        protected override MapperConfiguration Configuration => new MapperConfiguration(cfg => cfg.CreateMap<TModel, TInterface>().As<TConcrete>());
+        [Fact]
+        public void Should_report_missing_map() => new Action(() => Configuration.CompileMappings()).ShouldThrow<InvalidOperationException>().Message.ShouldBe(
+            "Missing map from AutoMapper.UnitTests.MappingInheritance.AsWithMissingMap+TModel to AutoMapper.UnitTests.MappingInheritance.AsWithMissingMap+TConcrete. Create using CreateMap<TModel, TConcrete>.");
+    }
     public class AsShouldWorkOnlyWithDerivedTypesWithGenerics : AutoMapperSpecBase
     {
         class Source<T>
@@ -22,7 +37,11 @@ class Override<T> : Destination<T>
         {
         }
 
-        protected override MapperConfiguration Configuration => new MapperConfiguration(c => c.CreateMap(typeof(Source<>), typeof(Destination<>)).As(typeof(Override<>)));
+        protected override MapperConfiguration Configuration => new MapperConfiguration(c =>
+        {
+            c.CreateMap(typeof(Source<>), typeof(Override<>));
+            c.CreateMap(typeof(Source<>), typeof(Destination<>)).As(typeof(Override<>));
+        });
     }
 
     public class AsShouldWorkOnlyWithDerivedTypes
