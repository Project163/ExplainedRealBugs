diff --git a/src/AutoMapper/LockingConcurrentDictionary.cs b/src/AutoMapper/LockingConcurrentDictionary.cs
index c8268ebc..eed4ab52 100644
--- a/src/AutoMapper/LockingConcurrentDictionary.cs
+++ b/src/AutoMapper/LockingConcurrentDictionary.cs
@@ -1,8 +1,9 @@
-namespace AutoMapper
-{
-    using System;
-    using System.Collections.Concurrent;
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
 
+namespace AutoMapper
+{
     internal struct LockingConcurrentDictionary<TKey, TValue>
     {
         private readonly ConcurrentDictionary<TKey, Lazy<TValue>> _dictionary;
@@ -14,9 +15,34 @@ public LockingConcurrentDictionary(Func<TKey, TValue> valueFactory)
             _valueFactory = key => new Lazy<TValue>(() => valueFactory(key));
         }
 
-        public TValue GetOrAdd(TKey key)
-        {
-            return _dictionary.GetOrAdd(key, _valueFactory).Value;
+        public TValue GetOrAdd(TKey key) => _dictionary.GetOrAdd(key, _valueFactory).Value;
+
+        public TValue this[TKey key]
+        {
+            get
+            {
+                return _dictionary[key].Value;
+            }
+            set
+            {
+                _dictionary[key] = new Lazy<TValue>(() => value);
+            }
         }
+
+        public bool TryGetValue(TKey key, out TValue value)
+        {
+            Lazy<TValue> lazy;
+            if(_dictionary.TryGetValue(key, out lazy))
+            {
+                value = lazy.Value;
+                return true;
+            }
+            value = default(TValue);
+            return false;
+        }
+
+        public bool ContainsKey(TKey key) => _dictionary.ContainsKey(key);
+
+        public ICollection<TKey> Keys => _dictionary.Keys;        
     }
 }
\ No newline at end of file
diff --git a/src/AutoMapper/MapperConfiguration.cs b/src/AutoMapper/MapperConfiguration.cs
index 6aadf88c..5447e1e7 100644
--- a/src/AutoMapper/MapperConfiguration.cs
+++ b/src/AutoMapper/MapperConfiguration.cs
@@ -21,13 +21,14 @@ public class MapperConfiguration : IConfigurationProvider
 
         private readonly IEnumerable<IObjectMapper> _mappers;
         private readonly TypeMapRegistry _typeMapRegistry = new TypeMapRegistry();
-        private readonly Dictionary<TypePair, TypeMap> _typeMapPlanCache = new Dictionary<TypePair, TypeMap>();
+        private LockingConcurrentDictionary<TypePair, TypeMap> _typeMapPlanCache;
         private readonly LockingConcurrentDictionary<MapRequest, MapperFuncs> _mapPlanCache;
         private readonly ConfigurationValidator _validator;
 
         public MapperConfiguration(MapperConfigurationExpression configurationExpression)
         {
             _mappers = configurationExpression.Mappers.ToArray();
+            _typeMapPlanCache = new LockingConcurrentDictionary<TypePair, TypeMap>(GetTypeMap);
             _mapPlanCache = new LockingConcurrentDictionary<MapRequest, MapperFuncs>(CreateMapperFuncs);
             Validators = configurationExpression.Advanced.GetValidators();
             _validator = new ConfigurationValidator(this);
@@ -79,7 +80,7 @@ public void Validate(ValidationContext context)
 
         public void CompileMappings()
         {
-            foreach (var request in _typeMapPlanCache.Select(e => new MapRequest(e.Key, e.Key)).ToArray())
+            foreach(var request in _typeMapPlanCache.Keys.Select(types => new MapRequest(types, types)).ToArray())
             {
                 GetMapperFunc(request);
             }
@@ -200,25 +201,23 @@ public TypeMap ResolveTypeMap(Type sourceType, Type destinationType)
 
         public TypeMap ResolveTypeMap(TypePair typePair)
         {
-            TypeMap typeMap;
-            if(!_typeMapPlanCache.TryGetValue(typePair, out typeMap))
-            {
-                typeMap = GetTypeMap(typePair);
-                _typeMapPlanCache.Add(typePair, typeMap);
-            }
+            var typeMap = _typeMapPlanCache.GetOrAdd(typePair);
             if(typeMap != null && typeMap.MapExpression == null && Configuration.CreateMissingTypeMaps)
             {
-                typeMap.Seal(_typeMapRegistry, this);
+                lock(typeMap)
+                {
+                    typeMap.Seal(_typeMapRegistry, this);
+                }
             }
             return typeMap;
-        }
+        }
 
         private TypeMap GetTypeMap(TypePair initialTypes)
         {
             TypeMap typeMap;
             foreach(var types in initialTypes.GetRelatedTypePairs())
             {
-                if(_typeMapPlanCache.TryGetValue(types, out typeMap))
+                if(types != initialTypes && _typeMapPlanCache.TryGetValue(types, out typeMap))
                 {
                     return typeMap;
                 }
