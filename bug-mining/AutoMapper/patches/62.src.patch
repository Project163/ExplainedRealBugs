diff --git a/src/AutoMapper/IMappingOperationOptions.cs b/src/AutoMapper/IMappingOperationOptions.cs
index 98bc0b67..3d83c4a8 100644
--- a/src/AutoMapper/IMappingOperationOptions.cs
+++ b/src/AutoMapper/IMappingOperationOptions.cs
@@ -24,6 +24,11 @@ public interface IMappingOperationOptions
         /// Add context items to be accessed at map time inside an <see cref="IValueResolver"/> or <see cref="ITypeConverter{TSource, TDestination}"/>
         /// </summary>
         IDictionary<string, object> Items { get; }
+
+        /// <summary>
+        /// Disable the cache used to re-use destination instances based on equality
+        /// </summary>
+        bool DisableCache { get; set; }
     }
 
     public class MappingOperationOptions : IMappingOperationOptions
@@ -36,6 +41,7 @@ public MappingOperationOptions()
         public Func<Type, object> ServiceCtor { get; private set; }
         public bool CreateMissingTypeMaps { get; set; }
         public IDictionary<string, object> Items { get; private set; }
+        public bool DisableCache { get; set; }
 
         void IMappingOperationOptions.ConstructServicesUsing(Func<Type, object> constructor)
         {
diff --git a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
index 466a188a..8b31adb3 100644
--- a/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
+++ b/src/AutoMapper/Mappers/TypeMapObjectMapperRegistry.cs
@@ -55,7 +55,7 @@ public object Map(ResolutionContext context, IMappingEngineRunner mapper)
 
 			public bool IsMatch(ResolutionContext context, IMappingEngineRunner mapper)
 			{
-				return context.DestinationValue == null && context.InstanceCache.ContainsKey(context);
+				return !context.Options.DisableCache && context.DestinationValue == null && context.InstanceCache.ContainsKey(context);
 			}
 		}
 
@@ -64,7 +64,7 @@ private abstract class PropertyMapMappingStrategy : ITypeMapObjectMapper
 			public object Map(ResolutionContext context, IMappingEngineRunner mapper)
 			{
 				var mappedObject = GetMappedObject(context, mapper);
-				if (context.SourceValue != null)
+				if (context.SourceValue != null && !context.Options.DisableCache)
                     context.InstanceCache[context] = mappedObject;
 
 				context.TypeMap.BeforeMap(context.SourceValue, mappedObject);
diff --git a/src/AutoMapper/Resources/Resource.Designer.cs b/src/AutoMapper/Resources/Resource.Designer.cs
index 52fea851..68835b4f 100644
--- a/src/AutoMapper/Resources/Resource.Designer.cs
+++ b/src/AutoMapper/Resources/Resource.Designer.cs
@@ -2,7 +2,7 @@
 //------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:4.0.30319.34003
+//     Runtime Version:4.0.30319.34011
 //
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
diff --git a/src/UnitTests/BidirectionalRelationships.cs b/src/UnitTests/BidirectionalRelationships.cs
index 1e2e0a58..0c419844 100644
--- a/src/UnitTests/BidirectionalRelationships.cs
+++ b/src/UnitTests/BidirectionalRelationships.cs
@@ -523,5 +523,75 @@ public ChildDto()
             }
 	    }
 
+	    public class When_disabling_instance_cache_for_instances : AutoMapperSpecBase
+	    {
+            public class Tag
+            {
+                public int Id { get; set; }
+                public string Name { get; set; }
+                public IEnumerable<Tag> ChildTags { get; set; }
+
+                protected bool Equals(Tag other)
+                {
+                    return Id == other.Id;
+                }
+
+                public override bool Equals(object obj)
+                {
+                    if (ReferenceEquals(null, obj)) return false;
+                    if (ReferenceEquals(this, obj)) return true;
+                    if (obj.GetType() != this.GetType()) return false;
+                    return Equals((Tag) obj);
+                }
+
+                public override int GetHashCode()
+                {
+                    return Id;
+                }
+            }
+
+	        [Fact]
+            public void Test()
+            {
+                var tags = new List<Tag>
+                {
+                    new Tag
+                    {
+                        Id = 1,
+                        Name = "Tag 1",
+                        ChildTags = new List<Tag>
+                        {
+                            new Tag
+                            {
+                                Id = 2,
+                                Name = "Tag 2",
+                                ChildTags = new List<Tag>
+                                {
+                                    new Tag {Id = 3, Name = "Tag 3"},
+                                    new Tag {Id = 4, Name = "Tag 4"}
+                                }
+                            }
+                        }
+                    },
+                    new Tag {Id = 1, Name = "Tag 1"},
+                    new Tag
+                    {
+                        Id = 3,
+                        Name = "Tag 3",
+                        ChildTags = new List<Tag>
+                        {
+                            new Tag {Id = 4, Name = "Tag 4"}
+                        }
+                    }
+                };
+
+                Mapper.CreateMap<Tag, Tag>().ForMember(dest => dest.ChildTags, opt => opt.MapFrom(src => src.ChildTags));
+                var result = Mapper.Map<IList<Tag>, IList<Tag>>(tags, opt => opt.DisableCache = true);
+
+                result[1].ChildTags.Count().ShouldEqual(0);
+                result[2].ChildTags.Count().ShouldEqual(1);
+                result[2].ChildTags.First().Id.ShouldEqual(4);
+            }
+	    }
     }
 }
diff --git a/src/UnitTests/ExpressionBridge.cs b/src/UnitTests/ExpressionBridge.cs
index 2faaefc5..e5ad3578 100644
--- a/src/UnitTests/ExpressionBridge.cs
+++ b/src/UnitTests/ExpressionBridge.cs
@@ -234,7 +234,7 @@ public void List_of_abstract_should_be_mapped()
 #endif
         }
 
-#if !NETFX_CORE
+#if !NETFX_CORE && !SILVERLIGHT
         namespace CircularReferences
         {
             public class A
