diff --git a/src/AutoMapper/Configuration/MappingExpression.cs b/src/AutoMapper/Configuration/MappingExpression.cs
index 70223498..e27bd219 100644
--- a/src/AutoMapper/Configuration/MappingExpression.cs
+++ b/src/AutoMapper/Configuration/MappingExpression.cs
@@ -181,10 +181,7 @@ protected virtual IMemberConfiguration CreateMemberConfigurationExpression<TMemb
                                                                    Action<IMemberConfigurationExpression<TSource, TDestination, TMember>> memberOptions)
         {
             var memberInfo = ReflectionHelper.FindProperty(destinationMember);
-            IMemberAccessor destProperty = memberInfo.ToMemberAccessor();
-
-            ForDestinationMember(destProperty, memberOptions);
-
+            ForDestinationMember(memberInfo, memberOptions);
             return this;
         }
 
@@ -192,7 +189,7 @@ protected virtual IMemberConfiguration CreateMemberConfigurationExpression<TMemb
                                                                    Action<IMemberConfigurationExpression<TSource, TDestination, object>> memberOptions)
         {
             var member = DestinationType.GetFieldOrProperty(name);
-            ForDestinationMember(member.ToMemberAccessor(), memberOptions);
+            ForDestinationMember(member, memberOptions);
             return this;
         }
 
@@ -210,17 +207,19 @@ public void ForAllMembers(Action<IMemberConfigurationExpression<TSource, TDestin
 
         public IMappingExpression<TSource, TDestination> IgnoreAllPropertiesWithAnInaccessibleSetter()
         {
-            var properties = DestinationType.GetDeclaredProperties().Where(pm => pm.HasAnInaccessibleSetter());
-            foreach (var property in properties)
-                ForMember(property.Name, opt => opt.Ignore());
+            foreach(var property in DestinationType.PropertiesWithAnInaccessibleSetter())
+            {
+                ForDestinationMember<object>(property, options => options.Ignore());
+            }
             return this;
         }
 
         public IMappingExpression<TSource, TDestination> IgnoreAllSourcePropertiesWithAnInaccessibleSetter()
         {
-            var properties = SourceType.GetDeclaredProperties().Where(pm => pm.HasAnInaccessibleSetter());
-            foreach (var property in properties)
-                ForSourceMember(property.Name, opt => opt.Ignore());
+            foreach(var property in SourceType.PropertiesWithAnInaccessibleSetter())
+            {
+                ForSourceMember(property.Name, options => options.Ignore());
+            }
             return this;
         }
 
@@ -457,6 +456,11 @@ public void ConvertUsing(ITypeConverter<TSource, TDestination> converter)
             return this;
         }
 
+        private void ForDestinationMember<TMember>(MemberInfo destinationProperty, Action<IMemberConfigurationExpression<TSource, TDestination, TMember>> memberOptions)
+        {
+            ForDestinationMember(destinationProperty.ToMemberAccessor(), memberOptions);
+        }
+
         private void ForDestinationMember<TMember>(IMemberAccessor destinationProperty, Action<IMemberConfigurationExpression<TSource, TDestination, TMember>> memberOptions)
         {
             var expression = (MemberConfigurationExpression<TSource, TDestination, TMember>) CreateMemberConfigurationExpression<TMember>(destinationProperty, SourceType);
diff --git a/src/AutoMapper/TypeExtensions.cs b/src/AutoMapper/TypeExtensions.cs
index 403a4ebc..a6d4c944 100644
--- a/src/AutoMapper/TypeExtensions.cs
+++ b/src/AutoMapper/TypeExtensions.cs
@@ -212,6 +212,11 @@ public static bool IsPublic(this PropertyInfo propertyInfo)
         {
             return (propertyInfo?.GetGetMethod(true)?.IsPublic ?? false)
                 || (propertyInfo?.GetSetMethod(true)?.IsPublic ?? false);
+        }
+
+        public static IEnumerable<PropertyInfo> PropertiesWithAnInaccessibleSetter(this Type type)
+        {
+            return type.GetDeclaredProperties().Where(pm => pm.HasAnInaccessibleSetter());
         }
 
         public static bool HasAnInaccessibleSetter(this PropertyInfo property)
diff --git a/src/UnitTests/ConditionalMapping.cs b/src/UnitTests/ConditionalMapping.cs
index b8610fe4..f7725cf1 100644
--- a/src/UnitTests/ConditionalMapping.cs
+++ b/src/UnitTests/ConditionalMapping.cs
@@ -4,243 +4,264 @@
 using Xunit;
 using Should;
 
-namespace AutoMapper.UnitTests
+namespace AutoMapper.UnitTests.ConditionalMapping
 {
-    namespace ConditionalMapping
+    public class When_ignoring_all_properties_with_an_inaccessible_setter_and_explicitly_implemented_member : AutoMapperSpecBase
     {
-        public class When_configuring_a_member_to_skip_based_on_the_property_value : AutoMapperSpecBase
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(c => c.CreateMap<SourceClass, DestinationClass>().IgnoreAllPropertiesWithAnInaccessibleSetter());
+
+        interface Interface
         {
-            public class Source
-            {
-                public int Value { get; set; }
-            }
+            int Value { get; }
+        }
 
-            public class Destination
-            {
-                public int Value { get; set; }
-            }
+        class SourceClass
+        {
+            public int PublicProperty { get; set; }
+        }
 
-            protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
-            {
-                cfg.CreateMap<Source, Destination>()
-                    .ForMember(dest => dest.Value, opt => opt.Condition(src => src.Value > 0));
-            });
+        class DestinationClass : Interface
+        {
+            int Interface.Value { get { return 123; } }
 
-            [Fact]
-            public void Should_skip_the_mapping_when_the_condition_is_true()
-            {
-                var destination = Mapper.Map<Source, Destination>(new Source {Value = -1});
+            public int PrivateProperty { get; private set; }
 
-                destination.Value.ShouldEqual(0);
-            }
+            public int PublicProperty { get; set; }
+        }
+    }
 
-            [Fact]
-            public void Should_execute_the_mapping_when_the_condition_is_false()
-            {
-                var destination = Mapper.Map<Source, Destination>(new Source { Value = 7 });
+    public class When_configuring_a_member_to_skip_based_on_the_property_value : AutoMapperSpecBase
+    {
+        public class Source
+        {
+            public int Value { get; set; }
+        }
 
-                destination.Value.ShouldEqual(7);
-            }
+        public class Destination
+        {
+            public int Value { get; set; }
         }
 
-        public class When_configuring_a_member_to_skip_based_on_the_property_value_with_custom_mapping : AutoMapperSpecBase
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
         {
-            public class Source
-            {
-                public int Value { get; set; }
-            }
+            cfg.CreateMap<Source, Destination>()
+                .ForMember(dest => dest.Value, opt => opt.Condition(src => src.Value > 0));
+        });
 
-            public class Destination
-            {
-                public int Value { get; set; }
-            }
+        [Fact]
+        public void Should_skip_the_mapping_when_the_condition_is_true()
+        {
+            var destination = Mapper.Map<Source, Destination>(new Source {Value = -1});
 
-            protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
-            {
-                cfg.CreateMap<Source, Destination>()
-                    .ForMember(dest => dest.Value, opt =>
-                    {
-                        opt.Condition(src => src.Value > 0);
-                        opt.ResolveUsing((Source src) =>
-                        {
-                            return 10;
-                        });
-                    });
-            });
+            destination.Value.ShouldEqual(0);
+        }
 
-            [Fact]
-            public void Should_skip_the_mapping_when_the_condition_is_true()
-            {
-                var destination = Mapper.Map<Source, Destination>(new Source { Value = -1 });
+        [Fact]
+        public void Should_execute_the_mapping_when_the_condition_is_false()
+        {
+            var destination = Mapper.Map<Source, Destination>(new Source { Value = 7 });
 
-                destination.Value.ShouldEqual(0);
-            }
+            destination.Value.ShouldEqual(7);
+        }
+    }
 
-            [Fact]
-            public void Should_execute_the_mapping_when_the_condition_is_false()
-            {
-                Mapper.Map<Source, Destination>(new Source { Value = 7 }).Value.ShouldEqual(10);
-            }
+    public class When_configuring_a_member_to_skip_based_on_the_property_value_with_custom_mapping : AutoMapperSpecBase
+    {
+        public class Source
+        {
+            public int Value { get; set; }
         }
 
-        public class When_configuring_a_map_to_ignore_all_properties_with_an_inaccessible_setter : AutoMapperSpecBase
+        public class Destination
         {
-            private Destination _destination;
+            public int Value { get; set; }
+        }
 
-            public class Source
-            {
-                public int Id { get; set; }
-                public string Title { get; set; }
-                public string CodeName { get; set; }
-                public string Nickname { get; set; }
-                public string ScreenName { get; set; }
-            }
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
+        {
+            cfg.CreateMap<Source, Destination>()
+                .ForMember(dest => dest.Value, opt =>
+                {
+                    opt.Condition(src => src.Value > 0);
+                    opt.ResolveUsing((Source src) =>
+                    {
+                        return 10;
+                    });
+                });
+        });
 
-            public class Destination
-            {
-                private double _height;
+        [Fact]
+        public void Should_skip_the_mapping_when_the_condition_is_true()
+        {
+            var destination = Mapper.Map<Source, Destination>(new Source { Value = -1 });
 
-                public int Id { get; set; }
-                public virtual string Name { get; protected set; }
-                public string Title { get; internal set; }
-                public string CodeName { get; private set; }
-                public string Nickname { get; private set; }
-                public string ScreenName { get; private set; }
-                public int Age { get; private set; }
+            destination.Value.ShouldEqual(0);
+        }
 
-                public double Height
-                {
-                    get { return _height; }
-                }
+        [Fact]
+        public void Should_execute_the_mapping_when_the_condition_is_false()
+        {
+            Mapper.Map<Source, Destination>(new Source { Value = 7 }).Value.ShouldEqual(10);
+        }
+    }
 
-                public Destination()
-                {
-                    _height = 60;
-                }
-            }
+    public class When_configuring_a_map_to_ignore_all_properties_with_an_inaccessible_setter : AutoMapperSpecBase
+    {
+        private Destination _destination;
 
-            protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
-            {
-                cfg.CreateMap<Source, Destination>()
-                    .ForMember(dest => dest.ScreenName, opt => opt.MapFrom(src => src.ScreenName))
-                    .IgnoreAllPropertiesWithAnInaccessibleSetter()
-                    .ForMember(dest => dest.Nickname, opt => opt.MapFrom(src => src.Nickname));
-            });
+        public class Source
+        {
+            public int Id { get; set; }
+            public string Title { get; set; }
+            public string CodeName { get; set; }
+            public string Nickname { get; set; }
+            public string ScreenName { get; set; }
+        }
 
-            protected override void Because_of()
-            {
-                _destination = Mapper.Map<Source, Destination>(new Source { Id = 5, CodeName = "007", Nickname = "Jimmy", ScreenName = "jbogard" });
-            }
+        public class Destination
+        {
+            private double _height;
 
-            [Fact]
-            public void Should_consider_the_configuration_valid_even_if_some_properties_with_an_inaccessible_setter_are_unmapped()
-            {
-                typeof(AutoMapperConfigurationException).ShouldNotBeThrownBy(Configuration.AssertConfigurationIsValid);
-            }
+            public int Id { get; set; }
+            public virtual string Name { get; protected set; }
+            public string Title { get; internal set; }
+            public string CodeName { get; private set; }
+            public string Nickname { get; private set; }
+            public string ScreenName { get; private set; }
+            public int Age { get; private set; }
 
-            [Fact]
-            public void Should_map_a_property_with_an_inaccessible_setter_if_a_specific_mapping_is_configured_after_the_ignore_method()
+            public double Height
             {
-                _destination.Nickname.ShouldEqual("Jimmy");
+                get { return _height; }
             }
 
-            [Fact]
-            public void Should_not_map_a_property_with_an_inaccessible_setter_if_no_specific_mapping_is_configured_even_though_name_and_type_match()
+            public Destination()
             {
-                _destination.CodeName.ShouldBeNull();
+                _height = 60;
             }
+        }
 
-            [Fact]
-            public void Should_not_map_a_property_with_no_public_setter_if_a_specific_mapping_is_configured_before_the_ignore_method()
-            {
-                _destination.ScreenName.ShouldBeNull();
-            }
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
+        {
+            cfg.CreateMap<Source, Destination>()
+                .ForMember(dest => dest.ScreenName, opt => opt.MapFrom(src => src.ScreenName))
+                .IgnoreAllPropertiesWithAnInaccessibleSetter()
+                .ForMember(dest => dest.Nickname, opt => opt.MapFrom(src => src.Nickname));
+        });
+
+        protected override void Because_of()
+        {
+            _destination = Mapper.Map<Source, Destination>(new Source { Id = 5, CodeName = "007", Nickname = "Jimmy", ScreenName = "jbogard" });
         }
 
-        public class When_configuring_a_reverse_map_to_ignore_all_source_properties_with_an_inaccessible_setter : AutoMapperSpecBase
+        [Fact]
+        public void Should_consider_the_configuration_valid_even_if_some_properties_with_an_inaccessible_setter_are_unmapped()
         {
-            private Destination _destination;
-            private Source _source;
+            typeof(AutoMapperConfigurationException).ShouldNotBeThrownBy(Configuration.AssertConfigurationIsValid);
+        }
 
-            public class Source
-            {
-                public int Id { get; set; }
-                public string Name { get; set; }
-                public int Age { get; set; }
-                public string Force { get; set; }
-                public string ReverseForce { get; private set; }
-                public string Respect { get; private set; }
-                public int Foo { get; private set; }
-                public int Bar { get; protected set; }
-
-                public void Initialize()
-                {
-                    ReverseForce = "You With";
-                    Respect = "R-E-S-P-E-C-T";
-                }
-            }
+        [Fact]
+        public void Should_map_a_property_with_an_inaccessible_setter_if_a_specific_mapping_is_configured_after_the_ignore_method()
+        {
+            _destination.Nickname.ShouldEqual("Jimmy");
+        }
 
-            public class Destination
-            {
-                public string Name { get; set; }
-                public int Age { get; set; }
-                public bool IsVisible { get; set; }
-                public string Force { get; private set; }
-                public string ReverseForce { get; set; }
-                public string Respect { get; set; }
-                public int Foz { get; private set; }
-                public int Baz { get; protected set; }
-            }
+        [Fact]
+        public void Should_not_map_a_property_with_an_inaccessible_setter_if_no_specific_mapping_is_configured_even_though_name_and_type_match()
+        {
+            _destination.CodeName.ShouldBeNull();
+        }
 
-            protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
-            {
-                cfg.CreateMap<Source, Destination>()
-                    .IgnoreAllPropertiesWithAnInaccessibleSetter()
-                    .ForMember(dest => dest.IsVisible, opt => opt.Ignore())
-                    .ForMember(dest => dest.Force, opt => opt.MapFrom(src => src.Force))
-                    .ReverseMap()
-                    .IgnoreAllSourcePropertiesWithAnInaccessibleSetter()
-                    .ForMember(dest => dest.ReverseForce, opt => opt.MapFrom(src => src.ReverseForce))
-                    .ForSourceMember(dest => dest.IsVisible, opt => opt.Ignore());
-            });
-
-            protected override void Because_of()
-            {
-                var source = new Source { Id = 5, Name = "Bob", Age = 35, Force = "With You" };
-                source.Initialize();
-                _destination = Mapper.Map<Source, Destination>(source);
-                _source = Mapper.Map<Destination, Source>(_destination);
-            }
+        [Fact]
+        public void Should_not_map_a_property_with_no_public_setter_if_a_specific_mapping_is_configured_before_the_ignore_method()
+        {
+            _destination.ScreenName.ShouldBeNull();
+        }
+    }
 
-            [Fact]
-            public void Should_consider_the_configuration_valid_even_if_some_properties_with_an_inaccessible_setter_are_unmapped()
-            {
-                typeof(AutoMapperConfigurationException).ShouldNotBeThrownBy(Configuration.AssertConfigurationIsValid);
-            }
+    public class When_configuring_a_reverse_map_to_ignore_all_source_properties_with_an_inaccessible_setter : AutoMapperSpecBase
+    {
+        private Destination _destination;
+        private Source _source;
 
-            [Fact]
-            public void Should_forward_and_reverse_map_a_property_that_is_accessible_on_both_source_and_destination()
+        public class Source
+        {
+            public int Id { get; set; }
+            public string Name { get; set; }
+            public int Age { get; set; }
+            public string Force { get; set; }
+            public string ReverseForce { get; private set; }
+            public string Respect { get; private set; }
+            public int Foo { get; private set; }
+            public int Bar { get; protected set; }
+
+            public void Initialize()
             {
-                _source.Name.ShouldEqual("Bob");
+                ReverseForce = "You With";
+                Respect = "R-E-S-P-E-C-T";
             }
+        }
 
-            [Fact]
-            public void Should_forward_and_reverse_map_an_inaccessible_destination_property_if_a_mapping_is_defined()
-            {
-                _source.Force.ShouldEqual("With You");
-            }
+        public class Destination
+        {
+            public string Name { get; set; }
+            public int Age { get; set; }
+            public bool IsVisible { get; set; }
+            public string Force { get; private set; }
+            public string ReverseForce { get; set; }
+            public string Respect { get; set; }
+            public int Foz { get; private set; }
+            public int Baz { get; protected set; }
+        }
 
-            [Fact]
-            public void Should_forward_and_reverse_map_an_inaccessible_source_property_if_a_mapping_is_defined()
-            {
-                _source.ReverseForce.ShouldEqual("You With");
-            }
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg =>
+        {
+            cfg.CreateMap<Source, Destination>()
+                .IgnoreAllPropertiesWithAnInaccessibleSetter()
+                .ForMember(dest => dest.IsVisible, opt => opt.Ignore())
+                .ForMember(dest => dest.Force, opt => opt.MapFrom(src => src.Force))
+                .ReverseMap()
+                .IgnoreAllSourcePropertiesWithAnInaccessibleSetter()
+                .ForMember(dest => dest.ReverseForce, opt => opt.MapFrom(src => src.ReverseForce))
+                .ForSourceMember(dest => dest.IsVisible, opt => opt.Ignore());
+        });
+
+        protected override void Because_of()
+        {
+            var source = new Source { Id = 5, Name = "Bob", Age = 35, Force = "With You" };
+            source.Initialize();
+            _destination = Mapper.Map<Source, Destination>(source);
+            _source = Mapper.Map<Destination, Source>(_destination);
+        }
 
-            [Fact]
-            public void Should_forward_and_reverse_map_an_inaccessible_source_property_even_if_a_mapping_is_not_defined()
-            {
-                _source.Respect.ShouldEqual("R-E-S-P-E-C-T"); // justification: if the mapping works one way, it should work in reverse
-            }
+        [Fact]
+        public void Should_consider_the_configuration_valid_even_if_some_properties_with_an_inaccessible_setter_are_unmapped()
+        {
+            typeof(AutoMapperConfigurationException).ShouldNotBeThrownBy(Configuration.AssertConfigurationIsValid);
+        }
+
+        [Fact]
+        public void Should_forward_and_reverse_map_a_property_that_is_accessible_on_both_source_and_destination()
+        {
+            _source.Name.ShouldEqual("Bob");
+        }
+
+        [Fact]
+        public void Should_forward_and_reverse_map_an_inaccessible_destination_property_if_a_mapping_is_defined()
+        {
+            _source.Force.ShouldEqual("With You");
+        }
+
+        [Fact]
+        public void Should_forward_and_reverse_map_an_inaccessible_source_property_if_a_mapping_is_defined()
+        {
+            _source.ReverseForce.ShouldEqual("You With");
+        }
+
+        [Fact]
+        public void Should_forward_and_reverse_map_an_inaccessible_source_property_even_if_a_mapping_is_not_defined()
+        {
+            _source.Respect.ShouldEqual("R-E-S-P-E-C-T"); // justification: if the mapping works one way, it should work in reverse
         }
     }
 }
\ No newline at end of file
diff --git a/src/UnitTests/Internal/PrimitiveExtensionsTester.cs b/src/UnitTests/Internal/PrimitiveExtensionsTester.cs
index 163d06af..0b743ed4 100644
--- a/src/UnitTests/Internal/PrimitiveExtensionsTester.cs
+++ b/src/UnitTests/Internal/PrimitiveExtensionsTester.cs
@@ -9,7 +9,27 @@ namespace AutoMapper.UnitTests
 
     public class PrimitiveExtensionsTester
 	{
-		[Fact]
+        interface Interface
+        {
+            int Value { get; }
+        }
+
+        class DestinationClass : Interface
+        {
+            int Interface.Value { get { return 123; } }
+
+            public int PrivateProperty { get; private set; }
+
+            public int PublicProperty { get; set; }
+        }
+
+        [Fact]
+        public void Should_find_explicitly_implemented_member()
+        {
+            typeof(DestinationClass).GetFieldOrProperty("Value").ShouldNotBeNull();
+        }
+
+        [Fact]
 		public void Should_not_flag_only_enumerable_type_as_writeable_collection()
 		{
 			typeof(string).IsListOrDictionaryType().ShouldBeFalse();
