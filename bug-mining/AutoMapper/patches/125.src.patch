diff --git a/src/AutoMapper/Mapper.cs b/src/AutoMapper/Mapper.cs
index 0e242141..61b5eaec 100644
--- a/src/AutoMapper/Mapper.cs
+++ b/src/AutoMapper/Mapper.cs
@@ -337,6 +337,10 @@ object IRuntimeMapper.Map(object source, object destination, Type sourceType, Ty
 
         object IRuntimeMapper.CreateObject(ResolutionContext context)
         {
+            if(context.DestinationValue != null)
+            {
+                return context.DestinationValue;
+            }
             return !_configurationProvider.AllowNullDestinationValues
                 ? ObjectCreator.CreateNonNullValue(context.DestinationType)
                 : ObjectCreator.CreateObject(context.DestinationType);
diff --git a/src/AutoMapper/MapperConfiguration.cs b/src/AutoMapper/MapperConfiguration.cs
index 7920126f..dbd276e6 100644
--- a/src/AutoMapper/MapperConfiguration.cs
+++ b/src/AutoMapper/MapperConfiguration.cs
@@ -186,7 +186,7 @@ public bool AllowNullCollections
         {
             var key = new TypePair(typeof (TSource), typeof (TDestination));
             var mapRequest = new MapRequest(key, types);
-            return (Func<TSource, TDestination, ResolutionContext, TDestination>) _mapPlanCache.GetOrAdd(mapRequest, mapReq =>
+            return (Func<TSource, TDestination, ResolutionContext, TDestination>)_mapPlanCache.GetOrAdd(mapRequest, mapReq =>
             {
                 var typeMap = ResolveTypeMap(types);
 
@@ -194,12 +194,12 @@ public bool AllowNullCollections
                 {
                     var mapExpression = typeMap.MapExpression;
 
-                    if (mapExpression.Parameters[0].Type != typeof (TSource)
-                        || mapExpression.Parameters[1].Type != typeof (TDestination))
+                    if(mapExpression.Parameters[0].Type != typeof(TSource)
+                        || mapExpression.Parameters[1].Type != typeof(TDestination))
                     {
-                        var srcParam = Parameter(typeof (TSource), "src");
-                        var destParam = Parameter(typeof (TDestination), "dest");
-                        var ctxtParam = Parameter(typeof (ResolutionContext), "ctxt");
+                        var srcParam = Parameter(typeof(TSource), "src");
+                        var destParam = Parameter(typeof(TDestination), "dest");
+                        var ctxtParam = Parameter(typeof(ResolutionContext), "ctxt");
 
                         mapExpression = Lambda(ToType(Invoke(typeMap.MapExpression,
                             ToType(srcParam, typeMap.MapExpression.Parameters[0].Type),
@@ -209,24 +209,9 @@ public bool AllowNullCollections
                             srcParam, destParam, ctxtParam);
                     }
 
-                    var autoMapException = Parameter(typeof(AutoMapperMappingException), "ex");
-                    var exception = Parameter(typeof(Exception), "ex");
-
-                    var mappingExceptionCtor = typeof(AutoMapperMappingException).GetTypeInfo().DeclaredConstructors
-                        .Where(ci => ci.GetParameters().Count() == 2)
-                        .First(ci => ci.GetParameters()[0].ParameterType == typeof(ResolutionContext) && ci.GetParameters()[1].ParameterType == typeof(Exception));
+                    mapExpression = TryCatch(mapExpression, mapExpression.Parameters[0], mapExpression.Parameters[1], mapExpression.Parameters[2]);
 
-                    mapExpression = Lambda(TryCatch(mapExpression.Body,
-                        MakeCatchBlock(typeof(AutoMapperMappingException), autoMapException,
-                            Block(Assign(Property(autoMapException, "Context"), mapExpression.Parameters[2]),
-                            Rethrow(),
-                            Default(typeof(TDestination))), null),
-                        MakeCatchBlock(typeof(Exception), exception, Block(
-                            Throw(New(mappingExceptionCtor, mapExpression.Parameters[2], exception)),
-                            Default(typeof(TDestination))), null)),
-                        mapExpression.Parameters);
-
-                    return (Func<TSource, TDestination, ResolutionContext, TDestination>) mapExpression.Compile();
+                    return (Func<TSource, TDestination, ResolutionContext, TDestination>)mapExpression.Compile();
                     //return new Func<TSource, TDestination, ResolutionContext, TDestination>((src, dest, context) =>
                     //{
                     //    try
@@ -269,6 +254,28 @@ public bool AllowNullCollections
             });
         }
 
+        private static LambdaExpression TryCatch(LambdaExpression mapExpression, ParameterExpression source, ParameterExpression destination, ParameterExpression context)
+        {
+            var autoMapException = Parameter(typeof(AutoMapperMappingException), "ex");
+            var exception = Parameter(typeof(Exception), "ex");
+
+            var mappingExceptionCtor = 
+                (from c in typeof(AutoMapperMappingException).GetConstructors()
+                let parameters = c.GetParameters()
+                where parameters.Length == 2 && parameters[0].ParameterType == typeof(ResolutionContext) && parameters[1].ParameterType == typeof(Exception)
+                select c).Single();
+
+            return Lambda(Expression.TryCatch(mapExpression.Body,
+                MakeCatchBlock(typeof(AutoMapperMappingException), autoMapException,
+                    Block(Assign(Property(autoMapException, "Context"), context),
+                    Rethrow(),
+                    Default(destination.Type)), null),
+                MakeCatchBlock(typeof(Exception), exception, Block(
+                    Throw(New(mappingExceptionCtor, context, exception)),
+                    Default(destination.Type)), null)),
+                source, destination, context);
+        }
+
         public Delegate GetMapperFunc(MapRequest mapRequest)
         {
             return _mapPlanCache.GetOrAdd(mapRequest, mapReq =>
@@ -315,29 +322,53 @@ public Delegate GetMapperFunc(MapRequest mapRequest)
 
                 IObjectMapper mapperToUse = _mappers.FirstOrDefault(om => om.IsMatch(tp));
 
-                return new Func<object, object, ResolutionContext, object>((src, dest, context) =>
-                {
-                    if (mapperToUse == null)
-                    {
-                        throw new AutoMapperMappingException(context,
-                            "Missing type map configuration or unsupported mapping.");
-                    }
-                    try
-                    {
-                        return mapperToUse.Map(context);
-                    }
-                    catch (AutoMapperMappingException)
-                    {
-                        throw;
-                    }
-                    catch (Exception ex)
-                    {
-                        throw new AutoMapperMappingException(context, ex);
-                    }
-                });
+                return GenerateObjectMapperExpression(mapReq, mapperToUse);
+                //return new Func<TSource, TDestination, ResolutionContext, TDestination>((src, dest, context) =>
+                //{
+                //    if(mapperToUse == null)
+                //    {
+                //        throw new AutoMapperMappingException(context,
+                //        "Missing type map configuration or unsupported mapping.");
+                //    }
+                //    try
+                //    {
+                //        return mapperToUse.Map(context);
+                //    }
+                //    catch(AutoMapperMappingException)
+                //    {
+                //        throw;
+                //    }
+                //    catch(Exception ex)
+                //    {
+                //        throw new AutoMapperMappingException(context, ex);
+                //    }
+                //});
             });
         }
 
+        private Delegate GenerateObjectMapperExpression(MapRequest mapRequest, IObjectMapper mapperToUse)
+        {
+            var destinationType = mapRequest.RuntimeTypes.DestinationType;
+
+            var source = Parameter(mapRequest.RuntimeTypes.SourceType, "source");
+            var destination = Parameter(destinationType, "destination");
+            var context = Parameter(typeof(ResolutionContext), "context");
+
+            var ctor = (from c in typeof(AutoMapperMappingException).GetConstructors()
+                            let parameters = c.GetParameters()
+                            where parameters.Length == 2 && parameters[0].ParameterType == typeof(ResolutionContext) && parameters[1].ParameterType == typeof(string)
+                            select c).Single();
+
+            var message = Constant("Missing type map configuration or unsupported mapping.");
+            var mapper = Constant(mapperToUse);
+            var throwIfNull = Condition(Equal(mapper, Constant(null)), Throw(New(ctor, context, message)), Empty());
+            var map = Call(mapper, "Map", new Type[0], context);
+            var mapToDestination = Lambda(ToType(map, destinationType), context);
+            var fullExpression = TryCatch(mapToDestination, source, destination, context);
+
+            return fullExpression.Compile();
+        }
+
         public TypeMap[] GetAllTypeMaps() => _typeMapRegistry.TypeMaps.ToArray();
 
         public TypeMap FindTypeMapFor(Type sourceType, Type destinationType) => FindTypeMapFor(new TypePair(sourceType, destinationType));
diff --git a/src/UnitTests/Bug/MapOverloadsWithDynamic.cs b/src/UnitTests/Bug/MapOverloadsWithDynamic.cs
new file mode 100644
index 00000000..1f749826
--- /dev/null
+++ b/src/UnitTests/Bug/MapOverloadsWithDynamic.cs
@@ -0,0 +1,55 @@
+ï»¿using Xunit;
+using Should;
+using System;
+using System.Dynamic;
+
+namespace AutoMapper.UnitTests.Bug
+{
+    public class MapOverloadsWithDynamic : AutoMapperSpecBase
+    {
+        Settings _settings;
+
+        class SubSetting
+        {
+            public int SubTimeout { get; set; }
+            public string SubColour { get; set; }
+        }
+
+        class Settings
+        {
+            public int Timeout { get; set; }
+            public string Colour { get; set; }
+            public SubSetting SubSettings { get; set; }
+        }
+
+        protected override MapperConfiguration Configuration { get; } = new MapperConfiguration(cfg => {});
+
+        protected override void Because_of()
+        {
+            // The SubSettings property is another ExpandoObject.
+            dynamic baseSettings = new ExpandoObject();
+            baseSettings.Timeout = 1;
+            baseSettings.Colour = "Red";
+            baseSettings.SubSettings = new ExpandoObject();
+            baseSettings.SubSettings.SubTimeout = 11;
+            baseSettings.SubSettings.SubColour = "Green";
+
+            // Create another object we will map onto the one above. 
+            // Notice that we do not set a Colour or SubColour property.
+            dynamic overrideSettings = new ExpandoObject();
+            overrideSettings.Timeout = 2;
+            overrideSettings.SubSettings = new ExpandoObject();
+            overrideSettings.SubSettings.SubTimeout = 22;
+
+            _settings = Mapper.Map<Settings>(baseSettings);
+            Mapper.Map(overrideSettings, _settings);
+        }
+
+        [Fact]
+        public void Should_work()
+        {
+            _settings.Timeout.ShouldEqual(2);
+            _settings.SubSettings.SubTimeout.ShouldEqual(22);
+        }
+    }
+}
\ No newline at end of file
