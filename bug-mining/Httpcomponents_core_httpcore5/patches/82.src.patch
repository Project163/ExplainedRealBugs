diff --git a/httpcore5/src/main/java/org/apache/hc/core5/reactor/ssl/SSLIOSession.java b/httpcore5/src/main/java/org/apache/hc/core5/reactor/ssl/SSLIOSession.java
index b636c0e19..36755e7d7 100644
--- a/httpcore5/src/main/java/org/apache/hc/core5/reactor/ssl/SSLIOSession.java
+++ b/httpcore5/src/main/java/org/apache/hc/core5/reactor/ssl/SSLIOSession.java
@@ -93,6 +93,7 @@ enum TLSHandShakeState { READY, INITIALIZED, HANDSHAKING, COMPLETE }
     private final AtomicInteger outboundClosedCount;
     private final AtomicReference<TLSHandShakeState> handshakeStateRef;
     private final IOEventHandler internalEventHandler;
+    private final int packetBufferSize;
 
     private int appEventMask;
 
@@ -178,9 +179,9 @@ public SSLIOSession(
 
         final SSLSession sslSession = this.sslEngine.getSession();
         // Allocate buffers for network (encrypted) data
-        final int netBufferSize = sslSession.getPacketBufferSize();
-        this.inEncrypted = SSLManagedBuffer.create(sslBufferMode, netBufferSize);
-        this.outEncrypted = SSLManagedBuffer.create(sslBufferMode, netBufferSize);
+        this.packetBufferSize = sslSession.getPacketBufferSize();
+        this.inEncrypted = SSLManagedBuffer.create(sslBufferMode, packetBufferSize);
+        this.outEncrypted = SSLManagedBuffer.create(sslBufferMode, packetBufferSize);
 
         // Allocate buffers for application (unencrypted) data
         final int appBufferSize = sslSession.getApplicationBufferSize();
@@ -668,9 +669,18 @@ public int write(final ByteBuffer src) throws IOException {
             if (this.handshakeStateRef.get() == TLSHandShakeState.READY) {
                 return 0;
             }
-            final ByteBuffer outEncryptedBuf = this.outEncrypted.acquire();
-            final SSLEngineResult result = doWrap(src, outEncryptedBuf);
-            return result.bytesConsumed();
+
+            for (;;) {
+                final ByteBuffer outEncryptedBuf = this.outEncrypted.acquire();
+                final SSLEngineResult result = doWrap(src, outEncryptedBuf);
+                if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {
+                    // We don't release the buffer here, it will be expanded (if needed)
+                    // and returned by the next attempt of SSLManagedBuffer#acquire() call.
+                    this.outEncrypted.ensureWriteable(packetBufferSize);
+                } else {
+                    return result.bytesConsumed();
+                }
+            }
         } finally {
             this.session.getLock().unlock();
         }
diff --git a/httpcore5/src/main/java/org/apache/hc/core5/reactor/ssl/SSLManagedBuffer.java b/httpcore5/src/main/java/org/apache/hc/core5/reactor/ssl/SSLManagedBuffer.java
index e3d21738a..1a184a7b8 100644
--- a/httpcore5/src/main/java/org/apache/hc/core5/reactor/ssl/SSLManagedBuffer.java
+++ b/httpcore5/src/main/java/org/apache/hc/core5/reactor/ssl/SSLManagedBuffer.java
@@ -57,13 +57,54 @@ abstract class SSLManagedBuffer {
      */
     abstract boolean hasData();
 
+    /**
+     * Expands the underlying buffer's to make sure it has enough write capacity to accommodate
+     * the required amount of bytes. This method has no side effect if the buffer has enough writeable
+     * capacity left.
+     * @param size the required write capacity
+     */
+    abstract void ensureWriteable(final int size);
+
+    /**
+     * Helper method to ensure additional writeable capacity with respect to the source buffer. It
+     * allocates a new buffer and copies all the data if needed, returning the new buffer. This method
+     * has no side effect if the source buffer has enough writeable capacity left.
+     * @param src source buffer
+     * @param size the required write capacity
+     * @return new buffer (or the source buffer of it  has enough writeable capacity left)
+     */
+    ByteBuffer ensureWriteable(final ByteBuffer src, final int size) {
+        if (src == null) {
+            // Nothing to do, the buffer is not allocated
+            return null;
+        }
+
+        // There is not enough capacity left, we need to expand
+        if (src.remaining() < size) {
+            final int additionalCapacityNeeded = size - src.remaining();
+            final ByteBuffer expanded = ByteBuffer.allocate(src.capacity() + additionalCapacityNeeded);
+
+            // use a duplicated buffer so we don't disrupt the limit of the original buffer
+            final ByteBuffer tmp = src.duplicate();
+            tmp.flip();
+
+            // Copy to expanded buffer
+            expanded.put(tmp);
+
+            // Use a new buffer
+            return expanded;
+        } else {
+            return src;
+        }
+    }
+
     static SSLManagedBuffer create(final SSLBufferMode mode, final int size) {
         return mode == SSLBufferMode.DYNAMIC ? new DynamicBuffer(size) : new StaticBuffer(size);
     }
 
     static final class StaticBuffer extends SSLManagedBuffer {
 
-        private final ByteBuffer buffer;
+        private ByteBuffer buffer;
 
         public StaticBuffer(final int size) {
             Args.positive(size, "size");
@@ -90,6 +131,10 @@ public boolean hasData() {
             return buffer.position() > 0;
         }
 
+        @Override
+        void ensureWriteable(final int size) {
+            buffer = ensureWriteable(buffer, size);
+        }
     }
 
     static final class DynamicBuffer extends SSLManagedBuffer {
@@ -126,6 +171,10 @@ public boolean hasData() {
             return wrapped != null && wrapped.position() > 0;
         }
 
+        @Override
+        void ensureWriteable(final int size) {
+            wrapped = ensureWriteable(wrapped, size);
+        }
     }
 
 }
