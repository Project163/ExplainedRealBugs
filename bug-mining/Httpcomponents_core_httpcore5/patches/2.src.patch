diff --git a/httpcore5/src/main/java/org/apache/hc/core5/http/bootstrap/io/HttpServer.java b/httpcore5/src/main/java/org/apache/hc/core5/http/bootstrap/io/HttpServer.java
index b85be210c..f9f8fb12b 100644
--- a/httpcore5/src/main/java/org/apache/hc/core5/http/bootstrap/io/HttpServer.java
+++ b/httpcore5/src/main/java/org/apache/hc/core5/http/bootstrap/io/HttpServer.java
@@ -29,9 +29,9 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.ServerSocket;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
+import java.util.Set;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -60,9 +60,9 @@ enum Status { READY, ACTIVE, STOPPING }
     private final HttpConnectionFactory<? extends DefaultBHttpServerConnection> connectionFactory;
     private final SSLServerSetupHandler sslSetupHandler;
     private final ExceptionLogger exceptionLogger;
-    private final ExecutorService listenerExecutorService;
+    private final ThreadPoolExecutor listenerExecutorService;
     private final ThreadGroup workerThreads;
-    private final ExecutorService workerExecutorService;
+    private final WorkerPoolExecutor workerExecutorService;
     private final AtomicReference<Status> status;
 
     private volatile ServerSocket serverSocket;
@@ -85,10 +85,14 @@ enum Status { READY, ACTIVE, STOPPING }
         this.connectionFactory = connectionFactory;
         this.sslSetupHandler = sslSetupHandler;
         this.exceptionLogger = exceptionLogger;
-        this.listenerExecutorService = Executors.newSingleThreadExecutor(
+        this.listenerExecutorService = new ThreadPoolExecutor(
+                1, 1, 0L, TimeUnit.MILLISECONDS,
+                new SynchronousQueue<Runnable>(),
                 new ThreadFactoryImpl("HTTP-listener-" + this.port));
         this.workerThreads = new ThreadGroup("HTTP-workers");
-        this.workerExecutorService = Executors.newCachedThreadPool(
+        this.workerExecutorService = new WorkerPoolExecutor(
+                0, Integer.MAX_VALUE, 1L, TimeUnit.SECONDS,
+                new SynchronousQueue<Runnable>(),
                 new ThreadFactoryImpl("HTTP-worker", this.workerThreads));
         this.status = new AtomicReference<>(Status.READY);
     }
@@ -133,6 +137,8 @@ public void start() throws IOException {
 
     public void stop() {
         if (this.status.compareAndSet(Status.ACTIVE, Status.STOPPING)) {
+            this.listenerExecutorService.shutdown();
+            this.workerExecutorService.shutdown();
             final RequestListener local = this.requestListener;
             if (local != null) {
                 try {
@@ -142,8 +148,6 @@ public void stop() {
                 }
             }
             this.workerThreads.interrupt();
-            this.listenerExecutorService.shutdown();
-            this.workerExecutorService.shutdown();
         }
     }
 
@@ -160,16 +164,13 @@ public void shutdown(final long gracePeriod, final TimeUnit timeUnit) {
                 Thread.currentThread().interrupt();
             }
         }
-        final List<Runnable> runnables = this.workerExecutorService.shutdownNow();
-        for (final Runnable runnable: runnables) {
-            if (runnable instanceof Worker) {
-                final Worker worker = (Worker) runnable;
-                final HttpServerConnection conn = worker.getConnection();
-                try {
-                    conn.shutdown();
-                } catch (final IOException ex) {
-                    this.exceptionLogger.log(ex);
-                }
+        final Set<Worker> workers = this.workerExecutorService.getWorkers();
+        for (Worker worker: workers) {
+            final HttpServerConnection conn = worker.getConnection();
+            try {
+                conn.shutdown();
+            } catch (IOException ex) {
+                this.exceptionLogger.log(ex);
             }
         }
     }
diff --git a/httpcore5/src/main/java/org/apache/hc/core5/http/bootstrap/io/WorkerPoolExecutor.java b/httpcore5/src/main/java/org/apache/hc/core5/http/bootstrap/io/WorkerPoolExecutor.java
new file mode 100644
index 000000000..82a15e46a
--- /dev/null
+++ b/httpcore5/src/main/java/org/apache/hc/core5/http/bootstrap/io/WorkerPoolExecutor.java
@@ -0,0 +1,74 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.hc.core5.http.bootstrap.io;
+
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * @since 4.4
+ */
+class WorkerPoolExecutor extends ThreadPoolExecutor {
+
+    private final Map<Worker, Boolean> workerSet;
+
+    public WorkerPoolExecutor(
+            final int corePoolSize,
+            final int maximumPoolSize,
+            final long keepAliveTime,
+            final TimeUnit unit,
+            final BlockingQueue<Runnable> workQueue,
+            final ThreadFactory threadFactory) {
+        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
+        this.workerSet = new ConcurrentHashMap<>();
+    }
+
+    @Override
+    protected void beforeExecute(final Thread t, final Runnable r) {
+        if (r instanceof Worker) {
+            this.workerSet.put((Worker) r, Boolean.TRUE);
+        }
+    }
+
+    @Override
+    protected void afterExecute(final Runnable r, final Throwable t) {
+        if (r instanceof Worker) {
+            this.workerSet.remove(r);
+        }
+    }
+
+    public Set<Worker> getWorkers() {
+        return new HashSet<>(this.workerSet.keySet());
+    }
+
+}
