diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDIndexed.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDIndexed.java
index ce0a47704c..87f5b1af2e 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDIndexed.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDIndexed.java
@@ -54,10 +54,17 @@ public class PDIndexed extends PDColorSpace
 
     private COSArray array;
 
+    private PDColorSpace baseColorspace = null;
+    private ColorModel baseColorModel = null;
+    
     /**
      * The lookup data as byte array.
      */
     private byte[] lookupData;
+
+    private byte[] indexedColorValues;
+    private int indexNumOfComponents;
+    private int maxIndex;
     
     /**
      * Constructor, default DeviceRGB, hival 255.
@@ -113,7 +120,7 @@ public class PDIndexed extends PDColorSpace
      */
     protected ColorSpace createColorSpace() throws IOException
     {
-        throw new IOException( "Not implemented" );
+        return getBaseColorSpace().getJavaColorSpace();
     }
 
     /**
@@ -127,40 +134,31 @@ public class PDIndexed extends PDColorSpace
      */
     public ColorModel createColorModel( int bpc ) throws IOException
     {
-        int size = getHighValue();
-        byte[] index = getLookupData();
-        PDColorSpace baseColorSpace = getBaseColorSpace();
-        ColorModel cm = null;
-        if( baseColorSpace instanceof PDDeviceRGB )
+        return createColorModel(bpc, -1);
+    }
+
+    /**
+     * Create a Java color model for this colorspace including the given mask value.
+     *
+     * @param bpc The number of bits per component.
+     * @param mask the mask value, -1 indicates no mask
+     *
+     * @return A color model that can be used for Java AWT operations.
+     *
+     * @throws IOException If there is an error creating the color model.
+     */
+    public ColorModel createColorModel( int bpc, int mask ) throws IOException
+    {
+        ColorModel colorModel = getBaseColorModel(bpc);
+        calculateIndexedColorValues(colorModel, bpc);
+        if (mask > -1)
         {
-            cm = new IndexColorModel(bpc, size+1, index,0,false);
+            return new IndexColorModel(bpc, maxIndex+1, indexedColorValues, 0, colorModel.hasAlpha(), mask);
         }
         else
         {
-            ColorModel baseColorModel = baseColorSpace.createColorModel(bpc);
-            if( baseColorModel.getTransferType() != DataBuffer.TYPE_BYTE )
-            {
-                throw new IOException( "Not implemented" );
-            }
-            byte[] r = new byte[size+1];
-            byte[] g = new byte[size+1];
-            byte[] b = new byte[size+1];
-            byte[] a = baseColorModel.hasAlpha() ? new byte[size+1] : null;
-            byte[] inData = new byte[baseColorModel.getNumComponents()];
-            for( int i = 0; i <= size; i++ )
-            {
-                System.arraycopy(index, i * inData.length, inData, 0, inData.length);
-                r[i] = (byte)baseColorModel.getRed(inData);
-                g[i] = (byte)baseColorModel.getGreen(inData);
-                b[i] = (byte)baseColorModel.getBlue(inData);
-                if(a != null)
-                {
-                    a[i] = (byte)baseColorModel.getAlpha(inData);
-                }
-            }
-            cm = a == null ? new IndexColorModel(bpc, size+1, r, g, b) : new IndexColorModel(bpc, size+1, r, g, b, a);
+            return new IndexColorModel(bpc, maxIndex+1, indexedColorValues, 0, colorModel.hasAlpha());
         }
-        return cm;
     }
 
     /**
@@ -172,8 +170,12 @@ public class PDIndexed extends PDColorSpace
      */
     public PDColorSpace getBaseColorSpace() throws IOException
     {
-        COSBase base = array.getObject( 1 );
-        return PDColorSpaceFactory.createColorSpace( base );
+        if (baseColorspace == null)
+        {
+            COSBase base = array.getObject( 1 );
+            baseColorspace = PDColorSpaceFactory.createColorSpace( base );
+        }
+        return baseColorspace;
     }
 
     /**
@@ -184,6 +186,7 @@ public class PDIndexed extends PDColorSpace
     public void setBaseColorSpace( PDColorSpace base )
     {
         array.set( 1, base.getCOSObject() );
+        baseColorspace = base;
     }
 
     /**
@@ -285,4 +288,74 @@ public class PDIndexed extends PDColorSpace
         COSString string = new COSString( data );
         array.set( 3, string );
     }
+
+    /**
+     * Returns the components of the color for the given index.
+     * @param index the index of the color value
+     * @return COSArray with the color components
+     * @throws IOException If the tint function is not supported
+     */
+    public float[] calculateColorValues(int index) throws IOException
+    {
+        // TODO bpc != 8 ??
+        calculateIndexedColorValues(getBaseColorModel(8), 8);
+        float[] colorValues = null;
+        if (index < maxIndex)
+        {
+            int bufferIndex = index * indexNumOfComponents;
+            colorValues = new float[indexNumOfComponents];
+            for (int i=0; i < indexNumOfComponents; i++)
+            {
+                colorValues[i] = (float)indexedColorValues[bufferIndex+i];
+            }
+        }
+        return colorValues;
+    }
+    
+    private ColorModel getBaseColorModel(int bpc) throws IOException
+    {
+        if (baseColorModel == null)
+        {
+            baseColorModel = getBaseColorSpace().createColorModel(bpc);
+        }
+        return baseColorModel;
+    }
+    
+    private void calculateIndexedColorValues(ColorModel colorModel, int bpc) throws IOException
+    {
+        if (indexedColorValues == null)
+        {
+            // number of possible color values in the target color space
+            int numberOfColorValues = 1 << bpc;
+            // number of indexed color values
+            int highValue = getHighValue();
+            // choose the correct size, sometimes there are more indexed values than needed
+            // and sometimes there are fewer indexed value than possible
+            maxIndex = Math.min(numberOfColorValues-1, highValue);
+            byte[] index = getLookupData();
+            if( baseColorModel.getTransferType() != DataBuffer.TYPE_BYTE )
+            {
+                throw new IOException( "Not implemented" );
+            }
+            boolean hasAlpha = baseColorModel.hasAlpha();
+            indexNumOfComponents = 3 + ( hasAlpha ? 1 : 0);
+            int buffersize = (maxIndex+1) * indexNumOfComponents;
+            indexedColorValues = new byte[buffersize];
+            byte[] inData = new byte[baseColorModel.getNumComponents()];
+            int bufferIndex = 0;
+            for( int i = 0; i <= maxIndex; i++ )
+            {
+                System.arraycopy(index, i * inData.length, inData, 0, inData.length);
+                indexedColorValues[bufferIndex] = (byte)colorModel.getRed(inData);
+                indexedColorValues[bufferIndex+1] = (byte)colorModel.getGreen(inData);
+                indexedColorValues[bufferIndex+2] = (byte)colorModel.getBlue(inData);
+                if(hasAlpha)
+                {
+                    indexedColorValues[bufferIndex+3] = (byte)colorModel.getAlpha(inData);
+                }
+                bufferIndex += indexNumOfComponents;
+            }
+        }
+    }
+
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
index 31876d4e0a..2db4bd5611 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
@@ -200,50 +200,14 @@ public class PDPixelMap extends PDXObjectImage
             if (colorspace instanceof PDIndexed)
             {
                 PDIndexed csIndexed = (PDIndexed)colorspace;
-                // the base color space uses 8 bit per component, as the indexed color values
-                // of an indexed color space are always in a range from 0 to 255
-                ColorModel baseColorModel = csIndexed.getBaseColorSpace().createColorModel(8);
-                // number of possible color values in the target color space
-                int numberOfColorValues = 1 << bpc;
-                // number of indexed color values
-                int highValue = csIndexed.getHighValue();
-                // choose the correct size, sometimes there are more indexed values than needed
-                // and sometimes there are fewer indexed value than possible
-                int size = Math.min(numberOfColorValues-1, highValue);
-                byte[] index = csIndexed.getLookupData();
-                boolean hasAlpha = baseColorModel.hasAlpha();
                 COSBase maskArray = getMask();
-                if( baseColorModel.getTransferType() != DataBuffer.TYPE_BYTE )
-                {
-                    throw new IOException( "Not implemented" );
-                }
-                // the IndexColorModel uses RGB-based color values
-                // which leads to 3 color components and a optional alpha channel
-                int numberOfComponents = 3 + (hasAlpha ? 1 : 0);
-                int buffersize = (size+1) * numberOfComponents;
-                byte[] colorValues = new byte[buffersize];
-                byte[] inData = new byte[baseColorModel.getNumComponents()];
-                int bufferIndex = 0;
-                for( int i = 0; i <= size; i++ )
-                {
-                    System.arraycopy(index, i * inData.length, inData, 0, inData.length);
-                    // convert the indexed color values to RGB 
-                    colorValues[bufferIndex] = (byte)baseColorModel.getRed(inData);
-                    colorValues[bufferIndex+1] = (byte)baseColorModel.getGreen(inData);
-                    colorValues[bufferIndex+2] = (byte)baseColorModel.getBlue(inData);
-                    if( hasAlpha )
-                    {
-                        colorValues[bufferIndex+3] = (byte)baseColorModel.getAlpha(inData);
-                    }
-                    bufferIndex += numberOfComponents;
-                }
                 if (maskArray != null && maskArray instanceof COSArray)
                 {
-                    cm = new IndexColorModel(bpc, size+1, colorValues, 0, hasAlpha, ((COSArray)maskArray).getInt(0));
+                    cm = csIndexed.createColorModel(bpc, ((COSArray)maskArray).getInt(0));
                 }
                 else
                 {
-                    cm = new IndexColorModel(bpc, size+1, colorValues, 0, hasAlpha);
+                    cm = csIndexed.createColorModel(bpc);
                 }
             }
             else if (colorspace instanceof PDSeparation)
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetNonStrokingColor.java b/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetNonStrokingColor.java
index 03792a1e55..286667ebd4 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetNonStrokingColor.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetNonStrokingColor.java
@@ -28,6 +28,7 @@ import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceRGB;
 import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceCMYK;
 import org.apache.pdfbox.pdmodel.graphics.color.PDICCBased;
 import org.apache.pdfbox.pdmodel.graphics.color.PDCalRGB;
+import org.apache.pdfbox.pdmodel.graphics.color.PDIndexed;
 import org.apache.pdfbox.pdmodel.graphics.color.PDPattern;
 import org.apache.pdfbox.pdmodel.graphics.color.PDSeparation;
 import org.apache.pdfbox.util.PDFOperator;
@@ -91,6 +92,10 @@ public class SetNonStrokingColor extends OperatorProcessor
             {
                 newOperator = new SetNonStrokingPattern();
             }
+            else if (colorSpace instanceof PDIndexed)
+            {
+                newOperator = new SetNonStrokingIndexed();
+            }
 
             if (newOperator != null) 
             {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetNonStrokingIndexed.java b/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetNonStrokingIndexed.java
new file mode 100644
index 0000000000..94926d8986
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetNonStrokingIndexed.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pdfbox.util.operator;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.pdfbox.cos.COSBase;
+import org.apache.pdfbox.cos.COSInteger;
+import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
+import org.apache.pdfbox.pdmodel.graphics.color.PDColorState;
+import org.apache.pdfbox.pdmodel.graphics.color.PDIndexed;
+import org.apache.pdfbox.util.PDFOperator;
+
+/**
+ * 
+ * @version $Revision: 1.0 $
+ */
+public class SetNonStrokingIndexed extends OperatorProcessor 
+{
+
+    /**
+     * scn Set color space for non stroking operations.
+     * @param operator The operator that is being executed.
+     * @param arguments List
+     * @throws IOException If an error occurs while processing the font.
+     */
+    public void process(PDFOperator operator, List<COSBase> arguments) throws IOException
+    {
+        PDColorState colorInstance = context.getGraphicsState().getNonStrokingColor();
+        PDColorSpace colorSpace = colorInstance.getColorSpace();
+
+        if (colorSpace != null) 
+        {
+            PDIndexed indexed = (PDIndexed) colorSpace;
+            colorSpace = indexed.getBaseColorSpace();
+            COSInteger colorValue = (COSInteger)arguments.get(0);
+            colorInstance.setColorSpaceValue(indexed.calculateColorValues(colorValue.intValue()));
+        }
+    }
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetStrokingColor.java b/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetStrokingColor.java
index 6952023cfd..0b0497b189 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetStrokingColor.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetStrokingColor.java
@@ -28,6 +28,7 @@ import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceRGB;
 import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceCMYK;
 import org.apache.pdfbox.pdmodel.graphics.color.PDICCBased;
 import org.apache.pdfbox.pdmodel.graphics.color.PDCalRGB;
+import org.apache.pdfbox.pdmodel.graphics.color.PDIndexed;
 import org.apache.pdfbox.pdmodel.graphics.color.PDPattern;
 import org.apache.pdfbox.pdmodel.graphics.color.PDSeparation;
 import org.apache.pdfbox.util.PDFOperator;
@@ -91,6 +92,10 @@ public class SetStrokingColor extends OperatorProcessor
             {
                 newOperator = new SetStrokingPattern();
             }
+            else if (colorSpace instanceof PDIndexed)
+            {
+                newOperator = new SetStrokingIndexed();
+            }
 
             if (newOperator != null) 
             {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetStrokingIndexed.java b/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetStrokingIndexed.java
new file mode 100644
index 0000000000..df0b6b0378
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/util/operator/SetStrokingIndexed.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pdfbox.util.operator;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.pdfbox.cos.COSBase;
+import org.apache.pdfbox.cos.COSInteger;
+import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
+import org.apache.pdfbox.pdmodel.graphics.color.PDColorState;
+import org.apache.pdfbox.pdmodel.graphics.color.PDIndexed;
+import org.apache.pdfbox.util.PDFOperator;
+
+/**
+ * 
+ * @version $Revision: 1.0 $
+ */
+public class SetStrokingIndexed extends OperatorProcessor 
+{
+
+    /**
+     * scn Set color space for non stroking operations.
+     * @param operator The operator that is being executed.
+     * @param arguments List
+     * @throws IOException If an error occurs while processing the font.
+     */
+    public void process(PDFOperator operator, List<COSBase> arguments) throws IOException
+    {
+        PDColorState colorInstance = context.getGraphicsState().getStrokingColor();
+        PDColorSpace colorSpace = colorInstance.getColorSpace();
+
+        if (colorSpace != null) 
+        {
+            PDIndexed indexed = (PDIndexed) colorSpace;
+            colorSpace = indexed.getBaseColorSpace();
+            COSInteger colorValue = (COSInteger)arguments.get(0);
+            colorInstance.setColorSpaceValue(indexed.calculateColorValues(colorValue.intValue()));
+        }
+    }
+}
