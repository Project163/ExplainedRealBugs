diff --git a/pdfbox/src/main/java/org/apache/pdfbox/examples/pdmodel/EmbeddedFiles.java b/pdfbox/src/main/java/org/apache/pdfbox/examples/pdmodel/EmbeddedFiles.java
index 5b64424a15..584bbccacf 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/examples/pdmodel/EmbeddedFiles.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/examples/pdmodel/EmbeddedFiles.java
@@ -18,9 +18,10 @@ package org.apache.pdfbox.examples.pdmodel;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.util.Collections;
 import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.SortedMap;
+import java.util.TreeMap;
 
 import org.apache.pdfbox.exceptions.COSVisitorException;
 
@@ -100,9 +101,7 @@ public class EmbeddedFiles
             fs.setEmbeddedFile( ef );
 
             //now add the entry to the embedded file tree and set in the document.
-            Map efMap = new HashMap();
-            efMap.put( "My first attachment", fs );
-            efTree.setNames( efMap );
+            efTree.setNames( Collections.singletonMap( "My first attachment",  fs ) );
             PDDocumentNameDictionary names = new PDDocumentNameDictionary( doc.getDocumentCatalog() );
             names.setEmbeddedFiles( efTree );
             doc.getDocumentCatalog().setNames( names );
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDNameTreeNode.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDNameTreeNode.java
index 19de438c03..13f2523e8d 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDNameTreeNode.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDNameTreeNode.java
@@ -20,7 +20,7 @@ import java.io.IOException;
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -162,32 +162,30 @@ public class PDNameTreeNode implements COSObjectable
 
 
     /**
-     * This will return a map of names.  The key will be a java.lang.String the value will
-     * depend on where this class is being used.
-     *
-     * @return A map of cos objects.
+     * This will return a map of names. The key will be a string, and the
+     * value will depend on where this class is being used.
      *
+     * @return ordered map of cos objects
      * @throws IOException If there is an error while creating the sub types.
      */
-    public Map getNames() throws IOException
+    public Map<String, Object> getNames() throws IOException
     {
-        Map names = null;
         COSArray namesArray = (COSArray)node.getDictionaryObject( COSName.NAMES );
         if( namesArray != null )
         {
-            names = new HashMap();
+            Map<String, Object> names = new LinkedHashMap<String, Object>();
             for( int i=0; i<namesArray.size(); i+=2 )
             {
                 COSString key = (COSString)namesArray.getObject(i);
                 COSBase cosValue = namesArray.getObject( i+1 );
-                Object pdValue = convertCOSToPD( cosValue );
-
-                names.put( key.getString(), pdValue );
+                names.put( key.getString(), convertCOSToPD( cosValue ) );
             }
-            names = Collections.unmodifiableMap(names);
+            return Collections.unmodifiableMap(names);
+        }
+        else
+        {
+            return null;
         }
-
-        return names;
     }
 
     /**
@@ -231,9 +229,9 @@ public class PDNameTreeNode implements COSObjectable
      * values must be a COSObjectable.  This method will set the appropriate upper and lower
      * limits based on the keys in the map.
      *
-     * @param names The map of names to objects.
+     * @param names map of names to objects, or <code>null</code>
      */
-    public void setNames( Map names )
+    public void setNames( Map<String, ? extends COSObjectable> names )
     {
         if( names == null )
         {
@@ -242,26 +240,16 @@ public class PDNameTreeNode implements COSObjectable
         }
         else
         {
-            List keys = new ArrayList( names.keySet() );
-            Collections.sort( keys );
             COSArray array = new COSArray();
-            for( int i=0; i<keys.size(); i++ )
-            {
-                String key = (String)keys.get(i);
-                array.add( new COSString( key ) );
-                COSObjectable obj = (COSObjectable)names.get( key );
-                array.add( obj );
-            }
-            String lower = null;
-            String upper = null;
-            if( keys.size() > 0 )
-            {
-                lower = (String)keys.get( 0 );
-                upper = (String)keys.get( keys.size()-1 );
+            List<String> keys = new ArrayList<String>(names.keySet());
+            Collections.sort(keys);
+            for (String key : keys) {
+                array.add(new COSString(key));
+                array.add(names.get(key));
             }
-            setUpperLimit( upper );
-            setLowerLimit( lower );
-            node.setItem( "Names", array );
+            setLowerLimit(keys.get(0));
+            setUpperLimit(keys.get(keys.size() - 1));
+            node.setItem("Names", array);
         }
     }
 
