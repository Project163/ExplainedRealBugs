diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TriangleBasedShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TriangleBasedShadingContext.java
index ffaed711fc..8d5dbb034b 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TriangleBasedShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TriangleBasedShadingContext.java
@@ -95,110 +95,6 @@ abstract class TriangleBasedShadingContext extends ShadingContext implements Pai
                 boundary[2] = Math.max(boundary[2], deviceBounds.y);
                 boundary[3] = Math.min(boundary[3], deviceBounds.y + deviceBounds.height);
 
-//                // https://github.com/mozilla/pdf.js/blob/master/src/display/pattern_helper.js
-//                // drawTriangle
-//                // Very basic Gouraud-shaded triangle rasterization algorithm.
-//                // rev 398e6ac Yury Delendik
-//                float x1 = (float) tri.corner[0].getX();
-//                float y1 = (float) tri.corner[0].getY();
-//                float x2 = (float) tri.corner[1].getX();
-//                float y2 = (float) tri.corner[1].getY();
-//                float x3 = (float) tri.corner[2].getX();
-//                float y3 = (float) tri.corner[2].getY();
-//                float tmpd;
-//                float[] tmpf;
-//                float[] c1 = tri.color[0];
-//                float[] c2 = tri.color[1];
-//                float[] c3 = tri.color[2];
-//                if (y1 > y2)
-//                {
-//                    tmpd = x1;
-//                    x1 = x2;
-//                    x2 = tmpd;
-//                    tmpd = y1;
-//                    y1 = y2;
-//                    y2 = tmpd;
-//                    tmpf = c1;
-//                    c1 = c2;
-//                    c2 = tmpf;
-//                }
-//                if (y2 > y3)
-//                {
-//                    tmpd = x2;
-//                    x2 = x3;
-//                    x3 = tmpd;
-//                    tmpd = y2;
-//                    y2 = y3;
-//                    y3 = tmpd;
-//                    tmpf = c2;
-//                    c2 = c3;
-//                    c3 = tmpf;
-//                }
-//                if (y1 > y2)
-//                {
-//                    tmpd = x1;
-//                    x1 = x2;
-//                    x2 = tmpd;
-//                    tmpd = y1;
-//                    y1 = y2;
-//                    y2 = tmpd;
-//                    tmpf = c1;
-//                    c1 = c2;
-//                    c2 = tmpf;
-//                }
-//                if (y1 >= y3)
-//                {
-//                    //TODO needed? we're in degree 3
-//                    continue;
-//                }
-//                
-//                float[] ca = new float[numberOfColorComponents];
-//                float[] cb = new float[numberOfColorComponents];
-//                float[] cres = new float[numberOfColorComponents];
-//                for (int y = boundary[2]; y <= boundary[3]; y++)
-//                {
-//                    float k, xa, xb;
-//                    if (y < y2)
-//                    {
-//                        k = y < y1 ? 0 : y1 == y2 ? 1 : (y1 - y) / (y1 - y2);
-//                        xa = x1 - (x1 - x2) * k;
-//                        for (int i = 0; i < numberOfColorComponents; i++)
-//                        {
-//                            ca[i] = c1[i] - (c1[i] - c2[i]) * k;
-//                        }
-//                    }
-//                    else
-//                    {
-//                        k = y > y3 ? 1 : y2 == y3 ? 0 : (y2 - y) / (y2 - y3);
-//                        xa = x2 - (x2 - x3) * k;
-//                        for (int i = 0; i < numberOfColorComponents; i++)
-//                        {
-//                            ca[i] = c2[i] - (c2[i] - c3[i]) * k;
-//                        }
-//                    }
-//                    k = (y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3));
-//                    xb = x1 - (x1 - x3) * k;
-//                    for (int i = 0; i < numberOfColorComponents; i++)
-//                    {
-//                        cb[i] = c1[i] - (c1[i] - c3[i]) * k;
-//                    }
-//                    int x1r = Math.round(Math.min(xa, xb));
-//                    int x2r = Math.round(Math.max(xa, xb));
-//                    x1r = Math.max(x1r, boundary[0]);
-//                    x2r = Math.min(x2r, boundary[1]);
-//                    float div = xa - xb;
-//                    for (int x = x1r; x <= x2r; ++x)
-//                    {
-//                        k = (xa - x) / div;
-//                        k = k < 0 ? 0 : k > 1 ? 1 : k;
-//                        for (int i = 0; i < numberOfColorComponents; i++)
-//                        {
-//                            cres[i] = ca[i] - (ca[i] - cb[i]) * k;
-//                        }
-//                        map.put(new IntPoint(x, y), evalFunctionAndConvertToRGB(cres));
-//                    }
-//                }                
-                
                 for (int x = boundary[0]; x <= boundary[1]; x++)
                 {
                     for (int y = boundary[2]; y <= boundary[3]; y++)
