diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSInputStream.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSInputStream.java
index bf14cd6914..06840b28aa 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSInputStream.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSInputStream.java
@@ -17,20 +17,18 @@
 
 package org.apache.pdfbox.cos;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 
 import org.apache.pdfbox.filter.DecodeOptions;
 import org.apache.pdfbox.filter.DecodeResult;
 import org.apache.pdfbox.filter.Filter;
+import org.apache.pdfbox.io.RandomAccessInputStream;
+import org.apache.pdfbox.io.RandomAccessRead;
 
 /**
  * An InputStream which reads from an encoded COS stream.
@@ -71,26 +69,9 @@ public final class COSInputStream extends FilterInputStream
         {
             return new COSInputStream(in, Collections.<DecodeResult>emptyList());
         }
-
         List<DecodeResult> results = new ArrayList<>(filters.size());
-        InputStream input = in;
-        if (filters.size() > 1)
-        {
-            Set<Filter> filterSet = new HashSet<>(filters);
-            if (filterSet.size() != filters.size())
-            {
-                throw new IOException("Duplicate");
-            }
-        }
-        ByteArrayOutputStream output = new ByteArrayOutputStream();
-        // apply filters
-        for (int i = 0; i < filters.size(); i++)
-        {
-            output.reset();
-            results.add(filters.get(i).decode(input, output, parameters, i, options));
-            input = new ByteArrayInputStream(output.toByteArray());
-        }
-        return new COSInputStream(input, results);
+        RandomAccessRead decoded = Filter.decode(in, filters, parameters, options, results);
+        return new COSInputStream(new RandomAccessInputStream(decoded), results);
     }
 
     private final List<DecodeResult> decodeResults;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSStream.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSStream.java
index 8870eb0bd3..e773bbbde0 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSStream.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSStream.java
@@ -16,17 +16,13 @@
  */
 package org.apache.pdfbox.cos;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.FilterOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -197,37 +193,7 @@ public class COSStream extends COSDictionary implements Closeable
                 return new RandomAccessReadBuffer(createRawInputStream());
             }
         }
-        else
-        {
-            if (filterList.size() > 1)
-            {
-                Set<Filter> filterSet = new HashSet<>(filterList);
-                if (filterSet.size() != filterList.size())
-                {
-                    throw new IOException("Duplicate");
-                }
-            }
-            InputStream input = createRawInputStream();
-            ByteArrayOutputStream output = new ByteArrayOutputStream(input.available());
-            // apply filters
-            for (int i = 0; i < filterList.size(); i++)
-            {
-                if (i > 0)
-                {
-                    input = new ByteArrayInputStream(output.toByteArray());
-                    output.reset();
-                }
-                try
-                {
-                    filterList.get(i).decode(input, output, this, i, DecodeOptions.DEFAULT);
-                }
-                finally
-                {
-                    IOUtils.closeQuietly(input);
-                }
-            }
-            return new RandomAccessReadBuffer(output.toByteArray());
-        }
+        return Filter.decode(createRawInputStream(), filterList, this, DecodeOptions.DEFAULT, null);
     }
 
     /**
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/filter/Filter.java b/pdfbox/src/main/java/org/apache/pdfbox/filter/Filter.java
index 00eb082ec8..4b756c0a4e 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/filter/Filter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/filter/Filter.java
@@ -19,7 +19,10 @@ package org.apache.pdfbox.filter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.util.HashSet;
 import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
 import java.util.zip.Deflater;
 
 import javax.imageio.ImageIO;
@@ -31,6 +34,12 @@ import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
+import org.apache.pdfbox.io.IOUtils;
+import org.apache.pdfbox.io.RandomAccessInputStream;
+import org.apache.pdfbox.io.RandomAccessOutputStream;
+import org.apache.pdfbox.io.RandomAccessRead;
+import org.apache.pdfbox.io.RandomAccessReadBuffer;
+import org.apache.pdfbox.io.RandomAccessReadWriteBuffer;
 
 /**
  * A filter for stream data.
@@ -178,4 +187,66 @@ public abstract class Filter
         }
         return Math.max(-1, Math.min(Deflater.BEST_COMPRESSION, compressionLevel));
     }
+
+    /**
+     * Decodes data, with optional DecodeOptions. Not all filters support all options, and so callers should check the
+     * options' <code>honored</code> flag to test if they were applied.
+     *
+     * @param encoded the input stream holding the encoded data
+     * @param filterList list of filters to be used for decoding
+     * @param parameters the parameters used for decoding
+     * @param options additional options for decoding
+     * @param results list of optional decoding results for each filter
+     * @return the decoded stream data
+     * @throws IOException if the stream cannot be decoded
+     */
+    public static RandomAccessRead decode(InputStream encoded, List<Filter> filterList,
+            COSDictionary parameters, DecodeOptions options, List<DecodeResult> results)
+            throws IOException
+    {
+        int length = parameters.getInt(COSName.LENGTH,
+                RandomAccessReadBuffer.DEFAULT_CHUNK_SIZE_4KB);
+        if (filterList.size() > 1)
+        {
+            Set<Filter> filterSet = new HashSet<>(filterList);
+            if (filterSet.size() != filterList.size())
+            {
+                throw new IOException("Duplicate");
+            }
+        }
+        InputStream input = encoded;
+        RandomAccessReadWriteBuffer randomAccessWriteBuffer = null;
+        OutputStream output = null;
+        // apply filters
+        for (int i = 0; i < filterList.size(); i++)
+        {
+            if (i > 0)
+            {
+                randomAccessWriteBuffer.seek(0);
+                input = new RandomAccessInputStream(randomAccessWriteBuffer);
+                length = (int) randomAccessWriteBuffer.length();
+            }
+            // we don't know the size of the decoded stream, just estimate a 4 times bigger size than the encoded stream
+            // use the estimated stream size as chunk size, use the default chunk size as limit to avoid to big values
+            randomAccessWriteBuffer = new RandomAccessReadWriteBuffer(
+                    Math.min(length << 2, RandomAccessReadBuffer.DEFAULT_CHUNK_SIZE_4KB));
+            output = new RandomAccessOutputStream(randomAccessWriteBuffer);
+            try
+            {
+                DecodeResult result = filterList.get(i).decode(input, output, parameters, i,
+                        options);
+                if (results != null)
+                {
+                    results.add(result);
+                }
+            }
+            finally
+            {
+                IOUtils.closeQuietly(input);
+            }
+        }
+        randomAccessWriteBuffer.seek(0);
+        return randomAccessWriteBuffer;
+    }
+    
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java
index c866c7dfa6..dc71e6e980 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java
@@ -16,8 +16,6 @@
  */
 package org.apache.pdfbox.pdmodel.common;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -40,6 +38,8 @@ import org.apache.pdfbox.filter.DecodeOptions;
 import org.apache.pdfbox.filter.Filter;
 import org.apache.pdfbox.filter.FilterFactory;
 import org.apache.pdfbox.io.IOUtils;
+import org.apache.pdfbox.io.RandomAccessInputStream;
+import org.apache.pdfbox.io.RandomAccessRead;
 import org.apache.pdfbox.pdmodel.PDDocument;
 import org.apache.pdfbox.pdmodel.common.filespecification.PDFileSpecification;
 
@@ -205,31 +205,23 @@ public class PDStream implements COSObjectable
     public InputStream createInputStream(List<String> stopFilters) throws IOException
     {
         InputStream is = stream.createRawInputStream();
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        List<Filter> someFilters = new ArrayList<>();
         List<COSName> filters = getFilters();
-        for (int i = 0; i < filters.size(); i++)
+        for (COSName nextFilter : filters)
         {
-            COSName nextFilter = filters.get(i);
-            if ((stopFilters != null) && stopFilters.contains(nextFilter.getName()))
+            if (stopFilters != null && stopFilters.contains(nextFilter.getName()))
             {
                 break;
             }
-            else
-            {
-                Filter filter = FilterFactory.INSTANCE.getFilter(nextFilter);
-                try
-                {
-                    filter.decode(is, os, stream, i);
-                }
-                finally
-                {
-                    IOUtils.closeQuietly(is);
-                }
-                is = new ByteArrayInputStream(os.toByteArray());
-                os.reset();
-            }
+            someFilters.add(FilterFactory.INSTANCE.getFilter(nextFilter));
+        }
+        if (someFilters.isEmpty())
+        {
+            return is;
         }
-        return is;
+        RandomAccessRead decoded = Filter.decode(is, someFilters, getCOSObject(),
+                DecodeOptions.DEFAULT, null);
+        return new RandomAccessInputStream(decoded);
     }
 
     /**
