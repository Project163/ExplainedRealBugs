diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/function/PDFunction.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/function/PDFunction.java
index 71b11ce35c..0b91fdeaa3 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/function/PDFunction.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/function/PDFunction.java
@@ -46,7 +46,8 @@ public abstract class PDFunction implements COSObjectable
     /**
      * Constructor.
      *
-     * @param functionStream The function stream.
+     * @param function The function stream.
+     * 
      */
     public PDFunction( COSBase function )
     {
@@ -130,7 +131,7 @@ public abstract class PDFunction implements COSObjectable
         PDFunction retval = null;
         if( function instanceof COSObject )
         {
-            function = ((COSObject)function).getCOSObject();
+            function = ((COSObject)function).getObject();
         }
         COSDictionary functionDictionary = (COSDictionary)function;
         int functionType =  functionDictionary.getInt( COSName.FUNCTION_TYPE );
@@ -191,7 +192,7 @@ public abstract class PDFunction implements COSObjectable
     /**
      * This will set the range values.
      *
-     * @param range The new range values.
+     * @param rangeValues The new range values.
      */
     public void setRangeValues(COSArray rangeValues)
     {
@@ -230,7 +231,7 @@ public abstract class PDFunction implements COSObjectable
     /**
      * This will set the domain values.
      *
-     * @param range The new domain values.
+     * @param domainValues The new domain values.
      */
     public void setDomainValues(COSArray domainValues)
     {
@@ -242,8 +243,13 @@ public abstract class PDFunction implements COSObjectable
      * Evaluates the function at the given input.
      * ReturnValue = f(input)
      *
-     * @param input The array of input values for the function. In many cases will be an array of a single value, but not always.
-     * @return The of outputs the function returns based on those inputs. In many cases will be an array of a single value, but not always.
+     * @param input The array of input values for the function. 
+     * In many cases will be an array of a single value, but not always.
+     * 
+     * @return The of outputs the function returns based on those inputs. 
+     * In many cases will be an array of a single value, but not always.
+     * 
+     * @throws IOException an IOExcpetion is thrown if something went wrong processing the function.  
      */
     public abstract COSArray eval(COSArray input) throws IOException;
     
@@ -292,7 +298,9 @@ public abstract class PDFunction implements COSObjectable
             result = new COSArray();
             int numberOfRanges = rangeValues.length/2;
             for (int i=0; i<numberOfRanges; i++)
+            {
                 result.add(new COSFloat( clipToRange(inputValues[i], rangeValues[2*i], rangeValues[2*i+1])));
+            }
         }
         else
         {
@@ -320,11 +328,11 @@ public abstract class PDFunction implements COSObjectable
      * on the line defined by the two points (xRangeMin , xRangeMax ) 
      * and (yRangeMin , yRangeMax ).
      * 
-     * @param x
-     * @param xRangeMin
-     * @param xRangeMax
-     * @param yRangeMin
-     * @param yRangeMax
+     * @param x the to be interpolated value.
+     * @param xRangeMin the min value of the x range
+     * @param xRangeMax the max value of the x range
+     * @param yRangeMin the min value of the y range
+     * @param yRangeMax the max value of the y range
      * @return the interpolated y value
      */
     protected float interpolate(float x, float xRangeMin, float xRangeMax, float yRangeMin, float yRangeMax) 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/function/PDFunctionType3.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/function/PDFunctionType3.java
index 2a9d7c8496..43a69ea35a 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/function/PDFunctionType3.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/function/PDFunctionType3.java
@@ -43,9 +43,9 @@ public class PDFunctionType3 extends PDFunction
      *
      * @param functionStream The function .
      */
-    public PDFunctionType3(COSBase function)
+    public PDFunctionType3(COSBase functionStream)
     {
-        super( function );
+        super( functionStream );
     }
 
     /**
@@ -62,49 +62,50 @@ public class PDFunctionType3 extends PDFunction
     public COSArray eval(COSArray input) throws IOException
     {
         //This function is known as a "stitching" function. Based on the input, it decides which child function to call.
+        // All functions in the array are 1-value-input functions
         //See PDF Reference section 3.9.3.
         PDFunction function = null;
         float x = ((COSNumber)input.get(0)).floatValue();
-        PDRange domain = getDomainForInput(1);
+        PDRange domain = getDomainForInput(0);
         // clip input value to domain
         x = clipToRange(x, domain.getMin(), domain.getMax());
 
-        float[] boundsValues = getBounds().toFloatArray();
-        int boundsSize = boundsValues.length;
-        if (boundsSize == 0 || x < boundsValues[0])
+        COSArray functionsArray = getFunctions();
+        int numberOfFunctions = functionsArray.size();
+        // This doesn't make sense but it may happen ...
+        if (numberOfFunctions == 1) 
         {
-            function = PDFunction.create(getFunctions().get(0));
-            PDRange encode = getEncodeForParameter(0);
-            if (boundsSize == 0)
-            {
-                x = interpolate(x, domain.getMin(), domain.getMax(), encode.getMin(), encode.getMax());
-            }
-            else
-            {
-                x = interpolate(x, domain.getMin(), boundsValues[0], encode.getMin(), encode.getMax());
-            }
+            function = PDFunction.create(functionsArray.get(0));
+            PDRange encRange = getEncodeForParameter(0);
+            x = interpolate(x, domain.getMin(), domain.getMax(), encRange.getMin(), encRange.getMax());
         }
-        else
+        else 
         {
-            for (int i=0; i<boundsSize-1; i++)
+            float[] boundsValues = getBounds().toFloatArray();
+            int boundsSize = boundsValues.length;
+            // create a combined array containing the domain and the bounds values
+            // domain.min, bounds[0], bounds[1], ...., bounds[boundsSize-1], domain.max
+            float[] partitionValues = new float[boundsSize+2];
+            int partitionValuesSize = partitionValues.length;
+            partitionValues[0] = domain.getMin();
+            partitionValues[partitionValuesSize-1] = domain.getMax();
+            System.arraycopy(boundsValues, 0, partitionValues, 1, boundsSize);
+            // find the partition 
+            for (int i=0; i < partitionValuesSize-1; i++)
             {
-                if ( x >= boundsValues[i] && x < boundsValues[i+1] )
+                if ( x >= partitionValues[i] && 
+                        (x < partitionValues[i+1] || (i == partitionValuesSize - 2 && x == partitionValues[i+1])))
                 {
-                    function = PDFunction.create(getFunctions().get(i+1));
-                    PDRange encode = getEncodeForParameter(i+1);
-                    x = interpolate(x, boundsValues[i], boundsValues[i+1], encode.getMin(), encode.getMax());
+                    function = PDFunction.create(functionsArray.get(i));
+                    PDRange encRange = getEncodeForParameter(i);
+                    x = interpolate(x, partitionValues[i], partitionValues[i+1], encRange.getMin(), encRange.getMax());
                     break;
                 }
             }
-            if(function==null) //must be in last partition
-            {
-                function = PDFunction.create(getFunctions().get(boundsSize+1));
-                PDRange encode = getEncodeForParameter(boundsSize+1);
-                x = interpolate(x, boundsValues[boundsSize-1], domain.getMax(), encode.getMin(), encode.getMax());
-            }
         }
         COSArray functionValues = new COSArray();
         functionValues.add(new COSFloat(x));
+        // calculate the output values using the chosen function
         COSArray functionResult = function.eval(functionValues);
         // clip to range if available
         return clipToRange(functionResult);
