diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java
index c203831540..16a38ec424 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java
@@ -34,13 +34,19 @@ import java.awt.geom.GeneralPath;
 import java.awt.geom.NoninvertibleTransformException;
 import java.awt.geom.Point2D;
 import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.fontbox.cmap.CMap;
+import org.apache.fontbox.ttf.TrueTypeFont;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.cos.COSStream;
+import org.apache.pdfbox.pdfviewer.font.Glyph2D;
+import org.apache.pdfbox.pdfviewer.font.TTFGlyph2D;
 import org.apache.pdfbox.pdmodel.PDPage;
 import org.apache.pdfbox.pdmodel.PDResources;
 import org.apache.pdfbox.pdmodel.common.PDMatrix;
@@ -48,6 +54,7 @@ import org.apache.pdfbox.pdmodel.common.PDRectangle;
 import org.apache.pdfbox.pdmodel.font.PDCIDFontType2Font;
 import org.apache.pdfbox.pdmodel.font.PDFont;
 import org.apache.pdfbox.pdmodel.font.PDSimpleFont;
+import org.apache.pdfbox.pdmodel.font.PDTrueTypeFont;
 import org.apache.pdfbox.pdmodel.font.PDType0Font;
 import org.apache.pdfbox.pdmodel.font.PDType3Font;
 import org.apache.pdfbox.pdmodel.graphics.PDGraphicsState;
@@ -70,7 +77,7 @@ import org.apache.pdfbox.util.TextPosition;
  * This will paint a page in a PDF document to a graphics context.
  * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.22 $
+ * 
  */
 public class PageDrawer extends PDFStreamEngine
 {
@@ -98,11 +105,12 @@ public class PageDrawer extends PDFStreamEngine
 
     private GeneralPath linePath = new GeneralPath();
 
+    private HashMap<PDFont, Glyph2D> fontGlyph2D = new HashMap<PDFont, Glyph2D>();
+
     /**
      * Default constructor, loads properties from file.
      * 
-     * @throws IOException
-     *             If there is an error loading properties from the file.
+     * @throws IOException If there is an error loading properties from the file.
      */
     public PageDrawer() throws IOException
     {
@@ -112,15 +120,11 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * This will draw the page to the requested context.
      * 
-     * @param g
-     *            The graphics context to draw onto.
-     * @param p
-     *            The page to draw.
-     * @param pageDimension
-     *            The size of the page to draw.
+     * @param g The graphics context to draw onto.
+     * @param p The page to draw.
+     * @param pageDimension The size of the page to draw.
      * 
-     * @throws IOException
-     *             If there is an IO error while drawing the page.
+     * @throws IOException If there is an IO error while drawing the page.
      */
     public void drawPage(Graphics g, PDPage p, Dimension pageDimension) throws IOException
     {
@@ -170,14 +174,33 @@ public class PageDrawer extends PDFStreamEngine
                 }
             }
         }
+    }
 
+    /**
+     * Remove all cached resources.
+     */
+    public void dispose()
+    {
+        if (fontGlyph2D != null)
+        {
+            Iterator<Glyph2D> iter = fontGlyph2D.values().iterator();
+            while (iter.hasNext())
+            {
+                iter.next().dispose();
+            }
+            fontGlyph2D.clear();
+            fontGlyph2D = null;
+        }
+        graphics = null;
+        linePath = null;
+        page = null;
+        pageSize = null;
     }
 
     /**
      * You should override this method if you want to perform an action when a text is being processed.
      * 
-     * @param text
-     *            The text to process
+     * @param text The text to process
      */
     protected void processTextPosition(TextPosition text)
     {
@@ -254,11 +277,22 @@ public class PageDrawer extends PDFStreamEngine
             // use different methods to draw the string
             if (font.isType3Font())
             {
-                drawType3String((PDType3Font) font, text.getCharacter(), text.getCodePoints(), at);
+                // Type3 fonts are using streams for each character
+                drawType3String((PDType3Font) font, text.getCharacter(), at);
             }
             else
             {
-                drawString((PDSimpleFont) font, text.getCharacter(), text.getCodePoints(), graphics, at, x, y);
+                Glyph2D glyph2D = createGlyph2D(font);
+                if (glyph2D != null)
+                {
+                    // Let PDFBox render the font if supported
+                    drawGlyph2D(glyph2D, text.getCodePoints(), graphics, at, x, y);
+                }
+                else
+                {
+                    // Use AWT to render the font
+                    drawString((PDSimpleFont) font, text.getCharacter(), text.getCodePoints(), graphics, at, x, y);
+                }
             }
         }
         catch (IOException io)
@@ -267,8 +301,73 @@ public class PageDrawer extends PDFStreamEngine
         }
     }
 
-    private void drawType3String(PDType3Font font, String string, int[] codePoints, AffineTransform at)
+    /**
+     * Render the font using the Glyph2d interface.
+     * 
+     * @param glyph2D the Glyph2D implementation provided a GeneralPath for each glyph
+     * @param codePoints the string to be rendered
+     * @param graphics the graphics object to be used for rendering
+     * @param at the transformation
+     * @param x the x coordinate of the text
+     * @param y the y coordinate of the text
+     * @throws IOException if something went wrong
+     */
+    private void drawGlyph2D(Glyph2D glyph2D, int[] codePoints, Graphics graphics, AffineTransform at, float x, float y)
             throws IOException
+    {
+        Graphics2D g2d = (Graphics2D) graphics;
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        for (int i = 0; i < codePoints.length; i++)
+        {
+            if (!at.isIdentity())
+            {
+                try
+                {
+                    AffineTransform atInv = at.createInverse();
+                    // do only apply the size of the transform, rotation will be realized by rotating the graphics,
+                    // otherwise the hp printers will not render the font
+                    // apply the transformation to the graphics, which should be the same as applying the
+                    // transformation itself to the text
+                    g2d.transform(at);
+                    // translate the coordinates
+                    Point2D.Float newXy = new Point2D.Float(x, y);
+                    atInv.transform(new Point2D.Float(x, y), newXy);
+
+                    GeneralPath path = glyph2D.getPathForCharactercode(codePoints[i]);
+                    if (path != null)
+                    {
+                        g2d.translate(newXy.getX(), newXy.getY());
+                        g2d.fill(path);
+                        g2d.translate(-newXy.getX(), -newXy.getY());
+                    }
+                    // restore the original transformation
+                    g2d.transform(atInv);
+                }
+                catch (NoninvertibleTransformException e)
+                {
+                    LOG.error("Error in " + getClass().getName() + ".drawGlyph2D", e);
+                }
+            }
+            else
+            {
+                GeneralPath path = glyph2D.getPathForCharactercode(codePoints[i]);
+                if (path != null)
+                {
+                    g2d.draw(path);
+                }
+            }
+        }
+    }
+
+    /**
+     * Render the text using a type 3 font.
+     * 
+     * @param font the type3 font
+     * @param string the string to be rendered
+     * @param at the transformation
+     * @throws IOException if something went wrong
+     */
+    private void drawType3String(PDType3Font font, String string, AffineTransform at) throws IOException
     {
         int stringLength = string.length();
         for (int i = 0; i < stringLength; i++)
@@ -297,23 +396,15 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * This will draw a string on a canvas using the font.
      * 
-     * @param font
-     *            the font to be used to draw the string
-     * @param string
-     *            The string to draw.
-     * @param codePoints
-     *            The codePoints of the given string.
-     * @param g
-     *            The graphics to draw onto.
-     * @param at
-     *            The transformation matrix with all information for scaling and shearing of the font.
-     * @param x
-     *            The x coordinate to draw at.
-     * @param y
-     *            The y coordinate to draw at.
-     * 
-     * @throws IOException
-     *             If there is an error drawing the specific string.
+     * @param font the font to be used to draw the string
+     * @param string The string to draw.
+     * @param codePoints The codePoints of the given string.
+     * @param g The graphics to draw onto.
+     * @param at The transformation matrix with all information for scaling and shearing of the font.
+     * @param x The x coordinate to draw at.
+     * @param y The y coordinate to draw at.
+     * 
+     * @throws IOException If there is an error drawing the specific string.
      */
     private void drawString(PDSimpleFont font, String string, int[] codePoints, Graphics g, AffineTransform at,
             float x, float y) throws IOException
@@ -394,6 +485,86 @@ public class PageDrawer extends PDFStreamEngine
         }
     }
 
+    /**
+     * Provide a Glyh2d for the given font if supported.
+     * 
+     * @param font the font
+     * @return the implementation of the Glyph2D interface for the given font if supported
+     * @throws IOException if something went wrong
+     */
+    private Glyph2D createGlyph2D(PDFont font) throws IOException
+    {
+        Glyph2D glyph2D = null;
+        // Is there already a Glyph2D for the given font?
+        if (fontGlyph2D.containsKey(font))
+        {
+            glyph2D = fontGlyph2D.get(font);
+        }
+        else
+        {
+            // check if the given font is supported
+
+            // TTF fonts are supported
+            if (font instanceof PDTrueTypeFont)
+            {
+                PDTrueTypeFont ttfFont = (PDTrueTypeFont) font;
+                // does the font have an optional toUnicode mapping
+                CMap toUnicodeCMap = null;
+                if (ttfFont.hasToUnicode())
+                {
+                    toUnicodeCMap = ttfFont.getToUnicodeCMap();
+                }
+                // get the true type font raw data
+                TrueTypeFont ttf = ttfFont.getTTFFont();
+                if (ttf != null)
+                {
+                    glyph2D = new TTFGlyph2D(ttf, font.getBaseFont(), ttfFont.isSymbolicFont(), toUnicodeCMap);
+                }
+                // cache the Glyph2D instance
+                if (glyph2D != null)
+                {
+                    fontGlyph2D.put(font, glyph2D);
+                }
+            }
+            else if (font instanceof PDType0Font)
+            {
+                PDType0Font type0Font = (PDType0Font) font;
+                CMap toUnicodeCMap = null;
+                if (type0Font.hasToUnicode())
+                {
+                    toUnicodeCMap = type0Font.getToUnicodeCMap();
+                }
+                if (type0Font.getDescendantFont() instanceof PDCIDFontType2Font)
+                {
+                    // a CIDFontType2Font contains TTF font
+                    PDCIDFontType2Font cidType2Font = (PDCIDFontType2Font) type0Font.getDescendantFont();
+                    // get the true type font raw data
+                    TrueTypeFont ttf = cidType2Font.getTTFFont();
+                    if (ttf != null)
+                    {
+                        if (cidType2Font.hasCIDToGIDMap())
+                        {
+                            glyph2D = new TTFGlyph2D(ttf, font.getBaseFont(), cidType2Font.isSymbolicFont(),
+                                    toUnicodeCMap, cidType2Font.getCID2GID());
+                        }
+                        else
+                        {
+                            glyph2D = new TTFGlyph2D(ttf, font.getBaseFont(), cidType2Font.isSymbolicFont(),
+                                    toUnicodeCMap);
+                        }
+                    }
+                    // cache the Glyph2D instance
+                    if (glyph2D != null)
+                    {
+                        fontGlyph2D.put(font, glyph2D);
+                    }
+
+                }
+            }
+        }
+        return glyph2D;
+    }
+
     /**
      * Get the graphics that we are currently drawing on.
      * 
@@ -427,8 +598,7 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Fix the y coordinate.
      * 
-     * @param y
-     *            The y coordinate.
+     * @param y The y coordinate.
      * @return The updated y coordinate.
      */
     public double fixY(double y)
@@ -449,8 +619,7 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Set the line path to draw.
      * 
-     * @param newLinePath
-     *            Set the line path to draw.
+     * @param newLinePath Set the line path to draw.
      */
     public void setLinePath(GeneralPath newLinePath)
     {
@@ -467,11 +636,9 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Fill the path.
      * 
-     * @param windingRule
-     *            The winding rule this path will use.
+     * @param windingRule The winding rule this path will use.
      * 
-     * @throws IOException
-     *             If there is an IO error while filling the path.
+     * @throws IOException If there is an IO error while filling the path.
      */
     public void fillPath(int windingRule) throws IOException
     {
@@ -498,8 +665,7 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * This will set the current stroke.
      * 
-     * @param newStroke
-     *            The current stroke.
+     * @param newStroke The current stroke.
      * 
      */
     public void setStroke(BasicStroke newStroke)
@@ -521,8 +687,7 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Stroke the path.
      * 
-     * @throws IOException
-     *             If there is an IO error while stroking the path.
+     * @throws IOException If there is an IO error while stroking the path.
      */
     public void strokePath() throws IOException
     {
@@ -549,10 +714,8 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Called when the color changed.
      * 
-     * @param bStroking
-     *            true for the stroking color, false for the non-stroking color
-     * @throws IOException
-     *             if an I/O error occurs
+     * @param bStroking true for the stroking color, false for the non-stroking color
+     * @throws IOException if an I/O error occurs
      */
     @Deprecated
     public void colorChanged(boolean bStroking) throws IOException
@@ -564,10 +727,8 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * use the current transformation matrix to transform a single point.
      * 
-     * @param x
-     *            x-coordinate of the point to be transform
-     * @param y
-     *            y-coordinate of the point to be transform
+     * @param x x-coordinate of the point to be transform
+     * @param y y-coordinate of the point to be transform
      * @return the transformed coordinates as Point2D.Double
      */
     public java.awt.geom.Point2D.Double transformedPoint(double x, double y)
@@ -582,8 +743,7 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Set the clipping Path.
      * 
-     * @param windingRule
-     *            The winding rule this path will use.
+     * @param windingRule The winding rule this path will use.
      * 
      * @deprecated use {@link #setClippingWindingRule(int)} instead
      * 
@@ -596,8 +756,7 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Set the clipping winding rule.
      * 
-     * @param windingRule
-     *            The winding rule which will be used for clipping.
+     * @param windingRule The winding rule which will be used for clipping.
      * 
      */
     public void setClippingWindingRule(int windingRule)
@@ -637,10 +796,8 @@ public class PageDrawer extends PDFStreamEngine
      * Draw the AWT image. Called by Invoke. Moved into PageDrawer so that Invoke doesn't have to reach in here for
      * Graphics as that breaks extensibility.
      * 
-     * @param awtImage
-     *            The image to draw.
-     * @param at
-     *            The transformation to use when drawing.
+     * @param awtImage The image to draw.
+     * @param at The transformation to use when drawing.
      * 
      */
     public void drawImage(Image awtImage, AffineTransform at)
@@ -653,11 +810,9 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Fill with Shading. Called by SHFill operator.
      * 
-     * @param ShadingName
-     *            The name of the Shading Dictionary to use for this fill instruction.
+     * @param ShadingName The name of the Shading Dictionary to use for this fill instruction.
      * 
-     * @throws IOException
-     *             If there is an IO error while shade-filling the path/clipping area.
+     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
      * 
      * @deprecated use {@link #shFill(COSName)) instead.
      */
@@ -669,11 +824,9 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Fill with Shading. Called by SHFill operator.
      * 
-     * @param shadingName
-     *            The name of the Shading Dictionary to use for this fill instruction.
+     * @param shadingName The name of the Shading Dictionary to use for this fill instruction.
      * 
-     * @throws IOException
-     *             If there is an IO error while shade-filling the clipping area.
+     * @throws IOException If there is an IO error while shade-filling the clipping area.
      */
     public void shFill(COSName shadingName) throws IOException
     {
@@ -714,11 +867,9 @@ public class PageDrawer extends PDFStreamEngine
      * Fill with a Function-based gradient / shading. If extending the class, override this and its siblings, not the
      * public SHFill method.
      * 
-     * @param Shading
-     *            The Shading Dictionary to use for this fill instruction.
+     * @param Shading The Shading Dictionary to use for this fill instruction.
      * 
-     * @throws IOException
-     *             If there is an IO error while shade-filling the path/clipping area.
+     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_Function(PDShading Shading) throws IOException
     {
@@ -728,11 +879,9 @@ public class PageDrawer extends PDFStreamEngine
     /**
      * Fill with an Axial Shading. If extending the class, override this and its siblings, not the public SHFill method.
      * 
-     * @param Shading
-     *            The Shading Dictionary to use for this fill instruction.
+     * @param Shading The Shading Dictionary to use for this fill instruction.
      * 
-     * @throws IOException
-     *             If there is an IO error while shade-filling the path/clipping area.
+     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_Axial(PDShading Shading) throws IOException
     {
@@ -744,11 +893,9 @@ public class PageDrawer extends PDFStreamEngine
      * Fill with a Radial gradient / shading. If extending the class, override this and its siblings, not the public
      * SHFill method.
      * 
-     * @param Shading
-     *            The Shading Dictionary to use for this fill instruction.
+     * @param Shading The Shading Dictionary to use for this fill instruction.
      * 
-     * @throws IOException
-     *             If there is an IO error while shade-filling the path/clipping area.
+     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_Radial(PDShading Shading) throws IOException
     {
@@ -759,11 +906,9 @@ public class PageDrawer extends PDFStreamEngine
      * Fill with a Free-form Gourad-shaded triangle mesh. If extending the class, override this and its siblings, not
      * the public SHFill method.
      * 
-     * @param Shading
-     *            The Shading Dictionary to use for this fill instruction.
+     * @param Shading The Shading Dictionary to use for this fill instruction.
      * 
-     * @throws IOException
-     *             If there is an IO error while shade-filling the path/clipping area.
+     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_FreeGourad(PDShading Shading) throws IOException
     {
@@ -774,11 +919,9 @@ public class PageDrawer extends PDFStreamEngine
      * Fill with a Lattice-form Gourad-shaded triangle mesh. If extending the class, override this and its siblings, not
      * the public SHFill method.
      * 
-     * @param Shading
-     *            The Shading Dictionary to use for this fill instruction.
+     * @param Shading The Shading Dictionary to use for this fill instruction.
      * 
-     * @throws IOException
-     *             If there is an IO error while shade-filling the path/clipping area.
+     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_LatticeGourad(PDShading Shading) throws IOException
     {
@@ -789,11 +932,9 @@ public class PageDrawer extends PDFStreamEngine
      * Fill with a Coons patch mesh If extending the class, override this and its siblings, not the public SHFill
      * method.
      * 
-     * @param Shading
-     *            The Shading Dictionary to use for this fill instruction.
+     * @param Shading The Shading Dictionary to use for this fill instruction.
      * 
-     * @throws IOException
-     *             If there is an IO error while shade-filling the path/clipping area.
+     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_CoonsPatch(PDShading Shading) throws IOException
     {
@@ -804,11 +945,9 @@ public class PageDrawer extends PDFStreamEngine
      * Fill with a Tensor-product patch mesh. If extending the class, override this and its siblings, not the public
      * SHFill method.
      * 
-     * @param Shading
-     *            The Shading Dictionary to use for this fill instruction.
+     * @param Shading The Shading Dictionary to use for this fill instruction.
      * 
-     * @throws IOException
-     *             If there is an IO error while shade-filling the path/clipping area.
+     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_TensorPatch(PDShading Shading) throws IOException
     {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/font/Glyph2D.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/font/Glyph2D.java
new file mode 100644
index 0000000000..71f35e077c
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/font/Glyph2D.java
@@ -0,0 +1,62 @@
+/*
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.pdfbox.pdfviewer.font;
+
+import java.awt.geom.GeneralPath;
+
+/**
+ * This interface is implemented by several font specific classes which is called to get the general path of a single
+ * glyph of the represented font most likely to render it.
+ * 
+ */
+public interface Glyph2D
+{
+
+    /**
+     * Returns the path describing the glyph for the given glyphId.
+     * 
+     * @param glyphId the glyphId
+     * 
+     * @return the GeneralPath for the given glyphId
+     */
+    public GeneralPath getPathForGlyphId(int glyphId);
+
+    /**
+     * Returns the path describing the glyph for the given character code.
+     * 
+     * @param code the character code
+     * 
+     * @return the GeneralPath for the given character code
+     */
+    public GeneralPath getPathForCharactercode(int code);
+
+    /**
+     * Returns the number of glyphs provided by the given font.
+     * 
+     * @return the number of glyphs
+     */
+    public int getNumberOfGlyphs();
+
+    /**
+     * Remove all cached resources.
+     */
+    public void dispose();
+
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/font/TTFGlyph2D.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/font/TTFGlyph2D.java
new file mode 100644
index 0000000000..9002a9497c
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/font/TTFGlyph2D.java
@@ -0,0 +1,434 @@
+/*
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+package org.apache.pdfbox.pdfviewer.font;
+
+import java.awt.geom.AffineTransform;
+import java.awt.geom.GeneralPath;
+import java.awt.geom.Point2D;
+import java.util.HashMap;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.fontbox.cmap.CMap;
+import org.apache.fontbox.ttf.CMAPEncodingEntry;
+import org.apache.fontbox.ttf.CMAPTable;
+import org.apache.fontbox.ttf.GlyfDescript;
+import org.apache.fontbox.ttf.GlyphData;
+import org.apache.fontbox.ttf.GlyphDescription;
+import org.apache.fontbox.ttf.HeaderTable;
+import org.apache.fontbox.ttf.TrueTypeFont;
+
+/**
+ * This class provides a glyph to GeneralPath conversion for true type fonts.
+ * 
+ * This class is based on code from Apache Batik a subproject of Apache XMLGraphics. see
+ * http://xmlgraphics.apache.org/batik/ for further details.
+ */
+public class TTFGlyph2D implements Glyph2D
+{
+
+    /**
+     * Log instance.
+     */
+    private static final Log LOG = LogFactory.getLog(TTFGlyph2D.class);
+
+    private TrueTypeFont font;
+    private String name;
+    private float scale = 0.001f;
+    private CMAPEncodingEntry cmapMiscUnicode = null;
+    private CMAPEncodingEntry cmapWinUnicode = null;
+    private CMAPEncodingEntry cmapWinSymbol = null;
+    private CMAPEncodingEntry cmapMacintoshSymbol = null;
+    private boolean isSymbol = false;
+    private HashMap<Integer, GeneralPath> glyphs = new HashMap<Integer, GeneralPath>();
+    private CMap toUnicode = null;
+    private int[] cid2gid = null;
+
+    /**
+     * Constructor.
+     * 
+     * @param trueTypeFont the true type font containing the glyphs
+     * @param fontname the name of the given font
+     * @param symbolFont indicates if the font is a symbolic font
+     * 
+     */
+    public TTFGlyph2D(TrueTypeFont trueTypeFont, String fontname, boolean symbolFont)
+    {
+        this(trueTypeFont, fontname, symbolFont, null);
+    }
+
+    /**
+     * Constructor.
+     * 
+     * @param trueTypeFont the true type font containing the glyphs
+     * @param fontname the name of the given font
+     * @param symbolFont indicates if the font is a symbolic font
+     * @param toUnicodeCMap an optional toUnicode mapping
+     * 
+     */
+    public TTFGlyph2D(TrueTypeFont trueTypeFont, String fontname, boolean symbolFont, CMap toUnicodeCMap)
+    {
+        this(trueTypeFont, fontname, symbolFont, toUnicodeCMap, null);
+    }
+
+    /**
+     * Constructor.
+     * 
+     * @param trueTypeFont the true type font containing the glyphs
+     * @param fontname the name of the given font
+     * @param symbolFont indicates if the font is a symbolic font
+     * @param toUnicodeCMap an optional toUnicode mapping
+     * @param cid2gidMapping an optional CID2GIC mapping
+     * 
+     */
+    public TTFGlyph2D(TrueTypeFont trueTypeFont, String fontname, boolean symbolFont, CMap toUnicodeCMap,
+            int[] cid2gidMapping)
+    {
+        font = trueTypeFont;
+        isSymbol = symbolFont;
+        name = fontname;
+        toUnicode = toUnicodeCMap;
+        cid2gid = cid2gidMapping;
+        // get units per em, which is used as scaling factor
+        HeaderTable header = font.getHeader();
+        if (header != null)
+        {
+            scale = 1f / header.getUnitsPerEm();
+        }
+        CMAPTable cmapTable = font.getCMAP();
+        if (cmapTable != null)
+        {
+            // get all relevant CMaps
+            CMAPEncodingEntry[] cmaps = cmapTable.getCmaps();
+            for (int i = 0; i < cmaps.length; i++)
+            {
+                if (CMAPTable.PLATFORM_WINDOWS == cmaps[i].getPlatformId())
+                {
+                    if (CMAPTable.ENCODING_UNICODE == cmaps[i].getPlatformEncodingId())
+                    {
+                        cmapWinUnicode = cmaps[i];
+                    }
+                    else if (CMAPTable.ENCODING_SYMBOL == cmaps[i].getPlatformEncodingId())
+                    {
+                        cmapWinSymbol = cmaps[i];
+                    }
+                }
+                else if (CMAPTable.PLATFORM_MACINTOSH == cmaps[i].getPlatformId())
+                {
+                    if (CMAPTable.ENCODING_SYMBOL == cmaps[i].getPlatformEncodingId())
+                    {
+                        cmapMacintoshSymbol = cmaps[i];
+                    }
+                }
+                else if (CMAPTable.PLATFORM_MISC == cmaps[i].getPlatformId())
+                {
+                    if (CMAPTable.ENCODING_UNICODE == cmaps[i].getPlatformEncodingId())
+                    {
+                        cmapMiscUnicode = cmaps[i];
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Set the points of a glyph from the GlyphDescription.
+     */
+    private Point[] describe(GlyphDescription gd)
+    {
+        int endPtIndex = 0;
+        Point[] points = new Point[gd.getPointCount()];
+        for (int i = 0; i < gd.getPointCount(); i++)
+        {
+            boolean endPt = gd.getEndPtOfContours(endPtIndex) == i;
+            if (endPt)
+            {
+                endPtIndex++;
+            }
+            points[i] = new Point(gd.getXCoordinate(i), -gd.getYCoordinate(i),
+                    (gd.getFlags(i) & GlyfDescript.ON_CURVE) != 0, endPt);
+        }
+        return points;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public GeneralPath getPathForGlyphId(int glyphId)
+    {
+        GeneralPath glyphPath = null;
+        if (glyphs.containsKey(glyphId))
+        {
+            glyphPath = glyphs.get(glyphId);
+        }
+        else
+        {
+            GlyphData[] glyphData = font.getGlyph().getGlyphs();
+            if (glyphId < glyphData.length && glyphData[glyphId] != null)
+            {
+                GlyphData glyph = glyphData[glyphId];
+                GlyphDescription gd = glyph.getDescription();
+                Point[] points = describe(gd);
+                glyphPath = calculatePath(points);
+                AffineTransform atScale = AffineTransform.getScaleInstance(scale, scale);
+                glyphPath.transform(atScale);
+                glyphs.put(glyphId, glyphPath);
+            }
+            else
+            {
+                LOG.debug(name + ": Glyph not found:" + glyphId);
+            }
+        }
+        return glyphPath != null ? (GeneralPath) glyphPath.clone() : null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public GeneralPath getPathForCharactercode(int code)
+    {
+        if (isSymbol)
+        {
+            // symbol fonts
+            if (cmapWinSymbol != null)
+            {
+                int glyphId = cmapWinSymbol.getGlyphId(code);
+                // microsoft sometimes uses PUA unicode values for symbol fonts
+                // the range 0x0020 - 0x00FF maps to 0xF020 - 0xF0FF
+                if (glyphId == 0 && code >= 0x0020 && code <= 0x00FF)
+                {
+                    glyphId = cmapWinSymbol.getGlyphId(code + 0xF000);
+                }
+                return getPathForGlyphId(glyphId);
+            }
+        }
+        else
+        {
+            // non symbol fonts
+            // Unicode mapping
+            if (cmapWinUnicode != null)
+            {
+                return getPathForGlyphId(cmapWinUnicode.getGlyphId(code));
+            }
+            // some fonts provide a custom CMap
+            if (cmapMiscUnicode != null)
+            {
+                int unicode = code;
+                // map the given code to a valid unicode value, if necessary
+                if (toUnicode != null)
+                {
+                    String unicodeStr = toUnicode.lookup(code, 1);
+                    if (unicodeStr != null)
+                    {
+                        unicode = unicodeStr.codePointAt(0);
+                    }
+                }
+                return getPathForGlyphId(cmapMiscUnicode.getGlyphId(unicode));
+            }
+            // use a mac related mapping
+            if (cmapMacintoshSymbol != null)
+            {
+                return getPathForGlyphId(cmapMacintoshSymbol.getGlyphId(code));
+            }
+        }
+        // there isn't any mpping, but propably an optional CID2GID mapping
+        if (cid2gid != null && code <= cid2gid.length)
+        {
+            code = cid2gid[code];
+        }
+        return getPathForGlyphId(code);
+    }
+
+    /**
+     * Use the given points to calculate a GeneralPath.
+     * 
+     * @param points the points to be used to generate the GeneralPath
+     * 
+     * @return the calculated GeneralPath
+     */
+    private GeneralPath calculatePath(Point[] points)
+    {
+        GeneralPath path = new GeneralPath();
+        int numberOfPoints = points.length;
+        int i = 0;
+        boolean endOfContour = true;
+        Point startingPoint = null;
+        Point lastCtrlPoint = null;
+        while (i < numberOfPoints)
+        {
+            Point point = points[i % numberOfPoints];
+            Point nextPoint1 = points[(i + 1) % numberOfPoints];
+            Point nextPoint2 = points[(i + 2) % numberOfPoints];
+            // new contour
+            if (endOfContour)
+            {
+                // skip endOfContour points
+                if (point.endOfContour)
+                {
+                    i++;
+                    continue;
+                }
+                // move to the starting point
+                path.moveTo(point.x, point.y);
+                endOfContour = false;
+                startingPoint = point;
+            }
+            // lineTo
+            if (point.onCurve && nextPoint1.onCurve)
+            {
+                path.lineTo(nextPoint1.x, nextPoint1.y);
+                i++;
+                if (point.endOfContour || nextPoint1.endOfContour)
+                {
+                    endOfContour = true;
+                    path.closePath();
+                }
+                continue;
+            }
+            // quadratic bezier
+            if (point.onCurve && !nextPoint1.onCurve && nextPoint2.onCurve)
+            {
+                if (nextPoint1.endOfContour)
+                {
+                    // use the starting point as end point
+                    path.quadTo(nextPoint1.x, nextPoint1.y, startingPoint.x, startingPoint.y);
+                }
+                else
+                {
+                    path.quadTo(nextPoint1.x, nextPoint1.y, nextPoint2.x, nextPoint2.y);
+                }
+                if (nextPoint1.endOfContour || nextPoint2.endOfContour)
+                {
+                    endOfContour = true;
+                    path.closePath();
+                }
+                i += 2;
+                lastCtrlPoint = nextPoint1;
+                continue;
+            }
+            if (point.onCurve && !nextPoint1.onCurve && !nextPoint2.onCurve)
+            {
+                // interpolate endPoint
+                int endPointX = midValue(nextPoint1.x, nextPoint2.x);
+                int endPointY = midValue(nextPoint1.y, nextPoint2.y);
+                path.quadTo(nextPoint1.x, nextPoint1.y, endPointX, endPointY);
+                if (point.endOfContour || nextPoint1.endOfContour || nextPoint2.endOfContour)
+                {
+                    path.quadTo(nextPoint2.x, nextPoint2.y, startingPoint.x, startingPoint.y);
+                    endOfContour = true;
+                    path.closePath();
+                }
+                i += 2;
+                lastCtrlPoint = nextPoint1;
+                continue;
+            }
+            if (!point.onCurve && !nextPoint1.onCurve)
+            {
+                Point2D lastEndPoint = path.getCurrentPoint();
+                // calculate new control point using the previous control point
+                lastCtrlPoint = new Point(midValue(lastCtrlPoint.x, (int) lastEndPoint.getX()), midValue(
+                        lastCtrlPoint.y, (int) lastEndPoint.getY()));
+                // interpolate endPoint
+                int endPointX = midValue((int) lastEndPoint.getX(), nextPoint1.x);
+                int endPointY = midValue((int) lastEndPoint.getY(), nextPoint1.y);
+                path.quadTo(lastCtrlPoint.x, lastCtrlPoint.y, endPointX, endPointY);
+                if (point.endOfContour || nextPoint1.endOfContour)
+                {
+                    endOfContour = true;
+                    path.closePath();
+                }
+                i++;
+                continue;
+            }
+            if (!point.onCurve && nextPoint1.onCurve)
+            {
+                path.quadTo(point.x, point.y, nextPoint1.x, nextPoint1.y);
+                if (point.endOfContour || nextPoint1.endOfContour)
+                {
+                    endOfContour = true;
+                    path.closePath();
+                }
+                i++;
+                lastCtrlPoint = point;
+                continue;
+            }
+            System.err.println("Unknown glyph command!!");
+            break;
+        }
+        return path;
+    }
+
+    private int midValue(int a, int b)
+    {
+        return a + (b - a) / 2;
+    }
+
+    /**
+     * This class represents one point of a glyph.
+     * 
+     */
+    private class Point
+    {
+
+        public int x = 0;
+        public int y = 0;
+        public boolean onCurve = true;
+        public boolean endOfContour = false;
+
+        public Point(int xValue, int yValue, boolean onCurveValue, boolean endOfContourValue)
+        {
+            x = xValue;
+            y = yValue;
+            onCurve = onCurveValue;
+            endOfContour = endOfContourValue;
+        }
+
+        public Point(int xValue, int yValue)
+        {
+            this(xValue, yValue, false, false);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getNumberOfGlyphs()
+    {
+        return font != null ? font.getGlyph().getGlyphs().length : 0;
+    }
+
+    @Override
+    public void dispose()
+    {
+        cid2gid = null;
+        cmapMacintoshSymbol = null;
+        cmapMiscUnicode = null;
+        cmapWinSymbol = null;
+        cmapWinUnicode = null;
+        font = null;
+        toUnicode = null;
+        if (glyphs != null)
+        {
+            glyphs.clear();
+        }
+    }
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDCIDFontType2Font.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDCIDFontType2Font.java
index ed43ff8037..d23aecf688 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDCIDFontType2Font.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDCIDFontType2Font.java
@@ -16,12 +16,12 @@
  */
 package org.apache.pdfbox.pdmodel.font;
 
-import java.awt.Font;
-import java.awt.FontFormatException;
 import java.io.IOException;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.fontbox.ttf.TTFParser;
+import org.apache.fontbox.ttf.TrueTypeFont;
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
@@ -31,7 +31,7 @@ import org.apache.pdfbox.pdmodel.common.PDStream;
 
 /**
  * This is implementation of the CIDFontType2 Font.
- *
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
  * 
  */
@@ -45,56 +45,24 @@ public class PDCIDFontType2Font extends PDCIDFont
 
     private Boolean hasCIDToGIDMap = null;
     private int[] cid2gid = null;
-    
+
     /**
      * Constructor.
      */
     public PDCIDFontType2Font()
     {
         super();
-        font.setItem( COSName.SUBTYPE, COSName.CID_FONT_TYPE2 );
+        font.setItem(COSName.SUBTYPE, COSName.CID_FONT_TYPE2);
     }
 
     /**
      * Constructor.
-     *
+     * 
      * @param fontDictionary The font dictionary according to the PDF specification.
      */
-    public PDCIDFontType2Font( COSDictionary fontDictionary )
+    public PDCIDFontType2Font(COSDictionary fontDictionary)
     {
-        super( fontDictionary );
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    public Font getawtFont() throws IOException
-    {
-        Font awtFont = null;
-        PDFontDescriptorDictionary fd = (PDFontDescriptorDictionary)getFontDescriptor();
-        PDStream ff2Stream = fd.getFontFile2();
-        if( ff2Stream != null )
-        {
-            try
-            {
-                // create a font with the embedded data
-                awtFont = Font.createFont( Font.TRUETYPE_FONT, ff2Stream.createInputStream() );
-            }
-            catch( FontFormatException f )
-            {
-                LOG.info("Can't read the embedded font " + fd.getFontName() );
-            }
-            if (awtFont == null)
-            {
-                awtFont = FontManager.getAwtFont(fd.getFontName());
-                if (awtFont != null)
-                {
-                    LOG.info("Using font "+awtFont.getName()+ " instead");
-                }
-                setIsFontSubstituted(true);
-            }
-        }
-        return awtFont;
+        super(fontDictionary);
     }
 
     /**
@@ -103,28 +71,28 @@ public class PDCIDFontType2Font extends PDCIDFont
     private void readCIDToGIDMapping()
     {
         COSBase map = font.getDictionaryObject(COSName.CID_TO_GID_MAP);
-        if (map instanceof COSStream) 
+        if (map instanceof COSStream)
         {
-            COSStream stream = (COSStream)map;
-            try 
+            COSStream stream = (COSStream) map;
+            try
             {
                 byte[] mapAsBytes = IOUtils.toByteArray(stream.getUnfilteredStream());
                 int numberOfInts = mapAsBytes.length / 2;
                 cid2gid = new int[numberOfInts];
                 int offset = 0;
-                for(int index = 0;index < numberOfInts;index++)
+                for (int index = 0; index < numberOfInts; index++)
                 {
                     cid2gid[index] = getCodeFromArray(mapAsBytes, offset, 2);
-                    offset+=2;
+                    offset += 2;
                 }
             }
-            catch(IOException exception)
+            catch (IOException exception)
             {
                 LOG.error("Can't read the CIDToGIDMap", exception);
             }
         }
     }
-    
+
     /**
      * Indicates if this font has a CIDToGIDMap.
      * 
@@ -146,16 +114,16 @@ public class PDCIDFontType2Font extends PDCIDFont
         }
         return hasCIDToGIDMap.booleanValue();
     }
-    
+
     /**
      * Maps the given CID to the correspondent GID.
      * 
      * @param cid the given CID
      * @return the mapped GID, or -1 if something went wrong.
      */
-    public int mapCIDToGID(int cid) 
+    public int mapCIDToGID(int cid)
     {
-        if (hasCIDToGIDMap()) 
+        if (hasCIDToGIDMap())
         {
             if (cid2gid == null)
             {
@@ -173,4 +141,41 @@ public class PDCIDFontType2Font extends PDCIDFont
             return cid;
         }
     }
+
+    /**
+     * Returns the CID2GID mapping if present.
+     * 
+     * @return the CID2GID mapping
+     */
+    public int[] getCID2GID()
+    {
+        if (hasCIDToGIDMap())
+        {
+            if (cid2gid == null)
+            {
+                readCIDToGIDMapping();
+            }
+        }
+        return cid2gid;
+    }
+
+    /**
+     * Returns the embedded true type font.
+     * 
+     * @return the true type font
+     * @throws IOException exception if something went wrong
+     */
+    public TrueTypeFont getTTFFont() throws IOException
+    {
+        PDFontDescriptorDictionary fd = (PDFontDescriptorDictionary) getFontDescriptor();
+        PDStream ff2Stream = fd.getFontFile2();
+        TrueTypeFont trueTypeFont = null;
+        if (ff2Stream != null)
+        {
+            TTFParser ttfParser = new TTFParser(true);
+            trueTypeFont = ttfParser.parseTTF(ff2Stream.createInputStream());
+        }
+        return trueTypeFont;
+    }
+
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java
index 762a091c59..1cd12d76fe 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java
@@ -16,13 +16,18 @@
  */
 package org.apache.pdfbox.pdmodel.font;
 
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
 import org.apache.fontbox.afm.AFMParser;
 import org.apache.fontbox.afm.FontMetric;
-import org.apache.fontbox.cmap.CMapParser;
 import org.apache.fontbox.cmap.CMap;
-
-import org.apache.pdfbox.encoding.Encoding;
-
+import org.apache.fontbox.cmap.CMapParser;
 import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
@@ -30,28 +35,18 @@ import org.apache.pdfbox.cos.COSFloat;
 import org.apache.pdfbox.cos.COSInteger;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.cos.COSString;
-
+import org.apache.pdfbox.encoding.Encoding;
 import org.apache.pdfbox.pdmodel.common.COSArrayList;
 import org.apache.pdfbox.pdmodel.common.COSObjectable;
 import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.pdmodel.common.PDRectangle;
-
 import org.apache.pdfbox.util.ResourceLoader;
 
-import java.io.InputStream;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
 /**
  * This is the base class for all PDF fonts.
- *
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.46 $
+ * 
  */
 public abstract class PDFont implements COSObjectable
 {
@@ -67,18 +62,17 @@ public abstract class PDFont implements COSObjectable
     private Encoding fontEncoding = null;
 
     /**
-     *  The descriptor of the font.
+     * The descriptor of the font.
      */
     private PDFontDescriptor fontDescriptor = null;
 
     /**
-     *  The font matrix.
+     * The font matrix.
      */
     protected PDMatrix fontMatrix = null;
 
     /**
-     * This is only used if this is a font object and it has an encoding and it is
-     * a type0 font with a cmap.
+     * This is only used if this is a font object and it has an encoding and it is a type0 font with a cmap.
      */
     protected CMap cmap = null;
 
@@ -86,62 +80,59 @@ public abstract class PDFont implements COSObjectable
      * The CMap holding the ToUnicode mapping.
      */
     protected CMap toUnicodeCmap = null;
-    
+
     private boolean hasToUnicode = false;
 
-    protected static Map<String, CMap> cmapObjects =
-        Collections.synchronizedMap( new HashMap<String, CMap>() );
+    protected static Map<String, CMap> cmapObjects = Collections.synchronizedMap(new HashMap<String, CMap>());
 
     /**
-     *  A list a floats representing the widths.
+     * A list a floats representing the widths.
      */
     private List<Float> widths = null;
 
     /**
      * The static map of the default Adobe font metrics.
      */
-    private static final Map<String, FontMetric> afmObjects =
-        Collections.unmodifiableMap( getAdobeFontMetrics() );
+    private static final Map<String, FontMetric> afmObjects = Collections.unmodifiableMap(getAdobeFontMetrics());
 
     // TODO move the Map to PDType1Font as these are the 14 Standard fonts
     // which are definitely Type 1 fonts
     private static Map<String, FontMetric> getAdobeFontMetrics()
     {
         Map<String, FontMetric> metrics = new HashMap<String, FontMetric>();
-        addAdobeFontMetric( metrics, "Courier-Bold" );
-        addAdobeFontMetric( metrics, "Courier-BoldOblique" );
-        addAdobeFontMetric( metrics, "Courier" );
-        addAdobeFontMetric( metrics, "Courier-Oblique" );
-        addAdobeFontMetric( metrics, "Helvetica" );
-        addAdobeFontMetric( metrics, "Helvetica-Bold" );
-        addAdobeFontMetric( metrics, "Helvetica-BoldOblique" );
-        addAdobeFontMetric( metrics, "Helvetica-Oblique" );
-        addAdobeFontMetric( metrics, "Symbol" );
-        addAdobeFontMetric( metrics, "Times-Bold" );
-        addAdobeFontMetric( metrics, "Times-BoldItalic" );
-        addAdobeFontMetric( metrics, "Times-Italic" );
-        addAdobeFontMetric( metrics, "Times-Roman" );
-        addAdobeFontMetric( metrics, "ZapfDingbats" );
+        addAdobeFontMetric(metrics, "Courier-Bold");
+        addAdobeFontMetric(metrics, "Courier-BoldOblique");
+        addAdobeFontMetric(metrics, "Courier");
+        addAdobeFontMetric(metrics, "Courier-Oblique");
+        addAdobeFontMetric(metrics, "Helvetica");
+        addAdobeFontMetric(metrics, "Helvetica-Bold");
+        addAdobeFontMetric(metrics, "Helvetica-BoldOblique");
+        addAdobeFontMetric(metrics, "Helvetica-Oblique");
+        addAdobeFontMetric(metrics, "Symbol");
+        addAdobeFontMetric(metrics, "Times-Bold");
+        addAdobeFontMetric(metrics, "Times-BoldItalic");
+        addAdobeFontMetric(metrics, "Times-Italic");
+        addAdobeFontMetric(metrics, "Times-Roman");
+        addAdobeFontMetric(metrics, "ZapfDingbats");
         return metrics;
     }
 
     protected static final String resourceRootCMAP = "org/apache/pdfbox/resources/cmap/";
     private static final String resourceRootAFM = "org/apache/pdfbox/resources/afm/";
 
-    private static void addAdobeFontMetric(
-            Map<String, FontMetric> metrics, String name )
+    private static void addAdobeFontMetric(Map<String, FontMetric> metrics, String name)
     {
         try
         {
             String resource = resourceRootAFM + name + ".afm";
-            InputStream afmStream = ResourceLoader.loadResource( resource );
-            if( afmStream != null )
+            InputStream afmStream = ResourceLoader.loadResource(resource);
+            if (afmStream != null)
             {
                 try
                 {
-                    AFMParser parser = new AFMParser( afmStream );
+                    AFMParser parser = new AFMParser(afmStream);
                     parser.parse();
-                    metrics.put( name, parser.getResult() );
+                    metrics.put(name, parser.getResult());
                 }
                 finally
                 {
@@ -156,15 +147,13 @@ public abstract class PDFont implements COSObjectable
     }
 
     /**
-     * This will clear AFM resources that are stored statically.
-     * This is usually not a problem unless you want to reclaim
-     * resources for a long running process.
-     *
-     * SPECIAL NOTE: The font calculations are currently in COSObject, which
-     * is where they will reside until PDFont is mature enough to take them over.
-     * PDFont is the appropriate place for them and not in COSObject but we need font
-     * calculations for text extraction.  THIS METHOD WILL BE MOVED OR REMOVED
-     * TO ANOTHER LOCATION IN A FUTURE VERSION OF PDFBOX.
+     * This will clear AFM resources that are stored statically. This is usually not a problem unless you want to
+     * reclaim resources for a long running process.
+     * 
+     * SPECIAL NOTE: The font calculations are currently in COSObject, which is where they will reside until PDFont is
+     * mature enough to take them over. PDFont is the appropriate place for them and not in COSObject but we need font
+     * calculations for text extraction. THIS METHOD WILL BE MOVED OR REMOVED TO ANOTHER LOCATION IN A FUTURE VERSION OF
+     * PDFBOX.
      */
     public static void clearResources()
     {
@@ -177,15 +166,15 @@ public abstract class PDFont implements COSObjectable
     public PDFont()
     {
         font = new COSDictionary();
-        font.setItem( COSName.TYPE, COSName.FONT );
+        font.setItem(COSName.TYPE, COSName.FONT);
     }
 
     /**
      * Constructor.
-     *
+     * 
      * @param fontDictionary The font dictionary according to the PDF specification.
      */
-    public PDFont( COSDictionary fontDictionary )
+    public PDFont(COSDictionary fontDictionary)
     {
         font = fontDictionary;
         determineEncoding();
@@ -193,25 +182,25 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * This will get the font descriptor for this font.
-     *
+     * 
      * @return The font descriptor for this font.
-     *
+     * 
      */
     public PDFontDescriptor getFontDescriptor()
     {
-        if(fontDescriptor == null)
+        if (fontDescriptor == null)
         {
-            COSDictionary fd = (COSDictionary)font.getDictionaryObject( COSName.FONT_DESC );
+            COSDictionary fd = (COSDictionary) font.getDictionaryObject(COSName.FONT_DESC);
             if (fd != null)
             {
-                fontDescriptor = new PDFontDescriptorDictionary( fd );
+                fontDescriptor = new PDFontDescriptorDictionary(fd);
             }
             else
             {
                 getAFM();
-                if( afm != null )
+                if (afm != null)
                 {
-                    fontDescriptor = new PDFontDescriptorAFM( afm );
+                    fontDescriptor = new PDFontDescriptorAFM(afm);
                 }
             }
         }
@@ -220,24 +209,23 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * This will set the font descriptor.
-     *
+     * 
      * @param fdDictionary The font descriptor.
      */
-    public void setFontDescriptor( PDFontDescriptorDictionary fdDictionary )
+    public void setFontDescriptor(PDFontDescriptorDictionary fdDictionary)
     {
         COSDictionary dic = null;
-        if( fdDictionary != null )
+        if (fdDictionary != null)
         {
             dic = fdDictionary.getCOSDictionary();
         }
-        font.setItem( COSName.FONT_DESC, dic );
+        font.setItem(COSName.FONT_DESC, dic);
         fontDescriptor = fdDictionary;
     }
 
     /**
-     * Determines the encoding for the font.
-     * This method as to be overwritten, as there are different
-     * possibilities to define a mapping.
+     * Determines the encoding for the font. This method as to be overwritten, as there are different possibilities to
+     * define a mapping.
      */
     protected abstract void determineEncoding();
 
@@ -251,112 +239,112 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * This will get the font width for a character.
-     *
+     * 
      * @param c The character code to get the width for.
      * @param offset The offset into the array.
      * @param length The length of the data.
-     *
+     * 
      * @return The width is in 1000 unit of text space, ie 333 or 777
-     *
+     * 
      * @throws IOException If an error occurs while parsing.
      */
-    public abstract float getFontWidth( byte[] c, int offset, int length ) throws IOException;
+    public abstract float getFontWidth(byte[] c, int offset, int length) throws IOException;
 
     /**
      * This will get the font width for a character.
-     *
+     * 
      * @param c The character code to get the width for.
      * @param offset The offset into the array.
      * @param length The length of the data.
-     *
+     * 
      * @return The width is in 1000 unit of text space, ie 333 or 777
-     *
+     * 
      * @throws IOException If an error occurs while parsing.
      */
-    public abstract float getFontHeight( byte[] c, int offset, int length ) throws IOException;
+    public abstract float getFontHeight(byte[] c, int offset, int length) throws IOException;
 
     /**
      * This will get the width of this string for this font.
-     *
+     * 
      * @param string The string to get the width of.
-     *
+     * 
      * @return The width of the string in 1000 units of text space, ie 333 567...
-     *
+     * 
      * @throws IOException If there is an error getting the width information.
      */
-    public float getStringWidth( String string ) throws IOException
+    public float getStringWidth(String string) throws IOException
     {
         byte[] data = string.getBytes("ISO-8859-1");
         float totalWidth = 0;
-        for( int i=0; i<data.length; i++ )
+        for (int i = 0; i < data.length; i++)
         {
-            totalWidth+=getFontWidth( data, i, 1 );
+            totalWidth += getFontWidth(data, i, 1);
         }
         return totalWidth;
     }
 
     /**
      * This will get the average font width for all characters.
-     *
+     * 
      * @return The width is in 1000 unit of text space, ie 333 or 777
-     *
+     * 
      * @throws IOException If an error occurs while parsing.
      */
     public abstract float getAverageFontWidth() throws IOException;
 
     /**
      * Used for multibyte encodings.
-     *
+     * 
      * @param data The array of data.
      * @param offset The offset into the array.
      * @param length The number of bytes to use.
-     *
+     * 
      * @return The int value of data from the array.
      */
-    public int getCodeFromArray( byte[] data, int offset, int length )
+    public int getCodeFromArray(byte[] data, int offset, int length)
     {
         int code = 0;
-        for( int i=0; i<length; i++ )
+        for (int i = 0; i < length; i++)
         {
             code <<= 8;
-            code |= (data[offset+i]+256)%256;
+            code |= (data[offset + i] + 256) % 256;
         }
         return code;
     }
 
     /**
      * This will attempt to get the font width from an AFM file.
-     *
+     * 
      * @param code The character code we are trying to get.
-     *
+     * 
      * @return The font width from the AFM file.
-     *
+     * 
      * @throws IOException if we cannot find the width.
      */
-    protected float getFontWidthFromAFMFile( int code ) throws IOException
+    protected float getFontWidthFromAFMFile(int code) throws IOException
     {
         float retval = 0;
         FontMetric metric = getAFM();
-        if( metric != null )
+        if (metric != null)
         {
-            String characterName = fontEncoding.getName( code );
-            retval = metric.getCharacterWidth( characterName );
+            String characterName = fontEncoding.getName(code);
+            retval = metric.getCharacterWidth(characterName);
         }
         return retval;
     }
 
     /**
      * This will attempt to get the average font width from an AFM file.
-     *
+     * 
      * @return The average font width from the AFM file.
-     *
+     * 
      * @throws IOException if we cannot find the width.
      */
     protected float getAverageFontWidthFromAFMFile() throws IOException
     {
         float retval = 0;
         FontMetric metric = getAFM();
-        if( metric != null )
+        if (metric != null)
         {
             retval = metric.getAverageCharacterWidth();
         }
@@ -365,33 +353,33 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * This will get an AFM object if one exists.
-     *
+     * 
      * @return The afm object from the name.
-     *
+     * 
      */
     protected FontMetric getAFM()
     {
         if (isType1Font() && afm == null)
         {
-            COSBase baseFont = font.getDictionaryObject( COSName.BASE_FONT );
+            COSBase baseFont = font.getDictionaryObject(COSName.BASE_FONT);
             String name = null;
-            if( baseFont instanceof COSName )
+            if (baseFont instanceof COSName)
             {
-                name = ((COSName)baseFont).getName();
+                name = ((COSName) baseFont).getName();
                 if (name.indexOf("+") > -1)
                 {
-                    name = name.substring(name.indexOf("+")+1);
+                    name = name.substring(name.indexOf("+") + 1);
                 }
 
             }
-            else if ( baseFont instanceof COSString )
+            else if (baseFont instanceof COSString)
             {
-                COSString string = (COSString)baseFont;
+                COSString string = (COSString) baseFont;
                 name = string.getString();
             }
-            if ( name != null )
+            if (name != null)
             {
-                afm = afmObjects.get( name );
+                afm = afmObjects.get(name);
             }
         }
         return afm;
@@ -400,46 +388,49 @@ public abstract class PDFont implements COSObjectable
     private FontMetric afm = null;
 
     private COSBase encoding = null;
+
     /**
-     * cache the {@link COSName#ENCODING} object from
-     * the font's dictionary since it is called so often.
+     * cache the {@link COSName#ENCODING} object from the font's dictionary since it is called so often.
      * <p>
      * Use this method instead of
+     * 
      * <pre>
-     *   font.getDictionaryObject(COSName.ENCODING);
+     * font.getDictionaryObject(COSName.ENCODING);
      * </pre>
+     * 
      * @return the encoding
      */
     protected COSBase getEncoding()
     {
         if (encoding == null)
         {
-            encoding = font.getDictionaryObject( COSName.ENCODING );
+            encoding = font.getDictionaryObject(COSName.ENCODING);
         }
         return encoding;
     }
 
     /**
      * Set the encoding object from the fonts dictionary.
+     * 
      * @param encodingValue the given encoding.
      */
     protected void setEncoding(COSBase encodingValue)
     {
-        font.setItem( COSName.ENCODING, encodingValue );
+        font.setItem(COSName.ENCODING, encodingValue);
         encoding = encodingValue;
     }
 
     /**
      * Encode the given value using the CMap of the font.
-     *
+     * 
      * @param code the code to encode.
      * @param length the byte length of the given code.
      * @param isCIDFont indicates that the used font is a CID font.
-     *
+     * 
      * @return The value of the encoded character.
      * @throws IOException if something went wrong
      */
-    protected String cmapEncoding( int code, int length, boolean isCIDFont, CMap sourceCmap ) throws IOException
+    protected String cmapEncoding(int code, int length, boolean isCIDFont, CMap sourceCmap) throws IOException
     {
         String retval = null;
         // there is not sourceCmap if this is a descendant font
@@ -457,75 +448,76 @@ public abstract class PDFont implements COSObjectable
         }
         return retval;
     }
+
     /**
      * This will perform the encoding of a character if needed.
-     *
+     * 
      * @param c The character to encode.
      * @param offset The offset into the array to get the data
      * @param length The number of bytes to read.
-     *
+     * 
      * @return The value of the encoded character.
-     *
+     * 
      * @throws IOException If there is an error during the encoding.
      */
-    public String encode( byte[] c, int offset, int length ) throws IOException
+    public String encode(byte[] c, int offset, int length) throws IOException
     {
         String retval = null;
-        int code = getCodeFromArray( c, offset, length );
-        if( toUnicodeCmap != null )
+        int code = getCodeFromArray(c, offset, length);
+        if (toUnicodeCmap != null)
         {
             retval = cmapEncoding(code, length, false, toUnicodeCmap);
         }
-        if( retval == null && cmap != null )
+        if (retval == null && cmap != null)
         {
             retval = cmapEncoding(code, length, false, cmap);
         }
 
         // there is no cmap but probably an encoding with a suitable mapping
-        if( retval == null )
+        if (retval == null)
         {
-            if( fontEncoding != null )
+            if (fontEncoding != null)
             {
-                retval = fontEncoding.getCharacter( code );
+                retval = fontEncoding.getCharacter(code);
             }
-            if( retval == null && (cmap == null || length == 2))
+            if (retval == null && (cmap == null || length == 2))
             {
-                retval = getStringFromArray( c, offset, length );
+                retval = getStringFromArray(c, offset, length);
             }
         }
         return retval;
     }
 
-    public int encodeToCID( byte[] c, int offset, int length ) throws IOException
+    public int encodeToCID(byte[] c, int offset, int length) throws IOException
     {
         int code = -1;
-        if (encode(c, offset, length) != null) 
+        if (encode(c, offset, length) != null)
         {
-            code = getCodeFromArray( c, offset, length );
+            code = getCodeFromArray(c, offset, length);
         }
         return code;
     }
-    
+
     private static final String[] SINGLE_CHAR_STRING = new String[256];
     private static final String[][] DOUBLE_CHAR_STRING = new String[256][256];
     static
     {
-        for( int i=0; i<256; i++ )
+        for (int i = 0; i < 256; i++)
         {
             try
             {
-                SINGLE_CHAR_STRING[i] = new String( new byte[] {(byte)i}, "ISO-8859-1" );
+                SINGLE_CHAR_STRING[i] = new String(new byte[] { (byte) i }, "ISO-8859-1");
             }
             catch (UnsupportedEncodingException e)
             {
                 // Nothing should happen here
                 e.printStackTrace();
             }
-            for( int j=0; j<256; j++ )
+            for (int j = 0; j < 256; j++)
             {
                 try
                 {
-                    DOUBLE_CHAR_STRING[i][j] = new String( new byte[] {(byte)i, (byte)j}, "UTF-16BE" );
+                    DOUBLE_CHAR_STRING[i][j] = new String(new byte[] { (byte) i, (byte) j }, "UTF-16BE");
                 }
                 catch (UnsupportedEncodingException e)
                 {
@@ -536,57 +528,59 @@ public abstract class PDFont implements COSObjectable
         }
     }
 
-    private static String getStringFromArray( byte[] c, int offset, int length ) throws IOException
+    private static String getStringFromArray(byte[] c, int offset, int length) throws IOException
     {
         String retval = null;
-        if( length == 1 )
+        if (length == 1)
         {
-            retval = SINGLE_CHAR_STRING[(c[offset]+256)%256];
+            retval = SINGLE_CHAR_STRING[(c[offset] + 256) % 256];
         }
-        else if( length == 2 )
+        else if (length == 2)
         {
-            retval = DOUBLE_CHAR_STRING[(c[offset]+256)%256][(c[offset+1]+256)%256];
+            retval = DOUBLE_CHAR_STRING[(c[offset] + 256) % 256][(c[offset + 1] + 256) % 256];
         }
         else
         {
-            throw new IOException( "Error:Unknown character length:" + length );
+            throw new IOException("Error:Unknown character length:" + length);
         }
         return retval;
     }
 
-    protected CMap parseCmap( String cmapRoot, InputStream cmapStream)
+    protected CMap parseCmap(String cmapRoot, InputStream cmapStream)
     {
         CMap targetCmap = null;
-        if( cmapStream != null )
+        if (cmapStream != null)
         {
             CMapParser parser = new CMapParser();
             try
             {
-                targetCmap = parser.parse( cmapRoot, cmapStream );
+                targetCmap = parser.parse(cmapRoot, cmapStream);
                 // limit the cache to external CMaps
                 if (cmapRoot != null)
                 {
-                    cmapObjects.put( targetCmap.getName(), targetCmap );
+                    cmapObjects.put(targetCmap.getName(), targetCmap);
                 }
             }
-            catch (IOException exception) {}
+            catch (IOException exception)
+            {
+            }
         }
         return targetCmap;
     }
 
     /**
      * The will set the encoding for this font.
-     *
+     * 
      * @param enc The font encoding.
      */
-    public void setFontEncoding( Encoding enc )
+    public void setFontEncoding(Encoding enc)
     {
         fontEncoding = enc;
     }
 
     /**
      * This will get or create the encoder.
-     *
+     * 
      * @return The encoding to use.
      */
     public Encoding getFontEncoding()
@@ -596,12 +590,12 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * This will always return "Font" for fonts.
-     *
+     * 
      * @return The type of object that this is.
      */
     public String getType()
     {
-        return font.getNameAsString( COSName.TYPE );
+        return font.getNameAsString(COSName.TYPE);
     }
 
     // Memorized values to avoid repeated dictionary lookups
@@ -613,14 +607,14 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * This will get the subtype of font, Type1, Type3, ...
-     *
+     * 
      * @return The type of font that this is.
      */
     public String getSubType()
     {
         if (subtype == null)
         {
-            subtype = font.getNameAsString( COSName.SUBTYPE );
+            subtype = font.getNameAsString(COSName.SUBTYPE);
             type1Font = "Type1".equals(subtype);
             trueTypeFont = "TrueType".equals(subtype);
             type0Font = "Type0".equals(subtype);
@@ -631,6 +625,7 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * Determines if the font is a type 1 font.
+     * 
      * @return returns true if the font is a type 1 font
      */
     public boolean isType1Font()
@@ -641,6 +636,7 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * Determines if the font is a type 3 font.
+     * 
      * @return returns true if the font is a type 3 font
      */
     public boolean isType3Font()
@@ -648,9 +644,10 @@ public abstract class PDFont implements COSObjectable
         getSubType();
         return type3Font;
     }
-    
+
     /**
      * Determines if the font is a type 0 font.
+     * 
      * @return returns true if the font is a type 0 font
      */
     public boolean isType0Font()
@@ -661,6 +658,7 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * Determines if the font is a true type font.
+     * 
      * @return returns true if the font is a true type font
      */
     public boolean isTrueTypeFont()
@@ -669,79 +667,93 @@ public abstract class PDFont implements COSObjectable
         return trueTypeFont;
     }
 
+    /**
+     * Determines if the font is a symbolic font.
+     * 
+     * @return returns true if the font is a symbolic font
+     */
+    public boolean isSymbolicFont()
+    {
+        if (getFontDescriptor() != null)
+        {
+            return getFontDescriptor().isSymbolic();
+        }
+        return false;
+    }
+
     /**
      * The PostScript name of the font.
-     *
+     * 
      * @return The postscript name of the font.
      */
     public String getBaseFont()
     {
-        return font.getNameAsString( COSName.BASE_FONT );
+        return font.getNameAsString(COSName.BASE_FONT);
     }
 
     /**
      * Set the PostScript name of the font.
-     *
+     * 
      * @param baseFont The postscript name for the font.
      */
-    public void setBaseFont( String baseFont )
+    public void setBaseFont(String baseFont)
     {
-        font.setName( COSName.BASE_FONT, baseFont );
+        font.setName(COSName.BASE_FONT, baseFont);
     }
 
     /**
      * The code for the first char or -1 if there is none.
-     *
+     * 
      * @return The code for the first character.
      */
     public int getFirstChar()
     {
-        return font.getInt( COSName.FIRST_CHAR, -1 );
+        return font.getInt(COSName.FIRST_CHAR, -1);
     }
 
     /**
      * Set the first character this font supports.
-     *
+     * 
      * @param firstChar The first character.
      */
-    public void setFirstChar( int firstChar )
+    public void setFirstChar(int firstChar)
     {
-        font.setInt( COSName.FIRST_CHAR, firstChar );
+        font.setInt(COSName.FIRST_CHAR, firstChar);
     }
 
     /**
      * The code for the last char or -1 if there is none.
-     *
+     * 
      * @return The code for the last character.
      */
     public int getLastChar()
     {
-        return font.getInt( COSName.LAST_CHAR, -1 );
+        return font.getInt(COSName.LAST_CHAR, -1);
     }
 
     /**
      * Set the last character this font supports.
-     *
+     * 
      * @param lastChar The last character.
      */
-    public void setLastChar( int lastChar )
+    public void setLastChar(int lastChar)
     {
-        font.setInt( COSName.LAST_CHAR, lastChar );
+        font.setInt(COSName.LAST_CHAR, lastChar);
     }
 
     /**
-     * The widths of the characters.  This will be null for the standard 14 fonts.
-     *
+     * The widths of the characters. This will be null for the standard 14 fonts.
+     * 
      * @return The widths of the characters.
      */
     public List<Float> getWidths()
     {
         if (widths == null)
         {
-            COSArray array = (COSArray)font.getDictionaryObject( COSName.WIDTHS );
+            COSArray array = (COSArray) font.getDictionaryObject(COSName.WIDTHS);
             if (array != null)
             {
-                widths = COSArrayList.convertFloatCOSArrayToList( array );
+                widths = COSArrayList.convertFloatCOSArrayToList(array);
             }
         }
         return widths;
@@ -749,39 +761,38 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * Set the widths of the characters code.
-     *
+     * 
      * @param widthsList The widths of the character codes.
      */
-    public void setWidths( List<Float> widthsList )
+    public void setWidths(List<Float> widthsList)
     {
         widths = widthsList;
-        font.setItem( COSName.WIDTHS, COSArrayList.converterToCOSArray( widths ) );
+        font.setItem(COSName.WIDTHS, COSArrayList.converterToCOSArray(widths));
     }
 
     /**
-     * This will get the matrix that is used to transform glyph space to
-     * text space.  By default there are 1000 glyph units to 1 text space
-     * unit, but type3 fonts can use any value.
-     *
-     * Note:If this is a type3 font then it can be modified via the PDType3Font.setFontMatrix, otherwise this
-     * is a read-only property.
-     *
+     * This will get the matrix that is used to transform glyph space to text space. By default there are 1000 glyph
+     * units to 1 text space unit, but type3 fonts can use any value.
+     * 
+     * Note:If this is a type3 font then it can be modified via the PDType3Font.setFontMatrix, otherwise this is a
+     * read-only property.
+     * 
      * @return The matrix to transform from glyph space to text space.
      */
     public PDMatrix getFontMatrix()
     {
         if (fontMatrix == null)
         {
-            COSArray array = (COSArray)font.getDictionaryObject( COSName.FONT_MATRIX );
-            if( array == null )
+            COSArray array = (COSArray) font.getDictionaryObject(COSName.FONT_MATRIX);
+            if (array == null)
             {
                 array = new COSArray();
-                array.add( new COSFloat( 0.001f ) );
-                array.add( COSInteger.ZERO );
-                array.add( COSInteger.ZERO );
-                array.add( new COSFloat( 0.001f ) );
-                array.add( COSInteger.ZERO );
-                array.add( COSInteger.ZERO );
+                array.add(new COSFloat(0.001f));
+                array.add(COSInteger.ZERO);
+                array.add(COSInteger.ZERO);
+                array.add(new COSFloat(0.001f));
+                array.add(COSInteger.ZERO);
+                array.add(COSInteger.ZERO);
             }
             fontMatrix = new PDMatrix(array);
         }
@@ -790,9 +801,9 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * This will get the fonts bounding box.
-     *
+     * 
      * @return The fonts bounding box.
-     *
+     * 
      * @throws IOException If there is an error getting the bounding box.
      */
     public abstract PDRectangle getFontBoundingBox() throws IOException;
@@ -800,9 +811,9 @@ public abstract class PDFont implements COSObjectable
     /**
      * {@inheritDoc}
      */
-    public boolean equals( Object other )
+    public boolean equals(Object other)
     {
-        return other instanceof PDFont && ((PDFont)other).getCOSObject() == this.getCOSObject();
+        return other instanceof PDFont && ((PDFont) other).getCOSObject() == this.getCOSObject();
     }
 
     /**
@@ -815,10 +826,11 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * Determines the width of the given character.
+     * 
      * @param charCode the code of the given character
      * @return the width of the character
      */
-    public float getFontWidth( int charCode )
+    public float getFontWidth(int charCode)
     {
         float width = -1;
         int firstChar = getFirstChar();
@@ -829,7 +841,7 @@ public abstract class PDFont implements COSObjectable
             getWidths();
             if (widths != null)
             {
-                width = widths.get(charCode-firstChar).floatValue();
+                width = widths.get(charCode - firstChar).floatValue();
             }
         }
         else
@@ -845,26 +857,38 @@ public abstract class PDFont implements COSObjectable
 
     /**
      * Determines if a font as a ToUnicode entry.
+     * 
      * @return true if the font has a ToUnicode entry
      */
-    protected boolean hasToUnicode()
+    public boolean hasToUnicode()
     {
         return hasToUnicode;
     }
 
     /**
      * Sets hasToUnicode to the given value.
+     * 
      * @param hasToUnicodeValue the given value for hasToUnicode
      */
     protected void setHasToUnicode(boolean hasToUnicodeValue)
     {
         hasToUnicode = hasToUnicodeValue;
     }
-    
+
     /**
      * Determines the width of the space character.
+     * 
      * @return the width of the space character
      */
     public abstract float getSpaceWidth();
-    
+
+    /**
+     * Returns the toUnicode mapping if present.
+     * 
+     * @return the CMap representing the toUnicode mapping
+     */
+    public CMap getToUnicodeCMap()
+    {
+        return toUnicodeCmap;
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java
index d0226cf8de..9a9ddfabf5 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java
@@ -17,9 +17,6 @@
 package org.apache.pdfbox.pdmodel.font;
 
 import java.awt.Font;
-import java.awt.FontFormatException;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -46,7 +43,6 @@ import org.apache.fontbox.ttf.NamingTable;
 import org.apache.fontbox.ttf.OS2WindowsMetricsTable;
 import org.apache.fontbox.ttf.PostScriptTable;
 import org.apache.fontbox.ttf.TTFParser;
-import org.apache.fontbox.ttf.TTFSubFont;
 import org.apache.fontbox.ttf.TrueTypeFont;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
@@ -59,9 +55,9 @@ import org.apache.pdfbox.util.ResourceLoader;
 
 /**
  * This is the TrueType implementation of fonts.
- *
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.17 $
+ * 
  */
 public class PDTrueTypeFont extends PDSimpleFont
 {
@@ -69,136 +65,133 @@ public class PDTrueTypeFont extends PDSimpleFont
     /**
      * Log instance.
      */
-    private static final Log log = LogFactory.getLog(PDTrueTypeFont.class);
+    private static final Log LOG = LogFactory.getLog(PDTrueTypeFont.class);
 
     /**
-     * This is the key to a property in the PDFBox_External_Fonts.properties
-     * file to load a Font when a mapping does not exist for the current font.
+     * This is the key to a property in the PDFBox_External_Fonts.properties file to load a Font when a mapping does not
+     * exist for the current font.
      */
     public static final String UNKNOWN_FONT = "UNKNOWN_FONT";
 
     private Font awtFont = null;
 
     private static Properties externalFonts = new Properties();
-    private static Map<String,TrueTypeFont> loadedExternalFonts = new HashMap<String,TrueTypeFont>();
+    private static Map<String, TrueTypeFont> loadedExternalFonts = new HashMap<String, TrueTypeFont>();
 
     static
     {
         try
         {
-            ResourceLoader.loadProperties(
-                    "org/apache/pdfbox/resources/PDFBox_External_Fonts.properties",
-                    externalFonts );
+            ResourceLoader
+                    .loadProperties("org/apache/pdfbox/resources/PDFBox_External_Fonts.properties", externalFonts);
         }
-        catch( IOException io )
+        catch (IOException io)
         {
-            throw new RuntimeException( "Error loading font resources", io );
+            throw new RuntimeException("Error loading font resources", io);
         }
     }
 
-
     /**
      * Constructor.
      */
     public PDTrueTypeFont()
     {
         super();
-        font.setItem( COSName.SUBTYPE, COSName.TRUE_TYPE );
+        font.setItem(COSName.SUBTYPE, COSName.TRUE_TYPE);
     }
 
     /**
      * Constructor.
-     *
+     * 
      * @param fontDictionary The font dictionary according to the PDF specification.
      * 
      * @throws IOException exception if something went wrong when loading the font.
      */
-    public PDTrueTypeFont( COSDictionary fontDictionary ) throws IOException
+    public PDTrueTypeFont(COSDictionary fontDictionary) throws IOException
     {
-        super( fontDictionary );
-        ensureFontDescriptor();
+        super(fontDictionary);
     }
 
     /**
      * This will load a TTF font from a font file.
-     *
+     * 
      * @param doc The PDF document that will hold the embedded font.
      * @param file The file on the filesystem that holds the font file.
      * @return A true type font.
      * @throws IOException If there is an error loading the file data.
      */
-    public static PDTrueTypeFont loadTTF( PDDocument doc, String file ) throws IOException
+    public static PDTrueTypeFont loadTTF(PDDocument doc, String file) throws IOException
     {
-        return loadTTF( doc, new File( file ) );
+        return loadTTF(doc, new File(file));
     }
 
     /**
      * This will load a TTF to be embedded into a document.
-     *
+     * 
      * @param doc The PDF document that will hold the embedded font.
      * @param file a ttf file.
      * @return a PDTrueTypeFont instance.
      * @throws IOException If there is an error loading the data.
      */
-    public static PDTrueTypeFont loadTTF( PDDocument doc, File file ) throws IOException
+    public static PDTrueTypeFont loadTTF(PDDocument doc, File file) throws IOException
     {
-        return loadTTF( doc, new FileInputStream( file ) );
-    } 
-    
+        return loadTTF(doc, new FileInputStream(file));
+    }
+
     /**
      * This will load a TTF to be embedded into a document.
-     *
+     * 
      * @param doc The PDF document that will hold the embedded font.
      * @param stream a ttf input stream.
      * @return a PDTrueTypeFont instance.
      * @throws IOException If there is an error loading the data.
      */
-    public static PDTrueTypeFont loadTTF( PDDocument doc, InputStream stream ) throws IOException
-    { 
-        return PDTrueTypeFont.loadTTF(doc,stream,new WinAnsiEncoding());
+    public static PDTrueTypeFont loadTTF(PDDocument doc, InputStream stream) throws IOException
+    {
+        return PDTrueTypeFont.loadTTF(doc, stream, new WinAnsiEncoding());
     }
 
     /**
      * This will load a TTF to be embedded into a document.
-     *
+     * 
      * @param doc The PDF document that will hold the embedded font.
      * @param stream a ttf input stream.
      * @param enc The font encoding.
      * @return a PDTrueTypeFont instance.
      * @throws IOException If there is an error loading the data.
      */
-    public static PDTrueTypeFont loadTTF( PDDocument doc, InputStream stream, Encoding enc ) throws IOException
-    { 
-        PDStream fontStream = new PDStream(doc, stream, false );
-        fontStream.getStream().setInt( COSName.LENGTH1, fontStream.getByteArray().length );
+    public static PDTrueTypeFont loadTTF(PDDocument doc, InputStream stream, Encoding enc) throws IOException
+    {
+        PDStream fontStream = new PDStream(doc, stream, false);
+        fontStream.getStream().setInt(COSName.LENGTH1, fontStream.getByteArray().length);
         fontStream.addCompression();
-        //only support winansi encoding right now, should really
-        //just use Identity-H with unicode mapping
-        return PDTrueTypeFont.loadTTF(fontStream,enc);
+        // only support winansi encoding right now, should really
+        // just use Identity-H with unicode mapping
+        return PDTrueTypeFont.loadTTF(fontStream, enc);
     }
 
     /**
      * This will load a TTF to be embedded into a document.
-     *
+     * 
      * @param fontStream a ttf input stream.
      * @param enc The font encoding.
      * @return a PDTrueTypeFont instance.
      * @throws IOException If there is an error loading the data.
      */
-    public static PDTrueTypeFont loadTTF( PDStream fontStream, Encoding enc ) throws IOException
-    { 
+    public static PDTrueTypeFont loadTTF(PDStream fontStream, Encoding enc) throws IOException
+    {
         PDTrueTypeFont retval = new PDTrueTypeFont();
-        retval.setFontEncoding( enc );
+        retval.setFontEncoding(enc);
         retval.setEncoding(enc.getCOSObject());
 
         PDFontDescriptorDictionary fd = new PDFontDescriptorDictionary();
-        retval.setFontDescriptor( fd );
-        fd.setFontFile2( fontStream );
+        retval.setFontDescriptor(fd);
+        fd.setFontFile2(fontStream);
         // As the stream was close within the PDStream constructor, we have to recreate it
         InputStream stream = fontStream.createInputStream();
         try
         {
-            retval.loadDescriptorDictionary(fd, stream); 
+            retval.loadDescriptorDictionary(fd, stream);
         }
         finally
         {
@@ -207,165 +200,144 @@ public class PDTrueTypeFont extends PDSimpleFont
         return retval;
     }
 
-    private void ensureFontDescriptor() throws IOException
-    {
-        if( getFontDescriptor() == null )
-        {
-            PDFontDescriptorDictionary fdd = new PDFontDescriptorDictionary(); 
-            setFontDescriptor(fdd);
-            InputStream ttfData = getExternalTTFData();
-            if( ttfData != null )
-            {
-                try
-                {
-                    loadDescriptorDictionary(fdd, ttfData);
-                }
-                finally
-                {
-                    ttfData.close();
-                }
-            }
-        }
-    }
-
     private void loadDescriptorDictionary(PDFontDescriptorDictionary fd, InputStream ttfData) throws IOException
     {
         TrueTypeFont ttf = null;
         try
         {
             TTFParser parser = new TTFParser();
-            ttf = parser.parseTTF( ttfData );
+            ttf = parser.parseTTF(ttfData);
             NamingTable naming = ttf.getNaming();
             List<NameRecord> records = naming.getNameRecords();
-            for( int i=0; i<records.size(); i++ )
+            for (int i = 0; i < records.size(); i++)
             {
-                NameRecord nr = records.get( i );
-                if( nr.getNameId() == NameRecord.NAME_POSTSCRIPT_NAME )
+                NameRecord nr = records.get(i);
+                if (nr.getNameId() == NameRecord.NAME_POSTSCRIPT_NAME)
                 {
-                    setBaseFont( nr.getString() );
-                    fd.setFontName( nr.getString() );
+                    setBaseFont(nr.getString());
+                    fd.setFontName(nr.getString());
                 }
-                else if( nr.getNameId() == NameRecord.NAME_FONT_FAMILY_NAME )
+                else if (nr.getNameId() == NameRecord.NAME_FONT_FAMILY_NAME)
                 {
-                    fd.setFontFamily( nr.getString() );
+                    fd.setFontFamily(nr.getString());
                 }
             }
 
             OS2WindowsMetricsTable os2 = ttf.getOS2Windows();
             boolean isSymbolic = false;
-            switch( os2.getFamilyClass() )
+            switch (os2.getFamilyClass())
             {
-                case OS2WindowsMetricsTable.FAMILY_CLASS_SYMBOLIC:
-                    isSymbolic = true;
-                    break;
-                case OS2WindowsMetricsTable.FAMILY_CLASS_SCRIPTS:
-                    fd.setScript( true );
-                    break;
-                case OS2WindowsMetricsTable.FAMILY_CLASS_CLAREDON_SERIFS:
-                case OS2WindowsMetricsTable.FAMILY_CLASS_FREEFORM_SERIFS:
-                case OS2WindowsMetricsTable.FAMILY_CLASS_MODERN_SERIFS:
-                case OS2WindowsMetricsTable.FAMILY_CLASS_OLDSTYLE_SERIFS:
-                case OS2WindowsMetricsTable.FAMILY_CLASS_SLAB_SERIFS:
-                    fd.setSerif( true );
-                    break;
-                default:
-                    //do nothing
+            case OS2WindowsMetricsTable.FAMILY_CLASS_SYMBOLIC:
+                isSymbolic = true;
+                break;
+            case OS2WindowsMetricsTable.FAMILY_CLASS_SCRIPTS:
+                fd.setScript(true);
+                break;
+            case OS2WindowsMetricsTable.FAMILY_CLASS_CLAREDON_SERIFS:
+            case OS2WindowsMetricsTable.FAMILY_CLASS_FREEFORM_SERIFS:
+            case OS2WindowsMetricsTable.FAMILY_CLASS_MODERN_SERIFS:
+            case OS2WindowsMetricsTable.FAMILY_CLASS_OLDSTYLE_SERIFS:
+            case OS2WindowsMetricsTable.FAMILY_CLASS_SLAB_SERIFS:
+                fd.setSerif(true);
+                break;
+            default:
+                // do nothing
             }
-            switch( os2.getWidthClass() )
+            switch (os2.getWidthClass())
             {
-                case OS2WindowsMetricsTable.WIDTH_CLASS_ULTRA_CONDENSED:
-                    fd.setFontStretch( "UltraCondensed" );
-                    break;
-                case OS2WindowsMetricsTable.WIDTH_CLASS_EXTRA_CONDENSED:
-                    fd.setFontStretch( "ExtraCondensed" );
-                    break;
-                case OS2WindowsMetricsTable.WIDTH_CLASS_CONDENSED:
-                    fd.setFontStretch( "Condensed" );
-                    break;
-                case OS2WindowsMetricsTable.WIDTH_CLASS_SEMI_CONDENSED:
-                    fd.setFontStretch( "SemiCondensed" );
-                    break;
-                case OS2WindowsMetricsTable.WIDTH_CLASS_MEDIUM:
-                    fd.setFontStretch( "Normal" );
-                    break;
-                case OS2WindowsMetricsTable.WIDTH_CLASS_SEMI_EXPANDED:
-                    fd.setFontStretch( "SemiExpanded" );
-                    break;
-                case OS2WindowsMetricsTable.WIDTH_CLASS_EXPANDED:
-                    fd.setFontStretch( "Expanded" );
-                    break;
-                case OS2WindowsMetricsTable.WIDTH_CLASS_EXTRA_EXPANDED:
-                    fd.setFontStretch( "ExtraExpanded" );
-                    break;
-                case OS2WindowsMetricsTable.WIDTH_CLASS_ULTRA_EXPANDED:
-                    fd.setFontStretch( "UltraExpanded" );
-                    break;
-                default:
-                    //do nothing
+            case OS2WindowsMetricsTable.WIDTH_CLASS_ULTRA_CONDENSED:
+                fd.setFontStretch("UltraCondensed");
+                break;
+            case OS2WindowsMetricsTable.WIDTH_CLASS_EXTRA_CONDENSED:
+                fd.setFontStretch("ExtraCondensed");
+                break;
+            case OS2WindowsMetricsTable.WIDTH_CLASS_CONDENSED:
+                fd.setFontStretch("Condensed");
+                break;
+            case OS2WindowsMetricsTable.WIDTH_CLASS_SEMI_CONDENSED:
+                fd.setFontStretch("SemiCondensed");
+                break;
+            case OS2WindowsMetricsTable.WIDTH_CLASS_MEDIUM:
+                fd.setFontStretch("Normal");
+                break;
+            case OS2WindowsMetricsTable.WIDTH_CLASS_SEMI_EXPANDED:
+                fd.setFontStretch("SemiExpanded");
+                break;
+            case OS2WindowsMetricsTable.WIDTH_CLASS_EXPANDED:
+                fd.setFontStretch("Expanded");
+                break;
+            case OS2WindowsMetricsTable.WIDTH_CLASS_EXTRA_EXPANDED:
+                fd.setFontStretch("ExtraExpanded");
+                break;
+            case OS2WindowsMetricsTable.WIDTH_CLASS_ULTRA_EXPANDED:
+                fd.setFontStretch("UltraExpanded");
+                break;
+            default:
+                // do nothing
             }
-            fd.setFontWeight( os2.getWeightClass() );
-            fd.setSymbolic( isSymbolic );
-            fd.setNonSymbolic( !isSymbolic );
+            fd.setFontWeight(os2.getWeightClass());
+            fd.setSymbolic(isSymbolic);
+            fd.setNonSymbolic(!isSymbolic);
 
-            //todo retval.setFixedPitch
-            //todo retval.setItalic
-            //todo retval.setAllCap
-            //todo retval.setSmallCap
-            //todo retval.setForceBold
+            // todo retval.setFixedPitch
+            // todo retval.setItalic
+            // todo retval.setAllCap
+            // todo retval.setSmallCap
+            // todo retval.setForceBold
 
             HeaderTable header = ttf.getHeader();
             PDRectangle rect = new PDRectangle();
-            float scaling = 1000f/header.getUnitsPerEm();
-            rect.setLowerLeftX( header.getXMin() * scaling );
-            rect.setLowerLeftY( header.getYMin() * scaling );
-            rect.setUpperRightX( header.getXMax() * scaling );
-            rect.setUpperRightY( header.getYMax() * scaling );
-            fd.setFontBoundingBox( rect );
+            float scaling = 1000f / header.getUnitsPerEm();
+            rect.setLowerLeftX(header.getXMin() * scaling);
+            rect.setLowerLeftY(header.getYMin() * scaling);
+            rect.setUpperRightX(header.getXMax() * scaling);
+            rect.setUpperRightY(header.getYMax() * scaling);
+            fd.setFontBoundingBox(rect);
 
             HorizontalHeaderTable hHeader = ttf.getHorizontalHeader();
-            fd.setAscent( hHeader.getAscender() * scaling );
-            fd.setDescent( hHeader.getDescender() * scaling );
+            fd.setAscent(hHeader.getAscender() * scaling);
+            fd.setDescent(hHeader.getDescender() * scaling);
 
             GlyphTable glyphTable = ttf.getGlyph();
             GlyphData[] glyphs = glyphTable.getGlyphs();
 
             PostScriptTable ps = ttf.getPostScript();
-            fd.setFixedPitch( ps.getIsFixedPitch() > 0 );
-            fd.setItalicAngle( ps.getItalicAngle() );
+            fd.setFixedPitch(ps.getIsFixedPitch() > 0);
+            fd.setItalicAngle(ps.getItalicAngle());
 
             String[] names = ps.getGlyphNames();
-            
-            if( names != null )
+
+            if (names != null)
             {
-                for( int i=0; i<names.length; i++ )
+                for (int i = 0; i < names.length; i++)
                 {
-                     //if we have a capital H then use that, otherwise use the
-                    //tallest letter
-                    if( names[i].equals( "H" ) )
+                    // if we have a capital H then use that, otherwise use the
+                    // tallest letter
+                    if (names[i].equals("H"))
                     {
-                        fd.setCapHeight( glyphs[i].getBoundingBox().getUpperRightY()/scaling );
+                        fd.setCapHeight(glyphs[i].getBoundingBox().getUpperRightY() / scaling);
                     }
-                    if( names[i].equals( "x" ) )
+                    if (names[i].equals("x"))
                     {
-                        fd.setXHeight( glyphs[i].getBoundingBox().getUpperRightY()/scaling );
+                        fd.setXHeight(glyphs[i].getBoundingBox().getUpperRightY() / scaling);
                     }
                 }
             }
 
-            //hmm there does not seem to be a clear definition for StemV,
-            //this is close enough and I am told it doesn't usually get used.
-            fd.setStemV( (fd.getFontBoundingBox().getWidth() * .13f) );
+            // hmm there does not seem to be a clear definition for StemV,
+            // this is close enough and I am told it doesn't usually get used.
+            fd.setStemV((fd.getFontBoundingBox().getWidth() * .13f));
 
             CMAPTable cmapTable = ttf.getCMAP();
             CMAPEncodingEntry[] cmaps = cmapTable.getCmaps();
             CMAPEncodingEntry uniMap = null;
-            
-            for( int i=0; i<cmaps.length; i++ )
+
+            for (int i = 0; i < cmaps.length; i++)
             {
-                if( cmaps[i].getPlatformId() == CMAPTable.PLATFORM_WINDOWS) 
+                if (cmaps[i].getPlatformId() == CMAPTable.PLATFORM_WINDOWS)
                 {
                     int platformEncoding = cmaps[i].getPlatformEncodingId();
-                    if ( CMAPTable.ENCODING_UNICODE == platformEncoding )
+                    if (CMAPTable.ENCODING_UNICODE == platformEncoding)
                     {
                         uniMap = cmaps[i];
                         break;
@@ -374,22 +346,22 @@ public class PDTrueTypeFont extends PDSimpleFont
             }
 
             Map<Integer, String> codeToName = this.getFontEncoding().getCodeToNameMap();
-             
+
             int firstChar = Collections.min(codeToName.keySet());
             int lastChar = Collections.max(codeToName.keySet());
-            
+
             HorizontalMetricsTable hMet = ttf.getHorizontalMetrics();
             int[] widthValues = hMet.getAdvanceWidth();
-            // some monospaced fonts provide only one value for the width 
-            // instead of an array containing the same value for every glyphid 
+            // some monospaced fonts provide only one value for the width
+            // instead of an array containing the same value for every glyphid
             boolean isMonospaced = widthValues.length == 1;
-            int nWidths=lastChar-firstChar+1;
+            int nWidths = lastChar - firstChar + 1;
             List<Float> widths = new ArrayList<Float>(nWidths);
             // width of the .notdef character.
-            Float zero = Float.valueOf(widthValues[0]*scaling);
-            for( int i=0; i<nWidths; i++ )
+            Float zero = Float.valueOf(widthValues[0] * scaling);
+            for (int i = 0; i < nWidths; i++)
             {
-                widths.add( zero );
+                widths.add(zero);
             }
             // Encoding singleton to have acces to the chglyph name to
             // unicode cpoint point mapping of Adobe's glyphlist.txt
@@ -400,32 +372,32 @@ public class PDTrueTypeFont extends PDSimpleFont
             // glyph ID.
             // For details, see PDFReference16.pdf, Section 5.5.5, p.401
             //
-            for (Entry<Integer, String> e : codeToName.entrySet()) 
+            for (Entry<Integer, String> e : codeToName.entrySet())
             {
                 String name = e.getValue();
                 // pdf code to unicode by glyph list.
                 String c = glyphlist.getCharacter(name);
                 int charCode = c.codePointAt(0);
                 int gid = uniMap.getGlyphId(charCode);
-                if (gid != 0) 
+                if (gid != 0)
                 {
                     if (isMonospaced)
                     {
-                        widths.set( e.getKey().intValue()-firstChar,widthValues[0]*scaling );
+                        widths.set(e.getKey().intValue() - firstChar, widthValues[0] * scaling);
                     }
                     else
                     {
-                        widths.set( e.getKey().intValue()-firstChar,widthValues[gid]*scaling );
+                        widths.set(e.getKey().intValue() - firstChar, widthValues[gid] * scaling);
                     }
                 }
             }
-            setWidths( widths );
-            setFirstChar( firstChar );
-            setLastChar( lastChar );
+            setWidths(widths);
+            setFirstChar(firstChar);
+            setLastChar(lastChar);
         }
         finally
         {
-            if( ttf != null )
+            if (ttf != null)
             {
                 ttf.close();
             }
@@ -437,148 +409,73 @@ public class PDTrueTypeFont extends PDSimpleFont
      */
     public Font getawtFont() throws IOException
     {
-         PDFontDescriptorDictionary fd = (PDFontDescriptorDictionary)getFontDescriptor();
-        if( awtFont == null )
-        {
-            PDStream ff2Stream = fd.getFontFile2();
-            if( ff2Stream != null )
-            {
-                try
-                {
-                    // create a font with the embedded data
-                    awtFont = Font.createFont( Font.TRUETYPE_FONT, ff2Stream.createInputStream() );
-                }
-                catch( FontFormatException f )
-                {
-                    try
-                    {
-                        // as a workaround we try to rebuild the embedded subsfont
-                        byte[] fontData = rebuildTTF(fd, ff2Stream.createInputStream());
-                        if (fontData != null)
-                        {
-                            ByteArrayInputStream bais = new ByteArrayInputStream(fontData);
-                            awtFont = Font.createFont( Font.TRUETYPE_FONT,bais);
-                        }
-                    } 
-                    catch (FontFormatException e)
-                    {
-                        log.info("Can't read the embedded font " + fd.getFontName() );
-                    }
-                }
-                if (awtFont == null)
-                {
-                    awtFont = FontManager.getAwtFont(fd.getFontName());
-                    if (awtFont != null)
-                    {
-                        log.info("Using font "+awtFont.getName()+ " instead");
-                    }
-                    setIsFontSubstituted(true);
-                }
-            }
-            else
-            {
-                // check if the font is part of our environment
-                awtFont = FontManager.getAwtFont(fd.getFontName());
-                if (awtFont == null)
-                {
-                    log.info("Can't find the specified font " + fd.getFontName() );
-                    // check if there is a font mapping for an external font file
-                    TrueTypeFont ttf = getExternalFontFile2( fd );
-                    if( ttf != null )
-                    {
-                        try
-                        {
-                            awtFont = Font.createFont( Font.TRUETYPE_FONT, ttf.getOriginalData() );
-                        }
-                        catch( FontFormatException f )
-                        {
-                            log.info("Can't read the external fontfile " + fd.getFontName() );
-                        }
-                    }
-                }
-            }
-            if (awtFont == null)
-            {
-                // we can't find anything, so we have to use the standard font
-                awtFont = FontManager.getStandardFont();
-                log.info("Using font "+awtFont.getName()+ " instead");
-                setIsFontSubstituted(true);
-            }
-        }
+        // TODO remove if no longer needed
+        // fallback if getTTFFont doesn't provides a suitable font
+        awtFont = FontManager.getStandardFont();
+        LOG.info("Using font " + awtFont.getName() + " instead");
+        setIsFontSubstituted(true);
         return awtFont;
     }
 
-    private byte[] rebuildTTF(PDFontDescriptorDictionary fd, InputStream inputStream) throws IOException
-    {
-        // this is one possible case of an incomplete subfont which leads to a font exception
-        if (getFontEncoding() instanceof WinAnsiEncoding)
-        {
-            TTFParser ttfParser = new TTFParser(true);
-            TrueTypeFont ttf = ttfParser.parseTTF(inputStream);
-            TTFSubFont ttfSub = new TTFSubFont(ttf, "PDFBox-Rebuild");
-            for (int i=getFirstChar();i<=getLastChar();i++)
-            {
-                ttfSub.addCharCode(i);
-            }
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            ttfSub.writeToStream(baos);
-            return baos.toByteArray();
-        }
-        return null;
-    }
-
-    private InputStream getExternalTTFData() throws IOException
-    {
-        String ttfResource = externalFonts.getProperty( UNKNOWN_FONT );
-        String baseFont = getBaseFont();
-        if( baseFont != null && externalFonts.containsKey(baseFont) )
-        {
-            ttfResource = externalFonts.getProperty( baseFont );
-        }
-        return (ttfResource != null ? ResourceLoader.loadResource(ttfResource) : null);
-    }
-
     /**
      * Permit to load an external TTF Font program file
-     *
-     * Created by Pascal Allain
-     * Vertical7 Inc.
-     *
-     * @param fd The font descriptor currently used
+     * 
+     * Created by Pascal Allain Vertical7 Inc.
+     * 
      * @return A PDStream with the Font File program, null if fd is null
      * @throws IOException If the font is not found
      */
-    private TrueTypeFont getExternalFontFile2(PDFontDescriptorDictionary fd)
-        throws IOException
+    private TrueTypeFont getExternalFontFile2() throws IOException
     {
         TrueTypeFont retval = null;
-
-        if ( fd != null )
+        String baseFont = getBaseFont();
+        String fontResource = externalFonts.getProperty(UNKNOWN_FONT);
+        if ((baseFont != null) && (externalFonts.containsKey(baseFont)))
         {
-            String baseFont = getBaseFont();
-            String fontResource = externalFonts.getProperty( UNKNOWN_FONT );
-            if( (baseFont != null) &&
-                 (externalFonts.containsKey(baseFont)) )
-            {
-                fontResource = externalFonts.getProperty(baseFont);
-            }
-            if( fontResource != null )
+            fontResource = externalFonts.getProperty(baseFont);
+        }
+        if (fontResource != null)
+        {
+            retval = (TrueTypeFont) loadedExternalFonts.get(baseFont);
+            if (retval == null)
             {
-                retval = (TrueTypeFont)loadedExternalFonts.get( baseFont );
-                if( retval == null )
+                TTFParser ttfParser = new TTFParser();
+                InputStream fontStream = ResourceLoader.loadResource(fontResource);
+                if (fontStream == null)
                 {
-                    TTFParser ttfParser = new TTFParser();
-                    InputStream fontStream = ResourceLoader.loadResource( fontResource );
-                    if( fontStream == null )
-                    {
-                        throw new IOException( "Error missing font resource '" + externalFonts.get(baseFont) + "'" );
-                    }
-                    retval = ttfParser.parseTTF( fontStream );
-                    loadedExternalFonts.put( baseFont, retval );
+                    throw new IOException("Error missing font resource '" + externalFonts.get(baseFont) + "'");
                 }
+                retval = ttfParser.parseTTF(fontStream);
+                loadedExternalFonts.put(baseFont, retval);
             }
         }
-
         return retval;
     }
+
+    /**
+     * Return the TTF font as TrueTypeFont.
+     * 
+     * @return the TTF font
+     * @throws IOException If there is an error loading the data
+     */
+    public TrueTypeFont getTTFFont() throws IOException
+    {
+        TrueTypeFont trueTypeFont = null;
+        PDFontDescriptorDictionary fd = (PDFontDescriptorDictionary) getFontDescriptor();
+        if (fd != null)
+        {
+            PDStream ff2Stream = fd.getFontFile2();
+            if (ff2Stream != null)
+            {
+                TTFParser ttfParser = new TTFParser(true);
+                trueTypeFont = ttfParser.parseTTF(ff2Stream.createInputStream());
+            }
+        }
+        if (trueTypeFont == null)
+        {
+            // check if there is a font mapping for an external font file
+            trueTypeFont = getExternalFontFile2();
+        }
+        return trueTypeFont;
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/util/PDFStreamEngine.java b/pdfbox/src/main/java/org/apache/pdfbox/util/PDFStreamEngine.java
index 9e9cb0f0ef..19bed14063 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/util/PDFStreamEngine.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/util/PDFStreamEngine.java
@@ -17,7 +17,6 @@
 package org.apache.pdfbox.util;
 
 import java.io.IOException;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Enumeration;
@@ -36,27 +35,23 @@ import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSObject;
 import org.apache.pdfbox.cos.COSStream;
 import org.apache.pdfbox.exceptions.WrappedIOException;
-
 import org.apache.pdfbox.pdfparser.PDFStreamParser;
 import org.apache.pdfbox.pdmodel.PDPage;
 import org.apache.pdfbox.pdmodel.PDResources;
-
 import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.pdmodel.font.PDFont;
 import org.apache.pdfbox.pdmodel.font.PDType3Font;
-
 import org.apache.pdfbox.pdmodel.graphics.PDExtendedGraphicsState;
 import org.apache.pdfbox.pdmodel.graphics.PDGraphicsState;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
 import org.apache.pdfbox.pdmodel.graphics.xobject.PDXObject;
-
 import org.apache.pdfbox.util.operator.OperatorProcessor;
 
 /**
- * This class will run through a PDF content stream and execute certain operations
- * and provide a callback interface for clients that want to do things with the stream.
- * See the PDFTextStripper class for an example of how to use this class.
- *
+ * This class will run through a PDF content stream and execute certain operations and provide a callback interface for
+ * clients that want to do things with the stream. See the PDFTextStripper class for an example of how to use this
+ * class.
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
  * @version $Revision: 1.38 $
  */
@@ -72,14 +67,14 @@ public class PDFStreamEngine
      * The PDF operators that are ignored by this engine.
      */
     private final Set<String> unsupportedOperators = new HashSet<String>();
-    
+
     private PDGraphicsState graphicsState = null;
 
     private Matrix textMatrix = null;
     private Matrix textLineMatrix = null;
     private Stack<PDGraphicsState> graphicsStack = new Stack<PDGraphicsState>();
 
-    private Map<String,OperatorProcessor> operators = new HashMap<String,OperatorProcessor>();
+    private Map<String, OperatorProcessor> operators = new HashMap<String, OperatorProcessor>();
 
     private Stack<PDResources> streamResourcesStack = new Stack<PDResources>();
 
@@ -98,51 +93,47 @@ public class PDFStreamEngine
      */
     public PDFStreamEngine()
     {
-        //default constructor
+        // default constructor
         validCharCnt = 0;
         totalCharCnt = 0;
-        
+
     }
 
     /**
-     * Constructor with engine properties.  The property keys are all
-     * PDF operators, the values are class names used to execute those
-     * operators. An empty value means that the operator will be silently
-     * ignored.
-     *
+     * Constructor with engine properties. The property keys are all PDF operators, the values are class names used to
+     * execute those operators. An empty value means that the operator will be silently ignored.
+     * 
      * @param properties The engine properties.
-     *
+     * 
      * @throws IOException If there is an error setting the engine properties.
      */
-    public PDFStreamEngine( Properties properties ) throws IOException
+    public PDFStreamEngine(Properties properties) throws IOException
     {
-        if( properties == null ) 
+        if (properties == null)
         {
-            throw new NullPointerException( "properties cannot be null" );
+            throw new NullPointerException("properties cannot be null");
         }
         Enumeration<?> names = properties.propertyNames();
-        for ( Object name : Collections.list( names ) )
+        for (Object name : Collections.list(names))
         {
             String operator = name.toString();
-            String processorClassName = properties.getProperty( operator );
-            if( "".equals( processorClassName ) )
+            String processorClassName = properties.getProperty(operator);
+            if ("".equals(processorClassName))
             {
-                unsupportedOperators.add( operator );
+                unsupportedOperators.add(operator);
             }
             else
             {
                 try
                 {
-                    Class<?> klass = Class.forName( processorClassName );
-                    OperatorProcessor processor =
-                        (OperatorProcessor) klass.newInstance();
-                    registerOperatorProcessor( operator, processor );
+                    Class<?> klass = Class.forName(processorClassName);
+                    OperatorProcessor processor = (OperatorProcessor) klass.newInstance();
+                    registerOperatorProcessor(operator, processor);
                 }
-                catch( Exception e )
+                catch (Exception e)
                 {
-                    throw new WrappedIOException(
-                            "OperatorProcessor class " + processorClassName
-                            + " could not be instantiated", e );
+                    throw new WrappedIOException("OperatorProcessor class " + processorClassName
+                            + " could not be instantiated", e);
                 }
             }
         }
@@ -155,7 +146,7 @@ public class PDFStreamEngine
      * 
      * @return true if force parsing is active
      */
-    public boolean isForceParsing() 
+    public boolean isForceParsing()
     {
         return forceParsing;
     }
@@ -165,29 +156,28 @@ public class PDFStreamEngine
      * 
      * @param forceParsingValue true activates force parsing
      */
-    public void setForceParsing(boolean forceParsingValue) 
+    public void setForceParsing(boolean forceParsingValue)
     {
         forceParsing = forceParsingValue;
     }
 
     /**
      * Register a custom operator processor with the engine.
-     *
+     * 
      * @param operator The operator as a string.
      * @param op Processor instance.
      */
-    public void registerOperatorProcessor( String operator, OperatorProcessor op )
+    public void registerOperatorProcessor(String operator, OperatorProcessor op)
     {
-        op.setContext( this );
-        operators.put( operator, op );
+        op.setContext(this);
+        operators.put(operator, op);
     }
 
     /**
-     * This method must be called between processing documents.  The
-     * PDFStreamEngine caches information for the document between pages
-     * and this will release the cached information.  This only needs
-     * to be called if processing a new document.
-     *
+     * This method must be called between processing documents. The PDFStreamEngine caches information for the document
+     * between pages and this will release the cached information. This only needs to be called if processing a new
+     * document.
+     * 
      */
     public void resetEngine()
     {
@@ -197,34 +187,34 @@ public class PDFStreamEngine
 
     /**
      * This will process the contents of the stream.
-     *
+     * 
      * @param aPage The page.
      * @param resources The location to retrieve resources.
      * @param cosStream the Stream to execute.
-     *
-     *
+     * 
+     * 
      * @throws IOException if there is an error accessing the stream.
      */
-    public void processStream( PDPage aPage, PDResources resources, COSStream cosStream ) throws IOException
+    public void processStream(PDPage aPage, PDResources resources, COSStream cosStream) throws IOException
     {
         graphicsState = new PDGraphicsState(aPage.findCropBox());
         textMatrix = null;
         textLineMatrix = null;
         graphicsStack.clear();
         streamResourcesStack.clear();
-        processSubStream( aPage, resources, cosStream );
+        processSubStream(aPage, resources, cosStream);
     }
 
     /**
      * Process a sub stream of the current stream.
-     *
+     * 
      * @param aPage The page used for drawing.
      * @param resources The resources used when processing the stream.
      * @param cosStream The stream to process.
-     *
+     * 
      * @throws IOException If there is an exception while processing the stream.
      */
-    public void processSubStream(PDPage aPage, PDResources resources, COSStream cosStream) throws IOException 
+    public void processSubStream(PDPage aPage, PDResources resources, COSStream cosStream) throws IOException
     {
         page = aPage;
         if (resources != null)
@@ -245,25 +235,25 @@ public class PDFStreamEngine
         }
     }
 
-    private void processSubStream(COSStream cosStream) throws IOException 
+    private void processSubStream(COSStream cosStream) throws IOException
     {
         List<COSBase> arguments = new ArrayList<COSBase>();
         PDFStreamParser parser = new PDFStreamParser(cosStream, forceParsing);
-        try 
+        try
         {
             Iterator<Object> iter = parser.getTokenIterator();
-            while (iter.hasNext()) 
+            while (iter.hasNext())
             {
                 Object next = iter.next();
-                if (LOG.isDebugEnabled()) 
+                if (LOG.isDebugEnabled())
                 {
                     LOG.debug("processing substream token: " + next);
                 }
-                if (next instanceof COSObject) 
+                if (next instanceof COSObject)
                 {
                     arguments.add(((COSObject) next).getObject());
                 }
-                else if (next instanceof PDFOperator) 
+                else if (next instanceof PDFOperator)
                 {
                     processOperator((PDFOperator) next, arguments);
                     arguments = new ArrayList<COSBase>();
@@ -280,99 +270,97 @@ public class PDFStreamEngine
         }
     }
 
-    
     /**
-     * A method provided as an event interface to allow a subclass to perform
-     * some specific functionality when text needs to be processed.
-     *
+     * A method provided as an event interface to allow a subclass to perform some specific functionality when text
+     * needs to be processed.
+     * 
      * @param text The text to be processed.
      */
-    protected void processTextPosition( TextPosition text )
+    protected void processTextPosition(TextPosition text)
     {
-        //subclasses can override to provide specific functionality.
+        // subclasses can override to provide specific functionality.
     }
 
     /**
-     * A method provided as an event interface to allow a subclass to perform
-     * some specific functionality on the string encoded by a glyph.
-     *
+     * A method provided as an event interface to allow a subclass to perform some specific functionality on the string
+     * encoded by a glyph.
+     * 
      * @param str The string to be processed.
      */
-    protected String inspectFontEncoding( String str )
+    protected String inspectFontEncoding(String str)
     {
         return str;
     }
 
     /**
-     * Process encoded text from the PDF Stream. 
-     * You should override this method if you want to perform an action when 
+     * Process encoded text from the PDF Stream. You should override this method if you want to perform an action when
      * encoded text is being processed.
-     *
+     * 
      * @param string The encoded text
-     *
+     * 
      * @throws IOException If there is an error processing the string
      */
-    public void processEncodedText( byte[] string ) throws IOException
+    public void processEncodedText(byte[] string) throws IOException
     {
-        /* Note on variable names.  There are three different units being used
-         * in this code.  Character sizes are given in glyph units, text locations
-         * are initially given in text units, and we want to save the data in 
-         * display units. The variable names should end with Text or Disp to 
-         * represent if the values are in text or disp units (no glyph units are saved).
+        /*
+         * Note on variable names. There are three different units being used in this code. Character sizes are given in
+         * glyph units, text locations are initially given in text units, and we want to save the data in display units.
+         * The variable names should end with Text or Disp to represent if the values are in text or disp units (no
+         * glyph units are saved).
          */
         final float fontSizeText = graphicsState.getTextState().getFontSize();
-        final float horizontalScalingText = graphicsState.getTextState().getHorizontalScalingPercent()/100f;
-        //float verticalScalingText = horizontalScaling;//not sure if this is right but what else to do???
+        final float horizontalScalingText = graphicsState.getTextState().getHorizontalScalingPercent() / 100f;
+        // float verticalScalingText = horizontalScaling;//not sure if this is right but what else to do???
         final float riseText = graphicsState.getTextState().getRise();
         final float wordSpacingText = graphicsState.getTextState().getWordSpacing();
         final float characterSpacingText = graphicsState.getTextState().getCharacterSpacing();
-        
-        //We won't know the actual number of characters until
-        //we process the byte data(could be two bytes each) but
-        //it won't ever be more than string.length*2(there are some cases
-        //were a single byte will result in two output characters "fi"
-        
+
+        // We won't know the actual number of characters until
+        // we process the byte data(could be two bytes each) but
+        // it won't ever be more than string.length*2(there are some cases
+        // were a single byte will result in two output characters "fi"
+
         final PDFont font = graphicsState.getTextState().getFont();
         // all fonts are providing the width/height of a character in thousandths of a unit of text space
-        float fontMatrixXScaling = 1/1000f;
-        float fontMatrixYScaling = 1/1000f;
-        float glyphSpaceToTextSpaceFactor = 1/1000f;
+        float fontMatrixXScaling = 1 / 1000f;
+        float fontMatrixYScaling = 1 / 1000f;
+        float glyphSpaceToTextSpaceFactor = 1 / 1000f;
         // expect Type3 fonts, those are providing the width of a character in glyph space units
         if (font instanceof PDType3Font)
         {
             PDMatrix fontMatrix = font.getFontMatrix();
             fontMatrixXScaling = fontMatrix.getValue(0, 0);
             fontMatrixYScaling = fontMatrix.getValue(1, 1);
-            //This will typically be 1000 but in the case of a type3 font
-            //this might be a different number
-            glyphSpaceToTextSpaceFactor = 1f/fontMatrix.getValue( 0, 0 );
+            // This will typically be 1000 but in the case of a type3 font
+            // this might be a different number
+            glyphSpaceToTextSpaceFactor = 1f / fontMatrix.getValue(0, 0);
         }
-        float spaceWidthText=0;
+        float spaceWidthText = 0;
         try
-        {   
+        {
             // to avoid crash as described in PDFBOX-614
             // lets see what the space displacement should be
-            spaceWidthText = (font.getSpaceWidth()*glyphSpaceToTextSpaceFactor);
+            spaceWidthText = (font.getSpaceWidth() * glyphSpaceToTextSpaceFactor);
         }
         catch (Throwable exception)
         {
-            LOG.warn( exception, exception);
+            LOG.warn(exception, exception);
         }
-        
-        if( spaceWidthText == 0 )
+
+        if (spaceWidthText == 0)
         {
-            spaceWidthText = (font.getAverageFontWidth()*glyphSpaceToTextSpaceFactor);
-            //The average space width appears to be higher than necessary
-            //so lets make it a little bit smaller.
+            spaceWidthText = (font.getAverageFontWidth() * glyphSpaceToTextSpaceFactor);
+            // The average space width appears to be higher than necessary
+            // so lets make it a little bit smaller.
             spaceWidthText *= .80f;
         }
-        
+
         float maxVerticalDisplacementText = 0;
 
         Matrix textStateParameters = new Matrix();
-        textStateParameters.setValue(0,0, fontSizeText*horizontalScalingText);
-        textStateParameters.setValue(1,1, fontSizeText);
-        textStateParameters.setValue(2,1, riseText);
+        textStateParameters.setValue(0, 0, fontSizeText * horizontalScalingText);
+        textStateParameters.setValue(1, 1, fontSizeText);
+        textStateParameters.setValue(2, 1, riseText);
 
         int pageRotation = page.findRotation();
         float pageHeight = page.findCropBox().getHeight();
@@ -385,37 +373,38 @@ public class PDFStreamEngine
         Matrix tempMatrix = new Matrix();
 
         int codeLength = 1;
-        for( int i=0; i<string.length; i+=codeLength)
+        for (int i = 0; i < string.length; i += codeLength)
         {
             // Decode the value to a Unicode character
             codeLength = 1;
-            String c = font.encode( string, i, codeLength );
+            String c = font.encode(string, i, codeLength);
             int[] codePoints = null;
-            if( c == null && i+1<string.length)
+            if (c == null && i + 1 < string.length)
             {
-                //maybe a multibyte encoding
+                // maybe a multibyte encoding
                 codeLength++;
-                c = font.encode( string, i, codeLength );
-                codePoints = new int[] {font.getCodeFromArray(string, i, codeLength)};
+                c = font.encode(string, i, codeLength);
+                codePoints = new int[] { font.getCodeFromArray(string, i, codeLength) };
+            }
+            else
+            {
+                codePoints = new int[] { font.getCodeFromArray(string, i, codeLength) };
             }
 
             // the space width has to be transformed into display units
-            float spaceWidthDisp = spaceWidthText * fontSizeText * horizontalScalingText 
-                                    * textMatrix.getValue(0, 0) * ctm.getValue(0, 0);
+            float spaceWidthDisp = spaceWidthText * fontSizeText * horizontalScalingText * textMatrix.getValue(0, 0)
+                    * ctm.getValue(0, 0);
 
-            //todo, handle horizontal displacement
-            // get the width and height of this character in text units 
-            float characterHorizontalDisplacementText = font.getFontWidth( string, i, codeLength );
-            float characterVerticalDisplacementText = font.getFontHeight( string, i, codeLength );
+            // todo, handle horizontal displacement
+            // get the width and height of this character in text units
+            float characterHorizontalDisplacementText = font.getFontWidth(string, i, codeLength);
+            float characterVerticalDisplacementText = font.getFontHeight(string, i, codeLength);
 
             // multiply the width/height with the scaling factor
             characterHorizontalDisplacementText = characterHorizontalDisplacementText * fontMatrixXScaling;
             characterVerticalDisplacementText = characterVerticalDisplacementText * fontMatrixYScaling;
 
-            maxVerticalDisplacementText = 
-                Math.max( 
-                    maxVerticalDisplacementText, 
-                    characterVerticalDisplacementText);
+            maxVerticalDisplacementText = Math.max(maxVerticalDisplacementText, characterVerticalDisplacementText);
 
             // PDF Spec - 5.5.2 Word Spacing
             //
@@ -423,20 +412,20 @@ public class PDFStreamEngine
             // only to the space character, code 32.
             //
             // Note: Word spacing is applied to every occurrence of the single-byte
-            // character code 32 in a string.  This can occur when using a simple
+            // character code 32 in a string. This can occur when using a simple
             // font or a composite font that defines code 32 as a single-byte code.
             // It does not apply to occurrences of the byte value 32 in multiple-byte
             // codes.
             //
             // RDD - My interpretation of this is that only character code 32's that
-            // encode to spaces should have word spacing applied.  Cases have been
+            // encode to spaces should have word spacing applied. Cases have been
             // observed where a font has a space character with a character code
-            // other than 32, and where word spacing (Tw) was used.  In these cases,
+            // other than 32, and where word spacing (Tw) was used. In these cases,
             // applying word spacing to either the non-32 space or to the character
             // code 32 non-space resulted in errors consistent with this interpretation.
             //
             float spacingText = 0;
-            if( (string[i] == 0x20) && codeLength == 1 )
+            if ((string[i] == 0x20) && codeLength == 1)
             {
                 spacingText += wordSpacingText;
             }
@@ -444,19 +433,19 @@ public class PDFStreamEngine
             // Convert textMatrix to display units
             // We need to instantiate a new Matrix instance here as it is passed to the TextPosition constructor below.
             Matrix textMatrixStart = textStateParameters.multiply(textXctm);
-            
+
             // TODO : tx should be set for horizontal text and ty for vertical text
             // which seems to be specified in the font (not the direction in the matrix).
-            float tx = ((characterHorizontalDisplacementText)*fontSizeText)*horizontalScalingText;
+            float tx = ((characterHorizontalDisplacementText) * fontSizeText) * horizontalScalingText;
             float ty = 0;
             // reset the matrix instead of creating a new one
             td.reset();
-            td.setValue( 2, 0, tx );
-            td.setValue( 2, 1, ty );
+            td.setValue(2, 0, tx);
+            td.setValue(2, 1, ty);
 
-            // The text matrix gets updated after each glyph is placed.  The updated
+            // The text matrix gets updated after each glyph is placed. The updated
             // version will have the X and Y coordinates for the next glyph.
-            // textMatrixEnd contains the coordinates of the end of the last glyph without 
+            // textMatrixEnd contains the coordinates of the end of the last glyph without
             // taking characterSpacingText and spacintText into account, otherwise it'll be
             // impossible to detect new words within text extraction
             tempMatrix = textStateParameters.multiply(td, tempMatrix);
@@ -465,24 +454,24 @@ public class PDFStreamEngine
             final float endYPosition = textMatrixEnd.getYPosition();
 
             // add some spacing to the text matrix (see comment above)
-            tx = ((characterHorizontalDisplacementText)*fontSizeText+characterSpacingText+spacingText)
-                    *horizontalScalingText;
-            td.setValue( 2, 0, tx );
-            textMatrix = td.multiply(textMatrix, textMatrix );
-            
+            tx = ((characterHorizontalDisplacementText) * fontSizeText + characterSpacingText + spacingText)
+                    * horizontalScalingText;
+            td.setValue(2, 0, tx);
+            textMatrix = td.multiply(textMatrix, textMatrix);
+
             // determine the width of this character
             // XXX: Note that if we handled vertical text, we should be using Y here
             float startXPosition = textMatrixStart.getXPosition();
             float widthText = endXPosition - startXPosition;
 
-            //there are several cases where one character code will
-            //output multiple characters.  For example "fi" or a
-            //glyphname that has no mapping like "visiblespace"
-            if( c != null )
+            // there are several cases where one character code will
+            // output multiple characters. For example "fi" or a
+            // glyphname that has no mapping like "visiblespace"
+            if (c != null)
             {
                 validCharCnt++;
             }
-            else 
+            else
             {
                 // PDFBOX-373: Replace a null entry with "?" so it is
                 // not printed as "(null)"
@@ -493,40 +482,26 @@ public class PDFStreamEngine
             float totalVerticalDisplacementDisp = maxVerticalDisplacementText * fontSizeText * textXctm.getYScale();
 
             // process the decoded text
-            processTextPosition(
-                    new TextPosition(
-                            pageRotation,
-                            pageWidth,
-                            pageHeight,
-                            textMatrixStart,
-                            endXPosition,
-                            endYPosition,
-                            totalVerticalDisplacementDisp,
-                            widthText,
-                            spaceWidthDisp,
-                            c,
-                            codePoints,
-                            font,
-                            fontSizeText,
-                            (int)(fontSizeText * textMatrix.getXScale())
-                            ));
+            processTextPosition(new TextPosition(pageRotation, pageWidth, pageHeight, textMatrixStart, endXPosition,
+                    endYPosition, totalVerticalDisplacementDisp, widthText, spaceWidthDisp, c, codePoints, font,
+                    fontSizeText, (int) (fontSizeText * textMatrix.getXScale())));
         }
     }
 
     /**
      * This is used to handle an operation.
-     *
+     * 
      * @param operation The operation to perform.
      * @param arguments The list of arguments.
-     *
+     * 
      * @throws IOException If there is an error processing the operation.
      */
-    public void processOperator( String operation, List<COSBase> arguments ) throws IOException
+    public void processOperator(String operation, List<COSBase> arguments) throws IOException
     {
         try
         {
-            PDFOperator oper = PDFOperator.getOperator( operation );
-            processOperator( oper, arguments );
+            PDFOperator oper = PDFOperator.getOperator(operation);
+            processOperator(oper, arguments);
         }
         catch (IOException e)
         {
@@ -536,26 +511,26 @@ public class PDFStreamEngine
 
     /**
      * This is used to handle an operation.
-     *
+     * 
      * @param operator The operation to perform.
      * @param arguments The list of arguments.
-     *
+     * 
      * @throws IOException If there is an error processing the operation.
      */
-    protected void processOperator( PDFOperator operator, List<COSBase> arguments ) throws IOException
+    protected void processOperator(PDFOperator operator, List<COSBase> arguments) throws IOException
     {
         try
         {
             String operation = operator.getOperation();
-            OperatorProcessor processor = (OperatorProcessor)operators.get( operation );
-            if( processor != null )
+            OperatorProcessor processor = (OperatorProcessor) operators.get(operation);
+            if (processor != null)
             {
                 processor.setContext(this);
-                processor.process( operator, arguments );
+                processor.process(operator, arguments);
             }
             else
             {
-                if (!unsupportedOperators.contains(operation)) 
+                if (!unsupportedOperators.contains(operation))
                 {
                     LOG.info("unsupported/disabled operation: " + operation);
                     unsupportedOperators.add(operation);
@@ -571,7 +546,7 @@ public class PDFStreamEngine
     /**
      * @return Returns the colorSpaces.
      */
-    public Map<String,PDColorSpace> getColorSpaces()
+    public Map<String, PDColorSpace> getColorSpaces()
     {
         return streamResourcesStack.peek().getColorSpaces();
     }
@@ -579,7 +554,7 @@ public class PDFStreamEngine
     /**
      * @return Returns the colorSpaces.
      */
-    public Map<String,PDXObject> getXObjects()
+    public Map<String, PDXObject> getXObjects()
     {
         return streamResourcesStack.peek().getXObjects();
     }
@@ -587,29 +562,32 @@ public class PDFStreamEngine
     /**
      * @param value The colorSpaces to set.
      */
-    public void setColorSpaces(Map<String,PDColorSpace> value)
+    public void setColorSpaces(Map<String, PDColorSpace> value)
     {
         streamResourcesStack.peek().setColorSpaces(value);
     }
+
     /**
      * @return Returns the fonts.
      */
-    public Map<String,PDFont> getFonts()
+    public Map<String, PDFont> getFonts()
     {
-        if ( streamResourcesStack.isEmpty() )
+        if (streamResourcesStack.isEmpty())
         {
             return Collections.emptyMap();
         }
-        
+
         return streamResourcesStack.peek().getFonts();
     }
+
     /**
      * @param value The fonts to set.
      */
-    public void setFonts(Map<String,PDFont> value)
+    public void setFonts(Map<String, PDFont> value)
     {
         streamResourcesStack.peek().setFonts(value);
     }
+
     /**
      * @return Returns the graphicsStack.
      */
@@ -617,6 +595,7 @@ public class PDFStreamEngine
     {
         return graphicsStack;
     }
+
     /**
      * @param value The graphicsStack to set.
      */
@@ -624,6 +603,7 @@ public class PDFStreamEngine
     {
         graphicsStack = value;
     }
+
     /**
      * @return Returns the graphicsState.
      */
@@ -631,6 +611,7 @@ public class PDFStreamEngine
     {
         return graphicsState;
     }
+
     /**
      * @param value The graphicsState to set.
      */
@@ -638,20 +619,23 @@ public class PDFStreamEngine
     {
         graphicsState = value;
     }
+
     /**
      * @return Returns the graphicsStates.
      */
-    public Map<String,PDExtendedGraphicsState> getGraphicsStates()
+    public Map<String, PDExtendedGraphicsState> getGraphicsStates()
     {
         return streamResourcesStack.peek().getGraphicsStates();
     }
+
     /**
      * @param value The graphicsStates to set.
      */
-    public void setGraphicsStates(Map<String,PDExtendedGraphicsState> value)
+    public void setGraphicsStates(Map<String, PDExtendedGraphicsState> value)
     {
         streamResourcesStack.peek().setGraphicsStates(value);
     }
+
     /**
      * @return Returns the textLineMatrix.
      */
@@ -659,6 +643,7 @@ public class PDFStreamEngine
     {
         return textLineMatrix;
     }
+
     /**
      * @param value The textLineMatrix to set.
      */
@@ -666,6 +651,7 @@ public class PDFStreamEngine
     {
         textLineMatrix = value;
     }
+
     /**
      * @return Returns the textMatrix.
      */
@@ -673,6 +659,7 @@ public class PDFStreamEngine
     {
         return textMatrix;
     }
+
     /**
      * @param value The textMatrix to set.
      */
@@ -680,6 +667,7 @@ public class PDFStreamEngine
     {
         textMatrix = value;
     }
+
     /**
      * @return Returns the resources.
      */
@@ -690,18 +678,18 @@ public class PDFStreamEngine
 
     /**
      * Get the current page that is being processed.
-     *
+     * 
      * @return The page being processed.
      */
     public PDPage getCurrentPage()
     {
         return page;
     }
-    
-    /** 
-     * Get the total number of valid characters in the doc 
-     * that could be decoded in processEncodedText(). 
-     * @return The number of valid characters. 
+
+    /**
+     * Get the total number of valid characters in the doc that could be decoded in processEncodedText().
+     * 
+     * @return The number of valid characters.
      */
     public int getValidCharCnt()
     {
@@ -709,13 +697,13 @@ public class PDFStreamEngine
     }
 
     /**
-     * Get the total number of characters in the doc
-     * (including ones that could not be mapped).  
-     * @return The number of characters. 
+     * Get the total number of characters in the doc (including ones that could not be mapped).
+     * 
+     * @return The number of characters.
      */
     public int getTotalCharCnt()
     {
         return totalCharCnt;
     }
-    
+
 }
