diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDPattern.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDPattern.java
index 8cc527f7d5..159b7baca1 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDPattern.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDPattern.java
@@ -23,20 +23,9 @@ import org.apache.pdfbox.pdmodel.graphics.pattern.PDAbstractPattern;
 import org.apache.pdfbox.pdmodel.graphics.pattern.PDShadingPattern;
 import org.apache.pdfbox.pdmodel.graphics.pattern.PDTilingPattern;
 import org.apache.pdfbox.pdmodel.graphics.pattern.TilingPaint;
-import org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingPaint;
 import org.apache.pdfbox.pdmodel.graphics.shading.PDShading;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType1;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType2;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType3;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType4;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType5;
-import org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingPaint;
-import org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingPaint;
-import org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint;
-import org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingPaint;
 import org.apache.pdfbox.rendering.PDFRenderer;
 
-import java.awt.Color;
 import java.awt.Paint;
 import java.awt.image.BufferedImage;
 
@@ -46,7 +35,6 @@ import java.util.Map;
 
 /**
  * A Pattern color space is either a Tiling pattern or a Shading pattern.
- *
  * @author John Hewson
  * @author Ben Litchfield
  */
@@ -127,57 +115,23 @@ public final class PDPattern extends PDSpecialColorSpace
         PDAbstractPattern pattern = patterns.get(color.getPatternName());
         if (pattern instanceof PDTilingPattern)
         {
-            return toTilingPaint(renderer, (PDTilingPattern)pattern, color);
-        }
-        else
-        {
-            return toShadingPaint((PDShadingPattern)pattern, pageHeight);
-        }
-    }
-
-    private Paint toTilingPaint(PDFRenderer renderer, PDTilingPattern tilingPattern, PDColor color)
-            throws IOException
-    {
-        if (tilingPattern.getPaintType() == PDTilingPattern.PAINT_COLORED)
-        {
-            // colored tiling pattern
-            return new TilingPaint(renderer, tilingPattern);
+            PDTilingPattern tilingPattern = (PDTilingPattern)pattern;
+            if (tilingPattern.getPaintType() == PDTilingPattern.PAINT_COLORED)
+            {
+                // colored tiling pattern
+                return new TilingPaint(renderer, tilingPattern);
+            }
+            else
+            {
+                // uncolored tiling pattern
+                return new TilingPaint(renderer, tilingPattern, underlyingColorSpace, color);
+            }
         }
         else
         {
-            // uncolored tiling pattern
-            return new TilingPaint(renderer, tilingPattern, underlyingColorSpace, color);
-        }
-    }
-
-    private Paint toShadingPaint(PDShadingPattern shadingPattern, int pageHeight) throws IOException
-    {
-        PDShading shadingResources = shadingPattern.getShading();
-        int shadingType = shadingResources != null ? shadingResources.getShadingType() : 0;
-        switch (shadingType)
-        {
-            case PDShading.SHADING_TYPE1:
-                return new Type1ShadingPaint((PDShadingType1)shadingResources,
-                                             shadingPattern.getMatrix(), pageHeight);
-            case PDShading.SHADING_TYPE2:
-                return new AxialShadingPaint((PDShadingType2)shadingResources,
-                                             shadingPattern.getMatrix(), pageHeight);
-            case PDShading.SHADING_TYPE3:
-                return new RadialShadingPaint((PDShadingType3)shadingResources,
-                                              shadingPattern.getMatrix(), pageHeight);
-            case PDShading.SHADING_TYPE4:
-                return new Type4ShadingPaint((PDShadingType4)shadingResources,
-                                             shadingPattern.getMatrix(), pageHeight);
-            case PDShading.SHADING_TYPE5:
-                return new Type5ShadingPaint((PDShadingType5)shadingResources,
-                                             shadingPattern.getMatrix(), pageHeight);
-            case PDShading.SHADING_TYPE6:
-            case PDShading.SHADING_TYPE7:
-                // TODO ...
-                LOG.debug("Not implemented, shading type: " + shadingType);
-                return new Color(0, 0, 0, 0); // transparent
-            default:
-                throw new IOException("Invalid shading type: " + shadingType);
+            PDShadingPattern shadingPattern = (PDShadingPattern)pattern;
+            PDShading shading = shadingPattern.getShading();
+            return shading.toPaint(shadingPattern.getMatrix(), pageHeight);
         }
     }
 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java
index 00d246a6f1..1f01826c72 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java
@@ -20,7 +20,6 @@ import java.awt.PaintContext;
 import java.awt.Transparency;
 import java.awt.color.ColorSpace;
 import java.awt.geom.AffineTransform;
-import java.awt.geom.NoninvertibleTransformException;
 import java.awt.image.ColorModel;
 import java.awt.image.ComponentColorModel;
 import java.awt.image.DataBuffer;
@@ -32,22 +31,19 @@ import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBoolean;
-import org.apache.pdfbox.pdmodel.common.function.PDFunction;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
-import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceN;
-import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceRGB;
-import org.apache.pdfbox.pdmodel.graphics.color.PDSeparation;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This class represents the PaintContext of an axial shading.
- * 
+ * AWT PaintContext for axial shading.
  */
-public class AxialShadingContext implements PaintContext 
+class AxialShadingContext implements PaintContext
 {
+    private static final Log LOG = LogFactory.getLog(AxialShadingContext.class);
+
     private ColorModel outputColorModel;
     private PDColorSpace shadingColorSpace;
-    private PDShadingType2 shadingType;
+    private PDShadingType2 shading;
 
     private float[] coords;
     private float[] domain;
@@ -57,27 +53,20 @@ public class AxialShadingContext implements PaintContext
     private double y1y0;
     private float d1d0;
     private double denom;
-    
-    /**
-     * Log instance.
-     */
-    private static final Log LOG = LogFactory.getLog(AxialShadingContext.class);
 
     /**
      * Constructor creates an instance to be used for fill operations.
-     * 
-     * @param shadingType2 the shading type to be used
-     * @param colorModelValue the color model to be used
+     * @param shading the shading type to be used
+     * @param cm the color model to be used
      * @param xform transformation for user to device space
      * @param ctm the transformation matrix
      * @param pageHeight height of the current page
-     * 
      */
-    public AxialShadingContext(PDShadingType2 shadingType2, ColorModel colorModelValue, 
-            AffineTransform xform, Matrix ctm, int pageHeight) throws IOException
+    public AxialShadingContext(PDShadingType2 shading, ColorModel cm, AffineTransform xform,
+                               Matrix ctm, int pageHeight) throws IOException
     {
-        shadingType = shadingType2;
-        coords = shadingType.getCoords().toFloatArray();
+        this.shading = shading;
+        coords = this.shading.getCoords().toFloatArray();
 
         if (ctm != null)
         {
@@ -86,15 +75,15 @@ public class AxialShadingContext implements PaintContext
         }
         xform.transform(coords, 0, coords, 0, 2);
         // get the shading colorSpace
-        shadingColorSpace = shadingType.getColorSpace();
+        shadingColorSpace = this.shading.getColorSpace();
         // create the output colormodel using RGB+alpha as colorspace
         ColorSpace outputCS = ColorSpace.getInstance(ColorSpace.CS_sRGB);
         outputColorModel = new ComponentColorModel(outputCS, true, false, Transparency.TRANSLUCENT,
                 DataBuffer.TYPE_BYTE);
         // domain values
-        if (shadingType.getDomain() != null)
+        if (this.shading.getDomain() != null)
         {
-            domain = shadingType.getDomain().toFloatArray();
+            domain = this.shading.getDomain().toFloatArray();
         }
         else
         {
@@ -102,8 +91,8 @@ public class AxialShadingContext implements PaintContext
             domain = new float[] { 0, 1 };
         }
         // extend values
-        COSArray extendValues = shadingType.getExtend();
-        if (shadingType.getExtend() != null)
+        COSArray extendValues = this.shading.getExtend();
+        if (this.shading.getExtend() != null)
         {
             extend = new boolean[2];
             extend[0] = ((COSBoolean) extendValues.get(0)).getValue();
@@ -121,38 +110,33 @@ public class AxialShadingContext implements PaintContext
         denom = Math.pow(x1x0, 2) + Math.pow(y1y0, 2);
 
         // get background values if available
-        COSArray bg = shadingType2.getBackground();
+        COSArray bg = shading.getBackground();
         if (bg != null)
         {
             background = bg.toFloatArray();
         }
     }
-    /**
-     * {@inheritDoc}
-     */
+
+    @Override
     public void dispose() 
     {
         outputColorModel = null;
         shadingColorSpace = null;
-        shadingType = null;
+        shading = null;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public ColorModel getColorModel() 
     {
         return outputColorModel;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public Raster getRaster(int x, int y, int w, int h) 
     {
         // create writable raster
         WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);
-        boolean useBackground = false;
+        boolean useBackground;
         int[] data = new int[w * h * 4];
         for (int j = 0; j < h; j++)
         {
@@ -229,7 +213,7 @@ public class AxialShadingContext implements PaintContext
                     try
                     {
                         float input = (float) (domain[0] + (d1d0 * inputValue));
-                        values = shadingType.evalFunction(input);
+                        values = shading.evalFunction(input);
                     }
                     catch (IOException exception)
                     {
@@ -257,7 +241,6 @@ public class AxialShadingContext implements PaintContext
 
     /**
      * Returns the coords values.
-     * 
      * @return the coords values as array
      */
     public float[] getCoords() 
@@ -267,7 +250,6 @@ public class AxialShadingContext implements PaintContext
         
     /**
      * Returns the domain values.
-     * 
      * @return the domain values as array
      */
     public float[] getDomain() 
@@ -277,7 +259,6 @@ public class AxialShadingContext implements PaintContext
         
     /**
      * Returns the extend values.
-     * 
      * @return the extend values as array
      */
     public boolean[] getExtend() 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingPaint.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingPaint.java
index 024df883a9..3f1579e321 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingPaint.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingPaint.java
@@ -30,11 +30,10 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This represents the Paint of an axial shading.
- * 
- * @author lehmi
+ * AWT Paint for axial shading.
+ * @author Andreas Lehmkhler
  */
-public class AxialShadingPaint implements Paint
+class AxialShadingPaint implements Paint
 {
     private static final Log LOG = LogFactory.getLog(AxialShadingPaint.class);
 
@@ -44,7 +43,6 @@ public class AxialShadingPaint implements Paint
     
     /**
      * Constructor.
-     * 
      * @param shadingType2 the shading resources
      * @param ctm current transformation matrix
      * @param pageHeight size of the current page
@@ -55,19 +53,17 @@ public class AxialShadingPaint implements Paint
         this.ctm = ctm;
         this.pageHeight = pageHeight;
     }
-    /**
-     * {@inheritDoc}
-     */
+
+    @Override
     public int getTransparency() 
     {
         return 0;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public PaintContext createContext(ColorModel cm, Rectangle deviceBounds,
-            Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
+                                      Rectangle2D userBounds, AffineTransform xform,
+                                      RenderingHints hints)
     {
         try
         {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/GouraudShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/GouraudShadingContext.java
index 7af85e7014..6a4395e1cf 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/GouraudShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/GouraudShadingContext.java
@@ -38,67 +38,57 @@ import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- *
- * Helper class that Type4ShadingContext and Type5ShadingContext must extend;
- * does the shading of Gouraud triangles.
- *
- * @author lehmi
+ * Shades Gouraud triangles for  Type4ShadingContext and Type5ShadingContext.
+ * @author Andreas Lehmkhler
  * @author Tilman Hausherr
- *
  */
-public abstract class GouraudShadingContext implements PaintContext
+abstract class GouraudShadingContext implements PaintContext
 {
     private static final Log LOG = LogFactory.getLog(GouraudShadingContext.class);
 
     private ColorModel outputColorModel;
     private PDColorSpace shadingColorSpace;
-    /**
-     * number of color components.
-     */
+
+    /** number of color components. */
     protected int numberOfColorComponents;
-    /**
-     * triangle list.
-     */
+
+    /** triangle list. */
     protected ArrayList<GouraudTriangle> triangleList;
-    /**
-     * bits per coordinate.
-     */
+
+    /** bits per coordinate. */
     protected int bitsPerCoordinate;
-    /**
-     * bits per color component.
-     */
+
+    /** bits per color component. */
     protected int bitsPerColorComponent;
-    /**
-     * background values.
-     */
+
+    /** background values.*/
     protected float[] background;
+
     private final boolean hasFunction;
     private final PDShading gouraudShadingType;
 
     /**
      * Constructor creates an instance to be used for fill operations.
-     *
-     * @param shadingType the shading type to be used
-     * @param colorModelValue the color model to be used
+     * @param shading the shading type to be used
+     * @param colorModel the color model to be used
      * @param xform transformation for user to device space
      * @param ctm current transformation matrix
      * @param pageHeight height of the current page
      * @throws IOException if something went wrong
-     *
      */
-    protected GouraudShadingContext(PDShading shadingType, ColorModel colorModelValue,
-            AffineTransform xform, Matrix ctm, int pageHeight) throws IOException
+    protected GouraudShadingContext(PDShading shading, ColorModel colorModel, AffineTransform xform,
+                                    Matrix ctm, int pageHeight) throws IOException
     {
-        gouraudShadingType = shadingType;
+        gouraudShadingType = shading;
         triangleList = new ArrayList<GouraudTriangle>();
-        hasFunction = shadingType.getFunction() != null;
+        hasFunction = shading.getFunction() != null;
 
-        shadingColorSpace = shadingType.getColorSpace();
+        shadingColorSpace = shading.getColorSpace();
         LOG.debug("colorSpace: " + shadingColorSpace);
         numberOfColorComponents = shadingColorSpace.getNumberOfComponents();
 
-        LOG.debug("BBox: " + shadingType.getBBox());
-        LOG.debug("Background: " + shadingType.getBackground());
+        LOG.debug("BBox: " + shading.getBBox());
+        LOG.debug("Background: " + shading.getBackground());
 
         // create the output color model using RGB+alpha as color space
         ColorSpace outputCS = ColorSpace.getInstance(ColorSpace.CS_sRGB);
@@ -107,9 +97,7 @@ public abstract class GouraudShadingContext implements PaintContext
     }
 
     /**
-     * Read a vertex from the bit input stream and do the interpolations
-     * described in the PDF specification.
-     *
+     * Read a vertex from the bit input stream performs interpolations.
      * @param input bit input stream
      * @param flag the flag or any value if not relevant
      * @param maxSrcCoord max value for source coordinate (2^bits-1)
@@ -117,13 +105,11 @@ public abstract class GouraudShadingContext implements PaintContext
      * @param rangeX dest range for X
      * @param rangeY dest range for Y
      * @param colRangeTab dest range array for colors
-     *
      * @return a new vertex with the flag and the interpolated values
-     *
      * @throws IOException if something went wrong
      */
     protected Vertex readVertex(ImageInputStream input, byte flag, long maxSrcCoord, long maxSrcColor,
-            PDRange rangeX, PDRange rangeY, PDRange[] colRangeTab) throws IOException
+                                PDRange rangeX, PDRange rangeY, PDRange[] colRangeTab) throws IOException
     {
         float[] colorComponentTab = new float[numberOfColorComponents];
         long x = input.readBits(bitsPerCoordinate);
@@ -142,9 +128,7 @@ public abstract class GouraudShadingContext implements PaintContext
     }
 
     /**
-     * transform a list of vertices from shading to user space (if applicable)
-     * and from user to device space.
-     *
+     * Transforms vertices from shading to user space (if applicable) and from user to device space.
      * @param vertexList list of vertices
      * @param xform transformation for user to device space
      * @param ctm current transformation matrix
@@ -176,9 +160,7 @@ public abstract class GouraudShadingContext implements PaintContext
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public void dispose()
     {
         triangleList = null;
@@ -186,9 +168,7 @@ public abstract class GouraudShadingContext implements PaintContext
         shadingColorSpace = null;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public final ColorModel getColorModel()
     {
         return outputColorModel;
@@ -196,7 +176,6 @@ public abstract class GouraudShadingContext implements PaintContext
 
     /**
      * Calculate the interpolation, see p.345 pdf spec 1.7.
-     *
      * @param src src value
      * @param srcMax max src value (2^bits-1)
      * @param dstMin min dst value
@@ -208,9 +187,7 @@ public abstract class GouraudShadingContext implements PaintContext
         return dstMin + (src * (dstMax - dstMin) / srcMax);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public final Raster getRaster(int x, int y, int w, int h)
     {
         WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/GouraudTriangle.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/GouraudTriangle.java
index 8840ec4322..78f59ae50f 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/GouraudTriangle.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/GouraudTriangle.java
@@ -20,40 +20,30 @@ package org.apache.pdfbox.pdmodel.graphics.shading;
 import java.awt.geom.Point2D;
 
 /**
- * Helper class to deal with Gouraud triangles for type 4 and 5 shading.
- *
+ * A Gouraud triangle, used in Type 4 and Type 5 shadings.
  * @author Tilman Hausherr
  */
-public class GouraudTriangle
+class GouraudTriangle
 {
-    /**
-     * point A of the triangle.
-     */
+    /** point A of the triangle. */
     protected final Point2D pointA;
-    /**
-     * point B of the triangle.
-     */
+
+    /** point B of the triangle. */
     protected final Point2D pointB;
-    /**
-     * point C of the triangle.
-     */
+
+    /** point C of the triangle. */
     protected final Point2D pointC;
-    /**
-     * the color of point A.
-     */
+
+    /** the color of point A. */
     protected final float[] colorA;
-    /**
-     * the color of point B.
-     */
+
+    /** the color of point B. */
     protected final float[] colorB;
-    /**
-     * the color of point C.
-     */
+
+    /** the color of point C. */
     protected final float[] colorC;
 
-    /*
-     * intermediate constants
-     */
+    // intermediate constants
     private final double xBminusA;
     private final double yBminusA;
     private final double xCminusA;
@@ -64,7 +54,6 @@ public class GouraudTriangle
 
     /**
      * Constructor for using 3 points and their colors.
-     *
      * @param a point A of the triangle
      * @param aColor color of point A
      * @param b point B of the triangle
@@ -93,9 +82,7 @@ public class GouraudTriangle
 
     /**
      * Check whether the point is within the triangle.
-     *
      * @param p Point
-     *
      * @return true if yes, false if no
      */
     public boolean contains(Point2D p)
@@ -125,10 +112,7 @@ public class GouraudTriangle
         return true;
     }
 
-    /**
-     * Get the area of a triangle.
-     *
-     */
+    // returns the area of a triangle
     private double getArea(Point2D a, Point2D b, Point2D c)
     {
         // inspiration: http://stackoverflow.com/a/2145584/535646
@@ -139,19 +123,16 @@ public class GouraudTriangle
 
     /**
      * Tell whether a triangle is empty.
-     * 
-     * @return true if the area is empty, false if not.
+     * @return true if the area is empty, false if not
      */
-    boolean isEmpty()
+    public boolean isEmpty()
     {
         return area == 0;
     }
 
     /**
      * calculate color weights with barycentric interpolation.
-     *
-     * @param p Point within triangle
-     *
+     * @param p point within triangle
      * @return array of weights (between 0 and 1) for a b c
      */
     public double[] getWeights(Point2D p)
@@ -159,9 +140,9 @@ public class GouraudTriangle
         // http://classes.soe.ucsc.edu/cmps160/Fall10/resources/barycentricInterpolation.pdf
         return new double[]
         {
-            getArea(pointB, pointC, p) / area, getArea(pointA, pointC, p)
-            / area, getArea(pointA, pointB, p) / area
+            getArea(pointB, pointC, p) / area,
+            getArea(pointA, pointC, p) / area,
+            getArea(pointA, pointB, p) / area
         };
     }
-
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShading.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShading.java
index 868f95a11f..b5e2af5519 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShading.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShading.java
@@ -16,6 +16,7 @@
  */
 package org.apache.pdfbox.pdmodel.graphics.shading;
 
+import java.awt.Paint;
 import java.io.IOException;
 
 import org.apache.pdfbox.cos.COSArray;
@@ -26,10 +27,10 @@ import org.apache.pdfbox.pdmodel.common.COSObjectable;
 import org.apache.pdfbox.pdmodel.common.PDRectangle;
 import org.apache.pdfbox.pdmodel.common.function.PDFunction;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
+import org.apache.pdfbox.util.Matrix;
 
 /**
- * This represents resources for a shading.
- *
+ * A Shading Resource.
  * @author Andreas Lehmkhler
  */
 public abstract class PDShading implements COSObjectable
@@ -41,33 +42,25 @@ public abstract class PDShading implements COSObjectable
     private PDFunction function = null;
     private PDFunction[] functionArray = null;
     
-    /**
-     * shading type 1 = function based shading.
-     */
+    /** shading type 1 = function based shading. */
     public static final int SHADING_TYPE1 = 1;
-    /**
-     * shading type 2 = axial shading.
-     */
+
+    /** shading type 2 = axial shading. */
     public static final int SHADING_TYPE2 = 2;
-    /**
-     * shading type 3 = radial shading.
-     */
+
+    /** shading type 3 = radial shading. */
     public static final int SHADING_TYPE3 = 3;
-    /**
-     * shading type 4 = Free-Form Gouraud-Shaded Triangle Meshes.
-     */
+
+    /** shading type 4 = Free-Form Gouraud-Shaded Triangle Meshes. */
     public static final int SHADING_TYPE4 = 4;
-    /**
-     * shading type 5 = Lattice-Form Gouraud-Shaded Triangle Meshes.
-     */
+
+    /** shading type 5 = Lattice-Form Gouraud-Shaded Triangle Meshes. */
     public static final int SHADING_TYPE5 = 5;
-    /**
-     * shading type 6 = Coons Patch Meshes.
-     */
+
+    /** shading type 6 = Coons Patch Meshes. */
     public static final int SHADING_TYPE6 = 6;
-    /**
-     * shading type 7 = Tensor-Product Patch Meshes.
-     */
+
+    /** shading type 7 = Tensor-Product Patch Meshes. */
     public static final int SHADING_TYPE7 = 7;
     
     /**
@@ -80,8 +73,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * Constructor using the given shading dictionary.
-     *
-     * @param shadingDictionary The dictionary for this shading.
+     * @param shadingDictionary the dictionary for this shading
      */
     public PDShading(COSDictionary shadingDictionary)
     {
@@ -90,8 +82,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will get the underlying dictionary.
-     *
-     * @return The dictionary for this shading.
+     * @return the dictionary for this shading
      */
     public COSDictionary getCOSDictionary()
     {
@@ -100,8 +91,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * Convert this standard java object to a COS object.
-     *
-     * @return The cos object that matches this Java object.
+     * @return the cos object that matches this Java object
      */
     public COSBase getCOSObject()
     {
@@ -110,8 +100,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will return the type.
-     *
-     * @return The type of object that this is.
+     * @return the type of object that this is
      */
     public String getType()
     {
@@ -120,8 +109,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will set the shading type.
-     *
-     * @param shadingType The new shading type.
+     * @param shadingType the new shading type
      */
     public void setShadingType(int shadingType)
     {
@@ -130,15 +118,13 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will return the shading type.
-     *
-     * @return The shading type
+     * @return the shading typ
      */
     public abstract int getShadingType();
 
     /**
      * This will set the background.
-     *
-     * @param newBackground The new background.
+     * @param newBackground the new background
      */
     public void setBackground(COSArray newBackground)
     {
@@ -148,8 +134,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will return the background.
-     *
-     * @return The background
+     * @return the background
      */
     public COSArray getBackground()
     {
@@ -161,11 +146,10 @@ public abstract class PDShading implements COSObjectable
     }
 
     /**
-     * An array of four numbers in the form coordinate system (see
-     * below), giving the coordinates of the left, bottom, right, and top edges,
-     * respectively, of the shadings's bounding box.
-     *
-     * @return The BBox of the form.
+     * An array of four numbers in the form coordinate system (see below),
+     * giving the coordinates of the left, bottom, right, and top edges, respectively,
+     * of the shading's bounding box.
+     * @return the BBox of the form
      */
     public PDRectangle getBBox()
     {
@@ -182,8 +166,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will set the BBox (bounding box) for this Shading.
-     *
-     * @param newBBox The new BBox.
+     * @param newBBox the new BBox
      */
     public void setBBox(PDRectangle newBBox)
     {
@@ -200,8 +183,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will set the AntiAlias value.
-     *
-     * @param antiAlias The new AntiAlias value.
+     * @param antiAlias the new AntiAlias value
      */
     public void setAntiAlias(boolean antiAlias)
     {
@@ -210,8 +192,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will return the AntiAlias value.
-     *
-     * @return The AntiAlias value
+     * @return the AntiAlias value
      */
     public boolean getAntiAlias()
     {
@@ -220,10 +201,8 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will get the color space or null if none exists.
-     *
-     * @return The color space for the shading.
-     *
-     * @throws IOException If there is an error getting the color space.
+     * @return the color space for the shading
+     * @throws IOException if there is an error getting the color space
      */
     public PDColorSpace getColorSpace() throws IOException
     {
@@ -237,8 +216,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will set the color space for the shading.
-     *
-     * @param colorSpace The color space
+     * @param colorSpace the color space
      */
     public void setColorSpace( PDColorSpace colorSpace )
     {
@@ -255,12 +233,9 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * Create the correct PD Model shading based on the COS base shading.
-     * 
      * @param resourceDictionary the COS shading dictionary
-     * 
      * @return the newly created shading resources object
-     * 
-     * @throws IOException If we are unable to create the PDShading object.
+     * @throws IOException if we are unable to create the PDShading object
      */
     public static PDShading create(COSDictionary resourceDictionary) throws IOException
     {
@@ -297,8 +272,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will set the function for the color conversion.
-     *
-     * @param newFunction The new function.
+     * @param newFunction the new function
      */
     public void setFunction(PDFunction newFunction)
     {
@@ -316,8 +290,7 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will set the functions COSArray for the color conversion.
-     *
-     * @param newFunctions The new COSArray containing all functions.
+     * @param newFunctions the new COSArray containing all functions
      */
     public void setFunction(COSArray newFunctions)
     {
@@ -335,9 +308,8 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * This will return the function used to convert the color values.
-     *
-     * @return The function
-     * @exception IOException If we are unable to create the PDFunction object.
+     * @return the function
+     * @exception IOException if we are unable to create the PDFunction object
      */
     public PDFunction getFunction() throws IOException
     {
@@ -352,9 +324,8 @@ public abstract class PDShading implements COSObjectable
 
     /**
      * Provide the function(s) of the shading dictionary as array.
-     * 
      * @return an array containing the function(s) 
-     * @throws IOException throw if something went wrong
+     * @throws IOException if something went wrong
      */
     private PDFunction[] getFunctionsArray() throws IOException
     {
@@ -382,7 +353,6 @@ public abstract class PDShading implements COSObjectable
     
     /**
      * Convert the input value using the functions of the shading dictionary.
-     *
      * @param inputValue the input value
      * @return the output values
      * @throws IOException thrown if something went wrong
@@ -394,7 +364,6 @@ public abstract class PDShading implements COSObjectable
     
     /**
      * Convert the input values using the functions of the shading dictionary.
-     * 
      * @param input the input values
      * @return the output values
      * @throws IOException thrown if something went wrong
@@ -419,4 +388,12 @@ public abstract class PDShading implements COSObjectable
         }
         return returnValues;
     }
+
+    /**
+     * Returns an AWT paint which corresponds to this shading
+     * @param matrix the pattern matrix
+     * @param pageHeight the height of the current page
+     * @return an AWT Paint instance
+     */
+    public abstract Paint toPaint(Matrix matrix, int pageHeight);
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType1.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType1.java
index 87645dace0..e64be5c2ff 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType1.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType1.java
@@ -16,6 +16,7 @@
  */
 package org.apache.pdfbox.pdmodel.graphics.shading;
 
+import java.awt.Paint;
 import java.awt.geom.AffineTransform;
 
 import org.apache.pdfbox.cos.COSArray;
@@ -26,27 +27,22 @@ import org.apache.pdfbox.cos.COSNumber;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This represents resources for a function based shading.
- *
+ * Resources for a function based shading.
  */
 public class PDShadingType1 extends PDShading
 {
-
     private COSArray domain = null;
 
     /**
      * Constructor using the given shading dictionary.
-     *
-     * @param shadingDictionary The dictionary for this shading.
+     * @param shadingDictionary the dictionary for this shading
      */
     public PDShadingType1(COSDictionary shadingDictionary)
     {
         super(shadingDictionary);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public int getShadingType()
     {
         return PDShading.SHADING_TYPE1;
@@ -54,29 +50,27 @@ public class PDShadingType1 extends PDShading
 
     /**
      * This will get the optional Matrix of a function based shading.
-     *
      * @return the matrix
      */
     public Matrix getMatrix()
     {
-        Matrix retval = null;
+        Matrix matrix = null;
         COSArray array = (COSArray) getCOSDictionary().getDictionaryObject(COSName.MATRIX);
         if (array != null)
         {
-            retval = new Matrix();
-            retval.setValue(0, 0, ((COSNumber) array.get(0)).floatValue());
-            retval.setValue(0, 1, ((COSNumber) array.get(1)).floatValue());
-            retval.setValue(1, 0, ((COSNumber) array.get(2)).floatValue());
-            retval.setValue(1, 1, ((COSNumber) array.get(3)).floatValue());
-            retval.setValue(2, 0, ((COSNumber) array.get(4)).floatValue());
-            retval.setValue(2, 1, ((COSNumber) array.get(5)).floatValue());
+            matrix = new Matrix();
+            matrix.setValue(0, 0, ((COSNumber) array.get(0)).floatValue());
+            matrix.setValue(0, 1, ((COSNumber) array.get(1)).floatValue());
+            matrix.setValue(1, 0, ((COSNumber) array.get(2)).floatValue());
+            matrix.setValue(1, 1, ((COSNumber) array.get(3)).floatValue());
+            matrix.setValue(2, 0, ((COSNumber) array.get(4)).floatValue());
+            matrix.setValue(2, 1, ((COSNumber) array.get(5)).floatValue());
         }
-        return retval;
+        return matrix;
     }
 
     /**
      * Sets the optional Matrix entry for the function based shading.
-     *
      * @param transform the transformation matrix
      */
     public void setMatrix(AffineTransform transform)
@@ -93,7 +87,6 @@ public class PDShadingType1 extends PDShading
 
     /**
      * This will get the optional Domain values of a function based shading.
-     *
      * @return the domain values
      */
     public COSArray getDomain()
@@ -107,7 +100,6 @@ public class PDShadingType1 extends PDShading
 
     /**
      * Sets the optional Domain entry for the function based shading.
-     *
      * @param newDomain the domain array
      */
     public void setDomain(COSArray newDomain)
@@ -115,4 +107,10 @@ public class PDShadingType1 extends PDShading
         domain = newDomain;
         getCOSDictionary().setItem(COSName.DOMAIN, newDomain);
     }
+
+    @Override
+    public Paint toPaint(Matrix matrix, int pageHeight)
+    {
+        return new Type1ShadingPaint(this, matrix, pageHeight);
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType2.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType2.java
index 5493e0088e..1a85d7ddb5 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType2.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType2.java
@@ -19,11 +19,12 @@ package org.apache.pdfbox.pdmodel.graphics.shading;
 import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
+import org.apache.pdfbox.util.Matrix;
+
+import java.awt.Paint;
 
 /**
- * This represents resources for an axial shading.
- *
- * @version $Revision: 1.0 $
+ * Resources for an axial shading.
  */
 public class PDShadingType2 extends PDShading
 {
@@ -33,17 +34,14 @@ public class PDShadingType2 extends PDShading
 
     /**
      * Constructor using the given shading dictionary.
-     *
-     * @param shadingDictionary The dictionary for this shading.
+     * @param shadingDictionary the dictionary for this shading
      */
     public PDShadingType2(COSDictionary shadingDictionary)
     {
         super(shadingDictionary);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public int getShadingType()
     {
         return PDShading.SHADING_TYPE2;
@@ -51,7 +49,6 @@ public class PDShadingType2 extends PDShading
 
     /**
      * This will get the optional Extend values for this shading.
-     *
      * @return the extend values
      */
     public COSArray getExtend()
@@ -65,7 +62,6 @@ public class PDShadingType2 extends PDShading
 
     /**
      * Sets the optional Extend entry for this shading.
-     *
      * @param newExtend the extend array
      */
     public void setExtend(COSArray newExtend)
@@ -83,7 +79,6 @@ public class PDShadingType2 extends PDShading
 
     /**
      * This will get the optional Domain values for this shading.
-     *
      * @return the domain values
      */
     public COSArray getDomain()
@@ -97,7 +92,6 @@ public class PDShadingType2 extends PDShading
 
     /**
      * Sets the optional Domain entry for this shading.
-     *
      * @param newDomain the domain array
      */
     public void setDomain(COSArray newDomain)
@@ -115,8 +109,7 @@ public class PDShadingType2 extends PDShading
 
     /**
      * This will get the Coords values for this shading.
-     *
-     * @return the coords values
+     * @return the coordinate values
      */
     public COSArray getCoords()
     {
@@ -129,8 +122,7 @@ public class PDShadingType2 extends PDShading
 
     /**
      * Sets the Coords entry for this shading.
-     *
-     * @param newCoords the coords array
+     * @param newCoords the coordinates array
      */
     public void setCoords(COSArray newCoords)
     {
@@ -144,4 +136,10 @@ public class PDShadingType2 extends PDShading
             getCOSDictionary().setItem(COSName.COORDS, newCoords);
         }
     }
+
+    @Override
+    public Paint toPaint(Matrix matrix, int pageHeight)
+    {
+        return new AxialShadingPaint(this, matrix, pageHeight);
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType3.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType3.java
index f879c7d7c8..77156a12d2 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType3.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType3.java
@@ -17,29 +17,33 @@
 package org.apache.pdfbox.pdmodel.graphics.shading;
 
 import org.apache.pdfbox.cos.COSDictionary;
+import org.apache.pdfbox.util.Matrix;
+
+import java.awt.Paint;
 
 /**
- * This represents resources for a radial shading.
- *
- * @version $Revision: 1.0 $
+ * Resources for a radial shading.
  */
 public class PDShadingType3 extends PDShadingType2
 {
     /**
      * Constructor using the given shading dictionary.
-     *
-     * @param shadingDictionary The dictionary for this shading.
+     * @param shadingDictionary the dictionary for this shading
      */
     public PDShadingType3(COSDictionary shadingDictionary)
     {
         super(shadingDictionary);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public int getShadingType()
     {
         return PDShading.SHADING_TYPE3;
     }
+
+    @Override
+    public Paint toPaint(Matrix matrix, int pageHeight)
+    {
+        return new RadialShadingPaint(this, matrix, pageHeight);
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType4.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType4.java
index 7881533d80..439f7d075b 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType4.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType4.java
@@ -20,45 +20,38 @@ import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.pdmodel.common.PDRange;
+import org.apache.pdfbox.util.Matrix;
+
+import java.awt.Paint;
 
 /**
- * This represents resources for a shading type 4 (Free-Form Gouraud-Shaded
- * Triangle Meshes).
- *
+ * Resources for a shading type 4 (Free-Form Gouraud-Shaded Triangle Mesh).
  */
 public class PDShadingType4 extends PDShading
 {
-
-    /**
-     * An array of 2^n numbers specifying the linear mapping of sample values
-     * into the range appropriate for the function's output values. Default
-     * value: same as the value of Range
-     */
+    // an array of 2^n numbers specifying the linear mapping of sample values
+    // into the range appropriate for the function's output values. Default
+    // value: same as the value of Range
     private COSArray decode = null;
 
     /**
      * Constructor using the given shading dictionary.
-     *
-     * @param shadingDictionary The dictionary for this shading.
+     * @param shadingDictionary the dictionary for this shading
      */
     public PDShadingType4(COSDictionary shadingDictionary)
     {
         super(shadingDictionary);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public int getShadingType()
     {
         return PDShading.SHADING_TYPE4;
     }
 
     /**
-     * The bits per component of this shading. This will return -1 if one has
-     * not been set.
-     *
-     * @return The number of bits per component.
+     * The bits per component of this shading. This will return -1 if one has not been set.
+     * @return the number of bits per component
      */
     public int getBitsPerComponent()
     {
@@ -67,19 +60,16 @@ public class PDShadingType4 extends PDShading
 
     /**
      * Set the number of bits per component.
-     *
-     * @param bpc The number of bits per component.
+     * @param bitsPerComponent the number of bits per component
      */
-    public void setBitsPerComponent(int bpc)
+    public void setBitsPerComponent(int bitsPerComponent)
     {
-        getCOSDictionary().setInt(COSName.BITS_PER_COMPONENT, bpc);
+        getCOSDictionary().setInt(COSName.BITS_PER_COMPONENT, bitsPerComponent);
     }
 
     /**
-     * The bits per coordinate of this shading. This will return -1 if one has
-     * not been set.
-     *
-     * @return The number of bits per coordinate.
+     * The bits per coordinate of this shading. This will return -1 if one has not been set.
+     * @return the number of bits per coordinate
      */
     public int getBitsPerCoordinate()
     {
@@ -88,18 +78,15 @@ public class PDShadingType4 extends PDShading
 
     /**
      * Set the number of bits per coordinate.
-     *
-     * @param bpc The number of bits per coordinate.
+     * @param bitsPerComponent the number of bits per coordinate
      */
-    public void setBitsPerCoordinate(int bpc)
+    public void setBitsPerCoordinate(int bitsPerComponent)
     {
-        getCOSDictionary().setInt(COSName.BITS_PER_COORDINATE, bpc);
+        getCOSDictionary().setInt(COSName.BITS_PER_COORDINATE, bitsPerComponent);
     }
 
     /**
-     * The bits per flag of this shading. This will return -1 if one has not
-     * been set.
-     *
+     * The bits per flag of this shading. This will return -1 if one has not been set.
      * @return The number of bits per flag.
      */
     public int getBitsPerFlag()
@@ -109,18 +96,16 @@ public class PDShadingType4 extends PDShading
 
     /**
      * Set the number of bits per flag.
-     *
-     * @param bpf The number of bits per flag.
+     * @param bitsPerFlag the number of bits per flag
      */
-    public void setBitsPerFlag(int bpf)
+    public void setBitsPerFlag(int bitsPerFlag)
     {
-        getCOSDictionary().setInt(COSName.BITS_PER_FLAG, bpf);
+        getCOSDictionary().setInt(COSName.BITS_PER_FLAG, bitsPerFlag);
     }
 
     /**
      * Returns all decode values as COSArray.
-     *
-     * @return the decode array.
+     * @return the decode array
      */
     private COSArray getDecodeValues()
     {
@@ -133,8 +118,7 @@ public class PDShadingType4 extends PDShading
 
     /**
      * This will set the decode values.
-     *
-     * @param decodeValues The new decode values.
+     * @param decodeValues the new decode values
      */
     public void setDecodeValues(COSArray decodeValues)
     {
@@ -144,10 +128,8 @@ public class PDShadingType4 extends PDShading
 
     /**
      * Get the decode for the input parameter.
-     *
-     * @param paramNum The function parameter number.
-     *
-     * @return The decode parameter range or null if none is set.
+     * @param paramNum the function parameter number
+     * @return the decode parameter range or null if none is set
      */
     public PDRange getDecodeForParameter(int paramNum)
     {
@@ -160,4 +142,9 @@ public class PDShadingType4 extends PDShading
         return retval;
     }
 
+    @Override
+    public Paint toPaint(Matrix matrix, int pageHeight)
+    {
+        return new Type4ShadingPaint(this, matrix, pageHeight);
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType5.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType5.java
index 859ef19e4e..9cb360f5c2 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType5.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType5.java
@@ -20,45 +20,39 @@ import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.pdmodel.common.PDRange;
+import org.apache.pdfbox.util.Matrix;
+
+import java.awt.Paint;
+import java.io.IOException;
 
 /**
- * This represents resources for a shading type 5 (Lattice-Form Gouraud-Shaded
- * Triangle Meshes).
- *
+ * Resources for a shading type 5 (Lattice-Form Gouraud-Shade Triangle Mesh).
  */
 public class PDShadingType5 extends PDShading
 {
-
-    /**
-     * An array of 2^n numbers specifying the linear mapping of sample values
-     * into the range appropriate for the function's output values. Default
-     * value: same as the value of Range
-     */
+    // an array of 2^n numbers specifying the linear mapping of sample values
+    // into the range appropriate for the function's output values. Default
+    // value: same as the value of Range
     private COSArray decode = null;
 
     /**
      * Constructor using the given shading dictionary.
-     *
-     * @param shadingDictionary The dictionary for this shading.
+     * @param shadingDictionary the dictionary for this shading
      */
     public PDShadingType5(COSDictionary shadingDictionary)
     {
         super(shadingDictionary);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public int getShadingType()
     {
         return PDShading.SHADING_TYPE5;
     }
 
     /**
-     * The bits per component of this shading. This will return -1 if one has
-     * not been set.
-     *
-     * @return The number of bits per component.
+     * The bits per component of this shading. This will return -1 if one has not been set.
+     * @return the number of bits per component
      */
     public int getBitsPerComponent()
     {
@@ -67,19 +61,16 @@ public class PDShadingType5 extends PDShading
 
     /**
      * Set the number of bits per component.
-     *
-     * @param bpc The number of bits per component.
+     * @param bitsPerComponent the number of bits per component
      */
-    public void setBitsPerComponent(int bpc)
+    public void setBitsPerComponent(int bitsPerComponent)
     {
-        getCOSDictionary().setInt(COSName.BITS_PER_COMPONENT, bpc);
+        getCOSDictionary().setInt(COSName.BITS_PER_COMPONENT, bitsPerComponent);
     }
 
     /**
-     * The bits per coordinate of this shading. This will return -1 if one has
-     * not been set.
-     *
-     * @return The number of bits per coordinate.
+     * The bits per coordinate of this shading. This will return -1 if one has not been set.
+     * @return the number of bits per coordinate
      */
     public int getBitsPerCoordinate()
     {
@@ -88,19 +79,16 @@ public class PDShadingType5 extends PDShading
 
     /**
      * Set the number of bits per coordinate.
-     *
-     * @param bpc The number of bits per coordinate.
+     * @param bitsPerComponent the number of bits per coordinate
      */
-    public void setBitsPerCoordinate(int bpc)
+    public void setBitsPerCoordinate(int bitsPerComponent)
     {
-        getCOSDictionary().setInt(COSName.BITS_PER_COORDINATE, bpc);
+        getCOSDictionary().setInt(COSName.BITS_PER_COORDINATE, bitsPerComponent);
     }
 
     /**
-     * The vertices per row of this shading. This will return -1 if one has not
-     * been set.
-     *
-     * @return The number of vertices per row.
+     * The vertices per row of this shading. This will return -1 if one has not been set.
+     * @return the number of vertices per row
      */
     public int getVerticesPerRow()
     {
@@ -109,17 +97,15 @@ public class PDShadingType5 extends PDShading
 
     /**
      * Set the number of vertices per row.
-     *
-     * @param vpr The number of vertices per row.
+     * @param verticesPerRow the number of vertices per row
      */
-    public void setVerticesPerRow(int vpr)
+    public void setVerticesPerRow(int verticesPerRow)
     {
-        getCOSDictionary().setInt(COSName.VERTICES_PER_ROW, vpr);
+        getCOSDictionary().setInt(COSName.VERTICES_PER_ROW, verticesPerRow);
     }
 
     /**
      * Returns all decode values as COSArray.
-     *
      * @return the decode array.
      */
     private COSArray getDecodeValues()
@@ -133,7 +119,6 @@ public class PDShadingType5 extends PDShading
 
     /**
      * This will set the decode values.
-     *
      * @param decodeValues The new decode values.
      */
     public void setDecodeValues(COSArray decodeValues)
@@ -144,9 +129,7 @@ public class PDShadingType5 extends PDShading
 
     /**
      * Get the decode for the input parameter.
-     *
      * @param paramNum The function parameter number.
-     *
      * @return The decode parameter range or null if none is set.
      */
     public PDRange getDecodeForParameter(int paramNum)
@@ -159,4 +142,10 @@ public class PDShadingType5 extends PDShading
         }
         return retval;
     }
+
+    @Override
+    public Paint toPaint(Matrix matrix, int pageHeight)
+    {
+        return new Type5ShadingPaint(this, matrix, pageHeight);
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType6.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType6.java
index d86e962c0c..de5eab4889 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType6.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType6.java
@@ -16,30 +16,41 @@
  */
 package org.apache.pdfbox.pdmodel.graphics.shading;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.cos.COSDictionary;
+import org.apache.pdfbox.util.Matrix;
+
+import java.awt.Color;
+import java.awt.Paint;
 
 /**
- * This represents resources for a shading type 6 (Coons Patch Meshes).
- *
- * @version $Revision: 1.0 $
+ * Resources for a shading type 6 (Coons Patch Mesh).
  */
 public class PDShadingType6 extends PDShadingType4
 {
+    private static final Log LOG = LogFactory.getLog(PDShadingType6.class);
+
     /**
      * Constructor using the given shading dictionary.
-     *
-     * @param shadingDictionary The dictionary for this shading.
+     * @param shadingDictionary the dictionary for this shading
      */
     public PDShadingType6(COSDictionary shadingDictionary)
     {
         super(shadingDictionary);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public int getShadingType()
     {
         return PDShading.SHADING_TYPE6;
     }
+
+    @Override
+    public Paint toPaint(Matrix matrix, int pageHeight)
+    {
+        // TODO ...
+        LOG.debug("Type 6 Shading not implemented");
+        return new Color(0, 0, 0, 0); // transparent
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType7.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType7.java
index aead3f4d8a..d3134d3584 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType7.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType7.java
@@ -16,30 +16,41 @@
  */
 package org.apache.pdfbox.pdmodel.graphics.shading;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.cos.COSDictionary;
+import org.apache.pdfbox.util.Matrix;
+
+import java.awt.Color;
+import java.awt.Paint;
 
 /**
- * This represents resources for a shading type 7 (Tensor-Product Patch Meshes).
- *
- * @version $Revision: 1.0 $
+ * Resources for a shading type 7 (Tensor-Product Patch Mesh).
  */
 public class PDShadingType7 extends PDShadingType4
 {
+    private static final Log LOG = LogFactory.getLog(PDShadingType7.class);
+
     /**
      * Constructor using the given shading dictionary.
-     *
-     * @param shadingDictionary The dictionary for this shading.
+     * @param shadingDictionary the dictionary for this shading
      */
     public PDShadingType7(COSDictionary shadingDictionary)
     {
         super(shadingDictionary);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public int getShadingType()
     {
         return PDShading.SHADING_TYPE6;
     }
+
+    @Override
+    public Paint toPaint(Matrix matrix, int pageHeight)
+    {
+        // TODO ...
+        LOG.debug("Type 7 Shading not implemented");
+        return new Color(0, 0, 0, 0); // transparent
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
index c62540455e..9526fc5c93 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
@@ -35,14 +35,15 @@ import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This class represents the PaintContext of an radial shading.
- * 
+ * AWT PaintContext for radial shading.
  */
-public class RadialShadingContext implements PaintContext 
+class RadialShadingContext implements PaintContext
 {
+    private static final Log LOG = LogFactory.getLog(RadialShadingContext.class);
+
     private ColorModel outputColorModel;
     private PDColorSpace shadingColorSpace;
-    private PDShadingType3 shadingType;
+    private PDShadingType3 shading;
 
     private float[] coords;
     private float[] domain;
@@ -57,27 +58,20 @@ public class RadialShadingContext implements PaintContext
 
     private float d1d0;
     private double denom;
-    
-    /**
-     * Log instance.
-     */
-    private static final Log LOG = LogFactory.getLog(RadialShadingContext.class);
 
     /**
      * Constructor creates an instance to be used for fill operations.
-     * 
-     * @param shadingType3 the shading type to be used
-     * @param colorModelValue the color model to be used
+     * @param shading the shading type to be used
+     * @param cm the color model to be used
      * @param xform transformation for user to device space
      * @param ctm the transformation matrix
      * @param pageHeight height of the current page
-     * 
      */
-    public RadialShadingContext(PDShadingType3 shadingType3, ColorModel colorModelValue, 
-            AffineTransform xform, Matrix ctm, int pageHeight) throws IOException
+    public RadialShadingContext(PDShadingType3 shading, ColorModel cm, AffineTransform xform,
+                                Matrix ctm, int pageHeight) throws IOException
     {
-        shadingType = shadingType3;
-        coords = shadingType.getCoords().toFloatArray();
+        this.shading = shading;
+        coords = this.shading.getCoords().toFloatArray();
 
         if (ctm != null)
         {
@@ -96,15 +90,15 @@ public class RadialShadingContext implements PaintContext
         coords[5] *= xform.getScaleX();
 
         // get the shading colorSpace
-        shadingColorSpace = shadingType.getColorSpace();
+        shadingColorSpace = this.shading.getColorSpace();
         // create the output colormodel using RGB+alpha as colorspace
         ColorSpace outputCS = ColorSpace.getInstance(ColorSpace.CS_sRGB);
         outputColorModel = new ComponentColorModel(outputCS, true, false, Transparency.TRANSLUCENT,
                 DataBuffer.TYPE_BYTE);
         // domain values
-        if (shadingType.getDomain() != null)
+        if (this.shading.getDomain() != null)
         {
-            domain = shadingType.getDomain().toFloatArray();
+            domain = this.shading.getDomain().toFloatArray();
         }
         else
         {
@@ -112,8 +106,8 @@ public class RadialShadingContext implements PaintContext
             domain = new float[] { 0, 1 };
         }
         // extend values
-        COSArray extendValues = shadingType.getExtend();
-        if (shadingType.getExtend() != null)
+        COSArray extendValues = this.shading.getExtend();
+        if (this.shading.getExtend() != null)
         {
             extend = new boolean[2];
             extend[0] = ((COSBoolean) extendValues.get(0)).getValue();
@@ -135,33 +129,28 @@ public class RadialShadingContext implements PaintContext
         d1d0 = domain[1] - domain[0];
 
         // get background values if available
-        COSArray bg = shadingType3.getBackground();
+        COSArray bg = shading.getBackground();
         if (bg != null)
         {
             background = bg.toFloatArray();
         }
     }
-    /**
-     * {@inheritDoc}
-     */
+
+    @Override
     public void dispose() 
     {
         outputColorModel = null;
-        shadingType = null;
+        shading = null;
         shadingColorSpace = null;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public ColorModel getColorModel() 
     {
         return outputColorModel;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    @Override
     public Raster getRaster(int x, int y, int w, int h) 
     {
         // create writable raster
@@ -287,7 +276,7 @@ public class RadialShadingContext implements PaintContext
                     try
                     {
                         float input = (float) (domain[0] + (d1d0 * inputValue));
-                        values = shadingType.evalFunction(input);
+                        values = shading.evalFunction(input);
                     }
                     catch (IOException exception)
                     {
@@ -315,24 +304,22 @@ public class RadialShadingContext implements PaintContext
 
     private float[] calculateInputValues(int x, int y)
     {
-
-        /**
-         * According to Adobes Technical Note #5600 we have to do the following
-         * 
-         * x0, y0, r0 defines the start circle x1, y1, r1 defines the end circle
-         * 
-         * The parametric equations for the center and radius of the gradient fill circle moving between the start
-         * circle and the end circle as a function of s are as follows:
-         * 
-         * xc(s) = x0 + s * (x1 - x0) yc(s) = y0 + s * (y1 - y0) r(s) = r0 + s * (r1 - r0)
-         * 
-         * Given a geometric coordinate position (x, y) in or along the gradient fill, the corresponding value of s can
-         * be determined by solving the quadratic constraint equation:
-         * 
-         * [x - xc(s)]2 + [y - yc(s)]2 = [r(s)]2
-         * 
-         * The following code calculates the 2 possible values of s
-         */
+        // According to Adobes Technical Note #5600 we have to do the following
+        //
+        // x0, y0, r0 defines the start circle x1, y1, r1 defines the end circle
+        //
+        // The parametric equations for the center and radius of the gradient fill circle moving
+        // between the start circle and the end circle as a function of s are as follows:
+        //
+        // xc(s) = x0 + s * (x1 - x0) yc(s) = y0 + s * (y1 - y0) r(s) = r0 + s * (r1 - r0)
+        //
+        // Given a geometric coordinate position (x, y) in or along the gradient fill, the
+        // corresponding value of s can be determined by solving the quadratic constraint equation:
+        //
+        // [x - xc(s)]2 + [y - yc(s)]2 = [r(s)]2
+        //
+        // The following code calculates the 2 possible values of s
+        //
         double p = -(x - coords[0]) * x1x0 - (y - coords[1]) * y1y0 - coords[2] * r1r0;
         double q = (Math.pow(x - coords[0], 2) + Math.pow(y - coords[1], 2) - r0pow2);
         double root = Math.sqrt(p * p - denom * q);
@@ -350,7 +337,6 @@ public class RadialShadingContext implements PaintContext
 
     /**
      * Returns the coords values.
-     * 
      * @return the coords values as array
      */
     public float[] getCoords() 
@@ -360,7 +346,6 @@ public class RadialShadingContext implements PaintContext
         
     /**
      * Returns the domain values.
-     * 
      * @return the domain values as array
      */
     public float[] getDomain() 
@@ -370,7 +355,6 @@ public class RadialShadingContext implements PaintContext
         
     /**
      * Returns the extend values.
-     * 
      * @return the extend values as array
      */
     public boolean[] getExtend() 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingPaint.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingPaint.java
index 735a105c4f..e95222a1b9 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingPaint.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingPaint.java
@@ -30,11 +30,10 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This represents the Paint of an radial shading.
- * 
- * @author lehmi
+ * AWT Paint for radial shading.
+ * @author Andreas Lehmkhler
  */
-public class RadialShadingPaint implements Paint 
+class RadialShadingPaint implements Paint
 {
     private static final Log LOG = LogFactory.getLog(RadialShadingPaint.class);
 
@@ -44,30 +43,26 @@ public class RadialShadingPaint implements Paint
     
     /**
      * Constructor.
-     * 
-     * @param shadingType3 the shading resources
+     * @param shading the shading resources
      * @param ctm current transformation matrix
      * @param pageHeight size of the current page
      */
-    public RadialShadingPaint(PDShadingType3 shadingType3, Matrix ctm, int pageHeight)
+    public RadialShadingPaint(PDShadingType3 shading, Matrix ctm, int pageHeight)
     {
-        shading = shadingType3;
+        this.shading = shading;
         this.ctm = ctm;
         this.pageHeight = pageHeight;
     }
-    /**
-     * {@inheritDoc}
-     */
+
+    @Override
     public int getTransparency() 
     {
         return 0;
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    public PaintContext createContext(ColorModel cm, Rectangle deviceBounds,
-            Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
+    @Override
+    public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds,
+                                      AffineTransform xform, RenderingHints hints)
     {
         try
         {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type1ShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type1ShadingContext.java
index 19ba8b7b3c..07b3e52b1f 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type1ShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type1ShadingContext.java
@@ -29,18 +29,13 @@ import java.io.IOException;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.cos.COSArray;
-import org.apache.pdfbox.pdmodel.common.function.PDFunction;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
-import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceN;
-import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceRGB;
-import org.apache.pdfbox.pdmodel.graphics.color.PDSeparation;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This represents the Paint of a type 1 (Function based) shading context.
- *
- * @author lehmi
- * @author Tilman Hausherr <tilman@snafu.de>
+ * AWT PaintContext for function-based (Type 1) shading.
+ * @author Andreas Lehmkhler
+ * @author Tilman Hausherr
  */
 class Type1ShadingContext implements PaintContext
 {
@@ -48,7 +43,7 @@ class Type1ShadingContext implements PaintContext
 
     private ColorModel outputColorModel;
     private PDColorSpace shadingColorSpace;
-    private PDShadingType1 shadingType;
+    private PDShadingType1 shading;
     private AffineTransform rat;
     private float[] domain;
     private Matrix matrix;
@@ -56,21 +51,19 @@ class Type1ShadingContext implements PaintContext
 
     /**
      * Constructor creates an instance to be used for fill operations.
-     *
-     * @param shadingType1 the shading type to be used
-     * @param colorModelValue the color model to be used
+     * @param shading the shading type to be used
+     * @param cm the color model to be used
      * @param xform transformation for user to device space
      * @param ctm current transformation matrix
      * @param pageHeight height of the current page
-     *
      */
-    public Type1ShadingContext(PDShadingType1 shadingType1, ColorModel colorModelValue, 
-            AffineTransform xform, Matrix ctm, int pageHeight) throws IOException
+    public Type1ShadingContext(PDShadingType1 shading, ColorModel cm, AffineTransform xform,
+                               Matrix ctm, int pageHeight) throws IOException
     {
-        shadingType = shadingType1;
+        this.shading = shading;
 
         // color space
-        shadingColorSpace = shadingType.getColorSpace();
+        shadingColorSpace = this.shading.getColorSpace();
         // create the output colormodel using RGB+alpha as colorspace
         ColorSpace outputCS = ColorSpace.getInstance(ColorSpace.CS_sRGB);
         outputColorModel = new ComponentColorModel(outputCS, true, false, Transparency.TRANSLUCENT,
@@ -80,9 +73,9 @@ class Type1ShadingContext implements PaintContext
         // (Optional) An array of four numbers [ xmin xmax ymin ymax ] 
         // specifying the rectangular domain of coordinates over which the 
         // color function(s) are defined. Default value: [ 0.0 1.0 0.0 1.0 ].
-        if (shadingType.getDomain() != null)
+        if (this.shading.getDomain() != null)
         {
-            domain = shadingType.getDomain().toFloatArray();
+            domain = this.shading.getDomain().toFloatArray();
         }
         else
         {
@@ -92,7 +85,7 @@ class Type1ShadingContext implements PaintContext
             };
         }
 
-        matrix = shadingType.getMatrix();
+        matrix = this.shading.getMatrix();
         if (matrix == null)
         {
             matrix = new Matrix();
@@ -113,41 +106,30 @@ class Type1ShadingContext implements PaintContext
         }
 
         // get background values if available
-        COSArray bg = shadingType1.getBackground();
+        COSArray bg = shading.getBackground();
         if (bg != null)
         {
             background = bg.toFloatArray();
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public void dispose()
     {
         outputColorModel = null;
         shadingColorSpace = null;
-        shadingType = null;
+        shading = null;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public ColorModel getColorModel()
     {
         return outputColorModel;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public Raster getRaster(int x, int y, int w, int h)
     {
-        // create writable raster
-        
         WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);
         int[] data = new int[w * h * 4];
         for (int j = 0; j < h; j++)
@@ -181,7 +163,7 @@ class Type1ShadingContext implements PaintContext
                 {
                     try
                     {
-                        values = shadingType.evalFunction(values);
+                        values = shading.evalFunction(values);
                     }
                     catch (IOException exception)
                     {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type1ShadingPaint.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type1ShadingPaint.java
index 9a8b46e0bb..94bd6eaac4 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type1ShadingPaint.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type1ShadingPaint.java
@@ -30,9 +30,9 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This represents the Paint of an type1 shading.
+ * AWT PaintContext for function-based (Type 1) shading.
  */
-public class Type1ShadingPaint implements Paint
+class Type1ShadingPaint implements Paint
 {
     private static final Log LOG = LogFactory.getLog(Type1ShadingPaint.class);
 
@@ -42,33 +42,26 @@ public class Type1ShadingPaint implements Paint
 
     /**
      * Constructor.
-     *
-     * @param shadingType1 the shading resources
+     * @param shading the shading resources
      * @param ctm current transformation matrix
      * @param pageHeight the height of the page
      */
-    public Type1ShadingPaint(PDShadingType1 shadingType1, Matrix ctm, int pageHeight)
+    public Type1ShadingPaint(PDShadingType1 shading, Matrix ctm, int pageHeight)
     {
-        shading = shadingType1;
+        this.shading = shading;
         this.ctm = ctm;
         this.pageHeight = pageHeight;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public int getTransparency()
     {
         return 0;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public PaintContext createContext(ColorModel cm, Rectangle deviceBounds,
-            Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
+    public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds,
+                                      AffineTransform xform, RenderingHints hints)
     {
         try
         {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type4ShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type4ShadingContext.java
index efefe797a3..56888c4204 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type4ShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type4ShadingContext.java
@@ -34,9 +34,7 @@ import org.apache.pdfbox.pdmodel.common.PDRange;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This represents the Paint of a type 4 (Gouraud triangle mesh) shading
- * context.
- *
+ * AWT PaintContext for Gouraud Triangle Mesh (Type 4) shading.
  * @author Tilman Hausherr
  */
 class Type4ShadingContext extends GouraudShadingContext
@@ -47,33 +45,31 @@ class Type4ShadingContext extends GouraudShadingContext
 
     /**
      * Constructor creates an instance to be used for fill operations.
-     *
-     * @param shadingType4 the shading type to be used
-     * @param colorModelValue the color model to be used
+     * @param shading the shading type to be used
+     * @param cm the color model to be used
      * @param xform transformation for user to device space
      * @param ctm current transformation matrix
      * @param pageHeight height of the current page
-     *
      */
-    public Type4ShadingContext(PDShadingType4 shadingType4, ColorModel colorModelValue,
-            AffineTransform xform, Matrix ctm, int pageHeight) throws IOException
+    public Type4ShadingContext(PDShadingType4 shading, ColorModel cm, AffineTransform xform,
+                               Matrix ctm, int pageHeight) throws IOException
     {
-        super(shadingType4, colorModelValue, xform, ctm, pageHeight);
+        super(shading, cm, xform, ctm, pageHeight);
 
         ArrayList<Vertex> vertexList = new ArrayList<Vertex>();
 
         LOG.debug("Type4ShadingContext");
 
-        bitsPerColorComponent = shadingType4.getBitsPerComponent();
+        bitsPerColorComponent = shading.getBitsPerComponent();
         LOG.debug("bitsPerColorComponent: " + bitsPerColorComponent);
-        bitsPerCoordinate = shadingType4.getBitsPerCoordinate();
+        bitsPerCoordinate = shading.getBitsPerCoordinate();
         LOG.debug(Math.pow(2, bitsPerCoordinate) - 1);
         long maxSrcCoord = (int) Math.pow(2, bitsPerCoordinate) - 1;
         long maxSrcColor = (int) Math.pow(2, bitsPerColorComponent) - 1;
         LOG.debug("maxSrcCoord: " + maxSrcCoord);
         LOG.debug("maxSrcColor: " + maxSrcColor);
 
-        COSDictionary cosDictionary = shadingType4.getCOSDictionary();
+        COSDictionary cosDictionary = shading.getCOSDictionary();
         COSStream cosStream = (COSStream) cosDictionary;
 
         //The Decode key specifies how
@@ -84,24 +80,24 @@ class Type4ShadingContext extends GouraudShadingContext
         // see p344
         COSArray decode = (COSArray) cosDictionary.getDictionaryObject(COSName.DECODE);
         LOG.debug("decode: " + decode);
-        PDRange rangeX = shadingType4.getDecodeForParameter(0);
-        PDRange rangeY = shadingType4.getDecodeForParameter(1);
+        PDRange rangeX = shading.getDecodeForParameter(0);
+        PDRange rangeY = shading.getDecodeForParameter(1);
         LOG.debug("rangeX: " + rangeX.getMin() + ", " + rangeX.getMax());
         LOG.debug("rangeY: " + rangeY.getMin() + ", " + rangeY.getMax());
 
         PDRange[] colRangeTab = new PDRange[numberOfColorComponents];
         for (int i = 0; i < numberOfColorComponents; ++i)
         {
-            colRangeTab[i] = shadingType4.getDecodeForParameter(2 + i);
+            colRangeTab[i] = shading.getDecodeForParameter(2 + i);
         }
 
         LOG.debug("bitsPerCoordinate: " + bitsPerCoordinate);
-        bitsPerFlag = shadingType4.getBitsPerFlag();
+        bitsPerFlag = shading.getBitsPerFlag();
         LOG.debug("bitsPerFlag: " + bitsPerFlag); //TODO handle cases where bitperflag isn't 8
         LOG.debug("Stream size: " + cosStream.getInt(COSName.LENGTH));
 
         // get background values if available
-        COSArray bg = shadingType4.getBackground();
+        COSArray bg = shading.getBackground();
         if (bg != null)
         {
             background = bg.toFloatArray();
@@ -184,11 +180,7 @@ class Type4ShadingContext extends GouraudShadingContext
         createTriangleList(vertexList);
     }
 
-    /**
-     * Create GouraudTriangle list from vertices, see p.316 of pdf spec 1.7.
-     *
-     * @param vertexList list of vertices
-     */
+    // create GouraudTriangle list from vertices, see p.316 of pdf spec 1.7.
     private void createTriangleList(ArrayList<Vertex> vertexList)
     {
         Point2D a = null, b = null, c = null;
@@ -251,9 +243,6 @@ class Type4ShadingContext extends GouraudShadingContext
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public void dispose()
     {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type4ShadingPaint.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type4ShadingPaint.java
index a57872f4f2..22be2db27a 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type4ShadingPaint.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type4ShadingPaint.java
@@ -24,57 +24,48 @@ import java.awt.geom.AffineTransform;
 import java.awt.geom.Rectangle2D;
 import java.awt.image.ColorModel;
 import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This represents the Paint of an Type 4 shading.
+ * AWT PaintContext for Gouraud Triangle Mesh (Type 4) shading.
  */
-public class Type4ShadingPaint implements Paint
+class Type4ShadingPaint implements Paint
 {
     private static final Log LOG = LogFactory.getLog(Type4ShadingPaint.class);
 
     private PDShadingType4 shading;
-    private Matrix currentTransformationMatrix;
+    private Matrix ctm;
     private int pageHeight;
 
     /**
      * Constructor.
-     *
-     * @param shadingType4 the shading resources
+     * @param shading the shading resources
      * @param ctm current transformation matrix
-     * @param pageHeightValue the height of the page
+     * @param pageHeight the height of the page
      */
-    public Type4ShadingPaint(PDShadingType4 shadingType4, Matrix ctm, int pageHeightValue)
+    public Type4ShadingPaint(PDShadingType4 shading, Matrix ctm, int pageHeight)
     {
-        shading = shadingType4;
-        currentTransformationMatrix = ctm;
-        pageHeight = pageHeightValue;
+        this.shading = shading;
+        this.ctm = ctm;
+        this.pageHeight = pageHeight;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public int getTransparency()
     {
         return 0;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public PaintContext createContext(ColorModel cm, Rectangle deviceBounds,
-            Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
+    public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds,
+                                      AffineTransform xform, RenderingHints hints)
     {
         try
         {
-            return new Type4ShadingContext(shading, cm, xform, currentTransformationMatrix, pageHeight);
+            return new Type4ShadingContext(shading, cm, xform, ctm, pageHeight);
         }
         catch (IOException ex)
         {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type5ShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type5ShadingContext.java
index bdaf4b26fb..cee11d5f06 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type5ShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type5ShadingContext.java
@@ -33,44 +33,39 @@ import org.apache.pdfbox.pdmodel.common.PDRange;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- *
- * This represents the Paint of a type 5 (Gouraud triangle lattice) shading
- * context.
- *
+ * AWT PaintContext for Gouraud Triangle Lattice (Type 5) shading.
  * @author Tilman Hausherr
  */
-public class Type5ShadingContext extends GouraudShadingContext
+class Type5ShadingContext extends GouraudShadingContext
 {
     private static final Log LOG = LogFactory.getLog(Type5ShadingContext.class);
 
     /**
      * Constructor creates an instance to be used for fill operations.
-     *
-     * @param shadingType5 the shading type to be used
-     * @param colorModelValue the color model to be used
+     * @param shading the shading type to be used
+     * @param cm the color model to be used
      * @param xform transformation for user to device space
      * @param ctm current transformation matrix
      * @param pageHeight height of the current page
-     *
      * @throws IOException if something went wrong
      */
-    public Type5ShadingContext(PDShadingType5 shadingType5, ColorModel colorModelValue,
-            AffineTransform xform, Matrix ctm, int pageHeight) throws IOException
+    public Type5ShadingContext(PDShadingType5 shading, ColorModel cm, AffineTransform xform,
+                               Matrix ctm, int pageHeight) throws IOException
     {
-        super(shadingType5, colorModelValue, xform, ctm, pageHeight);
+        super(shading, cm, xform, ctm, pageHeight);
 
         LOG.debug("Type5ShadingContext");
 
-        bitsPerColorComponent = shadingType5.getBitsPerComponent();
+        bitsPerColorComponent = shading.getBitsPerComponent();
         LOG.debug("bitsPerColorComponent: " + bitsPerColorComponent);
-        bitsPerCoordinate = shadingType5.getBitsPerCoordinate();
+        bitsPerCoordinate = shading.getBitsPerCoordinate();
         LOG.debug(Math.pow(2, bitsPerCoordinate) - 1);
         long maxSrcCoord = (int) Math.pow(2, bitsPerCoordinate) - 1;
         long maxSrcColor = (int) Math.pow(2, bitsPerColorComponent) - 1;
         LOG.debug("maxSrcCoord: " + maxSrcCoord);
         LOG.debug("maxSrcColor: " + maxSrcColor);
 
-        COSDictionary cosDictionary = shadingType5.getCOSDictionary();
+        COSDictionary cosDictionary = shading.getCOSDictionary();
         COSStream cosStream = (COSStream) cosDictionary;
 
         //The Decode key specifies how
@@ -81,21 +76,21 @@ public class Type5ShadingContext extends GouraudShadingContext
         // see p344
         COSArray decode = (COSArray) cosDictionary.getDictionaryObject(COSName.DECODE);
         LOG.debug("decode: " + decode);
-        PDRange rangeX = shadingType5.getDecodeForParameter(0);
-        PDRange rangeY = shadingType5.getDecodeForParameter(1);
+        PDRange rangeX = shading.getDecodeForParameter(0);
+        PDRange rangeY = shading.getDecodeForParameter(1);
         LOG.debug("rangeX: " + rangeX.getMin() + ", " + rangeX.getMax());
         LOG.debug("rangeY: " + rangeY.getMin() + ", " + rangeY.getMax());
 
         PDRange[] colRangeTab = new PDRange[numberOfColorComponents];
         for (int i = 0; i < numberOfColorComponents; ++i)
         {
-            colRangeTab[i] = shadingType5.getDecodeForParameter(2 + i);
+            colRangeTab[i] = shading.getDecodeForParameter(2 + i);
         }
 
         LOG.debug("bitsPerCoordinate: " + bitsPerCoordinate);
 
         // get background values if available
-        COSArray bg = shadingType5.getBackground();
+        COSArray bg = shading.getBackground();
         if (bg != null)
         {
             background = bg.toFloatArray();
@@ -107,7 +102,7 @@ public class Type5ShadingContext extends GouraudShadingContext
         //  reading in sequence from higher-order to lower-order bit positions
         ImageInputStream mciis = new MemoryCacheImageInputStream(cosStream.getFilteredStream());
 
-        int verticesPerRow = shadingType5.getVerticesPerRow(); //TODO check >=2
+        int verticesPerRow = shading.getVerticesPerRow(); //TODO check >=2
         LOG.debug("verticesPerRow" + verticesPerRow);
 
         try
@@ -168,13 +163,9 @@ public class Type5ShadingContext extends GouraudShadingContext
         mciis.close();
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public void dispose()
     {
         super.dispose();
     }
-
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type5ShadingPaint.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type5ShadingPaint.java
index 4ca62b90ab..f22d9bdc4c 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type5ShadingPaint.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Type5ShadingPaint.java
@@ -24,57 +24,48 @@ import java.awt.geom.AffineTransform;
 import java.awt.geom.Rectangle2D;
 import java.awt.image.ColorModel;
 import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.util.Matrix;
 
 /**
- * This represents the Paint of a Type 5 shading.
+ * AWT Paint for Gouraud Triangle Lattice (Type 5) shading.
  */
-public class Type5ShadingPaint implements Paint
+class Type5ShadingPaint implements Paint
 {
     private static final Log LOG = LogFactory.getLog(Type5ShadingPaint.class);
 
     private PDShadingType5 shading;
-    private Matrix currentTransformationMatrix;
+    private Matrix ctm;
     private int pageHeight;
 
     /**
      * Constructor.
-     *
-     * @param shadingType5 the shading resources
+     * @param shading the shading resources
      * @param ctm current transformation matrix
-     * @param pageHeightValue
+     * @param pageHeight the height of the page
      */
-    public Type5ShadingPaint(PDShadingType5 shadingType5, Matrix ctm, int pageHeightValue)
+    public Type5ShadingPaint(PDShadingType5 shading, Matrix ctm, int pageHeight)
     {
-        shading = shadingType5;
-        currentTransformationMatrix = ctm;
-        pageHeight = pageHeightValue;
+        this.shading = shading;
+        this.ctm = ctm;
+        this.pageHeight = pageHeight;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public int getTransparency()
     {
         return 0;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public PaintContext createContext(ColorModel cm, Rectangle deviceBounds,
-            Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
+    public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds,
+                                      AffineTransform xform, RenderingHints hints)
     {
         try
         {
-            return new Type5ShadingContext(shading, cm, xform, currentTransformationMatrix, pageHeight);
+            return new Type5ShadingContext(shading, cm, xform, ctm, pageHeight);
         }
         catch (IOException ex)
         {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Vertex.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Vertex.java
index f7bfa1545a..8bd88476f6 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Vertex.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/Vertex.java
@@ -20,9 +20,7 @@ package org.apache.pdfbox.pdmodel.graphics.shading;
 import java.awt.geom.Point2D;
 
 /**
- * 
- * Helper class to deal with Vertices for type 4 and 5 shading.
- *
+ * Vertex for Type 4 and Type 5 shadings.
  * @author Tilman Hausherr
  */
 class Vertex
@@ -52,5 +50,4 @@ class Vertex
         }
         return "Vertex{" + flag + ": " + point + ", colors=[" + colorStr + "] }";
     }
-
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/rendering/PageDrawer.java b/pdfbox/src/main/java/org/apache/pdfbox/rendering/PageDrawer.java
index d896e6e2ec..5675fe4176 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/rendering/PageDrawer.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/rendering/PageDrawer.java
@@ -69,17 +69,7 @@ import org.apache.pdfbox.pdmodel.graphics.PDLineDashPattern;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColor;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
 import org.apache.pdfbox.pdmodel.graphics.pattern.PDTilingPattern;
-import org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingPaint;
 import org.apache.pdfbox.pdmodel.graphics.shading.PDShading;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType1;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType2;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType3;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType4;
-import org.apache.pdfbox.pdmodel.graphics.shading.PDShadingType5;
-import org.apache.pdfbox.pdmodel.graphics.shading.RadialShadingPaint;
-import org.apache.pdfbox.pdmodel.graphics.shading.Type1ShadingPaint;
-import org.apache.pdfbox.pdmodel.graphics.shading.Type4ShadingPaint;
-import org.apache.pdfbox.pdmodel.graphics.shading.Type5ShadingPaint;
 import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation;
 import org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceDictionary;
 import org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceStream;
@@ -826,45 +816,17 @@ public class PageDrawer extends PDFStreamEngine
 
     /**
      * Fill with Shading. Called by SHFill operator.
-     * 
+     *
      * @param shadingName The name of the Shading Dictionary to use for this fill instruction.
-     * 
+     *
      * @throws IOException If there is an IO error while shade-filling the clipping area.
      */
-    // TODO would this now be better off using PDPattern?
     public void shFill(COSName shadingName) throws IOException
     {
         PDShading shading = getResources().getShadings().get(shadingName.getName());
-        LOG.debug("Shading = " + shading.toString());
-        int shadingType = shading.getShadingType();
         Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();
-        Paint paint = null;
-        switch (shadingType)
-        {
-        case 1:
-            paint = new Type1ShadingPaint((PDShadingType1) shading, ctm, pageHeight);
-            break;
-        case 2:
-            paint = new AxialShadingPaint((PDShadingType2) shading, ctm, pageHeight);
-            break;
-        case 3:
-            paint = new RadialShadingPaint((PDShadingType3) shading, ctm, pageHeight);
-            break;
-        case 4:
-            paint = new Type4ShadingPaint((PDShadingType4) shading, ctm, pageHeight);
-            break;
-        case 5:
-            paint = new Type5ShadingPaint((PDShadingType5) shading, ctm, pageHeight);
-            break;
-        case 6:
-        case 7:
-            // TODO
-            LOG.debug("Shading type " + shadingType + " not yet supported");
-            paint = new Color(0, 0, 0, 0); // transparent
-            break;
-        default:
-            throw new IOException("Invalid ShadingType " + shadingType + " for Shading " + shadingName);
-        }
+        Paint paint = shading.toPaint(ctm, pageHeight);
+
         graphics.setComposite(getGraphicsState().getNonStrokeJavaComposite());
         graphics.setPaint(paint);
         graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
