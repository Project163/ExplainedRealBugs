diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java
index 10253b5cec..556d21d51b 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java
@@ -19,6 +19,7 @@ package org.apache.pdfbox.pdmodel.graphics.shading;
 import java.awt.PaintContext;
 import java.awt.Rectangle;
 import java.awt.geom.AffineTransform;
+import java.awt.geom.NoninvertibleTransformException;
 import java.awt.image.ColorModel;
 import java.awt.image.Raster;
 import java.awt.image.WritableRaster;
@@ -55,9 +56,11 @@ public class AxialShadingContext extends ShadingContext implements PaintContext
     private final float d1d0;
     private double denom;
 
-    private final double axialLength;
+    private int factor;
     private final int[] colorTable;
 
+    private AffineTransform rat;
+
     /**
      * Constructor creates an instance to be used for fill operations.
      *
@@ -74,13 +77,6 @@ public class AxialShadingContext extends ShadingContext implements PaintContext
         this.axialShadingType = shading;
         coords = shading.getCoords().toFloatArray();
 
-        if (ctm != null)
-        {
-            // transform the coords using the given matrix
-            ctm.createAffineTransform().transform(coords, 0, coords, 0, 2);
-        }
-        xform.transform(coords, 0, coords, 0, 2);
-
         // domain values
         if (shading.getDomain() != null)
         {
@@ -115,7 +111,24 @@ public class AxialShadingContext extends ShadingContext implements PaintContext
         y1y0 = coords[3] - coords[1];
         d1d0 = domain[1] - domain[0];
         denom = Math.pow(x1x0, 2) + Math.pow(y1y0, 2);
-        axialLength = Math.sqrt(denom);
+        double axialLength = Math.sqrt(denom);
+        
+        try
+        {
+            // get inverse transform to be independent of current user / device space 
+            // when handling actual pixels in getRaster()
+            rat = ctm.createAffineTransform().createInverse();
+            rat.concatenate(xform.createInverse());
+        }
+        catch (NoninvertibleTransformException ex)
+        {
+            LOG.error(ex, ex);
+        }
+
+        // transform the distance to actual pixel space
+        double maxX = Math.max(10, Math.abs(ctm.getXScale() * xform.getScaleX() * axialLength));
+        double maxY = Math.max(10, Math.abs(ctm.getYScale() * xform.getScaleY() * axialLength));
+        factor = (int) Math.max(maxX, maxY);
         colorTable = calcColorTable();
     }
 
@@ -127,8 +140,8 @@ public class AxialShadingContext extends ShadingContext implements PaintContext
      */
     private int[] calcColorTable()
     {
-        int[] map = new int[(int) axialLength + 1];
-        if (axialLength == 0 || d1d0 == 0)
+        int[] map = new int[factor + 1];
+        if (factor == 0 || d1d0 == 0)
         {
             try
             {
@@ -142,9 +155,9 @@ public class AxialShadingContext extends ShadingContext implements PaintContext
         }
         else
         {
-            for (int i = 0; i <= axialLength; i++)
+            for (int i = 0; i <= factor; i++)
             {
-                float t = domain[0] + d1d0 * i / (float) axialLength;
+                float t = domain[0] + d1d0 * i / (float) factor;
                 try
                 {
                     float[] values = axialShadingType.evalFunction(t);
@@ -195,6 +208,13 @@ public class AxialShadingContext extends ShadingContext implements PaintContext
                     continue;
                 }
                 useBackground = false;
+                float[] values = new float[]
+                {
+                    x + i, y + j
+                };
+                rat.transform(values, 0, values, 0, 1);
+                currentX = values[0];
+                currentY = values[1];
                 double inputValue = x1x0 * (currentX - coords[0]);
                 inputValue += y1y0 * (currentY - coords[1]);
                 // TODO this happens if start == end, see PDFBOX-1442
@@ -252,7 +272,7 @@ public class AxialShadingContext extends ShadingContext implements PaintContext
                 }
                 else
                 {
-                    int key = (int) (inputValue * axialLength);
+                    int key = (int) (inputValue * factor);
                     value = colorTable[key];
                 }
                 int index = (j * w + i) * 4;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
index 1ef5cef63e..b7fbd71bb5 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
@@ -19,6 +19,7 @@ package org.apache.pdfbox.pdmodel.graphics.shading;
 import java.awt.PaintContext;
 import java.awt.Rectangle;
 import java.awt.geom.AffineTransform;
+import java.awt.geom.NoninvertibleTransformException;
 import java.awt.image.ColorModel;
 import java.awt.image.Raster;
 import java.awt.image.WritableRaster;
@@ -58,9 +59,11 @@ public class RadialShadingContext extends ShadingContext implements PaintContext
     private final float d1d0;
     private final double denom;
 
-    private final double longestDistance;
+    private int factor;
     private final int[] colorTable;
 
+    private AffineTransform rat;
+
     /**
      * Constructor creates an instance to be used for fill operations.
      *
@@ -77,25 +80,6 @@ public class RadialShadingContext extends ShadingContext implements PaintContext
         this.radialShadingType = shading;
         coords = shading.getCoords().toFloatArray();
 
-        if (ctm != null)
-        {
-            // transform the coords using the given matrix
-            AffineTransform at = ctm.createAffineTransform();
-            at.transform(coords, 0, coords, 0, 1);
-            at.transform(coords, 3, coords, 3, 1);
-            coords[2] *= ctm.getXScale();
-            coords[5] *= ctm.getXScale();
-        }
-        // transform coords to device space
-        xform.transform(coords, 0, coords, 0, 1);
-        xform.transform(coords, 3, coords, 3, 1);
-        // scale radius to device space
-        coords[2] *= xform.getScaleX();
-        coords[5] *= xform.getScaleX();
-        // a radius is always positive
-        coords[2] = Math.abs(coords[2]);
-        coords[5] = Math.abs(coords[5]);
-
         // domain values
         if (this.radialShadingType.getDomain() != null)
         {
@@ -135,12 +119,33 @@ public class RadialShadingContext extends ShadingContext implements PaintContext
         r0pow2 = Math.pow(coords[2], 2);
         denom = x1x0pow2 + y1y0pow2 - Math.pow(r1r0, 2);
         d1d0 = domain[1] - domain[0];
-        longestDistance = getLongestDis();
+        double longestDistance = getLongestDistance();
+
+        try
+        {
+            // get inverse transform to be independent of current user / device space 
+            // when handling actual pixels in getRaster()
+            rat = ctm.createAffineTransform().createInverse();
+            rat.concatenate(xform.createInverse());
+        }
+        catch (NoninvertibleTransformException ex)
+        {
+            LOG.error(ex, ex);
+        }
+
+        // transform the distance to actual pixel space
+        double maxX = Math.abs(ctm.getXScale() * xform.getScaleX() * longestDistance);
+        double maxY = Math.abs(ctm.getYScale() * xform.getScaleY() * longestDistance);
+        factor = (int) Math.max(maxX, maxY);
+        if (factor > 0 && factor < 10)
+        {
+            factor = 10;
+        }
         colorTable = calcColorTable();
     }
 
     // get the longest distance of two points which are located on these two circles
-    private double getLongestDis()
+    private double getLongestDistance()
     {
         double centerToCenter = Math.sqrt(x1x0pow2 + y1y0pow2);
         double rmin, rmax;
@@ -173,8 +178,8 @@ public class RadialShadingContext extends ShadingContext implements PaintContext
      */
     private int[] calcColorTable()
     {
-        int[] map = new int[(int) longestDistance + 1];
-        if (longestDistance == 0 || d1d0 == 0)
+        int[] map = new int[factor + 1];
+        if (factor == 0 || d1d0 == 0)
         {
             try
             {
@@ -188,9 +193,9 @@ public class RadialShadingContext extends ShadingContext implements PaintContext
         }
         else
         {
-            for (int i = 0; i <= longestDistance; i++)
+            for (int i = 0; i <= factor; i++)
             {
-                float t = domain[0] + d1d0 * i / (float) longestDistance;
+                float t = domain[0] + d1d0 * i / (float) factor;
                 try
                 {
                     float[] values = radialShadingType.evalFunction(t);
@@ -241,8 +246,17 @@ public class RadialShadingContext extends ShadingContext implements PaintContext
                 {
                     continue;
                 }
+
+                float[] values = new float[]
+                {
+                    x + i, y + j
+                };
+                rat.transform(values, 0, values, 0, 1);
+                currentX = values[0];
+                currentY = values[1];
+
                 useBackground = false;
-                float[] inputValues = calculateInputValues(x + i, y + j);
+                float[] inputValues = calculateInputValues(currentX, currentY);
                 if (Float.isNaN(inputValues[0]) && Float.isNaN(inputValues[1]))
                 {
                     if (background == null)
@@ -343,7 +357,7 @@ public class RadialShadingContext extends ShadingContext implements PaintContext
                 }
                 else
                 {
-                    int key = (int) (inputValue * longestDistance);
+                    int key = (int) (inputValue * factor);
                     value = colorTable[key];
                 }
                 int index = (j * w + i) * 4;
@@ -359,7 +373,7 @@ public class RadialShadingContext extends ShadingContext implements PaintContext
         return raster;
     }
 
-    private float[] calculateInputValues(int x, int y)
+    private float[] calculateInputValues(double x, double y)
     {
         // According to Adobes Technical Note #5600 we have to do the following
         //
