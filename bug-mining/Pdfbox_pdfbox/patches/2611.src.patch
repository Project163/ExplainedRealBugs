diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/COSParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/COSParser.java
index cb110745ea..afce1b9402 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/COSParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/COSParser.java
@@ -141,6 +141,12 @@ public class COSParser extends BaseParser implements ICOSParser
     private boolean bruteForceSearchTriggered = false;
     private PDEncryption encryption = null;
 
+    /**
+     * Intermediate cache. Contains all objects of already read compressed object streams. Objects are removed after
+     * dereferencing them.
+     */
+    private final Map<Integer, Map<Long, COSBase>> decompressedObjects = new HashMap<>();
+
     /**
      * The security handler.
      */
@@ -761,20 +767,33 @@ public class COSParser extends BaseParser implements ICOSParser
      */
     protected COSBase parseObjectStreamObject(int objstmObjNr, COSObjectKey key) throws IOException
     {
+        Map<Long, COSBase> streamObjects = decompressedObjects.computeIfAbsent(objstmObjNr,
+                n -> new HashMap<>());
+        // did we already read the compressed object stream?
+        COSBase objectStreamObject = streamObjects.remove(key.getNumber());
+        if (objectStreamObject != null)
+        {
+            return objectStreamObject;
+        }
         final COSObjectKey objKey = new COSObjectKey(objstmObjNr, 0);
         final COSBase objstmBaseObj = document.getObjectFromPool(objKey).getObject();
-        COSBase objectStreamObject = null;
         if (objstmBaseObj instanceof COSStream)
         {
-            // parse object stream
-            PDFObjectStreamParser parser = null;
             try
             {
-                parser = new PDFObjectStreamParser((COSStream) objstmBaseObj, document);
-                objectStreamObject = parser.parseObject(key.getNumber());
-                if (objectStreamObject != null)
+                PDFObjectStreamParser parser = new PDFObjectStreamParser((COSStream) objstmBaseObj,
+                        document);
+                for (Entry<Long, COSBase> entry : parser.parseAllObjects().entrySet())
                 {
-                    objectStreamObject.setKey(key);
+                    Long stmObjNumber = entry.getKey();
+                    if (key.getNumber() == stmObjNumber)
+                    {
+                        objectStreamObject = entry.getValue();
+                    }
+                    else
+                    {
+                        streamObjects.putIfAbsent(stmObjNumber, entry.getValue());
+                    }
                 }
             }
             catch (IOException ex)
@@ -792,7 +811,7 @@ public class COSParser extends BaseParser implements ICOSParser
         }
         return objectStreamObject;
     }
-    
+
     /** 
      * Returns length value referred to or defined in given object. 
      */
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFObjectStreamParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFObjectStreamParser.java
index 1bce44b2d8..9aceddc8e5 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFObjectStreamParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFObjectStreamParser.java
@@ -19,6 +19,8 @@ package org.apache.pdfbox.pdfparser;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Map.Entry;
+import java.util.TreeMap;
 
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDocument;
@@ -83,7 +85,7 @@ public class PDFObjectStreamParser extends BaseParser
         try
         {
             Integer objectOffset = privateReadObjectNumbers().get(objectNumber);
-            if (objectOffset != null) 
+            if (objectOffset != null)
             {
                 // jump to the offset of the first object
                 long currentPosition = source.getPosition();
@@ -108,6 +110,48 @@ public class PDFObjectStreamParser extends BaseParser
         return streamObject;
     }
 
+    /**
+     * Parse all compressed objects. The stream is closed after parsing.
+     * 
+     * @return a map containing all parsed objects using the object number as key
+     * @throws IOException if there is an error while parsing the stream
+     */
+    public Map<Long, COSBase> parseAllObjects() throws IOException
+    {
+        Map<Long, COSBase> allObjects = new HashMap<>();
+        try
+        {
+            Map<Integer, Long> objectNumbers = privateReadObjectOffets();
+            long currentPosition = source.getPosition();
+            if (firstObject > 0 && currentPosition < firstObject)
+            {
+                source.skip(firstObject - (int) currentPosition);
+            }
+            for (Entry<Integer, Long> entry : objectNumbers.entrySet())
+            {
+                int finalPosition = firstObject + entry.getKey();
+                currentPosition = source.getPosition();
+                if (finalPosition > 0 && currentPosition < finalPosition)
+                {
+                    // jump to the offset of the object to be parsed
+                    source.skip(finalPosition - (int) currentPosition);
+                }
+                COSBase streamObject = parseDirObject();
+                if (streamObject != null)
+                {
+                    streamObject.setDirect(false);
+                }
+                allObjects.put(entry.getValue(), streamObject);
+            }
+        }
+        finally
+        {
+            source.close();
+            document = null;
+        }
+        return allObjects;
+    }
+
     private Map<Long, Integer> privateReadObjectNumbers() throws IOException
     {
         // don't initialize map using numberOfObjects as there might by less object numbers than expected
@@ -127,6 +171,27 @@ public class PDFObjectStreamParser extends BaseParser
         return objectNumbers;
     }
 
+    private Map<Integer, Long> privateReadObjectOffets() throws IOException
+    {
+        // according to the pdf spec the offsets shall be sorted ascending
+        // but we can't rely on that, so that we have to sort the offsets
+        // as the sequential parsers relies on it, see PDFBOX-4927
+        Map<Integer, Long> objectOffsets = new TreeMap<>();
+        long firstObjectPosition = source.getPosition() + firstObject - 1;
+        for (int i = 0; i < numberOfObjects; i++)
+        {
+            // don't read beyond the part of the stream reserved for the object numbers
+            if (source.getPosition() >= firstObjectPosition)
+            {
+                break;
+            }
+            long objectNumber = readObjectNumber();
+            int offset = (int) readLong();
+            objectOffsets.put(offset, objectNumber);
+        }
+        return objectOffsets;
+    }
+
     /**
      * Read all object numbers from the compressed object stream. The stream is closed after reading the object numbers.
      * 
