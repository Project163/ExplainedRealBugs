diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java
index 6bcf784844..0660907033 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingContext.java
@@ -46,9 +46,9 @@ public class AxialShadingContext implements PaintContext
 {
 
     private ColorModel colorModel;
-    private PDFunction function;
     private ColorSpace shadingColorSpace;
     private PDFunction shadingTinttransform;
+    private PDShadingType2 shadingType;
 
     private float[] coords;
     private float[] domain;
@@ -76,7 +76,8 @@ public class AxialShadingContext implements PaintContext
     public AxialShadingContext(PDShadingType2 shadingType2, ColorModel colorModelValue, 
             AffineTransform xform, Matrix ctm, int pageHeight) 
     {
-        coords = shadingType2.getCoords().toFloatArray();
+        shadingType = shadingType2;
+        coords = shadingType.getCoords().toFloatArray();
         if (ctm != null)
         {
             // the shading is used in combination with the sh-operator
@@ -101,7 +102,7 @@ public class AxialShadingContext implements PaintContext
         // colorSpace 
         try 
         {
-            PDColorSpace cs = shadingType2.getColorSpace();
+            PDColorSpace cs = shadingType.getColorSpace();
             if (!(cs instanceof PDDeviceRGB))
             {
                 // we have to create an instance of the shading colorspace if it isn't RGB
@@ -130,26 +131,17 @@ public class AxialShadingContext implements PaintContext
             try
             {
                 // TODO bpc != 8 ??  
-                colorModel = shadingType2.getColorSpace().createColorModel(8);
+                colorModel = shadingType.getColorSpace().createColorModel(8);
             }
             catch(IOException exception)
             {
                 LOG.error("error while creating colorModel", exception);
             }
         }
-        // shading function
-        try
-        {
-            function = shadingType2.getFunction();
-        }
-        catch(IOException exception)
-        {
-            LOG.error("error while creating a function", exception);
-        }
         // domain values
-        if (shadingType2.getDomain() != null)
+        if (shadingType.getDomain() != null)
         {
-            domain = shadingType2.getDomain().toFloatArray();
+            domain = shadingType.getDomain().toFloatArray();
         }
         else 
         {
@@ -157,8 +149,8 @@ public class AxialShadingContext implements PaintContext
             domain = new float[]{0,1};
         }
         // extend values
-        COSArray extendValues = shadingType2.getExtend();
-        if (shadingType2.getExtend() != null)
+        COSArray extendValues = shadingType.getExtend();
+        if (shadingType.getExtend() != null)
         {
             extend = new boolean[2];
             extend[0] = ((COSBoolean)extendValues.get(0)).getValue();
@@ -183,9 +175,9 @@ public class AxialShadingContext implements PaintContext
     public void dispose() 
     {
         colorModel = null;
-        function = null;
         shadingColorSpace = null;
         shadingTinttransform = null;
+        shadingType = null;
     }
 
     /**
@@ -203,7 +195,6 @@ public class AxialShadingContext implements PaintContext
     {
         // create writable raster
         WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);
-        float[] input = new float[1];
         int[] data = new int[w * h * 3];
         for (int j = 0; j < h; j++) 
         {
@@ -238,12 +229,12 @@ public class AxialShadingContext implements PaintContext
                         continue;
                     }
                 }
-                input[0] = (float)(domain[0] + (d1d0*inputValue));
+                float input = (float)(domain[0] + (d1d0*inputValue));
                 float[] values = null;
                 int index = (j * w + i) * 3;
                 try 
                 {
-                    values = function.eval(input);
+                    values = shadingType.evalFunction(input);
                     // convert color values from shading colorspace to RGB 
                     if (shadingColorSpace != null)
                     {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType2.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType2.java
index 8c8dc86c53..b67be30925 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType2.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType2.java
@@ -21,6 +21,7 @@ package org.apache.pdfbox.pdmodel.graphics.shading;
 import java.io.IOException;
 
 import org.apache.pdfbox.cos.COSArray;
+import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.pdmodel.common.function.PDFunction;
@@ -36,7 +37,7 @@ public class PDShadingType2 extends PDShadingResources
     private COSArray coords = null;
     private COSArray domain = null;
     private COSArray extend = null;
-    private PDFunction function = null;
+    private PDFunction[] functionArray = null;
     
     /**
      * Constructor using the given shading dictionary.
@@ -159,7 +160,7 @@ public class PDShadingType2 extends PDShadingResources
      */
     public void setFunction(PDFunction newFunction)
     {
-        function = newFunction;
+        functionArray = null;
         if (newFunction == null)
         {
             getCOSDictionary().removeItem(COSName.FUNCTION);
@@ -170,6 +171,23 @@ public class PDShadingType2 extends PDShadingResources
         }
     }
 
+    /**
+     * This will set the functions COSArray for the color conversion.
+     *
+     * @param newFunctions The new COSArray containing all functions.
+     */
+    public void setFunction(COSArray newFunctions)
+    {
+        functionArray = null;
+        if (newFunctions == null)
+        {
+            getCOSDictionary().removeItem(COSName.FUNCTION);
+        }
+        else
+        {
+            getCOSDictionary().setItem(COSName.FUNCTION, newFunctions);
+        }
+    }
     /**
      * This will return the function used to convert the color values.
      *
@@ -177,14 +195,73 @@ public class PDShadingType2 extends PDShadingResources
      * 
      * @exception IOException If we are unable to create the PDFunction object. 
      * 
+     * @deprecated
+     * 
      */
     public PDFunction getFunction() throws IOException
     {
-        if (function == null)
+        // TODO
+        // change the return value to COSArray
+        return null;
+    }
+    
+    /**
+     * Provide the function(s) of the shading dictionary as array.
+     * 
+     * @return an array containing the function(s) 
+     * @throws IOException throw if something went wrong
+     */
+    private PDFunction[] getFunctionsArray() throws IOException
+    {
+        if (functionArray == null)
+        {
+            COSBase functionObject = getCOSDictionary().getDictionaryObject(COSName.FUNCTION);
+            if (functionObject instanceof COSDictionary)
+            {
+                functionArray = new PDFunction[1];
+                functionArray[0] = PDFunction.create(functionObject);
+            }
+            else
+            {
+                COSArray functionCOSArray = (COSArray)functionObject;
+                int numberOfFunctions = functionCOSArray.size();
+                functionArray = new PDFunction[numberOfFunctions];
+                for (int i=0; i<numberOfFunctions; i++)
+                {
+                    functionArray[i] = PDFunction.create(functionCOSArray.get(i));
+                }
+            }
+        }
+        return functionArray;
+    }
+    
+    /**
+     * Convert the input value using the functions of the shading dictionary.
+     * 
+     * @param inputValue the input value
+     * @return the output values
+     * @throws IOException thrown if something went wrong
+     */
+    public float[] evalFunction(float inputValue) throws IOException
+    {
+        float[] input = new float[] {inputValue};
+        PDFunction[] functions = getFunctionsArray();
+        int numberOfFunctions = functions.length;
+        float[] returnValues = null;
+        if (numberOfFunctions == 1)
+        {
+            returnValues = functions[0].eval(input);
+        }
+        else
         {
-            function = PDFunction.create(getCOSDictionary().getDictionaryObject(COSName.FUNCTION));
+            returnValues = new float[numberOfFunctions];
+            for (int i=0; i<numberOfFunctions;i++)
+            {
+                float[] newValue = functions[i].eval(input);
+                returnValues[i] = newValue[0];
+            }
         }
-        return function;
+        return returnValues;
     }
 
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
index b5420d22fe..506d29fe68 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
@@ -46,9 +46,9 @@ public class RadialShadingContext implements PaintContext
 {
 
     private ColorModel colorModel;
-    private PDFunction function;
     private ColorSpace shadingColorSpace;
     private PDFunction shadingTinttransform;
+    private PDShadingType3 shadingType;
 
     private float[] coords;
     private float[] domain;
@@ -81,7 +81,8 @@ public class RadialShadingContext implements PaintContext
     public RadialShadingContext(PDShadingType3 shadingType3, ColorModel colorModelValue, 
             AffineTransform xform, Matrix ctm, int pageHeight) 
     {
-        coords = shadingType3.getCoords().toFloatArray();
+        shadingType = shadingType3;
+        coords = shadingType.getCoords().toFloatArray();
         if (ctm != null)
         {
             // the shading is used in combination with the sh-operator
@@ -108,7 +109,7 @@ public class RadialShadingContext implements PaintContext
         // colorSpace 
         try 
         {
-            PDColorSpace cs = shadingType3.getColorSpace();
+            PDColorSpace cs = shadingType.getColorSpace();
             if (!(cs instanceof PDDeviceRGB))
             {
                 // we have to create an instance of the shading colorspace if it isn't RGB
@@ -137,26 +138,17 @@ public class RadialShadingContext implements PaintContext
             try
             {
                 // TODO bpc != 8 ??  
-                colorModel = shadingType3.getColorSpace().createColorModel(8);
+                colorModel = shadingType.getColorSpace().createColorModel(8);
             }
             catch(IOException exception)
             {
                 LOG.error("error while creating colorModel", exception);
             }
         }
-        // shading function
-        try
-        {
-            function = shadingType3.getFunction();
-        }
-        catch(IOException exception)
-        {
-            LOG.error("error while creating a function", exception);
-        }
         // domain values
-        if (shadingType3.getDomain() != null)
+        if (shadingType.getDomain() != null)
         {
-            domain = shadingType3.getDomain().toFloatArray();
+            domain = shadingType.getDomain().toFloatArray();
         }
         else 
         {
@@ -164,8 +156,8 @@ public class RadialShadingContext implements PaintContext
             domain = new float[]{0,1};
         }
         // extend values
-        COSArray extendValues = shadingType3.getExtend();
-        if (shadingType3.getExtend() != null)
+        COSArray extendValues = shadingType.getExtend();
+        if (shadingType.getExtend() != null)
         {
             extend = new boolean[2];
             extend[0] = ((COSBoolean)extendValues.get(0)).getValue();
@@ -194,7 +186,7 @@ public class RadialShadingContext implements PaintContext
     public void dispose() 
     {
         colorModel = null;
-        function = null;
+        shadingType = null;
         shadingColorSpace = null;
         shadingTinttransform = null;
     }
@@ -214,7 +206,6 @@ public class RadialShadingContext implements PaintContext
     {
         // create writable raster
         WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);
-        float[] input = new float[1];
         float inputValue;
         int[] data = new int[w * h * 3];
         for (int j = 0; j < h; j++) 
@@ -276,12 +267,12 @@ public class RadialShadingContext implements PaintContext
                         continue;
                     }
                 }
-                input[0] = (float)(domain[0] + (d1d0*inputValue));
+                float input = (float)(domain[0] + (d1d0*inputValue));
                 float[] values = null;
                 int index = (j * w + i) * 3;
                 try 
                 {
-                    values = function.eval(input);
+                    values = shadingType.evalFunction(input);
                     // convert color values from shading colorspace to RGB 
                     if (shadingColorSpace != null)
                     {
