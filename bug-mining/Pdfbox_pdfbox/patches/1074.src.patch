diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java
index a78a622c9c..d114305ddc 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java
@@ -102,6 +102,7 @@ public class PDTrueTypeFont extends PDSimpleFont
     private CmapSubtable cmapWinSymbol = null;
     private CmapSubtable cmapMacRoman = null;
     private boolean cmapInitialized = false;
+    private Map<Integer, Integer> gidToCode; // for embedding
 
     private final TrueTypeFont ttf;
     private final boolean isEmbedded;
@@ -259,24 +260,69 @@ public class PDTrueTypeFont extends PDSimpleFont
     @Override
     protected byte[] encode(int unicode) throws IOException
     {
-        if (!getEncoding().contains(getGlyphList().codePointToName(unicode)))
+        if (getEncoding() != null)
         {
-            throw new IllegalArgumentException(
+            if (!getEncoding().contains(getGlyphList().codePointToName(unicode)))
+            {
+                throw new IllegalArgumentException(
                     String.format("U+%04X is not available in this font's Encoding", unicode));
-        }
+            }
 
-        String name = getGlyphList().codePointToName(unicode);
-        Map<String, Integer> inverted = getInvertedEncoding();
-        
-        int gid = ttf.getUnicodeCmap().getGlyphId(unicode);
-        if (gid == 0)
+            String name = getGlyphList().codePointToName(unicode);
+            Map<String, Integer> inverted = getInvertedEncoding();
+
+            if (!ttf.hasGlyph(name))
+            {
+                throw new IllegalArgumentException(
+                    String.format("No glyph for U+%04X in font %s", unicode, getName()));
+            }
+
+            int code = inverted.get(name);
+            return new byte[] { (byte)code };
+        }
+        else
         {
-            throw new IllegalArgumentException(
+            // use TTF font's built-in encoding
+            String name = getGlyphList().codePointToName(unicode);
+
+            if (!ttf.hasGlyph(name))
+            {
+                throw new IllegalArgumentException(
                     String.format("No glyph for U+%04X in font %s", unicode, getName()));
+            }
+            
+            int gid = ttf.nameToGID(name);
+            Integer code = getGIDToCode().get(gid);
+            if (code == null)
+            {
+                throw new IllegalArgumentException(
+                    String.format("U+%04X is not available in this font's Encoding", unicode));
+            }
+            
+            return new byte[] { (byte)(int)code };
+        }
+    }
+
+    /**
+     * Inverts the font's code -> GID mapping. Any duplicate (GID -> code) mappings will be lost.
+     */
+    protected Map<Integer, Integer> getGIDToCode() throws IOException
+    {
+        if (gidToCode != null)
+        {
+            return gidToCode;
+        }
+
+        gidToCode = new HashMap<Integer, Integer>();
+        for (int code = 0; code <= 255; code++)
+        {
+            int gid = codeToGID(code);
+            if (!gidToCode.containsKey(gid))
+            {
+                gidToCode.put(gid, code);
+            }
         }
-        
-        int code = inverted.get(name);
-        return new byte[] { (byte)code };
+        return gidToCode;
     }
 
     @Override
