diff --git a/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/AbstractCCITTFaxTestCase.java b/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/AbstractCCITTFaxTestCase.java
deleted file mode 100644
index 94614f14c9..0000000000
--- a/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/AbstractCCITTFaxTestCase.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* $Id$ */
-
-package org.apache.pdfbox.filter.ccitt;
-
-import junit.framework.TestCase;
-
-/**
- * Abstract base class for testing CCITT fax encoding.
- */
-public abstract class AbstractCCITTFaxTestCase extends TestCase
-{
-
-    /**
-     * Visualizes a packed bitmap and dumps it on System.out.
-     * @param data the bitmap
-     * @param columns the number of columns
-     */
-    protected void dumpBitmap(byte[] data, int columns)
-    {
-        int lineBytes = columns / 8;
-        if (columns % 8 != 0)
-        {
-            lineBytes++;
-        }
-        int lines = data.length / lineBytes;
-        for (int y = 0; y < lines; y++)
-        {
-            int start = y * lineBytes;
-            for (int x = 0; x < columns; x++)
-            {
-                int index = start + (x / 8);
-                int mask = 1 << (7 - (x % 8));
-                int value = data[index] & mask;
-                System.out.print(value != 0 ? 'X' : '_');
-            }
-            System.out.println();
-        }
-    }
-
-    /**
-     * Converts a series of bytes to a "binary" String of 0s and 1s.
-     * @param data the data
-     * @return the binary string
-     */
-    protected String toBitString(byte[] data)
-    {
-        return PackedBitArray.toBitString(data);
-    }
-
-}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/TestCCITTFaxG31DDecodeInputStream.java b/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/TestCCITTFaxG31DDecodeInputStream.java
deleted file mode 100644
index 509084ee23..0000000000
--- a/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/TestCCITTFaxG31DDecodeInputStream.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* $Id$ */
-
-package org.apache.pdfbox.filter.ccitt;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-
-import org.apache.pdfbox.io.IOUtils;
-
-/**
- * Tests the CCITT Fax G3 1D decoder.
- */
-public class TestCCITTFaxG31DDecodeInputStream extends AbstractCCITTFaxTestCase
-{
-
-    private static final boolean DEBUG = false;
-
-    private static final String EOL = "000000000001";
-    private static final String RTC = EOL + EOL + EOL + EOL + EOL + EOL;
-
-    /**
-     * Tests the decoder with naked bits (no EOL, no alignment, nothing).
-     * @throws IOException if an I/O error occurs
-     */
-    public void testDecoderNaked() throws IOException
-    {
-        //Test data: 24x3 pixels encoded
-        byte[] data = fromBinary("10011" + "000101" + "10011"
-                    + "00110101" + "011" + "10011" + "0000111"
-                    + "00110101" + "010" + "000111" + "010" + "0010111" + "000000");
-        assertStandardDecodingResult(data);
-    }
-
-    /**
-     * Tests the decoder with EOLs.
-     * @throws IOException if an I/O error occurs
-     */
-    public void testDecoderWithEOL() throws IOException
-    {
-        //Test data: 24x3 pixels encoded
-        byte[] data = fromBinary("10011" + "000101" + "10011" + EOL
-                    + "00110101" + "011" + "10011" + "0000111" + EOL
-                    + "00110101" + "010" + "000111" + "010" + "0010111" + "000000" + EOL);
-        assertStandardDecodingResult(data);
-    }
-
-    /**
-     * Tests the decoder with RTC and byte alignment.
-     * @throws IOException if an I/O error occurs
-     */
-    public void testDecoderAlignedWithRTC() throws IOException
-    {
-        //Test data: 24x3 pixels encoded
-        byte[] data = fromBinary("1001100010110011" + EOL
-                               + "00110101011100110000111" + "0" + EOL
-                               + "001101010100001110100010111000000" + "00000" + RTC);
-        assertStandardDecodingResult(data);
-    }
-
-    /**
-     * Tests the decoder with an initial EOL.
-     * @throws IOException if an I/O error occurs
-     */
-    public void testDecoderInitialEOL() throws IOException
-    {
-        //Test data: 24x3 pixels encoded
-        byte[] data = fromBinary("000" + EOL + "1001100010110011" + EOL
-                               + "00110101011100110000111" + EOL
-                               + "001101010100001110100010111000000");
-        assertStandardDecodingResult(data);
-    }
-
-    private void assertStandardDecodingResult(byte[] data) throws IOException
-    {
-        int columns = 24;
-
-        byte[] decoded = decode(data, columns);
-
-        if (DEBUG)
-        {
-            dumpBitmap(decoded, columns);
-            System.out.println(PackedBitArray.toBitString(decoded));
-        }
-
-        assertEquals(9, decoded.length);
-        assertEquals("000000001111111100000000"
-                   + "111100000000111111111111"
-                   + "101000000000000000000000", toBitString(decoded));
-    }
-
-    /**
-     * Tests the decoder with a restriction in the number of rows.
-     * @throws IOException if an I/O error occurs
-     */
-    public void testDecoderRowsRestriction() throws IOException
-    {
-        //Test data: 24x3 pixels encoded
-        byte[] data = fromBinary("10011" + "000101" + "10011"
-                    + "00110101" + "011" + "10011" + "0000111"
-                    + "00110101" + "010" + "000111" + "010" + "0010111" + "000000");
-        int columns = 24;
-        int rows = 2; //We actually have data for three rows. Just checking the restriction.
-
-        CCITTFaxG31DDecodeInputStream decoder = new CCITTFaxG31DDecodeInputStream(
-                new ByteArrayInputStream(data), columns, rows, false);
-        byte[] decoded = IOUtils.toByteArray(decoder);
-        decoder.close();
-
-        if (DEBUG)
-        {
-            dumpBitmap(decoded, columns);
-            System.out.println(PackedBitArray.toBitString(decoded));
-        }
-
-        assertEquals(6, decoded.length);
-        assertEquals("000000001111111100000000"
-                   + "111100000000111111111111", toBitString(decoded));
-    }
-
-    /**
-     * Tests the decoder with white lines.
-     * @throws IOException if an I/O error occurs
-     */
-    public void testDecoderWhiteLines() throws IOException
-    {
-        //Test data: 1728x3 pixels encoded (all white)
-        byte[] data = fromBinary(EOL + "010011011" + "00110101" //EOL + w1728 (make-up) + w0
-                               + EOL + "010011011" + "00110101"
-                               + EOL + "010011011" + "00110101" + RTC);
-        int columns = 1728;
-
-        byte[] decoded = decode(data, columns);
-
-        if (DEBUG)
-        {
-            dumpBitmap(decoded, columns);
-        }
-
-        assertEquals(columns * 3 / 8, decoded.length);
-    }
-
-    /**
-     * Decodes a byte buffer.
-     * @param data the data
-     * @param columns the number of columns
-     * @return the decoded bits/pixels
-     * @throws IOException if an I/O error occurs
-     */
-    public static byte[] decode(byte[] data, int columns) throws IOException
-    {
-        CCITTFaxG31DDecodeInputStream decoder = new CCITTFaxG31DDecodeInputStream(
-                new ByteArrayInputStream(data), columns, false);
-        byte[] decoded = IOUtils.toByteArray(decoder);
-        decoder.close();
-        return decoded;
-    }
-
-    private byte[] fromBinary(String binary)
-    {
-        ByteArrayOutputStream baout = new ByteArrayOutputStream();
-        int pos = 0;
-        while (pos < binary.length() - 8)
-        {
-            int v = Integer.parseInt(binary.substring(pos, pos + 8), 2);
-            baout.write(v & 0xFF);
-            pos += 8;
-        }
-        int rest = binary.length() - pos;
-        if (rest > 0)
-        {
-            String f = binary.substring(pos) + "00000000".substring(rest);
-            baout.write(Integer.parseInt(f, 2));
-        }
-        return baout.toByteArray();
-    }
-
-}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/TestPackedBitArray.java b/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/TestPackedBitArray.java
deleted file mode 100644
index 5265bf6724..0000000000
--- a/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/TestPackedBitArray.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* $Id$ */
-
-package org.apache.pdfbox.filter.ccitt;
-
-import junit.framework.TestCase;
-
-/**
- * This is a unit test for {@link PackedBitArray}.
- */
-public class TestPackedBitArray extends TestCase
-{
-
-    /**
-     * Tests the {@link PackedBitArray} class.
-     */
-    public void testPackedBitArray()
-    {
-        PackedBitArray bits = new PackedBitArray(19);
-        assertEquals(19, bits.getBitCount());
-        assertEquals(3, bits.getByteCount());
-        assertEquals("0000000000000000000", bits.toString());
-
-        bits.set(1);
-        assertEquals("0100000000000000000", bits.toString());
-
-        bits.clear(1);
-        assertEquals("0000000000000000000", bits.toString());
-
-        bits.setBits(4, 4);
-        assertEquals("0000111100000000000", bits.toString());
-
-        bits.setBits(2, 1);
-        assertEquals("0010111100000000000", bits.toString());
-
-        bits.setBits(9, 9, 1);
-        assertEquals("0010111101111111110", bits.toString());
-
-        bits.clearBits(15, 2);
-        assertEquals("0010111101111110010", bits.toString());
-
-        bits.setBits(9, 9, 0);
-        assertEquals("0010111100000000000", bits.toString());
-
-        bits.clear();
-        assertEquals("0000000000000000000", bits.toString());
-
-        bits.setBits(1, 18);
-        assertEquals("0111111111111111111", bits.toString());
-
-        bits.clearBits(3, 1);
-        assertEquals("0110111111111111111", bits.toString());
-
-        try
-        {
-            bits.setBits(1, 19);
-            fail("Expecting IndexOutOfBoundsException");
-        }
-        catch (IndexOutOfBoundsException e)
-        {
-            //good
-        }
-    }
-
-}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/package.html b/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/package.html
deleted file mode 100644
index 975173e46e..0000000000
--- a/pdfbox/src/test/java/org/apache/pdfbox/filter/ccitt/package.html
+++ /dev/null
@@ -1,25 +0,0 @@
-<!--
- ! Licensed to the Apache Software Foundation (ASF) under one or more
- ! contributor license agreements.  See the NOTICE file distributed with
- ! this work for additional information regarding copyright ownership.
- ! The ASF licenses this file to You under the Apache License, Version 2.0
- ! (the "License"); you may not use this file except in compliance with
- ! the License.  You may obtain a copy of the License at
- !
- !      http://www.apache.org/licenses/LICENSE-2.0
- !
- ! Unless required by applicable law or agreed to in writing, software
- ! distributed under the License is distributed on an "AS IS" BASIS,
- ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ! See the License for the specific language governing permissions and
- ! limitations under the License.
- !-->
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<html>
-<head>
-
-</head>
-<body>
-This package contains classes testing the CCITT encoders and decoders.
-</body>
-</html>
