diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDMeshBasedShadingType.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDMeshBasedShadingType.java
index 8badfcc4f7..b65a030e37 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDMeshBasedShadingType.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDMeshBasedShadingType.java
@@ -175,7 +175,8 @@ abstract class PDMeshBasedShadingType extends PDShadingType4
     {
         float[][] color = new float[4][getNumberOfColorComponents()];
         Point2D[] points = new Point2D[controlPoints];
-        int pStart = 4, cStart = 2;
+        int pStart = 4;
+        int cStart = 2;
         if (isFree)
         {
             pStart = 0;
@@ -236,7 +237,7 @@ abstract class PDMeshBasedShadingType extends PDShadingType4
     abstract Patch generatePatch(Point2D[] points, float[][] color);
 
     @Override
-    abstract public Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException;
+    public abstract Rectangle2D getBounds(AffineTransform xform, Matrix matrix) throws IOException;
 
     Rectangle2D getBounds(AffineTransform xform, Matrix matrix, int controlPoints)
             throws IOException
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType4.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType4.java
index 58303da44b..38a3cfeec2 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType4.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingType4.java
@@ -129,7 +129,9 @@ public class PDShadingType4 extends PDTriangleBasedShadingType
             boolean eof = false;
             while (!eof)
             {
-                Vertex p0, p1, p2;
+                Vertex p0;
+                Vertex p1;
+                Vertex p2;
                 Point2D[] ps;
                 float[][] cs;
                 int lastIndex;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDTriangleBasedShadingType.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDTriangleBasedShadingType.java
index 64f34f1aa5..7d922352b5 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDTriangleBasedShadingType.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDTriangleBasedShadingType.java
@@ -41,7 +41,7 @@ abstract class PDTriangleBasedShadingType extends PDShading
     // value: same as the value of Range
     private COSArray decode = null;
 
-    private static final Log LOG = LogFactory.getLog(TriangleBasedShadingContext.class);
+    private static final Log LOG = LogFactory.getLog(PDTriangleBasedShadingType.class);
 
     private int bitsPerCoordinate = -1;
     private int bitsPerColorComponent = -1;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TriangleBasedShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TriangleBasedShadingContext.java
index e85bac20f7..ffaed711fc 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TriangleBasedShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TriangleBasedShadingContext.java
@@ -25,8 +25,7 @@ import java.awt.image.WritableRaster;
 import java.io.IOException;
 import java.util.List;
 import java.util.Map;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+
 import org.apache.pdfbox.util.Matrix;
 
 /**
@@ -95,6 +94,111 @@ abstract class TriangleBasedShadingContext extends ShadingContext implements Pai
                 boundary[1] = Math.min(boundary[1], deviceBounds.x + deviceBounds.width);
                 boundary[2] = Math.max(boundary[2], deviceBounds.y);
                 boundary[3] = Math.min(boundary[3], deviceBounds.y + deviceBounds.height);
+
+//                // https://github.com/mozilla/pdf.js/blob/master/src/display/pattern_helper.js
+//                // drawTriangle
+//                // Very basic Gouraud-shaded triangle rasterization algorithm.
+//                // rev 398e6ac Yury Delendik
+//                float x1 = (float) tri.corner[0].getX();
+//                float y1 = (float) tri.corner[0].getY();
+//                float x2 = (float) tri.corner[1].getX();
+//                float y2 = (float) tri.corner[1].getY();
+//                float x3 = (float) tri.corner[2].getX();
+//                float y3 = (float) tri.corner[2].getY();
+//                float tmpd;
+//                float[] tmpf;
+//                float[] c1 = tri.color[0];
+//                float[] c2 = tri.color[1];
+//                float[] c3 = tri.color[2];
+//                if (y1 > y2)
+//                {
+//                    tmpd = x1;
+//                    x1 = x2;
+//                    x2 = tmpd;
+//                    tmpd = y1;
+//                    y1 = y2;
+//                    y2 = tmpd;
+//                    tmpf = c1;
+//                    c1 = c2;
+//                    c2 = tmpf;
+//                }
+//                if (y2 > y3)
+//                {
+//                    tmpd = x2;
+//                    x2 = x3;
+//                    x3 = tmpd;
+//                    tmpd = y2;
+//                    y2 = y3;
+//                    y3 = tmpd;
+//                    tmpf = c2;
+//                    c2 = c3;
+//                    c3 = tmpf;
+//                }
+//                if (y1 > y2)
+//                {
+//                    tmpd = x1;
+//                    x1 = x2;
+//                    x2 = tmpd;
+//                    tmpd = y1;
+//                    y1 = y2;
+//                    y2 = tmpd;
+//                    tmpf = c1;
+//                    c1 = c2;
+//                    c2 = tmpf;
+//                }
+//                if (y1 >= y3)
+//                {
+//                    //TODO needed? we're in degree 3
+//                    continue;
+//                }
+//                
+//                float[] ca = new float[numberOfColorComponents];
+//                float[] cb = new float[numberOfColorComponents];
+//                float[] cres = new float[numberOfColorComponents];
+//                for (int y = boundary[2]; y <= boundary[3]; y++)
+//                {
+//                    float k, xa, xb;
+//                    if (y < y2)
+//                    {
+//                        k = y < y1 ? 0 : y1 == y2 ? 1 : (y1 - y) / (y1 - y2);
+//                        xa = x1 - (x1 - x2) * k;
+//                        for (int i = 0; i < numberOfColorComponents; i++)
+//                        {
+//                            ca[i] = c1[i] - (c1[i] - c2[i]) * k;
+//                        }
+//                    }
+//                    else
+//                    {
+//                        k = y > y3 ? 1 : y2 == y3 ? 0 : (y2 - y) / (y2 - y3);
+//                        xa = x2 - (x2 - x3) * k;
+//                        for (int i = 0; i < numberOfColorComponents; i++)
+//                        {
+//                            ca[i] = c2[i] - (c2[i] - c3[i]) * k;
+//                        }
+//                    }
+//                    k = (y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3));
+//                    xb = x1 - (x1 - x3) * k;
+//                    for (int i = 0; i < numberOfColorComponents; i++)
+//                    {
+//                        cb[i] = c1[i] - (c1[i] - c3[i]) * k;
+//                    }
+//                    int x1r = Math.round(Math.min(xa, xb));
+//                    int x2r = Math.round(Math.max(xa, xb));
+//                    x1r = Math.max(x1r, boundary[0]);
+//                    x2r = Math.min(x2r, boundary[1]);
+//                    float div = xa - xb;
+//                    for (int x = x1r; x <= x2r; ++x)
+//                    {
+//                        k = (xa - x) / div;
+//                        k = k < 0 ? 0 : k > 1 ? 1 : k;
+//                        for (int i = 0; i < numberOfColorComponents; i++)
+//                        {
+//                            cres[i] = ca[i] - (ca[i] - cb[i]) * k;
+//                        }
+//                        map.put(new IntPoint(x, y), evalFunctionAndConvertToRGB(cres));
+//                    }
+//                }                
+                
                 for (int x = boundary[0]; x <= boundary[1]; x++)
                 {
                     for (int y = boundary[2]; y <= boundary[3]; y++)
