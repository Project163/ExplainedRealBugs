diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendComposite.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendComposite.java
index fa83c2a920..8c1c45cec0 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendComposite.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendComposite.java
@@ -64,7 +64,7 @@ public final class BlendComposite implements Composite
         {
             throw new IllegalArgumentException("blendMode parameter cannot be null");
         }
-        if (blendMode == SeparableBlendMode.NORMAL)
+        if (blendMode == BlendMode.NORMAL)
         {
             return AlphaComposite.getInstance(AlphaComposite.SRC_OVER, constantAlpha);
         }
@@ -135,12 +135,7 @@ public final class BlendComposite implements Composite
             boolean subtractive = (dstColorSpaceType != ColorSpace.TYPE_RGB)
                     && (dstColorSpaceType != ColorSpace.TYPE_GRAY);
 
-            boolean blendModeIsSeparable = blendMode instanceof SeparableBlendMode;
-            SeparableBlendMode separableBlendMode = blendModeIsSeparable ?
-                    (SeparableBlendMode) blendMode : null;
-            NonSeparableBlendMode nonSeparableBlendMode = !blendModeIsSeparable ?
-                    (NonSeparableBlendMode) blendMode : null;
-
+            boolean blendModeIsSeparable = blendMode.isSeparableBlendMode();
             boolean needsColorConversion = !srcColorSpace.equals(dstColorSpace);
 
             Object srcPixel = null;
@@ -175,7 +170,7 @@ public final class BlendComposite implements Composite
                     float resultAlpha = dstAlpha + srcAlpha - srcAlpha * dstAlpha;
                     float srcAlphaRatio = (resultAlpha > 0) ? srcAlpha / resultAlpha : 0;
 
-                    if (separableBlendMode != null)
+                    if (blendModeIsSeparable)
                     {
                         // convert color
                         System.arraycopy(srcComponents, 0, srcColor, 0, numSrcColorComponents);
@@ -201,7 +196,8 @@ public final class BlendComposite implements Composite
                                 dstValue = 1 - dstValue;
                             }
 
-                            float value = separableBlendMode.blendChannel(srcValue, dstValue);
+                            float value = blendMode.getBlendChannelFunction().blendChannel(srcValue,
+                                    dstValue);
                             value = srcValue + dstAlpha * (value - srcValue);
                             value = dstValue + srcAlphaRatio * (value - dstValue);
 
@@ -236,7 +232,7 @@ public final class BlendComposite implements Composite
                             dstConverted = dstColorSpace.toRGB(dstComponents);
                         }
                         
-                        nonSeparableBlendMode.blend(srcConverted, dstConverted, rgbResult);
+                        blendMode.getBlendFunction().blend(srcConverted, dstConverted, rgbResult);
 
                         for (int k = 0; k < 3; k++)
                         {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendMode.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendMode.java
index 1ddf7b9763..c00e86d6b7 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendMode.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendMode.java
@@ -16,6 +16,9 @@
  */
 package org.apache.pdfbox.pdmodel.graphics.blend;
 
+import java.util.HashMap;
+import java.util.Map;
+
 import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSName;
@@ -25,31 +28,185 @@ import org.apache.pdfbox.cos.COSName;
  *
  * @author Kühn &amp; Weyh Software GmbH
  */
-public abstract class BlendMode
+public class BlendMode
 {
-	// Separable blend modes
-	public static final BlendMode NORMAL = SeparableBlendMode.NORMAL;
-	public static final BlendMode COMPATIBLE = SeparableBlendMode.NORMAL;
-	public static final BlendMode MULTIPLY = SeparableBlendMode.MULTIPLY;
-	public static final BlendMode SCREEN = SeparableBlendMode.SCREEN;
-	public static final BlendMode OVERLAY = SeparableBlendMode.OVERLAY;
-	public static final BlendMode DARKEN = SeparableBlendMode.DARKEN;
-	public static final BlendMode LIGHTEN = SeparableBlendMode.LIGHTEN;
-	public static final BlendMode COLOR_DODGE = SeparableBlendMode.COLOR_DODGE;
-	public static final BlendMode COLOR_BURN = SeparableBlendMode.COLOR_BURN;
-	public static final BlendMode HARD_LIGHT = SeparableBlendMode.HARD_LIGHT;
-	public static final BlendMode SOFT_LIGHT = SeparableBlendMode.SOFT_LIGHT;
-	public static final BlendMode DIFFERENCE = SeparableBlendMode.DIFFERENCE;
-	public static final BlendMode EXCLUSION = SeparableBlendMode.EXCLUSION;
+    @FunctionalInterface
+    public interface BlendChannelFunction
+    {
+        /**
+         * BlendChannel function for separable blend modes.
+         *
+         * @param src the source value
+         * @param dest the destination value
+         * @return the function result
+         */
+        float blendChannel(float src, float dest);
+    }
+
+    @FunctionalInterface
+    public interface BlendFunction
+    {
+        /**
+         * Blend function for non separable blend modes.
+         *
+         * @param src the source values
+         * @param dest the destination values
+         * @param the function result values
+         */
+        void blend(float[] src, float[] dest, float[] result);
+    }
+
+    private static BlendChannelFunction normal = (src, dest) -> {
+        return src;
+    };
+
+    private static BlendChannelFunction multiply = (src, dest) -> {
+        return src * dest;
+    };
+
+    private static BlendChannelFunction screen = (src, dest) -> {
+        return src + dest - src * dest;
+    };
+
+    private static BlendChannelFunction overlay = (src, dest) -> {
+        return (dest <= 0.5) ? 2 * dest * src : 2 * (src + dest - src * dest) - 1;
+    };
+
+    private static BlendChannelFunction darken = (src, dest) -> {
+        return Math.min(src, dest);
+    };
+
+    private static BlendChannelFunction lighten = (src, dest) -> {
+        return Math.max(src, dest);
+    };
+
+    private static BlendChannelFunction colorDodge = (src, dest) -> {
+        // See PDF 2.0 specification
+        if (Float.compare(dest, 0) == 0)
+        {
+            return 0f;
+        }
+        if (dest >= 1 - src)
+        {
+            return 1f;
+        }
+        return dest / (1 - src);
+    };
+
+    private static BlendChannelFunction colorBurn = (src, dest) -> {
+        // See PDF 2.0 specification
+        if (Float.compare(dest, 1) == 0)
+        {
+            return 1f;
+        }
+        if (1 - dest >= src)
+        {
+            return 0f;
+        }
+        return 1 - (1 - dest) / src;
+    };
+
+    private static BlendChannelFunction hardLight = (src, dest) -> {
+        return (src <= 0.5) ? 2 * dest * src : 2 * (src + dest - src * dest) - 1;
+    };
+
+    private static BlendChannelFunction softLight = (src, dest) -> {
+        if (src <= 0.5)
+        {
+            return dest - (1 - 2 * src) * dest * (1 - dest);
+        }
+        else
+        {
+            float d = (dest <= 0.25) ? ((16 * dest - 12) * dest + 4) * dest
+                    : (float) Math.sqrt(dest);
+            return dest + (2 * src - 1) * (d - dest);
+        }
+    };
+
+    private static BlendChannelFunction difference = (src, dest) -> {
+        return Math.abs(dest - src);
+    };
+
+    private static BlendChannelFunction exclusion = (src, dest) -> {
+        return dest + src - 2 * dest * src;
+    };
+
+    private static BlendFunction hue = (src, dest, result) -> {
+        float[] temp = new float[3];
+        getSaturationRGB(dest, src, temp);
+        getLuminosityRGB(dest, temp, result);
+    };
+
+    private static BlendFunction saturation = (src, dest, result) -> {
+        getSaturationRGB(src, dest, result);
+    };
+
+    private static BlendFunction color = (src, dest, result) -> {
+        getLuminosityRGB(dest, src, result);
+    };
+
+    private static BlendFunction luminosity = (src, dest, result) -> {
+        getLuminosityRGB(src, dest, result);
+    };
+
+    // Separable blend modes
+	public static final BlendMode NORMAL = new BlendMode(COSName.NORMAL, normal, null);
+	public static final BlendMode COMPATIBLE = BlendMode.NORMAL;
+	public static final BlendMode MULTIPLY = new BlendMode(COSName.MULTIPLY, multiply, null);
+	public static final BlendMode SCREEN = new BlendMode(COSName.SCREEN, screen, null);
+	public static final BlendMode OVERLAY = new BlendMode(COSName.OVERLAY, overlay, null);
+	public static final BlendMode DARKEN = new BlendMode(COSName.DARKEN, darken, null);
+	public static final BlendMode LIGHTEN =new BlendMode(COSName.LIGHTEN, lighten, null);
+	public static final BlendMode COLOR_DODGE = new BlendMode(COSName.COLOR_DODGE, colorDodge, null);
+	public static final BlendMode COLOR_BURN = new BlendMode(COSName.COLOR_BURN, colorBurn, null);
+	public static final BlendMode HARD_LIGHT = new BlendMode(COSName.HARD_LIGHT, hardLight, null);
+	public static final BlendMode SOFT_LIGHT = new BlendMode(COSName.SOFT_LIGHT, softLight, null);
+	public static final BlendMode DIFFERENCE = new BlendMode(COSName.DIFFERENCE, difference, null);
+	public static final BlendMode EXCLUSION = new BlendMode(COSName.EXCLUSION, exclusion, null);
 
 	// non-separable blend modes
-	public static final BlendMode HUE = NonSeparableBlendMode.HUE;
-	public static final BlendMode SATURATION = NonSeparableBlendMode.SATURATION;
-	public static final BlendMode COLOR = NonSeparableBlendMode.COLOR;
-	public static final BlendMode LUMINOSITY = NonSeparableBlendMode.LUMINOSITY;
+    public static final BlendMode HUE = new BlendMode(COSName.HUE, null, hue);
+    public static final BlendMode SATURATION = new BlendMode(COSName.SATURATION, null, saturation);
+    public static final BlendMode COLOR = new BlendMode(COSName.COLOR, null, color);
+    public static final BlendMode LUMINOSITY = new BlendMode(COSName.LUMINOSITY, null, luminosity);
+
+    private static final Map<COSName, BlendMode> BLEND_MODES = createBlendModeMap();
+
+    private static Map<COSName, BlendMode> createBlendModeMap()
+    {
+        Map<COSName, BlendMode> map = new HashMap<>(13);
+        map.put(COSName.NORMAL, NORMAL);
+        // BlendMode.COMPATIBLE should not be used
+        map.put(COSName.COMPATIBLE, NORMAL);
+        map.put(COSName.MULTIPLY, MULTIPLY);
+        map.put(COSName.SCREEN, SCREEN);
+        map.put(COSName.OVERLAY, OVERLAY);
+        map.put(COSName.DARKEN, DARKEN);
+        map.put(COSName.LIGHTEN, LIGHTEN);
+        map.put(COSName.COLOR_DODGE, COLOR_DODGE);
+        map.put(COSName.COLOR_BURN, COLOR_BURN);
+        map.put(COSName.HARD_LIGHT, HARD_LIGHT);
+        map.put(COSName.SOFT_LIGHT, SOFT_LIGHT);
+        map.put(COSName.DIFFERENCE, DIFFERENCE);
+        map.put(COSName.EXCLUSION, EXCLUSION);
+        map.put(COSName.HUE, HUE);
+        map.put(COSName.SATURATION, SATURATION);
+        map.put(COSName.LUMINOSITY, LUMINOSITY);
+        map.put(COSName.COLOR, COLOR);
+        return map;
+    }
+
+    private final COSName name;
+    private final BlendChannelFunction blendChannel;
+    private final BlendFunction blend;
+    private final boolean isSeparable;
 
-    BlendMode()
+    private BlendMode(COSName name, BlendChannelFunction blendChannel, BlendFunction blend)
     {
+    	this.name = name;
+    	this.blendChannel = blendChannel;
+        this.blend = blend;
+        isSeparable = blendChannel != null;
     }
 
     /**
@@ -57,9 +214,41 @@ public abstract class BlendMode
      *
      * @return name of blend mode.
      */
-    public abstract COSName getCOSName();
+    public COSName getCOSName()
+    {
+    	return name;
+    }
 
+    /**
+     * Determines if the blend mode is a separable blend mode.
+     * 
+     * @return true for separable blend modes
+     */
+    public boolean isSeparableBlendMode()
+    {
+        return isSeparable;
+    }
     
+    /**
+     * Returns the blend channel function, only available for separable blend modes.
+     * 
+     * @return the blend channel function
+     */
+    public BlendChannelFunction getBlendChannelFunction()
+    {
+        return blendChannel;
+    }
+
+    /**
+     * Returns the blend function, only available for non separable blend modes.
+     * 
+     * @return the blend function
+     */
+    public BlendFunction getBlendFunction()
+    {
+        return blend;
+    }
+
     /**
      * Determines the blend mode from the BM entry in the COS ExtGState.
      *
@@ -71,7 +260,7 @@ public abstract class BlendMode
         BlendMode result = null;
         if (cosBlendMode instanceof COSName)
         {
-            result = getBlendMode((COSName)cosBlendMode);
+            result = BLEND_MODES.get((COSName) cosBlendMode);
         }
         else if (cosBlendMode instanceof COSArray)
         {
@@ -81,7 +270,7 @@ public abstract class BlendMode
             	COSBase cosBase = cosBlendModeArray.getObject(i);
             	if (cosBase instanceof COSName)
             	{
-	                result = getBlendMode((COSName)cosBase);
+                    result = BLEND_MODES.get((COSName) cosBase);
 	                if (result != null)
 	                {
 	                    break;
@@ -89,16 +278,115 @@ public abstract class BlendMode
             	}
             }
         }
-        return result != null ? result : SeparableBlendMode.NORMAL;
+        return result != null ? result : BlendMode.NORMAL;
     }
-    
-    private static BlendMode getBlendMode(COSName cosBlendMode)
+
+    private static int get255Value(float val)
+    {
+        return (int) Math.floor(val >= 1.0 ? 255 : val * 255.0);
+    }
+
+    private static void getSaturationRGB(float[] srcValues, float[] dstValues, float[] result)
     {
-    	BlendMode result = SeparableBlendMode.getBlendMode((COSName)cosBlendMode);
-        if (result == null)
+        int rd = get255Value(dstValues[0]);
+        int gd = get255Value(dstValues[1]);
+        int bd = get255Value(dstValues[2]);
+        int rs = get255Value(srcValues[0]);
+        int gs = get255Value(srcValues[1]);
+        int bs = get255Value(srcValues[2]);
+
+        int minb = Math.min(rd, Math.min(gd, bd));
+        int maxb = Math.max(rd, Math.max(gd, bd));
+        if (minb == maxb)
         {
-            result = NonSeparableBlendMode.getBlendMode((COSName)cosBlendMode);
+            /* backdrop has zero saturation, avoid divide by 0 */
+            result[0] = gd / 255.0f;
+            result[1] = gd / 255.0f;
+            result[2] = gd / 255.0f;
+            return;
         }
-    	return result;
+
+        int mins = Math.min(rs, Math.min(gs, bs));
+        int maxs = Math.max(rs, Math.max(gs, bs));
+
+        int scale = ((maxs - mins) << 16) / (maxb - minb);
+        int y = (rd * 77 + gd * 151 + bd * 28 + 0x80) >> 8;
+        int r = y + ((((rd - y) * scale) + 0x8000) >> 16);
+        int g = y + ((((gd - y) * scale) + 0x8000) >> 16);
+        int b = y + ((((bd - y) * scale) + 0x8000) >> 16);
+
+        if (((r | g | b) & 0x100) == 0x100)
+        {
+            int scalemin;
+            int scalemax;
+
+            int min = Math.min(r, Math.min(g, b));
+            int max = Math.max(r, Math.max(g, b));
+
+            if (min < 0)
+            {
+                scalemin = (y << 16) / (y - min);
+            }
+            else
+            {
+                scalemin = 0x10000;
+            }
+
+            if (max > 255)
+            {
+                scalemax = ((255 - y) << 16) / (max - y);
+            }
+            else
+            {
+                scalemax = 0x10000;
+            }
+
+            scale = Math.min(scalemin, scalemax);
+            r = y + (((r - y) * scale + 0x8000) >> 16);
+            g = y + (((g - y) * scale + 0x8000) >> 16);
+            b = y + (((b - y) * scale + 0x8000) >> 16);
+        }
+        result[0] = r / 255.0f;
+        result[1] = g / 255.0f;
+        result[2] = b / 255.0f;
     }
+
+    private static void getLuminosityRGB(float[] srcValues, float[] dstValues, float[] result)
+    {
+        int rd = get255Value(dstValues[0]);
+        int gd = get255Value(dstValues[1]);
+        int bd = get255Value(dstValues[2]);
+        int rs = get255Value(srcValues[0]);
+        int gs = get255Value(srcValues[1]);
+        int bs = get255Value(srcValues[2]);
+        int delta = ((rs - rd) * 77 + (gs - gd) * 151 + (bs - bd) * 28 + 0x80) >> 8;
+        int r = rd + delta;
+        int g = gd + delta;
+        int b = bd + delta;
+
+        if (((r | g | b) & 0x100) == 0x100)
+        {
+            int scale;
+            int y = (rs * 77 + gs * 151 + bs * 28 + 0x80) >> 8;
+            if (delta > 0)
+            {
+                int max;
+                max = Math.max(r, Math.max(g, b));
+                scale = max == y ? 0 : ((255 - y) << 16) / (max - y);
+            }
+            else
+            {
+                int min;
+                min = Math.min(r, Math.min(g, b));
+                scale = y == min ? 0 : (y << 16) / (y - min);
+            }
+            r = y + (((r - y) * scale + 0x8000) >> 16);
+            g = y + (((g - y) * scale + 0x8000) >> 16);
+            b = y + (((b - y) * scale + 0x8000) >> 16);
+        }
+        result[0] = r / 255.0f;
+        result[1] = g / 255.0f;
+        result[2] = b / 255.0f;
+    }
+
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/NonSeparableBlendMode.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/NonSeparableBlendMode.java
deleted file mode 100644
index 231c2fb103..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/NonSeparableBlendMode.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.pdmodel.graphics.blend;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.pdfbox.cos.COSName;
-
-/**
- * Non-separable blend mode (supports blend function).
- *
- * @author Kühn &amp; Weyh Software GmbH
- */
-public abstract class NonSeparableBlendMode extends BlendMode
-{
-
-    public static final NonSeparableBlendMode HUE = new NonSeparableBlendMode()
-    {
-        @Override
-        public void blend(float[] srcValues, float[] dstValues, float[] result)
-        {
-            float[] temp = new float[3];
-            getSaturationRGB(dstValues, srcValues, temp);
-            getLuminosityRGB(dstValues, temp, result);
-        }
-        
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.HUE;
-        }
-    };
-
-    public static final NonSeparableBlendMode SATURATION = new NonSeparableBlendMode()
-    {
-        @Override
-        public void blend(float[] srcValues, float[] dstValues, float[] result)
-        {
-            getSaturationRGB(srcValues, dstValues, result);
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.SATURATION;
-        }
-    };
-
-    public static final NonSeparableBlendMode COLOR = new NonSeparableBlendMode()
-    {
-        @Override
-        public void blend(float[] srcValues, float[] dstValues, float[] result)
-        {
-            getLuminosityRGB(dstValues, srcValues, result);
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.COLOR;
-        }
-    };
-
-    public static final NonSeparableBlendMode LUMINOSITY = new NonSeparableBlendMode()
-    {
-        @Override
-        public void blend(float[] srcValues, float[] dstValues, float[] result)
-        {
-            getLuminosityRGB(srcValues, dstValues, result);
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.LUMINOSITY;
-        }
-    };
-
-    private static Map<COSName, BlendMode> createBlendModeMap()
-    {
-        Map<COSName, BlendMode> map = new HashMap<>(4);
-        map.put(COSName.HUE, HUE);
-        map.put(COSName.SATURATION, SATURATION);
-        map.put(COSName.LUMINOSITY, LUMINOSITY);
-        map.put(COSName.COLOR, COLOR);
-        return map;
-    }
-
-    private static final Map<COSName, BlendMode> BLEND_MODES = createBlendModeMap();
-
-    protected static final BlendMode getBlendMode(COSName cosBlendMode)
-    {
-    	return BLEND_MODES.get(cosBlendMode);
-    }
-
-    NonSeparableBlendMode()
-    {
-    }
-
-    public abstract void blend(float[] srcValues, float[] dstValues, float[] result);
-    
-    private static int get255Value(float val)
-    {
-        return (int) Math.floor(val >= 1.0 ? 255 : val * 255.0);
-    }
-
-    private static void getSaturationRGB(float[] srcValues, float[] dstValues, float[] result)
-    {
-        int rd = get255Value(dstValues[0]);
-        int gd = get255Value(dstValues[1]);
-        int bd = get255Value(dstValues[2]);
-        int rs = get255Value(srcValues[0]);
-        int gs = get255Value(srcValues[1]);
-        int bs = get255Value(srcValues[2]);
-
-        int minb = Math.min(rd, Math.min(gd, bd));
-        int maxb = Math.max(rd, Math.max(gd, bd));
-        if (minb == maxb)
-        {
-            /* backdrop has zero saturation, avoid divide by 0 */
-            result[0] = gd / 255.0f;
-            result[1] = gd / 255.0f;
-            result[2] = gd / 255.0f;
-            return;
-        }
-
-        int mins = Math.min(rs, Math.min(gs, bs));
-        int maxs = Math.max(rs, Math.max(gs, bs));
-
-        int scale = ((maxs - mins) << 16) / (maxb - minb);
-        int y = (rd * 77 + gd * 151 + bd * 28 + 0x80) >> 8;
-        int r = y + ((((rd - y) * scale) + 0x8000) >> 16);
-        int g = y + ((((gd - y) * scale) + 0x8000) >> 16);
-        int b = y + ((((bd - y) * scale) + 0x8000) >> 16);
-
-        if (((r | g | b) & 0x100) == 0x100)
-        {
-            int scalemin;
-            int scalemax;
-
-            int min = Math.min(r, Math.min(g, b));
-            int max = Math.max(r, Math.max(g, b));
-
-            if (min < 0)
-            {
-                scalemin = (y << 16) / (y - min);
-            }
-            else
-            {
-                scalemin = 0x10000;
-            }
-
-            if (max > 255)
-            {
-                scalemax = ((255 - y) << 16) / (max - y);
-            }
-            else
-            {
-                scalemax = 0x10000;
-            }
-
-            scale = Math.min(scalemin, scalemax);
-            r = y + (((r - y) * scale + 0x8000) >> 16);
-            g = y + (((g - y) * scale + 0x8000) >> 16);
-            b = y + (((b - y) * scale + 0x8000) >> 16);
-        }
-        result[0] = r / 255.0f;
-        result[1] = g / 255.0f;
-        result[2] = b / 255.0f;
-    }
-
-    private static void getLuminosityRGB(float[] srcValues, float[] dstValues, float[] result)
-    {
-        int rd = get255Value(dstValues[0]);
-        int gd = get255Value(dstValues[1]);
-        int bd = get255Value(dstValues[2]);
-        int rs = get255Value(srcValues[0]);
-        int gs = get255Value(srcValues[1]);
-        int bs = get255Value(srcValues[2]);
-        int delta = ((rs - rd) * 77 + (gs - gd) * 151 + (bs - bd) * 28 + 0x80) >> 8;
-        int r = rd + delta;
-        int g = gd + delta;
-        int b = bd + delta;
-
-        if (((r | g | b) & 0x100) == 0x100)
-        {
-            int scale;
-            int y = (rs * 77 + gs * 151 + bs * 28 + 0x80) >> 8;
-            if (delta > 0)
-            {
-                int max;
-                max = Math.max(r, Math.max(g, b));
-                scale = max == y ? 0 : ((255 - y) << 16) / (max - y);
-            }
-            else
-            {
-                int min;
-                min = Math.min(r, Math.min(g, b));
-                scale = y == min ? 0 : (y << 16) / (y - min);
-            }
-            r = y + (((r - y) * scale + 0x8000) >> 16);
-            g = y + (((g - y) * scale + 0x8000) >> 16);
-            b = y + (((b - y) * scale + 0x8000) >> 16);
-        }
-        result[0] = r / 255.0f;
-        result[1] = g / 255.0f;
-        result[2] = b / 255.0f;
-    }
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/SeparableBlendMode.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/SeparableBlendMode.java
deleted file mode 100644
index 74e708e979..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/blend/SeparableBlendMode.java
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.pdmodel.graphics.blend;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.pdfbox.cos.COSName;
-
-/**
- * Separable blend mode (support blendChannel)
- *
- * @author Kühn &amp; Weyh Software GmbH
- */
-public abstract class SeparableBlendMode extends BlendMode
-{
-	
-	public static final SeparableBlendMode NORMAL = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            return srcValue;
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.NORMAL;
-        }
-    };
-	
-    public static final SeparableBlendMode COMPATIBLE = NORMAL;
-
-    public static final SeparableBlendMode MULTIPLY = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            return srcValue * dstValue;
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.MULTIPLY;
-        }
-    };
-
-    public static final SeparableBlendMode SCREEN = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            return srcValue + dstValue - srcValue * dstValue;
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.SCREEN;
-        }
-    };
-
-    public static final SeparableBlendMode OVERLAY = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            return (dstValue <= 0.5) ? 2 * dstValue * srcValue : 2 * (srcValue + dstValue - srcValue
-                    * dstValue) - 1;
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.OVERLAY;
-        }
-    };
-
-    public static final SeparableBlendMode DARKEN = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            return Math.min(srcValue, dstValue);
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.DARKEN;
-        }
-    };
-
-    public static final SeparableBlendMode LIGHTEN = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            return Math.max(srcValue, dstValue);
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.LIGHTEN;
-        }
-    };
-
-    public static final SeparableBlendMode COLOR_DODGE = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            // See PDF 2.0 specification
-            if (Float.compare(dstValue,0) == 0)
-            {
-                return 0;
-            }
-            if (dstValue >= 1 - srcValue)
-            {
-                return 1;
-            }
-            return dstValue / (1 - srcValue);
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.COLOR_DODGE;
-        }
-    };
-
-    public static final SeparableBlendMode COLOR_BURN = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            // See PDF 2.0 specification
-            if (Float.compare(dstValue, 1) == 0)
-            {
-                return 1;
-            }
-            if (1 - dstValue >= srcValue)
-            {
-                return 0;
-            }
-            return 1 - (1 - dstValue) / srcValue;
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.COLOR_BURN;
-        }
-    };
-
-    public static final SeparableBlendMode HARD_LIGHT = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            return (srcValue <= 0.5) ? 2 * dstValue * srcValue :
-                    2 * (srcValue + dstValue - srcValue * dstValue) - 1;
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.HARD_LIGHT;
-        }
-    };
-
-    public static final SeparableBlendMode SOFT_LIGHT = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            if (srcValue <= 0.5)
-            {
-                return dstValue - (1 - 2 * srcValue) * dstValue * (1 - dstValue);
-            }
-            else
-            {
-                float d = (dstValue <= 0.25) ? ((16 * dstValue - 12) * dstValue + 4) * dstValue
-                        : (float) Math .sqrt(dstValue);
-                return dstValue + (2 * srcValue - 1) * (d - dstValue);
-            }
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.SOFT_LIGHT;
-        }
-    };
-
-    public static final SeparableBlendMode DIFFERENCE = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            return Math.abs(dstValue - srcValue);
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.DIFFERENCE;
-        }
-    };
-
-    public static final SeparableBlendMode EXCLUSION = new SeparableBlendMode()
-    {
-        @Override
-        public float blendChannel(float srcValue, float dstValue)
-        {
-            return dstValue + srcValue - 2 * dstValue * srcValue;
-        }
-
-        @Override
-        public COSName getCOSName() 
-        {
-        	return COSName.EXCLUSION;
-        }
-    };
-
-    private static final Map<COSName, BlendMode> BLEND_MODES = createBlendModeMap();
-
-    private static Map<COSName, BlendMode> createBlendModeMap()
-    {
-        Map<COSName, BlendMode> map = new HashMap<>(13);
-        map.put(COSName.NORMAL, NORMAL);
-        // BlendMode.COMPATIBLE should not be used
-        map.put(COSName.COMPATIBLE, NORMAL);
-        map.put(COSName.MULTIPLY, MULTIPLY);
-        map.put(COSName.SCREEN, SCREEN);
-        map.put(COSName.OVERLAY, OVERLAY);
-        map.put(COSName.DARKEN, DARKEN);
-        map.put(COSName.LIGHTEN, LIGHTEN);
-        map.put(COSName.COLOR_DODGE, COLOR_DODGE);
-        map.put(COSName.COLOR_BURN, COLOR_BURN);
-        map.put(COSName.HARD_LIGHT, HARD_LIGHT);
-        map.put(COSName.SOFT_LIGHT, SOFT_LIGHT);
-        map.put(COSName.DIFFERENCE, DIFFERENCE);
-        map.put(COSName.EXCLUSION, EXCLUSION);
-        return map;
-    }
-
-    protected static final BlendMode getBlendMode(COSName cosBlendMode)
-    {
-    	return BLEND_MODES.get(cosBlendMode);
-    }
-
-    SeparableBlendMode()
-    {
-    }
-
-    public abstract float blendChannel(float srcValue, float dstValue);
-}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendModeTest.java b/pdfbox/src/test/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendModeTest.java
index f703c6a332..f8a0a987b2 100644
--- a/pdfbox/src/test/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendModeTest.java
+++ b/pdfbox/src/test/java/org/apache/pdfbox/pdmodel/graphics/blend/BlendModeTest.java
@@ -29,54 +29,52 @@ class BlendModeTest
 {
 
     /**
-     * Check that BlendMode.* constant instances are not null. This could happen if the declaration
-     * sequence is changed.
+     * Check that BlendMode.* constant instances are not null.
      */
     @Test
     void testInstances()
     {
-        assertEquals(SeparableBlendMode.NORMAL, BlendMode.getInstance(COSName.NORMAL));
-        assertEquals(SeparableBlendMode.NORMAL, BlendMode.getInstance(COSName.COMPATIBLE));
-        assertEquals(SeparableBlendMode.MULTIPLY, BlendMode.getInstance(COSName.MULTIPLY));
-        assertEquals(SeparableBlendMode.SCREEN, BlendMode.getInstance(COSName.SCREEN));
-        assertEquals(SeparableBlendMode.OVERLAY, BlendMode.getInstance(COSName.OVERLAY));
-        assertEquals(SeparableBlendMode.DARKEN, BlendMode.getInstance(COSName.DARKEN));
-        assertEquals(SeparableBlendMode.LIGHTEN, BlendMode.getInstance(COSName.LIGHTEN));
-        assertEquals(SeparableBlendMode.COLOR_DODGE, BlendMode.getInstance(COSName.COLOR_DODGE));
-        assertEquals(SeparableBlendMode.COLOR_BURN, BlendMode.getInstance(COSName.COLOR_BURN));
-        assertEquals(SeparableBlendMode.HARD_LIGHT, BlendMode.getInstance(COSName.HARD_LIGHT));
-        assertEquals(SeparableBlendMode.SOFT_LIGHT, BlendMode.getInstance(COSName.SOFT_LIGHT));
-        assertEquals(SeparableBlendMode.DIFFERENCE, BlendMode.getInstance(COSName.DIFFERENCE));
-        assertEquals(SeparableBlendMode.EXCLUSION, BlendMode.getInstance(COSName.EXCLUSION));
-        assertEquals(NonSeparableBlendMode.HUE, BlendMode.getInstance(COSName.HUE));
-        assertEquals(NonSeparableBlendMode.SATURATION, BlendMode.getInstance(COSName.SATURATION));
-        assertEquals(NonSeparableBlendMode.LUMINOSITY, BlendMode.getInstance(COSName.LUMINOSITY));
-        assertEquals(NonSeparableBlendMode.COLOR, BlendMode.getInstance(COSName.COLOR));
+        assertEquals(BlendMode.NORMAL, BlendMode.getInstance(COSName.NORMAL));
+        assertEquals(BlendMode.NORMAL, BlendMode.getInstance(COSName.COMPATIBLE));
+        assertEquals(BlendMode.MULTIPLY, BlendMode.getInstance(COSName.MULTIPLY));
+        assertEquals(BlendMode.SCREEN, BlendMode.getInstance(COSName.SCREEN));
+        assertEquals(BlendMode.OVERLAY, BlendMode.getInstance(COSName.OVERLAY));
+        assertEquals(BlendMode.DARKEN, BlendMode.getInstance(COSName.DARKEN));
+        assertEquals(BlendMode.LIGHTEN, BlendMode.getInstance(COSName.LIGHTEN));
+        assertEquals(BlendMode.COLOR_DODGE, BlendMode.getInstance(COSName.COLOR_DODGE));
+        assertEquals(BlendMode.COLOR_BURN, BlendMode.getInstance(COSName.COLOR_BURN));
+        assertEquals(BlendMode.HARD_LIGHT, BlendMode.getInstance(COSName.HARD_LIGHT));
+        assertEquals(BlendMode.SOFT_LIGHT, BlendMode.getInstance(COSName.SOFT_LIGHT));
+        assertEquals(BlendMode.DIFFERENCE, BlendMode.getInstance(COSName.DIFFERENCE));
+        assertEquals(BlendMode.EXCLUSION, BlendMode.getInstance(COSName.EXCLUSION));
+        assertEquals(BlendMode.HUE, BlendMode.getInstance(COSName.HUE));
+        assertEquals(BlendMode.SATURATION, BlendMode.getInstance(COSName.SATURATION));
+        assertEquals(BlendMode.LUMINOSITY, BlendMode.getInstance(COSName.LUMINOSITY));
+        assertEquals(BlendMode.COLOR, BlendMode.getInstance(COSName.COLOR));
     }
 
     /**
-     * Check that COSName constants returned for BlendMode.* instances are not null. This could
-     * happen if the declaration sequence is changed.
+     * Check that COSName constants returned for BlendMode.* instances are not null.
      */
     @Test
     void testCOSNames()
     {
-        assertEquals(COSName.NORMAL, SeparableBlendMode.NORMAL.getCOSName());
-        assertEquals(COSName.NORMAL, SeparableBlendMode.COMPATIBLE.getCOSName());
-        assertEquals(COSName.MULTIPLY, SeparableBlendMode.MULTIPLY.getCOSName());
-        assertEquals(COSName.SCREEN, SeparableBlendMode.SCREEN.getCOSName());
-        assertEquals(COSName.OVERLAY, SeparableBlendMode.OVERLAY.getCOSName());
-        assertEquals(COSName.DARKEN, SeparableBlendMode.DARKEN.getCOSName());
-        assertEquals(COSName.LIGHTEN, SeparableBlendMode.LIGHTEN.getCOSName());
-        assertEquals(COSName.COLOR_DODGE, SeparableBlendMode.COLOR_DODGE.getCOSName());
-        assertEquals(COSName.COLOR_BURN, SeparableBlendMode.COLOR_BURN.getCOSName());
-        assertEquals(COSName.HARD_LIGHT, SeparableBlendMode.HARD_LIGHT.getCOSName());
-        assertEquals(COSName.SOFT_LIGHT, SeparableBlendMode.SOFT_LIGHT.getCOSName());
-        assertEquals(COSName.DIFFERENCE, SeparableBlendMode.DIFFERENCE.getCOSName());
-        assertEquals(COSName.EXCLUSION, SeparableBlendMode.EXCLUSION.getCOSName());
-        assertEquals(COSName.HUE, NonSeparableBlendMode.HUE.getCOSName());
-        assertEquals(COSName.SATURATION, NonSeparableBlendMode.SATURATION.getCOSName());
-        assertEquals(COSName.LUMINOSITY, NonSeparableBlendMode.LUMINOSITY.getCOSName());
-        assertEquals(COSName.COLOR, NonSeparableBlendMode.COLOR.getCOSName());
+        assertEquals(COSName.NORMAL, BlendMode.NORMAL.getCOSName());
+        assertEquals(COSName.NORMAL, BlendMode.COMPATIBLE.getCOSName());
+        assertEquals(COSName.MULTIPLY, BlendMode.MULTIPLY.getCOSName());
+        assertEquals(COSName.SCREEN, BlendMode.SCREEN.getCOSName());
+        assertEquals(COSName.OVERLAY, BlendMode.OVERLAY.getCOSName());
+        assertEquals(COSName.DARKEN, BlendMode.DARKEN.getCOSName());
+        assertEquals(COSName.LIGHTEN, BlendMode.LIGHTEN.getCOSName());
+        assertEquals(COSName.COLOR_DODGE, BlendMode.COLOR_DODGE.getCOSName());
+        assertEquals(COSName.COLOR_BURN, BlendMode.COLOR_BURN.getCOSName());
+        assertEquals(COSName.HARD_LIGHT, BlendMode.HARD_LIGHT.getCOSName());
+        assertEquals(COSName.SOFT_LIGHT, BlendMode.SOFT_LIGHT.getCOSName());
+        assertEquals(COSName.DIFFERENCE, BlendMode.DIFFERENCE.getCOSName());
+        assertEquals(COSName.EXCLUSION, BlendMode.EXCLUSION.getCOSName());
+        assertEquals(COSName.HUE, BlendMode.HUE.getCOSName());
+        assertEquals(COSName.SATURATION, BlendMode.SATURATION.getCOSName());
+        assertEquals(COSName.LUMINOSITY, BlendMode.LUMINOSITY.getCOSName());
+        assertEquals(COSName.COLOR, BlendMode.COLOR.getCOSName());
     }
 }
